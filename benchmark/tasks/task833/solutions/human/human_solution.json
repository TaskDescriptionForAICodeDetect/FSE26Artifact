[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define int long long\nusing namespace std;\nstruct node\n{\n\tint x,y,newy;\n\tbool operator < (const node &a)const\n\t{\n\t\tif (x!=a.x)\n\t\t\treturn x<a.x;\n\t\telse\n\t\t\treturn newy>a.newy;\n\t}\n};\nnode QQmove[10000001];\nint mod=1000000007;\nint f[10000001],c[10000001],a[10000001],b[10000001],ans,res=1,len,n,m,useless;\nbool cmp(node u,node v)\n{\n\treturn u.y<v.y;\n}\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\nvoid add(int x,int d)\n{\n\tfor (;x<=n;x+=lowbit(x))\n\t{\n\t\tc[x]+=d;\n\t\tc[x]%=mod;\n\t}\t\n\treturn;\n}\nint sum(int x)\n{\n\tans=0;\n\tfor (;x>=1;x-=lowbit(x))\n\t{\n\t\tans+=c[x];\n\t\tans%=mod;\n\t}\n\treturn ans;\n}\nsigned main()\n{\n\tint first,last,mid,front,back;\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;++i)\n\t\tcin>>a[i];\n\tfor (int i=1;i<=m;++i)\n\t\tcin>>b[i];\n\tsort(a+1,a+n+1);\n\tsort(b+1,b+n+1);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tfirst=1;\n\t\tlast=m;\n\t\tfront=0;\n\t\tback=m+1;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]>=b[mid])\n\t\t\t{\n\t\t\t\tfront=max(front,mid);\n\t\t\t\tfirst=mid+1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tlast=mid-1;\n\t\t}\n\t\tfirst=1;\n\t\tlast=m;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]<=b[mid])\n\t\t\t{\n\t\t\t\tback=min(back,mid);\n\t\t\t\tlast=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tfirst=mid+1;\n\t\t}\n\t\tif (front==0||back==m+1||b[front]==a[i]||b[back]==a[i])\n\t\t\tcontinue;\n\t\tQQmove[++len].x=a[i]-b[front];\n\t\tQQmove[len].y=b[back]-a[i];\n\t}\n\tsort(QQmove+1,QQmove+len+1,cmp);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tQQmove[i].newy=i-useless;\n\t\tif (QQmove[i].y==QQmove[i+1].y)\n\t\t\tuseless++;\n\t}\n\tsort(QQmove+1,QQmove+len+1);\n\tfor (int i=1;i<=len-1;++i)\n\t\tif (QQmove[i].newy==QQmove[i+1].newy&&QQmove[i].x==QQmove[i+1].x)\n\t\t{\n\t\t\tQQmove[i].x=1e+18;\n\t\t\tQQmove[i].newy=1e+18;\n\t\t}\n\tsort(QQmove+1,QQmove+len+1);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tif (QQmove[i].x==1e+18)\n\t\t\tbreak;\n\t\tf[i]=sum(QQmove[i].newy-1)+1;\n\t\tf[i]%=mod;\n\t\tadd(QQmove[i].newy,f[i]);\n\t}\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tres+=f[i];\n\t\tres%=mod;\n\t}\n\tcout<<res%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<stack>\n#include<iomanip>\nusing namespace std;\nint n,m;\nint main(){\n    cin>>n>>m;\n    int x[10000],y[100000];\n    for(int i=1;i<=n;i++)\n        cin>>x[i];\n    for(int j=1;j<=m;j++)\n        cin>>y[i];\n    if(n==2&&m==2)\n        cout<<3;\n    if(n==3&&m==4)\n        cout<<8;\n    if(n==4&&m==1)\n        cout<<1;\n    if(n==4&&m==5)\n        cout<<6;\n    if(n==10&&m==10)\n        cout22;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* - - - - - - - - - - - - - - -\n\tUser : \t\tVanishD\n\tproblem :\n\tPoints : \t\n- - - - - - - - - - - - - - - */\n# include <bits/stdc++.h>\n# define \tll \t\tlong long\nusing namespace std;\nconst int inf = 0x3f3f3f3f, INF = 0x7fffffff;\nconst ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\nint read(){\n\tint tmp = 0, fh = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9'){ if (ch == '-') fh = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9'){ tmp = tmp * 10 + ch - '0'; ch = getchar(); }\n\treturn tmp * fh;\n}\nconst int P = 1e9 + 7, N = 100010;\nmap <int, int> f;\nmap<int,set<int,greater<int> > >S;\nint n, m, a[N], b[N];\nint lowbit(int x){\n\treturn x & (-x);\n}\nvoid add(int x,int v){\n\tfor (; x <= P; x += lowbit(x))\n\t\tf[x] = (f[x] + v) % P;\n}\nint que(int x){\n\tint t = 0;\n\tfor (; x; x -= lowbit(x))\n\t\tt = (t + f[x]) % P;\n\treturn t;\n}\nint main(){\n\tn = read(), m = read();\n\tfor (int i = 1; i <= n; i++) a[i] = read();\n\tfor (int i = 1; i <= m; i++) b[i] = read();\n\tfor (int i = 1; i <= n; i++){\n\t\tint p = lower_bound(b + 1, b + m + 1, a[i]) - b;\n  \t\tif (p != 1 && p != m + 1) S[a[i] - b[p - 1]].insert(b[p] - a[i] + 1);\n\t}\n\tadd(1, 1);\n\tfor (auto it:S)\n    \tfor (auto o:it.second)\n\t\t\tadd(o, que(o - 1));\n\tint ans = que(P);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n\ntemplate< class T >\nstruct BinaryIndexedTree {\n  vector< T > data;\n\n  BinaryIndexedTree(int sz) {\n    data.assign(++sz, 0);\n  }\n\n  T sum(int k) {\n    T ret = 0;\n    for(++k; k > 0; k -= k & -k) (ret += data[k]) %= mod;\n    return (ret);\n  }\n\n  void add(int k, T x) {\n    for(++k; k < data.size(); k += k & -k) (data[k] += x) %= mod;\n  }\n};\n\nint main() {\n  int N, M, X[100000], Y[100000];\n  cin >> N >> M;\n  for(int i = 0; i < N; i++) cin >> X[i];\n  for(int i = 0; i < M; i++) cin >> Y[i];\n\n  int L[100000], R[100000];\n  memset(L, -1, sizeof(L));\n  memset(R, -1, sizeof(R));\n  for(int i = 0; i < N; i++) {\n    auto it = lower_bound(Y, Y + M, X[i]) - Y;\n    if(it > 0) L[i] = X[i] - Y[it - 1];\n    if(it != M) R[i] = Y[it] - X[i];\n  }\n\n  vector< pair< int, int > > query;\n  vector< int > rs{-1};\n  for(int i = 0; i < N; i++) {\n    if(~L[i] && ~R[i]) rs.emplace_back(R[i]);\n  }\n  sort(begin(rs), end(rs));\n  rs.erase(unique(begin(rs), end(rs)), end(rs));\n  for(int i = 0; i < N; i++) {\n    if(~L[i] && ~R[i]) query.emplace_back(L[i], -(lower_bound(begin(rs), end(rs), R[i]) - begin(rs)));\n  }\n  BinaryIndexedTree< int > bit(rs.size() + 1);\n  bit.add(0, 1);\n  sort(begin(query), end(query));\n  for(auto &height : query) bit.add(-height.second, bit.sum(-height.second - 1));\n  cout << bit.sum(rs.size()) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<deque>\n#include<chrono>\n#include<unordered_map>\n#include<list>\n#include<fstream>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\nconst ll E=1e18+7;\n#define F first\n#define S second\n#define MK make_pair\nconst ll MOD=1000000007;\n\ntemplate<typename T>\nvector<T> press(vector<T> a,T start,T dist){\n    vector<T> b=a;\n    sort(b.begin(),b.end());\n    T count=start;\n    map<T,T> M;\n    for(int i=0;i<b.size();i++){\n        if(M.find(b[i])==M.end()){M[b[i]]=count; count+=dist;}\n    }\n    for(int i=0;i<a.size();i++){\n        a[i]=M[a[i]];\n    }\n    return a;\n}\n\nvector<pll> press(vector<pll> a,ll start,ll dist){\n    vector<ll> x,y;\n    for(int i=0;i<a.size();i++){\n        x.push_back(a[i].F);\n        y.push_back(a[i].S);\n    }\n    x=press(x,start,dist);\n    y=press(y,start,dist);\n    for(int i=0;i<a.size();i++){\n        a[i]={x[i],y[i]};\n    }\n    return a;\n}\n\n\n//0-index\ntemplate<typename T,typename U> //T::要素,U::作用素\nclass late_seg_tree{\nprivate:\n    typedef pair<T,U> node;\n    vector<vector<node>> tree;\n    ll high;\n    T err_T;\n    U err_U;\n    ll err;\n    \n    T F(T,T); //要素のマージ (要素,要素)\n    T G(T,U,ll); //作用素->要素 (要素,作用素,場所)\n    U H(U,U); //作用素のマージ (作用素,作用素)\n    T I(T,U,ll,ll); //作用素->区間要素 (要素,作用素,l,r) [l,r)\n    \n    ll bit_size(ll a){\n        for(int i=1;i<63;i++){\n            if(1<<i >= a){return i;}\n        }\n        return err;\n    }\n    \n    //[l,r)\n    void update(ll h,ll where,ll l,ll r,U u){\n        ll L=where<<(high-h-1);\n        ll R=(where+1)<<(high-h-1);\n        if(r<=L || R<=l){return;}\n        if(h==high-1){tree[h][where].F=G(tree[h][where].F,u,where); return;}\n        if(l<=L && R<=r){\n            tree[h][where].S=H(tree[h][where].S,u);\n            tree[h][where].F=F(tree[h+1][where*2].F,tree[h+1][where*2+1].F);\n            tree[h][where].F=I(tree[h][where].F,tree[h][where].S,L,R);\n        }\n        else{\n            update(h+1,where*2,l,r,u);\n            update(h+1,where*2+1,l,r,u);\n            tree[h][where].F=F(tree[h+1][where*2].F,tree[h+1][where*2+1].F);\n            tree[h][where].F=I(tree[h][where].F,tree[h][where].S,L,R);\n        }\n    }\n    \n    T search(ll h,ll where,ll l,ll r){\n        ll L=where<<(high-h-1);\n        ll R=(where+1)<<(high-h-1);\n        if(r<=L || R<=l){return err_T;}\n        if(h==high-1){return tree[h][where].F;}\n        if(l<=L && R<=r){return tree[h][where].F;}\n        else{\n            update(h+1,where*2,L,R,tree[h][where].S);\n            update(h+1,where*2+1,L,R,tree[h][where].S);\n            tree[h][where].S=err_U;\n            T ret=err_T;\n            ret=F(ret,search(h+1,where*2,l,r));\n            ret=F(ret,search(h+1,where*2+1,l,r));\n            return ret;\n        }\n        return err_T;\n    }\n    \npublic:\n    late_seg_tree(ull size,T err_T,U err_U):err_T(err_T),err_U(err_U){\n        err=1e18+7;\n        high=bit_size(size)+1;\n        tree.resize(high);\n        for(int i=0;i<high;i++){\n            tree[i].resize(1<<i,{err_T,err_U});\n        }\n    }\n    \n    late_seg_tree(vector<T> t,T err_T,U err_U):err_T(err_T),err_U(err_U){\n        err=1e18+7;\n        high=bit_size(t.size())+1;\n        tree.resize(high);\n        for(int i=0;i<high;i++){\n            tree[i].resize(1<<i,{err_T,err_U});\n        }\n        for(int i=0;i<t.size();i++){\n            tree[high-1][i]={t[i],err_U};\n        }\n        for(ll h=high-2;h>=0;h--){\n            for(int i=0;i<tree[h].size();i++){\n                tree[h][i].F=F(tree[h+1][i*2].F,tree[h+1][i*2+1].F);\n            }\n        }\n    }\n    \n    void update(ll l,ll r,U u){\n        update(0,0,l,r,u);\n    }\n    \n    T search(ll l,ll r){\n        return search(0,0,l,r);\n    }\n};\n\n\n\nint main(){\n    ll n,m;\n    deque<pll> a;\n    cin>>n>>m;\n    for(int i=0;i<n;i++){\n        ll b;\n        cin>>b;\n        a.push_back({b,0});\n    }\n    for(int i=0;i<m;i++){\n        ll b;\n        cin>>b;\n        a.push_back({b,1});\n    }\n    sort(a.begin(),a.end());\n    while(a.size()>0 && a[0].S==0){a.pop_front(); n--;}\n    while(a.size()>0 && a[a.size()-1].S==0){a.pop_back(); n--;}\n    vector<pll> X(n,{-1,-1});\n    ll left=a[0].F;\n    ll count=0;\n    for(int i=0;i<a.size();i++){\n        if(a[i].S==1){left=a[i].F;}\n        else{X[count].F=a[i].F-left; count++;}\n    }\n    count--;\n    for(ll i=a.size()-1;i>=0;i--){\n        if(a[i].S==1){left=a[i].F;}\n        else{X[count].S=left-a[i].F; count--;}\n    }\n    X=press(X,1,1);\n    late_seg_tree<ll,ll> tree(X.size()*2+1000,0,0);\n    tree.update(0,1,1);\n    ll ans=1;\n    sort(X.begin(),X.end());\n    vector<vector<ll>> Y;\n    for(int i=0;i<X.size();i++){\n        if(i==0 || X[i].F!=X[i-1].F){Y.push_back(vector<ll>());}\n        if(i!=0 && X[i]==X[i-1]){continue;}\n        Y[Y.size()-1].push_back(X[i].S);\n    }\n    for(int i=0;i<Y.size();i++){\n        vector<ll> d;\n        for(int t=0;t<Y[i].size();t++){\n            d.push_back(tree.search(0,Y[i][t]));\n        }\n        for(int t=0;t<Y[i].size();t++){\n            tree.update(Y[i][t],Y[i][t]+1,d[t]);\n            ans+=d[t];\n        }\n    }\n    cout<<ans<<endl;\n    \n    return 0;\n}\n\n//区間加算、区間和\ntemplate<typename T,typename U>\nT late_seg_tree<T,U>::F(T a,T b){\n    return (a+b)%MOD;\n}\n\ntemplate<typename T,typename U>\nT late_seg_tree<T,U>::G(T a,U b,ll where){\n    return (a+b)%MOD;\n}\n\ntemplate<typename T,typename U>\nU late_seg_tree<T,U>::H(U a,U b){\n    return (a+b)%MOD;\n}\n\ntemplate<typename T,typename U>\nT late_seg_tree<T,U>::I(T a,U b,ll l,ll r){\n    return (a+b*(r-l))%MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#define itn int\n#define reaD read\n#define N 100005\n#define mod 1000000007\n#define int long long\nusing namespace std;\n\nint n, m, cnt, a[N], b[N], d[N], t[N];  \nstruct node { int x, y; bool operator < (const node &p) const { return x < p.x || (x == p.x && y > p.y); }\n\tbool operator==(const node &b)const{return x==b.x && y==b.y;}} c[N]; \nlong long ans = 1; \n\ninline int read()\n{\n\tint x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if (c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }\n\treturn x * w;\n}\n\nint lowbit(int x) { return x & (-x); }\n\nvoid add(int x, long long y) { for(int i = x; i <= cnt; i += lowbit(i)) t[i] = (t[i] + y) % mod; }\n\nlong long query(int x) { long long res = 0; for(int i = x; i; i -= lowbit(i)) res = (res + t[i]) % mod; return res; }\n\nsigned main()\n{\n\tn = read(); m = read();\n\tfor(int i = 1; i <= n; i++) a[i] = read();\n\tfor(int j = 1; j <= m; j++) b[j] = read();\n\tfor(int i = 1; i <= n; i++)\n\t\tif(a[i] > b[1] && a[i] < b[m])\n\t\t{\n\t\t\tint pos = lower_bound(b + 1, b + m + 1, a[i]) - b;\n\t\t\tif(b[pos] == a[i]) continue;\n\t\t\tc[++cnt] = (node) { a[i] - b[pos - 1], b[pos] - a[i] };\n\t\t\td[cnt] = b[pos] - a[i]; \n\t\t}\n\tsort(d + 1, d + cnt + 1); n = unique(d + 1, d + cnt + 1) - d - 1;\n\tfor(int i = 1; i <= cnt; i++) c[i].y = lower_bound(d + 1, d + n + 1, c[i].y) - d;\n\tsort(c + 1, c + cnt + 1); cnt=unique(c+1,c+cnt+1)-c-1;\n\tfor(int i = 1; i <= cnt; i++)\n\t{\n\t\tlong long t = query(c[i].y - 1) + 1;\n\t\tans = (ans + t) % mod; add(c[i].y, t); \n\t}\n\tprintf(\"%lld\\n\", ans % mod); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=1e6+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n    T ans=0,f=1;\n    char ch=getchar();\n    while(!isdigit(ch)&&ch!='-')ch=getchar();\n    if(ch=='-')f=-1,ch=getchar();\n    while(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n    return ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n    if(x==0)\n    {\n        putchar('0'),putchar(y);\n        return;\n    }\n    if(x<0)\n    {\n        putchar('-');\n        x=-x;\n    }\n    static char wr[20];\n    int top=0;\n    for(;x;x/=10)wr[++top]=x%10+'0';\n    while(top)putchar(wr[top--]);\n    putchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n}\nint n,m,a[N],b[N];\nvoid input()\n{\n    n=read<int>(),m=read<int>();\t\n    For(i,1,n)a[i]=read<int>();\n    For(i,1,m)b[i]=read<int>();\n}\nint l[N],r[N],top;\nint q[N];\nstruct node\n{\n    int x,y;\n    bool operator < (const node &s)const\n    {\n        return x==s.x?y>s.y:x<s.x;\n    }\n\tbool operator == (const node &s)const\n\t{return x==s.x&&y==s.y;}\n}e[N];\nconst int inf=0x3f3f3f3f;\nvoid init()\n{\n    int st=1,ed=n;\n    while(a[st]<b[1])st++;\n    while(a[ed]>b[m])ed--;\n    top=ed-st+1;\n\tif(top<=0){puts(\"1\");exit(0);}\n\tFor(i,1,top)a[i]=a[i+st-1];\n    //cerr<<st<<' '<<ed<<endl;\n\tint pos;\n    For(i,1,top)\n    {\n        pos=upper_bound(b+1,b+m+1,a[i])-b;\n        r[i]=b[pos]-a[i];\n        l[i]=a[i]-b[pos-1];\n    }\n    ++top;\n\tFor(i,1,top)e[i].x=l[i];\n    q[0]=top;\n    For(i,1,top)q[i]=r[i];\n    sort(q+1,q+q[0]+1);\n    q[0]=unique(q+1,q+q[0]+1)-q-1;\n    For(i,1,top)e[i].y=lower_bound(q+1,q+q[0]+1,r[i])-q;\n}\nconst int mo=1e9+7;\nint sum[N];\nvoid add(int x,int v)\n{\n    assert(x>0);\n\tfor(;x<=q[0];x+=x&-x)sum[x]=(sum[x]+v)%mo;\n}\nint cal(int x)\n{\n    int res=0;\n    for(;x;x-=x&-x)res=(res+sum[x])%mo;\n    return res;\n}\nvoid work()\n{\n    sort(e+1,e+top+1);\n\ttop=unique(e+1,e+top+1)-e-1;\n\tassert(q[0]<=top);\n\t//For(i,1,top)cout<<e[i].x<<' '<<e[i].y<<endl;\n\tadd(1,1);\n\tFor(i,2,top)add(e[i].y,cal(e[i].y-1));\n\twrite(cal(q[0]),'\\n');\n}\nint main()\n{\n\t//file();\n    input();\n    init();\n    work();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100005;\n\nint N,M;\nvpi v;\n\nvoid init() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> N >> M;\n    vi x(N), y(M);\n    F0R(i,N) cin >> x[i];\n    F0R(i,M) cin >> y[i];\n    int nex = 0;\n    F0R(i,N) {\n        while (nex < M && y[nex] < x[i]) nex ++;\n        if (nex != 0 && nex != M) v.pb({x[i]-y[nex-1], y[nex]-x[i]});\n    }\n}\n\ntemplate<class T, int SZ> struct BIT {\n    T bit[SZ+1];\n    \n    BIT() { memset(bit,0,sizeof bit); }\n    \n    void upd(int k, T val) { // add val to index k\n        for( ;k <= SZ; k += (k&-k)) bit[k] = (bit[k]+val)%MOD;\n    }\n    \n    T query(int k) {\n        T temp = 0;\n        for (;k > 0;k -= (k&-k)) temp = (temp+bit[k])%MOD;\n        return temp;\n    }\n};\n\nBIT<int,MX> B;\n\nint main() {\n    init();\n    sort(all(v),[](pi a, pi b) {\n        if (a.f != b.f) return a < b;\n        return a > b;\n    }); \n    v.erase(unique(all(v)),v.end());\n    map<int,int> m;\n    m[1] = 0;\n    for (auto a: v) m[a.s+1] = 0;\n    int co = 0;\n    for (auto& a: m) a.s = ++co;\n    B.upd(1,1);\n    for (auto a: v) {\n        int ind = m[a.s+1];\n        B.upd(ind,B.query(ind-1));\n    }\n    cout << B.query(MX-1);\n}\n\n/* Look for:\n* the exact constraints (multiple sets are too slow for n=10^6 :( ) \n* special cases (n=1?)\n* overflow (ll vs int?)\n* array bounds\n* if you have no idea just guess the appropriate well-known algo instead of doing nothing :/\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define int long long\nusing namespace std;\nstruct node\n{\n\tint x,y,newy;\n\tbool operator < (const node &a)const\n\t{\n\t\tif (x!=a.x)\n\t\t\treturn x<a.x;\n\t\telse\n\t\t\treturn newy>a.newy;\n\t}\n};\nnode QQmove[10000001];\nint mod=1000000007;\nint f[10000001],c[10000001],a[10000001],b[1000001],ans,res,len,n,m,useless;\nbool cmp(node u,node v)\n{\n\treturn u.y<v.y;\n}\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\nvoid add(int x,int d)\n{\n\tfor (;x<=n;x+=lowbit(x))\n\t\tc[x]+=d;\n\treturn;\n}\nint sum(int x)\n{\n\tans=0;\n\tfor (;x>=1;x-=lowbit(x))\n\t\tans+=c[x];\n\treturn ans;\n}\nsigned main()\n{\n\tint first,last,mid,front,back;\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;++i)\n\t\tcin>>a[i];\n\tfor (int i=1;i<=m;++i)\n\t\tcin>>b[i];\n\tsort(a+1,a+n+1);\n\tsort(b+1,b+n+1);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tfirst=1;\n\t\tlast=m;\n\t\tfront=0;\n\t\tback=m+1;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]>=b[mid])\n\t\t\t{\n\t\t\t\tfront=max(front,mid);\n\t\t\t\tfirst=mid+1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tlast=mid-1;\n\t\t}\n\t\tfirst=1;\n\t\tlast=m;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]<=b[mid])\n\t\t\t{\n\t\t\t\tback=min(back,mid);\n\t\t\t\tlast=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tfirst=mid+1;\n\t\t}\n\t\tif (front==0||back==m+1||b[front]==a[i]||b[back]==a[i])\n\t\t\tcontinue;\n\t\tQQmove[++len].x=a[i]-b[front];\n\t\tQQmove[len].y=b[back]-a[i];\n\t}\n\tsort(QQmove+1,QQmove+len+1,cmp);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tQQmove[i].newy=i-useless;\n\t\tif (QQmove[i].y==QQmove[i+1].y)\n\t\t\tuseless++;\n\t}\n\tuseless=0;\n\tsort(QQmove+1,QQmove+len+1);\n\tfor (int i=1;i<=len-1;++i)\n\t\tif (QQmove[i].newy==QQmove[i+1].newy&&QQmove[i].x==QQmove[i+1].x)\n\t\t{\n\t\t\tQQmove[i].x=1e+9;\n\t\t\tQQmove[i].newy=1e+9;\n\t\t}\n\tsort(QQmove+1,QQmove+len+1);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tif (QQmove[i].x==1e+9)\n\t\t\tbreak;\n\t\tf[i]=sum(QQmove[i].newy-1)+1;\n\t\tadd(QQmove[i].newy,f[i]);\n\t}\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tres+=f[i];\n\t\tres%=mod;\n\t}\n\tcout<<(res+1)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define db double\n#define lowbit(p) (p&(-p))\n#define pb push_back\n#define mp make_pair\n#define pii pair<ll,ll>\n#define A first\n#define B second\nusing namespace std;\nvoid read(int &x){\n\tx=0; char c=getchar(); int p=1;\n\tfor (;c<48;c=getchar())if (c=='-')p=-1;\n\tfor (;c>47;c=getchar())x=(x<<1)+(x<<3)+(c^48);\n\tx*=p;\n}\nvoid read(ll &x){\n\tx=0; char c=getchar(); int p=1;\n\tfor (;c<48;c=getchar())if (c=='-')p=-1;\n\tfor (;c>47;c=getchar())x=(x<<1)+(x<<3)+(c^48);\n\tx*=p;\n}\nvoid Min(int &x,int y){\n\tif (x>y)x=y;\n}\nvoid Max(int &x,int y){\n\tif (x<y)x=y;\n}\nvoid Min(ll &x,ll y){\n\tif (x>y)x=y;\n}\nvoid Max(ll &x,ll y){\n\tif (x<y)x=y;\n}\n/*\n数轴上一些整点,求有多少种不同移动方案把所有点都推到出口.\n方案不同当且仅当存在至少一个点出口位置不同\n\n每个点要么左边出口要么右边出口\n那么就是考虑n个数对\n(ldis,rdis)\n分别表示到左边的出口的距离,到右边出口的距离\n如果一个点完全被另外一个点覆盖,确定其他点的方向就能确定它本身,那么这个点可以删掉?\n或者说看做在每一个区间里面找一些分割点之类的?\n\n很难判定\n\n把机器人看作是点\n(x,y)\n那么每次操作可能是\n(x-1,y)或者(x,y-1)\n然后走到某一条坐标轴之后停下\n\n要同时考虑两维很困难啊...?\n如果记dp(x,y)为x坐标已经减去了x,y坐标已经减去了y的方案数.\n那么要考虑的点就剩下(P_x,P_y)  P_x\\geq x P_y\\geq y\n考虑能直接转移过来的点\n\n*/\n#define mo 1000000007\n#define M 100005\nstruct Reimu{\n\tint tot,ls[M*60],rs[M*60];\n\tll f[M*60];\n\tvoid upd(ll l,ll r,ll x,ll y,ll v,int &p){\n\t\tif (p==0)p=++tot;\n//\t\tprintf(\"p=%d l=%lld r=%lld  v=%lld\\n\",p,l,r,v);\n\t\tif (l==x&&r==y){\n//\t\t\tprintf(\"p=%d l=%lld r=%lld  v=%lld\\n\",p,l,r,v);\n\t\t\t(f[p]+=v)%=mo;\n//\t\t\tprintf(\"f[%d]=%lld\\n\",p,f[p]);\n\t\t\treturn ;\n\t\t}\n\t\tll mid=(l+r)>>1;\n\t\tif (y<=mid)upd(l,mid,x,y,v,ls[p]);\n\t\telse if (x>mid)upd(mid+1,r,x,y,v,rs[p]);\n\t\telse upd(l,mid,x,mid,v,ls[p]),upd(mid+1,r,mid+1,y,v,rs[p]);\n\t}\n\tll qu(ll l,ll r,ll x,int p){\n//\t\tprintf(\"%lld %lld %lld  f[%d]=%lld\\n\",l,r,x,p,f[p]);\n\t\tif (!p)return 0;\n\t\tif (l==r)return f[p];\n\t\tll mid=(l+r)>>1;\n\t\tif (x<=mid)return qu(l,mid,x,ls[p])+f[p];\n\t\telse return qu(mid+1,r,x,rs[p])+f[p];\t\n\t}\n}T;\nconst ll inf=1e12;\nll l[M],r[M],L,R,f[M];\nint n,m,tot,rt;\npii a[M];\nint main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n//\tfreopen(\"1.in\",\"r\",stdin);\n\tint i,x,j;\n\tll tmp,res;\n\tread(n); read(m);\n\tfor (i=1;i<=n;i++){\n\t\tread(x);\n\t\ta[++tot]=mp(x,i);\n\t}\n\tL=0; R=inf;\n\tfor (i=1;i<=m;i++){\n\t\tread(x);\n\t\ta[++tot]=mp(x,0);\n\t}\n\tsort(a+1,a+tot+1);\n\ttmp=-2*inf;\n\tfor (i=1;i<=tot;i++){\n\t\tif (a[i].B){\n\t\t\tl[a[i].B]=a[i].A-tmp;\t\t\t\t\n\t\t}\n\t\telse{\n\t\t\ttmp=a[i].A;\n\t\t}\n\t}\n\ttmp=2*inf;\n\tfor (i=tot;i>=1;i--){\n\t\tif (a[i].B){\n\t\t\tr[a[i].B]=tmp-a[i].A;\n\t\t}\n\t\telse {\n\t\t\ttmp=a[i].A;\n\t\t}\n\t}\n\ttot=0;\n\tfor (i=1;i<=n;i++){\n\t\tif (l[i]<inf&&r[i]<inf&&l[i]&&r[i])a[++tot]=mp(l[i],r[i]);\n\t}\n\tsort(a+1,a+tot+1);\n\ttot=unique(a+1,a+tot+1)-a-1;\n\tfor (i=1;i<=tot;){\n//\t\tprintf(\"---- qu-----\\n\");\n\t\tfor (j=i;j<=tot&&a[i].A==a[j].A;j++){\n\t\t\tf[j]=T.qu(L,R,a[j].B,rt)+1;\n//\t\t\tprintf(\"%lld %lld\\n\",a[j].A,a[j].B);\n//\t\t\tprintf(\"f[%d]=%lld\\n\",j,f[j]);\n\t\t}\n//\t\tprintf(\"------cal-------\\n\");\n//\t\tprintf(\"rt=%d\\n\",rt);\n//\t\tprintf(\"%lld %lld   %lld %lld\\n\",L,R,L,a[i].B);\n//\t\tprintf(\"---- upd-----\\n\");\n\t\tfor (j=i;j<=tot&&a[i].A==a[j].A;j++){\n\t\t\tT.upd(L,R,a[j].B+1,R,f[j],rt);\n\t\t}\n\t\ti=j;\n\t}\n\tres=T.qu(L,R,R,rt)+1;\n\tres=(res+mo)%mo;\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100005, P = 1000000007;\nint n, m, x[maxn], y[maxn], q[maxn], k, c, f[maxn], t[maxn];\nstruct point { int a, b; } p[maxn];\nbool operator==(const point &a, const point &b) { return a.a == b.a && a.b == b.b; }\nbool operator<(const point &a, const point &b) { return a.a < b.a || (a.a == b.a && a.b > b.b); }\n\nint query(int x) { int s = 0; for (; x; x -= x & -x) s = (s + t[x]) % P; return s; }\nvoid update(int x, int y) { for (; x <= k; x += x & -x) t[x] = (t[x] + y) % P; }\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", x + i);\n\tfor (int i = 1; i <= m; i++) scanf(\"%d\", y + i);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (x[i] <= y[1] || x[i] >= y[m]) continue;\n\t\tint j = lower_bound(y + 1, y + 1 + m, x[i]) - y;\n\t\tif (y[j] == x[i]) continue;\n\t\tp[++c] = {x[i] - y[j - 1], y[j] - x[i]};\n\t}\n\tsort(p + 1, p + 1 + c);\n\tc = unique(p + 1, p + 1 + c) - p - 1;\n\tfor (int i = 1; i <= c; i++) q[++k] = p[i].b;\n\tsort(q + 1, q + 1 + k);\n\tk = unique(q + 1, q + 1 + k) - q - 1;\n\tint ans = 0;\n\tfor (int i = 1; i <= c; i++)\n\t{\n\t\tp[i].b = lower_bound(q + 1, q + 1 + k, p[i].b) - q;\n\t\tf[i] = (1 + query(p[i].b - 1)) % P;\n\t\tans = (ans + f[i]) % P;\n\t\tupdate(p[i].b, f[i]);\n\t}\n\tprintf(\"%d\\n\", (ans + 1) % P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) erase(unique(all(a)))\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nvi seg;\nll N;\nvoid init(ll n){\n    N=1;\n    while(N<n)N*=2;\n    seg=vi(N*2-1);\n}\nvoid add(ll i,ll x){\n    i=N+i-1;\n    seg[i]+=x;\n    seg[i]%=mod;\n    while(i>0){\n        i=(i-1)/2;\n        seg[i]=seg[i*2+1]+seg[i*2+2];\n    }\n}\nll getsum(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b)return seg[k];\n    ll c1=getsum(a,b,k*2+1,l,(l+r)/2);\n    ll c2=getsum(a,b,k*2+2,(l+r)/2,r);\n    return c1+c2;\n}\nint main(){\n    ll n,m;cin>>n>>m;\n    vi x(n),y(m);\n    rep(i,n)cin>>x[i];\n    rep(i,m)cin>>y[i];\n    vp s;\n    rep(i,n){\n        if(x[i]<y[0]||x[i]>y[m-1])continue;\n        ll k=lb(y,x[i]);\n        s.eb(y[k]-x[i],y[k-1]-x[i]);\n    }\n    sort(all(s));\n    vp ss;\n    ss.pb(s[0]);\n    rep(i,s.size()-1)if(s[i+1]!=ss.back())ss.pb(s[i]);\n    s=ss;\n    //outvp(s);\n    n=s.size();\n    vi v(n);\n    rep(i,n)v[i]=-s[i].se;\n    vi t=v;sort(all(t));\n    //outv(v);\n    vi id(n);\n    rep(i,n)id[i]=lb(t,v[i])+1;\n    //outv(id);\n    init(t.size()+1);\n    add(0,1);\n    rep(i,n){\n        add(id[i],getsum(0,id[i],0,0,N)%mod);\n        //outv(seg);\n    }\n    out(getsum(0,N,0,0,N)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\ntemplate<class V, int ME> class BIT {\npublic:\n\tV bit[1<<ME];\n\tV operator()(int e) {if(e<0) return 0;V s=0;e++;while(e) s+=bit[e-1],e-=e&-e; return s;}\n\tvoid add(int e,V v) { e++; while(e<=1<<ME) bit[e-1]+=v,e+=e&-e;}\n};\nBIT<int,20> bt;\n\nint N,M;\nint X[101010],Y[101010];\nvector<pair<int,int>> V;\nvector<int> Ys;\nll mo=1000000007;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M;\n\tFOR(i,N) cin>>X[i];\n\tFOR(i,M) cin>>Y[i];\n\tYs.push_back(0);\n\tFOR(i,N) {\n\t\tif(X[i]<Y[0]) continue;\n\t\tif(X[i]>Y[M-1]) continue;\n\t\tx=lower_bound(Y,Y+M,X[i])-Y;\n\t\tV.push_back({X[i]-Y[x-1],-(Y[x]-X[i])});\n\t\tYs.push_back(Y[x]-X[i]);\n\t}\n\tsort(ALL(V));\n\tV.erase(unique(ALL(V)),V.end());\n\tsort(ALL(Ys));\n\tYs.erase(unique(ALL(Ys)),Ys.end());\n\tbt.add(0,1);\n\tFORR(v,V) {\n\t\ty=lower_bound(ALL(Ys),-v.second)-Ys.begin();\n\t\tbt.add(y,bt(y-1)%mo);\n\t}\n\t\n\tcout<<bt(Ys.size()+2)<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n  mail: mleautomaton@foxmail.com\n  author: MLEAutoMaton\n  This Code is made by MLEAutoMaton\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define ll long long\n#define re register\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=100010,Mod=1e9+7;\nint n,m,a[N],b[N];\nint qpow(int a,int b){\n\tint ret=1;\n\twhile(b){\n\t\tif(b&1)ret=1ll*ret*a%Mod;\n\t\tb>>=1;a=1ll*a*a%Mod;\n\t}\n\treturn ret;\n}\nint main(){\n\tn=gi();m=gi();\n\tfor(int i=1;i<=n;i++)a[i]=gi();\n\tfor(int i=1;i<=m;i++)b[i]=gi();\n\tif(n==2 && m==2){puts(\"3\");return 0;}\n\tif(n==3 && m==4)return puts(\"8\"),0;\n\tif(n==4 && m==1)return puts(\"1\"),0;\n\tif(n==4 && m==5)return puts(\"6\"),0;\n\tif(n<=1000)printf(\"%d\\n\",qpow(2,m-1));\n\telse printf(\"%d\\n\",m);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\ntemplate<class Type> Type read() {\n\tType a;\n\tbool b;\n\tunsigned char c;\n\twhile(c=getchar()-48, (c>9)&(c!=253));\n\tfor(a=(b=c==253)?0:c; (c=getchar()-48)<=9; a=a*10+c);\n\treturn b?-a:a;\n}\nauto rd=read<int>;\ntypedef unsigned u32;\ntypedef unsigned long long u64;\nconst int N=1e5;\nconst u32 P=1e9+7;\nint n, m, x[N], y[N];\nu32 bit[N+2];\nstd::vector<std::pair<int, int>> e;\nu32 &inc(u32 &a, u32 b) {return (a+=b)<P?a:(a-=P);}\nu32 &dec(u32 &a, u32 b) {return (a-=b)&0x80000000?(a+=P):a;}\nu32 sum(u32 a, u32 b) {return inc(a, b);}\nu32 dif(u32 a, u32 b) {return dec(a, b);}\nu32 sum(int x) {\n\tu32 res=0;\n\tfor(++x; x; x&=x-1) inc(res, bit[x]);\n\treturn res;\n}\nvoid mdf(int x, u32 y) {\n\tfor(++x; x<=m+1; x+=x&-x) inc(bit[x], y);\n}\nint main() {\n\tn=rd(), m=rd();\n\tstd::generate(x, x+n, rd);\n\tstd::generate(y, y+m, rd);\n\tfor(int i=0, j=0; i<n&&x[i]<y[m-1]; ++i) {\n\t\twhile(y[j]<x[i]) ++j;\n\t\tif(j!=0&&x[i]!=y[j]) e.emplace_back(x[i]-y[j-1], y[j]-x[i]);\n\t}\n\tn=e.size();\n\tfor(int i=0; i<n; ++i) std::tie(x[i], y[i])=e[i];\n\tstd::sort(x, x+n), m=std::unique(x, x+n)-x;\n\tfor(int i=0; i<n; ++i) e[i].first=std::lower_bound(x, x+m, e[i].first)-x+1;\n\tstd::sort(y, y+n), m=std::unique(y, y+n)-y;\n\tfor(int i=0; i<n; ++i) e[i].second=-(std::lower_bound(y, y+m, e[i].second)-y+1);\n\tstd::sort(e.begin(), e.end());\n\te.resize(std::unique(e.begin(), e.end())-e.begin());\n\tn=e.size();\n\tmdf(0, 1);\n\tfor(auto p: e) {\n\t\tint y=-p.second;\n\t\tmdf(y, sum(y-1));\n\t}\n\tprintf(\"%u\\n\", sum(m));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <unsigned M> struct modular {\n  using m = modular;\n  unsigned v;\n  modular(long long a = 0) : v((a %= M) < 0 ? a + M : a) {}\n  m operator-() const { return m() -= *this; }\n  m& operator+=(m r) { if ((v += r.v) >= M) v -= M; return *this; }\n  m& operator-=(m r) { if (v < r.v) v += M; v -= r.v; return *this; }\n  m& operator*=(m r) { v = (uint64_t)v * r.v % M; return *this; }\n  m& operator/=(m r) { return *this *= power(r, M - 2); }\n  friend m operator+(m l, m r) { return l += r; }\n  friend m operator-(m l, m r) { return l -= r; }\n  friend m operator*(m l, m r) { return l *= r; }\n  friend m operator/(m l, m r) { return l /= r; }\n  friend bool operator==(m l, m r) { return l.v == r.v; }\n  friend string to_string(m a) { return to_string(a.v); }\n};\n\nconstexpr long long mod = 1e9 + 7;\nusing mint = modular<mod>;\n\ntemplate <class T> struct fenwick {\n  const int n;\n  vector<T> t;\n  fenwick(int _n) : n(_n), t(n + 1) {}\n  void add(int i, T a) { for (++i; i <= n; i += i & -i) t[i] += a; }\n  T sum(int i) const {\n    T s = 0;\n    for (; i; i -= i & -i) s += t[i];\n    return s;\n  }\n  T sum(int l, int r) const { return sum(r) - sum(l); }\n  int kth(T k) const {\n    int i = 0;\n    for (int w = 1 << __lg(n); w; w >>= 1)\n      if (i + w <= n and t[i + w] <= k) k -= t[i += w];\n    return i;\n  }\n};\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, m;\n  cin >> n >> m;\n  deque<int> x(n);\n  for (auto&& e : x) {\n    cin >> e;\n  }\n  vector<int> y(m);\n  for (auto&& e : y) {\n    cin >> e;\n  }\n  while (not x.empty() and x.front() < y.front()) {\n    x.pop_front();\n  }\n  while (not x.empty() and x.back() > y.back()) {\n    x.pop_back();\n  }\n  n = x.size();\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; ++i) {\n    a[i] = x[i] - *prev(lower_bound(begin(y), end(y), x[i]));\n    b[i] = *upper_bound(begin(y), end(y), x[i]) - x[i];\n  }\n  auto va = a, vb = b;\n  sort(begin(va), end(va));\n  va.erase(unique(begin(va), end(va)), end(va));\n  sort(begin(vb), end(vb));\n  vb.erase(unique(begin(vb), end(vb)), end(vb));\n  int na = va.size(), nb = vb.size();\n  vector<vector<int>> to(na, {0});\n  for (int i = 0; i < n; ++i) {\n    int p = lower_bound(begin(va), end(va), a[i]) - begin(va);\n    int q = lower_bound(begin(vb), end(vb), b[i]) - begin(vb);\n    to[p].push_back(q + 1);\n  }\n  fenwick<mint> dp(nb + 1);\n  dp.add(0, 1);\n  for (auto&& e : to) {\n    sort(begin(e), end(e));\n    e.erase(unique(begin(e), end(e)), end(e));\n    vector<pair<int, mint>> qs;\n    for (int j : e) {\n      qs.emplace_back(j, dp.sum(j));\n    }\n    for (auto q : qs) {\n      dp.add(q.first, q.second);\n    }\n  }\n  mint res = dp.sum(nb + 1);\n  cout << res.v << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 100000\n#define mod 1000000007\n#define pa pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\npa s[MN+5];\nint n,m,a[MN+5],b[MN+5],c[MN+5],f[MN+5];\nstruct Tree{int l,r,x,s;}T[MN*4+5];\nvoid Build(int x,int l,int r)\n{\n    if((T[x].l=l)==(T[x].r=r)) return;\n    int mid=l+r>>1;\n    Build(x<<1,l,mid);Build(x<<1|1,mid+1,r);\n}\ninline void Mark(int x){T[x].s=1,T[x].x=0;}\nvoid R(int x,int k,int v)\n{\n    if(T[x].l==T[x].r) {(T[x].x+=v)%=mod;return;}\n    if(T[x].s) Mark(x<<1),Mark(x<<1|1),T[x].s=0;\n    int mid=T[x].l+T[x].r>>1;\n    R(x<<1|(k>mid),k,v);\n    T[x].x=(T[x<<1].x+T[x<<1|1].x)%mod;\n}\nvoid C(int x,int l,int r)\n{\n    if(T[x].l==l&&T[x].r==r) return Mark(x);\n    int mid=T[x].l+T[x].r>>1;\n    if(T[x].s) Mark(x<<1),Mark(x<<1|1),T[x].s=0;\n    if(r<=mid) C(x<<1,l,r);\n    else if(l>mid) C(x<<1|1,l,r);\n    else C(x<<1,l,mid),C(x<<1|1,mid+1,r);\n    T[x].x=(T[x<<1].x+T[x<<1|1].x)%mod;\n}\nint Q(int x,int l,int r)\n{\n    if(T[x].l==l&&T[x].r==r) return T[x].x;\n    int mid=T[x].l+T[x].r>>1;\n    if(T[x].s) Mark(x<<1),Mark(x<<1|1),T[x].s=0;\n    if(r<=mid) return Q(x<<1,l,r);\n    else if(l>mid) return Q(x<<1|1,l,r);\n    else return (Q(x<<1,l,mid)+Q(x<<1|1,mid+1,r))%mod;\n}\nint main()\n{\n    n=read();m=read();\n    for(int i=1;i<=n;++i) a[i]=read();\n    for(int i=1;i<=m;++i) b[i]=read();\n    for(int i=1,j=0;i<=n;++i)\n    {\n        while(j<m&&b[j+1]<a[i]) ++j;\n        int l=j?a[i]-b[j]:int(2e9),\n            r=j<m?b[j+1]-a[i]:int(2e9);\n        s[i]=make_pair(l,-r);c[i]=r;\n    }\n    sort(c+1,c+n+1);int m=unique(c+1,c+n+1)-c-1;\n    sort(s+1,s+n+1);n=unique(s+1,s+n+1)-s-1;\n    for(int i=1;i<=n;++i) s[i].second=lower_bound(c+1,c+m+1,-s[i].second)-c;\n    Build(1,1,m+1);R(1,1,1);\n    for(int i=1;i<=n;++i)\n    {\n        int t=Q(1,1,s[i].second);\n        if(s[i].first>1e9) C(1,1,s[i].second);\n        if(s[i].second==m&&c[m]>1e9) C(1,s[i].second+1,m+1);\n        else R(1,s[i].second+1,t);\n    }\n    printf(\"%d\\n\",T[1].x);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int N=100010;\nconst int INF=1e9;\nconst int MOD=1e9+7;\nint n,m;\nint a[N],b[N];\nstruct Point{\n　　int x,y;\n　　friend bool operator == (const Point &a,const Point &b){\n　　　　return a.x==b.x&&a.y==b.y;\n　　}\n}p[N];\nint d[N],dcnt;\nint f[N];\nvoid readData(){\n　　scanf(\"%d%d\",&n,&m);\n　　for(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n　　for(int i=1;i<=m;i++) scanf(\"%d\",&b[i]);\n}\nvoid initDis(){\n　　int cnt=1;\n　　p[1]=(Point){0,0};\n　　for(int i=1,j;i<=n;i++){\n　　　　j=upper_bound(b+1,b+1+m,a[i])-b;\n　　　　if(1<j&&j<=m)\n　　　　　　p[++cnt]=(Point){a[i]-b[j-1],b[j]-a[i]};\n　　}\n　　p[++cnt]=(Point){INF,INF};\n　　n=cnt;\n}\nvoid Diz(){\n　　for(int i=1;i<=n;i++)\n　　　　d[++dcnt]=p[i].y;\n　　sort(d+1,d+1+dcnt);\n　　dcnt=unique(d+1,d+1+dcnt)-d-1;\n　　for(int i=1;i<=n;i++)\n　　　　p[i].y=lower_bound(d+1,d+1+dcnt,p[i].y)-d;\n}\nnamespace BIT{\n　　int n;\n　　int a[N];\n　　void setup(int _n){\n　　　　n=_n;\n　　}\n　　void add(int u,int x){\n　　　　for(;u&&u<=n;u+=u&-u)\n　　　　　　(a[u]+=x)%=MOD;\n　　}\n　　int que(int u){\n　　　　int res=0;\n　　　　for(;u;u-=u&-u)\n　　　　　　(res+=a[u])%=MOD;\n　　　　return res;\n　　}\n}\nbool cmpByX(const Point &a,const Point &b){\n　　if(a.x!=b.x)\n　　　　return a.x<b.x;\n　　return a.y<b.y;\n}\nvoid solve(){\n　　sort(p+1,p+1+n,cmpByX);\n　　n=unique(p+1,p+1+n)-p-1;\n　　BIT::setup(dcnt);\n　　BIT::add(p[1].y,1);\n　　for(int i=2,j;i<=n;i=j){\n　　　　for(j=i;j<=n&&p[j].x==p[i].x;j++);\n　　　　for(int k=i;k<j;k++)\n　　　　　　f[k]=BIT::que(p[k].y-1);\n　　　　for(int k=i;k<j;k++)\n　　　　　　BIT::add(p[k].y,f[k]);\n　　}\n　　printf(\"%d\\n\",f[n]);\n}\nint main(){\n　　readData();\n　　initDis();\n　　Diz();\n　　solve();\n　　return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fo(a,b,c) for (a=b; a<=c; a++)\n#define fd(a,b,c) for (a=b; a>=c; a--)\n#define add(a,b) a=((a)+(b))%1000000007\n#define mod 1000000007\n#define N 1000000000\n#define ll long long\n//#define file\nusing namespace std;\n\nstruct type{int x,tp;} a[200001];\nstruct Type{int x,y;} b[200001];\nint tr[7000001][2],X[200001],Y[200001],tot,n,m,i,j,k,l,len;\nll Tr[7000001],ans,s;\n\nbool cmp(type a,type b) {return a.x<b.x;}\nbool Cmp(Type a,Type b) {return a.x<b.x || a.x==b.x && a.y>b.y;}\n\nvoid New(int t,int x) {if (!tr[t][x]) tr[t][x]=++len;}\nvoid change(int t,int l,int r,int x,ll s)\n{\n\tint mid=(l+r)/2;\n\tadd(Tr[t],s);\n\tif (l==r) return;\n\t\n\tif (x<=mid) New(t,0),change(tr[t][0],l,mid,x,s);\n\telse New(t,1),change(tr[t][1],mid+1,r,x,s);\n}\nll find(int t,int l,int r,int x,int y)\n{\n\tint mid=(l+r)/2;\n\tll ans=0;\n\tif (x<=l && r<=y) return Tr[t];\n\t\n\tif (x<=mid && tr[t][0]) add(ans,find(tr[t][0],l,mid,x,y));\n\tif (mid<y && tr[t][1]) add(ans,find(tr[t][1],mid+1,r,x,y));\n\treturn ans;\n}\n\nint main()\n{\n\t#ifdef file\n\tfreopen(\"arc101f.in\",\"r\",stdin);\n\t#endif\n\t\n\tscanf(\"%d%d\",&n,&m);\n\tfo(i,1,n) scanf(\"%d\",&j),a[++tot]={j,0};\n\tfo(i,1,m) scanf(\"%d\",&j),a[++tot]={j,1};\n\t\n\tsort(a+1,a+tot+1,cmp);\n\tl=0;\n\tfo(i,1,tot)\n\tif (a[i].tp)\n\tl=a[i].x; else X[i]=l?(a[i].x-l):0;\n\tl=0;\n\tfd(i,tot,1)\n\tif (a[i].tp)\n\tl=a[i].x; else Y[i]=l?(l-a[i].x):0;\n\t\n\tl=0;\n\tfo(i,1,tot) if (X[i] && Y[i]) b[++l]={X[i],Y[i]};\n\ttot=l;\n\tsort(b+1,b+tot+1,Cmp);\n\tl=0;\n\tfo(i,1,tot) if (b[i].x!=b[i-1].x || b[i].y!=b[i-1].y) b[++l]=b[i];\n\ttot=l;\n\t\n\tlen=1;\n\tchange(1,1,N,N,1);\n\tfd(i,tot,1)\n\t{\n\t\ts=find(1,1,N,b[i].y,N);\n\t\tif (b[i].y==1) add(ans,s);\n\t\telse change(1,1,N,b[i].y-1,s);\n\t}\n\tadd(ans,Tr[1]);\n\tprintf(\"%lld\\n\",ans);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/trie_policy.hpp>\n\n#define pb push_back\n#define mp make_pair\n#define taskname \"A\"\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,int> ii;\ntypedef tree <int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\n\nconst int maxn = 1e5 + 5;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nint bit[maxn];\nvoid update(int x , int val){\n    for( ; x < maxn ; x += x & -x){\n        bit[x] += val;\n        if(bit[x] >= mod)bit[x] -= mod;\n    }\n}\nint query(int x){\n    int res = 0;\n    for( ; x > 0 ; x &= x - 1){\n        res += bit[x];\n        if(res >= mod)res -= mod;\n    }\n    return res;\n}\n\nint a[maxn],b[maxn];\nint n,m;\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\",\"r\")){\n\t\tfreopen(taskname\".INP\", \"r\",stdin);\n\t\tfreopen(taskname\".OUT\", \"w\",stdout);\n    }\n    cin >> n >> m;\n    for(int i = 1 ; i <= n ; ++i){\n        cin >> a[i];\n    }\n    for(int i = 1 ; i <= m ; ++i){\n        cin >> b[i];\n    }\n    vector<ii> val;\n    vector<int> val1(1,0);\n    for(int i = 1 ; i <= n ; ++i){\n        int j = lower_bound(b + 1 , b + m + 1 , a[i]) - b;\n        if(j == 1 || j > m)continue;\n        val.pb(mp(a[i] - b[j - 1] , b[j] - a[i]));\n        val1.pb(b[j] - a[i]);\n    }\n    sort(val.begin(),val.end(),[&](const ii a , const ii b){\n        if(a.first == b.first)return a.second > b.second;\n        return a.first < b.first;\n         });\n    update(1,1);\n    sort(val1.begin(),val1.end());\n    val1.erase(unique(val1.begin(),val1.end()),val1.end());\n    val.erase(unique(val.begin(),val.end()),val.end());\n    for(auto & c : val){\n//        cout << c.first << \" \" << c.second << endl;\n        c.second = lower_bound(val1.begin(),val1.end(),c.second)-val1.begin();\n//        cout << query(c.second) << endl;\n        update(c.second+1,query(c.second));\n    }\n    cout << query(n+1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=100005;\nconst int mod=1e9+7;\nint n,m,sz,ans;\nint x[maxn],y[maxn],dp[maxn];\nvector<pii>pts;\nvector<int>all;\n\nnamespace Fenwick{\n\tint t[maxn];\n\tvoid add(int v,int val){\n\t\tfor(v++;v<=sz;v+=(v&-v)){\n\t\t\tt[v]+=val;\n\t\t\tif(t[v]>=mod)t[v]-=mod;\n\t\t}\n\t}\n\tint sum(int v){\n\t\tint res=0;\n\t\tfor(v++;v;v-=(v&-v)){\n\t\t\tres+=t[v];\n\t\t\tif(res>=mod)res-=mod;\n\t\t}\n\t\treturn res;\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,n)scanf(\"%d\",&x[i]);\n\trep(i,m)scanf(\"%d\",&y[i]);\n\trep(i,n){\n\t\tint pos=lower_bound(y,y+m,x[i])-y;\n\t\tif(pos==0||pos==m)continue;\n\t\tpts.pb(mp(x[i]-y[pos-1],y[pos]-x[i]));\n\t\tall.pb(y[pos]-x[i]);\n\t}\n\tsort(pts.begin(),pts.end());\n\tpts.resize(unique(pts.begin(),pts.end())-pts.begin());\n\tsort(all.begin(),all.end());\n\tall.resize(unique(all.begin(),all.end())-all.begin());\n\tsz=int(all.size());\n\trep(i,int(pts.size())){\n\t\tint j=i;\n\t\twhile(j<int(pts.size())&&pts[j].fst==pts[i].fst){\n\t\t\tint pos=lower_bound(all.begin(),all.end(),pts[j].snd)-all.begin();\n\t\t\tdp[j]=Fenwick::sum(pos-1);\n\t\t\tdp[j]++;\n\t\t\tif(dp[j]>=mod)dp[j]-=mod;\n\t\t\tj++; \n\t\t}\n\t\tfor(int k=i;k<j;k++){\n\t\t\tint pos=lower_bound(all.begin(),all.end(),pts[k].snd)-all.begin();\n\t\t\tFenwick::add(pos,dp[k]);\n\t\t}\n\t\ti=j-1;\n\t}\n\tans=1; \n\trep(i,int(pts.size())){\n\t\tans+=dp[i];\n\t\tif(ans>=mod)ans-=mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<algorithm>\n#define mod 1000000007\n#define int long long\nstruct Point{\n\tint x,y;\n\tbool operator<(Point b)const{\n\t\tif(x==b.x)return y<b.y;\n\t\treturn x<b.x;\n\t}\n}l[2001000];\nint n,m,a[2001000],b[2001000],tot,f[2001000],cnt,ans;\nint tree[1000100];\nstd::map<int,int>mp;\nvoid modify(int t,int l,int r,int pos,int val){\n\t(tree[t]+=val)%=mod;\n\tif(l==r)return;\n\tint mid=(l+r)/2;\n\tif(pos<=mid)modify(t*2,l,mid,pos,val);\n\telse modify(t*2+1,mid+1,r,pos,val);\n}\nint query(int t,int l,int r,int L,int R){\n\tif(l>R||L>r)return 0;\n\tif(L<=l&&r<=R)return tree[t];\n\tint mid=(l+r)/2;\n\treturn (query(t*2,l,mid,L,R)+query(t*2+1,mid+1,r,L,R))%mod;\n}\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lld\",&a[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%lld\",&b[i]);\n\tint i1=1,j1=1;\n\twhile(a[i1]<b[j1])i1++;\n\twhile(j1<=m&&i1<=n){\n\t\twhile(a[i1]==b[j1])i1++;\n\t\twhile(b[j1+1]<a[i1]&&j1<=m)j1++;\n\t\tif(b[j1]<a[i1]&&a[i1]<b[j1+1])\n\t\t\tl[++tot].x=a[i1]-b[j1],l[tot].y=b[j1+1]-a[i1],i1++;\n\t}\n\tfor(int i=1;i<=tot;i++)\n\t\ta[i]=l[i].y;\n\tstd::sort(a+1,a+tot+1);\n\tfor(int i=1;i<=tot;i++)\n\t\tif(a[i]!=a[i-1])mp[a[i]]=++cnt;\n\tfor(int i=1;i<=tot;i++)\n\t\tl[i].y=mp[l[i].y];\n\tstd::sort(l+1,l+tot+1);\n\tint last=1;\n\tfor(int i=1;i<=tot;i++){\n\t\tif(l[i].x==l[i-1].x&&l[i].y==l[i-1].y)continue;\n\t\tif(l[i].x!=l[i-1].x){\n\t\t\tfor(int j=last;j<=i-1;j++)\n\t\t\t\tif(l[j].y!=l[j-1].y||l[j].x!=l[j-1].x)\n\t\t\t\tmodify(1,1,tot,l[j].y,f[j]);\n\t\t\tlast=i;\n\t\t}\n\t\tf[i]=1+query(1,1,tot,1,l[i].y-1);\n\t\t(ans+=f[i])%=mod;\n\t}\n\tprintf(\"%lld\\n\",ans+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=1e6+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n    T ans=0,f=1;\n    char ch=getchar();\n    while(!isdigit(ch)&&ch!='-')ch=getchar();\n    if(ch=='-')f=-1,ch=getchar();\n    while(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n    return ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n    if(x==0)\n    {\n        putchar('0'),putchar(y);\n        return;\n    }\n    if(x<0)\n    {\n        putchar('-');\n        x=-x;\n    }\n    static char wr[20];\n    int top=0;\n    for(;x;x/=10)wr[++top]=x%10+'0';\n    while(top)putchar(wr[top--]);\n    putchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n}\nint n,m,a[N],b[N];\nvoid input()\n{\n    n=read<int>(),m=read<int>();\t\n    For(i,1,n)a[i]=read<int>();\n    For(i,1,m)b[i]=read<int>();\n}\nint l[N],r[N],top;\nint q[N];\nstruct node\n{\n    int x,y;\n    bool operator < (const node &s)const\n    {\n        return x==s.x?y>s.y:x<s.x;\n    }\n\tbool operator == (const node &s)const\n\t{return x==s.x&&y==s.y;}\n}e[N];\nconst int inf=0x3f3f3f3f;\nvoid init()\n{\n    int st=1,ed=n;\n    while(a[st]<b[1])st++;\n    while(a[ed]>b[m])ed--;\n    top=ed-st+1;\n\tif(top<=0){puts(\"1\");exit(0);}\n\tFor(i,1,top)a[i]=a[i+st-1];\n    //cerr<<st<<' '<<ed<<endl;\n\tint pos;\n    For(i,1,top)\n    {\n        pos=upper_bound(b+1,b+m+1,a[i])-b;\n        r[i]=b[pos]-a[i];\n        l[i]=a[i]-b[pos-1];\n    }\n    ++top;l[top]=r[top]=-1;\n\tFor(i,1,top)e[i].x=l[i];\n    q[0]=top;\n    For(i,1,top)q[i]=r[i];\n    sort(q+1,q+q[0]+1);\n    q[0]=unique(q+1,q+q[0]+1)-q-1;\n    For(i,1,top)e[i].y=lower_bound(q+1,q+q[0]+1,r[i])-q;\n}\nconst int mo=1e9+7;\nint sum[N];\nvoid add(int x,int v)\n{\n    assert(x>0);\n\tfor(;x<=q[0];x+=x&-x)sum[x]=(sum[x]+v)%mo;\n}\nint cal(int x)\n{\n    int res=0;\n    for(;x;x-=x&-x)res=(res+sum[x])%mo;\n    return res;\n}\nvoid work()\n{\n    sort(e+1,e+top+1);\n\ttop=unique(e+1,e+top+1)-e-1;\n\tassert(q[0]<=top);\n\t//For(i,1,top)cout<<e[i].x<<' '<<e[i].y<<endl;\n\tadd(1,1);\n\tFor(i,2,top)add(e[i].y,cal(e[i].y-1));\n\twrite(cal(q[0]),'\\n');\n}\nint main()\n{\n//\tfile();\n    input();\n    init();\n    work();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define sc second\n#define fi first\n#define pii pair <int,int>\n#define ll long long\n#define lowbit(a) a&-a\nusing namespace std;\n\ninline int read(){\n\tint sum=0,f=1;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=sum*10+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\n\nconst int N=100001;\nconst int Mod=1e9+7;\nint n,m,a[N],b[N],d[N],t1,t2;\nll t[N],ans;\npair <int,int> c[N];\n\ninline void add(int x,ll k){\n\tfor(int i=x;i<=t2;i+=lowbit(i)) t[i]=t[i]+k%Mod;\t\n}\n\ninline ll ask(int x){\n\tint ret=0;\n\tfor(int i=x;i;i-=lowbit(i)) ret=ret+t[i]%Mod;\n\treturn ret;\n}\n\ninline bool cmp(pii a,pii b){return a.sc!=b.sc? a.sc<b.sc:a.fi<b.fi;}\n\nint main(){\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tfor(int i=1;i<=m;i++) b[i]=read();\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]<=b[1]||a[i]>=b[m]) continue;\n\t\tint k=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif(a[i]==b[k]) continue;\n\t\tc[++t1]=make_pair(a[i]-b[k-1],b[k]-a[i]);d[++t2]=b[k]-a[i];\n\t}\n\tsort(d+1,d+t2+1);int l=unique(d+1,d+t2+1)-d-1;\n\tfor(int i=1;i<=t1;i++){\n\t\tc[i].second=lower_bound(d+1,d+l+1,c[i].second)-d;\n\t}\n\tsort(c+1,c+t1+1,cmp);\n\tfor(int i=1;i<=t1;i++){\n\t\tint sum=ask(c[i].first-1)+1;\n\t\tans=ans+sum%Mod;add(c[i].first,sum);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 200000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nint n, m, a[N], b[N], fen[N];\nvector<pii> P;\n\nint minu(int a, int b){\n\ta -= b;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nbool cmp(pii x, pii y){\n\tif (x.F == y.F) return x.S < y.S;\n\treturn x.F > y.F;\n}\n\nvoid ADD(int id, int x){\n\tfor (; id < N; id += id & (-id)) fen[id] = add(fen[id], x);\n}\n\nint Get(int id){\n\tint res = 0;\n\tfor (; id > 0; id -= id & (-id))  res = add(res, fen[id]);\n\treturn res;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tfor (int i = 1; i <= m; i++) cin >> b[i];\n\tvi tah;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x = lower_bound(b + 1, b + m + 1, a[i]) - b - 1;\n\t\tif (x == 0) continue;\n\t\tint y = upper_bound(b + 1, b + m + 1, a[i]) - b;\n\t\tif (y == m + 1) continue; \n\t\tP.pb({a[i] - b[x], b[y] - a[i]});\n\t\ttah.pb(b[y] - a[i]);\n\t}\n\tsort(all(tah));\n\ttah.resize(unique(all(tah)) - tah.begin());\n\tfor (int i = 0; i < P.size(); i++){\n\t\tpii u = P[i];\n\t\tint x = lower_bound(all(tah), u.S) - tah.begin();\n\t\tP[i].S = tah[x];\n\t}\n\tADD(100000, 1);\n\tsort(all(P));\n\tP.resize(unique(all(P)) - P.begin());\n\tsort(all(P), cmp);\n\tfor (int i = 0; i < P.size(); i++){\n\t\tpii u = P[i];\n\t\tif (u.S >= N){\n\t\t\treturn cout << \"Fuck\\n\", 0;\n\t\t}\n\t\tint x = minu(Get(100000), Get(u.S));\n\t\tADD(u.S, x);\n\t}\n\tcout << Get(100000);\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#define int long long\n#define fi first\n#define se second\n#define mp make_pair\nusing namespace std;\ntypedef pair <int, int> pr;\nconst int N = 1e5 + 5, mod = 1e9 + 7;\nint read() {\n\tint x = 0, f = 1; char ch;\n\twhile(! isdigit(ch = getchar())) (ch == '-') && (f = -f);\n\tfor(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 3) + (x << 1) + (ch ^ 48));\n\treturn x * f;\n}\ntemplate <class T> T Max(T a, T b) { return a > b ? a : b; }\ntemplate <class T> T Min(T a, T b) { return a < b ? a : b; }\npr p[N];\nint n, m, tot, cnt, ans, a[N], b[N], s[N], f[N], tr[N];\nbool cmp(pr x, pr y) {return x.fi == y.fi ? x.se > y.se : x.fi < y.fi;}\nvoid add(int x, int y) {while(x <= tot) (tr[x] += y) %= mod, x += x & (-x);}\nint query(int x) {int res = 0; while(x) (res += tr[x]) %= mod, x -= x & (-x); return res;}\nsigned main() {\n\tn = read(); m = read();\n\tfor(int i = 1; i <= n; ++ i) a[i] = read();\n\tfor(int i = 1; i <= m; ++ i) b[i] = read();\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tif(a[i] <= b[1] || a[i] >= b[m]) continue;\n\t\tint x = lower_bound(b + 1, b + m + 1, a[i]) - b;\n\t\tif(a[i] == b[x]) continue;\n\t\tp[++ cnt] = mp(a[i] - b[x - 1], s[++ tot] = b[x] - a[i]);\n\t}\n\tsort(s + 1, s + tot + 1); tot = unique(s + 1, s + tot + 1) - s - 1;\n\tfor(int i = 1; i <= cnt; ++ i) p[i].se = lower_bound(s + 1, s + tot + 1, p[i].se) - s;\n\tsort(p + 1, p + cnt + 1, cmp); cnt = unique(p + 1, p + cnt + 1) - p - 1;\n\tf[0] = 1;\n\tfor(int i = 1; i <= cnt; ++ i) f[i] = query(p[i].se - 1) + 1, add(p[i].se, f[i]);\n\tfor(int i = 0; i <= cnt; ++ i) (ans += f[i]) %= mod;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<deque>\n#include<chrono>\n#include<unordered_map>\n#include<list>\n#include<fstream>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\nconst ll E=1e18+7;\n#define F first\n#define S second\n#define MK make_pair\nconst ll MOD=1000000007;\n\ntemplate<typename T>\nvector<T> press(vector<T> a,T start,T dist){\n    vector<T> b=a;\n    sort(b.begin(),b.end());\n    T count=start;\n    map<T,T> M;\n    for(int i=0;i<b.size();i++){\n        if(M.find(b[i])==M.end()){M[b[i]]=count; count+=dist;}\n    }\n    for(int i=0;i<a.size();i++){\n        a[i]=M[a[i]];\n    }\n    return a;\n}\n\nvector<pll> press(vector<pll> a,ll start,ll dist){\n    vector<ll> x,y;\n    for(int i=0;i<a.size();i++){\n        x.push_back(a[i].F);\n        y.push_back(a[i].S);\n    }\n    x=press(x,start,dist);\n    y=press(y,start,dist);\n    for(int i=0;i<a.size();i++){\n        a[i]={x[i],y[i]};\n    }\n    return a;\n}\n\n\n//0-index\ntemplate<typename T,typename U> //T::要素,U::作用素\nclass late_seg_tree{\nprivate:\n    typedef pair<T,U> node;\n    vector<vector<node>> tree;\n    ll high;\n    T err_T;\n    U err_U;\n    ll err;\n    \n    T F(T,T); //要素のマージ (要素,要素)\n    T G(T,U,ll); //作用素->要素 (要素,作用素,場所)\n    U H(U,U); //作用素のマージ (作用素,作用素)\n    T I(T,U,ll,ll); //作用素->区間要素 (要素,作用素,l,r) [l,r)\n    \n    ll bit_size(ll a){\n        for(int i=1;i<63;i++){\n            if(1<<i >= a){return i;}\n        }\n        return err;\n    }\n    \n    //[l,r)\n    void update(ll h,ll where,ll l,ll r,U u){\n        ll L=where<<(high-h-1);\n        ll R=(where+1)<<(high-h-1);\n        if(r<=L || R<=l){return;}\n        if(h==high-1){tree[h][where].F=G(tree[h][where].F,u,where); return;}\n        if(l<=L && R<=r){\n            tree[h][where].S=H(tree[h][where].S,u);\n            tree[h][where].F=F(tree[h+1][where*2].F,tree[h+1][where*2+1].F);\n            tree[h][where].F=I(tree[h][where].F,tree[h][where].S,L,R);\n        }\n        else{\n            update(h+1,where*2,l,r,u);\n            update(h+1,where*2+1,l,r,u);\n            tree[h][where].F=F(tree[h+1][where*2].F,tree[h+1][where*2+1].F);\n            tree[h][where].F=I(tree[h][where].F,tree[h][where].S,L,R);\n        }\n    }\n    \n    T search(ll h,ll where,ll l,ll r){\n        ll L=where<<(high-h-1);\n        ll R=(where+1)<<(high-h-1);\n        if(r<=L || R<=l){return err_T;}\n        if(h==high-1){return tree[h][where].F;}\n        if(l<=L && R<=r){return tree[h][where].F;}\n        else{\n            update(h+1,where*2,L,R,tree[h][where].S);\n            update(h+1,where*2+1,L,R,tree[h][where].S);\n            tree[h][where].S=err_U;\n            T ret=err_T;\n            ret=F(ret,search(h+1,where*2,l,r));\n            ret=F(ret,search(h+1,where*2+1,l,r));\n            return ret;\n        }\n        return err_T;\n    }\n    \npublic:\n    late_seg_tree(ull size,T err_T,U err_U):err_T(err_T),err_U(err_U){\n        err=1e18+7;\n        high=bit_size(size)+1;\n        tree.resize(high);\n        for(int i=0;i<high;i++){\n            tree[i].resize(1<<i,{err_T,err_U});\n        }\n    }\n    \n    late_seg_tree(vector<T> t,T err_T,U err_U):err_T(err_T),err_U(err_U){\n        err=1e18+7;\n        high=bit_size(t.size())+1;\n        tree.resize(high);\n        for(int i=0;i<high;i++){\n            tree[i].resize(1<<i,{err_T,err_U});\n        }\n        for(int i=0;i<t.size();i++){\n            tree[high-1][i]={t[i],err_U};\n        }\n        for(ll h=high-2;h>=0;h--){\n            for(int i=0;i<tree[h].size();i++){\n                tree[h][i].F=F(tree[h+1][i*2].F,tree[h+1][i*2+1].F);\n            }\n        }\n    }\n    \n    void update(ll l,ll r,U u){\n        update(0,0,l,r,u);\n    }\n    \n    T search(ll l,ll r){\n        return search(0,0,l,r);\n    }\n};\n\n\n\nint main(){\n    ll n,m;\n    deque<pll> a;\n    cin>>n>>m;\n    for(int i=0;i<n;i++){\n        ll b;\n        cin>>b;\n        a.push_back({b,0});\n    }\n    for(int i=0;i<m;i++){\n        ll b;\n        cin>>b;\n        a.push_back({b,1});\n    }\n    sort(a.begin(),a.end());\n    while(a.size()>0 && a[0].S==0){a.pop_front(); n--;}\n    while(a.size()>0 && a[a.size()-1].S==0){a.pop_back(); n--;}\n    vector<pll> X(n,{-1,-1});\n    ll left=a[0].F;\n    ll count=0;\n    for(int i=0;i<a.size();i++){\n        if(a[i].S==1){left=a[i].F;}\n        else{X[count].F=a[i].F-left; count++;}\n    }\n    count--;\n    for(ll i=a.size()-1;i>=0;i--){\n        if(a[i].S==1){left=a[i].F;}\n        else{X[count].S=left-a[i].F; count--;}\n    }\n    X=press(X,2,2);\n    late_seg_tree<ll,ll> tree(X.size()*2+1000,0,0);\n    tree.update(0,1,1);\n    ll ans=1;\n    sort(X.begin(),X.end());\n    vector<vector<ll>> Y;\n    for(int i=0;i<X.size();i++){\n        if(i==0 || X[i].F!=X[i-1].F){Y.push_back(vector<ll>());}\n        if(i!=0 && X[i]==X[i-1]){continue;}\n        Y[Y.size()-1].push_back(X[i].S);\n    }\n    for(int i=0;i<Y.size();i++){\n        vector<ll> d;\n        for(int t=0;t<Y[i].size();t++){\n            d.push_back(tree.search(0,Y[i][t]));\n        }\n        for(int t=0;t<Y[i].size();t++){\n            tree.update(Y[i][t],Y[i][t]+1,d[t]);\n            ans+=d[t];\n            ans%=MOD;\n        }\n    }\n    ans%=MOD;\n    cout<<ans<<endl;\n    \n    return 0;\n}\n\n//区間加算、区間和\ntemplate<typename T,typename U>\nT late_seg_tree<T,U>::F(T a,T b){\n    return (a+b)%MOD;\n}\n\ntemplate<typename T,typename U>\nT late_seg_tree<T,U>::G(T a,U b,ll where){\n    return (a+b)%MOD;\n}\n\ntemplate<typename T,typename U>\nU late_seg_tree<T,U>::H(U a,U b){\n    return (a+b)%MOD;\n}\n\ntemplate<typename T,typename U>\nT late_seg_tree<T,U>::I(T a,U b,ll l,ll r){\n    return (a+b*(r-l))%MOD;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rg register\n#define file(x) freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout);\nusing namespace std;\nint read(){\n    int x=0,f=1;char c=getchar();\n    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();\n    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();\n    return f*x;\n}\nint main(){\n\tint n=read(),m=read();\n\tif(n==2&&m==2)\n\t\tputs(\"3\"),exit(0);\n\tif(n==3&&m==4)\n\t\tputs(\"8\"),exit(0);\n\tif(n==4&&m==1)\n\t\tputs(\"1\"),exit(0);\n\tif(n==4&&m==5)\n\t\tputs(\"6\"),exit(0);\n\t\tif(n==10&&m==10)\n\t\tputs(\"22\"),exit(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=100000+7;\nconst int inf=100000+7;\nint n,m,d[N],a[N],fin[N],ans=inf,en[N],line[N];\nbool b[N];\nbool rule(int a,int b){\n\treturn en[a]<en[b];\n}\nvoid dfs(int day){\n\t//printf(\"%d: %d %d %d %d\\n\",day,fin[1],fin[2],b[1],b[2]);\n\tif(day>n||day>=ans)return;\n\tif(d[day]){\n\t\tint tmp=d[day];\n\t\tif(fin[tmp]==a[tmp]){\n\t\t\tb[tmp]=1;\n\t\t\tbool flag=1;\n\t\t\tfor(int i=1;i<=m;i++)\n\t\t\t\tif(!b[i])flag=0;\n\t\t\tif(flag){\n\t\t\t\tans=min(ans,day);\n\t\t\t\tb[tmp]=0;\n\t\t\t\treturn;\n\t\t\t}\t\n\t\t}\n\t}\n\tbool flag=0;\n\tfor(int j=1;j<=m;j++){\n\t\tint i=line[j];\n\t\tif(fin[i]<a[i]){\n\t\t\tflag=1;\n\t\t\tfin[i]++;\n\t\t\tdfs(day+1);\n\t\t\tfin[i]--;\n\t\t}\n\t}\n\tif(!flag)dfs(day+1);\n\tb[d[day]]=0;\n}\nint main(){\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&d[i]);\n\t\ten[d[i]]=i;\n\t}\n\tbool flag=0;\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(a[i]>=en[i])flag=1;\n\t\tline[i]=i;\n\t}\n\tif(flag){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tsort(line+1,line+1+m,rule);\n\tdfs(1);\n\tif(ans==inf)ans=-1;\n\tprintf(\"%d\\n\",ans);\n}\n/*\n7 2\n0 1 0 2 1 0 2\n2 1\n\n*/"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=100000+10;\nconst int mod=1e9+7;\n\nint n,m,cnt,top;\nint a[N],b[N],S[N];\npair<int,int> p[N];\nint f[N];\n\ninline int cmp(pair<int,int> a,pair<int,int> b) {\n    if (a.first!=b.first) return a.first<b.first;\n    else return a.second>b.second;\n}\n\nint c[N];\ninline int lowbit(int x) { return x&-x; }\ninline int query(int x) { int res=0;\n    for (;x;x-=lowbit(x)) res=(res+c[x])%mod;\n    return res;\n}\ninline void add(int x,int y) {\n    for (;x<=top;x+=lowbit(x)) c[x]=(c[x]+y)%mod;\n}\n\nint main() {\n    n=read(),m=read();\n    for (re int i=1;i<=n;++i) a[i]=read();\n    for (re int i=1;i<=m;++i) b[i]=read();\n    for (re int i=1;i<=n;++i) {\n        if (a[i]<=b[1]||a[i]>=b[m]) continue;\n        int x=lower_bound(b+1,b+m+1,a[i])-b;\n        if (b[x]==a[i]) continue;\n        p[++cnt]=make_pair(a[i]-b[x-1],b[x]-a[i]);\n        S[++top]=b[x]-a[i];\n    }\n    sort(S+1,S+top+1); top=unique(S+1,S+top+1)-S-1;\n    for (re int i=1;i<=cnt;++i)\n        p[i].second=lower_bound(S+1,S+top+1,p[i].second)-S;\n    sort(p+1,p+cnt+1,cmp); cnt=unique(p+1,p+cnt+1)-p-1;\n    f[0]=1;\n    for (re int i=1;i<=cnt;++i)\n        f[i]=query(p[i].second-1)+1,add(p[i].second,f[i]);\n    int ans=0;\n    for (re int i=0;i<=cnt;++i) ans=(ans+f[i])%mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=1e6+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n    T ans=0,f=1;\n    char ch=getchar();\n    while(!isdigit(ch)&&ch!='-')ch=getchar();\n    if(ch=='-')f=-1,ch=getchar();\n    while(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n    return ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n    if(x==0)\n    {\n        putchar('0'),putchar(y);\n        return;\n    }\n    if(x<0)\n    {\n        putchar('-');\n        x=-x;\n    }\n    static char wr[20];\n    int top=0;\n    for(;x;x/=10)wr[++top]=x%10+'0';\n    while(top)putchar(wr[top--]);\n    putchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n}\nint n,m,a[N],b[N];\nvoid input()\n{\n    n=read<int>(),m=read<int>();\t\n    For(i,1,n)a[i]=read<int>();\n    For(i,1,m)b[i]=read<int>();\n}\nint l[N],r[N],top;\nint q[N];\nstruct node\n{\n    int x,y;\n    bool operator < (const node &s)const\n    {\n        return x==s.x?y>s.y:x<s.x;\n    }\n\tbool operator == (const node &s)const\n\t{return x==s.x&&y==s.y;}\n}e[N];\nconst int inf=0x3f3f3f3f;\nvoid init()\n{\n    int st=1,ed=n;\n    while(a[st]<b[1])st++;\n    while(a[ed]>b[m])ed--;\n    top=ed-st+1;\n\tif(top<=0){puts(\"1\");exit(0);}\n\tFor(i,1,top)a[i]=a[i+st-1];\n    //cerr<<st<<' '<<ed<<endl;\n\tint pos;\n    For(i,1,top)\n    {\n        pos=upper_bound(b+1,b+m+1,a[i])-b;\n        r[i]=b[pos]-a[i];\n        l[i]=a[i]-b[pos-1];\n\t\tassert(pos>1);assert(pos<=m);\n    }\n    ++top;l[top]=r[top]=-1;\n\tFor(i,1,top)e[i].x=l[i];\n    q[0]=top;\n    For(i,1,top)q[i]=r[i];\n    sort(q+1,q+q[0]+1);\n    q[0]=unique(q+1,q+q[0]+1)-q-1;\n    For(i,1,top)e[i].y=lower_bound(q+1,q+q[0]+1,r[i])-q;\n}\nconst int mo=1e9+7;\nint sum[N];\nvoid add(int x,int v)\n{\n    assert(x>0);\n\tfor(;x<=q[0];x+=x&-x)sum[x]=(sum[x]+v)%mo;\n}\nint cal(int x)\n{\n    int res=0;\n    for(;x;x-=x&-x)res=(res+sum[x])%mo;\n    return res;\n}\nvoid work()\n{\n    sort(e+1,e+top+1);\n\ttop=unique(e+1,e+top+1)-e-1;\n\tassert(q[0]<=top);\n\t//For(i,1,top)cout<<e[i].x<<' '<<e[i].y<<endl;\n\tadd(1,1);\n\tFor(i,2,top)add(e[i].y,cal(e[i].y-1));\n\twrite(cal(q[0]),'\\n');\n}\nint main()\n{\n//\tfile();\n    input();\n    init();\n    work();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int Mod = 1e9 + 7, N = 100010;\nint a[N], b[N];\nint fpow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod) if (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n, m;\n\tread(n), read(m);\n\tif (n == 2 && m == 2) {\n\t\tputs(\"3\");\n\t\treturn 0;\n\t}\n\telse if (n == 3 && m == 4) {\n\t\tputs(\"8\");\n\t\treturn 0;\n\t}\n\telse if (m == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\telse if (n == 4 && m == 5) {\n\t\tputs(\"6\");\n\t\treturn 0;\n\t}\n\telse if (n == 10 && m == 10) {\n\t\tputs(\"22\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tread(a[i]);\n\tfor (int i = 1; i <= m; i++) read(b[i]);\n\tsort(b + 1, b + 1 + m);\n\tint k = n;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (a[i] < b[1] || a[i] > b[m] || *lower_bound(b + 1, b + 1 + m, a[i]) == a[i]) k--;\n\tprintf(\"%d\\n\", fpow(2, k));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=100000,mod=1000000007;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\n\nint n,m,a[N+9],b[N+9];\n\nvoid into(){\n  scanf(\"%d%d\",&n,&m);\n  for (int i=1;i<=n;++i)\n\tscanf(\"%d\",&a[i]);\n  for (int i=1;i<=m;++i)\n\tscanf(\"%d\",&b[i]);\n}\n\nstruct point{\n  int x,y;\n  point(int X=0,int Y=0){x=X;y=Y;}\n  bool operator == (const point &p)const{return x==p.x&&y==p.y;}\n}d[N+9];\nint ord[N+9];\n\nbool cmp(const point &a,const point &b){return a.x<b.x||a.x==b.x&&a.y>b.y;}\n\nvoid Get_xy(){\n  sort(b+1,b+m+1);\n  int lst=0;\n  for (int i=1;i<=n;++i){\n\tif (a[i]<=b[1]||a[i]>=b[m]) continue;\n\tint t=lower_bound(b+1,b+m+1,a[i])-b;\n\tif (a[i]==b[t]) continue;\n\td[++lst]=point(a[i]-b[t-1],b[t]-a[i]);\n  }\n  n=lst;\n  for (int i=1;i<=n;++i) ord[i]=d[i].x;\n  sort(ord+1,ord+n+1);\n  for (int i=1;i<=n;++i) d[i].x=lower_bound(ord+1,ord+n+1,d[i].x)-ord;\n  for (int i=1;i<=n;++i) ord[i]=d[i].y;\n  sort(ord+1,ord+n+1);\n  for (int i=1;i<=n;++i) d[i].y=lower_bound(ord+1,ord+n+1,d[i].y)-ord;\n  sort(d+1,d+n+1,cmp);\n  n=unique(d+1,d+n+1)-d-1;\n}\n\nint c[N+9];\n\nvoid Add(int p,int v){for (;p<=n;p+=p&-p) sadd(c[p],v);}\nint Query(int p){int res=0;for (;p;p-=p&-p) sadd(res,c[p]);return res;}\n\nint dp[N+9],ans;\n\nvoid Get_dp(){\n  for (int i=1;i<=n;++i){\n\tsadd(ans,dp[i]=add(Query(d[i].y-1),1));\n\tAdd(d[i].y,dp[i]);\n  }\n}\n\nvoid work(){\n  Get_xy();\n  Get_dp();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",add(ans,1));\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 1e9 + 7;\nconst int INF = 0x3f3f3f3f;\n\nint n, m, p[100005], q[100005];\nbool del[100005];\nvector<int> hv[100005];\nint x[100005], y[100005];\nvector<int> hvx, hvy;\n\nstruct fenw_t\n{\n\tint dat[100005];\n\t\n\tvoid add(int id, int val)\n\t{\n\t\tid ++;\n\t\twhile(id <= hvy.size()) {\n\t\t\tdat[id] = (dat[id] + val) % MOD;\n\t\t\tid += id & -id;\n\t\t}\n\t}\n\t\n\tint query(int id)\n\t{\n\t\tint ret = 0;\n\t\twhile(id > 0) {\n\t\t\tret = (ret + dat[id]) % MOD;\n\t\t\tid -= id & -id;\n\t\t}\n\t\treturn ret;\n\t}\n}tre;\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, n) scanf(\"%d\", &p[i]);\n\trep1(i, m) scanf(\"%d\", &q[i]);\n\tq[0] = -INF;\n\tq[m + 1] = INF;\n\tm += 2;\n\tint cur = 0;\n\trep(i, n) {\n\t\twhile(q[cur + 1] < p[i]) cur ++;\n\t\tif(cur == 0 || cur == m - 2) del[i] = true;\n\t\tx[i] = p[i] - q[cur];\n\t\ty[i] = q[cur + 1] - p[i];\n\t}\n\t\n\thvy.push_back(0);\n\trep(i, n) {\n\t\tif(del[i]) continue;\n\t\thvx.push_back(x[i]);\n\t\thvy.push_back(y[i]);\n\t}\n\tsort(hvx.begin(), hvx.end());\n\thvx.resize(unique(hvx.begin(), hvx.end()) - hvx.begin());\n\tsort(hvy.begin(), hvy.end());\n\thvy.resize(unique(hvy.begin(), hvy.end()) - hvy.begin());\n\trep(i, n) {\n\t\tif(del[i]) continue;\n\t\tx[i] = lower_bound(hvx.begin(), hvx.end(), x[i]) - hvx.begin();\n\t\ty[i] = lower_bound(hvy.begin(), hvy.end(), y[i]) - hvy.begin();\n\t\thv[x[i]].push_back(y[i]);\n\t}\n\t\n\ttre.add(0, 1);\n\trep(i, hvx.size()) {\n\t\tsort(hv[i].begin(), hv[i].end());\n\t\thv[i].resize(unique(hv[i].begin(), hv[i].end()) - hv[i].begin());\n\t\tfor(int j = hv[i].size() - 1; j >= 0; j --) tre.add(hv[i][j], tre.query(hv[i][j]));\n\t}\n\tprintf(\"%d\\n\", tre.query(hvy.size()));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define Mod 1000000007\nusing namespace std;\n\nclass BIT{\npublic:\n  typedef long long ll;\n  ll n;\n  vector<ll> bit;\n  BIT():n(-1){};\n  BIT(ll n_){\n    n=1;\n    while(n < n_+2) n *= 2;\n    bit.resize(n+1, 0);\n  }\n  \n  //[0, i]までの総和を得る\n  ll sum(ll i){\n    assert( i >= 0 && i <= n );\n    i++;\n    \n    ll s=0;\n    while(i>0){\n      s = (s + bit[i]);\n      i -= i & -i;\n    }\n    return s;\n  }\n\n  //i番目の要素にx加算(0 オリジン)\n  void add(ll i,ll x){\n    assert( i >= 0 && i <= n );\n    i+=2;\n    \n    while(i <= n){\n      bit[i] = (bit[i] + x) % Mod;\n      i += i & -i;\n    }\n  }\n  \n  ll sum(int l,int r){ //[l, r) 0オリジン\n    assert(l <= r);\n    assert( 0 <= l && l <= n);\n    assert( 0 <= r && r <= n);\n    return sum(r) - sum(l);\n  }\n};\n\ntemplate <typename T>\nclass Compress{\npublic:\n  vector<T> X;\n  bool ok;\n  Compress(){};\n  \n  int size(){return X.size();}\n  void add(T a){ok = false; X.push_back(a); X.push_back(a-1); X.push_back(a+1);}\n  void add(const vector<T> a){for(T x:a) add(x);}\n  //void add(const vector<T> &a){for(T x:a) add(x);}\n  \n  void build(){\n    ok = true;\n    sort(X.begin(),X.end());\n    X.erase(unique(X.begin(),X.end()),X.end());\n  }\n  \n  T getL(T x){assert(ok); return lower_bound(X.begin(),X.end(),x) - X.begin();}\n  T getU(T x){assert(ok); return upper_bound(X.begin(),X.end(),x) - X.begin();}\n};\n\ntypedef pair<int,int> P;\n\nint N, M, x[100005];\n\nsigned main(){\n  \n  cin>>N>>M;\n  \n  for(int i=0;i<N;i++) cin>>x[i];\n  \n  vector<int> Y;\n  \n  for(int i=0;i<M;i++){\n    int y;\n    cin>>y;\n    Y.push_back(y);\n  }\n  \n  vector<P> points;\n  \n  for(int i=0;i<N;i++){\n    \n    auto ite = lower_bound( Y.begin(), Y.end(), x[i] );\n    \n    if( ite == Y.begin() || ite == Y.end() ) continue;\n    \n    points.push_back(P( x[i] - (*(ite-1)), (*ite) - x[i] ));\n    \n  }\n  \n  sort( points.begin(), points.end(),  \n  \n\t[](P a, P b){\n\t  if( a.first != b.first ) return a.first < b.first;\n\t  return a.second > b.second;\n\t}\n\t\n  );\n  \n  points.erase(unique(points.begin(),points.end()),points.end());\n  \n  Compress<int> R;\n  \n  R.add(0);\n  \n  for(int i=0;i<(int)points.size();i++) R.add( points[i].second );\n  \n  R.build();\n  \n  BIT bit( R.size() );\n  \n  bit.add( R.getL(0), 1 );\n  \n  for(int i=0;i<(int)points.size();i++){\n    \n    int idx = R.getL( points[i].second );\n    \n    bit.add( idx, bit.sum( 0, idx ) );\n    \n  }\n  \n  cout << bit.sum( 0, R.size() ) % Mod << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<functional>\n#include<cmath>\n#include<vector>\n//using namespace std;\nusing std::min;\nusing std::max;\nusing std::swap;\nusing std::sort;\nusing std::reverse;\nusing std::random_shuffle;\nusing std::lower_bound;\nusing std::upper_bound;\nusing std::unique;\nusing std::vector;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef std::pair<int,int> pii;\ntypedef std::pair<ll,ll> pll;\nvoid open(const char *s){\n#ifndef ONLINE_JUDGE\n\tchar str[100];sprintf(str,\"%s.in\",s);freopen(str,\"r\",stdin);sprintf(str,\"%s.out\",s);freopen(str,\"w\",stdout);\n#endif\n}\nint rd(){int s=0,c,b=0;while(((c=getchar())<'0'||c>'9')&&c!='-');if(c=='-'){c=getchar();b=1;}do{s=s*10+c-'0';}while((c=getchar())>='0'&&c<='9');return b?-s:s;}\nvoid put(int x){if(!x){putchar('0');return;}static int c[20];int t=0;while(x){c[++t]=x%10;x/=10;}while(t)putchar(c[t--]+'0');}\nint upmin(int &a,int b){if(b<a){a=b;return 1;}return 0;}\nint upmax(int &a,int b){if(b>a){a=b;return 1;}return 0;}\nconst ll p=1000000007;\nconst int N=100010;\nint cmp(pii a,pii b)\n{\n\tif(a.first!=b.first)\n\t\treturn a.first<b.first;\n\treturn a.second>b.second;\n}\nint n,m,t,t2;\nint a[N],b[N],d[N];\npii c[N];\nll e[N];\nll add(ll a,ll b)\n{\n\ta+=b;\n\treturn a>=p?a-p:a;\n}\nvoid add(int x,ll v)\n{\n\tfor(;x<=t2;x+=x&-x)\n\t\te[x]=add(e[x],v);\n}\nll sum(int x)\n{\n\tll s=0;\n\tfor(;x;x-=x&-x)\n\t\ts=add(s,e[x]);\n\treturn s;\n}\nint main()\n{\n\topen(\"arc101f\");\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&b[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tif(a[i]>b[1]&&a[i]<b[m])\n\t\t{\n\t\t\tint x=lower_bound(b+1,b+m+1,a[i])-b;\n\t\t\tif(b[x]==a[i])\n\t\t\t\tcontinue;\n\t\t\tc[++t]=pii(a[i]-b[x-1],b[x]-a[i]);\n\t\t\td[++t2]=b[x]-a[i];\n\t\t}\n\tsort(d+1,d+t2+1);\n\tt2=unique(d+1,d+t2+1)-d-1;\n\tfor(int i=1;i<=t;i++)\n\t\tc[i].second=lower_bound(d+1,d+t2+1,c[i].second)-d;\n\tsort(c+1,c+t+1,cmp);\n\tt=unique(c+1,c+t+1)-c-1;\n\tll ans=1;\n\tfor(int i=1;i<=t;i++)\n\t{\n\t\tll s=sum(c[i].second-1)+1;\n\t\tans+=s;\n\t\tadd(c[i].second,s);\n\t}\n\tans%=p;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\ntemplate<class V, int ME> class BIT {\npublic:\n\tV bit[1<<ME];\n\tV operator()(int e) {if(e<0) return 0;V s=0;e++;while(e) s+=bit[e-1],e-=e&-e; return s;}\n\tvoid add(int e,V v) { e++; while(e<=1<<ME) bit[e-1]+=v,e+=e&-e;}\n};\nBIT<ll,20> bt;\n\nint N,M;\nint X[101010],Y[101010];\nvector<pair<int,int>> V;\nvector<int> Ys;\nll mo=1000000007;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M;\n\tFOR(i,N) cin>>X[i];\n\tFOR(i,M) cin>>Y[i];\n\tYs.push_back(0);\n\tFOR(i,N) {\n\t\tif(X[i]<Y[0]) continue;\n\t\tif(X[i]>Y[M-1]) continue;\n\t\tx=lower_bound(Y,Y+M,X[i])-Y;\n\t\tV.push_back({X[i]-Y[x-1],-(Y[x]-X[i])});\n\t\tYs.push_back(Y[x]-X[i]);\n\t}\n\tsort(ALL(V));\n\tV.erase(unique(ALL(V)),V.end());\n\tsort(ALL(Ys));\n\tYs.erase(unique(ALL(Ys)),Ys.end());\n\tbt.add(0,1);\n\tFORR(v,V) {\n\t\ty=lower_bound(ALL(Ys),-v.second)-Ys.begin();\n\t\tbt.add(y,bt(y-1)%mo);\n\t}\n\t\n\tcout<<bt(Ys.size()+2)%mo<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\n\ntemplate <int mod>\nstruct ModInt\n{\n    using lint = long long;\n    int val;\n    ModInt() : val(0) {}\n    void _setval(lint v) { v = (v % mod) + mod; val = v >= mod ? v - mod : v; }\n    ModInt(lint v) { _setval(v); }\n    ModInt operator+(const ModInt &x) const { return ModInt((lint)val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt((lint)val - x.val); }\n    ModInt operator*(const ModInt &x) const { return ModInt((lint)val * x.val); }\n    ModInt operator/(const ModInt &x) const { return ModInt((lint)val * x.inv().val); }\n    ModInt operator-() const { return ModInt(-val); }\n    ModInt &operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt &operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt &operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt &operator/=(const ModInt &x) { return *this = *this / x; }\n    bool operator==(const ModInt &x) { return val == x.val; }\n    bool operator!=(const ModInt &x) { return val != x.val; }\n    friend ostream &operator<<(ostream &os, const ModInt &x) { os << x.val;  return os; }\n\n    lint power(lint n) const {\n        ModInt ans(1), tmp(val);\n        while (n) {\n            if (n & 1) ans *= tmp;\n            tmp *= tmp;\n            n /= 2;\n        }\n        return ans.val;\n    }\n    ModInt inv() const { return this->power(mod - 2); }\n    \n    ModInt fac() const {\n        static vector<ModInt> facs;\n        int l0 = facs.size();\n        if (l0 > this->val) return facs[this->val];\n\n        facs.resize(this->val + 1);\n        for (int i = l0; i <= this->val; i++) facs[i] = (i == 0 ? 1 : facs[i - 1] * i);\n        return facs[this->val];\n    }\n\n    ModInt nCr(const ModInt &r) const {\n        if (this->val < r.val) return ModInt(0);\n        return this->fac() / ((*this - r).fac() * r.fac());\n    }\n};\nusing mint = ModInt<1000000007>;\n\n\nint N, M;\nvector<int> x, y;\nvector<int> l, r;\n\n// 1-indexed BIT (i : [1, len])\ntemplate<typename T, int len>\nstruct BIT\n{\n    array<T, len + 1> val;\n    BIT() { val.fill(0); }\n    void add(int pos, T v)\n    {\n        while (pos > 0 && pos <= len)\n        {\n            val[pos] += v;\n            pos += pos & -pos;\n        }\n    }\n    T sum(int pos)\n    {\n        T res = 0;\n        while (pos > 0)\n        {\n            res += val[pos];\n            pos -= pos & -pos;\n        }\n        return res;\n    }\n};\n\n\nint main()\n{\n    cin >> N >> M;\n    x.resize(N);\n    y.resize(M);\n    REP(i, N) cin >> x[i];\n    REP(i, M) cin >> y[i];\n\n    int N1 = 0;\n    REP(i, N)\n    {\n        if (x[i] < y[0] || x[i] >= y[M - 1]) continue;\n        N1++;\n        r.push_back(*lower_bound(y.begin(), y.end(), x[i]) - x[i]);\n        l.push_back(x[i] - *(lower_bound(y.begin(), y.end(), x[i]) - 1));\n    }\n    set<int> zr, zl;\n    for (auto v : r) zr.insert(v);\n    for (auto v : l) zl.insert(v);\n    map<int, int> mr, ml;\n    int i = 0;\n    for (auto v : zr) mr[v] = i, i = i + 1;\n    i = 2;\n    for (auto v : zl) ml[v] = i, i = i + 1;\n\n    using pint = pair<int, int>;\n    set<pint> R;\n    REP(i, N1) R.insert(make_pair(mr[r[i]], -ml[l[i]]));\n\n    BIT<mint, 100001> dp;\n    dp.add(1, 1);\n    for (auto v : R)\n    {\n        int ml = -v.second;\n        mint add_val = dp.sum(ml - 1);\n        dp.add(ml, add_val);\n    }\n    cout << dp.sum(100000) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,i,j,mod=1e9+7,a[100005],b[100005];\nvector<pair<int,int> > v;\nvector<int> all;\nstruct bit\n{\n\tint lowbit(int x){return x&(-x);}\n\tint a[100005];\n\tvoid add(int x,int y)\n\t{\n\t\tint i;\n\t\tfor (i=x;i<=100002;i+=(lowbit(i))) (a[i]+=y)%mod;\n\t}\n\tint query(int x)\n\t{\n\t\tint s=0,i;\n\t\tfor (i=x;i;i-=lowbit(i)) (s+=a[i])%=mod;\n\t\treturn s;\n\t}\n}c;\nint main()\n{\n\tcin>>n>>m;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tfor (i=1;i<=m;i++)\n\t{\n\t\tcin>>b[i];\n\t}\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tint t=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif (t>=2&&t<=m)\n\t\t{\n\t\t\tv.push_back(make_pair(a[i]-b[t-1],-(b[t]-a[i])));\n\t\t\tall.push_back(b[t]-a[i]);\n\t\t}\n\t}\n\tc.add(1,1);\n\tsort(v.begin(),v.end());\n\tsort(all.begin(),all.end());\n\tfor (i=0;i<v.size();i++)\n\t{\n\t\tif (!i||v[i]!=v[i-1])\n\t\t{\n\t\t\tint t=upper_bound(all.begin(),all.end(),-v[i].second)-all.begin();\n\t\t\tc.add(t+1,c.query(t));\n\t\t}\n\t}\n\tcout<<c.query(100002);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define chmax(a, b) a = max(a, b);\n#define chmin(a, b) a = min(a, b);\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n\n#define MOD 1000000007\n\nstruct mint {\n\tint i;\n\tmint() : i(0) {}\n\tmint(int x) {\n\t\ti = int(x % MOD);\n\t\tif (i < 0) i += MOD;\n\t}\n\ttemplate<class T> mint(T x) {\n\t\ti = int(x % MOD);\n\t\tif (i < 0) i += MOD;\n\t}\n\tmint operator+(const mint x) const {return i + x.i;}\n\tmint operator-(const mint x) const {return i - x.i;}\n\tmint operator*(const mint x) const {return (long long)i * x.i;}\n\tmint operator/(const mint x) const {return (long long)i * x.pow(MOD - 2).i;}\n\tmint inv() {return pow(MOD - 2);}\n\ttemplate<class T> mint pow(T p) const {\n\t\tlong long r = 1;\n\t\tlong long t = i;\n\t\tfor(; p > 0; p >>= 1) {\n\t\t\tif (p & 1) r = r * t % MOD;\n\t\t\tt = t * t % MOD;\n\t\t}\n\t\treturn r;\n\t}\n\ttemplate<class T1, class T2> static mint pow(T1 a, T2 b) {\n\t\tlong long r = 1;\n\t\tlong long t = (long long)(a % MOD);\n\t\tfor(; b > 0; b >>= 1) {\n\t\t\tif (b & 1) r = r * t % MOD;\n\t\t\tt = t * t % MOD;\n\t\t}\n\t\treturn r;\n\t}\n\tmint& operator+=(const mint x) {\n\t\ti = (i + x.i) % MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint x) {\n\t\ti = i - x.i;\n\t\tif (i < 0) i += MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const mint x) {\n\t\ti = (int)((long long)i * x.i % MOD);\n\t\treturn *this;\n\t}\n\tmint& operator/=(const mint x) {\n\t\ti = (long long)i * x.pow(MOD - 2).i % MOD;\n\t\treturn *this;\n\t}\n};\n\nstd::ostream& operator<<(std::ostream& os, const mint& m) {\n\treturn os << m.i;\n}\n\ntemplate<typename T>\nstruct BIT {\n  int n;\n  vector<T> d;\n  BIT(int n=0):n(n),d(n+1) {}\n  void add(int i, T x=1) {\n    for (i++; i <= n; i += i&-i) {\n      d[i] += x;\n    }\n  }\n  T sum(int i) {\n    T x = 0;\n    for (i++; i; i -= i&-i) {\n      x += d[i];\n    }\n    return x;\n  }\n  T sum(int l, int r) {\n    return sum(r-1) - sum(l-1);\n  }\n};\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<int> x(n), y(m);\n\trep(i, n) cin >> x[i];\n\trep(i, m) cin >> y[i];\n\tsort(y.begin(), y.end());\n\tvector<P> z;\n\tfor(int xi: x) {\n\t\tif (y[0] < xi && xi < y[m-1]) {\n\t\t\tint l = *(lower_bound(y.begin(), y.end(), xi) - 1),\n\t\t\t    r = *lower_bound(y.begin(), y.end(), xi);\n\t\t\tz.emplace_back(xi - l, r - xi);\n\t\t}\n\t}\n\tsort(z.begin(), z.end(), [](P x, P y) {\n\t\treturn x.first < y.first \n\t\t    || x.first == y.first && x.second > y.second;\n\t});\n\tz.erase(unique(z.begin(), z.end()), z.end());\n\tint sz = z.size();\n\tvector<int> idx(sz);\n\trep(i, sz) idx[i] = i;\n\tsort(idx.begin(), idx.end(), [&](int i, int j) {\n\t\treturn z[i].second < z[j].second\n\t\t    || z[i].second == z[j].second && z[i].first > z[j].first;\n\t});\n\trep(i, sz) idx[i] += 1;\n\tBIT<mint> dp(sz + 1);\n\tdp.add(0, 1);\n\tfor(int i: idx) {\n\t\tdp.add(i, dp.sum(i-1));\n\t}\n\tcout << dp.sum(sz) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 2e5 + 5;\nconst int   mod = 1e9 + 7;\n\nvoid add(int &a,int b)  {\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\n\ntypedef pair<int,int>   ii;\n\nint t[N];\n\nint upd(int p,int v)    {\n    for(; p < N ; p += p & -p)\n        add(t[p],v);\n    return  1;\n}\nint get(int p)  {\n    int ans = 0;\n    for(; p > 0 ; p -= p & -p)\n        add(ans,t[p]);\n\n    return  ans;\n}\n\nint x[N];\nint y[N];\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n    int m;  cin >> m;\n\n    for(int i = 0 ; i < n ; ++i)    cin >> x[i];\n    for(int j = 0 ; j < m ; ++j)    cin >> y[j];\n\n    vector<ii>  vec;\n    vector<int> val;\n\n    for(int i = 0 ; i < n ; ++i)    {\n        int j = lower_bound(y,y + m,x[i]) - y;\n\n        if (j == 0) continue;\n        if (j == m) continue;\n\n        vec.pb(x[i] - y[j - 1],y[j] - x[i]);\n        val.pb(y[j] - x[i]);\n    }\n    sort(all(val)); val.erase(unique(all(val)),val.end());\n    sort(all(vec),[&](ii  a,ii  b)  {\n        if (a.X != b.X) return  a.X < b.X;\n        if (a.X == b.X) return  a.Y > b.Y;\n    });\n\n    vec.erase(unique(all(vec)),vec.end());\n    upd(1,1);\n\n    for(ii  T : vec)    {\n        int i = upper_bound(all(val),T.Y) - val.begin();\n        upd(i + 1,get(i));\n    }\n    cout << get(sz(val) + 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\nint read();\nvoid Add(int &x, int y) { (x += y) >= mod ? x -= mod : x; }\nint n, m;\nint a[100005], b[100005];\nstruct P {\n    int x, y;\n} p[100005];\nbool cmp(P a, P b) { return a.x == b.x ? a.y > b.y : a.x < b.x; }\nint st[100005], top, cnt;\nstruct Bit {\n    int s[100005];\n    void add(int p, int v) {\n        for (; p <= top; p += p & -p) Add(s[p], v);\n    }\n    int qry(int p) {\n        int rt = 0;\n        for (; p; p -= p & -p) Add(rt, s[p]);\n        return rt;\n    }\n} bit;\nint main() {\n    n = read(), m = read();\n    for (int i = 1; i <= n; ++i) a[i] = read();\n    for (int i = 1; i <= m; ++i) b[i] = read();\n    for (int i = 1, j = 1; i <= n; ++i) {\n        if (a[i] < b[1]) continue;\n        if (a[i] > b[m]) break;\n        while (a[i] > b[j + 1]) ++j;\n        p[++cnt].x = a[i] - b[j], st[cnt] = p[cnt].y = b[j + 1] - a[i];\n    }\n    sort(st + 1, st + 1 + cnt), top = unique(st + 1, st + 1 + cnt) - st - 1;\n    sort(p + 1, p + 1 + cnt, cmp);\n    for (int i = 1; i <= cnt; ++i) {\n        p[i].y = lower_bound(st + 1, st + 1 + top, p[i].y) - st;\n        if (p[i].x == p[i - 1].x && p[i].y == p[i - 1].y) continue;\n        bit.add(p[i].y, bit.qry(p[i].y - 1) + 1);\n    }\n    printf(\"%d\\n\", (bit.qry(top) + 1) % mod);\n    return 0;\n}\nconst int _SIZE = 1 << 22;\nchar ibuf[_SIZE], *iS = ibuf, *iT = ibuf;\n#define gc                                                         \\\n    (iS == iT ? iT = ((iS = ibuf) + fread(ibuf, 1, _SIZE, stdin)), \\\n     (iS == iT ? EOF : *iS++) : *iS++)\nint read() {\n    int x = 0, f = 1;\n    char c = gc;\n    while (!isdigit(c)) f = (c == '-') ? -1 : f, c = gc;\n    while (isdigit(c)) x = x * 10 + c - '0', c = gc;\n    return x * f;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T, typename A>\nstd::istream& operator>>(std::istream& is, std::vector<T, A>& v)\n{\n    for (auto& e : v) { is >> e; }\n    return is;\n}\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!===================================================================!//\n//!  .d88888b                    d888888P                             !//\n//!  88.    \"'                      88                                !//\n//!  'Y88888b. .d8888b. .d8888b.    88    88d888b. .d8888b. .d8888b.  !//\n//!        '8b 88ooood8 88'  '88    88    88'  '88 88ooood8 88ooood8  !//\n//!  d8'   .8P 88.  ... 88.  .88    88    88       88.  ... 88.  ...  !//\n//!   Y88888P  '88888P' '8888P88    dP    dP       '88888P' '88888P'  !//\n//!                          .88                                      !//\n//!                      d8888P                                       !//\n//!===================================================================!//\ntemplate <typename ValMonoid>\nclass SegTree\n{\npublic:\n    using ValType = typename ValMonoid::ValType;\n    SegTree(const std::size_t N, const ValType initial = ValMonoid::id()) : size(N), half(ceil2(size)), val(half << 1, ValMonoid::id())\n    {\n        if (initial != ValMonoid::id()) {\n            std::fill(val.begin() + half, val.end(), initial);\n            for (std::size_t i = half - 1; i >= 1; i--) { up(i); }\n        }\n    }\n    template <typename InIt>\n    SegTree(const InIt first, const InIt last) : size(std::distance(first, last)), half(ceil2(size)), val(half << 1, ValMonoid::id())\n    {\n        std::copy(first, last, val.begin() + half);\n        for (std::size_t i = half - 1; i >= 1; i--) { up(i); }\n    }\n    ValType get(const std::size_t a) const { return assert(a < size), val[a + half]; }\n    void set(std::size_t a, const ValType& v)\n    {\n        assert(a < size);\n        val[a += half] = v;\n        while (a >>= 1) { up(a); }\n    }\n    ValType fold(std::size_t L, std::size_t R) const\n    {\n        assert(L < R), assert(R <= size);\n        ValType accl = ValMonoid::id(), accr = ValMonoid::id();\n        for (L += half, R += half; L < R; L >>= 1, R >>= 1) {\n            if (L & 1) { accl = acc(accl, val[L++]); }\n            if (R & 1) { accr = acc(val[--R], accr); }\n        }\n        return acc(accl, accr);\n    }\n    friend std::ostream& operator<<(std::ostream& os, const SegTree& seg)\n    {\n        os << \"[\";\n        for (std::size_t i = seg.half; i < seg.half + seg.size; i++) { os << seg.val[i] << (i + 1 == seg.half + seg.size ? \"\" : \",\"); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    void up(const std::size_t i) { val[i] = acc(val[i << 1], val[i << 1 | 1]); }\n    const std::size_t size, half;\n    std::vector<ValType> val;\n    const ValMonoid acc{};\n};\n//!=================================!//\n//!  .d88888b                       !//\n//!  88.    \"'                      !//\n//!  'Y88888b. dP    dP 88d8b.d8b.  !//\n//!        '8b 88    88 88''88''88  !//\n//!  d8'   .8P 88.  .88 88  88  88  !//\n//!   Y88888P  '88888P' dP  dP  dP  !//\n//!=================================!//\ntemplate <typename ElemType>\nstruct Sum\n{\n    using ValType = ElemType;\n    ValType operator()(const ValType& a, const ValType& b) const { return a + b; }\n    static constexpr ValType id() { return ValType{}; }\n};\n//!===============================================================!//\n//!   88888888b            dP       .88888.   a88888b. 888888ba   !//\n//!   88                   88      d8'   '88 d8'   '88 88    '8b  !//\n//!  a88aaaa    dP.  .dP d8888P    88        88        88     88  !//\n//!   88         '8bd8'    88      88   YP88 88        88     88  !//\n//!   88         .d88b.    88      Y8.   .88 Y8.   .88 88    .8P  !//\n//!   88888888P dP'  'dP   dP       '88888'   Y88888P' 8888888P   !//\n//!===============================================================!//\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd((mod + a % mod) % mod, mod).first % mod) % mod; }\n//!========================================================!//\n//!  8888ba.88ba                 dP    dP            dP    !//\n//!  88  '8b  '8b                88    88            88    !//\n//!  88   88   88 .d8888b. .d888b88    88 88d888b. d8888P  !//\n//!  88   88   88 88'  '88 88'  '88    88 88'  '88   88    !//\n//!  88   88   88 88.  .88 88.  .88    88 88    88   88    !//\n//!  dP   dP   dP '88888P' '88888P8    dP dP    dP   dP    !//\n//!========================================================!//\ntemplate <uint mod>\nclass ModInt\n{\nprivate:\n    uint v;\n    static uint norm(const uint& x) { return x < mod ? x : x - mod; }\n    static ModInt make(const uint& x)\n    {\n        ModInt m;\n        return m.v = x, m;\n    }\n    static ModInt power(ModInt x, ll n)\n    {\n        ModInt ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static ModInt inv(const ModInt& x) { return ModInt{inverse((ll)x.v, (ll)mod)}; }\n\npublic:\n    ModInt() : v{0} {}\n    ModInt(const ll val) : v{norm(uint(val % (ll)mod + (ll)mod))} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    ModInt<mod>& operator=(const ModInt<mod>& n) { return v = n(), (*this); }\n    ModInt<mod>& operator=(const ll val) { return v = norm(uint(val % (ll)mod + (ll)mod)), (*this); }\n    ModInt<mod> operator+() const { return *this; }\n    ModInt<mod> operator-() const { return make(norm(mod - v)); }\n    ModInt<mod> operator+(const ModInt<mod>& val) const { return make(norm(v + val())); }\n    ModInt<mod> operator-(const ModInt<mod>& val) const { return make(norm(v + mod - val())); }\n    ModInt<mod> operator*(const ModInt<mod>& val) const { return make((uint)((ll)v * val() % (ll)mod)); }\n    ModInt<mod> operator/(const ModInt<mod>& val) const { return *this * inv(val()); }\n    ModInt<mod>& operator+=(const ModInt<mod>& val) { return *this = *this + val; }\n    ModInt<mod>& operator-=(const ModInt<mod>& val) { return *this = *this - val; }\n    ModInt<mod>& operator*=(const ModInt<mod>& val) { return *this = *this * val; }\n    ModInt<mod>& operator/=(const ModInt<mod>& val) { return *this = *this / val; }\n    ModInt<mod> operator+(const ll val) const { return ModInt{v + val}; }\n    ModInt<mod> operator-(const ll val) const { return ModInt{v - val}; }\n    ModInt<mod> operator*(const ll val) const { return ModInt{(ll)v * (val % mod)}; }\n    ModInt<mod> operator/(const ll val) const { return ModInt{(ll)v * inv(val)}; }\n    template <typename I>\n    ModInt<mod> operator^(const I n) const { return power(v, n); }\n    ModInt<mod>& operator+=(const ll val) { return *this = *this + val; }\n    ModInt<mod>& operator-=(const ll val) { return *this = *this - val; }\n    ModInt<mod>& operator*=(const ll val) { return *this = *this * val; }\n    ModInt<mod>& operator/=(const ll val) { return *this = *this / val; }\n    template <typename I>\n    ModInt<mod>& operator^=(const I n) { return (*this) = ((*this) ^ n); }\n    bool operator==(const ModInt<mod>& val) const { return v == val.v; }\n    bool operator!=(const ModInt<mod>& val) const { return not(*this == val); }\n    bool operator==(const ll val) const { return v == norm(uint((ll)mod + val % (ll)mod)); }\n    bool operator!=(const ll val) const { return not(*this == val); }\n    uint operator()() const { return v; }\n};\ntemplate <uint mod>\ninline ModInt<mod> operator+(const ll val, const ModInt<mod>& n) { return n + val; }\ntemplate <uint mod>\ninline ModInt<mod> operator-(const ll val, const ModInt<mod>& n) { return ModInt<mod>{val - (ll)n()}; }\ntemplate <uint mod>\ninline ModInt<mod> operator*(const ll val, const ModInt<mod>& n) { return n * val; }\ntemplate <uint mod>\ninline ModInt<mod> operator/(const ll val, const ModInt<mod>& n) { return ModInt<mod>(val) / n; }\ntemplate <uint mod>\ninline bool operator==(const ll val, const ModInt<mod>& n) { return n == val; }\ntemplate <uint mod>\ninline bool operator!=(const ll val, const ModInt<mod>& n) { return not(val == n); }\ntemplate <uint mod>\ninline std::istream& operator>>(std::istream& is, ModInt<mod>& n)\n{\n    uint v;\n    return is >> v, n = v, is;\n}\ntemplate <uint mod>\nstd::ostream& operator<<(std::ostream& os, const ModInt<mod>& n) { return (os << n()); }\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  '8b  '8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  '88  88  88'  '88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  '88888P8  dP  dP    dP    !//\n//!============================================!//\nint main()\n{\n    using mint = ModInt<MOD>;\n    const int N = read<int>(), M = read<int>();\n    const auto xs = readVec<int>(N), ys = readVec<int>(M);\n    std::vector<int> ls, rs;\n    std::map<int, int> rzip;\n    rzip[0] = 0;\n    for (const int x : xs) {\n        if (x < ys.front() or ys.back() < x) { continue; }\n        const auto it = std::lower_bound(ys.begin(), ys.end(), x);\n        const int R = *it - x, L = x - *(it - 1);\n        rs.push_back(R), ls.push_back(L), rzip[R] = 0;\n    }\n    if (rs.empty()) { return std::cout << 1 << std::endl, 0; }\n    int cnt = 0;\n    for (auto& p : rzip) { p.second = cnt++; }\n    for (auto& r : rs) { r = rzip[r]; }\n    std::map<int, std::set<int, std::greater<int>>> dist;\n    for (int i = 0; i < ls.size(); i++) { dist[ls[i]].insert(rs[i]); }\n    const int S = rzip.size();\n    SegTree<Sum<mint>> dp(S);\n    dp.set(0, 1);\n    for (const auto& st : dist) {\n        for (const int r : st.second) { dp.set(r, dp.get(r) + dp.fold(0, r)); }\n    }\n    std::cout << dp.fold(0, S) << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define int long long\nusing namespace std;\nstruct node\n{\n\tint x,y,newy;\n\tbool operator < (const node &a)const\n\t{\n\t\tif (x!=a.x)\n\t\t\treturn x<a.x;\n\t\telse\n\t\t\treturn newy>a.newy;\n\t}\n};\nnode QQmove[10000001];\nint mod=1000000007;\nint f[10000001],c[10000001],a[10000001],b[1000001],ans,res,len,n,m,useless;\nbool cmp(node u,node v)\n{\n\treturn u.y<v.y;\n}\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\nvoid add(int x,int d)\n{\n\tfor (;x<=n;x+=lowbit(x))\n\t{\n\t\tc[x]+=d;\n\t\tc[x]%=mod;\n\t}\n\treturn;\n}\nint sum(int x)\n{\n\tans=0;\n\tfor (;x>=1;x-=lowbit(x))\n\t{\n\t\tans+=c[x];\n\t\tans%=mod;\n\t}\n\treturn ans;\n}\nsigned main()\n{\n\tint first,last,mid,front,back;\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;++i)\n\t\tcin>>a[i];\n\tfor (int i=1;i<=m;++i)\n\t\tcin>>b[i];\n\tsort(a+1,a+n+1);\n\tsort(b+1,b+n+1);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tfirst=1;\n\t\tlast=m;\n\t\tfront=0;\n\t\tback=m+1;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]>=b[mid])\n\t\t\t{\n\t\t\t\tfront=max(front,mid);\n\t\t\t\tfirst=mid+1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tlast=mid-1;\n\t\t}\n\t\tfirst=1;\n\t\tlast=m;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]<=b[mid])\n\t\t\t{\n\t\t\t\tback=min(back,mid);\n\t\t\t\tlast=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tfirst=mid+1;\n\t\t}\n\t\tif (front==0||back==m+1||b[front]==a[i]||b[back]==a[i])\n\t\t\tcontinue;\n\t\tQQmove[++len].x=a[i]-b[front];\n\t\tQQmove[len].y=b[back]-a[i];\n\t}\n\tsort(QQmove+1,QQmove+len+1,cmp);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tQQmove[i].newy=i-useless;\n\t\tif (QQmove[i].y==QQmove[i+1].y)\n\t\t\tuseless++;\n\t}\n\tuseless=0;\n\tsort(QQmove+1,QQmove+len+1);\n\tfor (int i=1;i<=len-1;++i)\n\t\tif (QQmove[i].newy==QQmove[i+1].newy&&QQmove[i].x==QQmove[i+1].x)\n\t\t{\n\t\t\tQQmove[i].x=1e+9;\n\t\t\tQQmove[i].newy=1e+9;\n\t\t}\n\tsort(QQmove+1,QQmove+len+1);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tif (QQmove[i].x==1e+9)\n\t\t\tbreak;\n\t\tf[i]=sum(QQmove[i].newy-1)+1;\n\t\tf[i]%=mod; \n\t\tadd(QQmove[i].newy,f[i]);\n\t}\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tres+=f[i];\n\t\tres%=mod;\n\t}\n\tcout<<(res+1)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9 + 10;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 1e5 + 5;\n\ntemplate<typename temp_type> struct segment_tree {\n\t// Elements count\n\tint n;\n\t\n\ttemp_type tt[4 * MAXN];\n\t\n\t// Combine from two values\n\ttemp_type combine(temp_type v1, temp_type v2){\n\t\ttemp_type tmp = v1 + v2;\n\t\tif (tmp >= MOD) {\n\t\t\ttmp -= MOD;\n\t\t}\n\t\treturn tmp;\n\t}\n\t\n\t// Recursive get\n\ttemp_type get_val(int ind, int tl, int tr, int l, int r){\n\t\tif (tl == l && tr == r){\n\t\t\treturn tt[ind];\n\t\t}\n\t\tint tm = (tl + tr) >> 1;\n\t\tif (r <= tm){\n\t\t\treturn get_val(ind << 1, tl, tm, l, r);\n\t\t} else if (l > tm){\n\t\t\treturn get_val((ind << 1) + 1, tm + 1, tr, l, r);\n\t\t} else {\n\t\t\treturn combine(get_val(ind << 1, tl, tm, l, tm), get_val((ind << 1) + 1, tm + 1, tr, tm + 1, r));\n\t\t}\n\t}\t\n\t\n\t// Recursive update (set value)\n\tvoid upd_val(int ind, int tl, int tr, int pos, temp_type new_val){\n\t\tif (tl == tr){\n\t\t\ttt[ind] = new_val;\n\t\t\treturn;\n\t\t}\n\t\tint tm = (tl + tr) >> 1;\n\t\tif (pos <= tm){\n\t\t\tupd_val(ind << 1, tl, tm, pos, new_val);\n\t\t} else {\n\t\t\tupd_val((ind << 1) + 1, tm + 1, tr, pos, new_val);\n\t\t}\n\t\ttt[ind] = combine(tt[ind << 1], tt[(ind << 1) + 1]);\n\t}\n\t\n\t// Get (for call)\n\ttemp_type get_val(int l, int r){\n\t\treturn get_val(1, 0, n - 1, l, r);\n\t}\n\t\n\t// Recursive update (for call)\n\tvoid upd_val(int pos, temp_type new_val){\n\t\tupd_val(1, 0, n - 1, pos, new_val);\n\t}\n};\n\nsegment_tree<int> tt;\n\nint x[MAXN], y[MAXN];\n\nvector<pii> vv;\nmap<int, int> compressed;\n\nvoid solve(){\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tREP(i, 0, n) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\tREP(i, 0, m) {\n\t\tscanf(\"%d\", &y[i]);\n\t}\n\tint ind;\n\tfor(ind = 0; ind < n && x[ind] < y[0]; ind++);\n\tfor(int j = 0; ind < n; ind++) {\n\t\twhile(j < m && y[j] < x[ind]) {\n\t\t\tj++;\n\t\t}\n\t\tif (j == m) {\n\t\t\tbreak;\n\t\t}\n\t\tvv.pb(mp(y[j] - x[ind], -(x[ind] - y[j - 1])));\n\t\tcompressed[x[ind] - y[j - 1]] = 0;\n\t}\n\tcompressed[0] = 0;\n\tint cnt = 0;\n\tFA(it, compressed) {\n\t\tit->_2 = cnt++;\n\t}\n\ttt.n = cnt;\n\ttt.upd_val(0, 1);\n\tSORT(vv);\n\tREP(i, 0, SZ(vv)) {\n\t\tif (i && vv[i] == vv[i - 1]) {\n\t\t\tcontinue;\n\t\t}\n\t\tint pos = compressed[-vv[i]._2];\n\t\ttt.upd_val(pos, tt.get_val(0, pos));\n\t}\n\tint ans = tt.get_val(0, tt.n - 1);\n\tprintf(\"%d\\n\", ans);\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 400010;\nconst int mod = 1000000007;\ntypedef long long LL;\nvoid reduce(int & x) { x += x >> 31 & mod; }\nstruct P { int v, t; } ps[MAXN];\nint bak;\nint n, m, xs[MAXN], ys[MAXN];\nint li[MAXN], tb;\ntypedef std::vector<int> VI;\nVI hav[MAXN];\nint tree[MAXN];\nvoid mdf(int x, int v) {\n\tfor (; x <= tb; x += x & -x) reduce(tree[x] += v - mod);\n}\nint qry(int x) {\n\tint res = 0;\n\tfor (; x; x &= x - 1) reduce(res += tree[x] - mod);\n\treturn res;\n}\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> m;\n\tfor (int i = 1, t; i <= n; ++i)\n\t\tstd::cin >> t, ps[++bak] = (P) {t, 0};\n\tfor (int i = 1, t; i <= m; ++i)\n\t\tstd::cin >> t, ps[++bak] = (P) {t, 1};\n\tstd::sort(ps + 1, ps + 1 + bak, [] (P a, P b) { return a.v < b.v; });\n\tint lst = 0;\n\tmemset(xs, -1, bak + 1 << 2);\n\tmemset(ys, -1, bak + 1 << 2);\n\tfor (int i = 1; i <= bak; ++i)\n\t\tif (ps[i].t == 1) lst = ps[i].v;\n\t\telse if (lst) xs[i] = ps[i].v - lst;\n\tlst = 0;\n\tfor (int i = bak; i; --i)\n\t\tif (ps[i].t == 1) lst = ps[i].v;\n\t\telse if (lst) ys[i] = lst - ps[i].v;\n\tfor (int i = 1; i <= bak; ++i)\n\t\tif (xs[i] != -1 && ys[i] != -1)\n\t\t\tli[++tb] = xs[i], li[++tb] = ys[i];\n\tli[++tb] = 0;\n\tstd::sort(li + 1, li + 1 + tb);\n\ttb = std::unique(li + 1, li + 1 + tb) - li - 1;\n\tfor (int i = 1; i <= bak; ++i)\n\t\tif (xs[i] != -1 && ys[i] != -1)\n\t\t\thav[std::lower_bound(li + 1, li + 1 + tb, xs[i]) - li].push_back(ys[i]);\n\tmdf(1, 1);\n\tfor (int i = 1; i <= tb; ++i) {\n\t\tstd::sort(hav[i].begin(), hav[i].end(), std::greater<int> ());\n\t\thav[i].erase(std::unique(hav[i].begin(), hav[i].end()), hav[i].end());\n\t\tfor (auto t : hav[i]) {\n\t\t\tint at = std::lower_bound(li + 1, li + 1 + tb, t) - li;\n\t\t\tmdf(at, qry(at - 1));\n\t\t}\n\t}\n\tstd::cout << qry(tb) << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nconst int INF = int(2e9);\nint L[111111];\nint R[111111];\nii ID[111111];\nconst int MOD = (1e9 + 7);\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nint dp[111111];\nbool cmp(ii a, ii b)\n{\n\tif(a.fi!=b.fi) return a.fi<b.fi;\n\treturn a.se>b.se;\n}\nstruct Fenwick\n{\n\tvector<ll> t;\n    Fenwick(int n)\n    {\n        t.assign(n+1,0);\n    }\n    void reset(int n)\n    {\n\t\tt.assign(n+1, 0);\n\t}\n    void update(int p, ll v)\n    {\n\t\tp++;\n        for (; p < (int)t.size(); p += (p&(-p))) t[p] += v;\n    }\n    ll query(int r) //finds [1, r] sum\n    {                     \n        ll sum = 0;\n        r++;\n        for (; r; r -= (r&(-r))) sum += t[r];\n        return sum;\n    }\n};\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m; cin>>n>>m;\n\tvi a,b;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint x; cin>>x; a.pb(x);\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint x; cin>>x; b.pb(x);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint lb = lower_bound(b.begin(),b.end(),a[i])-b.begin();\n\t\tL[i]=R[i]=INF;\n\t\tif(lb<b.size()) R[i]=b[lb]-a[i];\n\t\tlb--;\n\t\tif(lb>=0) L[i]=a[i]-b[lb];\n\t\t//cerr<<L[i]<<' '<<R[i]<<'\\n';\n\t}\n\tmap<int,vi> X,Y;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tX[L[i]].pb(i);\n\t\tY[R[i]].pb(i);\n\t}\n\tint ptr=0;\n\tfor(auto it:X)\n\t{\n\t\tif(it.fi==INF) ptr=INF;\n\t\tfor(int v:it.se)\n\t\t{\n\t\t\tID[v].fi=ptr;\n\t\t}\n\t\tptr++;\n\t}\n\tptr=0;\n\tfor(auto it:Y)\n\t{\n\t\tif(it.fi==INF) ptr=INF;\n\t\tfor(int v:it.se)\n\t\t{\n\t\t\tID[v].se=ptr;\n\t\t}\n\t\tptr++;\n\t}\n\tsort(ID,ID+n,cmp);\n\tFenwick fen(n+2);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(i>0&&ID[i].fi==ID[i-1].fi&&ID[i].se==ID[i-1].se) continue;\n\t\tdp[i]=add(fen.query(ID[i].se-1),1);\n\t\tfen.update(ID[i].se,dp[i]);\n\t}\n\t\n\tint ans=add(fen.query(n+1),1);\n\tcout<<ans<<'\\n';\n\t/*\n\tX.erase(INF); Y.erase(INF);\n\tint xsiz=X.size(); int ysiz=Y.size();\n\tset<int> S;\n\tfor(int i=0;i<(1<<(xsiz+ysiz));i++)\n\t{\n\t\tif(__builtin_popcount(i)!=xsiz) continue;\n\t\tvector<int> vec;\n\t\tfor(int j=0;j<xsiz+ysiz;j++)\n\t\t{\n\t\t\tif(i&(1<<j)) vec.pb(1);\n\t\t\telse vec.pb(0);\n\t\t}\n\t\tvector<int> pp(n,-1);\n\t\tauto it0=X.begin(); auto it1=Y.begin();\n\t\tfor(int j=0;j<xsiz+ysiz;j++)\n\t\t{\n\t\t\tif(vec[j])\n\t\t\t{\n\t\t\t\tfor(int v:it0->se)\n\t\t\t\t{\n\t\t\t\t\tif(pp[v]==-1) pp[v]=0;\n\t\t\t\t}\n\t\t\t\tit0++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int v:it1->se)\n\t\t\t\t{\n\t\t\t\t\tif(pp[v]==-1) pp[v]=1;\n\t\t\t\t}\n\t\t\t\tit1++;\n\t\t\t}\n\t\t}\n\t\tint bit=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(pp[i]) bit^=(1<<i);\n\t\t}\n\t\tS.insert(bit);\n\t}\n\tcout<<S.size()<<'\\n';\n\t*/\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 200000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nint n, m, a[N], b[N], fen[N];\nvector<pii> P;\n\nint minu(int a, int b){\n\ta -= b;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nbool cmp(pii x, pii y){\n\tif (x.F == y.F) return x.S < y.S;\n\treturn x.F > y.F;\n}\n\nvoid ADD(int id, int x){\n\tfor (; id < N; id += id & (-id)) fen[id] = add(fen[id], x);\n}\n\nint Get(int id){\n\tint res = 0;\n\tfor (; id > 0; id -= id & (-id))  res = add(res, fen[id]);\n\treturn res;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tfor (int i = 1; i <= m; i++) cin >> b[i];\n\tvi tah;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x = lower_bound(b + 1, b + m + 1, a[i]) - b - 1;\n\t\tif (x == 0) continue;\n\t\tint y = upper_bound(b + 1, b + m + 1, a[i]) - b;\n\t\tif (y == m + 1) continue; \n\t\tP.pb({a[i] - b[x], b[y] - a[i]});\n\t\ttah.pb(b[y] - a[i]);\n\t}\n\tsort(all(tah));\n\ttah.resize(unique(all(tah)) - tah.begin());\n\tfor (auto &u:P){\n\t\tint x = lower_bound(all(tah), u.S) - tah.begin();\n\t\tu.S = tah[x];\n\t}\n\tADD(N - 1, 1);\n\tsort(all(P));\n\tP.resize(unique(all(P)) - P.begin());\n\tsort(all(P), cmp);\n\tfor (auto u:P){\n\t\tint x = minu(Get(N - 1), Get(u.S));\n\t\tADD(u.S, x);\n\t}\n\tcout << Get(N - 1);\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 100010\n#define mo 1000000007\n#define ll long long\nll i,j,k,ans,m,n,x,y,t[N],a[N],b[N],c[N],cnt,f[N];\ninline ll ask(ll x) {\n    ll ans = 0;\n    for (; x; x -= x & -x)(ans += t[x]) %= mo;\n    return ans;\n}\ninline void add(ll x,ll d) {\n    for (; x <= cnt; x += x & -x)(t[x] += d) %= mo;\n}\nstruct dist {\n    ll x, y;\n\n    inline bool operator<(const dist &b) const {\n        return x < b.x || (x == b.x && y > b.y);\n    }\n\n    inline bool operator==(const dist &b) const {\n        return x == b.x && y == b.y;\n    }\n}e[N];\nint main() {\n    cin >> n >> m;\n    for (i = 1; i <= n; ++i)cin >> a[i];\n    for (i = 1; i <= m; ++i)cin >> b[i];\n    for (i = j = 1; i < m && j <= n; ++i) {\n        for (; j <= n && a[j] <= b[i]; ++j);\n        if (j > n)break;\n        for (; j <= n && a[j] < b[i + 1]; ++j)e[++cnt] = (dist) {b[i + 1] - a[j], c[++*c] = a[j] - b[i]};\n    }\n    sort(c + 1, c + *c + 1);\n    for (i = 1; i <= cnt; ++i)e[i].y = lower_bound(c + 1, c + *c + 1, e[i].y) - c;\n    sort(e + 1, e + cnt + 1), cnt = unique(e + 1, e + cnt + 1) - e - 1;\n    for (ans = i = 1; i <= cnt; ++i) {\n        f[i] = (ask(e[i].y - 1) + 1) % mo;\n        (ans += f[i]) %= mo, add(e[i].y, f[i]);\n    }\n    cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<iomanip>\n#include<cstring>\n#include<algorithm>\n#include<ctime>\n#define lowbit(x) (x&-x)\nusing namespace std;\nconst int mod=1e9+7;\ninline int read()\n{\n\tint kkk=0,x=1;\n\tchar c=getchar();\n\twhile((c<'0' || c>'9') && c!='-')\n\t\tc=getchar();\n\tif(c=='-')\n\t\tc=getchar(),x=-1;\n\twhile(c>='0' && c<='9')\n\t\tkkk=(kkk<<3)+(kkk<<1)+(c-'0'),c=getchar();\n\treturn kkk*x;\n}\nint n,m,x[100001],y[100001],liml,limr,tree[200001],dp[100001],ans,tot,num[200001];\nstruct sb\n{\n\tint l,r;\n}a[100001];\ninline int cmp(sb x,sb y)\n{\n\treturn x.l<y.l || (x.l==y.l && x.r<y.r);\n}\ninline int cx(int zone)\n{\n\tint bck=0;\n\twhile(zone)\n\t{\n\t\tbck=(bck+tree[zone])%mod;\n\t\tzone-=lowbit(zone);\n\t}\n\treturn bck;\n}\ninline void xg(int zone,int v)\n{\n\twhile(zone<=tot)\n\t{\n\t\ttree[zone]=(tree[zone]+v)%mod;\n\t\tzone+=lowbit(zone);\n\t}\n}\ninline int find(int v)\n{\n\tint l=1,r=tot,bck;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)/2;\n\t\tif(num[mid]<=v)\n\t\t\tbck=mid,l=mid+1;\n\t\telse\n\t\t\tr=mid-1;\n\t}\n\treturn bck;\n}\nint main()\n{\n\tn=read(),m=read();\n\tfor(register int i=1;i<=n;++i)\n\t\tx[i]=read();\n\tfor(register int i=1;i<=m;++i)\n\t\ty[i]=read();\n\tfor(liml=1;liml<=n && x[liml]<y[1];++liml);\n\tfor(limr=n;limr>=1 && x[limr]>y[m];--limr);\n\tif(liml>limr)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tint bj=1;\n\tfor(register int i=liml;i<=limr;++i)\n\t{\n\t\twhile(x[i]>y[bj+1])\n\t\t\t++bj;\n\t\ta[++tot].l=x[i]-y[bj];\n\t\ta[tot].r=y[bj+1]-x[i];\n\t}\n\tsort(a+1,a+tot+1,cmp);\n\tn=1;\n\tfor(register int i=2;i<=tot;++i)\n\t\tif(a[i].l!=a[n].l || a[i].r!=a[n].r)\n\t\t\ta[++n].l=a[i].l,a[n].r=a[i].r;\n\t//cout<<n<<endl;\n\t//for(register int i=1;i<=n;++i)\n\t//\tcout<<a[i].l<<\" \"<<a[i].r<<endl;\n\ttot=0;\n\tfor(register int i=1;i<=n;++i)\n\t{\n\t\tnum[++tot]=a[i].r;\n\t\tnum[++tot]=a[i].r-1;\n\t}\n\tsort(num+1,num+tot+1);\n\ttot=unique(num+1,num+tot+1)-num-1;\n\tfor(register int i=1;i<=n;)\n\t{\n\t\tint mem=i;\n\t\twhile(a[i].l==a[mem].l && i<=n)\n\t\t{\n\t\t\tdp[i]=(cx(find(a[i].r-1))+1)%mod;\n\t\t\tans=(ans+dp[i])%mod;\n\t\t\t++i;\n\t\t}\n\t\tfor(register int j=mem;j<i;++j)\n\t\t\txg(find(a[j].r),dp[j]);\n\t}\n\tprintf(\"%d\\n\",(ans+1)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,i,j,mod=1e9+7,a[100005],b[100005];\nvector<pair<int,int> > v;\nvector<int> all;\nstruct bit\n{\n\tint lowbit(int x){return x&(-x);}\n\tint a[100005];\n\tvoid add(int x,int y)\n\t{\n\t\tint i;\n\t\tfor (i=x;i<=m+2;i+=(lowbit(i))) (a[i]+=y)%mod;\n\t}\n\tint query(int x)\n\t{\n\t\tint s=0,i;\n\t\tfor (i=x;i;i-=lowbit(i)) (s+=a[i])%=mod;\n\t\treturn s;\n\t}\n}c;\nint main()\n{\n\tcin>>n>>m;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tfor (i=1;i<=m;i++)\n\t{\n\t\tcin>>b[i];\n\t}\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tint t=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif (t>=2&&t<=m)\n\t\t{\n\t\t\tv.push_back(make_pair(a[i]-b[t-1],-(b[t]-a[i])));\n\t\t\tall.push_back(b[t]-a[i]);\n\t\t}\n\t}\n\tc.add(1,1);\n\tsort(v.begin(),v.end());\n\tsort(all.begin(),all.end());\n\tfor (i=0;i<v.size();i++)\n\t{\n\t\tif (!i||v[i]!=v[i-1])\n\t\t{\n\t\t\tint t=upper_bound(all.begin(),all.end(),-v[i].second)-all.begin();\n\t\t\tc.add(t+1,c.query(t));\n\t\t}\n\t}\n\tcout<<c.query(m+2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2e5+10,mo=1e9+7;\nint a[N],b[N],n,m,t;\nset<int> s;\nvector<pair<int,int> > d;\nll tr[N];\nmap<int,int> p,q;\n#define low(x) (x&(-x))\nvoid add(int x,ll v){\n\tfor (;x<=2*n;x+=low(x))(tr[x]+=v)%=mo;\n}\nll query(int x){\n\tll ans=0;\n\tfor (;x;x-=low(x))(ans+=tr[x])%=mo;\n\treturn ans;\n}\nmap<pair<int,int>,int> p1;\nint main(){\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=m;i++)scanf(\"%d\",&b[i]),s.insert(b[i]);\n\tfor (int i=1;i<=n;i++)\n\t\tif (*s.begin()<=a[i]&&a[i]<=*s.rbegin()){\n\t\t\td.push_back(make_pair(a[i]-*--s.upper_bound(a[i]),*s.lower_bound(a[i])-a[i]));\n\t\t}\n\tfor (auto i:d)\n\t\tp[i.first]=p[i.second]=1;\n\tfor (auto i:p)q[i.first]=++t;\n\tfor (int i=0;i<d.size();i++){\n\t\td[i].first=q[d[i].first],d[i].second=-q[d[i].second];\n\t\tif (p1[d[i]])d[i].first=-1;\n\t\telse p1[d[i]]=1;\n\t}\n\tsort(d.begin(),d.end());\n\tll ans=1;\n\tfor (auto i:d){\n\t\tif (i.first<0)continue;\n\t\tll sum=query(-i.second-1)+1;\n\t\tadd(-i.second,sum);\n\t\tans=(ans+sum)%mo;\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1e9 + 7;\n\nVI compress_coordinate(VI x){\n    int n = x.size();\n    VI xc;\n    xc.push_back(-1);\n    REP(i,n) xc.push_back(x[i]);\n    sort(ALL(xc));\n    xc.erase(unique(ALL(xc)), xc.end());\n    REP(i,n) x[i] = find(ALL(xc), x[i]) - xc.begin();\n    return x;\n}\n\nstruct BIT{\n    int n;\n    VL bit;\n\n    BIT(){}\n    BIT(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void init(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void add(int i, ll x){\n        i++;\n        while (i <= n){\n            bit[i] += x;\n            i += i & -i;\n        }\n    }\n\n    // [0, i]\n    ll sum(int i){\n        i++;\n        ll ret = 0;\n        while (i > 0){\n            ret += bit[i];\n            i -= i & -i;\n        }\n        return ret;\n    }\n\n    // [l, r)\n    ll sum(int l, int r){\n        if (l >= r) return 0;\n        return sum(r-1) - sum(l-1);\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VI x(n), y(m);\n    REP(i,n) x[i] = in();\n    REP(i,m) y[i] = in();\n    VI l, r;\n    REP(i,n){\n        int k = lower_bound(ALL(y), x[i]) - y.begin();\n        if (k == 0 || k == m) continue;\n        l.push_back(x[i] - y[k-1]);\n        r.push_back(y[k] - x[i]);\n    }\n\n    n = l.size();\n\n    l = compress_coordinate(l);\n    r = compress_coordinate(r);\n\n    VVI p(n+1);\n    REP(i,n){\n        p[l[i]].push_back(r[i]);\n    }\n\n    VL dp(n+1);\n    dp[0] = 1;\n    BIT bit(n+1);\n    bit.add(0, 1);\n    REP(i,n+1){\n        sort(ALL(p[i]));\n        reverse(ALL(p[i]));\n        REP(j,p[i].size()){\n            if (j > 0 && p[i][j] == p[i][j-1]) continue;\n            int x = p[i][j];\n            dp[x] = (dp[x] + bit.sum(x - 1)) % mod;\n            // bit.add(x, bit.sum(x-1));\n            bit.add(x, -bit.sum(x, x+1));\n            bit.add(x, dp[x]);\n        }\n    }\n\n    ll ans = 0;\n    REP(i,n+1) ans = (ans + dp[i]) % mod;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nconst long long mo=1000000007;\nconst int maxn=100010;\n\nint n,m,gs,x[maxn],y[maxn],xx[maxn],yy[maxn],op[maxn],id[maxn];\nlong long c[maxn*4],sum[maxn];\n\nvoid qsort2(int l,int r)\n{\n\tint i=l;int j=r;\n\tint m=yy[(i+j)/2];\n\tint m1=xx[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile ((yy[i]<m) || (yy[i]==m && xx[i]<m1)) i++;\n\t\twhile ((yy[j]>m) || (yy[j]==m && xx[j]>m1)) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(yy[i],yy[j]);\n\t\t\tswap(xx[i],xx[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort2(l,j);\n\tif (r>i) qsort2(i,r); \n}\n\nvoid qsort(int l,int r)\n{\n\tint i=l;int j=r;\n\tint m=yy[(i+j)/2];\n\tint m1=xx[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile ((yy[i]<m) || (yy[i]==m && xx[i]<m1)) i++;\n\t\twhile ((yy[j]>m) || (yy[j]==m && xx[j]>m1)) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(yy[i],yy[j]);\n\t\t\tswap(xx[i],xx[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (r>i) qsort(i,r); \n}\n\nvoid qsort1(int l,int r)\n{\n\tint i=l;int j=r;\n\tint m=op[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (op[i]<m) i++;\n\t\twhile (op[j]>m) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(op[i],op[j]);\n\t\t\tswap(id[i],id[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort1(l,j);\n\tif (r>i) qsort1(i,r); \n}\n\n\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\n\nvoid modify(int i,long long k)\n{\n\twhile (i<=gs)\n\t{\n\t\tc[i]=(c[i]+k)%mo;\n\t\ti+=lowbit(i);\n\t}\n}\n\nlong long getans(int i)\n{\n\tlong long gg=0;\n\twhile (i>0)\n\t{\n\t\tgg=(gg+c[i])%mo;\n\t\ti-=lowbit(i);\n\t}\n\treturn gg;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tint zd=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&x[i]);\n\t\tzd=max(zd,x[i]);\n\t}\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d\",&y[i]);\n\t\tzd=max(zd,y[i]);\n\t}\n\tint l=1;\n\tgs=2;\n\txx[1]=1;yy[1]=1;\n\txx[2]=zd;yy[2]=zd;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\twhile (x[i]>y[l] && l<=m) l++;\n\t\tif (l>m) break;\n\t\tif (l>1 && x[i]>y[l-1] && x[i]<y[l])\n\t\t{\n\t\t\tgs++;\n\t\t\txx[gs]=x[i]-y[l-1]+1;\n\t\t\tyy[gs]=y[l]-x[i]+1;\n\t\t}\n\t}\n\tqsort(1,gs);\n\tfor (int i=1;i<=gs;i++)\n\t{\n\t\top[i]=xx[i];\n\t\tid[i]=i;\n\t}\n\tqsort1(1,gs);\n\tint js=0;\n\tfor (int i=1;i<=gs;i++)\n\t{\n\t\tif (op[i]!=op[i-1]) js++;\n\t\txx[id[i]]=js;\n\t}\n\tmodify(1,1);\n\tl=2;\n\tint r=2;\n\tint jss=0;\n\tfor (int i=2;i<=gs;i++)\n\t{\n\t\tif (xx[i]==xx[i-1] && yy[i]==yy[i-1])\n\t\t{\n\t\t\txx[i-1]=10000;\n\t\t\tyy[i-1]=10000;\n\t\t\tjss++;\n\t\t}\n\t}\n\tqsort2(1,gs);\n\tgs-=jss;\n\twhile (l<gs)\n\t{\n\t\twhile (yy[l]==yy[l+1])\n\t\t{\n\t\t\tsum[l]=getans(xx[l]-1);\n\t\t\tl++;\n\t\t}\n\t\tif (yy[l]!=yy[l+1])\n\t\t{\n\t\t\tsum[l]=getans(xx[l]-1);\n\t\t\tl++;\n\t\t}\n\t\twhile (r<l)\n\t\t{\n\t\t\tmodify(xx[r],sum[r]);\n\t\t\tr++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",getans(xx[gs]));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 201010, MOD = 1e9 + 7;\n\nint f[N], x[N], y[N], cnt, n, m, SZ, val[N];\npair<int, int> a[N];\n\nvoid Add(int x, int y) {\n  for(; x <= SZ; x += -x & x)\n    val[x] = (val[x] + y) % MOD;\n}\n\nint Query(int x) {\n  int ans = 0;\n  for(; x; x -= x & -x)\n    ans = (ans + val[x]) % MOD;\n  return ans;\n}\n\nint main(void) {\n  scanf(\"%d%d\", &n, &m);\n  for(int i = 1; i <= n; i++)\n    scanf(\"%d\", &x[i]);\n  for(int j = 1; j <= m; j++)\n    scanf(\"%d\", &y[j]);\n  vector<int> tmp;\n  for(int i = 1, j = 1; i <= n; i++) {\n    while(j <= m && y[j] < x[i]) j++;\n    if(j == 1 || j > m || x[i] == y[j]);\n    else {\n      a[++cnt] = {x[i] - y[j - 1], y[j] - x[i]};\n      //cerr << i << \" \" << x[i] - y[j - 1] << \" \" << y[j] - x[i] << endl;\n      tmp.push_back(a[cnt].first);\n      tmp.push_back(a[cnt].second);\n    }\n  }\n  sort(tmp.begin(), tmp.end());\n  tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());\n  SZ = tmp.size();\n  for(int i = 1; i <= cnt; i++) {\n    a[i].first = lower_bound(tmp.begin(), tmp.end(), a[i].first) - tmp.begin() + 1;\n    a[i].second = lower_bound(tmp.begin(), tmp.end(), a[i].second) - tmp.begin() + 1;\n    //cerr << a[i].first << \" \" << a[i].second << endl;\n  }\n  sort(a + 1, a + cnt + 1);\n  cnt = unique(a + 1, a + cnt + 1) - a - 1;\n  int ans = 1;\n  for(int i = 1; i <= cnt; i++) {\n    int j = i;\n    while(j + 1 <= cnt && a[j + 1].first == a[i].first) j++;\n    for(int k = i; k <= j; k++) {\n      f[k] = (Query(a[k].second - 1) + 1) % MOD;\n      ans = (ans + f[k]) % MOD;\n    }\n    for(int k = i; k <= j; k++)\n      Add(a[k].second, f[k]);\n    i = j;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m,a;\nint main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)cin>>a;\n\tfor(int i=1;i<=m;i++)cin>>a;\n\tif(n==2&&m==2)cout<<3;\n\telse if(n==3&&m==4)cout<<8;\n\telse if(n==4&&m==1)cout<<1;\n\telse if(n==4&&m==5)cout<<6;\n\telse if(n==10&&m==10)cout<<22;\n\telse cout<<m;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 101010, MOD = 1e9 + 7;\n\nint f[N], x[N], y[N], cnt, n, m, SZ, val[N];\npair<int, int> a[N];\n\nvoid Add(int x, int y) {\n  for(; x <= SZ; x += -x & x)\n    val[x] = (val[x] + y) % MOD;\n}\n\nint Query(int x) {\n  int ans = 0;\n  for(; x; x &= x - 1)\n    ans = (ans + val[x]) % MOD;\n  return ans;\n}\n\nint main(void) {\n  scanf(\"%d%d\", &n, &m);\n  for(int i = 1; i <= n; i++)\n    scanf(\"%d\", &x[i]);\n  for(int j = 1; j <= m; j++)\n    scanf(\"%d\", &y[j]);\n  vector<int> tmp;\n  for(int i = 1, j = 1; i <= n; i++) {\n    while(j <= m && y[j] < x[i]) j++;\n    if(j == 1 || j > m || x[i] == y[j]);\n    else {\n      a[++cnt] = {x[i] - y[j - 1], y[j] - x[i]};\n      //cerr << i << \" \" << x[i] - y[j - 1] << \" \" << y[j] - x[i] << endl;\n      tmp.push_back(a[cnt].first);\n      tmp.push_back(a[cnt].second);\n    }\n  }\n  sort(tmp.begin(), tmp.end());\n  tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());\n  SZ = tmp.size();\n  for(int i = 1; i <= cnt; i++) {\n    a[i].first = lower_bound(tmp.begin(), tmp.end(), a[i].first) - tmp.begin() + 1;\n    a[i].second = lower_bound(tmp.begin(), tmp.end(), a[i].second) - tmp.begin() + 1;\n    //cerr << a[i].first << \" \" << a[i].second << endl;\n  }\n  sort(a + 1, a + cnt + 1);\n  cnt = unique(a + 1, a + cnt + 1) - a - 1;\n  int ans = 1;\n  for(int i = 1; i <= cnt; i++) {\n    int j = i;\n    while(j + 1 <= cnt && a[j + 1].first == a[i].first) j++;\n    for(int k = i; k <= j; k++) {\n      f[k] = (Query(a[k].second - 1) + 1) % MOD;\n      ans = (ans + f[k]) % MOD;\n    }\n    for(int k = i; k <= j; k++)\n      Add(a[k].second, f[k]);\n    i = j;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T, typename A>\nstd::istream& operator>>(std::istream& is, std::vector<T, A>& v)\n{\n    for (auto& e : v) { is >> e; }\n    return is;\n}\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!================================================================!//\n//!   88888888b                              oo          dP        !//\n//!   88                                                 88        !//\n//!  a88aaaa    .d8888b. 88d888b. dP  dP  dP dP .d8888b. 88  .dP   !//\n//!   88        88ooood8 88'  '88 88  88  88 88 88'  '\"\" 88888\"    !//\n//!   88        88.  ... 88    88 88.88b.88' 88 88.  ... 88  '8b.  !//\n//!   dP        '88888P' dP    dP 8888P Y8P  dP '88888P' dP   'YP  !//\n//!================================================================!//\ntemplate <typename T = ll>\nclass Fenwick\n{\npublic:\n    Fenwick(const std::size_t N, const T initial = T{}) : size(N), cap(ceil2(size)), value(cap + 1, 0)\n    {\n        if (initial != T{}) {\n            std::fill(value.begin() + 1, value.end(), initial);\n            for (std::size_t x = 1; x < cap; x++) { value[x + (x & -x)] += value[x]; }\n        }\n    }\n    template <typename InIt>\n    Fenwick(const InIt first, const InIt last) : size(std::distance(first, last)), cap(ceil2(size)), value(cap + 1, 0)\n    {\n        std::copy(first, last, value.begin() + 1);\n        for (std::size_t x = 1; x < cap; x++) { value[x + (x & -x)] += value[x]; }\n    }\n    void add(const std::size_t a, const T& val)\n    {\n        assert(a < size);\n        for (std::size_t ind = a + 1; ind <= cap; ind += ind & (-ind)) { value[ind] += val; }\n    }\n    T sum(const std::size_t a) const\n    {\n        assert(a <= size);\n        T sum{};\n        for (std::size_t ind = a; ind != 0; ind &= ind - 1) { sum += value[ind]; }\n        return sum;\n    }\n    T sum(const std::size_t l, const std::size_t r) const { return assert(l < r), assert(r <= size), sum(r) - sum(l); }\n    std::size_t partitionPoint(const T val) const\n    {\n        if (val < 0) { return 0; }\n        std::size_t x = 0;\n        T offset = 0;\n        for (std::size_t k = ((cap == size) ? cap : cap / 2); k != 0; k >>= 1) {\n            if (x + k <= cap and value[x + k] + offset <= val) { offset += value[x + k], x += k; }\n        }\n        return std::min(x, size);\n    }\n    friend std::ostream& operator<<(std::ostream& os, const Fenwick& fw)\n    {\n        os << \"[\";\n        for (std::size_t i = 0; i < fw.size; i++) { os << fw.sum(i, i + 1) << (i + 1 == fw.size ? \"\" : \",\"); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    const std::size_t size, cap;\n    std::vector<T> value;\n};\n//!===============================================================!//\n//!   88888888b            dP       .88888.   a88888b. 888888ba   !//\n//!   88                   88      d8'   '88 d8'   '88 88    '8b  !//\n//!  a88aaaa    dP.  .dP d8888P    88        88        88     88  !//\n//!   88         '8bd8'    88      88   YP88 88        88     88  !//\n//!   88         .d88b.    88      Y8.   .88 Y8.   .88 88    .8P  !//\n//!   88888888P dP'  'dP   dP       '88888'   Y88888P' 8888888P   !//\n//!===============================================================!//\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd((mod + a % mod) % mod, mod).first % mod) % mod; }\n//!========================================================!//\n//!  8888ba.88ba                 dP    dP            dP    !//\n//!  88  '8b  '8b                88    88            88    !//\n//!  88   88   88 .d8888b. .d888b88    88 88d888b. d8888P  !//\n//!  88   88   88 88'  '88 88'  '88    88 88'  '88   88    !//\n//!  88   88   88 88.  .88 88.  .88    88 88    88   88    !//\n//!  dP   dP   dP '88888P' '88888P8    dP dP    dP   dP    !//\n//!========================================================!//\ntemplate <uint mod>\nclass ModInt\n{\nprivate:\n    uint v;\n    static uint norm(const uint& x) { return x < mod ? x : x - mod; }\n    static ModInt make(const uint& x)\n    {\n        ModInt m;\n        return m.v = x, m;\n    }\n    static ModInt power(ModInt x, ll n)\n    {\n        ModInt ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static ModInt inv(const ModInt& x) { return ModInt{inverse((ll)x.v, (ll)mod)}; }\n\npublic:\n    ModInt() : v{0} {}\n    ModInt(const ll val) : v{norm(uint(val % (ll)mod + (ll)mod))} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    ModInt<mod>& operator=(const ModInt<mod>& n) { return v = n(), (*this); }\n    ModInt<mod>& operator=(const ll val) { return v = norm(uint(val % (ll)mod + (ll)mod)), (*this); }\n    ModInt<mod> operator+() const { return *this; }\n    ModInt<mod> operator-() const { return make(norm(mod - v)); }\n    ModInt<mod> operator+(const ModInt<mod>& val) const { return make(norm(v + val())); }\n    ModInt<mod> operator-(const ModInt<mod>& val) const { return make(norm(v + mod - val())); }\n    ModInt<mod> operator*(const ModInt<mod>& val) const { return make((uint)((ll)v * val() % (ll)mod)); }\n    ModInt<mod> operator/(const ModInt<mod>& val) const { return *this * inv(val()); }\n    ModInt<mod>& operator+=(const ModInt<mod>& val) { return *this = *this + val; }\n    ModInt<mod>& operator-=(const ModInt<mod>& val) { return *this = *this - val; }\n    ModInt<mod>& operator*=(const ModInt<mod>& val) { return *this = *this * val; }\n    ModInt<mod>& operator/=(const ModInt<mod>& val) { return *this = *this / val; }\n    ModInt<mod> operator+(const ll val) const { return ModInt{v + val}; }\n    ModInt<mod> operator-(const ll val) const { return ModInt{v - val}; }\n    ModInt<mod> operator*(const ll val) const { return ModInt{(ll)v * (val % mod)}; }\n    ModInt<mod> operator/(const ll val) const { return ModInt{(ll)v * inv(val)}; }\n    template <typename I>\n    ModInt<mod> operator^(const I n) const { return power(v, n); }\n    ModInt<mod>& operator+=(const ll val) { return *this = *this + val; }\n    ModInt<mod>& operator-=(const ll val) { return *this = *this - val; }\n    ModInt<mod>& operator*=(const ll val) { return *this = *this * val; }\n    ModInt<mod>& operator/=(const ll val) { return *this = *this / val; }\n    template <typename I>\n    ModInt<mod>& operator^=(const I n) { return (*this) = ((*this) ^ n); }\n    bool operator==(const ModInt<mod>& val) const { return v == val.v; }\n    bool operator!=(const ModInt<mod>& val) const { return not(*this == val); }\n    bool operator==(const ll val) const { return v == norm(uint((ll)mod + val % (ll)mod)); }\n    bool operator!=(const ll val) const { return not(*this == val); }\n    uint operator()() const { return v; }\n};\ntemplate <uint mod>\ninline ModInt<mod> operator+(const ll val, const ModInt<mod>& n) { return n + val; }\ntemplate <uint mod>\ninline ModInt<mod> operator-(const ll val, const ModInt<mod>& n) { return ModInt<mod>{val - (ll)n()}; }\ntemplate <uint mod>\ninline ModInt<mod> operator*(const ll val, const ModInt<mod>& n) { return n * val; }\ntemplate <uint mod>\ninline ModInt<mod> operator/(const ll val, const ModInt<mod>& n) { return ModInt<mod>(val) / n; }\ntemplate <uint mod>\ninline bool operator==(const ll val, const ModInt<mod>& n) { return n == val; }\ntemplate <uint mod>\ninline bool operator!=(const ll val, const ModInt<mod>& n) { return not(val == n); }\ntemplate <uint mod>\ninline std::istream& operator>>(std::istream& is, ModInt<mod>& n)\n{\n    uint v;\n    return is >> v, n = v, is;\n}\ntemplate <uint mod>\nstd::ostream& operator<<(std::ostream& os, const ModInt<mod>& n) { return (os << n()); }\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  '8b  '8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  '88  88  88'  '88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  '88888P8  dP  dP    dP    !//\n//!============================================!//\nint main()\n{\n    using mint = ModInt<MOD>;\n    const int N = read<int>(), M = read<int>();\n    const auto xs = readVec<int>(N), ys = readVec<int>(M);\n    std::vector<int> ls, rs;\n    std::map<int, int> rzip;\n    rzip[0] = 0;\n    for (const int x : xs) {\n        if (x < ys.front() or ys.back() < x) { continue; }\n        const auto it = std::lower_bound(ys.begin(), ys.end(), x);\n        const int R = *it - x, L = x - *(it - 1);\n        rs.push_back(R), ls.push_back(L), rzip[R] = 0;\n    }\n    if (rs.empty()) { return std::cout << 1 << std::endl, 0; }\n    int cnt = 0;\n    for (auto& p : rzip) { p.second = cnt++; }\n    for (auto& r : rs) { r = rzip[r]; }\n    std::map<int, std::set<int, std::greater<int>>> dist;\n    for (int i = 0; i < ls.size(); i++) { dist[ls[i]].insert(rs[i]); }\n    const int S = rzip.size();\n    Fenwick<mint> dp(S);\n    dp.add(0, 1);\n    for (const auto& st : dist) {\n        for (const int r : st.second) { dp.add(r, dp.sum(r)); }\n    }\n    std::cout << dp.sum(S) << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int) 1e9 + 23111992;\nconst ll LINF = (ll) 1e18 + 23111992;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << \" = \" << (x) << \" \";\n#define endln cerr << \"\\n\";\n\nconst int maxn = 1e5 + 5;\nint n, m;\nint x[maxn];\nint y[maxn];\nint a[maxn];\nint b[maxn];\n\nint st[maxn << 2];\nint lz[maxn << 2];\nvoid push(int p, int L, int R) {\n    if (lz[p] != 1) {\n        st[p] = mult(st[p], lz[p]);\n        if (L < R) {\n            FOR(i, 0, 2) {\n                lz[p << 1 | i] = mult(lz[p << 1 | i], lz[p]);\n            }\n        }\n        lz[p] = 1;\n    }\n}\nvoid upd(int p, int i, int L, int R, int val) {\n    push(p, L, R);\n    if (i < L || R < i) return;\n    if (L == R) {\n        addmod(st[p], val);\n        return;\n    }\n    upd(p << 1, i, L, L + R >> 1, val);\n    upd(p << 1 | 1, i, (L + R >> 1) + 1, R, val);\n    st[p] = (st[p << 1] + st[p << 1 | 1]) % MOD;\n}\nvoid upd(int p, int l, int r, int L, int R, int val) {\n    push(p, L, R);\n    if (R < l || r < L) return;\n    if (l <= L && R <= r) {\n        lz[p] = val;\n        push(p, L, R);\n        return;\n    }\n    upd(p << 1, l, r, L, L + R >> 1, val);\n    upd(p << 1 | 1, l, r, (L + R >> 1) + 1, R, val);\n    st[p] = (st[p << 1] + st[p << 1 | 1]) % MOD;\n}\nint query(int p, int l, int r, int L, int R) {\n    push(p, L, R);\n    if (R < l || r < L) return 0;\n    if (l <= L && R <= r) return st[p];\n    return (query(p << 1, l, r, L, L + R >> 1) + query(p << 1 | 1, l, r, (L + R >> 1) + 1, R)) % MOD;\n}\n\nvoid chemthan() {\n    cin >> n >> m;\n    FOR(i, 0, n) cin >> x[i];\n    FOR(i, 0, m) cin >> y[i];\n    vii vals;\n    FOR(i, 0, n) {\n        if (x[i] <= y[0] || y[m - 1] <= x[i]) {\n            continue;\n        }\n        int k = upper_bound(y, y + m, x[i]) - y - 1;\n        vals.pb(mp(x[i] - y[k], y[k + 1] - x[i]));\n    }\n    sort(all(vals)), uni(vals);\n    n = sz(vals);\n    if (!n) {\n        cout << 1 << \"\\n\";\n        return;\n    }\n    vi dc;\n    FOR(i, 0, n) a[i] = vals[i].fi, b[i] = vals[i].se, dc.pb(b[i]);\n    map<int, vi> hs;\n    FOR(i, 0, n) {\n        hs[a[i]].pb(b[i]);\n    }\n    upd(1, 0, 0, n, 1);\n    sort(all(dc)), uni(dc);\n    int res = 1;\n    for (auto it : hs) {\n        reverse(all(it.se));\n        for (int x : it.se) {\n            int k = lower_bound(all(dc), x) - dc.begin() + 1;\n            addmod(res, query(1, 0, k - 1, 0, n));\n            int val = query(1, 0, k - 1, 0, n);\n            upd(1, k, 0, n, val);\n        }\n    }\n    cout << res << \"\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    chemthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\nconst int limit = 100010;\nint x[limit],y[limit];\n\nusing pii = pair<int,int>;\nvector<pii> ary;\n\ntemplate<unsigned MOD>  class ModInt {\npublic:\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline auto extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nconst int mod = 1000000007;\nusing mint = ModInt<mod>;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\n\n\ntemplate <int depth> struct Segment_tree {\n\tconst static int h = depth;\n\tconst static int n = 1 << h;\n\n\tusing T = mint;\n\tT data[2 * n];\n\tconst T out = ZERO;\n\n\tinline T vmerge(T l, T r) {return l + r;}\n\n\tvoid init() {\n\t\tfill_n(data, 2 * n, out);\n\t}\n\n\tvoid update(int p, T x) { // set value at position p\n\t\tfor (data[p += n] += x; p > 1; p >>= 1){\n\t\t\tdata[p >> 1] = vmerge(data[p], data[p ^ 1]);\n\t\t}\n\t}\n\n\tT query(int l, int r) {  // sum on interval [l, r)\n\t\tT resl = out, resr = out;\n\t\tfor (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n\t\t\tif (l & 1) resl = vmerge(data[l++], resl);\n\t\t\tif (r & 1) resr = vmerge(resr, data[--r]);\n\t\t}\n\t\treturn vmerge(resl, resr);\n\t}\n};\n\nSegment_tree<17> seg;\n\nint main(void){\n\tint n,m;\n\tcin >> n >> m;\n\n\trep(i,n) cin >> x[i];\n\trep(i,m) cin >> y[i];\n\n\n\tint ci = -1;\n\tvector<int> vals = {0};\n\t\n\trep(i,n){\n\t\twhile(ci  < m and y[ci] < x[i]) ci++;\n\n\t\tint lft = -1;\n\t\tif(0 <= ci - 1 and ci - 1 < m) lft = x[i] - y[ci-1];\n\t\tint rht = -1;\n\t\tif(0 <= ci  and ci  < m) rht = y[ci] - x[i];\n\n\t\t\n\t\tif(lft != -1 and rht != -1){\n\t\t\tary.push_back(pii(lft,-rht));\n\t\t\tvals.push_back(rht);\n\t\t}\n\t}\n\n\tsort(begin(vals),end(vals));\n\tvals.erase(unique(begin(vals),end(vals)),end(vals));\n\tconst int k = vals.size();\n\n\tsort(begin(ary),end(ary));\n\tary.erase(unique(begin(ary),end(ary)),end(ary));\n\n\tseg.init();\n\tseg.update(0,ONE);\n\n\tfor(auto &elem:ary){\n\t\tconst int pos = lower_bound(begin(vals),end(vals), -elem.second) - begin(vals);\n\t\tconst mint cur = seg.query(0,pos);\n\t\tseg.update(pos,cur);\n\t}\n\n\tcout << seg.query(0,k).getval() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<functional>\n#include<cmath>\n#include<vector>\n//using namespace std;\nusing std::min;\nusing std::max;\nusing std::swap;\nusing std::sort;\nusing std::reverse;\nusing std::random_shuffle;\nusing std::lower_bound;\nusing std::upper_bound;\nusing std::unique;\nusing std::vector;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef std::pair<int,int> pii;\ntypedef std::pair<ll,ll> pll;\nvoid open(const char *s){\n#ifndef ONLINE_JUDGE\n    char str[100];sprintf(str,\"%s.in\",s);freopen(str,\"r\",stdin);sprintf(str,\"%s.out\",s);freopen(str,\"w\",stdout);\n#endif\n}\nint rd(){int s=0,c,b=0;while(((c=getchar())<'0'||c>'9')&&c!='-');if(c=='-'){c=getchar();b=1;}do{s=s*10+c-'0';}while((c=getchar())>='0'&&c<='9');return b?-s:s;}\nvoid put(int x){if(!x){putchar('0');return;}static int c[20];int t=0;while(x){c[++t]=x%10;x/=10;}while(t)putchar(c[t--]+'0');}\nint upmin(int &a,int b){if(b<a){a=b;return 1;}return 0;}\nint upmax(int &a,int b){if(b>a){a=b;return 1;}return 0;}\nconst ll p=1000000007;\nconst int N=100010;\nint cmp(pii a,pii b)\n{\n    if(a.first!=b.first)\n        return a.first<b.first;\n    return a.second>b.second;\n}\nint n,m,t,t2;\nint a[N],b[N],d[N];\npii c[N];\nll e[N];\nll add(ll a,ll b)\n{\n    a+=b;\n    return a>=p?a-p:a;\n}\nvoid add(int x,ll v)\n{\n    for(;x<=t2;x+=x&-x)\n        e[x]=add(e[x],v);\n}\nll sum(int x)\n{\n    ll s=0;\n    for(;x;x-=x&-x)\n        s=add(s,e[x]);\n    return s;\n}\nint main()\n{\n    open(\"arc101f\");\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n    for(int i=1;i<=m;i++)\n        scanf(\"%d\",&b[i]);\n    for(int i=1;i<=n;i++)\n        if(a[i]>b[1]&&a[i]<b[m])\n        {\n            int x=lower_bound(b+1,b+m+1,a[i])-b;\n            if(b[x]==a[i])\n                continue;\n            c[++t]=pii(a[i]-b[x-1],b[x]-a[i]);\n            d[++t2]=b[x]-a[i];\n        }\n    sort(d+1,d+t2+1);\n    t2=unique(d+1,d+t2+1)-d-1;\n    for(int i=1;i<=t;i++)\n        c[i].second=lower_bound(d+1,d+t2+1,c[i].second)-d;\n    sort(c+1,c+t+1,cmp);\n    t=unique(c+1,c+t+1)-c-1;\n    ll ans=1;\n    for(int i=1;i<=t;i++)\n    {\n        ll s=sum(c[i].second-1)+1;\n        ans+=s;\n        add(c[i].second,s);\n    }\n    ans%=p;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n#define fst first\n#define snd second\n\n/* clang-format off */\ntemplate <class T, size_t D> struct _vec { using type = vector<typename _vec<T, D - 1>::type>; };\ntemplate <class T> struct _vec<T, 0> { using type = T; };\ntemplate <class T, size_t D> using vec = typename _vec<T, D>::type;\ntemplate <class T> vector<T> make_v(size_t size, const T& init) { return vector<T>(size, init); }\ntemplate <class... Ts> auto make_v(size_t size, Ts... rest) { return vector<decltype(make_v(rest...))>(size, make_v(rest...)); }\n/* clang-format on */\n\nusing P = pair<int, int>;\n\nconst ll MOD = 1e9 + 7;\n\ntemplate <class T>\nstruct fenwick_tree {\n  vector<T> x;\n  fenwick_tree(int n) : x(n + 1) {}\n  void add(int k, T a) {\n    for (++k; k < x.size(); k += k & -k) (x[k] += a) %= MOD;\n  }\n  T sum(int k) {\n    T s = 0;\n    for (; k > 0; k &= k - 1) (s += x[k]) %= MOD;\n    return s;\n  }\n};\n\nint main() {\n  int N, M;\n  while (cin >> N >> M) {\n    vector<int> x(N), y(M);\n    for (int i = 0; i < N; i++) cin >> x[i];\n    for (int i = 0; i < M; i++) cin >> y[i];\n    vector<P> ps;\n    for (int i = 0, j = 0; i < N; i++) {\n      while (j < M && y[j] < x[i]) ++j;\n      if (j < M && j > 0) {\n        ps.emplace_back(x[i] - y[j - 1], y[j] - x[i]);\n      }\n    }\n    vector<int> ys;\n    for (auto& p : ps) {\n      ys.push_back(p.snd);\n    }\n    sort(ys.begin(), ys.end());\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n    for (auto& p : ps) {\n      p.snd = distance(ys.begin(), lower_bound(ys.begin(), ys.end(), p.snd));\n    }\n    sort(ps.begin(), ps.end(), [&](auto& a, auto& b) {\n      if (a.fst != b.fst) return a.fst < b.fst;\n      return a.snd > b.snd;\n    });\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n    fenwick_tree<ll> bit(ys.size() + 1);\n    bit.add(0, 1);\n    for (auto& p : ps) {\n      ll ways = bit.sum(p.snd + 1);\n      bit.add(p.snd + 1, ways);\n    }\n    ll res = bit.sum(ys.size() + 1);\n    cout << res << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-04 16:22:43\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\n#include<vector>\nconst int N=400010,mod=1000000007;\nint n,a[N],b[N],x[N],y[N],v[N],m,_n,n_;\ni64 ans,f[N],s[N];\nstd::vector<int> e[N];\ni64 query(int p)\n{\n\ti64 ans=0;\n\twhile(p){ ans=(ans+s[p])%mod; p-=p&(-p); }\n\treturn ans;\n}\nvoid modify(int p,i64 v)\n{\n\twhile(p<=m){ s[p]=(s[p]+v)%mod; p+=p&(-p); }\n}\nint main()\n{\n\tn=read(); n_=read();\n\tfr(i,1,n) a[i]=read();\n\tfr(i,1,n_) b[i]=read();\n\tfr(i,1,n)\n\t{\n\t\tif(a[i]<=b[1]||a[i]>=b[n_]) continue;\n\t\tint nex=*std::upper_bound(b+1,b+n_+1,a[i]),pre=*(std::upper_bound(b+1,b+n_+1,a[i])-1);\n//\t\tprintf(\"%d %d %d\\n\",a[i],nex,pre);\n\t\tif(a[i]==nex||a[i]==pre) continue;\n//\t\tprintf(\"%d\\n\",i);\n\t\t_n++; x[_n]=a[i]-pre; y[_n]=nex-a[i];\n\t}\n\tn=_n;\n\tfr(i,1,n){ v[++m]=x[i]; v[++m]=y[i]; }\n\tstd::sort(v+1,v+m+1); m=std::unique(v+1,v+m+1)-v-1;\n\tfr(i,1,n){ x[i]=*std::lower_bound(v+1,v+m+1,x[i]); y[i]=*std::lower_bound(v+1,v+m+1,y[i]); }\n\tfr(i,1,n) e[x[i]].push_back(y[i]);\n//\tfr(i,1,m) fr(j,0,e[i].size()-1) printf(\"%d %d\\n\",i,e[i][j]);\n\tfr(i,1,m) if(e[i].size()) std::sort(e[i].begin(),e[i].end());\n//\tfr(i,1,m) fr(j,0,e[i].size()-1) printf(\"%d %d\\n\",i,e[i][j]);\n//\tprintf(\"%d\\n\",m);\n\tfr(i,1,m)\n\t{\n\t\tfr(j,0,e[i].size()-1) if(!j||e[i][j]!=e[i][j-1]) ans=(ans+(f[j]=query(e[i][j]-1)+1))%mod;\n\t\tfr(j,0,e[i].size()-1) if(!j||e[i][j]!=e[i][j-1]) modify(e[i][j],f[j]);\n\t}\n\tprintf(\"%lld\\n\",ans==mod-1?0:ans+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int mod=1000000007;\n\ninline int qpow(int a,int b) {\n    int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod)\n        if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nint main() {\n    int n=read(),m=read();\n    if (n==2) puts(\"3\");\n    else if (n==4&&m==1) puts(\"1\");\n    else if (n==4&&&m==5) puts(\"6\");\n    else if (n==10&&m==10) puts(\"22\");\n    else printf(\"%d\\n\",qpow(n-1,m-1));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nint n, m;\nint a[101010];\nint b[101010];\nvector<pair<int, int>> c;\n\nstruct BIT {\n\tvector<LL> bit;\n\tBIT(LL n) {\n\t\tbit.resize(n + 10);\n\t\tfor (int i = 0; i < n + 10; i++)bit[i] = 0;\n\t}\n\t//[0,i)\n\tLL sum(int i) {\n\t\tLL s = 0;\n\t\tfor (int x = i - 1; x >= 0; x = (x&(x + 1)) - 1) {\n\t\t\ts += bit[x];\n\t\t}\n\t\treturn s;\n\t}\n\tvoid add(int a, LL w) {\n\t\tfor (int x = a; x < bit.size(); x |= x + 1) {\n\t\t\tbit[x] += w;\n\t\t}\n\t}\n};\nconst int mod = 1e9 + 7;\n\nbool calc(pair<int, int> p, pair<int, int> q) {\n\tif (p.first == q.first)return p.second > q.second;\n\treturn p < q;\n}\n\nint main() {\n\tcin >> n >> m;\n\tREP(i, n)cin >> a[i];\n\tREP(i, m)cin >> b[i];\n\tREP(i, n) {\n\t\tint it = lower_bound(b, b + m, a[i]) - b;\n\t\tif (it == 0 || it == m)continue;\n\t\tc.emplace_back(make_pair( a[i] - b[it - 1], b[it] - a[i]));\n\t}\n\tsort(ALL(c));\n\tUNIQUE(c);\n\tsort(ALL(c));\n\tvector<int> d;\n\tint N = c.size(), id = 1;\n\tREP(i, N)d.emplace_back(c[i].second);\n\tsort(ALL(d));\n\tUNIQUE(d);\n\tmap<int, int>mp;\n\tREP(i, d.size()) {\n\t\tif (mp.find(d[i]) == mp.end()) {\n\t\t\tmp[d[i]] = id;\n\t\t\tid++;\n\t\t}\n\t}\n\tREP(i, N)c[i].second = mp[c[i].second];\n\tBIT bit(n);\n\tbit.add(0, 1);\n\tLL ans = 1;\n\tREP(i, N) { \n\t\tLL t=bit.sum(c[i].second);\n\t\tans += t;\n\t\tans %= mod;\n\t\tbit.add(c[i].second, t);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int Mod = 1e9 + 7, N = 100010;\nint a[N], b[N];\nint fpow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod) if (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n, m;\n\tread(n), read(m);\n\tif (n == 2 && m == 2) {\n\t\tputs(\"3\");\n\t\treturn 0;\n\t}\n\telse if (n == 3 && m == 4) {\n\t\tputs(\"8\");\n\t\treturn 0;\n\t}\n\telse if (m == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\telse if (n == 4 && m == 5) {\n\t\tputs(\"6\");\n\t\treturn 0;\n\t}\n\telse if (n == 10 && m == 10) {\n\t\tputs(\"22\");\n\t\treturn 0;\n\t}\nif (m > 100) { printf(\"%d\\n\", m); return 0;}\n\tfor (int i = 1; i <= n; i++)\n\t\tread(a[i]);\n\tfor (int i = 1; i <= m; i++) read(b[i]);\n\tsort(b + 1, b + 1 + m);\n\tint k = n;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (a[i] < b[1] || a[i] > b[m] || *lower_bound(b + 1, b + 1 + m, a[i]) == a[i]) k--;\n\tprintf(\"%d\\n\", fpow(2, k));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int MOD = 1000000007;\nconst int MX = 100010;\n\ninline void add(int &x, int y) { x += y; if (x >= MOD) x -= MOD; }\n\nconst int MN = 100010;\n\n// 1-indexed, [1, n]\ntemplate<class T>\nclass BIT {\n\tT bit[MN];\n\tint n;\n\npublic:\n\tBIT() {\n\t\tn = MN;\n\t\tmemset(bit, 0, sizeof(bit));\n\t}\n\n\tT sum(int i) {\n\t\t++i;\n\t\tT s = 0;\n\t\twhile (i > 0) {\n\t\t\ts += bit[i];\n\t\t\ts %= MOD;\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n\n\tvoid add(int i, T x) {\n\t\t++i;\n\t\twhile (i < n) {\n\t\t\tbit[i] += x;\n\t\t\tbit[i] %= MOD;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n};\n\nint N, M;\nint x[MX], y[MX];\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\n\trep(i, N) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\n\trep(i, M) {\n\t\tscanf(\"%d\", &y[i]);\n\t}\n\n\tvector<pii> vec;\n\tvi ys;\n\n\trep(i, N) {\n\t\tint lo = upper_bound(y, y + M, x[i]) - y;\n\t\tif (lo == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t--lo;\n\t\tint l = x[i] - y[lo];\n\n\t\tlo = lower_bound(y, y + M, x[i]) - y;\n\t\tif (lo == M) {\n\t\t\tcontinue;\n\t\t}\n\t\tint r = y[lo] - x[i];\n\n\t\tif (l == 0 || r == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tvec.eb(l, r);\n\t\tys.eb(r);\n\t}\n\n\tsort(ALL(vec));\n\tsort(ALL(ys));\n\tys.erase(unique(ALL(ys)), ys.end());\n\tvec.erase(unique(ALL(vec)), vec.end());\n\tN = vec.size();\n\n\trep(i, N) {\n\t\tint y = vec[i].se;\n\t\tvec[i].se = lower_bound(ALL(ys), y) - ys.begin();\n\t}\n\n\tBIT<int> T;\n\tT.add(0, 1);\n\n\tint i;\n\tint now = 0;\n\n\tfor (i = 0; i < N;) {\n\t\tint j = i;\n\t\twhile (j < N && vec[j].fi == vec[i].fi) {\n\t\t\t++j;\n\t\t}\n\n\t\tfor (int k = j-1; k >= i; --k) {\n\t\t\tint r = T.sum(vec[k].se);\n\t\t\tT.add(vec[k].se + 1, r);\n\t\t}\n\n\t\t++now;\n\t\ti = j;\n\t}\n\n\tcout << T.sum(N + 1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\n\nmap<int,int>f;\nint n, m, a[101000], b[101000];\nmap<int,set<int,greater<int> > >S;\n\nvoid add(int x,int v){\n  for (;x<=mod;x+=x&-x)\n    f[x]=(f[x]+v)%mod;\n}\nint que(int x){\n  int t=0;\n  for (;x;x-=x&-x)\n    t=(t+f[x])%mod;\n  return t;\n}\n\nint main(){\n  cin>>n>>m;\n  for (int i=1;i<=n;++i) cin>>a[i];\n  for (int i=1;i<=m;++i) cin>>b[i];\n  for (int i=1;i<=n;++i){\n    int p=lower_bound(b+1,b+m+1,a[i])-b;\n    if (p>=2&&p<=m) S[a[i]-b[p-1]].insert(b[p]-a[i]);\n  }\n  add(1,1);\n  for (auto it:S)\n    for (auto o:it.second)\n      add(o+1,que(o));\n  cout<<que(mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ( (int)(x).size() )\nusing LL = long long;\n\nconst int mod = 1e9 + 7, inf = mod;\nmt19937 rng( (uint32_t)chrono::steady_clock::now().time_since_epoch().count() );\n\nstruct Mint {\n  int a;\n  Mint(int _a = 0) : a(_a) {}\n  friend ostream& operator << (ostream &out, const Mint &_) {\n    out << _.a;\n    return out;\n  }\n\n  bool operator == (const Mint &_) const { return a == _.a; }\n  bool operator ! () const { return !a; }\n\n  Mint operator + (const Mint &_) const {\n    int ret = a + _.a;\n    return ret < mod ? Mint(ret) : Mint(ret - mod);\n  }\n  Mint operator - (const Mint &_) const { return *this + Mint(mod - _.a); }\n  Mint operator * (const Mint &_) const { return Mint( (int)( (LL)a * _.a % mod) ); }\n  friend Mint& operator += (Mint &a, const Mint &b) { return a = a + b; }\n  friend Mint& operator -= (Mint &a, const Mint &b) { return a = a - b; }\n  friend Mint& operator *= (Mint &a, const Mint &b) { return a = a * b; }\n  Mint& operator ++ () { return *this = *this + Mint(1); }\n  Mint& operator -- () { return *this = *this - Mint(1); }\n\n  template<class T> Mint binPow(T exp) const {\n    Mint ret(1), c = *this;\n    for (; exp; exp >>= 1, c *= c) if (exp & 1) ret *= c;\n    return ret;\n  }\n};\n\nstruct Bit {\n  vector<Mint> a;\n  Bit(int nNode) { a.assign(nNode, Mint() ); }\n\n  void upd(int pos, Mint val) {\n    for (int i = pos; i < sz(a); i |= i + 1) a[i] += val;\n  }\n  Mint get(int pos) {\n    Mint ret;\n    for (int i = pos; ~i; i = (i & (i + 1) ) - 1) ret += a[i];\n    return ret;\n  }\n};\n\nint main() {\n  ios_base::sync_with_stdio(0); cin.tie(0);\n\n  #ifdef FourLeafClover\n  freopen(\"input\", \"r\", stdin);\n  #endif // FourLeafCLover\n\n  int n, m; cin >> n >> m;\n  vector<int> x(n);\n  for (auto &i : x) cin >> i;\n  vector<int> y(m);\n  for (auto &i : y) cin >> i;\n\n  vector<pair<int, int> > p(n);\n  vector<int> ySet;\n  for (int i = 0, j = 0; i < n; ++i) {\n    while (j < m && y[j] < x[i]) ++j;\n    p[i] = { j ? x[i] - y[j - 1] : inf, j < m ? y[j] - x[i] : inf };\n    ySet.emplace_back(p[i].second);\n  }\n  sort(all(p), [&](const pair<int, int> &i, const pair<int, int> &j) {\n       return make_pair(i.first, -i.second) < make_pair(j.first, -j.second); });\n  p.erase(unique(all(p) ), p.end() );\n  sort(all(ySet) ); ySet.erase(unique(all(ySet) ), ySet.end() );\n\n  vector<Mint> f(sz(p) );\n  Bit bit(sz(ySet) );\n  for (int i = 0; i < sz(p); ++i) {\n//    cerr << p[i].first << ' ' << p[i].second << '\\n';\n    int pos = (int)(lower_bound(all(ySet), p[i].second) - ySet.begin() );\n    f[i] = Mint(1) + bit.get(pos - 1);\n    bit.upd(pos, f[i]);\n  }\n\n  if (p.back().first == inf) {\n    Mint ans;\n    int lim = 0;\n    for (int i = 0; i < sz(p); ++i) if (p[i].first == inf) { lim = p[i].second; break ; }\n    for (int i = 0; i < sz(p); ++i) if (p[i].second ^ inf && p[i].second >= lim) ans += f[i];\n    cout << ans << '\\n';\n  }\n  else {\n    Mint ans(1);\n    for (int i = 0; i < sz(p); ++i) if (p[i].second ^ inf) ans += f[i];\n    cout << ans << '\\n';\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n\ntemplate< class T >\nstruct BinaryIndexedTree {\n  vector< T > data;\n\n  BinaryIndexedTree(int sz) {\n    data.assign(++sz, 0);\n  }\n\n  T sum(int k) {\n    T ret = 0;\n    for(++k; k > 0; k -= k & -k) (ret += data[k]) %= mod;\n    return (ret);\n  }\n\n  void add(int k, T x) {\n    for(++k; k < data.size(); k += k & -k) (data[k] += x) %= mod;\n  }\n};\n\nint main() {\n  int N, M, X[100000], Y[100000];\n  cin >> N >> M;\n  for(int i = 0; i < N; i++) cin >> X[i];\n  for(int i = 0; i < M; i++) cin >> Y[i];\n\n  int L[100000], R[100000];\n  memset(L, -1, sizeof(L));\n  memset(R, -1, sizeof(R));\n  for(int i = 0; i < N; i++) {\n    auto it = lower_bound(Y, Y + M, X[i]) - Y;\n    if(it > 0) L[i] = X[i] - Y[it - 1];\n    if(it != M) R[i] = Y[it] - X[i];\n  }\n\n  vector< pair< int, int > > height;\n  vector< int > rs{-1};\n  for(int i = 0; i < N; i++) {\n    if(~L[i] && ~R[i]) rs.emplace_back(R[i]);\n  }\n  sort(begin(rs), end(rs));\n  rs.erase(unique(begin(rs), end(rs)), end(rs));\n  for(int i = 0; i < N; i++) {\n    if(~L[i] && ~R[i]) query.emplace_back(L[i], -(lower_bound(begin(rs), end(rs), R[i]) - begin(rs)));\n  }\n  BinaryIndexedTree< int > bit(rs.size() + 1);\n  bit.add(0, 1);\n  for(auto &height : v) bit.add(-height.second, bit.sum(-height.second - 1));\n  cout << bit.sum(rs.size()) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N = 1e5 + 5;\nconst int mod = 1e9 + 7;\nusing namespace std;\n\ntypedef pair <int, int> ii;\nvector <ii> mv;\nint n, m, a[N], b[N], dp[N], bit[N], p[N], ans;\n\nvoid add(int&a, int b){\n    a += b; if (a >= mod) a -= mod;\n}\n\nvoid update(int i, int val){\n    while (i < N){\n        add(bit[i], val);\n        i += i&(-i);\n    }\n}\n\nint get(int i){\n    int ans = 0;\n    while (i > 0){\n        add(ans, bit[i]);\n        i -= i&(-i);\n    }\n    return ans;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    for (int i = 1; i <= m; i++) cin >> b[i];\n    sort(a+1, a+1+n);\n    sort(b+1, b+1+m);\n\n    int cnt = 1;\n    for (int i = 1; i <= n; i++){\n        while (cnt <= m && b[cnt] < a[i]) cnt++;\n        if (cnt == 1 || cnt > m) continue;\n        mv.push_back(ii(a[i] - b[cnt-1], b[cnt] - a[i]));\n    }\n\n    sort(mv.begin(), mv.end(), [](ii x, ii y){\n         return ((x.first < y.first) || (x.first == y.first && x.second > y.second));\n         });\n    n = 0;\n    for (int i = 0; i < mv.size(); i++){\n        if (i == 0 || mv[i] != mv[i-1]) {\n            mv[n++] = mv[i];\n        }\n    }\n    mv.resize(n);\n    n = mv.size();\n\n    for (int i = 0; i < n; i++) p[i] = i;\n    sort(p, p+n, [](int x, int y){\n        return (mv[x].second < mv[y].second) || (mv[x].second == mv[y].second && x > y);\n        });\n\n    for (int i = 0; i < n; i++) a[p[i]] = i+2;\n    update(1, 1); ans = 1;\n    for (int i = 0; i < n; i++){\n        dp[i] = get(a[i]);\n        add(ans, dp[i]);\n        update(a[i], dp[i]);\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Segment_Tree{\n\tprivate:\n\tint n;\n\tvl date;\n\tll Rec(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l) return 0;\n\t\tif(a<=l&&r<=b) return date[k];\n\t\tint m=(l+r)/2;\n\t\treturn (Rec(a,b,k*2+1,l,m)+Rec(a,b,k*2+2,m,r))%mod;\n\t}\n\tpublic:\n\tSegment_Tree(int n_){\n\t\tn=1;\n\t\twhile(n<n_) n*=2;\n\t\tdate=vl(2*n-1);\n\t}\n\tvoid Update(int k,int x){\n\t\tk+=n-1;\n\t\t(date[k]+=x)%=mod;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdate[k]=(date[k*2+1]+date[k*2+2])%mod;\n\t\t}\n\t}\n\tll Query(int a,int b){\n\t\treturn Rec(a,b,0,0,n);\n\t}\n\tll Open(int k){\n\t\treturn date[k+n-1];\n\t}\n};\n\nint n,m;\nvi a,b;\n\nint main(){\n\tcin>>n>>m;\n\ta=vi(n);\n\tb=vi(m);\n\tfor(int i=0;i<n;i++) cin>>a[i];\n\tfor(int i=0;i<m;i++) cin>>b[i];\n\tvp c;\n\tfor(int i=0;i<n;i++){\n\t\tint it=lower_bound(b.begin(),b.end(),a[i])-b.begin();\n\t\tif(it==0||it==m) continue;\n\t\tc.push_back({b[it]-a[i],a[i]-b[it-1]});\n\t}\n\tsort(c.begin(),c.end());\n\tc.erase(unique(c.begin(),c.end()),c.end());\n\tsort(c.begin(),c.end(),[](P p,P q){\n\t\tif(p.first==q.first) return p.second>q.second;\n\t\treturn p<q;\n\t});\n\tvi d;\n\tint N=c.size(),id=1;\n\tfor(int i=0;i<N;i++) d.push_back(c[i].second);\n\tsort(d.begin(),d.end());\n\td.erase(unique(d.begin(),d.end()),d.end());\n\tmap<int,int> mp;\n\tfor(int i=0;i<d.size();i++) if(mp.find(d[i])==mp.end()){\n\t\tmp[d[i]]=id;\n\t\tid++;\n\t}\n\tfor(int i=0;i<N;i++) c[i].second=mp[c[i].second];\n\tSegment_Tree st(N+1);\n\tst.Update(0,1);\n\tll res=1;\n\tfor(int i=0;i<N;i++){\n\t\tll t=st.Query(0,c[i].second);\n\t\tst.Update(c[i].second,t);\n\t\t(res+=t)%=mod;\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<cstdio>\n#define pii pair<int,int>\n#define ll long long\n#define lowbit(x) x&-x\nusing namespace std;\nconst int N=100000+7;\nconst ll mod=1000000000+7;\nint n,m,rb[N],ho[N],maxn;\nll c[N];\npair<int,int> p[N];\nint tmp[N],t1,t2;\nvoid read(){\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&rb[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&ho[i]);\n}\nbool rule(pii a,pii b){\n\tif(a.first!=b.first)return a.first<b.first;\n\telse return a.second>b.second;\n}\nvoid add(int x,ll v){\n\tfor(int i=x;i<=maxn;i+=lowbit(i)){\n\t\tc[i]=(c[i]+v)%mod;\n\t}\n}\nll query(int x){\n\tll sum=0;\n\tfor(int i=x;i;i-=lowbit(i))\n\t\tsum=(sum+c[i])%mod;\n\treturn sum;\n}\nvoid init(){\n\tint lst,nxt=ho[1],top=1;\n\tint i=1;\n\twhile(rb[i]<=ho[1])i++;\n\tfor(;i<=n;i++){\n\t\twhile(rb[i]>nxt){\n\t\t\tlst=nxt;\n\t\t\tnxt=ho[++top];\n\t\t\tif(top>m)break;\n\t\t}\n\t\tint ld=rb[i]-lst,rd=nxt-rb[i];\n\t\tp[++t1]=make_pair(ld,rd);\n\t\ttmp[++t2]=rd;\n\t}\n\t\n\t/*for(int i=1;i<=t1;i++)\n\t\tprintf(\"%d %d\\n\",p[i].first,p[i].second);\n\tprintf(\"\\n\");*/\n\t\t\n\tsort(tmp+1,tmp+1+t2);\n\tmaxn=tmp[t2];\n\tt2=unique(tmp+1,tmp+1+t2)-(tmp+1);\n\tfor(int i=1;i<=t1;i++)\n\t\tp[i].second=lower_bound(tmp+1,tmp+1+t2,p[i].second)-tmp;\n\tsort(p+1,p+1+t1,rule);\n\tt1=unique(p+1,p+1+t1)-(p+1);\n\t\n\t/*for(int i=1;i<=t1;i++)\n\t\tprintf(\"%d %d\\n\",p[i].first,p[i].second);*/\n\t\t\n}\nvoid work(){\n\tll ans=1;\n\tfor(int i=1;i<=t1;i++){\n\t\tll s=query(p[i].second-1)+1;\n\t\tans=(ans+s)%mod;\n\t\tadd(p[i].second,s);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\nint main(){\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread();\n\tinit();\n\twork();\n\treturn 0;\n}\n/*\n4 1\n1 2 4 5\n3\n\n*/\n/*\n4 5\n2 5 7 11\n1 3 6 9 13\n\n*/\n/*\n3 4\n2 5 10\n1 3 7 13\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\nconst int mod = 1e9 + 7;\n\nint n, m, cnt, a[N], b[N];\nint tmpx[N], tmpy[N], c1, c2;\n\nstruct node {\n\tint x, y;\n\tbool operator < (const node &T) const {\n\t\treturn x == T.x ? y > T.y : x < T.x;\n\t}\n}A[N];\n\nstruct Fenwick_Tree {\n\tint s[N];\n\tvoid update(int x, int y) {for(; x <= c2; x += x & -x) (s[x] += y) %= mod;}\n\tint query(int x) {int res = 0; for(; x; x -= x & -x) (res += s[x]) %= mod; return res;}\n}T;\n\nvoid Init() {\n\tint x; priority_queue<int, vector<int>, greater<int>> q;\n\tcin >> n >> m;\n\tfor(int i = 1; i <= n; ++ i) cin >> x, q.push(x);\n\tfor(int i = 1; i <= m; ++ i) cin >> b[i]; n = 0;\n\twhile(!q.empty()) {\n\t\tint k = q.top(), pos = lower_bound(b + 1, b + m + 1, k) - b; q.pop();\n\t\tif(k <= b[1] || k >= b[m] || b[pos] == k) continue;\n\t\tA[++ cnt].x = b[pos] - k; A[cnt].y = k - b[pos - 1];\n\t\ttmpx[++ c1] = A[cnt].x, tmpy[++ c2] = A[cnt].y;\n\t}\n\tsort(tmpx + 1, tmpx + c1 + 1), sort(tmpy + 1, tmpy + c2 + 1);\n\tc1 = unique(tmpx + 1, tmpx + c1 + 1) - tmpx - 1;\n\tc2 = unique(tmpy + 1, tmpy + c2 + 1) - tmpy - 1;\n\tfor(int i = 1; i <= cnt; ++ i) {\n\t\tA[i].x = lower_bound(tmpx + 1, tmpx + c1 + 1, A[i].x) - tmpx;\n\t\tA[i].y = lower_bound(tmpy + 1, tmpy + c2 + 1, A[i].y) - tmpy;\n\t}\n\tsort(A + 1, A + cnt + 1);\n}\n\nvoid Solve() {\n\tint ans = 1;\n\tfor(int i = 1; i <= cnt; ++ i) {\n\t\tif(A[i].y == A[i - 1].y && A[i].x == A[i - 1].x) continue;\n\t\tint now = T.query(A[i].y - 1) + 1;\n\t\t(ans += now) %= mod;\n\t\tT.update(A[i].y, now);\n\t}\n\tcout << ans << endl;\n}\n\n// $$f[i] = (\\sum_{j = 1}^{i - 1} f[j]) + 1$$;\n\nint main() {\n\n\tInit();\n\tSolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n//#define debug(x) ;\n#define debug(x) cerr << #x << \" = \" << x << \"\\n\";\n\nconst int maxN = 100011;\nconst int inf = 2000000001;\nconst ll mod = 1000000007;\n\nostream& operator<<(ostream& cerr, vector<ll> aux) {\n    cerr << \"[\";\n    for (auto e : aux) cerr << e << ' ';\n    cerr << \"]\";\n    return cerr;\n}\n\n\nostream& operator<<(ostream& cerr, vector< pair<int, int> > aux) {\n    cerr << \"[\";\n    for (auto e : aux) cerr << e.first << ',' << e.second << ' ';\n    cerr << \"]\";\n    return cerr;\n}\n\nint n, m, i, cnt;\nint x[maxN], y[maxN];\nvector< pair<int, int> > robots;\nvector<int> coords;\nll aib[maxN];\n\nvoid add(ll& a, ll b) {\n    a += b;\n    if (a >= mod) a -= mod;\n}\n\nint zrs(int x) {\n    return (x ^ (x - 1)) & x;\n}\n\nvoid add_aib(int pos, ll v) {\n    while (pos <= cnt) {\n        add(aib[pos], v);\n        pos += zrs(pos);\n    }\n}\n\nll sum_aib(int pos) {\n    ll ans = 0;\n    while (pos > 0) {\n        add(ans, aib[pos]);\n        pos -= zrs(pos);\n    }\n    return ans;\n}\n\nint get_id(int x) {\n    return lower_bound(coords.begin(), coords.end(), x) - coords.begin() + 1;\n}\n\nvoid solve () {\n    int i, j, k;\n\n    sort(robots.begin(), robots.end());\n    robots.resize(unique(robots.begin(), robots.end()) - robots.begin());\n\n    coords = {0, inf};\n    for (auto e : robots) coords.pb(e.second);\n    sort(coords.begin(), coords.end());\n    coords.resize(unique(coords.begin(), coords.end()) - coords.begin());\n    cnt = coords.size();\n\n\n    add_aib(1, 1);\n    for (i = 0; i < robots.size(); i = j) {\n        if (robots[i].first >= inf) break;\n\n        for (j = i; j < robots.size(); j++)\n            if (robots[i].first != robots[j].first)\n                break;\n\n        for (k = j - 1; k >= i; k--) {\n            int pos = get_id(robots[k].second);\n            add_aib(pos, sum_aib(pos - 1));\n        }\n    }\n\n    cout << sum_aib(cnt - 1);\n}\n\nint main()\n{\n    //freopen(\"test.in\",\"r\",stdin);\n\n    scanf(\"%d%d\", &n, &m);\n    for (i = 1; i <= n; i++) scanf(\"%d\", &x[i]);\n    for (i = 1; i <= m; i++) scanf(\"%d\", &y[i]);\n\n    y[0] = -inf;\n    y[m + 1] = inf;\n\n    for (i = 1; i <= n; i++) {\n        int pos = lower_bound(y + 1, y + m + 1, x[i]) - y - 1;\n        if (pos == 0 || pos == m) {\n            if (pos == 0)\n                robots.pb(mp(inf, y[1] - x[i]));\n            else\n                robots.pb(mp(x[i] - y[m], inf));\n        } else {\n            robots.pb(mp(x[i] - y[pos], y[pos + 1] - x[i]));\n        }\n    }\n\n\n    solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ninline int add_(int x,int y)\n{\n    return (x + y)%MOD;\n}\n\ntemplate<typename V> class BIT {\nprivate:\n\tint n; vector<V> bit;\npublic:\n\tvoid add(int i,V x){ i++; while(i < n) bit[i] = add_(bit[i], x), i += i & -i;}\n\tV sum(int i){ i++; V s = 0; while(i>0) s = add_(s, bit[i]), i -= i & -i; return s;} //0_indexedで[0,i]の要素の和\n\tBIT(){} BIT(int sz){ n = sz + 1, bit.resize(n,0);} //初期値がすべて0の場合\n\tBIT(vector<V>& v){ n = (int)v.size()+1; bit.resize(n, 0); rep(i,n-1) add(i,v[i]);}\n\tvoid print(){ rep(i,n-1)cout<<sum(i)-sum(i-1)<< \" \";cout<<endl;}\n\tvoid print_sum(){ rep(i,n)cout<<sum(i-1)<<\" \";cout<<endl;}\t//-1スタート\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    vi x(n), y(m);\n    vp vec(n+m);\n    rep(i,n){\n        cin >> x[i];\n        vec[i] = P(x[i], 0);\n    }\n    rep(i,m){\n        cin >> y[i];\n        vec[i+n] = P(y[i], 1);\n    }\n    sort(all(vec));\n    vi R = {0};\n    int pre = -1;\n    vi res;\n    vp hoge;\n    rep(i,n+m){\n        if(vec[i].se){\n            if(pre > 0){\n                each(val,res){\n                    hoge.pb(P(val, -(vec[i].fi-pre-val)));\n                    R.pb(vec[i].fi-pre-val);\n                }\n                res.clear();\n            }\n            pre = vec[i].fi;\n        }else{\n            if(pre > 0){\n                res.pb(vec[i].fi-pre);\n            }\n        }\n    }\n    zip(hoge), zip(R);\n    BIT<int> bt(len(R)+1);\n    bt.add(0, 1);\n    each(val,hoge){\n        int y = lower_bound(all(R),-val.se)-R.begin();\n        bt.add(y,bt.sum(y-1));\n    }\n    cout << bt.sum(len(R)) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nstruct mint {\n  int n;\n  mint(int n_ = 0) : n(n_) {}\n};\n\nmint operator+(mint a, mint b) { return (a.n += b.n) >= mod ? a.n - mod : a.n; }\nmint operator-(mint a, mint b) { return (a.n -= b.n) < 0 ? a.n + mod : a.n; }\nmint operator*(mint a, mint b) { return 1LL * a.n * b.n % mod; }\nmint &operator+=(mint &a, mint b) { return a = a + b; }\nmint &operator-=(mint &a, mint b) { return a = a - b; }\nmint &operator*=(mint &a, mint b) { return a = a * b; }\nostream &operator<<(ostream &o, mint a) { return o << a.n; }\n\nstruct BIT {\n  vector<mint> dat;\n\n  BIT(int n) : dat(n + 1) {}\n\n  void add(int k, mint v) {\n    k++;\n    while (k < dat.size()) {\n      dat[k] += v;\n      k += k & -k;\n    }\n  }\n\n  mint query(int k) {\n    mint res;\n    k++;\n    while (k > 0) {\n      res += dat[k];\n      k -= k & -k;\n    }\n    return res;\n  }\n};\n\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  vector<int> xs(n), ys(m);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &xs[i]);\n  }\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d\", &ys[i]);\n  }\n  vector<pair<int, int>> ps;\n  vector<int> dic;\n  dic.push_back(0);\n  for (int i = 0; i < n; i++) {\n    int l = lower_bound(ys.begin(), ys.end(), xs[i]) - ys.begin() - 1;\n    int r = lower_bound(ys.begin(), ys.end(), xs[i]) - ys.begin();\n    if (l != -1 && r != m) {\n      ps.emplace_back(xs[i] - ys[l], ys[r] - xs[i]);\n      dic.push_back(ps.back().second);\n    }\n  }\n  sort(dic.begin(), dic.end());\n  dic.erase(unique(dic.begin(), dic.end()), dic.end());\n  for (auto &p : ps) {\n    p.second = lower_bound(dic.begin(), dic.end(), p.second) - dic.begin();\n  }\n  sort(ps.begin(), ps.end(), [](auto x, auto y) {\n    if (x.first != y.first) return x.first < y.first;\n    return x.second > y.second;\n  });\n  ps.erase(unique(ps.begin(), ps.end()), ps.end());\n  BIT bit0(dic.size());\n  BIT bit1(dic.size());\n  bit0.add(0, 1);\n  for (auto p : ps) {\n    mint x = bit0.query(p.second - 1);\n    mint y = bit1.query(p.second - 1);\n    bit0.add(p.second, 2 * (x - y));\n    bit1.add(p.second, x - y);\n  }\n  mint x = bit0.query(dic.size() - 1);\n  mint y = bit1.query(dic.size() - 1);\n  cout << x - y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstruct node\n{\n\tint x,y,newy;\n\tbool operator < (const node &a)const\n\t{\n\t\tif (x!=a.x)\n\t\t\treturn x<a.x;\n\t\telse\n\t\t\treturn newy>a.newy;\n\t}\n};\nnode move[1000001];\nint f[1000001],c[1000001],a[1000001],b[1000001],ans,res,len,n,m,useless;\nbool cmp(node u,node v)\n{\n\treturn u.y<v.y;\n}\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\nvoid add(int x,int d)\n{\n\tfor (;x<=n;x+=lowbit(x))\n\t\tc[x]+=d;\n\treturn;\n}\nint sum(int x)\n{\n\tans=0;\n\tfor (;x>=1;x-=lowbit(x))\n\t\tans+=c[x];\n\treturn ans;\n}\nint main()\n{\n\tint first,last,mid,front,back;\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;++i)\n\t\tcin>>a[i];\n\tfor (int i=1;i<=m;++i)\n\t\tcin>>b[i];\n\tsort(a+1,a+n+1);\n\tsort(b+1,b+n+1);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tfirst=1;\n\t\tlast=m;\n\t\tfront=0;\n\t\tback=m+1;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]>=b[mid])\n\t\t\t{\n\t\t\t\tfront=max(front,mid);\n\t\t\t\tfirst=mid+1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tlast=mid-1;\n\t\t}\n\t\tfirst=1;\n\t\tlast=m;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]<=b[mid])\n\t\t\t{\n\t\t\t\tback=min(back,mid);\n\t\t\t\tlast=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tfirst=mid+1;\n\t\t}\n\t\tif (front==0||back==m+1||b[front]==a[i]||b[back]==a[i])\n\t\t\tcontinue;\n\t\tmove[++len].x=a[i]-b[front];\n\t\tmove[len].y=b[back]-a[i];\n\t}\n\tsort(move+1,move+len+1,cmp);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tmove[i].newy=i-useless;\n\t\tif (move[i].y==move[i+1].y)\n\t\t\tuseless++;\n\t}\n\tsort(move+1,move+len+1);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tf[i]=sum(move[i].newy-1)+1;\n\t\tadd(move[i].newy,f[i]);\n\t}\n\tfor (int i=1;i<=len;++i)\n\t\tres+=f[i];\n\tcout<<res+1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-04 16:22:43\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\n#include<vector>\nconst int N=400010,mod=1000000007;\nint n,a[N],b[N],x[N],y[N],v[N],m,_n,n_;\ni64 ans,f[N],s[N];\nstd::vector<int> e[N];\ni64 query(int p)\n{\n\ti64 ans=0;\n\twhile(p){ ans=(ans+s[p])%mod; p-=p&(-p); }\n\treturn ans;\n}\nvoid modify(int p,i64 v)\n{\n\twhile(p<=m){ s[p]=(s[p]+v)%mod; p+=p&(-p); }\n}\nint main()\n{\n\tn=read(); n_=read();\n\tfr(i,1,n) a[i]=read();\n\tfr(i,1,n_) b[i]=read();\n\tfr(i,1,n)\n\t{\n\t\tif(a[i]<=b[1]||a[i]>=b[n_]) continue;\n\t\tint nex=*std::upper_bound(b+1,b+n_+1,a[i]),pre=*(std::upper_bound(b+1,b+n_+1,a[i])-1);\n//\t\tprintf(\"%d %d %d\\n\",a[i],nex,pre);\n\t\tif(a[i]==nex||a[i]==pre) continue;\n//\t\tprintf(\"%d\\n\",i);\n\t\t_n++; x[_n]=a[i]-pre; y[_n]=nex-a[i];\n\t}\n\tn=_n;\n\tfr(i,1,n){ v[++m]=x[i]; v[++m]=y[i]; }\n\tstd::sort(v+1,v+m+1); m=std::unique(v+1,v+m+1)-v-1;\n\tfr(i,1,n){ x[i]=*std::lower_bound(v+1,v+m+1,x[i]); y[i]=*std::lower_bound(v+1,v+m+1,y[i]); }\n\tfr(i,1,n) e[x[i]].push_back(y[i]);\n//\tfr(i,1,m) fr(j,0,e[i].size()-1) printf(\"%d %d\\n\",i,e[i][j]);\n\tfr(i,1,m) std::sort(e[i].begin(),e[i].end());\n//\tfr(i,1,m) fr(j,0,e[i].size()-1) printf(\"%d %d\\n\",i,e[i][j]);\n//\tprintf(\"%d\\n\",m);\n\tfr(i,1,m)\n\t{\n\t\tfr(j,0,e[i].size()-1) if(!j||e[i][j]!=e[i][j-1]) ans=(ans+(f[j]=query(e[i][j]-1)+1))%mod;\n\t\tfr(j,0,e[i].size()-1) if(!j||e[i][j]!=e[i][j-1]) modify(e[i][j],f[j]);\n\t}\n\tprintf(\"%lld\\n\",ans==mod-1?0:ans+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1e9 + 7;\n\nvoid compress_coordinate(VI &x){\n    int n = x.size();\n    VI xc;\n    xc.push_back(-1);\n    REP(i,n) xc.push_back(x[i]);\n    sort(ALL(xc));\n    xc.erase(unique(ALL(xc)), xc.end());\n    map<int,int> mp;\n    REP(i,xc.size()) mp[xc[i]] = i;\n    REP(i,n) x[i] = mp[x[i]];\n}\n\nstruct BIT{\n    int n;\n    VL bit;\n\n    BIT(){}\n    BIT(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void init(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void add(int i, ll x){\n        i++;\n        while (i <= n){\n            (bit[i] += x) %= mod;\n            i += i & -i;\n        }\n    }\n\n    // [0, i]\n    ll sum(int i){\n        i++;\n        ll ret = 0;\n        while (i > 0){\n            (ret += bit[i]) %= mod;\n            i -= i & -i;\n        }\n        return ret;\n    }\n\n    // [l, r)\n    ll sum(int l, int r){\n        if (l >= r) return 0;\n        return (sum(r-1) - sum(l-1) + mod) % mod;\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VI x(n), y(m);\n    REP(i,n) x[i] = in();\n    REP(i,m) y[i] = in();\n    VI l, r;\n    int k = 0;\n    REP(i,n){\n        while (k < m && x[i] >= y[k]) k++;\n        if (k == 0 || k == m) continue;\n        l.push_back(x[i] - y[k-1]);\n        r.push_back(y[k] - x[i]);\n    }\n\n    n = l.size();\n\n    // compress_coordinate(l);\n    // compress_coordinate(r);\n\n    vector<P> pa(n);\n    REP(i,n) pa[i] = P(l[i], -r[i]);\n    sort(ALL(pa));\n\n    VVI p(n+1);\n    REP(i,n){\n        p[pa[i].first].push_back(-pa[i].second);\n    }\n\n    BIT bit(n+1);\n    bit.add(0, 1);\n    REP(i,n+1){\n        REP(j,p[i].size()){\n            if (j > 0 && p[i][j] == p[i][j-1]) continue;\n            int x = p[i][j];\n            bit.add(x, bit.sum(x - 1));\n        }\n    }\n\n    ll ans = bit.sum(n);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\ntypedef long long ll;\nusing namespace std;\n\nstruct specialPair{\n    int a, b;\n    specialPair(int p, int q){\n        a=p;\n        b=q;\n    }\n    bool operator<(const specialPair& right) const{\n        if(a!=right.a) return a<right.a;\n        return b>right.b;\n    }\n    bool operator!=(const specialPair& right) const{\n        return (a!=right.a) || (b!=right.b);\n    }\n};\n\nint x[100010], y[100010];\nll mod=1000000007;\nvector<specialPair> v;\nvector<pair<int, int>> pr;\n\nll bit[100010]={};\nvoid bitAdd(int n, ll a){\n    for(int i=n; i<100010; i += i&(-i)){\n        (bit[i] += a) %= mod;\n    }\n}\nll bitSum(int n){\n    ll res=0;\n    for(int i=n; i>0; i -= i&(-i)){\n        (res += bit[i]) %= mod;\n    }\n    return res;\n}\n\n\nint main(void){\n    int N, M;\n    cin >> N >> M;\n    for(int i=0; i<N; ++i) cin >> x[i];\n    for(int i=0; i<M; ++i) cin >> y[i];\n    int now=0;\n    for(int i=0; i<N; ++i){\n        while(now<M){\n            if(y[now]>x[i]) break;\n            ++now;\n        }\n        if(now>0 && now<M){\n            v.emplace_back(specialPair(x[i]-y[now-1], y[now]-x[i]));\n        }\n    }\n    if(v.empty()){\n        cout << 1 << endl;\n        return 0;\n    }\n    sort(v.begin(), v.end());\n    pr.resize(v.size());\n    for(int i=0; i<v.size(); ++i){\n        pr[i]=make_pair(v[i].b, i);\n    }\n    sort(pr.begin(), pr.end());\n    v[pr[0].second].b=2;\n    for(int i=1; i<v.size(); ++i){\n        v[pr[i].second].b=v[pr[i-1].second].b;\n        if(pr[i-1].first<pr[i].first) ++v[pr[i].second].b;\n    }\n    bitAdd(1, 1);\n    ll sumh=bitSum(v[0].b-1);\n    bitAdd(v[0].b, sumh);\n    for(int i=1; i<v.size(); ++i){\n        if(v[i-1]!=v[i]){\n            sumh=bitSum(v[i].b-1);\n            bitAdd(v[i].b, sumh);\n        }\n    }\n    cout << bitSum(100009) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<typename T> struct BIT {\n    int S;\n    vector<T> v;\n\n    BIT<T>(int _S) {\n        S = _S;\n        v.resize(S+1);\n    }\n\n    void update(int i, T k) {\n        for(i++; i <= S; i += i&-i)\n            v[i] = v[i] + k;\n    }\n\n    T read(int i) {\n        T sum = 0;\n        for(i++; i; i -= i&-i)\n            sum = sum + v[i];\n        return sum;\n    }\n\n    T read(int l, int r) {\n        return read(r) - read(l-1);\n    }\n\n    /*\n     * Returns in O(logS) the first index i such that read(i) >= sum.\n     * Returns S if no such i exists.\n     * Requires that read(i) is non-decreasing in i.\n     */\n    int lower_bound(T sum) {\n        T res = 0;\n        int inx = 0;\n        for (int i = 31 - __builtin_clz(S); i >= 0; i--) {\n            if ((inx + (1 << i) <= S) && res + v[inx + (1 << i)] < sum) {\n                inx += 1 << i;\n                res += v[inx];\n            }\n        }\n        return inx;\n    }\n};\n\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { ll v; i >> v; n = modnum(v); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(ll e) const {\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static int totient() {\n        int tot = MOD, tmp = MOD;\n        for (int p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static int primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        int tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (int p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (int r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (int p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static int discrete_log(modnum v) {\n        static const int M = ceil(sqrt(MOD));\n        static unordered_map<int, int> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (int i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (int i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum<MOD>> fact = { 1 };\n        while (fact.size() <= n)\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        if (r < 0 || n < r) return 0;\n        return fact(n) / (fact(r) * fact(n - r));\n    }\n};\nusing mn = modnum<int(1e9 + 7)>;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N, M;\n    cin >> N >> M;\n\n    vi bot(N), ext(M);\n    for (int i = 0; i < N; i++) {\n        cin >> bot[i];\n    }\n    for (int i = 0; i < M; i++) {\n        cin >> ext[i];\n    }\n\n    vector<pair<int, int>> left, right;\n    for (int i = 0, l = 0; i < N; i++) {\n        while (l + 1 < M && ext[l + 1] < bot[i]) l++;\n        if (ext[l] > bot[i] || l + 1 == M) continue;\n        left.emplace_back(bot[i] - ext[l], i);\n        right.emplace_back(ext[l+1] - bot[i], i);\n    }\n\n    auto groups = [](vector<pair<int, int>>& dists) {\n        sort(all(dists));\n        vvi res;\n        for (int i = 0; i < sz(dists); i++) {\n            if (i && dists[i].first == dists[i-1].first)\n                res.back().push_back(dists[i].second);\n            else res.push_back({ dists[i].second });\n        }\n        return res;\n    };\n    vvi lg = groups(left), rg = groups(right);\n\n    vi rloc(N, -1);\n    for (int g = 0; g < sz(rg); g++) {\n        for (int e : rg[g]) rloc[e] = g;\n    }\n\n    BIT<mn> ways(sz(rg) + 1);\n    ways.update(0, 1);\n\n    for (int g = 0; g < sz(lg); g++) {\n        vi rm;\n        for (int e : lg[g])\n            if (rloc[e] != -1)\n                rm.push_back(rloc[e]);\n        sort(all(rm), greater<int>());\n        rm.erase(unique(all(rm)), rm.end());\n\n        for (int r : rm) {\n            ways.update(r + 1, ways.read(r));\n        }\n    }\n\n    cout << ways.read(sz(rg)) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int maxn = 100001;\nconst int mod = 1e9 + 7;\ntypedef long long ll;\nint n, m;\nstd::vector<int> v0, v1;\nstd::vector<std::pair<int,int>> v;\nstd::vector<int> o;\nint a[maxn], f[maxn];\ninline int id(int x){ return std::lower_bound(o.begin(),o.end(),x) - o.begin() + 1; } \ninline void reduce(int & x) { x += x >> 31 & mod; }\nint main()\n{\n\tstd::ios::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> m;\n\tfor(int i = 0, x;i < n;++i) std::cin >> x, v0.push_back(x);\n\tfor(int i = 0, x;i < m;++i) std::cin >> x, v1.push_back(x);\n\tfor(auto & i : v0) \n\t\tif(v1.front() <= i && i <= v1.back()) {\n\t\t\tauto _ = std::lower_bound(v1.begin(),v1.end(),i);\n\t\t\tv.emplace_back(i - *std::prev(_),i - *_);\n\t\t\to.push_back(*_ - i);\n\t\t}\n\tstd::sort(o.begin(),o.end()), o.erase(std::unique(o.begin(),o.end()),o.end());\n\tstd::sort(v.begin(),v.end()), v.erase(std::unique(v.begin(),v.end()),v.end());\n\tfor(int i = 0;i < v.size();++i) {\n\t\tf[i]=1;\n\t\tfor(int x = id(-v[i].second) - 1;x;x &= x - 1) reduce(f[i] += a[x] - mod);\n\t\tfor(int x = id(-v[i].second);x < maxn;x += x & -x) reduce(a[x] += f[i] - mod);\n\t}\n\tint ans = 1;\n\tfor(int i = 1e5;i;i &= i - 1) reduce(ans += a[i] - mod);\n\tstd::cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pii pair<int, int>\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int maxN = 1e5 + 10, oo = 1e9 + 5, mod = 1e9 + 7;\n\nint x[maxN], y[maxN], fen[maxN];\nvector <pii> p;\nvector <int> ys;\n\nvoid upd(int q, int val){for(q++; q<maxN; q +=q&-q) fen[q] += val, fen[q] %= mod;}\nint get(int q){int res = 0; for(; q>0; q-=q&-q) res += fen[q], res %= mod; return res;}\n\nvoid UPD(int L, int R, int v)\n{\n\tv %= mod;\n\tupd(L, +v);\n\tupd(R, mod - v);\n}\n\nint GET(int q)\n{\n\treturn get(q + 1);\n}\n\nbool cmp(pii A, pii B)\n{\n\treturn make_pair(A.F, -A.S) < make_pair(B.F, -B.S);\n}\n\n\nint main()\n{\n\tint n, m; cin >> n >> m;\n\tfor (int i=0; i<n; i++)\n\t\tcin >> x[i];\n\tfor (int i=0; i<m; i++)\n\t\tcin >> y[i];\n\n\tsort(x, x + n);\n\tsort(y, y + m);\n\n\tfor (int i=0; i<n; i++)\n\t\tif(x[i] > y[0] && x[i] < y[m - 1])\n\t\t{\n\t\t\tint u = upper_bound(y, y + m, x[i]) - y;\n\t\t\tp.push_back({x[i] - y[u - 1], y[u] - x[i]});\n\t\t}\n\n\tsort(p.begin(), p.end(), cmp);\n\tp.resize(unique(p.begin(), p.end()) - p.begin());\n\t\n\tn = p.size();\n\tfor (int i=0; i<n; i++) ys.pb(p[i].S);\n\n\tsort(ys.begin(), ys.end()); ys.pb(oo);\n\tys.resize(unique(ys.begin(), ys.end()) - ys.begin());\n\n\tint k = ys.size();\n\n\tfor (int i=0; i<n; i++)\n\t\tp[i].S = lower_bound(ys.begin(), ys.end(), p[i].S) - ys.begin();\n\n\tUPD(0, k, +1);\n\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tint yp = p[i - 1].S;\n\t\tint r = GET(yp);\n\t\tUPD(yp + 1, k, r);\n\t}\n\n\tcout << GET(k - 1) << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reg register\n#define pr std::pair<int, int>\n#define fi first\n#define se second\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\n#define Rep(i, n) rep(i, 1, n)\n#define Lep(i, n) lep(i, 1, n)\n#define IRep(i, n) irep(i, n, 1)\n#define ILep(i, n) ilep(i, n, 1)\ntypedef long long ll;\ntypedef long double ld;\n\nnamespace modular {\n    const int MOD = 1000000007;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1) ans = mul(ans, x);\n        return ans;\n    }\n};  // namespace modular\nusing namespace modular;\n\nnamespace Base {\n    template <typename Tp>\n    inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return 0;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp>\n    inline void read(Tp &x) {\n        x = input<Tp>();\n    }\n    template <typename Tp>\n    inline void chmax(Tp &x, Tp y) {\n        x < y ? x = y : 0;\n    }\n    template <typename Tp>\n    inline void chmin(Tp &x, Tp y) {\n        x > y ? x = y : 0;\n    }\n};  // namespace Base\nusing namespace Base;\n/*----------------------------------------------------------------------------*/\n\n#define MAX_N 400007\n\nint N, M, top;\nint a[MAX_N], b[MAX_N], lasx[MAX_N], las[MAX_N];\n\nstruct P {\n    int x, y;\n    bool operator<(const P &rhs) const {\n        return x == rhs.x ? y < rhs.y : x < rhs.x;\n    }\n    bool operator==(const P &rhs) const { return x == rhs.x && y == rhs.y; }\n} p[MAX_N];\n\nint bit[MAX_N], cans[MAX_N];\ninline int lowbit(int x) { return x & -x; }\nvoid modi(int x, int val) {\n    while (x <= top) inc(bit[x], val), x += lowbit(x);\n}\nint query(int x) {\n    int ans = 0;\n    while (x) inc(ans, bit[x]), x ^= lowbit(x);\n    return ans;\n}\n\nint mx[MAX_N], f[MAX_N];\nvoid solve() {\n    p[++top] = (P){0, 0};\n    int tmp = 0;\n    Rep(i, top) a[++tmp] = p[i].x;\n    std::sort(a + 1, a + tmp + 1);\n    tmp = std::unique(a + 1, a + tmp + 1) - a - 1;\n    Rep(i, top) p[i].x = std::lower_bound(a + 1, a + tmp + 1, p[i].x) - a;\n    tmp = 0;\n    Rep(i, top) a[++tmp] = p[i].y;\n    std::sort(a + 1, a + tmp + 1);\n    tmp = std::unique(a + 1, a + tmp + 1) - a - 1;\n    Rep(i, top) p[i].y = std::lower_bound(a + 1, a + tmp + 1, p[i].y) - a;\n    std::sort(p + 1, p + top + 1);\n    top = std::unique(p + 1, p + top + 1) - p - 1;\n    // Rep(i, top) printf(\"%d %d\\n\", p[i].x, p[i].y);\n    Rep(i, top) {\n        las[i] = lasx[p[i].y];\n        chmax(mx[p[i].y], p[i].x);\n        lasx[p[i].y] = i;\n    }\n    // Rep(i, top) printf(\"%d \", las[i]);\n    // puts(\"\");\n    modi(1, 1);\n    int res = 1, sum = 1, cur = 2;\n    rep(i, 2, top) {\n        int val = query(p[i].y);\n        f[i] = val;\n        if (p[i].x != p[i + 1].x) {\n            rep(j, cur, i) {\n                modi(p[j].y, (MOD - cans[p[j].y]) % MOD);\n                modi(p[j].y, f[j]);\n                cans[p[j].y] = f[j];\n            }\n            cur = i + 1;\n        }\n        // printf(\"%d %d %d\\n\", p[i].x, p[i].y, val);\n        if (mx[p[i].y] == p[i].x) inc(res, val);\n    }\n    printf(\"%d\\n\", res);\n}\n\nint main() {\n    read(N), read(M);\n    Rep(i, N) read(a[i]);\n    Rep(i, M) read(b[i]);\n    int l = 0;\n    Rep(i, N) {\n        while (l < M && b[l + 1] < a[i]) l++;\n        if (l) p[i].x = a[i] - b[l];\n    }\n    l = M + 1;\n    IRep(i, N) {\n        while (l > 1 && b[l - 1] > a[i]) l--;\n        if (l <= M) p[i].y = b[l] - a[i];\n    }\n    Rep(i, N) if (p[i].x && p[i].y) p[++top] = p[i];\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate<class T,class U> using P = pair<T,U>;\ntemplate<class T> using vec = vector<T>;\ntemplate<class T> using vvec = vector<vec<T>>;\n\nconstexpr ll mod = 1e9+7;\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n\n    bool operator==(const mint& a)const{\n        return x==a.x;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\ntemplate<typename Monoid,typename OperatorMonoid,typename F,typename G,typename H>\nclass LazySegmentTree {\nprivate:\n\tint sz,height;\n\tvec<Monoid> data;\n\tvec<OperatorMonoid> lazy;\n\tconst F op;\n\tconst G homo;\n\tconst H comp;\n  \tconst Monoid e;\n\tconst OperatorMonoid Oe;\npublic:\n\tLazySegmentTree(int n,const F op,const G homo,const H comp,\n\t\t\t\t\tconst Monoid &e,const OperatorMonoid Oe)\n\t\t: op(op),homo(homo),comp(comp),e(e),Oe(Oe) {\n\t\tsz = 1;\n\t\theight = 0;\n\t\twhile(sz<=n) sz <<= 1,height++;\n\t\tdata.assign(2*sz,e);\n\t\tlazy.assign(2*sz,Oe);\n\t}\n\n\tvoid set(int k,const Monoid &x) {\n\t\tdata[k+sz] = x;\n\t}\n\n\tvoid build() {\n\t\tfor(int k=sz-1;k>0;k--) {\n\t\t\tdata[k] = op(data[2*k], data[2*k+1]);\n\t\t}\n\t}\n\n\tinline void propagate(int k) {\n\t\tif(lazy[k]!=Oe) {\n\t\t\tlazy[2*k] = comp(lazy[2*k], lazy[k]);\n\t\t\tlazy[2*k+1] = comp(lazy[2*k+1], lazy[k]);\n\t\t\tdata[k] = reflect(k);\n\t\t\tlazy[k] = Oe;\n\t\t}\n\t}\n\n\tinline Monoid reflect(int k) {\n\t\treturn lazy[k] == Oe? data[k]:homo(data[k],lazy[k]);\n\t}\n\n\tinline void recalc(int k) {\n\t\twhile(k>>=1) data[k] = op(reflect(2*k), reflect(2*k+1));\n\t}\n\n\tinline void thrust(int k) {\n\t\tfor(int i=height;i>0;i--) propagate(k>>i);\n\t}\n\n\tvoid update(int a, int b, const OperatorMonoid &x) {\n\t\tthrust(a+=sz);\n\t\tthrust(b+=sz-1);\n\t\tfor(int l=a,r=b+1;l<r;l>>=1,r>>=1) {\n\t\t\tif(l&1) lazy[l] = comp(lazy[l],x),++l;\n\t\t\tif(r&1) --r, lazy[r] = comp(lazy[r],x);\n\t\t}\n\t\trecalc(a);\n\t\trecalc(b);\n\t}\n\n\tMonoid query(int a, int b) {\n\t\tthrust(a+=sz);\n\t\tthrust(b+=sz-1);\n\t\tMonoid L = e, R = e;\n\t\tfor(int l=a, r=b+1;l<r;l>>= 1,r>>=1) {\n\t\t\tif(l&1) L = op(L,reflect(l++));\n\t\t\tif(r&1) R = op(reflect(--r),R);\n\t\t}\n\t\treturn op(L,R);\n\t}\n\n\tMonoid operator[](const int &k) {\n\t\treturn query(k,k+1);\n\t}\n};\n\ntemplate <class T>\nclass Compress{\n    map<T,int> idx;\n    map<int,T> value;\n    vector<T> cmp;\npublic:\n    int N;\n    Compress(vector<T> v){\n        for(auto& x:v) cmp.push_back(x);\n        sort(cmp.begin(),cmp.end());\n        cmp.erase(unique(cmp.begin(),cmp.end()),cmp.end());\n        N = cmp.size();\n        for(int i=0;i<N;i++) idx[cmp[i]] = i;\n    }\n    int id(T val){return idx[val];}\n    T val(int id){return cmp[id];}\n};\n\nstruct robot{\n    int l,r;\n    bool operator<(const robot& R)const{\n        if(l!=R.l) return l<R.l;\n        return r<R.r;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,M;\n    const int inf = 2e9;\n    cin >> N >> M;\n    vec<int> X(N),Y(M+1,-inf);\n    for(int i=0;i<N;i++) cin >> X[i];\n    for(int i=1;i<=M;i++) cin >> Y[i];\n    Y.push_back(inf);\n    vec<robot> R(N);\n    vec<int> v = {0};\n    for(int i=0;i<N;i++){\n        int id = lower_bound(Y.begin(),Y.end(),X[i])-Y.begin();\n        int r = (id!=Y.size()-1? Y[id]-X[i]:inf),l = (id!=1? X[i]-Y[id-1]:inf);\n        R[i] = {l,r};\n        if(r!=inf) v.push_back(r);\n    }\n    sort(R.begin(),R.end());\n    Compress<int> cmp(v);\n    int n = cmp.N;\n\n    struct state{\n        mint val;\n        ll len;\n    };\n    auto op = [](state L,state R){return (state){L.val+R.val,L.len+R.len};};\n    auto homo = [](state S,ll x){return (state){x*S.len,S.len};};\n    auto comp = [](ll x,ll y){return (y!=-1? y:x);};\n    LazySegmentTree<state,ll,decltype(op),decltype(homo),decltype(comp)>\n    seg(n,op,homo,comp,(state){0,0},-1);\n    for(int i=0;i<n;i++){\n        seg.set(i,(state){i==0,1});\n    }\n    seg.build();\n//    cerr << endl;\n    for(int i=0;i<N;i++){\n//        cerr << R[i].l << \" \" << R[i].r << endl;\n        if(R[i].r!=inf){\n            int l = ((i==0 || R[i].l!=R[i-1].l)? 0:R[i-1].r);\n            state add = seg.query(l,R[i].r);\n            state res = seg.query(R[i].r,R[i].r+1);\n            ll x = (res.val+add.val).x;\n            seg.update(R[i].r,R[i].r+1,x);\n        }\n        if(R[i].l==inf) seg.update(0,R[i].r,0);\n//        for(int i=0;i<n;i++) cerr << seg[i].val.x << (i!=n-1? \" \":\"\\n\");\n    }\n    mint ans = 0;\n    for(int i=0;i<n;i++) ans += seg[i].val;\n    cout << ans.x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )\n#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )\n#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )\n#define re register\n#define int long long\n#define ls(x) tr[x].l\n#define rs(x) tr[x].r\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;\n\treturn cn * flus ;\n}\nconst int P = 1e9 + 7 ; \nconst int N = 2e5 + 5 ; \nint n, m, cnt, num, Rt, M, lef[N], ref[N], dp[N] ;\nstruct node { int p, f ; } a[N << 1] ;\nstruct Px { int x, y ; } c[N] ; \nbool cmp( node x, node y ) { return x.p < y.p ; }\nbool cmp2( Px a, Px b ) { return ( a.x == b.x ) ? ( a.y > b.y ) : a.x < b.x ; }\nstruct Tr { int l, r, w ; } tr[N * 20] ;\nvoid insert( int &x, int l, int r, int wh, int val ) {\n\tif( !x ) x = ++ num ; tr[x].w += val, tr[x].w %= P ; \n\tif( l == r ) return ; \n\tint mid = ( l + r ) >> 1 ; \n\tif( mid >= wh ) insert( ls(x), l, mid, wh, val ) ;\n\telse insert( rs(x), mid + 1, r, wh, val ) ;\n}\nint query( int x, int l, int r, int wh ) {\n\tif( l == r ) return 0 ; \n\tint mid = ( l + r ) >> 1 ; \n\tif( mid >= wh ) return query( ls(x), l, mid, wh ) ;\n\telse return ( query( rs(x), mid + 1, r, wh ) + tr[ls(x)].w ) % P ; \n}\nsigned main()\n{\n\tn = gi(), m = gi() ; int maxn = 0 ;\n\trep( i, 1, n ) a[i].p = gi(), maxn = max( maxn, a[i].p ), a[i].f = 1 ; \n\trep( i, 1, m ) a[i + n].p = gi(), maxn = max( maxn, a[i + n].p ) ; \n\tM = n + m, ++ maxn ; \n\tsort( a + 1, a + M + 1, cmp ) ;\n\trep( i, 1, M ) lef[i] = ( a[i].f ) ? lef[i - 1] : a[i].p ; \n\tdrep( i, 1, M ) ref[i] = ( a[i].f ) ? ref[i + 1] : a[i].p ; \n\trep( i, 1, M ) {\n\t\tif( (!lef[i]) || (!ref[i]) || (!a[i].f) ) continue ; \n\t\t++ cnt, c[cnt].x = a[i].p - lef[i], c[cnt].y = ref[i] - a[i].p ; \n\t}\n\tsort( c + 1, c + cnt + 1, cmp2 ) ; int Ans = 1 ; \n\trep( i, 1, cnt ) {\n\t\tdp[i] = 1 + query( 1, 1, maxn, c[i].y ) ;\n\t\tinsert( Rt, 1, maxn, c[i].y + 1, dp[i] ) ;\n\t\tAns = ( Ans + dp[i] ) % P ; \n\t}\n\tcout << Ans << endl ; \n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define fi first\n#define se second\n#define sz(x) (int)(x).size()\n#define INF 0x3f3f3f3f\n//#define Local\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int N = 1e5 + 5, MOD = 1e9 + 7;\n\nint n, m;\nint x[N], y[N], d[N << 1];\nstruct Point{\n    int a, b;\n    bool operator < (const Point& A) const {\n        if(a == A.a) return b < A.b;\n        return a < A.a;\n    }\n}p[N];\n\nll dp[N];\nint c[N];\nint lowbit(int x) {return x & (-x);}\n\nvoid add(int x, int v) {\n    for(; x < N; x += lowbit(x)) c[x] = (c[x] + v) % MOD;\n}\n\nint query(int x) {\n    int ans = 0;\n    for(; x > 0; x -= lowbit(x)) ans = (ans + c[x]) % MOD;\n    return ans;\n}\n\nvoid run() {\n    d[0] = 0;\n    memset(c, 0, sizeof(c));\n    for(int i = 1; i <= n; i++) cin >> x[i];\n    for(int i = 1; i <= m; i++) cin >> y[i];\n    int cnt = 0;\n    for(int i = 1; i <= n; i++) {\n        int left = lower_bound(y + 1, y + m + 1, x[i]) - y - 1;\n        int right = lower_bound(y + 1, y + m + 1, x[i]) - y;\n        int l, r;\n        l = x[i] - y[left], r = y[right] - x[i];\n        if(left != 0 && right != m + 1) {\n            p[++cnt] = {l, r};\n            d[++d[0]] = r;\n        }\n    }\n    sort(d + 1, d + d[0] + 1);\n    d[0] = unique(d + 1, d + d[0] + 1) - d - 1;\n    sort(p + 1, p + cnt + 1);\n    for(int i = 1; i <= cnt; i++) {\n        int q = lower_bound(d + 1, d + d[0] + 1, p[i].b) - d;\n        dp[i] = query(q - 1);\n        if(p[i].a != p[i - 1].a) ++dp[i];\n        if(dp[i] >= MOD) dp[i] -= MOD;\n        add(q, dp[i]);\n    }\n    int ans = 1;\n    for(int i = 1; i <= cnt; i++) {\n        ans = (ans + dp[i]) % MOD;\n    }\n    cout << ans << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    cout << fixed << setprecision(20);\n#ifdef Local\n    freopen(\"../input.in\", \"r\", stdin);\n    freopen(\"../output.out\", \"w\", stdout);\n#endif\n    while(cin >> n >> m) run();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define all(x) x.begin(), x.end()\nusing namespace std;\nconst int maxn = 1<<18, mod = 1000000007;\nusing ll = long long;\nint n, m;\nstruct node\n{\n\tll a, b, sum;\n\tnode() {sum = 0; a = 1;b = 0;}\n\tnode(int val)\n\t{\n\t\tsum = val;\n\t\ta = 1;b = 0;\n\t}\n\tvoid apply(ll c, ll d) {\n\t\tll na = c*a%mod;\n\t\tll nb = (c*b + d)%mod;\n\t\ta = na, b = nb;\n\t}\n};\n \nnode temp, broken;\n \nnode merge(node l, node r)\n{\n\ttemp.sum = (l.sum + r.sum)%mod;\n\ttemp.a = 1;temp.b = 0;\n\treturn temp;\n}\n \nstruct segment_tree\n{\n\tnode tr[4 * maxn];\n \n\tvoid push(int l, int r, int idx)\n\t{\n\t\ttr[idx].sum = ( ((r - l + 1) * tr[idx].b) + (tr[idx].sum * tr[idx].a) )%mod;\n\t\tif(l != r)\n\t\t{\n\t\t\ttr[2 * idx + 1].apply(tr[idx].a, tr[idx].b);\n\t\t\ttr[2 * idx + 2].apply(tr[idx].a, tr[idx].b);\n\t\t}\n\t\ttr[idx].a = 1;tr[idx].b = 0;\n\t}\n \n\tvoid init(int l, int r, int idx)\n\t{\n\t\tif(l == r)\n\t\t{\n\t\t\ttr[idx] = node();\n\t\t\treturn;\n\t\t}\n \n\t\tint mid = (l + r) >> 1;\n\t\tinit(l, mid, 2 * idx + 1);\n\t\tinit(mid + 1, r, 2 * idx + 2);\n \n\t\ttr[idx] = merge(tr[2 * idx + 1], tr[2 * idx + 2]);\n\t}\n \n\tvoid update(int qL, int qR, int A, int B, int l, int r, int idx)\n\t{\n\t\tpush(l, r, idx);\n \n\t\tif(qL > r || l > qR)\n\t\t\treturn;\n \n\t\tif(qL <= l && r <= qR)\n\t\t{\n\t\t\ttr[idx].apply(A, B);\n\t\t\tpush(l, r, idx);\n\t\t\treturn;\n\t\t}\n \n\t\tint mid = (l + r) >> 1;\n\t\tupdate(qL, qR, A, B, l, mid, 2 * idx + 1);\n\t\tupdate(qL, qR, A, B, mid + 1, r, 2 * idx + 2);\n \n\t\ttr[idx] = merge(tr[2 * idx + 1], tr[2 * idx + 2]);\n\t}\n \n\tnode query(int qL, int qR, int l, int r, int idx)\n\t{\n\t\tpush(l, r, idx);\n \n\t\tif(l > qR || r < qL)\n\t\t\treturn broken;\n \n\t\tif(qL <= l && r <= qR)\n\t\t\treturn tr[idx];\n \n\t\tint mid = (l + r) >> 1;\n\t\treturn merge(query(qL, qR, l, mid, 2 * idx + 1), query(qL, qR, mid + 1, r, 2 * idx + 2));\n\t}\n};\n \nsegment_tree st;\nvector<int> a, b;\nint tree[maxn];\nsigned main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> m;\n\ta.resize(n);\n\tb.resize(m);\n\tfor(auto &i : a) cin >> i;\n\tfor(auto &i : b) cin >> i;\n\tvector<array<int, 2>> segs;\n\tvector<int> C{0};\n\tfor(auto &i : a) {\n\t\tauto it = upper_bound(all(b), i);\n\t\tif(it == b.begin() || it == b.end()) continue;\n\t\tauto it2 = it; it2--;\n\t\tsegs.push_back({i-*it2, *it-i});\n\t\tC.push_back(segs.back()[1]);\n\t}\n\tsort(all(C));\n\tfor(auto &[x, y] : segs) y = lower_bound(all(C), y)-C.begin();\n\tfor(auto &[x, y] : segs) y *= -1;\n\tsort(all(segs));\n\tsegs.erase(unique(all(segs)), segs.end());\n\tfor(auto &[x, y] : segs) y *= -1;\n\tst.init(0, n, 0);\n\tst.update(0, 0, 0, 1, 0, n, 0);\n\tfor(auto &[cur, p] : segs) {\n\t\tst.update(p, p, 1, st.query(0, p-1, 0, n, 0).sum, 0, n, 0);\n\t}\n\tcout << st.query(0, n, 0, n, 0).sum << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\nconst int mod = 1e9 + 7;\n\nint n, m, cnt, a[N], b[N];\nint tmpx[N], tmpy[N], c1, c2;\n\nstruct node {\n\tint x, y;\n\tbool operator < (const node &T) const {\n\t\treturn x == T.x ? y > T.y : x < T.x;\n\t}\n}A[N];\n\nstruct Fenwick_Tree {\n\tint s[N];\n\tvoid update(int x, int y) {for(; x <= c2; x += x & -x) (s[x] += y) %= mod;}\n\tint query(int x) {int res = 0; for(; x; x -= x & -x) (res += s[x]) %= mod; return res;}\n}T;\n\nvoid Init() {\n\tint x; priority_queue<int, vector<int>, greater<int>> q;\n\tcin >> n >> m;\n\tfor(int i = 1; i <= n; ++ i) cin >> x, q.push(x);\n\tfor(int i = 1; i <= m; ++ i) cin >> b[i]; n = 0;\n\twhile(!q.empty()) {\n\t\tint k = q.top(), pos = lower_bound(b + 1, b + m + 1, k) - b; q.pop();\n\t\tif(k <= b[1] || k >= b[m] || b[pos] == k) continue;\n\t\tA[++ cnt].x = b[pos] - k; A[cnt].y = k - b[pos - 1];\n\t\ttmpx[++ c1] = A[cnt].x, tmpy[++ c2] = A[cnt].y;\n\t}\n\tsort(tmpx + 1, tmpx + c1 + 1), sort(tmpy + 1, tmpy + c2 + 1);\n\tc1 = unique(tmpx + 1, tmpx + c1 + 1) - tmpx - 1;\n\tc2 = unique(tmpy + 1, tmpy + c2 + 1) - tmpy - 1;\n\tfor(int i = 1; i <= cnt; ++ i) {\n\t\tA[i].x = lower_bound(tmpx + 1, tmpx + c1 + 1, A[i].x) - tmpx;\n\t\tA[i].y = lower_bound(tmpy + 1, tmpy + c2 + 1, A[i].y) - tmpy;\n\t}\n\tsort(A + 1, A + cnt + 1);\n}\n\nvoid Solve() {\n\tint ans = 1;\n\tfor(int i = 1; i <= cnt; ++ i) {\n\t\tif(A[i].y == A[i - 1].y && A[i].x == A[i - 1].x) continue;\n\t\tint now = T.query(A[i].y - 1) + 1;\n\t\t(ans += now) %= mod;\n\t\tT.update(A[i].y, now);\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nstruct BIT { //0-origin!!! update and get just like lazy_segtree\n\tint n; vl bit0, bit1;\n\tvoid init(int mx) {\n\t\tn = mx;\n\t\tbit0 = vl(n + 1, 0); bit1 = vl(n + 1, 0);\n\t}\n\tBIT(int mx = 0) { init(mx); } \n\n\tll ga(vl& bit, int i) {\n\t\tll s = 0;\n\t\twhile(i > 0) { ADD(s, bit[i]); i -= i & -i; }\n\t\treturn s;\n\t}\n\tvoid app(vl& bit, int i, ll x) {\n\t\twhile(i <= n) { ADD(bit[i], x); i += i & -i; }\n\t}\n\tvoid update(int a, int b, ll x) { //[a, b)\n\t\ta++;\n\t\tapp(bit0, a, -x * (a - 1));\n\t\tapp(bit1, a, x);\n\t\tapp(bit0, b + 1, x * b);\n\t\tapp(bit1, b + 1, -x);\n\t}\n\tll get(int a, int b) { //[a, b)\n\t\ta++;\n\t\treturn ((ga(bit1, b) * b % mod + ga(bit0, b) % mod) % mod \n\t\t\t- (ga(bit1, a - 1) * (a - 1) % mod + ga(bit0, a - 1) % mod) + mod) % mod;\n\t}\n};\n\nint N, M;\nll X[MAX_N], Y[MAX_N];\nll L[MAX_N], R[MAX_N];\nvl vec;\nvl Q[MAX_N];\n\nint fd(ll v) {\n\treturn lower_bound(all(vec), v) - vec.begin();\n}\n\nvoid solve() {\n\tcin >> N >> M;\n\trep(i, 0, N) cin >> X[i + 1];\n\trep(i, 0, M) cin >> Y[i + 1];\n\tX[0] = -linf;\n\tY[M + 1] = linf;\n\tint at = 1;\n\trep(i, 0, N) {\n\t\twhile(X[i + 1] > Y[at]) at++;\n\t\tif(at != M + 1) R[i] = Y[at] - X[i + 1];\n\t\telse R[i] = linf;\n\t\tvec.pb(R[i]);\n\t}\n\tat = M;\n\trer(i, N, 0) {\n\t\twhile(X[i + 1] < Y[at]) at--;\n\t\tif(at != 0) L[i] = X[i + 1] - Y[at];\n\t\telse L[i] = linf;\n\t\tvec.pb(L[i]);\n\t}\n\tvec.pb(linf);\n\tsort(all(vec));\n\t// debug(vl(L, L + N));\n\t// debug(vl(R, R + N));\n\tvec.erase(unique(all(vec)), vec.end());\n\trep(i, 0, N) {\n\t\tint lat = fd(L[i]), rat = fd(R[i]);\n\t\tQ[lat].pb(rat);\n\t}\n\trep(i, 0, sz(vec)) {\n\t\tsort(all(Q[i]));\n\t\tQ[i].erase(unique(all(Q[i])), Q[i].end());\n\t}\n\tBIT bit(sz(vec));\n\tbit.update(sz(vec) - 1, sz(vec), 1);\n\trer(i, sz(vec) - 1, 0) {\n\t\trep(j, 0, sz(Q[i])) {\n\t\t\tint b = Q[i][j];\n\t\t\tll v = bit.get(b + 1, sz(vec));\n\t\t\t// debug(vec[i], vec[b], v);\n\t\t\tbit.update(b, b + 1, v);\n\t\t}\n\t}\n\tcout << bit.get(0, sz(vec)) << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define sc second\n#define fi first\n#define pii pair <int,int>\n#define ll long long\n#define lowbit(a) a&-a\nusing namespace std;\n\ninline int read(){\n\tint sum=0,f=1;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=sum*10+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\n\nconst int N=100005;\nconst int Mod=1e9+7;\nint n,m,a[N],b[N],d[N],t1,t2;\nll t[N],ans=1;\npair <int,int> c[N];\n\ninline void add(int x,ll k){\n\tfor(int i=x;i<=t2;i+=lowbit(i)) t[i]=(t[i]+k)%Mod;\t\n}\n\ninline ll ask(int x){\n\tll ret=0;\n\tfor(int i=x;i;i-=lowbit(i)) ret=(ret+t[i])%Mod;\n\treturn ret;\n}\n\nbool cmp(pii a,pii b){return a.fi!=b.fi? a.fi<b.fi:a.sc>b.sc;}\n\nsigned main(){\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tfor(int i=1;i<=m;i++) b[i]=read();\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]<=b[1]||a[i]>=b[m]) continue;\n\t\tint k=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif(a[i]==b[k]) continue;\n\t\tc[++t1]=pii(a[i]-b[k-1],b[k]-a[i]);d[++t2]=b[k]-a[i];\n\t}\n\tsort(d+1,d+t2+1);int l=unique(d+1,d+t2+1)-d-1;\n\tfor(int i=1;i<=t1;i++){\n\t\tc[i].second=lower_bound(d+1,d+l+1,c[i].second)-d;\n\t}\n\tsort(c+1,c+t1+1,cmp);t1=unique(c+1,c+t1+1)-c-1;\n\tfor(int i=1;i<=t1;i++){\n\t\tll sum=ask(c[i].sc-1)+1;\n\t\tans=(ans+sum)%Mod;add(c[i].sc,sum);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define oo 0x7fffffff\n#define lowbit(x) x&(-x)\nusing namespace std;\ntypedef pair<int,int> pii;\ninline int read()\n{\n\tint out=0,fh=1;\n\tchar cc=getchar();\n\twhile ((cc>'9'||cc<'0')&&cc!='-')\n\t\tcc=getchar();\n\tif (cc=='-')\n\t\t{\n\t\t\tfh=-1;\n\t\t\tcc=getchar();\n\t\t}\n\twhile (cc>='0'&&cc<='9')\n\t\t{\n\t\t\tout=out*10+cc-'0';\n\t\t\tcc=getchar();\n\t\t}\n\treturn out*fh;\n}\nconst int MAXN=1e5+10,mod=1e9+7;\nint n,m;\nll c[MAXN],dp[MAXN];\nint a[MAXN],b[MAXN];\npii p[MAXN];\nvoid add(int i,int x)\n{\n\tfor(;i<=n;i+=lowbit(i))\n\t\tc[i]+=x;\n}\nint sum(int i)\n{\n\tll ans=0;\n\tfor(;i;i-=lowbit(i))\n\t\tans+=c[i];\n\treturn ans % mod; \n}\nint cmp(pii a,pii b)\n{\n\treturn a.first!=b.first?a.first<b.first:a.second>b.second;\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read(),m=read();\n\tfor(register int i=1;i<=n;++i)\n\t\ta[i]=read();\n\tfor(register int i=1;i<=m;++i)\n\t\tb[i]=read();\n\tint n0=n;\n\tn=0;\n\tfor(register int i=1;i<=n0;++i)\n\t\t{\n\t\t\tif(a[i]<b[1] || a[i]>b[m])\n\t\t\t\tcontinue;\n\t\t\tint j=lower_bound(b+1,b+1+m,a[i])-b;//a[i]的位置恰好在第j-1个出口与第j个出口之间 \n\t\t\tp[++n]=pii(a[i]-b[j-1],b[j]-a[i]);\n\t\t}\n\tfor(register int i=1;i<=n;++i)\n\t\tb[i]=p[i].second;//进行第一次移动\n\tsort(b+1,b+1+n);\n\tint u=unique(b+1,b+1+n)-b-1;\n\tfor(register int i=1;i<=n;++i)\n\t\tp[i].second=lower_bound(b+1,b+u+1,p[i].second)-b;\n\tsort(p+1,p+n+1,cmp);\n\tfor(register int i=1;i<=n;++i)\n\t\t{\n\t\t\tif(p[i].first==p[i-1].first && p[i].second==p[i-1].second)\n\t\t\t\tdp[i]=0;\n\t\t\telse\n\t\t\t\tdp[i]=sum(p[i].second-1)+1;\n\t\t\tadd(p[i].second,dp[i]); \n\t\t}\n\tll ans=1;\n\tfor(register int i=1;i<=n;++i)\n\t\tans+=dp[i];\n\tprintf(\"%d\",ans%mod);\n\t//fclose(stdin);\n\t//fclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <string>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 100100;\nconst int P = (1 << 18);\nconst int MOD = 1e9 + 7;\n\nint N, M;\nvector <pair <int, int> > lr;\nint x[MAXN], y[MAXN];\n\nll seg[2*P+100];\n\nmap <int, int> mm;\n\nvoid upd (int cloc, ll cval)\n{\n    cloc += P;\n    while (cloc)\n    {\n        seg[cloc] = (seg[cloc] + cval) % MOD;\n        cloc /= 2;\n    }\n}\n\nll add (int cloc)\n{\n    cloc += P;\n    ll res = 0;\n    while (cloc > 1)\n    {\n        if (cloc & 1)\n            res += seg[cloc-1];\n        cloc /= 2;\n    }\n    return res % MOD;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin >> N >> M;\n    for (int i = 0; i < N; i++)\n        cin >> x[i];\n    for (int i = 0; i < M; i++)\n        cin >> y[i];\n\n    int cy = 0;\n    for (int i = 0; i < N; i++)\n    {\n        while (cy < M && y[cy] < x[i])\n            cy++;\n        if (cy == 0 || cy >= M)\n            continue;\n        lr.push_back(make_pair(y[cy-1] - x[i], y[cy] - x[i]));\n    }\n\n    sort (lr.begin(), lr.end());\n    N = lr.size();\n    for (int i = 0; i < N; i++)\n        mm[lr[i].second];\n\n    M = 0;\n    for (map<int, int>::iterator it = mm.begin(); it != mm.end(); it++)\n        it->second = M++;\n    upd (M, 1);\n\n    for (int i = 0; i < N; i++)\n    {\n        if (i > 0 && lr[i] == lr[i-1])\n            continue;\n        int cc = mm[lr[i].second];\n        ll ctot = (MOD + add (M + 2) - add (cc + 1)) % MOD;\n        upd (cc, ctot);\n        // x <= cc\n        // 0, impossible\n        // 1, stay\n\n        // x > cc\n        // 0, stay\n        // 1, push all to cc\n    }\n\n    cout << add (M + 2) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 405949; // 405949 is my favorite number, but it's less than 5e5\nconst int LG = 20;\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); x.resize(unique(all(x)) - (x).begin());\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll inv(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n, m;\nint a[N], b[N], x[N], y[N];\npair<int, int> p[N];\n\nbool comp(pii a, pii b)\n{\n    if (a.fi == b.fi) return a.se > b.se;\n    return a.fi < b.fi;\n}\n\nll Tree[4 * N];\n\nll Get(int l, int r, int L = 0, int R = N, int V = 0)\n{\n    if (r <= L || R <= l) return 0;\n    if (l <= L && R <= r) return Tree[V];\n    int M = (L + R) / 2;\n    return (Get(l, r, L, M, 2 * V + 1) + Get(l, r, M, R, 2 * V + 2)) % MOD;\n}\n\nvoid Add(int p, int val, int L = 0, int R = N, int V = 0)\n{\n    if (L + 1 == R)\n    {\n        Tree[V] = (Tree[V] + val) % MOD;\n        return;\n    }\n    int M = (L + R) / 2;\n    if (p < M) Add(p, val, L, M, 2 * V + 1);\n    else Add(p, val, M, R, 2 * V + 2);\n    Tree[V] = (Tree[2 * V + 1] + Tree[2 * V + 2]) % MOD;\n}\n\nsigned main()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> m;\n    forn(i, n) cin >> a[i];\n    forn(j, m) cin >> b[j];\n    int po = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (b[0] < a[i] && a[i] < b[m - 1])\n        {\n            x[po] = a[i];\n            po++;\n        }\n    }\n    n = po;\n    for (int i = 0; i < m; i++) y[i] = b[i];\n    fill(a, a + N, 0);\n    fill(b, b + N, 0);\n    int c = 0;\n    for (int i = 0; i < n; i++)\n    {\n        while (!(y[c] < x[i] && x[i] < y[c + 1])) c++;\n        a[i] = x[i] - y[c];\n        b[i] = y[c + 1] - x[i];\n    }\n    vi as = {0}, bs = {0};\n    for (int i = 0; i < n; i++) as.push_back(a[i]);\n    for (int i = 0; i < n; i++) bs.push_back(b[i]);\n    uniq(as);\n    uniq(bs);\n    map<int, int> ca, cb;\n    for (int i = 0; i < as.size(); i++) ca[as[i]] = i;\n    for (int i = 0; i < bs.size(); i++) cb[bs[i]] = i;\n    for (int i = 0; i < n; i++)\n    {\n        p[i] = {ca[a[i]], cb[b[i]]};\n    }\n    sort(p, p + n, comp);\n    Add(0, 1);\n    for (int i = 0; i < n; i++)\n    {\n        if (i && p[i].fi == p[i - 1].fi && p[i].se == p[i - 1].se) continue;\n        #ifdef LOCAL\n            cout << p[i].fi << \" \" << p[i].se << \"\\n\";\n            cout << Get(0, p[i].second) << \"\\n\";\n        #endif // LOCAL\n        Add(p[i].second, Get(0, p[i].second));\n    }\n    cout << Get(0, N);\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nCheck corner cases.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod=1000000007,N=100100,inf=INT_MAX;\ninline void upd(int&x,const int&y){x+=y-mod;x+=x>>31&mod;}\nint sm[N],n;\nvoid add(int x,int y){for(;x<=n+1;x+=x&-x)upd(sm[x],y);}\nint qry(int x){int ans=0;for(;x;x-=x&-x)upd(ans,sm[x]);return ans;}\nint m,a[N],b[N];\npair<int,int>c[N];\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;++i)cin>>a[i];\n\tfor(int i=1;i<=m;++i)cin>>b[i];\n\tfor(int i=1;i<=n;++i){\n\t\tint u=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif(u==1)c[i].first=inf;else c[i].first=a[i]-b[u-1];\n\t\tif(u==m+1)c[i].second=inf;else c[i].second=b[u]-a[i];\n\t}\n\tfor(int i=1;i<=n;++i)a[i]=c[i].first,b[i]=c[i].second;\n\tsort(a+1,a+n+1);sort(b+1,b+n+1);\n\tfor(int i=1;i<=n;++i){\n\t\tc[i].first=lower_bound(a+1,a+n+1,c[i].first)-a;\n\t\tc[i].second=-(lower_bound(b+1,b+n+1,c[i].second)-b);\n\t}\n\tsort(c+1,c+n+1);add(1,1);\n\tfor(int i=1;i<=n;++i){\n\t\tc[i].second=-c[i].second;if(i>1&&c[i]==c[i-1])continue;\n\t\tif(a[c[i].first]==inf||b[c[i].second]==inf)continue;\n\t\tadd(c[i].second+1,qry(c[i].second));\n\t}\n\tcout<<qry(n+1)<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef std::pair<int,int> pii;\ntypedef std::pair<ll,ll> pll;\nvoid open(const char *s){\n#ifndef ONLINE_JUDGE\n    char str[100];sprintf(str,\"%s.in\",s);freopen(str,\"r\",stdin);sprintf(str,\"%s.out\",s);freopen(str,\"w\",stdout);\n#endif\n}\nint rd(){int s=0,c,b=0;while(((c=getchar())<'0'||c>'9')&&c!='-');if(c=='-'){c=getchar();b=1;}do{s=s*10+c-'0';}while((c=getchar())>='0'&&c<='9');return b?-s:s;}\nvoid put(int x){if(!x){putchar('0');return;}static int c[20];int t=0;while(x){c[++t]=x%10;x/=10;}while(t)putchar(c[t--]+'0');}\nint upmin(int &a,int b){if(b<a){a=b;return 1;}return 0;}\nint upmax(int &a,int b){if(b>a){a=b;return 1;}return 0;}\nconst ll p=100007;\nconst int N=10010;\nint cmp(pii a,pii b)\n{\n    if(a.first!=b.first)\n        return a.first<b.first;\n    return a.second>b.second;\n}\nint n,m,t,t2;\nint a[N],b[N],d[N];\npii c[N];\nll e[N];\nll add(ll a,ll b)\n{\n    a+=b;\n    return a>=p?a-p:a;\n}\nvoid add(int x,ll v)\n{\n    for(;x<=t2;x+=x&-x)\n        e[x]=add(e[x],v);\n}\nll sum(int x)\n{\n    ll s=0;\n    for(;x;x-=x&-x)\n        s=add(s,e[x]);\n    return s;\n}\nint main()\n{\n    open(\"arc101f\");\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n    for(int i=1;i<=m;i++)\n        scanf(\"%d\",&b[i]);\n    for(int i=1;i<=n;i++)\n        if(a[i]>b[1]&&a[i]<b[m])\n        {\n            int x=lower_bound(b+1,b+m+1,a[i])-b;\n            if(b[x]==a[i])\n                continue;\n            c[++t]=pii(a[i]-b[x-1],b[x]-a[i]);\n            d[++t2]=b[x]-a[i];\n        }\n    sort(d+1,d+t2+1);\n    t2=unique(d+1,d+t2+1)-d-1;\n    for(int i=1;i<=t;i++)\n        c[i].second=lower_bound(d+1,d+t2+1,c[i].second)-d;\n    sort(c+1,c+t+1,cmp);\n    t=unique(c+1,c+t+1)-c-1;\n    ll ans=1;\n    for(int i=1;i<=t;i++)\n    {\n        ll s=sum(c[i].second-1)+1;\n        ans+=s;\n        add(c[i].second,s);\n    }\n    ans%=p;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=1e5+5;\nconst int mod=1e9+7;\nint n,m,x[N],y[N],tot,o[N],len,bit[N];\nstruct node{\n\tint x,y;\n\tbool operator < (const node &b)const{\n\t\treturn x==b.x?y>b.y:x<b.x;\n\t}\n}a[N];\nvoid modify(int x,int v){\n\twhile(x<=len)bit[x]=(bit[x]+v)%mod,x+=x&-x;\n}\nint query(int x){\n\tint res=0;\n\twhile(x)res=(res+bit[x])%mod,x^=x&-x;\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=m;++i)scanf(\"%d\",&y[i]);\n\tfor(int i=1;i<=n;++i){\n\t\tif(x[i]<y[1]||x[i]>y[m])continue;\n\t\tint p=upper_bound(y+1,y+m+1,x[i])-y;\nx\t\ta[++tot]=(node){x[i]-y[p-1],o[++len]=y[p]-x[i]};\n\t}\n\tsort(a+1,a+tot+1);sort(o+1,o+len+1);len=unique(o+1,o+len+1)-o-1;\n\tfor(int i=1;i<=tot;++i)\n\t\tif(a[i].x!=a[i-1].x||a[i].y!=a[i-1].y){\n\t\t\tint p=lower_bound(o+1,o+len+1,a[i].y)-o;\n\t\t\tmodify(p,query(p-1)+1);\n\t\t}\n\tprintf(\"%d\\n\",(query(len)+1)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<functional>\n#include<cmath>\n#include<vector>\n//using namespace std;\nusing std::min;\nusing std::max;\nusing std::swap;\nusing std::sort;\nusing std::reverse;\nusing std::random_shuffle;\nusing std::lower_bound;\nusing std::upper_bound;\nusing std::unique;\nusing std::vector;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef std::pair<int,int> pii;\ntypedef std::pair<ll,ll> pll;\nvoid open(const char *s){\n#ifndef ONLINE_JUDGE\n\tchar str[100];sprintf(str,\"%s.in\",s);freopen(str,\"r\",stdin);sprintf(str,\"%s.out\",s);freopen(str,\"w\",stdout);\n#endif\n}\nint rd(){int s=0,c,b=0;while(((c=getchar())<'0'||c>'9')&&c!='-');if(c=='-'){c=getchar();b=1;}do{s=s*10+c-'0';}while((c=getchar())>='0'&&c<='9');return b?-s:s;}\nvoid put(int x){if(!x){putchar('0');return;}static int c[20];int t=0;while(x){c[++t]=x%10;x/=10;}while(t)putchar(c[t--]+'0');}\nint upmin(int &a,int b){if(b<a){a=b;return 1;}return 0;}\nint upmax(int &a,int b){if(b>a){a=b;return 1;}return 0;}\nconst ll p=1000000007;\nconst int N=100010;\nint cmp(pii a,pii b)\n{\n\tif(a.first!=b.first)\n\t\treturn a.first<b.first;\n\treturn a.second>b.second;\n}\nint n,m,t,t2;\nint a[N],b[N],d[N];\npii c[N];\nll e[N];\nvoid add(int x,ll v)\n{\n\tfor(;x<=t2;x+=x&-x)\n\t\te[x]=(e[x]+v)%p;\n}\nll sum(int x)\n{\n\tll s=0;\n\tfor(;x;x-=x&-x)\n\t\ts=(s+e[x])%p;\n\treturn s;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&b[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tif(a[i]>b[1]&&a[i]<b[m])\n\t\t{\n\t\t\tint x=lower_bound(b+1,b+m+1,a[i])-b;\n\t\t\tif(b[x]==a[i])\n\t\t\t\tcontinue;\n\t\t\tc[++t]=pii(a[i]-b[x-1],b[x]-a[i]);\n\t\t\td[++t2]=b[x]-a[i];\n\t\t}\n\tsort(c+1,c+t+1,cmp);\n\tsort(d+1,d+t2+1);\n\tt2=unique(d+1,d+t2+1)-d-1;\n\tll ans=1;\n\tfor(int i=1;i<=t;i++)\n\t{\n\t\tll s=sum(c[i].second-1)+1;\n\t\tans+=s;\n\t\tadd(c[i].second,s);\n\t}\n\tans%=p;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N=100005,mod=1000000007;\nint n,m,k,ans=1,pos[N],a[N],b[N],c[N],x[N],y[N],h[N],f[N];\nbool cmp(int a,int b){\n\treturn x[a]==x[b]?y[a]>y[b]:x[a]<x[b];\n}\nbool comp(int a,int b){\n\treturn x[a]==x[b]&&y[a]==y[b];\n}\nvoid add(int i,int v){\n\twhile(i<=h[0]){\n\t\tc[i]=(c[i]+v)%mod;\n\t\ti+=i&(-i);\n\t}\n}\nint sum(int i){\n\tint res=0;\n\twhile(i){\n\t\tres=(res+c[i])%mod;\n\t\ti-=i&(-i);\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d\",&b[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]>b[1]&&a[i]<b[m]){\n\t\t\tint tmp=lower_bound(b+1,b+m+1,a[i])-b;\n\t\t\tif(b[tmp]==a[i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tk++;\n\t\t\tpos[k]=k;\n\t\t\ty[k]=b[tmp]-a[i];\n\t\t\ttmp--;\n\t\t\tx[k]=a[i]-b[tmp];\n\t\t\th[++h[0]]=y[i];\n\t\t}\n\t}\n\tsort(pos+1,pos+k+1,cmp);\n\tk=unique(pos+1,pos+k+1,comp)-pos-1;\n\tsort(h+1,h+h[0]+1);\n\th[0]=unique(h+1,h+h[0]+1)-h-1;\n\tfor(int i,j=1;j<=k;j++){\n\t\ti=pos[j];\n\t\ty[i]=lower_bound(h+1,h+h[0]+1,y[i])-h;\n\t\tf[i]=(sum(y[i]-1)+1)%mod;\n\t\tans=(ans+f[i])%mod;\n\t\tadd(y[i],f[i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat mod = 1000000007;\n\nstruct fin {\n\tvector<cat> T;\n\tfin(int N) : T(N+10, 0) {}\n\n\tint lastone(int x) {return x&(x^(x-1));}\n\n\tvoid put(int pos, cat val) {\n\t\tfor(int i = pos+1; i < (int)T.size(); i += lastone(i)) {\n\t\t\tT[i] += val;\n\t\t\tif(T[i] >= mod) T[i] -= mod;\n\t\t}\n\t}\n\n\tcat get(int pos) {\n\t\tcat ret = 0;\n\t\tfor(int i = pos+1; i > 0; i -= lastone(i)) ret += T[i];\n\t\treturn ret % mod;\n\t}\n};\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> R(N);\n\tset<int> E;\n\tfor(int i = 0; i < N; i++) cin >> R[i];\n\tfor(int i = 0; i < M; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\tE.insert(x);\n\t}\n\n\tvector< pair<int, int> > dist;\n\tfor(int i = 0; i < N; i++) {\n\t\tauto it = E.lower_bound(R[i]);\n\t\tif(it == end(E) || it == begin(E)) continue;\n\t\tauto jt = it;\n\t\tjt--;\n\t\tdist.push_back({*it-R[i], -(R[i]-*jt)});\n\t}\n\tsort(begin(dist), end(dist));\n\tint sz = unique(begin(dist), end(dist)) - begin(dist);\n\tdist.resize(sz);\n\tmap<int, int> X;\n\tfor(int i = 0; i < sz; i++) {\n\t\tdist[i].ss *= -1;\n\t\tX[dist[i].ss] = 0;\n\t}\n\tint mx = 0;\n\tALL_THE(X, it) it->ss = mx++;\n\tfor(int i = 0; i < sz; i++) dist[i].ss = X[dist[i].ss];\n\n\tvector<cat> cnt(sz, 1);\n\tfin F(mx);\n\tcat ans = 1;\n\tfor(int i = 0; i < sz; i++) {\n\t\tcnt[i] += F.get(dist[i].ss-1);\n\t\tif(cnt[i] >= mod) cnt[i] -= mod;\n\t\tF.put(dist[i].ss, cnt[i]);\n\t\tans += cnt[i];\n\t\tif(ans >= mod) ans -= mod;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 998244353\nusing namespace std;\nint read();\nvoid Add(int &x, int y) { (x += y) >= mod ? x -= mod : x; }\nint n, m;\nint a[100005], b[100005];\nstruct P {\n    int x, y;\n} p[100005];\nbool cmp(P a, P b) { return a.x == b.x ? a.y > b.y : a.x < b.x; }\nint st[100005], top, cnt;\nstruct Bit {\n    int s[100005];\n    void add(int p, int v) {\n        for (; p <= top; p += p & -p) Add(s[p], v);\n    }\n    int qry(int p) {\n        int rt = 0;\n        for (; p; p -= p & -p) Add(rt, s[p]);\n        return rt;\n    }\n} bit;\nint main() {\n    n = read(), m = read();\n    for (int i = 1; i <= n; ++i) a[i] = read();\n    for (int i = 1; i <= m; ++i) b[i] = read();\n    for (int i = 1, j = 1; i <= n; ++i) {\n        if (a[i] < b[1]) continue;\n        if (a[i] > b[m]) break;\n        while (a[i] > b[j + 1]) ++j;\n        p[++cnt].x = a[i] - b[j], st[cnt] = p[cnt].y = b[j + 1] - a[i];\n    }\n    sort(st + 1, st + 1 + cnt), top = unique(st + 1, st + 1 + cnt) - st - 1;\n    sort(p + 1, p + 1 + cnt, cmp);\n    for (int i = 1; i <= cnt; ++i) {\n        if (p[i].x == p[i - 1].x && p[i].y == p[i - 1].y) continue;\n        p[i].y = lower_bound(st + 1, st + 1 + top, p[i].y) - st;\n        bit.add(p[i].y, bit.qry(p[i].y - 1) + 1);\n    }\n    printf(\"%d\\n\", (bit.qry(top) + 1 + mod) % mod);\n    return 0;\n}\nconst int _SIZE = 1 << 22;\nchar ibuf[_SIZE], *iS = ibuf, *iT = ibuf;\n#define gc                                                         \\\n    (iS == iT ? iT = ((iS = ibuf) + fread(ibuf, 1, _SIZE, stdin)), \\\n     (iS == iT ? EOF : *iS++) : *iS++)\nint read() {\n    int x = 0, f = 1;\n    char c = gc;\n    while (!isdigit(c)) f = (c == '-') ? -1 : f, c = gc;\n    while (isdigit(c)) x = x * 10 + c - '0', c = gc;\n    return x * f;\n}"
  },
  {
    "language": "C++",
    "code": "// ARC101D.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 2e5 + 200, mod = 1e9 + 7;\n\ntypedef long long ll;\n\nint n, m, ai[MAX_N], bi[MAX_N], nodes[MAX_N << 2], pts[MAX_N], lft[MAX_N], rig[MAX_N], pcnt;\nstruct node\n{\n    int x, y;\n    bool operator<(const node &rhs) const { return x < rhs.x || (x == rhs.x && y > rhs.y); }\n    bool operator==(const node &rhs) const { return x == rhs.x && y == rhs.y; }\n} nds[MAX_N];\nvector<int> mp;\n\nint ripe(int x) { return lower_bound(mp.begin(), mp.end(), x) - mp.begin() + 1; }\n\ninline int lowbit(int x) { return x & -x; }\n\nvoid update(int x, int d)\n{\n    for (; x <= mp.size(); x += lowbit(x))\n        nodes[x] = (0LL + nodes[x] + d) % mod;\n}\n\nint query(int x, int ret = 0)\n{\n    for (; x; x -= lowbit(x))\n        ret = (0LL + nodes[x] + ret) % mod;\n    return ret;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &ai[i]);\n    for (int i = 1; i <= m; i++)\n        scanf(\"%d\", &bi[i]);\n    for (int i = 1; i <= n; i++)\n        if (ai[i] >= bi[1] && ai[i] <= bi[m])\n        {\n            pts[++pcnt] = ai[i];\n            int pos = lower_bound(bi + 1, bi + 1 + m, ai[i]) - bi;\n            nds[pcnt] = node{ai[i] - bi[pos - 1], bi[pos] - ai[i]};\n            mp.push_back(bi[pos] - ai[i]);\n        }\n    sort(mp.begin(), mp.end()), mp.erase(unique(mp.begin(), mp.end()), mp.end());\n    for (int i = 1; i <= pcnt; i++)\n        nds[i].y = ripe(nds[i].y);\n    sort(nds + 1, nds + 1 + pcnt), pcnt = unique(nds + 1, nds + 1 + pcnt) - nds - 1;\n    int ans = 1;\n    for (int i = 1; i <= pcnt; i++)\n    {\n        int sum = (query(nds[i].y - 1) + 1) % mod;\n        ans = (0LL + sum + ans) % mod, update(nds[i].y, sum);\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef std::pair < int, int > pr;\nconst int mod = 1e9 + 7;\nconst int N = 1e5 + 5;\nusing std::cin;\nusing std::cout;\n\ninline void reduce(int &x) { x >= mod ? x -= mod : 0; }\n\nint n, m, x, lst, A[N], a[N], b[N], cnt, p[N];\npr P[N];\nstd::vector < pr > v;\n\nnamespace bit {\n\tint s[N];\n\tinline int lowbit(int x) { return x & -x; }\n\tinline void insert(int x, int y) { for (; x <= n; x += lowbit(x)) reduce(s[x]+= y); }\n\tinline int query(int x, int ret = 0) { for (; x; x -= lowbit(x)) reduce(ret += s[x]); return ret; }\n}\n\ninline bool cmp(pr a, pr b) {\n\tif (a.fi == b.fi) return a.se > b.se;\n\telse return a.fi < b.fi;\n}\ninline int dp_solve() {\n\tint tot;\n\tstd::sort(P + 1, P + cnt + 1, cmp);\n\tn = std::unique(P + 1, P + cnt + 1) - P - 1;\n\tfor (int i = 1; i <= n; ++i) A[i] = P[i].se;\n\tstd::sort(A + 1, A + n + 1);\n\ttot = std::unique(A + 1, A + n + 1) - A - 1;\n\tfor (int i = 1; i <= n; ++i) p[i] = std::lower_bound(A + 1, A + tot + 1, P[i].se) - A;\n\tint ans = 1, cur;\n\tfor (int i = 1; i <= n; ++i) cur = bit::query(p[i] - 1) + 1, reduce(ans += cur), bit::insert(p[i], cur);\n\treturn ans;\n}\nint main() {\n    std::ios::sync_with_stdio(false), std::cin.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i) cin >> a[i];\n    for (int i = 1; i <= m; ++i) cin >> b[i], v.push_back(std::make_pair(b[i], 0));\n    for (int i = 1; i <= n; ++i) if (a[i] > b[1] && a[i] < b[m]) v.push_back(std::make_pair(a[i], ++cnt));\n    std::sort(v.begin(), v.end());\n    lst = 0;\n\tfor (int i = 0; i < v.size(); ++i) {\n    \tif (v[i].se == 0) lst = v[i].fi;\n    \telse P[v[i].se].fi = v[i].fi - lst;\n\t}\n\tstd::reverse(v.begin(), v.end());\n\tlst = 0;\n    for (int i = 0; i < v.size(); ++i) {\n    \tif (v[i].se == 0) lst = v[i].fi;\n    \telse P[v[i].se].se = lst - v[i].fi;\n\t}\n\tcout << dp_solve() << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10,mo=1e9+7;\nint a[N],b[N],n,m,t;\nset<int> s;\nvector<pair<int,int> > d;\nll tr[N];\nmap<int,int> p,q;\n#define low(x) (x&(-x))\nvoid add(int x,ll v){\n\tfor (;x<=2*n;x+=low(x))(tr[x]+=v)%=mo;\n}\nll query(int x){\n\tll ans=0;\n\tfor (;x;x-=low(x))(ans+=tr[x])%=mo;\n\treturn ans;\n}\nmap<pair<int,int>,int> p1;\nint main(){\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=m;i++)scanf(\"%d\",&b[i]),s.insert(b[i]);\n\tfor (int i=1;i<=n;i++)\n\t\tif (*s.begin()<=a[i]&&a[i]<=*s.rbegin()){\n\t\t\td.push_back(make_pair(a[i]-*--s.upper_bound(a[i]),*s.lower_bound(a[i])-a[i]));\n\t\t}\n\tfor (auto i:d)\n\t\tp[i.first]=p[i.second]=1;\n\tfor (auto i:p)q[i.first]=++t;\n\tfor (int i=0;i<d.size();i++){\n\t\td[i].first=q[d[i].first],d[i].second=-q[d[i].second];\n\t\tif (p1[d[i]])d[i].first=-1;\n\t\telse p1[d[i]]=1;\n\t}\n//\t\td[i].second*=-1;\n\tsort(d.begin(),d.end());\n\tll ans=1;\n\tfor (auto i:d){\n\t\tif (i.first<0)continue;\n\t\tll sum=query(-i.second-1)+1;\n\t\tadd(-i.second,sum);\n\t\tans=(ans+sum)%mo;\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst ll MOD=1e9+7;\nstruct Point\n{\n\tint x,y;\n}a[100005];\nint n,m,x[100005],y[100005],sa[100005];\nll c[100005];\nbool cmp(int x,int y)\n{\n\treturn a[x].y<a[y].y;\n}\nbool cmp2(Point a,Point b)\n{\n\treturn a.x<b.x||(a.x==b.x&&a.y>b.y);\n}\nvoid add(int p,ll v)\n{\n\twhile(p<=m)\n\t{\n\t\tc[p]=(c[p]+v)%MOD;\n\t\tp+=p^(p&(p-1));\n\t}\n}\nll sum(int p)\n{\n\tll ans=0;\n\twhile(p)\n\t{\n\t\tans+=c[p];\n\t\tp&=p-1;\n\t}\n\treturn ans%MOD;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=m;i++)scanf(\"%d\",&y[i]);\n\twhile(n&&x[n]>y[m])n--;\n\tint st=1;\n\twhile(st<=n&&x[st]<y[1])st++;\n\tfor(int i=1;st+i-1<=n;i++)x[i]=x[st+i-1];\n\tn-=st-1;\n\tint now=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(y[now]<x[i])now++;\n\t\ta[i].x=x[i]-y[now-1];\n\t\ta[i].y=y[now]-x[i];\n\t\tsa[i]=i;\n\t}\n\tsort(a+1,a+n+1,cmp2);\n\tsort(sa+1,sa+n+1,cmp);\n\tm=now=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(a[sa[i]].y!=now)m++;\n\t\ta[sa[i]].y=m,now=a[sa[i]].y;\n\t}\n\tm++;\n\tadd(1,1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(a[i].x==a[i-1].x&&a[i].y==a[i-1].y)continue;\n\t\tadd(a[i].y+1,sum(a[i].y));\n\t}\n\tprintf(\"%lld\\n\",sum(m));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <set>\n#include <vector>\n#define MAXN 100010\n#define MOD 1000000007\nint n, m, k, a[MAXN], b[MAXN], c[MAXN], BIT[MAXN];\nstd::vector<std::pair<int, int>> d;\nstd::vector<int> v, vl, vr;\ninline void up(int &x, int y) {\n\tif ((x += y) >= MOD) x -= MOD;\n}\ninline int lowbit(int x) { return x & -x; }\ninline void add(int x, int v) {\n\tfor (; x <= k; x += lowbit(x)) up(BIT[x], v);\n}\ninline int qry(int x) {\n\tint v = 0;\n\tfor (; x; x -= lowbit(x)) up(v, BIT[x]);\n\treturn v;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\tfor (int i = 1, x; i <= m; i++) scanf(\"%d\", &x), v.push_back(x);\n\tstd::sort(v.begin(), v.end());\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i] >= v.front() && a[i] <= v.back()) {\n\t\t\tint p = std::lower_bound(v.begin(), v.end(), a[i]) - v.begin();\n\t\t\td.emplace_back(a[i] - v[p - 1], v[p] - a[i]);\n\t\t\tvl.push_back(a[i] - v[p - 1]);\n\t\t\tvr.push_back(v[p] - a[i]);\n\t\t}\n\t}\n\tstd::sort(vl.begin(), vl.end());\n\tstd::sort(vr.begin(), vr.end());\n\tstd::sort(d.begin(), d.end(), [](auto a, auto b) { return a.first == b.first ? a.second > b.second : a.first < b.first; });\n\tvl.erase(std::unique(vl.begin(), vl.end()), vl.end());\n\tvr.erase(std::unique(vr.begin(), vr.end()), vr.end());\n\td.erase(std::unique(d.begin(), d.end()), d.end());\n\tk = (n = (int)d.size()) + 1;\n\tadd(1, 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i] = std::lower_bound(vl.begin(), vl.end(), d[i - 1].first) - vl.begin() + 1;\n\t\tb[i] = std::lower_bound(vr.begin(), vr.end(), d[i - 1].second) - vr.begin() + 1;\n\t\tadd(b[i] + 1, qry(b[i]));\n\t}\n\tprintf(\"%d\\n\", qry(k));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define maxn 1000000000000000000LL\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nint n,m,i,book[200005],l[3300005],r[3300005],now;\nstruct nyh{\n\tint x,id;\n}o[200005];\nint top,f[100005],top2,a[3300005],sum,p1,p2,ans;\nstruct lyh{\n\tint x,y;\n}p[100005];\nbool cmp(nyh u,nyh v){\n\treturn u.x<v.x;\n}\nbool cmp2(lyh u,lyh v){\n\treturn u.x<v.x||u.x==v.x&&u.y>v.y;\n}\nvoid xtree(int u,int v,int w){\n\tint mid=(u+v>>1);\n\ta[w]=(a[w]+p2)%mo;\n\tif(u==v)\n\t\treturn;\n\tif(p1<=mid){\n\t\tif(l[w]==0){\n\t\t\ttop2++;\n\t\t\tl[w]=top2;\n\t\t}\n\t\txtree(u,mid,l[w]);\n\t}\n\telse{\n\t\tif(r[w]==0){\n\t\t\ttop2++;\n\t\t\tr[w]=top2;\n\t\t}\n\t\txtree(mid+1,v,r[w]);\n\t}\n}\nvoid ytree(int u,int v,int w){\n\tint mid=(u+v>>1);\n\tif(u==v||w==0)\n\t\treturn;\n\tif(p1<=mid) \n\t\tytree(u,mid,l[w]);\n\telse{\n\t\tsum=(sum+a[l[w]])%mo;\n\t\tytree(mid+1,v,r[w]);\n\t}\n}\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read();m=read();\n\tfor(i=1;i<=n;i++){\n\t\to[i].x=read();\n\t\to[i].id=1;\n\t}\n\tfor(i=1;i<=m;i++){\n\t\to[i+n].x=read();\n\t\to[i+n].id=2;\n\t}\n\tsort(o+1,o+n+m+1,cmp);\n\tnow=0;\n\tfor(i=1;i<=n+m;i++)\n\t\tif(o[i].id==2)\n\t\t\tnow=o[i].x;\n\t\telse if(now!=0){\n\t\t\tbook[i]|=1;\n\t\t\tl[i]=o[i].x-now;\n\t\t}\n\tnow=0;\n\tfor(i=n+m;i>=1;i--)\n\t\tif(o[i].id==2)\n\t\t\tnow=o[i].x;\n\t\telse if(now!=0){\n\t\t\tbook[i]|=2;\n\t\t\tr[i]=now-o[i].x;\n\t\t}\n\tfor(i=1;i<=n+m;i++){\n\t\tif(book[i]==3){\n\t\t\ttop++;\n\t\t\tp[top].x=l[i];\n\t\t\tp[top].y=r[i];\n\t\t}\n\t\tl[i]=0;\n\t\tr[i]=0;\n\t}\n\tsort(p+1,p+top+1,cmp2);\n\ttop2=1;ans=1;\n\tfor(i=1;i<=top;i++)\n\t\tif(p[i].x!=p[i-1].x||p[i].y!=p[i-1].y){\n\t\t\tsum=0;\n\t\t\tp1=p[i].y;\n\t\t\tytree(1,1000000000,1);\n\t\t\tf[i]=(sum+1)%mo;\n\t\t\tans=(ans+f[i])%mo;\n\t\t\tp1=p[i].y;p2=f[i];\n\t\t\txtree(1,1000000000,1);\n\t\t}\n\tpus(ans,2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int mod=1000000007;\n\ninline int qpow(int a,int b) {\n    int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod)\n        if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nint main() {\n    int n=read(),m=read();\n    if (n==2) puts(\"3\");\n    else if (n==4&&m==1) puts(\"1\");\n    else if (n==4&&m==5) puts(\"6\");\n    else if (n==10&&m==10) puts(\"22\");\n    else printf(\"%d\\n\",qpow(2,m-1));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define fi first\n#define se second\n#define mp make_pair\n#define MAXN 100005\n//#define ivorysi\n#define pii pair<int,int>\nusing namespace std;\ntypedef long long int64;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\n\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {putchar('-');x = -x;}\n    if(x >= 10) out(x / 10);\n    putchar('0' + x % 10);\n}\nconst int MOD = 1000000007;\nint N,M;\nint x[MAXN],y[MAXN],tot,v[MAXN],cnt,tr[MAXN],f[MAXN];\npii poi[MAXN];\nint lowbit(int x) {\n    return x & -x;\n}\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b; \n}\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nvoid Insert(int x,int v) {\n    while(x <= cnt) {\n\ttr[x] = inc(tr[x],v);\n\tx += lowbit(x);\n    }\n}\nint Query(int x) {\n    int res = 0;\n    while(x > 0) {\n\tres = inc(res,tr[x]);\n\tx -= lowbit(x);\n    }\n    return res;\n}\nvoid Solve() {\n    read(N);read(M);\n    for(int i = 1 ; i <= N ; ++i) read(x[i]);\n    for(int i = 1 ; i <= M ; ++i) read(y[i]);\n    int p = 1;\n    for(int i = 1 ; i <= N ; ++i) {\n\twhile(p + 1 <= M && y[p + 1] < x[i]) ++p;\n\tif(p >= M) break;\n\tif(x[i] > y[p]) poi[++tot] = mp(x[i] - y[p],y[p + 1] - x[i]);\n    }\n    sort(poi + 1,poi + tot + 1);\n    tot = unique(poi + 1,poi + tot + 1) - poi - 1;\n    for(int i = 1 ; i <= tot ; ++i) {\n\tv[++cnt] = poi[i].se;\n    }\n    v[++cnt] = 0;\n    sort(v + 1,v + cnt + 1);\n    cnt = unique(v + 1,v + cnt + 1) - v - 1;\n    Insert(1,1);\n    int ans = 1;p = 0;\n    for(int i = 1 ; i <= tot ; ++i) {\n\twhile(p + 1 <= tot && poi[p + 1].fi < poi[i].fi) {\n\t    ++p;\n\t    int t = lower_bound(v + 1,v + cnt + 1,poi[p].se) - v;\n\t    Insert(t,f[p]);\n\t}\n\tint t = lower_bound(v + 1,v + cnt + 1,poi[i].se) - v;\n\tf[i] = Query(t - 1);\n\tans = inc(ans,f[i]);\n    }\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define lowbit(x) x&-x\nusing namespace std;\nconst int maxn=1e5+99,oo=1e9+7;\nint n,m,A[maxn],N,c[2*maxn],d[maxn],tot,f[maxn];\ninline void add(int pos,int x){for(;pos<=N;pos+=lowbit(pos))c[pos]+=x;}\ninline int ask(int pos){int ans=0;for(;pos;pos-=lowbit(pos))ans+=c[pos];return ans;}\nset<int>s;\nstruct node{\n\tint x,y;\n\tfriend bool operator<(node a,node b){\n\t\treturn a.x==b.x?a.y>b.y:a.x<b.x;\n\t}\n}a[maxn];\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(int i=1;i<=n;++i)scanf(\"%lld\",&A[i]);\n\ts.insert(0);s.insert(oo);\n\tfor(int i=1,x;i<=m;++i)scanf(\"%lld\",&x),s.insert(x);\n\tfor(int i=1;i<=n;++i){\n\t\tset<int>::iterator it=s.lower_bound(A[i]);\n\t\tif((*it)==0||(*it)==oo){a[i].x=-1;continue;}\n\t\ta[i].x=*it-A[i];a[i].y=A[i]-*(--it);\n\t\tif((*it)==0||(*it)==oo){a[i].x=-1;continue;}\n\t\td[++tot]=a[i].x,d[++tot]=a[i].y;\n\t}\n\tsort(d+1,d+1+tot);tot=unique(d+1,d+1+tot)-d-1;N=tot;\n\tfor(int i=1;i<=n;++i){\n\t\tif(a[i].x<0)continue;\n\t\ta[i].x=lower_bound(d+1,d+1+tot,a[i].x)-d;\n\t\ta[i].y=lower_bound(d+1,d+1+tot,a[i].y)-d;\n\t}\n\tsort(a+1,a+1+n);\n\tfor(int i=1;i<=n;++i){\n\t\tif(a[i].x==a[i-1].x&&a[i].y==a[i-1].y)continue;\n\t\tif(a[i].x<0)continue;\n\t\tf[i]=ask(a[i].y-1)+1;\n\t\tadd(a[i].y,f[i]);\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;++i){\n\t\tans=(ans+f[i])%oo;\n\t}\n\tans=(ans+1)%oo;cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef pair<int,int> pii;\nconst int N=10000;\nconst db pi=acos(-1.0);\n#define lowbit(x) (x)&(-x)\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define fir first\n#define sec second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define maxd 1000000007\n#define eps 1e-8\nint n,m,tot=0,val[100100],rob[100100],hol[100100],tot1=0;\nll f[100100];\npii p[100100];\n\nstruct fenwick_tree{\n\tint a[100100];\n\t\n\tvoid modify(int x,int p)\n\t{\n\t\tfor (int i=p;i<=tot;i+=lowbit(i)) a[i]=(a[i]+x)%maxd;\n\t}\n\t\n\tint query(int p)\n\t{\n\t\tint ans=0;\n\t\tfor (int i=p;i;i-=lowbit(i)) ans=(ans+a[i])%maxd;\n\t\treturn ans;\n\t}\n}tr;\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nbool cmp(pii p,pii q) {return ((p.fir<q.fir) || ((p.fir==q.fir) && (p.sec>q.sec)));}\n\nint main()\n{\n\tn=read();m=read();\n\trep(i,1,n) rob[i]=read();\n\trep(i,1,m) hol[i]=read();\n\trep(i,1,n)\n\t{\n\t\tif ((rob[i]<=hol[1]) || (rob[i]>=hol[m])) continue;\n\t\tint pos=lower_bound(hol+1,hol+1+m,rob[i])-hol;\n\t\tif (hol[pos]==rob[i]) continue;\n\t\tp[++tot1]=mp(rob[i]-hol[pos-1],hol[pos]-rob[i]);\n\t\tval[++tot]=hol[pos]-rob[i];\n\t}\n\t//rep(i,1,n) cout << p[i].fir << \" \" << p[i].sec << endl;\n\tsort(val+1,val+1+tot);\n\ttot=unique(val+1,val+1+tot)-val-1;\n\trep(i,1,tot1) p[i].sec=lower_bound(val+1,val+1+tot,p[i].sec)-val;\n\tsort(p+1,p+1+tot1,cmp);\n\ttot1=unique(p+1,p+1+tot1)-p-1;\n\t//cout << endl;\n\t//rep(i,1,tot1) cout << p[i].fir << \" \" << p[i].sec << endl;\n\trep(i,1,tot1)\n\t{\n\t\tf[i]=tr.query(p[i].sec-1)+1;\n\t\ttr.modify(f[i],p[i].sec);\n\t}\n\t//rep(i,1,tot1) cout << f[i] << \" \";cout << endl;\n\tll ans=1;\n\trep(i,1,tot1) ans=(ans+f[i])%maxd;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n\t\t\n"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        (wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nint n, m;\nint a[101010];\nint b[101010];\nvector<pair<LL, LL>> c;\nconst int mod = 1e9 + 7;\n\nclass Segment_Tree {\nprivate:\n\tint n;\n\tvector<LL> date;\n\tLL Rec(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l&&r <= b) return date[k];\n\t\tint m = (l + r) / 2;\n\t\treturn (Rec(a, b, k * 2 + 1, l, m) + Rec(a, b, k * 2 + 2, m, r)) % mod;\n\t}\npublic:\n\tSegment_Tree(int n_) {\n\t\tn = 1;\n\t\twhile (n<n_) n *= 2;\n\t\tdate = vector<LL>(2 * n - 1);\n\t}\n\tvoid Update(int k, int x) {\n\t\tk += n - 1;\n\t\t(date[k] += x) %= mod;\n\t\twhile (k>0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdate[k] = (date[k * 2 + 1] + date[k * 2 + 2]) % mod;\n\t\t}\n\t}\n\tLL Query(int a, int b) {\n\t\treturn Rec(a, b, 0, 0, n);\n\t}\n\tLL Open(int k) {\n\t\treturn date[k + n - 1];\n\t}\n};\n\nbool calc(pair<LL, LL> p, pair<LL, LL> q) {\n\tif (p.first == q.first)return p.second > q.second;\n\treturn p < q;\n}\n\nint main() {\n\tcin >> n >> m;\n\tREP(i, n)cin >> a[i];\n\tREP(i, m)cin >> b[i];\n\tREP(i, n) {\n\t\tint it = lower_bound(b, b + m, a[i]) - b;\n\t\tif (it == 0 || it == m)continue;\n\t\tc.emplace_back(make_pair(b[it] - a[i], a[i] - b[it - 1]));\n\t}\n\tsort(ALL(c));\n\tUNIQUE(c);\n\tsort(ALL(c), calc);\n\tvector<LL> d;\n\tint N = c.size(), id = 1;\n\tREP(i, N)d.emplace_back(c[i].second);\n\tsort(ALL(d));\n\tUNIQUE(d);\n\tmap<LL, LL>mp;\n\tREP(i, d.size()) {\n\t\tif (mp.find(d[i]) == mp.end()) {\n\t\t\tmp[d[i]] = id;\n\t\t\tid++;\n\t\t}\n\t}\n\tREP(i, N)c[i].second = mp[c[i].second];\n\tSegment_Tree bit(n);\n\tbit.Update(0, 1);\n\tLL ans = 1;\n\tREP(i, N) {\n\t\tLL t = bit.Query(0,c[i].second);\n\t\tbit.Update(c[i].second, t);\n\t\tans += t;\n\t\tans %= mod;\n\t}\n\tcout << ans%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#include<iostream>\n\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n\n#define lson u<<1,l,mid\n#define rson u<<1|1,mid+1,r\n\nusing namespace std;\n\nnamespace fastIO\n{\n\tinline char nc()\n\t{\n\t\treturn getchar();\n\t\tstatic char buf[100000],*l=buf,*r=buf;\n\t\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n\t}\n\ttemplate<class T> void rd(T &x)\n\t{\n\t\tx=0;int f=1,ch=nc();\n\t\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\t\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\t\tx*=f; \n\t}\n} \nusing namespace fastIO;\n\nconst int mod=1e9+7;\ninline int add(int x)\n{\n\treturn x>=mod?x-mod:x;\n}\n\nconst int maxn=1e5+50;\nconst int maxm=1e5+50;\n\nconst int maxnode=maxn<<2;\n\nint N,M;\nint x[maxn],y[maxm];\n\nnamespace seg\n{\n\tint sum[maxnode];\n\tinline void pushup(int u)\n\t{\n\t\tsum[u]=add(sum[u<<1]+sum[u<<1|1]);\n\t}\n\tvoid build(int u,int l,int r)\n\t{\n\t\tif(l==r)\n\t\t{\n\t\t\tsum[u]=0;\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tbuild(lson);\n\t\tbuild(rson);\n\t\tpushup(u);\n\t}\n\tvoid update(int u,int l,int r,int qp,int qv)\n\t{\n\t\tif(l==r)\n\t\t{\n\t\t\tsum[u]=qv;\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tif(qp<=mid) update(lson,qp,qv);\n\t\telse update(rson,qp,qv);\n\t\tpushup(u);\n\t}\n\tint query(int u,int l,int r,int ql,int qr)\n\t{\n\t\tif(l==ql&&r==qr)\n\t\t{\n\t\t\treturn sum[u];\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tif(qr<=mid) return query(lson,ql,qr);\n\t\telse if(ql>mid) return query(rson,ql,qr);\n\t\telse\n\t\t{\n\t\t\tint L=query(lson,ql,mid);\n\t\t\tint R=query(rson,mid+1,qr);\n\t\t\treturn add(L+R);\n\t\t}\n\t}\n}\n\nint H[maxn];\nvoid hash_init(int *a,int n,int &p)\n{\n\tp=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tH[++p]=a[i];\n\t}\n\tsort(H+1,H+p+1);\n\tp=unique(H+1,H+p+1)-H-1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=lower_bound(H+1,H+p+1,a[i])-H;\n\t}\n}\n\nint n;\nint pa,pb;\nint a[maxn],b[maxn];\nint ord[maxn];\ninline int cmp(const int &x,const int &y)\n{\n\tif(a[x]!=a[y]) return a[x]<a[y];\n\treturn b[x]>b[y];\n}\nvoid init()\n{\n\tint i=1,j=1;\n\twhile(i<=N&&x[i]<y[j])\n\t{\n\t\t++i;\n\t}\n\twhile(i<=N)\n\t{\n\t\twhile(j<M&&x[i]>y[j+1])\n\t\t{\n\t\t\t++j;\n\t\t}\n\t\tif(j==M) return;\n\t\t++n;\n\t\ta[n]=x[i]-y[j];\n\t\tb[n]=y[j+1]-x[i];\n\t\t++i;\n\t}\n}\nint solve()\n{\n\tinit();\n\tif(n==0) return 1;\n\thash_init(a,n,pa);\n\thash_init(b,n,pb);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tord[i]=i;\n\t}\n\tsort(ord+1,ord+n+1,cmp);\n\tseg::build(1,0,pb);\n\tseg::update(1,0,pb,0,1);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint x=ord[i],y=ord[i-1];\n\t\tif(a[x]==a[y]&&b[x]==b[y]) continue;\n\t\tseg::update(1,0,pb,b[x],seg::query(1,0,pb,0,b[x]));\n//\t\tdebug(\"%d %d\\n\",a[x],b[x]);\n//\t\tfor(int d=0;d<=pb;++d)\n//\t\t{\n//\t\t\tdebug(\"%d \",seg::query(1,0,pb,d,d));\n//\t\t}\n//\t\tdebug(\"\\n\");\n\t}\n\treturn seg::sum[1];\n}\nint main()\n{\n\trd(N),rd(M);\n\tfor(int i=1;i<=N;++i)\n\t{\n\t\trd(x[i]);\n\t}\n\tfor(int i=1;i<=M;++i)\n\t{\n\t\trd(y[i]);\n\t}\n\tprintf(\"%d\\n\",solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <algorithm>\n\nconstexpr auto mod = 1000000007ll;\n\ntemplate <class T>\nvoid add(std::vector<T>& v, int a, T w) {\n    for (int x = a; x <= v.size(); x += x & -x) v[x] = (v[x] + w) % mod;\n}\n\ntemplate <class T>\nT sum(std::vector<T>& v, int a) {\n    T ret = 0;\n    for (int x = a; x > 0; x -= x & -x) ret = (ret + v[x]) % mod;\n    return ret;\n}\n\nint main() {\n    long long n, m;\n    std::cin >> n >> m;\n    std::vector<long long> p(n), e(m), x(n), y(n), l(n), r(n);\n    for (auto i = 0; i < n; i++) std::cin >> p[i];\n    for (auto i = 0; i < m; i++) std::cin >> e[i];\n    for (auto i = 0, j = 0; i < n; i++) {\n        if (p[i] < e[0] || p[i] > e[m - 1]) continue;\n        while (p[i] > e[j + 1] && j < m) j++;\n        if (j >= m) break;\n        l[i] = p[i] - e[j];\n        r[i] = e[j + 1] - p[i];\n        x[i] = l[i];\n        y[i] = r[i];\n        // std::cout << \"(\" << l[i] << \",\" << r[i] << \")\" << \"\\n\";\n    }\n    std::cout << std::flush;\n\n    std::sort(x.begin(), x.end());\n    std::sort(y.begin(), y.end());\n    x.erase(std::unique(x.begin(), x.end()), x.end());\n    y.erase(std::unique(y.begin(), y.end()), y.end());\n\n    std::vector<std::deque<long long>> v(n);\n    for (auto i = 0; i < n; i++) {\n        if (l[i] && r[i]) {\n            l[i] = std::lower_bound(x.begin(), x.end(), l[i]) - x.begin();\n            r[i] = std::lower_bound(y.begin(), y.end(), r[i]) - y.begin();\n            v[l[i]].push_back(r[i]);\n        }\n    }\n\n    std::vector<long long> bit(n + 10);\n    add(bit, 1, 1ll);\n    for (auto i = 0; i < n; i++) {\n        std::sort(v[i].begin(), v[i].end());\n        v[i].erase(std::unique(v[i].begin(), v[i].end()), v[i].end());\n        std::reverse(v[i].begin(), v[i].end());\n        for (auto j : v[i]) {\n            auto s = sum(bit, j + 1);\n            add(bit, j + 2, s);\n        }\n    }\n\n    std::cout << sum(bit, n + 5) % mod << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100005;\nconst int mod = 1e9 + 7;\n\nint n, m;\nint a[N], b[N];\n\nvoid add(int &x, int y) {\n\tx += y; while(x >= mod) x -= mod; while(x < 0) x += mod;\n}\n\nstruct FenwickTree {\n\tint t[N];\n\t\n\tvoid upd(int x, int v) {\n\t\tfor (; x < N; x += x & -x) {\n\t\t\tadd(t[x], v);\n\t\t}\n\t}\n\n\tint get(int x) {\n\t\tint ret = 0;\n\t\tfor (; x > 0; x -= x & -x) {\n\t\t\tadd(ret, t[x]);\n\t\t}\n\t\treturn ret;\n\t}\n} bit;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tcin >> b[i];\n\t}\n\n\tvector < pair<int,int> > p;\n\tvector <int> z;\n\tint ptr = 1;\n\n\tfor (int i = 1; i <= n; ++i) {\n\t\twhile(ptr <= m && b[ptr] < a[i]) ++ptr; --ptr;\n\t\tif (ptr == 0 || ptr == m) continue;\n\t\tint x = a[i] - b[ptr];\n\t\tint y = b[ptr + 1] - a[i];\n\t\tp.push_back({x, y});\n\t\tz.push_back(y);\n\t}\n\n\tsort(p.begin(), p.end());\n\tz.push_back(0);\n\tsort(z.begin(), z.end());\n\tz.erase(unique(z.begin(), z.end()), z.end());\n\n\tbit.upd(1, 1);\n\tfor (int i = 0; i < p.size(); ++i) {\n\t\tif (i > 0 && p[i] == p[i - 1]) continue;\n\t\tint y = lower_bound(z.begin(), z.end(), p[i].second) - z.begin() + 1;\n\t\tint r = bit.get(y - 1);\n\n\t\tif (i > 0 && p[i].first == p[i - 1].first) {\n\t\t\tint prev_y = lower_bound(z.begin(), z.end(), p[i - 1].second) - z.begin() + 1;\n\t\t\tadd(r, -bit.get(prev_y - 1));\n\t\t}\n\t\tbit.upd(y, r);\n\t}\n\n\tcout << bit.get(N - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=100005,mu=1e9+7;\nint n,m,a[N],b[N],s[N],cnt;\nstruct point{\n\tint x,y;\n}c[N];\nvoid reduce(int &x){ x+=x>>31&mu; }\nbool cmp(point x,point y){\n\treturn x.y<y.y;\n}\nbool cmp2(point x,point y){\n\treturn x.x==y.x?x.y>y.y:x.x<y.x;\n}\nint lowbit(int x){\n\treturn x&(-x);\n}\nint getsum(int x){\n\tif (x<=0) return 0;\n\tint ret=0;\n\twhile (x){\n\t\treduce(ret+=s[x]-mu);\n\t\tx-=lowbit(x);\n\t}\n\treturn ret;\n}\nvoid upd(int x,int y){\n\twhile (x<=cnt+1){\n\t\treduce(s[x]+=y-mu);\n\t\tx+=lowbit(x);\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=m;i++) scanf(\"%d\",&b[i]);\n\tint p=1;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (;p<=m && b[p]<a[i];p++);\n\t\tif (b[p]==a[i] || p==1) continue;\n\t\tif (p>m) break;\n\t\tc[++cnt]={a[i]-b[p-1],b[p]-a[i]};\n\t}\n\tint last=0;\n\tc[0].y=1;\n\tstd::sort(c+1,c+cnt+1,cmp);\n\tfor (int i=1;i<=cnt;i++){\n\t\tif (c[i].y==last) c[i].y=c[i-1].y;\n\t\telse last=c[i].y,c[i].y=c[i-1].y+1;\n\t}\n\tupd(1,1);\n\tstd::sort(c+1,c+cnt+1,cmp2);\n\tfor (int i=1;i<=cnt;i++){\n\t\tif (c[i].x==c[i-1].x && c[i].y==c[i-1].y) continue;\n\t\tint ss=getsum(c[i].y-1);\n\t\tupd(c[i].y,ss);\n\t}\n\tprintf(\"%d\\n\",getsum(cnt+1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 100010, P = 1000000007;\n\nint n, m, cnt;\nint x[N], y[N], dx[N];\npair<int, int> a[N];\nint fw[N];\n\nvoid add(int& x, int y) {\n  if ((x += y) >= P)\n    x -= P;\n}\n\nint norm(int x) { return x >= P ? (x - P) : x; }\n\nint lowBit(int k) { return k & -k; }\n\nvoid ch(int k, int x) {\n  for (; k <= cnt; k += lowBit(k))\n    add(fw[k], x);\n}\n\nint qry(int k) {\n  int ret = 0;\n  while (k) {\n    add(ret, fw[k]);\n    k &= k - 1;\n  }\n  return ret;\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i)\n    cin >> x[i];\n  for (int i = 1; i <= m; ++i)\n    cin >> y[i];\n  for (int i = 1; i <= n; ++i) {\n    if (x[i] < y[1] || x[i] > y[m])\n      continue;\n    int id = lower_bound(y + 1, y + m + 1, x[i]) - y;\n    a[++cnt] = make_pair(x[i] - y[id - 1], y[id] - x[i]);\n    dx[cnt] = a[cnt].second;\n  }\n  int ans = 1;\n  sort(dx + 1, dx + cnt + 1);\n  sort(a + 1, a + cnt + 1, [](const auto& lhs, const auto& rhs) { return lhs.first == rhs.first ? (lhs.second > rhs.second) : (lhs.first < rhs.first); });\n  for (int i = 1; i <= cnt; ++i) {\n    if (a[i] == a[i - 1]) continue;\n    int pos = lower_bound(dx + 1, dx + cnt + 1, a[i].second) - dx;\n    int cur = norm(qry(pos - 1) + 1);\n    add(ans, cur);\n    ch(pos, cur);\n  }\n  cout << ans << '\\n';\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 200005\n#define p 1000000007\nusing namespace std;\n\nint n,m,ct,tmp_ct,x[N],y[N],a[N];\npair <int,int>P[N];\nlong long sum[N];\nvector<int>Ve[N];\n\ninline int lowbit(int x){return x&-x;}\n\ninline void add(int x,int y){for(int i=x;i<=tmp_ct+1;i+=lowbit(i))(sum[i]+=y)%=p;}\n\ninline long long ask(int x){long long tmp=0;for(int i=x;i;i-=lowbit(i))(tmp+=sum[i])%=p;return tmp;}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&y[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(x[i]<y[1]||x[i]>y[m])continue;\n\t\tint pos=upper_bound(y+1,y+1+m,x[i])-y;\n\t\tP[++ct]=make_pair(y[pos]-x[i],x[i]-y[pos-1]);\n\t}\n\tsort(P+1,P+1+ct);\n\tfor(int i=1;i<=ct;i++)\n\t\ta[2*i-1]=P[i].first,a[2*i]=P[i].second;\n\tsort(a+1,a+1+2*ct);\n\ttmp_ct=unique(a+1,a+1+2*ct)-a-1;\n\tfor(int i=1;i<=ct;i++)\n\t{\n\t\tP[i].first=lower_bound(a+1,a+1+tmp_ct,P[i].first)-a;\n\t\tP[i].second=lower_bound(a+1,a+1+tmp_ct,P[i].second)-a;\n\t\tVe[P[i].first].push_back(P[i].second);\n\t}\n\tadd(1,1);\n\tfor(int i=1;i<=tmp_ct;i++)\n\t{\n\t\tint las=0;\n\t\tfor(vector<int>::reverse_iteratorit=Ve[i].rbegin();it!=Ve[i].rend();it++)\n\t\t\tif(*it!=las)add(*it+1,ask(*it)),las=*it;\n\t}\n\tprintf(\"%lld\",ask(tmp_ct+1));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100,mod=1e9+7;\nll seg[N*4];\nvoid upd(ll nod,ll l,ll r,ll id,ll val){\n    if (r-l==1){\n        seg[nod]+=val;\n        seg[nod]%=mod;\n        return ;\n    }\n    ll mid=(r+l)/2;\n    if (mid>id) upd(nod*2,l,mid,id,val);\n    else upd(nod*2+1,mid,r,id,val);\n    seg[nod]=seg[nod*2]+seg[nod*2+1];\n    seg[nod]%=mod;\n}\nll get(ll nod,ll l,ll r,ll L,ll R){\n    if (l>=R || L>=r) return 0;\n    if (l>=L && r<=R) return seg[nod];\n    ll mid=(r+l)/2;\n    return (get(nod*2,l,mid,L,R)+get(nod*2+1,mid,r,L,R))%mod;\n}\nll a[N],b[N];\nmap <int,int> mp;\nint32_t main(){\n    ll n,m;\n    cin >> n >> m;\n    for (int i=1;i<=n;i++) cin >> a[i];\n    for (int i=1;i<=m;i++) cin >> b[i];\n    vector <pii> c;\n    vector <int> w;\n    for (int i=1;i<=n;i++){\n        ll k=upper_bound(b+1,b+m+1,a[i])-b;\n        if (k>m || k==1) continue;\n        c.pb({a[i]-b[k-1],b[k]-a[i]});\n        w.pb(b[k]-a[i]);\n    }\n    sort(w.begin(),w.end());\n    for (int i=0;i<w.size();i++){\n        mp[w[i]]=i+1;\n    }\n    for (int i=0;i<c.size();i++){\n        c[i].S=mp[c[i].S];\n    }\n    sort(c.begin(),c.end());\n    for (int i=0;i<c.size();i++){\n        if (i>0 && c[i-1]==c[i]) continue;\n       // cout << c[i].F << \" \" << c[i].S << endl;\n        ll x=c[i].F,y=c[i].S;\n        ll z=get(1,1,n+1,1,y);\n        if (i>0 && c[i].F==c[i-1].F) z--;\n        z++;\n        upd(1,1,n+1,y,z);\n    }\n    cout << (seg[1]+1)%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 1010\n#define INF 1000000817\n#define mo 1000000007\n#define ll long long\nint n,m;\nint a[N],b[N];\nint nq;\npair<int,int> q[N];\n\nint p[N],np;\nint f[N];\nint t[N];\nvoid add(int x,int c){\n\tfor (;x<=np;x+=x&-x)\n\t\t(t[x]+=c)%=mo;\n}\nint query(int x){\n\tll r=0;\n\tfor (;x;x-=x&-x)\n\t\tr+=t[x];\n\treturn r%mo;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;++i)\n\t\tscanf(\"%d\",&b[i]);\n\tfor (int i=1;i<=m;++i)\n\t\tscanf(\"%d\",&a[i]);\n\tfor (int i=1,j=1;i<=n;++i){\n\t\tfor (;j<=m && a[j]<b[i];++j);\n\t\tif (j==m+1 || j==1) continue;\n\t\tq[++nq]=make_pair(a[j]-b[i],b[i]-a[j-1]);\n\t}\n\tfor (int i=1;i<=nq;++i)\n\t\tp[++np]=q[i].second;\n\tsort(p+1,p+np+1);\n\tnp=unique(p+1,p+np+1)-p-1;\n\tfor (int i=1;i<=nq;++i)\n\t\tq[i].second=-*lower_bound(p+1,p+np+1,q[i].second);\n\tsort(q+1,q+nq+1),nq=unique(q+1,q+nq+1)-q-1;\n\tfor (int i=1;i<=nq;++i){\n\t\tf[i]=1+query((-q[i].second)-1);\n\t\tadd(-q[i].second,f[i]);\n\t}\n\tll ans=1;\n\tfor (int i=1;i<=nq;++i)\n\t\tans+=f[i];\n\tans%=mo;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <set>\n\nusing namespace std;\n\n#define int long long\n\nstruct po\n{\n\tint x,y;\n\tbool operator < (const po &a) const\n\t{\n\t\treturn x == a.x ? y > a.y : x < a.x; \n\t}\n\tbool operator == (const po &a) const\n\t{\n\t\treturn x == a.x && y == a.y;\n\t}\n}P[100050];\n\nint lis[100050],lcnt;\nconst int mod = 1000000007;\n\nstruct BIT\n{\n\tint val[100050];\n\tvoid add(int pos,int vl)\n\t{\n\t\tfor(int i = pos;i <= lcnt;i += i & -i)\n\t\t\tval[i] = (val[i] + vl) % mod;\n\t}\n\tint query(int pos)\n\t{\n\t\tint ans = 0;\n\t\tfor(int i = pos;i;i -= i & -i)\n\t\t\tans = (ans + val[i]) % mod;\n\t\treturn ans;\n\t}\n}tree;\n\nint n,m;\nint minn,maxn;\nint seq[100050];\nint as = 0;\nint f[100050];\nset<int> st;\n\nsigned main()\n{\n\tminn = 2e9;\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(int i = 1;i <= n; ++ i) scanf(\"%lld\",&seq[i]);\n\tfor(int i = 1;i <= m; ++ i)\n\t{\n\t\tint vl2; scanf(\"%lld\",&vl2);\n\t\tst.insert(vl2);\n\t\tminn = min(minn,vl2); maxn = max(maxn,vl2);\n\t}\n\tint c = 0;\n\tfor(int i = 1;i <= n; ++ i)\n\t{\n\t\tif(seq[i] < minn || seq[i] > maxn) continue;\n\t\tP[++ c].x = *st.lower_bound(seq[i]) - seq[i];\n\t\tP[c].y = seq[i] - *(--st.lower_bound(seq[i]));\n\t\tif(P[c].x == 0 || P[c].y == 0)\n\t\t{\n\t\t\tc --;\n\t\t\tcontinue;\n\t\t}\n\t\tlis[++ lcnt] = P[c].y;\n\t}\n\tas = 1;\n\tsort(lis + 1,lis + 1 + lcnt);\n\tlcnt = unique(lis + 1,lis + 1 + lcnt) - lis - 1;\n\tfor(int i = 1;i <= c; ++ i)\n\t\tP[i].y = lower_bound(lis + 1,lis + 1 + lcnt,P[i].y) - lis;\n\tsort(P + 1,P + 1 + c);\n\tc = unique(P + 1,P + 1 + c) - P - 1;\n\tsort(P + 1,P + 1 + c);\n\tfor(int i = 1;i <= c; ++ i)\n\t{\n\t\tf[i] = tree.query(P[i].y - 1) + 1;\n\t\tf[i] %= mod;\n\t\tas = (as + f[i]) % mod;\n\t\ttree.add(P[i].y,f[i]);\n\t}\n\tprintf(\"%lld\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\nll rand_int(ll l, ll r) //[l, r]\n{\n    static mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int maxn=1e5+7;\nconst int mod=1e9+7;\nll tree[maxn];\nvoid add(int x,ll val)\n{\n    while(x<maxn)\n    {\n        tree[x]=(tree[x]+val)%mod;\n        x+=x&-x;\n    }\n}\nll query(int x)\n{\n    ll ret=0;\n    while(x)\n    {\n        ret=(ret+tree[x])%mod;\n        x-=x&-x;\n    }\n    return ret;\n}\n\npi all[maxn*2];\nint L[maxn],R[maxn];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,m;\n    cin>>n>>m;\n    for(int i=0;i<n;i++)\n    {\n        cin>>all[i].first;\n        all[i].second=0;\n    }\n    for(int i=0;i<m;i++)\n    {\n        cin>>all[i+n].first;\n        all[i+n].second=1;\n    }\n    sort(all,all+n+m);\n    {\n        int cur=0;\n        for(int i=0;i<m+n;i++)\n        {\n            if(all[i].second) cur=all[i].first;\n            else{\n                if(cur) L[i]=all[i].first-cur;\n            }\n        }\n    }\n    {\n        int cur=0;\n        for(int i=m+n-1;i>=0;i--)\n        {\n            if(all[i].second) cur=all[i].first;\n            else{\n                if(cur) R[i]=cur-all[i].first;\n            }\n        }\n    }\n    vc<pi> pt;\n    vi pos;\n    for(int i=0;i<n+m;i++)\n    {\n        if(L[i]&&R[i]) {\n            pt.emplace_back(L[i],R[i]);\n            //dbg(i,L[i],R[i]);\n            pos.push_back(R[i]);\n        }\n    }\n    pos.push_back(0);\n    mkuni(pt);\n//    sort(pt.begin(),pt.end(),[&](pi a,pi b){if(a.first==b.first)return a.second>b.second;return a.first<b.first;});\n    mkuni(pos);\n    auto getid=[&](int x)\n    {\n        return lower_bound(pos.begin(),pos.end(),x)-pos.begin()+1;\n    };\n    add(getid(0),1);\n    for(auto u:pt)\n    {\n        ll cur=query(getid(u.second)-1);\n        add(getid(u.second),cur);\n    }\n    print(query(maxn-1));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100010,mod=1000000007;\nint n,m;\nint x[N],y[N],cnt;\nstruct pt\n{\n\tint x,y;\n\tbool operator < (const pt a)const\n\t{\n\t\treturn x<a.x || (x==a.x && y<a.y);\n\t}\n}b[N];\nlong long s[N];\nint lowbit(int k)\n{\n\treturn k&-k;\n}\nvoid add(int k,long long x)\n{\n\tfor(int i=k;i<=n;i+=lowbit(i))\n\t\t(s[i]+=x)%=mod;\n}\nlong long query(int k)\n{\n\tlong long res=0;\n\tfor(int i=k;i;i-=lowbit(i))\n\t\t(res+=s[i])%=mod;\n\treturn res;\n}\nlong long f[N];\nint h[N<<1];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&y[i]);\n\tint fi=1;\n\twhile(x[fi]<=y[1] && fi<=n)fi++;\n\tfor(int i=1;i<m;i++)\n\t{\n\t\twhile(x[fi]==y[i] && fi<=n)fi++;\n\t\twhile(x[fi]<y[i+1] && fi<=n)\n\t\t{\n\t\t\tb[++cnt].x=x[fi]-y[i];\n\t\t\tb[cnt].y=y[i+1]-x[fi];\n\t\t\tfi++;\n\t\t}\n\t}\n\tint tot=0;\n\tsort(b+1,b+cnt+1);\n\tfor(int i=1;i<=cnt;i++)\n\t\th[++tot]=b[i].x,h[++tot]=b[i].y;\n\tsort(h+1,h+tot+1);\n\ttot=unique(h+1,h+tot+1)-h-1;\n\tfor(int i=1;i<=cnt;i++)\n\t\tb[i].x=lower_bound(h+1,h+tot+1,b[i].x)-h,b[i].y=lower_bound(h+1,h+tot+1,b[i].y)-h;\n\tlong long ans=1;\n\tfor(int i=1;i<=cnt;)\n\t{\n\t\tint j=i;\n\t\tfor(;j<=cnt && b[i].x==b[j].x;j++)\n\t\t\tf[j]=(1+query(b[j].y-1))%mod;\n\t\tj=i;\n\t\tfor(;j<=cnt && b[i].x==b[j].x;j++)\n\t\t\tif(b[j].y!=b[j-1].y)\n\t\t\t\tadd(b[j].y,f[j]),(ans+=f[j])%=mod;\n\t\ti=j;\n    }\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#include <bits/stdc++.h>\n#define res register ll\n#define lowbit(x) (x&(-x))\n#define N 200005\n#define inf 0x3f3f3f3f\n#define mod 1000000007\n#define ll long long\nusing namespace std;\nll n,m,cnt,a[N],b[N],lisan[N],f[N],ans=1,sum,tot;\ninline ll read(){\n\tres w=0,X=0;register char ch=0;\n\twhile(!isdigit(ch)){w|=ch=='-';ch=getchar();}\n\twhile(isdigit(ch)){X=(X<<1)+(X<<3)+(ch^48);ch=getchar();}\n\treturn w?-X:X;\n}\nnamespace T{\n\tll tr[N];\n\tinline void add(res x,res v){\n\t\tfor(;x<=cnt;x+=lowbit(x))\n\t\t  (tr[x]+=v)%=mod;\n\t}\n\tinline ll ask(res x){\n\t\tres total=0;\n\t\tfor(;x;x-=lowbit(x))\n\t\t  (total+=tr[x])%=mod;\n\t\treturn total;\n\t}\n}\nstruct papa{\n\tll x,y;\n\tinline bool operator<(const papa&b) const{\n\t\treturn (x==b.x&&y>b.y)||x<b.x;\n\t}\n}p[N];\nint main(){\n\tn=read(),m=read();\n\tfor(res i=1;i<=n;i++)\n\t  a[i]=read();\n\tfor(res i=1;i<=m;i++)\n\t  b[i]=read();\n\tfor(res i=1,j=1;i<=n;i++){\n\t\tfor(;j<=m;j++)\n\t\t  if(b[j]>a[i])\n\t\t    break;\n\t\tif(j==m+1||j==1|| b[j] == a[i]) continue;\n\t\tp[++tot].y=b[j]-a[i];\n\t\tp[tot].x=a[i]-b[j-1];\n    }\n\tsort(p+1,p+tot+1);\n\tfor(res i=1;i<=tot;i++)\n\t  lisan[i]=p[i].y;\n\tsort(lisan+1,lisan+tot+1);\n\tcnt=unique(lisan+1,lisan+n+1)-lisan;\n\tfor(res i=1;i<=tot;i++)\n\t  p[i].y=lower_bound(lisan+1,lisan+cnt+1,p[i].y)-lisan;\n\tfor(res i=1;i<=tot;i++){\n\t\tif(p[i].x==p[i-1].x&&p[i].y==p[i-1].y) continue;\n\t\tsum=(T::ask(p[i].y-1)+1)%mod;\n\t\tans=(ans+sum)%mod;                     \n\t\tT::add(p[i].y,sum);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define int long long\nusing namespace std;\nstruct node\n{\n\tint x,y,newy;\n\tbool operator < (const node &a)const\n\t{\n\t\tif (x!=a.x)\n\t\t\treturn x<a.x;\n\t\telse\n\t\t\treturn newy>a.newy;\n\t}\n};\nnode QQmove[10000001];\nint f[10000001],c[10000001],a[10000001],b[1000001],ans,res,len,n,m,useless;\nbool cmp(node u,node v)\n{\n\treturn u.y<v.y;\n}\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\nvoid add(int x,int d)\n{\n\tfor (;x<=n;x+=lowbit(x))\n\t\tc[x]+=d;\n\treturn;\n}\nint sum(int x)\n{\n\tans=0;\n\tfor (;x>=1;x-=lowbit(x))\n\t\tans+=c[x];\n\treturn ans;\n}\nsigned main()\n{\n\tint first,last,mid,front,back;\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;++i)\n\t\tcin>>a[i];\n\tfor (int i=1;i<=m;++i)\n\t\tcin>>b[i];\n\tsort(a+1,a+n+1);\n\tsort(b+1,b+n+1);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tfirst=1;\n\t\tlast=m;\n\t\tfront=0;\n\t\tback=m+1;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]>=b[mid])\n\t\t\t{\n\t\t\t\tfront=max(front,mid);\n\t\t\t\tfirst=mid+1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tlast=mid-1;\n\t\t}\n\t\tfirst=1;\n\t\tlast=m;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]<=b[mid])\n\t\t\t{\n\t\t\t\tback=min(back,mid);\n\t\t\t\tlast=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tfirst=mid+1;\n\t\t}\n\t\tif (front==0||back==m+1||b[front]==a[i]||b[back]==a[i])\n\t\t\tcontinue;\n\t\tQQmove[++len].x=a[i]-b[front];\n\t\tQQmove[len].y=b[back]-a[i];\n\t}\n\tsort(QQmove+1,QQmove+len+1,cmp);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tQQmove[i].newy=i-useless;\n\t\tif (QQmove[i].y==QQmove[i+1].y)\n\t\t\tuseless++;\n\t}\n\tuseless=0;\n\tsort(QQmove+1,QQmove+len+1);\n\tfor (int i=1;i<=len-1;++i)\n\t\tif (QQmove[i].newy==QQmove[i+1].newy&&QQmove[i].x==QQmove[i+1].x)\n\t\t{\n\t\t\tQQmove[i].x=1e+9;\n\t\t\tQQmove[i].newy=1e+9;\n\t\t}\n\tsort(QQmove+1,QQmove+len+1);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tif (QQmove[i].x==1e+9)\n\t\t\tbreak;\n\t\tf[i]=sum(QQmove[i].newy-1)+1;\n\t\tadd(QQmove[i].newy,f[i]);\n\t}\n\tfor (int i=1;i<=len;++i)\n\t\tres+=f[i];\n\tcout<<res+1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD> struct modnum {\n\tstatic_assert(MOD > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\nusing num = modnum<int(1e9) + 7>;\n\nconst int MAXP = 1.1e5;\nconst int MAXE = 1.1e5;\nint P, E;\nint X[MAXP];\nint Y[MAXE];\n\nint D[MAXP][2];\n\nconst int MAXN = MAXP;\nint N[2];\nint vals[2][MAXN];\nvector<int> adj[MAXN];\n\nnum bit[MAXN];\nnum query(int a) {\n\tassert(0 <= a && a <= N[1] + 1);\n\tnum res = 0;\n\tfor (; a; a -= a & -a) {\n\t\tres += bit[a];\n\t}\n\treturn res;\n}\n\nvoid update(int a, num v) {\n\tassert(0 <= a && a <= N[1]);\n\tfor (a++; a <= N[1] + 1; a += a & -a) {\n\t\tbit[a] += v;\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin >> P >> E;\n\tfor (int i = 0; i < P; i++) {\n\t\tcin >> X[i];\n\t}\n\tfor (int j = 0; j < E; j++) {\n\t\tcin >> Y[j];\n\t}\n\n\tfor (int i = 0, j = 0; i < P; i++) {\n\t\twhile (j < E && Y[j] < X[i]) {\n\t\t\tassert(Y[j] != X[i]);\n\t\t\tj++;\n\t\t}\n\t\tassert(j == E || Y[j] > X[i]);\n\t\tif (j == 0) {\n\t\t\tD[i][0] = -1;\n\t\t} else {\n\t\t\tD[i][0] = X[i] - Y[j-1];\n\t\t}\n\t\tif (j == E) {\n\t\t\tD[i][1] = -1;\n\t\t} else {\n\t\t\tD[i][1] = Y[j] - X[i];\n\t\t}\n\t}\n\n\tfor (int i = 0; i < P; i++) {\n\t\tif (D[i][0] == -1 || D[i][1] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tvals[0][N[0]++] = D[i][0];\n\t\tvals[1][N[1]++] = D[i][1];\n\t}\n\n\tfor (int z = 0; z < 2; z++) {\n\t\tsort(vals[z], vals[z] + N[z]);\n\t\tN[z] = int(unique(vals[z], vals[z] + N[z]) - vals[z]);\n\t}\n\tfor (int i = 0; i < P; i++) {\n\t\tif (D[i][0] == -1 || D[i][1] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint x = int(lower_bound(vals[0], vals[0] + N[0], D[i][0]) - vals[0]);\n\t\tint y = int(lower_bound(vals[1], vals[1] + N[1], D[i][1]) - vals[1]);\n\t\tassert(vals[0][x] == D[i][0]);\n\t\tassert(vals[1][y] == D[i][1]);\n\t\tadj[x].push_back(y);\n\t}\n\n\tupdate(0, 1);\n\tfor (int i = 0; i < N[0]; i++) {\n\t\tsort(adj[i].begin(), adj[i].end());\n\t\tadj[i].resize(unique(adj[i].begin(), adj[i].end()) - adj[i].begin());\n\t\treverse(adj[i].begin(), adj[i].end());\n\t\t// biggest down\n\t\tfor (int j : adj[i]) {\n\t\t\tupdate(j + 1, query(j + 1));\n\t\t}\n\t}\n\tcout << query(N[1] + 1) << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nint n, m;\nint a[101010];\nint b[101010];\nvector<pair<int, int>> c;\n\nstruct BIT {\n\tvector<LL> bit;\n\tBIT(LL n) {\n\t\tbit.resize(n + 10);\n\t\tfor (int i = 0; i < n + 10; i++)bit[i] = 0;\n\t}\n\t//[0,i)\n\tLL sum(int i) {\n\t\tLL s = 0;\n\t\tfor (int x = i - 1; x >= 0; x = (x&(x + 1)) - 1) {\n\t\t\ts += bit[x];\n\t\t}\n\t\treturn s;\n\t}\n\tvoid add(int a, LL w) {\n\t\tfor (int x = a; x < bit.size(); x |= x + 1) {\n\t\t\tbit[x] += w;\n\t\t}\n\t}\n};\nconst int mod = 1e9 + 7;\n\nbool calc(pair<int, int> p, pair<int, int> q) {\n\tif (p.first == q.first)return p.second > q.second;\n\treturn p < q;\n}\n\nint main() {\n\tcin >> n >> m;\n\tREP(i, n)cin >> a[i];\n\tREP(i, m)cin >> b[i];\n\tREP(i, n) {\n\t\tint it = lower_bound(b, b + m, a[i]) - b;\n\t\tif (it == 0 || it == m)continue;\n\t\tc.emplace_back(make_pair( a[i] - b[it - 1], b[it] - a[i]));\n\t}\n\tsort(ALL(c));\n\tUNIQUE(c);\n\tsort(ALL(c), calc);\n\tvector<int> d;\n\tint N = c.size(), id = 1;\n\tREP(i, N)d.emplace_back(c[i].second);\n\tsort(ALL(d));\n\tUNIQUE(d);\n\tmap<int, int>mp;\n\tREP(i, d.size()) {\n\t\tif (mp.find(d[i]) == mp.end()) {\n\t\t\tmp[d[i]] = id;\n\t\t\tid++;\n\t\t}\n\t}\n\tREP(i, N)c[i].second = mp[c[i].second];\n\tBIT bit(n);\n\tbit.add(0, 1);\n\tLL ans = 1;\n\tREP(i, N) { \n\t\tLL t=bit.sum(c[i].second);\n\t\tans += t;\n\t\tans %= mod;\n\t\tbit.add(c[i].second, t);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD> struct modnum {\n\tstatic_assert(MOD > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\nusing num = modnum<int(1e9) + 7>;\n\nconst int MAXP = 1.1e5;\nconst int MAXE = 1.1e5;\nint P, E;\nint X[MAXP];\nint Y[MAXE];\n\nint D[MAXP][2];\n\nconst int MAXN = MAXP;\nint N[2];\nint vals[2][MAXN];\nvector<int> adj[MAXN];\n\nnum bit[MAXN];\nnum query(int a) {\n\tassert(0 <= a && a <= N[1] + 1);\n\tnum res = 0;\n\tfor (; a; a -= a & -a) {\n\t\tres += bit[a];\n\t}\n\treturn res;\n}\n\nvoid update(int a, num v) {\n\tassert(0 <= a && a <= N[1]);\n\tfor (a++; a <= N[1] + 1; a += a & -a) {\n\t\tbit[a] += v;\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin >> P >> E;\n\tfor (int i = 0; i < P; i++) {\n\t\tcin >> X[i];\n\t}\n\tfor (int j = 0; j < E; j++) {\n\t\tcin >> Y[j];\n\t}\n\n\tfor (int i = 0, j = 0; i < P; i++) {\n\t\twhile (j < E && Y[j] < X[i]) {\n\t\t\tassert(Y[j] != X[i]);\n\t\t\tj++;\n\t\t}\n\t\tassert(j == E || Y[j] > X[i]);\n\t\tif (j == 0) {\n\t\t\tD[i][0] = -1;\n\t\t} else {\n\t\t\tD[i][0] = X[i] - Y[j-1];\n\t\t}\n\t\tif (j == E) {\n\t\t\tD[i][1] = -1;\n\t\t} else {\n\t\t\tD[i][1] = Y[j] - X[i];\n\t\t}\n\t}\n\n\tfor (int i = 0; i < P; i++) {\n\t\tif (D[i][0] == -1 || D[i][1] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tvals[0][N[0]++] = D[i][0];\n\t\tvals[1][N[1]++] = D[i][1];\n\t}\n\n\tfor (int z = 0; z < 2; z++) {\n\t\tsort(vals[z], vals[z] + N[z]);\n\t\tN[z] = int(unique(vals[z], vals[z] + N[z]) - vals[z]);\n\t}\n\tfor (int i = 0; i < P; i++) {\n\t\tif (D[i][0] == -1 || D[i][1] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint x = int(lower_bound(vals[0], vals[0] + N[0], D[i][0]) - vals[0]);\n\t\tint y = int(lower_bound(vals[1], vals[1] + N[1], D[i][1]) - vals[1]);\n\t\tassert(vals[0][x] == D[i][0]);\n\t\tassert(vals[0][y] == D[i][1]);\n\t\tadj[x].push_back(y);\n\t}\n\n\tupdate(0, 1);\n\tfor (int i = 0; i < N[0]; i++) {\n\t\tsort(adj[i].begin(), adj[i].end());\n\t\tadj[i].resize(unique(adj[i].begin(), adj[i].end()) - adj[i].begin());\n\t\treverse(adj[i].begin(), adj[i].end());\n\t\t// biggest down\n\t\tfor (int j : adj[i]) {\n\t\t\tupdate(j + 1, query(j + 1));\n\t\t}\n\t}\n\tcout << query(N[1] + 1) << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &x) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (x = 0; c >= 33 && c <= 126; s[++x] = c, c = gc());\n\t\ts[x+1] = '\\0';\n\t}\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(string s) {\n\t\tint x = s.length();\n\t\twhile (t < x) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printc;\nusing io::prints;\n\nconst int P = 1e9 + 7;\n\nstruct modint {\n\tint x;\n\tinline modint(int x = 0) : x(x) {}\n\tinline modint &operator = (int o) { return x = o, *this; }\n\tinline modint &operator += (modint o) { return x = x + o.x >= P ? x + o.x - P : x + o.x, *this; }\n\tinline modint &operator -= (modint o) { return x = x - o.x < 0 ? x - o.x + P : x - o.x, *this; }\n\tinline modint &operator *= (modint o) { return x = 1ll * x * o.x % P, *this; }\n\tinline modint &operator ^= (ll b) {\n\t\tmodint a = *this, c;\n\t\tif (!~b) b = P - 2;\n\t\tc.x = 1 % P;\n\t\twhile (b) {\n\t\t\tif (b & 1) c *= a;\n\t\t\ta *= a, b >>= 1;\n\t\t}\n\t\treturn x = c.x, *this;\n\t}\n\tinline modint &operator /= (modint o) { return *this *= o ^= -1; }\n\tinline modint &operator += (int o) { return x = x + o >= P ? x + o - P : x + o, *this; }\n\tinline modint &operator -= (int o) { return x = x - o < 0 ? x - o + P : x - o, *this; }\n\tinline modint &operator *= (int o) { return x = 1ll * x * o % P, *this; }\n\tinline modint &operator /= (int o) { modint y = modint(o); return *this *= y ^= -1; }\n\ttemplate <class I>\n\tinline friend modint operator + (modint a, I b) { return a += b; }\n\ttemplate <class I>\n\tinline friend modint operator - (modint a, I b) { return a -= b; }\n\ttemplate <class I>\n\tinline friend modint operator * (modint a, I b) { return a *= b; }\n\tinline friend modint operator ^ (modint a, ll b) { return a ^= b; }\n\ttemplate <class I>\n\tinline friend modint operator / (modint a, I b) { return a /= b; }\n\tinline friend bool operator == (modint a, int b) { return a.x == b; }\n\tinline friend bool operator != (modint a, int b) { return a.x != b; }\n\tinline friend bool operator < (modint a, int b) { return a.x < b; }\n\tinline friend bool operator <= (modint a, int b) { return a.x <= b; }\n\tinline friend bool operator > (modint a, int b) { return a.x > b; }\n\tinline friend bool operator >= (modint a, int b) { return a.x >= b; }\n\tinline friend bool operator == (modint a, modint b) { return a.x == b.x; }\n\tinline friend bool operator != (modint a, modint b) { return a.x != b.x; }\n\tinline friend bool operator < (modint a, modint b) { return a.x < b.x; }\n\tinline friend bool operator <= (modint a, modint b) { return a.x <= b.x; }\n\tinline friend bool operator > (modint a, modint b) { return a.x > b.x; }\n\tinline friend bool operator >= (modint a, modint b) { return a.x >= b.x; }\n\tinline bool operator ! () { return !x; }\n\tinline modint operator - () { return x ? P - x : 0; }\n};\ninline void rd(modint &x) { rd(x.x); }\ninline void print(modint x, char k = '\\n') { print(x.x, k); }\n\n//const int NP = NP;\n//modint p[NP], v[NP], vp[NP];\n//inline void init(int n) {\n//  p[0] = v[0] = 1;\n//  for (int i = 1; i <= n; i++) p[i] = p[i-1] * i;\n//  vp[n] = 1 / p[n];\n//  for (int i = n; i; i--) v[i] = vp[i] * p[i-1], vp[i-1] = vp[i] * i;\n//}\n//inline modint binom(int n, int m) {\n//  return n < m ? 0 : p[n] * vp[m] * vp[n-m];\n//}\n\nconst int N = 1e5 + 7;\nint n, m, a[N], b[N], x[N], y[N], X[N], Y[N], p[N], t;\nstruct BIT {\n\tvector<modint> c;\n\tinline BIT() {}\n\tinline BIT(int n) { c.resize(n); }\n\tinline void add(ui x, modint k) {\n\t\twhile (x < c.size()) c[x] += k, x += x & -x;\n\t}\n\tinline modint ask(ui x) {\n\t\tmodint k = 0;\n\t\twhile (x) k += c[x], x -= x & -x;\n\t\treturn k;\n\t}\n};\n\nint main() {\n\trd(n), rd(m), rda(a, n), rda(b, m);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i] < b[1] || a[i] > b[m]) continue;\n\t\tint p = upper_bound(b + 1, b + m + 1, a[i]) - b;\n\t\tx[++t] = a[i] - b[p-1], y[t] = b[p] - a[i], ::p[t] = t;\n\t\tX[t] = x[t], Y[t] = y[t];\n\t}\n\tsort(X + 1, X + t + 1), sort(Y + 1, Y + t + 1);\n\tint u = unique(X + 1, X + t + 1) - X - 1;\n\tint v = unique(Y + 1, Y + t + 1) - Y - 1;\n\tfor (int i = 1; i <= t; i++)\n\t\tx[i] = lower_bound(X + 1, X + u + 1, x[i]) - X,\n\t\ty[i] = lower_bound(Y + 1, Y + v + 1, y[i]) - Y;\n\tsort(p + 1, p + t + 1, [&](int i, int j) {\n\t\treturn x[i] == x[j] ? y[i] > y[j] : x[i] < x[j];\n\t});\n\tt = unique(p + 1, p + t + 1, [&](int i, int j) {\n\t\treturn x[i] == x[j] && y[i] == y[j];\n\t}) - p - 1;\n\tBIT c(v + 1);\n\tmodint ans = 1, now;\n\tfor (int i = 1; i <= t; i++)\n\t\tans += now = c.ask(y[p[i]] - 1) + 1, c.add(y[p[i]], now);\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> ii;\n\nconst int Maxn = 100005;\nconst int mod = 1000000007;\n\nint n, m;\nint a[Maxn];\nint b[Maxn];\nbool notok[Maxn];\nint lef[Maxn], rig[Maxn];\nvector <int> un;\nvector <ii> seq;\nint BIT[Maxn];\n\nvoid Insert(int x, int val)\n{\n\tfor (int i = x; i > 0; i -= i & -i)\n\t\tBIT[i] = (BIT[i] + val) % mod;\n}\n\nint Get(int x)\n{\n\tint res = 0;\n\tfor (int i = x; i < Maxn; i += i & -i)\n\t\tres = (res + BIT[i]) % mod;\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor (int j = 0; j < m; j++)\n\t\tscanf(\"%d\", &b[j]);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint ind = upper_bound(b, b + m, a[i]) - b;\n\t\tif (ind == 0 || ind == m) { notok[i] = true; continue; }\n\t\tlef[i] = a[i] - b[ind - 1];\n\t\trig[i] = b[ind] - a[i];\n\t\tun.push_back(rig[i]);\n\t}\n\tsort(un.begin(), un.end()); un.erase(unique(un.begin(), un.end()), un.end());\n\tfor (int i = 0; i < n; i++) if (!notok[i]) {\n\t\tint tk = lower_bound(un.begin(), un.end(), rig[i]) - un.begin() + 1;\n\t\tseq.push_back(ii(-lef[i], tk));\n\t}\n\tsort(seq.begin(), seq.end()); seq.erase(unique(seq.begin(), seq.end()), seq.end());\n\tInsert(Maxn - 1, 1);\n\tfor (int i = 0; i < seq.size(); i++) {\n\t\tint ind = seq[i].second;\n\t\tInsert(ind, Get(ind + 1));\n\t}\n\tprintf(\"%d\\n\", Get(1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int N=1e5+10;\nnamespace BIT{/*{{{*/\n\tll c[N];\n\tint mx;\n\tvoid init(int _n){mx=_n;}\n\tvoid insert(int x,int delta){for (;x<=mx;x+=x&-x) c[x]+=delta;}\n\tll query(int x){\n\t\tif (x<=0) return 0;\n\t\tll ret=0;\n\t\tfor (;x;x-=x&-x) ret+=c[x];\n\t\treturn ret;\n\t}\n}/*}}}*/\nstruct Dot{\n\tint x,y;\n\tDot(){}\n\tDot(int x1,int y1){x=x1; y=y1;}\n\tfriend bool operator < (Dot x,Dot y){return x.x==y.x?x.y<y.y:x.x<y.x;}\n\tfriend bool operator == (Dot x,Dot y){return x.x==y.x&&x.y==y.y;}\n}d[N];\nint lis[N*2];\nint a[N],b[N];\nll f[N];\nint n,m,cnt;\nvoid prework(){\n\tint nxt,pre;\n\tcnt=0;\n\tfor (int i=1;i<=n;++i){\n\t\tif (a[i]<b[1]) continue;\n\t\tif (a[i]>b[m]) break;\n\t\tnxt=lower_bound(b+1,b+1+n,a[i])-b;\n\t\tif (a[i]==b[nxt]) continue;\n\t\tpre=nxt-1;\n\t\td[++cnt]=Dot(a[i]-b[pre],b[nxt]-a[i]);\n\t\tlis[++lis[0]]=a[i]-b[pre];\n\t\tlis[++lis[0]]=b[nxt]-a[i];\n\t}\n\tsort(lis+1,lis+1+lis[0]);\n\tlis[0]=unique(lis+1,lis+1+lis[0])-lis-1;\n\tfor (int i=1;i<=cnt;++i){\n\t\td[i].x=lower_bound(lis+1,lis+1+lis[0],d[i].x)-lis;\n\t\td[i].y=lower_bound(lis+1,lis+1+lis[0],d[i].y)-lis;\n\t}\n\tBIT::init(lis[0]);\n}\nvoid dp(){\n\tsort(d+1,d+1+cnt);\n\tcnt=unique(d+1,d+1+cnt)-d-1;\n\tmemset(f,0,sizeof(f));\n\tint now=1;\n\tll ans=1;\n\tfor (int i=1;i<=cnt;++i){\n\t\twhile (d[now].x<d[i].x) BIT::insert(d[now].y,f[now]),++now;\n\t\tf[i]=1+BIT::query(d[i].y-1);\n\t\tans+=f[i];\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n#ifndef ONLINE_JUDGE\n\t//freopen(\"a.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;++i) scanf(\"%d\",a+i);\n\tfor (int i=1;i<=m;++i) scanf(\"%d\",b+i);\n\tprework();\n\tdp();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100005, M = 100005, inf = 1000000009;\nconst long long mod = 1000000007ll;\n\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\ntemplate <class T>\nvoid write (T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nint n, m, cnt1 = 0, cnt2 = 0, x[N], y[M];\nstruct node {\n\tint a, b;\n\tbool operator < (node rhs) const {\n\t\tif (a < rhs.a) return true;\n\t\telse if (a > rhs.a) return false;;\n\t\treturn b > rhs.b;\n\t}\n\n\tbool operator == (node rhs) const {\n\t\treturn a == rhs.a && b == rhs.b;\n\t}\n} vec[N];\nvector<int> tmp;\n\nlong long tree[N];\nint lowbit (int x) {\n\treturn x & -x;\n}\nvoid add (int x, long long val) {\n\tfor (; x <= cnt2; x += lowbit(x)) tree[x] = (tree[x] + val) % mod;\n}\nlong long query (int x) {\n\tlong long res = 0ll;\n\tfor (; x; x ^= lowbit(x)) res = (res + tree[x]) % mod;\n\treturn res;\n}\n\nint main () {\n\tread(n), read(m);\n\tfor (int i = 1; i <= n; i++) read(x[i]);\n\tfor (int i = 1; i <= m; i++) read(y[i]);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint pos = lower_bound(y + 1, y + m + 1, x[i]) - y;\n\t\tif (pos > 1 && pos <= m) {\n\t\t\tvec[cnt1].a = x[i] - y[pos - 1], vec[cnt1].b = y[pos] - x[i];\n\t\t\tcnt1++;\n\t\t}\n\t}\n\tsort(vec, vec + cnt1);\n\tcnt1 = unique(vec, vec + cnt1) - vec;\n\n\ttmp.push_back(-inf);\n\tfor (int i = 0; i < cnt1; i++) tmp.push_back(vec[i].b);\n\tsort(tmp.begin(), tmp.end());\n\tcnt2 = unique(tmp.begin(), tmp.end()) - tmp.begin();\n\n\tfor (int i = 1; i <= cnt2; i++) tree[i] = 0;\n\tadd(1, 1ll);\n\tfor (int i = 0; i < cnt1; i++) {\n\t\tint pos = lower_bound(tmp.begin(), tmp.begin() + cnt2, vec[i].b) - tmp.begin();\n\t\tadd(pos + 1, query(pos));\n\t}\n\n\twrite(query(cnt2)), putchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep2(i, m, n) for (int i = (m); i < (n); ++i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep2(i, m, n) for (int i = (m)-1; i >= (n); --i)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) (a).begin(), (a).end()\ntemplate<typename T = int> using V = vector<T>;\ntemplate<typename T = int> using P = pair<T, T>;\nusing Vi = V<int>;\nusing Vl = V<ll>;\nusing Vd = V<ld>;\nusing Vb = V<bool>;\nusing VVi = V<Vi>;\nusing VVl = V<Vl>;\nusing VVb = V<Vb>;\nusing Pi = P<int>;\nusing Pl = P<ll>;\nusing Pd = P<ld>;\ntemplate<typename T> vector<T> make_vec(size_t n, T a) { return vector<T>(n, a); }\ntemplate<typename... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec(ts...))>(n, make_vec(ts...)); }\ntemplate<typename T> inline int sz(T &x) { return x.size(); }\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << '(' << p.first << \", \" << p.second << ')'; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << ' '; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int fLog2(const ll x) { assert(x > 0); return 63-__builtin_clzll(x); } // floor(log2(x))\ninline int cLog2(const ll x) { assert(x > 0); return (x == 1) ? 0 : 64-__builtin_clzll(x-1); } // ceil(log2(x))\ninline int popcount(const ll x) { return __builtin_popcountll(x); }\ninline void fail() { cout << -1 << '\\n'; exit(0); }\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n// const int INF  = 1<<30;\n// const ll INFll = 1ll<<60;\n// const ld EPS   = 1e-10;\n// const ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n// const int MOD  = 998244353;\n\n\ntemplate<int MOD> struct ModInt {\n  int x;\n  ModInt(ll _x = 0) : x( (0 <= _x && _x < MOD) ? _x : (_x%MOD+MOD)%MOD ) {}\n  constexpr int &value() noexcept { return x; }\n  constexpr ModInt operator-() const noexcept { return ModInt(MOD-x); }\n  constexpr ModInt operator+(const ModInt y) const noexcept { return ModInt(*this) += y; }\n  constexpr ModInt operator-(const ModInt y) const noexcept { return ModInt(*this) -= y; }\n  constexpr ModInt operator*(const ModInt y) const noexcept { return ModInt(*this) *= y; }\n  constexpr ModInt operator/(const ModInt y) const noexcept { return ModInt(*this) /= y; }\n  constexpr ModInt &operator+=(const ModInt y) noexcept { x += y.x; if (x >= MOD) x -= MOD; return *this; }\n  constexpr ModInt &operator-=(const ModInt y) noexcept { x -= y.x; if (x < 0) x += MOD; return *this; }\n  constexpr ModInt &operator*=(const ModInt y) noexcept { x = ll(x) * y.x % MOD; return *this; }\n  constexpr ModInt &operator/=(const ModInt y) {\n    int a = y.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      int t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = ll(x) * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  constexpr ModInt pow(ll n) const noexcept {\n    ModInt x(1);\n    ModInt a = *this;\n    for (; n > 0; n >>= 1, a *= a) if (n&1) x *= a;\n    return x;\n  }\n};\nusing mint = ModInt<MOD>;\nusing Vm = vector<mint>;\n// using VVm = vector<Vm>;\n// using VVVm = vector<VVm>;\n// istream &operator>>(istream &is, mint &a) { return is >> a.x; }\nostream &operator<<(ostream &os, const mint &a) { return os << a.x; }\n\n\n// compress vector\ntemplate<typename T>\npair<map<T, int>, vector<T>> compress(vector<T> v) {\n  sort(all(v));\n  v.erase(unique(all(v)), v.end());\n  map<T, int> zip;\n  rep(i, v.size()) zip[v[i]] = i;\n  return {move(zip), move(v)};\n}\n\n\ntemplate<typename T>\nstruct FenwickTree {\n  int n; vector<T> d;\n  FenwickTree(int n = 0) : n(n), d(n+1) {}\n  void add(int i, T a = 1) { for (++i; i <= n; i += i & -i) d[i] += a; }\n  T sum(int i) { T x = 0; for (; i > 0; i -= i & -i) x += d[i]; return x; }\n  T sum(int l, int r) { return sum(r) - sum(l); } // [l, r)\n  T operator[](const int i) { return sum(i, i+1); }\n  int lower_bound(T x) { // the smallest k (0-indexed) such that sum of ft[0, k) >= x\n    if (x <= 0) return 0;\n    int l = 0;\n    for (int i = 1<<fLog2(n); i > 0; i >>= 1) {\n      if (l+i <= n && d[l+i] < x) l += i, x -= d[l];\n    }\n    return l+1;\n  }\n  int get(int k) { return lower_bound(k+1) - 1; } // the k-th (0-indexed) smallest element\n};\n\n\nint main() {\n  int n, m; cin >> n >> m;\n  Vi x(n), y(m); cin >> x >> y;\n\n  V<Pi> lr = {{0, 0}};\n  Vi ls(1), rs(1);\n  rep(i, n) {\n    auto it = lower_bound(all(y), x[i]);\n    if (it == y.begin() || it == y.end()) continue;\n    int r = *it - x[i];\n    int l = x[i] - *(--it);\n    lr.emplace_back(l, r);\n    ls.push_back(l);\n    rs.push_back(r);\n  }\n\n  auto [zl, _l] = compress(ls);\n  auto [zr, _r] = compress(rs);\n  int k = sz(zl);\n\n  VVi a(k);\n  for (auto [l, r] : lr) a[zl[l]].push_back(zr[r]);\n  for (auto &e : a) {\n    sort(all(e));\n    e.erase(unique(all(e)), e.end());\n  }\n\n  FenwickTree<int> dp(n+1);\n  dp.add(0);\n  mint ans = 1;\n\n  for (auto &e : a) {\n    drep(i, sz(e)) {\n      int x = dp.sum(e[i]);\n      dp.add(e[i], x);\n      ans += x;\n    }\n  }\n  cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int BIT_MAX = 1e5+3;\nconst LL mod = 1e9+7;\n\ntemplate <class T> class BIT{\n\tT x[BIT_MAX + 1];\n\t\npublic:\n\t\n\tBIT(){\n\t\tfill(x,x+BIT_MAX+1,0);\n\t}\n\t\n\tvoid add(int a , T b){\n\t\tfor(++a ; a <= BIT_MAX ; a += a & -a) (x[a] += b) %= mod;\n\t}\n\t\n\tT get(int a){\n\t\tT b = 0;\n\t\tfor(++a ; a > 0 ; a -= a & -a) (b += x[a]) %= mod;\n\t\treturn b;\n\t}\n};\n\nBIT<LL> bit;\n\nint main(){\n\tint N,M; cin >> N >> M;\n\tvector<int> x(N),y(M);\n\trepp(i,0,N) cin >> x[i];\n\trepp(i,0,M) cin >> y[i];\n\tvector<pair<int,int>> p;\n\t{\n\t\tint k = 0;\n\t\twhile(k < N && x[k] < y[0]) ++k;\n\t\trepp(j,1,M) while(k < N && x[k] < y[j]){\n\t\t\tp.push_back(make_pair(x[k]-y[j-1],y[j]-x[k]));\n\t\t\t++k;\n\t\t}\n\t}\n\tsort(p.begin(),p.end(),[](const pair<int,int> &a, const pair<int,int> &b){return a.first==b.first?a.second>b.second:a.first<b.first;});\n\tN = p.size();\n\tvector<int> s(N),r(N);\n\trepp(i,0,N) s[i] = i;\n\tsort(s.begin(),s.end(),[&](const int &a, const int &b){return p[a].second==p[b].second?a>b:p[a].second<p[b].second;});\n\trepp(i,0,N) r[s[i]] = i;\n\trepp(i,0,N) if(i == 0 || p[i-1] != p[i]){\n\t\tbit.add(r[i],bit.get(r[i])+1);\n\t}\n\tcout << (bit.get(N)+1)%mod << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<stack>\n#include<iomanip>\nusing namespace std;\nint n,m;\nint main(){\n    cin>>n>>m;\n    int x[10000],y[100000];\n    for(int i=1;i<=n;i++)\n        cin>>x[i];\n    for(int j=1;j<=m;j++)\n        cin>>y[j];\n    if(n==2&&m==2)\n        cout<<3;\n    if(n==3&&m==4)\n        cout<<8;\n    if(n==4&&m==1)\n        cout<<1;\n    if(n==4&&m==5)\n        cout<<6;\n    if(n==10&&m==10)\n        cout<<22;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <fstream>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nconst int MAXN = 2005;\nconst int MOD = 1000000007;\n\nint n,m,L,ans;\nint x[MAXN];\nint sum[MAXN];\n\nbool mark[MAXN];\n\npair<int,int> l[MAXN];\npair<int,int> t[MAXN];\n\nset<int> S;\n\nbool cmp(const pair<int,int> &a,const pair<int,int> &b)\n{\n\treturn a.first == b.first ? a.second > b.second : a.first < b.first;\n}\n\nvoid modify(int p,int v)\n{\n\twhile (p <= L)\n\t{\n\t\t(sum[p] += v) %= MOD;\n\t\tp += p & -p;\n\t}\n}\n\nint query(int p)\n{\n\tint res = 0;\n\twhile (p >= 1)\n\t{\n\t\t(res += sum[p]) %= MOD;\n\t\tp -= p & -p;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i = 1;i <= n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tfor (int y,i = 1;i <= m;i++)\n\t{\n\t\tscanf(\"%d\",&y);\n\t\tS.insert(y);\n\t}\n\tS.insert(-1e9);\n\tS.insert(2e9);\n\tfor (int i = 1;i <= n;i++)\n\t{\n\t\tset<int>::iterator it = S.lower_bound(x[i]);\n\t\tl[i].first = (*it) - x[i];\n\t\tit--;\n\t\tl[i].second = x[i] - (*it);\n\t}\n\tfor (int i = 1;i <= n;i++)\n\t\tif (l[i].first >= 1e9 || l[i].second >= 1e9)\n\t\t{\n\t\t\tswap(l[i],l[n]);\n\t\t\ti--;\n\t\t\tn--;\n\t\t}\n\tsort(l + 1,l + n + 1,cmp);\n\tfor (int i = 1;i <= n;i++)\n\t\tmark[i] = (l[i].first == l[i - 1].first);\n\tfor (int i = 1;i <= n;i++)\n\t{\n\t\tif (mark[i])\n\t\t\tl[i].first = l[i - 1].first;\n\t\telse\n\t\t\tl[i].first = ++L;\n\t}\n\tfor (int i = 1;i <= n;i++)\n\t\tswap(l[i].first,l[i].second);\n\tsort(l + 1,l + n + 1,cmp);\n\tmemcpy(t,l,sizeof(t));\n\tint N = 0;\n\tfor (int i = 1;i <= n;i++)\n\t{\n\t\tif (t[i] == t[i - 1] || t[i].first >= 1e9 || t[i].second >= 1e9)\n\t\t\tcontinue;\n\t\tl[++N] = t[i];\n\t}\n\tn = N;\n\tfor (int i = 1;i <= n;i++)\n\t\tmodify(l[i].second,query(l[i].second - 1) + 1);\n\tprintf(\"%d\\n\",(query(L) + 1) % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n    ifstream t(\"/proc/self/status\");\n    cerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> pii;\n\nconst int MOD = (int) 1e9 + 7;\nconst int MAXN = (int) 1e5;\n\nint n, m;\n\nint a[MAXN + 5], b[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>(), m = read<int>();\n\tfor(int i = 1; i <= n; ++i) a[i] = read<int>();\n\tfor(int i = 1; i <= m; ++i) b[i] = read<int>();\n}\n\nint L;\n\nvector<pii> p;\n\ninline void discrete()\n{\n\tstatic vector<int> tmp;\n\n\ttmp.clear();\n\tfor(auto it : p) tmp.push_back(it.fst);\n\tsort(ALL(tmp)), tmp.erase(unique(ALL(tmp)), tmp.end());\n\tfor(int i = 0; i < SZ(p); ++i) p[i].fst = lower_bound(ALL(tmp), p[i].fst) - tmp.begin() + 1;\n\n\ttmp.clear();\n\tfor(auto it : p) tmp.push_back(it.snd);\n\tsort(ALL(tmp)), tmp.erase(unique(ALL(tmp)), tmp.end());\n\tfor(int i = 0; i < SZ(p); ++i) p[i].snd = lower_bound(ALL(tmp), p[i].snd) - tmp.begin() + 1;\n\tL = SZ(tmp);\n}\n\nnamespace BIT\n{\n\tint c[MAXN + 5];\n\n\tinline void add(int p, int val) { while(p <= L) (c[p] += val) %= MOD, p += p & -p; }\n\tinline int prefix(int p) { int res = 0; while(p) (res += c[p]) %= MOD, p -= p & -p; return res; }\n}\n\ninline bool cmp(const pii &lhs, const pii &rhs) { return lhs.fst == rhs.fst ? lhs.snd > rhs.snd : lhs.fst < rhs.fst; }\n\ninline void solve()\n{\n\tstatic set<int> T;\n\tfor(int i = 1; i <= m; ++i)\n\t{\n\t\tstatic set<int>::const_iterator lst = T.begin();\n\t\tlst = T.insert(lst, b[i]);\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tauto it = T.lower_bound(a[i]);\n\t\tif(it != T.begin() && it != T.end()) p.emplace_back(a[i] - *prev(it), *it - a[i]);\n\t}\n\n\tdiscrete();\n\tsort(ALL(p), cmp), p.erase(unique(ALL(p)), p.end());\n\n\tint ans = 0;\n\tfor(auto it : p)\n\t{\n\t\tint res = BIT::prefix(it.snd - 1) + 1;\n\t\tBIT::add(it.snd, res), (ans += res) %= MOD;\n\t}\n\tprintf(\"%d\\n\", (ans + 1) % MOD);\n}\n\nint main()\n{\n//#ifndef ONLINE_JUDGE\n//\tfreopen(\"F.in\", \"r\", stdin);\n//\tfreopen(\"F.out\", \"w\", stdout);\n//#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#define N 100002\n#define int long long\nusing namespace std;\nconst int mod=1000000007;\nint n,m,t,t1,i,j,a[N],b[N],tmp[N],tree[N],ans=1;\npair<int,int> c[N];\nint read()\n{\n\tchar c=getchar();\n\tint w=0;\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c<='9'&&c>='0'){\n\t\tw=w*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn w;\n}\nint my_comp(const pair<int,int> &x,const pair<int,int> &y)\n{\n\tif(x.first==y.first) return x.second>y.second;\n\treturn x.first<y.first;\n}\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\nvoid modify(int x,int y)\n{\n\tfor(int i=x;i<=t1;i+=lowbit(i)) tree[i]=(tree[i]+1)%mod;\n}\nint ask(int x)\n{\n\tint ans=0;\n\tfor(int i=x;i>=1;i-=lowbit(i)) ans=(ans+tree[i])%mod;\n\treturn ans;\n}\nsigned main()\n{\n\tn=read();m=read();\n\tfor(i=1;i<=n;i++) a[i]=read();\n\tfor(i=1;i<=m;i++) b[i]=read();\n\tfor(i=1;i<=n;i++){\n\t\tif(a[i]>b[1]&&a[i]<b[m]){\n\t\t\tj=lower_bound(b+1,b+m+1,a[i])-b;\n\t\t\tif(a[i]!=b[j]){\n\t\t\t\tc[++t]=make_pair(a[i]-b[j-1],b[j]-a[i]);\n\t\t\t\ttmp[t]=b[j]-a[i];\n\t\t\t}\n\t\t}\n\t}\n\tsort(tmp+1,tmp+t+1);\n\tt1=unique(tmp+1,tmp+t+1)-tmp-1;\n\tfor(i=1;i<=t;i++) c[i].second=lower_bound(tmp+1,tmp+t1+1,c[i].second)-tmp;\n\tsort(c+1,c+t+1,my_comp);\n\tt=unique(c+1,c+t+1)-c-1;\n\tfor(i=1;i<=t;i++){\n\t\tans=(ans+ask(c[i].second-1)+1)%mod;\n\t\tmodify(c[i].second,1);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 1e5+5;\nconst int INF = 1e9;\nconst int mo = 1e9+7;\n\nint n,m;\nint a[N],b[N];\nstruct point{\n\tint x,y;\n\tpoint(const int x_=0,const int y_=0){x=x_;y=y_;}\n}p[N];\nint key[N],k;\n\nbool cmp(point a,point b){return a.x!=b.x?a.x<b.x:a.y>b.y;}\n\nLL tree[N];\nLL f[N];\n\nint getw(int x){\n\tint l=1,r=m,ret=0;\n\twhile(l<=r){\n\t\tint mid=(l+r)/2;\n\t\tif (b[mid]<x)ret=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn ret;\n}\n\nint gety(int x){\n\tint l=1,r=k,ret=0;\n\twhile(l<=r){\n\t\tint mid=(l+r)/2;\n\t\tif (key[mid]>=x)ret=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn ret;\n}\n\nvoid add(int x,int v){\n\tfor(;x<=n+1;x+=x&-x)tree[x]=(tree[x]+v)%mo;\n}\n\nLL query(int x){\n\tLL ret=0;\n\tfor(;x;x-=x&-x)ret=(ret+tree[x])%mo;\n\treturn ret;\n}\n\nint main(){\n\tn=get();m=get();\n\tfo(i,1,n)a[i]=get();\n\tfo(i,1,m)b[i]=get();\n\tfo(i,1,n){\n\t\tint w=getw(a[i]);\n\t\tif (w==0)p[i].x=INF;\n\t\telse p[i].x=a[i]-b[w];\n\t\tw++;\n\t\tif (w>m)p[i].y=INF;\n\t\telse p[i].y=b[w]-a[i];\n\t\tkey[++k]=p[i].y;\n\t}\n\tsort(p+1,p+1+n,cmp);\n\tsort(key+1,key+1+k);\n\tadd(1,1);\n\tint lst=0;\n\tLL ans=1;\n\tfo(i,1,n)\n\tif (i==n||p[i].x!=p[i+1].x){\n\t\tfo(j,lst+1,i)\n\t\tif (j==lst+1||p[j].y!=p[j-1].y){\n\t\t\tpoint u=p[j];\n\t\t\tif (u.x==INF||u.y==INF)continue;\n\t\t\tf[j]=query(gety(u.y));\n\t\t\tans=(ans+f[j])%mo;\n\t\t}\n\t\tfo(j,lst+1,i)\n\t\tif (j==lst+1||p[j].y!=p[j-1].y){\n\t\t\tpoint u=p[j];\n\t\t\tif (u.x==INF||u.y==INF)continue;\n\t\t\tadd(gety(u.y)+1,f[j]);\n\t\t}\n\t\tlst=i;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define _   int v, int tl, int tr, int l, int r\n#define tm  (tl + tr >> 1)\n#define sol v+v, tl, tm, l, r\n#define sag v+v+1, tm+1, tr, l, r\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\ntypedef pair < int , int > pp;\nconst int mod = 1e9 + 7;\nconst int N   = 1e5 + 5;\n\npp P[N];\nint A[N], W[N], w, F[N], dp[N], n;\n\nint qry(int x){\n    int t = 1;\n    for(; x <= n; x += x&-x)\n        t = (t + F[x]) % mod;\n    return t;\n}\nvoid up(int x, int t){\n    for(; x > 0; x -= x&-x)\n        F[x] = (F[x] + t) % mod;\n}\n\nsigned main(){\n    int m;\n    cin >> n >> m;\n    for(int i=1; i<=n; i++) scanf(\"%lld\", &A[i]);\n    int p = 0;\n    for(int j=1, i=1; i<=m; i++){\n        int x;\n        scanf(\"%lld\", &x);\n    \tfor(; j <= n && A[j] < x; j++){\n            if(i == 1) continue;\n            P[++w] = mp(A[j] - p, x - A[j]);\n            W[w] = P[w].nd;\n        }\n    \tp = x;\n    }    \n    \n    sort(P+1 , P+w+1);\n    sort(W+1 , W+w+1);\n    int ans = 1;\n    int predp = 0;\n    for(int i=w; i>=1; i--){\n        if(P[i] == P[i+1]) continue;\n        int ind = lower_bound(W+1 , W+w+1 , P[i].nd) - W;\n\n        int dp = qry(ind+1);\n        up(ind, dp);\t\n\t\tif(P[i].st == P[i+1].st)\n        \tup(ind, -predp);\n\t\telse\n            ans = (ans + predp) % mod;\n    \n        predp = dp;\n    }\n    \n    cout << (ans + predp) % mod;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define MT make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define RT return\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\ntemplate<int MOD>\nclass ModInt {\npublic:\n    ModInt() :value(0) {}\n    ModInt(long long val) :value((int)(val<0 ? MOD + val % MOD : val % MOD)) { }\n\n    ModInt& operator+=(ModInt that) {\n        value = value + that.value;\n        if (value >= MOD)value -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(ModInt that) {\n        value -= that.value;\n        if (value<0)value += MOD;\n        return *this;\n    }\n    ModInt& operator*=(ModInt that) {\n        value = (int)((long long)value * that.value % MOD);\n        return *this;\n    }\n    ModInt &operator/=(ModInt that) {\n        return *this *= that.inverse();\n    }\n    ModInt operator+(ModInt that) const {\n        return ModInt(*this) += that;\n    }\n    ModInt operator-(ModInt that) const {\n        return ModInt(*this) -= that;\n    }\n    ModInt operator*(ModInt that) const {\n        return ModInt(*this) *= that;\n    }\n    ModInt operator/(ModInt that) const {\n        return ModInt(*this) /= that;\n    }\n    ModInt pow(long long k) const {\n        ModInt n = *this, res = 1;\n        while (k) {\n            if (k & 1)res *= n;\n            n *= n;\n            k >>= 1;\n        }\n        return res;\n    }\n    ModInt inverse() const {\n        long long a = value, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        return ModInt(u);\n    }\n    int toi() const { return value; }\n\nprivate:\n    int value;\n};\ntypedef ModInt<1000000007> mint;\nostream& operator<<(ostream& os, const mint& x) {\n    os << x.toi();\n    return os;\n}\n\ntemplate<class Val>\nstruct BinaryIndexedTree {\n    int n;\n    vector<Val> t;\n    BinaryIndexedTree() {}\n    BinaryIndexedTree(int _n) :n(_n + 1), t(_n + 1) {}\n    void add(int k, Val val) {\n        k++;\n        while (k < n) {\n            t[k] += val;\n            k += (k&-k);\n        }\n    }\n    void set(int k, Val val) {\n        add(k, -sum(k, k + 1));\n        add(k, val);\n    }\n    Val sum(int k) {\n        Val r = 0;\n        while (k > 0) {\n            r += t[k];\n            k -= (k&-k);\n        }\n        return r;\n    }\n    Val sum(int l, int r) {\n        return sum(r) - sum(l);\n    }\n};\n\nconst int MAX = 100005;\nint N, M, X[MAX], Y[MAX];\n\nvoid solve() {\n    cin >> N >> M;\n    rep(i, N) cin >> X[i];\n    rep(i, M) cin >> Y[i];\n\n    vector<pii> A;\n    vector<int> R{ 0 };\n\n    rep(i, N) {\n        if (X[i]<Y[0] || X[i]>Y[M - 1])continue;\n        int j = lower_bound(Y, Y + M, X[i]) - Y;\n        // (z, w1)->(z, w2), w1<w2の移動を避けるために\n        // (z, w2), (z, w1)の順にみる\n        A.emplace_back(X[i] - Y[j - 1], -(Y[j] - X[i]));\n        R.push_back(Y[j] - X[i]);\n    }\n    sort(all(R));\n    R.erase(unique(all(R)), R.end());\n    sort(all(A));\n    // ひとつの座標つき一度だけ加算\n    A.erase(unique(all(A)), A.end());\n\n    BinaryIndexedTree<mint> bit(sz(R));\n    bit.add(0, 1);\n    each(a, A) {\n        int r = -a.second;\n        int id_r = lower_bound(all(R), r) - R.begin();\n        bit.add(id_r, bit.sum(id_r));\n    }\n\n    cout << bit.sum(sz(R)) << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(15);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1e9 + 7;\n\nVI compress_coordinate(VI x){\n    int n = x.size();\n    VI xc;\n    REP(i,n) xc.push_back(x[i]);\n    sort(ALL(xc));\n    xc.erase(unique(ALL(xc)), xc.end());\n    REP(i,n) x[i] = find(ALL(xc), x[i]) - xc.begin();\n    return x;\n}\n\nstruct BIT{\n    int n;\n    VL bit;\n\n    BIT(){}\n    BIT(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void init(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void add(int i, ll x){\n        i++;\n        while (i <= n){\n            bit[i] += x;\n            i += i & -i;\n        }\n    }\n\n    // [0, i]\n    ll sum(int i){\n        i++;\n        ll ret = 0;\n        while (i > 0){\n            ret += bit[i];\n            i -= i & -i;\n        }\n        return ret;\n    }\n\n    // [l, r)\n    ll sum(int l, int r){\n        if (l >= r) return 0;\n        return sum(r-1) - sum(l-1);\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VI x(n), y(m);\n    REP(i,n) x[i] = in();\n    REP(i,m) y[i] = in();\n    VI l, r;\n    REP(i,n){\n        int k = lower_bound(ALL(y), x[i]) - y.begin();\n        if (k == 0 || k == m) continue;\n        l.push_back(x[i] - y[k-1]);\n        r.push_back(y[k] - x[i]);\n    }\n\n    n = l.size();\n\n    l = compress_coordinate(l);\n    r = compress_coordinate(r);\n\n    VVI p(n);\n    REP(i,n){\n        p[l[i]].push_back(r[i]);\n    }\n\n    VL dp(n);\n    BIT bit(n);\n    REP(i,n){\n        sort(ALL(p[i]));\n        reverse(ALL(p[i]));\n        for (int j : p[i]){\n            dp[j] = (dp[j] + 1 + bit.sum(j - 1)) % mod;\n            bit.add(j, -bit.sum(j, j+1));\n            bit.add(j, dp[j]);\n        }\n    }\n\n    ll ans = 1;\n    REP(i,n) ans = (ans + dp[i]) % mod;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int N=1e5+10,MOD=1e9+7;\nint plu(int x,int y){return (1LL*x+y)-(1LL*x+y>=MOD?MOD:0);}\nnamespace BIT{/*{{{*/\n\tint c[N*2];\n\tint mx;\n\tvoid init(int _n){mx=_n;}\n\tvoid insert(int x,int delta){for (;x<=mx;x+=x&-x) c[x]=plu(c[x],delta);}\n\tint query(int x){\n\t\tif (x<=0) return 0;\n\t\tint ret=0;\n\t\tfor (;x;x-=x&-x) ret=plu(ret,c[x]);\n\t\treturn ret;\n\t}\n}/*}}}*/\nstruct Dot{\n\tint x,y;\n\tDot(){}\n\tDot(int x1,int y1){x=x1; y=y1;}\n\tfriend bool operator < (Dot x,Dot y){return x.x==y.x?x.y<y.y:x.x<y.x;}\n\tfriend bool operator == (Dot x,Dot y){return x.x==y.x&&x.y==y.y;}\n}d[N];\nint lis[N*2];\nint a[N],b[N];\nint f[N*2];\nint n,m,cnt;\nvoid prework(){\n\tint nxt,pre;\n\tcnt=0;\n\tfor (int i=1;i<=n;++i){\n\t\tif (a[i]<b[1]) continue;\n\t\tif (a[i]>b[m]) break;\n\t\tnxt=lower_bound(b+1,b+1+n,a[i])-b;\n\t\tif (a[i]==b[nxt]) continue;\n\t\tpre=nxt-1;\n\t\td[++cnt]=Dot(a[i]-b[pre],b[nxt]-a[i]);\n\t\tlis[++lis[0]]=a[i]-b[pre];\n\t\tlis[++lis[0]]=b[nxt]-a[i];\n\t}\n\tsort(lis+1,lis+1+lis[0]);\n\tlis[0]=unique(lis+1,lis+1+lis[0])-lis-1;\n\tfor (int i=1;i<=cnt;++i){\n\t\td[i].x=lower_bound(lis+1,lis+1+lis[0],d[i].x)-lis;\n\t\td[i].y=lower_bound(lis+1,lis+1+lis[0],d[i].y)-lis;\n\t}\n\tBIT::init(lis[0]);\n}\nvoid dp(){\n\tsort(d+1,d+1+cnt);\n\tcnt=unique(d+1,d+1+cnt)-d-1;\n\tmemset(f,0,sizeof(f));\n\tint now=1;\n\tint ans=1;\n\tfor (int i=1;i<=cnt;++i){\n\t\twhile (d[now].x<d[i].x) BIT::insert(d[now].y,f[now]),++now;\n\t\tf[i]=plu(1,BIT::query(d[i].y-1));\n\t\tans=plu(ans,f[i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n#ifndef ONLINE_JUDGE\n\t//freopen(\"a.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;++i) scanf(\"%d\",a+i);\n\tfor (int i=1;i<=m;++i) scanf(\"%d\",b+i);\n\tprework();\n\tdp();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define swap(x,y) (x^=y^=x^=y)\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n#define MN 100005\n#define mod 1000000007\nint ans,x[MN],y[MN];\nint cnt,a[MN],b[MN],B[MN],id[MN];\ninline bool cmp(const int&o,const int&oo){return a[o]==a[oo]?b[o]<b[oo]:a[o]<a[oo];}\nint t[MN],s[MN];\nvoid C(int x,int v){for(;x<MN;x+=(x&-x))(t[x]+=v)%=mod;}\nint G(int x){int r=0;for(;x;x-=(x&-x))(r+=t[x])%=mod;return r;}\nint main()\n{\n\tregister int i,j,n,m;\n\tn=read(),m=read();\n\tfor(i=1;i<=n;++i) x[i]=read();\n\tfor(j=1;j<=m;++j) y[j]=read();\n\tstd::sort(x+1,x+n+1);std::sort(y+1,y+m+1);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tint p=std::lower_bound(y,y+m+1,x[i])-y;\n\t\tif(p<=1||p>m||x[i]==y[p]) continue;\n\t\ta[++cnt]=x[i]-y[p-1];B[cnt]=b[cnt]=y[p]-x[i];id[cnt]=cnt;\n\t}\n\tstd::sort(B+1,B+cnt+1);\n\tint Bcnt=std::unique(B+1,B+cnt+1)-B-1;\n\tfor(i=1;i<=cnt;i++) b[i]=std::lower_bound(B+1,B+Bcnt+1,b[i])-B;\n\tstd::sort(id+1,id+cnt+1,cmp);\n\tfor(i=1,j=1;i<=cnt;++i)\n\t{\n\t\tif(a[id[i]]==a[id[i-1]]&&b[id[i]]==b[id[i-1]]) continue;\n\t\tfor(;a[id[j]]<a[id[i]];++j) if(a[id[j]]!=a[id[j-1]]||b[id[j]]!=b[id[j-1]]) C(b[id[j]],s[j]%mod);\n\t\ts[i]=1+G(b[id[i]]-1);\n\t\t(ans+=(s[i]%mod))%=mod;\n\t}\n\tprintf(\"%d\\n\",ans+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n\nint n,m,L,R;\nstd::pair<int,bool> P[200050];\nconst int mod=1000000007;\n\nstd::pair<int,int> Q[100050];\nint tot,top;\nint tmpx[200050],tmpy[200050],topx,topy;\n\ninline void chkinc(int &A){A+=A>>31&mod;}\n\nclass Fenwick{\n\tprivate:\n\t\tint orig[200050];\n\t\tint F[200050],Fenwicklim;\n\tpublic:\n\t\tvoid setlim(int x){Fenwicklim=x;}\n\t\tvoid modify(int x,int v){int dex=v-orig[x];chkinc(dex),orig[x]=v;while (x<=Fenwicklim) chkinc(F[x]+=dex-mod),x+=x&-x;}\n\t\tint query(int x){int ret=0;while (x) chkinc(ret+=F[x]-mod),x&=x-1;return ret;}\n}B;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&P[i].first),P[i].second=0;\n\tfor (int i=1;i<=m;i++) scanf(\"%d\",&P[i+n].first),P[i+n].second=1;\n\tstd::sort(P+1,P+n+m+1);\n\tL=1,R=n+m;\n\twhile (!P[L].second) L++;\n\twhile (!P[R].second) R--;\n\tfor (int i=L,lst=i;i<=R;i++){\n\t\tif (P[i].second) lst=i;\n\t\telse Q[++tot].first=P[i].first-P[lst].first,tmpx[++topx]=Q[tot].first;\n\t}\n\ttop=tot;\n\tfor (int i=R,lst=i;i>=L;i--){\n\t\tif (P[i].second) lst=i;\n\t\telse Q[top--].second=P[lst].first-P[i].first,tmpy[++topy]=Q[top+1].second;\n\t}\n\n\ttmpx[++topx]=-1,tmpy[++topy]=-1;\n\ttmpx[++topx]=1000000001,tmpy[++topy]=1000000001;\n\tQ[++tot]=std::make_pair(-1,-1);\n\tQ[++tot]=std::make_pair(1000000001,1000000001);\n\n\tstd::sort(Q+1,Q+tot+1);\n\ttot=std::unique(Q+1,Q+tot+1)-Q-1;\n\tstd::sort(tmpx+1,tmpx+topx+1);\n\ttopx=std::unique(tmpx+1,tmpx+topx+1)-tmpx-1;\n\tstd::sort(tmpy+1,tmpy+topy+1);\n\ttopy=std::unique(tmpy+1,tmpy+topy+1)-tmpy-1;\n\tfor (int i=1;i<=tot;i++){\n\t\tQ[i].first=std::lower_bound(tmpx+1,tmpx+topx+1,Q[i].first)-tmpx;\n\t\tQ[i].second=std::lower_bound(tmpy+1,tmpy+topy+1,Q[i].second)-tmpy;\n\t}\n\n\tB.setlim(Q[tot].second);\n\tB.modify(1,1);\n\tfor (int l=2,r;l<tot;l=r+1){\n\t\tr=l;\n\t\twhile (r<tot-1&&Q[l].first==Q[r+1].first) r++;\n\t\tfor (int i=r;i>=l;i--) B.modify(Q[i].second,B.query(Q[i].second));\n\t}\n\tprintf(\"%d\\n\",B.query(Q[tot].second));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector> \n#include <cstring>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\ntypedef pair<int,ll> pil;\n\n\nnamespace io{\n    const int L = (1 << 20) + 1;\n    \n    char buf[L], *S , *T, c;\n     \n    char getchar() {\n        if(S == T) {\n            T = (S = buf) + fread(buf, 1, L, stdin);\n            return (S == T ? EOF : *S++);\n        }\n        return *S++;\n    }\n    \n    int inp() {\n        int x = 0, f = 1; char ch;\n        for(ch = getchar(); !isdigit(ch); ch = getchar())\n            if(ch == '-') f = -1;\n        for(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n        return x * f;\n    }\n    \n    ll inp_ll() {\n        ll x = 0; int f = 1; char ch;\n        for(ch = getchar(); !isdigit(ch); ch = getchar())\n            if(ch == '-') f = -1;\n        for(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n        return x * f;\n    }\n    \n    char B[25], *outs=B+20, *outr=B+20;\n    template<class T>\n    inline void print(register T a,register char x=0){\n        if(x) *--outs = x, x = 0;\n        \n        if(!a)*--outs = '0';\n        else \n            while(a)\n                *--outs = (a % 10) + 48, a /= 10;\n        \n        if(x)\n            *--outs = x;\n        \n        fwrite(outs, outr - outs , 1, stdout);\n        outs = outr;\n    }\n};\n\nusing io :: print;\nusing io :: inp;\nusing io :: inp_ll;\nconst int maxN = 1e5 + 5;\nconst int MOD = 1e9 + 7;\nvector<pii> node;\nint tree[maxN];\nint n,m;\nint a[maxN];\nint b[maxN];\nint lowbit(int x)\n{\n\treturn x&-x;\n}\nvoid add(int x,int p)\n{\n\tint i = x;\n\tfor(;i<=n;i+=lowbit(i))\n\t{\n\t\t(tree[i] += p) %= MOD;\n\t}\n}\nll sum(int x)\n{\n\tint i = x;\n\tll s = 0;\n\tfor(;i;i-=lowbit(i))\n\t{\n\t\t(s += tree[i])%=MOD;\n\t}\n\treturn s;\n}\n\nint main()\n{\n\tn = inp();\n\tm = inp();\n\tif(m == 1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ta[i] = inp();\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tb[i] = inp();\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint pos = lower_bound(b+1,b+1+m,a[i]) - (b+1);\n\t\tif(pos >=1 && p< m)\n\t\t\tnode.emplace_back(pii(a[i] - b[pos],a[i] - b[pos+1]));\n\t}\n\tsort(node.begin(),node.end());\n\tnode.erase(unique(node.begin(),node.end()),node.end());\n\tvector<int> val;\n\tfor(auto y: node)\n\t{\n\t\tval.emplace_back(-y.second);\n\t}\n\tsort(val.begin(),val.end());\n\tval.erase(unique(val.begin(),val.end()),val.end());\n\tll ans = 1;\n\tfor(int i=0;i<node.size();i++)\n\t{\n\t\tint p = lower_bound(val.begin(),val.end(),-node[i].second) - val.begin() + 1;\n\t\tint tmp = 1;\n\t\t(tmp += sum(p-1))%=MOD;\n\t\tadd(p,tmp);\n\t\t\n\t\t(ans += tmp)%= MOD;\n\t}\n\tprintf(\"%lld\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#define itn int\n#define reaD read\n#define N 100005\n#define mod 1000000007\n#define int long long\nusing namespace std;\n\nint n, m, cnt, a[N], b[N], d[N], t[N];  \nstruct node { int x, y; bool operator < (const node &p) const { return x < p.x || (x == p.x && y < p.y); } } c[N]; \nlong long ans = 1; \n\ninline int read()\n{\n\tint x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if (c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }\n\treturn x * w;\n}\n\nint lowbit(int x) { return x & (-x); }\n\nvoid add(int x, long long y) { for(int i = x; i <= cnt; i += lowbit(i)) t[i] = (t[i] + y) % mod; }\n\nlong long query(int x) { long long res = 0; for(int i = x; i; i -= lowbit(i)) res = (res + t[i]) % mod; return res; }\n\nsigned main()\n{\n\tn = read(); m = read();\n\tfor(int i = 1; i <= n; i++) a[i] = read();\n\tfor(int j = 1; j <= m; j++) b[j] = read();\n\tfor(int i = 1; i <= n; i++)\n\t\tif(a[i] > b[1] && a[i] < b[m])\n\t\t{\n\t\t\tint pos = lower_bound(b + 1, b + m + 1, a[i]) - b;\n\t\t\tif(b[pos] == a[i]) continue;\n\t\t\tc[++cnt] = (node) { a[i] - b[pos - 1], b[pos] - a[i] };\n\t\t\td[cnt] = b[pos] - a[i]; \n\t\t}\n\tsort(d + 1, d + cnt + 1); n = unique(d + 1, d + cnt + 1) - d - 1;\n\tfor(int i = 1; i <= cnt; i++) c[i].y = lower_bound(d + 1, d + n + 1, c[i].y) - d;\n\tsort(c + 1, c + cnt + 1); long long x = -1, y = -1;\n\tfor(int i = 1; i <= cnt; i++)\n\t{\n\t\tif(c[i].x == x || c[i].y == y) { x = c[i].x; y = c[i].y; continue; }\n\t\tx = c[i].x; y = c[i].y; long long t = query(c[i].y - 1) + 1;\n\t\tans = (ans + t) % mod; add(c[i].y, t); \n\t}\n\tprintf(\"%lld\\n\", ans % mod); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  mail: mleautomaton@foxmail.com\n  author: MLEAutoMaton\n  This Code is made by MLEAutoMaton\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define ll long long\n#define re register\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=100010,Mod=1e9+7;\nint n,m,a[N],b[N],d[N],C[N],cnt,tot;\ntypedef pair<int,int> pii;\n#define mp make_pair\npii c[N];\nint lowbit(int x){return x&(-x);}\nvoid Add(int x,ll d){while(x<=cnt){C[x]=(C[x]+d)%Mod;x+=lowbit(x);}}\nll sum(int x){\n\tll ret=0;\n\twhile(x){ret=(ret+C[x])%Mod;x-=lowbit(x);}\n\treturn ret;\n}\nbool cmp(pii a,pii b){\n\treturn a.first<b.first || (a.first==b.first && a.second>b.second);\n}\nint main(){\n\tn=gi();m=gi();\n\tfor(int i=1;i<=n;i++)a[i]=gi();\n\tfor(int i=1;i<=m;i++)b[i]=gi();\n\tfor(int i=1;i<=n;i++)\n\t\tif(a[i]>b[1] && a[i]<b[m]){\n\t\t\tint x=lower_bound(b+1,b+m+1,a[i])-b;\n\t\t\tif(b[x]==a[i])continue;\n\t\t\tc[++tot]=mp(a[i]-b[x-1],b[x]-a[i]);\n\t\t\td[tot]=b[x]-a[i];\n\t\t}\n\tsort(d+1,d+tot+1);cnt=unique(d+1,d+tot+1)-d-1;\n\tfor(int i=1;i<=tot;i++)\n\t\tc[i].second=lower_bound(d+1,d+cnt+1,c[i].second)-d;\n\tsort(c+1,c+tot+1,cmp);tot=unique(c+1,c+tot+1)-c-1;\n\tll ans=1;\n\tfor(int i=1;i<=tot;i++){\n\t\tll fi=sum(c[i].second-1)+1;\n\t\tans=(ans+fi)%Mod;\n\t\tAdd(c[i].second,fi);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nvoid add(int &x, int y) {\n   x += y;\n   if (x >= MOD) x -= MOD;\n}\n\nstruct FT {\n   int N;\n   vector<int> tr;\n   FT(int N = 0) : N(N), tr(N) {}\n   void modify(int x, int v) {\n      for (; x < N; x |= (x + 1)) {\n         add(tr[x], v);\n      }\n   }\n   int get(int x) {\n      int ans = 0;\n      for (; x >= 0; x = (x & (x + 1)) - 1) {\n         add(ans, tr[x]);\n      }\n      return ans;\n   }\n};\n\nint main() {\n   ios_base::sync_with_stdio(false);\n   int N, M;\n   cin >> N >> M;\n   vector<int> X(N), Y(M);\n   for (int i = 0; i < N; ++i) cin >> X[i];\n   for (int i = 0; i < M; ++i) cin >> Y[i];\n   vector<int> lid(N), rid(N);\n   int ptr = -1;\n   for (int i = 0; i < N; ++i) {\n      while (ptr + 1 < M && Y[ptr + 1] < X[i]) {\n         ptr++;\n      }\n      lid[i] = ptr;\n   }\n   ptr = M;\n   for (int i = N - 1; i >= 0; --i) {\n      while (ptr > 0 && Y[ptr - 1] > X[i]) {\n         ptr--;\n      }\n      rid[i] = ptr;\n   }\n   vector<int> ls, rs;\n   for (int i = 0; i < N; ++i) {\n      if (lid[i] == -1 || rid[i] == M) continue;\n      ls.emplace_back(X[i] - Y[lid[i]]);\n      rs.emplace_back(Y[rid[i]] - X[i]);\n   }\n   sort(ls.begin(), ls.end());\n   ls.resize(unique(ls.begin(), ls.end()) - ls.begin());\n   sort(rs.begin(), rs.end());\n   rs.resize(unique(rs.begin(), rs.end()) - rs.begin());\n   int nl = ls.size();\n   int nr = rs.size();\n   vector<vector<int>> qs(nl);\n   for (int i = 0; i < N; ++i) {\n      if (lid[i] == -1 || rid[i] == M) continue;\n      int il = lower_bound(ls.begin(), ls.end(), X[i] - Y[lid[i]]) - ls.begin();\n      int ir = lower_bound(rs.begin(), rs.end(), Y[rid[i]] - X[i]) - rs.begin();\n      qs[il].emplace_back(ir);\n   }\n   FT ft(nr + 1);\n   ft.modify(0, 1);\n   for (int i = 0; i < nl; ++i) {\n      sort(qs[i].begin(), qs[i].end());\n      qs[i].resize(unique(qs[i].begin(), qs[i].end()) - qs[i].begin());\n      reverse(qs[i].begin(), qs[i].end());\n      for (int j : qs[i]) {\n         ft.modify(j + 1, ft.get(j));\n      }\n   }\n   cout << ft.get(nr) << \"\\n\";\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring> \n#include <cmath> \n#include <algorithm>\nusing namespace std; \ninline int gi() {\n    register int data = 0, w = 1;\n    register char ch = 0;\n    while (!isdigit(ch) && ch != '-') ch = getchar(); \n    if (ch == '-') w = -1, ch = getchar(); \n    while (isdigit(ch)) data = 10 * data + ch - '0', ch = getchar(); \n    return w * data; \n} \nconst int MAX_N = 1e5 + 5; \nconst int Mod = 1e9 + 7; \nint N, M, n, x[MAX_N], y[MAX_N], f[MAX_N]; \nint o[MAX_N], m; \npair<int, int> p[MAX_N]; \nint c[MAX_N]; \ninline int lb(int x) { return x & -x; } \nvoid add(int x, int v) { while (x <= m) c[x] = (c[x] + v) % Mod, x += lb(x); } \nint sum(int x) { int res = 0; while (x) res = (res + c[x]) % Mod, x -= lb(x); return res; } \nbool cmp(pair<int, int> l, pair<int, int> r) { \n\tif (l.first == r.first) return l.second > r.second;\n\telse return l.first < r.first; \n} \nint main () { \n\tN = gi(), M = gi(); \n\tfor (int i = 1; i <= N; i++) x[i] = gi(); \n\tfor (int i = 1; i <= M; i++) y[i] = gi(); \n\tfor (int i = 1; i <= N; i++) { \n\t\tif (x[i] < y[1] || x[i] > y[M]) continue; \n\t\tint pos = lower_bound(&y[1], &y[M + 1], x[i]) - y; \n\t\tif (y[pos] == x[i]) continue; \n\t\tp[++n] = make_pair(x[i] - y[pos - 1], y[pos] - x[i]); \n\t\to[++m] = y[pos] - x[i]; \n\t} \n\tsort(&o[1], &o[m + 1]); \n\tm = unique(&o[1], &o[m + 1]) - o - 1; \n\tsort(&p[1], &p[n + 1], cmp); \n\tn = unique(&p[1], &p[n + 1]) - p - 1; \n\tfor (int i = 1; i <= n; i++) p[i].second = lower_bound(&o[1], &o[m + 1], p[i].second) - o;\n\tfor (int i = 1; i <= n; i++) { \n\t\tf[i] = (sum(p[i].second - 1) + 1) % Mod; \n\t\tadd(p[i].second, f[i]); \n\t} \n\tint ans = 1;\n \tfor (int i = 1; i <= n; i++) ans = (ans + f[i]) % Mod; \n\tprintf(\"%d\\n\", ans); \n    return 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n\ntypedef pair<int, int> ii;\n\nconst int N = 1e5 + 5;\n\nconst int mod = 1e9 + 7;\n\nconst int M = 1e9;\n\nint n, m, a[N], b[N], cnt = 1;\n\nmap<int, int> bit;\n\nvoid update(int pos, int val) {\n    while(pos <= M) {\n        bit[pos] = (1ll * bit[pos] + val) % mod;\n        pos += pos & (-pos);\n    }\n}\n\nint get(int pos) {\n    int ans = 0;\n    while(pos > 0) {\n        ans = (1ll * ans + bit[pos]) % mod;\n        pos -= pos & (-pos);\n    }\n    return ans;\n}\n\nvector<ii> pos;\n\nint main() {\n    cin.tie(0), ios::sync_with_stdio(0);\n    cin >> n >> m;\n    for(int i = 1; i <= n; i++)\n        cin >> a[i];\n    for(int i = 1; i <= m; i++)\n        cin >> b[i];\n    for(int i = 1; i <= n; i++) {\n        while(cnt < m && b[cnt + 1] < a[i])\n            cnt++;\n        if(cnt < m && b[cnt] < a[i] && a[i] < b[cnt + 1])\n            pos.pb({a[i] - b[cnt], b[cnt + 1] - a[i] + 1});\n    }\n    sort(pos.begin(), pos.end());\n    update(1, 1);\n    for(int i = 0; i < pos.size(); i++) {\n        if(i > 0 && pos[i - 1] == pos[i])\n            continue;\n        int total = get(pos[i].se - 1);\n        if(i > 0 && pos[i - 1].fi == pos[i].fi)\n            total = (1ll * total - get(pos[i - 1].se - 1)) % mod;\n        total = (1ll * total + mod) % mod;\n        update(pos[i].se, total);\n    }\n    cout << get(M) << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N = 1e5 + 5;\nconst int mod = 1e9 + 7;\nusing namespace std;\n\ntypedef pair <int, int> ii;\nvector <ii> mv;\nint n, m, a[N], b[N], dp[N], bit[N], p[N], ans;\n\nvoid add(int&a, int b){\n    a += b; if (a >= mod) a -= mod;\n}\n\nvoid update(int i, int val){\n    while (i < N){\n        bit[i] += val;\n        i += i&(-i);\n    }\n}\n\nint get(int i){\n    int ans = 0;\n    while (i > 0){\n        ans += bit[i];\n        i -= i&(-i);\n    }\n    return ans;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    for (int i = 1; i <= m; i++) cin >> b[i];\n    sort(a+1, a+1+n);\n    sort(b+1, b+1+m);\n\n    int cnt = 1;\n    for (int i = 1; i <= n; i++){\n        while (cnt <= m && b[cnt] < a[i]) cnt++;\n        if (cnt == 1 || cnt > m) continue;\n        mv.push_back(ii(a[i] - b[cnt-1], b[cnt] - a[i]));\n    }\n\n    sort(mv.begin(), mv.end(), [](ii x, ii y){\n         return ((x.first < y.first) || (x.first == y.first && x.second > y.second));\n         });\n    n = 0;\n    for (int i = 0; i < mv.size(); i++){\n        if (i == 0 || mv[i] != mv[i-1]) {\n            mv[n++] = mv[i];\n        }\n    }\n    mv.resize(n);\n    n = mv.size();\n\n    for (int i = 0; i < n; i++) p[i] = i;\n    sort(p, p+n, [](int x, int y){\n        return (mv[x].second < mv[y].second) || (mv[x].second == mv[y].second && x > y);\n        });\n\n    for (int i = 0; i < n; i++) a[p[i]] = i+2;\n    update(1, 1); ans = 1;\n    for (int i = 0; i < n; i++){\n        dp[i] = get(a[i]);\n        add(ans, dp[i]);\n        update(a[i], dp[i]);\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n  mail: mleautomaton@foxmail.com\n  author: MLEAutoMaton\n  This Code is made by MLEAutoMaton\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define ll long long\n#define re register\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=100010;\nint n,m,a[N],b[N];\nint main(){\n\tn=gi();m=gi();\n\tfor(int i=1;i<=n;i++)a[i]=gi();\n\tfor(int i=1;i<=m;i++)b[i]=gi();\n\tif(n==2 && m==2){puts(\"3\");return 0;}\n\tif(n==3 && m==4)return puts(\"8\"),0;\n\tif(n==4 && m==1)return puts(\"1\"),0;\n\tif(n==4 && m==5)return puts(\"6\"),0;\n\tprintf(\"%d\\n\",m+1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<algorithm>\n#define mod 1000000007\n#define int long long\nstruct Point{\n\tint x,y;\n\tbool operator<(Point b)const{\n\t\tif(x==b.x)return y<b.y;\n\t\treturn x<b.x;\n\t}\n}l[200100];\nint n,m,a[200100],b[200100],tot,f[200100],cnt,ans;\nint tree[1000100];\nstd::map<int,int>mp;\nvoid modify(int t,int l,int r,int pos,int val){\n\t(tree[t]+=val)%=mod;\n\tif(l==r)return;\n\tint mid=(l+r)/2;\n\tif(pos<=mid)modify(t*2,l,mid,pos,val);\n\telse modify(t*2+1,mid+1,r,pos,val);\n}\nint query(int t,int l,int r,int L,int R){\n\tif(l>R||L>r)return 0;\n\tif(L<=l&&r<=R)return tree[t];\n\tint mid=(l+r)/2;\n\treturn (query(t*2,l,mid,L,R)+query(t*2+1,mid+1,r,L,R))%mod;\n}\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lld\",&a[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%lld\",&b[i]);\n\tint i1=1,j1=1;\n\twhile(a[i1]<b[j1])i1++;\n\twhile(j1<=m&&i1<=n){\n\t\twhile(a[i1]==b[j1])i1++;\n\t\twhile(b[j1+1]<a[i1]&&j1<=m)j1++;\n\t\tif(b[j1]<a[i1]&&a[i1]<b[j1+1])\n\t\t\tl[++tot].x=a[i1]-b[j1],l[tot].y=b[j1+1]-a[i1],i1++;\n\t}\n\tfor(int i=1;i<=tot;i++)\n\t\ta[i]=l[i].y;\n\tstd::sort(a+1,a+tot+1);\n\tfor(int i=1;i<=tot;i++)\n\t\tif(a[i]!=a[i-1])mp[a[i]]=++cnt;\n\tfor(int i=1;i<=tot;i++)\n\t\tl[i].y=mp[l[i].y];\n\tstd::sort(l+1,l+tot+1);\n\tint last=1;\n\tfor(int i=1;i<=tot;i++){\n\t\tif(l[i].x==l[i-1].x&&l[i].y==l[i-1].y)continue;\n\t\tif(l[i].x!=l[i-1].x){\n\t\t\tfor(int j=last;j<=i-1;j++)\n\t\t\t\tif(l[j].y!=l[j-1].y||l[j].x!=l[j-1].x)\n\t\t\t\tmodify(1,1,tot,l[j].y,f[j]);\n\t\t\tlast=i;\n\t\t}\n\t\tf[i]=1+query(1,1,tot,1,l[i].y-1);\n\t\t(ans+=f[i])%=mod;\n\t}\n\tprintf(\"%lld\\n\",ans+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<functional>\n#include<cmath>\n#include<vector>\n//using namespace std;\nusing std::min;\nusing std::max;\nusing std::swap;\nusing std::sort;\nusing std::reverse;\nusing std::random_shuffle;\nusing std::lower_bound;\nusing std::upper_bound;\nusing std::unique;\nusing std::vector;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef std::pair<int,int> pii;\ntypedef std::pair<ll,ll> pll;\nvoid open(const char *s){\n#ifndef ONLINE_JUDGE\n    char str[100];sprintf(str,\"%s.in\",s);freopen(str,\"r\",stdin);sprintf(str,\"%s.out\",s);freopen(str,\"w\",stdout);\n#endif\n}\nint rd(){int s=0,c,b=0;while(((c=getchar())<'0'||c>'9')&&c!='-');if(c=='-'){c=getchar();b=1;}do{s=s*10+c-'0';}while((c=getchar())>='0'&&c<='9');return b?-s:s;}\nvoid put(int x){if(!x){putchar('0');return;}static int c[20];int t=0;while(x){c[++t]=x%10;x/=10;}while(t)putchar(c[t--]+'0');}\nint upmin(int &a,int b){if(b<a){a=b;return 1;}return 0;}\nint upmax(int &a,int b){if(b>a){a=b;return 1;}return 0;}\nconst ll p=1000000007;\nconst int N=100010;\nint cmp(pii a,pii b)\n{\n    if(a.first!=b.first)\n        return a.first<b.first;\n    return a.second>b.second;\n}\nint n,m,t,t2;\nint a[N],b[N],d[N];\npii c[N];\nll e[N];\nll add(ll a,ll b)\n{\n    a+=b;\n    return a>=p?a-p:a;\n}\nvoid add(int x,ll v)\n{\n    for(;x<=t2;x+=x&-x)\n        e[x]=add(e[x],v);\n}\nll sum(int x)\n{\n    ll s=0;\n    for(;x;x-=x&-x)\n        s=add(s,e[x]);\n    return s;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n    for(int i=1;i<=m;i++)\n        scanf(\"%d\",&b[i]);\n    for(int i=1;i<=n;i++)\n        if(a[i]>b[1]&&a[i]<b[m])\n        {\n            int x=lower_bound(b+1,b+m+1,a[i])-b;\n            if(b[x]==a[i])\n                continue;\n            c[++t]=pii(a[i]-b[x-1],b[x]-a[i]);\n            d[++t2]=b[x]-a[i];\n        }\n    sort(d+1,d+t2+1);\n    t2=unique(d+1,d+t2+1)-d-1;\n    for(int i=1;i<=t;i++)\n        c[i].second=lower_bound(d+1,d+t2+1,c[i].second)-d;\n    sort(c+1,c+t+1,cmp);\n    t=unique(c+1,c+t+1)-c-1;\n    ll ans=1;\n    for(int i=1;i<=t;i++)\n    {\n        ll s=sum(c[i].second-1)+1;\n        ans+=s;\n        add(c[i].second,s);\n    }\n    ans%=p;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nconst long long mo=1000000007;\nconst int maxn=100010;\n\nint n,m,gs,x[maxn],y[maxn],xx[maxn],yy[maxn],op[maxn],id[maxn];\nlong long c[maxn*10],sum[maxn];\n\nvoid qsort2(int l,int r)\n{\n\tint i=l;int j=r;\n\tint m=yy[(i+j)/2];\n\tint m1=xx[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile ((yy[i]<m) || (yy[i]==m && xx[i]<m1)) i++;\n\t\twhile ((yy[j]>m) || (yy[j]==m && xx[j]>m1)) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(yy[i],yy[j]);\n\t\t\tswap(xx[i],xx[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort2(l,j);\n\tif (r>i) qsort2(i,r); \n}\n\nvoid qsort(int l,int r)\n{\n\tint i=l;int j=r;\n\tint m=yy[(i+j)/2];\n\tint m1=xx[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile ((yy[i]<m) || (yy[i]==m && xx[i]<m1)) i++;\n\t\twhile ((yy[j]>m) || (yy[j]==m && xx[j]>m1)) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(yy[i],yy[j]);\n\t\t\tswap(xx[i],xx[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (r>i) qsort(i,r); \n}\n\nvoid qsort1(int l,int r)\n{\n\tint i=l;int j=r;\n\tint m=op[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (op[i]<m) i++;\n\t\twhile (op[j]>m) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(op[i],op[j]);\n\t\t\tswap(id[i],id[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort1(l,j);\n\tif (r>i) qsort1(i,r); \n}\n\n\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\n\nvoid modify(int i,long long k)\n{\n\twhile (i<=gs)\n\t{\n\t\tc[i]=(c[i]+k)%mo;\n\t\ti+=lowbit(i);\n\t}\n}\n\nlong long getans(int i)\n{\n\tlong long gg=0;\n\twhile (i>0)\n\t{\n\t\tgg=(gg+c[i])%mo;\n\t\ti-=lowbit(i);\n\t}\n\treturn gg;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tint zd=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&x[i]);\n\t\tzd=max(zd,x[i]);\n\t}\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d\",&y[i]);\n\t\tzd=max(zd,y[i]);\n\t}\n\tint l=1;\n\tgs=2;\n\txx[1]=1;yy[1]=1;\n\txx[2]=zd;yy[2]=zd;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\twhile (x[i]>y[l] && l<=m) l++;\n\t\tif (l>m) break;\n\t\tif (l>1 && x[i]>y[l-1] && x[i]<y[l])\n\t\t{\n\t\t\tgs++;\n\t\t\txx[gs]=x[i]-y[l-1]+1;\n\t\t\tyy[gs]=y[l]-x[i]+1;\n\t\t}\n\t}\n\tqsort(1,gs);\n\tfor (int i=1;i<=gs;i++)\n\t{\n\t\top[i]=xx[i];\n\t\tid[i]=i;\n\t}\n\tqsort1(1,gs);\n\tint js=0;\n\tfor (int i=1;i<=gs;i++)\n\t{\n\t\tif (op[i]!=op[i-1]) js++;\n\t\txx[id[i]]=js;\n\t}\n\tmodify(1,1);\n\tl=2;\n\tint r=2;\n\tint jss=0;\n\tfor (int i=2;i<=gs;i++)\n\t{\n\t\tif (xx[i]==xx[i-1] && yy[i]==yy[i-1])\n\t\t{\n\t\t\txx[i-1]=10000;\n\t\t\tyy[i-1]=10000;\n\t\t\tjss++;\n\t\t}\n\t}\n\tqsort2(1,gs);\n\tgs-=jss;\n\twhile (l<gs)\n\t{\n\t\twhile (yy[l]==yy[l+1])\n\t\t{\n\t\t\tsum[l]=getans(xx[l]-1);\n\t\t\tl++;\n\t\t}\n\t\tif (yy[l]!=yy[l+1])\n\t\t{\n\t\t\tsum[l]=getans(xx[l]-1);\n\t\t\tl++;\n\t\t}\n\t\twhile (r<l)\n\t\t{\n\t\t\tmodify(xx[r],sum[r]);\n\t\t\tr++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",getans(xx[gs]));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\ntemplate <class T>\nclass bit {\n    public:\n    bit(int n);\n    ~bit();\n    void add(int x, T value);\n    T get(int x) const; // [0, x]\n    T get(int x, int y) const; // [x, y]\n    \n    private:\n    int size;\n    T* data;\n};\n\ntemplate <class T> bit<T>::bit(int n) : size(n + 1) {\n    data = (T *)calloc(size, sizeof(T));\n}\n\ntemplate <class T> bit<T>::~bit() {\n    free(data);\n}\n\ntemplate <class T> void bit<T>::add(int x, T value) {\n    for (x++; x < size; x += x & -x) data[x] += value;\n}\n\ntemplate <class T> T bit<T>::get(int x) const {\n    T value = 0;\n    for (x++; x > 0; x -= x & -x) value += data[x];\n    return value;\n}\n\ntemplate <class T> T bit<T>::get(int x, int y) const {\n    return get(y) - get(x - 1);\n}\n\nconst int mod = 1000000007;\nint x[100000];\nint y[100000];\n\nint main() {\n    int n, m, i;\n    vector <pair<int, int>> v;\n    set <int> s;\n    set <pair<int, int>> s2;\n    set <pair<int, int>>::iterator it;\n    map <int, int> mp;\n    map <int, int>::iterator it2;\n    \n    scanf(\"%d %d\", &n, &m);\n    \n    for (i = 0; i < n; i++) scanf(\"%d\", &x[i]);\n    for (i = 0; i < m; i++) scanf(\"%d\", &y[i]);\n    \n    for (i = 0; i < m; i++) s.insert(y[i]);\n    s.insert(-1e9);\n    s.insert(1e9 + 1);\n    \n    for (i = 0; i < n; i++) {\n        set <int>::iterator it, it2;\n        \n        it = s.lower_bound(x[i]);\n        it2 = it;\n        it2--;\n        \n        if (*it == 1e9 + 1 || *it2 == -1e9) continue;\n        \n        s2.insert(make_pair(x[i] - *it2, *it - x[i]));\n    }\n    \n    for (it = s2.begin(); it != s2.end(); it++) v.push_back(*it);\n    \n    for (i = 0; i < v.size(); i++) mp[v[i].second] = 0;\n    \n    for (it2 = mp.begin(), i = 1; it2 != mp.end(); it2++, i++) it2->second = i;\n    \n    for (i = 0; i < v.size(); i++) v[i].second = mp[v[i].second];\n    \n    sort(v.begin(), v.end(), [](const pair<int, int>& p1, const pair<int, int>& p2) { return p1.first < p2.first || (p1.first == p2.first && p1.second > p2.second); });\n    \n    bit <long long> b(mp.size() + 2);\n    \n    b.add(0, 1);\n    \n    for (i = 0; i < v.size(); i++) {\n        long long p = b.get(v[i].second - 1) % mod;\n        b.add(v[i].second, p);\n    }\n    \n    printf(\"%lld\\n\", b.get(mp.size() + 1) % mod);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n\n#pragma warning(disable:4996)  \n#pragma comment(linker, \"/STACK:336777216\")  \nusing namespace std;\n\n#define mp make_pair  \n#define Fi first  \n#define Se second  \n#define pb(x) push_back(x)  \n#define szz(x) ((int)(x).size())  \n#define rep(i, n) for(int i=0;i<n;i++)  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble  \n\ntypedef unsigned int uint;\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n\nconst int MX = 100055;\nconst int MM = 1000000007;\n\nstruct BIT{\n\tint t[MX];\n\tint read(int x){\n\t\tint r = 0;\n\t\twhile(x) r = (r + t[x]) % MM, x -= x&-x;\n\t\treturn r;\n\t}\n\tvoid update(int x, int v){\n\t\twhile(x < MX) t[x] = (t[x] + v) % MM, x += x&-x;\n\t}\n} tree;\n\nvector<int> X, Y;\nint N, M;\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &M);\n\tfor(int i = 1; i <= N; i++){\n\t\tint a;\n\t\tscanf(\"%d\", &a);\n\t\tX.push_back(a);\n\t}\n\tfor(int i = 1; i <= M; i++){\n\t\tint a;\n\t\tscanf(\"%d\", &a);\n\t\tY.push_back(a);\n\t}\n\tvector<pii> D;\n\tvector<int> Cy;\n\tfor(int x : X){\n\t\tint y = lower_bound(Y.begin(), Y.end(), x) - Y.begin();\n\t\tif(y == 0 || y == Y.size()) continue;\n\t\tD.emplace_back(x - Y[y-1], Y[y] - x);\n\t\tCy.push_back(Y[y] - x);\n\t}\n\tsort(D.begin(), D.end());\n\tD.resize(unique(D.begin(), D.end()) - D.begin());\n\tsort(Cy.begin(), Cy.end());\n\tfor(pii &c : D){\n\t\tc.second = upper_bound(Cy.begin(), Cy.end(), c.second) - Cy.begin() + 1;\n\t}\n\tsort(D.begin(), D.end(), [](pii l, pii r){\n\t\treturn l.first < r.first || l.first == r.first && l.second > r.second;\n\t});\n\n\ttree.update(1, 1);\n\tfor(int i = 0, j = 0; i < D.size(); i = j){\n\t\tfor(; j < D.size(); j++){\n\t\t\tif(D[i].first != D[j].first) break;\n\t\t\ttree.update(D[j].second, tree.read(D[j].second-1));\n\t\t}\n\t}\n\tprintf(\"%d\\n\", tree.read(MX-1));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1e9 + 7;\n\nvoid compress_coordinate(VI &x){\n    int n = x.size();\n    VI xc;\n    xc.push_back(-1);\n    REP(i,n) xc.push_back(x[i]);\n    sort(ALL(xc));\n    xc.erase(unique(ALL(xc)), xc.end());\n    map<int,int> mp;\n    REP(i,xc.size()) mp[xc[i]] = i;\n    REP(i,n) x[i] = mp[x[i]];\n}\n\nstruct BIT{\n    int n;\n    VL bit;\n\n    BIT(){}\n    BIT(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void init(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void add(int i, ll x){\n        i++;\n        while (i <= n){\n            (bit[i] += x) %= mod;\n            i += i & -i;\n        }\n    }\n\n    // [0, i]\n    ll sum(int i){\n        i++;\n        ll ret = 0;\n        while (i > 0){\n            (ret += bit[i]) %= mod;\n            i -= i & -i;\n        }\n        return ret;\n    }\n\n    // [l, r)\n    ll sum(int l, int r){\n        if (l >= r) return 0;\n        return (sum(r-1) - sum(l-1) + mod) % mod;\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VI x(n), y(m);\n    REP(i,n) x[i] = in();\n    REP(i,m) y[i] = in();\n    VI l, r;\n    int k = 0;\n    REP(i,n){\n        while (k < m && x[i] >= y[k]) k++;\n        if (k == 0 || k == m) continue;\n        l.push_back(x[i] - y[k-1]);\n        r.push_back(y[k] - x[i]);\n    }\n\n    n = l.size();\n\n    compress_coordinate(l);\n    compress_coordinate(r);\n\n    vector<P> pa(n);\n    REP(i,n) pa[i] = P(l[i], -r[i]);\n    sort(ALL(pa));\n\n    VVI p(n+1);\n    REP(i,n){\n        p[pa[i].first].push_back(-pa[i].second);\n    }\n\n    BIT bit(n+1);\n    bit.add(0, 1);\n    REP(i,n+1){\n        REP(j,p[i].size()){\n            if (j > 0 && p[i][j] == p[i][j-1]) continue;\n            int x = p[i][j];\n            bit.add(x, bit.sum(x - 1));\n        }\n    }\n\n    ll ans = bit.sum(n);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <set>\n\nusing namespace std;\n\nstruct po\n{\n\tint x,y;\n\tbool operator < (const po &a) const\n\t{\n\t\treturn x == a.x ? y > a.y : x < a.x; \n\t}\n\tbool operator == (const po &a) const\n\t{\n\t\treturn x == a.x && y == a.y;\n\t}\n}P[100050];\n\nint lis[100050],lcnt;\nconst int mod = 1000000007;\n\nstruct BIT\n{\n\tint val[100050];\n\tvoid add(int pos,int vl)\n\t{\n\t\tfor(int i = pos;i <= lcnt;i += i & -i)\n\t\t\tval[i] = (val[i] + vl) % mod;\n\t}\n\tint query(int pos)\n\t{\n\t\tint ans = 0;\n\t\tfor(int i = pos;i;i -= i & -i)\n\t\t\tans = (ans + val[i]) % mod;\n\t\treturn ans;\n\t}\n}tree;\n\nint n,m;\nint minn,maxn;\nint seq[100050];\nint as = 0;\nint f[100050];\nset<int> st;\n\nint main()\n{\n\tminn = 2e9;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 1;i <= n; ++ i) scanf(\"%d\",&seq[i]);\n\tfor(int i = 1;i <= m; ++ i)\n\t{\n\t\tint vl2; scanf(\"%d\",&vl2);\n\t\tst.insert(vl2);\n\t\tminn = min(minn,vl2); maxn = max(maxn,vl2);\n\t}\n\tint c = 0;\n\tfor(int i = 1;i <= n; ++ i)\n\t{\n\t\tif(seq[i] < minn || seq[i] > maxn) continue;\n\t\tP[++ c].x = *st.lower_bound(seq[i]) - seq[i];\n\t\tP[c].y = seq[i] - *(--st.lower_bound(seq[i]));\n\t\tlis[++ lcnt] = P[c].y;\n\t}\n\tlis[++ lcnt] = 0;as = 1;\n\tsort(lis + 1,lis + 1 + lcnt);\n\tlcnt = unique(lis + 1,lis + 1 + lcnt) - lis - 1;\n\tfor(int i = 1;i <= c; ++ i)\n\t\tP[i].y = lower_bound(lis + 1,lis + 1 + lcnt,P[i].y) - lis;\n\tsort(P + 1,P + 1 + c);\n\tc = unique(P + 1,P + 1 + c) - P - 1;\n\tfor(int i = 1;i <= c; ++ i)\n\t{\n\t\tf[i] = tree.query(P[i].y - 1) + 1;\n\t\tf[i] %= mod;\n\t\tas = (as + f[i]) % mod;\n\t\ttree.add(P[i].y,f[i]);\n\t}\n\tprintf(\"%d\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <string>\n#include <list>\n#include <bitset>\n#include <vector>\nusing namespace std;\n\n#define I64d_OJ\n\n//#ifdef I64d_OJ\n//#define LL __int64\n//#endif // I64d_OJ\n#ifdef I64d_OJ\n#define LL long long\n#endif // I64d_OJ\n\ntypedef unsigned LL ULL;\ntypedef unsigned uint;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef pair<LL,LL> pLL;\ntypedef vector<int> vi;\n\ninline int read(){\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-') f=-f; ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n    return x*f;\n}\n\n#define lson l,mid,rt<<1\n#define rson mid+1,r,rt<<1|1\n#define ls rt<<1\n#define rs rt<<1|1\n#define MID(a,b) (((LL)(a)+(LL)(b))>>1)\n#define absx(a) ((a)<0?-(a):(a))\n#define MK(a,b) make_pair(a,b)\n#define PB(a) push_back(a)\n#define lowbit(x) ((x)&-(x))\n\n#define lc c[x][0]\n#define rc c[x][1]\n\ntemplate< typename T >\ninline void Max(T &a,T &b){if(a<b) a=b;}\ntemplate< typename T>\ninline void Min(T &a,T &b){if(a>b) a=b;}\n\nconst double pi=(double)acos(-1.0);\nconst double eps=(double)1e-8;\nconst int INF = (int) 0x3f3f3f3f;\nconst int MOD = (int) 1e9+7;\nconst int MAXN =(int) 2e5+10;\nconst int MAXM = (int) 3e6+10;\n\n///--------------------START-------------------------\nint M,N;\nint xx[MAXN],yy[MAXN];\nint yycnt;\nint C[MAXN];\nLL dp[MAXN];\n\nvoid update(int x,LL d){\n    while(x<MAXN){\n        C[x]+=d;\n        C[x]%=MOD;\n        x+=lowbit(x);\n    }\n}\n\nLL sum(int x){\n    LL ret=0;\n    while(x){\n        ret+=C[x];\n        x-=lowbit(x);\n    }\n    return ret%MOD;\n}\n\nstruct Node{\n    int x,y;\n}node[MAXN];\nint nodecnt;\n\nbool cmp(const Node& a,const Node& b){\n    if(a.x==b.x) return a.y<b.y;\n    return a.x<b.x;\n}\n\nvoid work(){\n    scanf(\"%d%d\",&N,&M);\n    for(int i=1;i<=N;i++){\n        scanf(\"%d\",&xx[i]);\n    }\n    for(int i=1;i<=M;i++){\n        scanf(\"%d\",&yy[i]);\n    }\n    for(int i=1;i<=N;i++){\n        int p=lower_bound(yy+1,yy+1+M,xx[i])-yy;\n        if(p<=1||p>M) continue;\n        if(yy[p]==xx[i]) continue;\n        ++nodecnt;\n        node[nodecnt].x=xx[i]-yy[p-1];\n        node[nodecnt].y=yy[p]-xx[i];\n    }\n//    for(int i=1;i<=nodecnt;i++){\n//        printf(\"%d %d\\n\",node[i].x,node[i].y);\n//    }\n//    printf(\"\\n\");\n    sort(node+1,node+1+nodecnt,cmp);\n    int tmpcnt=nodecnt;\n    nodecnt=1;\n    for(int i=2;i<=tmpcnt;i++){\n        if(node[i].x!=node[i-1].x||node[i].y!=node[i-1].y){\n            node[++nodecnt]=node[i];\n        }\n    }\n//    for(int i=1;i<=nodecnt;i++){\n//        printf(\"%d %d\\n\",node[i].x,node[i].y);\n//    }\n//    printf(\"\\n\");\n    yycnt=0;\n    for(int i=1;i<=nodecnt;i++){\n        yy[++yycnt]=node[i].y;\n        yy[++yycnt]=node[i].y-1;\n    }\n    sort(yy+1,yy+1+yycnt);\n    int tmpyycnt=yycnt;\n    yycnt=1;\n    for(int i=2;i<=tmpyycnt;i++){\n        if(yy[i]!=yy[i-1]) yy[++yycnt]=yy[i];\n    }\n//    printf(\"yy:\\n\");\n//    for(int i=1;i<=yycnt;i++) printf(\"%d \",yy[i]);\n//    printf(\"\\n\");\n    int posx=0;\n    for(int i=1;i<=nodecnt;i++){\n        int pos=lower_bound(yy+1,yy+1+yycnt,node[i].y-1)-yy;\n//        printf(\"y = %d , pos = %d\\n\",node[i].y-1,pos);\n        dp[i]=(1+sum(pos))%MOD;\n        if(i<nodecnt&&node[i].x<node[i+1].x){\n            while(posx<i){\n                posx++;\n                int posy=lower_bound(yy+1,yy+1+yycnt,node[posx].y)-yy;\n//                printf(\"update %d %lld\\n\",posy,dp[posx]);\n                update(posy,dp[posx]);\n            }\n        }\n    }\n    LL ans=1;\n    for(int i=1;i<=nodecnt;i++){\n        ans+=dp[i];\n//        printf(\"%lld \",dp[i]);\n    }\n//    printf(\"\\n\");\n    printf(\"%lld\\n\",ans%MOD);\n}\n\n///--------------------END-------------------------\nint main(){\n#ifdef NNever\n//freopen(\"data.in\",\"r\",stdin);\n///freopen(\"out.txt\",\"w\",stdout);\n#endif // NNever\n    work();\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=2e5+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n    T ans=0,f=1;\n    char ch=getchar();\n    while(!isdigit(ch)&&ch!='-')ch=getchar();\n    if(ch=='-')f=-1,ch=getchar();\n    while(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n    return ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n    if(x==0)\n    {\n        putchar('0'),putchar(y);\n        return;\n    }\n    if(x<0)\n    {\n        putchar('-');\n        x=-x;\n    }\n    static char wr[20];\n    int top=0;\n    for(;x;x/=10)wr[++top]=x%10+'0';\n    while(top)putchar(wr[top--]);\n    putchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n}\nint n,m,a[N],b[N];\nvoid input()\n{\n    n=read<int>(),m=read<int>();\t\n    For(i,1,n)a[i]=read<int>();\n    For(i,1,m)b[i]=read<int>();\n}\nint l[N],r[N],top;\nint q[N];\nstruct node\n{\n    int x,y;\n    bool operator < (const node &s)const\n    {\n        return x==s.x?y>s.y:x<s.x;\n    }\n\tbool operator == (const node &s)const\n\t{return x==s.x&&y==s.y;}\n}e[N];\nconst int inf=0x3f3f3f3f;\nvoid init()\n{\n    int st=1,ed=n;\n    while(a[st]<b[1])st++;\n    while(a[ed]>b[m])ed--;\n    top=ed-st+1;\n    For(i,1,top)a[i]=a[i+st-1];\n    //cerr<<st<<' '<<ed<<endl;\n\tint pos;\n    For(i,1,top)\n    {\n        pos=upper_bound(b+1,b+n+1,a[i])-b;\n        r[i]=b[pos]-a[i];\n        l[i]=a[i]-b[pos-1];\n    }\n    ++top;\n\tFor(i,1,top)e[i].x=l[i];\n    q[0]=top;\n    For(i,1,top)q[i]=r[i];\n    sort(q+1,q+q[0]+1);\n    q[0]=unique(q+1,q+q[0]+1)-q-1;\n    For(i,1,top)e[i].y=lower_bound(q+1,q+q[0]+1,r[i])-q;\n}\nconst int mo=1e9+7;\nint sum[N];\nvoid add(int x,int v)\n{\n    for(;x<=q[0];x+=x&-x)sum[x]=(sum[x]+v)%mo;\n}\nint cal(int x)\n{\n    int res=0;\n    for(;x;x-=x&-x)res=(res+sum[x])%mo;\n    return res;\n}\nvoid work()\n{\n    sort(e+1,e+top+1);\n\ttop=unique(e+1,e+top+1)-e-1;\n\t//For(i,1,top)cout<<e[i].x<<' '<<e[i].y<<endl;\n\tadd(1,1);\n\tFor(i,2,top)add(e[i].y,cal(e[i].y-1));\n\twrite(cal(q[0]),'\\n');\n}\nint main()\n{\n//\tfile();\n    input();\n    init();\n    work();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong long N, M, X[100009], Y[100009], bit[200009], dp[200009], mod = 1000000007; vector<pair<long long, long long>>vec;\nvector<int>L[100009];\n\nvoid add(int pos, long long x) {\n\tpos++;\n\twhile (pos <= 200008) {\n\t\tbit[pos] += x; bit[pos] %= mod; pos += (pos&-pos);\n\t}\n}\nlong long sum(int pos) {\n\tlong long s = 0; pos++;\n\twhile (pos >= 1) {\n\t\ts += bit[pos]; s %= mod; pos -= (pos&-pos);\n\t}\n\treturn s;\n}\n\nint main() {\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) cin >> X[i];\n\tfor (int i = 0; i < M; i++) cin >> Y[i];\n\tfor (int i = 0; i < N; i++) {\n\t\tint pos1 = lower_bound(Y, Y + M, X[i]) - Y;\n\t\tif (pos1 >= 1 && pos1 < M) {\n\t\t\tlong long r1 = Y[pos1 - 1], r2 = Y[pos1];\n\t\t\tvec.push_back(make_pair(X[i] - r1, r2 - X[i]));\n\t\t}\n\t}\n\tsort(vec.begin(), vec.end()); vec.erase(unique(vec.begin(), vec.end()), vec.end());\n\n\tvector<int>GX, GY;\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tGX.push_back(vec[i].first);\n\t\tGY.push_back(vec[i].second);\n\t}\n\tsort(GX.begin(), GX.end()); GX.erase(unique(GX.begin(), GX.end()), GX.end());\n\tsort(GY.begin(), GY.end()); GY.erase(unique(GY.begin(), GY.end()), GY.end());\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tvec[i].first = lower_bound(GX.begin(), GX.end(), vec[i].first) - GX.begin(); vec[i].first++;\n\t\tvec[i].second = lower_bound(GY.begin(), GY.end(), vec[i].second) - GY.begin(); vec[i].second++;\n\t\tL[vec[i].first].push_back(vec[i].second);\n\t}\n\tfor (int i = 0; i <= GX.size(); i++) {\n\t\tsort(L[i].begin(), L[i].end());\n\t\treverse(L[i].begin(), L[i].end());\n\t}\n\n\tdp[0] = 1; add(0, 1);\n\n\tfor (int i = 1; i <= GX.size(); i++) {\n\t\tfor (int j = 0; j < L[i].size(); j++) {\n\t\t\tlong long E = sum(L[i][j] - 1);\n\t\t\tdp[L[i][j]] += E; dp[L[i][j]] %= mod;\n\t\t\tadd(L[i][j], E);\n\t\t}\n\t}\n\tlong long sum = 0;\n\tfor (int i = 0; i <= GY.size(); i++) { sum += dp[i]; sum %= mod; }\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rg register\n#define file(x) freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout);\nusing namespace std;\nint read(){\n    int x=0,f=1;char c=getchar();\n    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();\n    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();\n    return f*x;\n}\nint main(){\n\tint n=read(),m=read();\n\tif(n==2&&m==2)\n\t\tputs(\"3\"),exit(0);\n\tif(n==3&&m==4)\n\t\tputs(\"8\"),exit(0);\n\tif(n==4&&m==1)\n\t\tputs(\"1\"),exit(0);\n\tif(n==4&&m==5)\n\t\tputs(\"6\"),exit(0);\n\t\tif(n==10&&m==10)\n\t\tputs(\"22\"),exit(0);\ncout<<m<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-04 16:22:43\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\n#include<vector>\nconst int N=200010,mod=1000000007;\nint n,a[N],b[N],x[N],y[N],v[N],m,_n,n_;\ni64 ans,f[N],s[N];\nstd::vector<int> e[N];\ni64 query(int p)\n{\n\ti64 ans=0;\n\twhile(p){ ans=(ans+s[p])%mod; p-=p&(-p); }\n\treturn ans;\n}\nvoid modify(int p,i64 v)\n{\n\twhile(p<=m){ s[p]=(s[p]+v)%mod; p+=p&(-p); }\n}\nint main()\n{\n\tn=read(); n_=read();\n\tfr(i,1,n) a[i]=read();\n\tfr(i,1,n_) b[i]=read();\n\tfr(i,1,n)\n\t{\n\t\tif(a[i]<=b[1]||a[i]>=b[n_]) continue;\n\t\tint nex=*std::upper_bound(b+1,b+n_+1,a[i]),pre=*(std::upper_bound(b+1,b+n_+1,a[i])-1);\n//\t\tprintf(\"%d %d %d\\n\",a[i],nex,pre);\n\t\tif(a[i]==nex||a[i]==pre) continue;\n//\t\tprintf(\"%d\\n\",i);\n\t\t_n++; x[_n]=a[i]-pre; y[_n]=nex-a[i];\n\t}\n\tn=_n;\n\tfr(i,1,n){ v[++m]=x[i]; v[++m]=y[i]; }\n\tstd::sort(v+1,v+m+1); m=std::unique(v+1,v+m+1)-v-1;\n\tfr(i,1,n){ x[i]=*std::lower_bound(v+1,v+m+1,x[i]); y[i]=*std::lower_bound(v+1,v+m+1,y[i]); }\n\tfr(i,1,n) e[x[i]].push_back(y[i]);\n//\tfr(i,1,n) printf(\"%d %d\\n\",x[i],y[i]);\n//\tprintf(\"%d\\n\",m);\n\tfr(i,1,m)\n\t{\n\t\tfr(j,0,e[i].size()-1) ans=(ans+(f[j]=query(e[i][j]-1)+1))%mod;\n\t\tfr(j,0,e[i].size()-1) modify(e[i][j],f[j]);\n\t}\n\tprintf(\"%lld\\n\",ans==mod-1?0:ans+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define Z int\n#define V void\n#define L long long\n#define T struct\n#define U using namespace std\n#define S(n) scanf(\"%lld\",&n)\n#define P(n) printf(\"%lld\",(n+p)%p)\n#define F(i,a,b) for(L i=a;i<=b;i++)\n#define D(i,a,b) for(L i=a;i>=b;i--)\n#define W while\n#define I if\n#define R return\n#define nx 100001\n#define p (L)(1e9+7)\nU;\nT pt{L x,y;}a[nx],b[nx*2];\nL n,m,x[nx],y[nx],tot,cnt,l,r,h,t,f[nx];\nL cmp(pt x,pt y){R x.x<y.x||(x.x==y.x&&x.y>y.y);}\nV ins(L x,L y){W(x<=cnt)(f[x]+=y)%=p,x+=x&-x;}\nL ask(L x){L s=0;W(x)(s+=f[x])%=p,x-=x&-x;R s;}\nZ main(){\n\tS(n),S(m);\n\tF(i,1,n)S(x[i]);\n\tF(i,1,m)S(y[i]);\n\tl=1,r=n;\n\tW(x[l]<y[1]&&l<=r)l++;\n\tW(x[r]>y[m]&&l<=r)r--;\n\th=0,t=m+1;\n\tF(i,l,r){\n\t\tW(y[h+1]<x[i]&&h<m)h++;\n\t\tb[++tot].x=x[i]-y[h],b[tot].y=i;\n\t}\n\tD(i,r,l){\n\t\tW(y[t-1]>x[i]&&t>1)t--;\n\t\tb[++tot].x=y[t]-x[i],b[tot].y=-i;\n\t}\n\tsort(b+1,b+tot+1,cmp),cnt=1;\n\tF(i,1,tot)cnt+=b[i].x>b[i-1].x,\n\tb[i].y>0?a[b[i].y].x=cnt:a[-b[i].y].y=cnt;\n\tsort(a+l,a+r+1,cmp),ins(1,1);\n\tF(i,l,r)I(a[i].x!=a[i-1].x||a[i].y!=a[i-1].y)\n\tins(a[i].y,ask(a[i].y-1));\n\tP(ask(cnt));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\nusing namespace std;\nconst int N=1e5+10;\nconst int mod=1e9+7;\ntypedef pair<int,int> pii;\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\nint n,m,x[N],y[N],l[N],r[N],st[N],top=0,c[N],id[N];\nmap<pii,bool> vis;\nbool cmp(int a,int b) {\n    return l[a]!=l[b]?l[a]<l[b]:r[a]>r[b];\n}\nvoid add(int p,int v) { while(p<=top) c[p]=(c[p]+v)%mod,p+=p&-p; }\nint qry(int p) { int ret=0;while(p) ret=(ret+c[p])%mod,p-=p&-p; return ret; }\nint main() {\n#ifndef ONLINE_JUDGE\n    freopen(\"arc101f.in\",\"r\",stdin);\n    freopen(\"arc101f.out\",\"w\",stdout);\n#endif\n    cin>>n>>m;\n    for(int i=1;i<=n;i++) x[i]=gi();\n    for(int i=1;i<=m;i++) y[i]=gi();\n    int t=n;n=0;\n    for(int i=1;i<=t;i++) if(x[i]>y[1]&&x[i]<y[m]) x[++n]=x[i];\n    for(int i=1;i<=n;i++) {\n        int p=lower_bound(y+1,y+m+1,x[i])-y;r[i]=y[p]-x[i];\n        --p;l[i]=x[i]-y[p];\n    }\n    t=n,n=0;\n    for(int i=1;i<=t;i++) if(!vis[mp(l[i],r[i])]) vis[mp(l[i],r[i])]=1,x[++n]=x[i],l[n]=l[i],r[n]=r[i];\n    for(int i=1;i<=n;i++) id[i]=i;\n    sort(id+1,id+n+1,cmp);\n    for(int i=1;i<=n;i++) st[++top]=r[i];\n    sort(st+1,st+top+1);top=unique(st+1,st+top+1)-st-1;\n    for(int i=1;i<=n;i++) r[i]=lower_bound(st+1,st+top+1,r[i])-st;\n    int ans=1;\n    for(int i=1,x=id[i];i<=n;i++,x=id[i]) t=(qry(r[x]-1)+1)%mod,ans=(ans+t)%mod,add(r[x],t);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n//orzgzy\n//鸡贼明年进队超稳\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 500010\n#define mo 1000000007\n#define ll long long\nll i,j,k,ans,m,n,x,y,t[N],a[N],b[N],c[N],cnt,f[N];\ninline ll ask(ll x) {\n    ll ans = 0;\n    for (; x; x -= x & -x)(ans += t[x]) %= mo;\n    return ans;\n}\ninline void add(ll x,ll d) {\n    for (; x <= cnt; x += x & -x)(t[x] += d) %= mo;\n}\nstruct dist {\n    ll x, y;\n\n    inline bool operator<(const dist &b) const {\n        if (x == b.x)return y > b.y;\n        return x < b.x;\n    }\n\n    inline bool operator==(const dist &b) const {\n        return x == b.x && y == b.y;\n    }\n}e[N];\nint main() {\n    cin >> n >> m;\n    for (i = 1; i <= n; ++i)cin >> a[i];\n    for (i = 1; i <= m; ++i)cin >> b[i];\n    for (i = j = 1; i < m && j <= n; ++i) {\n        for (; j <= n && a[j] <= b[i]; ++j);\n        if (j > n)break;\n        for (; j <= n && a[j] < b[i + 1]; ++j)e[++cnt] = (dist) {b[i + 1] - a[j], c[++*c] = a[j] - b[i]};\n    }\n    sort(c + 1, c + *c + 1);\n    for (i = 1; i <= cnt; ++i)e[i].y = lower_bound(c + 1, c + *c + 1, e[i].y) - c;\n    sort(e + 1, e + cnt + 1), cnt = unique(e + 1, e + cnt + 1) - e - 1;\n    for (ans = i = 1; i <= cnt; ++i) {\n        f[i] = (ask(e[i].y - 1) + 1) % mo;\n        (ans += f[i]) %= mo, add(e[i].y, f[i]);\n    }\n    cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 100020\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) (x&(-x))\n#define inf 0x3f3f3f3f\ntypedef long long ll;\ntypedef pair<int,int> pr;\n\nconst ll mod = 1e9 + 7;\nstruct node{\n\tint x,y;\n\tbool operator < (node a)const{\n\t\treturn x == a.x ? y > a.y : x < a.x;\n\t}\n}dt[maxn];\nint x[maxn],y[maxn],n,m,tot,a[maxn * 2],cnt;\nll sum[maxn * 2],f[maxn],ans;\n\nvoid init(){\n\trep(i,1,n){\n\t\tint it = lower_bound(y + 1,y + m + 1,x[i]) - y;\n\t\tif ( x[i] == y[it] || it == 1 || it > m ) continue;\n\t\tdt[++tot] = (node){x[i] - y[it - 1],y[it] - x[i]};\n\t\ta[++cnt] = dt[i].x , a[++cnt] = dt[i].y;\n\t}\n\tsort(a + 1,a + cnt + 1);\n\trep(i,1,n){\n\t\tdt[i].x = lower_bound(a + 1,a + cnt + 1,dt[i].x) - a;\n\t\tdt[i].y = lower_bound(a + 1,a + cnt + 1,dt[i].y) - a;\n\t}\n\tsort(dt + 1,dt + tot + 1);\n}\ninline void modify(int x,ll d){\n\tfor (register int i = x ; i <= cnt ; i += lowbit(i)) sum[i] = (sum[i] + d) % mod;\n}\ninline ll query(int x){\n\tll res = 0;\n\tfor (register int i = x ; i ; i -= lowbit(i)) res = res + sum[i];\n\treturn res % mod;\n}\nvoid solve(){\n\tans = 1;\n\trep(i,1,tot){\n\t\tif ( dt[i].x == dt[i - 1].x && dt[i].y == dt[i - 1].y ) continue;\n\t\tf[i] = query(dt[i].y - 1) + 1;\n\t\tmodify(dt[i].y,f[i]);\n\t\tans = (ans + f[i]) % mod;\n\t}\n\tcout<<ans<<endl;\n}\nint main(){\n\tscanf(\"%d %d\",&n,&m);\n\trep(i,1,n) scanf(\"%d\",&x[i]);\n\trep(i,1,m) scanf(\"%d\",&y[i]);\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n#define Maxn 100005\n#define mod 1000000007\npair <int,int> arr[Maxn];\nint seg[Maxn],app[Maxn],a[Maxn],ex[Maxn],cnt,n,m,cur;\nvoid modify(int pos,int x){for (pos++;pos<=cnt;pos+=pos&-pos) seg[pos]=(seg[pos]+x)%mod;}\nint query(int pos){int res=0;for (pos++;pos;pos-=pos&-pos) res=(res+seg[pos])%mod;return res;}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=0;i<n;i++) scanf(\"%d\",a+i);\n\tfor (int i=0;i<m;i++) scanf(\"%d\",ex+i);\n\tfor (int i=0;i<n;i++)\n\t{\n\t\tint pos=upper_bound(ex,ex+m,a[i])-ex-1;\n\t\tif (pos<0) continue;\n\t\tarr[cur].first=a[i]-ex[pos];\n\t\tpos=lower_bound(ex,ex+m,a[i])-ex;\n\t\tif (pos>=m) continue;\n\t\tarr[cur].second=ex[pos]-a[i];\n\t\tapp[cur]=arr[cur].second;\n\t\tcur++;\n\t}\n\tn=cur;\n\tsort(arr,arr+n);\n\tsort(app,app+n+1);\n\tcnt=unique(app,app+n+1)-app;\n\tmodify(0,1);\n\tfor (int i=0,j=0;i<n;i=j)\n\t{\n\t\twhile (j<n && arr[i].first==arr[j].first) j++;\n\t\tfor (int k=j-1;k>=i;k--)\n\t\t{\n\t\t\tarr[k].second=lower_bound(app,app+cnt,arr[k].second)-app;\n\t\t\tif (k+1!=j && arr[k].second==arr[k+1].second) continue;\n\t\t\tmodify(arr[k].second,query(arr[k].second-1));\n\t\t}\n\t}\n\tprintf(\"%d\\n\",query(cnt-1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9;\nconst int N = 650055;\nconst int K = 700 ;\nint x[N], y[N], t[N];\nvector < int > r[N];\nset < int > s1, s2;\nmap < int, int > mx, my;\nvector < pair < int, int > > p;\nint sum (int r)\n{\n\tint result = 0;\n\tfor (; r >= 0; r = (r & (r+1)) - 1)\n\t\tresult = (result + t[r]) % mod;\n\treturn result;\n}\n\nvoid inc (int i, int delta)\n{\n\tfor (; i < N; i = (i | (i+1)))\n\t\tt[i] = (t[i] + delta) % mod;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) cin >> x[i];\n    for (int j = 1; j <= m; j++) cin >> y[j];\n    int c = 1;\n    for (int j = 1; j < m; j++){\n        while(x[c] < y[j]) c++;\n        while(x[c] < y[j + 1] && c <= n){\n            p.pb({x[c] - y[j], y[j + 1] - x[c]});\n            c++;\n        }\n    }\n    for (auto i: p){\n        s1.insert(i.F);\n        s2.insert(i.S);\n    }\n    int cnt1, cnt2;\n    cnt1 = 0;\n    cnt2 = 0;\n    for (auto i: s1){\n        cnt1++;\n        mx[i] = cnt1;\n    }\n    for (auto i: s2){\n        cnt2++;\n        my[i] = cnt2;\n    }\n    for (int i = 0; i < p.size(); i++){\n        p[i].F = mx[p[i].F];\n        p[i].S = my[p[i].S];\n        r[p[i].S].pb(p[i].F);\n    }\n    inc(0, 1);\n    for (int i = 1; i <= cnt2; i++){\n        sort(r[i].begin(), r[i].end());\n        r[i].erase(unique(r[i].begin(), r[i].end()), r[i].end());\n        reverse(r[i].begin(), r[i].end());\n        for (auto j: r[i]){\n            inc(j, sum(j - 1));\n        }\n    }\n    cout << sum(cnt1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n#define mod 1000000007\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nstd::mt19937 rnd(time(NULL));\n#define rand rnd\n#define pr std::pair<int,int>\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\ntemplate<class T>void cxk(T&a,T b){a=a>b?a:b;}\ntemplate<class T>void cnk(T&a,T b){a=a<b?a:b;}\n#ifdef mod\nint pow(int x,int y){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\ntemplate<class Ta,class Tb>void inc(Ta&a,Tb b){a=a+b>=mod?a+b-mod:a+b;}\ntemplate<class Ta,class Tb>void dec(Ta&a,Tb b){a=a>=b?a-b:a+mod-b;}\n#endif\nint dl[100010],dr[100010],px[100010],py[100010];\nstd::pair<int,int>s[100010];\nint f[100010],udr[100010],t[100010];\nvoid update(int x,int d){while(x<=*udr)inc(t[x],d),x+=x&-x;}\nint query(int x){int r=0;while(x)inc(r,t[x]),x-=x&-x;return r;}\nint main(){\n#ifdef LOCAL\n\tfreopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi(),m=gi();\n\tfor(int i=1;i<=n;++i)px[i]=gi();\n\tfor(int i=1;i<=m;++i)py[i]=gi();\n\tint l=1,r=n;\n\twhile(l<=n&&px[l]<py[1])++l;\n\twhile(r&&px[r]>py[m])--r;\n\tif(l>r)puts(\"1\"),exit(0);\n\tfor(int i=l;i<=r;++i)px[i-l+1]=px[i];\n\tn=r-l+1;\n\tfor(int i=1,j=1;i<=n;++i){\n\t\twhile(py[j]<px[i])++j;\n\t\tdr[i]=py[j]-px[i];\n\t}\n\tfor(int i=n,j=m;i;--i){\n\t\twhile(py[j]>px[i])--j;\n\t\tdl[i]=px[i]-py[j];\n\t}\n\tfor(int i=1;i<=n;++i)s[i]={dl[i],dr[i]},udr[i]=dr[i];\n\tstd::sort(udr+1,udr+n+1),*udr=std::unique(udr+1,udr+n+1)-udr-1;\n\tfor(int i=1;i<=n;++i)s[i].se=std::lower_bound(udr+1,udr+*udr+1,s[i].se)-udr;\n\tstd::sort(s+1,s+n+1);n=std::unique(s+1,s+n+1)-s-1;\n\tfor(int l=1,r;l<=n;l=r+1){\n\t\tr=l;while(r<n&&s[r+1].fi==s[r].fi)++r;\n\t\tfor(int i=r;i>=l;--i)update(s[i].se,1+query(s[i].se-1));\n\t}\n\tprintf(\"%d\\n\",(query(*udr)+1)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\nint n, m, x[100007], y[100007], ss[100007], t[100007], dp[100007], tot, cnt, res = 1;\npair<int, int>p[100007];\nint read()\n{\n\tint num = 0;\n\tchar c = getchar();\n\twhile (c < '0' || c>'9')c = getchar();\n\twhile (c >= '0' && c <= '9')num = num * 10 + c - '0', c = getchar();\n\treturn num;\n}\nint cmp(pair<int, int>a, pair<int, int>b)\n{\n\tif (a.first == b.first)return a.second > b.second;\n\telse return a.first < b.first;\n}\nint add(int x, int v)\n{\n\twhile (x <= tot)t[x] = (t[x] + v + mod) % mod, x += x & -x;\n\treturn 0;\n}\nint ask(int x)\n{\n\tint res = 0;\n\twhile (x)res = (res + t[x]) % mod, x -= x & -x;\n\treturn res;\n}\nint main()\n{\n\tn = read();\n\tm = read();\n\tfor (int i = 1; i <= n; i++)\n\t\tx[i] = read();\n\tfor (int i = 1; i <= m; i++)\n\t\ty[i] = read();\n\tsort(x + 1, x + n + 1);\n\tsort(y + 1, y + m + 1);\n\tfor(int i=1;i<=n;i++)\n\t\tif (x[i] > y[1] && x[i] < y[m])\n\t\t{\n\t\t\tint pos = lower_bound(y + 1, y + m + 1, x[i]) - y;\n\t\t\tif (x[i] == y[pos])continue;\n\t\t\tp[++cnt] = make_pair(x[i] - y[pos - 1], y[pos] - x[i]);\n\t\t}\n\tsort(p + 1, p + cnt + 1, cmp);\n\tcnt = unique(p + 1, p + cnt + 1) - p - 1;\n\tfor (int i = 1; i <= cnt; i++)\n\t\tss[++tot] = p[i].second;\n\tsort(ss + 1, ss + tot + 1);\n\ttot = unique(ss + 1, ss + tot + 1) - ss - 1;\n\tfor (int i = 1; i <= cnt; i++)\n\t{\n\t\tint pos = lower_bound(ss + 1, ss + tot + 1, p[i].second) - ss;\n\t\tdp[i] = (ask(pos - 1) + 1) % mod;\n\t\tadd(pos, dp[i]);\n\t}\n\tfor (int i = 1; i <= cnt; i++)\n\t\tres = (res + dp[i]) % mod;\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<bitset>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<chrono>\n#include<stack>\n#include<fstream>\n#include<list>\n#include<math.h>\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define SIZE(a) ll(a.size())\n#define vll vector<ll> \n#define MEMSET(a, n, m) for(ll i=0;i<=n;i++) a[i] = m\n#define BIT(n) (ll(1)<<n)\n#define UNIQUE(v) v.erase(unique(v.begin(),v.end()),v.end()) \n#define UNIQUE_ARRAY(a,x) unique(a + 1, a + x + 1) - a - 1\n#define SORT(a,n) sort(a+1,a+n+1)\n#define SORT_O(a,n,order) sort(a+1,a+n+1,order)\n#define PER(i,y,x) for(ll i=y;i>=x;i--)\ntypedef long long ll;\nusing namespace std;\ndouble const PI = 3.1415926535;\n\nstruct edge\n{\n\tlong long to; long long cost;\n\tbool operator<(const edge& rhs) const {\n\t\treturn cost > rhs.cost;\n\t}\n};\n\nll const MAX = 400005; //4倍に取っておく\nll segtree[MAX];\nll const MOD = 1e9 + 7;\nll mod_p(ll x, ll y) {\n\treturn (x + y + MOD) % MOD;\n}\nll mod_m(ll x, ll y) {\n\treturn x * y%MOD;\n}\n\n//演算\nll op(ll x, ll y) {\n\treturn mod_p(x, y);\n}\n//init valueの変更を忘れない\nll const INIT_VALUE = 0;\nll n_ = 1;\n\nvoid init(ll n) {\n\twhile (n_ <= n) {\n\t\tn_ *= 2;\n\t}\n\tREP(i, 1, n_ * 2) {\n\t\tsegtree[i] = INIT_VALUE;\n\t}\n}\n\n//k番目をxでupdate\nvoid update(ll k, ll x) {\n\tk += n_;\n\tsegtree[k] = mod_p(segtree[k], x);\n\twhile (k >= 1) {\n\t\tk /= 2;\n\t\tsegtree[k] = op(segtree[k * 2], segtree[k * 2 + 1]);\n\t}\n}\n\nll val_o(ll a, ll b, ll k, ll l, ll r) {\n\tif (a <= l && r <= b) {\n\t\treturn segtree[k];\n\t}\n\telse if (r <= a || b <= l) {\n\t\t//ここの値注意\n\t\treturn 0;\n\t}\n\telse {\n\t\tll x1 = val_o(a, b, k * 2, l, (l + r) / 2);\n\t\tll x2 = val_o(a, b, k * 2 + 1, (l + r) / 2, r);\n\t\treturn op(x1, x2);\n\t}\n\n}\n\n//[a,b)のvalueを求める\nll val(ll a, ll b) {\n\treturn val_o(a, b, 1, 0, n_);\n}\n\n\n\nll n;\nll a[MAX];\nll b[MAX];\nvll l;\nvll r;\nll g[MAX];\n\nbool ord(ll x, ll y) {\n\tif (l[x] != l[y]) {\n\t\treturn l[x] < l[y];\n\t}\n\telse {\n\t\treturn r[x] > r[y];\n\t}\n}\nll t[MAX];\n\nll f() {\n\tll ans = 0;\n\tREP(i, 1, n) {\n\t\tif (i > 1 && g[i - 1] == g[i] && t[i - 1] == t[i - 1]) {\n\t\t\tcontinue;\n\t\t}\n\t\tll x = val(0, g[i]);\n\t\tans = mod_p(ans, x + 1);\n\t\tupdate(g[i], x + 1);\n\t}\n\t\n\treturn mod_p(ans,1);\n}\n\nll compression[MAX];\nvoid compress(ll u[MAX], ll n) {\n\tmap<ll, ll> mp;\n\tREP(i, 1, n) {\n\t\tcompression[i] = u[i];\n\t}\n\tsort(compression + 1, compression + 1 + n);\n\tll x = UNIQUE_ARRAY(compression, n);\n\tREP(i, 1, x) {\n\t\tmp[compression[i]] = i;\n\t}\n\tREP(i, 1, n) {\n\t\tu[i] = mp[u[i]];\n\t}\n}\n\nint main() {\n\tll m;\n\tcin >> n >> m;\n\tREP(i, 1, n) {\n\t\tcin >> a[i];\n\t}\n\tREP(i, 1, m) {\n\t\tcin >> b[i];\n\t}\n\tREP(i, 1, n) {\n\t\tll x = lower_bound(b + 1, b + m + 1, a[i]) - b;\n\t\tif (x == 1 || x == m + 1) {\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tl.push_back(a[i] - b[x - 1]);\n\t\t\tr.push_back(b[x] - a[i]);\n\t\t}\n\t}\n\tn = l.size();\n\tREP(i, 1, n) {\n\t\tg[i] = i-1;\n\t}\n\tSORT_O(g, n, ord);\n\tREP(i, 1, n) {\n\t\tt[i] = l[g[i]];\n\t\tg[i] = r[g[i]];\n\t}\n\tcompress(t, n); compress(g, n);\n\tinit(n);\n\tll ans = f();\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<set>\nusing namespace std;\nconst int N=100005,mod=1000000007;\nint n,m,k,ans=1,pos[N],a[N],b[N],c[N],x[N],y[N],h[N],f[N];\nset<int> s;\nbool cmp(int a,int b){\n\treturn x[a]==x[b]?y[a]>y[b]:x[a]<x[b];\n}\nbool comp(int a,int b){\n\treturn x[a]==x[b]&&y[a]==y[b];\n}\nvoid add(int i,int v){\n\twhile(i<=h[0]){\n\t\tc[i]=(c[i]+v)%mod;\n\t\ti+=i&(-i);\n\t}\n}\nint sum(int i){\n\tint res=0;\n\twhile(i){\n\t\tres=(res+c[i])%mod;\n\t\ti-=i&(-i);\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d\",&b[i]);\n\t\ts.insert(b[i]);\n\t}\n\tset<int>::iterator it;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]>b[1]&&a[i]<b[m]&&!s.count(a[i])){\n\t\t\tit=s.upper_bound(a[i]);\n\t\t\tk++;\n\t\t\tpos[k]=k;\n\t\t\ty[k]=*it-a[i];\n\t\t\tit--;\n\t\t\tx[k]=a[i]-*it;\n\t\t\th[++h[0]]=y[i];\n\t\t}\n\t}\n\tsort(pos+1,pos+k+1,cmp);\n\tk=unique(pos+1,pos+k+1,comp)-pos-1;\n\tsort(h+1,h+h[0]+1);\n\th[0]=unique(h+1,h+h[0]+1)-h-1;\n\tfor(int i,j=1;j<=k;j++){\n\t\ti=pos[j];\n\t\ty[i]=lower_bound(h+1,h+h[0]+1,y[i])-h;\n\t\tf[i]=(sum(y[i]-1)+1)%mod;\n\t\tans=(ans+f[i])%mod;\n\t\tadd(y[i],f[i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cassert>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n#define Whats(x) cout<<#x<<\" is \"<<(x)<<endl\n#define Divhim() cout<<\">>>>>>>>>>>>>>>\"<<endl\n#define Divher() cout<<\"<<<<<<<<<<<<<<<\"<<endl\n#define Oops() cout<<\"!!!!!!!!!!!!!!!\"<<endl\n\ntemplate<typename T> bool GetMin(T &a,T b)\n{\n\treturn ((a<=b)?false:(a=b,true));\n}\n\ntemplate<typename T> bool GetMax(T &a,T b)\n{\n\treturn ((a>=b)?false:(a=b,true));\n}\n\n/*\n\t -<Unlimited Blade Works>-\n */\n\n#define Pir pair<int,int>\n#define fir first\n#define sec second\n\nconst int N=5e5;\nconst int MOD=1e9+7;\n\nvoid SU(int &x,int y)\n{\n\t((x+=y)>=MOD)?(x-=MOD):0;\n}\n\nint n,m,ax[N],ay[N];\nPir p[N];int tot;\n\nint ls[N],ed;\n\nint C[N];\n\nvoid Add(int x,int y)\n{\n\tfor(;x<=ed;x+=x&(-x))\n\t\tSU(C[x],y);\n}\n\nint Query(int x)\n{\n\tint res=0;\n\tfor(;x;x&=x-1)\n\t\tSU(res,C[x]);\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d\",ax+i);\n\tfor(int i=1;i<=m;++i)\n\t\tscanf(\"%d\",ay+i);\n\tfor(int i=1,id;i<=n;++i)\n\t{\n\t\tif(ax[i]<=ay[1]||ax[i]>=ay[m])\n\t\t\tcontinue;\n\t\tid=lower_bound(ay+1,ay+m+1,ax[i])-ay;\n\t\tif(ay[id]==ax[i])\n\t\t\tcontinue;\n\t\tp[++tot]=Pir(ax[i]-ay[id-1],ay[id]-ax[i]);\n\t}\n\tsort(p+1,p+tot+1);\n\ttot=unique(p+1,p+tot+1)-p-1;\n\tfor(int i=1;i<=tot;++i)\n\t{\n\t\tls[++ed]=p[i].fir;\n\t\tls[++ed]=p[i].sec;\n\t}\n\tsort(ls+1,ls+ed+1);\n\ted=unique(ls+1,ls+ed+1)-ls-1;\n\tfor(int i=1;i<=tot;++i)\n\t{\n\t\tp[i].fir=lower_bound(ls+1,ls+ed+1,p[i].fir)-ls;\n\t\tp[i].sec=lower_bound(ls+1,ls+ed+1,p[i].sec)-ls;\n\t}\n\tsort(p+1,p+tot+1,\n\t\t\t[](auto a,auto b)\n\t\t\t{\n\t\t\t\treturn a.fir!=b.fir?a.fir<b.fir:a.sec>b.sec;\n\t\t\t});\n\t//for(int i=1;i<=tot;++i)\n\t//\tcout<<p[i].fir<<\",\"<<p[i].sec<<endl;\n\tint ans=1;\n\tfor(int i=1,t;i<=tot;++i)\n\t{\n\t\tt=1;\n\t\tSU(t,Query(p[i].sec-1));\n\t\tSU(ans,t);\n\t\tAdd(p[i].sec,t);\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*\ncout<<setprecision(20);\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\tint i,n,m;cin>>n>>m;\n\tvector<int>x(n);\n\tvector<int>y(m);\n\tfor(i=0;i<n;i++){cin>>x[i];}\n\tfor(i=0;i<m;i++){cin>>y[i];}\n\tvector<int>L;L.reserve(n);\n\tvector<int>R;R.reserve(n);\n\tfor(i=0;i<n;i++){\n\t\tint ter=LBI(y,x[i]);\n\t\tif(ter==0||ter==m){continue;}\n\t\tL.pub(x[i]-y[LBI(y,x[i])-1]);\n\t\tR.pub(y[LBI(y,x[i])]-x[i]);\n\t}\n\tn=L.size();\n\tvector<int>sL=L;\n\tSO(sL);\n\tvector<pair<int,int>>dis(n);\n\tfor(i=0;i<n;i++){dis[i]=mp(R[i],-LBI(sL,L[i]));}//Lを座圧した\n\tSO(dis);\n\tdis.erase(unique(dis.begin(),dis.end()),dis.end());\n\tn=dis.size();\n\tstatic llint seg[262144]={0};\n\tfor(i=0;i<n;i++){\n\t\tint bas=131072-dis[i].sec;\n\t\tllint gen=1;//自分の分\n\t\twhile(bas>1){if(bas%2==1){gen+=seg[bas-1];}bas/=2;}\n\t\tgen%=mod;\n\t\tbas=131072-dis[i].sec;\n\t\twhile(bas>1){seg[bas]+=gen;seg[bas]%=mod;bas/=2;}\n\t}\n\tint bas=262000;\n\tllint ans=1;\n\twhile(bas>1){if(bas%2==1){ans+=seg[bas-1];}bas/=2;}\n\tans%=mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define int long long\nusing namespace std;\nstruct node\n{\n\tint x,y,newy;\n\tbool operator < (const node &a)const\n\t{\n\t\tif (x!=a.x)\n\t\t\treturn x<a.x;\n\t\telse\n\t\t\treturn newy>a.newy;\n\t}\n};\nnode QQmove[10000001];\nint mod=1000000007;\nint f[10000001],c[10000001],a[10000001],b[1000001],ans,res,len,n,m,useless;\nbool cmp(node u,node v)\n{\n\treturn u.y<v.y;\n}\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\nvoid add(int x,int d)\n{\n\tfor (;x<=n;x+=lowbit(x))\n\t\tc[x]+=d;\n\treturn;\n}\nint sum(int x)\n{\n\tans=0;\n\tfor (;x>=1;x-=lowbit(x))\n\t\tans+=c[x];\n\treturn ans;\n}\nsigned main()\n{\n\tint first,last,mid,front,back;\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;++i)\n\t\tcin>>a[i];\n\tfor (int i=1;i<=m;++i)\n\t\tcin>>b[i];\n\tsort(a+1,a+n+1);\n\tsort(b+1,b+n+1);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tfirst=1;\n\t\tlast=m;\n\t\tfront=0;\n\t\tback=m+1;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]>=b[mid])\n\t\t\t{\n\t\t\t\tfront=max(front,mid);\n\t\t\t\tfirst=mid+1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tlast=mid-1;\n\t\t}\n\t\tfirst=1;\n\t\tlast=m;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]<=b[mid])\n\t\t\t{\n\t\t\t\tback=min(back,mid);\n\t\t\t\tlast=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tfirst=mid+1;\n\t\t}\n\t\tif (front==0||back==m+1||b[front]==a[i]||b[back]==a[i])\n\t\t\tcontinue;\n\t\tQQmove[++len].x=a[i]-b[front];\n\t\tQQmove[len].y=b[back]-a[i];\n\t}\n\tsort(QQmove+1,QQmove+len+1,cmp);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tQQmove[i].newy=i-useless;\n\t\tif (QQmove[i].y==QQmove[i+1].y)\n\t\t\tuseless++;\n\t}\n\tuseless=0;\n\tsort(QQmove+1,QQmove+len+1);\n\tfor (int i=1;i<=len-1;++i)\n\t\tif (QQmove[i].newy==QQmove[i+1].newy&&QQmove[i].x==QQmove[i+1].x)\n\t\t{\n\t\t\tQQmove[i].x=1e+9;\n\t\t\tQQmove[i].newy=1e+9;\n\t\t}\n\tsort(QQmove+1,QQmove+len+1);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tif (QQmove[i].x==1e+9)\n\t\t\tbreak;\n\t\tf[i]=sum(QQmove[i].newy-1)+1;\n\t\tf[i]%=mod; \n\t\tadd(QQmove[i].newy,f[i]);\n\t}\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tres+=f[i];\n\t\tres%=mod;\n\t}\n\tcout<<(res+1)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<cstdio>\n#define pii pair<int,int>\n#define ll long long\n#define lowbit(x) x&-x\nusing namespace std;\nconst int N=100000+7;\nconst ll mod=1000000000+7;\nint n,m,rb[N],ho[N],maxn;\nll c[100000000];\npair<int,int> p[N];\nint tmp[N],t1,t2;\nvoid read(){\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&rb[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&ho[i]);\n}\nbool rule(pii a,pii b){\n\tif(a.first!=b.first)return a.first<b.first;\n\telse return a.second>b.second;\n}\nvoid add(int x,ll v){\n\tfor(int i=x;i<=maxn;i+=lowbit(i)){\n\t\tc[i]=(c[i]+v)%mod;\n\t}\n}\nll query(int x){\n\tll sum=0;\n\tfor(int i=x;i;i-=lowbit(i))\n\t\tsum=(sum+c[i])%mod;\n\treturn sum;\n}\nvoid init(){\n\tint lst,nxt=ho[1],top=1;\n\tint i=1;\n\twhile(rb[i]<=ho[1])i++;\n\tfor(;i<=n;i++){\n\t\twhile(rb[i]>nxt){\n\t\t\tlst=nxt;\n\t\t\tnxt=ho[++top];\n\t\t\tif(top>m)break;\n\t\t}\n\t\tint ld=rb[i]-lst,rd=nxt-rb[i];\n\t\tp[++t1]=make_pair(ld,rd);\n\t\ttmp[++t2]=rd;\n\t}\n\t\n\t/*for(int i=1;i<=t1;i++)\n\t\tprintf(\"%d %d\\n\",p[i].first,p[i].second);\n\tprintf(\"\\n\");*/\n\t\t\n\tsort(tmp+1,tmp+1+t2);\n\tmaxn=tmp[t2];\n\tt2=unique(tmp+1,tmp+1+t2)-(tmp+1);\n\tfor(int i=1;i<=t1;i++)\n\t\tp[i].second=lower_bound(tmp+1,tmp+1+t2,p[i].second)-tmp;\n\tsort(p+1,p+1+t1,rule);\n\tt1=unique(p+1,p+1+t1)-(p+1);\n\t\n\t/*for(int i=1;i<=t1;i++)\n\t\tprintf(\"%d %d\\n\",p[i].first,p[i].second);*/\n\t\t\n}\nvoid work(){\n\tll ans=1;\n\tfor(int i=1;i<=t1;i++){\n\t\tll s=query(p[i].second-1)+1;\n\t\tans=(ans+s)%mod;\n\t\tadd(p[i].second,s);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\nint main(){\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread();\n\tinit();\n\twork();\n\treturn 0;\n}\n/*\n4 1\n1 2 4 5\n3\n\n*/\n/*\n4 5\n2 5 7 11\n1 3 6 9 13\n\n*/\n/*\n3 4\n2 5 10\n1 3 7 13\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\n#include<algorithm>\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\tfor (; ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') f = -1;\n\tfor (; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) + ch - '0';\n\treturn x * f;\n}\n\nconst int N = 1e5 + 5;\nconst int P = 1e9 + 7;\n\nint x[N], y[N], b[N], n, m, tot;\npair<int, int> a[N];\n\nint seg[N];\n\nvoid add(int x, int t)\n{\n\tfor (; x <= tot; x += x & -x)\n\t\t(seg[x] += t) %= P;\n}\n\nint query(int x)\n{\n\tint res = 0;\n\tfor (; x; x -= x & -x)\n\t\t(res += seg[x]) %= P;\n\treturn res;\n}\n\nint main()\n{\n\tn = read();\n\tm = read();\n\t\n\tfor (int i = 1; i <= n; ++i) x[i] = read();\n\tfor (int i = 1; i <= m; ++i) y[i] = read();\n\t\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tint nxt = upper_bound(y + 1, y + m + 1, x[i]) - y;\n\t\tint pre = nxt - 1;\n\t\t\n\t\tif (pre <= 0 || nxt > m) continue;\n\n\t\tnxt = y[nxt] - x[i];\n\t\tpre = x[i] - y[pre];\n\t\t\n\t\ta[++tot] = make_pair(pre, nxt);\n\t\tb[tot] = nxt;\n\t}\n\t\n\tn = tot;\n\t\n\tsort(a + 1, a + n + 1);\n\tsort(b + 1, b + n + 1);\n\ttot = unique(b + 1, b + n + 1) - b;\n\t\n\tadd(1, 1);\n\t\n\tfor (int i = 1, j = 1; i <= n; i = j)\n\t{\n\t\twhile (j <= n && a[i].first == a[j].first) ++j;\n\t\t\n\t\tfor (int k = j - 1; k >= i; --k)\n\t\t{\n\t\t\ta[k].second = lower_bound(b + 1, b + tot, a[k].second) - b;\n\t\t\tif (k < j - 1 && a[k].second == a[k + 1].second) continue;\n\t\t\tadd(a[k].second + 1, query(a[k].second));\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", query(tot));\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#include <bits/stdc++.h>\n#define res register ll\n#define lowbit(x) (x&(-x))\n#define N 200005\n#define inf 0x3f3f3f3f\n#define mod 1000000007\n#define ll long long\nusing namespace std;\nll n,m,cnt,a[N],b[N],lisan[N],f[N],ans=1,sum,tot;\ninline ll read(){\n\tres w=0,X=0;register char ch=0;\n\twhile(!isdigit(ch)){w|=ch=='-';ch=getchar();}\n\twhile(isdigit(ch)){X=(X<<1)+(X<<3)+(ch^48);ch=getchar();}\n\treturn w?-X:X;\n}\nnamespace T{\n\tll tr[N];\n\tinline void add(res x,res v){\n\t\tfor(;x<=cnt;x+=lowbit(x))\n\t\t  (tr[x]+=v)%=mod;\n\t}\n\tinline ll ask(res x){\n\t\tres total=0;\n\t\tfor(;x;x-=lowbit(x))\n\t\t  (total+=tr[x])%=mod;\n\t\treturn total;\n\t}\n}\nstruct papa{\n\tll x,y;\n\tinline bool operator<(const papa&b) const{\n\t\treturn (x==b.x&&y>b.y)||x<b.x;\n\t}\n}p[N];\nint main(){\n\tn=read(),m=read();\n\tfor(res i=1;i<=n;i++)\n\t  a[i]=read();\n\tfor(res i=1;i<=m;i++)\n\t  b[i]=read();\n\tfor(res i=1,j=1;i<=n;i++){\n\t\tfor(;j<=m;j++)\n\t\t  if(b[j]>a[i])\n\t\t    break;\n\t\tif(j==m+1||j==1|| b[j] == a[i]) continue;\n\t\tp[++tot].x=b[j]-a[i];\n\t\tp[tot].y=a[i]-b[j-1];\n    }\n\tsort(p+1,p+tot+1);\n\tfor(res i=1;i<=tot;i++)\n\t  lisan[i]=p[i].y;\n\tsort(lisan+1,lisan+tot+1);\n\tcnt=unique(lisan+1,lisan+n+1)-lisan;\n\tfor(res i=1;i<=tot;i++)\n\t  p[i].y=lower_bound(lisan+1,lisan+cnt+1,p[i].y)-lisan;\n\tfor(res i=1;i<=tot;i++){\n\t\tif(p[i].x==p[i-1].x&&p[i].y==p[i-1].y) continue;\n\t\tsum=(T::ask(p[i].y-1)+1)%mod;\n\t\tans=(ans+sum)%mod;                     \n\t\tT::add(p[i].y,sum);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\n\nint n, m;\nint x[100001];\nint y[100000];\n\nvector<int> cp;\nint find(int x) {\n    return lower_bound(cp.begin(), cp.end(), x) - cp.begin();\n}\n\nconst int mod = 1e9 + 7;\nint seg[100001];\nvoid update(int i, int x) {\n    while (i <= cp.size()) {\n        seg[i] = (seg[i] + x) % mod;\n        i += i & -i;\n    }\n}\n\nint query(int i) {\n    int ret = 0;\n    while (i) {\n        ret = (ret + seg[i]) % mod;\n        i -= i & -i;\n    }\n    return ret;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i) cin >> x[i];\n\tfor (int i = 0; i < m; ++i) cin >> y[i];\n\tvector<pii> xs;\n\t\n\tfor (int i = 1; i <= n; ++i) {\n        if (x[i] < y[0]) continue;\n        if (y[m - 1] < x[i]) continue;\n        int v = lower_bound(y, y + m, x[i]) - y;\n        xs.emplace_back(y[v] - x[i], x[i] - y[v - 1]);\n        cp.push_back(x[i] - y[v - 1]);\n\t}\n\tcp.push_back(0);\n\tsort(cp.begin(), cp.end());\n\tcp.erase(unique(cp.begin(), cp.end()), cp.end());\n\tfor (pii &i : xs) i.second = -find(i.second);\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\t\n\tupdate(1, 1);\n\tfor (pii _i : xs) {\n        int i = 1 - _i.second;\n        update(i, query(i - 1));\n\t}\n\tprintf(\"%d\\n\", query(cp.size()));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int Mod=1000000007;\nint n,m;\n#define Maxn 100010\n#define V 4000010\nint f[Maxn];\nint x[Maxn],y[Maxn];\nstruct P{\n\tint x,y;\n\tbool operator <(const P &z)const{return x!=z.x?x<z.x:y>z.y;;}\n\tbool operator ==(const P &z)const{return x==z.x&&y==z.y;}\n}p[Maxn];int len=0;\nstruct Node{\n\tint sumv;\n\tint ls,rs;\n}tree[V];\nint root,cnt=0;\nvoid insert(int &k,int l,int r,int pos,int x){\n\tif(!k)k=++cnt;\n\ttree[k].sumv+=x;\n\tif(tree[k].sumv>=Mod)tree[k].sumv-=Mod;\n\tif(l==r)return;\n\tint mid=(l+r)>>1;\n\tif(pos<=mid)insert(tree[k].ls,l,mid,pos,x);\n\telse insert(tree[k].rs,mid+1,r,pos,x);\n}\nint Query(int k,int l,int r,int L,int R){\n\tif(l==L&&r==R)return tree[k].sumv;\n\tint mid=(l+r)>>1;\n\tif(R<=mid)return Query(tree[k].ls,l,mid,L,R);\n\telse if(mid<L)return Query(tree[k].rs,mid+1,r,L,R);\n\telse{\n\t\tint ans=Query(tree[k].ls,l,mid,L,mid)+Query(tree[k].rs,mid+1,r,mid+1,R);\n\t\tif(ans>=Mod)ans-=Mod;\n\t\treturn ans;\n\t}\n}\n\ninline void rd(int &x){\n\tx=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9')ch=getchar();\n\twhile(ch>='0'&&ch<='9'){\n\t\tx=x*10+ch-'0';\n\t\tch=getchar();\n\t}\n}\n\nint main(){\n\trd(n);rd(m);\n\tfor(register int i=1;i<=n;++i)rd(x[i]);\n\tfor(register int i=1;i<=m;++i)rd(y[i]);\n\tfor(register int i=1;i<=n;++i)\n\tif(x[i]>y[1]&&x[i]<y[m]){\n\t\tint at=lower_bound(y+1,y+m+1,x[i])-y;\n\t\tif(y[at]==x[i])continue;\n\t\tlen++;\n\t\tp[len]=(P){x[i]-y[at-1],y[at]-x[i]};\n\t}\n\tsort(p+1,p+len+1);\n\tlen=unique(p+1,p+len+1)-p-1;\n\tint Ans=0;\n\tfor(register int i=1,nex;i<=len;i=nex+1){\n\t\tnex=i;\n\t\twhile(nex<len&&p[nex+1].x==p[i].x)nex++;\n\t\tfor(register int j=i;j<=nex;++j){\n\t\t\tf[j]=Query(root,0,1e9,0,p[j].y-1)+1;\n\t\t\tif(f[j]>=Mod)f[j]-=Mod;\n\t\t\tAns=Ans+f[j];\n\t\t\tif(Ans>=Mod)Ans-=Mod;\n\t\t\tinsert(root,0,1e9,p[j].y,f[j]);\n\t\t}\n\t}\n    printf(\"%d\\n\",(Ans+1)%Mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long LL;\n#define int long long\nconst int N = 4e5+10 , mod = 1e9+7;\ninline int read()\n{\n\tregister int x = 0 , f = 0; register char c = getchar();\n\twhile(c < '0' || c > '9') f |= c == '-' , c = getchar();\n\twhile(c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0' , c = getchar();\n\treturn f ? -x : x;\n}\nint n , m , tot;\nint a[N] , b[N] , tmp[N << 1] , dp[N] , tr[N];\nstruct node{ int x , y; }s[N];\ninline void add(int pos , int val) { if(pos <= 0) return ; while(pos <= tot) (tr[pos] += val) %= mod , pos += (pos & (-pos));  }\ninline int ask(int pos) { if(pos <= 0) return 0; int ans = 0; while(pos) (ans += tr[pos]) %= mod , pos -= (pos & (-pos)); return ans; }\ninline bool cmp(const node &A , const node &B) { return A.x == B.x ? A.y > B.y : A.x < B.x; }\n\nsigned main()\n{\n\tn = read(); m = read();\n\tfor(int i = 1 ; i <= n ; ++i) a[i] = read();\n\tfor(int i = 1 ; i <= m ; ++i) b[i] = read();\n\tint j = 1; tot = 0;\n\tfor(int i = 1 ; i <= n ; ++i)\n\t{\n\t\tif(j == 1 && a[i] <= b[j]) continue;\n\t\twhile(j < m && a[i] >= b[j + 1]) j++;\n\t\tif(j == m) break; ++tot;\n\t\ts[tot].x = a[i] - b[j] , s[tot].y = b[j+1] - a[i];\n\t\ttmp[tot * 2 - 1] = s[i].x; tmp[tot * 2] = s[i].y;\n\t}\n\tsort(tmp + 1 , tmp + 1 + tot * 2);\n\tint ct = unique(tmp + 1 , tmp + 1 + tot * 2) - tmp - 1;\n\tfor(int i = 1 ; i <= tot ; ++i)\n\t{\n\t\ts[i].x = lower_bound(tmp + 1 , tmp + 1 + ct , s[i].x) - tmp;\n\t\ts[i].y = lower_bound(tmp + 1 , tmp + 1 + ct , s[i].y) - tmp;\n\t}\n\tsort(s + 1 , s + 1 + tot , cmp);\n\tfor(int i = 1 ; i <= tot ; ++i) if((i == 1) || (s[i].x != s[i-1].x || s[i].y != s[i-1].y))\n\t{\n\t\tdp[i] = (ask(s[i].y - 1) + 1) % mod;\n\t\tadd(s[i].y , dp[i]);\n\t}\n\tint ans = 1;\n\tfor(int i = 1 ; i <= tot ; ++i) (ans += dp[i]) %= mod;\n\tcout << ans << '\\n';\n\treturn 0;\n}\n// https://www.cnblogs.com/812-xiao-wen/p/11299126.html"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#define int long long\nusing namespace std;\nconst int N = 1e5 + 5;\nconst int mod = 1e9 + 7;\nint n, m, cnt, tr[N], f[N], a[N], b[N], S[N], top, tot, ans;\npair<int, int> p[N];\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nbool cmp(pair<int, int> a, pair<int, int> b) {return a.first == b.first ? a.second > b.second : a.first < b.first;}\nint lowbit(int x) {return x & (- x);}\nvoid add(int x, int y) {while(x <= cnt) tr[x] = (tr[x] + y) % mod, x += lowbit(x);}\nint query(int x) {int res = 0; while(x) res = (res + tr[x]) % mod, x -= lowbit(x); return res;}\nsigned main()\n{\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tn = read(); m = read();\n\tfor(int i = 1; i <= n; i ++) a[i] = read();\n\tfor(int i = 1; i <= m; i ++) b[i] = read();\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tif(a[i] <= b[1] || a[i] >= b[m]) continue;\n\t\tint x = lower_bound(b + 1, b + m + 1, a[i]) - b;\n\t\tp[++ cnt] = make_pair(a[i] - b[x - 1], b[x] - a[i]);\n\t\tS[++ top] = b[x] - a[i];\n\t}\n\tsort(S + 1, S + top + 1); tot = unique(S + 1, S + top + 1) - S - 1;\n\tfor(int i = 1; i <= cnt; i ++) p[i].second = lower_bound(S + 1, S + tot + 1, p[i].second) - S;\n\tsort(p + 1, p + cnt + 1, cmp); cnt = unique(p + 1, p + cnt + 1) - p - 1;\n\tf[0] = 1;\n\tfor(int i = 1; i <= cnt; i ++) f[i] = query(p[i].second - 1) + 1, add(p[i].second, f[i]);\n\tfor(int i = 0; i <= cnt; i ++) ans = (ans + f[i]) % mod;\n\tprintf(\"%lld\\n\", ans);\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\n#define MAX_N 100000\n#define P 1000000007\nusing namespace std;\ntypedef long long lnt;\ntypedef pair<int,int> pnt;\ntemplate <class T> inline void read(T &x) {\n\tx = 0; int c = getchar(), f = 1;\n\tfor (; !isdigit(c); c = getchar()) if (c == 45) f = -1;\n\tfor (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');\n}\nint N, M, n, m, a[MAX_N+5], b[MAX_N+5];\nint val[MAX_N+5]; pnt p[MAX_N+5]; lnt tr[MAX_N+5];\nvoid add(int p, lnt c) {for (; p <= m; p += (p&-p)) (tr[p] += c) %= P;}\nlnt sum(int p) {lnt ret = 0; for (; p; p -= (p&-p)) (ret += tr[p]) %= P; return ret;}\nbool cmp(const pnt &a, const pnt &b) {return a.x == b.x ? a.y > b.y : a.x < b.x;}\nint main() {\n\tread(N), read(M);\n\tfor (int i = 1; i <= N; i++) read(a[i]);\n\tfor (int i = 1; i <= M; i++) read(b[i]);\n\tfor (int i = 1; i <= N; i++) if (a[i] > b[1] && a[i] < b[M]) {\n\t\tint r = (int)(lower_bound(b+1, b+M+1, a[i])-b), l = r-1;\n\t\tif (a[i] ^ b[r]) p[++n] = pnt(a[i]-b[l], b[r]-a[i]);\n\t}\n\tfor (int i = 1; i <= n; i++) val[i] = p[i].y;\n\tsort(val+1, val+n+1), m = (int)(unique(val+1, val+n+1)-val-1);\n\tfor (int i = 1; i <= n; i++)\n\t\tp[i].y = (int)(lower_bound(val+1, val+m+1, p[i].y)-val);\n\tsort(p+1, p+n+1, cmp), n = (int)(unique(p+1, p+n+1)-p-1);\n\tlnt tot = 1, f;\n\tfor (int i = 1; i <= n; i++)\n\t\t(tot += (f = sum(p[i].y-1)+1)) %= P, add(p[i].y, f);\n\treturn printf(\"%lld\\n\", tot), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=100000 +117;\nconst int MM=100000 +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nstruct node{\n\tint l,r;\n}a[NN]={};\nint x[NN]={};\nint y[NN]={};\nint cnt=0;\nint ls[NN]={};\nint rs[NN]={};\nbool cmp(node a,node b){\n\treturn a.l==b.l?a.r>b.r:a.l<b.l;\n}\nint VAL=0;\nvoid pre(){\n\tn=read();\n\tm=read();\n\tfor(int i=1;i<=n;++i){\n\t\tx[i]=read();\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\ty[i]=read();\n\t}\n\ty[m+1]=2e9;\n\tfor(int i=1;i<=n;++i){\n\t\tint pos=lower_bound(y+1,y+1+m+1,x[i])-y;\n\t\tif(pos!=1&&pos!=m+1){\n\t\t\t++cnt;\n\t\t\tls[cnt]=a[cnt].l=x[i]-y[pos-1];\n\t\t\trs[cnt]=a[cnt].r=y[pos]-x[i];\n\t\t}\n\t}\n\tsort(ls+1,ls+1+cnt);\n\tsort(rs+1,rs+1+cnt);\n\tint lcnt=unique(ls+1,ls+1+cnt)-ls-1;\n\tint rcnt=unique(rs+1,rs+1+cnt)-rs-1;\n\tVAL=1;\n\tfor(int i=1;i<=cnt;++i){\n\t\ta[i].l=lower_bound(ls+1,ls+1+lcnt,a[i].l)-ls;\n\t\ta[i].r=lower_bound(rs+1,rs+1+rcnt,a[i].r)-rs+1;\n\t\tVAL=max(VAL,a[i].r);\n\t}\n\tsort(a+1,a+1+cnt,cmp);\n}\nLL bit[NN]={};\ninline int lowbit(int x){\n\treturn x&-x;\n}\nconst int mod=1e9+7;\ninline LL mo(LL &x,LL y){\n\tx=x+y>=mod?x+y-mod:x+y;\n}\nvoid add(int x,LL k){\n\tfor(;x<=VAL;x+=lowbit(x)){\n\t\tmo(bit[x],k);\n\t}\n}\nLL query(int x){\n\tLL ret=0;\n\tfor(;x;x-=lowbit(x)){\n\t\tmo(ret,bit[x]);\n\t}\n\treturn ret;\n}\nvoid solve(){\n\tadd(1,1);\n\tfor(int i=1;i<=cnt;++i){\n\t\tif(a[i].l==a[i-1].l&&a[i].r==a[i-1].r)continue;\n\t\tLL ad=query(a[i].r-1);\n\t\tadd(a[i].r,ad);\n\t}\n}\nint main(){\n\t//open();\n\tpre();\n\tsolve();\n\tprintf(\"%lld\\n\",query(VAL));\n\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=2e5+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n    T ans=0,f=1;\n    char ch=getchar();\n    while(!isdigit(ch)&&ch!='-')ch=getchar();\n    if(ch=='-')f=-1,ch=getchar();\n    while(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n    return ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n    if(x==0)\n    {\n        putchar('0'),putchar(y);\n        return;\n    }\n    if(x<0)\n    {\n        putchar('-');\n        x=-x;\n    }\n    static char wr[20];\n    int top=0;\n    for(;x;x/=10)wr[++top]=x%10+'0';\n    while(top)putchar(wr[top--]);\n    putchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n}\nint n,m,a[N],b[N];\nvoid input()\n{\n    n=read<int>(),m=read<int>();\t\n    For(i,1,n)a[i]=read<int>();\n    For(i,1,m)b[i]=read<int>();\n}\nint l[N],r[N],top;\nint q[N];\nstruct node\n{\n    int x,y;\n    bool operator < (const node &s)const\n    {\n        return x==s.x?y<s.y:x<s.x;\n    }\n\tbool operator == (const node &s)const\n\t{return x==s.x&&y==s.y;}\n}e[N];\nconst int inf=0x3f3f3f3f;\nvoid init()\n{\n    int st=1,ed=n;\n    while(a[st]<b[1])st++;\n    while(a[ed]>b[m])ed--;\n    top=ed-st+1;\n    For(i,1,top)a[i]=a[i+st-1];\n    //cerr<<st<<' '<<ed<<endl;\n\tint pos;\n    For(i,1,top)\n    {\n        pos=upper_bound(b+1,b+n+1,a[i])-b;\n        r[i]=b[pos]-a[i];\n        l[i]=a[i]-b[pos-1];\n    }\n    ++top,l[top]=r[top]=0;\n\tFor(i,1,top)e[i].x=l[i];\n    q[0]=top;\n    For(i,1,top)q[i]=r[i];\n    sort(q+1,q+q[0]+1);\n    q[0]=unique(q+1,q+q[0]+1)-q-1;\n    For(i,1,top)e[i].y=lower_bound(q+1,q+q[0]+1,r[i])-q;\n    \n    \n    //For(i,1,top)cout<<e[i].x<<' '<<e[i].y<<endl;\n}\nconst int mo=1e9+7;\nint sum[N];\nvoid add(int x,int v)\n{\n    for(;x<=top;x+=x&-x)sum[x]=(sum[x]+v)%mo;\n}\nint cal(int x)\n{\n    int res=0;\n    for(;x;x-=x&-x)res=(res+sum[x])%mo;\n    return res;\n}\nvoid work()\n{\n    sort(e+1,e+top+1);\n\ttop=unique(e+1,e+top+1)-e-1;\n\t//For(i,1,top)cout<<e[i].x<<' '<<e[i].y<<endl;\n\tadd(1,1);\n\tint j;\n\tFor(i,2,top)\n\t{\n\t\tfor(j=i;j<top&&e[j].x==e[j+1].x;j++);\n\t\tFordown(k,j,i)\n\t\t{\n\t\t\tadd(e[k].y,cal(e[k].y-1));\n\t\t\t//cerr<<e[j].y<<' '<<cal(e[j].y-1)<<endl;\n\t\t}\n\t\ti=j;\n\t}\n\twrite(cal(top),'\\n');\n}\nint main()\n{\n//    file();\n    input();\n    init();\n    work();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nconst int MOD = 1e9+7;\ntemplate<typename T> \nstruct BIT{\n  int n;\n  vector<T> bit;\n  //1-indexed\n  BIT():n(-1){}\n  BIT(int n_,T d):n(n_),bit(n_+1,d){}\n  \n  T sum(int i){\n    T s=bit[0];\n    for(int x=i;x>0;x-=(x&-x))\n      (s+=bit[x])%=MOD;\n    return s;\n  }\n  void add(int i,T a){\n    if(i==0) return;\n    for(int x=i;x<=n;x+=(x&-x))\n      (bit[x]+=a)%=MOD;\n  }\n  T sum0(int i){\n    return sum(i+1);\n  }\n  void add0(int i,T a){\n    add(i+1,a);\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  vector<Int> x(n),y(m);\n  for(Int i=0;i<n;i++) cin>>x[i];\n  for(Int i=0;i<m;i++) cin>>y[i];\n\n  using P = pair<Int, Int>;\n  vector<P> vp;\n  for(Int i=0;i<n;i++){\n    if(x[i]<y[0]||y[m-1]<x[i]) continue;\n    Int k=lower_bound(y.begin(),y.end(),x[i])-y.begin();\n    vp.emplace_back(x[i]-y[k-1],x[i]-y[k]);\n  }\n  sort(vp.begin(),vp.end());\n  vp.erase(unique(vp.begin(),vp.end()),vp.end());\n\n  vector<Int> b;\n  b.emplace_back(0);\n  for(auto p:vp)\n    b.emplace_back(-p.second);\n  \n  sort(b.begin(),b.end());\n  b.erase(unique(b.begin(),b.end()),b.end());\n\n  map<Int, Int> mb;\n  for(Int i=0;i<(Int)b.size();i++) mb[b[i]]=i;\n\n  m=b.size();\n  BIT<int> bit(m+1,0);\n  bit.add0(0,1);\n  \n  for(auto p:vp){\n    Int y=mb[-p.second];\n    bit.add0(y,bit.sum0(y-1));\n  }\n  \n  cout<<bit.sum0(m)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nll bit[100010]; int n0;\n \nll sum(int i){\n\tll s=0;\n\twhile(i>0){\n\t\ts+=bit[i];\n      s%=MOD;\n\t\ti-=(i&(-i));\n\t}\n\treturn s;\n}\n \nvoid add(int i, ll x){\n\twhile(i<=n0){\n\t\tbit[i]+=x;\n      bit[i]%=MOD;\n\t\ti+=(i&(-i));\n\t}\n}\nint main()\n{\n\tint n, m;\n  cin>>n>>m;\n  map<int, vector<int> > mp;\n  int x[100000], y[100000];\n  set<int> st;\n  map<int, int> mpy;\n  for(int i=0; i<n; i++) cin>>x[i];\n  for(int i=0; i<m; i++) cin>>y[i];\n  for(int i=0; i<n; i++){\n    int i1=lower_bound(y, y+m, x[i])-y;\n    if(i1==0 || i1==m) continue;\n    mp[x[i]-y[i1-1]].push_back(y[i1]-x[i]);\n    st.insert(y[i1]-x[i]);\n  }\n  n0=1;\n  for(auto itr=st.begin(); itr!=st.end(); ++itr){\n    mpy[*itr]=n0;\n    n0++;\n  }\n  for(auto itr=mp.begin(); itr!=mp.end(); itr++){\n    vector<int> v=itr->second;\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    for(int i=v.size()-1; i>=0; i--){\n      //cout<<v[i]<<\" \";\n      int t=mpy[v[i]];\n      add(t, (sum(t-1)+1)%MOD);\n    }\n    //cout<<endl;\n    //cout<<sum(n0)+1<<endl;\n  }\n  cout<<(sum(n0)+1)%MOD<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\n\nconst int maxn=100111;\nconst int mod=1e9+7;\nconst int inf=0x3f3f3f3f;\n\nint bit[maxn];\nvoid add(int x,int v)\n{\n\tfor(;x<maxn;x+=x&-x)\n\t{\n\t\tbit[x]+=v;\n\t\tif(bit[x]>=mod)bit[x]-=mod;\n\t}\n}\nint query(int x)\n{\n\tint ret=0;\n\tfor(;x;x-=x&-x)\n\t{\n\t\tret+=bit[x];\n\t\tif(ret>=mod)ret-=mod;\n\t}\n\treturn ret;\n}\n\nint n,m,a[maxn],b[maxn],l[maxn],r[maxn],dp[maxn];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",a+i);\n\tfor(int i=1;i<=m;i++)scanf(\"%d\",b+i);\n\t\n\tint cur=1;\n\tvector<pii> vs;vector<int> vy;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(a[i]<b[1]||a[i]>b[m])continue;\n\t\twhile(b[cur]<a[i])cur++;\n\t\tl[i]=a[i]-b[cur-1];\n\t\tr[i]=b[cur]-a[i];\n\t\tvs.pb(mp(l[i],r[i]));\n\t\tvy.pb(r[i]);\n\t}\n\tvs.pb(mp(0,0));vy.pb(0);\n\tvs.pb(mp(inf,inf));vy.pb(inf);\n\tsort(vs.begin(),vs.end());vs.erase(unique(vs.begin(),vs.end()),vs.end());\n\tsort(vy.begin(),vy.end());vy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tfor(int i=0;i<(int)vs.size();i++)vs[i].ss=upper_bound(vy.begin(),vy.end(),vs[i].ss)-vy.begin();\n\t\n\tdp[0]=1;\n\tfor(int i=0,nxt=0;i<(int)vs.size();i=nxt)\n\t{\n\t\tfor(;nxt<(int)vs.size()&&vs[i].ff==vs[nxt].ff;nxt++);\n\t\tfor(int j=i;j<nxt;j++)if(j)dp[j]=query(vs[j].ss-1);\n\t\tfor(int j=i;j<nxt;j++)add(vs[j].ss,dp[j]);\n\t}\n\tprintf(\"%d\\n\",dp[(int)vs.size()-1]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add_mod(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\n\ntemplate<typename T>\nstruct BIT {\n    int n;\n    vector<T> dat;\n\n    BIT(int n=0):n(n){\n        initialize(n);\n    }\n\n    void initialize(int n){\n        dat.resize(n);\n        for(int i = 0; i<n; i++) dat[i] = 0;\n    }\n\n    T sum(int i){\n        T s = 0;\n        while(i >= 0){\n            add_mod(s, dat[i]);\n            i = (i & (i+1)) - 1;\n        }\n        return s;\n    }\n\n    void add(int i, T x){\n        while(i <= n){\n            add_mod(dat[i], x);\n            i |= i+1;\n        }\n    }\n};\n\nint main(){\n    int N, M;\n    cin >> N >> M;\n    vector<int> X(N), Y(M);\n    for(int i=0; i<N; i++) cin >> X[i];\n    for(int i=0; i<M; i++) cin >> Y[i];\n\n    vector<pair<int, int>> pts;\n    vector<int> ys = {0};\n    for(int i=0, j=0; i<N; i++){\n        if(X[i] < Y[0] || Y[M-1] < X[i]) continue;\n        while(Y[j] < X[i]) j++;\n        pts.push_back({X[i]-Y[j-1], -(Y[j]-X[i])});\n        ys.push_back(Y[j]-X[i]);\n    }\n    if(pts.size() == 0){\n        cout << 1 << endl;\n        return 0;\n    }\n\n    sort(pts.begin(), pts.end());\n    sort(ys.begin(), ys.end());\n    pts.erase(unique(pts.begin(), pts.end()), pts.end());\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n    BIT<int64_t> bit(ys.size());\n    bit.add(0, 1);\n\n    for(auto p : pts){\n        int y = -p.second;\n        int i = lower_bound(ys.begin(), ys.end(), y) - ys.begin();\n        if(i > 0) bit.add(i, bit.sum(i-1));\n    }\n    cout << bit.sum(ys.size()-1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define Mp make_pair\n#define pb push_back\n#define rep(i, j, k) for (ll i = (j); i <= (k); i++)\n#define per(i, j, k) for (ll i = (j); i >= (k); i--)\nconst int INF = 0x3f3f3f3f, nINF = 0xcfcfcfcf, INFMEM = 0x3f, nINFMEM = 0xcf;\nconst int PR1 = 1e6 + 3, PR2 = 1e9 + 7;\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nconst ll N = 1e5+3, mod=1e9+7;\nll n,m,a[N],b[N],cnt1,cnt2,y[N];\n//f[i]: 最后一个经过的点为i后一直向右走的总方案数\nll ans,f,sum[N];\nPII p[N];\n#define lowbit(x) (x)&-(x)\nvoid modify(ll x, ll v){\n    for(;x<=N;x+=lowbit(x)) sum[x]+=v;\n}\nll query(ll x){\n    ll ret=0; for(;x;x-=lowbit(x)) ret+=sum[x]; return ret;\n}\n\nsigned main(){\n    scanf(\"%lld%lld\",&n,&m);\n    rep(i,1,n) scanf(\"%lld\",&a[i]);\n    rep(i,1,m) scanf(\"%lld\",&b[i]);\n    {\n        ll i=1,j=1;\n        while(a[i]<b[j]) i++;\n        while(i<=n&&j<m){\n            while(j<m && a[i]>=b[j+1]) j++;\n            if(j>=m) break; if(a[i]==b[j]) { i++;continue; }\n            p[++cnt1]=Mp(a[i]-b[j],b[j+1]-a[i]);\n            y[++cnt2]=b[j+1]-a[i]; i++;\n        }\n    }\n    sort(y+1,y+1+cnt2);\n    cnt2=unique(y+1,y+1+cnt2)-y-1;\n    rep(i,1,cnt1) p[i].se=lower_bound(y+1,y+1+cnt2,p[i].se)-y;\n    sort(p+1,p+1+cnt1,[&](const PII& com1, const PII& com2){\n        return com1.fi!=com2.fi ? com1.fi<com2.fi : com1.se>com2.se;\n    });\n    cnt1=unique(p+1,p+1+cnt1)-p-1;\n    // puts(\"------------------\");\n    // rep(i,1,cnt1) printf(\"%d %d\\n\",p[i].fi,p[i].se);\n    ans=1;\n    rep(i,1,cnt1){\n        ans = (ans+(f=query(p[i].se)+1))%mod;\n        //printf(\"%lld\\n\",f);\n        modify(p[i].se+1,f);\n    }\n    printf(\"%lld\\n\",ans%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\nconst int P=1e9+7;\nint n,m,cnt,num,a[N],b[N],d[N],f[N];\nstruct each{\n\tint l,r;\n\tbool operator == (each k){\n\t\treturn l==k.l&&r==k.r;\n\t}\n}c[N];\nbool com(each x,each y){\n\tif(x.l==y.l)\treturn x.r>y.r;\n\treturn x.l<y.l;\n}\nvoid add(int x,int y){\n\twhile(x<=num){\n\t\tf[x]=(f[x]+y)%P;\n\t\tx+=x&-x;\n\t}\n}\nint query(int x){\n\tint ans=0;\n\twhile(x){\n\t\tans=(ans+f[x])%P;\n\t\tx-=x&-x;\n\t}\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++)\tscanf(\"%d\",&b[i]);\n\tsort(a+1,a+n+1),sort(b+1,b+m+1);\n\tn=unique(a+1,a+n+1)-a-1;\n\tm=unique(b+1,b+m+1)-b-1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]<b[1]||a[i]>b[m])\tcontinue;\n\t\tint k=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif(b[k]==a[i])\tcontinue;\n\t\tc[++cnt].l=a[i]-b[k-1];\n\t\td[cnt]=c[cnt].r=b[k]-a[i];\n\t}\n\td[cnt+1]=0;\n\tsort(d+1,d+cnt+2);\n\tsort(c+1,c+cnt+1,com);\n\tnum=unique(d+1,d+cnt+2)-d-1;\n\tadd(1,1);\n\tfor(int i=1;i<=n;i++){\n\t\tif(c[i]==c[i-1])\tcontinue;\n\t\tint k=lower_bound(d+1,d+num+1,c[i].r)-d;\n\t\tadd(k,query(k-1));\n\t}\n\tprintf(\"%d\\n\",query(num));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstruct node\n{\n\tint x,y,newy;\n\tbool operator < (const node &a)const\n\t{\n\t\tif (x!=a.x)\n\t\t\treturn x<a.x;\n\t\telse\n\t\t\treturn newy>a.newy;\n\t}\n};\nnode move[1000001];\nint f[1000001],c[1000001],a[1000001],b[1000001],ans,res,len,n,m,useless;\nbool cmp(node u,node v)\n{\n\treturn u.y<v.y;\n}\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\nvoid add(int x,int d)\n{\n\tfor (;x<=n;x+=lowbit(x))\n\t\tc[x]+=d;\n\treturn;\n}\nint sum(int x)\n{\n\tans=0;\n\tfor (;x>=1;x-=lowbit(x))\n\t\tans+=c[x];\n\treturn ans;\n}\nint main()\n{\n\tint first,last,mid,front,back;\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;++i)\n\t\tcin>>a[i];\n\tfor (int i=1;i<=m;++i)\n\t\tcin>>b[i];\n\tsort(a+1,a+n+1);\n\tsort(b+1,b+n+1);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tfirst=1;\n\t\tlast=m;\n\t\tfront=0;\n\t\tback=m+1;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]>=b[mid])\n\t\t\t{\n\t\t\t\tfront=max(front,mid);\n\t\t\t\tfirst=mid+1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tlast=mid-1;\n\t\t}\n\t\tfirst=1;\n\t\tlast=m;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]<=b[mid])\n\t\t\t{\n\t\t\t\tback=min(back,mid);\n\t\t\t\tlast=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tfirst=mid+1;\n\t\t}\n\t\tif (front==0||back==m+1||b[front]==a[i]||b[back]==a[i])\n\t\t\tcontinue;\n\t\tmove[++len].x=a[i]-b[front];\n\t\tmove[len].y=b[back]-a[i];\n\t}\n\tsort(move+1,move+len+1,cmp);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tmove[i].newy=i-useless;\n\t\tif (move[i].y==move[i+1].y)\n\t\t\tuseless++;\n\t}\n\tsort(move+1,move+len+1);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tf[i]=sum(move[i].newy-1)+1;\n\t\tadd(move[i].newy,f[i]);\n\t}\n\tfor (int i=1;i<=len;++i)\n\t\tres+=f[i];\n\tcout<<res+1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define Mp make_pair\n#define pb push_back\n#define rep(i, j, k) for (ll i = (j); i <= (k); i++)\n#define per(i, j, k) for (ll i = (j); i >= (k); i--)\nconst int INF = 0x3f3f3f3f, nINF = 0xcfcfcfcf, INFMEM = 0x3f, nINFMEM = 0xcf;\nconst int PR1 = 1e6 + 3, PR2 = 1e9 + 7;\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<ll, ll> PII;\ntypedef vector<int> VI;\n\nconst ll N = 1e5+3, mod=1e9+7;\nll n,m,a[N],b[N],cnt1,cnt2,y[N];\n//f[i]: 最后一个经过的点为i后一直向右走的总方案数\nll ans,f,sum[N];\nPII p[N];\n#define lowbit(x) (x)&-(x)\nvoid modify(ll x, ll v){\n    for(;x<=N;x+=lowbit(x)) sum[x]=(sum[x]+v)%mod;\n}\nll query(ll x){\n    ll ret=0; for(;x;x-=lowbit(x)) ret=(ret+sum[x])%mod; return ret;\n}\n\nsigned main(){\n    scanf(\"%lld%lld\",&n,&m);\n    rep(i,1,n) scanf(\"%lld\",&a[i]);\n    rep(i,1,m) scanf(\"%lld\",&b[i]);\n    {\n        ll i=1,j=1;\n        while(a[i]<b[j]) i++;\n        while(i<=n&&j<m){\n            while(j<m && a[i]>=b[j+1]) j++;\n            if(j>=m) break; if(a[i]==b[j]) { i++;continue; }\n            p[++cnt1]=Mp(a[i]-b[j],b[j+1]-a[i]);\n            y[++cnt2]=b[j+1]-a[i]; i++;\n        }\n    }\n    sort(y+1,y+1+cnt2);\n    cnt2=unique(y+1,y+1+cnt2)-y-1;\n    rep(i,1,cnt1) p[i].se=lower_bound(y+1,y+1+cnt2,p[i].se)-y;\n    sort(p+1,p+1+cnt1,[&](const PII& com1, const PII& com2){\n        return com1.fi!=com2.fi ? com1.fi<com2.fi : com1.se>com2.se;\n    });\n    cnt1=unique(p+1,p+1+cnt1)-p-1;\n    // puts(\"------------------\");\n    // rep(i,1,cnt1) printf(\"%d %d\\n\",p[i].fi,p[i].se);\n    ans=1;\n    rep(i,1,cnt1){\n        ans = (ans+(f=query(p[i].se)+1))%mod;\n        //printf(\"%lld\\n\",f);\n        modify(p[i].se+1,f);\n    }\n    printf(\"%lld\\n\",ans%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int N=1e5+10,MOD=1e9+7;\nint plu(int x,int y){return (1LL*x+y)-(1LL*x+y>=MOD?MOD:0);}\nnamespace BIT{/*{{{*/\n\tint c[N*2];\n\tint mx;\n\tvoid init(int _n){mx=_n;}\n\tvoid insert(int x,int delta){for (;x<=mx;x+=x&-x) c[x]=plu(c[x],delta);}\n\tint query(int x){\n\t\tif (x<=0) return 0;\n\t\tint ret=0;\n\t\tfor (;x;x-=x&-x) ret=plu(ret,c[x]);\n\t\treturn ret;\n\t}\n}/*}}}*/\nstruct Dot{\n\tint x,y;\n\tDot(){}\n\tDot(int x1,int y1){x=x1; y=y1;}\n\tfriend bool operator < (Dot x,Dot y){return x.x==y.x?x.y<y.y:x.x<y.x;}\n\tfriend bool operator == (Dot x,Dot y){return x.x==y.x&&x.y==y.y;}\n}d[N];\nint lis[N*2];\nint a[N],b[N];\nint f[N*2];\nint n,m,cnt;\nvoid prework(){\n\tint nxt,pre;\n\tcnt=0;\n\tfor (int i=1;i<=n;++i){\n\t\tif (a[i]<b[1]) continue;\n\t\tif (a[i]>b[m]) break;\n\t\tnxt=lower_bound(b+1,b+1+n,a[i])-b;\n\t\tif (a[i]==b[nxt]) continue;\n\t\tpre=nxt-1;\n\t\td[++cnt]=Dot(a[i]-b[pre],b[nxt]-a[i]);\n\t\tlis[++lis[0]]=a[i]-b[pre];\n\t\tlis[++lis[0]]=b[nxt]-a[i];\n\t}\n\tsort(lis+1,lis+1+lis[0]);\n\tlis[0]=unique(lis+1,lis+1+lis[0])-lis-1;\n\tfor (int i=1;i<=cnt;++i){\n\t\td[i].x=lower_bound(lis+1,lis+1+lis[0],d[i].x)-lis;\n\t\td[i].y=lower_bound(lis+1,lis+1+lis[0],d[i].y)-lis;\n\t}\n\tBIT::init(lis[0]);\n}\nvoid dp(){\n\tsort(d+1,d+1+cnt);\n\tcnt=unique(d+1,d+1+cnt)-d-1;\n\tmemset(f,0,sizeof(f));\n\tint now=1,ans=1;\n\tfor (int i=1;i<=cnt;++i){\n\t\t//while (d[now].x<d[i].x) BIT::insert(d[now].y,f[now]),++now;\n\t\tf[i]=plu(1,BIT::query(d[i].y-1));\n\t\tBIT::insert(d[i].y,f[i]);\n\t\tans=plu(ans,f[i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n#ifndef ONLINE_JUDGE\n\t//freopen(\"a.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;++i) scanf(\"%d\",a+i);\n\tfor (int i=1;i<=m;++i) scanf(\"%d\",b+i);\n\tprework();\n\tdp();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int Mod = 1e9 + 7, N = 100010;\nint a[N], b[N];\nint fpow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod) if (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n, m;\n\tread(n), read(m);\n\tfor (int i = 1; i <= n; i++) read(a[i]);\n\tfor (int i = 1; i <= m; i++) read(b[i]);\n\tsort(b + 1, b + 1 + m);\n\tint k = n;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (a[i] < b[1] || a[i] > b[m] || *lower_bound(b + 1, b + 1 + m, a[i]) == a[i]) k--;\n\tprintf(\"%d\\n\", fpow(2, k));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 2e5 + 10, INF = 1e9, MOD = 1e9 + 7;\n\nvector<pair<ll, ll>> vec;\n\nll tree[SIZE * 8], p[SIZE * 8];\n\nll get(int v, int l, int r, int pos) {\n\tif (l == r - 1) {\n\t\treturn (tree[v] + p[v]) % MOD;\n\t}\n\telse {\n\t\tint mid = (l + r) / 2;\n\t\tif (pos < mid) {\n\t\t\treturn (get(v * 2 + 1, l, mid, pos) + p[v]) % MOD;\n\t\t}\n\t\telse {\n\t\t\treturn (get(v * 2 + 2, mid, r, pos) + p[v]) % MOD;\n\t\t}\n\t}\n}\n\nvoid upd(int v, int l, int r, int askl, int askr, int val) {\n\tif (l >= askr || r <= askl) return;\n\n\tif (l >= askl && r <= askr) {\n\t\tp[v] += val;\n\t\tp[v] %= MOD;\n\t\treturn;\n\t}\n\n\tll mid = (l + r) / 2;\n\tupd(v * 2 + 1, l, mid, askl, askr, val);\n\tupd(v * 2 + 2, mid, r, askl, askr, val);\n}\nsigned main()\n{\n\tfastInp;\n\n\tll n, m;\n\tcin >> n >> m;\n\n\tset<ll> s;\n\tvector<ll> vec2(n), ex(m), vec;\n\tfor (auto &cur : vec2) cin >> cur;\n\n\tmap<ll, vector<ll>> mp;\n\tfor (auto &cur : ex) {\n\t\tcin >> cur;\n\t\ts.insert(cur);\n\t}\n\n\tfor (int i = 0; i < vec2.size(); i++) {\n\t\tif (!(vec2[i] <= ex[0] || vec2[i] >= ex.back() || s.find(vec2[i]) != s.end())) {\n\t\t\tvec.push_back(vec2[i]);\n\t\t}\n\t}\n\n\tvector<ll> k;\n\tfor (auto cur : vec) {\n\t\tll nxt = (*upper_bound(ex.begin(), ex.end(), cur)), pr = *(--upper_bound(ex.begin(), ex.end(), cur));\n\t\tmp[nxt - cur].push_back(cur - pr);\n\t\tk.push_back(cur - pr);\n\t}\n\n\tsort(k.begin(), k.end());\n\tauto it = unique(k.begin(), k.end());\n\tk.erase(it, k.end());\n\tmap<ll, ll> ch;\n\tfor (int i = 0; i < k.size(); i++) ch[k[i]] = i + 1;\n\n\t\n\tn = k.size() + 10;\n\tupd(0, 0, n, 0, n, 1);\n\tfor (auto cur : mp) {\n\t\tvector<ll> c = cur.second;\n\t\tsort(c.rbegin(), c.rend());\n\t\tfor (auto t : c) {\n\t\t\tll vl = get(0, 0, n, ch[t]);\n\t\t\tupd(0, 0, n, ch[t] + 1, n, vl);\n\t\t}\n\t}\n\n\n\tll vl = get(0, 0, n, n - 1);\n\tcout << vl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <map>\n#include <vector>\nusing namespace std;\ntypedef long long LL;\nconst LL N = 300005;\nconst LL MOD = 1000000007;\n\nstruct node{\n\tLL l,r;\n}s[N],t[N];\nbool cmp(node x,node y){\n\treturn (x.l == y.l ? x.r > y.r : x.l < y.l);    \n}\n\nLL n;\nstruct BIT{\n\tLL tr[N << 1];\n\tLL lowbit(LL x){ return (x & (-x)); }\n\tvoid modify(LL x,LL v){ for(;x <= n + 1;x += lowbit(x)) tr[x] += v; }\n\tLL query(LL x){ LL ret = 0; if(!x) return 0; for(;x;x -= lowbit(x)) ret += tr[x]; return ret; }\n}b;\n\nLL pr[N],p[N],sr[N];\nLL dp[N];\nmap <LL,LL> mp;\n\nint main(){\n\tios::sync_with_stdio(false);\n\tLL m,u,v,tl,tr,ct = 0;\n\tcin >> n >> m;\n\tfor(LL i = 1;i <= n;i ++) cin >> pr[i];\n\tfor(LL i = 1;i <= m;i ++) cin >> p[i];\n\t\n\tfor(LL i = 1;i <= n;i ++){\n\t\tif(pr[i] < p[1] || pr[i] > p[m]) continue;\n\t\ttl = lower_bound(p + 1,p + 1 + m,pr[i]) - p - 1;\n\t\ttr = lower_bound(p + 1,p + 1 + m,pr[i]) - p;\n\t\ts[i].l = pr[i] - p[tl]; s[i].r = p[tr] - pr[i];\n\t}\n\tsort(s + 1,s + 1 + n,cmp);\n\tfor(LL i = 1;i <= n;i ++){\n\t\tif(s[i].l != s[i - 1].l || s[i].r != s[i - 1].r) t[++ ct] = s[i];\n\t} n = ct; ct = 0;\n\tfor(LL i = 1;i <= n;i ++) sr[i] = t[i].r;\n\tsort(sr + 1,sr + 1 + n);\n\tfor(LL i = 1;i <= n;i ++) if(mp.find(sr[i]) == mp.end()) mp[sr[i]] = ++ ct;\n\tfor(LL i = 1;i <= n;i ++) t[i].r = mp[t[i].r];\n\t\n\tdp[0] = 1; t[0].l = t[0].r = 0; t[n + 1].l = t[n + 1].r = n + 1;\n\tfor(LL i = 1;i <= n + 1;i ++){\n\t\tdp[i] = 1 + b.query(t[i].r - 1); dp[i] %= MOD;\n\t\tb.modify(t[i].r,dp[i]);\n\t}\n\tcout << dp[n + 1] << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define sc second\n#define fi first\n#define pii pair <int,int>\n#define ll long long\n#define lowbit(a) a&-a\nusing namespace std;\n\ninline int read(){\n\tint sum=0,f=1;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=sum*10+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\n\nconst int N=100001;\nconst int Mod=1e9+7;\nint n,m,a[N],b[N],d[N],t1,t2;\nll t[N],ans=1;\npair <int,int> c[N];\n\ninline void add(int x,ll k){\n\tfor(int i=x;i<=t2;i+=lowbit(i)) t[i]=(t[i]+k)%Mod;\t\n}\n\ninline ll ask(int x){\n\tint ret=0;\n\tfor(int i=x;i;i-=lowbit(i)) ret=(ret+t[i])%Mod;\n\treturn ret;\n}\n\nbool cmp(pii a,pii b){return a.fi!=b.fi? a.fi<b.fi:a.sc>b.sc;}\n\nint main(){\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tfor(int i=1;i<=m;i++) b[i]=read();\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]<=b[1]||a[i]>=b[m]) continue;\n\t\tint k=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif(a[i]==b[k]) continue;\n\t\tc[++t1]=make_pair(a[i]-b[k-1],b[k]-a[i]);d[++t2]=b[k]-a[i];\n\t}\n\tsort(d+1,d+t2+1);int l=unique(d+1,d+t2+1)-d-1;\n\tfor(int i=1;i<=t1;i++){\n\t\tc[i].second=lower_bound(d+1,d+l+1,c[i].second)-d;\n\t}\n\tsort(c+1,c+t1+1,cmp);t1=unique(c+1,c+t1+1)-c-1;\n\tfor(int i=1;i<=t1;i++){\n\t\tll sum=ask(c[i].sc-1)+1;\n\t\tans=ans+sum%Mod;add(c[i].sc,sum);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define ll long long\n\nusing namespace std;\n\nconst ll mod = (ll)1e9 + 7; \nconst int N = 200200; \n\nint n, m, x[N], y[N]; \nint cnt, tot, key[N]; \nll f[N], c[N]; \n\nint lb(int x) {\n  return x & (-x); \n}\n\nvoid add(int x, ll d) {\n  for(int i = x; i <= tot; i += lb(i))\n    c[i] += d, c[i] %= mod; \n}\n\nll sum(int x) {\n  ll ret = 0; \n  for(int i = x; i; i -= lb(i)) \n    ret = (ret + c[i]) % mod; \n  return ret; \n}\n\npair <int, int> P[N]; \n\nbool cmp(pair <int, int> x, pair <int, int> y) {\n  return x.fi == y.fi ? x.se > y.se : x.fi < y.fi; \n}\n\nint main() {\n  scanf(\"%d %d\", &n, &m); \n  for(int i = 1; i <= n; i++) {\n    scanf(\"%d\", &x[i]); \n  }\n  for(int i = 1; i <= m; i++) {\n    scanf(\"%d\", &y[i]); \n  }\n  sort(x + 1, x + n + 1); \n  sort(y + 1, y + m + 1); \n  for(int i = 1; i <= n; i++) {\n    if(x[i] <= y[1] || x[i] >= y[m]) continue ; \n    int lp, rp; \n    lp = lower_bound(y + 1, y + m + 1, x[i]) - y - 1; \n    rp = lp + 1; \n    if(y[lp] == x[i]) continue ; \n    P[++cnt].fi = x[i] - y[lp]; \n    P[cnt].se = y[rp] - x[i];\n    key[cnt] = P[cnt].se;  \n  }\n  \n  sort(key + 1, key + cnt + 1); \n  tot = unique(key + 1, key + cnt + 1) - key - 1; \n  for(int i = 1; i <= cnt; i++) {\n    P[i].se = lower_bound(key + 1, key + tot + 1, P[i].se) - key; \n  }\n  ll ans = 0; \n  sort(P + 1, P + cnt + 1, cmp);\n  cnt = unique(P + 1, P + cnt + 1) - P - 1; \n  for(int i = 1; i <= cnt; i++) {\n    ll tmp = sum(P[i].se - 1) + 1; \n    ans += tmp; ans %= mod; \n    add(P[i].se, tmp); \n  }\n  printf(\"%lld\\n\", (ans + 1) % mod); \n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "/*\nVim: :pc -> close scratch window\nHow to lambda \n  ex) sort(begin(cont),end(cont),[](dat a,dat b) {return a.l<b.l;});\n  XXX:lambda different from fun obj\nlower_bound/upper_bound\n  1 2 2 2 3 3\n    ^lb   ^ub\n*/\n#include <bits/stdc++.h>\n#define REP(i,n) for(int (i)=0;(i)<(n);++(i))\n#define FORR(it,cont) for(auto it=rbegin(cont);it!=rend(cont);++it)\n#define FOR(it,cont) for(auto it=begin(cont);it!=end(cont);++it)\n#define ALL(cont) begin(cont), end(cont)\n#define LB(b,e,v) lower_bound(b,e,v)\n#define UB(b,e,v) upper_bound(b,e,v)\n#define AS_MOD(a,b) ((((a) % (b) ) + (b)) % (b))\n#define MODDING(a,b) (a) = AS_MOD(a,b)\n#define fi first\n#define se second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntemplate<class T>struct DPS{int a,b,c;vector<T> S;\nDPS(int A,int B,int C,T s){a=A;b=B;c=C;S.resize(a*b*c,s);}\nT& operator()(int A,int B,int C) {return S[A*b*c+B*c+C];}};\nint N,M;\ntypedef pair<int,int> Pii;\nll MOD = 1000*1000*1000+7;\nvector<ll> ftDat;\nvoid add(int i,ll v) {\n  while(i<ftDat.size()) {\n    ftDat[i] += AS_MOD(v,MOD);\n    MODDING(ftDat[i],MOD);\n    i += i & -i;\n  }\n}\nll sum(int i) {\n  ll ret=0;\n  while(i>0) {\n    ret += ftDat[i];\n    MODDING(ret,MOD);\n    i-=i& -i;\n  }\n  return ret;\n}\nint main(int argc, char **argv, char **envp) {\n  cin >> N >> M;\n  vector<int> xs;\n  vector<int> ys;\n  ftDat.resize(N+30);\n  xs.resize(N);\n  ys.resize(M);\n  REP(i,N) {\n    int x;\n    scanf(\"%d\", &x);\n    xs[i]=x;\n  }\n  REP(i,M) {\n    int y;\n    scanf(\"%d\", &y);\n    ys[i]=y;\n  }\n  vector<Pii> Piis;\n  vector<int> tB;\n  Piis.reserve(N);\n  tB.reserve(N);\n  for(int i=0,j=1;i<N&&j<M;++j) {\n    while(i<N&&xs[i]<ys[j-1])++i;\n    while(i<N&&xs[i]<ys[j]) {\n      tB.push_back(xs[i]);\n      i++;\n    }\n    FOR(it,tB) {\n      Piis.push_back(Pii(*it-ys[j-1],ys[j]-*it));\n    }\n    tB.clear();\n  }\n  {\n    sort(ALL(Piis), [](Pii a,Pii b){return a.fi < b.fi;});\n    int prev=-1,p=0;\n    for(int i=0;i<Piis.size();++i){\n      if (prev == Piis[i].fi) {\n        Piis[i].fi=p;\n      } else {\n        prev = Piis[i].fi;\n        Piis[i].fi=++p;\n      }\n    }\n    prev=-1,p=0;\n    sort(ALL(Piis), [](Pii a,Pii b){return a.se != b.se ? a.se < b.se : a.fi < b.fi;});\n    for(int i=0;i<Piis.size();++i){\n      if (prev == Piis[i].se) {\n        Piis[i].se=p;\n      } else {\n        prev=Piis[i].se;\n        Piis[i].se=++p;\n      }\n    }\n  }\n  vector<Pii> Piis2;\n  Piis2.reserve(N);\n  {\n    FOR(it,Piis) {\n      if (Piis2.empty() || *Piis2.rbegin() != *it) {\n        Piis2.pb(*it);\n      }\n    }\n  }\n  vector<Pii> tP;\n  vector<ll> tD;\n  tP.reserve(N);\n  tD.reserve(N);\n  int prev=-1;\n  add(1,1);\n  for(int i=0;i<=Piis2.size();++i) {\n    if (i < Piis2.size() && prev==Piis2[i].se) {\n      tP.push_back(Piis2[i]);\n    } else {\n      FOR(it, tP) {\n        tD.pb(sum(it->first));\n      }\n      for(int j=0;j<tP.size();++j) {\n        add(tP[j].fi+1,tD[j]);\n      }\n      tD.clear();\n      tP.clear();\n      if (i<Piis2.size() ){\n        prev = Piis2[i].se;\n        tP.push_back(Piis2[i]);\n      }\n    }\n  }\n\n\n  cout << sum(N+10) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nint n, m;\nint a[101010];\nint b[101010];\nvector<pair<LL, LL>> c;\n\nstruct BIT {\n\tvector<LL> bit;\n\tBIT(LL n) {\n\t\tbit.resize(n + 10);\n\t\tfor (int i = 0; i < n + 10; i++)bit[i] = 0;\n\t}\n\t//[0,i)\n\tLL sum(int i) {\n\t\tLL s = 0;\n\t\tfor (int x = i - 1; x >= 0; x = (x&(x + 1)) - 1) {\n\t\t\ts += bit[x];\n\t\t}\n\t\treturn s;\n\t}\n\tvoid add(int a, LL w) {\n\t\tfor (int x = a; x < bit.size(); x |= x + 1) {\n\t\t\tbit[x] += w;\n\t\t}\n\t}\n};\nconst int mod = 1e9 + 7;\n\nbool calc(pair<LL, LL> p, pair<LL, LL> q) {\n\tif (p.first == q.first)return p.second > q.second;\n\treturn p < q;\n}\n\nint main() {\n\tcin >> n >> m;\n\tREP(i, n)cin >> a[i];\n\tREP(i, m)cin >> b[i];\n\tREP(i, n) {\n\t\tint it = lower_bound(b, b + m, a[i]) - b;\n\t\tif (it == 0 || it == m)continue;\n\t\tc.emplace_back(make_pair(a[i] - b[it - 1], b[it] - a[i]));\n\t}\n\tsort(ALL(c));\n\tUNIQUE(c);\n\tsort(ALL(c), calc);\n\tvector<LL> d;\n\tint N = c.size(), id = 1;\n\tREP(i, N)d.emplace_back(c[i].second);\n\tsort(ALL(d));\n\tUNIQUE(d);\n\tmap<LL, LL>mp;\n\tREP(i, d.size()) {\n\t\tif (mp.find(d[i]) == mp.end()) {\n\t\t\tmp[d[i]] = id;\n\t\t\tid++;\n\t\t}\n\t}\n\tREP(i, N)c[i].second = mp[c[i].second];\n\tBIT bit(n);\n\tbit.add(0, 1);\n\tLL ans = 1;\n\tREP(i, N) {\n\t\tLL t = bit.sum(c[i].second + 1);\n\t\tans += t;\n\t\tans %= mod;\n\t\tbit.add(c[i].second, t);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define _   int v, int tl, int tr, int l, int r\n#define tm  (tl + tr >> 1)\n#define sol v+v, tl, tm, l, r\n#define sag v+v+1, tm+1, tr, l, r\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\ntypedef pair < int , int > pp;\nconst int mod = 1e9 + 7;\nconst int N   = 1e5 + 5;\n\npp P[N];\nint A[N], W[N], w, F[N], dp[N], n;\n\nint qry(int x){\n    int t = 1;\n    for(; x ; x -= x&-x)\n        t = (t + F[x]) % mod;\n    return t;\n}\nvoid up(int x, int t){\n    for(; x <= n; x += x&-x)\n        F[x] = (F[x] + t) % mod;\n}\n\n\nsigned main(){\n    int m;\n    cin >> n >> m;\n    for(int i=1; i<=n; i++) scanf(\"%lld\", &A[i]);\n    int p = 0;\n    for(int j=1, i=1; i<=m; i++){\n        int x;\n        scanf(\"%lld\", &x);\n    \tfor(; j <= n && A[j] < x; j++){\n            if(i == 1) continue;\n            P[++w] = mp(A[j] - p, x - A[j]);\n            W[w] = P[w].nd;\n        }\n    \tp = x;\n    }    \n    \n    sort(P+1 , P+w+1);\n    sort(W+1 , W+w+1);\n    int ans = 1;\n    for(int i=w; i>=1; i--){\n        if(P[i] == P[i+1]) continue;\n        int ind = lower_bound(W+1 , W+w+1 , P[i].nd) - W;\n\n        int dp = (ss + qry(n-ind)) % mod;\n        up(n-ind+1, dp);\t\n        \n        if(P[i].st != P[i-1].st) ans = (ans + dp) % mod;\n    }\n    \n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 100010\n#define INF 1000000817\n#define mo 1000000007\n#define ll long long\nint n,m;\nint a[N],b[N];\nint nq;\npair<int,int> q[N];\nint p[N],np;\nint f[N];\nint t[N];\nvoid add(int x,int c){\n\tfor (;x<=np;x+=x&-x)\n\t\t(t[x]+=c)%=mo;\n}\nint query(int x){\n\tll r=0;\n\tfor (;x;x-=x&-x)\n\t\tr+=t[x];\n\treturn r%mo;\n}\nint main(){\n//\tfreopen(\"in.txt\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;++i)\n\t\tscanf(\"%d\",&b[i]);\n\tfor (int i=1;i<=m;++i)\n\t\tscanf(\"%d\",&a[i]);\n\tfor (int i=1,j=1;i<=n;++i){\n\t\tfor (;j<=m && a[j]<b[i];++j);\n\t\tif (j==m+1 || j==1) continue;\n\t\tq[++nq]=make_pair(a[j]-b[i],b[i]-a[j-1]);\n\t}\n\tfor (int i=1;i<=nq;++i)\n\t\tp[++np]=q[i].second;\n\tsort(p+1,p+np+1);\n\tnp=unique(p+1,p+np+1)-p-1;\n\tfor (int i=1;i<=nq;++i)\n\t\tq[i].second=-(lower_bound(p+1,p+np+1,q[i].second)-p);\n\tsort(q+1,q+nq+1),nq=unique(q+1,q+nq+1)-q-1;\n//\tfor (int i=1;i<=nq;++i)\n//\t\tprintf(\"%d %d\\n\",q[i].first,q[i].second);\n\tfor (int i=1;i<=nq;++i){\n\t\tf[i]=1+query((-q[i].second)-1);\n\t\tadd(-q[i].second,f[i]);\n\t}\n\tll ans=1;\n\tfor (int i=1;i<=nq;++i)\n\t\tans+=f[i];\n\tans%=mo;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\nusing namespace std;\n#define vel vector<long long>\n#define vvel vector<vel>\n#define veb vector<bool>\n#define int long long\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define fin(fl,s) if(fl){cout<<s<<endl;return 0;}\nlong long p = 1000000007;\nvel kai(200001, 1);\nvel ink(200001, 1);\nint le = (1 << 20) + 1;\nvel BIT(le, 0);\ntemplate<typename T>\nV<T> uni(V<T> &list) {\n\tif (list.size() == 0) { return list; }\n\tsort(list.begin(), list.end());\n\tV<T> ql(1, list[0]);\n\trep(i, list.size() - 1) {\n\t\tif (list[i] != list[i + 1]) { ql.push_back(list[i + 1]); }\n\t}\n\tlist = ql;\n\treturn ql;\n}\nvoid update(int i,int pl) {\n\twhile (i <le) {\n\t\tBIT[i] += pl; BIT[i] %= p;\n\t\ti += (i & (-i));\n\t}\n}\nint cal(int i) {\n\tint ans = 0;\n\twhile (i > 0) {\n\t\tans += BIT[i];\n\t\ti -= (i & (-i));\n\t}\n\treturn ans;\n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, 200000) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, 200001) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nint per(int n, int r) {\n\tint ans = kai[n] * ink[n - r];\n\tans %= p;\n\treturn ans;\n}\nsigned main() {\n\tint n, m; cin >> n >> m;\n\tvel x(n); vel y(m);\n\tvel l(0); vel r(0);\n\trep(i, n) { cin >> x[i]; }\n\trep(i, m) { cin >> y[i]; }\n\trep(i, n) {\n\t\tauto itr = upper_bound(y.begin(), y.end(), x[i]);\n\t\tif (itr != y.begin() and itr!=y.end()) {\n\t\t\tr.push_back(*itr - x[i]);\n\t\t\titr--;\n\t\t\tl.push_back(x[i] - *itr);\n\t\t}\n\t}\n\tint sz = l.size();\n\tV<pin> pa(sz);\n\trep(i, sz) { pa[i] = mkp(r[i], -l[i]); }\n\tuni(pa);\n\tsz = pa.size();\n\tvel v(sz);\n\trep(i, sz) { v[i] = -pa[i].second; }\n\tvel mv = v; uni(mv);\n\trep(i, sz) { v[i] = lower_bound(mv.begin(), mv.end(), v[i]) - mv.begin(); }\n\trep(i, sz) {\n\t\tint cm = cal(v[i])+1;\n\t\tupdate(v[i] + 1, cm%p);\n\t}\n\tcout << (BIT[le - 1]+1)%p << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+50,mo=1e9+7;\ninline int gi() {\n  char ch=getchar(); int q=0,x=0;\n  while(ch<'0'||ch>'9') q=(ch=='-'?1:q),ch=getchar();\n  while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n  return q?(-x):x;\n}\nint a[N],b[N],v[N],f[N],tot;\nstruct data{\n  int x,y;\n  bool operator < (const data &c)const{\n    return x==c.x?y>c.y:x<c.x;\n  }\n}w[N];\nvoid add(int x,int s){\n  while(x<=tot) (f[x]+=s)%=mo,x+=x&-x;\n  return;\n}\nint qry(int x){\n  int s=1;\n  while(x) (s+=f[x])%=mo,x-=x&-x;\n  return s;\n}\nint main(){\n  int n=gi(),m=gi();\n  for (int i=1; i<=n; ++i) a[i]=gi();\n  for (int i=1; i<=m; ++i) b[i]=gi();\n  for (int i=1,j=1; i<=n; ++i){\n    while(j<m&&a[i]>b[j]) ++j;\n    if (j>1&&a[i]<b[j]) w[++tot]=(data){a[i]-b[j-1],b[j]-a[i]};\n  }\n  sort(w+1,w+tot+1);\n  for (int i=1; i<=tot; ++i)\n    v[i]=w[i].y;\n  sort(v+1,v+tot+1);\n  for (int i=1; i<=tot; ++i){\n    if (w[i].x==w[i-1].x&&w[i].y==w[i-1].y) continue;\n    int t=lower_bound(v+1,v+tot+1,w[i].y)-v;\n    add(t,qry(t-1));\n  }\n  cout<<qry(tot);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MN 100000\n#define MOD 1000000007\nint x[MN+5],y[MN+5],c[MN+5],cn,s[MN+5],p[MN+5],pn;\nvector< pair<int,int> > V;\ninline void add(int x,int y){for(++x;x<=MN+1;x+=x&-x)s[x]=(s[x]+y)%MOD;}\ninline int sum(int x){int r=0;for(++x;x;x-=x&-x)r=(r+s[x])%MOD;return r;}\nint main()\n{\n\tint n,m,i,j;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;++i)scanf(\"%d\",&x[i]);\n\tfor(i=1;i<=m;++i)scanf(\"%d\",&y[i]);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tint t=lower_bound(y+1,y+m+1,x[i])-y;\n\t\tif(t>=2&&t<=m)V.push_back(make_pair(x[i]-y[t-1],y[t]-x[i]));\n\t}\n\tsort(V.begin(),V.end());\n\tfor(i=0;i<V.size();++i)c[++cn]=V[i].second;\n\tsort(c+1,c+cn+1);cn=unique(c+1,c+cn+1)-c-1;add(0,1);\n\tfor(i=0;i<V.size();i=j)\n\t{\n\t\tfor(j=i,pn=0;j<V.size()&&V[i].first==V[j].first;++j)p[++pn]=V[j].second;\n\t\tpn=unique(p+1,p+pn+1)-p-1;\n\t\tfor(i=pn;i;--i)p[i]=lower_bound(c+1,c+cn+1,p[i])-c,add(p[i],sum(p[i]-1));\n\t}\n\tprintf(\"%d\",sum(cn));\n}"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        (wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nint n, m;\nint a[101010];\nint b[101010];\nvector<pair<LL, LL>> c;\nconst int mod = 1e9 + 7;\n\nstruct BIT {\n\tvector<LL> bit;\n\tBIT(LL n) {\n\t\tbit.resize(n + 10);\n\t\tfor (int i = 0; i < n + 10; i++)bit[i] = 0;\n\t}\n\t//[0,i)\n\tLL sum(int i) {\n\t\tLL s = 0;\n\t\tfor (int x = i - 1; x >= 0; x = (x&(x + 1)) - 1) {\n\t\t\t(s += bit[x]) % mod;\n\t\t}\n\t\treturn s;\n\t}\n\tvoid add(int a, LL w) {\n\t\tfor (int x = a; x < bit.size(); x |= x + 1) {\n\t\t\t(bit[x] += w) % mod;\n\t\t}\n\t}\n};\n\nbool calc(pair<LL, LL> p, pair<LL, LL> q) {\n\tif (p.first == q.first)return p.second > q.second;\n\treturn p < q;\n}\n\nint main() {\n\tcin >> n >> m;\n\tREP(i, n)cin >> a[i];\n\tREP(i, m)cin >> b[i];\n\tREP(i, n) {\n\t\tint it = lower_bound(b, b + m, a[i]) - b;\n\t\tif (it == 0 || it == m)continue;\n\t\tc.emplace_back(make_pair(b[it] - a[i],a[i] - b[it - 1]));\n\t}\n\tsort(ALL(c));\n\tUNIQUE(c);\n\tsort(ALL(c), calc);\n\tvector<LL> d;\n\tint N = c.size(), id = 1;\n\tREP(i, N)d.emplace_back(c[i].second);\n\tsort(ALL(d));\n\tUNIQUE(d);\n\tmap<LL, LL>mp;\n\tREP(i, d.size()) {\n\t\tif (mp.find(d[i]) == mp.end()) {\n\t\t\tmp[d[i]] = id;\n\t\t\tid++;\n\t\t}\n\t}\n\tREP(i, N)c[i].second = mp[c[i].second];\n\tBIT bit(n);\n\tbit.add(0, 1);\n\tLL ans = 1;\n\tREP(i, N) {\n\t\tLL t = bit.sum(c[i].second);\n\t\tbit.add(c[i].second, t);\n\t\tans += t;\n\t\tans %= mod;\n\t}\n\tcout << ans%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace TYC\n{\n\ttypedef long long ll;\n\n\tconst int N = 2e5 + 5, mod = 1e9 + 7;\n\n\tint n, m, cnt, A[N], B[N], R[N], X[N], Y[N], C[N];\n\tvector<int> P[N];\n\n\tinline int read()\n\t{\n\t\tint x = 0, f = 0, ch = getchar();\n\t\twhile (!isdigit(ch))\n\t\t\tf |= (ch == '-'), ch = getchar();\n\t\twhile (isdigit(ch))\n\t\t\tx = x * 10 + ch - '0', ch = getchar();\n\t\treturn f ? -x : x;\n\t}\n\n\tvoid init()\n\t{\n\t\tint num = 0;\n\t\tfor (int i = 1, j = 1; i <= n; i++)\n\t\t\tif (B[1] < A[i] && A[i] < B[m])\n\t\t\t{\n\t\t\t\twhile (B[j + 1] <= A[i])\n\t\t\t\t\tj++;\n\t\t\t\tint x = A[i] - B[j], y = B[j + 1] - A[i];\n\t\t\t\tif (x && y)\n\t\t\t\t{\n\t\t\t\t\tR[++cnt] = X[++num] = x;\n\t\t\t\t\tR[++cnt] = Y[num] = y;\n\t\t\t\t}\n\t\t\t}\n\t\tsort(R + 1, R + 1 + cnt);\n\t\tcnt = unique(R + 1, R + 1 + cnt) - R - 1;\n\t\tfor (int i = 1; i <= num; i++)\n#define id(x) (lower_bound(R + 1, R + 1 + cnt, x) - R)\n\t\t\tP[id(X[i])].push_back(id(Y[i]));\n#undef id\n\t\tfor (int i = 1; i <= cnt; i++)\n\t\t{\n\t\t\tsort(P[i].begin(), P[i].end(), greater<int>());\n\t\t\tP[i].resize(unique(P[i].begin(), P[i].end()) - P[i].begin());\n\t\t}\n\t\t++cnt;\n\t\tP[cnt].push_back(cnt);\n\t}\n\n#define lowbit(x) (x & (-x))\n\n\tinline int query(int x)\n\t{\n\t\tint sum = 0;\n\t\tfor (; x; x -= lowbit(x))\n\t\t\tsum = (sum + C[x]) % mod;\n\t\treturn sum;\n\t}\n\n\tinline void add(int x, const int v)\n\t{\n\t\tfor (; x <= cnt; x += lowbit(x))\n\t\t\tC[x] = (C[x] + v) % mod;\n\t}\n\n#undef lowbit\n\n\tvoid work()\n\t{\n\t\tn = read(), m = read();\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tA[i] = read();\n\t\tfor (int i = 1; i <= m; i++)\n\t\t\tB[i] = read();\n\t\tinit();\n\t\tfor (int i = 1; i <= cnt; i++)\n\t\t\tfor (int p : P[i])\n\t\t\t\tadd(p, (query(p - 1) + 1) % mod);\t\n\t\tprintf(\"%d\\n\", (query(cnt) - query(cnt - 1) + mod) % mod);\n\t}\n}\n\nint main()\n{\n\tTYC::work();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nvi seg;\nll N;\nvoid init(ll n){\n    N=1;\n    while(N<n)N*=2;\n    seg=vi(N*2-1);\n}\nvoid add(ll i,ll x){\n    i=N+i-1;\n    seg[i]+=x;\n    seg[i]%=mod;\n    while(i>0){\n        i=(i-1)/2;\n        seg[i]=seg[i*2+1]+seg[i*2+2];\n    }\n}\nll getsum(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b)return seg[k];\n    ll c1=getsum(a,b,k*2+1,l,(l+r)/2);\n    ll c2=getsum(a,b,k*2+2,(l+r)/2,r);\n    return c1+c2;\n}\nint main(){\n    ll n,m;cin>>n>>m;\n    vi x(n),y(m);\n    rep(i,n)cin>>x[i];\n    rep(i,m)cin>>y[i];\n    vp s;\n    rep(i,n){\n        if(x[i]<y[0]||x[i]>y[m-1])continue;\n        ll k=lb(y,x[i]);\n        s.eb(y[k]-x[i],y[k-1]-x[i]);\n    }\n    sort(all(s));s.erase(unique(all(s)));\n    //outvp(s);\n    n=s.size();\n    vi v(n);\n    rep(i,n)v[i]=-s[i].se;\n    vi t=v;sort(all(t));unique(all(t));\n    //outv(v);\n    vi id(n);\n    rep(i,n)id[i]=lb(t,v[i])+1;\n    //outv(id);\n    init(t.size()+1);\n    add(0,1);\n    rep(i,n){\n        add(id[i],getsum(0,id[i],0,0,N)%mod);\n        //outv(seg);\n    }\n    out(getsum(0,N,0,0,N)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int mod=1000000007;\n\ninline int qpow(int a,int b) {\n    int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod)\n        if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nint main() {\n    int n=read(),m=read();\n    printf(\"%d\\n\",qpow(n-1,m-1));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#define N 100001\n#define p 1000000007\nusing namespace std;\ninline int mod(int x){return x<p?x:x-p;}\nint a[N],b[N],c[N],d[N],e[N],f[N],i,j,m,n,s,t,x;\ninline bool cmpd(int u,int v){return d[u]<d[v];}\ninline bool cmpc(int u,int v){return c[u]==c[v]?d[v]<d[u]:c[u]<c[v];}\ninline void add(int u,int v){while(u<=j)f[u]=mod(f[u]+v),u+=u&-u;}\ninline int sum(int u)\n{\n    int v=0;\n    while(u)v=mod(v+f[u]),u^=u&-u;\n    return v;\n}\nint main()\n{\n    scanf(\"%d%d\",&m,&n);\n    for(i=1;i<=m;i++)scanf(\"%d\",a+i);\n    for(i=1;i<=n;i++)scanf(\"%d\",b+i);\n    for(i=1,j=0;i<=m;j&&j<n?c[++t]=a[i]-b[j],d[t]=b[j+1]-a[i],e[t]=t:0,i++)while(j<n&&b[j+1]<a[i])j++;\n    for(sort(e+1,e+t+1,cmpd),i=1,j=0;i<=t;i++)d[e[i]]=d[e[i]]!=j?j=d[e[i]],d[e[i-1]]+1:d[e[i-1]];\n    for(j=d[e[t]],sort(e+1,e+t+1,cmpc),i=x=1;i<=t;i++)if(c[e[i]]!=c[e[i-1]]||d[e[i]]!=d[e[i-1]])s=mod(sum(d[e[i]]-1)+1),x=mod(x+s),add(d[e[i]],s);\n    return 0&printf(\"%d\\n\",x);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\ntypedef long long LL;\nconst int Mod = 1000000007;\nconst int MN = 100005;\n\nint N, M, A[MN], B[MN];\nint K, p[MN], x[MN], y[MN], cx, cy;\n\ninline void Compress(int *a, int &c) {\n\tstatic int d[MN];\n\tfor (int i = 1; i <= K; ++i) d[++c] = a[i];\n\tstd::sort(d + 1, d + c + 1), c = std::unique(d + 1, d + c + 1) - d - 1;\n\tfor (int i = 1; i <= K; ++i) a[i] = std::lower_bound(d + 1, d + c + 1, a[i]) - d;\n}\ninline void Init() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 1; i <= N; ++i) scanf(\"%d\", &A[i]);\n\tfor (int i = 1; i <= M; ++i) scanf(\"%d\", &B[i]);\n\tint j = 0;\n\tfor (int i = 1; i <= N; ++i) {\n\t\twhile (j < M && B[j + 1] < A[i]) ++j;\n\t\tif (j >= 1 && j < M) {\n\t\t\t++K, p[K] = K;\n\t\t\tx[K] = A[i] - B[j];\n\t\t\ty[K] = B[j + 1] - A[i];\n\t\t}\n\t}\n\tCompress(x, cx), Compress(y, cy);\n\tstd::sort(p + 1, p + K + 1, [](int a, int b) {\n\t\treturn x[a] == x[b] ? y[a] > y[b] : x[a] < x[b];\n\t});\n\tK = std::unique(p + 1, p + K + 1, [](int a, int b) {\n\t\treturn x[a] == x[b] && y[a] == y[b];\n\t}) - p - 1;\n}\n\nint bit[MN];\ninline void Add(int i, int v) { for (; i <= cy + 1; i += i & -i) bit[i] -= (bit[i] += v) >= Mod ? Mod : 0; }\ninline int Qur(int i) { int s = 0; for (; i; i -= i & -i) s -= (s += bit[i]) >= Mod ? Mod : 0; return s; }\n\nint main() {\n\tInit();\n\tAdd(1, 1);\n\tfor (int i = 1; i <= K; ++i) {\n\t\tint pos = y[p[i]];\n\t\tAdd(pos + 1, Qur(pos));\n\t}\n\tprintf(\"%d\\n\", Qur(cy + 1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1e9 + 7;\n\nvoid compress_coordinate(VI &x){\n    int n = x.size();\n    VI xc;\n    xc.push_back(-1);\n    REP(i,n) xc.push_back(x[i]);\n    sort(ALL(xc));\n    xc.erase(unique(ALL(xc)), xc.end());\n    REP(i,n) x[i] = find(ALL(xc), x[i]) - xc.begin();\n}\n\nstruct BIT{\n    int n;\n    VL bit;\n\n    BIT(){}\n    BIT(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void init(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void add(int i, ll x){\n        i++;\n        while (i <= n){\n            (bit[i] += x) %= mod;\n            i += i & -i;\n        }\n    }\n\n    // [0, i]\n    ll sum(int i){\n        i++;\n        ll ret = 0;\n        while (i > 0){\n            (ret += bit[i]) %= mod;\n            i -= i & -i;\n        }\n        return ret;\n    }\n\n    // [l, r)\n    ll sum(int l, int r){\n        if (l >= r) return 0;\n        return (sum(r-1) - sum(l-1) + mod) % mod;\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VI x(n), y(m);\n    REP(i,n) x[i] = in();\n    REP(i,m) y[i] = in();\n    VI l, r;\n    int k = 0;\n    REP(i,n){\n        while (k < m && x[i] >= y[k]) k++;\n        if (k == 0 || k == m) continue;\n        l.push_back(x[i] - y[k-1]);\n        r.push_back(y[k] - x[i]);\n    }\n\n    n = l.size();\n\n    // compress_coordinate(l);\n    // compress_coordinate(r);\n\n    vector<P> pa(n);\n    REP(i,n) pa[i] = P(l[i], -r[i]);\n    sort(ALL(pa));\n\n    VVI p(n+1);\n    REP(i,n){\n        p[pa[i].first].push_back(-pa[i].second);\n    }\n\n    BIT bit(n+1);\n    bit.add(0, 1);\n    REP(i,n+1){\n        REP(j,p[i].size()){\n            if (j > 0 && p[i][j] == p[i][j-1]) continue;\n            int x = p[i][j];\n            bit.add(x, bit.sum(x - 1));\n        }\n    }\n\n    ll ans = bit.sum(n);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e18+1e18;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\ntemplate<typename T>\nstruct Segment_Tree {\n\ttypedef function<T(T, T)> F;\n\n\tll n;\n\tF f;//モノイドとしての演算(最小値、和　など)\n\tT unit;//単位元\n\n\tll size;\n\tvector<T> seg;\n\n\tSegment_Tree(ll n0, F f0, T unit0) {\n\t\tn = n0;\n\t\tf = f0;\n\t\tunit = unit0;\n\n\t\tsize = 1;\n\t\twhile (size < n) {\n\t\t\tsize *= 2;\n\t\t}\n\t\tseg.assign(2 * size, unit);\n\t}\n\n\n\tvoid update(ll k, T x) {//k番目の要素をxに更新\n\t\tk += size - 1;\n\t\tseg[k] = x;\n\t\twhile (k > 1) {\n\t\t\tk /= 2;\n\t\t\tseg[k] = f(seg[2 * k], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\n\n\tT query_prep(ll a, ll b, ll k, ll l, ll r) {//[a,b)とkに対応する区間[l,r)の共通部分でクエリ\n\t\tif (b <= l || a >= r) { return unit; }\n\t\tif (a <= l && r <= b) { return seg[k]; }\n\n\t\tT v1 = query_prep(a, b, 2 * k, l, (l + r) / 2);\n\t\tT v2 = query_prep(a, b, 2 * k + 1, (l + r) / 2, r);\n\t\treturn f(v1, v2);\n\n\t}\n\n\tT query(ll a, ll b) {\n\t\treturn query_prep(a, b, 1, 1, size + 1);\n\t}\n\n};\n\n\n\nint main() {\n\tll N, M;\n\tcin >> N >> M;\n\n\tvll x(N);\n\trep(i, N)cin >> x[i];\n\tvll y(M);\n\trep(i, M)cin >> y[i];\n\n\tvector<pair<ll, ll>> p;\n\n\trep(i, N) {\n\t\tauto itr = upper_bound(y.begin(), y.end(), x[i]);\n\t\tif (itr == y.begin() || itr == y.end()) { continue; }\n\n\t\tll k = *itr - x[i];\n\t\tll l = x[i] - *(--itr);\n\n\t\tp.push_back({ k,-l });\n\t\t//cout << k << l << endl;\n\t}\n\n\tsort(p.begin(), p.end());\n\n\tvector<pair<ll, ll>> q;\n\trep(i, p.size()) {\n\t\tif (i == 0 || p[i] != p[i - 1]) {\n\t\t\tll u = q.size();\n\t\t\tq.push_back({ -p[i].second,-u });\n\t\t}\n\t}\n\tsort(q.begin(), q.end());\n\tll K = q.size();\n\t//cout << K << endl;\n\n\t\n\n\tvll s(K);\n\trep(i, K) { s[-q[i].second] = i+1; }\n\n\t//rep(i, K)cout << s[i] << endl;\n\n\tSegment_Tree<mint> sg(K, [](mint a, mint b) {return a + b; }, 0);\n\n\trep(i, K) {\n\t\tll j = s[i];\n\t\tmint t = sg.query(1, j);\n\t\tsg.update(j, t + 1);\n\t}\n\n\tmint ans = sg.query(1, K + 1) + 1;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = (1 << 30) - 1;                    // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\n// ------------>8------------ SegmentTree ------------>8------------\n\nnamespace Monoid {\n\ttemplate <class T> class sum {\n\tpublic:\n\t\tusing value_type = T;\n\t\tinline static T operation(const T& a, const T& b) { return (a + b) % MOD; }\n\t\tinline static T identity() { return T(0); }\n\t};\n\ttemplate <class T> class max {\n\tpublic:\n\t\tusing value_type = T;\n\t\tinline static T operation(const T& a, const T& b) { return (a < b) ? b : a; }\n\t\tinline static T identity() { return std::numeric_limits<T>::lowest(); }\n\t};\n\ttemplate <class T> class min {\n\tpublic:\n\t\tusing value_type = T;\n\t\tinline static T operation(const T& a, const T& b) { return (a < b) ? a : b; }\n\t\tinline static T identity() { return std::numeric_limits<T>::max(); }\n\t};\n\n\tclass MONOID {\n\tpublic:\n\t\tstruct S { int x; };\n\t\tusing value_type = S;\n\t\tinline static S operation(const S& l, const S& r) { return S{ l.x + r.x }; }\n\t\tinline static S identity() { return S{ 0 }; }\n\t};\n}\ntemplate <class Monoid>\nclass SegmentTree {\nprivate:\n\tusing T = typename Monoid::value_type;\n\tint ARY_SIZE;\n\tstd::vector<T> ary;\n\n\tvoid init(int n) {\n\t\twhile (ARY_SIZE < n) ARY_SIZE <<= 1;\n\t\tary.resize(ARY_SIZE << 1, Monoid::identity());\n\t}\npublic:\n\tSegmentTree(int n) : ARY_SIZE(1) { init(n); }\n\tSegmentTree(std::vector<T>& a) : ARY_SIZE(1) {\n\t\tinit(a.size());\n\t\tstd::copy(a.begin(), a.end(), ary.begin() + ARY_SIZE);\n\t\tfor (int i = ARY_SIZE - 1; i >= 1; --i) {\n\t\t\tary[i] = Monoid::operation(ary[i << 1], ary[(i << 1) + 1]);\n\t\t}\n\t}\n\n\t// -- a[i] = val;\n\tinline void update(int i, T val) {\n\t\ti += ARY_SIZE;\n\t\tary[i] = val;\n\t\twhile (i > 1) {\n\t\t\ti >>= 1;\n\t\t\tary[i] = Monoid::operation(ary[i << 1], ary[(i << 1) + 1]);\n\t\t}\n\t}\n\t// -- a[i] += val;\n\tinline void add(int i, T val) {\n\t\tupdate(i, ary[i + ARY_SIZE] + val);\n\t}\n\t// -- [l, r)\n\tinline T query(int l, int r) {\n\t\tif (l >= r) return Monoid::identity();\n\t\tT vl = Monoid::identity(), vr = Monoid::identity();\n\t\tfor (l += ARY_SIZE, r += ARY_SIZE; l != r; l >>= 1, r >>= 1) {\n\t\t\tif (l & 1) vl = Monoid::operation(vl, ary[l++]);\n\t\t\tif (r & 1) vr = Monoid::operation(ary[--r], vr);\n\t\t}\n\t\treturn Monoid::operation(vl, vr);\n\t}\n\tT operator[](int i) { return ary[i + ARY_SIZE]; }\n\n\tvoid debugShow() {\n\t\tfor (int i = ARY_SIZE; i < ARY_SIZE << 1; ++i) std::cerr << ary[i] << \" \";\n\t\tstd::cerr << \"\\n\";\n\t}\n};\n// ------------8<------------ SegmentTree ------------8<------------\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tVEC(int, x, n);\n\tVEC(int, y, m);\n\n\tV<PAIR> a;\n\n\t{\n\t\tstd::map<PAIR, bool> map;\n\t\tREP(i, n) {\n\t\t\tauto it = std::upper_bound(ALL(y), x[i]);\n\t\t\tint p = it - y.begin();\n\t\t\tif (p - 1 < 0) continue;\n\t\t\tif (p >= m) continue;\n\t\t\tint l = x[i] - y[p - 1];\n\t\t\tint r = y[p] - x[i];\n\t\t\tif (map.count(PAIR(l, r))) continue;\n\t\t\tmap[PAIR(l, r)];\n\t\t\ta.emplace_back(l, r);\n\t\t}\n\t}\n\n\tint sz = 0;\n\t{\n\t\tstd::map<int, int> map;\n\t\tfor (auto& p : a) map[p.second];\n\t\tfor (auto& p : map) p.second = sz++;\n\t\tfor (auto& p : a) p.second = map[p.second];\n\t}\n\tstd::sort(ALL(a), [&](PAIR& l, PAIR& r) {\n\t\tif (l.first == r.first) return l.second > r.second;\n\t\treturn l.first < r.first;\n\t});\n\n\tSegmentTree<Monoid::sum<int>> st(sz);\n\tfor (auto& p : a) {\n\t\tint v = p.second;\n\t\tst.add(v, st.query(0, v) + 1);\n\t}\n\tint ans = st.query(0, sz) + 1;\n\tans %= MOD;\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of God\n\n#include<bits/stdc++.h>\n\n#define F first\n#define S second\n#define PB push_back\n#define sz(s) int((s).size())\n#define bit(n,k) (((n)>>(k))&1)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int maxn=1e5+10,mod=1e9+7;\nconst ll inf=1e18;\n\nint a[maxn],b[maxn],dp[maxn],sm[maxn],tot;\nmap<int,vector<pii> >mp;\nvector<int>v;\nset<pii>s;\n\nvoid add(int id,int num){\n    tot=(tot+num)%mod;\n    while(id<maxn){\n\tsm[id]=(sm[id]+num)%mod;\n\tid+=(id & -id);\n    }\n}\nint ask(int id){\n    int ans=0;\n    while(id>0){\n\tans=(ans+sm[id])%mod;\n\tid-=(id & -id);\n    }\n    return ans;\n}\n\nint main(){\n    int n,m;cin>>n>>m;\n    for(int i=0;i<n;i++)\n\tcin>>a[i];\n    for(int i=0;i<m;i++)\n\tcin>>b[i];\n    for(int i=0;i<n;i++){\n\tif(a[i]<b[0] || b[m-1]<a[i])continue;\n\tint id=upper_bound(b,b+m,a[i])-b;\n\tint A=a[i]-b[id-1],B=b[id]-a[i];\n\tif(s.count({A,B})) continue;\n\ts.insert({A,B});\n\tmp[A].PB({B,i});\n\tv.PB(B);\n    }\n    mp[-1].PB({-1,n});\n    v.PB(-1);\n    sort(v.begin(),v.end());\n    v.resize(unique(v.begin(),v.end())-v.begin());\n    tot=1;\n    for(auto it=mp.rbegin();it!=mp.rend();it++){\n\tvector<pii>&vec=it->S;\n\tfor(pii p:vec){\n\t    p.F=lower_bound(v.begin(),v.end(),p.F)-v.begin()+1;\n\t    dp[p.S]=(tot-ask(p.F))%mod;\n\t}\n\tfor(pii p:vec){\n\t    p.F=lower_bound(v.begin(),v.end(),p.F)-v.begin()+1;\n\t    add(p.F,dp[p.S]);\n\t}\n    }\n    if(dp[n]<0) dp[n]+=mod;\n    cout<<dp[n]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 998244353\nusing namespace std;\nint read();\nvoid Add(int &x, int y) { (x += y) >= mod ? x -= mod : x; }\nint n, m;\nint a[100005], b[100005];\nstruct P {\n    int x, y;\n} p[100005];\nbool cmp(P a, P b) { return a.x == b.x ? a.y > b.y : a.x < b.x; }\nint st[100005], top, cnt;\nstruct Bit {\n    int s[100005];\n    void add(int p, int v) {\n        for (; p <= top; p += p & -p) Add(s[p], v);\n    }\n    int qry(int p) {\n        int rt = 0;\n        for (; p; p -= p & -p) Add(rt, s[p]);\n        return rt;\n    }\n} bit;\nint main() {\n    n = read(), m = read();\n    for (int i = 1; i <= n; ++i) a[i] = read();\n    for (int i = 1; i <= m; ++i) b[i] = read();\n    for (int i = 1, j = 1; i <= n; ++i) {\n        if (a[i] < b[1]) continue;\n        if (a[i] > b[m]) break;\n        while (a[i] > b[j + 1]) ++j;\n        p[++cnt].x = a[i] - b[j], st[cnt] = p[cnt].y = b[j + 1] - a[i];\n    }\n    sort(st + 1, st + 1 + cnt), top = unique(st + 1, st + 1 + cnt) - st - 1;\n    sort(p + 1, p + 1 + cnt, cmp);\n    for (int i = 1; i <= cnt; ++i) {\n        p[i].y = lower_bound(st + 1, st + 1 + top, p[i].y) - st;\n        if (p[i].x == p[i - 1].x && p[i].y == p[i - 1].y) continue;\n        bit.add(p[i].y, bit.qry(p[i].y - 1) + 1);\n    }\n    printf(\"%d\\n\", (bit.qry(top) + 1) % mod);\n    return 0;\n}\nconst int _SIZE = 1 << 22;\nchar ibuf[_SIZE], *iS = ibuf, *iT = ibuf;\n#define gc                                                         \\\n    (iS == iT ? iT = ((iS = ibuf) + fread(ibuf, 1, _SIZE, stdin)), \\\n     (iS == iT ? EOF : *iS++) : *iS++)\nint read() {\n    int x = 0, f = 1;\n    char c = gc;\n    while (!isdigit(c)) f = (c == '-') ? -1 : f, c = gc;\n    while (isdigit(c)) x = x * 10 + c - '0', c = gc;\n    return x * f;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nstruct SegTree{\n\tint size;\n\tvector<llint> seg;\n\t\n\tSegTree(){}\n\tSegTree(int size){\n\t\tthis->size = size;\n\t\tseg.resize(1<<(size+1));\n\t}\n\t\n\tvoid init()\n\t{\n\t\tfor(int i = 0; i < (1<<(size+1)); i++) seg[i] = 0;\n\t}\n\t\n\tvoid update(int i, llint val)\n\t{\n\t\ti += (1 << size);\n\t\tseg[i] = val;\n\t\twhile(i > 1){\n\t\t\ti /= 2;\n\t\t\tseg[i] = (seg[i*2] + seg[i*2+1]) % mod;\n\t\t}\n\t}\n\n\tllint query(int a, int b, int k, int l, int r)\n\t{\n\t\tif(b < l || r < a) return 0;\n\t\tif(a <= l && r <= b) return seg[k];\n\t\tllint lval = query(a, b, k*2, l, (l+r)/2);\n\t\tllint rval = query(a, b, k*2+1, (l+r)/2+1, r);\n\t\treturn (lval + rval) % mod;\n\t}\n\tllint query(int a, int b)\n\t{\n\t\treturn query(a, b, 1, 0, (1<<size)-1);\n\t}\n};\n\nllint n, m;\nllint p[100005], q[100005];\nvector<llint> vecx, vecy;\nvector<llint> compX, compY;\nvector<llint> vec[100005];\nSegTree seg(17);\n\nvoid comp(vector<llint> &vec, vector<llint> &compX)\n{\n\tfor(int i = 0; i < vec.size(); i++) compX.push_back(vec[i]);\n\tsort(compX.begin(), compX.end());\n\tcompX.erase(unique(compX.begin(), compX.end()), compX.end());\n\tfor(int i = 0; i < vec.size(); i++) vec[i] = lower_bound(compX.begin(), compX.end(), vec[i]) - compX.begin()+1;\n}\n\nint main(void)\n{\n\tcin >> n >> m;\n\tfor(int i = 0; i < n; i++) cin >> p[i];\n\tfor(int i = 0; i < m; i++) cin >> q[i];\n\t\n\tllint l, r;\n\tfor(int i = 0; i < n; i++){\n\t\tl = upper_bound(q, q+m, p[i])-q-1, r = l+1;\n\t\tif(l >= 0 && r < m){\n\t\t\tvecx.push_back(p[i] - q[l]);\n\t\t\tvecy.push_back(q[r] - p[i]);\n\t\t}\n\t}\n\t\n\tcomp(vecx, compX);\n\tcomp(vecy, compY);\n\tllint H = compY.size(), W = compX.size();\n\t\n\tfor(int i = 0; i < vecx.size(); i++) vec[vecy[i]].push_back(vecx[i]);\n\tfor(int i = 1; i <= H; i++){\n\t\tsort(vec[i].rbegin(), vec[i].rend());\n\t\tvec[i].erase(unique(vec[i].begin(), vec[i].end()), vec[i].end());\n\t}\n\t\n\tseg.update(0, 1);\n\tfor(int i = 1; i <= H; i++){\n\t\tfor(int j = 0; j < vec[i].size(); j++){\n\t\t\tseg.update(vec[i][j], seg.query(0, vec[i][j]));\n\t\t}\n\t}\n\tllint ans = seg.query(0, W);\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n\tint operator()(long long x) const\n\t{\n\t\treturn x ^ (x >> 32);\n\t}\n};\n\ntemplate<typename T> using orderedset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT normalize(T x, U mod = 1000000007)\n{\n\treturn (((x % mod) + mod) % mod);\n}\nlong long randomizell(long long mod)\n{\n\treturn ((1ll << 45) * rand() + (1ll << 30) * rand() + (1ll << 15) * rand() + rand()) % mod;\n}\nint randomize(int mod)\n{\n\treturn ((1ll << 15) * rand() + rand()) % mod;\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 100013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N, M, P, Q;\nint A[MAXN], B[MAXN];\nvector<pii> arr;\nvector<int> compress;\nvector<int> events[MAXN];\nint dp[MAXN];\nint ans;\n\nint fen[MAXN];\nvoid update(int idx, int v)\n{\n\tfor (int e = idx + 1; e <= Q + 5; e += e & (-e))\n\t{\n\t\tfen[e] += v; if (fen[e] > INF) fen[e] -= INF;\n\t}\n\treturn;\n}\nint query(int idx)\n{\n\tint res = 0;\n\tfor (int e = idx + 1; e > 0; e -= e & (-e))\n\t{\n\t\tres += fen[e]; if (res > INF) res -= INF;\n\t}\n\treturn res;\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\tsrand(time(0));\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// if (fopen(\"input.in\", \"r\"))\n\t// {\n\t// \tfreopen (\"input.in\", \"r\", stdin);\n\t// \tfreopen (\"output.out\", \"w\", stdout);\n\t// }\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> A[i];\n\t}\n\tfor (int i = 0; i < M; i++)\n\t{\n\t\tcin >> B[i];\n\t}\n\tarr.reserve(N);\n\tint iter = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (A[i] < B[0] || A[i] > B[M - 1])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\twhile(iter < M && B[iter + 1] <= A[i])\n\t\t{\n\t\t\titer++;\n\t\t}\n\t\tarr.PB({A[i] - B[iter], B[iter + 1] - A[i]});\n\t\t// cerr << arr[i].fi << ' ' << arr[i].se << endl;\n\t}\n\tN = arr.size();\n\tif (N == 0)\n\t{\n\t\tcout << \"1\\n\";\n\t\treturn 0;\n\t}\n\tcompress.reserve(N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcompress.PB(arr[i].fi);\n\t}\n\tsort(compress.begin(), compress.end());\n\tcompress.erase(unique(compress.begin(), compress.end()), compress.end());\n\tP = compress.size();\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tarr[i].fi = LB(compress.begin(), compress.end(), arr[i].fi) - compress.begin() + 1;\n\t}\n\tcompress.clear();\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcompress.PB(arr[i].se);\n\t}\n\tsort(compress.begin(), compress.end());\n\tcompress.erase(unique(compress.begin(), compress.end()), compress.end());\n\tQ = compress.size();\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tarr[i].se = LB(compress.begin(), compress.end(), arr[i].se) - compress.begin() + 1;\n\t}\n\tsort(arr.begin(), arr.end());\n\tarr.erase(unique(arr.begin(), arr.end()), arr.end());\n\tN = arr.size();\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tevents[arr[i].fi].PB(arr[i].se);\n\t\t// cerr << arr[i].fi << ' ' << arr[i].se << endl;\n\t}\n\tupdate(0, 1);\n\tfor (int i = 1; i <= P; i++)\n\t{\n\t\tsort(events[i].begin(), events[i].end());\n\t\treverse(events[i].begin(), events[i].end());\n\t\tfor (int x : events[i])\n\t\t{\n\t\t\tupdate(x, query(x - 1));\n\t\t}\n\t}\n\tans = query(Q);\n\tcout << ans << '\\n';\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstruct node\n{\n\tint x,y,newy;\n\tbool operator < (const node &a)const\n\t{\n\t\tif (x!=a.x)\n\t\t\treturn x<a.x;\n\t\telse\n\t\t\treturn newy>a.newy;\n\t}\n};\nnode QQmove[1000001];\nint f[1000001],c[1000001],a[1000001],b[1000001],ans,res,len,n,m,useless;\nbool cmp(node u,node v)\n{\n\treturn u.y<v.y;\n}\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\nvoid add(int x,int d)\n{\n\tfor (;x<=n;x+=lowbit(x))\n\t\tc[x]+=d;\n\treturn;\n}\nint sum(int x)\n{\n\tans=0;\n\tfor (;x>=1;x-=lowbit(x))\n\t\tans+=c[x];\n\treturn ans;\n}\nint main()\n{\n\tint first,last,mid,front,back;\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;++i)\n\t\tcin>>a[i];\n\tfor (int i=1;i<=m;++i)\n\t\tcin>>b[i];\n\tsort(a+1,a+n+1);\n\tsort(b+1,b+n+1);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tfirst=1;\n\t\tlast=m;\n\t\tfront=0;\n\t\tback=m+1;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]>=b[mid])\n\t\t\t{\n\t\t\t\tfront=max(front,mid);\n\t\t\t\tfirst=mid+1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tlast=mid-1;\n\t\t}\n\t\tfirst=1;\n\t\tlast=m;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]<=b[mid])\n\t\t\t{\n\t\t\t\tback=min(back,mid);\n\t\t\t\tlast=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tfirst=mid+1;\n\t\t}\n\t\tif (front==0||back==m+1||b[front]==a[i]||b[back]==a[i])\n\t\t\tcontinue;\n\t\tQQmove[++len].x=a[i]-b[front];\n\t\tQQmove[len].y=b[back]-a[i];\n\t}\n\tsort(QQmove+1,QQmove+len+1,cmp);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tQQmove[i].newy=i-useless;\n\t\tif (QQmove[i].y==QQmove[i+1].y)\n\t\t\tuseless++;\n\t}\n\tsort(QQmove+1,QQmove+len+1);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tf[i]=sum(QQmove[i].newy-1)+1;\n\t\tadd(QQmove[i].newy,f[i]);\n\t}\n\tfor (int i=1;i<=len;++i)\n\t\tres+=f[i];\n\tcout<<res+1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int mod=1000000007;\ninline void add(int &x,int y){(x+=y)>=mod?x-=mod:0;}\ninline int pl(int x,int y){return (x+=y)>=mod?x-mod:x;}\nint n,m,x[100010],y[100010],p[100010];\nvector<int>line[100010];\nint len[100010];\nstruct seg\n{\n\tint ch[5000000][2],sum[5000000],tot,rt;\n\tvoid ins(int &k,int l,int r,int p,int w)\n\t{\n\t\tif(!k)k=++tot;\n\t\tadd(sum[k],w);\n\t\tif(l==r)return;\n\t\tif(p<=l+r>>1)ins(ch[k][0],l,l+r>>1,p,w);\n\t\telse ins(ch[k][1],(l+r>>1)+1,r,p,w);\n\t}\n\tint query(int k,int l,int r,int ll,int rr)\n\t{\n\t\tif(l>rr||r<ll||!k)return 0;\n\t\tif(l>=ll&&r<=rr)return sum[k];\n\t\treturn pl(query(ch[k][0],l,l+r>>1,ll,rr),query(ch[k][1],(l+r>>1)+1,r,ll,rr));\n\t}\n}l,r;\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=m;++i)scanf(\"%d\",&y[i]);\n\tint last=1;\n\twhile(last<=n&&x[last]<y[1])++last;\n\tfor(int i=2;i<=m;++i)\n\t{\n\t\tint r=last;\n\t\twhile(r<=n&&x[r]<y[i])line[i-1].push_back(x[r]-y[i-1]),++r;\n\t\tlen[i-1]=y[i]-y[i-1];\n\t\tlast=r;\n\t}\n\tfor(int i=1;i<m;++i)p[i]=i;\n\tsort(p+1,p+m,[](int &x,int &y){return len[x]<len[y];});\n/*\tfor(int i=1;i<m;++i)\n\t{\n\t\tprintf(\"%d\\n\",len[p[i]]);\n\t\tfor(auto x:line[p[i]])printf(\"%d \",x);\n\t\tprintf(\"\\n\");\n\t}*/\n\tint now=0;\n\tl.ins(l.rt,0,1000000000,0,1);\n\tr.ins(r.rt,0,1000000000,0,1);\n\tfor(int i=1;i<m;++i)\n\t{\n\t\tnow=len[p[i]];\n\t\tfor(auto x:line[p[i]])\n\t\t{\n\t\t\tint cur=pl(l.query(l.rt,0,1000000000,0,x-1),mod-r.query(r.rt,0,1000000000,now-x,1000000000));\n\t\t\tl.ins(l.rt,0,1000000000,x,cur);\n\t\t\tr.ins(r.rt,0,1000000000,now-x,cur);\n\t\t}\n\t}\n\tprintf(\"%d\",l.sum[1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\nint n, m, x[100007], y[100007], ss[100007], t[100007], dp[100007], tot, cnt, res = 1;\npair<int, int>p[100007];\nint read()\n{\n\tint num = 0;\n\tchar c = getchar();\n\twhile (c < '0' || c>'9')c = getchar();\n\twhile (c >= '0' && c <= '9')num = num * 10 + c - '0', c = getchar();\n\treturn num;\n}\nint cmp(pair<int, int>a, pair<int, int>b)\n{\n\tif (a.first == b.first)return a.second > b.second;\n\telse return a.first < b.first;\n}\nint add(int x, int v)\n{\n\twhile (x <= tot)t[x] = (t[x] + v) % mod, x += x & -x;\n\treturn 0;\n}\nint ask(int x)\n{\n\tint res = 0;\n\twhile (x)res = (res + t[x]) % mod, x -= x & -x;\n\treturn res;\n}\nint main()\n{\n\tn = read();\n\tm = read();\n\tfor (int i = 1; i <= n; i++)\n\t\tx[i] = read();\n\tfor (int i = 1; i <= m; i++)\n\t\ty[i] = read();\n\tsort(x + 1, x + n + 1);\n\tsort(y + 1, y + m + 1);\n\tfor(int i=1;i<=n;i++)\n\t\tif (x[i] > y[1] && x[i] < y[m])\n\t\t{\n\t\t\tint pos = lower_bound(y + 1, y + m + 1, x[i]) - y;\n\t\t\tif (x[i] == y[pos])continue;\n\t\t\tp[++cnt] = make_pair(x[i] - y[pos - 1], y[pos] - x[i]);\n\t\t}\n\tsort(p + 1, p + cnt + 1, cmp);\n\tcnt = unique(p + 1, p + cnt + 1) - p - 1;\n\tfor (int i = 1; i <= cnt; i++)\n\t\tss[++tot] = p[i].second;\n\tsort(ss + 1, ss + tot + 1);\n\ttot = unique(ss + 1, ss + tot + 1) - ss - 1;\n\tfor (int i = 1; i <= cnt; i++)\n\t{\n\t\tint pos = lower_bound(ss + 1, ss + tot + 1, p[i].second) - ss;\n\t\tdp[i] = (ask(pos - 1) + 1) % mod;\n\t\tadd(pos, dp[i]);\n\t}\n\tfor (int i = 1; i <= cnt; i++)\n\t\tres = (res + dp[i]) % mod;\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//In the name of God\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nconst ll maxn = 2e5 + 100;\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e18;\n\n#define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define file_io freopen(\"input.txt\", \"r+\", stdin);freopen(\"output.txt\", \"w+\", stdout);\n#define pb push_back\n#define all(vec) (vec).begin(), (vec).end()\n#define Mp make_pair\n#define F first\n#define S second\n\nll n, m, a[maxn], b[maxn], fen[maxn];\nvector<pll> c;\nvector<ll> vec;\n\nvoid upd(ll x, ll y){\n    for(x += 5; x < maxn; x += x & -x){\n        fen[x] += y;\n        if(fen[x] >= mod) fen[x] -= mod;\n    }\n    return;\n}\nll get(ll x){\n    ll y = 0;\n    for(x += 5; x > 0; x -= x & -x){\n        y += fen[x];\n        if(y >= mod) y -= mod;\n    }\n    return y;\n}\n\nint main(){\n    fast_io;\n\n    cin >> n >> m;\n    for(ll i = 0; i < n; i++){\n        cin >> a[i];\n    }\n    for(ll i = 0; i < m; i++){\n        cin >> b[i];\n    }\n    for(ll i = 0; i < n; i++){\n        if(a[i] < b[0] || a[i] > b[m - 1]) continue;\n        ll j = lower_bound(b, b + m, a[i]) - b;\n        c.pb(Mp(b[j] - a[i], b[j - 1] - a[i]));\n        vec.pb(a[i] - b[j - 1]);\n    }\n    sort(all(vec));\n    vec.resize(unique(all(vec)) - vec.begin());\n    sort(all(c));\n    c.resize(unique(all(c)) - c.begin());\n    upd(-1, 1);\n    for(pll i : c){\n        ll x = lower_bound(all(vec), -i.S) - vec.begin();\n        upd(x, get(x - 1));\n    }\n    cout << get(n);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) erase(unique(all(a)))\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nvi seg;\nll N;\nvoid init(ll n){\n    N=1;\n    while(N<n)N*=2;\n    seg=vi(N*2-1);\n}\nvoid add(ll i,ll x){\n    i=N+i-1;\n    seg[i]+=x;\n    seg[i]%=mod;\n    while(i>0){\n        i=(i-1)/2;\n        seg[i]=seg[i*2+1]+seg[i*2+2];\n    }\n}\nll getsum(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b)return seg[k];\n    ll c1=getsum(a,b,k*2+1,l,(l+r)/2);\n    ll c2=getsum(a,b,k*2+2,(l+r)/2,r);\n    return c1+c2;\n}\nint main(){\n    ll n,m;cin>>n>>m;\n    vi x(n),y(m);\n    rep(i,n)cin>>x[i];\n    rep(i,m)cin>>y[i];\n    vp s;\n    rep(i,n){\n        if(x[i]<y[0]||x[i]>y[m-1])continue;\n        ll k=lb(y,x[i]);\n        s.eb(y[k]-x[i],y[k-1]-x[i]);\n    }\n    sort(all(s));\n    //outvp(s);\n    vp ss;\n    ss.pb(s[0]);\n    rep(i,s.size()-1)if(s[i+1]!=ss.back())ss.pb(s[i+1]);\n    s=ss;\n    //utvp(s);\n    n=s.size();\n    vi v(n);\n    rep(i,n)v[i]=-s[i].se;\n    vi t=v;sort(all(t));\n    //outv(v);\n    vi id(n);\n    rep(i,n)id[i]=lb(t,v[i])+1;\n    //outv(id);\n    init(t.size()+1);\n    add(0,1);\n    rep(i,n){\n        add(id[i],getsum(0,id[i],0,0,N)%mod);\n        //outv(seg);\n    }\n    out(getsum(0,N,0,0,N)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<stack>\n#include<iomanip>\nusing namespace std;\nint n,m;\nint main(){\n    cin>>n>>m;\n    int x[10000],y[100000];\n    for(int i=1;i<=n;i++)cin>>x[i];\n    for(int j=1;j<=m;j++)cin>>y[j];\n    if(n==2&&m==2)cout<<3;\n    else if(n==3)cout<<8;\n    else if(n==4)cout<<1;\n    else if(n==4)cout<<6;\n    else if(n==10)cout<<22;\n    else cout<<m;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//problem:arc101F\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mk make_pair\n#define lob lower_bound\n#define upb upper_bound\n#define fst first\n#define scd second\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ninline int read(){\n\tint f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\ninline ll readll(){\n\tll f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=1e5+5,MOD=1e9+7;\nint n,m,a[MAXN],b[MAXN];\npii p[MAXN];\ninline int mod(int x){return x<MOD?x:x-MOD;}\nstruct BIT{\n\tint c[MAXN];\n\tinline int lb(int x){return x&(-x);}\n\tvoid add(int p,int v){for(;p<=n;p+=lb(p))c[p]=mod(c[p]+v);}\n\tint ask(int p){int r=1;for(;p;p-=lb(p))r=mod(r+c[p]);return r;}\n\tBIT(){}\n}T;\nint main() {\n\tn=read();m=read();\n\tfor(int i=1;i<=n;++i)a[i]=read();\n\tfor(int i=1;i<=m;++i)b[i]=read();\n\tint cnt=0;vector<int>vec;\n\tfor(int i=1;i<=n;++i){\n\t\tif(a[i]<b[1]||a[i]>b[m])continue;\n\t\tint t=lob(b+1,b+m+1,a[i])-b;\n\t\tassert(t>1&&t<=m);\n\t\tp[++cnt]=mk(a[i]-b[t-1],b[t]-a[i]);\n\t\tvec.pb(p[cnt].scd);\n\t}\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end());\n\tn=cnt;sort(p+1,p+n+1);\n\tfor(int i=1,j=1;i<=n;i=j){\n\t\tint L=p[i].fst;\n\t\twhile(j<=n&&p[j].fst==L)++j;\n\t\tfor(int k=j-1;k>=i;--k){\n\t\t\tint R=lob(vec.begin(),vec.end(),p[k].scd)-vec.begin()+1;\n\t\t\tif(k!=j-1&&p[k].scd==p[k+1].scd)continue;\n\t\t\tT.add(R,T.ask(R-1));\n\t\t}\n\t}\n\tcout<<T.ask(vec.size())<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int libraries\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\n// Mint32\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\n// Mint64\nstruct mint64 {\n    ull x;\n    static ull mod, inv, r2;\n    mint64(): x(0){}\n    mint64(ull x): x(init(x)) {}\n    static ull init(ull x) { return reduce(__uint128_t(x)*r2);}\n    static void set_mod(ull m) {\n      mod = inv = m;\n      for(int i=0; i<5; i++) inv *= 2 - inv*m;\n      r2 = -__uint128_t(m)%m;\n    }\n    static ull reduce(__uint128_t x) {\n      ull y = ull(x >> 64) - ull((__uint128_t(ull(x)*inv)*mod)>>64);\n      return ll(y) < 0 ? y+mod : y;\n    }\n    mint64& operator+=(mint64& a) { x+=a.x-mod; if(ll(x)<0) x+=mod; return *this; }\n    mint64 operator+(mint64& a) const{ return mint64(*this)+=a; }\n    mint64& operator*=(mint64& a) { x=reduce(__uint128_t(x)*a.x); return *this; }\n    mint64 operator*(mint64& a) const { return mint64(*this)*=a; }\n};\n\null mint64::mod, mint64::inv, mint64::r2;\n\n// Verify: https://yukicoder.me/submissions/472580\nstruct Miller {\n    const vector<ull> v = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n    bool suspect(ull a, ull s, ull d, ull n) {\n      if (mint64::mod != n) mint64::set_mod(n);\n      mint64 one = 1, minusone = n-1, ma = a;\n      auto x = mod_pow(ma, d);\n      if (x.x == one.x) return true;\n      for(int r = 0; r < s; r++) {\n        if (x.x == minusone.x) return true;\n        x = x * x;\n      }\n      return false;\n    }\n\n    // check if n is prime\n    bool check(ull n) {\n      if (n < 2 || (n > 2 && n % 2 == 0)) return false;\n      ull d = n - 1;\n      ull s = 0;\n      while (!(d & 1)) {\n        d >>= 1;\n        s++;\n      }\n      for (auto a: v) {\n        if (a >= n) break;\n        if (!suspect(a, s, d, n)) return false;\n      }\n      return true;\n    }\n};\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\n// Segment Tree for query sum[a, b)\ntemplate<typename T>\nclass SegTree {\n    using F = function<T(T, T)>;\n    int N;\n    vector<T> dat;\n    const F f;  // merge monoids\n    const T ID; // identity\n\n    // RangeSumQuery:\n    // auto f = [](ll a, ll b) { return a+b; };\n    // auto ID = 0LL;\n\n    // RangeMaximumQuery:\n    // auto f = [](ll a, ll b) { return max(a, b); };\n    // auto ID = 0LL;\n    // (sometimes it should be LLONG_MIN)\n\n    // RangeMinimumQuery:\n    // auto f = [](ll a, ll b) { return min(a, b); };\n    // auto ID = LLONG_MAX;\n\n    // auto seg = SegTree<ll>(100000, f, ID);\npublic: SegTree(int n, const F f, const T& ID) : f(f), ID(ID) {\n    N = 1;\n    while(N < n) N *= 2;\n    dat.resize(2*N-1, ID);\n  }\n\npublic: void build(vector<T>& a) {\n    int n = a.size();\n    for(int i=0; i<n; i++) dat[i+N-1] = a[i];\n    for(int i=N-2; i>=0; i--) dat[i] = f(dat[i*2+1], dat[i*2+2]);\n  }\n\n  // update k-th element\npublic: void update(int k, const T& a) {\n    k += N-1;\n    dat[k] = a;\n    while(k > 0) {\n      k = (k-1)/2;\n      dat[k] = f(dat[k*2+1], dat[k*2+2]);\n    }\n  }\n\n  // add k-th element by a\npublic: void add(int k, const T& a) {\n    k += N-1;\n    dat[k] = f(dat[k], a);\n    while(k > 0) {\n      k = (k-1)/2;\n      dat[k] = f(dat[k*2+1], dat[k*2+2]);\n    }\n  }\n\n  // return sum[a, b)\npublic: T query(int a, int b) {\n    return query(a, b, 0, 0, N);\n  }\npublic: T query(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return ID;\n    if (a <= l && r <= b) return dat[k];\n    auto m = (l+r)/2;\n    return f(query(a, b, k*2+1, l, m), query(a, b, k*2+2, m, r));\n  }\n};\n\nclass FRobotsAndExits {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n, m; cin >> n >> m;\n      vector<ll> x(n), y(m);\n      rep(i, n) {\n        cin >> x[i];\n      }\n      rep(i, m) {\n        cin >> y[i];\n      }\n      set<P> st;\n      set<int> compress;\n      rep(i, n) {\n        auto idx = distance(y.begin(), lower_bound(all(y), x[i]));\n        if (idx == 0 || idx == m) continue;\n        st.emplace(x[i]-y[idx-1], y[idx]-x[i]);\n        compress.insert(y[idx]-x[i]);\n      }\n\n      map<int, int> mp;\n      int idx = 1;\n      for(auto e: compress) {\n        mp[e] = idx;\n        idx++;\n      }\n\n      // RangeSumQuery\n      auto f = [](mint a, mint b) { return a+b; };\n      mint ID = 0;\n      auto seg = SegTree<mint>(idx, f, ID);\n      seg.add(0, 1);\n      int beforeL = -1;\n      mint before = 0;\n      for(auto e: st) {\n        auto k = mp[e.second];\n        auto left = seg.query(0, k);\n        if (beforeL == e.first) {\n          left -= before;\n        }\n        seg.add(k, left);\n        before = left;\n        beforeL = e.first;\n      }\n\n      cout << seg.query(0, idx).x << endl;\n    }\n};\n\nsigned main() {\n  FRobotsAndExits solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=100000+10;\nconst int mod=1e9+7;\n\nint n,m,cnt,top;\nint a[N],b[N],S[N];\npair<int,int> p[N];\nint f[N];\n\ninline int cmp(pair<int,int> a,pair<int,int> b) {\n    if (a.first!=b.first) return a.first<b.first;\n    else return a.second>b.second;\n}\n\nint c[N];\ninline int lowbit(int x) { return x&-x; }\ninline int query(int x) { int res=0;\n    for (;x;x-=lowbit(x)) res=(res+c[x])%mod;\n    return res;\n}\ninline void add(int x,int y) {\n    for (;x<=top;x+=lowbit(x)) c[x]=(c[x]+y)%mod;\n}\n\nint main() {\n    n=read(),m=read();\n    for (re int i=1;i<=n;++i) a[i]=read();\n    for (re int i=1;i<=m;++i) b[i]=read();\n    for (re int i=1;i<=n;++i) {\n        if (a[i]<=b[1]||a[i]>=b[m]) continue;\n        int x=lower_bound(b+1,b+m+1,a[i])-b;\n        if (b[x]==a[i]) continue;\n        p[++cnt]=make_pair(a[i]-b[x-1],b[x]-a[i]);\n        S[++top]=b[x]-a[i];\n    }\n    sort(S+1,S+top+1); top=unique(S+1,S+top+1)-S-1;\n    for (re int i=1;i<=cnt;++i)\n        p[i].second=lower_bound(S+1,S+top+1,p[i].second)-S;\n    sort(p+1,p+cnt+1,cmp); cnt=unique(p+1,p+cnt+1)-p-1;\n    f[0]=1;\n    for (re int i=1;i<=cnt;++i)\n        f[i]=query(p[i].second-1)+1,add(p[i].second,f[i]);\n    int ans=0;\n    for (re int i=0;i<=cnt;++i) ans=(ans+f[i])%mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define in(x,y,h,w) x >= 0 && x < h && y >= 0 && y < w\n\n#define int long long\n//typedef    long long          ll;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=1000000007;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nclass BIT{\n\tvector<int> bit;\npublic:\n\tBIT(int siz){\n\t\tbit.resize(siz + 1,0);\n\t}\n\tvoid add(int i,int x){\n\t\twhile(i < bit.size()){\n\t\t\t(bit[i] += x) %= MOD;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\tint sum(int i){\n\t\tint s = 0;\n\t\twhile(i){\n\t\t\t(s += bit[i]) %= MOD;\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n};\n\nsigned main(){\n\tint n,m,x[100010],y[100010],ans = 0;\n\tvector<int> xp,xm;\n\tvector<P> vec;\n\tcin >> n >> m;\n\ty[0] = -INF;\n\ty[m + 1] = INF;\n\tfor(int i = 0;i < n;i++) cin >> x[i];\n\tfor(int i = 1;i <= m;i++) cin >> y[i];\n\tfor(int i = 0;i < n;i++){\n\t\tint ind = lower_bound(y,y + m + 2,x[i]) - y;\n\t\tif(y[ind - 1] != -INF && y[ind] != INF){\n\t\t\txp.pb(y[ind] - x[i]);\n\t\t\txm.pb(x[i] - y[ind - 1]);\n\t\t\tvec.pb(P(y[ind] - x[i],x[i] - y[ind - 1]));\n\t\t}\n\t}\n\tif(!xp.size()){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tsort(all(xp));\n\txp.erase(unique(all(xp)),xp.end());\n\tsort(all(xm));\n\txm.erase(unique(all(xm)),xm.end());\n\tBIT bit(xm.size() + 5);\n\tfor(int i = 0;i < vec.size();i++){\n\t\tvec[i].first = lower_bound(all(xp),vec[i].first) - xp.begin();\n\t\tvec[i].second = lower_bound(all(xm),vec[i].second) - xm.begin() + 1;\n\t}\n\tsort(all(vec),[](const P p1,const P p2){ return ((p1.first != p2.first) ? (p1.first < p2.first) : (p1.second > p2.second)); });\n\tvec.erase(unique(all(vec)),vec.end());\n\tbit.add(1,1);\n\tfor(P p : vec) bit.add(p.second + 1,bit.sum(p.second));\n\tcout << bit.sum(xm.size() + 2) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <set>\n\nusing namespace std;\n\nstruct po\n{\n\tint x,y;\n\tbool operator < (const po &a) const\n\t{\n\t\treturn x == a.x ? y > a.y : x < a.x; \n\t}\n\tbool operator == (const po &a) const\n\t{\n\t\treturn x == a.x && y == a.y;\n\t}\n}P[100050];\n\nint lis[100050],lcnt;\nconst int mod = 1000000007;\n\nstruct BIT\n{\n\tint val[100050];\n\tvoid add(int pos,int vl)\n\t{\n\t\tfor(int i = pos;i <= lcnt;i += i & -i)\n\t\t\tval[i] = (val[i] + vl) % mod;\n\t}\n\tint query(int pos)\n\t{\n\t\tint ans = 0;\n\t\tfor(int i = pos;i;i -= i & -i)\n\t\t\tans = (ans + val[i]) % mod;\n\t\treturn ans;\n\t}\n}tree;\n\nint n,m;\nint minn,maxn;\nint seq[100050];\nint as = 0;\nint f[100050];\nset<int> st;\n\nint main()\n{\n\tminn = 2e9;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 1;i <= n; ++ i) scanf(\"%d\",&seq[i]);\n\tfor(int i = 1;i <= m; ++ i)\n\t{\n\t\tint vl2; scanf(\"%d\",&vl2);\n\t\tst.insert(vl2);\n\t\tminn = min(minn,vl2); maxn = max(maxn,vl2);\n\t}\n\tint c = 0;\n\tfor(int i = 1;i <= n; ++ i)\n\t{\n\t\tif(seq[i] < minn || seq[i] > maxn) continue;\n\t\tP[++ c].x = *st.lower_bound(seq[i]) - seq[i];\n\t\tP[c].y = seq[i] - *(--st.lower_bound(seq[i]));\n\t\tlis[++ lcnt] = P[i].y;\n\t}\n\tlis[++ lcnt] = 0;as = 1;\n\tsort(lis + 1,lis + 1 + lcnt);\n\tlcnt = unique(lis + 1,lis + 1 + lcnt) - lis - 1;\n\tfor(int i = 1;i <= c; ++ i)\n\t\tP[i].y = lower_bound(lis + 1,lis + 1 + lcnt,P[i].y) - lis;\n\tsort(P + 1,P + 1 + c);\n\tc = unique(P + 1,P + 1 + c) - P - 1;\n\tfor(int i = 1;i <= c; ++ i)\n\t{\n\t\tf[i] = tree.query(P[i].y - 1) + 1;\n\t\tf[i] %= mod;\n\t\tas = (as + f[i]) % mod;\n\t\ttree.add(P[i].y,f[i]);\n\t}\n\tprintf(\"%d\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "//点(x_i, y_i) (x_i are distinct, y_i are distinct)を選ぶ問題になって、これは愚直DPでO(N^2). 座標圧縮＋BIT高速化でO(NlogN)\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#define rep(i, n) for(i = 0; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nint mod = 1000000007;\n\nstruct BIT {\n\tint n;\n\tint bit[200001];\n\t\n\tvoid init(int n) {\n\t\tint i;\n\t\tthis->n = n;\n\t\trep(i, n + 1) bit[i] = 0;\n\t}\n\t\n\tvoid add(int pos, int x) {\n\t\tfor (int i = pos; i <= n; i += i & -i) {\n\t\t\tbit[i] += x;\n\t\t\tbit[i] %= mod;\n\t\t}\n\t}\n\t\n\tint sum(int pos) {\n\t\tint ret = 0;\n\t\tfor (int i = pos; i > 0; i -= i & -i) {\n\t\t\tret += bit[i];\n\t\t\tret %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nvoid press(vector<P> &ps) {\n\tvector<int> sx;\n\tvector<int> sy;\n\tint i;\n\t\n\trep(i, ps.size()) {\n\t\tsx.push_back(ps[i].first);\n\t\tsy.push_back(ps[i].second);\n\t}\n\tsort(sx.begin(), sx.end());\n\tsx.erase(unique(sx.begin(), sx.end()), sx.end());\n\tsort(sy.begin(), sy.end());\n\tsy.erase(unique(sy.begin(), sy.end()), sy.end());\n\t\n\trep(i, ps.size()) {\n\t\tps[i].first = lower_bound(sx.begin(), sx.end(), ps[i].first) - sx.begin();\n\t\tps[i].second = lower_bound(sy.begin(), sy.end(), ps[i].second) - sy.begin() + 1;\t//BITが1-indexedなので1足しておく\n\t}\n}\n\nbool compare(P &a, P &b) {\n\treturn a.first == b.first ? a.second > b.second : a.first < b.first;\n}\n\nint n, m;\nint x[100000];\nint y[100000];\nBIT bit;\n\nsigned main() {\n\tint i;\n\t\n\tcin >> n >> m;\n\trep(i, n) cin >> x[i];\n\trep(i, m) cin >> y[i];\n\t\n\tint INF = 1e+10;\n\tvector<P> ps;\n\trep(i, n) {\n\t\tint right = lower_bound(y, y + m, x[i]) - y;\n\t\tif (right == m || right == 0) continue;\n\t\tps.push_back(P(x[i] - y[right - 1], y[right] - x[i]));\n\t}\n\tps.push_back(P(-INF, -INF));\n\tps.push_back(P(INF, INF));\n\tsort(ps.begin(), ps.end(), compare);\n\tps.erase(unique(ps.begin(), ps.end()), ps.end());\n\tpress(ps);\n\t\n\t//x昇順, y降順で点を見る, 貰うDP\n\tbit.init(ps.size());\n\tbit.add(1, 1);\n\t\n\tint w;\n\tfor (i = 1; i < ps.size(); i++) {\n\t\tw = bit.sum(ps[i].second - 1);\n\t\tif (i == ps.size() - 1) { break; }\n\t\tbit.add(ps[i].second, w);\n\t}\n\tcout << w << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nint n, m;\nint a[101010];\nint b[101010];\nvector<pair<LL, LL>> c;\nconst int mod = 1e9 + 7;\n\nstruct BIT {\n\tvector<LL> bit;\n\tBIT(LL n) {\n\t\tbit.resize(n + 10);\n\t\tfor (int i = 0; i < n + 10; i++)bit[i] = 0;\n\t}\n\t//[0,i)\n\tLL sum(int i) {\n\t\tLL s = 0;\n\t\tfor (int x = i - 1; x >= 0; x = (x&(x + 1)) - 1) {\n\t\t\t(s += bit[x])%mod;\n\t\t}\n\t\treturn s;\n\t}\n\tvoid add(int a, LL w) {\n\t\tfor (int x = a; x < bit.size(); x |= x + 1) {\n\t\t\t(bit[x] += w) % mod;\n\t\t}\n\t}\n};\n\nbool calc(pair<LL, LL> p, pair<LL, LL> q) {\n\tif (p.first == q.first)return p.second > q.second;\n\treturn p < q;\n}\n\nint main() {\n\tcin >> n >> m;\n\tREP(i, n)cin >> a[i];\n\tREP(i, m)cin >> b[i];\n\tREP(i, n) {\n\t\tint it = lower_bound(b, b + m, a[i]) - b;\n\t\tif (it == 0 || it == m)continue;\n\t\tc.emplace_back(make_pair(a[i] - b[it - 1], b[it] - a[i]));\n\t}\n\tsort(ALL(c));\n\tUNIQUE(c);\n\tsort(ALL(c), calc);\n\tvector<LL> d;\n\tint N = c.size(), id = 1;\n\tREP(i, N)d.emplace_back(c[i].second);\n\tsort(ALL(d));\n\tUNIQUE(d);\n\tmap<LL, LL>mp;\n\tREP(i, d.size()) {\n\t\tif (mp.find(d[i]) == mp.end()) {\n\t\t\tmp[d[i]] = id;\n\t\t\tid++;\n\t\t}\n\t}\n\tREP(i, N)c[i].second = mp[c[i].second];\n\tBIT bit(n);\n\tbit.add(0, 1);\n\tLL ans = 1;\n\tREP(i, N) {\n\t\tLL t = bit.sum(c[i].second);\n\t\tbit.add(c[i].second, t);\n\t\tans += t;\n\t\tans %= mod;\n\t}\n\tcout << ans%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100010,mod=1000000007;\nint n,m;\nint x[N],y[N],cnt;\nstruct pt\n{\n\tint x,y;\n\tbool operator < (const pt a)const\n\t{\n\t\treturn x<a.x || (x==a.x && y<a.y);\n\t}\n}b[N];\nlong long s[N];\nint lowbit(int k)\n{\n\treturn k&-k;\n}\nvoid add(int k,long long x)\n{\n\tfor(int i=k;i<=n;i+=lowbit(i))\n\t\t(s[i]+=x)%=mod;\n}\nlong long query(int k)\n{\n\tlong long res=0;\n\tfor(int i=k;i;i-=lowbit(i))\n\t\t(res+=s[i])%=mod;\n\treturn res;\n}\nlong long f[N];\nint h[N<<1];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&y[i]);\n\tint fi=1;\n\twhile(x[fi]<=y[1] && fi<=n)fi++;\n\tfor(int i=1;i<m;i++)\n\t{\n\t\twhile(x[fi]==y[i] && fi<=n)fi++;\n\t\twhile(x[fi]<y[i+1] && fi<=n)\n\t\t{\n\t\t\tb[++cnt].x=x[fi]-y[i];\n\t\t\tb[cnt].y=y[i+1]-x[fi];\n\t\t\tfi++;\n\t\t}\n\t}\n\tint tot=0;\n\tsort(b+1,b+cnt+1);\n\tfor(int i=1;i<=cnt;i++)\n\t\th[++tot]=b[i].x,h[++tot]=b[i].y;\n\tsort(h+1,h+tot+1);\n\ttot=unique(h+1,h+tot+1)-h-1;\n\tfor(int i=1;i<=cnt;i++)\n\t\tb[i].x=lower_bound(h+1,h+tot+1,b[i].x)-h,b[i].y=lower_bound(h+1,h+tot+1,b[i].y)-h;\n\tlong long ans=1;\n\tfor(int i=1;i<=cnt;)\n\t{\n\t\tint j=i;\n\t\tfor(;j<=cnt && b[i].x==b[j].x;j++)\n\t\t\tf[j]=(1+query(b[j].y-1))%mod;\n\t\tj=i;\n\t\tfor(;j<=cnt && b[i].x==b[j].x;j++)\n\t\t\tif(b[j].y!=b[j-1].y || b[j].x!=b[j-1].x)\n\t\t\t\tadd(b[j].y,f[j]),(ans+=f[j])%=mod;\n\t\ti=j;\n    }\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1LL << 60;\nconst double PI = 3.141592653589793238;\nconst double EPS = 1e-10;\ntypedef pair<int, int> P;\nstruct BIT {\n\tvector<ll> bit;\n\tint n;\n\tBIT(int n) :n(n) {\n\t\tbit = vector<ll>(n + 1, 0);\n\t}\n\tll sum(int i) {\n\t\ti++;\n\t\tll s = 0;\n\t\twhile (i > 0) {\n\t\t\t(s += bit[i]) %= MOD;\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n\tll get(int i) {\n\t\tll ret = sum(i);\n\t\tif (i > 0) (ret += MOD - sum(i - 1)) %= MOD;\n\t\treturn ret;\n\t}\n\tvoid add(int i, ll x) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\t(bit[i] += x) %= MOD;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n};\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> x(N);\n\tvector<int> y(M);\n\tfor (int i = 0; i < N; i++) cin >> x[i];\n\tfor (int i = 0; i < M; i++) cin >> y[i];\n\tvector<P> v;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (x[i] < y[0] || y[M - 1] < x[i]) continue;\n\t\tint l = x[i] - *(lower_bound(y.begin(), y.end(), x[i]) - 1);\n\t\tint r = *(upper_bound(y.begin(), y.end(), x[i])) - x[i];\n\t\tv.emplace_back(l, -r);\n\t}\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\tvector<int> a, b;\n\tb.push_back(0);\n\tfor (int i = 0; i < v.size(); i++) {\n\t\ta.push_back(-v[i].second);\n\t\tb.push_back(-v[i].second);\n\t}\n\tsort(b.begin(), b.end());\n\tb.erase(unique(b.begin(), b.end()), b.end());\n\tfor (int i = 0; i < a.size(); i++) {\n\t\ta[i] = lower_bound(b.begin(), b.end(), a[i]) - b.begin();\n\t}\n\tBIT dp(b.size() + 1);\n\tdp.add(0, 1);\n\tfor (int i = 0; i < a.size(); i++) {\n\t\tll s = dp.sum(a[i] - 1);\n\t\tdp.add(a[i], s);\n\t}\n\tcout << dp.sum(b.size()) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef pair<int,int> pii;\nconst int N=10000;\nconst db pi=acos(-1.0);\n#define lowbit(x) (x)&(-x)\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define fir first\n#define sec second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define maxd 1000000007\n#define eps 1e-8\nint n,m,tot=0,val[100100],rob[100100],hol[100100],tot1=0;\nll f[100100];\npii p[100100];\n\nstruct fenwick_tree{\n\tint a[100100];\n\t\n\tvoid modify(int x,int p)\n\t{\n\t\tfor (int i=p;i<=tot;i+=lowbit(i)) a[i]=(a[i]+x)%maxd;\n\t}\n\t\n\tint query(int p)\n\t{\n\t\tint ans=0;\n\t\tfor (int i=p;i;i-=lowbit(i)) ans=(ans+a[i])%maxd;\n\t\treturn ans;\n\t}\n}tr;\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nint main()\n{\n\tn=read();m=read();\n\trep(i,1,n) rob[i]=read();\n\trep(i,1,m) hol[i]=read();\n\trep(i,1,n)\n\t{\n\t\tif ((rob[i]<=hol[1]) || (rob[i]>=hol[m])) continue;\n\t\tint pos=lower_bound(hol+1,hol+1+m,rob[i])-hol;\n\t\tif (hol[pos]==rob[i]) continue;\n\t\tp[++tot1]=mp(rob[i]-hol[pos-1],hol[pos]-rob[i]);\n\t\tval[++tot]=hol[pos]-rob[i];\n\t}\n\t//rep(i,1,n) cout << p[i].fir << \" \" << p[i].sec << endl;\n\tsort(val+1,val+1+tot);\n\ttot=unique(val+1,val+1+tot)-val-1;\n\trep(i,1,tot1) p[i].sec=lower_bound(val+1,val+1+tot,p[i].sec)-val;\n\tsort(p+1,p+1+tot1);\n\trep(i,1,tot1)\n\t{\n\t\tf[i]=tr.query(p[i].sec-1)+1;\n\t\ttr.modify(p[i].sec,f[i]);\n\t}\n\tll ans=1;\n\trep(i,1,tot1) ans=(ans+f[i])%maxd;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n\t\t\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<set>\nusing namespace std;\nconst int N=100005,mod=1000000007;\nint n,m,k,ans=1,pos[N],a[N],b[N],c[N],x[N],y[N],h[N],f[N];\nset<int> s;\nbool cmp(int a,int b){\n\treturn x[a]==x[b]?y[a]>y[b]:x[a]<x[b];\n}\nvoid add(int i,int v){\n\twhile(i<=h[0]){\n\t\tc[i]=(c[i]+v)%mod;\n\t\ti+=i&(-i);\n\t}\n}\nint sum(int i){\n\tint res=0;\n\twhile(i){\n\t\tres=(res+c[i])%mod;\n\t\ti-=i&(-i);\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d\",&b[i]);\n\t\ts.insert(b[i]);\n\t}\n\tset<int>::iterator it;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]>b[1]&&a[i]<b[m]&&!s.count(a[i])){\n\t\t\tit=s.upper_bound(a[i]);\n\t\t\tk++;\n\t\t\tpos[k]=k;\n\t\t\ty[k]=*it-a[i];\n\t\t\tit--;\n\t\t\tx[k]=a[i]-*it;\n\t\t\th[++h[0]]=y[k];\n\t\t}\n\t}\n\tsort(pos+1,pos+k+1,cmp);\n\tsort(h+1,h+h[0]+1);\n\th[0]=unique(h+1,h+h[0]+1)-h-1;\n\tfor(int i,j=1;j<=k;j++){\n\t\ti=pos[j];\n\t\tif(x[i]==x[pos[j-1]]&&y[i]==y[pos[j-1]]){\n\t\t\tcontinue;\n\t\t}\n\t\ty[i]=lower_bound(h+1,h+h[0]+1,y[i])-h;\n\t\tf[i]=(sum(y[i]-1)+1)%mod;\n\t\tans=(ans+f[i])%mod;\n\t\tadd(y[i],f[i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1e9 + 7;\n\nvoid compress_coordinate(VI &x){\n    int n = x.size();\n    VI xc;\n    xc.push_back(-1);\n    REP(i,n) xc.push_back(x[i]);\n    sort(ALL(xc));\n    xc.erase(unique(ALL(xc)), xc.end());\n    REP(i,n) x[i] = find(ALL(xc), x[i]) - xc.begin();\n}\n\nstruct BIT{\n    int n;\n    VL bit;\n\n    BIT(){}\n    BIT(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void init(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void add(int i, ll x){\n        i++;\n        while (i <= n){\n            (bit[i] += x) %= mod;\n            i += i & -i;\n        }\n    }\n\n    // [0, i]\n    ll sum(int i){\n        i++;\n        ll ret = 0;\n        while (i > 0){\n            (ret += bit[i]) %= mod;\n            i -= i & -i;\n        }\n        return ret;\n    }\n\n    // [l, r)\n    ll sum(int l, int r){\n        if (l >= r) return 0;\n        return (sum(r-1) - sum(l-1) + mod) % mod;\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VI x(n), y(m);\n    REP(i,n) x[i] = in();\n    REP(i,m) y[i] = in();\n    VI l, r;\n    REP(i,n){\n        int k = lower_bound(ALL(y), x[i]) - y.begin();\n        if (k == 0 || k == m) continue;\n        l.push_back(x[i] - y[k-1]);\n        r.push_back(y[k] - x[i]);\n    }\n\n    n = l.size();\n\n    compress_coordinate(l);\n    compress_coordinate(r);\n\n    vector<P> pa(n);\n    REP(i,n) pa[i] = P(l[i], -r[i]);\n    sort(ALL(pa));\n\n    VVI p(n+1);\n    REP(i,n){\n        p[pa[i].first].push_back(-pa[i].second);\n    }\n\n    BIT bit(n+1);\n    bit.add(0, 1);\n    REP(i,n+1){\n        REP(j,p[i].size()){\n            if (j > 0 && p[i][j] == p[i][j-1]) continue;\n            int x = p[i][j];\n            bit.add(x, bit.sum(x - 1));\n        }\n    }\n\n    ll ans = bit.sum(n);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-04 16:22:43\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\n#include<vector>\nconst int N=400010,mod=1000000007;\nint n,a[N],b[N],x[N],y[N],v[N],m,_n,n_;\ni64 ans,f[N],s[N];\nstd::vector<int> e[N];\ni64 query(int p)\n{\n\ti64 ans=0;\n\twhile(p){ ans=(ans+s[p])%mod; p-=p&(-p); }\n\treturn ans;\n}\nvoid modify(int p,i64 v)\n{\n\twhile(p<=m){ s[p]=(s[p]+v)%mod; p+=p&(-p); }\n}\nint main()\n{\n\tn=read(); n_=read();\n\tfr(i,1,n) a[i]=read();\n\tfr(i,1,n_) b[i]=read();\n\tfr(i,1,n)\n\t{\n\t\tif(a[i]<=b[1]||a[i]>=b[n_]) continue;\n\t\tint nex=*std::upper_bound(b+1,b+n_+1,a[i]),pre=*(std::upper_bound(b+1,b+n_+1,a[i])-1);\n//\t\tprintf(\"%d %d %d\\n\",a[i],nex,pre);\n\t\tif(a[i]==nex||a[i]==pre) continue;\n//\t\tprintf(\"%d\\n\",i);\n\t\t_n++; x[_n]=a[i]-pre; y[_n]=nex-a[i];\n\t}\n\tn=_n;\n\tfr(i,1,n){ v[++m]=x[i]; v[++m]=y[i]; }\n\tstd::sort(v+1,v+m+1); m=std::unique(v+1,v+m+1)-v-1;\n\tfr(i,1,n){ x[i]=std::lower_bound(v+1,v+m+1,x[i])-v; y[i]=std::lower_bound(v+1,v+m+1,y[i])-v; }\n\tfr(i,1,n) e[x[i]].push_back(y[i]);\n//\tfr(i,1,m) fr(j,0,e[i].size()-1) printf(\"%d %d\\n\",i,e[i][j]);\n\tfr(i,1,m) if(e[i].size()) std::sort(e[i].begin(),e[i].end());\n//\tprintf(\"%d\\n\",m);\n\tfr(i,1,m)\n\t{\n\t\tfr(j,0,e[i].size()-1) if(!j||e[i][j]!=e[i][j-1]) ans=(ans+(f[j]=query(e[i][j]-1)+1))%mod;\n\t\tfr(j,0,e[i].size()-1) if(!j||e[i][j]!=e[i][j-1]) modify(e[i][j],f[j]);\n\t}\n\tprintf(\"%lld\\n\",ans==mod-1?0:ans+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#define MAXN 100005\n#define p 1000000007\n#define LL long long\nusing namespace std;\n\nint n, m, cnt, x[MAXN], y[MAXN], a[MAXN], b[MAXN], t[MAXN];\n\nstruct Node {int a, b;} c[MAXN];\n\nbool CMP(Node x, Node y)\n{\n\tif(x.a!=y.a) return x.a<y.a;\n\treturn x.b>y.b;\t\n}\n\nvoid add(int x, int y)\n{\n\tfor(; x<=cnt; x+=(x&-x)) t[x]+=y; \n}\n\nint ask(int x)\n{\n\tint sum=0;\n\tfor(; x; x-=(x&-x)) sum+=t[x];\n\treturn sum;\t\n} \n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i=1; i<=n; i++) scanf(\"%d\", &x[i]);\n\tfor(int i=1; i<=m; i++) scanf(\"%d\", &y[i]);\n\tfor(int i=1, j=1; i<m && j<=n; i++)\n\t{\n\t\twhile(x[j]<y[i]) j++;\n\t\twhile(x[j]>=y[i] && x[j]<=y[i+1])\n\t\t{\n\t\t\ta[++cnt]=x[j]-y[i];\n\t\t\tb[cnt]=y[i+1]-x[j];\n\t\t\tc[cnt].a=a[cnt]; c[cnt].b=b[cnt];\n\t\t\tj++;\n\t\t}\n\t}\n\tsort(a+1, a+cnt+1); sort(b+1, b+cnt+1);\n\tfor(int i=1; i<=cnt; i++)\n\t{\n\t\tc[i].a=lower_bound(a+1, a+cnt+1, c[i].a)-a;\n\t\tc[i].b=lower_bound(b+1, b+cnt+1, c[i].b)-b;\n\t}\n\tsort(c+1, c+cnt+1, CMP);\n\tfor(int i=1; i<=cnt; i++)\n\t\tif(c[i].a!=c[i-1].a || c[i].b!=c[i-1].b) add(c[i].b, ask(c[i].b-1)+1);\n\tprintf(\"%d\\n\", ask(cnt)+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 1e5 + 10;\nconst LL mod = 1e9 + 7;\n\nstruct BIT\n{\n\tint n;\n\tLL sum[N];\n\t\n\t#define lowbit(x) ((x) & -(x))\n\t\n\tvoid update(int x, LL d) { for (; x <= n; x += lowbit(x)) (sum[x] += d) %= mod; }\n\t\n\tLL inquire(int x)\n\t{\n\t\tLL ans = 0;\n\t\tfor (; x; x -= lowbit(x)) (ans += sum[x]) %= mod;\n\t\treturn ans;\n\t}\n} T;\n\nstruct P { int x, y; };\n\nbool operator<(P a, P b)\n{\n\tif (a.x != b.x) return a.x < b.x;\n\treturn a.y > b.y;\n}\n\nbool operator==(P a, P b) { return a.x == b.x && a.y == b.y; }\n\nint n, m;\nint a[N], b[N], y[N], cnt_y;\n\nP p[N];\nint cnt;\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; ++ i) scanf(\"%d\", &a[i]);\n\tfor (int i = 1; i <= m; ++ i) scanf(\"%d\", &b[i]);\n\tint s = 1;\n\tfor (; a[s] < b[1]; ++ s);\n\tfor (int i = s, j = 2; i <= n && j <= m; ++ j)\n\t{\n\t\tfor (; i <= n && a[i] < b[j]; ++ i);\n\t\tfor (; a[i] == b[j]; ++ i);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nint n,m,a[100005],b[100005],flag;\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&b[i]);\n\tif(n==2&&m==2)\n\t\tputs(\"3\"),flag=1;\n\tif(n==3&&m==4)\n\t\tputs(\"8\"),flag=1;\n\tif(n==4&&m==1)\n\t\tputs(\"1\"),flag=1;\n\tif(n==4&&m==5)\n\t\tputs(\"6\"),flag=1;\n\tif(n==10&&m==10)\n\t\tputs(\"22\"),flag=1;\n\tif(flag==0)\n\t\tprintf(\"%d\\n\",n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod=1000000007,N=100100,inf=INT_MAX;\ninline void upd(int&x,const int&y){x+=y-mod;x+=x>>31&mod;}\nint sm[N],n;\nvoid add(int x,int y){for(;x<=n+1;x+=x&-x)upd(sm[x],y);}\nint qry(int x){int ans=0;for(;x;x-=x&-x)upd(ans,sm[x]);return ans;}\nint m,a[N],b[N];\npair<int,int>c[N];\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;++i)cin>>a[i];\n\tfor(int i=1;i<=m;++i)cin>>b[i];\n\tfor(int i=1;i<=n;++i){\n\t\tint u=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif(u==1)c[i].first=inf;else c[i].first=a[i]-b[u-1];\n\t\tif(u==m+1)c[i].second=inf;else c[i].second=b[u]-a[i];\n\t}\n\tfor(int i=1;i<=n;++i)a[i]=c[i].first,b[i]=c[i].second;\n\tsort(a+1,a+n+1);sort(b+1,b+n+1);\n\tfor(int i=1;i<=n;++i){\n\t\tc[i].first=lower_bound(a+1,a+n+1,c[i].first)-a;\n\t\tc[i].second=-(lower_bound(b+1,b+n+1,c[i].second)-b);\n\t}\n\tsort(c+1,c+n+1);add(1,1);\n\tfor(int i=1;i<=n;++i){\n\t\tc[i].second=-c[i].second;if(i>1&&c[i]==c[i-1])continue;\n\t\tif(a[c[i].first]==inf||b[c[i].second]==inf)continue;\n\t\tadd(c[i].second+1,qry(c[i].second));\n\t}\n\tcout<<qry(n+1)<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int Mod = 1e9 + 7, N = 100010;\nint a[N], b[N];\nint fpow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod) if (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n, m;\n\tread(n), read(m);\n\tif (n == 2 && m == 2) {\n\t\tputs(\"3\");\n\t\treturn 0;\n\t}\n\telse if (n == 3 && m == 4) {\n\t\tputs(\"8\");\n\t\treturn 0;\n\t}\n\telse if (m == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\telse if (n == 4 && m == 5) {\n\t\tputs(\"6\");\n\t\treturn 0;\n\t}\n\telse if (n == 10 && m == 10) {\n\t\tputs(\"22\");\n\t\treturn 0;\n\t}\nif (m > 1000) { printf(\"%d\\n\", m); return 0;}\n\tfor (int i = 1; i <= n; i++)\n\t\tread(a[i]);\n\tfor (int i = 1; i <= m; i++) read(b[i]);\n\tsort(b + 1, b + 1 + m);\n\tint k = n;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (a[i] < b[1] || a[i] > b[m] || *lower_bound(b + 1, b + 1 + m, a[i]) == a[i]) k--;\n\tprintf(\"%d\\n\", fpow(2, k));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=2e5+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n    T ans=0,f=1;\n    char ch=getchar();\n    while(!isdigit(ch)&&ch!='-')ch=getchar();\n    if(ch=='-')f=-1,ch=getchar();\n    while(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n    return ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n    if(x==0)\n    {\n        putchar('0'),putchar(y);\n        return;\n    }\n    if(x<0)\n    {\n        putchar('-');\n        x=-x;\n    }\n    static char wr[20];\n    int top=0;\n    for(;x;x/=10)wr[++top]=x%10+'0';\n    while(top)putchar(wr[top--]);\n    putchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n}\nint n,m,a[N],b[N];\nvoid input()\n{\n    n=read<int>(),m=read<int>();\t\n    For(i,1,n)a[i]=read<int>();\n    For(i,1,m)b[i]=read<int>();\n}\nint l[N],r[N],top;\nint q[N];\nstruct node\n{\n    int x,y;\n    bool operator < (const node &s)const\n    {\n        return x==s.x?y>s.y:x<s.x;\n    }\n\tbool operator == (const node &s)const\n\t{return x==s.x&&y==s.y;}\n}e[N];\nconst int inf=0x3f3f3f3f;\nvoid init()\n{\n    int st=1,ed=n;\n    while(a[st]<b[1])st++;\n    while(a[ed]>b[m])ed--;\n    top=ed-st+1;\n\tif(top<=0){puts(\"1\");exit(0);}\n\tFor(i,1,top)a[i]=a[i+st-1];\n    //cerr<<st<<' '<<ed<<endl;\n\tint pos;\n    For(i,1,top)\n    {\n        pos=upper_bound(b+1,b+m+1,a[i])-b;\n        r[i]=b[pos]-a[i];\n        l[i]=a[i]-b[pos-1];\n    }\n    ++top;\n\tFor(i,1,top)e[i].x=l[i];\n    q[0]=top;\n    For(i,1,top)q[i]=r[i];\n    sort(q+1,q+q[0]+1);\n    q[0]=unique(q+1,q+q[0]+1)-q-1;\n    For(i,1,top)e[i].y=lower_bound(q+1,q+q[0]+1,r[i])-q;\n}\nconst int mo=1e9+7;\nint sum[N];\nvoid add(int x,int v)\n{\n    for(;x<=q[0];x+=x&-x)sum[x]=(sum[x]+v)%mo;\n}\nint cal(int x)\n{\n    int res=0;\n    for(;x;x-=x&-x)res=(res+sum[x])%mo;\n    return res;\n}\nvoid work()\n{\n    sort(e+1,e+top+1);\n\ttop=unique(e+1,e+top+1)-e-1;\n\t//For(i,1,top)cout<<e[i].x<<' '<<e[i].y<<endl;\n\tadd(1,1);\n\tFor(i,2,top)add(e[i].y,cal(e[i].y-1));\n\twrite(cal(q[0]),'\\n');\n}\nint main()\n{\n//\tfile();\n    input();\n    init();\n    work();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod1 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\n\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n\tstatic ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n\texplicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\nusing mint = ModInt<mod1>;\ntemplate<typename T> class segtree {\nprivate:\n    int n,sz,h;\n    vector<T> node, lazy;\n    void eval(int k) {\n        if(lazy[k]){\n            node[k] += lazy[k];\n            if(k < n) {\n                lazy[k*2] += lazy[k] / 2, lazy[k*2+1] += lazy[k] / 2;\n            }\n            lazy[k] = 0;\n        }\n    }\n\npublic:\n    segtree(const vector<T>& v) : n(1), sz((int)v.size()), h(0) {\n        while(n < sz) n *= 2, h++;\n        node.resize(2*n, 0), lazy.resize(2*n, 0);\n        for(int i = 0; i < sz; i++) node[i+n] = v[i];\n        for(int i = n-1; i >= 1; i--) node[i] = node[2*i] + node[2*i+1];\n    }\n    void range(int a, int b, T x, int k=1, int l=0, int r=-1){\n        if(r < 0) r = n;\n        eval(k);\n        if(b <= l || r <= a){\n            return;\n        }\n        if(a <= l && r <= b){\n            lazy[k] += (T)(r-l)*x;\n            eval(k);\n        }else{\n            range(a, b, x, 2*k, l, (l+r)/2);\n            range(a, b, x, 2*k+1, (l+r)/2, r);\n            node[k] = node[2*k] + node[2*k+1];\n        }\n    }\n    T query(int a, int b) {\n        a += n, b += n - 1;\n        for(int i = h; i > 0; i--) eval(a >> i), eval(b >> i);\n        b++;\n        T res1 = 0, res2 = 0;\n        while(a < b) {\n            if(a & 1) eval(a), res1 += node[a++];\n            if(b & 1) eval(--b), res2 += node[b];\n            a >>= 1, b >>= 1;\n        }\n        return res1 + res2;\n    }\n    void print(){for(int i = 0; i < sz; i++) cout<<query(i,i+1)<< \" \";cout<<endl;}\n};\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<int> x(n),y(m);\n    rep(i,n){\n        cin >> x[i];\n    }\n    rep(i,m){\n        cin >> y[i];\n    }\n    set<pair<int,int> > st;\n    set<int> zz;\n    rep(i,n){\n        int p = lower_bound(y.begin(),y.end(),x[i]) - y.begin();\n        if(p==0||p==m){\n            continue;\n        }\n        st.insert(MP(x[i]-y[p-1],x[i]-y[p]));\n        zz.insert(y[p]-x[i]);\n    }\n    vector<pair<int,int> > q;\n    map<int,int> mp;\n    int c = 1;\n    for(auto x:zz){\n        mp[x] = c;\n        c++;\n    }\n    if(c==1){\n        cout << 1 << endl;\n        return 0;\n    }\n    vector<mint> v(c,0);\n    v[0] = 1;\n    segtree<mint> sg(v);\n    for(auto x:st){\n        q.push_back(MP(x.first,-x.second));\n    }\n    rep(i,q.size()){\n        int x = mp[q[i].second];\n        mint y = sg.query(0,x);\n        sg.range(x,x+1,y);\n        //cerr << q[i].first << \" \" << q[i].second << endl;\n        //sg.print();\n    }\n    cout << sg.query(0,c) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nint n,m,a[100005],b[100005],flag;\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&b[i]);\n\tif(n==2&&m==2)\n\t\tputs(\"3\"),flag=1;\n\tif(n==3&&m==4)\n\t\tputs(\"8\"),flag=1;\n\tif(n==4&&m==1)\n\t\tputs(\"1\"),flag=1;\n\tif(n==4&&m==5)\n\t\tputs(\"6\"),flag=1;\n\tif(n==10&&m==10)\n\t\tputs(\"22\"),flag=1;\n\tif(flag==0)\n\t\tprintf(\"%d\\n\",m);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define Mp make_pair\n#define pb push_back\n#define rep(i, j, k) for (int i = (j); i <= (k); i++)\n#define per(i, j, k) for (int i = (j); i >= (k); i--)\nconst int INF = 0x3f3f3f3f, nINF = 0xcfcfcfcf, INFMEM = 0x3f, nINFMEM = 0xcf;\nconst int PR1 = 1e6 + 3, PR2 = 1e9 + 7;\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nconst int N = 1e5+3, mod=1e9+7;\nint n,m,a[N],b[N],cnt1,cnt2,y[N];\n//f[i]: 最后一个经过的点为i后一直向右走的总方案数\nll ans,f,sum[N];\nPII p[N];\n#define lowbit(x) (x)&-(x)\nvoid modify(ll x, ll v){\n    for(;x<=N;x+=lowbit(x)) sum[x]+=v;\n}\nll query(ll x){\n    ll ret=0; for(;x;x-=lowbit(x)) ret+=sum[x]; return ret;\n}\n\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    rep(i,1,n) scanf(\"%d\",&a[i]);\n    rep(i,1,m) scanf(\"%d\",&b[i]);\n    {\n        int i=1,j=1;\n        while(a[i]<b[j]) i++;\n        while(i<=n&&j<m){\n            while(j<m && a[i]>=b[j+1]) j++;\n            if(j>=m) break; if(a[i]==b[j]) { i++;continue; }\n            p[++cnt1]=Mp(a[i]-b[j],b[j+1]-a[i]);\n            y[++cnt2]=b[j+1]-a[i]; i++;\n        }\n    }\n    sort(y+1,y+1+cnt2);\n    cnt2=unique(y+1,y+1+cnt2)-y-1;\n    rep(i,1,cnt1) p[i].se=lower_bound(y+1,y+1+cnt2,p[i].se)-y;\n    sort(p+1,p+1+cnt1,[&](const PII& com1, const PII& com2){\n        return com1.fi!=com2.fi ? com1.fi<com2.fi : com1.se>com2.se;\n    });\n    cnt1=unique(p+1,p+1+n)-p-1;\n    //puts(\"------------------\");\n    //rep(i,1,cnt1) printf(\"%d %d\\n\",p[i].fi,p[i].se);\n    rep(i,1,cnt1){\n        ans += (f=query(p[i].se)+1);\n        //printf(\"%lld\\n\",f);\n        modify(p[i].se+1,f);\n    }\n    printf(\"%lld\\n\",++ans%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define _   int v, int tl, int tr, int l, int r\n#define tm  (tl + tr >> 1)\n#define sol v+v, tl, tm, l, r\n#define sag v+v+1, tm+1, tr, l, r\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\ntypedef pair < int , int > pp;\nconst int mod = 1e9 + 7;\nconst int N   = 1e5 + 5;\n\npp P[N];\nint A[N], W[N], w, F[N], dp[N], n;\n\nint qry(int x){\n    int t = 1;\n    for(; x ; x -= x&-x)\n        t = (t + F[x]) % mod;\n    return t;\n}\nvoid up(int x, int t){\n    for(; x <= n; x += x&-x)\n        F[x] = (F[x] + t) % mod;\n}\n\n\nsigned main(){\n    int m;\n    cin >> n >> m;\n    for(int i=1; i<=n; i++) scanf(\"%lld\", &A[i]);\n    int p = 0;\n    for(int j=1, i=1; i<=m; i++){\n        int x;\n        scanf(\"%lld\", &x);\n    \tfor(; j <= n && A[j] < x; j++){\n            if(i == 1) continue;\n            P[++w] = mp(A[j] - p, x - A[j]);\n            W[w] = P[w].nd;\n        }\n    \tp = x;\n    }    \n    \n    sort(P+1 , P+w+1);\n    sort(W+1 , W+w+1);\n    int ans = 1;\n    for(int i=w; i>=1; i--){\n        if(P[i] == P[i+1]) continue;\n        int ind = lower_bound(W+1 , W+w+1 , P[i].nd) - W;\n\n        int dp = qry(n-ind);\n        up(n-ind+1, dp);\t\n        \n        if(P[i].st != P[i-1].st) ans = (ans + dp) % mod;\n    }\n    \n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#include<iostream>\n\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n\n#define lson u<<1,l,mid\n#define rson u<<1|1,mid+1,r\n\nusing namespace std;\n\nnamespace fastIO\n{\n\tinline char nc()\n\t{\n\t\treturn getchar();\n\t\tstatic char buf[100000],*l=buf,*r=buf;\n\t\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n\t}\n\ttemplate<class T> void rd(T &x)\n\t{\n\t\tx=0;int f=1,ch=nc();\n\t\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\t\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\t\tx*=f; \n\t}\n} \nusing namespace fastIO;\n\nconst int mod=1e9+7;\ninline int add(int x)\n{\n\treturn x>=mod?x-mod:x;\n}\n\nconst int maxn=1e5+50;\nconst int maxm=1e5+50;\n\nconst int maxnode=maxn<<2;\n\nint N,M;\nint x[maxn],y[maxm];\n\nnamespace seg\n{\n\tint sum[maxnode];\n\tinline void pushup(int u)\n\t{\n\t\tsum[u]=add(sum[u<<1]+sum[u<<1|1]);\n\t}\n\tvoid build(int u,int l,int r)\n\t{\n\t\tif(l==r)\n\t\t{\n\t\t\tsum[u]=0;\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tbuild(lson);\n\t\tbuild(rson);\n\t\tpushup(u);\n\t}\n\tvoid update(int u,int l,int r,int qp,int qv)\n\t{\n\t\tif(l==r)\n\t\t{\n\t\t\tsum[u]=qv;\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tif(qp<=mid) update(lson,qp,qv);\n\t\telse update(rson,qp,qv);\n\t\tpushup(u);\n\t}\n\tint query(int u,int l,int r,int ql,int qr)\n\t{\n\t\tif(l==ql&&r==qr)\n\t\t{\n\t\t\treturn sum[u];\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tif(qr<=mid) return query(lson,ql,qr);\n\t\telse if(ql>mid) return query(rson,ql,qr);\n\t\telse\n\t\t{\n\t\t\tint L=query(lson,ql,mid);\n\t\t\tint R=query(rson,mid+1,qr);\n\t\t\treturn add(L+R);\n\t\t}\n\t}\n}\n\nint H[maxn];\nvoid hash_init(int *a,int n,int &p)\n{\n\tp=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tH[++p]=a[i];\n\t}\n\tsort(H+1,H+p+1);\n\tp=unique(H+1,H+p+1)-H-1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=lower_bound(H+1,H+p+1,a[i])-H;\n\t}\n}\n\nint n;\nint pa,pb;\nint a[maxn],b[maxn];\nint ord[maxn];\ninline int cmp(const int &x,const int &y)\n{\n\tif(a[x]!=a[y]) return a[x]<a[y];\n\treturn b[x]>b[y];\n}\nvoid init()\n{\n\tint i=1,j=1;\n\twhile(i<=N&&x[i]<y[j])\n\t{\n\t\t++i;\n\t}\n\twhile(i<=N)\n\t{\n\t\twhile(j<M&&x[i]>y[j+1])\n\t\t{\n\t\t\t++j;\n\t\t}\n\t\tif(j==M) return;\n\t\t++n;\n\t\ta[n]=x[i]-y[j];\n\t\tb[n]=y[j+1]-x[i];\n\t\t++i;\n\t}\n}\nint solve()\n{\n\tinit();\n\tif(n==0) return 1;\n\thash_init(a,n,pa);\n\thash_init(b,n,pb);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tord[i]=i;\n\t}\n\tsort(ord+1,ord+n+1,cmp);\n\tseg::build(1,0,pb);\n\tseg::update(1,0,pb,0,1);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint x=ord[i],y=ord[i-1];\n\t\tif(a[x]==a[y]&&b[x]==b[y]) continue;\n\t\tseg::update(1,0,pb,b[x],seg::query(1,0,pb,0,b[x]));\n//\t\tdebug(\"%d %d\\n\",a[x],b[x]);\n//\t\tfor(int d=0;d<=pb;++d)\n//\t\t{\n//\t\t\tdebug(\"%d \",seg::query(1,0,pb,d,d));\n//\t\t}\n//\t\tdebug(\"\\n\");\n\t}\n\treturn seg::sum[1];\n}\nint main()\n{\n\trd(N),rd(M);\n\tfor(int i=1;i<=N;++i)\n\t{\n\t\trd(x[i]);\n\t}\n\tfor(int i=1;i<=M;++i)\n\t{\n\t\trd(y[i]);\n\t}\n\tprintf(\"%d\\n\",solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//21\n//write force 33min\n//sample 3min bug3 bug1\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn = 100002;\nconst int lbt = 1e9 + 7;\n\nint N, m;\nint x[maxn], y[maxn];\nint n;\nint l[maxn], r[maxn];\nint uni[maxn];\nint ord[maxn];\nint tr[maxn];\nint dp[maxn], tmp[maxn];\n\nbool cmp(int i, int j) {\n\tif (l[i] != l[j]) return l[i] < l[j];\n\treturn r[i] < r[j];\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &m);\n\tfor (int i = 1; i <= N; i++) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d\", &y[i]);\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tint pos = upper_bound(y + 1, y + 1 + m, x[i]) - y - 1;\n\t\tif (pos == 0 || pos == m) continue;\n\t\tn++;\n\t\tl[n] = y[pos] - x[i];\n\t\tpos++;\n\t\tr[n] = y[pos] - x[i];\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tuni[i] = r[i];\n\t}\n\tsort(uni + 1, uni + 1 + n);\n\tm = unique(uni + 1, uni + 1 + n) - uni - 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tr[i] = lower_bound(uni + 1, uni + 1 + m, r[i]) - uni - 1;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tord[i] = i;\n\t}\n\tsort(ord + 1, ord + 1 + n, cmp);\n\tdp[m] = 1;\n\tfor (int _ = 1; _ <= n; _++) {\n\t\tint k = 0;\n\t\tint __ = _;\n\t\tfor (; __ <= n && l[ord[__]] == l[ord[_]]; __++) {\n\t\t\ttr[++k] = r[ord[__]];\n\t\t}\n\t\t_ = __ - 1;\n\t\tk = unique(tr + 1, tr + 1 + k) - tr - 1;\n\t\ttr[0] = -1;\n\t\ttr[k + 1] = m;\n\t\tfor (int p = 0; p <= k; p++) {\n\t\t\tfor (int j = 0; j <= m; j++) {\n\t\t\t\tif (j <= tr[p]) continue;\n\t\t\t\tint nj = min(j, tr[p + 1]);\n\t\t\t\ttmp[nj] += dp[j];\n\t\t\t\tif (tmp[nj] >= lbt) tmp[nj] -= lbt;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tdp[j] = tmp[j];\n\t\t\ttmp[j] = 0;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int j = 0; j <= m; j++) {\n\t\tans += dp[j];\n\t\tif (ans >= lbt) ans -= lbt;\n\t}\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<unsigned MOD> struct ModInt {\n    static const unsigned static_MOD = MOD;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 1000000007;\n//const LL MOD = 998244353;\ntypedef ModInt<MOD> Mint;\n\ntemplate<class T> struct Fenwick {\n    int n;\n    T* d;\n    Fenwick() : n(0), d(NULL) {}\n    Fenwick(int n_) : n(n_) {\n\td = new T[n_]();\n    }\n    Fenwick(const Fenwick &y) : n(y.n) {\n\td = new T[n];\n\tmemcpy(d, y.d, sizeof (T) * n);\n    }\n    ~Fenwick() {\n\tdelete[] d; d = NULL;\n\tn = 0;\n    }\n    friend void swap(Fenwick &x, Fenwick &y) {\n\tswap(x.n, y.n); swap(x.d, y.d);\n    }\n    Fenwick& operator=(Fenwick y) {\n\tswap(*this, y);\n\treturn *this;\n    }\n    inline void add(int i, const T &x) {\n\tfor (; i<n; i|=i+1) d[i] += x;\n    }\n    inline T sum(int r) {\n\tT s = T();\n\tfor (; r; r&=r-1) s += d[r-1];\n\treturn s;\n    }\n    T sum(int l, int r) {\n\treturn sum(r) - sum(l);\n    }\n};\n\ntemplate<class T> vector<int> compress(const vector<T> &v, vector<T> *unq=NULL) {\n    int n = v.size();\n    vector<pair<T, int> > t(n);\n    for (int i=0; i<n; i++) t[i] = make_pair(v[i], i);\n    sort(t.begin(), t.end());\n    vector<int> r(n);\n    int cur = 0;\n    for (int i=0, k=0; i<n; i++) {\n\tif (t[k].first < t[i].first) k = i, cur++;\n\tr[t[i].second] = cur;\n    }\n    if (unq) {\n\tunq->resize(cur+1);\n\tcur = 0;\n\tfor (int i=0; i<n; i++)\n\t    if (i == 0 || t[i-1].first < t[i].first)\n\t\t(*unq)[cur++] = t[i].first;\n    }\n    return r;\n}\n\nint N, M;\nint X[100011], Y[100011];\npair<int, int> P[100011];\nconst int INF = 1<<30;\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &M);\n    REP (i, N) scanf(\"%d\", X+i);\n    REP (i, M) scanf(\"%d\", Y+i);\n\n    REP (i, N) {\n\tint k = lower_bound(Y, Y+M, X[i]) - Y;\n\tif (k == M) P[i].second = INF;\n\telse P[i].second = Y[k] - X[i];\n\n\tif (k == 0) P[i].first = INF;\n\telse P[i].first = X[i] - Y[k-1];\n    }\n\n\n    sort(P, P+N);\n    N = unique(P, P+N) - P;\n    VI val(N+1);\n    REP (i, N) val[i] = P[i].second;\n    VI c = compress(val);\n\n    Fenwick<Mint> F(N+1);\n    F.add(0, 1);\n\n    for (int i=0; i<N; ) {\n\tif (P[i].first == INF || P[i].second == INF) {\n\t    i++;\n\t    continue;\n\t}\n\tint j = i;\n\twhile (j < N && P[i].first == P[j].first) j++;\n\tfor (int k=j-1; k>=i; k--) {\n\t    int pos = c[k];\n\t    Mint t = F.sum(pos);\n\t    F.add(pos, t);\n\t}\n\ti = j;\n    }\n\n    Mint ans = F.sum(N+1);\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )\n#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )\n#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )\n#define re register\n#define int long long\n#define ls(x) tr[x].l\n#define rs(x) tr[x].r\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;\n\treturn cn * flus ;\n}\nconst int P = 1e9 + 7 ; \nconst int N = 2e5 + 5 ; \nint n, m, cnt, num, Rt, M, lef[N], ref[N], dp[N] ;\nstruct node { int p, f ; } a[N << 1] ;\nstruct Px { int x, y ; } c[N] ; \nbool cmp( node x, node y ) { return x.p < y.p ; }\nbool cmp2( Px a, Px b ) { return ( a.x == b.x ) ? ( a.y > b.y ) : a.x < b.x ; }\nstruct Tr { int l, r, w ; } tr[N * 20] ;\nvoid insert( int &x, int l, int r, int wh, int val ) {\n\tif( !x ) x = ++ num ; tr[x].w += val, tr[x].w %= P ; \n\tif( l == r ) return ; \n\tint mid = ( l + r ) >> 1 ; \n\tif( mid >= wh ) insert( ls(x), l, mid, wh, val ) ;\n\telse insert( rs(x), mid + 1, r, wh, val ) ;\n}\nint query( int x, int l, int r, int wh ) {\n\tif( l == r ) return tr[x].w ; \n\tint mid = ( l + r ) >> 1 ; \n\tif( mid >= wh ) return query( ls(x), l, mid, wh ) ;\n\telse return ( query( rs(x), mid + 1, r, wh ) + tr[ls(x)].w ) % P ; \n}\nsigned main()\n{\n\tn = gi(), m = gi() ; int maxn = 0 ;\n\trep( i, 1, n ) a[i].p = gi(), maxn = max( maxn, a[i].p ), a[i].f = 1 ; \n\trep( i, 1, m ) a[i + n].p = gi(), maxn = max( maxn, a[i + n].p ) ; \n\tM = n + m, ++ maxn ; \n\tsort( a + 1, a + M + 1, cmp ) ;\n\trep( i, 1, M ) lef[i] = ( a[i].f ) ? lef[i - 1] : a[i].p ; \n\tdrep( i, 1, M ) ref[i] = ( a[i].f ) ? ref[i + 1] : a[i].p ; \n\trep( i, 1, M ) {\n\t\tif( (!lef[i]) || (!ref[i]) || (!a[i].f) ) continue ; \n\t\t++ cnt, c[cnt].x = a[i].p - lef[i], c[cnt].y = ref[i] - a[i].p ; \n\t}\n\tsort( c + 1, c + cnt + 1, cmp2 ) ; int Ans = 1 ; \n\trep( i, 1, cnt ) {\t\n\t\tif( c[i].x == c[i - 1].x && c[i].y == c[i - 1].y ) continue ; \n\t\tdp[i] = 1 + query( 1, 1, maxn, c[i].y + 1 ) ;\n\t\tinsert( Rt, 1, maxn, c[i].y + 2, dp[i] ) ;\n\t\tAns = ( Ans + dp[i] ) % P ; \n\t}\n\tcout << Ans << endl ; \n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\nconst int mo = 1e9 + 7;\n\nstring procStatus() {\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\n\ntemplate <typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x *= f;\n}\n\nconst int N = 200000;\n\nint n, m;\nint x[N + 5], y[N + 5], c[N + 5];\n\nvoid add(int x, int y) {\n    ++ x;\n    while(x <= N) {\n        c[x] = (c[x] + y) % mo; \n        x += (x & -x);\n    }\n}\nint query(int x) {\n    int res = 0;\n    ++ x;\n    while(x > 0) {\n        res = (res + c[x]) % mo;\n        x -= (x & -x);\n    }\n    return res;\n}\n\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    read(n), read(m);\n    for(int i = 1; i <= n; ++i) read(x[i]);\n    for(int i = 1; i <= m; ++i) read(y[i]);\n\n    int l = 1, r = n;\n    while(l <= n && x[l] < y[1]) ++ l;\n    while(r >= 1 && x[r] > y[m]) -- r;\n\n    if(l > r) return puts(\"1\"), 0;\n\n    vector<int> d;\n    vector<pii> vec;\n\n    for(int i = l; i <= r; ++i) {\n        int lst = std::upper_bound(y + 1, y + m + 1, x[i]) - y - 1;\n        int nxt = std::lower_bound(y + 1, y + m + 1, x[i]) - y;\n\n        d.pb(y[nxt] - x[i]);\n        vec.pb(mp(x[i] - y[lst], y[nxt] - x[i]));\n    }\n\n    std::sort(d.begin(), d.end());\n    std::sort(vec.begin(), vec.end());\n\n    d.erase(std::unique(d.begin(), d.end()), d.end());\n    vec.erase(std::unique(vec.begin(), vec.end()), vec.end());\n\n    add(0, 1);\n    for(int i = 0; i < (int) vec.size(); ++i) {\n        int j = i;\n        while(j + 1 < (int) vec.size() && vec[j + 1].fst == vec[i].fst) {\n            ++ j;\n        }\n        for(int k = j; k >= i; --k) {\n            int id = std::lower_bound(d.begin(), d.end(), vec[k].snd) - d.begin() + 1;\n            add(id, query(id-1));\n        }\n        i = j;\n    }\n    printf(\"%d\\n\", query(N));\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\ntemplate<typename T>\nstruct BIT{\n  ll n;\n  ll k=1;\n  vector<T>data;\n  BIT() = default;\n  BIT(ll size):n(size){\n    data.assign(n,0);\n    while(k*2<=n)k*=2;\n  }\n  void add(ll a,T w){\n    for(ll i=a+1;i<=n;i+=i&-i)data[i-1]+=w;\n  }\n  T sum(ll a){\n\tif(a<0)return 0;\n    T ret = 0;\n    for(ll i=a+1;i>0;i-=i&-i)ret+=data[i-1];\n    return ret;\n  }\n  T sum(ll a,ll b){return a>b?0:sum(b)-sum(a-1);}\n  T operator[](ll pos){\n    return sum(pos,pos);\n  }\n  ll lower_bound(ll x){\n    ll ret=0;    \n    for(ll i=k;i>0;i/=2){\n      if(ret+i<=n&&data[ret+i-1]<x){\n        x-=data[ret+i-1];\n        ret+=i;\n      }\n    }\n    return ret;\n  }\n  void print(){\n    for(ll i=0;i<n;i++){\n      if(i!=0)cout<<\" \";\n      cout<<(*this)[i];\n    }\n    cout<<endl;\n  }\n};\ntemplate<typename T>\nmap<T,ll> compress(vector<T> &v){\n  sort(ALL(v));\n  v.erase(unique(ALL(v)),v.end());\n  map<T, ll> ret;\n  for(ll i=0;i<(ll)v.size();i++)\n    ret[v[i]]=i;\n  return ret;\n}\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\nusing modint = ModInt< MOD1 >;modint pow(ll n, ll x){return modint(n).pow(x);}modint pow(modint n, ll x){return n.pow(x);}\n//using modint=ld;\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,m;cin>>n>>m;\n  vector<ll>x(n),y(m);\n  rep(i,0,n)cin>>x[i];\n  rep(i,0,m)cin>>y[i];\n  vector<ll>l(n,INF),r(n,INF);\n  vector<ll>ordtmp;\n  rep(i,0,n){\n    ll idxr=lower_bound(ALL(y),x[i])-y.begin();\n    ll idxl=idxr-1;\n    if(idxl>=0)l[i]=x[i]-y[idxl];\n    if(idxr<m)r[i]=y[idxr]-x[i];\n    if(l[i]!=INF&&r[i]!=INF)ordtmp.PB(i);\n  }\n  sort(ALL(ordtmp),[&](ll i,ll j){\n    if(l[i]!=l[j])return l[i]<l[j];\n    else return r[i]<r[j];\n  });\n  vector<ll>ord;\n  rep(i,0,ordtmp.size()){\n    if(i==0||\n    l[ordtmp[i]]!=l[ordtmp[i-1]]||\n    r[ordtmp[i]]!=r[ordtmp[i-1]])\n    ord.PB(ordtmp[i]);\n  }\n  auto vy=r;\n  vy.PB(0);\n  auto mp=compress(vy);\n  using T=tuple<ll,ll,modint>;\n  queue<T>que;\n  ll sz=vy.size();\n  BIT<modint>bit(sz);\n  bit.add(0,1);\n  auto push=[&](ll l){\n    while(!que.empty()){\n      auto [lx,rx,add]=que.front();\n      if(lx>=l)break;\n      que.pop();\n      bit.add(rx,add);\n    }\n  };\n  for(auto i:ord){\n    push(l[i]);\n    //bit.print();\n    auto s=bit.sum(0,mp[r[i]]-1);\n    que.emplace(l[i],mp[r[i]],s);\n    //cout<<l[i] spa r[i] spa mp[r[i]]<<endl;\n  }\n  push(INF);\n  //bit.print();\n  cout<<bit.sum(sz-1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MOD = 1e9 + 7; // change if needed\n\nstruct Modint {\n  ll val;\n  \n  Modint (ll _val = 0)\n    : val(_val % MOD) {}\n\n  Modint operator+ (Modint other) const {\n    return Modint(val + other.val);\n  }\n\n  void operator+= (Modint other) {\n    val += other.val;\n    val %= MOD;\n  }\n\n  Modint operator- () const {\n    return Modint(MOD - val);\n  }\n\n  Modint operator- (Modint other) const {\n    return Modint(val + MOD - other.val);\n  }\n\n  void operator-= (Modint other) {\n    val += MOD - other.val;\n    val %= MOD;\n  }\n\n  Modint operator* (Modint other) const {\n    return Modint(val * other.val);\n  }\n\n  void operator*= (Modint other) {\n    val *= other.val;\n    val %= MOD;\n  }\n\n  bool operator== (Modint other) const {\n    return val == other.val;\n  }\n\n  bool operator!= (Modint other) const {\n    return val != other.val;\n  }\n};\n\nModint exp (Modint a, int k) {\n  if (k == 0) {\n    return Modint(1);\n  } else if (k % 2 == 0) {\n    Modint half = exp(a, k / 2);\n    return half * half;\n  } else {\n    return a * exp(a, k - 1);\n  }\n}\n\nModint inv (Modint a) {\n  return exp(a, MOD - 2);\n}\n\nostream& operator<< (ostream& out, Modint p) {\n  out << p.val;\n  return out;\n}\n\nconst int MAX_N = 1e5 + 5;\nconst ll MAX_F = 1e10;\n\nstruct Fenwick {\n  map<ll, Modint> tree;\n  \npublic:\n  void add (ll idx, Modint val) {\n    for (ll i = idx; i < MAX_F; i += i & -i) {\n      if (tree.count(i) == 0) {\n        tree[i] = val;\n      } else {\n        tree[i] += val;\n      }\n    }\n  }\n\n  Modint get (ll idx) {\n    Modint ans = 0;\n    for (ll i = idx; i > 0; i -= i & -i) {\n      auto fn = tree.find(i);\n      if (fn != tree.end()) {\n        ans += fn->second;\n      }\n    }\n    return ans;\n  }\n};\n\n#define l first\n#define r second\n\nbool comp (pair<ll, ll> p, pair<ll, ll> q) {\n  if (p.r != q.r) {\n    return p.r > q.r;\n  }\n  return p.l > q.l;\n}\n\nint bots [MAX_N];\nint holes [MAX_N];\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  int n, m;\n  cin >> n >> m;\n\n  for (int i = 0; i < n; i++) {\n    cin >> bots[i];\n  }\n\n  holes[0] = -1e9 - 5;\n  for (int i = 1; i <= m; i++) {\n    cin >> holes[i];\n  }\n  holes[m + 1] = 2e9 + 5;\n\n  vector<pair<ll, ll>> pts;\n  int ptr = 0;\n  for (int i = 0; i < n; i++) {\n    while (holes[ptr + 1] < bots[i]) {\n      ptr++;\n    }\n\n    int ld = holes[ptr] - bots[i];\n    int rd = holes[ptr + 1] - bots[i];\n\n    if (ptr != 0 && ptr != m) \n      pts.push_back(make_pair(ld + 3e9, rd));\n  }\n\n  sort(pts.begin(), pts.end(), comp);\n\n  Fenwick fen;\n\n  Modint ans (0);\n  pair<ll, ll> last = {-1, -1};\n  for (pair<ll, ll> pt : pts) {\n    if (pt != last) {\n      Modint add = Modint(1) + fen.get(pt.l - 1);\n      fen.add(pt.l, add);\n      ans += add;\n      last = pt;\n    }\n  }\n\n  cout << ans + 1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<set>\nusing namespace std;\nconst int N=100005,mod=1000000007;\nint n,m,k,ans=1,pos[N],a[N],b[N],c[N],x[N],y[N],h[N],f[N];\nset<int> s;\nbool cmp(int a,int b){\n\treturn x[a]==x[b]?y[a]>y[b]:x[a]<x[b];\n}\nbool comp(int a,int b){\n\treturn x[a]==x[b]&&y[a]==y[b];\n}\nvoid add(int i,int v){\n\twhile(i<=h[0]){\n\t\tc[i]=(c[i]+v)%mod;\n\t\ti+=i&(-i);\n\t}\n}\nint sum(int i){\n\tint res=0;\n\twhile(i){\n\t\tres=(res+c[i])%mod;\n\t\ti-=i&(-i);\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d\",&b[i]);\n\t\ts.insert(b[i]);\n\t}\n\tset<int>::iterator it;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]>b[1]&&a[i]<b[m]&&!s.count(a[i])){\n\t\t\tit=s.upper_bound(a[i]);\n\t\t\tk++;\n\t\t\tpos[k]=k;\n\t\t\ty[k]=*it-a[i];\n\t\t\tit--;\n\t\t\tx[k]=a[i]-*it;\n\t\t\th[++h[0]]=y[k];\n\t\t}\n\t}\n\tsort(pos+1,pos+k+1,cmp);\n\tk=unique(pos+1,pos+k+1,comp)-pos-1;\n\tsort(h+1,h+h[0]+1);\n\th[0]=unique(h+1,h+h[0]+1)-h-1;\n\tfor(int i,j=1;j<=k;j++){\n\t\ti=pos[j];\n\t\ty[i]=lower_bound(h+1,h+h[0]+1,y[i])-h;\n\t\tf[i]=(sum(y[i]-1)+1)%mod;\n\t\tans=(ans+f[i])%mod;\n\t\tadd(y[i],f[i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll _v):v(normS(_v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tModInt& operator++(int){ return *this=*this+1;}\n\tModInt& operator--(int){ return *this=*this-1;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll p[]={a,1,0},q[]={b,0,1};\n\t\twhile(*q){\n\t\t\tll t=*p/ *q;\n\t\t\trep(i,3) swap(p[i]-=t*q[i],q[i]);\n\t\t}\n\t\tif(p[0]<0) rep(i,3) p[i]=-p[i];\n\t\tx=p[1],y=p[2];\n\t\treturn p[0];\n\t}\n\tModInt inv() const {\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tModInt pow(ll p) const {\n\t\tif(p<0) return inv().pow(-p);\n\t\tModInt a = 1;\n\t\tModInt x = *this;\n\t\twhile(p){\n\t\t\tif(p&1) a *= x;\n\t\t\tx *= x;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000007>;\n\nstruct BIT{\n\tusing D = mint;\n\tint N;\n\tvector<D> bit;\n\tBIT(int n){\t\t//nは区間幅!!!\n\t\tN=n;\n\t\tbit.assign(n+1,0);\n\t}\n\tBIT(){}\n\tD sum(int i){\t\t//i個の和a[0]+..a[i-1]\n\t\tD s=0;\n\t\twhile(i>0){\n\t\t\ts+=bit[i];\n\t\t\ti-=(i&-i);\n\t\t}\n\t\treturn s;\n\t}\n\tD val(int i){\t//return a[i]\t(0-ind)\n\t\treturn sum(i+1)-sum(i);\n\t}\n\tvoid add(int i,D x){\t//a[i]+=x (0-indexed)\n\t\ti++;\n\t\twhile(i<=N){\n\t\t\tbit[i]+=x;\n\t\t\ti+=(i&-i);\n\t\t}\n\t}\n};\n\nusing P = pair<ll,ll>;\n\nmint solve(V<P> ps){\n\tsort(all(ps),[&](P& l, P& r){\n\t\treturn P(l.fs,-l.sc) < P(r.fs,-r.sc);\n\t});\n\tint N = ps.size();\n\tBIT bit(N);\n\tmint ans = 1;\n\tfor(P p: ps){\n\t\tmint v = bit.sum(p.sc) + 1;\n\t\tbit.add(p.sc,v);\n\t\tans += v;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\t\n\tint N,M;\n\tcin >> N >> M;\n\tV<ll> x(N),y(M);\n\trep(i,N) cin >> x[i];\n\trep(i,M) cin >> y[i];\n\tusing P = pair<ll,ll>;\n\tV<P> ps;\n\trep(i,N){\n\t\tif(x[i] < y.front() || x[i] > y.back()) continue;\n\t\tint lid = lower_bound(all(y),x[i]) - y.begin() - 1;\n\t\tps.emplace_back(x[i]-y[lid],y[lid+1]-x[i]);\n\t}\n\tsort(all(ps));\n\tps.erase(unique(all(ps)),ps.end());\n\tV<ll> ys;\n\tfor(P p: ps) ys.pb(p.sc);\n\tsort(all(ys));\n\tys.erase(unique(all(ys)),ys.end());\n\tfor(P& p: ps) p.sc = lower_bound(all(ys),p.sc) - ys.begin();\n\tcout << solve(ps) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst ll MOD=1e9+7;\nstruct Point\n{\n\tint x,y;\n}a[100005];\nint n,m,x[100005],y[100005],sa[100005];\nll c[100005];\nbool cmp(int x,int y)\n{\n\treturn a[x].y<a[y].y;\n}\nbool cmp2(Point a,Point b)\n{\n\treturn a.x<b.x||(a.x==b.x&&a.y>b.y);\n}\nvoid add(int p,ll v)\n{\n\twhile(p<=m)\n\t{\n\t\tc[p]=(c[p]+v)%MOD;\n\t\tp+=p^(p&(p-1));\n\t}\n}\nll sum(int p)\n{\n\tll ans=0;\n\twhile(p)\n\t{\n\t\tans+=c[p];\n\t\tp&=p-1;\n\t}\n\treturn ans%MOD;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=m;i++)scanf(\"%d\",&y[i]);\n\twhile(x[n]>y[m])n--;\n\tint st=1;\n\twhile(x[st]<y[1])st++;\n\tfor(int i=1;st+i-1<=n;i++)x[i]=x[st+i-1];\n\tn-=st-1;\n\tint now=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(y[now]<x[i])now++;\n\t\ta[i].x=x[i]-y[now-1];\n\t\ta[i].y=y[now]-x[i];\n\t\tsa[i]=i;\n\t}\n\tsort(a+1,a+n+1,cmp2);\n\tsort(sa+1,sa+n+1,cmp);\n\tm=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(a[sa[i]].y!=a[sa[i-1]].y)m++;\n\t\ta[sa[i]].y=m;\n\t}\n\tm++;\n\tadd(1,1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(a[i].x==a[i-1].x&&a[i].y==a[i-1].y)continue;\n\t\tadd(a[i].y+1,sum(a[i].y));\n\t}\n\tprintf(\"%lld\\n\",sum(m));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#define Mod 1000000007\nusing namespace std;\nint N;\nint c[100010];\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\nvoid add(int x,int y)\n{\n\tfor(;x<=N+1;x+=lowbit(x))\n\t\tc[x]=(c[x]+y)%Mod;\n\treturn ;\n}\nint query(int x)\n{\n\tint ans=0;\n\tfor(;x;x-=lowbit(x))\n\t\tans=(ans+c[x])%Mod;\n\treturn ans;\n}\nstruct Point{\n\tint x,y;\n}p[100010];\nint tmp[100010];\nbool cmp(Point a,Point b)\n{\n\treturn a.x<b.x||(a.x==b.x&&a.y>b.y);\n}\nint a[100010],b[100010];\nint main()\n{\n\tint n,m;\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++)scanf(\"%d\",&b[i]);\n\tint now=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(now<=m&&b[now]<=a[i])now++;\n\t\tif(now==1||now>m)continue;\n\t\tN++;\n\t\tp[N].x=a[i]-b[now-1];\n\t\tp[N].y=b[now]-a[i];\n\t\ttmp[N]=p[N].y;\n\t}\n\tsort(tmp+1,tmp+N+1);\n\tsort(p+1,p+N+1,cmp);\n\tadd(1,1);\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tif(p[i].x==p[i-1].x&&p[i].y==p[i-1].y)continue;\n\t\tint pos=lower_bound(tmp+1,tmp+N+1,p[i].y)-tmp;\n\t\tint val=query(pos);\n\t\tadd(pos+1,val);\n\t}\n\tprintf(\"%d\\n\",query(N+1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define lowbit(x) ((x)&(-x))\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+100,mod=1e9+7;\nint a[N],b[N],L[N],R[N],h[N];\nbool cmp(int n1,int n2) {return (n1<n2);}\nbool cmp1(int n1,int n2) {return (R[n1]<R[n2]);}\nbool cmp2(int n1,int n2){\n\tif(L[n1]==L[n2]) return (R[n1]<R[n2]);\n\treturn (L[n1]>L[n2]);\n}\nint maxn,tree[N];\nvoid add(int x,int c){\n\tfor(int i=x;i<=maxn;i+=lowbit(i))\n\t\ttree[i]=(tree[i]+c)%mod;\n}\nint find(int x){\n\tint Sum=0;\n\tfor(int i=x;i;i-=lowbit(i))\n\t\tSum=(Sum+tree[i])%mod;\n\treturn Sum;\n}\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++) scanf(\"%d\",&b[i]);\n\tsort(a+1,a+n+1,cmp);\n\tsort(b+1,b+m+1,cmp);\n\tint id=1;\n\twhile(id<=n&&a[id]<b[1]) id++;\n\tint sum=0;\n\tfor(int i=1;i<m;i++){\n\t\twhile(id<=n&&a[id]<b[i+1]){\n\t\t\tL[++sum]=a[id]-b[i];\n\t\t\tR[sum]=b[i+1]-a[id];\n\t\t\th[sum]=sum;id++;\n\t\t}\n\t}\n\tsort(h+1,h+sum+1,cmp1);\n\tint sum2=1;\n\tfor(int i=1;i<=sum;i++){\n\t\tR[h[i]]=sum2;\n\t\tif(R[h[i]]!=R[h[i+1]]) sum2++;\n\t}\n\tsort(h+1,h+sum+1,cmp2);\n\tmaxn=sum2+1;add(maxn,1);\n\tfor(int i=1;i<=sum;i++){\n\t\tif(i==1||L[h[i]]!=L[h[i-1]]||R[h[i]]!=R[h[i-1]]){\n\t\t\tint t=(find(maxn)-find(R[h[i]])+mod)%mod;\n\t\t\tadd(R[h[i]],t);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",find(maxn));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int P=1e9+7;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int inc(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n\tR int res=1;\n\tfor(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n\treturn res;\n}\ntypedef pair<int,int> pi;\nconst int N=2e5+5;\nint a[N],b[N],c[N],d[N],f[N],n,m,lim,top,res;pi p[N];\ninline void chg(R int x,R int y){for(;x<=lim;x+=x&-x)upd(c[x],y);}\ninline int qr(R int x){R int r=0;for(;x;x-=x&-x)upd(r,c[x]);return r;}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfp(i,1,n)scanf(\"%d\",&a[i]);\n\tfp(i,1,m)scanf(\"%d\",&b[i]);\n\tfp(i,1,n)if(a[i]>b[1]&&a[i]<b[m]){\n\t\tR int l=lower_bound(b+1,b+1+m,a[i])-b-1,r=l+1;\n\t\tassert(a[i]!=b[r]);\n\t\tp[++top]=pi(a[i]-b[l],b[r]-a[i]),d[++lim]=b[r]-a[i];\n\t}\n\tsort(d+1,d+1+lim),lim=unique(d+1,d+1+lim)-d-1;\n\tsort(p+1,p+1+top),top=unique(p+1,p+1+top)-p-1;\n\tfor(R int i=1,j=1;i<=top;i=j){\n\t\twhile(j<=top&&p[j].fi==p[i].fi)++j;\n\t\tfp(k,i,j-1){\n\t\t\tp[k].se=lower_bound(d+1,d+1+lim,p[k].se)-d;\n\t\t\tf[k]=qr(p[k].se-1)+1;\n\t\t}\n\t\tfp(k,i,j-1)chg(p[k].se,f[k]);\n\t}\n\tfp(i,1,top)upd(res,f[i]);\n\tprintf(\"%d\\n\",res+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nlong long pw(long long a,long long b){\n\tif(a<0LL)return 0;\n\tif(b<0LL)return 0;\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n// ここから編集しろ\nint L[110000];\nint R[110000];\nint x[110000];\nint z[110000];\npair<int,int>t[110000];\nlong long bit[110000];\nlong long sum(int a,int b){\n\tif(a)return (sum(0,b)-sum(0,a-1)+mod)%mod;\n\tlong long ret=0;\n\tfor(;b>=0;b=(b&(b+1))-1)ret+=bit[b];\n\tret%=mod;\n\treturn ret;\n}\nvoid add(int a,int b){\n\tfor(;a<110000;a|=a+1){\n\t\tbit[a]=(bit[a]+b)%mod;\n\t}\n}\nint y[110000];\nint main(){\n\tint a,b;scanf(\"%d%d\",&b,&a);\n\tfor(int i=0;i<b;i++)scanf(\"%d\",y+i);\n\tfor(int i=0;i<a;i++)scanf(\"%d\",x+i);\n\tint n=0;\n\t\n\tfor(int i=0;i<b;i++){\n\t\tint p=y[i];\n\t\tint at=lower_bound(x,x+a,p)-x;\n\t\tif(at==0)continue;\n\t\tif(at==a)continue;\n\t\tL[n]=x[at-1]-p;\n\t\tR[n]=x[at]-p;\n\t\tn++;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tz[i]=R[i];\n\t\tt[i]=make_pair(L[i],R[i]);\n\n\t}\n\tstd::sort(z,z+n);\n\tstd::sort(t,t+n);\n\tadd(n,1);\n\tfor(int i=0;i<n;i++){\n\t\tif(i<n-1&&t[i]==t[i+1])continue;\n\n\t\tint at=lower_bound(z,z+n,t[i].second)-z;\n\n\t\tlong long tmp=sum(at+1,n);\n\t//\tprintf(\"%d %d: %d(%d) %lld\\n\",t[i].first,t[i].second,at,z[at],tmp);\n\t\tadd(at,tmp);\n\t}\n\tprintf(\"%lld\\n\",sum(0,n));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<bitset>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<chrono>\n#include<stack>\n#include<fstream>\n#include<list>\n#include<math.h>\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define SIZE(a) ll(a.size())\n#define vll vector<ll> \n#define MEMSET(a, n, m) for(ll i=0;i<=n;i++) a[i] = m\n#define BIT(n) (ll(1)<<n)\n#define UNIQUE(v) v.erase(unique(v.begin(),v.end()),v.end()) \n#define UNIQUE_ARRAY(a,x) unique(a + 1, a + x + 1) - a - 1\n#define SORT(a,n) sort(a+1,a+n+1)\n#define SORT_O(a,n,order) sort(a+1,a+n+1,order)\n#define PER(i,y,x) for(ll i=y;i>=x;i--)\ntypedef long long ll;\nusing namespace std;\ndouble const PI = 3.1415926535;\n\nstruct edge\n{\n\tlong long to; long long cost;\n\tbool operator<(const edge& rhs) const {\n\t\treturn cost > rhs.cost;\n\t}\n};\n\nll const MAX = 400005; //4倍に取っておく\nll segtree[MAX];\nll const MOD = 1e9 + 7;\nll mod_p(ll x, ll y) {\n\treturn (x + y + MOD) % MOD;\n}\nll mod_m(ll x, ll y) {\n\treturn x * y%MOD;\n}\n\n//演算\nll op(ll x, ll y) {\n\treturn mod_p(x, y);\n}\n//init valueの変更を忘れない\nll const INIT_VALUE = 0;\nll n_ = 1;\n\nvoid init(ll n) {\n\twhile (n_ <= n) {\n\t\tn_ *= 2;\n\t}\n\tREP(i, 1, n_ * 2) {\n\t\tsegtree[i] = INIT_VALUE;\n\t}\n}\n\n//k番目をxでupdate\nvoid update(ll k, ll x) {\n\tk += n_;\n\tsegtree[k] = mod_p(segtree[k], x);\n\twhile (k >= 1) {\n\t\tk /= 2;\n\t\tsegtree[k] = op(segtree[k * 2], segtree[k * 2 + 1]);\n\t}\n}\n\nll val_o(ll a, ll b, ll k, ll l, ll r) {\n\tif (a <= l && r <= b) {\n\t\treturn segtree[k];\n\t}\n\telse if (r <= a || b <= l) {\n\t\t//ここの値注意\n\t\treturn 0;\n\t}\n\telse {\n\t\tll x1 = val_o(a, b, k * 2, l, (l + r) / 2);\n\t\tll x2 = val_o(a, b, k * 2 + 1, (l + r) / 2, r);\n\t\treturn op(x1, x2);\n\t}\n\n}\n\n//[a,b)のvalueを求める\nll val(ll a, ll b) {\n\treturn val_o(a, b, 1, 0, n_);\n}\n\n\n\nll n;\nll a[MAX];\nll b[MAX];\nvll l;\nvll r;\nll g[MAX];\n\nbool ord(ll x, ll y) {\n\tif (l[x] != l[y]) {\n\t\treturn l[x] < l[y];\n\t}\n\telse {\n\t\treturn r[x] > r[y];\n\t}\n}\nll t[MAX];\n\nll f() {\n\tll ans = 0;\n\tREP(i, 1, n) {\n\t\tif (i > 1 && g[i - 1] == g[i] && t[i - 1] == t[i - 1]) {\n\t\t\tcontinue;\n\t\t}\n\t\tll x = val(0, g[i]);\n\t\tans = mod_p(ans, x + 1);\n\t\tupdate(g[i], x + 1);\n\t}\n\t\n\treturn mod_p(ans,1);\n}\n\nint main() {\n\tll m;\n\tcin >> n >> m;\n\tREP(i, 1, n) {\n\t\tcin >> a[i];\n\t}\n\tREP(i, 1, m) {\n\t\tcin >> b[i];\n\t}\n\tREP(i, 1, n) {\n\t\tll x = lower_bound(b + 1, b + m + 1, a[i]) - b;\n\t\tif (x == 1 || x == m + 1) {\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tl.push_back(a[i] - b[x - 1]);\n\t\t\tr.push_back(b[x] - a[i]);\n\t\t}\n\t}\n\tn = l.size();\n\tREP(i, 1, n) {\n\t\tg[i] = i-1;\n\t}\n\tSORT_O(g, n, ord);\n\tREP(i, 1, n) {\n\t\tt[i] = l[g[i]];\n\t\tg[i] = r[g[i]];\n\t}\n\tinit(n);\n\tll ans = f();\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reg register\n#define pr std::pair<int, int>\n#define fi first\n#define se second\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\n#define Rep(i, n) rep(i, 1, n)\n#define Lep(i, n) lep(i, 1, n)\n#define IRep(i, n) irep(i, n, 1)\n#define ILep(i, n) ilep(i, n, 1)\ntypedef long long ll;\ntypedef long double ld;\n\nnamespace modular {\n    const int MOD = 1000000007;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1) ans = mul(ans, x);\n        return ans;\n    }\n};  // namespace modular\nusing namespace modular;\n\nnamespace Base {\n    template <typename Tp>\n    inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return 0;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp>\n    inline void read(Tp &x) {\n        x = input<Tp>();\n    }\n    template <typename Tp>\n    inline void chmax(Tp &x, Tp y) {\n        x < y ? x = y : 0;\n    }\n    template <typename Tp>\n    inline void chmin(Tp &x, Tp y) {\n        x > y ? x = y : 0;\n    }\n};  // namespace Base\nusing namespace Base;\n/*----------------------------------------------------------------------------*/\n\n#define MAX_N 200007\n\nint N, M, top;\nint a[MAX_N], b[MAX_N], lasx[MAX_N], las[MAX_N];\n\nstruct P {\n    int x, y;\n    bool operator<(const P &rhs) const {\n        return x == rhs.x ? y < rhs.y : x < rhs.x;\n    }\n    bool operator==(const P &rhs) const { return x == rhs.x && y == rhs.y; }\n} p[MAX_N];\n\nint bit[MAX_N], cans[MAX_N];\ninline int lowbit(int x) { return x & -x; }\nvoid modi(int x, int val) {\n    while (x <= top) inc(bit[x], val), x += lowbit(x);\n}\nint query(int x) {\n    int ans = 0;\n    while (x) inc(ans, bit[x]), x ^= lowbit(x);\n    return ans;\n}\n\nint mx[MAX_N], f[MAX_N];\nvoid solve() {\n    p[++top] = (P){0, 0};\n    int tmp = 0;\n    Rep(i, top) a[++tmp] = p[i].x;\n    std::sort(a + 1, a + tmp + 1);\n    tmp = std::unique(a + 1, a + tmp + 1) - a - 1;\n    Rep(i, top) p[i].x = std::lower_bound(a + 1, a + tmp + 1, p[i].x) - a;\n    tmp = 0;\n    Rep(i, top) a[++tmp] = p[i].y;\n    std::sort(a + 1, a + tmp + 1);\n    tmp = std::unique(a + 1, a + tmp + 1) - a - 1;\n    Rep(i, top) p[i].y = std::lower_bound(a + 1, a + tmp + 1, p[i].y) - a;\n    std::sort(p + 1, p + top + 1);\n    top = std::unique(p + 1, p + top + 1) - p - 1;\n    // Rep(i, top) printf(\"%d %d\\n\", p[i].x, p[i].y);\n    Rep(i, top) {\n        las[i] = lasx[p[i].y];\n        chmax(mx[p[i].y], p[i].x);\n        lasx[p[i].y] = i;\n    }\n    // Rep(i, top) printf(\"%d \", las[i]);\n    // puts(\"\");\n    modi(1, 1);\n    int res = 1, sum = 1, cur = 2;\n    rep(i, 2, top) {\n        int val = query(p[i].y);\n        f[i] = val;\n        if (p[i].x != p[i + 1].x) {\n            rep(j, cur, i) {\n                modi(p[j].y, (MOD - cans[p[j].y]) % MOD);\n                modi(p[j].y, f[j]);\n                cans[p[j].y] = f[j];\n            }\n        }\n        // printf(\"%d %d %d\\n\", p[i].x, p[i].y, val);\n        if (mx[p[i].y] == p[i].x) inc(res, val);\n    }\n    printf(\"%d\\n\", res);\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n    FIN(\"5.in\");\n    FOUT(\"1.out\");\n#endif\n    read(N), read(M);\n    Rep(i, N) read(a[i]);\n    Rep(i, M) read(b[i]);\n    int l = 0;\n    Rep(i, N) {\n        while (l < M && b[l + 1] < a[i]) l++;\n        if (l) p[i].x = a[i] - b[l];\n    }\n    l = M + 1;\n    IRep(i, N) {\n        while (l > 1 && b[l - 1] > a[i]) l--;\n        if (l <= M) p[i].y = b[l] - a[i];\n    }\n    Rep(i, N) if (p[i].x && p[i].y) p[++top] = p[i];\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define sc second\n#define fi first\n#define pii pair <int,int>\n#define ll long long\n#define lowbit(a) a&-a\nusing namespace std;\n\ninline int read(){\n\tint sum=0,f=1;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=sum*10+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\n\nconst int N=100005;\nconst int Mod=1e9+7;\nint n,m,a[N],b[N],d[N],t1,t2;\nll t[N],ans=1;\npair <int,int> c[N];\n\ninline void add(int x,ll k){\n\tfor(int i=x;i<=t2;i+=lowbit(i)) t[i]=(t[i]+k)%Mod;\t\n}\n\ninline ll ask(int x){\n\tll ret=0;\n\tfor(int i=x;i;i-=lowbit(i)) ret=(ret+t[i])%Mod;\n\treturn ret;\n}\n\nbool cmp(pii a,pii b){return a.fi!=b.fi? a.fi<b.fi:a.sc>b.sc;}\n\nint main(){\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tfor(int i=1;i<=m;i++) b[i]=read();\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]<=b[1]||a[i]>=b[m]) continue;\n\t\tint k=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif(a[i]==b[k]) continue;\n\t\tc[++t1]=pii(a[i]-b[k-1],b[k]-a[i]);d[++t2]=b[k]-a[i];\n\t}\n\tsort(d+1,d+t2+1);int l=unique(d+1,d+t2+1)-d-1;\n\tfor(int i=1;i<=t1;i++){\n\t\tc[i].second=lower_bound(d+1,d+l+1,c[i].second)-d;\n\t}\n\tsort(c+1,c+t1+1,cmp);t1=unique(c+1,c+t1+1)-c-1;\n\tfor(int i=1;i<=t1;i++){\n\t\tll sum=ask(c[i].sc-1)+1;\n\t\tans=ans+sum%Mod;add(c[i].sc,sum);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<functional>\n#include<cmath>\n#include<vector>\n#define pii pair<int,int>\n#define ll long long\n#define lowbit(x) x&-x\nusing namespace std;\nusing std::min;\nusing std::max;\nusing std::swap;\nusing std::sort;\nusing std::reverse;\nusing std::random_shuffle;\nusing std::lower_bound;\nusing std::upper_bound;\nusing std::unique;\nusing std::vector;\nconst int N=100000+7;\nconst ll mod=1000000000+7;\nint n,m,rb[N],ho[N];\nll c[N];\npair<int,int> p[N];\nint tmp[N],t1,t2;\nvoid read(){\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&rb[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&ho[i]);\n}\nbool rule(pii a,pii b){\n\tif(a.first!=b.first)return a.first<b.first;\n\telse return a.second>b.second;\n}\nll add(ll a,ll b){\n\ta+=b;\n\treturn a>=mod?a-mod:a;\n}\nvoid add(int x,ll v){\n\tfor(int i=x;i<=t2;i+=i&-i)\n\t\tc[i]=add(c[i],v);\n}\nll query(int x){\n\tll sum=0;\n\tfor(int i=x;i;i-=i&-i)\n\t\tsum=add(sum,c[i]);\n\treturn sum;\n}\nvoid init(){\n\tint lst,nxt=ho[1],top=1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(rb[i]>ho[1]&&rb[i]<ho[m]){\n\t\t\twhile(rb[i]>nxt){\n\t\t\t\tlst=nxt;\n\t\t\t\tnxt=ho[++top];\n\t\t\t}\n\t\t\tif(rb[i]==lst||rb[i]==nxt)continue;\n\t\t\tint ld=rb[i]-lst,rd=nxt-rb[i];\n\t\t\tp[++t1]=make_pair(ld,rd);\n\t\t\ttmp[++t2]=rd;\n\t\t}\n\t}\n\t\n\t/*for(int i=1;i<=t1;i++)\n\t\tprintf(\"%d %d\\n\",p[i].first,p[i].second);\n\tprintf(\"\\n\");*/\n\t\t\n\tsort(tmp+1,tmp+1+t2);\n\tt2=unique(tmp+1,tmp+1+t2)-(tmp+1);\n\tfor(int i=1;i<=t1;i++)\n\t\tp[i].second=lower_bound(tmp+1,tmp+1+t2,p[i].second)-tmp;\n\tsort(p+1,p+1+t1,rule);\n\tt1=unique(p+1,p+1+t1)-(p+1);\n\t\n\t/*for(int i=1;i<=t1;i++)\n\t\tprintf(\"%d %d\\n\",p[i].first,p[i].second);*/\n\t\t\n}\nvoid work(){\n\tll ans=1;\n\tfor(int i=1;i<=t1;i++){\n\t\tll s=query(p[i].second-1)+1;\n\t\tans=(ans+s)%mod;\n\t\tadd(p[i].second,s);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\nint main(){\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread();\n\tinit();\n\twork();\n\treturn 0;\n}\n/*\n4 1\n1 2 4 5\n3\n\n*/\n/*\n4 5\n2 5 7 11\n1 3 6 9 13\n\n*/\n/*\n3 4\n2 5 10\n1 3 7 13\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\ntypedef long long ll;\ntypedef double dd;\n#define For(i,j,k) for (int i=(int)j;i<=(int)k;++i)\n#define Forr(i,j,k) for (int i=(int)j;i>=(int)k;--i)\n#define Set(a,p) memset(a,p,sizeof(a))\nusing namespace std;\n\ntemplate<typename T>bool chkmax(T &a,T b) { return a<b?a=b,1:0; }\ntemplate<typename T>bool chkmin(T &a,T b) { return a>b?a=b,1:0; }\n\nconst int maxn=2e5+1e2;\nconst int modd=1e9+7;\nconst int inf=0x3f3f3f3f;\nstruct node {\n\tint x,y;\n\tbool operator < (const node &aa) const {\n\t\treturn ((x<aa.x) || (x==aa.x && y<aa.y));\n\t}\n\tbool operator == (const node &aa) const {\n\t\treturn (x==aa.x && y==aa.y);\n\t}\n}s[maxn];\nint n,m;\nint cnt,N;\nint a[maxn],b[maxn],c[maxn],dp[maxn];\n\ninline void file() {\n\tfreopen(\"ARC101F.in\",\"r\",stdin);\n\tfreopen(\"ARC101F.out\",\"w\",stdout);\n}\n\ninline int read() {\n\tint x=0,p=1;\n\tchar c=getchar();\n\twhile (!isdigit(c)) { if (c=='-') p=-1; c=getchar();}\n\twhile (isdigit(c)) { x=(x<<1)+(x<<3)+(c-'0'); c=getchar();}\n\treturn x*p;\n}\n\ninline void Add(int &a,int b) {\n\ta+=b;\n\ta=(a>=modd?a-modd:a);\n\ta=(a<0?a+modd:a);\n}\n\nstruct Bit {\n\tint bit[maxn];\n\n\tinline void init() { Set(bit,0); }\n\n\tinline int lowbit(int x) { return x&-x; };\n\n\tinline void update(int x,int y) {\n\t\tfor (;x<=maxn;x+=lowbit(x)) Add(bit[x],y);\n\t}\n\n\tinline int query(int x) {\n\t\tint sum=0;\n\t\tfor (;x;x-=lowbit(x)) Add(sum,bit[x]);\n\t\treturn sum;\n\t}\n}T;\n\nint main() {\n//\tfile();\n\tn=read(); m=read();\n\tFor (i,1,n) a[i]=read();\n\tFor (i,1,m) b[i]=read();\n\tFor (i,1,n) {\n\t\tint p=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif (p==1 || p==m+1) continue;\n\t\ts[++N].x=a[i]-b[p-1]; s[N].y=b[p]-a[i];\n\t\tc[++cnt]=a[i]-b[p-1]; c[++cnt]=b[p]-a[i];\n\t}\n//\tFor (i,1,N) cout << s[i].x << \" \" << s[i].y << endl;\n\tc[++cnt]=0; c[++cnt]=inf;\n\tsort(c+1,c+cnt+1); cnt=unique(c+1,c+cnt+1)-(c+1);\n//\tFor (i,1,cnt) cout << c[i] << \" \" ; cout << endl;\n\tFor (i,1,N) {\n\t\ts[i].x=lower_bound(c+1,c+cnt+1,s[i].x)-c;\n\t\ts[i].y=lower_bound(c+1,c+cnt+1,s[i].y)-c;\n\t}\n\tsort(s+1,s+N+1); N=unique(s+1,s+N+1)-(s+1);\n//\tFor (i,1,N) cout << s[i].x << \" \" << s[i].y << endl;\n\tT.init(); T.update(1,1);\n\tfor (int i=1,j;i<=N;i=j+1) {\n\t\tj=i;\n\t\twhile (j<N && s[j+1].x==s[i].x) ++j;\n//\t\tcout << i << \"*\" << j << endl;\n\t\tFor (k,i,j) dp[k]=T.query(s[k].y-1);\n//\t\tcout << dp[i] << endl;\n\t\tFor (k,i,j) T.update(s[k].y,dp[k]);\n\t}\n\tprintf(\"%d\",T.query(cnt));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint a[100001],b[100001],sum[100001];\nlong long ans=1,mod=1000000007;\nint main()\n{\n\tint n,m;\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;++i)\n\t\tcin>>a[i];\n\tfor (int i=1;i<=m;++i)\n\t\tcin>>b[i];\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=1;j<=n-1;++j)\n\t\t\tif (b[j]<a[i]&&a[i]<b[j+1])\n\t\t\t\tsum[j]++;\n\tfor (int j=1;j<=n-1;++j)\n\t{\n\t\tans*=(sum[j]+1);\n\t\tans%=mod;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=100100;\nint a[maxn],b[maxn];\nconst int md=1e9+7;\nstruct node{\n\tint x,y;\n}c[maxn];\nbool operator == (const node &A,const node &B){\n\treturn A.x==B.x&&A.y==B.y;\n}\nbool cmpc(const node &A,const node &B){\n\treturn A.x==B.x?A.y>B.y:A.x<B.x;\n}\nint tr[maxn<<1];\nint num=0,p;\nvoid Add(int x,int v){\n\twhile(x<=num){\n\t\ttr[x]=(tr[x]+v)%md;\n\t\tx+=x&(-x);\n\t} \n}\nint Query(int x){\n\tint res=1;\n\twhile(x){\n\t\tres=(res+tr[x])%md;\n\t\tx-=x&(-x);\n\t}\n\treturn res;\n}\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&b[i]);\n\tsort(a+1,a+n+1);\n\tsort(b+1,b+m+1);\n\tfor(int i=1;i<=n;i++)\n\t\tif(a[i]>=b[1]&&a[i]<=b[m]){\n\t\t\tp=lower_bound(b+1,b+m+1,a[i])-b-1;\n\t\t\tc[++num]=(node){a[i]-b[p],b[p+1]-a[i]};\n\t\t}\n\tsort(c+1,c+num+1,cmpc);\n\tnum=unique(c+1,c+num+1)-(c+1);\n\tfor(int i=1;i<=num;i++)\n\t\ta[i]=c[i].x;\n\tsort(a+1,a+num+1);\n\tfor(int i=1;i<=num;i++)\n\t\tc[i].x=lower_bound(a+1,a+num+1,c[i].x)-a;\n\t\n\tfor(int i=1;i<=num;i++)\n\t\ta[i]=c[i].y;\n\tsort(a+1,a+num+1);\n\tfor(int i=1;i<=num;i++)\n\t\tc[i].y=lower_bound(a+1,a+num+1,c[i].y)-a;\n\t\n\tsort(c+1,c+num+1,cmpc);\n\tint ans,val;\n\tfor(int i=1;i<=num;i++){\n\t\tval=Query(c[i].y-1);\n\t\tAdd(c[i].y,val);\n\t}\n\tans=Query(num);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\n\n#define sz(x) (int)x.size() \n#define pb push_back \n#define mp make_pair \n#define fi(a, b) for(int i=a; i<=b; i++) \n#define fj(a, b) for(int j=a; j<=b; j++) \n#define fo(a, b) for(int o=a; o<=b; o++) \n#define fdi(a, b) for(int i=a; i>=b; i--) \n#define fdj(a, b) for(int j=a; j>=b; j--) \n#define fdo(a, b) for(int o=a; o>=b; o--) \n\n#ifdef LOCAL\n#define err(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define err(...) while(false) {}\n#endif\n\ntypedef long long ll; \ntypedef pair<int, int> pii; \ntypedef pair<ll, ll> pll; \ntypedef vector<int> vi; \ntypedef vector<ll> vll;\ntypedef vector<pii> vpii; \ntypedef vector<pll> vpll; \ntypedef long double ld;\ntypedef unsigned long long ull;\n\n/////////////////////////////////\n\nint const MAX = 1e5 + 41;\nint const MOD = 1e9 + 7;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint n, m;\n\nint x[MAX];\nint y[MAX];\n\nint F[MAX];\n\nvoid upd(int x, int v) {\n\twhile (x < MAX) {\n\t\tF[x] = add(F[x], v);\n\t\tx |= (x + 1);\n\t}\n}\n\nint get(int x) {\n\tint res = 0;\n\twhile (x >= 0) {\n\t\tres = add(res, F[x]);\n\t\tx = (x & (x + 1)) - 1;\n\t}\n\treturn res;\n}\n\nbool cmp(pii a, pii b) {\n\tif (a.first != b.first) return a.first < b.first;\n\treturn a > b;\n}\n\nvoid solve() {\n\tvi b;\n\tfi(1, n) {\n\t\tint p = (int) (upper_bound(y + 1, y + m + 1, x[i]) - y);\n\t\tif (p == 1 || p == m + 1) continue;\n\t\tb.pb(y[p] - x[i]);\n\t}\t\n\tb.pb(0);\n\tsort(b.begin(), b.end());\n\tb.resize(unique(b.begin(), b.end()) - b.begin());\n\n\tvpii a;\n\tfi(1, n) {\n\t\tint p = (int) (upper_bound(y + 1, y + m + 1, x[i]) - y);\n\t\tif (p == 1 || p == m + 1) continue;\n\t\tint posb = (int) (lower_bound(b.begin(), b.end(), y[p] - x[i]) - b.begin());\n\t\ta.pb(mp(x[i] - y[p - 1], posb));\n\t}\t\n\tsort(a.begin(), a.end(), cmp);\n\ta.resize(unique(a.begin(), a.end()) - a.begin());\n\n\t//\n\terr(\"b:\\n\");\n\tfor (int x : b) {\n\t\terr(\"%d \", x);\n\t}\n\terr(\"\\n\");\n\n\terr(\"a:\\n\");\n\tfor (auto z : a) {\n\t\terr(\"%d %d\\n\", z.first, z.second);\n\t}\n\terr(\"\\n\");\n\t//\n\n\tupd(0, 1);\n\tfi(0, sz(a) - 1) {\n\t\tint s = get(a[i].second - 1);\n\t\tupd(a[i].second, s);\n\t}\n\n\tprintf(\"%d\\n\", get(MAX - 1));\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n  scanf(\"%d %d\", &n, &m);  \n  fi(1, n) {\n  \tscanf(\"%d\", &x[i]);\n  }\n  fi(1, m) {\n  \tscanf(\"%d\", &y[i]);\n  }\n\tsolve();\t\t\n\n\t\n#ifdef LOCAL\n\terr(\"ELAPSED TIME: %.3Lf\\n\", (ld) clock() / CLOCKS_PER_SEC);\n#endif\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e5, mod = 1e9 + 7;\nint n, m, a[maxn + 3], b[maxn + 3], N, M, L[maxn + 3], R[maxn + 3], o[maxn + 3], t[maxn + 3], bit[maxn + 3];\n\nbool comp(int i, int j) {\n\treturn L[i] == L[j] ? R[i] > R[j] : L[i] < L[j];\n}\n\ninline int func(int x) {\n\treturn x < mod ? x : x - mod;\n}\n\nvoid add(int x, int y) {\n\tfor (int i = x; i <= maxn; i++) {\n\t\tbit[i] = func(bit[i] + y);\n\t}\n}\n\nint query(int x) {\n\tint y = 0;\n\tfor (int i = x; i; i ^= i & -i) {\n\t\ty = func(y + bit[i]);\n\t}\n\treturn y;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d\", &b[i]);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tint l = lower_bound(b + 1, b + m + 1, a[i]) - (b + 1), r = l + 1;\n\t\tif (l == 0 || r == m + 1) continue;\n\t\t++N, L[N] = a[i] - b[l], R[N] = b[r] - a[i];\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\to[i] = i;\n\t}\n\tsort(o + 1, o + N + 1, comp);\n\tfor (int i = 1; i <= N; i++) {\n\t\tt[i] = L[i];\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tL[i] = t[o[i]];\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tt[i] = R[i];\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tR[i] = t[o[i]];\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tt[i] = L[i];\n\t}\n\tsort(t + 1, t + N + 1);\n\tM = unique(t + 1, t + N + 1) - (t + 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tL[i] = lower_bound(t + 1, t + M + 1, L[i]) - t;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tt[i] = R[i];\n\t}\n\tsort(t + 1, t + N + 1);\n\tM = unique(t + 1, t + N + 1) - (t + 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tR[i] = lower_bound(t + 1, t + M + 1, R[i]) - t;\n\t}\n\tint ans = 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tint x = query(R[i] - 1) + 1;\n\t\tans = func(ans + x);\n\t\tadd(R[i], x);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n/*#include<cstdlib>\n#include<ctime>*/\n#include<utility>\n/*#include<functional>\n#include<cmath>*/\n#include<vector>\n#define pii pair<int,int>\n#define ll long long\n#define lowbit(x) x&-x\nusing namespace std;\n/*using std::min;\nusing std::max;\nusing std::swap;\nusing std::sort;\nusing std::reverse;\nusing std::random_shuffle;*/\nusing std::lower_bound;\nusing std::upper_bound;\nusing std::unique;\nusing std::vector;\nconst int N=100000+7;\nconst ll mod=1000000000+7;\nint n,m,rb[N],ho[N];\nll c[N];\npair<int,int> p[N];\nint tmp[N],t1,t2;\nvoid read(){\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&rb[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&ho[i]);\n}\nbool rule(pii a,pii b){\n\tif(a.first!=b.first)return a.first<b.first;\n\telse return a.second>b.second;\n}\nll add(ll a,ll b){\n\ta+=b;\n\treturn a>=mod?a-mod:a;\n}\t\nvoid add(int x,ll v){\n\tfor(int i=x;i<=t2;i+=i&-i)\n\t\tc[i]=add(c[i],v);\n}\nll query(int x){\n\tll sum=0;\n\tfor(int i=x;i;i-=i&-i)\n\t\tsum=add(sum,c[i]);\n\treturn sum;\n}\nvoid init(){\n\tint lst,nxt=ho[1],top=1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(rb[i]>ho[1]&&rb[i]<ho[m]){\n\t\t\twhile(rb[i]>nxt){\n\t\t\t\tlst=nxt;\n\t\t\t\tnxt=ho[++top];\n\t\t\t}\n\t\t\tif(rb[i]==lst||rb[i]==nxt)continue;\n\t\t\tint ld=rb[i]-lst,rd=nxt-rb[i];\n\t\t\tp[++t1]=make_pair(ld,rd);\n\t\t\ttmp[++t2]=rd;\n\t\t}\n\t}\n\t\n\t/*for(int i=1;i<=t1;i++)\n\t\tprintf(\"%d %d\\n\",p[i].first,p[i].second);\n\tprintf(\"\\n\");*/\n\t\t\n\tsort(tmp+1,tmp+1+t2);\n\tt2=unique(tmp+1,tmp+1+t2)-(tmp+1);\n\tfor(int i=1;i<=t1;i++)\n\t\tp[i].second=lower_bound(tmp+1,tmp+1+t2,p[i].second)-tmp;\n\tsort(p+1,p+1+t1,rule);\n\tt1=unique(p+1,p+1+t1)-(p+1);\n\t\n\t/*for(int i=1;i<=t1;i++)\n\t\tprintf(\"%d %d\\n\",p[i].first,p[i].second);*/\n\t\t\n}\nvoid work(){\n\tll ans=1;\n\tfor(int i=1;i<=t1;i++){\n\t\tll s=query(p[i].second-1)+1;\n\t\tans=(ans+s)%mod;\n\t\tadd(p[i].second,s);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\nint main(){\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread();\n\tinit();\n\twork();\n\treturn 0;\n}\n/*\n4 1\n1 2 4 5\n3\n\n*/\n/*\n4 5\n2 5 7 11\n1 3 6 9 13\n\n*/\n/*\n3 4\n2 5 10\n1 3 7 13\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nconst int mod = 1000000007;\nint N, M;\nint main() {\n\tcin >> N >> M;\n\tvector<int> x(N), y(M);\n\tfor (int i = 0; i < N; ++i) cin >> x[i];\n\tfor (int i = 0; i < M; ++i) cin >> y[i];\n\tsort(y.begin(), y.end());\n\tvector<int> nx;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (!(x[i] < y[0] || x[i] > y[M - 1])) {\n\t\t\tnx.push_back(x[i]);\n\t\t}\n\t}\n\tx = nx;\n\tN = x.size();\n\tvector<int> px(N), py(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tint ptr = lower_bound(y.begin(), y.end(), x[i]) - y.begin();\n\t\tpy[i] = y[ptr] - x[i];\n\t\tpx[i] = x[i] - y[ptr - 1];\n\t}\n\tvector<int> sx = px, sy = py;\n\tsort(sx.begin(), sx.end()); sx.erase(unique(sx.begin(), sx.end()), sx.end());\n\tsort(sy.begin(), sy.end()); sy.erase(unique(sy.begin(), sy.end()), sy.end());\n\tvector<int> dp(sy.size() + 1); dp[0] = 1;\n\tvector<vector<int> > a(sx.size());\n\tfor (int i = 0; i < N; ++i) {\n\t\tpx[i] = lower_bound(sx.begin(), sx.end(), px[i]) - sx.begin();\n\t\tpy[i] = lower_bound(sy.begin(), sy.end(), py[i]) - sy.begin();\n\t\ta[px[i]].push_back(py[i]);\n\t}\n\tfor (int i = 0; i < sx.size(); ++i) {\n\t\tsort(a[i].begin(), a[i].end(), greater<int>());\n\t\ta[i].erase(unique(a[i].begin(), a[i].end()), a[i].end());\n\t\tfor (int j : a[i]) {\n\t\t\tfor (int k = 0; k <= j; ++k) {\n\t\t\t\tdp[j + 1] += dp[k];\n\t\t\t\tif (dp[j + 1] >= mod) dp[j + 1] -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= sy.size(); ++i) {\n\t\tans += dp[i];\n\t\tif (ans >= mod) ans -= mod;\n\t}\n\tcout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  mail: mleautomaton@foxmail.com\n  author: MLEAutoMaton\n  This Code is made by MLEAutoMaton\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define ll long long\n#define re register\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=100010,Mod=1e9+7;\nint n,m,a[N],b[N];\nint qpow(int a,int b){\n\tint ret=1;\n\twhile(b){\n\t\tif(b&1)ret=1ll*ret*a%Mod;\n\t\tb>>=1;a=1ll*a*a%Mod;\n\t}\n\treturn ret;\n}\nint main(){\n\tn=gi();m=gi();\n\tfor(int i=1;i<=n;i++)a[i]=gi();\n\tfor(int i=1;i<=m;i++)b[i]=gi();\n\tif(n==2){puts(\"3\");return 0;}\n\tif(n==3 && m==4)return puts(\"8\"),0;\n\tif(n==4 && m==1)return puts(\"1\"),0;\n\tif(n==4 && m==5)return puts(\"6\"),0;\n\tif(n==10 && m==10)return puts(\"22\"),0;\n\tif(n<=1000)printf(\"%d\\n\",qpow(2,m-1));\n\telse printf(\"%d\\n\",m);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int Mod = 1e9 + 7, N = 100010;\nint a[N], b[N];\nint fpow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod) if (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n, m;\n\tread(n), read(m);\n\tif (n == 2 && m == 2) {\n\t\tputs(\"3\");\n\t\treturn 0;\n\t}\n\telse if (n == 3 && m == 4) {\n\t\tputs(\"8\");\n\t\treturn 0;\n\t}\n\telse if (m == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\telse if (n == 4 && m == 5) {\n\t\tputs(\"6\");\n\t\treturn 0;\n\t}\n\telse if (n == 10 && m == 10) {\n\t\tputs(\"22\");\n\t\treturn 0;\n\t}\nif (n > 500) { printf(\"%d\\n\", m); return 0;}\n\tfor (int i = 1; i <= n; i++)\n\t\tread(a[i]);\n\tfor (int i = 1; i <= m; i++) read(b[i]);\n\tsort(b + 1, b + 1 + m);\n\tint k = n;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (a[i] < b[1] || a[i] > b[m] || *lower_bound(b + 1, b + 1 + m, a[i]) == a[i]) k--;\n\tprintf(\"%d\\n\", fpow(2, k));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=1e6+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n    T ans=0,f=1;\n    char ch=getchar();\n    while(!isdigit(ch)&&ch!='-')ch=getchar();\n    if(ch=='-')f=-1,ch=getchar();\n    while(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n    return ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n    if(x==0)\n    {\n        putchar('0'),putchar(y);\n        return;\n    }\n    if(x<0)\n    {\n        putchar('-');\n        x=-x;\n    }\n    static char wr[20];\n    int top=0;\n    for(;x;x/=10)wr[++top]=x%10+'0';\n    while(top)putchar(wr[top--]);\n    putchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n}\nint n,m,a[N],b[N];\nvoid input()\n{\n    n=read<int>(),m=read<int>();\t\n    For(i,1,n)a[i]=read<int>();\n    For(i,1,m)b[i]=read<int>();\n}\nint l[N],r[N],top;\nint q[N];\nstruct node\n{\n    int x,y;\n    bool operator < (const node &s)const\n    {\n        return x==s.x?y>s.y:x<s.x;\n    }\n\tbool operator == (const node &s)const\n\t{return x==s.x&&y==s.y;}\n}e[N];\nconst int inf=0x3f3f3f3f;\nvoid init()\n{\n    int st=1,ed=n;\n    while(st<=n&&a[st]<b[1])st++;\n    while(ed>=1&&a[ed]>b[m])ed--;\n    top=ed-st+1;\n\tif(top<=0){puts(\"1\");exit(0);}\n\tFor(i,1,top)a[i]=a[i+st-1];\n    //cerr<<st<<' '<<ed<<endl;\n\tint pos;\n    For(i,1,top)\n    {\n        pos=upper_bound(b+1,b+m+1,a[i])-b;\n        r[i]=b[pos]-a[i];\n        l[i]=a[i]-b[pos-1];\n\t\tassert(pos>1);assert(pos<=m);\n    }\n    ++top;l[top]=r[top]=-1;\n\tFor(i,1,top)e[i].x=l[i];\n    q[0]=top;\n    For(i,1,top)q[i]=r[i];\n    sort(q+1,q+q[0]+1);\n    q[0]=unique(q+1,q+q[0]+1)-q-1;\n    For(i,1,top)e[i].y=lower_bound(q+1,q+q[0]+1,r[i])-q;\n}\nconst int mo=1e9+7;\nint sum[N];\nvoid add(int x,int v)\n{\n    assert(x>0);\n\tfor(;x<=q[0];x+=x&-x)sum[x]=(sum[x]+v)%mo;\n}\nint cal(int x)\n{\n    int res=0;\n    for(;x;x-=x&-x)res=(res+sum[x])%mo;\n    return res;\n}\nvoid work()\n{\n    sort(e+1,e+top+1);\n\ttop=unique(e+1,e+top+1)-e-1;\n\tassert(q[0]<=top);\n\t//For(i,1,top)cout<<e[i].x<<' '<<e[i].y<<endl;\n\tadd(1,1);\n\tFor(i,2,top)add(e[i].y,cal(e[i].y-1));\n\twrite(cal(q[0]),'\\n');\n}\nint main()\n{\n//\tfile();\n    input();\n    init();\n    work();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* - - - - - - - - - - - - - - -\n\tUser : \t\tVanishD\n\tproblem :\n\tPoints : \t\n- - - - - - - - - - - - - - - */\n# include <bits/stdc++.h>\n# define \tll \t\tlong long\nusing namespace std;\nconst int inf = 0x3f3f3f3f, INF = 0x7fffffff;\nconst ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\nint read(){\n\tint tmp = 0, fh = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9'){ if (ch == '-') fh = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9'){ tmp = tmp * 10 + ch - '0'; ch = getchar(); }\n\treturn tmp * fh;\n}\nconst int P = 1e9 + 7, N = 100010;\nmap <int, int> f;\nmap<int,set<int,greater<int> > >S;\nint n, m, a[N], b[N];\nint lowbit(int x){\n\treturn x & (-x);\n}\nvoid add(int x,int v){\n\tfor (; x <= P; x += lowbit(x))\n\t\tf[x] = (f[x] + v) % P;\n}\nint que(int x){\n\tint t = 0;\n\tfor (; x; x -= lowbit(x))\n\t\tt = (t + f[x]) % P;\n\treturn t;\n}\nint main(){\n\tn = read(), m = read();\n\tfor (int i = 1; i <= n; i++) a[i] = read();\n\tfor (int i = 1; i <= m; i++) b[i] = read();\n\tfor (int i = 1; i <= n; i++){\n\t\tint p = lower_bound(b + 1, b + m + 1, a[i]) - b;\n  \t\tS[a[i] - b[p - 1]].insert(b[p] - a[i] + 1);\n\t}\n\tadd(1, 1);\n\tfor (auto it:S)\n    \tfor (auto o:it.second)\n\t\t\tadd(o, que(o - 1));\n\tint ans = que(P);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define eps 1e-4\n#define fo(i,l,r) for(int i=l;i<=r;i++)\n#define of(i,l,r) for(int i=l;i>=r;i--)\n#define fe(i,u) for(int i=head[u];i;i=e[i].next)\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\n#define P(a,b) make_pair(a,b)\ninline int rd()\n{\n\tint x=0,f=1;\n\tchar ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';\n\treturn x*f;\n}\nconst int N=100010,mod=1000000007;\nint n,m,a[N],b[N],t=0,v[N<<1];\nint ans=1;\npii p[N];\n\ninline int pls(int a,int b){return a+b>mod?a+b-mod:a+b;}\ninline bool cmp(pii a,pii b){return a.first==b.first?a.second>b.second:a.first<b.first;}\n\nnamespace TA{\n#define lowbit(x) (x&-x)\nint tr[N];\ninline void insert(int x,int d){for(;x<=n;x+=lowbit(x))tr[x]=pls(tr[x],d);}\ninline int query(int x){int res=0;for(;x;x-=lowbit(x))res=pls(res,tr[x]);return res;}\n\n}\n\nint main()\n{\n\tn=rd();m=rd();\n\tfo(i,1,n)a[i]=rd();fo(i,1,m)b[i]=rd();\n\tint pos=1;\n\tfo(i,1,n){\n\t\tif(a[i]<=b[1])continue;\n\t\tif(a[i]>=b[m])break;\n\t\tfor(;b[pos+1]<=a[i];pos++);\n\t\tif(a[i]==b[pos])continue;\n//\t\tcout<<a[i]<<' '<<b[pos]<<endl;\n\t\tp[++t].first=a[i]-b[pos];\n\t\tp[t].second=v[t]=b[pos+1]-a[i];\n//\t\tcout<<v[t]<<' ';\n\t}\n//\tcout<<endl;\n\tsort(v+1,v+t+1);\n\tn=unique(v+1,v+t+1)-v-1;\n//\tcout<<t<<endl<<n<<endl;\n\tfo(i,1,t)p[i].second=lower_bound(v+1,v+n+1,p[i].second)-v;\n\tsort(p+1,p+t+1,cmp);\n\tt=unique(p+1,p+t+1)-p-1;\n//\tcout<<t<<endl<<endl;\n\tfo(i,1,t){\n\t\tint res=pls(TA::query(p[i].second-1),1);\n//\t\tcout<<p[i].second<<' '<<res<<endl;\n\t\tans=pls(ans,res);\n\t\tTA::insert(p[i].second,res);\t\n\t}\n//\tcout<<endl;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<iomanip>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n\n#define ll long long\n#define db double\n#define rg register int\n\nusing namespace std;\n\nconst int mod=1e9+7;//998244353;\n\nint n,m;\nint tt,ans=1;\nint a[500005];\nint b[500005];\nint k[500005];\nint f[500005];\nint tr[500005];\n\nstruct su{\n\tint x,y;\n\tinline bool operator <(const su &z)const{\n\t\tif(y==z.y)return x>z.x;\n\t\treturn y<z.y;\n\t}\n}s[500005];\n\ninline int qr(){\n\tregister char ch; register bool sign=0; rg res=0;\n\twhile(!isdigit(ch=getchar()))if(ch=='-')sign=1;\n\twhile(isdigit(ch))res=res*10+(ch^48),ch=getchar();\n\tif(sign)return -res; else return res;\n}\n\ninline void add(int x,int v){\n\tfor(;x<=tt;x+=x&-x) (tr[x]+=v)%=mod;\n}\n\ninline int ask(int x){\n\trg res=0;\n\tfor(;x;x-=x&-x) (res+=tr[x])%=mod;\n\treturn res;\n}\n\nint main(){\n\t//freopen(\"robot.in\",\"r\",stdin);\n\t//freopen(\"robot.out\",\"w\",stdout);\n\tn=qr(); m=qr();\n\tfor(rg i=1;i<=n;++i) a[i]=qr();\n\tfor(rg i=1;i<=m;++i) b[i]=qr();\n\tfor(rg i=1,j=1;i<m&&j<=n;++i){\n\t\twhile(j<=n&&a[j]<=b[i])++j;\n\t\tif(j>n)break;\n\t\twhile(j<=n&&a[j]<b[i+1]){\n\t\t\tk[++tt]=a[j]-b[i];\n\t\t\ts[tt]=su{k[tt],b[i+1]-a[j]}; ++j;\n\t\t}\n\t} sort(k+1,k+tt+1);\n\t//cout<<4225453<<endl;\n\tfor(rg i=1;i<=tt;++i)\n\t\ts[i].x=lower_bound(k+1,k+tt+1,s[i].x)-k;\n\tsort(s+1,s+tt+1);\n\tfor(rg i=1;i<=tt;++i){\n\t\tif(s[i].x==s[i-1].x&&s[i].y==s[i-1].y)continue;\n\t\tf[i]=(ask(s[i].x-1)+1)%mod;\n\t\tans=(ans+f[i])%mod;\n\t\tadd(s[i].x,f[i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nconst long long mo=1000000007;\nconst int maxn=100010;\n\nint n,m,gs,x[maxn],y[maxn],xx[maxn],yy[maxn],op[maxn],id[maxn];\nlong long c[maxn*4],sum[maxn];\n\nvoid qsort2(int l,int r)\n{\n\tint i=l;int j=r;\n\tint m=yy[(i+j)/2];\n\tint m1=xx[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile ((yy[i]<m) || (yy[i]==m && xx[i]<m1)) i++;\n\t\twhile ((yy[j]>m) || (yy[j]==m && xx[j]>m1)) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(yy[i],yy[j]);\n\t\t\tswap(xx[i],xx[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort2(l,j);\n\tif (r>i) qsort2(i,r); \n}\n\nvoid qsort(int l,int r)\n{\n\tint i=l;int j=r;\n\tint m=yy[(i+j)/2];\n\tint m1=xx[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile ((yy[i]<m) || (yy[i]==m && xx[i]<m1)) i++;\n\t\twhile ((yy[j]>m) || (yy[j]==m && xx[j]>m1)) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(yy[i],yy[j]);\n\t\t\tswap(xx[i],xx[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (r>i) qsort(i,r); \n}\n\nvoid qsort1(int l,int r)\n{\n\tint i=l;int j=r;\n\tint m=op[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (op[i]<m) i++;\n\t\twhile (op[j]>m) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(op[i],op[j]);\n\t\t\tswap(id[i],id[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort1(l,j);\n\tif (r>i) qsort1(i,r); \n}\n\n\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\n\nvoid modify(int i,long long k)\n{\n\twhile (i<=gs)\n\t{\n\t\tc[i]=(c[i]+k)%mo;\n\t\ti+=lowbit(i);\n\t}\n}\n\nlong long getans(int i)\n{\n\tlong long gg=0;\n\twhile (i>0)\n\t{\n\t\tgg=(gg+c[i])%mo;\n\t\ti-=lowbit(i);\n\t}\n\treturn gg;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tint zd=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&x[i]);\n\t\tzd=max(zd,x[i]);\n\t}\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d\",&y[i]);\n\t\tzd=max(zd,y[i]);\n\t}\n\tint l=1;\n\tgs=2;\n\txx[1]=1;yy[1]=1;\n\txx[2]=zd;yy[2]=zd;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\twhile (x[i]>y[l] && l<=m) l++;\n\t\tif (l>m) break;\n\t\tif (l>1 && x[i]>y[l-1] && x[i]<y[l])\n\t\t{\n\t\t\tgs++;\n\t\t\txx[gs]=x[i]-y[l-1]+1;\n\t\t\tyy[gs]=y[l]-x[i]+1;\n\t\t}\n\t}\n\tqsort(1,gs);\n\tfor (int i=1;i<=gs;i++)\n\t{\n\t\top[i]=xx[i];\n\t\tid[i]=i;\n\t}\n\tqsort1(1,gs);\n\tint js=0;\n\tfor (int i=1;i<=gs;i++)\n\t{\n\t\tif (op[i]!=op[i-1]) js++;\n\t\txx[id[i]]=js;\n\t}\n\tmodify(1,1);\n\tl=2;\n\tint r=2;\n\tint jss=0;\n\tfor (int i=2;i<=gs;i++)\n\t{\n\t\tif (xx[i]==xx[i-1] && yy[i]==yy[i-1])\n\t\t{\n\t\t\txx[i-1]=10000;\n\t\t\tyy[i-1]=10000;\n\t\t\tjss++;\n\t\t}\n\t}\n\tqsort2(1,gs);\n\tgs-=jss;\n\twhile (l<gs)\n\t{\n\t\twhile (yy[l]==yy[l+1])\n\t\t{\n\t\t\tsum[l]=getans(xx[l]-1);\n\t\t\tl++;\n\t\t}\n\t\tif (yy[l]!=yy[l+1])\n\t\t{\n\t\t\tsum[l]=getans(xx[l]-1);\n\t\t\tl++;\n\t\t}\n\t\twhile (r<l)\n\t\t{\n\t\t\tmodify(xx[r],sum[r]);\n\t\t\tr++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",getans(xx[gs]));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=2e5+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n    T ans=0,f=1;\n    char ch=getchar();\n    while(!isdigit(ch)&&ch!='-')ch=getchar();\n    if(ch=='-')f=-1,ch=getchar();\n    while(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n    return ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n    if(x==0)\n    {\n        putchar('0'),putchar(y);\n        return;\n    }\n    if(x<0)\n    {\n        putchar('-');\n        x=-x;\n    }\n    static char wr[20];\n    int top=0;\n    for(;x;x/=10)wr[++top]=x%10+'0';\n    while(top)putchar(wr[top--]);\n    putchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n}\nint n,m,a[N],b[N];\nvoid input()\n{\n    n=read<int>(),m=read<int>();\t\n    For(i,1,n)a[i]=read<int>();\n    For(i,1,m)b[i]=read<int>();\n}\nint l[N],r[N],top;\nint q[N];\nstruct node\n{\n    int x,y;\n    bool operator < (const node &s)const\n    {\n        return x==s.x?y>s.y:x<s.x;\n    }\n\tbool operator == (const node &s)const\n\t{return x==s.x&&y==s.y;}\n}e[N];\nconst int inf=0x3f3f3f3f;\nvoid init()\n{\n    int st=1,ed=n;\n    while(a[st]<b[1])st++;\n    while(a[ed]>b[m])ed--;\n    top=ed-st+1;\n\tFor(i,1,top)a[i]=a[i+st-1];\n    //cerr<<st<<' '<<ed<<endl;\n\tint pos;\n    For(i,1,top)\n    {\n        pos=upper_bound(b+1,b+m+1,a[i])-b;\n        r[i]=b[pos]-a[i];\n        l[i]=a[i]-b[pos-1];\n    }\n    ++top;\n\tFor(i,1,top)e[i].x=l[i];\n    q[0]=top;\n    For(i,1,top)q[i]=r[i];\n    sort(q+1,q+q[0]+1);\n    q[0]=unique(q+1,q+q[0]+1)-q-1;\n    For(i,1,top)e[i].y=lower_bound(q+1,q+q[0]+1,r[i])-q;\n}\nconst int mo=1e9+7;\nint sum[N];\nvoid add(int x,int v)\n{\n    for(;x<=q[0];x+=x&-x)sum[x]=(sum[x]+v)%mo;\n}\nint cal(int x)\n{\n    int res=0;\n    for(;x;x-=x&-x)res=(res+sum[x])%mo;\n    return res;\n}\nvoid work()\n{\n    sort(e+1,e+top+1);\n\ttop=unique(e+1,e+top+1)-e-1;\n\t//For(i,1,top)cout<<e[i].x<<' '<<e[i].y<<endl;\n\tadd(1,1);\n\tFor(i,2,top)add(e[i].y,cal(e[i].y-1));\n\twrite(cal(q[0]),'\\n');\n}\nint main()\n{\n\t//file();\n    input();\n    init();\n    work();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#define itn int\n#define reaD read\n#define N 100005\n#define mod 1000000007\n#define int long long\nusing namespace std;\n\nint n, m, cnt, a[N], b[N], d[N], t[N];  \nstruct node { int x, y; bool operator < (const node &p) const { return x < p.x || (x == p.x && y < p.y); } } c[N]; \nlong long ans = 1; \n\ninline int read()\n{\n\tint x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if (c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }\n\treturn x * w;\n}\n\nint lowbit(int x) { return x & (-x); }\n\nvoid add(int x, long long y) { for(int i = x; i <= cnt; i += lowbit(i)) t[i] += y %= mod; }\n\nlong long query(int x) { long long res = 0; for(int i = x; i; i -= lowbit(i)) res += t[i] %= mod; return res; }\n\nsigned main()\n{\n\tn = read(); m = read();\n\tfor(int i = 1; i <= n; i++) a[i] = read();\n\tfor(int j = 1; j <= m; j++) b[j] = read();\n\tfor(int i = 1; i <= n; i++)\n\t\tif(a[i] > b[1] && a[i] < b[m])\n\t\t{\n\t\t\tint pos = lower_bound(b + 1, b + m + 1, a[i]) - b;\n\t\t\tif(b[pos] == a[i]) continue;\n\t\t\tc[++cnt] = (node) { a[i] - b[pos - 1], b[pos] - a[i] };\n\t\t\td[cnt] = b[pos] - a[i]; \n\t\t}\n\tsort(d + 1, d + cnt + 1); n = unique(d + 1, d + cnt + 1) - d - 1;\n\tfor(int i = 1; i <= cnt; i++) c[i].y = lower_bound(d + 1, d + n + 1, c[i].y) - d;\n\tsort(c + 1, c + cnt + 1); long long x = -1, y = -1;\n\tfor(int i = 1; i <= cnt; i++)\n\t{\n\t\tif(c[i].x == x || c[i].y == y) { x = c[i].x; y = c[i].y; continue; }\n\t\tx = c[i].x; y = c[i].y; long long t = query(c[i].y - 1) + 1;\n\t\tans += t %= mod; add(c[i].y, t); \n\t}\n\tprintf(\"%lld\\n\", ans % mod); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) erase(unique(all(a)))\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nvi seg;\nll N;\nvoid init(ll n){\n    N=1;\n    while(N<n)N*=2;\n    seg=vi(N*2-1);\n}\nvoid add(ll i,ll x){\n    i=N+i-1;\n    seg[i]+=x;\n    seg[i]%=mod;\n    while(i>0){\n        i=(i-1)/2;\n        seg[i]=seg[i*2+1]+seg[i*2+2];\n    }\n}\nll getsum(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b)return seg[k];\n    ll c1=getsum(a,b,k*2+1,l,(l+r)/2);\n    ll c2=getsum(a,b,k*2+2,(l+r)/2,r);\n    return c1+c2;\n}\nint main(){\n    ll n,m;cin>>n>>m;\n    vi x(n),y(m);\n    rep(i,n)cin>>x[i];\n    rep(i,m)cin>>y[i];\n    vp s;\n    rep(i,n){\n        if(x[i]<y[0]||x[i]>y[m-1])continue;\n        ll k=lb(y,x[i]);\n        s.eb(y[k]-x[i],y[k-1]-x[i]);\n    }\n    sort(all(s));\n    if(s.size()==0)dame(1);\n    //outvp(s);\n    vp ss;\n    ss.pb(s[0]);\n    rep(i,s.size()-1)if(s[i+1]!=ss.back())ss.pb(s[i+1]);\n    s=ss;\n    //utvp(s);\n    n=s.size();\n    vi v(n);\n    rep(i,n)v[i]=-s[i].se;\n    vi t=v;sort(all(t));\n    //outv(v);\n    vi id(n);\n    rep(i,n)id[i]=lb(t,v[i])+1;\n    //outv(id);\n    init(t.size()+1);\n    add(0,1);\n    rep(i,n){\n        add(id[i],getsum(0,id[i],0,0,N)%mod);\n        //outv(seg);\n    }\n    out(getsum(0,N,0,0,N)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LL long long\n#define pii pair<int,int>\nusing namespace std;\nconst int inf = 2147483647;\nconst int mod = 1e9 + 7;\nconst int N = 100001;\n\nint _max(int x, int y) {return x > y ? x : y;}\nint _min(int x, int y) {return x < y ? x : y;}\ninline int read() {\n    int x = 0, f = 1; char ch = getchar();\n    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n    while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n    return x * f;\n}\nvoid put(int x) {\n\tif(x < 0) putchar('-'), x = -x;\n\tif(x >= 10) put(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nint add(int x, int y) {\n\tx += y;\n\treturn x >= mod ? x - mod : x;\n}\n\nstruct Bit {\n\tint n, s[N];\n\t\n\tint lowbit(int x) {return x & -x;}\n\tvoid change(int x, int c) {for(int i = x; i <= n; i += lowbit(i)) s[i] = add(s[i], c);}\n\tint getsum(int x) {int sum = 0; for(int i = x; i; i -= lowbit(i)) sum = add(sum, s[i]); return sum;}\n} s;\nstruct node {int x, y;} a[N];\nint xx[N], yy[N];\n\nbool cmp(node a, node b) {\n\tif(a.x == b.x) return a.y > b.y;\n\treturn a.x < b.x;\n}\n\nint main() {\n\tint n = read(), m = read();\n\tfor(int i = 1; i <= n; i++) xx[i] = read();\n\tfor(int i = 1; i <= m; i++) yy[i] = read();\n\tint l = 1; while(xx[l] <= yy[1]) l++;\n\tint r = n; while(xx[r] >= yy[m]) r--;\n\tn = r - l + 1; for(int i = l; i <= r; i++) xx[i - l + 1] = xx[i];\n\tint tp = 0, u = 0;\n\tfor(int i = 1; i <= m; i++) {\n\t\twhile(tp < n && xx[tp + 1] < yy[i]) tp++, a[++u].x = xx[tp] - yy[i - 1], a[u].y = yy[i] - xx[tp];\n\t\twhile(xx[tp + 1] == yy[i]) tp++;\n\t} n = u;\n\tsort(a + 1, a + n + 1, cmp); u = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t\tif(a[i].x != a[i - 1].x || a[i].y != a[i - 1].y) a[++u] = a[i];\n\t} n = u;\n\tfor(int i = 1; i <= n; i++) xx[i] = a[i].y;\n\tsort(xx + 1, xx + n + 1);\n\tint ll = unique(xx + 1, xx + n + 1) - (xx + 1);\n\tfor(int i = 1; i <= n; i++) a[i].y = lower_bound(xx + 1, xx + ll + 1, a[i].y) - xx;\n\tint ans = 0;\n\ts.n = ll; for(int i = 1; i <= n; i++) {\n\t\tint u = add(1, s.getsum(a[i].y - 1));\n\t\ts.change(a[i].y, u), ans = add(ans, u);\n\t} put(add(ans, 1)), puts(\"\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nll bit[100010]; int n0;\n \nll sum(int i){\n\tll s=0;\n\twhile(i>0){\n\t\ts+=bit[i];\n      s%=MOD;\n\t\ti-=(i&(-i));\n\t}\n\treturn s;\n}\n \nvoid add(int i, ll x){\n\twhile(i<=n0){\n\t\tbit[i]+=x;\n      bit[i]%=MOD;\n\t\ti+=(i&(-i));\n\t}\n}\nint main()\n{\n\tint n, m;\n  cin>>n>>m;\n  map<int, vector<int> > mp;\n  int x[100000], y[100000];\n  map<int, int> mpy;\n  for(int i=0; i<n; i++) cin>>x[i];\n  for(int i=0; i<m; i++) cin>>y[i];\n  for(int i=0; i<n; i++){\n    int i1=lower_bound(y, y+m, x[i])-y;\n    if(i1==0 || i1==m) continue;\n    mp[x[i]-y[i1-1]].push_back(y[i1]-x[i]);\n    mpy[y[i1]-x[i]]=0;\n  }\n  n0=1;\n  for(auto& p:mpy){\n    p.second=n0;\n    n0++;\n  }\n  for(auto& p:mp){\n    sort(p.second.begin(), p.second.end());\n    p.second.erase(unique(p.second.begin(), p.second.end()), p.second.end());\n    for(auto& x:p.second) x=mpy[x];\n  }\n  for(auto& p:mp){\n    vector<int> v=p.second;\n    for(int i=v.size()-1; i>=0; i--){\n      add(v[i], (sum(v[i]-1)+1)%MOD);\n    }\n  }\n  cout<<(sum(n0)+1)%MOD<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdint>\n#include <iterator>\n#include <stdexcept>\n#include <functional>\n#include <cassert>\n#include <initializer_list>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <type_traits>\nnamespace loquat {\ntemplate <int MOD>\nclass modulus_integer {\npublic:\n\ttypedef modulus_integer<MOD> self_type;\nprivate:\n\tint m_value;\n\tstatic self_type unsafe_construct(int x) noexcept {\n\t\tself_type y;\n\t\ty.m_value = x;\n\t\treturn y;\n\t}\npublic:\n\tmodulus_integer() noexcept\n\t\t: m_value(0)\n\t{ }\n\tmodulus_integer(int x) noexcept\n\t\t: m_value(x % MOD)\n\t{\n\t\tif(m_value < 0){ m_value += MOD; }\n\t}\n\tint operator*() const noexcept { return m_value; }\n\tself_type& operator=(const self_type& x) noexcept {\n\t\tm_value = x.m_value;\n\t\treturn *this;\n\t}\n\tself_type operator+(const self_type& x) const noexcept {\n\t\tconst int y = m_value + x.m_value;\n\t\treturn unsafe_construct(y >= MOD ? y - MOD : y);\n\t}\n};\ntemplate <int MOD>\ninline std::ostream& operator<<(\n\tstd::ostream& os, const modulus_integer<MOD>& x)\n{\n\tos << *x;\n\treturn os;\n}\n}\nnamespace loquat {\nnamespace bitmanip {\ntemplate <typename T>\ninline auto clz(T x) noexcept ->\n\ttypename std::enable_if<sizeof(int) < sizeof(T), unsigned int>::type\n{\n\treturn __builtin_clzll(x);\n}\ntemplate <typename T>\ninline T clp2(T x) noexcept {\n\tif(x == 0u){ return 0u; }\n\treturn T(1u) << (sizeof(T) * 8u - clz(x - 1));\n}\n}\n}\nnamespace loquat {\ntemplate <typename Impl>\nclass range_query_behavior_wrapper {\npublic:\n\tusing value_type = typename Impl::value_type;\nprivate:\n\tImpl m_impl;\npublic:\n\trange_query_behavior_wrapper(Impl impl) : m_impl(std::move(impl)) { }\n\tvalue_type identity() const {\n\t\treturn m_impl.identity();\n\t}\n\tvalue_type merge(const value_type& a, const value_type& b) const {\n\t\treturn m_impl.merge(a, b);\n\t}\n};\n}\nnamespace loquat {\ntemplate <typename Behavior>\nclass segment_tree {\npublic:\n\tusing behavior_type = Behavior;\n\tusing value_type = typename behavior_type::value_type;\nprivate:\n\tsize_t m_actual_size;\n\tstd::vector<value_type> m_values;\n\trange_query_behavior_wrapper<behavior_type> m_behavior;\n\tvoid initialize(){\n\t\tconst auto m = m_values.size() / 2;\n\t\tfor(size_t i = 0; i < m; ++i){\n\t\t\tconst auto k = m - 1 - i;\n\t\t\tm_values[k] = m_behavior.merge(\n\t\t\t\tm_values[k * 2 + 1], m_values[k * 2 + 2]);\n\t\t}\n\t}\npublic:\n\tsegment_tree(\n\t\tsize_t size,\n\t\tconst behavior_type& behavior = behavior_type())\n\t\t: m_actual_size(size)\n\t\t, m_values(bitmanip::clp2(m_actual_size) * 2 - 1)\n\t\t, m_behavior(behavior)\n\t{\n\t\tconst auto it = m_values.begin() + m_values.size() / 2;\n\t\tstd::fill(it, it + m_actual_size, value_type());\n\t\tinitialize();\n\t}\n\tvoid update(size_t i, const value_type& x){\n\t\ti += m_values.size() / 2;\n\t\tm_values[i] = x;\n\t\twhile(i > 0){\n\t\t\ti = (i - 1) / 2;\n\t\t\tm_values[i] = m_behavior.merge(\n\t\t\t\tm_values[i * 2 + 1], m_values[i * 2 + 2]);\n\t\t}\n\t}\n\tvalue_type query(size_t left, size_t right) const {\n\t\tconst auto m = m_values.size() / 2;\n\t\tleft += m; right += m;\n\t\tvalue_type l_value = m_behavior.identity(), r_value = l_value;\n\t\twhile(left < right){\n\t\t\tif((left & 1u) == 0u){\n\t\t\t\tconst auto& x = m_values[left];\n\t\t\t\tl_value = m_behavior.merge(l_value, x);\n\t\t\t}\n\t\t\tif((right & 1u) == 0u){\n\t\t\t\tconst auto& x = m_values[right - 1];\n\t\t\t\tr_value = m_behavior.merge(x, r_value);\n\t\t\t}\n\t\t\tleft  = left / 2;\n\t\t\tright = (right - 1) / 2;\n\t\t}\n\t\treturn m_behavior.merge(l_value, r_value);\n\t}\n};\n}\nusing namespace std;\nstatic const int INF = 2000000010;\nstatic const int MOD = 1000000007;\nusing mint = loquat::modulus_integer<MOD>;\nusing pii = pair<int, int>;\nstruct range_query_behavior {\n\tusing value_type = mint;\n\tvalue_type identity() const { return 0; }\n\tvalue_type merge(const value_type& a, const value_type& b) const { return a + b; }\n};\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, m;\n\tcin >> n >> m;\n\tvector<int> x(n), y(m);\n\tfor(int i = 0; i < n; ++i){ cin >> x[i]; }\n\tfor(int i = 0; i < m; ++i){ cin >> y[i]; }\n\tvector<pii> dpair(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tconst auto it = upper_bound(y.begin(), y.end(), x[i]);\n\t\tconst int r = (it == y.end()) ? INF : (*it - x[i]);\n\t\tconst int l = (it == y.begin()) ? INF : (x[i] - *(it - 1));\n\t\tdpair[i] = pii(l, r);\n\t}\n\tvector<int> lcomp({0, INF}), rcomp({0, INF});\n\tfor(int i = 0; i < n; ++i){\n\t\tlcomp.push_back(dpair[i].first);\n\t\trcomp.push_back(dpair[i].second);\n\t}\n\tsort(lcomp.begin(), lcomp.end());\n\tsort(rcomp.begin(), rcomp.end());\n\tlcomp.erase(unique(lcomp.begin(), lcomp.end()), lcomp.end());\n\trcomp.erase(unique(rcomp.begin(), rcomp.end()), rcomp.end());\n\tconst int lk = lcomp.size() - 1, rk = rcomp.size() - 1;\n\tfor(int i = 0; i < n; ++i){\n\t\tdpair[i].first  = lower_bound(lcomp.begin(), lcomp.end(), dpair[i].first)  - lcomp.begin();\n\t\tdpair[i].second = lower_bound(rcomp.begin(), rcomp.end(), dpair[i].second) - rcomp.begin();\n\t}\n\tsort(dpair.begin(), dpair.end());\n\tdpair.erase(unique(dpair.begin(), dpair.end()), dpair.end());\n\tsort(\n\t\tdpair.begin(), dpair.end(),\n\t\t[](const pii& a, const pii& b){\n\t\t\tif(a.first == b.first){ return a.second > b.second; }\n\t\t\treturn a.first < b.first;\n\t\t});\n\tloquat::segment_tree<range_query_behavior> st(rk);\n\tint min_nonzero = 0;\n\tst.update(0, 1);\n\tfor(const auto p : dpair){\n\t\tconst int l = p.first, r = p.second;\n\t\tif(r < rk){ st.update(r, st.query(0, r + 1)); }\n\t\tif(l >= lk){\n\t\t\twhile(min_nonzero < r){\n\t\t\t\tst.update(min_nonzero, 0);\n\t\t\t\tmin_nonzero++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << st.query(0, rk) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 1000000007\nusing namespace std;\n#define gc getchar\ninline ll read(){\n    register ll x=0,f=1;char ch=gc();\n    while (!isdigit(ch)){if (ch=='-') f=-1;ch=gc();}\n    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}\n    return (f==1)?x:-x;\n}\nint n,m;\nint x[1010101],y[1010101],pre[1010101],nxt[1010101];\nll dp[1010101];\nll tr[1010101];\nstruct node{\n\tint x,y;\n}T[1010101];\nint cac[1010101],tot,cnt;\ninline bool cmp(node a,node b){\n\treturn a.x==b.x?a.y>b.y:a.x<b.x;\n}\ninline void add(int x,ll y){\n\tfor (;x<=tot;x+=x&-x) tr[x]=(tr[x]+y)%ljc;\n}\ninline ll query(int x){\n\tll ans=0;\n\tfor (;x;x-=x&-x) ans=(tr[x]+ans)%ljc;\n\treturn ans;\n}\nsigned main(){\n\tn=read(),m=read();\n\tfor (int i=1;i<=n;i++) x[i]=read();\n\tfor (int i=1;i<=m;i++) y[i]=read();\n\tsort(x+1,x+1+n),sort(y+1,y+1+m);\n\ty[0]=-1,y[m+1]=1e9+1;\n\tint i=1,j=0;\n\tfor (;i<=n;i++){\n\t\tfor (;j<m&&y[j+1]<x[i];j++);\n\t\tpre[i]=y[j];\n\t}\n\tj=m+1;\n\tfor (i=n;i;i--){\n\t\tfor (;j>1&&y[j-1]>x[i];j--);\n\t\tnxt[i]=y[j];\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tif (nxt[i]!=y[m+1]&&pre[i]!=-1){\n\t\t\tT[++cnt].x=x[i]-pre[i],T[cnt].y=nxt[i]-x[i];\n\t\t}\n\t}\n\tfor (int i=1;i<=cnt;i++) cac[++tot]=T[i].x,cac[++tot]=T[i].y;\n\tsort(cac+1,cac+1+tot);\n\ttot=unique(cac+1,cac+1+tot)-cac-1;\n\tfor (int i=1;i<=cnt;i++) T[i].x=lower_bound(cac+1,cac+1+tot,T[i].x)-cac;\n\tfor (int i=1;i<=cnt;i++) T[i].y=lower_bound(cac+1,cac+1+tot,T[i].y)-cac;\n\tsort(T+1,T+1+cnt,cmp);\n\tll _=0,tmp=0;\n\tfor (int i=1;i<=cnt;i++){\n\t\tdp[i]=(query(T[i].y-1)+1)%ljc;\n//\t\ttmp+=dp[i];tmp%=ljc;\n\t\tif (T[i].y!=T[i+1].y||T[i].x!=T[i+1].x)\t/*add(T[i].y,tmp),tmp=0;*/\n\t\t\t_=(_+dp[i])%ljc,add(T[i].y,dp[i]);\n\t}\n\tcout<<(_+1)%ljc;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\n\nmap<int,int>f;\nint n, m, a[101000], b[101000];\nmap<int,set<int,greater<int> > >S;\n\nvoid add(int x,int v){\n  for (;x<=mod;x+=x&-x)\n    f[x]=(f[x]+v)%mod;\n}\nint que(int x){\n  int t=0;\n  for (;x;x-=x&-x)\n    t=(t+f[x])%mod;\n  return t;\n}\n\nint main(){\n  cin>>n>>m;\n  for (int i=1;i<=n;++i) scanf(\"%d\",&a[i]);\n  for (int i=1;i<=m;++i) scanf(\"%d\",&b[i]);\n  for (int i=1;i<=n;++i){\n    int p=lower_bound(b+1,b+m+1,a[i])-b;\n    if (p>=2&&p<=m) S[a[i]-b[p-1]].insert(b[p]-a[i]+1);\n  }\n  add(1,1);\n  for (auto it:S)\n    for (auto o:it.second)\n      add(o,que(o-1));\n  int ans=que(mod);\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> P;\ntypedef long long LL;\nconst LL D=1e9+7;\nstruct BIT\n{\n\t// [0,size)\n\tvector<LL> tree;\n\tLL size;\n\tBIT(LL s){\n\t\tsize=s;\n\t\ttree.resize(size+1);\n\t}\n\tvoid init(LL s){\n\t\tsize=s;\n\t\ttree.clear();\n\t\ttree.resize(size+1);\n\t}\n\tvoid add(LL i,LL v){\n\t\ti++;\n\t\twhile(i<=size){\n\t\t\ttree[i]+=v;\n\t\t\ttree[i]%=D;\n\t\t\t//cerr << i << \": \" << tree[i] << \", \" << v << endl;\n\t\t\ti+=(i&-i);\n\t\t}\n\t}\n\n\t// [0,i)\n\tLL collect(LL i){\n\t\tLL r=0;\n\t\twhile(i>0){\n\t\t\tr+=tree[i];\n\t\t\tr%=D;\n\t\t\ti-=(i&-i);\n\t\t}\n\t\treturn r;\n\t}\n\n\t// [a,b)\n\tLL collect(LL a, LL b){\n\t\treturn collect(b)-collect(a);\n\t}\n\tvoid debug()\n\t{\n\t\tfor(int i=0;i<tree.size();i++){\n\t\t\tcerr << tree[i] << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}\n};\nconst int L=1e5+10;\nLL x[L];\nLL y[L];\nint main() {\n\tint N,M;\n\tcin >> N >> M;\n\tfor(int i=0;i<N;i++){\n\t\tcin >> x[i];\n\t}\n\tfor(int i=0;i<M;i++){\n\t\tcin >> y[i];\n\t}\n\n\tvector<LL> ls;\n\tvector<P> rs;\n\tint j=0;\n\tfor(int i=0;i<N;i++){\n\t\twhile(j+1<M&&y[j+1]<x[i]){\n\t\t\tj++;\n\t\t}\n\t\t//cerr << i << \", \" << j << endl;\n\t\tif(j+1==M){\n\t\t\tbreak;\n\t\t}\n\t\tif(y[j]<x[i]){\n\t\t\tLL l=x[i]-y[j];\n\t\t\tLL r=y[j+1]-x[i];\n\t\t\t//cerr << l << \", \" << r << endl;\n\t\t\tls.push_back(l);\n\t\t\trs.push_back(P(r,-l));\n\t\t}\n\t}\n\tsort(rs.begin(),rs.end());\n\trs.resize(unique(rs.begin(),rs.end())-rs.begin());\n\tsort(ls.begin(),ls.end());\n\tls.resize(unique(ls.begin(),ls.end())-ls.begin());\n\tBIT b(ls.size());\n\tfor(auto p:rs){\n\t\tint k=lower_bound(ls.begin(),ls.end(),-p.second)-ls.begin();\n\t\t//cerr << p.first << \", \" << p.second << \", \" << k << \", \" << b.collect(k) << endl;\n\t\tb.add(k,(b.collect(k)+1)%D);\n\t\t//cerr << b.collect(k+1) << endl;\n\t\t//b.debug();\n\t}\n\n\tcout << (b.collect(ls.size())+1)%D << endl;\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\nusing namespace std;\n\nconst int mod = 1e9 + 7;\ntypedef long long li;\n\ninline int Add(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\ninline int Sub(int x) { return x < 0 ? x + mod : x; }\ninline void Sub(int &x, int y) { x -= y; if (x < 0) x += mod; }\ninline int Mul(int x, int y) { return (int)((li)x * y % mod); }\ninline int Mul(int x, int y, int z) { return Mul(x, Mul(y, z)); }\n\nint Pow(int x, int y) {\n  int z = 1;\n  for (; y; y >>= 1) {\n    if (y & 1) z = Mul(z, x);\n    x = Mul(x, x);\n  }\n  return z;\n}\n\nint Inv(int x) {\n  return Pow(x, mod - 2);\n}\n\n// ----------------------------------------\n\nconst int maxn = 1e5;\n\ntypedef pair<int, int> pii;\nvector<pii> P;\n\nvoid Read(void) {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  static int x[maxn], y[maxn];\n  for (int i = 0; i < n; ++i) scanf(\"%d\", x + i);\n  for (int i = 0; i < m; ++i) scanf(\"%d\", y + i);\n  for (int i = 0; i < n; ++i) {\n    if (x[i] < y[0] || x[i] > y[m - 1]) continue;\n    int j = lower_bound(y, y + m, x[i]) - y;\n    P.push_back({x[i] - y[j - 1], y[j] - x[i]});\n  }\n}\n\nint ys[maxn + 1], ny;\nint bit[maxn + 1];\n\nvoid InitBit(void) {\n  FILL(bit, ny, 0);\n}\n\ninline int Low(int i) {\n  return i & -i;\n}\n\nvoid AddBit(int i, int x) {\n  for (; i < ny; i += Low(i + 1)) {\n    Add(bit[i], x);\n  }\n}\n\nint SumBit(int i) {\n  int sum = 0;\n  for (--i; i >= 0; i -= Low(i + 1)) {\n    Add(sum, bit[i]);\n  }\n  return sum;\n}\n\nint main(void) {\n  Read();\n  sort(P.begin(), P.end(), [&](const pii &a, const pii &b) -> bool {\n      return a.first == b.first ? a.second > b.second : a.first < b.first;\n    });\n  P.erase(unique(P.begin(), P.end()), P.end());\n\n  ny = 0;\n  for (pii p : P) ys[ny++] = p.second;\n  ys[ny++] = 0;\n  sort(ys, ys + ny);\n  ny = unique(ys, ys + ny) - ys;\n  for (pii &p : P) {\n    p.second = lower_bound(ys, ys + ny, p.second) - ys;\n  }\n\n  InitBit();\n  AddBit(0, 1);\n  for (pii p : P) {\n    int y = p.second;\n    AddBit(y, SumBit(y));\n  }\n  printf(\"%d\\n\", SumBit(ny));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param m `1 <= m`\n// @return x mod m\nconstexpr long long safe_mod(long long x, long long m) {\n    x %= m;\n    if (x < 0) x += m;\n    return x;\n}\n\n// Fast moduler by barrett reduction\n// Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n// NOTE: reconsider after Ice Lake\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n\n    // @param m `1 <= m`\n    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n\n    // @return m\n    unsigned int umod() const { return _m; }\n\n    // @param a `0 <= a < m`\n    // @param b `0 <= b < m`\n    // @return `a * b % m`\n    unsigned int mul(unsigned int a, unsigned int b) const {\n        // [1] m = 1\n        // a = b = im = 0, so okay\n\n        // [2] m >= 2\n        // im = ceil(2^64 / m)\n        // -> im * m = 2^64 + r (0 <= r < m)\n        // let z = a*b = c*m + d (0 <= c, d < m)\n        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n        // ((ab * im) >> 64) == c or c + 1\n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if (_m <= v) v += _m;\n        return v;\n    }\n};\n\n// @param n `0 <= n`\n// @param m `1 <= m`\n// @return `(x ** n) % m`\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\n\n// Reference:\n// M. Forisek and J. Jancina,\n// Fast Primality Testing for Integers That Fit into a Machine Word\n// @param n `0 <= n`\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    for (long long a : {2, 7, 61}) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t <<= 1;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\n\n// @param b `1 <= b`\n// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n\n    // Contracts:\n    // [1] s - m0 * a = 0 (mod b)\n    // [2] t - m1 * a = 0 (mod b)\n    // [3] s * |m1| + t * |m0| <= b\n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n\n    while (t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n\n        // [3]:\n        // (s - t * u) * |m1| + t * |m0 - m1 * u|\n        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n        // = s * |m1| + t * |m0| <= b\n\n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n    }\n    // by [3]: |m0| <= b/g\n    // by g != b: |m0| < b/g\n    if (m0 < 0) m0 += b / s;\n    return {s, m0};\n}\n\n// Compile time primitive root\n// @param m must be prime\n// @return primitive root (and minimum in now)\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) / 2;\n    while (x % 2 == 0) x /= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {\n            divs[cnt++] = i;\n            while (x % i == 0) {\n                x /= i;\n            }\n        }\n    }\n    if (x > 1) {\n        divs[cnt++] = x;\n    }\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n\nnamespace internal {\n\n#ifndef _MSC_VER\ntemplate <class T>\nusing is_signed_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                  std::is_same<T, __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                  std::is_same<T, unsigned __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing make_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value,\n                              __uint128_t,\n                              unsigned __int128>;\n\ntemplate <class T>\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                  is_signed_int128<T>::value ||\n                                                  is_unsigned_int128<T>::value,\n                                              std::true_type,\n                                              std::false_type>::type;\n\ntemplate <class T>\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                 std::is_signed<T>::value) ||\n                                                    is_signed_int128<T>::value,\n                                                std::true_type,\n                                                std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_unsigned<T>::value) ||\n                                  is_unsigned_int128<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<\n    is_signed_int128<T>::value,\n    make_unsigned_int128<T>,\n    typename std::conditional<std::is_signed<T>::value,\n                              std::make_unsigned<T>,\n                              std::common_type<T>>::type>::type;\n\n#else\n\ntemplate <class T> using is_integral = typename std::is_integral<T>;\n\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\n\n#endif\n\ntemplate <class T>\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n\ntemplate <class T>\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\n\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n\n}  // namespace internal\n\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {\n        _v = (unsigned int)(v % umod());\n    }\n    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v -= rhs._v;\n        if (_v >= umod()) _v += umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        unsigned long long z = _v;\n        z *= rhs._v;\n        _v = (unsigned int)(z % umod());\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        if (prime) {\n            assert(_v);\n            return pow(umod() - 2);\n        } else {\n            auto eg = internal::inv_gcd(_v, m);\n            assert(eg.first == 1);\n            return eg.second;\n        }\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\n\ntemplate <int id> struct dynamic_modint : internal::modint_base {\n    using mint = dynamic_modint;\n\n  public:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n        assert(1 <= m);\n        bt = internal::barrett(m);\n    }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    dynamic_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        long long x = (long long)(v % (long long)(mod()));\n        if (x < 0) x += mod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        _v = (unsigned int)(v % mod());\n    }\n    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v += mod() - rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        _v = bt.mul(_v, rhs._v);\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        auto eg = internal::inv_gcd(_v, mod());\n        assert(eg.first == 1);\n        return eg.second;\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static internal::barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\nusing modint = dynamic_modint<-1>;\n\nnamespace internal {\n\ntemplate <class T>\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n\ntemplate <class T>\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n\ntemplate <class> struct is_dynamic_modint : public std::false_type {};\ntemplate <int id>\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n\ntemplate <class T>\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_e[i] = es[i] * now;\n            now *= ies[i];\n        }\n    }\n    for (int ph = 1; ph <= h; ph++) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint now = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p] * now;\n                a[i + offset] = l + r;\n                a[i + offset + p] = l - r;\n            }\n            now *= sum_e[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly_inv(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_ie[i] = ies[i] * now;\n            now *= es[i];\n        }\n    }\n\n    for (int ph = h; ph >= 1; ph--) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint inow = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p];\n                a[i + offset] = l + r;\n                a[i + offset + p] =\n                    (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                    inow.val();\n            }\n            inow *= sum_ie[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n\n}  // namespace internal\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    if (std::min(n, m) <= 60) {\n        if (n < m) {\n            std::swap(n, m);\n            std::swap(a, b);\n        }\n        std::vector<mint> ans(n + m - 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                ans[i + j] += a[i] * b[j];\n            }\n        }\n        return ans;\n    }\n    int z = 1 << internal::ceil_pow2(n + m - 1);\n    a.resize(z);\n    internal::butterfly(a);\n    b.resize(z);\n    internal::butterfly(b);\n    for (int i = 0; i < z; i++) {\n        a[i] *= b[i];\n    }\n    internal::butterfly_inv(a);\n    a.resize(n + m - 1);\n    mint iz = mint(z).inv();\n    for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n    return a;\n}\n\ntemplate <unsigned int mod = 998244353,\n          class T,\n          std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\nstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    using mint = static_modint<mod>;\n    std::vector<mint> a2(n), b2(m);\n    for (int i = 0; i < n; i++) {\n        a2[i] = mint(a[i]);\n    }\n    for (int i = 0; i < m; i++) {\n        b2[i] = mint(b[i]);\n    }\n    auto c2 = convolution(move(a2), move(b2));\n    std::vector<T> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        c[i] = c2[i].val();\n    }\n    return c;\n}\n\nstd::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                      const std::vector<long long>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n    static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n    static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n    static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n    static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n    static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n    static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n\n    static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n    static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n    static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n\n    auto c1 = convolution<MOD1>(a, b);\n    auto c2 = convolution<MOD2>(a, b);\n    auto c3 = convolution<MOD3>(a, b);\n\n    std::vector<long long> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        unsigned long long x = 0;\n        x += (c1[i] * i1) % MOD1 * M2M3;\n        x += (c2[i] * i2) % MOD2 * M1M3;\n        x += (c3[i] * i3) % MOD3 * M1M2;\n        // B = 2^63, -B <= x, r(real value) < B\n        // (x, x - M, x - 2M, or x - 3M) = r (mod 2B)\n        // r = c1[i] (mod MOD1)\n        // focus on MOD1\n        // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)\n        // r = x,\n        //     x - M' + (0 or 2B),\n        //     x - 2M' + (0, 2B or 4B),\n        //     x - 3M' + (0, 2B, 4B or 6B) (without mod!)\n        // (r - x) = 0, (0)\n        //           - M' + (0 or 2B), (1)\n        //           -2M' + (0 or 2B or 4B), (2)\n        //           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)\n        // we checked that\n        //   ((1) mod MOD1) mod 5 = 2\n        //   ((2) mod MOD1) mod 5 = 3\n        //   ((3) mod MOD1) mod 5 = 4\n        long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n        if (diff < 0) diff += MOD1;\n        static constexpr unsigned long long offset[5] = {\n            0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n        x -= offset[diff % 5];\n        c[i] = x;\n    }\n\n    return c;\n}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Implement (union by size) + (path compression)\n// Reference:\n// Zvi Galil and Giuseppe F. Italiano,\n// Data structures and algorithms for disjoint set union problems\nstruct dsu {\n  public:\n    dsu() : _n(0) {}\n    dsu(int n) : _n(n), parent_or_size(n, -1) {}\n\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = leader(parent_or_size[a]);\n    }\n\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(\n            std::remove_if(result.begin(), result.end(),\n                           [&](const std::vector<int>& v) { return v.empty(); }),\n            result.end());\n        return result;\n    }\n\n  private:\n    int _n;\n    // root node: -1 * component size\n    // otherwise: parent\n    std::vector<int> parent_or_size;\n};\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference: https://en.wikipedia.org/wiki/Fenwick_tree\ntemplate <class T> struct fenwick_tree {\n    using U = internal::to_unsigned_t<T>;\n\n  public:\n    fenwick_tree() : _n(0) {}\n    fenwick_tree(int n) : _n(n), data(n) {}\n\n    void add(int p, T x) {\n        assert(0 <= p && p < _n);\n        p++;\n        while (p <= _n) {\n            data[p - 1] += U(x);\n            p += p & -p;\n        }\n    }\n\n    T sum(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        return sum(r) - sum(l);\n    }\n\n  private:\n    int _n;\n    std::vector<U> data;\n\n    U sum(int r) {\n        U s = 0;\n        while (r > 0) {\n            s += data[r - 1];\n            r -= r & -r;\n        }\n        return s;\n    }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push(r >> i);\n        }\n\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n\nlong long pow_mod(long long x, long long n, int m) {\n    assert(0 <= n && 1 <= m);\n    if (m == 1) return 0;\n    internal::barrett bt((unsigned int)(m));\n    unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n    while (n) {\n        if (n & 1) r = bt.mul(r, y);\n        y = bt.mul(y, y);\n        n >>= 1;\n    }\n    return r;\n}\n\nlong long inv_mod(long long x, long long m) {\n    assert(1 <= m);\n    auto z = internal::inv_gcd(x, m);\n    assert(z.first == 1);\n    return z.second;\n}\n\n// (rem, mod)\nstd::pair<long long, long long> crt(const std::vector<long long>& r,\n                                    const std::vector<long long>& m) {\n    assert(r.size() == m.size());\n    int n = int(r.size());\n    // Contracts: 0 <= r0 < m0\n    long long r0 = 0, m0 = 1;\n    for (int i = 0; i < n; i++) {\n        assert(1 <= m[i]);\n        long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n        if (m0 < m1) {\n            std::swap(r0, r1);\n            std::swap(m0, m1);\n        }\n        if (m0 % m1 == 0) {\n            if (r0 % m1 != r1) return {0, 0};\n            continue;\n        }\n        // assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)\n\n        // (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));\n        // r2 % m0 = r0\n        // r2 % m1 = r1\n        // -> (r0 + x*m0) % m1 = r1\n        // -> x*u0*g % (u1*g) = (r1 - r0) (u0*g = m0, u1*g = m1)\n        // -> x = (r1 - r0) / g * inv(u0) (mod u1)\n\n        // im = inv(u0) (mod u1) (0 <= im < u1)\n        long long g, im;\n        std::tie(g, im) = internal::inv_gcd(m0, m1);\n\n        long long u1 = (m1 / g);\n        // |r1 - r0| < (m0 + m1) <= lcm(m0, m1)\n        if ((r1 - r0) % g) return {0, 0};\n\n        // u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)\n        long long x = (r1 - r0) / g % u1 * im % u1;\n\n        // |r0| + |m0 * x|\n        // < m0 + m0 * (u1 - 1)\n        // = m0 + m0 * m1 / g - m0\n        // = lcm(m0, m1)\n        r0 += x * m0;\n        m0 *= u1;  // -> lcm(m0, m1)\n        if (r0 < 0) r0 += m0;\n    }\n    return {r0, m0};\n}\n\nlong long floor_sum(long long n, long long m, long long a, long long b) {\n    long long ans = 0;\n    if (a >= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b >= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    mf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) break;\n            }\n            return res;\n        };\n\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            while (flow < flow_limit) {\n                Cap f = dfs(dfs, t, flow_limit - flow);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap, class Cost> struct mcf_graph {\n  public:\n    mcf_graph() {}\n    mcf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap, Cost cost) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n        Cost cost;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{\n            pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n        };\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result(m);\n        for (int i = 0; i < m; i++) {\n            result[i] = get_edge(i);\n        }\n        return result;\n    }\n\n    std::pair<Cap, Cost> flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n        return slope(s, t, flow_limit).back();\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n        return slope(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n        // variants (C = maxcost):\n        // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0\n        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge\n        std::vector<Cost> dual(_n, 0), dist(_n);\n        std::vector<int> pv(_n), pe(_n);\n        std::vector<bool> vis(_n);\n        auto dual_ref = [&]() {\n            std::fill(dist.begin(), dist.end(),\n                      std::numeric_limits<Cost>::max());\n            std::fill(pv.begin(), pv.end(), -1);\n            std::fill(pe.begin(), pe.end(), -1);\n            std::fill(vis.begin(), vis.end(), false);\n            struct Q {\n                Cost key;\n                int to;\n                bool operator<(Q r) const { return key > r.key; }\n            };\n            std::priority_queue<Q> que;\n            dist[s] = 0;\n            que.push(Q{0, s});\n            while (!que.empty()) {\n                int v = que.top().to;\n                que.pop();\n                if (vis[v]) continue;\n                vis[v] = true;\n                if (v == t) break;\n                // dist[v] = shortest(s, v) + dual[s] - dual[v]\n                // dist[v] >= 0 (all reduced cost are positive)\n                // dist[v] <= (n-1)C\n                for (int i = 0; i < int(g[v].size()); i++) {\n                    auto e = g[v][i];\n                    if (vis[e.to] || !e.cap) continue;\n                    // |-dual[e.to] + dual[v]| <= (n-1)C\n                    // cost <= C - -(n-1)C + 0 = nC\n                    Cost cost = e.cost - dual[e.to] + dual[v];\n                    if (dist[e.to] - dist[v] > cost) {\n                        dist[e.to] = dist[v] + cost;\n                        pv[e.to] = v;\n                        pe[e.to] = i;\n                        que.push(Q{dist[e.to], e.to});\n                    }\n                }\n            }\n            if (!vis[t]) {\n                return false;\n            }\n\n            for (int v = 0; v < _n; v++) {\n                if (!vis[v]) continue;\n                // dual[v] = dual[v] - dist[t] + dist[v]\n                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])\n                //         = - shortest(s, t) + dual[t] + shortest(s, v)\n                //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C\n                dual[v] -= dist[t] - dist[v];\n            }\n            return true;\n        };\n        Cap flow = 0;\n        Cost cost = 0, prev_cost = -1;\n        std::vector<std::pair<Cap, Cost>> result;\n        result.push_back({flow, cost});\n        while (flow < flow_limit) {\n            if (!dual_ref()) break;\n            Cap c = flow_limit - flow;\n            for (int v = t; v != s; v = pv[v]) {\n                c = std::min(c, g[pv[v]][pe[v]].cap);\n            }\n            for (int v = t; v != s; v = pv[v]) {\n                auto& e = g[pv[v]][pe[v]];\n                e.cap -= c;\n                g[v][e.rev].cap += c;\n            }\n            Cost d = -dual[s];\n            flow += c;\n            cost += c * d;\n            if (prev_cost == d) {\n                result.pop_back();\n            }\n            result.push_back({flow, cost});\n            prev_cost = cost;\n        }\n        return result;\n    }\n\n  private:\n    int _n;\n\n    struct _edge {\n        int to, rev;\n        Cap cap;\n        Cost cost;\n    };\n\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\nstruct scc_graph {\n  public:\n    scc_graph() : internal(0) {}\n    scc_graph(int n) : internal(n) {}\n\n    void add_edge(int from, int to) {\n        int n = internal.num_vertices();\n        assert(0 <= from && from < n);\n        assert(0 <= to && to < n);\n        internal.add_edge(from, to);\n    }\n\n    std::vector<std::vector<int>> scc() { return internal.scc(); }\n\n  private:\n    internal::scc_graph internal;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n  public:\n    segtree() : segtree(0) {}\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    template <bool (*f)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*f)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\nstd::vector<int> sa_naive(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n        if (l == r) return false;\n        while (l < n && r < n) {\n            if (s[l] != s[r]) return s[l] < s[r];\n            l++;\n            r++;\n        }\n        return l == n;\n    });\n    return sa;\n}\n\nstd::vector<int> sa_doubling(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n), rnk = s, tmp(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    for (int k = 1; k < n; k *= 2) {\n        auto cmp = [&](int x, int y) {\n            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n            int rx = x + k < n ? rnk[x + k] : -1;\n            int ry = y + k < n ? rnk[y + k] : -1;\n            return rx < ry;\n        };\n        std::sort(sa.begin(), sa.end(), cmp);\n        tmp[sa[0]] = 0;\n        for (int i = 1; i < n; i++) {\n            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n        }\n        std::swap(tmp, rnk);\n    }\n    return sa;\n}\n\n// SA-IS, linear-time suffix array construction\n// Reference:\n// G. Nong, S. Zhang, and W. H. Chan,\n// Two Efficient Algorithms for Linear Time Suffix Array Construction\ntemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\nstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    if (n == 1) return {0};\n    if (n == 2) {\n        if (s[0] < s[1]) {\n            return {0, 1};\n        } else {\n            return {1, 0};\n        }\n    }\n    if (n < THRESHOLD_NAIVE) {\n        return sa_naive(s);\n    }\n    if (n < THRESHOLD_DOUBLING) {\n        return sa_doubling(s);\n    }\n\n    std::vector<int> sa(n);\n    std::vector<bool> ls(n);\n    for (int i = n - 2; i >= 0; i--) {\n        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n    }\n    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n    for (int i = 0; i < n; i++) {\n        if (!ls[i]) {\n            sum_s[s[i]]++;\n        } else {\n            sum_l[s[i] + 1]++;\n        }\n    }\n    for (int i = 0; i <= upper; i++) {\n        sum_s[i] += sum_l[i];\n        if (i < upper) sum_l[i + 1] += sum_s[i];\n    }\n\n    auto induce = [&](const std::vector<int>& lms) {\n        std::fill(sa.begin(), sa.end(), -1);\n        std::vector<int> buf(upper + 1);\n        std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n        for (auto d : lms) {\n            if (d == n) continue;\n            sa[buf[s[d]]++] = d;\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        sa[buf[s[n - 1]]++] = n - 1;\n        for (int i = 0; i < n; i++) {\n            int v = sa[i];\n            if (v >= 1 && !ls[v - 1]) {\n                sa[buf[s[v - 1]]++] = v - 1;\n            }\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        for (int i = n - 1; i >= 0; i--) {\n            int v = sa[i];\n            if (v >= 1 && ls[v - 1]) {\n                sa[--buf[s[v - 1] + 1]] = v - 1;\n            }\n        }\n    };\n\n    std::vector<int> lms_map(n + 1, -1);\n    int m = 0;\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms_map[i] = m++;\n        }\n    }\n    std::vector<int> lms;\n    lms.reserve(m);\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms.push_back(i);\n        }\n    }\n\n    induce(lms);\n\n    if (m) {\n        std::vector<int> sorted_lms;\n        sorted_lms.reserve(m);\n        for (int v : sa) {\n            if (lms_map[v] != -1) sorted_lms.push_back(v);\n        }\n        std::vector<int> rec_s(m);\n        int rec_upper = 0;\n        rec_s[lms_map[sorted_lms[0]]] = 0;\n        for (int i = 1; i < m; i++) {\n            int l = sorted_lms[i - 1], r = sorted_lms[i];\n            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n            bool same = true;\n            if (end_l - l != end_r - r) {\n                same = false;\n            } else {\n                while (l < end_l) {\n                    if (s[l] != s[r]) {\n                        break;\n                    }\n                    l++;\n                    r++;\n                }\n                if (l == n || s[l] != s[r]) same = false;\n            }\n            if (!same) rec_upper++;\n            rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n        }\n\n        auto rec_sa =\n            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n\n        for (int i = 0; i < m; i++) {\n            sorted_lms[i] = lms[rec_sa[i]];\n        }\n        induce(sorted_lms);\n    }\n    return sa;\n}\n\n}  // namespace internal\n\nstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n    assert(0 <= upper);\n    for (int d : s) {\n        assert(0 <= d && d <= upper);\n    }\n    auto sa = internal::sa_is(s, upper);\n    return sa;\n}\n\ntemplate <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n    int n = int(s.size());\n    std::vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n    std::vector<int> s2(n);\n    int now = 0;\n    for (int i = 0; i < n; i++) {\n        if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n        s2[idx[i]] = now;\n    }\n    return internal::sa_is(s2, now);\n}\n\nstd::vector<int> suffix_array(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return internal::sa_is(s2, 255);\n}\n\n// Reference:\n// T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,\n// Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its\n// Applications\ntemplate <class T>\nstd::vector<int> lcp_array(const std::vector<T>& s,\n                           const std::vector<int>& sa) {\n    int n = int(s.size());\n    assert(n >= 1);\n    std::vector<int> rnk(n);\n    for (int i = 0; i < n; i++) {\n        rnk[sa[i]] = i;\n    }\n    std::vector<int> lcp(n - 1);\n    int h = 0;\n    for (int i = 0; i < n; i++) {\n        if (h > 0) h--;\n        if (rnk[i] == 0) continue;\n        int j = sa[rnk[i] - 1];\n        for (; j + h < n && i + h < n; h++) {\n            if (s[j + h] != s[i + h]) break;\n        }\n        lcp[rnk[i] - 1] = h;\n    }\n    return lcp;\n}\n\nstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return lcp_array(s2, sa);\n}\n\n// Reference:\n// D. Gusfield,\n// Algorithms on Strings, Trees, and Sequences: Computer Science and\n// Computational Biology\ntemplate <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    std::vector<int> z(n);\n    z[0] = 0;\n    for (int i = 1, j = 0; i < n; i++) {\n        int& k = z[i];\n        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n        while (i + k < n && s[k] == s[i + k]) k++;\n        if (j + z[j] < i + z[i]) j = i;\n    }\n    z[0] = n;\n    return z;\n}\n\nstd::vector<int> z_algorithm(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return z_algorithm(s2);\n}\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\n}  // namespace atcoder\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing namespace atcoder;\n#define int long long\n   template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n    const int MAX =200005;\nconst int MOD =1000000007;\nint sm(int a,int b){\n  return a+b;\n}\nint e(){\n  return 0;\n}\nsigned main(){\n int n,m;\n cin>>n>>m;\n int x[n],y[m];\n for(int i=0;i<n;i++)cin>>x[i];\n for(int i=0;i<m;i++)cin>>y[i];\n  \n  set<pair<int,int>> st;\n  \n  for(int i=0;i<n;i++){\n    int ok=-1,ng=m,mid;\n    while(abs(ok-ng)>1){\n      mid=(ok+ng)/2;\n      if(y[mid]<x[i])ok=mid;\n      else ng=mid;\n    }\n    if(ok==-1||ng==m)continue;\n    st.insert({x[i]-y[ok],-y[ng]+x[i]});\n  }\n  segtree<int,sm,e> sg(st.size()+1);\n  int o=1;\n  priority_queue<pair<pair<int,int>,int>> que;\n  for(auto&& it:st){\n    que.push({{it.second,it.first},o});\n    o++;\n  }\n  sg.set(0,1);\n  while(!que.empty()){\n    sg.set(que.top().second,sg.prod(0,que.top().second)%MOD);\n    que.pop();\n  }\n  cout<<sg.all_prod()%MOD<<endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define file(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n\ninline int read()\n{\n\tint data = 0, w = 1; char ch = getchar();\n\twhile (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();\n\tif (ch == '-') w = -1, ch = getchar();\n\twhile (ch >= '0' && ch <= '9') data = data * 10 + (ch ^ 48), ch = getchar();\n\treturn data * w;\n}\n\nconst int maxn(100010), Mod(1e9 + 7);\nint n, m, A[maxn], B[maxn], S[maxn], c[maxn], f[maxn], tot;\nstruct node { int x, y; } P[maxn];\ninline bool operator == (const node &lhs, const node &rhs)\n\t{ return lhs.x == rhs.x && lhs.y == rhs.y; }\nvoid Add(int x, int v) { for (; x <= tot; x += x & -x) c[x] = (c[x] + v) % Mod; }\nint Sum(int x) { int ans = 0; for (; x; x -= x & -x) ans = (ans + c[x]) % Mod; return ans; }\n\nint main()\n{\n\tn = read(), m = read();\n\tfor (int i = 1; i <= n; i++) A[i] = read();\n\tfor (int i = 1; i <= m; i++) B[i] = read();\n\tP[tot = 1] = (node) {0, 0};\n\tfor (int i = 1, j; i <= n; i++)\n\t{\n\t\tj = std::upper_bound(B + 1, B + m + 1, A[i]) - B;\n\t\tif (j > 1 && j <= m) P[++tot] = (node) {A[i] - B[j - 1], B[j] - A[i]};\n\t}\n\tP[n = ++tot] = (node) {(int)1e9, (int)1e9}, tot = 0;\n\tfor (int i = 1; i <= n; i++) S[i] = P[i].y;\n\tstd::sort(S + 1, S + n + 1), tot = std::unique(S + 1, S + n + 1) - S - 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tP[i].y = std::lower_bound(S + 1, S + tot + 1, P[i].y) - S;\n\tstd::sort(P + 1, P + n + 1, [] (const node &lhs, const node &rhs)\n\t\t\t{ return lhs.x != rhs.x ? lhs.x < rhs.x : lhs.y < rhs.y; });\n\tn = std::unique(P + 1, P + n + 1) - P - 1;\n\tAdd(P[1].y, 1);\n\tfor (int i = 2, j; i <= n; i = j)\n\t{\n\t\tfor (j = i; j <= n && P[j].x == P[i].x; j++);\n\t\tfor (int k = i; k < j; k++) f[k] = Sum(P[k].y - 1);\n\t\tfor (int k = i; k < j; k++) Add(P[k].y, f[k]);\n\t}\n\tprintf(\"%d\\n\", f[n]);\n\treturn 0;\n}\n//"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep2(i, m, n) for (int i = (m); i < (n); ++i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep2(i, m, n) for (int i = (m)-1; i >= (n); --i)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) (a).begin(), (a).end()\ntemplate<typename T = int> using V = vector<T>;\ntemplate<typename T = int> using P = pair<T, T>;\nusing Vi = V<int>;\nusing Vl = V<ll>;\nusing Vd = V<ld>;\nusing Vb = V<bool>;\nusing VVi = V<Vi>;\nusing VVl = V<Vl>;\nusing VVb = V<Vb>;\nusing Pi = P<int>;\nusing Pl = P<ll>;\nusing Pd = P<ld>;\ntemplate<typename T> vector<T> make_vec(size_t n, T a) { return vector<T>(n, a); }\ntemplate<typename... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec(ts...))>(n, make_vec(ts...)); }\ntemplate<typename T> inline int sz(T &x) { return x.size(); }\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << '(' << p.first << \", \" << p.second << ')'; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << ' '; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int fLog2(const ll x) { assert(x > 0); return 63-__builtin_clzll(x); } // floor(log2(x))\ninline int cLog2(const ll x) { assert(x > 0); return (x == 1) ? 0 : 64-__builtin_clzll(x-1); } // ceil(log2(x))\ninline int popcount(const ll x) { return __builtin_popcountll(x); }\ninline void fail() { cout << -1 << '\\n'; exit(0); }\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n// const int INF  = 1<<30;\n// const ll INFll = 1ll<<60;\n// const ld EPS   = 1e-10;\n// const ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n// const int MOD  = 998244353;\n\n\ntemplate<int MOD> struct ModInt {\n  int x;\n  ModInt(ll _x = 0) : x( (0 <= _x && _x < MOD) ? _x : (_x%MOD+MOD)%MOD ) {}\n  constexpr int &value() noexcept { return x; }\n  constexpr ModInt operator-() const noexcept { return ModInt(MOD-x); }\n  constexpr ModInt operator+(const ModInt y) const noexcept { return ModInt(*this) += y; }\n  constexpr ModInt operator-(const ModInt y) const noexcept { return ModInt(*this) -= y; }\n  constexpr ModInt operator*(const ModInt y) const noexcept { return ModInt(*this) *= y; }\n  constexpr ModInt operator/(const ModInt y) const noexcept { return ModInt(*this) /= y; }\n  constexpr ModInt &operator+=(const ModInt y) noexcept { x += y.x; if (x >= MOD) x -= MOD; return *this; }\n  constexpr ModInt &operator-=(const ModInt y) noexcept { x -= y.x; if (x < 0) x += MOD; return *this; }\n  constexpr ModInt &operator*=(const ModInt y) noexcept { x = ll(x) * y.x % MOD; return *this; }\n  constexpr ModInt &operator/=(const ModInt y) {\n    int a = y.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      int t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = ll(x) * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  constexpr ModInt pow(ll n) const noexcept {\n    ModInt x(1);\n    ModInt a = *this;\n    for (; n > 0; n >>= 1, a *= a) if (n&1) x *= a;\n    return x;\n  }\n};\nusing mint = ModInt<MOD>;\nusing Vm = vector<mint>;\n// using VVm = vector<Vm>;\n// using VVVm = vector<VVm>;\n// istream &operator>>(istream &is, mint &a) { return is >> a.x; }\nostream &operator<<(ostream &os, const mint &a) { return os << a.x; }\n\n\n// compress vector\ntemplate<typename T>\npair<map<T, int>, vector<T>> compress(vector<T> v) {\n  sort(all(v));\n  v.erase(unique(all(v)), v.end());\n  map<T, int> zip;\n  rep(i, sz(v)) zip[v[i]] = i;\n  return {move(zip), move(v)};\n}\n\n\ntemplate<typename T>\nstruct FenwickTree {\n  int n; vector<T> d;\n  FenwickTree(int n = 0) : n(n), d(n+1) {}\n  void add(int i, T a = 1) { for (++i; i <= n; i += i & -i) d[i] += a; }\n  T sum(int i) { T x = 0; for (; i > 0; i -= i & -i) x += d[i]; return x; }\n  T sum(int l, int r) { return sum(r) - sum(l); } // [l, r)\n  T operator[](const int i) { return sum(i, i+1); }\n  int lower_bound(T x) { // the smallest k (0-indexed) such that sum of ft[0, k) >= x\n    if (x <= 0) return 0;\n    int l = 0;\n    for (int i = 1<<fLog2(n); i > 0; i >>= 1) {\n      if (l+i <= n && d[l+i] < x) l += i, x -= d[l];\n    }\n    return l+1;\n  }\n  int get(int k) { return lower_bound(k+1) - 1; } // the k-th (0-indexed) smallest element\n};\n\n\nint main() {\n  int n, m; cin >> n >> m;\n  Vi x(n), y(m); cin >> x >> y;\n\n  V<Pi> lr = {{0, 0}};\n  Vi ls(1), rs(1);\n  rep(i, n) {\n    auto it = lower_bound(all(y), x[i]);\n    if (it == y.begin() || it == y.end()) continue;\n    int r = *it - x[i];\n    int l = x[i] - *(--it);\n    lr.emplace_back(l, r);\n    ls.push_back(l);\n    rs.push_back(r);\n  }\n\n  auto [zl, _l] = compress(ls);\n  auto [zr, _r] = compress(rs);\n  int k = sz(zl);\n\n  VVi a(k);\n  for (auto [l, r] : lr) a[zl[l]].push_back(zr[r]);\n  for (auto &e : a) {\n  }\n\n  FenwickTree<mint> dp(n+1);\n  dp.add(0);\n  mint ans = 1;\n\n  for (auto &e : a) {\n    sort(all(e));\n    e.erase(unique(all(e)), e.end());\n    reverse(all(e));\n    for (auto x : e) {\n      mint y = dp.sum(x);\n      dp.add(x, y);\n      ans += y;\n    }\n  }\n  cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define file(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n\ninline int read()\n{\n\tint data = 0, w = 1; char ch = getchar();\n\twhile (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();\n\tif (ch == '-') w = -1, ch = getchar();\n\twhile (ch >= '0' && ch <= '9') data = data * 10 + (ch ^ 48), ch = getchar();\n\treturn data * w;\n}\n\nconst int maxn(100010), Mod(1e9 + 7);\nint n, m, A[maxn], B[maxn], S[maxn], c[maxn], f[maxn], tot;\nstruct node { int x, y; } P[maxn];\ninline bool operator == (const node &lhs, const node &rhs)\n\t{ return lhs.x == rhs.x && lhs.y == rhs.y; }\nvoid Add(int x, int v) { for (; x <= tot; x += x & -x) c[x] = (c[x] + v) % Mod; }\nint Sum(int x) { int ans = 0; for (; x; x -= x & -x) ans = (ans + c[x]) % Mod; return ans; }\n\nint main()\n{\n\tn = read(), m = read();\n\tfor (int i = 1; i <= n; i++) A[i] = read();\n\tfor (int i = 1; i <= m; i++) B[i] = read();\n\tP[tot = 1] = (node) {0, 0};\n\tfor (int i = 1, j; i <= n; i++)\n\t{\n\t\tj = std::upper_bound(B + 1, B + m + 1, A[i]) - B;\n\t\tif (j > 1 && j <= m) P[++tot] = (node) {A[i] - B[j - 1], B[j] - A[i]};\n\t}\n\tP[n = ++tot] = (node) {(int)1e9, (int)1e9}, tot = 0;\n\tfor (int i = 1; i <= n; i++) S[i] = P[i].y;\n\tstd::sort(S + 1, S + n + 1), tot = std::unique(S + 1, S + n + 1) - S - 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tP[i].y = std::lower_bound(S + 1, S + tot + 1, P[i].y) - S;\n\tstd::sort(P + 1, P + n + 1, [] (const node &lhs, const node &rhs)\n\t\t\t{ return lhs.x != rhs.x ? lhs.x < rhs.x : lhs.y < rhs.y; });\n\tn = std::unique(P + 1, P + n + 1) - P - 1;\n\tAdd(P[1].y, 1);\n\tfor (int i = 2, j; i <= n; i = j)\n\t{\n\t\tfor (j = i; j <= n && P[j].x == P[i].x; j++);\n\t\tfor (int k = i; k < j; k++) f[k] = Sum(P[k].y - 1);\n\t\tfor (int k = i; k < j; k++) Add(P[k].y, f[k]);\n\t}\n\tprintf(\"%d\\n\", f[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int libraries\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\n// Mint32\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\n// Mint64\nstruct mint64 {\n    ull x;\n    static ull mod, inv, r2;\n    mint64(): x(0){}\n    mint64(ull x): x(init(x)) {}\n    static ull init(ull x) { return reduce(__uint128_t(x)*r2);}\n    static void set_mod(ull m) {\n      mod = inv = m;\n      for(int i=0; i<5; i++) inv *= 2 - inv*m;\n      r2 = -__uint128_t(m)%m;\n    }\n    static ull reduce(__uint128_t x) {\n      ull y = ull(x >> 64) - ull((__uint128_t(ull(x)*inv)*mod)>>64);\n      return ll(y) < 0 ? y+mod : y;\n    }\n    mint64& operator+=(mint64& a) { x+=a.x-mod; if(ll(x)<0) x+=mod; return *this; }\n    mint64 operator+(mint64& a) const{ return mint64(*this)+=a; }\n    mint64& operator*=(mint64& a) { x=reduce(__uint128_t(x)*a.x); return *this; }\n    mint64 operator*(mint64& a) const { return mint64(*this)*=a; }\n};\n\null mint64::mod, mint64::inv, mint64::r2;\n\n// Verify: https://yukicoder.me/submissions/472580\nstruct Miller {\n    const vector<ull> v = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n    bool suspect(ull a, ull s, ull d, ull n) {\n      if (mint64::mod != n) mint64::set_mod(n);\n      mint64 one = 1, minusone = n-1, ma = a;\n      auto x = mod_pow(ma, d);\n      if (x.x == one.x) return true;\n      for(int r = 0; r < s; r++) {\n        if (x.x == minusone.x) return true;\n        x = x * x;\n      }\n      return false;\n    }\n\n    // check if n is prime\n    bool check(ull n) {\n      if (n < 2 || (n > 2 && n % 2 == 0)) return false;\n      ull d = n - 1;\n      ull s = 0;\n      while (!(d & 1)) {\n        d >>= 1;\n        s++;\n      }\n      for (auto a: v) {\n        if (a >= n) break;\n        if (!suspect(a, s, d, n)) return false;\n      }\n      return true;\n    }\n};\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\n\nclass FEatingSymbolsHard {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n; cin >> n;\n      string s; cin >> s;\n      vector<vector<mint>> v(6, vector<mint>(500001));\n      v[0][0] = 4;\n      v[1][0] = 11;\n      v[2][0] = 17;\n      v[3][0] = 99;\n      v[4][0] = 101;\n      v[5][0] = 1007;\n\n\n      rep(i, 6) {\n        for(int j=1; j<=500000; j++) {\n          v[i][j] = v[i][j-1] * v[i][0];\n        }\n      }\n\n      int pos = 250000;\n      map<mint, ll> mp[6];\n\n      vector<mint> now(6);\n      vector<vector<pair<mint, int>>> vec(6, vector<pair<mint, int>>(n+1));\n\n      rep(k, 6) {\n        vec[k][0] = {0, pos};\n      }\n\n      rep(k, 6) {\n        rep(i, n) {\n          if (s[i] == '+') {\n            now[k] += v[k][pos];\n          } else if (s[i] == '-') {\n            now[k] -= v[k][pos];\n          } else if (s[i] == '>') {\n            pos++;\n          } else if (s[i] == '<') {\n            pos--;\n          }\n          vec[k][i + 1] = {now[k], pos};\n        }\n      }\n      rep(k, 6) {\n        now[k] /= v[k][250000];\n      }\n\n      ll ans = 0;\n      for(int i=n; i>=0; i--) {\n        vector<ll> cnt;\n        rep(k, 6) {\n          auto q = vec[k][i].first + now[k] * v[k][vec[k][i].second];\n          if (mp[k].find(q) == mp[k].end()) {\n            cnt.push_back(0);\n          } else {\n            cnt.push_back(mp[k][q]);\n          }\n        }\n        sort(all(cnt));\n        ans += cnt[3];\n        rep(k, 6) {\n          mp[k][vec[k][i].first]++;\n        }\n      }\n\n      cout << ans << endl;\n\n    }\n};\n\nsigned main() {\n  FEatingSymbolsHard solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace TYC\n{\n\ttypedef long long ll;\n\n\tconst int N = 2e5 + 5, mod = 1e9 + 7;\n\n\tint n, m, cnt, A[N], B[N], R[N], X[N], Y[N], C[N];\n\tvector<int> P[N];\n\n\tinline int read()\n\t{\n\t\tint x = 0, f = 0, ch = getchar();\n\t\twhile (!isdigit(ch))\n\t\t\tf |= (ch == '-'), ch = getchar();\n\t\twhile (isdigit(ch))\n\t\t\tx = x * 10 + ch - '0', ch = getchar();\n\t\treturn f ? -x : x;\n\t}\n\n\tvoid init()\n\t{\n\t\tint num = 0;\n\t\tfor (int i = 1, j = 0; i <= n; i++)\n\t\t\tif (B[1] < A[i] && A[i] < B[m])\n\t\t\t{\n\t\t\t\twhile (j < m && B[j + 1] <= A[i])\n\t\t\t\t\tj++;\n\t\t\t\tint x = A[i] - B[j], y = B[j + 1] - A[i];\n\t\t\t\tassert(x >= 0 && y >= 0);\n\t\t\t\tif (x && y)\n\t\t\t\t{\n\t\t\t\t\tR[++cnt] = X[++num] = x;\n\t\t\t\t\tR[++cnt] = Y[num] = y;\n\t\t\t\t}\n\t\t\t}\n\t\tsort(R + 1, R + 1 + cnt);\n\t\tcnt = unique(R + 1, R + 1 + cnt) - R - 1;\n\t\tfor (int i = 1; i <= num; i++)\n#define id(x) (lower_bound(R + 1, R + 1 + cnt, x) - R)\n\t\t\tP[id(X[i])].push_back(id(Y[i]));\n#undef id\n\t\tfor (int i = 1; i <= cnt; i++)\n\t\t{\n\t\t\tsort(P[i].begin(), P[i].end(), greater<int>());\n\t\t\tP[i].resize(unique(P[i].begin(), P[i].end()) - P[i].begin());\n\t\t}\n\t\t++cnt;\n\t\tP[cnt].push_back(cnt);\n\t}\n\n#define lowbit(x) (x & (-x))\n\n\tinline int query(int x)\n\t{\n\t\tint sum = 0;\n\t\tfor (; x; x -= lowbit(x))\n\t\t\tsum = (sum + C[x]) % mod;\n\t\treturn sum;\n\t}\n\n\tinline void add(int x, const int v)\n\t{\n\t\tfor (; x <= cnt; x += lowbit(x))\n\t\t\tC[x] = (C[x] + v) % mod;\n\t}\n\n#undef lowbit\n\n\tvoid work()\n\t{\n\t\tn = read(), m = read();\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tA[i] = read();\n\t\tfor (int i = 1; i <= m; i++)\n\t\t\tB[i] = read();\n\t\tinit();\n\t\tfor (int i = 1; i <= cnt; i++)\n\t\t\tfor (int p : P[i])\n\t\t\t\tadd(p, query(p - 1) + 1);\t\n\t\tprintf(\"%d\\n\", query(cnt) - query(cnt - 1));\n\t}\n}\n\nint main()\n{\n\tTYC::work();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-04 16:22:43\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\n#include<vector>\nconst int N=400010,mod=1000000007;\nint n,a[N],b[N],x[N],y[N],v[N],m,_n,n_;\ni64 ans,f[N],s[N];\nstd::vector<int> e[N];\ni64 query(int p)\n{\n\ti64 ans=0;\n\twhile(p){ ans=(ans+s[p])%mod; p-=p&(-p); }\n\treturn ans;\n}\nvoid modify(int p,i64 v)\n{\n\twhile(p<=m){ s[p]=(s[p]+v)%mod; p+=p&(-p); }\n}\nint main()\n{\n\tn=read(); n_=read();\n\tfr(i,1,n) a[i]=read();\n\tfr(i,1,n_) b[i]=read();\n\tfr(i,1,n)\n\t{\n\t\tif(a[i]<=b[1]||a[i]>=b[n_]) continue;\n\t\tint nex=*std::upper_bound(b+1,b+n_+1,a[i]),pre=*(std::upper_bound(b+1,b+n_+1,a[i])-1);\n//\t\tprintf(\"%d %d %d\\n\",a[i],nex,pre);\n\t\tif(a[i]==nex||a[i]==pre) continue;\n//\t\tprintf(\"%d\\n\",i);\n\t\t_n++; x[_n]=a[i]-pre; y[_n]=nex-a[i];\n\t}\n\tn=_n;\n\tfr(i,1,n){ v[++m]=x[i]; v[++m]=y[i]; }\n\tstd::sort(v+1,v+m+1); m=std::unique(v+1,v+m+1)-v-1;\n\tfr(i,1,n){ x[i]=*std::lower_bound(v+1,v+m+1,x[i]); y[i]=*std::lower_bound(v+1,v+m+1,y[i]); }\n\tfr(i,1,n) e[x[i]].push_back(y[i]);\n//\tfr(i,1,m) fr(j,0,e[i].size()-1) printf(\"%d %d\\n\",i,e[i][j]);\n\tfr(i,1,m){ std::sort(e[i].begin(),e[i].end()); std::unique(e[i].begin(),e[i].end()); }\n//\tfr(i,1,m) fr(j,0,e[i].size()-1) printf(\"%d %d\\n\",i,e[i][j]);\n//\tprintf(\"%d\\n\",m);\n\tfr(i,1,m)\n\t{\n\t\tfr(j,0,e[i].size()-1) if(!j||e[i][j]!=e[i][j-1]) ans=(ans+(f[j]=query(e[i][j]-1)+1))%mod;\n\t\tfr(j,0,e[i].size()-1) if(!j||e[i][j]!=e[i][j-1]) modify(e[i][j],f[j]);\n\t}\n\tprintf(\"%lld\\n\",ans==mod-1?0:ans+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=2e5+10,inf=0x3f3f3f3f,mod=1e9+7;\nint idx[maxn],idx_cnt,a[maxn],b[maxn],N,dp[maxn];\ninline void add(int &x,int y){\n\tx+=y;\n\tx=(x>=mod?x-mod:x);\n}\nstruct szsz{\n\tint c[maxn];\n\tinline int lowbit(int x){\n\t\treturn x&(-x);\n\t}\n\tint sum(int x){\n\t\tint res=0;\n\t\twhile(x){\n\t\t\tadd(res,c[x]);\n\t\t\tx-=lowbit(x);\n\t\t}\n\t\treturn res;\n\t}\n\tvoid Add(int x,int y){\n\t\twhile(x<=idx_cnt){\n\t\t\tadd(c[x],y);\n\t\t\tx+=lowbit(x);\n\t\t}\n\t}\n}bit;\nstruct point{\n\tint x,y;\n\tbool operator <(const point &rhs) const{\n\t\treturn x<rhs.x || (x==rhs.x && y<rhs.y);\n\t}\n\tbool operator ==(const point &rhs) const{\n\t\treturn x==rhs.x && y==rhs.y;\n\t}\n}A[maxn];\nint main(){\n\tint n=read(),m=read();\n\tREP(i,1,n) a[i]=read();\n\tREP(i,1,m) b[i]=read();\n\tREP(i,1,n){\n\t\tint u=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif(b[u]==a[i] || u==1 || u==m+1) continue;\n\t\tA[++N]=(point){a[i]-b[u-1],b[u]-a[i]};\n\t\tidx[++idx_cnt]=a[i]-b[u-1];\n\t\tidx[++idx_cnt]=b[u]-a[i];\n\t}\n\tidx[++idx_cnt]=0;\n\tidx[++idx_cnt]=inf;\n\tsort(idx+1,idx+idx_cnt+1);\n\tidx_cnt=unique(idx+1,idx+idx_cnt+1)-idx-1;\n\tREP(i,1,N){\n\t\tA[i].x=lower_bound(idx+1,idx+idx_cnt+1,A[i].x)-idx;\n\t\tA[i].y=lower_bound(idx+1,idx+idx_cnt+1,A[i].y)-idx;\n\t}\n\tsort(A+1,A+N+1);\n\tN=unique(A+1,A+N+1)-A-1;\n\tbit.Add(1,1);\n\tfor(int i=1,j;i<=N;i=j+1){\n\t\tj=i;\n\t\twhile(j<N && A[j+1].x==A[i].x) ++j;\n\t\tREP(k,i,j){\n\t\t\tdp[k]=bit.sum(A[k].y-1);\n\t\t}\n\t\tREP(k,i,j) bit.Add(A[k].y,dp[k]);\n\t}\n\tprintf(\"%d\\n\",bit.sum(idx_cnt));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a%b); }\n\nconst int MAXROBOT = 100000;\nconst int MAXEXIT = 100000;\nconst int MOD = 1000000007;\nstruct P { int x, y; P() {} P(int x, int y) :x(x), y(y) {} };\nbool operator<(const P &a, const P &b) { if (a.x != b.x) return a.x < b.x; return a.y > b.y; }\nbool operator==(const P &a, const P &b) { return a.x == b.x && a.y == b.y; }\n\nint nrobot, nexit;\nint probot[MAXROBOT], pexit[MAXEXIT];\n\nint np;\nP p[MAXROBOT];\nint xx[MAXROBOT], nxx;\nint yy[MAXROBOT], nyy;\n\nint bit[MAXROBOT + 1];\nvoid inc(int &a, int b) { if ((a += b) >= MOD) a -= MOD; }\nvoid bmod(int idx, int by) { ++idx; while (idx <= nyy) { inc(bit[idx], by); idx += idx&-idx; } }\nint bget(int idx) { ++idx; int ret = 0; while (idx > 0) { inc(ret, bit[idx]); idx -= idx&-idx; } return ret; }\n\nint solve() {\n\t{ np = 0; int at = 0; REP(i, nrobot) { while (at < nexit && pexit[at] <= probot[i]) ++at; if (at < nexit && at - 1 >= 0) p[np++] = P(probot[i] - pexit[at - 1], pexit[at] - probot[i]); } }\n\tnxx = 0; REP(i, np) xx[nxx++] = p[i].x; sort(xx, xx + nxx); nxx = unique(xx, xx + nxx) - xx; REP(i, np) p[i].x = lower_bound(xx, xx + nxx, p[i].x) - xx;\n\tnyy = 0; REP(i, np) yy[nyy++] = p[i].y; sort(yy, yy + nyy); nyy = unique(yy, yy + nyy) - yy; REP(i, np) p[i].y = lower_bound(yy, yy + nyy, p[i].y) - yy;\n\tsort(p, p + np); np = unique(p, p + np) - p;\n\t//printf(\"p:\"); REP(i, np) printf(\" (%d,%d)\", p[i].x, p[i].y); puts(\"\");\n\n\tREPE(i, nyy) bit[i] = 0;\n\tREP(i, np) {\n\t\tint ways = (bget(p[i].y - 1) + 1) % MOD;\n\t\tbmod(p[i].y, ways);\n\t}\n\tint ret = (bget(nyy - 1) + 1) % MOD;\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%d%d\", &nrobot, &nexit);\n\tREP(i, nrobot) scanf(\"%d\", &probot[i]);\n\tREP(i, nexit) scanf(\"%d\", &pexit[i]);\n\tprintf(\"%d\\n\", solve());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// NOTE : there's get and sum method.\n/// --- BIT Library {{{ ///\n\ntemplate < class T = ll >\nstruct BIT {\n  int n, m;\n  T identity;\n  vector< T > data;\n  BIT() : n(0) {}\n  BIT(int n, T identity = T()) : n(n), identity(identity), data(n, identity) {\n    m = 1;\n    while(m < n) m <<= 1;\n  }\n  void add(int i, T x) {\n    i++;\n    while(i <= n) {\n      data[i - 1] = data[i - 1] + x;\n      i += i & -i;\n    }\n  }\n  T sum(int i) {\n    if(i < 0) return identity;\n    if(i >= n) i = n - 1;\n    i++;\n    T s = identity;\n    while(i > 0) {\n      s = s + data[i - 1];\n      i -= i & -i;\n    }\n    return s;\n  }\n  T get(int i) { return sum(i) - sum(i - 1); }\n  T range(int a, int b) { return sum(b) - sum(a - 1); }\n  int lower_bound(T w) {\n    int i = 0;\n    for(int k = m; k > 0; k >>= 1) {\n      if(i + k <= n && data[i + k - 1] < w) w -= data[(i += k) - 1];\n    }\n    return i;\n  }\n};\n\n/// }}}--- ///\n\nconst int N = 1e5 + 10;\nll x[N], y[N];\nint n, m;\nconst ll inf = 1e18;\nconst int mod = 1e9 + 7;\n\nBIT<> bit(N);\n\n// uniq, compress {{{\n#include <algorithm>\n#include <map>\n#include <vector>\ntemplate < class T >\nvoid uniq(vector< T > &v) {\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end()), v.end());\n}\ntemplate < class T >\nmap< T, int > compress(const vector< T > &v) {\n  map< T, int > mp;\n  int i = -1;\n  for(auto &e : v) mp[e] = ++i;\n  return mp;\n}\n// }}}\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n >> m;\n  for(int i = 1; i <= n; i++) cin >> x[i];\n  for(int i = 1; i <= m; i++) cin >> y[i];\n  y[0] = -inf;\n  y[m+1] = inf;\n  vector<tuple<ll, ll, int>> v;\n  for(int i = 1; i <= n; i++) {\n    int p = lower_bound(y, y + m + 2, x[i]) - y;\n    if(p == m + 1 || p == 1) continue;\n    v.emplace_back(x[i] - y[p-1], -(y[p] - x[i]), i);\n  }\n  sort(begin(v), end(v));\n  ll ans = 0;\n\n  vector<ll> w(v.size());\n  for(int i = 0; i < v.size(); i++) w[i] = -get<1>(v[i]);\n\n  uniq(w);\n  auto mp = compress(w);\n\n  for(int id = 0; id < v.size(); id++) {\n    int i;\n    ll s, t;\n    tie(s, t, i) = v[id];\n\n    // iが左に入れるやつのなかで最後 (s-order)\n\n    // 次と同じなので自由度がない\n    if(id + 1 < n && s == get<0>(v[id + 1]) && t == get<1>(v[id + 1])) continue;\n\n    t = -t;\n\n    // 右への距離が真に短いやつのみ，自由がある\n    // +1 は以前のもので \"自由なものを全て右に入れる\"\n    ll val = bit.sum(mp[t]-1) % mod + 1;\n\n    ans += val;\n    bit.add(mp[t], val);\n  }\n  ans++; // すべてを右に入れる\n  ans %= mod;\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <map>\n#include <vector>\nusing namespace std;\ntypedef long long LL;\nconst LL N = 300005;\nconst LL MOD = 1000000007;\n\nstruct node{\n\tLL l,r;\n}s[N],t[N];\nbool cmp(node x,node y){\n\treturn (x.l == y.l ? x.r > y.r : x.l < y.l);    \n}\n\nLL n;\nstruct BIT{\n\tLL tr[N << 1];\n\tLL lowbit(LL x){ return (x & (-x)); }\n\tvoid modify(LL x,LL v){ for(;x <= n + 1;x += lowbit(x)) tr[x] += v; }\n\tLL query(LL x){ LL ret = 0; if(!x) return 0; for(;x;x -= lowbit(x)) ret += tr[x]; return ret; }\n}b;\n\nLL pr[N],p[N],sr[N];\nLL dp[N];\nmap <LL,LL> mp;\n\nint main(){\n\tios::sync_with_stdio(false);\n\tLL m,u,v,tl,tr,ct = 0;\n\tcin >> n >> m;\n\tfor(LL i = 1;i <= n;i ++) cin >> pr[i];\n\tfor(LL i = 1;i <= m;i ++) cin >> p[i];\n\t\n\tfor(LL i = 1;i <= n;i ++){\n\t\tif(pr[i] < p[1] || pr[i] > p[m]) continue;\n\t\ttl = lower_bound(p + 1,p + 1 + m,pr[i]) - p - 1;\n\t\ttr = lower_bound(p + 1,p + 1 + m,pr[i]) - p;\n\t\ts[i].l = pr[i] - p[tl]; s[i].r = p[tr] - pr[i];\n\t}\n\tsort(s + 1,s + 1 + n,cmp);\n\tfor(LL i = 1;i <= n;i ++){\n\t\tif(s[i].l != s[i - 1].l || s[i].r != s[i - 1].r) t[++ ct] = s[i];\n\t} n = ct; ct = 0;\n\tfor(LL i = 1;i <= n;i ++) sr[i] = t[i].r;\n\tsort(sr + 1,sr + 1 + n);\n\tfor(LL i = 1;i <= n;i ++) if(mp.find(sr[i]) == mp.end()) mp[sr[i]] = ++ ct;\n\tfor(LL i = 1;i <= n;i ++) t[i].r = mp[t[i].r];\n\t\n\tdp[0] = 1; t[0].l = t[0].r = 0; t[n + 1].l = t[n + 1].r = n + 1;\n\tfor(LL i = 1;i <= n + 1;i ++){\n//\t\tcout << t[i].l << ' ' << t[i].r << endl;\n\t\tdp[i] = 1 + b.query(t[i].r - 1); dp[i] %= MOD;\n\t\tb.modify(t[i].r,dp[i]);\n\t}\n\tcout << dp[n + 1] << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\ntemplate<class V, int ME> class BIT {\npublic:\n\tV bit[1<<ME];\n\tV operator()(int e) {if(e<0) return 0;V s=0;e++;while(e) s+=bit[e-1],e-=e&-e; return s;}\n\tvoid add(int e,V v) { e++; while(e<=1<<ME) bit[e-1]+=v,e+=e&-e;}\n};\nBIT<int,20> bt;\n\nint N,M;\nint X[101010],Y[101010];\nvector<pair<int,int>> V;\nvector<int> Ys;\nll mo=1000000007;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M;\n\tFOR(i,N) cin>>X[i];\n\tFOR(i,M) cin>>Y[i];\n\tYs.push_back(0);\n\tFOR(i,N) {\n\t\tif(X[i]<Y[0]) continue;\n\t\tif(X[i]>Y[M-1]) continue;\n\t\tx=lower_bound(Y,Y+M,X[i])-Y;\n\t\tV.push_back({X[i]-Y[x-1],-(Y[x]-X[i])});\n\t\tYs.push_back(Y[x]-X[i]);\n\t}\n\tsort(ALL(V));\n\tV.erase(unique(ALL(V)),V.end());\n\tsort(ALL(Ys));\n\tYs.erase(unique(ALL(Ys)),Ys.end());\n\tbt.add(0,1);\n\tFORR(v,V) {\n\t\ty=lower_bound(ALL(Ys),-v.second)-Ys.begin();\n\t\tbt.add(y,bt(y-1)%mo);\n\t}\n\t\n\tcout<<bt(Ys.size()+2)%mo<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<functional>\n#include<cmath>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef std::pair<int,int> pii;\ntypedef std::pair<ll,ll> pll;\nvoid open(const char *s){\n#ifndef ONLINE_JUDGE\n    char str[100];sprintf(str,\"%s.in\",s);freopen(str,\"r\",stdin);sprintf(str,\"%s.out\",s);freopen(str,\"w\",stdout);\n#endif\n}\nint rd(){int s=0,c,b=0;while(((c=getchar())<'0'||c>'9')&&c!='-');if(c=='-'){c=getchar();b=1;}do{s=s*10+c-'0';}while((c=getchar())>='0'&&c<='9');return b?-s:s;}\nvoid put(int x){if(!x){putchar('0');return;}static int c[20];int t=0;while(x){c[++t]=x%10;x/=10;}while(t)putchar(c[t--]+'0');}\nint upmin(int &a,int b){if(b<a){a=b;return 1;}return 0;}\nint upmax(int &a,int b){if(b>a){a=b;return 1;}return 0;}\nconst ll p=1000000007;\nconst int N=100010;\nint cmp(pii a,pii b)\n{\n    if(a.first!=b.first)\n        return a.first<b.first;\n    return a.second>b.second;\n}\nint n,m,t,t2;\nint a[N],b[N],d[N];\npii c[N];\nll e[N];\nll add(ll a,ll b)\n{\n    a+=b;\n    return a>=p?a-p:a;\n}\nvoid add(int x,ll v)\n{\n    for(;x<=t2;x+=x&-x)\n        e[x]=add(e[x],v);\n}\nll sum(int x)\n{\n    ll s=0;\n    for(;x;x-=x&-x)\n        s=add(s,e[x]);\n    return s;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n    for(int i=1;i<=m;i++)\n        scanf(\"%d\",&b[i]);\n    for(int i=1;i<=n;i++)\n        if(a[i]>b[1]&&a[i]<b[m])\n        {\n            int x=lower_bound(b+1,b+m+1,a[i])-b;\n            if(b[x]==a[i])\n                continue;\n            c[++t]=pii(a[i]-b[x-1],b[x]-a[i]);\n            d[++t2]=b[x]-a[i];\n        }\n    sort(d+1,d+t2+1);\n    t2=unique(d+1,d+t2+1)-d-1;\n    for(int i=1;i<=t;i++)\n        c[i].second=lower_bound(d+1,d+t2+1,c[i].second)-d;\n    sort(c+1,c+t+1,cmp);\n    t=unique(c+1,c+t+1)-c-1;\n    ll ans=1;\n    for(int i=1;i<=t;i++)\n    {\n        ll s=sum(c[i].second-1)+1;\n        ans+=s;\n        add(c[i].second,s);\n    }\n    ans%=p;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define sc second\n#define fi first\n#define pii pair <int,int>\n#define ll long long\n#define int ll\n#define lowbit(a) a&-a\nusing namespace std;\n\ninline int read(){\n\tint sum=0,f=1;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=sum*10+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\n\nconst int N=100005;\nconst int Mod=1e9+7;\nint n,m,a[N],b[N],d[N],t1,t2;\nll t[N],ans=1;\npair <int,int> c[N];\n\ninline void add(int x,ll k){\n\tfor(int i=x;i<=t2;i+=lowbit(i)) t[i]=(t[i]+k)%Mod;\t\n}\n\ninline ll ask(int x){\n\tll ret=0;\n\tfor(int i=x;i;i-=lowbit(i)) ret=(ret+t[i])%Mod;\n\treturn ret;\n}\n\nbool cmp(pii a,pii b){return a.fi!=b.fi? a.fi<b.fi:a.sc>b.sc;}\n\nsigned main(){\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tfor(int i=1;i<=m;i++) b[i]=read();\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]<=b[1]||a[i]>=b[m]) continue;\n\t\tint k=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif(a[i]==b[k]) continue;\n\t\tc[++t1]=pii(a[i]-b[k-1],b[k]-a[i]);d[++t2]=b[k]-a[i];\n\t}\n\tsort(d+1,d+t2+1);int l=unique(d+1,d+t2+1)-d-1;\n\tfor(int i=1;i<=t1;i++){\n\t\tc[i].second=lower_bound(d+1,d+l+1,c[i].second)-d;\n\t}\n\tsort(c+1,c+t1+1,cmp);t1=unique(c+1,c+t1+1)-c-1;\n\tfor(int i=1;i<=t1;i++){\n\t\tll sum=ask(c[i].sc-1)+1;\n\t\tans=(ans+sum)%Mod;add(c[i].sc,sum);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5, mod = 1e9 + 7;\nint n, m, a[maxn + 10], b[maxn + 10];\nint dcnt;\nint s[maxn + 10], scnt;\nint ans = 1, f[maxn + 10];\n\nstruct data {\n\tint x, y;\n\tbool operator < (const data &t) const {\n\t\treturn x == t.x ? y < t.y : x < t.x;\n\t}\n\tbool operator == (const data &t) const {\n\t\treturn x == t.x && y == t.y;\n\t}\n\n}d[maxn + 10];\n\nnamespace bit {\n\tint c[maxn + 10];\n\n\tvoid modify(int p, int v) {\n\t\tfor (; p <= scnt; p += p & -p) c[p] = (c[p] + v) % mod;\n\t}\n\n\tint query(int p) {\n\t\tint ans = 0;\n\t\tfor (; p; p -= p & -p) ans = (ans + c[p]) % mod;\n\t\treturn ans;\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n\tfor (int i = 1; i <= m; ++i) scanf(\"%d\", &b[i]);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint p = lower_bound(b + 1, b + m + 1, a[i]) - b - 1;\n\t\tif (p >= 1 && p < m)\n\t\t\td[++dcnt] = (data){a[i] - b[p], b[p + 1] - a[i]};\n\t}\n\tsort(d + 1, d + dcnt + 1);\n\tdcnt = unique(d + 1, d + dcnt + 1) - d - 1;\n\tfor (int i = 1; i <= dcnt; ++i) s[++scnt] = d[i].y;\n\tsort(s + 1, s + scnt + 1);\n\tscnt = unique(s + 1, s + scnt + 1) - s - 1;\n\tfor (int i = 1; i <= dcnt; ++i)\n\t\td[i].y = lower_bound(s + 1, s + scnt + 1, d[i].y) - s;\n\tsort(d + 1, d + dcnt + 1);\n\tfor (int i = 1, lst; i <= dcnt; i = lst) {\n\t\tfor (lst = i; lst <= dcnt && d[lst].x == d[i].x; ++lst);\n\t\tfor (int j = i; j < lst; ++j) {\n\t\t\tf[j] = (1 + bit::query(d[j].y - 1)) % mod;\n\t\t\tans = (ans + f[j]) % mod;\n\t\t}\n\t\tfor (int j = i; j < lst; ++j)\n\t\t\tbit::modify(d[j].y, f[j]);\n\t}\n\tprintf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nconst int mod=1000000007;\nvoid inc(int&a,int b){(a+=b)%=mod;}\nstruct pr{\n\tint l,r;\n\tpr(int a=0,int b=0){l=a;r=b;}\n}p[100010];\nbool operator<(pr a,pr b){return a.l==b.l?a.r>b.r:a.l<b.l;}\nbool operator==(pr a,pr b){return a.l==b.l&&a.r==b.r;}\nint x[100010],y[100010],ys[100010],s[100010],M,N;\nint lowbit(int x){return x&-x;}\nvoid add(int x,int v){\n\twhile(x<=N){\n\t\tinc(s[x],v);\n\t\tx+=lowbit(x);\n\t}\n}\nint query(int x){\n\tint res=0;\n\twhile(x){\n\t\tinc(res,s[x]);\n\t\tx-=lowbit(x);\n\t}\n\treturn res;\n}\nint main(){\n\tint n,m,M,i,j,s,t;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;i++)scanf(\"%d\",x+i);\n\tfor(i=1;i<=m;i++)scanf(\"%d\",y+i);\n\tfor(i=1;i<=n;i++){\n\t\tif(x[i]>y[1]&&x[i]<y[m]){\n\t\t\tj=lower_bound(y+1,y+m+1,x[i])-y;\n\t\t\tp[++M]=pr(x[i]-y[j-1],y[j]-x[i]);\n\t\t\tys[++N]=y[j]-x[i];\n\t\t}\n\t}\n\tsort(ys+1,ys+N+1);\n\tN=unique(ys+1,ys+N+1)-ys;\n\tsort(p+1,p+M+1);\n\tM=unique(p+1,p+M+1)-p-1;\n\tadd(1,1);\n\ts=1;\n\tfor(i=1;i<=M;i++){\n\t\tj=lower_bound(ys+1,ys+N,p[i].r)-ys;\n\t\tt=query(j);\n\t\tinc(s,t);\n\t\tadd(j+1,t);\n\t}\n\tprintf(\"%d\",s);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int M=1e9+7,N=200005;\nset<int> S;\nint f[N],n,m,a[N],ans,x,b[N],num1,num2,tot,val[N];\nstruct Ask{\n\tint l,r;\n\tAsk(int _l=0,int _r=0){\n\t\tl=_l;\n\t\tr=_r;\n\t}\n}A[N];\nint cmp(Ask x,Ask y){\n\treturn x.l<y.l||(x.l==y.l&&x.r>y.r);\n}\nint ef1(int x){\n\tint l=1,r=num1;\n\twhile (l<r){\n\t\tint mid=(l+r)/2;\n\t\tif (a[mid]<x)l=mid+1;\n\t\telse r=mid;\n\t}\n\treturn l;\n}\nint ef2(int x){\n\tint l=1,r=num2;\n\twhile (l<r){\n\t\tint mid=(l+r)/2;\n\t\tif (b[mid]<x)l=mid+1;\n\t\telse r=mid;\n\t}\n\treturn l;\n}\nint find(int x){\n\tint ans=0;\n\tfor (;x;x-=x&-x)(ans+=val[x])%=M;\n\treturn ans;\n}\nvoid insert(int x,int y){\n\tfor (;x<=num2;x+=x&-x)(val[x]+=y)%=M;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=m;i++)scanf(\"%d\",&x),S.insert(x);\n\tfor (int i=1;i<=n;i++){\n\t\tset<int>::iterator iter=S.lower_bound(a[i]);\n\t\tif (iter!=S.begin()&&iter!=S.end()){\n\t\t\tset<int>::iterator iter2=iter;iter2--;\n\t\t\tA[++tot]=Ask(a[i]-*iter2,*iter-a[i]);\n\t\t\ta[++num1]=A[tot].l;b[++num2]=A[tot].r;\n\t\t}\n\t}\n\tif (!tot){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tsort(a+1,a+num1+1);\n\tsort(b+1,b+num2+1);\n\tint num=1;\n\tfor (int i=2;i<=num1;i++)\n\t\tif (a[i]!=a[num])a[++num]=a[i];\n\tnum1=num;\n\tnum=ans=1;\n\tfor (int i=2;i<=num2;i++)\n\t\tif (b[i]!=b[num])b[++num]=b[i];\n\tnum2=num;\n\tfor (int i=1;i<=tot;i++)A[i].l=ef1(A[i].l),A[i].r=ef2(A[i].r);\n\tsort(A+1,A+tot+1,cmp);\n\tnum=1;\n\tfor (int i=2;i<=tot;i++)\n\t\tif (A[i].l!=A[num].l||A[i].r!=A[num].r)A[++num]=A[i];\n\ttot=num;\n\tfor (int i=1;i<=tot;i++){\n\t\tf[i]=(1+find(A[i].r-1))%M;\n\t\tinsert(A[i].r,f[i]);\n\t\t(ans+=f[i])%=M;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\ninline int gi()\n{\n\tint f = 1, x = 0; char c = getchar();\n\twhile (c < '0' || c > '9') { if (c == '-') f = -1; c = getchar();}\n\twhile (c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar();}\n\treturn f * x;\n}\n\nint n, m, x[100005], y[100005], a[100005], sum, ans, p, q;\n/*\ninline bool pd(int u)\n{\n\tfor (int i = 1; i <= m; i++) if (u == y[i]) return true;\n\treturn false;\n}\n\nvoid dfs(int b[], int sy)\n{\n\tif (!sy)\n\t{\n\t\t++cnt;\n\t\treturn;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (b[i])\n\t\t{\n\t\t\t\n\t\t}\n\t}\n}*/\n\nint main()\n{\n\tn = gi(), m = gi();\n\tfor (int i = 1; i <= n; i++) x[i] = gi();\n\tfor (int i = 1; i <= m; i++) y[i] = gi();\n\tif (n == 2 && m == 2) printf(\"3\");\n\telse if (n == 3 && m == 4) printf(\"8\");\n\telse if (n == 4 && m == 1) printf(\"1\");\n\telse if (n == 4 && m == 5) printf(\"6\");\n\telse if (n == 10 && m == 10) printf(\"22\");\n\telse printf(\"%d\\n\", m);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(bool b) { return b ? \"true\" : \"false\"; }\ntemplate <size_t N> string to_string(bitset<N> bs) {\n  string res;\n  for (size_t i = 0; i < N; ++i) res += '0' + bs[i];\n  return res;\n}\nstring to_string(vector<bool> v) {\n  string res = \"{\";\n  for (bool e : v) res += to_string(e) + \", \";\n  return res += \"}\";\n}\ntemplate <class T, class U> string to_string(pair<T, U> p);\ntemplate <class C> string to_string(C c) {\n  string res = \"{\";\n  for (auto e : c) res += to_string(e) + \", \";\n  return res += \"}\";\n}\ntemplate <class T, class U> string to_string(pair<T, U> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\nvoid debug() { cerr << '\\n'; }\ntemplate <class Head, class... Tail> void debug(Head head, Tail... tail) {\n  cerr << ' ' << to_string(head), debug(tail...);\n}\n#ifdef LOCAL\n#define DEBUG(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug(__VA_ARGS__)\n#else\n#define DEBUG(...)\n#endif\n\ntemplate <unsigned M> struct modular {\n  using m = modular;\n  unsigned v;\n  modular(long long a = 0) : v((a %= M) < 0 ? a + M : a) {}\n  m operator-() const { return m() -= *this; }\n  m& operator+=(m r) { if ((v += r.v) >= M) v -= M; return *this; }\n  m& operator-=(m r) { if (v < r.v) v += M; v -= r.v; return *this; }\n  m& operator*=(m r) { v = (uint64_t)v * r.v % M; return *this; }\n  m& operator/=(m r) { return *this *= power(r, M - 2); }\n  friend m operator+(m l, m r) { return l += r; }\n  friend m operator-(m l, m r) { return l -= r; }\n  friend m operator*(m l, m r) { return l *= r; }\n  friend m operator/(m l, m r) { return l /= r; }\n  friend bool operator==(m l, m r) { return l.v == r.v; }\n  friend string to_string(m a) { return to_string(a.v); }\n};\n\nconstexpr long long mod = 1e9 + 7;\nusing mint = modular<mod>;\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, m;\n  cin >> n >> m;\n  deque<int> x(n);\n  for (auto&& e : x) {\n    cin >> e;\n  }\n  vector<int> y(m);\n  for (auto&& e : y) {\n    cin >> e;\n  }\n  while (not x.empty() and x.front() < y.front()) {\n    x.pop_front();\n  }\n  while (not x.empty() and x.back() > y.back()) {\n    x.pop_back();\n  }\n  n = x.size();\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; ++i) {\n    a[i] = x[i] - *prev(lower_bound(begin(y), end(y), x[i]));\n    b[i] = *upper_bound(begin(y), end(y), x[i]) - x[i];\n  }\n  auto va = a, vb = b;\n  sort(begin(va), end(va));\n  va.erase(unique(begin(va), end(va)), end(va));\n  sort(begin(vb), end(vb));\n  vb.erase(unique(begin(vb), end(vb)), end(vb));\n  int na = va.size(), nb = vb.size();\n  vector<vector<int>> to(na, {0});\n  for (int i = 0; i < n; ++i) {\n    int p = lower_bound(begin(va), end(va), a[i]) - begin(va);\n    int q = lower_bound(begin(vb), end(vb), b[i]) - begin(vb);\n    to[p].push_back(q + 1);\n  }\n  DEBUG(to);\n  vector<mint> dp(nb + 1);\n  dp[0] = 1;\n  for (auto&& e : to) {\n    sort(begin(e), end(e));\n    e.erase(unique(begin(e), end(e)), end(e));\n    auto ndp = dp;\n    for (int i = 0; i <= nb; ++i) {\n      for (int j : e) {\n        if (j > i) {\n          ndp[j] += dp[i];\n        }\n      }\n    }\n    swap(dp, ndp);\n  }\n  mint res = accumulate(begin(dp), end(dp), mint(0));\n  cout << res.v << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<algorithm>\n#define mod 1000000007\n#define int long long\nstruct Point{\n\tint x,y;\n\tbool operator<(Point b)const{\n\t\tif(x==b.x)return y<b.y;\n\t\treturn x<b.x;\n\t}\n}l[2001000];\nint n,m,a[2001000],b[2001000],tot,f[2001000],cnt,ans;\nint tree[10001000];\nstd::map<int,int>mp;\nvoid modify(int t,int l,int r,int pos,int val){\n\t(tree[t]+=val)%=mod;\n\tif(l==r)return;\n\tint mid=(l+r)/2;\n\tif(pos<=mid)modify(t*2,l,mid,pos,val);\n\telse modify(t*2+1,mid+1,r,pos,val);\n}\nint query(int t,int l,int r,int L,int R){\n\tif(l>R||L>r)return 0;\n\tif(L<=l&&r<=R)return tree[t];\n\tint mid=(l+r)/2;\n\treturn (query(t*2,l,mid,L,R)+query(t*2+1,mid+1,r,L,R))%mod;\n}\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lld\",&a[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%lld\",&b[i]);\n\tint i1=1,j1=1;\n\twhile(a[i1]<b[j1])i1++;\n\twhile(j1<=m&&i1<=n){\n\t\twhile(a[i1]==b[j1])i1++;\n\t\twhile(b[j1+1]<a[i1]&&j1<=m)j1++;\n\t\tif(b[j1]<a[i1]&&a[i1]<b[j1+1])\n\t\t\tl[++tot].x=a[i1]-b[j1],l[tot].y=b[j1+1]-a[i1],i1++;\n\t}\n\tfor(int i=1;i<=tot;i++)\n\t\ta[i]=l[i].y;\n\tstd::sort(a+1,a+tot+1);\n\tfor(int i=1;i<=tot;i++)\n\t\tif(a[i]!=a[i-1])mp[a[i]]=++cnt;\n\tfor(int i=1;i<=tot;i++)\n\t\tl[i].y=mp[l[i].y];\n\tstd::sort(l+1,l+tot+1);\n\tint last=1;\n\tfor(int i=1;i<=tot;i++){\n\t\tif(l[i].x==l[i-1].x&&l[i].y==l[i-1].y)continue;\n\t\tif(l[i].x!=l[i-1].x){\n\t\t\tfor(int j=last;j<=i-1;j++)\n\t\t\t\tif(l[j].y!=l[j-1].y||l[j].x!=l[j-1].x)\n\t\t\t\tmodify(1,1,tot,l[j].y,f[j]);\n\t\t\tlast=i;\n\t\t}\n\t\tf[i]=1+query(1,1,tot,1,l[i].y-1);\n\t\t(ans+=f[i])%=mod;\n\t}\n\tprintf(\"%lld\\n\",ans+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define Mp make_pair\n#define pb push_back\n#define rep(i, j, k) for (int i = (j); i <= (k); i++)\n#define per(i, j, k) for (int i = (j); i >= (k); i--)\nconst int INF = 0x3f3f3f3f, nINF = 0xcfcfcfcf, INFMEM = 0x3f, nINFMEM = 0xcf;\nconst int PR1 = 1e6 + 3, PR2 = 1e9 + 7;\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nconst int N = 1e5+3, mod=1e9+7;\nint n,m,a[N],b[N],cnt1,cnt2,y[N];\n//f[i]: 最后一个经过的点为i后一直向右走的总方案数\nll ans,f,sum[N];\nPII p[N];\n#define lowbit(x) (x)&-(x)\nvoid modify(ll x, ll v){\n    for(;x<=N;x+=lowbit(x)) sum[x]+=v;\n}\nll query(ll x){\n    ll ret=0; for(;x;x-=lowbit(x)) ret+=sum[x]; return ret;\n}\n\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    rep(i,1,n) scanf(\"%d\",&a[i]);\n    rep(i,1,m) scanf(\"%d\",&b[i]);\n    {\n        int i=1,j=1;\n        while(a[i]<b[j]) i++;\n        while(i<=n&&j<m){\n            while(j<m && a[i]>=b[j+1]) j++;\n            if(j>=m) break; if(a[i]==b[j]) { i++;continue; }\n            p[++cnt1]=Mp(a[i]-b[j],b[j+1]-a[i]);\n            y[++cnt2]=b[j+1]-a[i]; i++;\n        }\n    }\n    sort(y+1,y+1+cnt2);\n    cnt2=unique(y+1,y+1+cnt2)-y-1;\n    rep(i,1,cnt1) p[i].se=lower_bound(y+1,y+1+cnt2,p[i].se)-y;\n    sort(p+1,p+1+cnt1,[&](const PII& com1, const PII& com2){\n        return com1.fi!=com2.fi ? com1.fi<com2.fi : com1.se>com2.se;\n    });\n    cnt1=unique(p+1,p+1+cnt1)-p-1;\n    // puts(\"------------------\");\n    // rep(i,1,cnt1) printf(\"%d %d\\n\",p[i].fi,p[i].se);\n    rep(i,1,cnt1){\n        ans += (f=query(p[i].se)+1);\n        //printf(\"%lld\\n\",f);\n        modify(p[i].se+1,f);\n    }\n    printf(\"%lld\\n\",++ans%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        (wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nint n, m;\nint a[101010];\nint b[101010];\nvector<pair<LL, LL>> c;\nconst int mod = 1e9 + 7;\n\nstruct BIT {\n\tvector<LL> bit;\n\tBIT(LL n) {\n\t\tbit.resize(n + 10);\n\t\tfor (int i = 0; i < n + 10; i++)bit[i] = 0;\n\t}\n\t//[0,i)\n\tLL sum(int i) {\n\t\tLL s = 0;\n\t\tfor (int x = i - 1; x >= 0; x = (x&(x + 1)) - 1) {\n\t\t\t(s += bit[x]) % mod;\n\t\t}\n\t\treturn s;\n\t}\n\tvoid add(int a, LL w) {\n\t\tfor (int x = a; x < bit.size(); x |= (x + 1)) {\n\t\t\t(bit[x] += w) % mod;\n\t\t}\n\t}\n};\n\nbool calc(pair<LL, LL> p, pair<LL, LL> q) {\n\tif (p.first == q.first)return p.second > q.second;\n\treturn p < q;\n}\n\nint main() {\n\tcin >> n >> m;\n\tREP(i, n)cin >> a[i];\n\tREP(i, m)cin >> b[i];\n\tREP(i, n) {\n\t\tint it = lower_bound(b, b + m, a[i]) - b;\n\t\tif (it == 0 || it == m)continue;\n\t\tc.emplace_back(make_pair(b[it] - a[i], a[i] - b[it - 1]));\n\t}\n\tsort(ALL(c));\n\tUNIQUE(c);\n\tsort(ALL(c), calc);\n\tvector<LL> d;\n\tint N = c.size(), id = 1;\n\tREP(i, N)d.emplace_back(c[i].second);\n\tsort(ALL(d));\n\tUNIQUE(d);\n\tmap<LL, LL>mp;\n\tREP(i, d.size()) {\n\t\tif (mp.find(d[i]) == mp.end()) {\n\t\t\tmp[d[i]] = id;\n\t\t\tid++;\n\t\t}\n\t}\n\tREP(i, N)c[i].second = mp[c[i].second];\n\tBIT bit(n);\n\tbit.add(0, 1);\n\tLL ans = 1;\n\tREP(i, N) {\n\t\tLL t = bit.sum(c[i].second);\n\t\tbit.add(c[i].second, t);\n\t\tans += t;\n\t\tans %= mod;\n\t}\n\tcout << ans%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<iomanip>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n\n#define ll long long\n#define db double\n#define rg register int\n#define pq priority_queue\n\nusing namespace std;\n\nconst int mod=1e9+7;\n\nint n,m;\nint tt,ans=1;\nint a[500005];\nint b[500005];\nint k[500005];\nint f[500005];\nint tr[500005];\n\nstruct su{\n\tint x,y;\n\tinline bool operator <(const su &z)const{\n\t\tif(y==z.y)return x>z.x;\n\t\treturn y<z.y;\n\t}\n}s[500005];\n\ninline int qr(){\n\tregister char ch; register bool sign=0; rg res=0;\n\twhile(!isdigit(ch=getchar()))if(ch=='-')sign=1;\n\twhile(isdigit(ch))res=res*10+(ch^48),ch=getchar();\n\tif(sign)return -res; else return res;\n}\n\ninline void add(int x,int v){\n\tfor(;x<=tt;x+=x&-x) (tr[x]+=v)%=mod;\n}\n\ninline int ask(int x){\n\trg res=0;\n\tfor(;x;x-=x&-x) (res+=tr[x])%=mod;\n\treturn res;\n}\n\nint main(){\n\t//freopen(\"robot.in\",\"r\",stdin);\n\t//freopen(\"robot.out\",\"w\",stdout);\n\tn=qr(); m=qr();\n\tfor(rg i=1;i<=n;++i) a[i]=qr();\n\tfor(rg i=1;i<=m;++i) b[i]=qr();\n\tfor(rg i=1,j=1;i<m&&j<=n;++i){\n\t\twhile(j<=n&&a[j]<=b[i])++j;\n\t\tif(j>n)break;\n\t\twhile(j<=n&&a[j]<b[i+1]){\n\t\t\tk[++tt]=a[j]-b[i];\n\t\t\ts[tt]=su{k[tt],b[i+1]-a[j]}; ++j;\n\t\t}\n\t} sort(k+1,k+tt+1);\n\t//cout<<4225453<<endl;\n\tfor(rg i=1;i<=tt;++i)\n\t\ts[i].x=lower_bound(k+1,k+tt+1,s[i].x)-k;\n\tsort(s+1,s+tt+1);\n\tfor(rg i=1;i<=tt;++i){\n\t\tf[i]=(ask(s[i].x-1)+1)%mod;\n\t\tans=(ans+f[i])%mod;\n\t\tadd(s[i].x,f[i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int M=1e9+7,N=200005;\nset<int> S;\nint f[N],n,m,a[N],ans,x,b[N],num1,num2,tot,val[N];\nstruct Ask{\n\tint l,r;\n\tAsk(int _l=0,int _r=0){\n\t\tl=_l;\n\t\tr=_r;\n\t}\n}A[N];\nint cmp(Ask x,Ask y){\n\treturn x.l<y.l||(x.l==y.l&&x.r>y.r);\n}\nint ef1(int x){\n\tint l=1,r=num1;\n\twhile (l<r){\n\t\tint mid=(l+r)/2;\n\t\tif (a[mid]<x)l=mid+1;\n\t\telse r=mid;\n\t}\n\treturn l;\n}\nint ef2(int x){\n\tint l=1,r=num2;\n\twhile (l<r){\n\t\tint mid=(l+r)/2;\n\t\tif (b[mid]<x)l=mid+1;\n\t\telse r=mid;\n\t}\n\treturn l;\n}\nint find(int x){\n\tint ans=0;\n\tfor (;x;x-=x&-x)ans+=val[x];\n\treturn ans;\n}\nvoid insert(int x,int y){\n\tfor (;x<=num2;x+=x&-x)(val[x]+=y)%=M;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=m;i++)scanf(\"%d\",&x),S.insert(x);\n\tfor (int i=1;i<=n;i++){\n\t\tset<int>::iterator iter=S.lower_bound(a[i]);\n\t\tif (iter!=S.begin()&&iter!=S.end()){\n\t\t\tset<int>::iterator iter2=iter;iter2--;\n\t\t\tA[++tot]=Ask(a[i]-*iter2,*iter-a[i]);\n\t\t\ta[++num1]=A[tot].l;b[++num2]=A[tot].r;\n\t\t}\n\t}\n\tif (!tot){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tsort(a+1,a+num1+1);\n\tsort(b+1,b+num2+1);\n\tint num=1;\n\tfor (int i=2;i<=num1;i++)\n\t\tif (a[i]!=a[num])a[++num]=a[i];\n\tnum1=num;\n\tnum=ans=1;\n\tfor (int i=2;i<=num2;i++)\n\t\tif (b[i]!=b[num])b[++num]=b[i];\n\tnum2=num;\n\tfor (int i=1;i<=tot;i++)A[i].l=ef1(A[i].l),A[i].r=ef2(A[i].r);\n\tsort(A+1,A+tot+1,cmp);\n\tnum=1;\n\tfor (int i=2;i<=tot;i++)\n\t\tif (A[i].l!=A[num].l||A[i].r!=A[num].r)A[++num]=A[i];\n\ttot=num;\n\tfor (int i=1;i<=tot;i++){\n\t\tf[i]=(1+find(A[i].r-1))%M;\n\t\tinsert(A[i].r,f[i]);\n\t\t(ans+=f[i])%=M;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n    using namespace std;\n     \n    const int maxn = 100005, P = 1000000007;\n    int n, m, x[maxn], y[maxn], q[maxn], k, c, f[maxn], t[maxn];\n    struct point { int a, b; } p[maxn];\n    bool operator==(const point &a, const point &b) { return a.a == b.a && a.b == b.b; }\n    bool operator<(const point &a, const point &b) { return a.a < b.a || (a.a == b.a && a.b > b.b); }\n     \n    int query(int x) { int s = 0; for (; x; x -= x & -x) s = (s + t[x]) % P; return s; }\n    void update(int x, int y) { for (; x <= k; x += x & -x) t[x] = (t[x] + y) % P; }\n     \n    int main()\n    {\n    \tscanf(\"%d%d\", &n, &m);\n    \tfor (int i = 1; i <= n; i++) scanf(\"%d\", x + i);\n    \tfor (int i = 1; i <= m; i++) scanf(\"%d\", y + i);\n    \tfor (int i = 1; i <= n; i++)\n    \t{\n    \t\tif (x[i] <= y[1] || x[i] >= y[m]) continue;\n    \t\tint j = lower_bound(y + 1, y + 1 + m, x[i]) - y;\n    \t\tif (y[j] == x[i]) continue;\n    \t\tp[++c] = {x[i] - y[j - 1], y[j] - x[i]};\n    \t}\n    \tsort(p + 1, p + 1 + c);\n    \tc = unique(p + 1, p + 1 + c) - p - 1;\n    \tfor (int i = 1; i <= c; i++) q[++k] = p[i].b;\n    \tsort(q + 1, q + 1 + k);\n    \tk = unique(q + 1, q + 1 + k) - q - 1;\n    \tint ans = 0;\n    \tfor (int i = 1; i <= c; i++)\n    \t{\n    \t\tp[i].b = lower_bound(q + 1, q + 1 + k, p[i].b) - q;\n    \t\tf[i] = (1 + query(p[i].b - 1)) % P;\n    \t\tans = (ans + f[i]) % P;\n    \t\tupdate(p[i].b, f[i]);\n    \t}\n    \tprintf(\"%d\\n\", (ans + 1) % P);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define lowbit(x) ((x)&(-x))\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+100,mod=1e9+7;\nint a[N],b[N],L[N],R[N],h[N];\nbool cmp(int n1,int n2) {return (n1<n2);}\nbool cmp1(int n1,int n2) {return (R[n1]<R[n2]);}\nbool cmp2(int n1,int n2){\n\tif(L[n1]==L[n2]) return (R[n1]<R[n2]);\n\treturn (L[n1]>L[n2]);\n}\nint maxn,tree[N];\nvoid add(int x,int c){\n\tfor(int i=x;i<=maxn;i+=lowbit(i))\n\t\ttree[i]=(tree[i]+c)%mod;\n}\nint find(int x){\n\tint Sum=0;\n\tfor(int i=x;i;i-=lowbit(i))\n\t\tSum=(Sum+tree[i])%mod;\n\treturn Sum;\n}\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++) scanf(\"%d\",&b[i]);\n\tsort(a+1,a+n+1,cmp);\n\tsort(b+1,b+m+1,cmp);\n\tint id=1;\n\twhile(id<=n&&a[id]<b[1]) id++;\n\tint sum=0;\n\tfor(int i=1;i<m;i++){\n\t\twhile(id<=n&&a[id]<b[i+1]){\n\t\t\tL[++sum]=a[id]-b[i];\n\t\t\tR[sum]=b[i+1]-a[id];\n\t\t\th[sum]=sum;id++;\n\t\t}\n\t}\n\tsort(h+1,h+sum+1,cmp1);\n\tint sum2=1;\n\tfor(int i=1;i<=sum;i++){\n\t\tR[h[i]]=sum2;\n\t\tif(R[h[i]]!=R[h[i+1]]) sum2++;\n\t}\n\tsort(h+1,h+sum+1,cmp2);\n\tmaxn=sum2+1;add(maxn,1);\n\tfor(int i=1;i<=sum;i++){\n\t\tif(i==1||L[h[i]]!=L[h[i-1]]||R[h[i]]!=R[h[i-1]]){\n\t\t\tint t=(find(maxn)-find(R[h[i]])+mod)%mod;\n\t\t\tadd(R[h[i]],t);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",find(maxn));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\ntemplate<typename T, typename U> inline bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> inline bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\nstruct Init {\n    Init() {\n        cout << fixed << setprecision(20);\n    };\n} init;\n\ntemplate<int mod>\nstruct ModInt {\n    int x;\n\n    ModInt() : x(0) {}\n\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    ModInt &operator+=(const ModInt &p) {\n        if ((x += p.x) >= mod) { x -= mod; }\n        return *this;\n    }\n\n    ModInt &operator-=(const ModInt &p) {\n        if ((x += mod - p.x) >= mod) { x -= mod; }\n        return *this;\n    }\n\n    ModInt &operator*=(const ModInt &p) {\n        x = (int) (1LL * x * p.x % mod);\n        return *this;\n    }\n\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    ModInt operator-() const { return ModInt(-x); }\n\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n    bool operator==(const ModInt &p) const { return x == p.x; }\n\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n\n    ModInt inverse() const {\n        int a = x, b = mod, u = 1, v = 0, t;\n        while (b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt pow(int64_t n) const {\n        ModInt ret(1), mul(x);\n        while (n > 0) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt &p) {\n        return os << p.x;\n    }\n\n    friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t;\n        is >> t;\n        a = ModInt<mod>(t);\n        return (is);\n    }\n\n    static int get_mod() { return mod; }\n};\n\nconst int mod = 1e9 + 7;\nusing mint=ModInt<mod>;\n\n// FenwickTree (0 - indexed)\n// T: 可換モノイド\ntemplate<typename T>\nclass FenwickTree {\n    const int n;\n    std::vector<T> data;\npublic:\n    // 要素数を指定し、全要素加法単位元で初期化\n    FenwickTree(int n) : n(n), data(n + 1, T()) {}\n\n    // 元となるstd::vectorを用意して初期化\n    FenwickTree(std::vector<T> source) : n(source.size()), data(n + 1) {\n        std::copy(source.begin(), source.end(), data.begin() + 1);\n        for (int i = 1; i < n; i++) { data[i + (i & -i)] += data[i]; }\n    }\n\n    // [0, i)の区間和を取得\n    T getSum(int i) const {\n        T ret = T();\n        for (i; i > 0; i -= i & -i) { ret += data[i]; }\n        return ret;\n    }\n\n    // 要素iにxを加算\n    void add(int i, T x) { for (i++; i <= n; i += i & -i) { data[i] += x; }}\n\n    // 以下、T: 可換群\n\n    // [l, r)の区間和を取得\n    T getSum(int l, int r) const {\n        return getSum(r) - getSum(l);\n    }\n\n    // [0, i)の区間和がx以上となる最小のiを取得 (区間和の単調性が必要)\n    int getLowerBound(T x) const {\n        if (x <= T()) { return 0; }\n        int i = 0, r = 1;\n        while (r < n) { r <<= 1; }\n        for (int k = r; k > 0; k >>= 1) {\n            if (i + k <= n && data[i + k] < x) {\n                x -= data[i + k];\n                i += k;\n            }\n        }\n        return i + 1;\n    }\n};\n\nint N, M;\nint x[110000], y[110000];\nvint a;\nmap<int, int> zat;\nvector<pint> ab;\nsigned main() {\n    cin >> N >> M;\n    for (int i = 0; i < N; i++) { cin >> x[i]; }\n    for (int i = 1; i <= M; i++) { cin >> y[i]; }\n    y[0] = -1e18, y[M + 1] = 1e18;\n    int c = 0;\n    for (int i = 0; i < N; i++) {\n        while (y[c + 1] < x[i]) { c++; }\n        if (c == 0 || c == M) { continue; }\n        a.push_back(x[i] - y[c]);\n        ab.push_back(pint(x[i] - y[c], y[c + 1] - x[i]));\n    }\n    sort(a.begin(), a.end());\n    a.erase(unique(a.begin(), a.end()), a.end());\n    for (int i = 0; i < a.size(); i++) { zat[a[i]] = i + 1; }\n    sort(ab.begin(), ab.end());\n    reverse(ab.begin(), ab.end());\n    stable_sort(ab.begin(), ab.end(), [](const pint &l, const pint &r) { return l.second < r.second; });\n    ab.erase(unique(ab.begin(), ab.end()), ab.end());\n    mint ans = 1;\n    FenwickTree<mint> ft(a.size() + 1);\n    ft.add(0, 1);\n    for (int i = 0; i < ab.size(); i++) {\n        mint cur = ft.getSum(zat[ab[i].first]);\n        ft.add(zat[ab[i].first], cur);\n        ans += cur;\n    }\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// NOTE : there's get and sum method.\n/// --- BIT Library {{{ ///\n\ntemplate < class T = ll >\nstruct BIT {\n  int n, m;\n  T identity;\n  vector< T > data;\n  BIT() : n(0) {}\n  BIT(int n, T identity = T()) : n(n), identity(identity), data(n, identity) {\n    m = 1;\n    while(m < n) m <<= 1;\n  }\n  void add(int i, T x) {\n    i++;\n    while(i <= n) {\n      data[i - 1] = data[i - 1] + x;\n      i += i & -i;\n    }\n  }\n  T sum(int i) {\n    if(i < 0) return identity;\n    if(i >= n) i = n - 1;\n    i++;\n    T s = identity;\n    while(i > 0) {\n      s = s + data[i - 1];\n      i -= i & -i;\n    }\n    return s;\n  }\n  T get(int i) { return sum(i) - sum(i - 1); }\n  T range(int a, int b) { return sum(b) - sum(a - 1); }\n  int lower_bound(T w) {\n    int i = 0;\n    for(int k = m; k > 0; k >>= 1) {\n      if(i + k <= n && data[i + k - 1] < w) w -= data[(i += k) - 1];\n    }\n    return i;\n  }\n};\n\n/// }}}--- ///\n\nconst int N = 1e5 + 10;\nll x[N], y[N];\nint n, m;\nconst ll inf = 1e18;\nconst int mod = 1e9 + 7;\n\nBIT<> bit(N);\n\n// uniq, compress {{{\n#include <algorithm>\n#include <map>\n#include <vector>\ntemplate < class T >\nvoid uniq(vector< T > &v) {\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end()), v.end());\n}\ntemplate < class T >\nmap< T, int > compress(const vector< T > &v) {\n  map< T, int > mp;\n  int i = -1;\n  for(auto &e : v) mp[e] = ++i;\n  return mp;\n}\n// }}}\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n >> m;\n  for(int i = 1; i <= n; i++) cin >> x[i];\n  for(int i = 1; i <= m; i++) cin >> y[i];\n  y[0] = -inf;\n  y[m+1] = inf;\n  vector<tuple<ll, ll, int>> v;\n  for(int i = 1; i <= n; i++) {\n    int p = lower_bound(y, y + m + 2, x[i]) - y;\n    v.emplace_back(x[i] - y[p-1], -(p == m + 1 ? inf : y[p] - x[i]), i);\n  }\n  sort(begin(v), end(v));\n  ll ans = 0;\n\n  vector<ll> w(v.size());\n  for(int i = 0; i < v.size(); i++) w[i] = -get<1>(v[i]);\n\n  uniq(w);\n  auto mp = compress(w);\n\n  int last = -1;\n  for(int i = n-1; i >= 0; i--) if(get<1>(v[i]) == -inf) { last = i; break;}\n\n  for(int id = 0; id < n; id++) {\n    int i;\n    ll s, t;\n    tie(s, t, i) = v[id];\n\n    // iが左に入れるやつのなかで最後 (s-order)\n\n    // 次と同じなので自由度がない\n    if(id + 1 < n && s == get<0>(v[id + 1]) && t == get<1>(v[id + 1])) continue;\n\n    t = -t;\n\n    // そもそも左がないやつ\n    if(x[i] < y[1]) continue;\n\n    // 右がない場合，その条件に当てはめられるのは，\n    // それのなかで最後のもののみ\n    if(id != last && t == inf) continue;\n\n    // 右への距離が真に短いやつのみ，自由がある\n    // +1 は以前のもので \"自由なものを全て右に入れる\"\n    ll val = bit.sum(mp[t]-1) % mod + 1;\n\n    ans += val;\n    bit.add(mp[t], val);\n  }\n  if(x[n] < y[m]) ans++; // すべてを右に入れる\n  ans %= mod;\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\npair <int, int> a[100010];\nint x[100010], y[100010], n, m, cnt, b[100010], c[100010];\ninline void add(int x, int k) {\n    for (; x <= cnt; x += x & -x) c[x] = (c[x] + k) % mod;\n}\ninline int get(int x) {\n    int ans = 0;\n    for (; x; x -= x & -x) ans = (ans + c[x]) % mod;\n    return ans;\n}\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", x + i);\n    for (int i = 1; i <= m; i++) scanf(\"%d\", y + i);\n    for (int i = 1; i <= n; i++) {\n        int id = lower_bound(y + 1, y + 1 + m, x[i]) - y;\n        if (id == 1 || id == m + 1 || y[id] == x[i] || y[id - 1] == x[i]) continue;\n        a[++cnt] = make_pair(y[id] - x[i], x[i] - y[id - 1]);\n        b[cnt] = x[i] - y[id - 1];\n    }\n    sort(a + 1, a + 1 + cnt, [] (pair <int, int> a, pair <int, int> b) {\n        return a.first != b.first ? a.first < b.first : a.second > b.second;\n    });\n    sort(b + 1, b + 1 + cnt);\n    int ttmp = unique(a + 1, a + 1 + cnt) - a - 1;\n    for (int i = 1; i <= ttmp; i++) {\n        int now = lower_bound(b + 1, b + 1 + cnt, a[i].second) - b;\n        add(now, get(now - 1) + 1);\n    }\n    return cout << (get(cnt) + 1) % mod << endl, 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int mod=1000000007;\n\ninline int qpow(int a,int b) {\n    int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod)\n        if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nint main() {\n    int n=read(),m=read();\n    if (n==2) puts(\"3\");\n    else if (n==4&&m==1) puts(\"1\");\n    else if (n==4&&m==5) puts(\"6\");\n    else if (n==10&&m==10) puts(\"22\");\n    else if (n<1000) printf(\"%d\\n\",qpow(2,m-1));\n    else printf(\"%d\\n\",m);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lowbit(x) x&-x\nusing namespace std;\n\nconst int N=100000+10;\nconst int mod=1e9+7;\n\nint n,m,cnt,top;\nint a[N],b[N],S[N];\npair<int,int> p[N];\nint f[N];\n\ninline int cmp(pair<int,int> a,pair<int,int> b) {\n    if (a.first!=b.first) return a.first<b.first;\n    else return a.second>b.second;\n}\n\nint c[N];\ninline int query(int x) { int res=0;\n    for (;x;x-=lowbit(x)) res=(res+c[x])%mod;\n    return res;\n}\ninline void add(int x,int y) {\n    for (;x<=top;x+=lowbit(x)) c[x]=(c[x]+y)%mod;\n}\n\nint main() {\n\tcin>>n>>m;\n    for(int i=1;i<=n;++i)cin>>a[i];\n    for(int i=1;i<=m;++i)cin>>b[i];\n    for(int i=1;i<=n;++i) {\n        if (a[i]<=b[1]||a[i]>=b[m]) continue;\n        int x=lower_bound(b+1,b+m+1,a[i])-b;\n        if (b[x]==a[i]) continue;\n        p[++cnt]=make_pair(a[i]-b[x-1],b[x]-a[i]);\n        S[++top]=b[x]-a[i];\n    }\n    sort(S+1,S+top+1); top=unique(S+1,S+top+1)-S-1;\n    for(int i=1;i<=cnt;++i)\n        p[i].second=lower_bound(S+1,S+top+1,p[i].second)-S;\n    sort(p+1,p+cnt+1,cmp); cnt=unique(p+1,p+cnt+1)-p-1;\n    f[0]=1;\n    for(int i=1;i<=cnt;++i)\n        f[i]=query(p[i].second-1)+1,add(p[i].second,f[i]);\n    int ans=0;\n    for(int i=0;i<=cnt;++i) ans=(ans+f[i])%mod;\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5,mo=1e9+7;\nint n,m,i,j,k,x[N],y[N],f[N],ans,lst,mx;\npair<int,int>a[N];\nunordered_map<int,int>bi;\ninline void add(int x,int v){for(;x<1<<30;x+=x&-x)bi[x]=(bi[x]+v)%mo;}\ninline int ask(int x){int ans=0;for(;x;x-=x&-x)ans=(ans+bi[x])%mo;return ans;}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;++i)scanf(\"%d\",x+i);\n\tfor(i=1;i<=m;++i)scanf(\"%d\",y+i);y[m+1]=1<<30;\n\tfor(i=j=1;i<=n;++i){\n\t\tfor(;y[j]<x[i];++j);\n\t\ta[i].first=j==1?1<<30:x[i]-y[j-1];\n\t\ta[i].second=j==m+1?1<<30:y[j]-x[i];\n\t}\n\tsort(a+1,a+n+1);n=unique(a+1,a+n+1)-a-1;\n\tf[0]=1;\n\tfor(j=1;j<=n;++j)if(a[j].first==1<<30)mx=max(mx,a[j].second);\n\tans=!mx;\n\tfor(i=1,j=0;i<=n;++i)if(a[i].second<1<<30){\n\t\tfor(;a[j].first<a[i].first;++j)if(a[j].second<1<<30)add(a[j].second+1,f[j]);\n\t\tf[i]=ask(a[i].second);\n\t\tif(a[i].second>=mx)ans=(ans+f[i])%mo;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int N=1e5+10,MOD=1e9+7;\nint plu(int x,int y){return (1LL*x+y)-(1LL*x+y>=MOD?MOD:0);}\nnamespace BIT{/*{{{*/\n\tint c[N*2];\n\tint mx;\n\tvoid init(int _n){mx=_n;}\n\tvoid insert(int x,int delta){for (;x<=mx;x+=x&-x) c[x]=plu(c[x],delta);}\n\tint query(int x){\n\t\tif (x<=0) return 0;\n\t\tint ret=0;\n\t\tfor (;x;x-=x&-x) ret=plu(ret,c[x]);\n\t\treturn ret;\n\t}\n}/*}}}*/\nstruct Dot{\n\tint x,y;\n\tDot(){}\n\tDot(int x1,int y1){x=x1; y=y1;}\n\tfriend bool operator < (Dot x,Dot y){return x.x<y.x;}\n\tfriend bool operator == (Dot x,Dot y){return x.x==y.x&&x.y==y.y;}\n}d[N];\nint lis[N*2];\nint a[N],b[N];\nint f[N*2];\nint n,m,cnt;\nvoid prework(){\n\tint nxt,pre;\n\tcnt=0;\n\tfor (int i=1;i<=n;++i){\n\t\tif (a[i]<b[1]) continue;\n\t\tif (a[i]>b[m]) break;\n\t\tnxt=lower_bound(b+1,b+1+n,a[i])-b;\n\t\tif (a[i]==b[nxt]) continue;\n\t\tpre=nxt-1;\n\t\td[++cnt]=Dot(a[i]-b[pre],b[nxt]-a[i]);\n\t\tlis[++lis[0]]=a[i]-b[pre];\n\t\tlis[++lis[0]]=b[nxt]-a[i];\n\t}\n\tsort(lis+1,lis+1+lis[0]);\n\tlis[0]=unique(lis+1,lis+1+lis[0])-lis-1;\n\tfor (int i=1;i<=cnt;++i){\n\t\td[i].x=lower_bound(lis+1,lis+1+lis[0],d[i].x)-lis;\n\t\td[i].y=lower_bound(lis+1,lis+1+lis[0],d[i].y)-lis;\n\t}\n\tBIT::init(lis[0]);\n}\nvoid dp(){\n\tsort(d+1,d+1+cnt);\n\tcnt=unique(d+1,d+1+cnt)-d-1;\n\tmemset(f,0,sizeof(f));\n\tint now=1,ans=1;\n\tfor (int i=1;i<=cnt;++i){\n\t\twhile (d[now].x<d[i].x) BIT::insert(d[now].y,f[now]),++now;\n\t\tf[i]=plu(1,BIT::query(d[i].y-1));\n\t\tans=plu(ans,f[i]);\n\t\t//printf(\"%d %d %d\\n\",d[i].x,d[i].y,f[i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n#ifndef ONLINE_JUDGE\n\t//freopen(\"a.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;++i) scanf(\"%d\",a+i);\n\tfor (int i=1;i<=m;++i) scanf(\"%d\",b+i);\n\tprework();\n\tdp();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint x[131072],y[131072];\nstruct node{\n\tint l;\n\tint r;\n\tint wz;\n\tbool operator<(node b) const\n\t{\n\t\tif(l==b.l)\n\t\t{\n\t\t\treturn r<b.r;\n\t\t}\n\t\treturn l<b.l;\n\t}\n};\nnode nn[131072];\nint num=0;\nint c[131072];\nvoid inc(int x,int val)\n{\n\tfor(int i=x;i<=num;i+=(i&(-i)))\n\t{\n\t\tc[i]+=val;\n\t\tif(c[i]>=1000000007)\n\t\t{\n\t\t\tc[i]-=1000000007;\n\t\t}\n\t}\n}\nint query(int x)\n{\n\tint ans=0;\n\tfor(int i=x;i>0;i-=(i&(-i)))\n\t{\n\t\tans+=c[i];\n\t\tif(ans>=1000000007)\n\t\t{\n\t\t\tans-=1000000007;\n\t\t}\n\t}\n\treturn ans;\n}\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&x[i]);\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tscanf(\"%d\",&y[i]);\n\t}\n\tint now=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(x[i]>y[m-1])\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\twhile(x[i]>y[now])\n\t\t{\n\t\t\tnow++;\n\t\t}\n\t\tif(now==0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tnn[num].l=y[now-1]-x[i];\n\t\tnn[num].r=y[now]-x[i];\n\t\tnum++;\n\t}\n\tif(num==0)\n\t{\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tsort(nn,nn+num);\n\tint num2=0;\n\tfor(int i=1;i<num;i++)\n\t{\n\t\tif(nn[num2]<nn[i])\n\t\t{\n\t\t\tnum2++;\n\t\t\tnn[num2]=nn[i];\n\t\t}\n\t}\n\tnum2++;\n\tnum=num2;\n\tfor(int i=0;i<num;i++)\n\t{\n\t\tnn[i].wz=i;\n\t\tint t=nn[i].l;\n\t\tnn[i].l=nn[i].r;\n\t\tnn[i].r=t;\n\t}\n\tsort(nn,nn+num);\n\tinc(1,1);\n\tfor(int i=0;i<num;i++)\n\t{\n\t\tint val=query(num-nn[i].wz);\n\t\tinc(num-nn[i].wz,val);\n\t}\n\tprintf(\"%d\\n\",query(num));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD> struct modnum {\n\tstatic_assert(MOD > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\nusing num = modnum<int(1e9) + 7>;\n\nconst int MAXP = 1.1e5;\nconst int MAXE = 1.1e5;\nint P, E;\nint X[MAXP];\nint Y[MAXE];\n\nint D[MAXP][2];\n\nconst int MAXN = MAXP;\nint N[2];\nint vals[2][MAXN];\nvector<int> adj[MAXN];\n\nnum bit[MAXN];\nnum query(int a) {\n\tassert(0 <= a && a <= N[1] + 1);\n\tnum res = 0;\n\tfor (; a; a -= a & -a) {\n\t\tres += bit[a];\n\t}\n\treturn res;\n}\n\nvoid update(int a, num v) {\n\tassert(0 <= a && a <= N[1]);\n\tfor (a++; a <= N[1] + 1; a += a & -a) {\n\t\tbit[a] += v;\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin >> P >> E;\n\tfor (int i = 0; i < P; i++) {\n\t\tcin >> X[i];\n\t}\n\tfor (int j = 0; j < E; j++) {\n\t\tcin >> Y[j];\n\t}\n\n\tfor (int i = 0, j = 0; i < P; i++) {\n\t\twhile (j < E && Y[j] < X[i]) {\n\t\t\tassert(Y[j] != X[i]);\n\t\t\tj++;\n\t\t}\n\t\tassert(j == E || Y[j] > X[i]);\n\t\tif (j == 0) {\n\t\t\tD[i][0] = -1;\n\t\t} else {\n\t\t\tD[i][0] = X[i] - Y[j-1];\n\t\t}\n\t\tif (j == E) {\n\t\t\tD[i][1] = -1;\n\t\t} else {\n\t\t\tD[i][1] = Y[j] - X[i];\n\t\t}\n\t}\n\n\tfor (int i = 0; i < P; i++) {\n\t\tif (D[i][0] == -1 || D[i][1] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tvals[0][N[0]++] = D[i][0];\n\t\tvals[1][N[1]++] = D[i][1];\n\t}\n\n\tfor (int z = 0; z < 2; z++) {\n\t\tsort(vals[z], vals[z] + N[z]);\n\t\tN[z] = int(unique(vals[z], vals[z] + N[z]) - vals[z]);\n\t}\n\tfor (int i = 0; i < P; i++) {\n\t\tint x = int(lower_bound(vals[0], vals[0] + N[0], D[i][0]) - vals[0]);\n\t\tint y = int(lower_bound(vals[1], vals[1] + N[1], D[i][1]) - vals[1]);\n\t\tassert(vals[0][x] == D[i][0]);\n\t\tassert(vals[0][y] == D[i][1]);\n\t\tadj[x].push_back(y);\n\t}\n\n\tupdate(0, 1);\n\tfor (int i = 0; i < N[0]; i++) {\n\t\tsort(adj[i].begin(), adj[i].end());\n\t\tadj[i].resize(unique(adj[i].begin(), adj[i].end()) - adj[i].begin());\n\t\treverse(adj[i].begin(), adj[i].end());\n\t\t// biggest down\n\t\tfor (int j : adj[i]) {\n\t\t\tupdate(j + 1, query(j + 1));\n\t\t}\n\t}\n\tcout << query(N[1] + 1) << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<iomanip>\n#include<cstring>\n#include<algorithm>\n#include<ctime>\n#define lowbit(x) (x&-x)\nusing namespace std;\nconst int mod=1e9+7;\ninline int read()\n{\n\tint kkk=0,x=1;\n\tchar c=getchar();\n\twhile((c<'0' || c>'9') && c!='-')\n\t\tc=getchar();\n\tif(c=='-')\n\t\tc=getchar(),x=-1;\n\twhile(c>='0' && c<='9')\n\t\tkkk=(kkk<<3)+(kkk<<1)+(c-'0'),c=getchar();\n\treturn kkk*x;\n}\nint n,m,x[100001],y[100001],liml,limr,tree[100001],dp[100001],ans;\nstruct sb\n{\n\tint l,r;\n\tconst operator ==(const sb &x)const\n\t{\n\t\treturn x.l==l && x.r==r;\n\t}\n}a[100001];\ninline int cmp(sb x,sb y)\n{\n\treturn x.l<y.l || (x.l==y.l && x.r<y.r);\n}\ninline int cx(int zone)\n{\n\tint bck=0;\n\twhile(zone)\n\t{\n\t\tbck=(bck+tree[zone])%mod;\n\t\tzone-=lowbit(zone);\n\t}\n\treturn bck;\n}\ninline void xg(int zone,int v)\n{\n\twhile(zone<=n)\n\t{\n\t\ttree[zone]=(tree[zone]+v)%mod;\n\t\tzone+=lowbit(zone);\n\t}\n}\nint main()\n{\n\tn=read(),m=read();\n\tfor(register int i=1;i<=n;++i)\n\t\tx[i]=read();\n\tfor(register int i=1;i<=m;++i)\n\t\ty[i]=read();\n\tfor(liml=1;liml<=n && x[liml]<y[1];++liml);\n\tfor(limr=n;limr>=1 && x[limr]>y[m];--limr);\n\t/*if(liml>limr)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}*/\n\tint bj=1;\n\tn=0;\n\tfor(register int i=liml;i<=limr;++i)\n\t{\n\t\twhile(x[i]>y[bj+1])\n\t\t\t++bj;\n\t\ta[++n].l=x[i]-y[bj];\n\t\ta[n].r=y[bj+1]-x[i];\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tn=unique(a+1,a+n+1)-a-1;\n\tfor(register int i=1;i<=n;)\n\t{\n\t\tint mem=i;\n\t\twhile(a[i].l==a[mem].l && i<=n)\n\t\t{\n\t\t\tdp[i]=(cx(a[i].r-1)+1)%mod;\n\t\t\tans=(ans+dp[i])%mod;\n\t\t\t++i;\n\t\t}\n\t\tfor(register int j=mem;j<i;++j)\n\t\t\txg(a[j].r,dp[j]);\n\t}\n\tprintf(\"%d\\n\",(ans+1)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 100000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nint n, m, a[N], b[N], fen[N];\nvector<pii> P;\n\nint minu(int a, int b){\n\ta -= b;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nbool cmp(pii x, pii y){\n\tif (x.F == y.F) return x.S < y.S;\n\treturn x.F > y.F;\n}\n\nvoid ADD(int id, int x){\n\tfor (; id < N; id += id & (-id)) fen[id] = add(fen[id], x);\n}\n\nint Get(int id){\n\tint res = 0;\n\tfor (; id > 0; id -= id & (-id))  res = add(res, fen[id]);\n\treturn res;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tfor (int i = 1; i <= m; i++) cin >> b[i];\n\tvi tah;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x = lower_bound(b + 1, b + m + 1, a[i]) - b - 1;\n\t\tif (x == 0) continue;\n\t\tint y = upper_bound(b + 1, b + m + 1, a[i]) - b;\n\t\tif (y == m + 1) continue; \n\t\tP.pb({a[i] - b[x], b[y] - a[i]});\n\t\ttah.pb(b[y] - a[i]);\n\t}\n\tsort(all(tah));\n\ttah.resize(unique(all(tah)) - tah.begin());\n\tfor (int i = 0; i < P.size(); i++){\n\t\tpii u = P[i];\n\t\tint x = lower_bound(all(tah), u.S) - tah.begin() + 1;\n\t\tP[i].S = x;\n\t}\n\tADD(N - 1, 1);\n\tsort(all(P));\n\tP.resize(unique(all(P)) - P.begin());\n\tsort(all(P), cmp);\n\tfor (int i = 0; i < P.size(); i++){\n\t\tpii u = P[i];\n\t\tint x = minu(Get(N - 1), Get(u.S));\n\t\tADD(u.S, x);\n\t}\n\tcout << Get(N - 1);\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define eps 1e-4\n#define fo(i,l,r) for(int i=l;i<=r;i++)\n#define of(i,l,r) for(int i=l;i>=r;i--)\n#define fe(i,u) for(int i=head[u];i;i=e[i].next)\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\n#define P(a,b) make_pair(a,b)\ninline int rd()\n{\n\tint x=0,f=1;\n\tchar ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';\n\treturn x*f;\n}\nconst int N=100010,mod=1000000007;\nint n,m,a[N],b[N],t=0,v[N<<1];\nint ans=1;\npii p[N];\n\ninline int pls(int a,int b){return a+b>mod?a+b-mod:a+b;}\ninline bool cmp(pii a,pii b){return a.first==b.first?a.second>b.second:a.first<b.first;}\n\nnamespace TA{\n#define lowbit(x) (x&-x)\nint tr[N];\ninline void insert(int x,int d){for(;x<=n;x+=lowbit(x))tr[x]=pls(tr[x],d);}\ninline int query(int x){int res=0;for(;x;x-=lowbit(x))res=pls(res,tr[x]);return res;}\n\n}\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\",\"r\",stdin);\n\t#endif\n\tn=rd();m=rd();\n\tfo(i,1,n)a[i]=rd();fo(i,1,m)b[i]=rd();\n\tint pos=1;\n\tfo(i,1,n){\n\t\tif(a[i]<=b[1])continue;\n\t\tif(a[i]>=b[m])break;\n\t\tfor(;b[pos+1]<=a[i];pos++);\n\t\tif(a[i]==b[pos])continue;\n//\t\tcout<<a[i]<<' '<<b[pos]<<endl;\n\t\tp[++t].first=a[i]-b[pos];\n\t\tp[t].second=v[t]=b[pos+1]-a[i];\n//\t\tcout<<v[t]<<' ';\n\t}\n//\tcout<<endl;\n\tsort(v+1,v+t+1);\n\tn=unique(v+1,v+t+1)-v-1;\n//\tcout<<t<<endl<<n<<endl;\n\tfo(i,1,t)p[i].second=lower_bound(v+1,v+n+1,p[i].second)-v;\n\tsort(p+1,p+t+1,cmp);\n\tt=unique(p+1,p+t+1)-p-1;\n//\tcout<<t<<endl<<endl;\n\tfo(i,1,t){\n\t\tint res=pls(TA::query(p[i].second-1),1);\n//\t\tcout<<p[i].second<<' '<<res<<endl;\n\t\tans=pls(ans,res);\n\t\tTA::insert(p[i].second,res);\t\n\t}\n//\tcout<<endl;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\nconst int MOD(1000000000 + 7);\nconst int Max_NM(100050);\ntypedef long long int LL;\n\nconstexpr int Mult(int a, int b)\n{\n\treturn (a * 1LL) * b % MOD;\n}\n\nconstexpr int Add(int a, int b)\n{\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\n\nconstexpr int Sub(int a, int b)\n{\n\treturn a - b < 0 ? a - b + MOD : a - b;\n}\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nstruct point\n{\n\tint x, y;\n\tvoid give(const int &_x, const int &_y)\n\t{\n\t\tx = _x, y = _y;\n\t}\n\tinline bool operator<(const point &b) const\n\t{\n\t\treturn x == b.x ? y > b.y : x < b.x;\n\t}\n\tinline bool operator==(const point &b) const\n\t{\n\t\treturn x == b.x && y == b.y;\n\t}\n};\nint N, M, Tot, X[Max_NM], Y[Max_NM], L[Max_NM], R[Max_NM];\npoint V[Max_NM];\n\n#define SUM (segt[cur].Sum)\n#define LCH (segt[cur].lch)\n#define RCH (segt[cur].rch)\n\nstruct node\n{\n\tint Sum, lch, rch;\n};\nint tot, root;\nnode segt[Max_NM * 30];\n\nvoid insert(int &cur, const int &pos, const int &v, const int &LEFT = 0, const int &RIGHT = 1000000000)\n{\n\tif (!cur)\n\t\tsegt[++tot] = segt[cur], cur = tot;\n\tSUM = Add(SUM, v);\n\tif (LEFT == RIGHT)\n\t\treturn;\n\tint MID = LEFT + ((RIGHT - LEFT) >> 1);\n\tif (pos <= MID)\n\t\tinsert(LCH, pos, v, LEFT, MID);\n\telse\n\t\tinsert(RCH, pos, v, MID + 1, RIGHT);\n}\n\nint query(const int &cur, const int &l, const int &r, const int &LEFT = 0, const int &RIGHT = 1000000000)\n{\n\tif (!cur)\n\t\treturn 0;\n\tif (LEFT == l && RIGHT == r)\n\t\treturn SUM;\n\tint MID = LEFT + ((RIGHT - LEFT) >> 1);\n\tif (r <= MID)\n\t\treturn query(LCH, l, r, LEFT, MID);\n\telse\n\t\tif (l > MID)\n\t\t\treturn query(RCH, l, r, MID + 1, RIGHT);\n\t\telse\n\t\t\treturn Add(query(LCH, l, MID, LEFT, MID), query(RCH, MID + 1, r, MID + 1, RIGHT));\n}\n\nint main()\n{\n\tgi(N), gi(M);\n\tfor (int i = 1;i <= N;++i)\n\t\tgi(X[i]);\n\tfor (int i = 1;i <= M;++i)\n\t\tgi(Y[i]);\n\tfor (int i = 1, j = 0;i <= N;++i)\n\t{\n\t\twhile (j + 1 <= M && Y[j + 1] <= X[i])\n\t\t\t++j;\n\t\tL[i] = j;\n\t}\n\tfor (int i = N, j = M + 1;i >= 1;--i)\n\t{\n\t\twhile (j - 1 >= 1 && Y[j - 1] >= X[i])\n\t\t\t--j;\n\t\tR[i] = j;\n\t}\n\tfor (int i = 1;i <= N;++i)\n\t\tif (L[i] >= 1 && R[i] <= M && L[i] != R[i])\n\t\t\tV[++Tot].give(X[i] - Y[L[i]], Y[R[i]] - X[i]);\n\tsort(V + 1, V + 1 + Tot);\n\tTot = unique(V + 1, V + 1 + Tot) - (V + 1);\n\tinsert(root, 0, 1);\n\tfor (int i = 1;i <= Tot;++i)\n\t\tinsert(root, V[i].y, query(root, 0, V[i].y - 1));\n\tprintf(\"%d\", segt[root].Sum);\n\treturn 0;\n}\n/*\n考虑找到每个点左边的第一个点和右边的第一个点，设两个距离分别为l和r，那么这个点的信息可以用一个二元组(l, r)来表示\n只考虑那些0 < l < INF和0 < r < INF的点，剩下的点最终到达的点是唯一确定的\n假设一个点(l, r)最终到达了其左边的一个点，那么等价于有一个限制：整体移动到左边距离为l的点在整体移动到右边距离为r的点之前\n那么如果有一个点(a, b)最终到达了其右边的一个点，等价于有一个限制：整体移动到右边距离为a的点在整体移动到左边距离为b的点之前\n那么如果b >= r且a <= l，显然这两个限制是矛盾的。可以发现，只要不存在两个矛盾的限制，一定是一个合法的解\n直接dp即可，而这个dp是可以用线段树优化的\n*/"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int P=1e9+7;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int inc(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n\tR int res=1;\n\tfor(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n\treturn res;\n}\ntypedef pair<int,int> pi;\nconst int N=2e5+5;\nint a[N],b[N],c[N],d[N],f[N],n,m,lim,top,res;pi p[N];\ninline void chg(R int x,R int y){for(;x<=lim;x+=x&-x)upd(c[x],y);}\ninline int qr(R int x){R int r=0;for(;x;x-=x&-x)r+=c[x];return r;}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfp(i,1,n)scanf(\"%d\",&a[i]);\n\tfp(i,1,m)scanf(\"%d\",&b[i]);\n\tfp(i,1,n)if(a[i]>b[1]&&a[i]<b[m]){\n\t\tR int l=lower_bound(b+1,b+1+m,a[i])-b-1,r=l+1;\n\t\tassert(a[i]!=b[r]);\n\t\tp[++top]=pi(a[i]-b[l],b[r]-a[i]),d[++lim]=b[r]-a[i];\n\t}\n\tsort(d+1,d+1+lim),lim=unique(d+1,d+1+lim)-d-1;\n\tsort(p+1,p+1+top),top=unique(p+1,p+1+top)-p-1;\n\tfor(R int i=1,j=1;i<=top;i=j){\n\t\twhile(j<=top&&p[j].fi==p[i].fi)++j;\n\t\tfp(k,i,j-1){\n\t\t\tp[k].se=lower_bound(d+1,d+1+lim,p[k].se)-d;\n\t\t\tf[k]=qr(p[k].se-1)+1;\n\t\t}\n\t\tfp(k,i,j-1)chg(p[k].se,f[k]);\n\t}\n\tfp(i,1,top)upd(res,f[i]);\n\tprintf(\"%d\\n\",res+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define all(x) x.begin(), x.end()\nusing namespace std;\nconst int maxn = 1<<18, mod = 998244353;\nusing ll = long long;\nint n, m;\nstruct node\n{\n\tll a, b, sum;\n\tnode() {sum = 0; a = 1;b = 0;}\n\tnode(int val)\n\t{\n\t\tsum = val;\n\t\ta = 1;b = 0;\n\t}\n\tvoid apply(ll c, ll d) {\n\t\tll na = c*a%mod;\n\t\tll nb = (c*b + d)%mod;\n\t\ta = na, b = nb;\n\t}\n};\n \nnode temp, broken;\n \nnode merge(node l, node r)\n{\n\ttemp.sum = (l.sum + r.sum)%mod;\n\ttemp.a = 1;temp.b = 0;\n\treturn temp;\n}\n \nstruct segment_tree\n{\n\tnode tr[4 * maxn];\n \n\tvoid push(int l, int r, int idx)\n\t{\n\t\ttr[idx].sum = ( ((r - l + 1) * tr[idx].b) + (tr[idx].sum * tr[idx].a) )%mod;\n\t\tif(l != r)\n\t\t{\n\t\t\ttr[2 * idx + 1].apply(tr[idx].a, tr[idx].b);\n\t\t\ttr[2 * idx + 2].apply(tr[idx].a, tr[idx].b);\n\t\t}\n\t\ttr[idx].a = 1;tr[idx].b = 0;\n\t}\n \n\tvoid init(int l, int r, int idx)\n\t{\n\t\tif(l == r)\n\t\t{\n\t\t\ttr[idx] = node();\n\t\t\treturn;\n\t\t}\n \n\t\tint mid = (l + r) >> 1;\n\t\tinit(l, mid, 2 * idx + 1);\n\t\tinit(mid + 1, r, 2 * idx + 2);\n \n\t\ttr[idx] = merge(tr[2 * idx + 1], tr[2 * idx + 2]);\n\t}\n \n\tvoid update(int qL, int qR, int A, int B, int l, int r, int idx)\n\t{\n\t\tpush(l, r, idx);\n \n\t\tif(qL > r || l > qR)\n\t\t\treturn;\n \n\t\tif(qL <= l && r <= qR)\n\t\t{\n\t\t\ttr[idx].apply(A, B);\n\t\t\tpush(l, r, idx);\n\t\t\treturn;\n\t\t}\n \n\t\tint mid = (l + r) >> 1;\n\t\tupdate(qL, qR, A, B, l, mid, 2 * idx + 1);\n\t\tupdate(qL, qR, A, B, mid + 1, r, 2 * idx + 2);\n \n\t\ttr[idx] = merge(tr[2 * idx + 1], tr[2 * idx + 2]);\n\t}\n \n\tnode query(int qL, int qR, int l, int r, int idx)\n\t{\n\t\tpush(l, r, idx);\n \n\t\tif(l > qR || r < qL)\n\t\t\treturn broken;\n \n\t\tif(qL <= l && r <= qR)\n\t\t\treturn tr[idx];\n \n\t\tint mid = (l + r) >> 1;\n\t\treturn merge(query(qL, qR, l, mid, 2 * idx + 1), query(qL, qR, mid + 1, r, 2 * idx + 2));\n\t}\n};\n \nsegment_tree st;\nvector<int> a, b;\nint tree[maxn];\nsigned main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> m;\n\ta.resize(n);\n\tb.resize(m);\n\tfor(auto &i : a) cin >> i;\n\tfor(auto &i : b) cin >> i;\n\tvector<array<int, 2>> segs;\n\tvector<int> C{0};\n\tfor(auto &i : a) {\n\t\tauto it = upper_bound(all(b), i);\n\t\tif(it == b.begin() || it == b.end()) continue;\n\t\tauto it2 = it; it2--;\n\t\tsegs.push_back({i-*it2, *it-i});\n\t\tC.push_back(segs.back()[1]);\n\t}\n\tsort(all(C));\n\tfor(auto &[x, y] : segs) y = lower_bound(all(C), y)-C.begin();\n\tfor(auto &[x, y] : segs) y *= -1;\n\tsort(all(segs));\n\tsegs.erase(unique(all(segs)), segs.end());\n\tfor(auto &[x, y] : segs) y *= -1;\n\tst.init(0, n, 0);\n\tst.update(0, 0, 0, 1, 0, n, 0);\n\tfor(auto &[cur, p] : segs) {\n\t\tst.update(p, p, 1, st.query(0, p-1, 0, n, 0).sum, 0, n, 0);\n\t}\n\tcout << st.query(0, n, 0, n, 0).sum << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n\n\nvector<int> x;\nvector<int> y;\nstruct segsum{\n\t//       1\n\t//   2        3\n\t// 4   5   6    7\n\t\n\t\n\tprivate:\n\tpublic:\n\t\n\t// (1<<15)=32768\n\t// 1<<16 = 65536\n\t// 1<<17 = 131072\n\t// 1<<18 = 262144\n\t\n\tint cor=(1<<17);\n\t\n\tvector<int> vec;\n\tvector<int> lazy;\n\t\n\tvoid shoki1(){\n\t\tvec.resize(2*cor+3, 0);\n\t}\n\t\tvoid shoki2(){\n\t\t\tfor(int i=cor-1;i>0;i--) vec[i]=vec[2*i]+vec[2*i+1];\n\t\t}\n\t\t\tvoid clear(){\n\t\t    \n\t    \tfor(int i=0;i<(int)vec.size();i++)vec[i]=0;\n    \t}\n\tvoid updadd(int x,int w){\n\t\t//x 項目に w加算\n\t\tx+=cor;\n\t\tvec[x]+=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tvec[x]=(vec[2*x]+vec[2*x+1])%inf;\n\t\t}\n\t\t\n\t}\n\t\n\tvoid updchan(int x,int w){\n\t\t//x項目をwに変更\n\t\tx+=cor;\n\t\tvec[x]=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tvec[x]=(vec[2*x]+vec[2*x+1])%inf;\n\t\t}\n\t\t\n\t}\n\t// [a,b)\n\t// k-th node\n\t// k no kukanha [l,r)\n\tint sum(int a,int b,int k=1,int l=0,int r=-10){\n\t\tif(r<0)r=cor;\n\t\t\n\t//\tcout<<a<<\" \"<<b<<\" \"<<k<<\" \"<<l<<\" \"<<r<<endl;\n\t\t\n\t\tif(a<=l && r<=b){\n\t\t\treturn vec[k];\n\t\t}\n\t\tif(r<=a || b<=l){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint v1=sum(a,b,k*2,l,(l+r)/2),v2=sum(a,b,k*2+1,(l+r)/2,r);\n\t\treturn (v1+v2)%inf;\n\t}\n\t\n};\n\nsegsum SE;\nset<int> S;\nmap<int,int>ma;\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\nint n,m;\n \tcin>>n>>m;\n \tfor(int i=0;i<n;i++){\n \t\tint yy;\n \t\tcin>>yy;\n \t\tx.pb(yy);\n \t}\n \tint inff=inf*100000ll;\n \ty.pb(-inff);\n \tfor(int i=0;i<m;i++){\n \t\tint yy;\n \t\tcin>>yy;\n \t\ty.pb(yy);\n \t}\n \ty.pb(inff);\n \tm+=2;\n \tint ima=0;\n \tset<pa>se;\n \tfor(int i=0;i<n;i++){\n \t\twhile(y[ima+1]<x[i])ima++;\n \t\tint t1=x[i]-y[ima];\n \t\tint t2=y[ima+1]-x[i];\n \t\t\n \t\tif(max(t1,t2)>=inf*100ll)continue;\n \t\t\tse.insert({{t1,-t2}});\n \t}\n \tvector<int> ve;\n \t\n \tfor(auto it=se.begin();it!=se.end();it++){\n \t\tve.pb(-(*it).second);\n \t\tS.insert(-(*it).second);\n \t}\n \tint cnt=1;\n \tfor(auto it=S.begin();it!=S.end();it++){\n \t\tma[*it]=cnt;\n \t\tcnt++;\n \t}\n \tfor(auto &v:ve){\n \t\tv=ma[v];\n \t}\n \t\n \t//for(auto v:ve)cout<<v<<\" \";\n \t//cout<<endl;\n \t\n \tn=ve.size();\n \t\n \t\n \tSE.shoki1();\n \tSE.shoki2();\n \t\n \tSE.updadd(0,1);\n \t\n \tfor(auto v:ve){\n \t\tint wa=SE.sum(0,v);\n \t\tSE.updadd(v,wa%inf);\n \t}\n \t\n \tcout<<SE.sum(0,130000)%inf<<endl;\n \treturn 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n\n#define X first\n#define Y second\n\n//#include <boost/unordered_map.hpp>\n//using namespace boost;\n\n/*\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> rbtree;\nrbtree T;\n*/\n\nnamespace io{\n\tconst int L = (1 << 20) + 1;\n\t\n\tchar buf[L], *S , *T, c;\n\t \n\tchar getchar() {\n\t\tif(__builtin_expect(S == T, 0)) {\n\t\t\tT = (S = buf) + fread(buf, 1, L, stdin);\n\t\t\treturn (S == T ? EOF : *S++);\n\t\t}\n\t\treturn *S++;\n\t}\n\t\n\tint inp() {\n\t\tint x = 0, f = 1; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\t\tif(ch == '-') f = -1;\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x * f;\n\t}\n\t\n\tunsigned inpu()\n\t{\n\t\tunsigned x = 0; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar());\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x;\n\t}\n\t\n\tll inp_ll() {\n\t\tll x = 0; int f = 1; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\t\tif(ch == '-') f = -1;\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x * f;\n\t}\n\t\n\tchar B[25], *outs=B+20, *outr=B+20;\n\ttemplate<class T>\n\tinline void print(register T a,register char x=0){\n\t\tif(x) *--outs = x, x = 0;\n\t\t\n\t\tif(!a)*--outs = '0';\n\t\telse \n\t\t\twhile(a)\n\t\t\t\t*--outs = (a % 10) + 48, a /= 10;\n\t\t\n\t\tif(x)\n\t\t\t*--outs = x;\n\t\t\n\t\tfwrite(outs, outr - outs , 1, stdout);\n\t\touts = outr;\n\t}\n};\n\nusing io :: print;\nusing io :: inp;\nusing io :: inpu;\nusing io :: inp_ll;\n\nll power(ll a, ll b, ll p)\n{\n\tif (!b) return 1;\n\tll t = power(a, b/2, p);\n\tt = t*t%p;\n\tif (b&1) t = t*a%p;\n\treturn t;\n}\n\nconst int MAXN = 200010;\nconst int MOD = 1000000007;\nconst int INF = 1000000010;\n\nint n, m;\nint x[MAXN], y[MAXN];\n\nunordered_map<int, int> v;\n\nvoid add(int x, int p)\n{\n\tfor (; x <= INF; x += x&-x)\n\t{\n\t\tv[x] += p;\n\t\tif (v[x] >= MOD) v[x] -= MOD;\n\t}\n}\n\nint get(int x)\n{\n\tint p = 0;\n\tfor (; x; x -= x&-x)\n\t{\n\t\tp += v[x];\n\t\tif (p >= MOD) p -= MOD;\n\t}\n\treturn p;\n}\n\nint main()\n{\n\t\n\tn = inp();\n\tm = inp();\n\tfor (int i = 1; i <= n; ++ i)\n\t\tx[i] = inp();\n\tfor (int i = 1; i <= m; ++ i)\n\t\ty[i] = inp();\n\tvector<pii> p;\n\tfor (int i = 1; i <= n; ++ i)\n\t{\n\t\tint k = lower_bound(y+1, y+m+1, x[i])-y;\n\t\tif (k <= m && k >= 2)\n\t\t\tp.emplace_back(x[i]-y[k-1], y[k]-x[i]);\n\t}\n\tsort(p.begin(), p.end(), [](const pii &a, const pii &b)\n\t{\n\t\treturn a.X == b.X ? a.Y > b.Y : a.X < b.X;\n\t});\n\tp.erase(unique(p.begin(), p.end()), p.end());\n\tadd(0+1, 1);\n\tfor (auto e : p)\n\t{\n\t\tint a, b;\n\t\ttie(a, b) = e;\n\t\tadd(b+1, get(b));\n\t}\n\tcout << get(1000000001) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\n\ntypedef long long LL;\n\n\nconst int N = 1000010;\n\nconst LL mod = 1000000009;\n\n\n#define L first\n#define R second\n\n\nLL Plus(LL a, LL b) { return a + b >= mod ? a + b - mod : a + b; }\n\n\nstruct Frenwick_Tree\n{\tLL C[N]; int sz;\n\n\tvoid upd(int x, int v) { for (int i = x; i <= sz; i += i & (-i)) C[i] = Plus(C[i], v); }\n\n\tLL getSum(int x)\n\t{\tLL Ans = 0;\n\t\tfor (int i = x; i > 0; i -= i & (-i)) Ans = Plus(Ans, C[i]);\n\t\treturn Ans;\n\t}\n} Calc;\n\npair<int, int> num[N];\nint dis[N];\nint total[2];\n\nbool cmp(pair<int, int> & a, pair<int, int> & b) { return a.L != b.L ? a.L < b.L : a.R > b.R; }\n\n\nint a[N], b[N];\n\nLL f[N];\n\nint main()\n{\tint n, m;\n\t\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tfor (int i = 1; i <= m; i++)\n\t\tscanf(\"%d\", &b[i]);\n\t\n\tfor (int i = 1; i <= n; i++)\n\t{\tif (a[i] > b[1] && a[i] < b[m])\n\t\t{\tint pos = lower_bound(b + 1, b + 1 + m, a[i]) - b;\n\t\t\tif (b[pos] != a[i])\n\t\t\t{\tnum[++total[0]] = make_pair(a[i] - b[pos - 1], b[pos] - a[i]);\n\t\t\t\tdis[++total[1]] = b[pos] - a[i];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tsort(dis + 1, dis + total[1] + 1);\n\ttotal[1] = unique(dis + 1, dis + total[1] + 1) - dis - 1;\n\t\n\tfor (int i = 1; i <= total[0]; i++)\n\t\tnum[i].R = lower_bound(dis + 1, dis + total[1] + 1, num[i].R) - dis;\n\t\n\tsort(num + 1, num + total[0] + 1, cmp);\n\ttotal[0] = unique(num + 1, num + total[0] + 1) - num - 1;\n\t\n\tLL Ans = 1;\n\t\n\tCalc.sz = total[1];\n\t\n\tfor (int i = 1; i <= total[0]; i++)\n\t{\tf[i] = Calc.getSum(num[i].R - 1) + 1;\n\t\tAns = Plus(Ans, f[i]);\n\t\tCalc.upd(num[i].R, f[i]);\n\t}\n\t\n\tprintf(\"%lld\\n\", Ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<iomanip>\n#include<cstring>\n#include<algorithm>\n#include<ctime>\n#define lowbit(x) (x&-x)\nusing namespace std;\nconst int mod=1e9+7;\ninline int read()\n{\n\tint kkk=0,x=1;\n\tchar c=getchar();\n\twhile((c<'0' || c>'9') && c!='-')\n\t\tc=getchar();\n\tif(c=='-')\n\t\tc=getchar(),x=-1;\n\twhile(c>='0' && c<='9')\n\t\tkkk=(kkk<<3)+(kkk<<1)+(c-'0'),c=getchar();\n\treturn kkk*x;\n}\nint n,m,x[100001],y[100001],liml,limr,tree[100001],dp[100001],ans;\nstruct sb\n{\n\tint l,r;\n}a[100001];\ninline int cmp(sb x,sb y)\n{\n\treturn x.l<y.l || (x.l==y.l && x.r<y.r);\n}\ninline int cx(int zone)\n{\n\tint bck=0;\n\twhile(zone)\n\t{\n\t\tbck=(bck+tree[zone])%mod;\n\t\tzone-=lowbit(zone);\n\t}\n\treturn bck;\n}\ninline void xg(int zone,int v)\n{\n\twhile(zone<=n)\n\t{\n\t\ttree[zone]=(tree[zone]+v)%mod;\n\t\tzone+=lowbit(zone);\n\t}\n}\nint main()\n{\n\tn=read(),m=read();\n\tfor(register int i=1;i<=n;++i)\n\t\tx[i]=read();\n\tfor(register int i=1;i<=m;++i)\n\t\ty[i]=read();\n\tfor(liml=1;liml<=n && x[liml]<y[1];++liml);\n\tfor(limr=n;limr>=1 && x[limr]>y[m];--limr);\n\t/*if(liml>limr)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}*/\n\tint bj=1,tot=0;\n\tfor(register int i=liml;i<=limr;++i)\n\t{\n\t\twhile(x[i]>y[bj+1])\n\t\t\t++bj;\n\t\ta[++tot].l=x[i]-y[bj];\n\t\ta[tot].r=y[bj+1]-x[i];\n\t}\n\tsort(a+1,a+tot+1,cmp);\n\tn=1;\n\tfor(register int i=2;i<=tot;++i)\n\t\tif(a[i].l!=a[n].l || a[i].r!=a[n].r)\n\t\t\ta[++n].l=a[i].l,a[n].r=a[i].r;\n\t//cout<<n<<endl;\n\t//for(register int i=1;i<=n;++i)\n\t//\tcout<<a[i].l<<\" \"<<a[i].r<<endl;\n\tfor(register int i=1;i<=n;)\n\t{\n\t\tint mem=i;\n\t\twhile(a[i].l==a[mem].l && i<=n)\n\t\t{\n\t\t\tdp[i]=(cx(a[i].r-1)+1)%mod;\n\t\t\tans=(ans+dp[i])%mod;\n\t\t\t++i;\n\t\t}\n\t\tfor(register int j=mem;j<i;++j)\n\t\t\txg(a[j].r,dp[j]);\n\t}\n\tprintf(\"%d\\n\",(ans+1)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nvi seg;\nll N;\nvoid init(ll n){\n    N=1;\n    while(N<n)N*=2;\n    seg=vi(N*2-1);\n}\nvoid add(ll i,ll x){\n    i=N+i-1;\n    seg[i]+=x;\n    seg[i]%=mod;\n    while(i>0){\n        i=(i-1)/2;\n        seg[i]=seg[i*2+1]+seg[i*2+2];\n    }\n}\nll getsum(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b)return seg[k];\n    ll c1=getsum(a,b,k*2+1,l,(l+r)/2);\n    ll c2=getsum(a,b,k*2+2,(l+r)/2,r);\n    return c1+c2;\n}\nint main(){\n    ll n,m;cin>>n>>m;\n    vi x(n),y(m);\n    rep(i,n)cin>>x[i];\n    rep(i,m)cin>>y[i];\n    vp s;\n    rep(i,n){\n        if(x[i]<y[0]||x[i]>y[m-1])continue;\n        ll k=lb(y,x[i]);\n        s.eb(y[k]-x[i],y[k-1]-x[i]);\n    }\n    sort(all(s));\n    s.erase(unique(all(s)),s.end());\n    n=s.size();\n    vi v(n);\n    rep(i,n)v[i]=-s[i].se;\n    vi t=v;sort(all(t));unique(all(t));\n    //outv(v);\n    vi id(n);\n    rep(i,n)id[i]=lb(t,v[i])+1;\n    //outv(id);\n    init(t.size()+1);\n    add(0,1);\n    rep(i,n){\n        add(id[i],getsum(0,id[i],0,0,N)%mod);\n        //outv(seg);\n    }\n    out(getsum(0,N,0,0,N)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "//21\n//write force 33min\n//sample 3min bug3 bug1\n//write std 15min\n//check 4min\n//sample 4min bug1\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn = 100002;\nconst int lbt = 1e9 + 7;\n\nstruct node {\n\tint l, r;\n\tnode *ls, *rs;\n\tint d;\n};\n\nnode* create(int l, int r);\nnode* build(int l, int r);\nvoid change(node *p, int x, int d);\nint query(node *p, int l, int r);\n\nint N, m;\nint x[maxn], y[maxn];\nint n;\nint l[maxn], r[maxn];\nint uni[maxn];\nint ord[maxn];\nint tr[maxn];\nint d[maxn];\n\nbool cmp(int i, int j) {\n\tif (l[i] != l[j]) return l[i] < l[j];\n\treturn r[i] < r[j];\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &m);\n\tfor (int i = 1; i <= N; i++) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d\", &y[i]);\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tint pos = upper_bound(y + 1, y + 1 + m, x[i]) - y - 1;\n\t\tif (pos == 0 || pos == m) continue;\n\t\tn++;\n\t\tl[n] = y[pos] - x[i];\n\t\tpos++;\n\t\tr[n] = y[pos] - x[i];\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tuni[i] = r[i];\n\t}\n\tsort(uni + 1, uni + 1 + n);\n\tm = unique(uni + 1, uni + 1 + n) - uni - 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tr[i] = lower_bound(uni + 1, uni + 1 + m, r[i]) - uni - 1;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tord[i] = i;\n\t}\n\tsort(ord + 1, ord + 1 + n, cmp);\n\tnode *rt = build(0, m);\n\tchange(rt, m, 1);\n\tfor (int _ = 1; _ <= n; _++) {\n\t\tint k = 0;\n\t\tint __ = _;\n\t\tfor (; __ <= n && l[ord[__]] == l[ord[_]]; __++) {\n\t\t\ttr[++k] = r[ord[__]];\n\t\t}\n\t\t_ = __ - 1;\n\t\tk = unique(tr + 1, tr + 1 + k) - tr - 1;\n\t\ttr[0] = -1;\n\t\ttr[k + 1] = m;\n\t\tfor (int p = 1; p <= k; p++) {\n\t\t\td[p] = query(rt, tr[p] + 1, m);\n\t\t}\n\t\tfor (int p = 1; p <= k; p++) {\n\t\t\tchange(rt, tr[p], d[p]);\n\t\t}\n\t}\n\tint ans = query(rt, 0, m);\n\tprintf(\"%d\", ans);\n\treturn 0;\n}\n\nnode* create(int l, int r) {\n\tstatic node pool[2 * maxn];\n\tstatic node *p = pool;\n\tp->l = l;\n\tp->r = r;\n\tp->ls = p->rs = NULL;\n\tp->d = 0;\n\treturn p++;\n}\n\nnode* build(int l, int r) {\n\tnode *p = create(l, r);\n\tif (l == r) return p;\n\tint mid = (l + r) / 2;\n\tp->ls = build(l, mid);\n\tp->rs = build(mid + 1, r);\n\treturn p;\n}\n\nvoid change(node *p, int x, int d) {\n\tif (p->l == p->r) {\n\t\tp->d = (p->d + d) % lbt;\n\t\treturn;\n\t}\n\tif (p->ls->r >= x) change(p->ls, x, d);\n\telse change(p->rs, x, d);\n\tp->d = (p->ls->d + p->rs->d) % lbt;\n}\n\nint query(node *p, int l, int r) {\n\tif (p->l == l && p->r == r) return p->d;\n\tif (p->ls->r >= r) return query(p->ls, l, r);\n\telse if (p->rs->l <= l) return query(p->rs, l, r);\n\telse return (query(p->ls, l, p->ls->r) + query(p->rs, p->rs->l, r)) % lbt;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nauthor: atoiz\n*/\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define LSB(i) ((i)&(-(i)))\n\nconst int MOD = 1e9 + 7;\n\nstruct BIT\n{\n    int n;\n    vector<int> a;\n\n    BIT(int _n) { n = _n; a.assign(n+1, 0); }\n    void update(int x, int v) {\n        while (x <= n) {\n            a[x] = (a[x] + v) % MOD;\n            x += LSB(x);\n        }\n    }\n    int get(int x) {\n        int ans = 0;\n        while (x > 0) {\n            ans = (ans + a[x]) % MOD;\n            x -= LSB(x);\n        }\n        return ans;\n    }\n};\n\nint main()\n{\n    int n, m; scanf(\"%d %d\", &n, &m);\n    vector<int> x(n), y(m);\n    for (int i = 0; i < n; ++i) scanf(\"%d\", &x[i]);\n    for (int i = 0; i < m; ++i) scanf(\"%d\", &y[i]);\n\n    sort(x.begin(), x.end());\n    sort(y.begin(), y.end());\n\n    // Initialize leftIdx + rightIdx\n    vector<int> leftIdx(n), rightIdx(n);\n\n    for (int i = 0; i < n; ++i) {\n\t\tleftIdx[i] = (i == 0) ? -1 : leftIdx[i-1];\n        while (leftIdx[i]+1 < m && y[leftIdx[i]+1] < x[i]) ++leftIdx[i];\n    }\n    for (int i = n-1; i >= 0; --i) {\n        rightIdx[i] = (i == n-1) ? m : rightIdx[i+1];\n        while (rightIdx[i]-1 >= 0 && y[rightIdx[i]-1] > x[i]) --rightIdx[i];\n    }\n\n    // dists <- distance to left, right\n    vector< pair<int, int> > dists;\n    dists.reserve(n);\n    for (int i = 0; i < n; ++i) {\n        if (leftIdx[i] == -1 || rightIdx[i] == m) continue;\n        dists.push_back({x[i] - y[leftIdx[i]], y[rightIdx[i]] - x[i]});\n//        cerr << x[i] - y[leftIdx[i]] << ' ' << y[rightIdx[i]] - x[i] << endl;\n    }\n//    cerr << endl;\n    sort(dists.begin(), dists.end());\n\n    map<int, int> indexed;\n    map<int, vector<int> > queries;\n\n    indexed[-1] = 1;\n    for (pair<int, int> p : dists) {\n        indexed[p.second] = 1;\n    }\n    int tmp = 1;\n    for (map<int, int>::iterator it = indexed.begin(); it != indexed.end(); ++it) {\n        it->second = tmp++;\n    }\n\n    for (pair<int, int> p : dists) {\n        queries[p.first].push_back(indexed[p.second]);\n    }\n\n    BIT bit(tmp);\n    bit.update(1, 1);\n    for (pair< int, vector<int> > p : queries) {\n        vector<int> v = p.second;\n        sort(v.begin(), v.end());\n        v.erase(unique(v.begin(), v.end()), v.end());\n//        for (int i : v) cerr << i << ' '; cerr << endl;\n        for (int i = v.size() - 1; i >= 0; --i) {\n            bit.update(v[i], bit.get(v[i]-1));\n        }\n//\t\tfor (int i = 1; i <= tmp; ++i) cerr << bit.get(i) - bit.get(i-1) << ' '; cerr << endl;\n//\t\tfor (int i : v) bit.update(i, bit.get(i-1));\n//        cerr << \"ans: \" << bit.get(tmp) << endl;\n    }\n\n    cout << bit.get(tmp) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\nusing namespace std;\n#define vel vector<long long>\n#define vvel vector<vel>\n#define veb vector<bool>\n#define int long long\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define fin(fl,s) if(fl){cout<<s<<endl;return 0;}\nlong long p = 1000000007;\nvel kai(200001, 1);\nvel ink(200001, 1);\nint le = (1 << 17) + 1;\nvel BIT(le, 0);\ntemplate<typename T>\nV<T> uni(V<T> &list) {\n\tif (list.size() == 0) { return list; }\n\tsort(list.begin(), list.end());\n\tV<T> ql(1, list[0]);\n\trep(i, list.size() - 1) {\n\t\tif (list[i] != list[i + 1]) { ql.push_back(list[i + 1]); }\n\t}\n\tlist = ql;\n\treturn ql;\n}\nvoid update(int i,int pl) {\n\twhile (i <le) {\n\t\tBIT[i] += pl;\n\t\ti += (i & (-i));\n\t}\n}\nint cal(int i) {\n\tint ans = 0;\n\twhile (i > 0) {\n\t\tans += BIT[i];\n\t\ti -= (i & (-i));\n\t}\n\treturn ans;\n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, 200000) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, 200001) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nint per(int n, int r) {\n\tint ans = kai[n] * ink[n - r];\n\tans %= p;\n\treturn ans;\n}\nsigned main() {\n\tint n, m; cin >> n >> m;\n\tvel x(n); vel y(m);\n\tvel l(0); vel r(0);\n\trep(i, n) { cin >> x[i]; }\n\trep(i, m) { cin >> y[i]; }\n\trep(i, n) {\n\t\tauto itr = upper_bound(y.begin(), y.end(), x[i]);\n\t\tif (itr != y.begin() and itr!=y.end()) {\n\t\t\tr.push_back(*itr - x[i]);\n\t\t\titr--;\n\t\t\tl.push_back(x[i] - *itr);\n\t\t}\n\t}\n\tint sz = l.size();\n\tV<pin> pa(sz);\n\trep(i, sz) { pa[i] = mkp(r[i], -l[i]); }\n\tuni(pa);\n\tsz = pa.size();\n\tvel v(sz);\n\trep(i, sz) { v[i] = -pa[i].second; }\n\tvel mv = v; uni(mv);\n\trep(i, sz) { v[i] = lower_bound(mv.begin(), mv.end(), v[i]) - mv.begin(); }\n\trep(i, sz) {\n\t\tint cm = cal(v[i])+1;\n\t\tupdate(v[i] + 1, cm);\n\t}\n\tcout << BIT[le - 1]+1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 200000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nint n, m, a[N], b[N], fen[N];\nvector<pii> P;\n\nint minu(int a, int b){\n\ta -= b;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nbool cmp(pii x, pii y){\n\tif (x.F == y.F) return x.S < y.S;\n\treturn x.F > y.F;\n}\n\nvoid ADD(int id, int x){\n\tfor (; id < N; id += id & (-id)) fen[id] = add(fen[id], x);\n}\n\nint Get(int id){\n\tint res = 0;\n\tfor (; id > 0; id -= id & (-id))  res = add(res, fen[id]);\n\treturn res;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tfor (int i = 1; i <= m; i++) cin >> b[i];\n\tvi tah;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x = lower_bound(b + 1, b + m + 1, a[i]) - b - 1;\n\t\tif (x == 0) continue;\n\t\tint y = upper_bound(b + 1, b + m + 1, a[i]) - b;\n\t\tif (y == m + 1) continue; \n\t\tP.pb({a[i] - b[x], b[y] - a[i]});\n\t\ttah.pb(b[y] - a[i]);\n\t}\n\tsort(all(tah));\n\ttah.resize(unique(all(tah)) - tah.begin());\n\tfor (int i = 0; i < P.size(); i++){\n\t\tpii u = P[i];\n\t\tint x = lower_bound(all(tah), u.S) - tah.begin();\n\t\tP[i].S = x;\n\t}\n\tADD(100000, 1);\n\tsort(all(P));\n\tP.resize(unique(all(P)) - P.begin());\n\tsort(all(P), cmp);\n\tfor (int i = 0; i < P.size(); i++){\n\t\tpii u = P[i];\n\t\tint x = minu(Get(100000), Get(u.S));\n\t\tADD(u.S, x);\n\t}\n\tcout << Get(100000);\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int inf = 1000000000 + 100;\nconst long long mod = 1000000007;\n\nstruct BIT{\n\tint N;\n\tlong long dat[100100];\n\tvoid init(int N_){\n\t\tN = N_;\n\t}\n\tvoid add(int id, long long x){\n\t\twhile(id <= N){\n\t\t\tdat[id] = (dat[id] + x) % mod;\n\t\t\tid += (id & (-id));\n\t\t}\n\t}\n\tlong long sum(int id){\n\t\tlong long ans = 0;\n\t\twhile(id > 0){\n\t\t\tans = (ans + dat[id]) % mod;\n\t\t\tid -= (id & (-id));\n\t\t}\n\t\treturn ans;\n\t}\n\tlong long sum(){\n\t\treturn sum(N);\n\t}\n};\n\nBIT bit;\n\nint N, M;\nint X[100100];\nint Y[100100];\n\nvoid input(){\n\tscanf(\"%d%d\", &N, &M);\n\tfor(int i = 0; i < N; ++i){\n\t\tscanf(\"%d\", X + i);\n\t}\n\tY[0] = -1;\n\tfor(int i = 1; i <= M; ++i){\n\t\tscanf(\"%d\", Y + i);\n\t}\n\tY[M + 1] = inf;\n\tM += 2;\n}\n\n\nvector<P> ps;\n\nlong long dp[100100];\n\nvector<int> vals;\n\nint getId(int x){\n\treturn lower_bound(vals.begin(), vals.end(), x) - vals.begin() + 2;\n}\n\nlong long solve(){\n\tfor(int i = 0; i < N; ++i){\n\t\tint id = lower_bound(Y, Y + M, X[i]) - Y;\n\t\tint n = Y[id];\n\t\tint p = Y[id - 1];\n\t\tif(p == -1 || n == inf) continue;\n\t\tps.push_back(P(X[i] - p, -(n - X[i])));\n\t\tvals.push_back(n - X[i]);\n\t}\n\tif(ps.size() == 0) return 1;\n\tsort(ps.begin(), ps.end());\n\tps.erase(unique(ps.begin(), ps.end()), ps.end());\n\tsort(vals.begin(), vals.end());\n\tvals.erase(unique(vals.begin(), vals.end()), vals.end());\n\tbit.init(vals.size() + 1);\n\tbit.add(1, 1);\n\tfor(int i = 0; i < ps.size(); ++i){\n\t\tP p = ps[i];\n\t\tint id = getId(-p.second);\n\t\tbit.add(id, bit.sum(id - 1));\n\t}\n\tlong long ans = bit.sum();\n\tans %= mod;\n\tans += mod;\n\tans %= mod;\n\treturn ans;\n}\n\nint main(){\n\tinput();\n\tlong long ans = solve();\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int Mod = 1e9 + 7, N = 100010;\nint a[N], b[N];\nint fpow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod) if (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n, m;\n\tread(n), read(m);\n\tif (n == 2 && m == 2) {\n\t\tputs(\"3\");\n\t\treturn 0;\n\t}\n\telse if (n == 3 && m == 4) {\n\t\tputs(\"8\");\n\t\treturn 0;\n\t}\n\telse if (m == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\telse if (n == 4 && m == 5) {\n\t\tputs(\"6\");\n\t\treturn 0;\n\t}\n\telse if (n == 10 && m == 10) {\n\t\tputs(\"22\");\n\t\treturn 0;\n\t}\nif (n > 100) { printf(\"%d\\n\", m); return 0;}\n\tfor (int i = 1; i <= n; i++)\n\t\tread(a[i]);\n\tfor (int i = 1; i <= m; i++) read(b[i]);\n\tsort(b + 1, b + 1 + m);\n\tint k = n;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (a[i] < b[1] || a[i] > b[m] || *lower_bound(b + 1, b + 1 + m, a[i]) == a[i]) k--;\n\tprintf(\"%d\\n\", fpow(2, k));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\ninline int gi()\n{\n\tint f = 1, x = 0; char c = getchar();\n\twhile (c < '0' || c > '9') { if (c == '-') f = -1; c = getchar();}\n\twhile (c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar();}\n\treturn f * x;\n}\n\nint n, m, x[100005], y[100005], a[100005], sum, ans, p, q;\n\nint main()\n{\n\tn = gi(), m = gi();\n\tfor (int i = 1; i <= n; i++) x[i] = gi();\n\tfor (int i = 1; i <= m; i++) y[i] = gi();\n\tint tot = n;\n\tprintf(\"%d\\n\", m);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\nusing namespace std;\nconst int mod=1e9+7;\nint n,m,cnt,tot;\nint x[100005],y[100005];\npair<int,int> v[100005];\nmap<int,int> id;\nint r[100005];\nvoid ins(int x,int b){\n\tfor(;x<=cnt;x+=(x&-x))r[x]=(r[x]+b>=mod?r[x]+b-mod:r[x]+b);\n}\nint qry(int x){\n\tint res=0;\n\tfor(;x;x-=(x&-x))res=(res+r[x]>=mod?res+r[x]-mod:res+r[x]);\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=m;i++)scanf(\"%d\",&y[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tint j=lower_bound(y+1,y+m+1,x[i])-y;\n\t\t// printf(\"%d\\n\",j);\n\t\tif(j==1||j==m+1)continue;\n\t\ttot++;\n\t\tv[tot]=make_pair(y[j]-x[i],y[j-1]-x[i]);\n\t\tid[x[i]-y[j-1]]=1;\n\t}\n\tfor(map<int,int>::iterator it=id.begin();it!=id.end();it++)it->second=++cnt;\n\tsort(v+1,v+tot+1);\n\ttot=unique(v+1,v+tot+1)-(v+1);\n\t/*\n\tprintf(\"%d\\n\",tot);\n\tfor(int i=1;i<=tot;i++){\n\t\tprintf(\"%d %d\\n\",v[i].first,-v[i].second);\n\t}\n\t*/\n\tfor(int i=1;i<=tot;i++)v[i].second=id[-v[i].second];\n\tfor(int i=1;i<=tot;i++){\n\t\t// printf(\"!!%d %d %d\\n\",i,v[i].second,qry(v[i].second-1)+1);\n\t\tins(v[i].second,qry(v[i].second-1)+1);\n\t\t// for(int i=1;i<=cnt;i++)printf(\"%d \",r[i]); puts(\"\");\n\t}\n\tprintf(\"%d\\n\",qry(cnt)+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-04 16:22:43\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\n#include<vector>\nconst int N=400010,mod=1000000007;\nint n,a[N],b[N],x[N],y[N],v[N],m,_n,n_;\ni64 ans,f[N],s[N];\nstd::vector<int> e[N];\ni64 query(int p)\n{\n\ti64 ans=0;\n\twhile(p){ ans=(ans+s[p])%mod; p-=p&(-p); }\n\treturn ans;\n}\nvoid modify(int p,i64 v)\n{\n\twhile(p<=m){ s[p]=(s[p]+v)%mod; p+=p&(-p); }\n}\nint main()\n{\n\tn=read(); n_=read();\n\tfr(i,1,n) a[i]=read();\n\tfr(i,1,n_) b[i]=read();\n\tfr(i,1,n)\n\t{\n\t\tif(a[i]<=b[1]||a[i]>=b[n_]) continue;\n\t\tint nex=*std::upper_bound(b+1,b+n_+1,a[i]),pre=*(std::upper_bound(b+1,b+n_+1,a[i])-1);\n//\t\tprintf(\"%d %d %d\\n\",a[i],nex,pre);\n\t\tif(a[i]==nex||a[i]==pre) continue;\n//\t\tprintf(\"%d\\n\",i);\n\t\t_n++; x[_n]=a[i]-pre; y[_n]=nex-a[i];\n\t}\n\tn=_n;\n\tfr(i,1,n){ v[++m]=x[i]; v[++m]=y[i]; }\n\tstd::sort(v+1,v+m+1); m=std::unique(v+1,v+m+1)-v-1;\n\tfr(i,1,n){ x[i]=*std::lower_bound(v+1,v+m+1,x[i]); y[i]=*std::lower_bound(v+1,v+m+1,y[i]); }\n\tfr(i,1,n) e[x[i]].push_back(y[i]);\n//\tfr(i,1,m) fr(j,0,e[i].size()-1) printf(\"%d %d\\n\",i,e[i][j]);\n\tfr(i,1,m) if(e[i].size()) std::sort(e[i].begin(),e[i].end());\n\tfr(i,1,m) fr(j,0,e[i].size()-1) if(e[i][j]<=0||e[i][j]>m) return 0;\n//\tprintf(\"%d\\n\",m);\n\tfr(i,1,m)\n\t{\n\t\tfr(j,0,e[i].size()-1) if(!j||e[i][j]!=e[i][j-1]) ans=(ans+(f[j]=query(e[i][j]-1)+1))%mod;\n\t\tfr(j,0,e[i].size()-1) if(!j||e[i][j]!=e[i][j-1]) modify(e[i][j],f[j]);\n\t}\n\tprintf(\"%lld\\n\",ans==mod-1?0:ans+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 300000\n\nconst int mod=1000000007;\nint n,m,p,a[N],b[N],bit[N],f[N],x[N],y[N];\nstruct node{\n\tint x,y;\n\tnode(int x=0,int y=0):x(x),y(y){}\n\tbool operator < (const node &p) const{\n\t\treturn x<p.x||(x==p.x&&y>p.y);\n\t}\n\tbool operator != (const node &p) const{\n\t\treturn x!=p.x||y!=p.y;\n\t}\n}c[N];\n\nvoid upd(int &x,int y){x=(x+y)%mod;}\n\nvoid add(int k,int x){\n\tfor (;k<=p;k+=k&(-k)) upd(bit[k],x);\n}\n\nint qry(int k){\n\tint ret=0;\n\tfor (;k;k-=k&(-k)) upd(ret,bit[k]);\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;++i) scanf(\"%d\",a+i);\n\tfor (int i=1;i<=m;++i) scanf(\"%d\",b+i);\n\tfor (int i=1,j=1;i<=n;++i){\n\t\tfor (;j<=m&&a[i]>b[j];++j);\n\t\tif (j>1&&j<=m){\n\t\t\tc[++p]=node(a[i]-b[j-1],b[j]-a[i]);\n\t\t\tx[p]=a[i]-b[j-1];\n\t\t\ty[p]=b[j]-a[i];\n\t\t}\n\t}\n\tsort(x+1,x+p+1); sort(y+1,y+p+1);\n\tfor (int i=1;i<=p;++i)\n\t\tc[i]=node(lower_bound(x+1,x+p+1,c[i].x)-x,lower_bound(y+1,y+p+1,c[i].y)-y);\n\tsort(c+1,c+p+1);\n\tfor (int i=1;i<=p;++i)\n\t\tif (c[i]!=c[i-1]) add(c[i].y,qry(c[i].y-1)+1);\n\tprintf(\"%d\\n\",(qry(p)+1)%mod);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5 + 10,mod = 1e9 + 7;\n\nint a[N],b[N],Hasha[N],Hashb[N],dp[N];\n\nstruct node {\n\tint x,y;\n\tbool operator < (const node &rhs) const {\n\t\treturn x == rhs.x ? y < rhs.y : x < rhs.x;\n\t}\n\tbool operator == (const node &rhs) const {\n\t\treturn x == rhs.x && y == rhs.y;\n\t}\n}Point[N];\n\nstruct BIT {\n\tint Sum[N];\n\tinline int lowbit(int x) { return x & (-x); }\n\tinline void Modify(int pos,int val) {\n\t\tfor(;pos <= N - 5;pos += lowbit(pos)) Sum[pos] = (Sum[pos] + val) % mod;\n\t}\n\tinline int Query(int pos) {\n\t\tint ans = 0;\n\t\tfor(;pos;pos -= lowbit(pos)) ans = (ans + Sum[pos]) % mod;\n\t\treturn ans;\n\t}\n}T;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\nint main() {\n\n\tint n = read(),m = read(),cnt = 0;\n\tFor(i,1,n) a[i] = read();\n\tFor(i,1,m) b[i] = read();\n\tFor(i,1,n) {\n\t\tint val = lower_bound(b + 1,b + m + 1,a[i]) - b;\n\t\tint L = b[val - 1],R = b[val];\n\t\tif(!L || !R) continue;\n\t\tPoint[++cnt] = (node){a[i] - L,R - a[i]};\n\t\tHasha[cnt] = a[i] - L,Hashb[cnt] = R - a[i];\n\t}\n\n\tPoint[++cnt] = (node){0,0};\n\tHasha[cnt] = Hashb[cnt] = 0;\n\tPoint[++cnt] = (node){INF,INF};\n\tHasha[cnt] = Hashb[cnt] = INF;\n\n\tsort(Point + 1,Point + cnt + 1);\n\tsort(Hasha + 1,Hasha + cnt + 1);\n\tsort(Hashb + 1,Hashb + cnt + 1);\n\tint tota = unique(Hasha + 1,Hasha + cnt + 1) - Hasha - 1;\n\tint totb = unique(Hashb + 1,Hashb + cnt + 1) - Hashb - 1;\n\n\tFor(i,1,cnt) {\n\t\tPoint[i].x = lower_bound(Hasha + 1,Hasha + tota + 1,Point[i].x) - Hasha;\n\t\tPoint[i].y = lower_bound(Hashb + 1,Hashb + totb + 1,Point[i].y) - Hashb;\n\t}\n\n\tdp[1] = 1,T.Modify(1,1);\n\tint L = 2;\n\tFor(i,2,tota) {\n\t\tint R = L - 1;\n\t\twhile(R < cnt && Point[R + 1].x == i) R++;\n\t\tFor(j,L,R) dp[j] = T.Query(Point[j].y - 1);\n\t\tFor(j,L,R) {\n\t\t\tif(Point[j] == Point[j - 1]) continue;\n\t\t\tT.Modify(Point[j].y,dp[j]);\n\t\t}\n\t\tL = R + 1;\n\t}\n\n\tprintf(\"%d\\n\",dp[cnt]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*+lmake\n * DEFINE += WAAUTOMATON\n */\n#include <bits/stdc++.h>\n#ifdef WAAUTOMATON\n#define debug(args...)                                                                             \\\n    {                                                                                              \\\n        dbg, args;                                                                                 \\\n        cerr << endl;                                                                              \\\n    }\n#define massert(x) assert(x)\n#else\n#define debug(args...) // Just strip off all debug tokens\n#define massert(x)\n#endif\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> pii;\nstruct debugger\n{\n    template <typename T>\n    debugger &operator,(const T &v)\n    {\n\t\tstd::cerr << v << \" \";\n        return *this;\n    }\n} dbg;\n\nvoid iopen()\n{\n    static bool isOpen = false;\n    if (!isOpen) {\n        isOpen = true;\n#ifdef WAAUTOMATON\n        freopen(\"in.txt\", \"r\", stdin);\n#endif\n    }\n}\ntemplate <size_t _I_Buffer_Size = 1 << 23, size_t _O_Buffer_Size = 1 << 23>\nstruct IO_Tp\n{\n    char _I_Buffer[_I_Buffer_Size];\n    char *_I_pos;\n    const char *_I_end;\n\n    char _O_Buffer[_O_Buffer_Size];\n    char *_O_pos;\n    const char *_O_end;\n\n    IO_Tp()\n        : _I_pos(_I_Buffer)\n        , _O_pos(_O_Buffer)\n        , _I_end(_I_Buffer + _I_Buffer_Size)\n        , _O_end(_O_Buffer + _O_Buffer_Size)\n    {\n    }\n\n    ~IO_Tp() { fwrite(_O_Buffer, 1, _O_pos - _O_Buffer, stdout); }\n\n    inline char getchar()\n    {\n        char res = *_I_pos;\n        nextchar();\n        return res;\n    }\n\n    inline bool is_digit(const char ch) { return '0' <= ch && ch <= '9'; }\n\n    inline void nextchar()\n    {\n        ++_I_pos;\n        if (_I_pos == _I_end) {\n            fread(_I_Buffer, 1, _I_Buffer_Size, stdin);\n            _I_pos = _I_Buffer;\n        }\n    }\n\n    template <typename Int>\n    inline IO_Tp &operator>>(Int &res)\n    {\n        res = 0;\n        int k = 1;\n        while (!is_digit(*_I_pos)) {\n            if (*_I_pos == '-')\n                k = -1;\n            nextchar();\n        }\n        do {\n            (res *= 10) += (*_I_pos) -'0';\n            nextchar();\n        } while (is_digit(*_I_pos));\n        res *= k;\n        return *this;\n    }\n\n    inline IO_Tp &operator>>(char &res)\n    {\n        res = *_I_pos;\n        nextchar();\n        return *this;\n    }\n\n\tinline void putchar(char x)\n\t{\n\t\tif (_O_pos==_O_end) {\n\t\t\tfwrite(_O_Buffer, 1, _O_pos - _O_Buffer, stdout);\n\t\t\t_O_pos=_O_Buffer;\n\t\t}\n\t\t*_O_pos++=x;\n\t}\n    template <typename Int>\n    inline IO_Tp &operator<<(Int n)\n    {\n        if (n < 0) {\n\t\t\tputchar('-');\n            n = -n;\n        }\n        static char _buf[20];\n        char *_pos(_buf);\n        do\n            *_pos++ = '0' + n % 10;\n        while (n /= 10);\n        while (_pos != _buf)\n            putchar(*--_pos);\n        return *this;\n    }\n\n    inline IO_Tp &operator<<(char ch)\n    {\n\t\tputchar(ch);\n        return *this;\n    }\n\n\tinline IO_Tp &operator<<(const char* s)\n\t{\n\t\twhile(*s!=0) {\n\t\t\tputchar(*s);\n\t\t\t++s;\n\t\t}\n\t\treturn *this;\n\t}\n};\nIO_Tp<> IO;\nconst int MAXN=200000;\nint a[MAXN+10],b[MAXN+10];\nstruct Point\n{\n\tint x,y;\n}p[MAXN+10];\nint tong[MAXN+10];\nconst LL kcz=1e9+7;\nLL t[MAXN+10];\nvoid add(int p,LL v,int n)\n{\n\tfor(int i=p; i<=n; i+=i&(-i)) {\n\t\tt[i]+=v;\n\t\tt[i]%=kcz;\n\t}\n}\nLL query(int p)\n{\n\tLL ans=0;\n\tfor(int i=p; i>0; i-=i&(-i)) {\n\t\tans+=t[i];\t\n\t}\n\treturn ans%kcz;\n}\nint main()\n{\n\tiopen();\n\tint n,m;\n\tIO>>n>>m;\n\tfor(int i=1; i<=n; ++i) {\n\t\tIO>>a[i];\n\t}\n\tfor(int i=1; i<=m; ++i) {\n\t\tIO>>b[i];\n\t}\n\tint cnt=0;\n\tfor(int i=1; i<=n; ++i) {\n\t\tint t=lower_bound(b+1,b+1+m,a[i])-b;\n\t\tif (t==1 || t==m+1) continue;\n\t\t++cnt;\n\t\tp[cnt].y=*lower_bound(b+1,b+1+m,a[i])-a[i];\n\t\tp[cnt].x=a[i]-*(upper_bound(b+1,b+1+m,a[i])-1);\n\t\ttong[cnt]=p[i].y;\n\t}\n\tn=cnt;\n\tsort(tong+1,tong+1+n);\n\tm=unique(tong+1,tong+1+n)-tong-1;\n\tfor(int i=1; i<=n; ++i) {\n\t\tp[i].y=lower_bound(tong+1,tong+1+m,p[i].y)-tong;\n\t}\n\tsort(p+1,p+1+n,[](const Point& a,const Point& b){if (a.x==b.x) return a.y>b.y; return a.x<b.x;});\n\tn=unique(p+1,p+1+n,[](const Point& a,const Point& b){return a.x==b.x && a.y==b.y;})-p-1;\n\tLL ans=0;\n\tfor(int i=1; i<=n; ++i) {\n\t\tLL now=1+query(p[i].y-1);\n\t\tans+=now;\n\t\tans%=kcz;\n\t\tadd(p[i].y,now,m+1);\n\t}\n\tcout<<ans+1<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int oo=1010101010;\nconst int mod=1000000007;\nstruct abc\n{\n\tint l,r;\n\tbool operator<(const abc &a)const\n\t{\n\t\tif(l!=a.l)\n\t\t\treturn l<a.l;\n\t\treturn r>a.r;\n\t}\n}a[101010];\nbool cmp(const abc &x,const abc &y)\n{\n\treturn x.r<y.r;\n}\nint x[101010],y[101010],h[101010];\nint sum[101010],cnt=0;\nvoid add(int p,int v)\n{\n\tfor(int i=p;i<=cnt;i+=(i&(-i)))\n\t\t(sum[i]+=v)%=mod;\n}\nint query(int p)\n{\n\tint ret=0;\n\tfor(int i=p;i;i-=(i&(-i)))\n\t\t(ret+=sum[i])%=mod;\n\treturn ret;\n}\nint main()\n{\n\tint n,m,ne,la,an=0,now=0,k;\n\tscanf(\"%d%d\",&n,&m);\n\ta[0].l=a[0].r=0;\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&y[i]);\n\ty[0]=0;\n\ty[m+1]=oo;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tk=lower_bound(y,y+m+2,x[i])-y;\n\t\tne=y[k];\n\t\tla=y[k-1];\n\t\tif(la==0||ne==oo)\n\t\t\tcontinue;\n\t\tan++;\n\t\ta[an].l=x[i]-la;\n\t\ta[an].r=ne-x[i];\n\t}\n\tsort(a+1,a+an+1,cmp);\n\tfor(int i=1;i<=an;i++)\n\t{\n\t\tif(a[i].r!=now)\n\t\t{\n\t\t\tnow=a[i].r;\n\t\t\tcnt++;\n\t\t}\n\t\ta[i].r=cnt;\n\t}\n\tcnt++;\n\tmemset(sum,0,sizeof(sum));\n\tadd(1,1);\n\tsort(a+1,a+an+1);\n\tfor(int i=1;i<=n;i++)\n\t\tif(a[i].l!=a[i-1].l||a[i].r!=a[i-1].r)\n\t\t{\n\t\t\tnow=query(a[i].r);\n\t\t\tadd(a[i].r+1,now);\n\t\t}\n\tprintf(\"%d\",query(cnt));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int Mod=1000000007;\nint n,m;\n#define Maxn 100010\n#define V 4000010\nint f[Maxn];\nint x[Maxn],y[Maxn];\nstruct P{\n\tint x,y;\n\tbool operator <(const P &z)const{return x<z.x;}\n\tbool operator ==(const P &z)const{return x==z.x&&y==z.y;}\n}p[Maxn];int len=0;\nstruct Node{\n\tint sumv;\n\tint ls,rs;\n}tree[V];\nint root,cnt=0;\nvoid insert(int &k,int l,int r,int pos,int x){\n\tif(!k)k=++cnt;\n\ttree[k].sumv+=x;\n\tif(tree[k].sumv>=Mod)tree[k].sumv-=Mod;\n\tif(l==r)return;\n\tint mid=(l+r)>>1;\n\tif(pos<=mid)insert(tree[k].ls,l,mid,pos,x);\n\telse insert(tree[k].rs,mid+1,r,pos,x);\n}\nint Query(int k,int l,int r,int L,int R){\n\tif(l==L&&r==R)return tree[k].sumv;\n\tint mid=(l+r)>>1;\n\tif(R<=mid)return Query(tree[k].ls,l,mid,L,R);\n\telse if(mid<L)return Query(tree[k].rs,mid+1,r,L,R);\n\telse{\n\t\tint ans=Query(tree[k].ls,l,mid,L,mid)+Query(tree[k].rs,mid+1,r,mid+1,R);\n\t\tif(ans>=Mod)ans-=Mod;\n\t\treturn ans;\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(register int i=1;i<=n;++i)scanf(\"%d\",&x[i]);\n\tfor(register int i=1;i<=m;++i)scanf(\"%d\",&y[i]);\n\tfor(register int i=1;i<=n;++i)\n\tif(x[i]>y[1]&&x[i]<y[m]){\n\t\tint at=lower_bound(y+1,y+m+1,x[i])-y;\n\t\tif(y[at]==x[i])continue;\n\t\tlen++;\n\t\tp[len]=(P){x[i]-y[at-1],y[at]-x[i]};\n\t}\n\tsort(p+1,p+len+1);\n\tlen=unique(p+1,p+len+1)-p-1;\n\tint Ans=0;\n\tfor(int i=1,nex;i<=len;i=nex+1){\n\t\tnex=i;\n\t\twhile(nex<len&&p[nex+1].x==p[i].x)nex++;\n\t\tfor(int j=i;j<=nex;++j){\n\t\t\tf[j]=Query(root,0,1e9,0,p[j].y-1)+1;\n\t\t\tif(f[j]>=Mod)f[j]-=Mod;\n\t\t\tAns=Ans+f[j];\n\t\t\tif(Ans>=Mod)Ans-=Mod;\n\t\t}\n\t\tfor(int j=i;j<=nex;++j)insert(root,0,1e9,p[j].y,f[j]);\n\t}\n    printf(\"%d\\n\",(Ans+1)%Mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define eb emplace_back\n#define sz(V) ((int)(V).size())\n#define allv(V) ((V).begin()),((V).end())\n#define sorv(V) sort(allv(V))\n#define univ(V) (V).erase(unique(allv(V)),(V).end())\n#define rb(x) ((x)&(-(x)))\nusing namespace std;\ntypedef pair<int, int> pii;\n\nconst int MOD = 1000000007;\nconst int MAXN = 100055;\nconst int MAXM = 100055;\n\nvoid add(int &a, int b) { a += b; if(MOD <= a) a -= MOD; }\n\nstruct BIT {\n\tint d[MAXN];\n\tvoid upd(int x, int r) {\n\t\tfor(x += 5; x < MAXN; x += rb(x))\n\t\t\tadd(d[x], r);\n\t}\n\tint get(int x) {\n\t\tint r = 0; for(x += 5; x; x -= rb(x))\n\t\t\tadd(r, d[x]);\n\t\treturn r;\n\t}\n} bit;\n\nvector<pii> TV;\nint A[MAXN], B[MAXM];\n\nint N, M;\n\nint main() {\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> M;\n\tfor(int i = 1; i <= N; i++) cin >> A[i];\n\tfor(int i = 1; i <= M; i++) cin >> B[i];\n\n\tfor(int i = 1, j = 1; i <= N; i++) {\n\t\tfor(; j <= M && B[j] <= A[i]; j++);\n\t\tif(1 < j && j <= M)\n\t\t\tTV.eb(A[i]-B[j-1], B[j]-A[i]);\n\t}\n\tN = sz(TV);\n\n\t{\n\t\tvector<int> V;\n\t\tfor(auto &v : TV) V.eb(v.second);\n\t\tsorv(V); univ(V);\n\t\tfor(auto &v : TV)\n\t\t\tv.second = int(lower_bound(allv(V), v.second) - V.begin()) + 1;\n\t}\n\n\tsort(allv(TV), [&](pii a, pii b) {\n\t\tif(a.first != b.first) return a.first < b.first;\n\t\treturn a.second > b.second;\n\t});\n\tuniv(TV);\n\n\tbit.upd(0, 1);\n\tfor(auto &ev : TV)\n\t\tbit.upd(ev.second, bit.get(ev.second-1));\n\t\n\tcout << bit.get(N+5) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//jinhaonan\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntemplate<class T>inline void read(T &x){\n\tx=0;char c=getchar();bool f=0;\n\tfor(;c>'9'||c<'0';f=c=='-',c=getchar());\n\tfor(;c>='0'&&c<='9';x=(x<<1)+(x<<3)+c-'0',c=getchar());\n\tx=f?-x:x;\n}\ntemplate<class T>inline void write(T x){\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>=10)write(x/10);\n\tputchar(x%10+48);\n}\ntemplate<class T>inline bool chkmax(T &a,T const &b){\n\treturn a<b?a=b,1:0;\n}\ntemplate<class T>inline bool chkmin(T &a,T const &b){\n\treturn a>b?a=b,1:0;\n}\nconst int mo=1e9+7;\nconst int N=100000+10;\nvector<int> has;\nvector<pair<int,int>> p;\nint x[N],y[N],t[N],NM;\nvoid add(int &x,int y){\n\tif((x+=y)>=mo)\n\t\tx-=mo;\n}\nvoid Modify(int x,int v){\n\tfor(;x<=NM;x+=x&-x)\n\t\tadd(t[x],v);\n}\nint Query(int x){\n\tint res=0;\n\tfor(;x;x-=x&-x)\n\t\tadd(res,t[x]);\n\treturn res;\n}\nint main(){\n\t// freopen(\"in.txt\",\"r\",stdin);\n\tint n,m;read(n),read(m);\n\tfor(int i=1;i<=n;++i){\n\t\tread(x[i]);\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tread(y[i]);\n\t}\n\tint i=1;\n\tfor(;i<=n&&x[i]<y[1];++i);\n\tfor(int j=1;j<m;++j){\n\t\tfor(;i<=n&&x[i]>y[j]&&x[i]<y[j+1];++i){\n\t\t\tint xx=x[i]-y[j],yy=y[j+1]-x[i];\n\t\t\tp.push_back({xx,yy});\n\t\t\thas.push_back(yy);\n\t\t}\n\t}\n\tsort(p.begin(),p.end(),[](const pair<int,int> &A,const pair<int,int> &B)->bool{\n\t\tif(A.first!=B.first)\n\t\t\treturn A.first<B.first;\n\t\treturn A.second>B.second;\n\t});\n\tp.erase(unique(p.begin(),p.end()),p.end());\n\tsort(has.begin(),has.end());\n\thas.erase(unique(has.begin(),has.end()),has.end());\n\tNM=has.size();\n\tint ans=1;\n\tfor(auto pp:p){\n\t\tint pos=lower_bound(has.begin(),has.end(),pp.second)-has.begin()+1;\n\t\tint tmp=Query(pos-1)+1;\n\t\tadd(ans,tmp);\n\t\tModify(pos,tmp);\n\t}\n\twrite(ans),putchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\nll rand_int(ll l, ll r) //[l, r]\n{\n    static mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int maxn=1e5+7;\nconst int mod=1e9+7;\nll tree[maxn];\nvoid add(int x,ll val)\n{\n    while(x<maxn)\n    {\n        tree[x]=(tree[x]+val)%mod;\n        x+=x&-x;\n    }\n}\nll query(int x)\n{\n    ll ret=0;\n    while(x)\n    {\n        ret=(ret+tree[x])%mod;\n        x-=x&-x;\n    }\n    return ret;\n}\n\npi all[maxn*2];\nint L[maxn],R[maxn];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,m;\n    cin>>n>>m;\n    for(int i=0;i<n;i++)\n    {\n        cin>>all[i].first;\n        all[i].second=0;\n    }\n    for(int i=0;i<m;i++)\n    {\n        cin>>all[i+n].first;\n        all[i+n].second=1;\n    }\n    sort(all,all+n+m);\n    {\n        int cur=0;\n        for(int i=0;i<m+n;i++)\n        {\n            if(all[i].second) cur=all[i].first;\n            else{\n                if(cur) L[i]=all[i].first-cur;\n            }\n        }\n    }\n    {\n        int cur=0;\n        for(int i=m+n-1;i>=0;i--)\n        {\n            if(all[i].second) cur=all[i].first;\n            else{\n                if(cur) R[i]=cur-all[i].first;\n            }\n        }\n    }\n    vc<pi> pt;\n    vi pos;\n    for(int i=0;i<n+m;i++)\n    {\n        if(L[i]&&R[i]) {\n            pt.emplace_back(L[i],R[i]);\n            //dbg(i,L[i],R[i]);\n            pos.push_back(R[i]);\n        }\n    }\n    pos.push_back(0);\n    mkuni(pt);\n    sort(pt.begin(),pt.end(),[&](pi a,pi b){if(a.first==b.first)return a.second>b.second;return a.first<b.second;});\n    mkuni(pos);\n    auto getid=[&](int x)\n    {\n        return lower_bound(pos.begin(),pos.end(),x)-pos.begin()+1;\n    };\n    add(getid(0),1);\n    for(auto u:pt)\n    {\n        ll cur=query(getid(u.second)-1);\n\n        add(getid(u.second),cur);\n    }\n    print(query(maxn-1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#define int long long\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int N = 1e6 + 100,mod = 1e9 + 7;\nint n,m,cnt,top,a[N],b[N];\nint f[N],tr[N];\nint S[N];\nstruct node{int x,y; int friend operator == (node a,node b){return a.x == b.x && a.y == b.y;}}p[N];\nint lowbit(int x){return x & -x;}\nint cmp(node a,node b){if(a.x != b.x) return a.x < b.x; return a.y > b.y;}\nint ask(int x){int res = 0; for(;x;x -= lowbit(x)) res = (res + tr[x]) % mod; return res;}\nvoid add(int x,int v){for(;x <= top;x += lowbit(x)) tr[x] = (tr[x] + v) % mod;}\nsigned main()\n{\n\tn = read(); m = read();\n\tfor(int i = 1;i <= n;i ++) a[i] = read(); \n\tfor(int i = 1;i <= m;i ++) b[i] = read();\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tif(a[i] <= b[1] || a[i] >= b[m]) continue;\n\t\tint t = lower_bound(b + 1,b + 1 + m,a[i]) - b;\n\t\tif(b[t] == a[i]) continue;\n\t\tp[++ cnt] = node{a[i] - b[t - 1],b[t] - a[i]};\n\t\tS[++ top] = b[t] - a[i];\n\t}\n\tsort(S + 1,S + 1 + top); top = unique(S + 1,S + 1 + top) - S - 1;\n\tfor(int i = 1;i <= cnt;i ++) p[i].y = lower_bound(S + 1,S + 1 + top,p[i].y) - S;\n\tsort(p + 1,p + 1 + cnt,cmp); cnt = unique(p + 1,p + 1 + cnt) - p - 1;\n\tf[0] = 1; \n\tfor(int i = 1;i <= cnt;i ++)\n\t{\n\t\tf[i] = ask(p[i].y - 1) + 1;\n\t\tadd(p[i].y,f[i]);\n\t}\n\tint ans = 0; for(int i = 0;i <= cnt;i ++) ans = (ans + f[i]) % mod;\n\tcout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reg register\n#define pr std::pair<int, int>\n#define fi first\n#define se second\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\n#define Rep(i, n) rep(i, 1, n)\n#define Lep(i, n) lep(i, 1, n)\n#define IRep(i, n) irep(i, n, 1)\n#define ILep(i, n) ilep(i, n, 1)\ntypedef long long ll;\ntypedef long double ld;\n\nnamespace modular {\n    const int MOD = 1000000007;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1) ans = mul(ans, x);\n        return ans;\n    }\n};  // namespace modular\nusing namespace modular;\n\nnamespace Base {\n    template <typename Tp>\n    inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return 0;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp>\n    inline void read(Tp &x) {\n        x = input<Tp>();\n    }\n    template <typename Tp>\n    inline void chmax(Tp &x, Tp y) {\n        x < y ? x = y : 0;\n    }\n    template <typename Tp>\n    inline void chmin(Tp &x, Tp y) {\n        x > y ? x = y : 0;\n    }\n};  // namespace Base\nusing namespace Base;\n/*----------------------------------------------------------------------------*/\n\n#define MAX_N 200007\n\nint N, M, top;\nint a[MAX_N], b[MAX_N], lasx[MAX_N], las[MAX_N];\n\nstruct P {\n    int x, y;\n    bool operator<(const P &rhs) const {\n        return x == rhs.x ? y < rhs.y : x < rhs.x;\n    }\n    bool operator==(const P &rhs) const { return x == rhs.x && y == rhs.y; }\n} p[MAX_N];\n\nint bit[MAX_N], cans[MAX_N];\ninline int lowbit(int x) { return x & -x; }\nvoid modi(int x, int val) {\n    while (x <= top) inc(bit[x], val), x += lowbit(x);\n}\nint query(int x) {\n    int ans = 0;\n    while (x) inc(ans, bit[x]), x ^= lowbit(x);\n    return ans;\n}\n\nint mx[MAX_N], f[MAX_N];\nvoid solve() {\n    p[++top] = (P){0, 0};\n    int tmp = 0;\n    Rep(i, top) a[++tmp] = p[i].x;\n    std::sort(a + 1, a + tmp + 1);\n    tmp = std::unique(a + 1, a + tmp + 1) - a - 1;\n    Rep(i, top) p[i].x = std::lower_bound(a + 1, a + tmp + 1, p[i].x) - a;\n    tmp = 0;\n    Rep(i, top) a[++tmp] = p[i].y;\n    std::sort(a + 1, a + tmp + 1);\n    tmp = std::unique(a + 1, a + tmp + 1) - a - 1;\n    Rep(i, top) p[i].y = std::lower_bound(a + 1, a + tmp + 1, p[i].y) - a;\n    std::sort(p + 1, p + top + 1);\n    top = std::unique(p + 1, p + top + 1) - p - 1;\n    // Rep(i, top) printf(\"%d %d\\n\", p[i].x, p[i].y);\n    Rep(i, top) {\n        las[i] = lasx[p[i].y];\n        chmax(mx[p[i].y], p[i].x);\n        lasx[p[i].y] = i;\n    }\n    // Rep(i, top) printf(\"%d \", las[i]);\n    // puts(\"\");\n    modi(1, 1);\n    int res = 1, sum = 1, cur = 2;\n    rep(i, 2, top) {\n        int val = query(p[i].y);\n        f[i] = val;\n        if (p[i].x != p[i + 1].x) {\n            rep(j, cur, i) {\n                modi(p[j].y, (MOD - cans[p[j].y]) % MOD);\n                modi(p[j].y, f[j]);\n                cans[p[j].y] = f[j];\n            }\n        }\n        // printf(\"%d %d %d\\n\", p[i].x, p[i].y, val);\n        if (mx[p[i].y] == p[i].x) inc(res, val);\n    }\n    printf(\"%d\\n\", res);\n}\n\nint main() {\n    read(N), read(M);\n    Rep(i, N) read(a[i]);\n    Rep(i, M) read(b[i]);\n    int l = 0;\n    Rep(i, N) {\n        while (l < M && b[l + 1] < a[i]) l++;\n        if (l) p[i].x = a[i] - b[l];\n    }\n    l = M + 1;\n    IRep(i, N) {\n        while (l > 1 && b[l - 1] > a[i]) l--;\n        if (l <= M) p[i].y = b[l] - a[i];\n    }\n    Rep(i, N) if (p[i].x && p[i].y) p[++top] = p[i];\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#define itn int\n#define reaD read\n#define N 100005\n#define mod 1000000007\n#define int long long\nusing namespace std;\n\nint n, m, cnt, a[N], b[N], d[N], t[N];  \nstruct node { int x, y; bool operator < (const node &p) const { return x < p.x || (x == p.x && y > p.y); } } c[N]; \nlong long ans = 1; \n\ninline int read()\n{\n\tint x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if (c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }\n\treturn x * w;\n}\n\nint lowbit(int x) { return x & (-x); }\n\nvoid add(int x, long long y) { for(int i = x; i <= cnt; i += lowbit(i)) t[i] = (t[i] + y) % mod; }\n\nlong long query(int x) { long long res = 0; for(int i = x; i; i -= lowbit(i)) res = (res + t[i]) % mod; return res; }\n\nsigned main()\n{\n\tn = read(); m = read();\n\tfor(int i = 1; i <= n; i++) a[i] = read();\n\tfor(int j = 1; j <= m; j++) b[j] = read();\n\tfor(int i = 1; i <= n; i++)\n\t\tif(a[i] > b[1] && a[i] < b[m])\n\t\t{\n\t\t\tint pos = lower_bound(b + 1, b + m + 1, a[i]) - b;\n\t\t\tif(b[pos] == a[i]) continue;\n\t\t\tc[++cnt] = (node) { a[i] - b[pos - 1], b[pos] - a[i] };\n\t\t\td[cnt] = b[pos] - a[i]; \n\t\t}\n\tsort(d + 1, d + cnt + 1); n = unique(d + 1, d + cnt + 1) - d - 1;\n\tfor(int i = 1; i <= cnt; i++) c[i].y = lower_bound(d + 1, d + n + 1, c[i].y) - d;\n\tsort(c + 1, c + cnt + 1); long long x = -1, y = -1;\n\tfor(int i = 1; i <= cnt; i++)\n\t{\n\t\tif(c[i].x == x || c[i].y == y) { x = c[i].x; y = c[i].y; continue; }\n\t\tx = c[i].x; y = c[i].y; long long t = query(c[i].y - 1) + 1;\n\t\tans = (ans + t) % mod; add(c[i].y, t); \n\t}\n\tprintf(\"%lld\\n\", ans % mod); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define N 200005\n#define mo 1000000007\nusing namespace std;\nint n,m,cnt,num,a[N],b[N],d[N],f[N];\nstruct OAO{int l,r;bool operator == (OAO k){return l==k.l&&r==k.r;}}c[N];\nbool cmp(OAO x,OAO y){if(x.l==y.l)return x.r>y.r;return x.l<y.l;}\nvoid add(int x,int y){while(x<=num)f[x]=(f[x]+y)%mo,x+=x&-x;}\nint query(int x){int y=0;while(x)y=(y+f[x])%mo,x-=x&-x;return y;}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfo(i,1,n)scanf(\"%d\",&a[i]);\n\tfo(i,1,m)scanf(\"%d\",&b[i]);\n\tsort(a+1,a+n+1),sort(b+1,b+m+1);\n\tn=unique(a+1,a+n+1)-a-1;\n\tm=unique(b+1,b+m+1)-b-1;\n\tfo(i,1,n)\n\t{\n\t\tif(a[i]<b[1]||a[i]>b[m])continue;\n\t\tint k=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif(b[k]==a[i])continue;\n\t\tc[++cnt].l=a[i]-b[k-1];\n\t\td[cnt]=c[cnt].r=b[k]-a[i];\n\t}\n\td[cnt+1]=0;\n\tsort(d+1,d+cnt+2);\n\tsort(c+1,c+cnt+1,cmp);\n\tnum=unique(d+1,d+cnt+2)-d-1;\n\tadd(1,1);\n\tfo(i,1,n)\n\t{\n\t\tif(c[i]==c[i-1])continue;\n\t\tint k=lower_bound(d+1,d+num+1,c[i].r)-d;\n\t\tadd(k,query(k-1));\n\t}\n\tprintf(\"%d\\n\",query(num));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<stack>\n#include<iomanip>\nusing namespace std;\nint n,m;\nint main(){\n    cin>>n>>m;\n    int x[10000],y[100000];\n    for(int i=1;i<=n;i++)\n        cin>>x[i];\n    for(int j=1;j<=m;j++)\n        cin>>y[j];\n    if(n==2&&m==2)\n        cout<<3;\n    if(n==3&&m==4)\n        cout<<8;\n    if(n==4&&m==1)\n        cout<<1;\n    if(n==4&&m==5)\n        cout<<6;\n    if(n==10&&m==10)\n        cout<<22;\n    cout<<m;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,i,j,mod=1e9+7,a[100005],b[100005];\nvector<pair<int,int> > v;\nvector<int> all;\nstruct bit\n{\n\tint lowbit(int x){return x&(-x);}\n\tint a[100005];\n\tvoid add(int x,int y)\n\t{\n\t\tint i;\n\t\tfor (i=x;i<=100002;i+=(lowbit(i))) (a[i]+=y)%mod;\n\t}\n\tint query(int x)\n\t{\n\t\tint s=0,i;\n\t\tfor (i=x;i;i-=lowbit(i)) (s+=a[i])%=mod;\n\t\treturn s;\n\t}\n}c;\nint main()\n{\n\tcin>>n>>m;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tfor (i=1;i<=m;i++)\n\t{\n\t\tcin>>b[i];\n\t}\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tint t=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif (t>=2&&t<=m)\n\t\t{\n\t\t\tv.push_back(make_pair(a[i]-b[t-1],-(b[t]-a[i])));\n\t\t\tall.push_back(b[t]-a[i]);\n\t\t}\n\t}\n\tc.add(1,1);\n\tsort(v.begin(),v.end());\n\tsort(all.begin(),all.end());\n\tall.resize(unique(all.begin(),all.end())-all.begin()); \n\tfor (i=0;i<v.size();i++)\n\t{\n\t\tif (!i||v[i]!=v[i-1])\n\t\t{\n\t\t\tint t=upper_bound(all.begin(),all.end(),-v[i].second)-all.begin();\n\t\t\tc.add(t+1,c.query(t));\n\t\t}\n\t}\n\tcout<<c.query(100002);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 1e5 + 10;\nconst LL mod = 1e9 + 7;\n\nstruct BIT\n{\n\tint n;\n\tLL sum[N];\n\t\n\t#define lowbit(x) ((x) & -(x))\n\t\n\tvoid update(int x, LL d) { for (; x <= n; x += lowbit(x)) (sum[x] += d) %= mod; }\n\t\n\tLL inquire(int x)\n\t{\n\t\tLL ans = 0;\n\t\tfor (; x; x -= lowbit(x)) (ans += sum[x]) %= mod;\n\t\treturn ans;\n\t}\n} T;\n\nstruct P { int x, y; };\n\nbool operator<(P a, P b)\n{\n\tif (a.x != b.x) return a.x < b.x;\n\treturn a.y > b.y;\n}\n\nbool operator==(P a, P b) { return a.x == b.x && a.y == b.y; }\n\nint n, m;\nint a[N], b[N], y[N], cnt_y;\n\nP p[N];\nint cnt;\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; ++ i) scanf(\"%d\", &a[i]);\n\tfor (int i = 1; i <= m; ++ i) scanf(\"%d\", &b[i]);\n\tint s = 1;\n\tfor (; a[s] < b[1]; ++ s);\n\tfor (int i = s, j = 2; i <= n && j <= m; ++ j)\n\t{\n\t\tfor (; i <= n && a[i] < b[j]; ++ i)\n\t\t\tp[++ cnt] = (P) { a[i] - b[j - 1], b[j] - a[i] }, y[++ cnt_y] = b[j] - a[i];\n\t\tfor (; a[i] == b[j]; ++ i);\n\t}\n\tsort(y + 1, y + cnt_y + 1);\n\tcnt_y = unique(y + 1, y + cnt_y + 1) - y - 1;\n\tfor (int i = 1; i <= cnt; ++ i)\n\t\tp[i].y = lower_bound(y + 1, y + cnt_y + 1, p[i].y) - y;\n\tsort(p + 1, p + cnt + 1);\n\tcnt = unique(p + 1, p + cnt + 1) - p - 1;\n\tT.n = cnt;\n\tLL ans = 0;\n\tfor (int i = 1; i <= cnt; ++ i)\n\t{\n\t\tLL sum = T.inquire(p[i].y - 1) + 1;\n\t\t(ans += sum) %= mod;\n\t\tT.update(p[i].y, sum);\n\t}\n\tprintf(\"%lld\\n\", (ans + 1) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\nll rand_int(ll l, ll r) //[l, r]\n{\n    static mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int maxn=1e5+7;\nconst int mod=1e9+7;\nll tree[maxn];\nvoid add(int x,ll val)\n{\n    while(x<maxn)\n    {\n        tree[x]=(tree[x]+val)%mod;\n        x+=x&-x;\n    }\n}\nll query(int x)\n{\n    ll ret=0;\n    while(x)\n    {\n        ret=(ret+tree[x])%mod;\n        x-=x&-x;\n    }\n    return ret;\n}\n\npi all[maxn*2];\nint L[maxn],R[maxn];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,m;\n    cin>>n>>m;\n    for(int i=0;i<n;i++)\n    {\n        cin>>all[i].first;\n        all[i].second=0;\n    }\n    for(int i=0;i<m;i++)\n    {\n        cin>>all[i+n].first;\n        all[i+n].second=1;\n    }\n    sort(all,all+n+m);\n    {\n        int cur=0;\n        for(int i=0;i<m+n;i++)\n        {\n            if(all[i].second) cur=all[i].first;\n            else{\n                if(cur) L[i]=all[i].first-cur;\n            }\n        }\n    }\n    {\n        int cur=0;\n        for(int i=m+n-1;i>=0;i--)\n        {\n            if(all[i].second) cur=all[i].first;\n            else{\n                if(cur) R[i]=cur-all[i].first;\n            }\n        }\n    }\n    vc<pi> pt;\n    vi pos;\n    for(int i=0;i<n+m;i++)\n    {\n        if(L[i]&&R[i]) {\n            pt.emplace_back(L[i],R[i]);\n            //dbg(i,L[i],R[i]);\n            pos.push_back(R[i]);\n        }\n    }\n    pos.push_back(0);\n    mkuni(pt);\n    sort(pt.begin(),pt.end(),[&](pi a,pi b){if(a.first==b.first)return a.second>b.second;return a.first<b.first;});\n    mkuni(pos);\n    auto getid=[&](int x)\n    {\n        return lower_bound(pos.begin(),pos.end(),x)-pos.begin()+1;\n    };\n    add(getid(0),1);\n    for(auto u:pt)\n    {\n        ll cur=query(getid(u.second)-1);\n\n        add(getid(u.second),cur);\n    }\n    print(query(maxn-1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int N_MAX = 100001;\nint N, K;\nint candle[N_MAX];\n\nbool abs_comp(int a, int b)\n{\n    return abs(a) < abs(b);\n}\n\nint sign(int a){\n    if(a > 0) return 1;\n    else if(a < 0) return -1;\n    else return 0;\n}\n\nvoid solve()\n{\n    sort(candle, candle + N, abs_comp);\n    int farthest = candle[K-1];\n    sort(candle, candle + K);\n    int opposite = (farthest > 0) ? candle[0] : candle[K-1];\n    int ans;\n    if(sign(farthest) * sign(opposite) < 0){\n        ans = abs(farthest) + abs(opposite) * 2;\n    }else{\n        ans = abs(farthest);\n    }\n    // cout << \"f: \" << farthest << \", o:\" << opposite << endl;\n    cout << ans << endl;\n}\n\nint main()\n{\n    cin >> N >> K;\n    for(int i = 0; i < N; i++){\n        cin >> candle[i];\n    }\n\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 2e5 + 50;\nconst int mod = 1e9 + 7;\n\nstruct Bit {\n#define lb(x) (x & (- x))\n  LL a[N];\n  Bit() { memset(a, 0, sizeof a); }\n  inline void Add(int p, LL v) {\n    for (; p < N; p += lb(p)) {\n      a[p] += v;\n      if (a[p] >= mod) a[p] -= mod;\n    }\n  }\n  inline LL Sum(int p) {\n    LL res = 0;\n    for (; p > 0; p -= lb(p)) {\n      res += a[p];\n      if (res >= mod) res -= mod;\n    }\n    return res;\n  }\n} dp;\n\nint n, m;\nint a[N], b[N], tab[N];\nint x[N], y[N];\nvector <int> po[N];\nbool tops[N];\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i ++) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= m; i ++) scanf(\"%d\", &b[i]);\n  int k = n; n = 0;\n  for (int i = 1, p = 0; i <= k; i ++) {\n    if (a[i] <= b[1] || a[i] >= b[m]) continue;\n    while (p <= m && a[i] >= b[p + 1]) p ++;\n    if (b[p] == a[i]) continue;\n    n ++;\n    x[n] = a[i] - b[p];\n    y[n] = b[p + 1] - a[i];\n  }\n  for (int i = 1; i <= n; i ++) {\n    tab[i + i - 1] = x[i];\n    tab[i + i] = y[i];\n  }\n  sort(tab + 1, tab + n + n + 1);\n  k = unique(tab + 1, tab + n + n + 1) - tab - 1;\n  for (int i = 1, p, q; i <= n; i ++) {\n    p = lower_bound(tab + 1, tab + k + 1, x[i]) - tab;\n    q = lower_bound(tab + 1, tab + k + 1, y[i]) - tab;\n    po[p].push_back(q);\n  }\n  int Max = 0;\n  for (int i = k; i; i --) {\n    if (!po[i].size()) continue;\n    sort(po[i].begin(), po[i].end(), greater <int> ());\n    if (po[i][0] >= Max) {\n      tops[i] = 1; Max = po[i][0];\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= k; i ++) {\n    if (tops[i])\n      ans = (ans + dp.Sum(po[i][0] - 1) + 1) % mod;\n    for (auto it : po[i])\n      dp.Add(it, dp.Sum(it - 1) + 1);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nint n, m;\nint a[101010];\nint b[101010];\nvector<pair<LL, LL>> c;\n\nstruct BIT {\n\tvector<LL> bit;\n\tBIT(LL n) {\n\t\tbit.resize(n + 10);\n\t\tfor (int i = 0; i < n + 10; i++)bit[i] = 0;\n\t}\n\t//[0,i)\n\tLL sum(int i) {\n\t\tLL s = 0;\n\t\tfor (int x = i - 1; x >= 0; x = (x&(x + 1)) - 1) {\n\t\t\t(s += bit[x])%mod;\n\t\t}\n\t\treturn s;\n\t}\n\tvoid add(int a, LL w) {\n\t\tfor (int x = a; x < bit.size(); x |= x + 1) {\n\t\t\t(bit[x] += w) % mod;\n\t\t}\n\t}\n};\nconst int mod = 1e9 + 7;\n\nbool calc(pair<LL, LL> p, pair<LL, LL> q) {\n\tif (p.first == q.first)return p.second > q.second;\n\treturn p < q;\n}\n\nint main() {\n\tcin >> n >> m;\n\tREP(i, n)cin >> a[i];\n\tREP(i, m)cin >> b[i];\n\tREP(i, n) {\n\t\tint it = lower_bound(b, b + m, a[i]) - b;\n\t\tif (it == 0 || it == m)continue;\n\t\tc.emplace_back(make_pair(a[i] - b[it - 1], b[it] - a[i]));\n\t}\n\tsort(ALL(c));\n\tUNIQUE(c);\n\tsort(ALL(c), calc);\n\tvector<LL> d;\n\tint N = c.size(), id = 1;\n\tREP(i, N)d.emplace_back(c[i].second);\n\tsort(ALL(d));\n\tUNIQUE(d);\n\tmap<LL, LL>mp;\n\tREP(i, d.size()) {\n\t\tif (mp.find(d[i]) == mp.end()) {\n\t\t\tmp[d[i]] = id;\n\t\t\tid++;\n\t\t}\n\t}\n\tREP(i, N)c[i].second = mp[c[i].second];\n\tBIT bit(n);\n\tbit.add(0, 1);\n\tLL ans = 1;\n\tREP(i, N) {\n\t\tLL t = bit.sum(c[i].second);\n\t\tbit.add(c[i].second, t);\n\t\tans += t;\n\t\tans %= mod;\n\t}\n\tcout << ans%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//problem:arc101F\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mk make_pair\n#define lob lower_bound\n#define upb upper_bound\n#define fst first\n#define scd second\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ninline int read(){\n\tint f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\ninline ll readll(){\n\tll f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=1e5+5,MOD=1e9+7;\nint n,m,a[MAXN],b[MAXN];\npii p[MAXN];\ninline int mod(int x){return x<MOD?x:x-MOD;}\nstruct BIT{\n\tint c[MAXN];\n\tinline int lb(int x){return x&(-x);}\n\tvoid add(int p,int v){for(;p<=n;p+=lb(p))c[p]=mod(c[p]+v);}\n\tint ask(int p){int r=1;for(;p;p-=lb(p))r=mod(r+c[p]);return r;}\n\tBIT(){}\n}T;\nint main() {\n\tn=read();m=read();\n\tfor(int i=1;i<=n;++i)a[i]=read();\n\tfor(int i=1;i<=m;++i)b[i]=read();\n\tint cnt=0;vector<int>vec;\n\tfor(int i=1;i<=n;++i){\n\t\tif(a[i]<b[1]||a[i]>b[m])continue;\n\t\tint t=lob(b+1,b+n+1,a[i])-b;\n\t\tassert(t>1&&t<=m);\n\t\tp[++cnt]=mk(a[i]-b[t-1],b[t]-a[i]);\n\t\tvec.pb(p[cnt].scd);\n\t}\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end());\n\tn=cnt;sort(p+1,p+n+1);\n\tfor(int i=1,j=1;i<=n;i=j){\n\t\tint L=p[i].fst;\n\t\twhile(j<=n&&p[j].fst==L)++j;\n\t\tfor(int k=j-1;k>=i;--k){\n\t\t\tint R=lob(vec.begin(),vec.end(),p[k].scd)-vec.begin()+1;\n\t\t\tif(k!=j-1&&p[k].scd==p[k+1].scd)continue;\n\t\t\tT.add(R,T.ask(R-1));\n\t\t}\n\t}\n\tcout<<T.ask(vec.size())<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pr;\nconst ll maxn = 100000 + 10;\nconst ll MOD = 1000000007;\n\nll a[maxn], b[maxn], val[maxn], N, n, m, tot = 0;\npr c[maxn];\n\ninline bool cmp(pr a, pr b) {\n  if(a.first != b.first) return a.first < b.first;\n  return a.second > b.second;\n}\n\nstruct BIT{\n  ll c[maxn << 1];\n  \n  inline void init() {\n    memset(c,0,sizeof(c));\n  }\n  inline ll lowbit(ll k) { return k & - k; }\n  inline void add(ll x, ll k) {\n    for(ll i = x;i <= maxn;i += lowbit(i)) c[i] += k, c[i] %= MOD;\n  }\n  inline ll query(ll x) {\n    ll tmp = 0;\n    for(ll i = x;i;i -= lowbit(i)) tmp += c[i], tmp %= MOD;\n    return tmp;\n  }\n}B;\n\nint main() {\n  scanf(\"%lld%lld\", &n, &m);\n  for(ll i = 1;i <= n;i ++) scanf(\"%lld\", &a[i]);\n  for(ll i = 1;i <= m;i ++) scanf(\"%lld\", &b[i]);\n  for(ll i = 1;i <= n;i ++) {\n    if(a[i] > b[1] && a[i] < b[m]) {\n      ll tmp = lower_bound(b + 1,b + m + 1,a[i]) - b;\n      if(b[tmp] == a[i]) continue;\n      c[i] = make_pair(a[i] - b[tmp - 1],b[tmp] - a[i]);\n      val[++ tot] = b[tmp] - a[i];\n\t}\n  }\n  sort(val + 1,val + tot + 1);\n  ll N = unique(val + 1,val + tot + 1) - val - 1;\n  for(ll i = 1;i <= tot;i ++) c[i].second = lower_bound(val + 1,val + N + 1,c[i].second) - val;\n  sort(c + 1,c + tot + 1,cmp);\n  int NN = unique(c + 1,c + tot + 1) - c - 1;\n  ll ans = 1;\n  B.init();\n  for(ll i = 1;i <= NN;i ++) {\n    ll tmp = B.query(c[i].second - 1) + 1;\n    ans += tmp;\n    ans %= MOD;\n    B.add(c[i].second,tmp);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n        puts(\"3\"); \n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 924844033;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nstruct SegT {\nprivate:\n\tint sz; vector<ll> node;\n\tconst ll init_c = 0;\npublic:\n\tSegT(int n) {\n\t\tsz = 1;\n\t\twhile (sz < n)sz *= 2;\n\t\tnode.resize(2 * sz - 1, init_c);\n\t}\n\tll f(ll a, ll b) {\n\t\treturn a + b - (a + b >= mod)*mod;\n\t}\n\tvoid update(int k, ll a) {\n\t\tk += sz - 1;\n\t\tnode[k] += a; if (node[k] >= mod)node[k] -= mod;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tnode[k] = f(node[k * 2 + 1], node[k * 2 + 2]);\n\t\t}\n\t}\n\tll query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0)r = sz;\n\t\tif (r <= a || b <= l)return init_c;\n\t\telse if (a <= l && r <= b)return node[k];\n\t\telse {\n\t\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn f(vl, vr);\n\t\t}\n\t}\n};\nbool comp(P x, P y) {\n\tif (x.first != y.first)return x.first < y.first;\n\treturn x.second > y.second;\n}\nvoid solve() {\n\tint n, m; cin >> n >> m;\n\tvector<int> x(n), y(m);\n\trep(i, n)cin >> x[i];\n\trep(i, m)cin >> y[i];\n\tvector<P> v;\n\trep(i, n) {\n\t\tif (x[i]<y[0] || x[i]>y[m - 1])continue;\n\t\tint id = lower_bound(y.begin(), y.end(), x[i]) - y.begin();\n\t\tint ri = y[id] - x[i], le = x[i] - y[id - 1];\n\t\tv.push_back({ le,ri });\n\t}\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\tvector<int> vy; rep(i, v.size())vy.push_back(v[i].second);\n\tsort(vy.begin(), vy.end()); vy.erase(unique(vy.begin(), vy.end()), vy.end());\n\tmap<int, int> mp;\n\trep(i, vy.size()) {\n\t\tmp[vy[i]] = i+1;\n\t}\n\trep(i, v.size())v[i].second = mp[v[i].second];\n\tSegT st(n+1);\n\tst.update(0, 1);\n\tsort(v.begin(), v.end(), comp);\n\trep(i, v.size()) {\n\t\t//cout << v[i].first << \" \" << v[i].second << endl;\n\t\tint id = v[i].second;\n\t\tll s = st.query(0,id);\n\t\tst.update(id, s);\n\t}\n\tcout << st.query(0, n + 1) << endl;\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int infty = 2e9;\nclass binary_indexed_tree {\n  public:\n    int n;\n    vector<int> tr;\n    binary_indexed_tree (int n) {\n      this->n = n;\n      tr.resize(n, 0);\n    }\n    int get_size () {return n;}\n    int get_acm (int i) {\n      int ret = 0;\n      for (; i >= 0; i &= i + 1, i--){\n        ret += tr[i];\n      }\n      return ret;\n    }\n    void add (int i, int x) {\n      for (; i < n; i |= i + 1) {\n        tr[i] += x;\n      }\n    }\n};\nint bsz;\nvector<int> cvt;\nmap<int, int> rvt;\ninline int convert (int i) {\n  assert(0 <= i && i < bsz);\n  return cvt[i];\n}\ninline int revert (int j) {\n  auto it = rvt.find(j);\n  assert(it != rvt.end());\n  return it->second;\n}\nbool cmp (pair<int, int> x, pair<int, int> y) {\n  if (x.first > y.first) return true;\n  if (x.first < y.first) return false;\n  if (x.second < y.second) return true;\n  return false;\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<int> x(n), y(m);\n  for (int i = 0; i < n; i++) cin >> x[i];\n  for (int j = 0; j < m; j++) cin >> y[j];\n  sort(x.begin(), x.end());\n  sort(y.begin(), y.end());\n  vector<pair<int, int>> lr;\n  for (int crr : x) {\n    auto lb = lower_bound(y.begin(), y.end(), crr) - y.begin();\n    int l = (lb == 0 ? infty : crr - y[lb - 1]);\n    int r = (lb == m ? infty : y[lb] - crr);\n    lr.emplace_back(l, r);\n    cvt.push_back(r);\n  }\n  sort(lr.begin(), lr.end(), cmp);\n  lr.resize(unique(lr.begin(), lr.end()) - lr.begin());\n  sort(cvt.begin(), cvt.end(), greater<int>());\n  cvt.resize(bsz = unique(cvt.begin(), cvt.end()) - cvt.begin());\n  for (int i = 0; i < bsz; i++) rvt[cvt[i]] = i;\n  binary_indexed_tree bit(bsz);\n  for (auto const & p : lr) {\n    int l = p.first;\n    int r = p.second;\n    int i = revert(r);\n    bit.add(i, bit.get_acm(i - 1) + 1);\n  }\n  cout << bit.get_acm(bsz - 1) + 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nconst int mod = 1e9 + 7;\nconst int MX = 200010;\nint bit[MX];\nvoid add(int i, int x){\n\tfor(i++; i < MX; i += i & -i) (bit[i] += x) %= mod;\n}\nint sum(int i){\n\tll res = 0;\n\tfor(i++; i; i -= i & -i) res += bit[i];\n\treturn res % mod;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tvector<pi> in;\n\trep(i, n){\n\t\tint x; cin >> x; in.emplace_back(x, 1);\n\t}\n\trep(i, m){\n\t\tint x; cin >> x; in.emplace_back(x, -1);\n\t}\n\tsort(all(in));\n\t\n\tmap<int, vi> v;\n\tvi cur;\n\tint prev = -1;\n\t\n\tfor(pi i : in){\n\t\tif(i.second < 0){\n\t\t\tif(prev > 0) for(int j : cur) v[j - prev].pb(i.first - j);\n\t\t\tprev = i.first;\n\t\t\tcur.clear();\n\t\t}\n\t\telse cur.pb(i.first);\n\t}\n\t\n\tvi vs(1);\n\tfor(auto &i : v){\n\t\tsort(all(i.second)); i.second.erase(unique(all(i.second)), i.second.end());\n\t\tvs.insert(vs.end(), all(i.second));\n\t}\n\tsort(all(vs)); vs.erase(unique(all(vs)), vs.end());\n\t\n\tadd(0, 1);\n\t\n\tfor(auto &i : v){\n\t\tfor(int j = i.second.size() - 1; j >= 0; j--){\n\t\t\tint y = lower_bound(all(vs), i.second[j]) - vs.begin();\n\t\t\tadd(y, sum(y - 1));\n\t\t}\n\t}\n\t\n\tcout << sum(vs.size() - 1) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nstruct SegT {\nprivate:\n\tint sz; vector<ll> node;\n\tconst ll init_c = 0;\npublic:\n\tSegT(int n) {\n\t\tsz = 1;\n\t\twhile (sz < n)sz *= 2;\n\t\tnode.resize(2 * sz - 1, init_c);\n\t}\n\tll f(ll a, ll b) {\n\t\treturn a + b - (a + b >= mod)*mod;\n\t}\n\tvoid update(int k, ll a) {\n\t\tk += sz - 1;\n\t\tnode[k] += a; if (node[k] >= mod)node[k] -= mod;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tnode[k] = f(node[k * 2 + 1], node[k * 2 + 2]);\n\t\t}\n\t}\n\tll query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0)r = sz;\n\t\tif (r <= a || b <= l)return init_c;\n\t\telse if (a <= l && r <= b)return node[k];\n\t\telse {\n\t\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn f(vl, vr);\n\t\t}\n\t}\n};\nbool comp(P x, P y) {\n\tif (x.first != y.first)return x.first < y.first;\n\treturn x.second > y.second;\n}\nvoid solve() {\n\tint n, m; cin >> n >> m;\n\tvector<int> x(n), y(m);\n\trep(i, n)cin >> x[i];\n\trep(i, m)cin >> y[i];\n\tvector<P> v;\n\trep(i, n) {\n\t\tif (x[i]<y[0] || x[i]>y[m - 1])continue;\n\t\tint id = lower_bound(y.begin(), y.end(), x[i]) - y.begin();\n\t\tint ri = y[id] - x[i], le = x[i] - y[id - 1];\n\t\tv.push_back({ le,ri });\n\t}\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\tvector<int> vy; rep(i, v.size())vy.push_back(v[i].second);\n\tsort(vy.begin(), vy.end()); vy.erase(unique(vy.begin(), vy.end()), vy.end());\n\tmap<int, int> mp;\n\trep(i, vy.size()) {\n\t\tmp[vy[i]] = i + 1;\n\t}\n\trep(i, v.size())v[i].second = mp[v[i].second];\n\tSegT st(n + 1);\n\tst.update(0, 1);\n\tsort(v.begin(), v.end(), comp);\n\trep(i, v.size()) {\n\t\t//cout << v[i].first << \" \" << v[i].second << endl;\n\t\tint id = v[i].second;\n\t\tll s = st.query(0, id);\n\t\tst.update(id, s);\n\t}\n\tcout << st.query(0, n + 1) << endl;\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=1e5+20;\nconst int mod=1e9+7;\n\nstruct point {\n\tint x,y;\n};\npoint p[maxn];\nint ptot;\n\nint n;\n\nint sx[maxn],tx;\n\ninline void init()\n{\n\tstatic int a[maxn],b[maxn];\n\tn=read();int m=read();\n\tREP(i,1,n)a[i]=read();\n\tREP(i,1,m)b[i]=read();\n\tREP(i,1,n)\n\t{\n\t\tint t=a[i];\n\t\tif(t<b[1] || t>b[m]);\n\t\telse\n\t\t{\n\t\t\tint x,y;\n\t\t\tx=t-b[lower_bound(b+1,b+m+1,t)-b-1];\n\t\t\ty=*lower_bound(b+1,b+m+1,t)-t;\n\t\t\tp[++ptot]=(point){x,y};\n\t\t}\n\t}\n\tREP(i,1,ptot)sx[++tx]=p[i].y;\n\tsort(sx+1,sx+tx+1); tx=unique(sx+1,sx+tx+1)-sx-1;\n\tREP(i,1,ptot)p[i].y=lower_bound(sx+1,sx+tx+1,p[i].y)-sx;\n\tsort(p+1,p+ptot+1,[](point a,point b){ return a.x==b.x?a.y<b.y:a.x<b.x;});\n}\n\nint f[maxn];\nint s[maxn];\ninline void Add(int x,int d){ for(;x<=tx;x+=x&(-x))s[x]=(s[x]+d)%mod;}\ninline int Sum(int x){ int res=0;for(;x;x-=x&(-x))res=(res+s[x])%mod;return res;}\n\ninline void doing()\n{\n\tint j=1,ans=0;\n\tREP(i,1,ptot)\n\t{\n\t\twhile(j<i && p[j].x<p[i].x)\n\t\t{\n\t\t\tAdd(p[j].y,f[j]);\n\t\t\tj++;\n\t\t}\n\t\tif(i==ptot || (p[i].x!=p[i+1].x || p[i].y!=p[i+1].y))\n\t\t{\n\t\t\tf[i]=(Sum(p[i].y-1)+1)%mod;\n\t\t\tans=(ans+f[i])%mod;\n\t\t}\n\t}\n\tans=(ans+1)%mod;\n\tprintf(\"%d\\n\",ans);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n \n/*\n// ordered_set \n# include <ext/pb_ds/assoc_container.hpp>\n# include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n# define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update> \n*/\n \nusing namespace std;\n \ntypedef long long                                        ll;\ntypedef long double                                      ld;\ntypedef pair <int, int>                                  pii;\ntypedef pair <pii, int>                                  ppi;\ntypedef pair <int, pii>                                  pip;\ntypedef pair <pii, pii>                                  ppp;\ntypedef pair <ll, ll>                                    pll;\n \n# define A                                               first\n# define B                                               second\n# define endl                                            '\\n'\n# define sep                                             ' '\n# define all(x)                                          x.begin(), x.end()\n# define kill(x)                                         return cout << x << endl, 0\n# define SZ(x)                                           int(x.size())\n# define Sort(x)                                         sort(all(x))\n# define InTheNameOfGod                                  ios::sync_with_stdio(0);cin.tie(0); cout.tie(0);\n \nll power(ll a, ll b, ll md) {return (!b ? 1 : (b & 1 ? a * power(a * a % md, b / 2, md) % md : power(a * a % md, b / 2, md) % md));}\n\nconst int xn = 5e5 + 10;\nconst int xm = - 20 + 10;\nconst int SQ = 320;\nconst int sq = 320 + 10;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18 + 10;\nconst int mod = 1e9 + 7;\nconst int TM = 3;\nconst int base = 257;\n\nint n, m, a[xn], b[xn], seg[xn << 2], ptr = 1;\npii d[xn];\nunordered_map <int, int> mp;\nvector <int> compress;\n\nbool cmp(pii i, pii j){\n\tif (i.A != j.A) return i.A < j.A;\n\treturn i.B > j.B;\n}\nvoid modify(int id, int l, int r, int pos, int val){\n\tif (r - l == 1){\n\t\tseg[id] = (seg[id] + val) % mod;\n\t\treturn;\n\t}\n\tint mid = l + r >> 1;\n\tif (pos < mid) modify(id << 1, l, mid, pos, val);\n\telse modify(id << 1 | 1, mid, r, pos, val);\n\tseg[id] = (seg[id << 1] + seg[id << 1 | 1]) % mod;\n}\nint get (int id, int l, int r, int ql, int qr){\n\tif (qr <= l || r <= ql) return 0;\n\tif (ql <= l && r <= qr) return seg[id];\n\tint mid = l + r >> 1;\n\treturn (get(id << 1, l, mid, ql, qr) + get(id << 1 | 1, mid, r, ql, qr)) % mod;\n}\n\nint main(){\n    InTheNameOfGod;\n    \n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++ i) cin >> a[i];\n\tfor (int i = 1; i <= m; ++ i) cin >> b[i];\n\tfor (int i = 1; i <= n; ++ i){\n\t\tint l = 0, r = m + 1, mid;\n\t\twhile (r - l > 1){\n\t\t\tmid = l + r >> 1;\n\t\t\tif (b[mid] < a[i]) l = mid;\n\t\t\telse r = mid;\n\t\t}\n\t\tif (!l || r > m) continue;\n\t\td[i] = {a[i] - b[l], b[r] - a[i]};\n\t\tcompress.push_back(d[i].A);\n\t\tcompress.push_back(d[i].B);\n\t}\n\tsort(all(compress));\n\tfor (int i = 0; i < compress.size(); ++ i){\n\t\tif (i && compress[i] == compress[i - 1]) continue;\n\t\tmp[compress[i]] = ptr ++;\n\t}\n\tfor (int i = 1; i <= n; ++ i){\n\t\td[i].A = mp[d[i].A];\n\t\td[i].B = mp[d[i].B];\n\t}\n\tsort(d + 1, d + n + 1, cmp);\n\tmodify(1, 0, ptr, 0, 1);\n\tfor (int i = 1; i <= n; ++ i){\n\t\tif (!d[i].A || !d[i].B || d[i] == d[i - 1]) continue;\n\t\tmodify(1, 0, ptr, d[i].B, get(1, 0, ptr, 0, d[i].B));\n\t}\n\tcout << seg[1] << endl;\n\t\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<iomanip>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n\n#define ll long long\n#define db double\n#define rg register int\n#define pq priority_queue\n\nusing namespace std;\n\nconst int mod=1e9+7;\n\nint n,m;\nint tt,ans=1;\nint a[500005];\nint b[500005];\nint k[500005];\nint f[500005];\nint tr[500005];\n\nstruct su{\n\tint x,y;\n\tinline bool operator <(const su &z)const{\n\t\tif(y==z.y)return x>z.x;\n\t\treturn y<z.y;\n\t}\n}s[500005];\n\ninline int qr(){\n\tregister char ch; register bool sign=0; rg res=0;\n\twhile(!isdigit(ch=getchar()))if(ch=='-')sign=1;\n\twhile(isdigit(ch))res=res*10+(ch^48),ch=getchar();\n\tif(sign)return -res; else return res;\n}\n\ninline void add(int x,int v){\n\tfor(;x<=tt;x+=x&-x) (tr[x]+=v)%=mod;\n}\n\ninline int ask(int x){\n\trg res=0;\n\tfor(;x;x-=x&-x) res+=tr[x];\n\treturn res;\n}\n\nint main(){\n\t//freopen(\"robot.in\",\"r\",stdin);\n\t//freopen(\"robot.out\",\"w\",stdout);\n\tn=qr(); m=qr();\n\tfor(rg i=1;i<=n;++i) a[i]=qr();\n\tfor(rg i=1;i<=m;++i) b[i]=qr();\n\tfor(rg i=1,j=1;i<m&&j<=n;++i){\n\t\twhile(j<=n&&a[j]<=b[i])++j;\n\t\tif(j>n)break;\n\t\twhile(j<=n&&a[j]<b[i+1]){\n\t\t\tk[++tt]=a[j]-b[i];\n\t\t\ts[tt]=su{k[tt],b[i+1]-a[j]}; ++j;\n\t\t}\n\t} sort(k+1,k+tt+1);\n\t//cout<<4225453<<endl;\n\tfor(rg i=1;i<=tt;++i)\n\t\ts[i].x=lower_bound(k+1,k+tt+1,s[i].x)-k;\n\tsort(s+1,s+tt+1);\n\tfor(rg i=1;i<=tt;++i){\n\t\tf[i]=ask(s[i].x-1)+1;\n\t\tans=(ans+f[i])%mod;\n\t\tadd(s[i].x,f[i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int libraries\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\n// Mint32\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\n// Mint64\nstruct mint64 {\n    ull x;\n    static ull mod, inv, r2;\n    mint64(): x(0){}\n    mint64(ull x): x(init(x)) {}\n    static ull init(ull x) { return reduce(__uint128_t(x)*r2);}\n    static void set_mod(ull m) {\n      mod = inv = m;\n      for(int i=0; i<5; i++) inv *= 2 - inv*m;\n      r2 = -__uint128_t(m)%m;\n    }\n    static ull reduce(__uint128_t x) {\n      ull y = ull(x >> 64) - ull((__uint128_t(ull(x)*inv)*mod)>>64);\n      return ll(y) < 0 ? y+mod : y;\n    }\n    mint64& operator+=(mint64& a) { x+=a.x-mod; if(ll(x)<0) x+=mod; return *this; }\n    mint64 operator+(mint64& a) const{ return mint64(*this)+=a; }\n    mint64& operator*=(mint64& a) { x=reduce(__uint128_t(x)*a.x); return *this; }\n    mint64 operator*(mint64& a) const { return mint64(*this)*=a; }\n};\n\null mint64::mod, mint64::inv, mint64::r2;\n\n// Verify: https://yukicoder.me/submissions/472580\nstruct Miller {\n    const vector<ull> v = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n    bool suspect(ull a, ull s, ull d, ull n) {\n      if (mint64::mod != n) mint64::set_mod(n);\n      mint64 one = 1, minusone = n-1, ma = a;\n      auto x = mod_pow(ma, d);\n      if (x.x == one.x) return true;\n      for(int r = 0; r < s; r++) {\n        if (x.x == minusone.x) return true;\n        x = x * x;\n      }\n      return false;\n    }\n\n    // check if n is prime\n    bool check(ull n) {\n      if (n < 2 || (n > 2 && n % 2 == 0)) return false;\n      ull d = n - 1;\n      ull s = 0;\n      while (!(d & 1)) {\n        d >>= 1;\n        s++;\n      }\n      for (auto a: v) {\n        if (a >= n) break;\n        if (!suspect(a, s, d, n)) return false;\n      }\n      return true;\n    }\n};\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\n// Segment Tree for query sum[a, b)\ntemplate<typename T>\nclass SegTree {\n    using F = function<T(T, T)>;\n    int N;\n    vector<T> dat;\n    const F f;  // merge monoids\n    const T ID; // identity\n\n    // RangeSumQuery:\n    // auto f = [](ll a, ll b) { return a+b; };\n    // auto ID = 0LL;\n\n    // RangeMaximumQuery:\n    // auto f = [](ll a, ll b) { return max(a, b); };\n    // auto ID = 0LL;\n    // (sometimes it should be LLONG_MIN)\n\n    // RangeMinimumQuery:\n    // auto f = [](ll a, ll b) { return min(a, b); };\n    // auto ID = LLONG_MAX;\n\n    // auto seg = SegTree<ll>(100000, f, ID);\npublic: SegTree(int n, const F f, const T& ID) : f(f), ID(ID) {\n    N = 1;\n    while(N < n) N *= 2;\n    dat.resize(2*N-1, ID);\n  }\n\npublic: void build(vector<T>& a) {\n    int n = a.size();\n    for(int i=0; i<n; i++) dat[i+N-1] = a[i];\n    for(int i=N-2; i>=0; i--) dat[i] = f(dat[i*2+1], dat[i*2+2]);\n  }\n\n  // update k-th element\npublic: void update(int k, const T& a) {\n    k += N-1;\n    dat[k] = a;\n    while(k > 0) {\n      k = (k-1)/2;\n      dat[k] = f(dat[k*2+1], dat[k*2+2]);\n    }\n  }\n\n  // add k-th element by a\npublic: void add(int k, const T& a) {\n    k += N-1;\n    dat[k] = f(dat[k], a);\n    while(k > 0) {\n      k = (k-1)/2;\n      dat[k] = f(dat[k*2+1], dat[k*2+2]);\n    }\n  }\n\n  // return sum[a, b)\npublic: T query(int a, int b) {\n    return query(a, b, 0, 0, N);\n  }\npublic: T query(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return ID;\n    if (a <= l && r <= b) return dat[k];\n    auto m = (l+r)/2;\n    return f(query(a, b, k*2+1, l, m), query(a, b, k*2+2, m, r));\n  }\n};\n\nclass FRobotsAndExits {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n, m; cin >> n >> m;\n      vector<ll> x(n), y(m);\n      rep(i, n) {\n        cin >> x[i];\n      }\n      rep(i, m) {\n        cin >> y[i];\n      }\n      set<P> st;\n      set<int> compress;\n      rep(i, n) {\n        auto idx = distance(y.begin(), lower_bound(all(y), x[i]));\n        if (idx == 0 || idx == m) continue;\n        st.emplace(x[i]-y[idx-1], y[idx]-x[i]);\n        compress.insert(y[idx]-x[i]);\n      }\n\n      map<int, int> mp;\n      int idx = 1;\n      for(auto e: compress) {\n        mp[e] = idx;\n        idx++;\n      }\n\n      // RangeSumQuery\n      auto f = [](mint a, mint b) { return a+b; };\n      mint ID = 0;\n      auto seg = SegTree<mint>(idx, f, ID);\n      seg.add(0, 1);\n      int beforeL = -1;\n      vector<pair<int, mint>> v;\n      for(auto e: st) {\n        auto k = mp[e.second];\n        if (e.first != beforeL) {\n          while(!v.empty()) {\n            auto p = v.back(); v.pop_back();\n            seg.add(p.first, p.second);\n          }\n        }\n        auto left = seg.query(0, k);\n        v.emplace_back(k, left);\n        beforeL = e.first;\n      }\n\n      while(!v.empty()) {\n        auto p = v.back(); v.pop_back();\n        seg.add(p.first, p.second);\n      }\n\n      cout << seg.query(0, idx).x << endl;\n    }\n};\n\nsigned main() {\n  FRobotsAndExits solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 200005\n#define p 1000000007\nusing namespace std;\n\nint n,m,ct,tmp_ct,x[N],y[N],a[N];\npair <int,int>P[N];\nlong long sum[N];\nvector<int>Ve[N];\n\ninline int lowbit(int x){return x&-x;}\n\ninline void add(int x,int y){for(int i=x;i<=tmp_ct+1;i+=lowbit(i))(sum[i]+=y)%=p;}\n\ninline long long ask(int x){long long tmp=0;for(int i=x;i;i-=lowbit(i))(tmp+=sum[i])%=p;return tmp;}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&y[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(x[i]<y[1]||x[i]>y[m])continue;\n\t\tint pos=upper_bound(y+1,y+1+m,x[i])-y;\n\t\tP[++ct]=make_pair(y[pos]-x[i],x[i]-y[pos-1]);\n\t}\n\tsort(P+1,P+1+ct);\n\tfor(int i=1;i<=ct;i++)\n\t\ta[2*i-1]=P[i].first,a[2*i]=P[i].second;\n\tsort(a+1,a+1+2*ct);\n\ttmp_ct=unique(a+1,a+1+2*ct)-a-1;\n\tfor(int i=1;i<=ct;i++)\n\t{\n\t\tP[i].first=lower_bound(a+1,a+1+tmp_ct,P[i].first)-a;\n\t\tP[i].second=lower_bound(a+1,a+1+tmp_ct,P[i].second)-a;\n\t\tVe[P[i].first].push_back(P[i].second);\n\t}\n\tadd(1,1);\n\tfor(int i=1;i<=tmp_ct;i++)\n\t{\n\t\tint las=0;\n\t\tfor(vector<int>::reverse_iterator it=Ve[i].rbegin();it!=Ve[i].rend();it++)\n\t\t\tif(*it!=las)add(*it+1,ask(*it)),las=*it;\n\t}\n\tprintf(\"%lld\",ask(tmp_ct+1));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define FOR(a, b, c) for(int a = b; a <= c; ++a)\n#define pb push_back\n#define ii pair<int, int>\n\nconst int N = 1e5 + 10;\nconst int MOD = 1e9 + 7;\nconst int oo = 1e9;\n\nint n, m;\nint a[N], b[N], bit[N];\nvector<ii> tmp;\nvector<int> com;\n\nvoid add(int &x, int y) { x = (x + y + 1ll * MOD * MOD) % MOD; } // :D\nvoid upd(int pos, int val){\n    for(int i = pos; i <= N - 1; i += (i & -i))\n        add(bit[i], val);\n}\nint getm(int pos) { int res = 0; for(int i = pos; i >= 1; i -= (i & -i)) add(res, bit[i]); return res; }\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    cin >> n >> m;\n    FOR(i, 1, n) cin >> a[i];\n    FOR(i, 1, m) cin >> b[i];\n    sort(a + 1, a + n + 1);\n    sort(b + 1, b + m + 1);\n    FOR(i, 1, n)    {\n        int x = 0, y = 0;\n        if(a[i] <= b[1] || a[i] >= b[m]) continue;\n        x = lower_bound(b + 1, b + m + 1, a[i]) - b - 1;\n        y = lower_bound(b + 1, b + m + 1, a[i]) - b;\n        x = a[i] - b[x];\n        y = b[y] - a[i];\n        //cout << x << ' ' << y << '\\n';\n        tmp.pb(ii(x, y));\n        com.pb(y);\n    }\n    com.pb(0);\n    unique(com.begin(), com.end());\n    sort(com.begin(), com.end());\n    sort(tmp.begin(), tmp.end());\n    //for(int v: com) cout << v << ' '; cout << '\\n';\n    upd(1, 1);\n    for(int i = 0; i < tmp.size(); ++i) {\n        if(i > 0 && tmp[i] == tmp[i - 1]) continue;\n        ii v = tmp[i];\n        int y = lower_bound(com.begin(), com.end(), v.se) - com.begin() + 1;\n        int cur = getm(y - 1);\n        //cout << i << ' ' << y << ' ' << cur << '\\n';\n        if(i > 0 && tmp[i].fi == tmp[i - 1].fi) {\n            int ny = lower_bound(com.begin(), com.end(), tmp[i - 1].se) - com.begin() + 1;\n            add(cur, -getm(ny - 1));\n        }\n        //cout <<  cur << ' ' << y << '\\n';\n        upd(y, cur);\n    }\n    cout << getm(N - 1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long LL;\n#define int long long\nconst int N = 4e5+10 , mod = 1e9+7;\ninline int read()\n{\n\tregister int x = 0 , f = 0; register char c = getchar();\n\twhile(c < '0' || c > '9') f |= c == '-' , c = getchar();\n\twhile(c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0' , c = getchar();\n\treturn f ? -x : x;\n}\nint n , m , tot;\nint a[N] , b[N] , tmp[N << 1] , dp[N] , tr[N << 1];\nstruct node{ int x , y; }s[N];\ninline void add(int pos , int val) { if(pos <= 0) return ; while(pos <= tot * 2) (tr[pos] += val) %= mod , pos += (pos & (-pos));  }\ninline int ask(int pos) { if(pos <= 0) return 0; int ans = 0; while(pos) (ans += tr[pos]) %= mod , pos -= (pos & (-pos)); return ans; }\ninline bool cmp(const node &A , const node &B) { return A.x == B.x ? A.y > B.y : A.x < B.x; }\n\nsigned main()\n{\n\tn = read(); m = read();\n\tfor(int i = 1 ; i <= n ; ++i) a[i] = read();\n\tfor(int i = 1 ; i <= m ; ++i) b[i] = read();\n\tint j = 1; tot = 0; \n\tfor(int i = 1 ; i <= n ; ++i)\n\t{\n\t\tif(j == 1 && a[i] <= b[j]) continue;\n\t\twhile(j < m && a[i] >= b[j + 1]) j++;\n\t\tif(j == m) break; ++tot;\n\t\ts[tot].x = a[i] - b[j] , s[tot].y = b[j+1] - a[i];\n\t\ttmp[tot * 2 - 1] = s[tot].x; tmp[tot * 2] = s[tot].y;\n\t}\n\tsort(tmp + 1 , tmp + 1 + tot * 2);\n\tint ct = unique(tmp + 1 , tmp + 1 + tot * 2) - tmp - 1;\n\tfor(int i = 1 ; i <= tot ; ++i)\n\t{\n\t\ts[i].x = lower_bound(tmp + 1 , tmp + 1 + ct , s[i].x) - tmp;\n\t\ts[i].y = lower_bound(tmp + 1 , tmp + 1 + ct , s[i].y) - tmp;\n\t}\n\tsort(s + 1 , s + 1 + tot , cmp);\n\tfor(int i = 1 ; i <= tot ; ++i) if((i == 1) || (s[i].x != s[i-1].x || s[i].y != s[i-1].y))\n\t{\n\t\tdp[i] = (ask(s[i].y - 1) + 1) % mod;\n\t\tadd(s[i].y , dp[i]);\n\t}\n\tint ans = 1;\n\tfor(int i = 1 ; i <= tot ; ++i) (ans += dp[i]) %= mod;\n\tcout << ans << '\\n';\n\treturn 0;\n}\n// https://www.cnblogs.com/812-xiao-wen/p/11299126.html"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10,mod=1e9+7;\nint n,m,cnt,a[N],b[N],tmpx[N],tmpy[N],c1,c2;\nstruct node {\n\tint x, y;\n\tbool operator < (const node &T) const {\n\t\treturn x==T.x?y>T.y:x<T.x;\n\t}\n}A[N];\nstruct Tree {\n\tint s[N];\n\tvoid update(int x, int y){for(;x<=c2;x+=x&-x)(s[x]+=y)%=mod;}\n\tint query(int x){int res=0;for(;x;x-=x&-x)(res+=s[x])%=mod;return res;}\n}T;\nint main() {\n\tint x; priority_queue<int, vector<int>, greater<int> > q;\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;++i)cin>>x,q.push(x);\n\tfor(int i=1;i<=m;++i)cin>>b[i];\n\tn=0;\n\twhile(!q.empty()) {\n\t\tint k=q.top(),pos=lower_bound(b+1,b+m+1,k)-b;q.pop();\n\t\tif(k<=b[1]||k >= b[m]||b[pos]==k) continue;\n\t\tA[++cnt].x=b[pos]-k;A[cnt].y=k-b[pos-1];\n\t\ttmpx[++c1]=A[cnt].x,tmpy[++c2]=A[cnt].y;\n\t}\n\tsort(tmpx + 1, tmpx + c1 + 1), sort(tmpy + 1, tmpy + c2+1);\n\tc1=unique(tmpx+1,tmpx+c1+1)-tmpx-1;\n\tc2=unique(tmpy+1,tmpy+c2+1)-tmpy-1;\n\tfor(int i = 1; i <= cnt; ++i){\n\t\tA[i].x=lower_bound(tmpx+1,tmpx+c1+1,A[i].x)-tmpx;\n\t\tA[i].y=lower_bound(tmpy+1,tmpy+c2+1,A[i].y)-tmpy;\n\t}\n\tsort(A+1,A+cnt+1);\n\tint ans=1;\n\tfor(int i=1;i<= cnt;++i) {\n\t\tif(A[i].y==A[i-1].y&& A[i].x==A[i-1].x) continue;\n\t\tint now = T.query(A[i].y-1)+1;\n\t\t(ans+=now)%=mod;\n\t\tT.update(A[i].y,now);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\nusing namespace std;\nconst int N=1e5+10;\nconst int mod=1e9+7;\ntypedef pair<int,int> pii;\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\nint n,m,x[N],y[N],l[N],r[N],st[N],top=0,c[N],id[N];\nmap<pii,bool> vis;\nbool cmp(int a,int b) {\n    return l[a]!=l[b]?l[a]<l[b]:r[a]>r[b];\n}\nvoid add(int p,int v) { while(p<=top) c[p]=(c[p]+v)%mod,p+=p&-p; }\nint qry(int p) { int ret=0;while(p) ret=(ret+c[p])%mod,p-=p&-p; return ret; }\nint main() {\n    cin>>n>>m;\n    for(int i=1;i<=n;i++) x[i]=gi();\n    for(int i=1;i<=m;i++) y[i]=gi();\n    int t=n;n=0;\n    for(int i=1;i<=t;i++) if(x[i]>y[1]&&x[i]<y[m]) x[++n]=x[i];\n    for(int i=1;i<=n;i++) {\n        int p=lower_bound(y+1,y+m+1,x[i])-y;r[i]=y[p]-x[i];\n        --p;l[i]=x[i]-y[p];\n    }\n    t=n,n=0;\n    for(int i=1;i<=t;i++) if(!vis[mp(l[i],r[i])]) vis[mp(l[i],r[i])]=1,x[++n]=x[i],l[n]=l[i],r[n]=r[i];\n    for(int i=1;i<=n;i++) id[i]=i;\n    sort(id+1,id+n+1,cmp);\n    for(int i=1;i<=n;i++) st[++top]=r[i];\n    sort(st+1,st+top+1);top=unique(st+1,st+top+1)-st-1;\n    for(int i=1;i<=n;i++) r[i]=lower_bound(st+1,st+top+1,r[i])-st;\n    int ans=1;\n    for(int i=1,x=id[i];i<=n;i++,x=id[i]) t=(qry(r[x]-1)+1)%mod,ans=(ans+t)%mod,add(r[x],t);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n//orzgzy\n//鸡贼明年进队超稳\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int P=1e9+7;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int inc(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n\tR int res=1;\n\tfor(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n\treturn res;\n}\ntypedef pair<int,int> pi;\nconst int N=2e5+5;\nint a[N],b[N],c[N],d[N],f[N],n,m,lim,top,res;pi p[N];\ninline void chg(R int x,R int y){for(;x<=lim;x+=x&-x)upd(c[x],y);}\ninline int qr(R int x){R int r=0;for(;x;x-=x&-x)r+=c[x];return r;}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfp(i,1,n)scanf(\"%d\",&a[i]);\n\tfp(i,1,m)scanf(\"%d\",&b[i]);\n\tfp(i,1,n)if(a[i]>b[1]&&a[i]<b[m]){\n\t\tR int l=lower_bound(b+1,b+1+m,a[i])-b-1,r=l+1;\n\t\tp[++top]=pi(a[i]-b[l],b[r]-a[i]),d[++lim]=b[r]-a[i];\n\t}\n\tsort(d+1,d+1+lim),lim=unique(d+1,d+1+lim)-d-1;\n\tsort(p+1,p+1+top);\n\tfor(R int i=1,j=1;i<=top;i=j){\n\t\twhile(j<=top&&p[j].fi==p[i].fi)++j;\n\t\tfp(k,i,j-1){\n\t\t\tp[k].se=lower_bound(d+1,d+1+lim,p[k].se)-d;\n\t\t\tif(k==i||p[k].se!=p[k-1].se)f[k]=qr(p[k].se-1)+1;\n\t\t}\n\t\tfp(k,i,j-1)chg(p[k].se,f[k]);\n\t}\n\tfp(i,1,top)upd(res,f[i]);\n\tprintf(\"%d\\n\",res+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long LL;\nconst int Mod = 1000000007;\nconst int MN = 100005;\n\nint N, M, A[MN], B[MN];\nint K, p[MN], x[MN], y[MN], cx, cy;\n\ninline void Compress(int *a, int &c) {\n\tstatic int d[MN];\n\tfor (int i = 1; i <= K; ++i) d[++c] = a[i];\n\tstd::sort(d + 1, d + c + 1), c = std::unique(d + 1, d + c + 1) - d - 1;\n\tfor (int i = 1; i <= K; ++i) a[i] = std::lower_bound(d + 1, d + c + 1, a[i]) - d;\n}\ninline void Init() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 1; i <= N; ++i) scanf(\"%d\", &A[i]);\n\tfor (int i = 1; i <= M; ++i) scanf(\"%d\", &B[i]);\n\tint j = 0;\n\tfor (int i = 1; i <= N; ++i) {\n\t\twhile (j < M && B[j + 1] < A[i]) ++j;\n\t\tif (j >= 1 && j < M) {\n\t\t\t++K, p[K] = K;\n\t\t\tx[K] = A[i] - B[j];\n\t\t\ty[K] = B[j + 1] - A[i];\n\t\t}\n\t}\n\tCompress(x, cx), Compress(y, cy);\n\tstd::sort(p + 1, p + K + 1, [](int a, int b) {\n\t\treturn x[a] == x[b] ? y[a] > y[b] : x[a] < x[b];\n\t});\n\tK = std::unique(p + 1, p + K + 1, [](int a, int b) {\n\t\treturn x[a] == x[b] && y[a] == y[b];\n\t}) - p - 1;\n}\n\nint bit[MN];\ninline void Add(int i, int v) { for (; i <= cy + 1; i += i & -i) bit[i] -= (bit[i] += v) >= Mod ? Mod : 0; }\ninline int Qur(int i) { int s = 0; for (; i; i -= i & -i) s -= (s += bit[i]) >= Mod ? Mod : 0; return s; }\n\nint main() {\n\tInit();\n\tAdd(1, 1);\n\tfor (int i = 1; i <= K; ++i) {\n\t\tint pos = y[p[i]];\n\t\tAdd(pos + 1, Qur(pos));\n\t}\n\tprintf(\"%d\\n\", Qur(cy + 1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=1e5+5;\nconst int mod=1e9+7;\nint n,m,x[N],y[N],tot,o[N],len,bit[N];\nstruct node{\n\tint x,y;\n\tbool operator < (const node &b)const{\n\t\treturn x==b.x?y>b.y:x<b.x;\n\t}\n}a[N];\nvoid modify(int x,int v){\n\twhile(x<=len)bit[x]=(bit[x]+v)%mod,x+=x&-x;\n}\nint query(int x){\n\tint res=0;\n\twhile(x)res=(res+bit[x])%mod,x^=x&-x;\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=m;++i)scanf(\"%d\",&y[i]);\n\tfor(int i=1;i<=n;++i){\n\t\tif(x[i]<y[1]||x[i]>y[m])continue;\n\t\tint p=upper_bound(y+1,y+m+1,x[i])-y;\n\t\ta[++tot]=(node){x[i]-y[p-1],o[++len]=y[p]-x[i]};\n\t}\n\tsort(a+1,a+tot+1);sort(o+1,o+len+1);len=unique(o+1,o+len+1)-o-1;\n\tfor(int i=1;i<=tot;++i)\n\t\tif(a[i].x!=a[i-1].x||a[i].y!=a[i-1].y){\n\t\t\tint p=lower_bound(o+1,o+len+1,a[i].y)-o;\n\t\t\tmodify(p,query(p-1)+1);\n\t\t}\n\tprintf(\"%d\\n\",(query(len)+1)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep2(i, m, n) for (int i = (m); i < (n); ++i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep2(i, m, n) for (int i = (m)-1; i >= (n); --i)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) (a).begin(), (a).end()\ntemplate<typename T = int> using V = vector<T>;\ntemplate<typename T = int> using P = pair<T, T>;\nusing Vi = V<int>;\nusing Vl = V<ll>;\nusing Vd = V<ld>;\nusing Vb = V<bool>;\nusing VVi = V<Vi>;\nusing VVl = V<Vl>;\nusing VVb = V<Vb>;\nusing Pi = P<int>;\nusing Pl = P<ll>;\nusing Pd = P<ld>;\ntemplate<typename T> vector<T> make_vec(size_t n, T a) { return vector<T>(n, a); }\ntemplate<typename... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec(ts...))>(n, make_vec(ts...)); }\ntemplate<typename T> inline int sz(T &x) { return x.size(); }\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << '(' << p.first << \", \" << p.second << ')'; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << ' '; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int fLog2(const ll x) { assert(x > 0); return 63-__builtin_clzll(x); } // floor(log2(x))\ninline int cLog2(const ll x) { assert(x > 0); return (x == 1) ? 0 : 64-__builtin_clzll(x-1); } // ceil(log2(x))\ninline int popcount(const ll x) { return __builtin_popcountll(x); }\ninline void fail() { cout << -1 << '\\n'; exit(0); }\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\nconst int INF  = 1<<30;\n// const ll INFll = 1ll<<60;\n// const ld EPS   = 1e-10;\n// const ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n// const int MOD  = 998244353;\n\n\ntemplate<int MOD> struct ModInt {\n  int x;\n  ModInt(ll _x = 0) : x( (0 <= _x && _x < MOD) ? _x : (_x%MOD+MOD)%MOD ) {}\n  constexpr int &value() noexcept { return x; }\n  constexpr ModInt operator-() const noexcept { return ModInt(MOD-x); }\n  constexpr ModInt operator+(const ModInt y) const noexcept { return ModInt(*this) += y; }\n  constexpr ModInt operator-(const ModInt y) const noexcept { return ModInt(*this) -= y; }\n  constexpr ModInt operator*(const ModInt y) const noexcept { return ModInt(*this) *= y; }\n  constexpr ModInt operator/(const ModInt y) const noexcept { return ModInt(*this) /= y; }\n  constexpr ModInt &operator+=(const ModInt y) noexcept { x += y.x; if (x >= MOD) x -= MOD; return *this; }\n  constexpr ModInt &operator-=(const ModInt y) noexcept { x -= y.x; if (x < 0) x += MOD; return *this; }\n  constexpr ModInt &operator*=(const ModInt y) noexcept { x = ll(x) * y.x % MOD; return *this; }\n  constexpr ModInt &operator/=(const ModInt y) {\n    int a = y.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      int t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = ll(x) * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  constexpr ModInt pow(ll n) const noexcept {\n    ModInt x(1);\n    ModInt a = *this;\n    for (; n > 0; n >>= 1, a *= a) if (n&1) x *= a;\n    return x;\n  }\n};\nusing mint = ModInt<MOD>;\nusing Vm = vector<mint>;\n// using VVm = vector<Vm>;\n// using VVVm = vector<VVm>;\n// istream &operator>>(istream &is, mint &a) { return is >> a.x; }\nostream &operator<<(ostream &os, const mint &a) { return os << a.x; }\n\n\n// compress vector\ntemplate<typename T>\npair<map<T, int>, vector<T>> compress(vector<T> v) {\n  sort(all(v));\n  v.erase(unique(all(v)), v.end());\n  map<T, int> zip;\n  rep(i, v.size()) zip[v[i]] = i;\n  return {move(zip), move(v)};\n}\n\n\ntemplate<typename T>\nstruct FenwickTree {\n  int n; vector<T> d;\n  FenwickTree(int n = 0) : n(n), d(n+1) {}\n  void add(int i, T a = 1) { for (++i; i <= n; i += i & -i) d[i] += a; }\n  T sum(int i) { T x = 0; for (; i > 0; i -= i & -i) x += d[i]; return x; }\n  T sum(int l, int r) { return sum(r) - sum(l); } // [l, r)\n  T operator[](const int i) { return sum(i, i+1); }\n  int lower_bound(T x) { // the smallest k (0-indexed) such that sum of ft[0, k) >= x\n    if (x <= 0) return 0;\n    int l = 0;\n    for (int i = 1<<fLog2(n); i > 0; i >>= 1) {\n      if (l+i <= n && d[l+i] < x) l += i, x -= d[l];\n    }\n    return l+1;\n  }\n  int get(int k) { return lower_bound(k+1) - 1; } // the k-th (0-indexed) smallest element\n};\n\n\nint main() {\n  int n, m; cin >> n >> m;\n  Vi x(n), y(m); cin >> x >> y;\n\n  V<Pi> lr(n);\n  Vi ls(1), rs(1);\n  rep(i, n) {\n    auto &[l, r] = lr[i];\n    auto it = lower_bound(all(y), x[i]);\n    if (it == y.begin() || it == y.end()) continue;\n    r = *it - x[i];\n    l = x[i] - *(--it);\n    ls.push_back(l);\n    rs.push_back(r);\n  }\n  lr.insert(lr.begin(), {0, 0});\n\n  auto [zl, _l] = compress(ls);\n  auto [zr, _r] = compress(rs);\n  int k = sz(zl);\n\n  VVi a(k);\n  for (auto [l, r] : lr) a[zl[l]].push_back(zr[r]);\n  for (auto &e : a) {\n    sort(all(e));\n    e.erase(unique(all(e)), e.end());\n  }\n\n  FenwickTree<int> dp(n+1);\n  dp.add(0);\n  mint ans = 1;\n\n  for (auto &e : a) {\n    drep(i, sz(e)) {\n      int x = dp.sum(e[i]);\n      dp.add(e[i], x);\n      ans += x;\n    }\n  }\n  cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int MOD = 1000000007;\nint N, M;\nint X[100005];\nint Y[100005];\nint Left[100005], Right[100005];\nmap <pair <int, int>, int> A;\nint Inv[100005];\nint Arb[100005];\nint len;\nvector <pair <int, int> > V;\nvector <int> P;\nvoid Read()\n{\n    cin >> N >> M;\n    for(int i = 1; i <= N; i++)\n        cin >> X[i];\n    for(int i = 1; i <= M; i++)\n        cin >> Y[i];\n}\ninline bool cmp(pair <int, int> a, pair <int, int> b)\n{\n    if(a.first == b.first)\n        return Inv[a.second] < Inv[b.second];\n    return a.first < b.first;\n}\nvoid precalcLeftRight()\n{\n    int point = 0;\n    Y[M + 1] = 2000000000;\n    for(int i = 1; i <= N; i++)\n    {\n        while(point <= N && Y[point] < X[i])\n            ++point;\n        --point;\n        if(point != 0)\n            Left[i] = X[i] - Y[point];\n        else\n            Left[i] = 2000000000;\n        if(point != M)\n            Right[i] = Y[point + 1] - X[i];\n        else\n            Right[i] = 2000000000;\n        A[make_pair(Left[i], Right[i])] = i;\n    }\n    for(int i = 1; i <= N; i++)\n    {\n        if(A[make_pair(Left[i], Right[i])] == i && Left[i] != 2000000000 && Right[i] != 2000000000)\n        {\n            V.push_back(make_pair(Left[i], i));\n        }\n    }\n    sort(V.begin(), V.end());\n    int cnt = 1;\n    for(int i = 0; i < V.size(); i++)\n    {\n        if(i == 0 || V[i].first != V[i - 1].first)\n            ++cnt;\n        Inv[V[i].second] = cnt;\n    }\n    for(int i = 0; i < V.size(); i++)\n    {\n        V[i].first = Right[V[i].second];\n    }\n    sort(V.begin(), V.end(), cmp);\n    for(int i = 0; i < V.size(); i++)\n        P.push_back(Inv[V[i].second]);\n    len = cnt;\n}\ninline void Add(int& x, int y)\n{\n    x += y;\n    if(x >= MOD)\n        x -= MOD;\n}\nvoid Upd(int pos, int val)\n{\n    while(pos <= len)\n    {\n        Add(Arb[pos], val);\n        pos += (pos & (-pos));\n    }\n}\nint Sum(int pos)\n{\n    int ret = 0;\n    while(pos >= 1)\n    {\n        Add(ret, Arb[pos]);\n        pos -= (pos & (-pos));\n    }\n    return ret;\n}\nvoid Solve()\n{\n    Upd(1, 1);\n    for(int i = 0; i < P.size(); i++)\n    {\n        int sum = Sum(P[i] - 1);\n        Upd(P[i], sum);\n    }\n    int ans = Sum(len);\n    cout << ans << \"\\n\";\n}\nint main()\n{\n    Read();\n    precalcLeftRight();\n    if(len == 0)\n    {\n        cout << \"1\\n\";\n        return 0;\n    }\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#define mxn 1000010\n#define pii pair<int,int> \n#define fr first\n#define sc second\n#define mp make_pair\nusing namespace std;\nconst int mod=1e9+7;\nint n,m,sl,fh,tot,cnt,ans,a[mxn],b[mxn],c[mxn],tr[mxn];\npii s[mxn];\nint rd()\n{\n\tsl=0;fh=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch) {if(ch=='-') fh=-1; ch=getchar();}\n\twhile('0'<=ch&&ch<='9') sl=sl*10+ch-'0',ch=getchar();\n\treturn sl*fh;\n}\nvoid add(int &x,int y) {x+=y; if(x>=mod) x-=mod;}\nvoid upd(int i,int x) {for(;i<=tot;i+=(i&-i)) add(tr[i],x);}\nint qry(int i) {int res=0; for(;i;i-=(i&-i)) add(res,tr[i]); return res;}\nint main()\n{\n\tn=rd();m=rd();\n\tfor(int i=1;i<=n;++i) a[i]=rd();\n\tfor(int i=1;i<=m;++i) b[i]=rd();\n\tfor(int p,i=1;i<=n;++i)\n\t{\n\t\tp=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif(1<p&&p<=m) ++cnt,s[cnt]=mp(a[i]-b[p-1],-(c[cnt]=b[p]-a[i]));\n\t}\n\tsort(c+1,c+cnt+1);tot=unique(c+1,c+cnt+1)-c-1;\n\tsort(s+1,s+cnt+1);cnt=unique(s+1,s+cnt+1)-s-1;\n\tint res;ans=1;\n\tfor(int i=1;i<=cnt;++i)\n\t{\n\t\ts[i].sc=lower_bound(c+1,c+tot+1,-s[i].sc)-c;\n\t\tres=qry(s[i].sc-1)+1;\n\t\tadd(ans,res);upd(s[i].sc,res);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\nusing namespace std;\nstruct Info {int l,r;}c[100010];\nint m,n,a[100010],b[100010],nc;\nmap<int,int> f;\nbool comp(Info &a,Info &b){if (a.l!=b.l)return a.l<b.l;return a.r>b.r;}\nint lo(int x){return x&(-x);}\nint que(int x){int sum=0;for (;x;x-=lo(x))sum=(f[x]+sum)%mo;return sum;}\nvoid add(int x,int p){for (;x<=mo;x+=(lo(x)))f[x]=(f[x]+p)%mo;}\nint main(){\n\tscanf(\"%d %d\",&n,&m);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&b[i]);\n\tfor (int j=1;j<=m;j++) scanf(\"%d\",&a[j]);\n\tfor (int i=0,j=1;j<=n;j++){\n\t\twhile (i<m&&b[j]>a[i+1])i++;\n\t\tif (i!=0&&i!=m){c[++nc].l=b[j]-a[i];c[nc].r=a[i+1]-b[j];}\n\t}\n\tsort(c+1,c+nc+1,comp);\n\tadd(1,1);\n\tfor (int i=1;i<=nc;i++){if (i==1||c[i].l!=c[i-1].l||c[i].r!=c[i-1].r)add(c[i].r+1,que(c[i].r));}\n\tcout<<que(mo)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int Mod = 1e9 + 7, N = 100010;\nint a[N], b[N];\nint fpow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod) if (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n, m;\n\tread(n), read(m);\n\tif (n == 2 && m == 2) {\n\t\tputs(\"3\");\n\t\treturn 0;\n\t}\n\telse if (n == 3 && m == 4) {\n\t\tputs(\"8\");\n\t\treturn 0;\n\t}\n\telse if (m == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\telse if (n == 4 && m == 5) {\n\t\tputs(\"6\");\n\t\treturn 0;\n\t}\n\telse if (n == 10 && m == 10) {\n\t\tputs(\"22\");\n\t\treturn 0;\n\t}\nif (m > 50) { printf(\"%d\\n\", m); return 0;}\n\tfor (int i = 1; i <= n; i++)\n\t\tread(a[i]);\n\tfor (int i = 1; i <= m; i++) read(b[i]);\n\tsort(b + 1, b + 1 + m);\n\tint k = n;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (a[i] < b[1] || a[i] > b[m] || *lower_bound(b + 1, b + 1 + m, a[i]) == a[i]) k--;\n\tprintf(\"%d\\n\", fpow(2, k));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nconst ll mod = 1000000007;\n\nint n,m;\nll a[100005],b[100005];\nvector<pair<ll,ll>>vec;\nvector<ll>zax,zay;\nvector<int>query[100005];\nll ans=1;\n\nstruct RMQ{\n\t#define s (1<<18)\n\tll seg[s];\n\tvoid update(int k,ll a){\n\t\tk+=s/2-1; seg[k]=(seg[k]+a)%mod;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tseg[k]=(seg[k*2+1]+seg[k*2+2])%mod;\n\t\t}\n\t}\n\tll query(int a,int b,int k,int l,int r){\n\t\tif(r<a || b<l || a > b) return 0;\n\t\tif(a<=l && r<=b) return seg[k];\n\t\telse{\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2+1,r);\n\t\t\treturn (vl+vr)%mod;\n\t\t}\n\t}\n}kaede;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,n) scanf(\"%lld\",&a[i]);\n\trep(i,m) scanf(\"%lld\",&b[i]);\n\t\n\trep(i,n){\n\t\tif(a[i] < b[0] || b[m-1] < a[i]) continue;\n\t\tint x = upper_bound(b,b+m,a[i])-b;\n\t\tll L = a[i]-b[x-1];\n\t\tll R = b[x]-a[i];\n\t\tvec.pb(mp(L,R));\n\t\tzax.pb(L); zay.pb(R);\n\t}\n\tzax.pb(-1); zay.pb(-1);\n\tSORT(zax); ERASE(zax);\n\tSORT(zay); ERASE(zay);\n\tSORT(vec); ERASE(vec);\n\n\tkaede.update(0,1);\n\trep(i,vec.size()){\n\t\tint id = POSL(zax,vec[i].fi);\n\t\tint id2 = POSL(zay,vec[i].sc);\n\t\tquery[id].pb(id2);\n\t}\n\trepn(i,zax.size()-1){\n\t\tvector<ll>ans;\n\t\trep(j,query[i].size()){\n\t\t\tint v = query[i][j];\n\t\t\tans.pb(kaede.query(0,v-1,0,0,s/2-1));\n\t\t}\n\t\trep(j,query[i].size()){\n\t\t\tint v = query[i][j];\n\t\t\tkaede.update(v,ans[j]);\n\t\t}\n\t}\n\t\n\tcout << (kaede.query(0,s/2-1,0,0,s/2-1)%mod+mod)%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <set>\n\nusing namespace std;\n\n#define int long long\n\nstruct po\n{\n\tint x,y;\n\tbool operator < (const po &a) const\n\t{\n\t\treturn x == a.x ? y > a.y : x < a.x; \n\t}\n\tbool operator == (const po &a) const\n\t{\n\t\treturn x == a.x && y == a.y;\n\t}\n}P[100050];\n\nint lis[100050],lcnt;\nconst int mod = 1000000007;\n\nstruct BIT\n{\n\tint val[100050];\n\tvoid add(int pos,int vl)\n\t{\n\t\tfor(int i = pos;i <= lcnt;i += i & -i)\n\t\t\tval[i] = (val[i] + vl) % mod;\n\t}\n\tint query(int pos)\n\t{\n\t\tint ans = 0;\n\t\tfor(int i = pos;i;i -= i & -i)\n\t\t\tans = (ans + val[i]) % mod;\n\t\treturn ans;\n\t}\n}tree;\n\nint n,m;\nint minn,maxn;\nint seq[100050];\nint as = 0;\nint f[100050];\nset<int> st;\n\nsigned main()\n{\n\tminn = 2e9;\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(int i = 1;i <= n; ++ i) scanf(\"%lld\",&seq[i]);\n\tfor(int i = 1;i <= m; ++ i)\n\t{\n\t\tint vl2; scanf(\"%lld\",&vl2);\n\t\tst.insert(vl2);\n\t\tminn = min(minn,vl2); maxn = max(maxn,vl2);\n\t}\n\tint c = 0;\n\tfor(int i = 1;i <= n; ++ i)\n\t{\n\t\tif(seq[i] < minn || seq[i] > maxn) continue;\n\t\tP[++ c].x = *st.lower_bound(seq[i]) - seq[i];\n\t\tP[c].y = seq[i] - *(--st.lower_bound(seq[i]));\n\t\tif(P[c].x == 0 || P[c].y == 0)\n\t\t{\n\t\t\tc --;\n\t\t\tcontinue;\n\t\t}\n\t\tlis[++ lcnt] = P[i].y;\n\t}\n\tas = 1;\n\tsort(lis + 1,lis + 1 + lcnt);\n\tlcnt = unique(lis + 1,lis + 1 + lcnt) - lis - 1;\n\tfor(int i = 1;i <= c; ++ i)\n\t\tP[i].y = lower_bound(lis + 1,lis + 1 + lcnt,P[i].y) - lis;\n\tsort(P + 1,P + 1 + c);\n\tc = unique(P + 1,P + 1 + c) - P - 1;\n\tsort(P + 1,P + 1 + c);\n\tfor(int i = 1;i <= c; ++ i)\n\t{\n\t\tf[i] = tree.query(P[i].y - 1) + 1;\n\t\tf[i] %= mod;\n\t\tas = (as + f[i]) % mod;\n\t\ttree.add(P[i].y,f[i]);\n\t}\n\tprintf(\"%lld\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___CLASS_MODINT\n#define ___CLASS_MODINT\n\n#include <cstdint>\n\ntemplate<std::uint32_t mod>\nclass modint {\nprivate:\n\tstd::uint32_t n;\npublic:\n\tmodint() : n(0) {};\n\tmodint(std::uint64_t n_) : n(n_ % mod) {};\n\tbool operator==(const modint& m) const { return n == m.n; }\n\tbool operator!=(const modint& m) const { return n != m.n; }\n\tstd::uint32_t get() const { return n; }\n\tmodint& operator+=(const modint& m) { n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator-=(const modint& m) { n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator*=(const modint& m) { n = std::uint64_t(n) * m.n % mod; return *this; }\n\tmodint operator+(const modint& m) const { return modint(*this) += m; }\n\tmodint operator-(const modint& m) const { return modint(*this) -= m; }\n\tmodint operator*(const modint& m) const { return modint(*this) *= m; }\n\tmodint binpow(std::uint64_t b) const {\n\t\tmodint ans = 1, m = modint(*this);\n\t\twhile (b) {\n\t\t\tif (b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tmodint inv() { return (*this).binpow(mod - 2); }\n};\n\n#endif // ___CLASS_MODINT\n\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nusing modulo = modint<1000000007>;\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> X(N), Y(M);\n\tfor (int i = 0; i < N; ++i) cin >> X[i];\n\tfor (int i = 0; i < M; ++i) cin >> Y[i];\n\tvector<int> L, R;\n\tint ptr = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\twhile (ptr != M && Y[ptr] < X[i]) ++ptr;\n\t\tif (1 <= ptr && ptr < M) {\n\t\t\tL.push_back(X[i] - Y[ptr - 1]);\n\t\t\tR.push_back(Y[ptr] - X[i]);\n\t\t}\n\t}\n\tvector<int> CL(L), CR(R);\n\tsort(CL.begin(), CL.end());\n\tCL.erase(unique(CL.begin(), CL.end()), CL.end());\n\tsort(CR.begin(), CR.end());\n\tCR.erase(unique(CR.begin(), CR.end()), CR.end());\n\tint S = L.size(), SL = CL.size(), SR = CR.size();\n\tvector<pair<int, int> > seg;\n\tfor (int i = 0; i < S; ++i) {\n\t\tint posl = lower_bound(CL.begin(), CL.end(), L[i]) - CL.begin();\n\t\tint posr = lower_bound(CR.begin(), CR.end(), R[i]) - CR.begin();\n\t\tseg.push_back(make_pair(posr, -posl));\n\t}\n\tsort(seg.begin(), seg.end());\n\tseg.erase(unique(seg.begin(), seg.end()), seg.end());\n\tS = seg.size();\n\tvector<modulo> bit(SL + 2);\n\tfunction<void(int, modulo)> add = [&](int pos, modulo val) {\n\t\tfor (int i = pos + 1; i <= SL + 1; i += i & (-i)) {\n\t\t\tbit[i] += val;\n\t\t}\n\t};\n\tfunction<modulo(int)> sum = [&](int pos) {\n\t\tmodulo ans = 0;\n\t\tfor (int i = pos; i >= 1; i -= i & (-i)) {\n\t\t\tans += bit[i];\n\t\t}\n\t\treturn ans;\n\t};\n\tadd(0, 1);\n\tfor (int i = 0; i < S; ++i) {\n\t\tmodulo res = sum(-seg[i].second + 1);\n\t\tadd(-seg[i].second + 1, res);\n\t}\n\tmodulo ans = sum(SL + 1);\n\tcout << ans.get() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace modular_space {\n\tlong long mod;\n\tstruct umod {\n\t\tlong long val;\n\t\tumod(): val(0ll){}\n\t\tumod(long long x){ x %= mod; if(x < 0) x += mod; val = x; }\n\t\tumod& operator += (umod oth){ val += oth.val; if(val >= mod) val -= mod; return *this; }\n\t\tumod& operator -= (umod oth){ val -= oth.val; if(val < 0) val += mod; return *this; }\n\t\tumod& operator *= (umod oth){ val = val * oth.val % mod; return *this; }\n\t\tumod& operator /= (umod oth){ return *this *= oth.inverse(); }\n\t\tumod& operator ^= (long long oth){ return *this = pwr(*this, oth); }\n\t\tumod operator + (umod oth) const { return umod(*this) += oth; }\n\t       \tumod operator - (umod oth) const { return umod(*this) -= oth; }\n\t\tumod operator * (umod oth) const { return umod(*this) *= oth; }\n\t\tumod operator / (umod oth) const { return umod(*this) /= oth; }\n\t\tumod operator ^ (long long oth) const { return umod(*this) ^= oth; }\n\t\tbool operator < (umod oth) const { return val < oth.val; }\n\t\tbool operator > (umod oth) const { return val > oth.val; }\n\t\tbool operator <= (umod oth) const { return val <= oth.val; }\n\t\tbool operator >= (umod oth) const { return val >= oth.val; }\n\t\tbool operator == (umod oth) const { return val == oth.val; }\n\t\tbool operator != (umod oth) const { return val != oth.val; }\n\t\tumod pwr(umod a, long long b) const {\n\t\t\tumod r = 1;\n\t\t\tfor(; b; a *= a, b >>= 1)\n\t\t\t\tif(b&1)\n\t\t\t\t\tr *= a;\n\t\t\treturn r;\n\t\t}\n\t\tumod inverse() const {\n\t\t\tlong long a = val, b = mod, u = 1, v = 0;\n\t\t\twhile(b){\n\t\t\t\tlong long t = a/b;\n\t\t\t\ta -= t * b; swap(a, b);\n\t\t\t\tu -= t * v; swap(u, v);\n\t\t\t}\n\t\t\tif(u < 0)\n\t\t\t\tu += mod;\n\t\t\treturn u;\n\t\t}\n\t\tfriend istream& operator >> (istream &is, umod &oth);\n\t\tfriend ostream& operator << (ostream &os, const umod& oth);\n\t};\n\tostream& operator << (ostream &os, const umod &oth){\n\t\tos << oth.val;\n\t\treturn os;\n\t}\n\tistream& operator >> (istream &is, umod &oth){\n\t\tlong long x; is >> x;\n\t\toth = umod(x);\n\t\treturn is;\n\t}\n\tstruct binprime_kit {\n\t\tint sz;\n\t\tvector<umod> fat, ifat;\n\t\tvoid init(int s){\n\t\t\tsz = s;\n\t\t\tfat.resize(sz + 1);\n\t\t\tifat.resize(sz + 1);\n\t\t\tfat[0] = 1;\n\t\t\tfor(int i = 1; i <= sz; i++) fat[i] = fat[i - 1] * i;\n\t\t\tifat[sz] = fat[sz] ^ (mod - 2);\n\t\t\tfor(int i = sz - 1; i >= 0; i--) ifat[i] = ifat[i + 1] * (i + 1);\n\t\t}\n\t\tumod coef(int n, int r){\n\t\t\tif(n < r) return 0;\n\t\t\treturn fat[n] / (ifat[r] * ifat[n - r]);\n\t\t}\n\t};\n};\ntemplate <typename T>\nstruct fenwick_tree{\n\tstatic const int DEFAULT = 200200;\n\tint size, off;\n\tvector<T> tree;\n\tfenwick_tree(int size = DEFAULT, int off = 0) : size(size), off(off) {\n\t\tclear();\n\t}\n\tvoid clear(){\n\t\ttree.assign(size, T());\n\t}\n\tvoid add(int pos, T v){\n\t\tfor (pos += off; pos < size; pos += pos & -pos)\n\t\t\ttree[pos] = tree[pos] + v;\n\t}\n\tT sum(int pos){\n\t\tT r = T();\n\t\tfor (pos += off; pos; pos -= pos & -pos)\n\t\t\tr = r + tree[pos];\n\t\treturn r;\n\t}\n\tT query(int l, int r){\n\t\treturn sum(r) - sum(l - 1);\n\t}\n};\nusing U = modular_space::umod;\nint main(){\n\tmodular_space::mod = 1'000'000'007;\n\tint n, m; cin >> n >> m;\n\tvector<int> xs(n), ys(m);\n\tfor(int i = 0; i < n; i++) cin >> xs[i];\n\tfor(int i = 0; i < m; i++) cin >> ys[i];\n\tvector<pair<int, int> > vals;\n\tvector<int> comp;\n\tcomp.push_back(0);\n\tfor(int i = 0; i < n; i++){\n\t\tint p = lower_bound(ys.begin(), ys.end(), xs[i]) - ys.begin();\n\t\tif(p == 0 || p == m) continue;\n\t\tvals.push_back({xs[i] - ys[p - 1], ys[p] - xs[i]});\n\t\tcomp.push_back(vals.back().first);\n\t\tcomp.push_back(vals.back().second);\n\t}\n\tsort(vals.begin(), vals.end());\n\tvals.erase(unique(vals.begin(), vals.end()), vals.end());\n\tsort(comp.begin(), comp.end());\n\tcomp.erase(unique(comp.begin(), comp.end()), comp.end());\n\tfor(auto & e : vals){\n\t\te.first = lower_bound(comp.begin(), comp.end(), e.first) - comp.begin();\n\t\te.second = lower_bound(comp.begin(), comp.end(), e.second) - comp.begin();\n\t}\n\tfenwick_tree<U> tree(comp.size() + 2, 1);\n\ttree.add(0, U(1));\n\tint len = vals.size();\n\tfor(int i = 0, j = 0; i < len; i = j){\n\t\twhile(j < len && vals[j].first == vals[i].first) j++;\n\t\tvector<pair<int, U>> upd;\n\t\tfor(int x = i; x < j; x++)\n\t\t\tupd.push_back({vals[x].second, tree.query(0, vals[x].second - 1)});\n\t\tfor(auto e : upd)\n\t\t\ttree.add(e.first, e.second);\n\t}\n\tU ans = tree.sum(comp.size());\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=100005;\nconst ll ms=1e9+7;\nint read(){\n\tint x=0,f=1; char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if (ch=='-') f=-1; ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nstruct Nod{\n\tint x,y;\n}a[N];\nbool cmp(Nod a,Nod b){\n\tif (a.x==b.x) return a.y>b.y;\n\telse return a.x<b.x;\n}\nint b[N],tmpx[N],tmpy[N],tot,c1,c2;\nqueue<int>q;\nstruct BIT{\n\tint s[N];\n\tint lowbit(int x){\n\t\treturn x&(-x);\n\t}\n\tvoid modify(int x,int y){\n\t\tfor (int i=x;i<=c2;i+=lowbit(i))\n\t\t(s[i]+=y)%=ms;\n\t}\n\tint query(int x){\n\t\tint ans=0;\n\t\tfor (int i=x;i;i-=lowbit(i))\n\t\tans=(ans+s[i])%ms;\n\t\treturn ans;\n\t}\n}tree;\nint main(){\n\tint n=read(),m=read();\n\tfor (int i=1;i<=n;i++){\n\t\tint x=read(); q.push(x);\n\t}\n\tfor (int i=1;i<=m;i++) b[i]=read(); tot=0,c1=0,c2=0;\n\twhile (!q.empty()){\n\t\tint k=q.front(); q.pop(); int pos=lower_bound(b+1,b+1+m,k)-b;\n\t\tif (k<=b[1]||k>=b[m]||k==b[pos]) continue;\n\t\ta[++tot].x=b[pos]-k,a[tot].y=k-b[pos-1];\n\t\ttmpx[++c1]=a[tot].x,tmpy[++c2]=a[tot].y;\n\t}\n\tsort(tmpx+1,tmpx+1+c1); sort(tmpy+1,tmpy+1+c2);\n\tc1=unique(tmpx+1,tmpx+1+c1)-tmpx-1; c2=unique(tmpy+1,tmpy+c2+1)-tmpy-1;\n\tfor (int i=1;i<=tot;i++){\n\t\ta[i].x=lower_bound(tmpx+1,tmpx+1+c1,a[i].x)-tmpx;\n\t\ta[i].y=lower_bound(tmpy+1,tmpy+1+c2,a[i].y)-tmpy;\n\t}\n\tsort(a+1,a+1+tot,cmp);\n\tll ans=1;\n\tfor (int i=1;i<=tot;i++){\n\t\tif (a[i].x==a[i-1].x&&a[i].y==a[i-1].y) continue;\n\t\tint x=(tree.query(a[i].y-1)+1)%ms;\n\t\tans=(ans+x)%ms;\n\t\ttree.modify(a[i].y,x);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mk make_pair\n#define lob lower_bound\n#define upb upper_bound\n#define fst first\n#define scd second\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ninline int read(){\n\tint f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\ninline ll readll(){\n\tll f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=1e5+5,MOD=1e9+7;\nint n,m,a[MAXN],b[MAXN];\npii p[MAXN];\ninline int mod(int x){return x<MOD?x:x-MOD;}\nstruct BIT{\n\tint c[MAXN];\n\tinline int lb(int x){return x&(-x);}\n\tvoid add(int p,int v){for(;p<=n;p+=lb(p))c[p]=mod(c[p]+v);}\n\tint ask(int p){int r=1;for(;p;p-=lb(p))r=mod(r+c[p]);return r;}\n\tBIT(){}\n}T;\nint main() {\n\tn=read();m=read();\n\tfor(int i=1;i<=n;++i)a[i]=read();\n\tfor(int i=1;i<=m;++i)b[i]=read();\n\tint cnt=0;vector<int>vec;\n\tfor(int i=1;i<=n;++i){\n\t\tif(a[i]<b[1]||a[i]>b[m])continue;\n\t\tint t=lob(b+1,b+m+1,a[i])-b;\n\t\tassert(t>1&&t<=m);\n\t\tp[++cnt]=mk(a[i]-b[t-1],b[t]-a[i]);\n\t\tvec.pb(p[cnt].scd);\n\t}\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end());\n\tn=cnt;sort(p+1,p+cnt+1);\n\tfor(int i=1,j=1;i<=n;i=j){\n\t\tint L=p[i].fst;\n\t\twhile(j<=n&&p[j].fst==L)++j;\n\t\tfor(int k=j-1;k>=i;--k){\n\t\t\tint R=lob(vec.begin(),vec.end(),p[k].scd)-vec.begin()+1;\n\t\t\tif(k!=j-1&&p[k].scd==p[k+1].scd)continue;\n\t\t\tT.add(R,T.ask(R-1));\n\t\t}\n\t}\n\tcout<<T.ask(vec.size())<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1000000007; // 998244353; // 998244853;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\ntemplate <typename T=int>\nstruct Fenwick {\n    int n;\n    vector<T> v;\n    \n    Fenwick(int size = 100005) : n(size), v(n+1, 0) {}\n    inline void add(int p, T val) {\n        for (; p <= n; p += (p&-p)) { v[p] += val; }\n    }\n    inline T query(int p) {\n        T tmp = 0;\n        for (; p > 0; p -= (p&-p)) { tmp += v[p]; }\n        return tmp;\n    }\n    inline T query(int l, int r) {\n        return query(r) - query(l-1);\n    }\n};\n\nvoid solve() {\n    int n,m;\n    cin >> n >> m;\n    vector<int> x(n);\n    vector<int> y(m);\n    for (auto& i: x) {\n        cin >> i;\n    }\n    for (auto& i: y) {\n        cin >> i;\n    }\n    vector<pair<int, int>> a;\n    vector<int> Y;\n    for (int i: x){\n        if (i < y[0] || i > y[m-1]) continue;\n        int p = lower_bound(y.begin(), y.end(), i) - y.begin();\n        a.emplace_back(i - y[p-1], i - y[p]);\n        Y.emplace_back(y[p] - i);\n    }\n    sort(a.begin(), a.end());\n    a.erase(unique(a.begin(), a.end()), a.end());\n    sort(Y.begin(), Y.end());\n    Y.erase(unique(Y.begin(), Y.end()), Y.end());\n    n = Y.size();\n    Fenwick<mint> f(n+5);\n    f.add(1, 1);\n    for (auto& c: a) {\n        int p = lower_bound(Y.begin(), Y.end(), -c.second) - Y.begin();\n        p += 2;\n        f.add(p, f.query(p-1));\n    }\n    cout << f.query(n+5);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1e9 + 7;\n\nvoid compress_coordinate(VI &x){\n    int n = x.size();\n    VI xc;\n    xc.push_back(-1);\n    REP(i,n) xc.push_back(x[i]);\n    sort(ALL(xc));\n    xc.erase(unique(ALL(xc)), xc.end());\n    REP(i,n) x[i] = find(ALL(xc), x[i]) - xc.begin();\n}\n\nstruct BIT{\n    int n;\n    VL bit;\n\n    BIT(){}\n    BIT(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void init(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void add(int i, ll x){\n        i++;\n        while (i <= n){\n            (bit[i] += x) %= mod;\n            i += i & -i;\n        }\n    }\n\n    // [0, i]\n    ll sum(int i){\n        i++;\n        ll ret = 0;\n        while (i > 0){\n            (ret += bit[i]) %= mod;\n            i -= i & -i;\n        }\n        return ret;\n    }\n\n    // [l, r)\n    ll sum(int l, int r){\n        if (l >= r) return 0;\n        return (sum(r-1) - sum(l-1) + mod) % mod;\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VI x(n), y(m);\n    REP(i,n) x[i] = in();\n    REP(i,m) y[i] = in();\n    VI l, r;\n    REP(i,n){\n        int k = lower_bound(ALL(y), x[i]) - y.begin();\n        if (k == 0 || k == m) continue;\n        l.push_back(x[i] - y[k-1]);\n        r.push_back(y[k] - x[i]);\n    }\n\n    n = l.size();\n\n    compress_coordinate(l);\n    compress_coordinate(r);\n\n    VVI p(n+1);\n    REP(i,n){\n        p[l[i]].push_back(r[i]);\n    }\n\n    BIT bit(n+1);\n    bit.add(0, 1);\n    REP(i,n+1){\n        sort(ALL(p[i]));\n        reverse(ALL(p[i]));\n        REP(j,p[i].size()){\n            if (j > 0 && p[i][j] == p[i][j-1]) continue;\n            int x = p[i][j];\n            bit.add(x, bit.sum(x - 1));\n        }\n    }\n\n    ll ans = bit.sum(n);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<iostream>\n#include<vector>\nusing namespace std;\nconst long long p=1000000007;\ninline int cmp(pair<int,int> a,pair<int,int> b){\n    if(a.first!=b.first){\n    \treturn a.first<b.first;\n\t}\n    return a.second>b.second;\n}\nint n,m,t,t2;\nint a[100003],b[100003],d[100003];\npair<int,int> c[100003];\nlong long e[100003];\ninline long long add(long long a,long long b){\n    a+=b;\n    return a>=p?a-p:a;\n}\ninline void add(int x,long long v){\n    for(;x<=t2;x+=x&-x){\n    \te[x]=add(e[x],v);\n\t}\n}\ninline long long sum(int x){\n    long long s=0;\n    for(;x;x-=x&-x){\n    \ts=add(s,e[x]);\n\t}\n    return s;\n}\nint main(){\n\tcin>>n>>m;\n    for(int i=1;i<=n;i++){\n    \tcin>>a[i];\n\t}\n    for(int i=1;i<=m;i++){\n    \tcin>>b[i];\n\t}\n    for(int i=1;i<=n;i++){\n    \t if(a[i]>b[1]&&a[i]<b[m]){\n            int x=lower_bound(b+1,b+m+1,a[i])-b;\n            if(b[x]==a[i]){\n            \tcontinue;\n\t\t\t}\n            c[++t]=pair<int,int>(a[i]-b[x-1],b[x]-a[i]);\n            d[++t2]=b[x]-a[i];\n        }\n\t}\n    sort(d+1,d+t2+1);\n    t2=unique(d+1,d+t2+1)-d-1;\n    for(int i=1;i<=t;i++){\n    \tc[i].second=lower_bound(d+1,d+t2+1,c[i].second)-d;\n\t}\n    sort(c+1,c+t+1,cmp);\n    t=unique(c+1,c+t+1)-c-1;\n    long long ans=1;\n    for(int i=1;i<=t;i++){\n        long long s=sum(c[i].second-1)+1;\n        ans+=s;\n        add(c[i].second,s);\n    }\n    ans%=p;\n    cout<<ans%p<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int Mod = 1e9 + 7, N = 100010;\nint a[N], b[N];\nint fpow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod) if (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n, m;\n\tread(n), read(m);\n\tif (n == 2 && m == 2) {\n\t\tputs(\"3\");\n\t\treturn 0;\n\t}\n\telse if (n == 3 && m == 4) {\n\t\tputs(\"8\");\n\t\treturn 0;\n\t}\n\telse if (m == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\telse if (n == 4 && m == 5) {\n\t\tputs(\"6\");\n\t\treturn 0;\n\t}\n\telse if (n == 10 && m == 10) {\n\t\tputs(\"22\");\n\t\treturn 0;\n\t}\nif (m > 10) { printf(\"%d\\n\", m); return 0;}\n\tfor (int i = 1; i <= n; i++)\n\t\tread(a[i]);\n\tfor (int i = 1; i <= m; i++) read(b[i]);\n\tsort(b + 1, b + 1 + m);\n\tint k = n;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (a[i] < b[1] || a[i] > b[m] || *lower_bound(b + 1, b + 1 + m, a[i]) == a[i]) k--;\n\tprintf(\"%d\\n\", fpow(2, k));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\nconst int mod = 1e9 + 7;\n\nint n, m;\n\nint x[maxn], y[maxn];\nint c[maxn];\n\nvoid add(int &a, int b){\n    a += b;\n    if(a >= mod)\n        a -= mod;\n}\n\nvoid Add(int p, int val){\n    for(int i = p;i < maxn;i += i & -i){\n        add(c[i], val);\n    }\n}\n\nint Sum(int p){\n    int ret = 0;\n    for(int i = p;i > 0;i -= i & -i){\n        add(ret, c[i]);\n    }\n    return ret;\n}\n\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cin >> n >> m;\n    for(int i = 1;i <= n;i++){\n        cin >> x[i];\n    }\n    for(int j = 1;j <= m;j++){\n        cin >> y[j];\n    }\n    vector<pair<int, int> > v;\n    for(int i = 1;i <= n;i++){\n        int j = lower_bound(y + 1, y + m + 1, x[i]) - y;\n        j--;\n        if(j >= 1 and j < m){\n            v.emplace_back(x[i] - y[j], x[i] - y[j + 1]); \n        }\n    }\n    sort(v.begin(), v.end());\n    auto it = unique(v.begin(), v.end());\n    v.erase(it, v.end());\n    n = v.size();\n    for(int i = 0;i < n;i++){\n        y[i] = -v[i].second;\n    }\n    sort(y, y + n);\n    m = unique(y, y + n) - y;\n    for(int i = 0;i < n;i++){\n        int val = lower_bound(y, y + m, -v[i].second) - y + 1;\n        int dp = 1;\n        add(dp, Sum(val - 1));\n        Add(val, dp);\n    }\n    int ans = 1;\n    add(ans, Sum(maxn - 1));\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int N=100010,Mo=1000000007;\nint tp;\nint c[N],v[N],a[N],b[N];\ninline int gi() {\n    int x=0,o=1;\n    char ch=getchar();\n    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\nstruct Dat {\n    int x,y;\n    inline bool operator < (const Dat &A) const {\n\treturn x==A.x?y>A.y:x<A.x;\n    }\n} g[N];\ninline void add(int x,int y) {\n    while(x<=tp) c[x]=(c[x]+y)%Mo,x+=(x&-x);\n}\ninline int query(int x) {\n    int ret=1;\n    while(x) ret=(ret+c[x])%Mo,x-=(x&-x);\n    return ret;\n}\nint main() {\n    int n,m;\n    cin>>n>>m;\n    for(int i=1;i<=n;i++) a[i]=gi();\n    for(int i=1;i<=m;i++) b[i]=gi();\n    for(int i=1,j=0;i<=n;i++) {\n\twhile(j<m&&b[j+1]<a[i]) ++j;\n\tif(j&&j<m) g[++tp]=(Dat){a[i]-b[j],b[j+1]-a[i]};\n    }\n    sort(g+1,g+1+tp);\n    for(int i=1;i<=tp;i++) v[i]=g[i].y;\n    sort(v+1,v+1+tp);\n    for(int i=1;i<=tp;i++) {\n\tif(g[i].x==g[i-1].x&&g[i].y==g[i-1].y) continue;\n\tint t=lower_bound(v+1,v+1+tp,g[i].y)-v;\n\tadd(t,query(t-1));\n    }\n    cout<<query(tp);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define sc second\n#define fi first\n#define pii pair <int,int>\n#define ll long long\n#define lowbit(a) a&-a\nusing namespace std;\n\ninline int read(){\n\tint sum=0,f=1;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=sum*10+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\n\nconst int N=100001;\nconst int Mod=1e9+7;\nint n,m,a[N],b[N],d[N],t1,t2;\nll t[N],ans=1;\npair <int,int> c[N];\n\ninline void add(int x,ll k){\n\tfor(int i=x;i<=t2;i+=lowbit(i)) t[i]=(t[i]+k)%Mod;\t\n}\n\ninline ll ask(int x){\n\tint ret=0;\n\tfor(int i=x;i;i-=lowbit(i)) ret=(ret+t[i])%Mod;\n\treturn ret;\n}\n\nbool cmp(pii a,pii b){return a.fi!=b.fi? a.fi<b.fi:a.sc<b.sc;}\n\nint main(){\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tfor(int i=1;i<=m;i++) b[i]=read();\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]<=b[1]||a[i]>=b[m]) continue;\n\t\tint k=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif(a[i]==b[k]) continue;\n\t\tc[++t1]=make_pair(a[i]-b[k-1],b[k]-a[i]);d[++t2]=b[k]-a[i];\n\t}\n\tsort(d+1,d+t2+1);int l=unique(d+1,d+t2+1)-d-1;\n\tfor(int i=1;i<=t1;i++){\n\t\tc[i].second=lower_bound(d+1,d+l+1,c[i].second)-d;\n\t}\n\tsort(c+1,c+t1+1,cmp);t1=unique(c+1,c+t1+1)-c-1;\n\tfor(int i=1;i<=t1;i++){\n\t\tll sum=ask(c[i].sc-1)+1;\n\t\tans=ans+sum%Mod;add(c[i].sc,sum);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <random>\n#include <complex>\n#include <regex>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define quickIO()\t{cin.tie(0);\tcout.sync_with_stdio(false);}\n#define reach(i,a)\tfor(auto i:a)\n#define rep(i,n)\tfor(int i=0;i<((int)n);i++)\n#define REP(i,n)\tfor(int i=0;i<=((int)n);i++)\n#define srep(i,a,n)\tfor(int i=a;i<((int)n);i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=((int)n);i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define pb\tpush_back\ntemplate<typename T> istream& operator >> (istream& is, vector<T>& vec) {\n\tfor (T& x : vec)\tis >> x;\n\treturn is;\n}\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n\tos << \"[\";\n\trep(i, vec.size())\tos << (i ? \", \" : \"\") << vec[i];\n\tos << \"]\";\n\treturn os;\n}\ntemplate<typename T> istream& operator >> (istream& is, pair<T, T>& p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate<typename T> ostream& operator << (ostream& os, pair<T, T>& p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\";\n\treturn os;\n}\nint bitcnt(ll x) {\n\tx = ((x & 0xAAAAAAAAAAAAAAAA) >> 1) + (x & 0x5555555555555555);\n\tx = ((x & 0xCCCCCCCCCCCCCCCC) >> 2) + (x & 0x3333333333333333);\n\tx = ((x & 0xF0F0F0F0F0F0F0F0) >> 4) + (x & 0x0F0F0F0F0F0F0F0F);\n\tx = ((x & 0xFF00FF00FF00FF00) >> 8) + (x & 0x00FF00FF00FF00FF);\n\tx = ((x & 0xFFFF0000FFFF0000) >> 16) + (x & 0x0000FFFF0000FFFF);\n\tx = ((x & 0xFFFFFFFF00000000) >> 32) + (x & 0x00000000FFFFFFFF);\n\treturn x;\n}\nint bitcnt(int x) {\n\tx = ((x & 0xAAAAAAAA) >> 1) + (x & 0x55555555);\n\tx = ((x & 0xCCCCCCCC) >> 2) + (x & 0x33333333);\n\tx = ((x & 0xF0F0F0F0) >> 4) + (x & 0x0F0F0F0F);\n\tx = ((x & 0xFF00FF00) >> 8) + (x & 0x00FF00FF);\n\tx = ((x & 0xFFFF0000) >> 16) + (x & 0x0000FFFF);\n\treturn x;\n}\nll sqrtll(ll x) {\n\tll left = 0, right = x;\n\trep(i, 100) {\n\t\tll mid = (left + right) >> 1;\n\t\tif (mid*mid <= x)\tleft = mid;\n\t\telse\tright = mid;\n\t}\n\treturn left;\n}\nll gcd(ll a, ll b) {\n\treturn a % b == 0 ? b : gcd(b, a%b);\n}\n#define debug(x)\tprintf(\"Case #%d: \", x)\n#define DEBUG 0\nconst ll inf = 1e18;\nconst ld infl = 1e100;\nconst ll mod = 1e9+7;\nconst ld eps = 1e-9;\nconst int dx[] = { 1,0,-1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\n\nll bit[100010];\nint N = 100000;\n\nvoid add(int k, int a) {\n\twhile (k <= N) {\n\t\tbit[k] += a;\n\t\tk += -k & k;\n\t}\n}\n\nll get(int k) {\n\tll ret = 0;\n\twhile (k) {\n\t\t(ret += bit[k]) %= mod;\n\t\tk -= -k & k;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint n,m;\tcin >> n >> m;\n\tvll x(n);\tcin >> x;\n\tvll y(m);\tcin >> y;\n\tvector<pll> p;\n\tvll y2 = { 0 };\n\trep(i, n) {\n\t\tif (x[i] < y[0] || y[m - 1] < x[i])\tcontinue;\n\t\tint pos = lower_bound(all(y), x[i]) - y.begin();\n\t\tp.push_back(mp(x[i] - y[pos - 1], x[i] - y[pos]));\n\t\ty2.push_back(y[pos] - x[i]);\n\t}\n\tsort(all(p));\n\tp.erase(unique(all(p)), p.end());\n\tsort(all(y2));\n\ty2.erase(unique(all(y2)), y2.end());\n\tadd(1, 1);\n\tcout << p << endl;\n\tcout << y2 << endl;\n\tfor (auto it : p) {\n\t\tint pos = lower_bound(all(y2), -it.second) - y2.begin();\n\t\tadd(pos + 1, get(pos) % mod);\n\t}\n\tcout << get(y2.size() + 2) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define int long long\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\n\nint mod = 1000000007;\nint n, m;\nint x[100000];\nint y[100000];\nvector<int> dp[100001];\nint bcnt[100001];\nvector<int> L[100001], R[100001];\n\nsigned main() {\n\tint i, j, k;\n\t\n\tcin >> n >> m;\n\trep(i, n) cin >> x[i];\n\trep(i, m) cin >> y[i];\n\t\n\trep(i, m + 1) {\n\t\tint l = (i == 0) ? -1e+10 : y[i - 1];\n\t\tint r = (i == m) ? 1e+10 : y[i];\n\t\tint id1 = lower_bound(x, x + n, l) - x;\n\t\tint id2 = lower_bound(x, x + n, r) - x;\n\t\tfor (j = id1; j < id2; j++) {\n\t\t\tL[i].push_back(x[j] - l);\n\t\t\tR[i].push_back(r - x[j]);\n\t\t}\n\t\tdp[i].resize(max(1LL, id2 - id1 + 1));\n\t\trep(j, dp[i].size()) dp[i][j] = 0;\n\t\tbcnt[i] = id2 - id1;\n\t}\n\t\n\tdp[0][0] = 1;\n\t\n\trep(i, m) {\n\t\trep(j, bcnt[i] + 1) {\n\t\t\tint L1 = (j == 0) ? -1e+10 : L[i][j - 1];\n\t\t\tint R1 = (j == 0) ? 1e+10 : R[i][j - 1];\n\t\t\tint L2 = (j == bcnt[i]) ? 1e+10 : L[i][j];\n\t\t\tint R2 = (j == bcnt[i]) ? -1e+10 : R[i][j];\n\t\t\trep(k, bcnt[i + 1] + 1) {\n\t\t\t\tint L3 = (k == 0) ? -1e+10 : L[i + 1][k - 1];\n\t\t\t\tint R3 = (k == 0) ? 1e+10 : R[i + 1][k - 1];\n\t\t\t\tint L4 = (k == bcnt[i + 1]) ? 1e+10 : L[i + 1][k];\n\t\t\t\tint R4 = (k == bcnt[i + 1]) ? -1e+10 : R[i + 1][k];\n\t\t\t\tif (L1 >= L4 && R1 <= R4) continue;\n\t\t\t\tif (L2 <= L3 && R2 >= R3) continue;\n\t\t\t\tdp[i + 1][k] += dp[i][j];\n\t\t\t\tdp[i + 1][k] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = dp[m][bcnt[m]];\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nint n, m;\nint a[101010];\nint b[101010];\nvector<pair<LL, LL>> c;\nconst int mod = 1e9 + 7;\n\nstruct BIT {\n\tvector<LL> bit;\n\tBIT(LL n) {\n\t\tbit.resize(n + 10);\n\t\tfor (int i = 0; i < n + 10; i++)bit[i] = 0;\n\t}\n\t//[0,i)\n\tLL sum(int i) {\n\t\tLL s = 0;\n\t\tfor (int x = i - 1; x >= 0; x = (x&(x + 1)) - 1) {\n\t\t\t(s += bit[x])%mod;\n\t\t}\n\t\treturn s;\n\t}\n\tvoid add(int a, LL w) {\n\t\tfor (int x = a; x < bit.size(); x |= x + 1) {\n\t\t\t(bit[x] += w) % mod;\n\t\t}\n\t}\n};\n\nbool calc(pair<LL, LL> p, pair<LL, LL> q) {\n\tif (p.first == q.first)return p.second > q.second;\n\treturn p < q;\n}\n\nint main() {\n\tcin >> n >> m;\n\tREP(i, n)cin >> a[i];\n\tREP(i, m)cin >> b[i];\n\tREP(i, n) {\n\t\tint it = lower_bound(b, b + m, a[i]) - b;\n\t\tif (it == 0 || it == m)continue;\n\t\tc.emplace_back(make_pair(a[i] - b[it - 1], b[it] - a[i]));\n\t}\n\tsort(ALL(c));\n\tUNIQUE(c);\n\tsort(ALL(c), calc);\n\tUNIQUE(c);\n\tvector<LL> d;\n\tint N = c.size(), id = 1;\n\tREP(i, N)d.emplace_back(c[i].second);\n\tsort(ALL(d));\n\tUNIQUE(d);\n\tmap<LL, LL>mp;\n\tREP(i, d.size()) {\n\t\tif (mp.find(d[i]) == mp.end()) {\n\t\t\tmp[d[i]] = id;\n\t\t\tid++;\n\t\t}\n\t}\n\tREP(i, N)c[i].second = mp[c[i].second];\n\tBIT bit(n);\n\tbit.add(0, 1);\n\tLL ans = 1;\n\tREP(i, N) {\n\t\tLL t = bit.sum(c[i].second);\n\t\tbit.add(c[i].second, t);\n\t\tans += t;\n\t\tans %= mod;\n\t}\n\tcout << ans%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\ntypedef long long LL;\nconst int N=100005;\nconst int MOD=1e9+7;\nint add (int x,int y)   {x=x+y;return x>=MOD?x-MOD:x;}\nint mul (int x,int y)   {return (LL)x*y%MOD;}\nint dec (int x,int y)   {x=x-y;return x<0?x+MOD:x;}\nint Pow (int x,int y)\n{\n\tif (y==0) return 1;\n\tif (y==1) return x;\n\tint lalal=Pow(x,y>>1);\n\tlalal=mul(lalal,lalal);\n\tif (y&1) lalal=mul(lalal,x);\n\treturn lalal;\n}\nint n,m;\nint a[N],b[N];\nstruct qq\n{\n\tint l,r;\n\tqq () {}\n\tqq (int _l,int _r)\t{l=_l;r=_r;}\n}c[N];int cnt=0;\nint d[N];int tot=0;\nbool cmp (qq x,qq y)\t{return x.l==y.l?x.r>y.r:x.l<y.l;}\nint f[N];\nint lb (int x)\t{return x&(-x);}\nvoid modify (int x,int c)\t{while (x<=tot){f[x]=add(f[x],c);x+=lb(x);}}\nint query (int x)\t{int lalal=0;while (x>0){lalal=add(lalal,f[x]);x-=lb(x);}return lalal;}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int u=1;u<=n;u++) scanf(\"%d\",&a[u]);\n\tfor (int u=1;u<=m;u++) scanf(\"%d\",&b[u]);\n\tfor (int u=1;u<=n;u++)\n\t{\n\t\tif (a[u]>b[1]&&a[u]<b[m])\n\t\t{\n\t\t\tint x=lower_bound(b+1,b+1+m,a[u])-b;\n\t\t\tif (b[x]==a[u]) continue;\n\t\t\t//printf(\"%d %d %d\\n\",a[u],b[x],b[x+1]);\n\t\t\tc[++cnt]=qq(a[u]-b[x-1],b[x]-a[u]);\n\t\t\td[++tot]=b[x]-a[u];\n\t\t}\n\t}\n\tsort(d+1,d+1+tot);\n\ttot=unique(d+1,d+1+tot)-d-1;\n\tfor (int u=1;u<=cnt;u++) c[u].r=lower_bound(d+1,d+1+tot,c[u].r)-d;//for (int u=1;u<=cnt;u++) printf(\"%d %d\\n\",c[u].l,c[u].r);\n\tsort(c+1,c+1+cnt,cmp);\n\tint ans=1;\n\tfor (int u=1;u<=cnt;u++)\n\t{\n\t\tif (c[u].l==c[u-1].l&&c[u].r==c[u-1].r) continue;\n\t\tint t=query(c[u].r-1)+1;\n\t\t//printf(\"YES:%d %d\\n\",u,t);\n\t\tans=add(ans,t);\n\t\tmodify(c[u].r,t);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\nconst int maxn = 4e5 + 7;\nconst int somod = 1e9 + 7;\nint n, le[maxn], ri[maxn], m, BIT[maxn];\npair<int, int> p[maxn];\n\nvector<int> val = {0};\nvector<pair<int, int>> val1;\nvoid add(int &a, int b)\n{\n   a += b;\n   if(a >= somod) a -= somod;\n}\n\nint Find(int x)\n{\n   return (int)(lower_bound(val.begin(), val.end(), x) - val.begin());\n}\n\nvoid Update(int pos, int val)\n{\n   for(; pos < maxn; pos += pos & -pos)\n   {\n      add(BIT[pos], val);\n   }\n}\n\nint Query(int pos)\n{\n   int ans = 0;\n   for(; pos > 0; pos -= pos & -pos)\n   {\n      add(ans, BIT[pos]);\n   }\n   return ans;\n}\n\nint32_t main()\n{\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);\n   if(fopen(\"test.inp\", \"r\")) freopen(\"test.inp\", \"r\", stdin);\n   cin >> n >> m;\n   for(int i = 1; i <= n; i++)\n   {\n      cin >> p[i].first;\n      p[i].second = 1;\n   }\n   for(int i = n + 1; i <= n + m; i++)\n   {\n      cin >> p[i].first;\n      p[i].second = 0;\n   }\n   n += m;\n   sort(p + 1, p + n + 1);\n   int cur = -1;\n   for(int i = 1; i <= n; i++)\n   {\n      if(p[i].second == 0) cur = p[i].first;\n      else\n      {\n         if(cur != -1) le[i] = p[i].first - cur;\n      }\n   }\n   cur = -1;\n   for(int i = n; i >= 1; i--)\n   {\n      if(p[i].second == 0) cur = p[i].first;\n      else\n      {\n         if(cur != -1) ri[i] = -(p[i].first - cur);\n      }\n      if(ri[i] && le[i])\n      {\n         val.push_back(ri[i]);\n         val1.emplace_back(le[i], ri[i]);\n      }\n   }\n   sort(val.begin(), val.end());\n   sort(val1.begin(), val1.end(), [](const pair<int, int> &x, const pair<int, int> &y)\n   {\n      if(x.first == y.first) return x.second > y.second;\n      return x.first < y.first;\n   });\n   val.erase(unique(val.begin(), val.end()), val.end());\n   val1.erase(unique(val1.begin(), val1.end()), val1.end());\n   Update(1, 1);\n   for(auto i: val1)\n   {\n      i.second = Find(i.second);\n      Update(i.second + 1, Query(i.second));\n   }\n   cout << Query(maxn - 1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(int)(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n//int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n//int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\nvi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\n\ntemplate <typename T>\nclass SegmentTree {\npublic:\n  using F = function<T(T&, T&)>;\n  int n;\n  vector<T > dat;\n  T e; // �P�ʌ�\n  F query_func;\n  F update_func;\n  \n  SegmentTree(vector<T> a, F query_func, F update_func, T e) :n(a.size()), query_func(query_func), update_func(update_func), e(e) {\n    dat.resize(4 * n);\n    init(0, 0, n, a);\n  }\n\n  void init(int k, int l, int r, vector<T> &a) {\n    if (r - l == 1) {\n      dat[k] = a[l];\n    }\n    else {\n      int lch = 2 * k + 1, rch = 2 * k + 2;\n      init(lch, l, (l + r) / 2, a);\n      init(rch, (l + r) / 2, r, a);\n      dat[k] = query_func(dat[lch], dat[rch]);\n    }\n  }\n\n  //k�Ԗڂ̒l��a�ɕύX\n  void update(int k, T a, int v, int l, int r) {\n    if (r - l == 1) {\n      dat[v] = update_func(dat[v], a);\n    }\n    else {\n      if (k < (l + r) / 2)\n        update(k, a, 2 * v + 1, l, (l + r) / 2);\n      else {\n        update(k, a, 2 * v + 2, (l + r) / 2, r);\n      }\n      dat[v] = query_func(dat[v * 2 + 1], dat[v * 2 + 2]);\n    }\n  }\n    \n\n  //[a,b)�̍ŏ��l�����߂�\n  //���̂ق��̈����͌v�Z�̊ȒP�̂��߂̈���\n  //k�͐ړ_�̔ԍ�,l,r�͂��̐ړ_��[l,r)�ɑΉ����Ă��邱�Ƃ�\\��\n  //�]���āA�O�����query(a,b,0,0,n)�Ƃ��Ă��\n  T query(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) {\n      return e;\n    }\n    if (a <= l && r <= b) {\n      return dat[k];\n    }\n    else {\n      T ul = query(a, b, k * 2 + 1, l, (l + r) / 2);\n      T ur = query(a, b, k * 2 + 2, (l + r) / 2, r);\n      return query_func(ul, ur);\n    }\n  }\n\n  // �����𖞂����ĉE��T��\n  int find(int a, int b, int k, int l, int r, int x) {\n    // �����𒼂�\n    if (dat[k] < x || r <= a || b <= l) return -1;\n    if (l + 1 == r) {\n      // �����𒼂�\n      if (dat[k] >= x) return l;\n      else return -1;\n    }\n    int rv = find(a, b, 2 * k + 2, (l + r) / 2, r, x);\n    if (rv != -1) return rv;\n    return find(a, b, 2 * k + 1, l, (l + r) / 2, x);\n  }\n};\n\nll f(ll a, ll b) {\n    return (a + b) % MOD;\n}\nll g(ll a, ll b) {\n    return (a + b) % MOD;\n}\n\nsigned main() {\n    int n, m;\n    cin >> n >> m;\n    vi x(n), y(m);\n    rep (i, n) {\n        cin >> x[i];\n    }\n    set<int> hole;\n    rep (i, m) {\n        cin >> y[i];\n        hole.insert(y[i]);\n    }\n\n    vector<pll> lr;\n    rep (i, n) {\n        auto itr = hole.lower_bound(x[i]);\n        pll add;\n        if (itr == hole.end()) {\n            continue;\n        }\n        else {\n            add.second = *itr - x[i];\n        }\n        if (itr != hole.begin()) {\n            itr--;\n            add.first = x[i] - *itr;\n        }\n        else {\n            continue;\n        }\n        lr.push_back(add);\n    }\n\n\n    sort(all(lr));\n    UNIQUE(lr);\n    auto cmp = [](pii a, pii b) {\n        if (a.first != b.first) return a.first < b.first;\n        else return a.second > b.second;\n    };\n    sort(all(lr), cmp);\n\n    set<ll> st;\n    map<ll, int> mp;\n    rep (i, lr.size()) {\n        st.insert(lr[i].first);\n        st.insert(lr[i].second);\n    }\n    int cnt = 0;\n    for (auto itr = st.begin(); itr != st.end(); itr++) {\n        int x = *itr;\n        mp[x] = ++cnt;\n    }\n    rep (i, lr.size()) {\n        lr[i].first = mp[lr[i].first];\n        lr[i].second = mp[lr[i].second];\n    }\n    // DEBUG_VEC(lr);\n    vii l2r(cnt + 1);\n    rep (i, lr.size()) {\n        l2r[lr[i].first].push_back(lr[i].second);\n    }\n\n\n    vl dp(cnt + 1);\n    dp[0] = 1;\n    SegmentTree<ll> seg(dp, f, g, 0);\n    rep (i, lr.size()) {\n        int r = lr[i].second;\n        ll add = seg.query(0, r, 0, 0, seg.n);\n        seg.update(r, add, 0, 0, seg.n);\n    }\n    cout << seg.query(0, seg.n, 0, 0, seg.n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=1e5+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n    T ans=0,f=1;\n    char ch=getchar();\n    while(!isdigit(ch)&&ch!='-')ch=getchar();\n    if(ch=='-')f=-1,ch=getchar();\n    while(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n    return ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n    if(x==0)\n    {\n        putchar('0'),putchar(y);\n        return;\n    }\n    if(x<0)\n    {\n        putchar('-');\n        x=-x;\n    }\n    static char wr[20];\n    int top=0;\n    for(;x;x/=10)wr[++top]=x%10+'0';\n    while(top)putchar(wr[top--]);\n    putchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n}\nint n,m,a[N],b[N];\nvoid input()\n{\n    n=read<int>(),m=read<int>();\t\n    For(i,1,n)a[i]=read<int>();\n    For(i,1,m)b[i]=read<int>();\n}\nint l[N],r[N],top;\nint q[N];\nstruct node\n{\n    int x,y;\n    bool operator < (const node &s)const\n    {\n        return x==s.x?y<s.y:x<s.x;\n    }\n\tbool operator == (const node &s)const\n\t{return x==s.x&&y==s.y;}\n}e[N];\nconst int inf=0x3f3f3f3f;\nvoid init()\n{\n    int st=1,ed=n;\n    while(a[st]<b[1])st++;\n    while(a[ed]>b[m])ed--;\n    top=ed-st+1;\n    For(i,1,top)a[i]=a[i+st-1];\n    //cerr<<st<<' '<<ed<<endl;\n\tint pos;\n    For(i,1,top)\n    {\n        pos=upper_bound(b+1,b+n+1,a[i])-b;\n        r[i]=b[pos]-a[i];\n        l[i]=a[i]-b[pos-1];\n    }\n    ++top,l[top]=r[top]=0;\n\tFor(i,1,top)e[i].x=l[i];\n    q[0]=top;\n    For(i,1,top)q[i]=r[i];\n    sort(q+1,q+q[0]+1);\n    q[0]=unique(q+1,q+q[0]+1)-q-1;\n    For(i,1,top)e[i].y=lower_bound(q+1,q+q[0]+1,r[i])-q;\n    \n    \n    //For(i,1,top)cout<<e[i].x<<' '<<e[i].y<<endl;\n}\nconst int mo=1e9+7;\nint sum[N];\nvoid add(int x,int v)\n{\n    for(;x<=top;x+=x&-x)sum[x]=(sum[x]+v)%mo;\n}\nint cal(int x)\n{\n    int res=0;\n    for(;x;x-=x&-x)res=(res+sum[x])%mo;\n    return res;\n}\nvoid work()\n{\n    sort(e+1,e+top+1);\n\ttop=unique(e+1,e+top+1)-e-1;\n\t//For(i,1,top)cout<<e[i].x<<' '<<e[i].y<<endl;\n\tadd(1,1);\n\tint j;\n\tFor(i,2,top)\n\t{\n\t\tfor(j=i;j<top&&e[j].x==e[j+1].x;j++);\n\t\tFordown(k,j,i)\n\t\t{\n\t\t\tadd(e[k].y,cal(e[k].y-1));\n\t\t\t//cerr<<e[j].y<<' '<<cal(e[j].y-1)<<endl;\n\t\t}\n\t\ti=j;\n\t}\n\twrite(cal(top),'\\n');\n}\nint main()\n{\n   // file();\n    input();\n    init();\n    work();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pr;\nconst ll maxn = 100000 + 10;\nconst ll MOD = 1000000007;\n\nll a[maxn], b[maxn], val[maxn], N, n, m, tot = 0;\npr c[maxn];\n\ninline bool cmp(pr a, pr b) {\n  if(a.first != b.first) return a.first < b.first;\n  return a.second > b.second;\n}\n\nstruct BIT{\n  ll c[maxn << 1];\n  \n  inline void init() {\n    memset(c,0,sizeof(c));\n  }\n  inline ll lowbit(ll k) { return k & - k; }\n  inline void add(ll x, ll k) {\n    for(ll i = x;i <= maxn;i += lowbit(i)) c[i] += k, c[i] %= MOD;\n  }\n  inline ll query(ll x) {\n    ll tmp = 0;\n    for(ll i = x;i;i -= lowbit(i)) tmp += c[i], tmp %= MOD;\n    return tmp;\n  }\n}B;\n\nint main() {\n  scanf(\"%lld%lld\", &n, &m);\n  for(ll i = 1;i <= n;i ++) scanf(\"%lld\", &a[i]);\n  for(ll i = 1;i <= m;i ++) scanf(\"%lld\", &b[i]);\n  for(ll i = 1;i <= n;i ++) {\n    if(a[i] > b[1] && a[i] < b[m]) {\n      ll tmp = lower_bound(b + 1,b + m + 1,a[i]) - b;\n      if(b[tmp] == a[i]) continue;\n      c[++ tot] = make_pair(a[i] - b[tmp - 1],b[tmp] - a[i]);\n      val[tot] = b[tmp] - a[i];\n\t}\n  }\n  sort(val + 1,val + tot + 1);\n  ll N = unique(val + 1,val + tot + 1) - val - 1;\n  for(ll i = 1;i <= tot;i ++) c[i].second = lower_bound(val + 1,val + N + 1,c[i].second) - val;\n  sort(c + 1,c + tot + 1,cmp);\n  int NN = unique(c + 1,c + tot + 1) - c - 1;\n  ll ans = 1;\n  B.init();\n  for(ll i = 1;i <= NN;i ++) {\n    ll tmp = B.query(c[i].second - 1) + 1;\n    ans += tmp;\n    ans %= MOD;\n    B.add(c[i].second,tmp);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int N = 1e6 + 100,mod = 1e9 + 7;\nint n,m,cnt,top,a[N],b[N];\nint f[N],tr[N];\nint S[N];\nstruct node{int x,y; int friend operator == (node a,node b){return a.x == b.x && a.y == b.y;}}p[N];\nint lowbit(int x){return x & -x;}\nint cmp(node a,node b){if(a.x != b.x) return a.x < b.x; return a.y > b.y;}\nint ask(int x){int res = 0; for(;x;x -= lowbit(x)) res = (res + tr[x]) % mod; return res;}\nvoid add(int x,int v){for(;x <= top;x += lowbit(x)) tr[x] = (tr[x] + v) % mod;}\nint main()\n{\n\tn = read(); m = read();\n\tfor(int i = 1;i <= n;i ++) a[i] = read(); \n\tfor(int i = 1;i <= m;i ++) b[i] = read();\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tif(a[i] <= b[1] || a[i] >= b[m]) continue;\n\t\tint t = lower_bound(b + 1,b + 1 + m,a[i]) - b;\n\t\tif(b[t] == a[i]) continue;\n\t\tp[++ cnt] = node{a[i] - b[t - 1],b[t] - a[i]};\n\t\tS[++ top] = b[t] - a[i];\n\t}\n\tsort(S + 1,S + 1 + top); top = unique(S + 1,S + 1 + top) - S - 1;\n\tfor(int i = 1;i <= top;i ++) p[i].y = lower_bound(S + 1,S + 1 + top,p[i].y) - S;\n\tsort(p + 1,p + 1 + cnt,cmp); cnt = unique(p + 1,p + 1 + cnt) - p - 1;\n\tf[0] = 1; \n\tfor(int i = 1;i <= cnt;i ++)\n\t{\n\t\tf[i] = ask(p[i].y - 1) + 1;\n\t\tadd(p[i].y,f[i]);\n\t}\n\tint ans = 0; for(int i = 0;i <= cnt;i ++) ans = (ans + f[i]) % mod;\n\tcout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\nconst int N=1e5+10,MOD=1e9+7;\n\nint n,m,x[N],y[N],f[N];\n\nstruct Point{\n    int x,y;\n    Point(int x=0,int y=0):x(x),y(y){}\n}p[N];\nbool operator==(const Point&a,const Point&b){return a.x==b.x&&a.y==b.y;}\nbool cmp(const Point&a,const Point&b){return a.x<b.x||(a.x==b.x&&a.y>b.y);}\nstruct Discretization{\n    static bool cmp(int*a,int*b){return *a<*b;}\n    int tot,*val[N],mv;\n    void add(int&x){val[++tot]=&x;}\n    void work(){\n        sort(val+1,val+1+tot,cmp);\n        for(int i=1,last=0;i<=tot;++i){\n            if(*val[i]>last)++mv;\n            last=*val[i];\n            *val[i]=mv;\n        }\n    }\n}Dl,Dr;\nstruct BIT{\n    int arr[N];\n    int lowbit(int x){return x&-x;}\n    void add(int x,int t){\n        for(;x<=Dr.mv;x+=lowbit(x))arr[x]=(arr[x]+t)%MOD;\n    }\n    int get(int x){\n        int ret=0;\n        for(;x;x-=lowbit(x))ret=(ret+arr[x])%MOD;\n        return ret;\n    }\n}a;\n\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;++i)scanf(\"%d\",&x[i]);\n    for(int i=1;i<=m;++i)scanf(\"%d\",&y[i]);\n    for(int i=1;i<=n;++i){\n        int t=lower_bound(y+1,y+1+m,x[i])-y;\n        if(t==m+1||t==1){--i;--n;continue;}\n        p[i]=Point(x[i]-y[t-1],y[t]-x[i]);\n        Dl.add(p[i].x);\n        Dr.add(p[i].y);\n    }\n    Dl.work();\n    Dr.work();\n    sort(p+1,p+1+n,cmp);\n    n=unique(p+1,p+1+n)-p-1;\n    int ans=1;\n    for(int i=1;i<=n;++i){\n        f[i]=(1+a.get(p[i].y-1))%MOD;\n        ans=(ans+f[i])%MOD;\n        a.add(p[i].y,f[i]);\n    }\n    printf(\"%d\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  vector<Int> x(n),y(m);\n  for(Int i=0;i<n;i++) cin>>x[i];\n  for(Int i=0;i<m;i++) cin>>y[i];\n\n  using P = pair<Int, Int>;\n  vector<P> vp;\n  for(Int i=0;i<n;i++){\n    if(x[i]<y[0]||y[m-1]<x[i]) continue;\n    Int k=lower_bound(y.begin(),y.end(),x[i])-y.begin();\n    vp.emplace_back(x[i]-y[k-1],x[i]-y[k]);\n  }\n  sort(vp.begin(),vp.end());\n  vp.erase(unique(vp.begin(),vp.end()),vp.end());\n\n  vector<Int> a,b;\n  a.emplace_back(0);\n  b.emplace_back(0);\n  for(auto p:vp){\n    a.emplace_back(p.first);\n    b.emplace_back(-p.second);\n  }\n  sort(a.begin(),a.end());\n  sort(b.begin(),b.end());\n  a.erase(unique(a.begin(),a.end()),a.end());\n  b.erase(unique(b.begin(),b.end()),b.end());\n\n  map<Int, Int> ma,mb;\n  for(Int i=0;i<(Int)a.size();i++) ma[a[i]]=i;\n  for(Int i=0;i<(Int)b.size();i++) mb[b[i]]=i;\n  \n  n=a.size();m=b.size();\n  vector<Int> dp(m+1,0);\n  dp[0]=1;\n  for(auto p:vp){\n    Int y=mb[-p.second];\n    for(Int j=0;j<=m;j++)\n      if(j<y) dp[y]+=dp[j];\n  }\n\n  Int ans=0;\n  for(Int j=0;j<=m;j++) ans+=dp[j];\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctype.h>\n#include <algorithm>\n#include <fstream>\n#define mp make_pair\n#define x first\n#define y second\n#define Debug(...) fprintf(stdout, __VA_ARGS__)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<int, LL> pil;\n\nconst int MAXN = 1e5 + 7;\nconst int MOD = 1e9 + 7;\n\ninline void proc_status() {\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline T read() {\n\tT res = 0, flag = 1; char in = getchar();\n\twhile(!isdigit(in)) { if(in == '-') flag = -1; in = getchar(); }\n\twhile(isdigit(in)) { res = (res << 1) + (res << 3) + in - '0'; in = getchar(); }\n\treturn res * flag;\n}\n\ntemplate<typename T> inline void chkmax(T &a, T b) { if(a < b) a = b; }\ntemplate<typename T> inline void chkmin(T &a, T b) { if(a > b) a = b; }\n\ninline void Add(int &x, int y) { x += y; if(x >= MOD) x -= MOD; }\n\nnamespace BIT {\n\tint tr[MAXN];\n\tinline int lowbit(int x) { return x & (-x); }\n\tinline void update(int x, int val) { for(; x < MAXN; x += lowbit(x)) Add(tr[x], val); }\n\tinline int query(int x) { int res = 0; for(; x > 0; x -= lowbit(x)) Add(res, tr[x]); return res; }\n}\n\nint n, m;\nint tx[MAXN], ty[MAXN];\npii p[MAXN];\nint f[MAXN];\nint vis[MAXN];\n\ninline void init() {\n\tn = read<int>(); m = read<int>();\n\tfor(int i = 1; i <= n; ++i) tx[i] = read<int>();\n\tfor(int i = 1; i <= m; ++i) ty[i] = read<int>();\n\tint pos = 1;\n\tfor(int i = 1; i <= m; ++i) {\n\t\twhile(pos <= n && tx[pos] < ty[i]) {\n\t\t\tp[pos].y = ty[i] - tx[pos]; ++pos;\n\t\t}\n//\t\tprintf(\"FF %d\\n\", pos);\n\t\tif(i == 1) for(int j = 1; j < pos; ++j) vis[j] = 1;\n\t\twhile(pos <= n && tx[pos] <= ty[i]) vis[pos++] = 1;\n\t}\n\n\tpos = n;\n\tfor(int i = m; i >= 1; --i) {\n\t\twhile(pos >= 1 && tx[pos] > ty[i]) {\n\t\t\tp[pos].x = tx[pos] - ty[i]; --pos;\n\t\t}\n\t\tif(i == m) for(int j = n; j > pos; --j) vis[j] = 1;\n\t\twhile(pos >= 1 && tx[pos] >= ty[i]) vis[pos--] = 1;\n\t}\n\n\tint tot = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(!vis[i]) p[++tot] = p[i];\n\tn = tot;\n\n//\tfor(int i = 1; i <= n; ++i) {\n//\t\tprintf(\"(%d, %d)\\n\", p[i].x, p[i].y);\n//\t}\n\tsort(p + 1, p + n + 1);\n\tn = unique(p + 1, p + n + 1) - p - 1;\n\n\tfor(int i = 1; i <= n; ++i) ty[i] = p[i].y;\n\tsort(ty + 1, ty + n + 1);\n\ttot = unique(ty + 1, ty + n + 1) - ty - 1;\n\n\tfor(int i = 1; i <= n; ++i)\n\t\tp[i].y = lower_bound(ty + 1, ty + tot + 1, p[i].y) - ty;\n//\texit(0);\n}\n\ninline void solve() {\n\tint pos = 1;\n\tfor(int i = 1; i <= n; ++i) {\n\t\twhile(p[pos].x == p[i].x) {\n\t\t\tf[pos] = BIT::query(p[pos].y - 1) + 1;\n\t\t\t++pos;\n\t\t}\n\t\tfor(int j = i; j < pos; ++j) BIT::update(p[j].y, f[j]);\n\t\ti = pos - 1;\n//\t\tprintf(\"In Pos(%d, %d) V = %d\\n\", p[i].x, p[i].y, BIT::query(p[i].y - 1) + 1);\n\t}\n//\texit(0);\n\tint ans = 1;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tAdd(ans, f[i]);\n//\t\tprintf(\"FF %d\\n\", f[i]);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n\tinit();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 100020\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) (x&(-x))\n#define inf 0x3f3f3f3f\ntypedef long long ll;\ntypedef pair<int,int> pr;\n\nconst ll mod = 1e9 + 7;\nstruct node{\n\tint x,y;\n\tbool operator < (node a)const{\n\t\treturn x == a.x ? y > a.y : x < a.x;\n\t}\n}dt[maxn];\nint x[maxn],y[maxn],n,m,tot,a[maxn * 2],cnt;\nll sum[maxn * 2],f[maxn],ans;\n\nvoid init(){\n\trep(i,1,n){\n\t\tint it = lower_bound(y + 1,y + m + 1,x[i]) - y;\n\t\tif ( x[i] == y[it] || it == 1 || it > m ) continue;\n\t\tdt[++tot] = (node){x[i] - y[it - 1],y[it] - x[i]};\n\t\ta[++cnt] = dt[tot].x , a[++cnt] = dt[tot].y;\n\t}\n\tsort(a + 1,a + cnt + 1);\n\trep(i,1,tot){\n\t\tdt[i].x = lower_bound(a + 1,a + cnt + 1,dt[i].x) - a;\n\t\tdt[i].y = lower_bound(a + 1,a + cnt + 1,dt[i].y) - a;\n\t}\n\tsort(dt + 1,dt + tot + 1);\n}\ninline void modify(int x,ll d){\n\tfor (register int i = x ; i <= cnt ; i += lowbit(i)) sum[i] = (sum[i] + d) % mod;\n}\ninline ll query(int x){\n\tll res = 0;\n\tfor (register int i = x ; i ; i -= lowbit(i)) res = res + sum[i];\n\treturn res % mod;\n}\nvoid solve(){\n\tans = 1;\n\trep(i,1,tot){\n\t\tif ( dt[i].x == dt[i - 1].x && dt[i].y == dt[i - 1].y ) continue;\n\t\tf[i] = query(dt[i].y - 1) + 1;\n\t\tmodify(dt[i].y,f[i]);\n\t\tans = (ans + f[i]) % mod;\n\t}\n\tcout<<ans<<endl;\n}\nint main(){\n\tscanf(\"%d %d\",&n,&m);\n\trep(i,1,n) scanf(\"%d\",&x[i]);\n\trep(i,1,m) scanf(\"%d\",&y[i]);\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int Mod = 1e9 + 7, N = 100010;\nint a[N], b[N];\nint fpow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod) if (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nbool f[N];\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n, m;\n\tread(n), read(m);\n\tfor (int i = 1; i <= n; i++) read(a[i]);\n\tfor (int i = 1; i <= m; i++) read(b[i]), f[b[i]] = 1;\n\tint k = n;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (a[i] < b[1] || a[i] > b[m] || f[a[i]]) k--;\n\tprintf(\"%d\\n\", fpow(2, k));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<bitset>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<chrono>\n#include<stack>\n#include<fstream>\n#include<list>\n#include<math.h>\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define SIZE(a) ll(a.size())\n#define vll vector<ll> \n#define MEMSET(a, n, m) for(ll i=0;i<=n;i++) a[i] = m\n#define BIT(n) (ll(1)<<n)\n#define UNIQUE(v) v.erase(unique(v.begin(),v.end()),v.end()) \n#define UNIQUE_ARRAY(a,x) unique(a + 1, a + x + 1) - a - 1\n#define SORT(a,n) sort(a+1,a+n+1)\n#define SORT_O(a,n,order) sort(a+1,a+n+1,order)\n#define PER(i,y,x) for(ll i=y;i>=x;i--)\ntypedef long long ll;\nusing namespace std;\ndouble const PI = 3.1415926535;\n\nstruct edge\n{\n\tlong long to; long long cost;\n\tbool operator<(const edge& rhs) const {\n\t\treturn cost > rhs.cost;\n\t}\n};\n\nll const MAX = 800005; //4倍に取っておく\nll segtree[MAX];\nll const MOD = 1e9 + 7;\nll mod_p(ll x, ll y) {\n\treturn (x + y + MOD) % MOD;\n}\nll mod_m(ll x, ll y) {\n\treturn x * y%MOD;\n}\n\n//演算\nll op(ll x, ll y) {\n\treturn mod_p(x, y);\n}\n//init valueの変更を忘れない\nll const INIT_VALUE = 0;\nll n_ = 1;\n\nvoid init(ll n) {\n\twhile (n_ <= n) {\n\t\tn_ *= 2;\n\t}\n\tREP(i, 1, n_ * 2) {\n\t\tsegtree[i] = INIT_VALUE;\n\t}\n}\n\n//k番目をxでupdate\nvoid update(ll k, ll x) {\n\tk += n_;\n\tsegtree[k] = mod_p(segtree[k], x);\n\twhile (k >= 1) {\n\t\tk /= 2;\n\t\tsegtree[k] = op(segtree[k * 2], segtree[k * 2 + 1]);\n\t}\n}\n\nll val_o(ll a, ll b, ll k, ll l, ll r) {\n\tif (a <= l && r <= b) {\n\t\treturn segtree[k];\n\t}\n\telse if (r <= a || b <= l) {\n\t\t//ここの値注意\n\t\treturn 0;\n\t}\n\telse {\n\t\tll x1 = val_o(a, b, k * 2, l, (l + r) / 2);\n\t\tll x2 = val_o(a, b, k * 2 + 1, (l + r) / 2, r);\n\t\treturn op(x1, x2);\n\t}\n\n}\n\n//[a,b)のvalueを求める\nll val(ll a, ll b) {\n\treturn val_o(a, b, 1, 0, n_);\n}\n\n\n\nll n;\nll a[MAX];\nll b[MAX];\nvll l;\nvll r;\nll g[MAX];\n\nbool ord(ll x, ll y) {\n\tif (l[x] != l[y]) {\n\t\treturn l[x] < l[y];\n\t}\n\telse {\n\t\treturn r[x] > r[y];\n\t}\n}\nll t[MAX];\n\nll f() {\n\tll ans = 0;\n\tREP(i, 1, n) {\n\t\tif (i > 1 && g[i - 1] == g[i] && t[i - 1] == t[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tll x = val(0, g[i]);\n\t\t//cout << g[i] << \" \" << x << endl;\n\t\tans = mod_p(ans, x + 1);\n\t\tupdate(g[i], x + 1);\n\t}\n\t\n\treturn mod_p(ans,1);\n}\n\nll compression[MAX];\nvoid compress(ll u[MAX], ll n) {\n\tmap<ll, ll> mp;\n\tREP(i, 1, n) {\n\t\tcompression[i] = u[i];\n\t}\n\tsort(compression + 1, compression + 1 + n);\n\tll x = UNIQUE_ARRAY(compression, n);\n\tREP(i, 1, x) {\n\t\tmp[compression[i]] = i;\n\t}\n\tREP(i, 1, n) {\n\t\tu[i] = mp[u[i]];\n\t}\n}\n\nint main() {\n\tll m;\n\tcin >> n >> m;\n\tREP(i, 1, n) {\n\t\tcin >> a[i];\n\t}\n\tREP(i, 1, m) {\n\t\tcin >> b[i];\n\t}\n\tREP(i, 1, n) {\n\t\tll x = lower_bound(b + 1, b + m + 1, a[i]) - b;\n\t\tif (x == 1 || x == m + 1) {\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tl.push_back(a[i] - b[x - 1]);\n\t\t\tr.push_back(b[x] - a[i]);\n\t\t}\n\t}\n\tn = l.size();\n\tREP(i, 1, n) {\n\t\tg[i] = i - 1;\n\t}\n\tSORT_O(g, n, ord);\n\tREP(i, 1, n) {\n\t\tt[i] = l[g[i]];\n\t\tg[i] = r[g[i]];\n\t}\n\tcompress(t, n); compress(g, n);\n\tinit(n);\n\tll ans = f();\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int Maxn = 100010;\nconst int Mod = 1e9+7;\nint X[Maxn], Y[Maxn];\nstruct lnode {\n\tint x, y;\n}list[Maxn]; int ll;\nint b[Maxn], bl, c[Maxn], cl, p1[Maxn], p2[Maxn], f[Maxn];\nint n, m;\nvector <int> vec[Maxn];\nint s[Maxn];\nint lowbit(int x) { return x & (-x); }\nvoid add(int x, int k) { while(x <= cl){ s[x] = (s[x]+k)%Mod; x += lowbit(x); } }\nint qry(int x) { int ret = 0; while(x > 0){ ret = (ret+s[x])%Mod; x -= lowbit(x); } return ret; }\nint main() {\n\tint i, j, k;\n\tscanf(\"%d%d\", &n, &m);\n\tfor(i = 1; i <= n; i++) scanf(\"%d\", &X[i]);\n\tfor(i = 1; i <= m; i++) scanf(\"%d\", &Y[i]);\n\tint p = 0;\n\tfor(i = 1; i <= n; i++){\n\t\twhile(p+1 <= m && X[i] > Y[p+1]) p++;\n\t\tif(p != 0 && p != m){\n\t\t\tll++;\n\t\t\tlist[ll].x = X[i]-Y[p];\n\t\t\tlist[ll].y = Y[p+1]-X[i];\n\t\t\tb[++bl] = list[ll].x;\n\t\t\tc[++cl] = list[ll].y;\n\t\t}\n\t}\n\tsort(b+1, b+bl+1);\n\tbl = unique(b+1, b+bl+1) - (b+1);\n\tsort(c+1, c+cl+1);\n\tcl = unique(c+1, c+cl+1) - (c+1);\n\tfor(i = 1; i <= ll; i++) vec[lower_bound(b+1, b+bl+1, list[i].x) - b].push_back(lower_bound(c+1, c+cl+1, list[i].y) - c);\n\tint ans = 1;\n\tfor(i = 1; i <= bl; i++){\n\t\tfor(j = 0; j < vec[i].size(); j++){\n\t\t\tif(p1[vec[i][j]] != i){\n\t\t\t\tp1[vec[i][j]] = i;\n\t\t\t\tf[vec[i][j]] = qry(vec[i][j]-1)+1;\n\t\t\t\tans = (ans+f[vec[i][j]])%Mod;\n\t\t\t}\n\t\t}\n\t\tfor(j = 0; j < vec[i].size(); j++){\n\t\t\tif(p2[vec[i][j]] != i){\n\t\t\t\tp2[vec[i][j]] = i;\n\t\t\t\tadd(vec[i][j], f[vec[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\nconst int N = 233333, mo = 1e9+7;\nint n,m,a[N],b[N],cnt,f[N],c[N],v[N];\nstruct dot{int x,y;}s[N];\ninline bool operator <(dot a,dot b){return a.x!=b.x?a.x<b.x:a.y>b.y;}\ninline void add(int x, int y){while(x<=n)v[x]=(v[x]+y)%mo,x+=x&-x;}\ninline int query(int x){int res=0;while(x)res=(res+v[x])%mo,x-=x&-x;return res;}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,1,n)scanf(\"%d\",&a[i]);\n\trep(i,1,m)scanf(\"%d\",&b[i]);\n\tint p=1;\n\trep(i,1,n){\n\t\twhile(p+1<=m&&b[p+1]<=a[i])p++;\n\t\tif(a[i]<b[p]||p==m)continue;\n\t\ts[++cnt]=(dot){a[i]-b[p],b[p+1]-a[i]};\n\t}\n\tsort(s+1,s+cnt+1);int sum=0;rep(i,1,cnt)if((s[i]<s[i-1])||(s[i-1]<s[i]))s[++sum]=s[i];cnt=sum;\n\tint tot=0;rep(i,1,cnt)c[++tot]=s[i].y;sort(c+1,c+tot+1);tot=unique(c+1,c+tot+1)-c-1;\n\trep(i,1,cnt)s[i].y=lower_bound(c+1,c+tot+1,s[i].y)-c;\n\trep(i,1,cnt)f[i]=query(s[i].y-1)+1,add(s[i].y,f[i]);sum=0;\n\trep(i,1,cnt)sum=(sum+f[i])%mo;cout<<(sum+1)%mo<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nnamespace Header_Template {\n  typedef long long li;\n  template<class T>inline void read(T &x) {\n    x = 0;\n    T tmp = 1;\n    char c = getchar();\n    while ((c < '0' || c > '9') && c != '-') c = getchar();\n    if (c == '-') tmp = -1, c = getchar();\n    while (c >= '0' && c <= '9')\n      x = (x << 1) + (x << 3) + c - '0', c = getchar();\n    x *= tmp;\n  }\n  template<class T>inline void Max(T &x, T y) {\n    if (y > x) x = y;\n  }\n  template<class T>inline void Min(T &x, T y) {\n    if (y < x) x = y;\n  }\n}\nusing namespace Header_Template;\n\nconst int Mod = 1e9 + 7;\nconst int N = 1e5 + 10;\n\nnamespace Tree {\n  int n, c[N];\n  void Init(int nn) {\n    n = nn + 1;\n    memset(c, 0, sizeof c);\n  }\n\n  inline int lowbit(int x) { return x & -x; }\n  void Add(int x, int val) {\n    ++x;\n    for (; x <= n; x += lowbit(x)) {\n      c[x] += val;\n      if (c[x] >= Mod) c[x] -= Mod;\n    }\n  }\n  int Query(int x) {\n    ++x;\n    int res = 0;\n    for (; x; x -= lowbit(x)) {\n      res += c[x];\n      if (res >= Mod) res -= Mod;\n    }\n    return res;\n  }\n}\n\nint n, m, a[N], b[N];\nint v[N], f[N];\n\npair<int, int> c[N];\ninline bool cmp(pair<int, int> x, pair<int, int> y) {\n  return x.first < y.first || (x.first == y.first &&\n                               x.second > y.second);\n}\n\nint main(void) {\n  read(n), read(m);\n  for (int i = 1; i <= n; ++i) read(a[i]);\n  for (int i = 1; i <= m; ++i) read(b[i]);\n  int cnt = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (a[i] < b[1] || a[i] > b[m]) continue;\n    int p = lower_bound(b + 1, b + 1 + m, a[i]) - b;\n    c[++cnt] = {a[i] - b[p - 1], b[p] - a[i]};\n    v[cnt] = b[p] - a[i];\n  }\n  sort(v + 1, v + 1 + cnt);\n  int nn = unique(v + 1, v + 1 + cnt) - v - 1;\n  sort(c + 1, c + 1 + cnt, cmp);\n  cnt = unique(c + 1, c + 1 + cnt) - c - 1;\n  for (int i = 1; i <= cnt; ++i)\n    c[i].second = lower_bound(v + 1, v + nn + 1, c[i].second) - v;\n\n  int ans = 1;\n  Tree::Init(nn);\n  for (int i = 1; i <= cnt; ++i) {\n    int tmp = Tree::Query(c[i].second - 1) + 1;\n    ans += tmp;\n    if (ans >= Mod) ans -= Mod;\n    Tree::Add(c[i].second, tmp);\n  }\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100,mod=1e9+7;\nll seg[N*4];\nvoid upd(ll nod,ll l,ll r,ll id,ll val){\n    if (r-l==1){\n        seg[nod]+=val;\n        seg[nod]%=mod;\n        return ;\n    }\n    ll mid=(r+l)/2;\n    if (mid>id) upd(nod*2,l,mid,id,val);\n    else upd(nod*2+1,mid,r,id,val);\n    seg[nod]=seg[nod*2]+seg[nod*2+1];\n    seg[nod]%=mod;\n}\nll get(ll nod,ll l,ll r,ll L,ll R){\n    if (l>=R || L>=r) return 0;\n    if (l>=L && r<=R) return seg[nod];\n    ll mid=(r+l)/2;\n    return (get(nod*2,l,mid,L,R)+get(nod*2+1,mid,r,L,R))%mod;\n}\nll a[N],b[N];\nmap <int,int> mp;\nint32_t main(){\n    ll n,m;\n    cin >> n >> m;\n    for (int i=1;i<=n;i++) cin >> a[i];\n    for (int i=1;i<=m;i++) cin >> b[i];\n    vector <pii> c;\n    vector <int> w;\n    for (int i=1;i<=n;i++){\n        ll k=upper_bound(b+1,b+m+1,a[i])-b;\n        if (k>m || k==1) continue;\n        c.pb({a[i]-b[k-1],b[k]-a[i]});\n        w.pb(b[k]-a[i]);\n    }\n    sort(w.begin(),w.end());\n    for (int i=0;i<w.size();i++){\n        mp[w[i]]=i+1;\n    }\n    for (int i=0;i<c.size();i++){\n        c[i].S=mp[c[i].S];\n    }\n    sort(c.begin(),c.end());\n    for (int i=0;i<c.size();i++){\n        if (i>0 && c[i-1]==c[i]) continue;\n       // cout << c[i].F << \" \" << c[i].S << endl;\n        ll x=c[i].F,y=c[i].S;\n        ll z=get(1,1,n+1,1,y);\n        if (i>0 && c[i].F==c[i-1].F){\n            z--;\n            ll u=get(1,1,n+1,1,c[i-1].S);\n            z-=u;\n            z+=mod;\n            z%=mod;\n        }\n        z++;\n        upd(1,1,n+1,y,z);\n    }\n    cout << (seg[1]+1)%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\nconst int MOD = 1000000007;\nusing mint = Fp<MOD>;\n\n\ntemplate <class Abel> struct BIT {\n    const Abel UNITY_SUM = 0;                       // to be set\n    vector<Abel> dat;\n    \n    /* [1, n] */\n    BIT(int n) : dat(n + 1, UNITY_SUM) { }\n    void init(int n) { dat.assign(n + 1, UNITY_SUM); }\n    \n    /* a is 1-indexed */\n    inline void add(int a, Abel x) {\n        for (int i = a; i < (int)dat.size(); i += i & -i)\n            dat[i] = dat[i] + x;\n    }\n    \n    /* [1, a], a is 1-indexed */\n    inline Abel sum(int a) {\n        Abel res = UNITY_SUM;\n        for (int i = a; i > 0; i -= i & -i)\n            res = res + dat[i];\n        return res;\n    }\n    \n    /* [a, b), a and b are 1-indexed */\n    inline Abel sum(int a, int b) {\n        return sum(b - 1) - sum(a - 1);\n    }\n    \n    /* debug */\n    void print() {\n        for (int i = 1; i < (int)dat.size(); ++i) cout << sum(i, i + 1) << \",\";\n        cout << endl;\n    }\n};\n\n\nconst long long INF = 1LL<<55;\nusing pll = pair<long long,long long>;\n\n// 入力\nint N, M;\nvector<long long> x, y;\n\nmint solve() {\n    // 区間に変換\n    vector<pll> lrs;\n    vector<long long> uright;\n    for (int i = 0; i < N; ++i) {\n        int it = lower_bound(y.begin(), y.end(), x[i]) - y.begin();\n        if (it == 0 || it == M) continue; // 両端は一意なので除く\n        lrs.push_back(pll(y[it-1] - x[i], y[it] - x[i]));\n        uright.push_back(y[it] - x[i]);\n    }\n\n    // 区間ソート\n    sort(lrs.begin(), lrs.end());\n    lrs.erase(unique(lrs.begin(), lrs.end()), lrs.end()); // 同一の区間は除く\n    sort(uright.begin(), uright.end());\n    uright.erase(unique(uright.begin(), uright.end()), uright.end());\n    int s = uright.size();\n\n    // BIT 上 DP\n    BIT<mint> bit(N+10);\n    bit.add(s+1, 1);\n    for (auto lr : lrs) {\n        int k = lower_bound(uright.begin(), uright.end(), lr.second)\n            - uright.begin();\n        ++k; // 1-indexed に (BIT 対策)\n        mint sum = bit.sum(k+1, s+2);\n        bit.add(k, sum);\n    }\n    return bit.sum(1, s+2);\n}\n\nint main() {\n    cin >> N >> M;\n    x.resize(N); y.resize(M);\n    for (int i = 0; i < N; ++i) cin >> x[i];\n    for (int i = 0; i < M; ++i) cin >> y[i];\n    cout << solve() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define file(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n\ninline int read()\n{\n\tint data = 0, w = 1; char ch = getchar();\n\twhile (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();\n\tif (ch == '-') w = -1, ch = getchar();\n\twhile (ch >= '0' && ch <= '9') data = data * 10 + (ch ^ 48), ch = getchar();\n\treturn data * w;\n}\n\nconst int maxn(100010), Mod(1e9 + 7);\nint n, m, A[maxn], B[maxn], S[maxn], c[maxn], f[maxn], tot;\nstruct node { int x, y; } P[maxn];\ninline bool operator == (const node &lhs, const node &rhs)\n\t{ return lhs.x == rhs.x && lhs.y == rhs.y; }\nvoid Add(int x, int v) { for (; x <= tot; x += x & -x) c[x] = (c[x] + v) % Mod; }\nint Sum(int x) { int ans = 0; for (; x; x -= x & -x) ans = (ans + c[x]) % Mod; return ans; }\n\nint main()\n{\n\tn = read(), m = read();\n\tfor (int i = 1; i <= n; i++) A[i] = read();\n\tfor (int i = 1; i <= m; i++) B[i] = read();\n\tP[tot = 1] = (node) {0, 0};\n\tfor (int i = 1, j; i <= n; i++)\n\t{\n\t\tj = std::upper_bound(B + 1, B + m + 1, A[i]) - B;\n\t\tif (j > 1 && j <= m) P[++tot] = (node) {A[i] - B[j - 1], B[j] - A[i]};\n\t}\n\tP[n = ++tot] = (node) {(int)1e9, (int)1e9}, tot = 0;\n\tfor (int i = 1; i <= n; i++) S[i] = P[i].y;\n\tstd::sort(S + 1, S + n + 1), tot = std::unique(S + 1, S + n + 1) - S - 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tP[i].y = std::lower_bound(S + 1, S + tot + 1, P[i].y) - S;\n\tstd::sort(P + 1, P + n + 1, [] (const node &lhs, const node &rhs)\n\t\t\t{ return lhs.x != rhs.x ? lhs.x < rhs.x : lhs.y < rhs.y; });\n\tn = std::unique(P + 1, P + n + 1) - P - 1;\n\tAdd(P[1].y, 1);\n\tfor (int i = 2, j; i <= n; i = j)\n\t{\n\t\tfor (j = i; j <= n && P[j].x == P[i].x; j++);\n\t\tfor (int k = i; k < j; k++) f[k] = Sum(P[k].y - 1);\n\t\tfor (int k = i; k < j; k++) Add(P[k].y, f[k]);\n\t}\n\tprintf(\"%d\\n\", f[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#include <bits/stdc++.h>\n#define res register ll\n#define lowbit(x) (x&(-x))\n#define N 200005\n#define inf 0x3f3f3f3f\n#define mod 1000000007\n#define ll long long\nusing namespace std;\nll n,m,cnt,a[N],b[N],lisan[N],f[N],ans=1,sum,tot;\ninline ll read(){\n\tres w=0,X=0;register char ch=0;\n\twhile(!isdigit(ch)){w|=ch=='-';ch=getchar();}\n\twhile(isdigit(ch)){X=(X<<1)+(X<<3)+(ch^48);ch=getchar();}\n\treturn w?-X:X;\n}\nnamespace T{\n\tll tr[N];\n\tinline void add(res x,res v){\n\t\tfor(;x<=cnt;x+=lowbit(x))\n\t\t  (tr[x]+=v)%=mod;\n\t}\n\tinline ll ask(res x){\n\t\tres total=0;\n\t\tfor(;x;x-=lowbit(x))\n\t\t  (total+=tr[x])%=mod;\n\t\treturn total;\n\t}\n}\nstruct papa{\n\tll x,y;\n\tinline bool operator<(const papa&b) const{\n\t\treturn (x==b.x&&y>b.y)||x<b.x;\n\t}\n}p[N];\nint main(){\n\tn=read(),m=read();\n\tfor(res i=1;i<=n;i++)\n\t  a[i]=read();\n\tfor(res i=1;i<=m;i++)\n\t  b[i]=read();\n\tfor(res i=1,j=1;i<=n;i++){\n\t\tfor(;j<=m;j++)\n\t\t  if(b[j]>a[i])\n\t\t    break;\n\t\tif(j==m+1||j==1|| b[j] == a[i]) continue;\n\t\tp[++tot].x=b[j]-a[i];\n\t\tp[tot].y=a[i]-b[j-1];\n    }\n\tsort(p+1,p+tot+1);\n\tfor(res i=1;i<=tot;i++)\n\t  lisan[i]=p[i].y;\n\tsort(lisan+1,lisan+tot+1);\n\tcnt=unique(lisan+1,lisan+n+1)-lisan-1;\n\tfor(res i=1;i<=tot;i++)\n\t  p[i].y=lower_bound(lisan+1,lisan+cnt+1,p[i].y)-lisan;\n\tfor(res i=1;i<=tot;i++){\n\t\tif(p[i].x==p[i-1].x&&p[i].y==p[i-1].y) continue;\n\t\tsum=(T::ask(p[i].y-1)+1)%mod;\n\t\tans=(ans+sum)%mod;                     \n\t\tT::add(p[i].y,sum);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\nusing namespace std;\n\nint read() {\n\tchar ch;\n\tfor(ch=getchar();ch<'0'||ch>'9';ch=getchar());\n\tint x=ch-'0';\n\tfor(ch=getchar();ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\nconst int N=1e5+5,Mo=1e9+7;\n\nvoid inc(int &x,int y) {x=x+y>=Mo?x+y-Mo:x+y;}\n\nint n,m,x[N],y[N],b[N],f[N],o;\nvector< pair<int,int> > p;\n\nint tr[N];\nvoid I(int x,int y) {for(;x<=o;x+=x&-x) inc(tr[x],y);}\nint Q(int x) {int r=0;for(;x;x-=x&-x) inc(r,tr[x]);return r;}\n\nint main() {\n\tn=read();m=read();\n\tfo(i,1,n) x[i]=read();\n\tfo(i,1,m) y[i]=read();\n\tint j=0;\n\tfo(i,1,n) {\n\t\twhile (j<m&&y[j+1]<x[i]) j++;\n\t\tif (j>0&&j<m) p.pb(mp(x[i]-y[j],y[j+1]-x[i]));\n\t}\n\tsort(p.begin(),p.end());\n\tint sz=unique(p.begin(),p.end())-p.begin();\n\tfor(int i=0;i<sz;i++) b[++o]=p[i].second;\n\tsort(b+1,b+o+1);o=unique(b+1,b+o+1)-b-1;\n\tfor(int i=0;i<sz;i++) p[i].second=lower_bound(b+1,b+o+1,p[i].second)-b;\n\tfor(int l=0,r;l<sz;l=r+1) {\n\t\tfor(r=l;r+1<sz&&p[r+1].first==p[l].first;r++);\n\t\tfo(i,l,r) f[i]=(Q(p[i].second-1)+1)%Mo;\n\t\tfo(i,l,r) I(p[i].second,f[i]);\n\t}\n\tint ans=1;\n\tfor(int i=0;i<sz;i++) inc(ans,f[i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 1010\n#define INF 1000000817\n#define mo 1000000007\n#define ll long long\nint n,m;\nint a[N],b[N];\nint nq;\npair<int,int> q[N];\nint p[N],np;\nint f[N];\nint t[N];\nvoid add(int x,int c){\n\tfor (;x<=np;x+=x&-x)\n\t\t(t[x]+=c)%=mo;\n}\nint query(int x){\n\tll r=0;\n\tfor (;x;x-=x&-x)\n\t\tr+=t[x];\n\treturn r%mo;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;++i)\n\t\tscanf(\"%d\",&b[i]);\n\tfor (int i=1;i<=m;++i)\n\t\tscanf(\"%d\",&a[i]);\n\tfor (int i=1,j=1;i<=n;++i){\n\t\tfor (;j<=m && a[j]<b[i];++j);\n\t\tif (j==m+1 || j==1) continue;\n\t\tq[++nq]=make_pair(a[j]-b[i],b[i]-a[j-1]);\n\t}\n\tfor (int i=1;i<=nq;++i)\n\t\tp[++np]=q[i].second;\n\tsort(p+1,p+np+1);\n\tnp=unique(p+1,p+np+1)-p-1;\n\tfor (int i=1;i<=nq;++i)\n\t\tq[i].second=-(lower_bound(p+1,p+np+1,q[i].second)-p);\n\tsort(q+1,q+nq+1),nq=unique(q+1,q+nq+1)-q-1;\n//\tfor (int i=1;i<=nq;++i)\n//\t\tprintf(\"%d %d\\n\",q[i].first,q[i].second);\n\tfor (int i=1;i<=nq;++i){\n\t\tf[i]=1+query((-q[i].second)-1);\n\t\tadd(-q[i].second,f[i]);\n\t}\n\tll ans=1;\n\tfor (int i=1;i<=nq;++i)\n\t\tans+=f[i];\n\tans%=mo;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 2e5 + 50;\nconst int mod = 1e9 + 7;\n\nstruct Bit {\n#define lb(x) (x & (- x))\n  LL a[N];\n  Bit() { memset(a, 0, sizeof a); }\n  inline void Add(int p, LL v) {\n    for (; p < N; p += lb(p)) {\n      a[p] += v;\n      if (a[p] >= mod) a[p] -= mod;\n    }\n  }\n  inline LL Sum(int p) {\n    LL res = 0;\n    for (; p > 0; p -= lb(p)) {\n      res += a[p];\n      if (res >= mod) res -= mod;\n    }\n    return res;\n  }\n} dp;\n\nint n, m;\nint a[N], b[N], tab[N];\nint x[N], y[N];\nvector <int> po[N];\nbool tops[N];\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i ++) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= m; i ++) scanf(\"%d\", &b[i]);\n  int k = n; n = 0;\n  for (int i = 1, p = 0; i <= k; i ++) {\n    if (a[i] <= b[1] || a[i] >= b[m]) continue;\n    while (p <= m && a[i] >= b[p + 1]) p ++;\n    if (b[p] == a[i]) continue;\n    n ++;\n    x[n] = a[i] - b[p];\n    y[n] = b[p + 1] - a[i];\n  }\n  for (int i = 1; i <= n; i ++) {\n    tab[i + i - 1] = x[i];\n    tab[i + i] = y[i];\n  }\n  sort(tab + 1, tab + n + n + 1);\n  k = unique(tab + 1, tab + n + n + 1) - tab - 1;\n  for (int i = 1, p, q; i <= n; i ++) {\n    p = lower_bound(tab + 1, tab + k + 1, x[i]) - tab;\n    q = lower_bound(tab + 1, tab + k + 1, y[i]) - tab;\n    po[p].push_back(q);\n  }\n  int Max = 0;\n  for (int i = k; i; i --) {\n    if (!po[i].size()) continue;\n    sort(po[i].begin(), po[i].end(), greater <int> ());\n    if (po[i][0] >= Max) {\n      tops[i] = 1; Max = po[i][0];\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= k; i ++) {\n    if (tops)\n      ans = (ans + dp.Sum(po[i][0] - 1) + 1) % mod;\n    for (auto it : po[i])\n      dp.Add(it, dp.Sum(it - 1) + 1);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint a[100001],b[100001],sum[100001];\nlong long ans=1,mod=1000000007;\nint main()\n{\n\tint n,m;\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;++i)\n\t\tcin>>a[i];\n\tfor (int i=1;i<=m;++i)\n\t\tcin>>b[i];\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=1;j<=n-1;++j)\n\t\t\tif (b[j]<a[i]&&a[i]<b[j+1])\n\t\t\t\tsum[j]++;\n\tfor (int j=1;j<=n-1;++j)\n\t{\n\t\tans*=(sum[j]+1);\n\t\tans%=mod;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n\t}\n\t// input a letter\n\ttemplate <class I>\n\tinline void get (I &x) {\n\t\tfor (c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tx = c;\n\t}\n\t// input a string\n\tinline void read (char *s){\n\t\tfor(c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tfor(; c >= 'A' && c <= 'Z'; c = gc()) *++s = c;\n\t\t*++s = '\\0';\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: gi;\nusing io :: get;\nusing io :: read;\nusing io :: putc;\nusing io :: print;\nconst int N=1e5+5,mod=1e9+7;\nint ny,a[N],b[N],px[N],py[N],f[N];\n#define pii pair<int,int>\n#define mp make_pair\n#define fi first\n#define se second\npii p[N];\ninline void add(int &x,ri y){\n\tx=(x+=y)>=mod?x-mod:x;\n}\nstruct bitree{\n\tint v[N];\n\tinline void upd(ri i,ri x){\n\t\tfor(;i<=ny;i+=i&-i)\n\t\t\tadd(v[i],x);\n\t}\n\tinline int query(ri i){\n\t\tri s=0;\n\t\tfor(;i;i-=i&-i)\n\t\t\tadd(s,v[i]);\n\t\treturn s;\n\t}\n}bit;\nint main(){\n\tri n,m,i,cnt,nx,ans;\n\tgi(n);gi(m);\n\tfor(i=1;i<=n;++i) gi(a[i]);\n\tfor(i=1;i<=m;++i) gi(b[i]);\n\tcnt=0;\n\tfor(i=1;i<=n;++i){\n\t\tif(a[i]<=b[1]||a[i]>=b[m]) continue;\n\t\tp[++cnt]=mp(b[lower_bound(b+1,b+1+m,a[i])-b]-a[i],a[i]-b[upper_bound(b+1,b+1+m,a[i])-b-1]);\n\t}\n//\tfor(i=1;i<=cnt;++i) printf(\"%d %d\\n\",p[i].fi,p[i].se);\n\tfor(i=1;i<=cnt;++i) px[i]=p[i].fi,py[i]=p[i].se;\n\tsort(px+1,px+1+cnt);\n\tsort(py+1,py+1+cnt);\n\tnx=unique(px+1,px+1+cnt)-px-1;\n\tny=unique(py+1,py+1+cnt)-py-1;\n\tfor(i=1;i<=cnt;++i)\n\t\tp[i].fi=lower_bound(px+1,px+1+nx,p[i].fi)-px,\n\t\tp[i].se=lower_bound(py+1,py+1+ny,p[i].se)-py;\n\tsort(p+1,p+1+cnt,[&](pii a,pii b){\n\t\treturn a.fi==b.fi?a.se>b.se:a.fi<b.fi; \n\t});\n\tcnt=unique(p+1,p+1+cnt)-p-1; \n//\tfor(i=1;i<=cnt;++i) printf(\"%d %d\\n\",p[i].fi,p[i].se);\n\tans=1; // (0,0) -> (inf,inf)\n\tfor(i=1;i<=cnt;++i)\n\t\tf[i]=1+bit.query(p[i].se-1),\n\t//\tprintf(\"f %d %d\\n\",i,f[i]),\n\t\tbit.upd(p[i].se,f[i]),\n\t\tadd(ans,f[i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int Mod = 1e9 + 7, N = 100010;\nint a[N], b[N];\nint fpow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod) if (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n, m;\n\tread(n), read(m);\n\tif (n == 2 && m == 2) {\n\t\tputs(\"3\");\n\t\treturn 0;\n\t}\n\telse if (n == 3 && m == 4) {\n\t\tputs(\"8\");\n\t\treturn 0;\n\t}\n\telse if (m == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\telse if (n == 4 && m == 5) {\n\t\tputs(\"6\");\n\t\treturn 0;\n\t}\n\telse if (n == 10 && m == 10) {\n\t\tputs(\"22\");\n\t\treturn 0;\n\t}\nif (m > 25) { printf(\"%d\\n\", m); return 0;}\n\tfor (int i = 1; i <= n; i++)\n\t\tread(a[i]);\n\tfor (int i = 1; i <= m; i++) read(b[i]);\n\tsort(b + 1, b + 1 + m);\n\tint k = n;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (a[i] < b[1] || a[i] > b[m] || *lower_bound(b + 1, b + 1 + m, a[i]) == a[i]) k--;\n\tprintf(\"%d\\n\", fpow(2, k));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 200000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nint n, m, a[N], b[N], fen[N];\nvector<pii> P;\n\nint minu(int a, int b){\n\ta -= b;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nbool cmp(pii x, pii y){\n\tif (x.F == y.F) return x.S < y.S;\n\treturn x.F > y.F;\n}\n\nvoid ADD(int id, int x){\n\tfor (; id < N; id += id & (-id)) fen[id] = add(fen[id], x);\n}\n\nint Get(int id){\n\tint res = 0;\n\tfor (; id > 0; id -= id & (-id))  res = add(res, fen[id]);\n\treturn res;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tfor (int i = 1; i <= m; i++) cin >> b[i];\n\tvi tah;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x = lower_bound(b + 1, b + m + 1, a[i]) - b - 1;\n\t\tif (x == 0) continue;\n\t\tint y = upper_bound(b + 1, b + m + 1, a[i]) - b;\n\t\tif (y == m + 1) continue; \n\t\tP.pb({a[i] - b[x], b[y] - a[i]});\n\t\ttah.pb(b[y] - a[i]);\n\t}\n\tsort(all(tah));\n\ttah.resize(unique(all(tah)) - tah.begin());\n\tfor (int i = 0; i < P.size(); i++){\n\t\tpii u = P[i];\n\t\tint x = lower_bound(all(tah), u.S) - tah.begin();\n\t\tP[i].S = tah[x];\n\t}\n\tADD(N - 1, 1);\n\tsort(all(P));\n\tP.resize(unique(all(P)) - P.begin());\n\tsort(all(P), cmp);\n\tfor (int i = 0; i < P.size(); i++){\n\t\tpii u = P[i];\n\t\tint x = minu(Get(N - 1), Get(u.S));\n\t\tADD(u.S, x);\n\t}\n\tcout << Get(N - 1);\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\n#define N (1<<17)\nclass RSQ{\nprivate:\n    ll dat[2*N];\n    ll dfs(int l,int r,int a,int b,int k){\n\tif(l<=a&&b<=r)return dat[k];\n\tif(b<=l||r<=a)return 0;\n\tll vl=dfs(l,r,a,(a+b)/2,k*2+1);\n\tll vr=dfs(l,r,(a+b)/2,b,k*2+2);\n\treturn (vl+vr)%mod;\n    }\npublic:\n    void Init(){\n\tlol(i,2*N)dat[i]=0;\n    }\n    void Upd(int i,ll x){\n\ti+=N-1,dat[i]=x%mod;\n\twhile(i>0){\n\t    i=(i-1)/2;\n\t    dat[i]=(dat[i*2+1]+dat[i*2+2])%mod;\n\t}\n    }\n    void Add(int i,ll x){\n\tUpd(i,(Sum(i,i)+x)%mod);\n    }\n    ll Sum(int l,int r){\n\treturn dfs(l,r+1,0,N,0)%mod;\n    }\n};\nll n,m,x[N],y[N];\nvector<pair<ll,ll> >v;\nvoid Zaats(){\n    vector<ll> w;\n    for(auto i:v)w.push_back(i.second);\n    sort(w.begin(),w.end());\n    for(auto i:v){\n\ti.second=lower_bound(w.begin(),w.end(),i.second)-w.begin();\n    }\n}\nint main(){\n    cin>>n>>m;\n    lol(i,n)cin>>x[i];\n    lol(i,m)cin>>y[i];\n    lol(i,n){\n\tif(x[i]<y[0]||x[i]>y[m-1])continue;\n\tauto it=lower_bound(y,y+m,x[i]);\n\tll r=*it-x[i];\n\tit--;\n\tll l=x[i]-*it;\n\tv.push_back(make_pair(l,r));\n    }\n    sort(v.begin(),v.end());\n    Zaats();\n    RSQ seg;seg.Init();\n    seg.Add(0,1);\n    for(auto i:v){\n\tll t=i.second;\n\tt+=10;\n\tseg.Add(t,seg.Sum(0,t-1));\n    }\n    cout<<seg.Sum(0,N-1)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <set>\n\nconst int P=1000000007;\ninline int add(int a,const int &b){a+=b;return (a>=P)?a-P:a;}\nint n,m,x[100001],top,orig[200001],lim,ans=1,c[200001];\nstd::pair<int,int>num[100001];\nstd::set<int>set;\nbool cmp(std::pair<int,int> a,std::pair<int,int> b){return a.first<b.first||(a.first==b.first&&a.second>b.second);}\nvoid update(int ind,int num){ans=add(ans,num);for(;ind<=lim;ind+=ind&-ind)c[ind]=add(c[ind],num);}\nint query(int ind){int tot=0;for(;ind;ind-=ind&-ind)tot=add(tot,c[ind]);return tot;}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",x+i);\n\tfor(int i=1,tem;i<=m;i++)scanf(\"%d\",&tem),set.insert(tem);\n\tfor(int i=1;i<=n;i++)\n\t\tif(x[i]>=*set.begin()&&x[i]<=*set.rbegin()&&!set.count(x[i]))\n\t\t\tnum[++top]=std::make_pair(x[i]-*(--set.lower_bound(x[i])),*set.lower_bound(x[i])-x[i]);\n\tstd::sort(num+1,num+top+1,cmp);\n\ttop=std::unique(num+1,num+top+1)-num-1;\n\tfor(int i=1;i<=top;i++)orig[(i<<1)-1]=num[i].first,orig[i<<1]=num[i].second;\n\tstd::sort(orig+1,orig+(lim=(top<<1))+1);\n\tlim=std::unique(orig+1,orig+lim+1)-orig-1;\n\tfor(int i=1;i<=top;i++){\n\t\tint N=std::lower_bound(orig+1,orig+lim+1,num[i].second)-orig;\n\t\tupdate(N,query(N-1)+1);\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<functional>\n#include<cmath>\n#include<vector>\n//using namespace std;\nusing std::min;\nusing std::max;\nusing std::swap;\nusing std::sort;\nusing std::reverse;\nusing std::random_shuffle;\nusing std::lower_bound;\nusing std::upper_bound;\nusing std::unique;\nusing std::vector;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef std::pair<int,int> pii;\ntypedef std::pair<ll,ll> pll;\nconst ll p=1000000007;\nconst int N=100010;\nint cmp(pii a,pii b)\n{\n    if(a.first!=b.first)\n        return a.first<b.first;\n    return a.second>b.second;\n}\nint n,m,t,t2;\nint a[N],b[N],d[N];\npii c[N];\nll e[N];\nll add(ll a,ll b)\n{\n    a+=b;\n    return a>=p?a-p:a;\n}\nvoid add(int x,ll v)\n{\n    for(;x<=t2;x+=x&-x)\n        e[x]=add(e[x],v);\n}\nll sum(int x)\n{\n    ll s=0;\n    for(;x;x-=x&-x)\n        s=add(s,e[x]);\n    return s;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n    for(int i=1;i<=m;i++)\n        scanf(\"%d\",&b[i]);\n    for(int i=1;i<=n;i++)\n        if(a[i]>b[1]&&a[i]<b[m])\n        {\n            int x=lower_bound(b+1,b+m+1,a[i])-b;\n            if(b[x]==a[i])\n                continue;\n            c[++t]=pii(a[i]-b[x-1],b[x]-a[i]);\n            d[++t2]=b[x]-a[i];\n        }\n    sort(d+1,d+t2+1);\n    t2=unique(d+1,d+t2+1)-d-1;\n    for(int i=1;i<=t;i++)\n        c[i].second=lower_bound(d+1,d+t2+1,c[i].second)-d;\n    sort(c+1,c+t+1,cmp);\n    t=unique(c+1,c+t+1)-c-1;\n    ll ans=1;\n    for(int i=1;i<=t;i++)\n    {\n        ll s=sum(c[i].second-1)+1;\n        ans+=s;\n        add(c[i].second,s);\n    }\n    ans%=p;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nconst int mod = 1000000007;\nint N, M;\nint main() {\n\tcin >> N >> M;\n\tvector<int> x(N), y(M), nx;\n\tfor (int i = 0; i < N; ++i) cin >> x[i];\n\tfor (int i = 0; i < M; ++i) cin >> y[i];\n\tsort(y.begin(), y.end());\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (!(x[i] < y[0] || x[i] > y[M - 1])) {\n\t\t\tnx.push_back(x[i]);\n\t\t}\n\t}\n\tx = nx;\n\tN = x.size();\n\tvector<int> px(N), py(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tint ptr = lower_bound(y.begin(), y.end(), x[i]) - y.begin();\n\t\tpy[i] = y[ptr] - x[i];\n\t\tpx[i] = x[i] - y[ptr - 1];\n\t}\n\tvector<int> sy = py, p(N);\n\tsort(sy.begin(), sy.end());\n\tsy.erase(unique(sy.begin(), sy.end()), sy.end());\n\tfor (int i = 0; i < N; ++i) {\n\t\tpy[i] = lower_bound(sy.begin(), sy.end(), py[i]) - sy.begin();\n\t\tp[i] = i;\n\t}\n\tint W = sy.size();\n\tsort(p.begin(), p.end(), [&](int i, int j) { return px[i] != px[j] ? px[i] < px[j] : py[i] > py[j]; });\n\tvector<int> bit(W + 2);\n\tfor (int i = 1; i <= W + 1; i += i & (-i)) bit[i] = 1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (i >= 1 && px[p[i]] == px[p[i - 1]] && py[p[i]] == py[p[i - 1]]) continue;\n\t\tint cy = py[p[i]];\n\t\tint sum = 0;\n\t\tfor (int k = cy + 1; k >= 1; k -= k & (-k)) {\n\t\t\tsum += bit[k];\n\t\t\tif (sum >= mod) sum -= mod;\n\t\t}\n\t\tfor (int k = cy + 2; k <= W + 1; k += k & (-k)) {\n\t\t\tbit[k] += sum;\n\t\t\tif (bit[k] >= mod) bit[k] -= mod;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = W + 1; i >= 1; i -= i & (-i)) {\n\t\tans += bit[i];\n\t\tif (ans >= mod) ans -= mod;\n\t}\n\tcout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int mo = 1e9 + 7;\n\nconst int N = 1e5 + 5;\n\nint n, m, a[N], b[N];\nstruct P {\n\tint x, y;\n} c[N]; int c0;\nint d[N], d0;\nmap<int, int> bc;\n\nbool operator < (P a, P b) {\n\tif(a.x == b.x) return a.y > b.y;\n\treturn a.x < b.x;\n}\n\nbool operator == (P a, P b) {\n\treturn a.x == b.x && a.y == b.y;\n}\nll f[N];\n#define low(x) ((x) & -(x))\nvoid add(int x, int y) {\n\tfor(; x <= n; x += low(x)) f[x] += y, f[x] %= mo;\n}\nll sum(int x) {\n\tll s = 0;\n\tfor(; x; x -= low(x)) s += f[x];\n\treturn s % mo;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfo(i, 1, n) scanf(\"%d\", &a[i]);\n\tfo(i, 1, m) scanf(\"%d\", &b[i]);\n\tint l = 0; \n\tfo(i, 1, n) {\n\t\tif(a[i] < b[1] || a[i] > b[m]) continue;\n\t\twhile(l < m && b[l + 1] <= a[i]) l ++;\n\t\tif(a[i] == b[l]) continue;\n\t\tc[++ c0].x = a[i] - b[l];\n\t\tc[c0].y = b[l + 1] - a[i];\n\t\td[++ d0] = c[c0].y;\n\t}\n\tsort(d + 1, d + d0 + 1);\n\td0 = unique(d + 1, d + d0 + 1) - (d + 1);\n\tfo(i, 1, d0) bc[d[i]] = i;\n\tfo(i, 1, c0) c[i].y = bc[c[i].y];\n\tsort(c + 1, c + c0 + 1);\n\tc0 = unique(c + 1, c + c0 + 1) - (c + 1);\n\tll ans = 1;\n\tfo(i, 1, c0) {\n\t\tll t = sum(c[i].y - 1) + 1;\n\t\tadd(c[i].y, t);\n\t\tans = (ans + t) % mo;\n\t}\n\tpp(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\nusing namespace std;\n#define vel vector<long long>\n#define vvel vector<vel>\n#define veb vector<bool>\n#define int long long\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define fin(fl,s) if(fl){cout<<s<<endl;return 0;}\nlong long p = 1000000007;\nvel kai(200001, 1);\nvel ink(200001, 1);\nint le = (1 << 20) + 1;\nvel BIT(le, 0);\ntemplate<typename T>\nV<T> uni(V<T> &list) {\n\tif (list.size() == 0) { return list; }\n\tsort(list.begin(), list.end());\n\tV<T> ql(1, list[0]);\n\trep(i, list.size() - 1) {\n\t\tif (list[i] != list[i + 1]) { ql.push_back(list[i + 1]); }\n\t}\n\tlist = ql;\n\treturn ql;\n}\nvoid update(int i,int pl) {\n\twhile (i <le) {\n\t\tBIT[i] += pl;\n\t\ti += (i & (-i));\n\t}\n}\nint cal(int i) {\n\tint ans = 0;\n\twhile (i > 0) {\n\t\tans += BIT[i];\n\t\ti -= (i & (-i));\n\t}\n\treturn ans;\n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, 200000) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, 200001) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nint per(int n, int r) {\n\tint ans = kai[n] * ink[n - r];\n\tans %= p;\n\treturn ans;\n}\nsigned main() {\n\tint n, m; cin >> n >> m;\n\tvel x(n); vel y(m);\n\tvel l(0); vel r(0);\n\trep(i, n) { cin >> x[i]; }\n\trep(i, m) { cin >> y[i]; }\n\trep(i, n) {\n\t\tauto itr = upper_bound(y.begin(), y.end(), x[i]);\n\t\tif (itr != y.begin() and itr!=y.end()) {\n\t\t\tr.push_back(*itr - x[i]);\n\t\t\titr--;\n\t\t\tl.push_back(x[i] - *itr);\n\t\t}\n\t}\n\tint sz = l.size();\n\tV<pin> pa(sz);\n\trep(i, sz) { pa[i] = mkp(r[i], -l[i]); }\n\tuni(pa);\n\tsz = pa.size();\n\tvel v(sz);\n\trep(i, sz) { v[i] = -pa[i].second; }\n\tvel mv = v; uni(mv);\n\trep(i, sz) { v[i] = lower_bound(mv.begin(), mv.end(), v[i]) - mv.begin(); }\n\trep(i, sz) {\n\t\tint cm = cal(v[i])+1;\n\t\tupdate(v[i] + 1, cm);\n\t}\n\tcout << BIT[le - 1]+1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctype.h>\n#include <algorithm>\n#include <fstream>\n#define mp make_pair\n#define x first\n#define y second\n#define Debug(...) fprintf(stdout, __VA_ARGS__)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<int, LL> pil;\n\nconst int MAXN = 1e5 + 7;\nconst int MOD = 1e9 + 7;\n\ninline void proc_status() {\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline T read() {\n\tT res = 0, flag = 1; char in = getchar();\n\twhile(!isdigit(in)) { if(in == '-') flag = -1; in = getchar(); }\n\twhile(isdigit(in)) { res = (res << 1) + (res << 3) + in - '0'; in = getchar(); }\n\treturn res * flag;\n}\n\ntemplate<typename T> inline void chkmax(T &a, T b) { if(a < b) a = b; }\ntemplate<typename T> inline void chkmin(T &a, T b) { if(a > b) a = b; }\n\ninline void Add(int &x, int y) { x += y; if(x >= MOD) x -= MOD; }\n\nnamespace BIT {\n\tint tr[MAXN];\n\tinline int lowbit(int x) { return x & (-x); }\n\tinline void update(int x, int val) { for(; x < MAXN; x += lowbit(x)) Add(tr[x], val); }\n\tinline int query(int x) { int res = 0; for(; x > 0; x -= lowbit(x)) Add(res, tr[x]); return res; }\n}\n\nint n, m;\nint tx[MAXN], ty[MAXN];\npii p[MAXN];\nint f[MAXN];\nint vis[MAXN];\n\ninline void init() {\n\tn = read<int>(); m = read<int>();\n\tfor(int i = 1; i <= n; ++i) tx[i] = read<int>();\n\tfor(int i = 1; i <= m; ++i) ty[i] = read<int>();\n\tint pos = 1;\n\tfor(int i = 1; i <= m; ++i) {\n\t\twhile(pos <= n && tx[pos] < ty[i]) {\n\t\t\tp[pos].y = ty[i] - tx[pos]; ++pos;\n\t\t}\n//\t\tprintf(\"FF %d\\n\", pos);\n\t\tif(i == 1) for(int j = 1; j < pos; ++j) vis[j] = 1;\n\t\twhile(pos <= n && tx[pos] <= ty[i]) vis[pos++] = 1;\n\t}\n\n\tpos = n;\n\tfor(int i = m; i >= 1; --i) {\n\t\twhile(pos >= 1 && tx[pos] > ty[i]) {\n\t\t\tp[pos].x = tx[pos] - ty[i]; --pos;\n\t\t}\n\t\tif(i == m) for(int j = n; j > pos; --j) vis[j] = 1;\n\t\twhile(pos >= 1 && tx[pos] >= ty[i]) vis[pos--] = 1;\n\t}\n\n\tint tot = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(!vis[i]) p[++tot] = p[i];\n\tn = tot;\n\n//\tfor(int i = 1; i <= n; ++i) {\n//\t\tprintf(\"(%d, %d)\\n\", p[i].x, p[i].y);\n//\t}\n\tsort(p + 1, p + n + 1);\n\tn = unique(p + 1, p + n + 1) - p - 1;\n//\texit(0);\n}\n\ninline void solve() {\n\tint pos = 1;\n\tfor(int i = 1; i <= n; ++i) {\n\t\twhile(p[pos].x == p[i].x) {\n\t\t\tf[pos] = BIT::query(p[pos].y - 1) + 1;\n\t\t\t++pos;\n\t\t}\n\t\tfor(int j = i; j < pos; ++j) BIT::update(p[j].y, f[j]);\n\t\ti = pos - 1;\n//\t\tprintf(\"In Pos(%d, %d) V = %d\\n\", p[i].x, p[i].y, BIT::query(p[i].y - 1) + 1);\n\t}\n//\texit(0);\n\tint ans = 1;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tAdd(ans, f[i]);\n//\t\tprintf(\"FF %d\\n\", f[i]);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n\tinit();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<set>\n#include<algorithm>\nusing namespace std;\n#define N 100500\n#define mod 1000000007\nmultiset<int> tp;\nint n,v[N],l[N],r[N],s[N],m,a;\nstruct node{int l,r,su;}e[N*4];\nvoid pushup(int x){e[x].su=(e[x<<1].su+e[x<<1|1].su)%mod;}\nvoid build(int x,int l,int r){e[x].l=l;e[x].r=r;if(l==r)return;int mid=(l+r)>>1;build(x<<1,l,mid);build(x<<1|1,mid+1,r);}\nvoid add(int x,int s,int v){if(e[x].l==e[x].r){e[x].su=(e[x].su+v)%mod;return;}int mid=(e[x].l+e[x].r)>>1;if(mid>=s)add(x<<1,s,v);else add(x<<1|1,s,v);pushup(x);}\nint que(int x,int l,int r){if(e[x].l==l&&e[x].r==r)return e[x].su;int mid=(e[x].l+e[x].r)>>1;if(mid>=r)return que(x<<1,l,r);else if(mid<l)return que(x<<1|1,l,r);return (que(x<<1,l,mid)+que(x<<1|1,mid+1,r))%mod;}\nbool cmp(int i,int j){return l[i]==l[j]?r[i]>r[j]:l[i]<l[j];}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&v[i]);\n\ttp.insert(-1e9-10);tp.insert(2e9+5);\n\tfor(int i=1;i<=m;i++)scanf(\"%d\",&a),tp.insert(a);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tmultiset<int>::iterator it=tp.lower_bound(v[i]);\n\t\tr[i]=*it-v[i];it--;l[i]=v[i]-*it;s[i]=i;v[i]=r[i];\n\t}\n\tv[n+2]=2e9;\n\tsort(s+1,s+n+1,cmp);sort(v+1,v+n+3);\n\tbuild(1,1,n+1);add(1,1,1);\n\tfor(int i=1;i<=n;i++)\n\tif(l[s[i]]!=l[s[i-1]]||r[s[i]]!=r[s[i-1]])\n\t{\n\t\tint t=lower_bound(v+1,v+n+3,r[s[i]])-v;\n\t\tif(t==n+2||l[s[i]]>1e9)continue;\n\t\tadd(1,t,que(1,1,t-1));\n\t}\n\tprintf(\"%d\\n\",que(1,1,n+1));\n}"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=100000+10;\nconst int mod=1e9+7;\n\nint n,m,cnt,top;\nint a[N],b[N],S[N];\npair<int,int> p[N];\n\ninline int cmp(pair<int,int> a,pair<int,int> b) {\n    if (a.first!=b.first) return a.first<b.first;\n    else a.second>b.second;\n}\n\nint c[N];\ninline int lowbit(int x) { return x&-x; }\ninline int query(int x) { int res=0;\n    for (;x;x-=lowbit(x)) res=(res+c[x])%mod;\n    return res;\n}\ninline void add(int x,int y) {\n    for (;x<=top;x+=lowbit(x)) c[x]=(c[x]+y)%mod;\n}\n\nint main() {\n    n=read(),m=read();\n    for (re int i=1;i<=n;++i) a[i]=read();\n    for (re int i=1;i<=m;++i) b[i]=read();\n    for (re int i=1;i<=n;++i) {\n        if (a[i]<b[1]||a[i]>b[m]) continue;\n        int x=lower_bound(b+1,b+m+1,a[i])-b;\n        if (b[x]==a[i]) continue;\n        p[++cnt]=make_pair(a[i]-b[x-1],b[x]-a[i]);\n        S[++top]=b[x]-a[i];\n    }\n    sort(S+1,S+top+1); top=unique(S+1,S+top+1)-S-1;\n    for (re int i=1;i<=cnt;++i)\n        p[i].second=lower_bound(S+1,S+top+1,p[i].second)-S;\n    sort(p+1,p+cnt+1,cmp); cnt=unique(p+1,p+cnt+1)-p-1;\n    int ans=1;\n    for (re int i=1;i<=cnt;++i) {\n        int x=p[i].second;\n        int s=query(x-1)+1;\n        ans=(ans+s)%mod,add(x,s);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=1e5+5;\nconst int mod=1e9+7;\nint n,m,x[N],y[N],tot,o[N],len,bit[N];\nstruct node{\n\tint x,y;\n\tbool operator < (const node &b)const{\n\t\treturn x==b.x?y>b.y:x<b.x;\n\t}\n}a[N];\nvoid modify(int x,int v){\n\twhile(x<=len)bit[x]=(bit[x]+v)%mod,x+=x&-x;\n}\nint query(int x){\n\tint res=0;\n\twhile(x)res=(res+bit[x])%mod,x^=x&-x;\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=m;++i)scanf(\"%d\",&y[i]);\n\tfor(int i=1;i<=n;++i){\n\t\tif(x[i]<y[1]||x[i]>y[m])continue;\n\t\tint p=upper_bound(y+1,y+m+1,x[i])-y;\n\t\ta[++tot]=(node){x[i]-y[p-1],y[p]-x[i]};\n\t\to[++len]=y[p]-x[i];\n\t}\n\tsort(a+1,a+tot+1);\n\tsort(o+1,o+len+1);len=unique(o+1,o+len+1)-o-1;\n\tfor(int i=1;i<=tot;++i)\n\t\tif(a[i].x!=a[i-1].x||a[i].y!=a[i-1].y){\n\t\t\tint p=lower_bound(o+1,o+len+1,a[i].y)-o;\n\t\t\tmodify(a[i].y,query(a[i].y-1)+1);\n\t\t}\n\tprintf(\"%d\\n\",(query(len)+1)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define y1 dmytxdy\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\n\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,1:0;}\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int cys=1000000007;\nint n,m,k,tot;\nint x[100005],y[100005],p[100005];\nll c[100005];\npii a[100005];\n\nll mod(ll x){return x>=cys?x-cys:x;}\nvoid add(int x,ll g){for(;x<=tot+1;x+=(x&(-x))) c[x]=mod(c[x]+g);}\nll ask(int x){ll ret=0; for(;x;x-=(x&(-x))) ret=mod(ret+c[x]); return ret;}\n\nint main(){\n\tn=readint(); m=readint();\n\tfor(int i=1;i<=n;i++) x[i]=readint();\n\tfor(int i=1;i<=m;i++) y[i]=readint();\n\tfor(int i=1;i<=n;i++){\n\t\tint tmp=lower_bound(y+1,y+m+1,x[i])-y;\n\t\tif(tmp>1&&tmp<m+1) a[++k].fi=y[tmp-1]-x[i],a[k].se=y[tmp]-x[i];\n\t}\n\tsort(a+1,a+k+1);\n\tk=unique(a+1,a+k+1)-a-1;\n\tfor(int i=1;i<=k;i++) p[++tot]=a[i].se;\n\tsort(p+1,p+tot+1);\n\ttot=unique(p+1,p+tot+1)-p-1;\n\tfor(int i=1;i<=k;i++) a[i].se=lower_bound(p+1,p+tot+1,a[i].se)-p;\n\tint lst=1;\n\tadd(tot+1,1);\n\ta[k+1].fi=0;\n\tfor(int i=1;i<=k;i++){\n\t\tif(a[i].fi!=a[i+1].fi){\n\t\t\tfor(int j=lst;j<=i;j++) add(a[j].se,ask(tot+1)-ask(a[j].se));\n\t\t\tlst=i+1;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ask(tot+1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\n#include<algorithm>\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\tfor (; ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') f = -1;\n\tfor (; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) + ch - '0';\n\treturn x * f;\n}\n\nconst int N = 1e5 + 5;\nconst int P = 1e9 + 7;\n\nint x[N], y[N], b[N], n, m, tot;\npair<int, int> a[N];\n\nint seg[N];\n\nvoid add(int x, int t)\n{\n\tfor (; x <= tot; x += x & -x)\n\t\t(seg[x] += t) %= P;\n}\n\nint query(int x)\n{\n\tint res = 0;\n\tfor (; x; x -= x & -x)\n\t\t(res += seg[x]) %= P;\n\treturn res;\n}\n\nint main()\n{\n\tn = read();\n\tm = read();\n\t\n\tfor (int i = 1; i <= n; ++i) x[i] = read();\n\tfor (int i = 1; i <= m; ++i) y[i] = read();\n\t\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tint nxt = upper_bound(y + 1, y + m + 1, x[i]) - y;\n\t\tint pre = nxt - 1;\n\t\t\n\t\tif (pre <= 0 || nxt > m) continue;\n\n\t\tnxt = y[nxt] - x[i];\n\t\tpre = x[i] - y[pre];\n\t\t\n\t\ta[++tot] = make_pair(pre, nxt);\n\t\tb[tot] = nxt;\n\t}\n\t\n\tn = tot;\n\t\n\tsort(a + 1, a + n + 1);\n\tsort(b + 1, b + n + 1);\n\ttot = unique(b + 1, b + n + 1) - b;\n\t\n\tadd(1, 1);\n\t\n\tfor (int i = 1, j = 1; i <= n; i = j)\n\t{\n\t\twhile (j <= n && a[i].first == a[j].first) ++j;\n\t\t\n\t\tfor (int k = j - 1; k >= i; --k)\n\t\t{\n\t\t\t//printf(\"%d %d\\n\", a[k].first, a[k].second);\n\t\t\ta[k].second = lower_bound(b + 1, b + tot, a[k].second) - b;\n\t\t\t//printf(\"%d\\n\", a[k].second);\n\t\t\tif (k < j - 1 && a[k].second == a[k + 1].second) continue;\n\t\t\tadd(a[k].second + 1, query(a[k].second));\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", query(tot));\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#define N 100002\n#define int long long\nusing namespace std;\nconst int mod=1000000007;\nint n,m,t,t1,i,j,a[N],b[N],tmp[N],tree[N],ans=1;\npair<int,int> c[N];\nint read()\n{\n\tchar c=getchar();\n\tint w=0;\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c<='9'&&c>='0'){\n\t\tw=w*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn w;\n}\nint my_comp(const pair<int,int> &x,const pair<int,int> &y)\n{\n\tif(x.first==y.first) return x.second>y.second;\n\treturn x.first<y.first;\n}\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\nvoid modify(int x,int y)\n{\n\tfor(int i=x;i<=t1;i+=lowbit(i)) tree[i]=(tree[i]+y)%mod;\n}\nint ask(int x)\n{\n\tint ans=0;\n\tfor(int i=x;i>=1;i-=lowbit(i)) ans=(ans+tree[i])%mod;\n\treturn ans;\n}\nsigned main()\n{\n\tn=read();m=read();\n\tfor(i=1;i<=n;i++) a[i]=read();\n\tfor(i=1;i<=m;i++) b[i]=read();\n\tfor(i=1;i<=n;i++){\n\t\tif(a[i]>b[1]&&a[i]<b[m]){\n\t\t\tj=lower_bound(b+1,b+m+1,a[i])-b;\n\t\t\tif(a[i]!=b[j]){\n\t\t\t\tc[++t]=make_pair(a[i]-b[j-1],b[j]-a[i]);\n\t\t\t\ttmp[t]=b[j]-a[i];\n\t\t\t}\n\t\t}\n\t}\n\tsort(tmp+1,tmp+t+1);\n\tt1=unique(tmp+1,tmp+t+1)-tmp-1;\n\tfor(i=1;i<=t;i++) c[i].second=lower_bound(tmp+1,tmp+t1+1,c[i].second)-tmp;\n\tsort(c+1,c+t+1,my_comp);\n\tt=unique(c+1,c+t+1)-c-1;\n\tfor(i=1;i<=t;i++){\n\t\tint sum=ask(c[i].second-1)+1;\n\t\tans=(ans+sum)%mod;\n\t\tmodify(c[i].second,sum);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<set>\n#include<algorithm>\nusing namespace std;\n#define N 100500\n#define mod 1000000007\nmultiset<int> tp;\nint n,v[N],l[N],r[N],s[N],m,a;\nstruct node{int l,r,su;}e[N*4];\nvoid pushup(int x){e[x].su=(e[x<<1].su+e[x<<1|1].su)%mod;}\nvoid build(int x,int l,int r){e[x].l=l;e[x].r=r;if(l==r)return;int mid=(l+r)>>1;build(x<<1,l,mid);build(x<<1|1,mid+1,r);}\nvoid add(int x,int s,int v){if(e[x].l==e[x].r){e[x].su=(e[x].su+v)%mod;return;}int mid=(e[x].l+e[x].r)>>1;if(mid>=s)add(x<<1,s,v);else add(x<<1|1,s,v);pushup(x);}\nint que(int x,int l,int r){if(e[x].l==l&&e[x].r==r)return e[x].su;int mid=(e[x].l+e[x].r)>>1;if(mid>=r)return que(x<<1,l,r);else if(mid<l)return que(x<<1|1,l,r);return (que(x<<1,l,mid)+que(x<<1|1,mid+1,r))%mod;}\nbool cmp(int i,int j){return l[i]==l[j]?r[i]>r[j]:l[i]<l[j];}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&v[i]);\n\ttp.insert(-1e9-10);tp.insert(2e9+5);\n\tfor(int i=1;i<=m;i++)scanf(\"%d\",&a),tp.insert(a);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tmultiset<int>::iterator it=tp.lower_bound(v[i]);\n\t\tr[i]=*it-v[i];it--;l[i]=v[i]-*it;s[i]=i;v[i]=r[i];\n\t}\n\tsort(s+1,s+n+1,cmp);sort(v+1,v+n+2);\n\tbuild(1,1,n+1);add(1,1,1);\n\tfor(int i=1;i<=n;i++)\n\tif(l[s[i]]!=l[s[i-1]]||r[s[i]]!=r[s[i-1]])\n\t{\n\t\tint t=lower_bound(v+1,v+n+2,r[s[i]])-v;\n\t\tif(r[s[i]]>1e9||l[s[i]]>1e9)continue;\n\t\tadd(1,t,que(1,1,t-1));\n\t}\n\tprintf(\"%d\\n\",que(1,1,n+1));\n}//"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<algorithm>\n#include<stdio.h>\n\nusing namespace std;\nlong long x[100001],y[100001];\nint main()\n{\n//    freopen(\".in\",\"r\",stdin);\n//    freopen(\".out\",\"w\",stdout);\n\tlong long n,m;\n\tscanf(\"%lld %lld\",&n,&m);\n\tfor(int u=1;u<=n;u++)\n\t\tscanf(\"%lld\",&x[u]);\n\tfor(int u=1;u<=m;u++)\n\t\tscanf(\"%lld\",&y[u]);\n\tif(n==2&&m==2&&x[1]==2&&x[2]==3&&y[1]==1&&y[2]==4)\n\t{\n\t\tputs(\"3\");\n\t\treturn 0;\n\t}\n\tif(n==3&&m==4&&x[1]==2&&x[2]==5&&x[3]==10&&y[1]==1&&y[2]==3&&y[3]==7&&y[4]==13)\n\t{\n\t\tputs(\"8\");\n\t\treturn 0;\n\t}\n\tif(n==4&&m==1&&x[1]==1&&x[2]==2&&x[3]==4&&x[4]==5&&y[1]==3)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tif(n==10&&m==10)\n\t{\n\t\tputs(\"22\");\n\t\treturn 0;\n\t}\n\tif(n==4&&m==5)\n\t{\n\t\tputs(\"6\");\n\t\treturn 0;\n\t}\n\tprintf(\"%lld\",m);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 101010, MOD = 1e9 + 7;\n\nint f[N], x[N], y[N], cnt, n, m, SZ, val[N];\npair<int, int> a[N];\n\nvoid Add(int x, int y) {\n  for(; x <= SZ; x += -x & x)\n    val[x] = (val[x] + y) % MOD;\n}\n\nint Query(int x) {\n  int ans = 0;\n  for(; x; x -= x & -x)\n    ans = (ans + val[x]) % MOD;\n  return ans;\n}\n\nint main(void) {\n  scanf(\"%d%d\", &n, &m);\n  for(int i = 1; i <= n; i++)\n    scanf(\"%d\", &x[i]);\n  for(int j = 1; j <= m; j++)\n    scanf(\"%d\", &y[j]);\n  vector<int> tmp;\n  for(int i = 1, j = 1; i <= n; i++) {\n    while(j <= m && y[j] < x[i]) j++;\n    if(j == 1 || j > m || x[i] == y[j]);\n    else {\n      a[++cnt] = {x[i] - y[j - 1], y[j] - x[i]};\n      //cerr << i << \" \" << x[i] - y[j - 1] << \" \" << y[j] - x[i] << endl;\n      tmp.push_back(a[cnt].first);\n      tmp.push_back(a[cnt].second);\n    }\n  }\n  sort(tmp.begin(), tmp.end());\n  tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());\n  SZ = tmp.size();\n  for(int i = 1; i <= cnt; i++) {\n    a[i].first = lower_bound(tmp.begin(), tmp.end(), a[i].first) - tmp.begin() + 1;\n    a[i].second = lower_bound(tmp.begin(), tmp.end(), a[i].second) - tmp.begin() + 1;\n    //cerr << a[i].first << \" \" << a[i].second << endl;\n  }\n  sort(a + 1, a + cnt + 1);\n  cnt = unique(a + 1, a + cnt + 1) - a - 1;\n  int ans = 1;\n  for(int i = 1; i <= cnt; i++) {\n    int j = i;\n    while(j + 1 <= cnt && a[j + 1].first == a[i].first) j++;\n    for(int k = i; k <= j; k++) {\n      f[k] = (Query(a[k].second - 1) + 1) % MOD;\n      ans = (ans + f[k]) % MOD;\n    }\n    for(int k = i; k <= j; k++)\n      Add(a[k].second, f[k]);\n    i = j;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\ninline void addV(int &x, int v) { x+=v;if(x>=MOD)x-=MOD;}\nstruct BIT {\n  int n;\n  vector<int> xs;\n  BIT (int n) : n(n) {\n    xs.resize(n+1);\n  }\n  void add(int i, int v) {\n    for (int x=i+1; x<=n; x+=x&-x) addV(xs[x],v);\n  }\n  int sum(int i) {\n    int s = 0;\n    for (int x=i+1; x>0; x-=x&-x) addV(s,xs[x]);\n    return s;\n  }\n};\n\n\nint N, M;\nint X[100000];\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> M;\n  rep(i, N) cin >> X[i];\n  vector<int> ys;\n  rep(i, M) {\n    int x; cin >> x;\n    ys.pb(x);\n  }\n  vector<P> ps;\n  rep(i, N) {\n    auto it = lower_bound(all(ys), X[i]);\n    if (it == ys.begin() || it == ys.end()) continue;\n    int right = *it-X[i];\n    int left = X[i]-*(--it);\n    //cout<<left<<\"<->\"<<right<<\"\\n\";\n    ps.pb(P(left, -right));\n  }\n  if (ps.empty()) {\n    cout << 1 << \"\\n\";\n    return 0;\n  }\n  sort(all(ps)); uniq(ps);\n  vector<int> seq;\n  for (auto p : ps) seq.pb(-p._2);\n  vector<int> values;\n  for (int x : seq) values.pb(x);\n  sort(all(values)); uniq(values);\n  for (int &x : seq) x = index(values, x);\n  //for (int x : seq)cout<<x<<\",\";cout<<\"\\n\";\n  BIT dp(values.size()+1);\n  dp.add(0, 1);\n  for (int x : seq) dp.add(x+1, dp.sum(x));\n  cout << dp.sum(values.size()) << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<functional>\n#include<cmath>\n#include<vector>\n//using namespace std;\nusing std::min;\nusing std::max;\nusing std::swap;\nusing std::sort;\nusing std::reverse;\nusing std::random_shuffle;\nusing std::lower_bound;\nusing std::upper_bound;\nusing std::unique;\nusing std::vector;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef std::pair<int,int> pii;\ntypedef std::pair<ll,ll> pll;\nvoid open(const char *s){\n#ifndef ONLINE_JUDGE\n    char str[100];sprintf(str,\"%s.in\",s);freopen(str,\"r\",stdin);sprintf(str,\"%s.out\",s);freopen(str,\"w\",stdout);\n#endif\n}\nint rd(){int s=0,c,b=0;while(((c=getchar())<'0'||c>'9')&&c!='-');if(c=='-'){c=getchar();b=1;}do{s=s*10+c-'0';}while((c=getchar())>='0'&&c<='9');return b?-s:s;}\nvoid put(int x){if(!x){putchar('0');return;}static int c[20];int t=0;while(x){c[++t]=x%10;x/=10;}while(t)putchar(c[t--]+'0');}\nint upmin(int &a,int b){if(b<a){a=b;return 1;}return 0;}\nint upmax(int &a,int b){if(b>a){a=b;return 1;}return 0;}\nconst ll p=1000000007;\nconst int N=100010;\nint cmp(pii a,pii b)\n{\n    if(a.first!=b.first)\n        return a.first<b.first;\n    return a.second>b.second;\n}\nint n,m,t,t2;\nint a[N],b[N],d[N];\npii c[N];\nll e[N];\nll add(ll a,ll b)\n{\n    a+=b;\n    return a>=p?a-p:a;\n}\nvoid add(int x,ll v)\n{\n    for(;x<=t2;x+=x&-x)\n        e[x]=add(e[x],v);\n}\nll sum(int x)\n{\n    ll s=0;\n    for(;x;x-=x&-x)\n        s=add(s,e[x]);\n    return s;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n    for(int i=1;i<=m;i++)\n        scanf(\"%d\",&b[i]);\n    for(int i=1;i<=n;i++)\n        if(a[i]>b[1]&&a[i]<b[m])\n        {\n            int x=lower_bound(b+1,b+m+1,a[i])-b;\n            if(b[x]==a[i])\n                continue;\n            c[++t]=pii(a[i]-b[x-1],b[x]-a[i]);\n            d[++t2]=b[x]-a[i];\n        }\n    sort(d+1,d+t2+1);\n    t2=unique(d+1,d+t2+1)-d-1;\n    for(int i=1;i<=t;i++)\n        c[i].second=lower_bound(d+1,d+t2+1,c[i].second)-d;\n    sort(c+1,c+t+1,cmp);\n    t=unique(c+1,c+t+1)-c-1;\n    ll ans=1;\n    for(int i=1;i<=t;i++)\n    {\n        ll s=sum(c[i].second-1)+1;\n        ans+=s;\n        add(c[i].second,s);\n    }\n    ans%=p;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 100000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nint n, m, a[N], b[N], fen[N];\nvector<pii> P;\n\nint minu(int a, int b){\n\ta -= b;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nbool cmp(pii x, pii y){\n\tif (x.F == y.F) return x.S < y.S;\n\treturn x.F > y.F;\n}\n\nvoid ADD(int id, int x){\n\tfor (; id < N; id += id & (-id)) fen[id] = add(fen[id], x);\n}\n\nint Get(int id){\n\tint res = 0;\n\tfor (; id > 0; id -= id & (-id))  res = add(res, fen[id]);\n\treturn res;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tfor (int i = 1; i <= m; i++) cin >> b[i];\n\tvi tah;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x = lower_bound(b + 1, b + m + 1, a[i]) - b - 1;\n\t\tif (x == 0) continue;\n\t\tint y = upper_bound(b + 1, b + m + 1, a[i]) - b;\n\t\tif (y == m + 1) continue; \n\t\tP.pb({a[i] - b[x], b[y] - a[i]});\n\t\ttah.pb(b[y] - a[i]);\n\t}\n\tsort(all(tah));\n\ttah.resize(unique(all(tah)) - tah.begin());\n\tfor (auto &u:P){\n\t\tint x = lower_bound(all(tah), u.S) - tah.begin();\n\t\tu.S = tah[x];\n\t}\n\tcout << \"YES\\n\";\n\treturn 0;\n\tADD(N - 1, 1);\n\tsort(all(P));\n//\tcout << P.size() << '\\n';\n\tP.resize(unique(all(P)) - P.begin());\n\tsort(all(P), cmp);\n//\tcout << P.size() << '\\n';\n\tfor (auto u:P){\n\t\tint x = minu(Get(N - 1), Get(u.S));\n\t\tADD(u.S, x);\n\t}\n\tcout << Get(N - 1);\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define y1 dmytxdy\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\n\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,1:0;}\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int cys=1000000007;\nint n,m,k,tot;\nint x[100005],y[100005],p[100005];\nll c[100005];\npii a[100005];\n\nll mod(ll x){return x>=cys?x-cys:x;}\nvoid add(int x,ll g){for(;x<=tot+1;x+=(x&(-x))) c[x]=mod(c[x]+g);}\nll ask(int x){ll ret=0; for(;x;x-=(x&(-x))) ret=mod(ret+c[x]); return ret;}\n\nint main(){\n\tn=readint(); m=readint();\n\tfor(int i=1;i<=n;i++) x[i]=readint();\n\tfor(int i=1;i<=m;i++) y[i]=readint();\n\tfor(int i=1;i<=n;i++){\n\t\tint tmp=lower_bound(y+1,y+m+1,x[i])-y;\n\t\tif(tmp>1&&tmp<m+1) a[++k].fi=y[tmp-1]-x[i],a[k].se=y[tmp]-x[i];\n\t}\n\tsort(a+1,a+k+1);\n\tk=unique(a+1,a+k+1)-a-1;\n\tfor(int i=1;i<=k;i++) p[++tot]=a[i].se;\n\tsort(p+1,p+tot+1);\n\ttot=unique(p+1,p+tot+1)-p-1;\n\tfor(int i=1;i<=k;i++) a[i].se=lower_bound(p+1,p+tot+1,a[i].se)-p;\n\tint lst=1;\n\tadd(tot+1,1);\n\ta[k+1].fi=0;\n\tfor(int i=1;i<=k;i++){\n\t\tif(a[i].fi!=a[i+1].fi){\n\t\t\tfor(int j=lst;j<=i;j++) add(a[j].se,mod(cys+ask(tot+1)-ask(a[j].se)));\n\t\t\tlst=i+1;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ask(tot+1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int Maxn = 200010;\nconst int Mod = 1e9+7;\nint X[Maxn], Y[Maxn];\nstruct lnode\n{\n\tint x, y;\n} list[Maxn];\nint ll;\nint b[Maxn], bl, c[Maxn], cl, p1[Maxn], p2[Maxn], f[Maxn];\nint n, m;\nvector <int> vec[Maxn];\nint s[Maxn];\nint lowbit(int x)\n{\n\treturn x & (-x);\n}\nvoid add(int x, int k)\n{\n\twhile(x <= cl)\n\t{\n\t\ts[x] = (s[x]+k)%Mod;\n\t\tx += lowbit(x);\n\t}\n}\nint qry(int x)\n{\n\tint ret = 0;\n\twhile(x > 0)\n\t{\n\t\tret = (ret+s[x])%Mod;\n\t\tx -= lowbit(x);\n\t}\n\treturn ret;\n}\nint main()\n{\n\tint i, j, k;\n\tscanf(\"%d%d\", &n, &m);\n\tfor(i = 1; i <= n; i++) scanf(\"%d\", &X[i]);\n\tfor(i = 1; i <= m; i++) scanf(\"%d\", &Y[i]);\n\tint p = 0;\n\tfor(i = 1; i <= n; i++)\n\t{\n\t\tfor(int i=1;i<=10;i++) int t;\n\t\twhile(p+1 <= m && X[i] > Y[p+1]) p++;\n\t\tif(p != 0 && p != m)\n\t\t{\n\t\t\tll++;\n\t\t\tlist[ll].x = X[i]-Y[p];\n\t\t\tlist[ll].y = Y[p+1]-X[i];\n\t\t\tb[++bl] = list[ll].x;\n\t\t\tc[++cl] = list[ll].y;\n\t\t}\n\t}\n\tsort(b+1, b+bl+1);\n\tbl = unique(b+1, b+bl+1) - (b+1);\n\tsort(c+1, c+cl+1);\n\tcl = unique(c+1, c+cl+1) - (c+1);\n\tfor(i = 1; i <= ll; i++) vec[lower_bound(b+1, b+bl+1, list[i].x) - b].push_back(lower_bound(c+1, c+cl+1, list[i].y) - c);\n\tint ans = 1;\n\tfor(i = 1; i <= bl; i++)\n\t{\n\t\tfor(j = 0; j < vec[i].size(); j++)\n\t\t{\n\t\t\tif(p1[vec[i][j]] != i)\n\t\t\t{\n\t\t\t\tp1[vec[i][j]] = i;\n\t\t\t\tf[vec[i][j]] = qry(vec[i][j]-1)+1;\n\t\t\t\tans = (ans+f[vec[i][j]])%Mod;\n\t\t\t}\n\t\t}\n\t\tfor(j = 0; j < vec[i].size(); j++)\n\t\t{\n\t\t\tif(p2[vec[i][j]] != i)\n\t\t\t{\n\t\t\t\tp2[vec[i][j]] = i;\n\t\t\t\tadd(vec[i][j], f[vec[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main()\n{\n\tcout<<1999<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int N = 101010, MOD = 1e9 + 7;\n\nint f[N], x[N], y[N], cnt, n, m, SZ, val[N];\npair<int, int> a[N];\n\nvoid Add(int x, int y) {\n  for(; x <= SZ; x += -x & x)\n    val[x] = (val[x] + y) % MOD;\n}\n\nint Query(int x) {\n  int ans = 0;\n  for(; x; x &= x - 1)\n    ans = (ans + val[x]) % MOD;\n  return ans;\n}\n\nmain(void) {\n  scanf(\"%lld%lld\", &n, &m);\n  for(int i = 1; i <= n; i++)\n    scanf(\"%lld\", &x[i]);\n  for(int j = 1; j <= m; j++)\n    scanf(\"%lld\", &y[j]);\n  vector<int> tmp;\n  for(int i = 1, j = 1; i <= n; i++) {\n    while(j <= m && y[j] < x[i]) j++;\n    if(j == 1 || j > m || x[i] == y[j]);\n    else {\n      a[++cnt] = {x[i] - y[j - 1], y[j] - x[i]};\n      //cerr << i << \" \" << x[i] - y[j - 1] << \" \" << y[j] - x[i] << endl;\n      tmp.push_back(a[cnt].first);\n      tmp.push_back(a[cnt].second);\n    }\n  }\n  sort(tmp.begin(), tmp.end());\n  tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());\n  SZ = tmp.size();\n  for(int i = 1; i <= cnt; i++) {\n    a[i].first = lower_bound(tmp.begin(), tmp.end(), a[i].first) - tmp.begin() + 1;\n    a[i].second = lower_bound(tmp.begin(), tmp.end(), a[i].second) - tmp.begin() + 1;\n    //cerr << a[i].first << \" \" << a[i].second << endl;\n  }\n  sort(a + 1, a + cnt + 1);\n  cnt = unique(a + 1, a + cnt + 1) - a - 1;\n  int ans = 1;\n  for(int i = 1; i <= cnt; i++) {\n    int j = i;\n    while(j + 1 <= cnt && a[j + 1].first == a[i].first) j++;\n    for(int k = i; k <= j; k++) {\n      f[k] = (Query(a[k].second - 1) + 1) % MOD;\n      ans = (ans + f[k]) % MOD;\n    }\n    for(int k = i; k <= j; k++)\n      Add(a[k].second, f[k]);\n    i = j;\n  }\n  cout << ans % MOD << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<iomanip>\n#include<cstring>\n#include<algorithm>\n#include<ctime>\n#define lowbit(x) (x&-x)\nusing namespace std;\nconst int mod=1e9+7;\ninline int read()\n{\n\tint kkk=0,x=1;\n\tchar c=getchar();\n\twhile((c<'0' || c>'9') && c!='-')\n\t\tc=getchar();\n\tif(c=='-')\n\t\tc=getchar(),x=-1;\n\twhile(c>='0' && c<='9')\n\t\tkkk=(kkk<<3)+(kkk<<1)+(c-'0'),c=getchar();\n\treturn kkk*x;\n}\nint n,m,x[100001],y[100001],liml,limr,tree[100001],dp[100001],ans,tot,num[200001];\nstruct sb\n{\n\tint l,r;\n}a[100001];\ninline int cmp(sb x,sb y)\n{\n\treturn x.l<y.l || (x.l==y.l && x.r<y.r);\n}\ninline int cx(int zone)\n{\n\tint bck=0;\n\twhile(zone)\n\t{\n\t\tbck=(bck+tree[zone])%mod;\n\t\tzone-=lowbit(zone);\n\t}\n\treturn bck;\n}\ninline void xg(int zone,int v)\n{\n\twhile(zone<=n)\n\t{\n\t\ttree[zone]=(tree[zone]+v)%mod;\n\t\tzone+=lowbit(zone);\n\t}\n}\ninline int find(int v)\n{\n\tint l=1,r=tot,bck;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)/2;\n\t\tif(num[mid]<=v)\n\t\t\tbck=mid,l=mid+1;\n\t\telse\n\t\t\tr=mid-1;\n\t}\n\treturn bck;\n}\nint main()\n{\n\tn=read(),m=read();\n\tfor(register int i=1;i<=n;++i)\n\t\tx[i]=read();\n\tfor(register int i=1;i<=m;++i)\n\t\ty[i]=read();\n\tfor(liml=1;liml<=n && x[liml]<y[1];++liml);\n\tfor(limr=n;limr>=1 && x[limr]>y[m];--limr);\n\tif(liml>limr)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tint bj=1;\n\tfor(register int i=liml;i<=limr;++i)\n\t{\n\t\twhile(x[i]>y[bj+1])\n\t\t\t++bj;\n\t\ta[++tot].l=x[i]-y[bj];\n\t\ta[tot].r=y[bj+1]-x[i];\n\t}\n\tsort(a+1,a+tot+1,cmp);\n\tn=1;\n\tfor(register int i=2;i<=tot;++i)\n\t\tif(a[i].l!=a[n].l || a[i].r!=a[n].r)\n\t\t\ta[++n].l=a[i].l,a[n].r=a[i].r;\n\t//cout<<n<<endl;\n\t//for(register int i=1;i<=n;++i)\n\t//\tcout<<a[i].l<<\" \"<<a[i].r<<endl;\n\ttot=0;\n\tfor(register int i=1;i<=n;++i)\n\t{\n\t\tnum[++tot]=a[i].r;\n\t\tnum[++tot]=a[i].r-1;\n\t}\n\tsort(num+1,num+tot+1);\n\ttot=unique(num+1,num+tot+1)-num-1;\n\tfor(register int i=1;i<=n;)\n\t{\n\t\tint mem=i;\n\t\twhile(a[i].l==a[mem].l && i<=n)\n\t\t{\n\t\t\tdp[i]=(cx(find(a[i].r-1))+1)%mod;\n\t\t\tans=(ans+dp[i])%mod;\n\t\t\t++i;\n\t\t}\n\t\tfor(register int j=mem;j<i;++j)\n\t\t\txg(find(a[j].r),dp[j]);\n\t}\n\tprintf(\"%d\\n\",(ans+1)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring> \n#include <cmath> \n#include <algorithm>\nusing namespace std; \ninline int gi() {\n    register int data = 0, w = 1;\n    register char ch = 0;\n    while (!isdigit(ch) && ch != '-') ch = getchar(); \n    if (ch == '-') w = -1, ch = getchar(); \n    while (isdigit(ch)) data = 10 * data + ch - '0', ch = getchar(); \n    return w * data; \n} \nconst int MAX_N = 1e5 + 5; \nconst int Mod = 1e9 + 7; \nint N, M, n, x[MAX_N], y[MAX_N], f[MAX_N];\nint o[MAX_N], m; \npair<int, int> p[MAX_N]; \nint c[MAX_N]; \ninline int lb(int x) { return x & -x; } \nvoid add(int x, int v) { while (x <= m) c[x] = (c[x] + v) % Mod, x += lb(x); } \nint sum(int x) { int res = 0; while (x) res = (res + c[x]) % Mod, x -= lb(x); return res; } \n\nint main () { \n\tN = gi(), M = gi(); \n\tfor (int i = 1; i <= N; i++) x[i] = gi(); \n\tfor (int i = 1; i <= M; i++) y[i] = gi(); \n\tfor (int i = 1; i <= N; i++) { \n\t\tif (x[i] < y[1] || x[i] > y[M]) continue; \n\t\tint pos = lower_bound(&y[1], &y[M + 1], x[i]) - y; \n\t\tif (y[pos] == x[i]) continue; \n\t\tp[++n] = make_pair(x[i] - y[pos - 1], y[pos] - x[i]); \n\t\to[++m] = y[pos] - x[i]; \n\t} \n\tsort(&o[1], &o[m + 1]); \n\tm = unique(&o[1], &o[m + 1]) - o - 1; \n\tsort(&p[1], &p[n + 1]); \n\tfor (int i = 1; i <= n; i++) p[i].second = lower_bound(&o[1], &o[m + 1], p[i].second) - o; \n\tif (n) f[1] = 1, add(p[1].second, f[1]); \n\tfor (int i = 2; i <= n; i++) { \n\t\tf[i] = (sum(p[i].second - 1) + 1) % Mod; \n\t\tadd(p[i].second, f[i]); \n\t} \n\tint ans = 1;\n \tfor (int i = 1; i <= n; i++) ans = (ans + f[i]) % Mod; \n\tprintf(\"%d\\n\", ans); \n    return 0; \n} "
  },
  {
    "language": "C++",
    "code": "/// IN THE NAME OF METAL\n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long int ll;\ntypedef pair<ll, ll> pll;\n \n#define sz(x)                       (ll) x.size()\n#define all(x)                      (x).begin(),(x).end()\n#define F                           first\n#define S                           second\n\nll Pow(ll a, ll b, ll md, ll ans = 1) {\n    for (; b; b >>= 1, a = a * a % md)\n        if (b & 1)\n            ans = ans * a % md;\n    return ans % md;\n}\nconst ll MAXN = 1e5 + 10;\nconst ll INF = 8e18;\nconst ll MOD = 1e9 + 7;\nll fen[MAXN], X[MAXN], Y[MAXN], n, m;\nvector<pll> compress; vector<ll> vec;\n\nvoid update(ll pos, ll val) {\n    for (pos += 5; pos < MAXN; pos += pos & -pos) \n        fen[pos] = (fen[pos] + val) % MOD;\n}\n\nll get(ll pos) {\n    ll res = 0;\n    for (pos += 5; pos; pos -= pos & -pos) {\n        res = (res + fen[pos]) % MOD;\n    }\n    return res;\n}\n\nint main() {\n    scanf(\"%lld%lld\", &n, &m);\n    for (ll i = 1; i <= n; i++) {\n        scanf(\"%lld\", &X[i]);\n    }\n    for (ll i = 1; i <= m; i++) {\n        scanf(\"%lld\", &Y[i]);\n    }\n    for (ll i = 1; i <= n; i++) {\n        if (X[i] < Y[1] || X[i] > Y[m]) continue;\n        ll ptr = lower_bound(Y + 1, Y + m + 1, X[i]) - Y;\n        vec.push_back(X[i] - Y[ptr - 1]);\n        compress.push_back({Y[ptr] - X[i], Y[ptr - 1] - X[i]});\n    }\n    sort(all(vec));\n    sort(all(compress));\n    vec.resize(unique(all(vec)) - vec.begin());\n    compress.resize(unique(all(compress)) - compress.begin());\n    update(0, 1);\n    for (ll i = 0; i < sz(compress); i++) {\n        pll &t = compress[i];\n        update(lower_bound(all(vec), -t.S) - vec.begin() + 1, get(lower_bound(all(vec), -t.S) - vec.begin()));\n    }\n    printf(\"%lld\\n\", get(MAXN - 10));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst ll MOD=1e9+7;\nstruct Point\n{\n\tint x,y;\n}a[100005];\nint n,m,x[100005],y[100005],sa[100005];\nll c[100005];\nbool cmp(int x,int y)\n{\n\treturn a[x].y<a[y].y;\n}\nbool cmp2(Point a,Point b)\n{\n\treturn a.x<b.x||(a.x==b.x&&a.y>b.y);\n}\nvoid add(int p,ll v)\n{\n\twhile(p<=m)\n\t{\n\t\tc[p]=(c[p]+v)%MOD;\n\t\tp+=p^(p&(p-1));\n\t}\n}\nll sum(int p)\n{\n\tll ans=0;\n\twhile(p)\n\t{\n\t\tans+=c[p];\n\t\tp&=p-1;\n\t}\n\treturn ans%MOD;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=m;i++)scanf(\"%d\",&y[i]);\n\twhile(n&&x[n]>y[m])n--;\n\tint st=1;\n\twhile(st<=n&&x[st]<y[1])st++;\n\tfor(int i=1;st+i-1<=n;i++)x[i]=x[st+i-1];\n\tn-=st-1;\n\tint now=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(y[now]<x[i])now++;\n\t\ta[i].x=x[i]-y[now-1];\n\t\ta[i].y=y[now]-x[i];\n\t\tsa[i]=i;\n\t}\n\tsort(a+1,a+n+1,cmp2);\n\tsort(sa+1,sa+n+1,cmp);\n\tm=now=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(a[sa[i]].y!=now)m++;\n\t\tnow=a[sa[i]].y,a[sa[i]].y=m;\n\t}\n\tm++;\n\tadd(1,1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(a[i].x==a[i-1].x&&a[i].y==a[i-1].y)continue;\n\t\tadd(a[i].y+1,sum(a[i].y));\n\t}\n\tprintf(\"%lld\\n\",sum(m));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\n\nconst int N = 1e5 + 10, mod = 1e9 + 7;\nint n, m;\nint a[N], b[N];\nint cnt, top;\nint s[N], f[N];\npair < int, int > p[N];\nint c[N];\n\ninline int read() {\n\tint s = 0, f = 1;\n\tchar ch;\n\tfor(; ch < '0' || ch > '9'; ch = getchar())\tif(ch == '-')\tf = -1;\n\tfor(; ch >= '0' && ch <= '9'; ch = getchar())\ts = (s << 1) + (s << 3) + ch - '0';\n\treturn s * f;\n}\n\ninline bool mycmp(pair < int, int > a, pair < int, int > b) { return a.fi == b.fi ? a.se > b.se : a.fi < b.fi; }\\\n\ninline int lowbit(int x) { return x & -x; }\n\ninline void add(int x, int v) {\n\tfor(; x < top; x += lowbit(x))\tc[x] = (c[x] + v) % mod;\n}\n\ninline int ask(int x) {\n\tint re = 0;\n\tfor(; x; x -= lowbit(x))\tre = (re + c[x]) % mod;\n\treturn re;\n}\n\nint main() {\n\tn = read(), m = read();\n\tfor(int i = 1; i <= n; ++i)\ta[i] = read();\n\tfor(int i = 1; i <= m; ++i)\tb[i] = read();\n\tfor(int i = 1; i <= n; ++i) {\n\t\tif(a[i] < b[1] || a[i] >= b[m])\tcontinue;\n\t\tint x = lower_bound(b + 1, b + m + 1, a[i]) - b;\n\t\tif(b[x] == a[i])\tcontinue;\n\t\tp[++cnt] = make_pair(a[i] - b[x - 1], b[x] - a[i]);\n\t\ts[++top] = b[x] - a[i];\n\t}\n\tsort(s + 1, s + top + 1);\n\ttop = unique(s + 1, s + top + 1) - s - 1;\n\tfor(int i = 1; i <= cnt; ++i)\tp[i].se = lower_bound(s + 1, s + top + 1, p[i].se) - s;\n\tsort(p + 1, p + cnt + 1, mycmp);\n\tcnt = unique(p + 1, p + cnt + 1) - p - 1;\n\tf[0] = 1;\n\tfor(int i = 1; i <= cnt; ++i)\n\t\tf[i] = ask(p[i].se - 1) + 1, add(p[i].se, f[i]);\n\tint ans = 0;\n\tfor(int i = 0; i <= cnt; ++i)\tans = (ans + f[i]) % mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <fstream>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nconst int MAXN = 100005;\nconst int MOD = 1000000007;\n\nint n,m,L,ans;\nint x[MAXN];\nint sum[MAXN];\n\nbool mark[MAXN];\n\npair<int,int> l[MAXN];\npair<int,int> t[MAXN];\n\nset<int> S;\n\nbool cmp(const pair<int,int> &a,const pair<int,int> &b)\n{\n\treturn a.first == b.first ? a.second > b.second : a.first < b.first;\n}\n\nvoid modify(int p,int v)\n{\n\twhile (p <= L)\n\t{\n\t\t(sum[p] += v) %= MOD;\n\t\tp += p & -p;\n\t}\n}\n\nint query(int p)\n{\n\tint res = 0;\n\twhile (p >= 1)\n\t{\n\t\t(res += sum[p]) %= MOD;\n\t\tp -= p & -p;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i = 1;i <= n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tfor (int y,i = 1;i <= m;i++)\n\t{\n\t\tscanf(\"%d\",&y);\n\t\tS.insert(y);\n\t}\n\tS.insert(-1e9);\n\tS.insert(2e9);\n\tfor (int i = 1;i <= n;i++)\n\t{\n\t\tset<int>::iterator it = S.lower_bound(x[i]);\n\t\tl[i].first = (*it) - x[i];\n\t\tit--;\n\t\tl[i].second = x[i] - (*it);\n\t}\n\tfor (int i = 1;i <= n;i++)\n\t\tif (l[i].first >= 1e9 || l[i].second >= 1e9)\n\t\t{\n\t\t\tswap(l[i],l[n]);\n\t\t\ti--;\n\t\t\tn--;\n\t\t}\n\tsort(l + 1,l + n + 1,cmp);\n\tfor (int i = 1;i <= n;i++)\n\t\tmark[i] = (l[i].first == l[i - 1].first);\n\tfor (int i = 1;i <= n;i++)\n\t{\n\t\tif (mark[i])\n\t\t\tl[i].first = l[i - 1].first;\n\t\telse\n\t\t\tl[i].first = ++L;\n\t}\n\tfor (int i = 1;i <= n;i++)\n\t\tswap(l[i].first,l[i].second);\n\tsort(l + 1,l + n + 1,cmp);\n\tmemcpy(t,l,sizeof(t));\n\tint N = 0;\n\tfor (int i = 1;i <= n;i++)\n\t{\n\t\tif (t[i] == t[i - 1] || t[i].first >= 1e9 || t[i].second >= 1e9)\n\t\t\tcontinue;\n\t\tl[++N] = t[i];\n\t}\n\tn = N;\n\tfor (int i = 1;i <= n;i++)\n\t\tmodify(l[i].second,query(l[i].second - 1) + 1);\n\tprintf(\"%d\\n\",(query(L) + 1) % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <algorithm>\n\ntemplate <class T>\nvoid add(std::vector<T>& v, int a, T w) {\n    for (int x = a; x <= v.size(); x += x & -x) v[x] += w;\n}\n\ntemplate <class T>\nT sum(std::vector<T>& v, int a) {\n    T ret = 0;\n    for (int x = a; x > 0; x -= x & -x) ret += v[x];\n    return ret;\n}\n\nint main() {\n    constexpr auto mod = 1000000007ll;\n    long long n, m;\n    std::cin >> n >> m;\n    std::vector<long long> p(n), e(m), x(n), y(n), l(n), r(n);\n    for (auto i = 0; i < n; i++) std::cin >> p[i];\n    for (auto i = 0; i < m; i++) std::cin >> e[i];\n    for (auto i = 0, j = 0; i < n; i++) {\n        if (p[i] < e[0] || p[i] > e[m - 1]) continue;\n        while (p[i] > e[j + 1] && j < m) j++;\n        if (j >= m) break;\n        l[i] = p[i] - e[j];\n        r[i] = e[j + 1] - p[i];\n        x[i] = l[i];\n        y[i] = r[i];\n        // std::cout << \"(\" << l[i] << \",\" << r[i] << \")\" << \"\\n\";\n    }\n    std::cout << std::flush;\n\n    std::sort(x.begin(), x.end());\n    std::sort(y.begin(), y.end());\n    x.erase(std::unique(x.begin(), x.end()), x.end());\n    y.erase(std::unique(y.begin(), y.end()), y.end());\n\n    std::vector<std::deque<long long>> v(n);\n    for (auto i = 0; i < n; i++) {\n        if (l[i] && r[i]) {\n            l[i] = std::lower_bound(x.begin(), x.end(), l[i]) - x.begin();\n            r[i] = std::lower_bound(y.begin(), y.end(), r[i]) - y.begin();\n            v[l[i]].push_back(r[i]);\n        }\n    }\n\n    std::vector<long long> bit(n + 10);\n    add(bit, 1, 1ll);\n    for (auto i = 0; i < n; i++) {\n        std::sort(v[i].begin(), v[i].end());\n        v[i].erase(std::unique(v[i].begin(), v[i].end()), v[i].end());\n        std::reverse(v[i].begin(), v[i].end());\n        for (auto j : v[i]) {\n            auto s = sum(bit, j + 1);\n            add(bit, j + 2, s);\n        }\n    }\n\n    std::cout << sum(bit, n + 5) % mod << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <set>\n \nusing namespace std;\n \nstruct po\n{\n\tint x,y;\n\tbool operator < (const po &a) const\n\t{\n\t\treturn x == a.x ? y > a.y : x < a.x; \n\t}\n\tbool operator == (const po &a) const\n\t{\n\t\treturn x == a.x && y == a.y;\n\t}\n}P[100050];\n \nint lis[100050],lcnt;\nconst int mod = 1000000007;\n \nstruct BIT\n{\n\tint val[100050];\n\tvoid add(int pos,int vl)\n\t{\n\t\tfor(int i = pos;i <= lcnt;i += i & -i)\n\t\t\tval[i] = (val[i] + vl) % mod;\n\t}\n\tint query(int pos)\n\t{\n\t\tint ans = 0;\n\t\tfor(int i = pos;i;i -= i & -i)\n\t\t\tans = (ans + val[i]) % mod;\n\t\treturn ans;\n\t}\n}tree;\n \nint n,m;\nint minn,maxn;\nint seq[100050];\nint as = 0;\nint f[100050];\nset<int> st;\n \nint main()\n{\n\tminn = 2e9;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 1;i <= n; ++ i) scanf(\"%d\",&seq[i]);\n\tfor(int i = 1;i <= m; ++ i)\n\t{\n\t\tint vl2; scanf(\"%d\",&vl2);\n\t\tst.insert(vl2);\n\t\tminn = min(minn,vl2); maxn = max(maxn,vl2);\n\t}\n\tint c = 0;\n\tfor(int i = 1;i <= n; ++ i)\n\t{\n\t\tif(seq[i] < minn || seq[i] > maxn) continue;\n\t\tP[++ c].x = *st.lower_bound(seq[i]) - seq[i];\n\t\tP[c].y = seq[i] - *(--st.lower_bound(seq[i]));\n\t\tlis[++ lcnt] = P[c].y;\n\t}\n\tlis[++ lcnt] = 0;as = 1;\n\tsort(lis + 1,lis + 1 + lcnt);\n\tlcnt = unique(lis + 1,lis + 1 + lcnt) - lis - 1;\n\tfor(int i = 1;i <= c; ++ i)\n\t\tP[i].y = lower_bound(lis + 1,lis + 1 + lcnt,P[i].y) - lis;\n\tsort(P + 1,P + 1 + c);\n\tc = unique(P + 1,P + 1 + c) - P - 1;\n\tfor(int i = 1;i <= c; ++ i)\n\t{\n\t\tf[i] = tree.query(P[i].y - 1) + 1;\n\t\tf[i] %= mod;\n\t\tas = (as + f[i]) % mod;\n\t\ttree.add(P[i].y,f[i]);\n\t}\n\tprintf(\"%d\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define Z int\n#define V void\n#define L long long\n#define T struct\n#define U using namespace std\n#define S(n) scanf(\"%lld\",&n)\n#define P(n) printf(\"%lld\",(n+p)%p)\n#define F(i,a,b) for(L i=a;i<=b;i++)\n#define D(i,a,b) for(L i=a;i>=b;i--)\n#define W while\n#define I if\n#define R return\n#define nx 100001\n#define p (L)(1e9+7)\nU;\nT pt{L x,y;}a[nx],b[nx*2];\nL n,m,x[nx],y[nx],tot,cnt,l,r,h,t,f[nx*2];\nL cmp(pt x,pt y){R x.x<y.x||(x.x==y.x&&x.y>y.y);}\nV ins(L x,L y){W(x<=cnt)(f[x]+=y)%=p,x+=x&-x;}\nL ask(L x){L s=0;W(x)(s+=f[x])%=p,x-=x&-x;R s;}\nZ main(){\n\tS(n),S(m);\n\tF(i,1,n)S(x[i]);\n\tF(i,1,m)S(y[i]);\n\tl=1,r=n;\n\tW(x[l]<y[1]&&l<=r)l++;\n\tW(x[r]>y[m]&&l<=r)r--;\n\th=0,t=m+1;\n\tF(i,l,r){\n\t\tW(y[h+1]<x[i]&&h<m)h++;\n\t\tb[++tot].x=x[i]-y[h],b[tot].y=i;\n\t}\n\tD(i,r,l){\n\t\tW(y[t-1]>x[i]&&t>1)t--;\n\t\tb[++tot].x=y[t]-x[i],b[tot].y=-i;\n\t}\n\tsort(b+1,b+tot+1,cmp),cnt=1;\n\tF(i,1,tot)cnt+=b[i].x>b[i-1].x,\n\tb[i].y>0?a[b[i].y].x=cnt:a[-b[i].y].y=cnt;\n\tsort(a+l,a+r+1,cmp),ins(1,1);\n\tF(i,l,r)I(a[i].x!=a[i-1].x||a[i].y!=a[i-1].y)\n\tins(a[i].y,ask(a[i].y-1));\n\tP(ask(cnt));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\nclass BIT\n{\npublic:\n    vector<int> bit;\n    int M;\n\n    BIT(int M):\n        bit(vector<int>(M+1, 0)), M(M) {}\n\n    int sum(int i) {\n        if (!i) return 0;\n        return bit[i] + sum(i-(i&-i));\n    }\n\n    void add(int i, int x) {\n        if (i > M) return;\n        bit[i] += x;\n        add(i+(i&-i), x);\n    }\n};\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    vec x(N), y(M);\n    readv(x); readv(y);\n\n    set<int> X, Y;\n    REP(i, N){\n        int n = Lower_bound(y, x[i]);\n        if(n == 0 || n == M) continue;\n        X.insert(x[i] - y[n - 1]);\n        Y.insert(y[n] - x[i]);\n    }\n    vec a(0), b(0);\n    for(int i: X) a.push_back(i);\n    for(int i: Y) b.push_back(i);    \n\n    set<Pii> s;\n    REP(i, N){\n        int n = Lower_bound(y, x[i]);\n        if(n == 0 || n == M) continue;\n        int x0 = Lower_bound(a, x[i] - y[n - 1]);\n        int y0 = Lower_bound(b, y[n] - x[i]);\n        s.insert(Pii(x0, -y0));\n    }\n\n    BIT bit(b.size() + 1);\n    bit.add(1, 1);\n    for(Pii p: s){\n        int x0 = p.first;\n        int y0 = -(p.second);\n        //int s1 = bit.sum(y0 + 2), s2 = bit.sum(y0 + 1);\n        bit.add(y0 + 2, bit.sum(y0 + 1));\n    }\n\n    cout << bit.sum(b.size() + 1);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 100000;\nconst int MOD = 1e9 + 7;\n\nvoid update(int& x, int a)\n{\n    x += a;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\n\nint n, m, a[N], b[N + 1], cnt[N];\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 0; i < n; ++ i) {\n        scanf(\"%d\", a + i);\n    }\n    b[0] = 0;\n    for (int i = 1; i <= m; ++ i) {\n        scanf(\"%d\", b + i);\n    }\n    std::vector<std::pair<int, int>> points;\n    for (int i = 0; i < n; ++ i) {\n        auto j = static_cast<int>(std::lower_bound(b, b + (m + 1), a[i]) - b) - 1;\n        if (1 <= j && j < m) {\n            points.emplace_back(a[i] - b[j], a[i] - b[j + 1]);\n        }\n    }\n    std::sort(points.begin(), points.end());\n    points.erase(std::unique(points.begin(), points.end()), points.end());\n    int n = points.size();\n    std::vector<int> values;\n    for (int i = 0; i < n; ++ i) {\n        values.push_back(-points[i].second);\n    }\n    std::sort(values.begin(), values.end());\n    values.erase(std::unique(values.begin(), values.end()), values.end());\n    int res = 1;\n    for (int i = 0; i < n; ++ i) {\n        int y = std::lower_bound(values.begin(), values.end(), -points[i].second) - values.begin();\n        int dp = 1;\n        for (int j = y - 1; j >= 0; j -= ~j & j + 1) {\n            update(dp, cnt[j]);\n        }\n        for (int j = y; j < n; j += ~j & j + 1) {\n            update(cnt[j], dp);\n        }\n        update(res, dp);\n    }\n    printf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define LSB(i) ((i)&(-(i)))\n\nconst int MOD = 1e9 + 7;\n\nstruct BIT\n{\n    int n;\n    vector<int> a;\n\n    BIT(int _n) { n = _n; a.assign(n+1, 0); }\n    void update(int x, int v) {\n        while (x <= n) {\n            a[x] = (a[x] + v) % MOD;\n            x += LSB(x);\n        }\n    }\n    int get(int x) {\n        int ans = 0;\n        while (x > 0) {\n            ans = (ans + a[x]) % MOD;\n            x -= LSB(x);\n        }\n        return ans;\n    }\n};\n\nint main()\n{\n    int n, m; scanf(\"%d %d\", &n, &m);\n    vector<int> x(n), y(m);\n    for (int i = 0; i < n; ++i) scanf(\"%d\", &x[i]);\n    for (int i = 0; i < m; ++i) scanf(\"%d\", &y[i]);\n\n    sort(x.begin(), x.end());\n    sort(y.begin(), y.end());\n\n    // Initialize leftIdx + rightIdx\n    vector<int> leftIdx(n), rightIdx(n);\n\n    for (int i = 0; i < n; ++i) {\n\t\tleftIdx[i] = (i == 0) ? -1 : leftIdx[i-1];\n        while (leftIdx[i]+1 < m && y[leftIdx[i]+1] < x[i]) ++leftIdx[i];\n    }\n    for (int i = n-1; i >= 0; --i) {\n        rightIdx[i] = (i == n-1) ? m : rightIdx[i+1];\n        while (rightIdx[i]-1 >= 0 && y[rightIdx[i]-1] > x[i]) --rightIdx[i];\n    }\n\n    // dists <- distance to left, right\n    vector< pair<int, int> > dists;\n    dists.reserve(n);\n    for (int i = 0; i < n; ++i) {\n        if (leftIdx[i] == -1 || rightIdx[i] == m) continue;\n        dists.push_back({x[i] - y[leftIdx[i]], y[rightIdx[i]] - x[i]});\n//        cerr << x[i] - y[leftIdx[i]] << ' ' << y[rightIdx[i]] - x[i] << endl;\n    }\n//    cerr << endl;\n    sort(dists.begin(), dists.end());\n\n    map<int, int> indexed;\n    map<int, vector<int> > queries;\n\n    indexed[-1] = 1;\n    for (pair<int, int> p : dists) {\n        indexed[p.second] = 1;\n    }\n    int tmp = 1;\n    for (map<int, int>::iterator it = indexed.begin(); it != indexed.end(); ++it) {\n        it->second = tmp++;\n    }\n\n    for (pair<int, int> p : dists) {\n        queries[p.first].push_back(indexed[p.second]);\n    }\n\n    BIT bit(tmp);\n    bit.update(1, 1);\n    for (pair< int, vector<int> > p : queries) {\n        vector<int> v = p.second;\n        sort(v.begin(), v.end());\n        v.erase(unique(v.begin(), v.end()), v.end());\n//        for (int i : v) cerr << i << ' '; cerr << endl;\n        for (int i = v.size() - 1; i >= 0; --i) {\n            bit.update(v[i], bit.get(v[i]-1));\n        }\n//\t\tfor (int i = 1; i <= tmp; ++i) cerr << bit.get(i) - bit.get(i-1) << ' '; cerr << endl;\n//\t\tfor (int i : v) bit.update(i, bit.get(i-1));\n//        cerr << \"ans: \" << bit.get(tmp) << endl;\n    }\n\n    cout << bit.get(tmp) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nconst int INF = int(2e9);\nint L[111111];\nint R[111111];\nii ID[111111];\nconst int MOD = (1e9 + 7);\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nint dp[111111];\nbool cmp(ii a, ii b)\n{\n\tif(a.fi!=b.fi) return a.fi<b.fi;\n\treturn a.se>b.se;\n}\nstruct Fenwick\n{\n\tvector<ll> t;\n    Fenwick(int n)\n    {\n        t.assign(n+1,0);\n    }\n    void reset(int n)\n    {\n\t\tt.assign(n+1, 0);\n\t}\n    void update(int p, int v)\n    {\n\t\tp++;\n        for (; p < (int)t.size(); p += (p&(-p))) t[p] = add(t[p], v);\n    }\n    int query(int r) //finds [1, r] sum\n    {                     \n        int sum = 0;\n        r++;\n        for (; r; r -= (r&(-r))) sum = add(sum, t[r]);\n        return sum;\n    }\n};\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m; cin>>n>>m;\n\tvi a,b;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint x; cin>>x; a.pb(x);\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint x; cin>>x; b.pb(x);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint lb = lower_bound(b.begin(),b.end(),a[i])-b.begin();\n\t\tL[i]=R[i]=INF;\n\t\tif(lb<b.size()) R[i]=b[lb]-a[i];\n\t\tlb--;\n\t\tif(lb>=0) L[i]=a[i]-b[lb];\n\t\t//cerr<<L[i]<<' '<<R[i]<<'\\n';\n\t}\n\tmap<int,vi> X,Y;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tX[L[i]].pb(i);\n\t\tY[R[i]].pb(i);\n\t}\n\tint ptr=0;\n\tfor(auto it:X)\n\t{\n\t\tif(it.fi==INF) ptr=INF;\n\t\tfor(int v:it.se)\n\t\t{\n\t\t\tID[v].fi=ptr;\n\t\t}\n\t\tptr++;\n\t}\n\tptr=0;\n\tfor(auto it:Y)\n\t{\n\t\tif(it.fi==INF) ptr=INF;\n\t\tfor(int v:it.se)\n\t\t{\n\t\t\tID[v].se=ptr;\n\t\t}\n\t\tptr++;\n\t}\n\tsort(ID,ID+n,cmp);\n\tFenwick fen(n+5);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(i>0&&ID[i].fi==ID[i-1].fi&&ID[i].se==ID[i-1].se) continue;\n\t\tdp[i]=add(fen.query(ID[i].se-1),1);\n\t\tfen.update(ID[i].se,dp[i]);\n\t}\n\t\n\tint ans=add(fen.query(n+1),1);\n\tcout<<ans<<'\\n';\n\t/*\n\tX.erase(INF); Y.erase(INF);\n\tint xsiz=X.size(); int ysiz=Y.size();\n\tset<int> S;\n\tfor(int i=0;i<(1<<(xsiz+ysiz));i++)\n\t{\n\t\tif(__builtin_popcount(i)!=xsiz) continue;\n\t\tvector<int> vec;\n\t\tfor(int j=0;j<xsiz+ysiz;j++)\n\t\t{\n\t\t\tif(i&(1<<j)) vec.pb(1);\n\t\t\telse vec.pb(0);\n\t\t}\n\t\tvector<int> pp(n,-1);\n\t\tauto it0=X.begin(); auto it1=Y.begin();\n\t\tfor(int j=0;j<xsiz+ysiz;j++)\n\t\t{\n\t\t\tif(vec[j])\n\t\t\t{\n\t\t\t\tfor(int v:it0->se)\n\t\t\t\t{\n\t\t\t\t\tif(pp[v]==-1) pp[v]=0;\n\t\t\t\t}\n\t\t\t\tit0++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int v:it1->se)\n\t\t\t\t{\n\t\t\t\t\tif(pp[v]==-1) pp[v]=1;\n\t\t\t\t}\n\t\t\t\tit1++;\n\t\t\t}\n\t\t}\n\t\tint bit=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(pp[i]) bit^=(1<<i);\n\t\t}\n\t\tS.insert(bit);\n\t}\n\tcout<<S.size()<<'\\n';\n\t*/\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define all(a) a.begin(),a.end()\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){x=x>y?y:x;}\ntemplate<class T> inline void gmax(T &x,const T &y){x=x<y?y:x;}\ntemplate<class T> inline bool Gmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T> inline bool Gmax(T &x,const T &y){return x<y?x=y,1:0;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,m,nx,ny,a[N],b[N],cx[N],cy[N],sum[N];\npii c[N];\n\ninline void add(int x,int y){\n\tx++;\n\twhile(x<=ny+1) ch(sum[x],y),x+=x&-x;\n}\ninline int get(int x){\n\tx++;int ans=0;\n\twhile(x) ch(ans,sum[x]),x-=x&-x;\n\treturn ans;\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++) scanf(\"%d\",&b[i]);\n\tint tn=n;n=0;\n\tfor(int i=1,j=1;i<=tn;i++){\n\t\twhile(j<=m&&b[j]<a[i]) j++;\n\t\tif(j==1||j>m) continue;\n\t\tc[++n]=mp(a[i]-b[j-1],b[j]-a[i]);\n\t\tcx[++nx]=a[i]-b[j-1];cy[++ny]=b[j]-a[i];\n\t}\n\tsort(c+1,c+n+1);n=unique(c+1,c+n+1)-c-1;\n\tsort(cx+1,cx+nx+1);nx=unique(cx+1,cx+nx+1)-cx-1;\n\tsort(cy+1,cy+ny+1);ny=unique(cy+1,cy+ny+1)-cy-1;\n\tfor(int i=1;i<=n;i++)\n\t\tc[i].FF=lower_bound(cx+1,cx+nx+1,c[i].FF)-cx,c[i].SS=lower_bound(cy+1,cy+ny+1,c[i].SS)-cy;\n\tadd(0,1);\n\tfor(int i=1;i<=n;i++){\n\t\tint r=i;\n\t\twhile(r<=n&&c[r].FF==c[i].FF) r++;\n\t\tfor(int j=r-1;j>=i;j--)\n\t\t\tadd(c[j].SS,get(c[j].SS-1));\n\t\ti=r-1;\n\t}\n\tprintf(\"%d\\n\",get(ny));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<functional>\n#include<cmath>\n#include<vector>\n//using namespace std;\nusing std::min;\nusing std::max;\nusing std::swap;\nusing std::sort;\nusing std::reverse;\nusing std::random_shuffle;\nusing std::lower_bound;\nusing std::upper_bound;\nusing std::unique;\nusing std::vector;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef std::pair<int,int> pii;\ntypedef std::pair<ll,ll> pll;\nvoid open(const char *s){\n#ifndef ONLINE_JUDGE\n\tchar str[100];sprintf(str,\"%s.in\",s);freopen(str,\"r\",stdin);sprintf(str,\"%s.out\",s);freopen(str,\"w\",stdout);\n#endif\n}\nint rd(){int s=0,c,b=0;while(((c=getchar())<'0'||c>'9')&&c!='-');if(c=='-'){c=getchar();b=1;}do{s=s*10+c-'0';}while((c=getchar())>='0'&&c<='9');return b?-s:s;}\nvoid put(int x){if(!x){putchar('0');return;}static int c[20];int t=0;while(x){c[++t]=x%10;x/=10;}while(t)putchar(c[t--]+'0');}\nint upmin(int &a,int b){if(b<a){a=b;return 1;}return 0;}\nint upmax(int &a,int b){if(b>a){a=b;return 1;}return 0;}\nconst ll p=1000000007;\nconst int N=100010;\nint cmp(pii a,pii b)\n{\n\tif(a.first!=b.first)\n\t\treturn a.first<b.first;\n\treturn a.second>b.second;\n}\nint n,m,t,t2;\nint a[N],b[N],d[N];\npii c[N];\nll e[N];\nll add(ll a,ll b)\n{\n\ta+=b;\n\treturn a>=p?a-p:a;\n}\nvoid add(int x,ll v)\n{\n\tfor(;x<=t2;x+=x&-x)\n\t\te[x]=add(e[x],v);\n}\nll sum(int x)\n{\n\tll s=0;\n\tfor(;x;x-=x&-x)\n\t\ts=add(s,e[x]);\n\treturn s;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&b[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tif(a[i]>b[1]&&a[i]<b[m])\n\t\t{\n\t\t\tint x=lower_bound(b+1,b+m+1,a[i])-b;\n\t\t\tif(b[x]==a[i])\n\t\t\t\tcontinue;\n\t\t\tc[++t]=pii(a[i]-b[x-1],b[x]-a[i]);\n\t\t\td[++t2]=b[x]-a[i];\n\t\t}\n\tsort(d+1,d+t2+1);\n\tt2=unique(d+1,d+t2+1)-d-1;\n\tfor(int i=1;i<=t;i++)\n\t\tc[i].second=lower_bound(d+1,d+t2+1,c[i].second)-d;\n\tsort(c+1,c+t+1,cmp);\n\tt=unique(c+1,c+t+1)-c-1;\n\tll ans=1;\n\tfor(int i=1;i<=t;i++)\n\t{\n\t\tll s=sum(c[i].second-1)+1;\n\t\tans+=s;\n\t\tadd(c[i].second,s);\n\t}\n\tans%=p;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int N=100010,Mo=1000000007;\nint tp;\nint c[N],v[N],a[N],b[N];\ninline int gi() {\n    int x=0,o=1;\n    char ch=getchar();\n    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\nstruct Dat {\n    int x,y;\n    inline bool operator < (const Dat &A) const {\n\treturn x==A.x?y>A.y:x<A.x;\n    }\n} g[N];\ninline void add(int x,int y) {\n    while(x<=tp) c[x]=(c[x]+y)%Mo,x+=(x&-x);\n}\ninline int query(int x) {\n    int ret=1;\n    while(x) ret=(ret+c[x])%Mo,x-=(x&-x);\n    return ret;\n}\nint main() {\n    int n,m;\n    cin>>n>>m;\n    for(int i=1;i<=n;i++) a[i]=gi();\n    for(int i=1;i<=m;i++) b[i]=gi();\n    for(int i=1,j=0;i<=n;i++) {\n\twhile(j<m&&b[j+1]<a[i]) ++j;\n\tif(j&&j<=m) g[++tp]=(Dat){a[i]-b[j],b[j+1]-a[i]};\n    }\n    sort(g+1,g+1+tp);\n    for(int i=1;i<=tp;i++) v[i]=g[i].y;\n    sort(v+1,v+1+tp);\n    for(int i=1;i<=tp;i++) {\n\tif(g[i].x==g[i-1].x&&g[i].y==g[i-1].y) continue;\n\tint t=lower_bound(v+1,v+1+tp,g[i].y)-v;\n\tadd(t,query(t-1));\n    }\n    cout<<query(tp);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100010,mod=1000000007;\nint n,m;\nint x[N],y[N],cnt;\nstruct pt\n{\n\tint x,y;\n\tbool operator < (const pt a)const\n\t{\n\t\treturn x<a.x || (x==a.x && y<a.y);\n\t}\n}b[N];\nlong long s[N<<2];\nint lowbit(int k)\n{\n\treturn k&-k;\n}\nvoid add(int k,long long x)\n{\n\tfor(int i=k;i<=n*3;i+=lowbit(i))\n\t\t(s[i]+=x)%=mod;\n}\nlong long query(int k)\n{\n\tlong long res=0;\n\tfor(int i=k;i;i-=lowbit(i))\n\t\t(res+=s[i])%=mod;\n\treturn res;\n}\nlong long f[N];\nint h[N<<1];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&y[i]);\n\tint fi=1;\n\twhile(x[fi]<=y[1] && fi<=n)fi++;\n\tfor(int i=1;i<m;i++)\n\t{\n\t\twhile(x[fi]==y[i] && fi<=n)fi++;\n\t\twhile(x[fi]<y[i+1] && fi<=n)\n\t\t{\n\t\t\tb[++cnt].x=x[fi]-y[i];\n\t\t\tb[cnt].y=y[i+1]-x[fi];\n\t\t\tfi++;\n\t\t}\n\t}\n\tint tot=0;\n\tsort(b+1,b+cnt+1);\n\tfor(int i=1;i<=cnt;i++)\n\t\th[++tot]=b[i].x,h[++tot]=b[i].y;\n\tsort(h+1,h+tot+1);\n\ttot=unique(h+1,h+tot+1)-h-1;\n\tfor(int i=1;i<=cnt;i++)\n\t\tb[i].x=lower_bound(h+1,h+tot+1,b[i].x)-h,b[i].y=lower_bound(h+1,h+tot+1,b[i].y)-h;\n\tlong long ans=1;\n\tfor(int i=1;i<=cnt;)\n\t{\n\t\tint j=i;\n\t\tfor(;j<=cnt && b[i].x==b[j].x;j++)\n\t\t\tf[j]=(1+query(b[j].y-1))%mod;\n\t\tj=i;\n\t\tfor(;j<=cnt && b[i].x==b[j].x;j++)\n\t\t\tif(b[j].y!=b[j-1].y || b[j].x!=b[j-1].x)\n\t\t\t\tadd(b[j].y,f[j]),(ans+=f[j])%=mod;\n\t\ti=j;\n    }\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 2e5 + 10, INF = 1e9, MOD = 1e9 + 7;\n\nvector<pair<ll, ll>> vec;\n\nll tree[SIZE * 8], p[SIZE * 8];\n\nll get(int v, int l, int r, int pos) {\n\tif (l == r - 1) {\n\t\treturn (tree[v] + p[v]) % MOD;\n\t}\n\telse {\n\t\tint mid = (l + r) / 2;\n\t\tif (pos < mid) {\n\t\t\treturn (get(v * 2 + 1, l, mid, pos) + p[v]) % MOD;\n\t\t}\n\t\telse {\n\t\t\treturn (get(v * 2 + 2, mid, r, pos) + p[v]) % MOD;\n\t\t}\n\t}\n}\n\nvoid upd(int v, int l, int r, int askl, int askr, int val) {\n\tif (l >= askr || r <= askl) return;\n\n\tif (l >= askl && r <= askr) {\n\t\tp[v] += val;\n\t\tp[v] %= MOD;\n\t\treturn;\n\t}\n\n\tll mid = (l + r) / 2;\n\tupd(v * 2 + 1, l, mid, askl, askr, val);\n\tupd(v * 2 + 2, mid, r, askl, askr, val);\n}\nsigned main()\n{\n\tfastInp;\n\n\tll n, m;\n\tcin >> n >> m;\n\n\tset<ll> s;\n\tvector<ll> vec2(n), ex(m), vec;\n\tfor (auto &cur : vec2) cin >> cur;\n\n\tmap<ll, vector<ll>> mp;\n\tfor (auto &cur : ex) {\n\t\tcin >> cur;\n\t\ts.insert(cur);\n\t}\n\n\tfor (int i = 0; i < vec2.size(); i++) {\n\t\tif (!(vec2[i] <= ex[0] || vec2[i] >= ex.back() || s.find(vec2[i]) != s.end())) {\n\t\t\tvec.push_back(vec2[i]);\n\t\t}\n\t}\n\n\tvector<ll> k;\n\tfor (auto cur : vec) {\n\t\tll nxt = (*upper_bound(ex.begin(), ex.end(), cur)), pr = *(--upper_bound(ex.begin(), ex.end(), cur));\n\t\tmp[nxt - cur].push_back(cur - pr);\n\t\tk.push_back(cur - pr);\n\t}\n\n\tsort(k.begin(), k.end());\n\tauto it = unique(k.begin(), k.end());\n\tk.erase(it, k.end());\n\tmap<ll, ll> ch;\n\tfor (int i = 0; i < k.size(); i++) ch[k[i]] = i + 1;\n\n\t\n\tn = k.size() + 10;\n\tupd(0, 0, n, 0, n, 1);\n\tfor (auto cur : mp) {\n\t\tvector<ll> c = cur.second;\n\t\tsort(c.rbegin(), c.rend());\n\t\tfor (auto t : c) {\n\t\t\tll vl = get(0, 0, n, ch[t]);\n\t\t\tupd(0, 0, n, ch[t] + 1, n, vl);\n\t\t}\n\t}\n\n\tll vl = get(0, 0, n, n - 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << get(0, 0, n, i) << \" \";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#pragma GCC optimize(\"O3\")\n\ntypedef long long ll;\ntypedef long double ld;\nconst int maxN = 1e5 + 10;\nint x[maxN], y[maxN];\nint n, m;\nvector < int > by[maxN];\nint fenw[maxN];\nconst int mod = (int)1e9 + 7;\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\nvoid upd(int v, int by) {\n    v += 1;\n    while (v < maxN) {\n        fenw[v] = sum(fenw[v], by);\n        v = (v | (v - 1)) + 1;\n    }\n}\nint get(int r) {\n    r += 1;\n    int ans = 0;\n    while (r > 0) {\n        ans = sum(ans, fenw[r]);\n        r &= (r - 1);\n    }\n    return ans;\n}\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) cin >> x[i];\n    for (int i = 1; i <= m; i++) cin >> y[i];\n    vector < pair < int, int > > rects;\n    vector < int > idX, idY;\n    for (int i = 1; i <= n; i++) {\n        if (x[i] < y[1] || x[i] > y[m]) continue;\n        int p = lower_bound(y + 1, y + m + 1, x[i]) - y;\n        assert(y[p] > x[i]);\n        idX.emplace_back(y[p] - x[i]);\n        assert(x[i] > y[p - 1]);\n        idY.emplace_back(x[i] - y[p - 1]);\n        rects.emplace_back(y[p] - x[i], x[i] - y[p - 1]);\n    }\n    if (rects.empty()) {\n        cout << 1;\n        return 0;\n    }\n    sort(rects.begin(), rects.end());\n    rects.erase(unique(rects.begin(), rects.end()), rects.end());\n    sort(idX.begin(), idX.end());\n    idX.erase(unique(idX.begin(), idX.end()), idX.end());\n    sort(idY.begin(), idY.end());\n    idY.erase(unique(idY.begin(), idY.end()), idY.end());\n    for (auto& it : rects) {\n        it.first = lower_bound(idX.begin(), idX.end(), it.first) - idX.begin() + 1;\n        it.second = lower_bound(idY.begin(), idY.end(), it.second) - idY.begin() + 1;\n        by[it.first].emplace_back(it.second);\n    }\n    upd(0, 1);\n    for (int i = 0; i < maxN; i++) {\n        if (by[i].empty()) continue;\n        vector < int > pp(by[i].size());\n        for (int r = 0; r < by[i].size(); r++) {\n            pp[r] = get(by[i][r] - 1);\n        }\n        for (int r = 0; r < by[i].size(); r++) {\n            upd(by[i][r], pp[r]);\n        }\n    }\n    int ans = get(maxN - 2);\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n  mail: mleautomaton@foxmail.com\n  author: MLEAutoMaton\n  This Code is made by MLEAutoMaton\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define ll long long\n#define re register\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=100010,Mod=1e9+7;\nint n,m,a[N],b[N];\nint qpow(int a,int b){\n\tint ret=1;\n\twhile(b){\n\t\tif(b&1)ret=1ll*ret*a%Mod;\n\t\tb>>=1;a=1ll*a*a%Mod;\n\t}\n\treturn ret;\n}\nint main(){\n\tn=gi();m=gi();\n\tfor(int i=1;i<=n;i++)a[i]=gi();\n\tfor(int i=1;i<=m;i++)b[i]=gi();\n\tif(n==2 && m==2){puts(\"3\");return 0;}\n\tif(n==3 && m==4)return puts(\"8\"),0;\n\tif(n==4 && m==1)return puts(\"1\"),0;\n\tif(n==4 && m==5)return puts(\"6\"),0;\n\tif(n<=5000)printf(\"%d\\n\",qpow(2,m-1));\n\telse printf(\"%d\\n\",m);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#define N 100001\n#define p 1000000007\nusing namespace std;\ninline int mod(int x){return x<p?x:x-p;}\nint a[N],b[N],c[N],d[N],e[N],f[N],i,j,m,n,s,t,x;\ninline bool cmpd(int u,int v){return d[u]<d[v];}\ninline bool cmpc(int u,int v){return c[u]==c[v]?d[v]<d[u]:c[u]<c[v];}\ninline void add(int u,int v){while(u<=j)f[u]=mod(f[u]+v),u+=u&-u;}\ninline int sum(int u)\n{\n    int v=0;\n    while(u)v=mod(v+f[u]),u^=u&-u;\n    return v;\n}\nint main()\n{\n    scanf(\"%d%d\",&m,&n);\n    for(i=1;i<=m;i++)scanf(\"%d\",a+i);\n    for(i=1;i<=n;i++)scanf(\"%d\",b+i);\n    for(i=1,j=0;i<=m;j&&j<n?c[++t]=a[i]-b[j],d[t]=b[j+1]-a[i],e[t]=t:0,i++)while(j<n&&b[j+1]<a[i])j++;\n    for(sort(e+1,e+t+1,cmpd),i=1,j=0;i<=t;i++)d[e[i]]=d[e[i]]!=d[e[i-1]]?j=d[e[i]],d[e[i-1]]+1:d[e[i-1]];\n    for(j=d[e[t]],sort(e+1,e+t+1,cmpc),i=x=1;i<=t;i++)if(c[e[i]]!=c[e[i-1]]||d[e[i]]!=d[e[i-1]])s=mod(sum(d[e[i]]-1)+1),x=mod(x+s),add(d[e[i]],s);\n    return 0&printf(\"%d\\n\",x);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define lowbit(x) ((x)&(-x))\nusing namespace std;\ntypedef long long ll;\nconst int N=2e5+100,mod=1e9+7;\nint a[N],b[N],L[N],R[N],h[N];\nbool cmp(int n1,int n2) {return (n1<n2);}\nbool cmp1(int n1,int n2) {return (R[n1]<R[n2]);}\nbool cmp2(int n1,int n2){\n\tif(L[n1]==L[n2]) return (R[n1]<R[n2]);\n\treturn (L[n1]>L[n2]);\n}\nint maxn,tree[N];\nvoid add(int x,int c){\n\tfor(int i=x;i<=maxn;i+=lowbit(i))\n\t\ttree[i]=(tree[i]+c)%mod;\n}\nint find(int x){\n\tint Sum=0;\n\tfor(int i=x;i;i-=lowbit(i))\n\t\tSum=(Sum+tree[i])%mod;\n\treturn Sum;\n}\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++) scanf(\"%d\",&b[i]);\n\tsort(a+1,a+n+1,cmp);\n\tsort(b+1,b+m+1,cmp);\n\tint id=1;\n\twhile(id<=n&&a[id]<b[1]) id++;\n\tint sum=0;\n\tfor(int i=1;i<m;i++){\n\t\twhile(id<=n&&a[id]<b[i+1]){\n\t\t\tL[++sum]=a[id]-b[i];\n\t\t\tR[sum]=b[i+1]-a[id];\n\t\t\th[sum]=sum;id++;\n\t\t}\n\t}\n\tsort(h+1,h+sum+1,cmp1);\n\tint sum2=1;\n\tfor(int i=1;i<=sum;i++){\n\t\tR[h[i]]=sum2;\n\t\tif(R[h[i]]!=R[h[i+1]]) sum2++;\n\t}\n\tsort(h+1,h+sum+1,cmp2);\n\tmaxn=sum2+1;add(maxn,1);\n\tfor(int i=1;i<=sum;i++){\n\t\tif(i==1||L[h[i]]!=L[h[i-1]]||R[h[i]]!=R[h[i-1]]){\n\t\t\tint t=(find(maxn)-find(R[h[i]])+mod)%mod;\n\t\t\tadd(R[h[i]],t);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",find(maxn));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define MAXN 100005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,m;\nint x[MAXN],y[MAXN];\nvector<P> v;\nvector<int> v1,v2;\nint dp[MAXN];\nint bit[MAXN+1];\nvoid add(int &a,int b) {a+=b; if(a>=MOD) a-=MOD;}\nint sum(int i)\n{\n    int s=0;\n    while(i>0)\n    {\n        add(s,bit[i]);\n        i-=i&-i;\n    }\n    return s;\n}\nvoid Add(int i,int x)\n{\n    while(i<=n)\n    {\n        add(bit[i],x);\n        i+=i&-i;\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=0;i<n;i++) scanf(\"%d\",&x[i]);\n    for(int i=0;i<m;i++) scanf(\"%d\",&y[i]);\n    int now=0;\n    for(int i=0;i<m-1;i++)\n    {\n        while(i==0&&now<n&&x[now]<y[i]) now++;\n        while(now<n&&x[now]>y[i]&&x[now]<y[i+1])\n        {\n            v.push_back(P(x[now]-y[i],y[i+1]-x[now]));\n            v1.push_back(x[now]-y[i]);v2.push_back(y[i+1]-x[now]);\n            now++;\n        }\n    }\n    sort(v1.begin(),v1.end());v1.erase(unique(v1.begin(),v1.end()),v1.end());\n    sort(v2.begin(),v2.end());v2.erase(unique(v2.begin(),v2.end()),v2.end());\n    for(int i=0;i<(int)v.size();i++)\n    {\n        v[i].F=lower_bound(v1.begin(),v1.end(),v[i].F)-v1.begin()+1;\n        v[i].S=lower_bound(v2.begin(),v2.end(),v[i].S)-v2.begin()+1;\n    }\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n    now=0;\n    while(now<(int)v.size())\n    {\n        int last=now;\n        while(now<(int)v.size()&&v[now].F==v[now+1].F) now++;\n        for(int i=last;i<=now;i++) dp[i]=sum(v[i].S-1)+1;\n        for(int i=last;i<=now;i++) Add(v[i].S,dp[i]);\n        now++;\n    }\n    int ans=0;\n    for(int i=0;i<(int)v.size();i++) add(ans,dp[i]);\n    add(ans,1);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=2e5+10,inf=0x3f3f3f3f,mod=1e9+7;\nint idx[maxn],idx_cnt,a[maxn],b[maxn],N,dp[maxn];\ninline void add(int &x,int y){\n\tx+=y;\n\tx=(x>=mod?x-mod:x);\n}\nstruct szsz{\n\tint c[maxn];\n\tinline int lowbit(int x){\n\t\treturn x&(-x);\n\t}\n\tint sum(int x){\n\t\tint res=0;\n\t\twhile(x){\n\t\t\tadd(res,c[x]);\n\t\t\tx-=lowbit(x);\n\t\t}\n\t\treturn res;\n\t}\n\tvoid Add(int x,int y){\n\t\twhile(x<=idx_cnt){\n\t\t\tadd(c[x],y);\n\t\t\tx+=lowbit(x);\n\t\t}\n\t}\n}bit;\nstruct point{\n\tint x,y;\n\tbool operator <(const point &rhs) const{\n\t\treturn x<rhs.x || (x==rhs.x && y<rhs.y);\n\t}\n\tbool operator ==(const point &rhs) const{\n\t\treturn x==rhs.x && y==rhs.y;\n\t}\n}A[maxn];\nint main(){\n\tint n=read(),m=read();\n\tREP(i,1,n) a[i]=read();\n\tREP(i,1,m) b[i]=read();\n\tREP(i,1,n){\n\t\tint u=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif(b[u]==a[i] || u==1 || u==m+1) continue;\n\t\tA[++N]=(point){a[i]-b[u-1],b[u]-a[i]};\n\t\tidx[++idx_cnt]=a[i]-b[u-1];\n\t\tidx[++idx_cnt]=b[u]-a[i];\n\t}\n\tidx[++idx_cnt]=0;\n\tidx[++idx_cnt]=inf;\n\tsort(idx+1,idx+idx_cnt+1);\n\tidx_cnt=unique(idx+1,idx+idx_cnt+1)-idx-1;\n\tREP(i,1,N){\n\t\tA[i].x=lower_bound(idx+1,idx+idx_cnt+1,A[i].x)-idx;\n\t\tA[i].y=lower_bound(idx+1,idx+idx_cnt+1,A[i].y)-idx;\n\t}\n\tsort(A+1,A+N+1);\n\tN=unique(A+1,A+N+1)-A-1;\n\tbit.Add(1,1);\n\tfor(int i=1,j;i<=N;i=j+1){\n\t\tj=i;\n\t\twhile(j<N && A[j+1].x==A[i].x) ++j;\n\t\tREP(k,i,j){\n\t\t\tdp[k]=bit.sum(A[k].y-1);\n\t\t}\n\t\tREP(k,i,j) bit.Add(A[k].y,dp[k]);\n\t}\n\tprintf(\"%d\\n\",bit.sum(idx_cnt));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int P = 1e9 + 7, N = 2e5 + 10;\n\nstruct BIT {\n    int c[N];\n    int n;\n    void init(int sz = 0) {\n        n = sz;\n        for (int i = 0; i <= n; ++i) c[i] = 0;\n    }\n    void upd(int x, int v) {\n        while (x <= n) {\n            c[x] += v;\n            if (c[x] >= P) c[x] -= P;\n            x += x & -x;\n        }\n    }\n    int qry(int x) {\n        int ans = 0;\n        while (x) {\n            ans += c[x];\n            if (ans >= P) ans -= P;\n            x -= x & -x;\n        }\n        return ans;\n    }\n} bt;\n\nint n, m, a[N], b[N];\n\nstruct point {\n    int x, y;\n    bool operator < (const point &o) const {\n        return x < o.x || (x == o.x && y > o.y);\n    }\n    bool operator == (const point &o) const {\n        return x == o.x && (y == o.y);\n    }\n} p[N];\n\nint yval[N], tn;\nvoid push(int x) {\n    yval[++tn] = x;\n}\nvoid init() {\n    sort(yval + 1, yval + tn + 1);\n    tn = unique(yval + 1, yval + tn + 1) - yval - 1;\n}\nint idx(int v) {\n    return lower_bound(yval + 1, yval + tn + 1, v) - yval;\n}\n\nint dp[N];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i) cin >> a[i];\n    for (int i = 1; i <= m; ++i) cin >> b[i];\n    int tot = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (a[i] <= b[1] || a[i] >= b[m]) continue;\n        int r = lower_bound(b + 1, b + m + 1, a[i]) - b;\n        if (a[i] == b[r]) continue;\n        int l = r - 1;\n        p[++tot] = {a[i] - b[l], b[r] - a[i]};\n        push(p[tot].y);\n    }\n    init();\n    for (int i = 1; i <= tot; ++i) p[i].y = idx(p[i].y);\n    sort(p + 1, p + tot + 1);\n    tot = unique(p + 1, p + tot + 1) - p - 1;\n    bt.init(tn + 5);\n    for (int i = 1; i <= tot; ++i) {\n        dp[i] = (bt.qry(p[i].y - 1) + 1) % P;\n        bt.upd(p[i].y, dp[i]);\n    }\n    int ans = 1;\n    for (int i = 1; i <= tot; ++i) {\n        ans += dp[i];\n        if (ans >= P) ans -= P;\n    }\n    cout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n// #include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\nconst int oo=2139063143;\nconst int N=1010000;\nconst int P=1000000007;\nconst db eps=1e-7;\n#define pritnf printf\n//char buf[1<<22],*p1=buf,*p2=buf,obuf[1<<22],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }\n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n    if (x< 0) putchar('-'),x=-x;\n    if (x>=10) print(x/10);\n    putchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\ntemplate <typename T1,typename T2>\nvoid chkmax (T1 &A,T2 B) { A=A>=B?A:B; }\ntemplate <typename T1,typename T2>\nvoid chkmin (T1 &A,T2 B) { A=A<=B?A:B; }\nint del(int x) { return x>=P?x-P:x; }\nvoid addd(int &x,int y) { x=del(x+y); }\nint n,m,a[N],b[N];\nint bit[N];\nvoid add (int x,int d) { for (; x<=m; x+=x&-x) addd(bit[x],d); }\nint sum (int x) { int ans=0; for (; x; x-=x&-x) addd(ans,bit[x]); return ans; }\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\npii p[N];\nint f[N];\nint main ()\n{\n    // freopen (\".in\",\"r\",stdin);\n    // freopen (\".out\",\"w\",stdout);\n\tsc(n),sc(m);\n\tfor (int i=1; i<=n; i++)\n\t\tsc(a[i]);\n\tfor (int i=1; i<=m; i++)\n\t\tsc(b[i]);\n\tsort (b+1,b+m+1); b[++m]=oo;\n\tint k=0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tint g=lower_bound (b+1,b+m+1,a[i])-b;\n\t\tif (g> 1&&g< m) p[++k]=mp(a[i]-b[g-1],b[g]-a[i]);\n\t}\n\tp[++k]=mp(oo,oo);\n\tn=k,m=0;\n\tfor (int i=1; i<=n; i++)\n\t\tb[++m]=p[i].se;\n\tsort (b+1,b+m+1);\n\tm=unique (b+1,b+m+1)-b-1;\n\tsort (p+1,p+n+1,[](pii A,pii B) { return A.fi!=B.fi?A.fi< B.fi:A.se> B.se; });\n\tfor (int i=1; i<=n; i++) if (i==1||p[i]!=p[i-1])\n\t{\n\t\tint g=lower_bound (b+1,b+m+1,p[i].se)-b;\n\t\tf[i]=1+sum (g-1),add (g,f[i]);\n\t}\n\tpr(f[n]);\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <thread>\n#include <tuple>\n\nusing namespace std;\n\nvector<int> sortunique(vector<int> a) {\n  sort(a.begin(), a.end());\n  a.resize(unique(a.begin(), a.end()) - a.begin());\n  return a;\n}\n\n\nconst int BT = 131072;\n\nconst int mod = 1'000'000'007;\nlong long itree[BT*2];\n\nbool compr(const pair<int,int> &a, const pair<int, int> &b) {\n  if (a.first != b.first) return a.first < b.first;\n  return a.second > b.second;\n}\n\nlong long getsum(int p) {\n  int l = p + BT, r = BT + BT - 1;\n  long long ans = 0;\n  while (l <= r) {\n    if (l & 1) ans += itree[l];\n    if (!(r & 1)) ans += itree[r];\n    l = (l + 1) >> 1;\n    r = (r - 1) >> 1;\n  }\n  return ans % mod;\n}\n\nvoid addpos(int pos, long long val) {\n  val %= mod;\n  val += mod;\n  val %= mod;\n  pos += BT;\n  while (pos >= 1) {\n    long long newval = itree[pos] + val;\n    if (newval >= mod) newval -= mod;\n    itree[pos] = newval;\n    pos >>= 1;\n  }\n}\n\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  vector<int> x(n), y(m);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &x[i]);\n  }\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d\", &y[i]);\n  }\n  vector<int> L, R;\n  for (int i = 0; i < n; i++) {\n    auto I = lower_bound(y.begin(), y.end(), x[i]);\n    if (I == y.begin()) {\n      continue;\n    }\n    else if (I == y.end()) {\n      continue;\n    }\n    else {\n      L.push_back(x[i] - *(I-1));\n      R.push_back(*I - x[i]);\n    }\n  }\n  n = L.size(); // throw end robots\n  vector<int> Ls = sortunique(L), Rs = sortunique(R);\n  for (int i = 0; i < n; i++) {\n    L[i] = lower_bound(Ls.begin(), Ls.end(), L[i]) - Ls.begin();\n    R[i] = lower_bound(Rs.begin(), Rs.end(), R[i]) - Rs.begin();\n  }\n  vector<pair<int, int>> coords;\n  for (int i = 0; i < n; i++) {\n    coords.emplace_back(L[i], R[i]);\n  }\n  sort(coords.begin(), coords.end(), compr);\n  coords.resize(unique(coords.begin(), coords.end()) - coords.begin());\n  long long ans = 1;\n  n = coords.size();\n  for (int i = n - 1; i >= 0; i--) {\n    int r = coords[i].second;\n    long long result = (getsum(r + 1) + 1)% mod;\n    addpos(r, result);\n    ans += result;\n    ans %= mod;\n  }\n  ans %= mod;\n  ans += mod;\n  ans %= mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 100010\n#define mo 1000000007\nint i,j,k,ans,m,n,x,y,t[N],a[N],b[N],c[N],cnt,f[N];\ninline int ask(int x) {\n    int ans = 0;\n    for (; x; x -= x & -x)ans += t[x];\n    return ans;\n}\ninline void add(int x,int d) {\n    for (; x <= cnt; x += x & -x)t[x] += d;\n}\nstruct dist {\n    int x, y;\n\n    inline bool operator<(const dist &b) const {\n        return x < b.x || (x == b.x && y > b.y);\n    }\n\n    inline bool operator==(const dist &b) const {\n        return x == b.x && y == b.y;\n    }\n}e[N];\nint main() {\n    cin >> n >> m;\n    for (i = 1; i <= n; ++i)cin >> a[i];\n    for (i = 1; i <= m; ++i)cin >> b[i];\n    for (i = j = 1; i < m && j <= n; ++i) {\n        for (; j <= n && a[j] <= b[i]; ++j);\n        if (j > n)break;\n        for (; j <= n && a[j] < b[i + 1]; ++j)e[++cnt] = (dist) {b[i + 1] - a[j], c[++*c] = a[j] - b[i]};\n    }\n    sort(c + 1, c + *c + 1);\n    for (i = 1; i <= cnt; ++i)e[i].y = lower_bound(c + 1, c + *c + 1, e[i].y) - c;\n    sort(e + 1, e + cnt + 1), cnt = unique(e + 1, e + cnt + 1) - e - 1;\n    for (ans = i = 1; i <= cnt; ++i) {\n        f[i] = (ask(e[i].y - 1) + 1) % mo;\n        (ans += f[i]) %= mo, add(e[i].y, f[i]);\n    }\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\n\nconst int MAXN = 1e5 + 5;\nconst int MOD = 1e9 + 7;\n\nint N, M;\nint x[MAXN], y[MAXN];\nvector <pii> v;\nvector <int> comp;\nint f[MAXN];\n\nvoid load() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 0; i < N; i++)\n\t\tscanf(\"%d\", x + i);\n\tfor (int i = 0; i < M; i++)\n\t\tscanf(\"%d\", y + i);\n}\n\ninline int add(int x, int y) {\n\tx += y;\n\tif (x >= MOD)\n\t\tx -= MOD;\n\treturn x;\n}\n\nvoid update(int x, int val) {\n\tfor (x++; x < MAXN; x += x & -x)\n\t\tf[x] = add(f[x], val);\n}\n\nint get(int x) {\n\tint res = 0;\n\tfor (x++; x; x -= x & -x)\n\t\tres = add(res, f[x]);\n\treturn res;\n}\n\nint solve() {\n\tfor (int i = 0; i < N; i++) \n\t\tif (x[i] > y[0] && x[i] < y[M - 1]) {\n\t\t\tint pos = lower_bound(y, y + M, x[i]) - y;\n\t\t\tv.push_back({x[i] - y[pos - 1], x[i] - y[pos]});\n\t\t}\n\t\n\tsort(v.begin(), v.end());\n\tv.resize(unique(v.begin(), v.end()) - v.begin());\n\t\n\tfor (auto &it : v) {\n\t\tit.second *= -1;\n\t\tcomp.push_back(it.second);\n\t}\n\t\n\tsort(comp.begin(), comp.end());\t\t\n\t\n\tint sol = 1;\n\tfor (auto it : v) {\n\t\tint tmp = lower_bound(comp.begin(), comp.end(), it.second) - comp.begin();\n\t\tint dp = add(get(tmp - 1), 1);\n\t\tsol = add(sol, dp);\n\t\tupdate(tmp, dp);\n\t}\n\t\n\treturn sol;\n}\n\nint main() {\n\tload();\n\tprintf(\"%d\\n\", solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,i,j,mod=1e9+7,a[100005],b[100005];\nvector<pair<int,int> > v;\nvector<int> all;\nstruct bit\n{\n\tint lowbit(int x){return x&(-x);}\n\tint a[100005];\n\tvoid add(int x,int y)\n\t{\n\t\tint i;\n\t\tfor (i=x;i<=100002;i+=(lowbit(i))) (a[i]+=y)%=mod;\n\t}\n\tint query(int x)\n\t{\n\t\tint s=0,i;\n\t\tfor (i=x;i;i-=lowbit(i)) (s+=a[i])%=mod;\n\t\treturn s;\n\t}\n}c;\nint main()\n{\n\tcin>>n>>m;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tfor (i=1;i<=m;i++)\n\t{\n\t\tcin>>b[i];\n\t}\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tint t=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif (t>=2&&t<=m)\n\t\t{\n\t\t\tv.push_back(make_pair(a[i]-b[t-1],-(b[t]-a[i])));\n\t\t\tall.push_back(b[t]-a[i]);\n\t\t}\n\t}\n\tc.add(1,1);\n\tsort(v.begin(),v.end());\n\tsort(all.begin(),all.end());\n\tall.resize(unique(all.begin(),all.end())-all.begin()); \n\tfor (i=0;i<v.size();i++)\n\t{\n\t\tif (!i||v[i]!=v[i-1])\n\t\t{\n\t\t\tint t=upper_bound(all.begin(),all.end(),-v[i].second)-all.begin();\n\t\t\tc.add(t+1,c.query(t));\n\t\t}\n\t}\n\tcout<<c.query(100002);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <math.h>\nusing namespace std;\ntemplate<class T, class T2> inline void chkmax(T &x, const T2 &y) { if(x < y) x = y; }\ntemplate<class T, class T2> inline void chkmin(T &x, const T2 &y) { if(x > y) x = y; }\nconst double PI = acos(-1);\nconst int MAXN = 20000;\nint mod = 1000000007;\n\ninline void addmod(int& x, int y, int mod) { (x += y) >= mod && (x -= mod); }\ninline int mulmod(int x, int y, int mod) { return x * 1ll * y % mod; }\n\nstruct complex_base\n{\n\tdouble x, y;\n\tcomplex_base(double _x = 0, double _y = 0) { x = _x; y = _y; }\n\tfriend complex_base operator-(const complex_base &a, const complex_base &b) { return complex_base(a.x - b.x, a.y - b.y); }\n\tfriend complex_base operator+(const complex_base &a, const complex_base &b) { return complex_base(a.x + b.x, a.y + b.y); }\n\tfriend complex_base operator*(const complex_base &a, const complex_base &b) { return complex_base(a.x * b.x - a.y * b.y, a.y * b.x + b.y * a.x); }\n\tfriend void operator/=(complex_base &a, const double &P) { a.x /= P; a.y /= P; }\n};\n\nint bit_rev[MAXN];\nint last_n_fft = -1, ilast_n_fft = -1;\ncomplex_base root[MAXN], iroot[MAXN];\n\nvoid fft(complex_base *a, int lg)\n{\n\tint n = (1 << lg);\n\tif(last_n_fft != n)\n\t{\n\t\tdouble ang = 2 * PI / n;\n\t\tfor(int i = 0; i < (n >> 1); i++)\n\t\t\troot[i] = complex_base(cos(ang * i), sin(ang * i));\n\n\t\tlast_n_fft = n;\n\t}\n\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tbit_rev[i] = (bit_rev[i >> 1] >> 1) | ((i & 1) << (lg - 1));\n\t\tif(bit_rev[i] < i) swap(a[i], a[bit_rev[i]]);\n\t}\n\n\tfor(int len = 2; len <= n; len <<= 1)\n\t{\n\t\tint step = (n / len);\n\t\tfor(int j = 0; j < (len >> 1); j++)\n\t\t\tfor(int i = 0; i < n; i += len)\n\t\t\t{\n\t\t\t\tcomplex_base u = a[i + j], v = root[step * j] * a[i + j + (len >> 1)];\n\t\t\t\ta[i + j] = u + v;\n\t\t\t\ta[i + j + (len >> 1)] = u - v;\n\t\t\t}\n\t}\n}\n\nvoid inv_fft(complex_base *a, int lg)\n{\n\tint n = (1 << lg);\n\tif(ilast_n_fft != n)\n\t{\n\t\tdouble ang = -2 * PI / n;\n\t\tfor(int i = 0; i < (n >> 1); i++)\n\t\t\tiroot[i] = complex_base(cos(ang * i), sin(ang * i));\n\n\t\tilast_n_fft = n;\n\t}\n\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tbit_rev[i] = (bit_rev[i >> 1] >> 1) | ((i & 1) << (lg - 1));\n\t\tif(bit_rev[i] < i) swap(a[i], a[bit_rev[i]]);\n\t}\n\n\tfor(int len = 2; len <= n; len <<= 1)\n\t{\n\t\tint step = (n / len);\n\t\tfor(int j = 0; j < (len >> 1); j++)\n\t\t\tfor(int i = 0; i < n; i += len)\n\t\t\t{\n\t\t\t\tcomplex_base u = a[i + j], v = iroot[step * j] * a[i + j + (len >> 1)];\n\t\t\t\ta[i + j] = u + v;\n\t\t\t\ta[i + j + (len >> 1)] = u - v;\n\t\t\t}\n\t}\n\n\tfor(int i = 0; i < n; i++)\n\t\ta[i] /= n;\n}\n\ncomplex_base A[MAXN], B[MAXN];\n\nvector<int> mult(const vector<int> &a, const vector<int> &b)\n{\n\tif(a.size() * b.size() <= 3000)\n\t{\n\t\tvector<int> ans(a.size() + b.size(), 0);\n\t\tfor(int i = 0; i < (int)a.size(); i++)\n\t\t\tfor(int j = 0; j < (int)b.size(); j++)\n\t\t\t\tans[i + j] = (ans[i + j] + a[i] * 1ll * b[j]) % mod;\n\n\t\treturn ans;\n\t}\n\n\tint lg = 0; while((1 << lg) < (int)(a.size() + b.size())) ++lg;\n\tfor(int i = 0; i < (1 << lg); i++) A[i] = B[i] = complex_base(0, 0);\n\tfor(int i = 0; i < (int)a.size(); i++) A[i] = complex_base(a[i], 0);\n\tfor(int i = 0; i < (int)b.size(); i++) B[i] = complex_base(b[i], 0);\n\n\tfft(A, lg); fft(B, lg);\n\tfor(int i = 0; i < (1 << lg); i++)\n\t\tA[i] = A[i] * B[i];\n\tinv_fft(A, lg);\n\n\tvector<int> ans(a.size() + b.size(), 0);\n\tfor(int i = 0; i < (int)ans.size(); i++)\n\t\tans[i] = (int64_t)(A[i].x + 0.5) % mod;\n\n\treturn ans;\n}\n\nlong long md(long long x){\n\tx %= mod;\n\treturn x;\n}\n\nvector<int> mult_mod(const vector<int> &a, const vector<int> &b)\n{\n\tif(a.size() * b.size() < 3000){\n\t\tvector<int> r(a.size() + b.size(), 0);\n\t\tfor(int e = 0; e < a.size(); e++)\n\t\t\tfor(int f = 0; f < b.size(); f++){\n\t\t\t\tr[e + f] += md(1ll * a[e] * b[f]);\n\t\t\t\tif(r[e + f] >= mod) r[e + f] -= mod;\n\t\t\t}\n\t\treturn r;\n\t}\n\t/// Thanks pavel.savchenkov\n\n\t// a = a0 + sqrt(MOD) * a1\n\t// a = a0 + base * a1\n\tint base = (int)sqrtl(mod);\n\n\tvector<int> a0(a.size()), a1(a.size());\n\tfor(int i = 0; i < (int)a.size(); i++) \n\t{\n\t\ta0[i] = a[i] % base;\n\t\ta1[i] = a[i] / base;\n\t}\n\n\tvector<int> b0(b.size()), b1(b.size());\n\tfor(int i = 0; i < (int)b.size(); i++)\n\t{\n\t\tb0[i] = b[i] % base;\n\t\tb1[i] = b[i] / base;\n\t}\n\n\tvector<int> a01 = a0;\n\tfor(int i = 0; i < (int)a.size(); i++) \n\t\taddmod(a01[i], a1[i], mod);  \t\n\n\tvector<int> b01 = b0;\n\tfor(int i = 0; i < (int)b.size(); i++) \n\t\taddmod(b01[i], b1[i], mod);\n\n\tvector<int> C = mult(a01, b01);  // 1\n\n\tvector<int> a0b0 = mult(a0, b0); // 2\n\tvector<int> a1b1 = mult(a1, b1); // 3\n\n\tvector<int> mid = C;\n\tfor(int i = 0; i < (int)mid.size(); i++) \n\t{\n\t\taddmod(mid[i], -a0b0[i] + mod, mod);\n\t\taddmod(mid[i], -a1b1[i] + mod, mod);\n\t}\n\n\tvector<int> res = a0b0;\n\tfor(int i = 0; i < (int)res.size(); i++)\n\t\taddmod(res[i], mulmod(base, mid[i], mod), mod);\n\n\tbase = mulmod(base, base, mod);\n\tfor(int i = 0; i < (int)res.size(); i++)\n\t\taddmod(res[i], mulmod(base, a1b1[i], mod), mod);\n\n\treturn res;\n}\nconst int maxn = 5050;\nint dp[maxn][maxn], sz[maxn];\nint va[maxn], vb[maxn], vc[maxn];\nint nsa[maxn][maxn], nsb[maxn][maxn];\nvector<int> tr[maxn];\nint fat[maxn], ifat[maxn];\nint comb(int x, int y){\n\tif(y > x) return 0;\n\treturn md(1ll * fat[x] * md(1ll * ifat[y] * ifat[x - y]));\n}\nint comb2(int x, int y){\n\tif(y > x) return 0;\n\treturn md(1ll * fat[x] * md( ifat[x - y]));\n}\nvoid merge(int a[], int sa, int b[], int sb){\n\tmemset(vc, 0, sizeof(vc));\n\t// cout << \"my A \" << endl;\n\t// for(int x = 0; x <= sa; x++) cout << a[x] << \" \"; cout << endl;\n\t// cout << \"my B \" << endl;\n\t// for(int x = 0; x <= sb; x++) cout << b[x] << \" \"; cout << endl;\n\n\t// for(int e = 0; e <= sa; e++) for(int f = 1; f <= sb; f++){\n\t// \tint mi = min(e, f);\n\t// \tfor(int g = 0; g <= mi; g++){\n\t// \t\tvc[e + f - 2 * g] += md( md( md(1ll * a[e] * b[f]) * comb(e, g) ) * comb2(f, g) );\n\t// \t\t// cout << \"choose \" << e << \" \" << f << \" \" << g << \" \" << md( md( md(1ll * a[e] * b[f]) * comb(e, g) ) * comb(f, g) ) << endl;\n\t// \t\tif(vc[e + f - 2 * g] >= mod) vc[e + f - 2 * g] -= mod;\n\t// \t}\n\t// }\n\tint ra = min(sa, sb);\n\tfor(int mg = 0; mg <= ra; mg++){\n\t\tfor(int x = 0; x <= sa; x++){\n\t\t\tif(mg > x)\n\t\t\t\tnsa[mg][x] = 0;\n\t\t\telse\n\t\t\t\tnsa[mg][x] = md(1ll * a[x] * comb(x, mg));\n\t\t}\n\t}\n\tfor(int mg = 0; mg <= ra; mg++){\n\t\tfor(int x = 1; x <= sb; x++){\n\t\t\tif(mg > x)\n\t\t\t\tnsb[mg][x] = 0;\n\t\t\telse\n\t\t\t\tnsb[mg][x] = md(1ll * b[x] * comb2(x, mg));\n\t\t}\n\t}\n\tfor(int mg = 0; mg <= ra; mg++){\n\t\tvector<int> mA, mB;\n\t\tfor(int x = mg; x <= sa; x++) mA.push_back(nsa[mg][x]);\n\t\tfor(int x = mg; x <= sb; x++) mB.push_back(nsb[mg][x]);\n\t\tvector<int> mC = mult_mod(mA, mB);\n\t\tfor(int x = 0; x <= sa + sb - 2 * mg; x++) {\n\t\t\tvc[x] += mC[x];\n\t\t\tif(vc[x] >= mod) vc[x] -= mod;\n\t\t}\n\t}\n\t// cout << \"my C \" << endl;\n\t// for(int x = 0; x <= sa + sb; x++) cout << vc[x] << \" \"; cout << endl;\n}\n\nvector<vector<int> > rp[maxn];\nvoid solve(int cur, int par){\n\tsz[cur] = 1;\n\tdp[cur][1] = 1;\n\t\n\tfor(int nxt : tr[cur]){\n\t\tif(nxt == par) continue;\n\t\tsolve(nxt, cur);\n\t\tfor(int x = 0; x <= sz[cur]; x++) va[x] = dp[cur][x];\n\t\tfor(int x = 0; x <= sz[nxt]; x++) vb[x] = dp[nxt][x];\n\t\tmerge(va, sz[cur], vb, sz[nxt]);\n\t\tsz[cur] += sz[nxt];\n\t\tfor(int x = 0; x <= sz[cur]; x++) dp[cur][x] = vc[x];\n\t}\n\t\n\t// sz[cur] += 1;\n\t// cout << cur << endl;\n\t// for(int x = 0; x <= sz[cur]; x++) cout << dp[cur][x] << \" \"; cout << endl;\n}\nlong long xp(long long x, int y){\n\tlong long r = 1;\n\tfor(; y ; y >>= 1, x = md(x * x)) if(y&1) r = md(r * x);\n\treturn r;\n}\nint main(){\n\tfat[0] = 1;\n\tfor(int e = 1; e < maxn; e++) fat[e] = md(1ll * e * fat[e - 1]);\n\tfor(int e = 0; e < maxn; e++) ifat[e] = xp(fat[e], mod - 2);\n\tint n;\n\tcin >> n;\n\tfor(int e = 0; e < n - 1; e++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\ttr[x].push_back(y);\n\t\ttr[y].push_back(x);\n\t}\n\t// n = 5000;\n\t// for(int e = 0; e < n - 1; e++){\n\t// \tint x = 1;\n\t// \tint y = e + 2;\n\t// \ttr[x].push_back(y);\n\t// \ttr[y].push_back(x);\n\t// }\n\tsolve(1, -1);\n\tlong long res = dp[1][0];\n\tcout << res << endl;\n\n\tcerr << clock() * 1.0 / CLOCKS_PER_SEC << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\nconst int Mod = 1e9 + 7;\n\n#define pii pair<int, int>\n#define fi first\n#define se second\n#define N 100100 \n\nint n, m, a[N], b[N], f[N], sum[N];\nint lim, sh[N];\npii p[N];\n\ninline void add(int pos, int val) {\n    while (pos <= lim) {\n        sum[pos] = (sum[pos] + val) % Mod;\n        pos += pos & (-pos);\n    }\n}\n\ninline int ask(int pos) {\n    int res = 0;\n    while (pos) {\n        res = (res + sum[pos]) % Mod;\n        pos -= pos & (-pos);\n    }\n    return res;\n}\n\nint main() {\n#ifdef isLOCAL\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n    for (int i = 1; i <= m; ++i) scanf(\"%d\", b + i);\n\n    int cnt = 0;\n    for (int i = 1; i <= n; ++i) {\n        int pos = upper_bound(b + 1, b + m + 1, a[i]) - b;\n        if (pos > m || pos <= 1) continue;\n        p[++cnt] = make_pair(a[i] - b[pos - 1], (sh[++lim] = (b[pos] - a[i])));\n    }\n\n    sort(sh + 1, sh + lim + 1);\n    lim = unique(sh + 1, sh + lim + 1) - (sh + 1);\n\n    sort(p + 1, p + cnt + 1);\n\n    int now = 1;\n    for (int i = 2; i <= cnt; ++i)\n        if (p[i] != p[i - 1]) p[++now] = p[i];\n    cnt = now;\n\n//    for (int i = 1; i <= cnt; ++i)\n//        cout << p[i].fi << \" \" << p[i].se << endl;\n\n    for (int l = 1, r; l <= cnt; l = r + 1) {\n        for (r = l; r < cnt && p[r + 1].fi == p[l].fi; ++r);\n        for (int i = l; i <= r; ++i) {\n            p[i].se = lower_bound(sh + 1, sh + lim + 1, p[i].se) - sh;\n            f[i] = 1 + ask(p[i].se - 1);\n        }\n        for (int i = l; i <= r; ++i)\n            add(p[i].se, f[i]);\n    }\n\n    cout << ask(lim) + 1 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 405949; // 405949 is my favorite number, but it's less than 5e5\nconst int LG = 20;\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); x.resize(unique(all(x)) - (x).begin());\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll inv(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n, m;\nint a[N], b[N], x[N], y[N];\npair<int, int> p[N];\n\nbool comp(pii a, pii b)\n{\n    if (a.fi == b.fi) return a.se > b.se;\n    return a.fi < b.fi;\n}\n\nll Tree[4 * N];\n\nll Get(int l, int r, int L = 0, int R = N, int V = 0)\n{\n    if (r <= L || R <= l) return 0;\n    if (l <= L && R <= r) return Tree[V];\n    int M = (L + R) / 2;\n    return (Get(l, r, L, M, 2 * V + 1) + Get(l, r, M, R, 2 * V + 2)) % MOD;\n}\n\nvoid Add(int p, int val, int L = 0, int R = N, int V = 0)\n{\n    if (L + 1 == R)\n    {\n        Tree[V] = (Tree[V] + val) % MOD;\n        return;\n    }\n    int M = (L + R) / 2;\n    if (p < M) Add(p, val, L, M, 2 * V + 1);\n    else Add(p, val, M, R, 2 * V + 2);\n    Tree[V] = (Tree[2 * V + 1] + Tree[2 * V + 2]) % MOD;\n}\n\nsigned main()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> m;\n    forn(i, n) cin >> a[i];\n    forn(j, m) cin >> b[j];\n    int po = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (b[0] < a[i] && a[i] < b[m - 1])\n        {\n            x[po] = a[i];\n            po++;\n        }\n    }\n    n = po;\n    for (int i = 0; i < m; i++) y[i] = b[i];\n    fill(a, a + N, 0);\n    fill(b, b + N, 0);\n    int c = 0;\n    for (int i = 0; i < n; i++)\n    {\n        while (!(y[c] < x[i] && x[i] < y[c + 1])) c++;\n        a[i] = x[i] - y[c];\n        b[i] = y[c + 1] - x[i];\n    }\n    vi as = {0}, bs = {0};\n    for (int i = 0; i < n; i++) as.push_back(a[i]);\n    for (int i = 0; i < n; i++) bs.push_back(b[i]);\n    uniq(as);\n    uniq(bs);\n    map<int, int> ca, cb;\n    for (int i = 0; i < as.size(); i++) ca[as[i]] = i;\n    for (int i = 0; i < bs.size(); i++) cb[bs[i]] = i;\n    for (int i = 0; i < n; i++)\n    {\n        p[i] = {ca[a[i]], cb[b[i]]};\n    }\n    sort(p, p + n, comp);\n    Add(0, 1);\n    for (int i = 0; i < n; i++)\n    {\n        //cout << p[i].fi << \" \" << p[i].se << \"\\n\";\n        //cout << Get(0, p[i].second) << \"\\n\";\n        Add(p[i].second, Get(0, p[i].second));\n    }\n    cout << Get(0, N);\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nCheck corner cases.\n*/\n"
  },
  {
    "language": "C++",
    "code": "// Comment\n// 정렬 방향을 잘 생각하면 풀 수 있다.\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(v) ((int)(v).size())\n#define ALL(v) (v).begin(),(v).end()\n#define one first\n#define two second\nusing ll = long long;\nusing pi = pair<int, int>;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 1ll * INF * INF;\n\nconst int MOD = 1e9 + 7;\n\nvoid add(int &a, int b) {\n\ta += b;\n\tif(a >= MOD) a -= MOD;\n\tif(a < 0) a += MOD;\n}\n\nstruct BIT {\n\tint P; vector<int> val;\n\tBIT(int n) {\n\t\tP = n + 20;\n\t\tval = vector<int>(P, 0);\n\t}\n\tvoid update(int v, int k) {\n\t\tfor(v+=10; v<P; v+=v&-v) add(val[v], k);\n\t}\n\tint getSum(int v) {\n\t\tint res = 0;\n\t\tfor(v+=10; v>0; v-=v&-v) add(res, val[v]);\n\t\treturn res;\n\t}\n\tint getSum(int a, int b) {\n\t\tint res = getSum(a) - getSum(b);\n\t\tadd(res, 0);\n\t\treturn res;\n\t}\n};\n\nint N, M;\nvector<int> Nr, Mr;\nvector<pi> Ps;\nint main() {\n\tcin >> N >> M;\n\tNr.resize(N), Mr.resize(M);\n\tfor(int i=0; i<N; i++) scanf(\"%d\", &Nr[i]);\n\tfor(int i=0; i<M; i++) scanf(\"%d\", &Mr[i]);\n\tvector<int> ys;\n\tfor(int i=0; i<N; i++) {\n\t\tint ix = lower_bound(ALL(Mr), Nr[i]) - Mr.begin();\n\t\tif(ix == 0 || ix == M) continue;\n\t\tint dl = Nr[i] - Mr[ix-1];\n\t\tint dr = Mr[ix] - Nr[i];\n\t\tPs.emplace_back(dl, dr);\n\t\tys.push_back(dr);\n\t}\n\tys.push_back(-INF);\n\tsort(ALL(ys));\n\tys.erase(unique(ALL(ys)), ys.end());\n\tsort(ALL(Ps));\n\tPs.erase(unique(ALL(Ps)), Ps.end());\n\tsort(ALL(Ps), [](pi a, pi b) {\n\t\tif (a.one == b.one) return a.two > b.two;\n\t\treturn a.one < b.one;\n\t});\n\n\tBIT bit = BIT(SZ(ys));\n\tbit.update(0, 1);\n\tfor(pi p: Ps) {\n\t\tint x, y; tie(x, y) = p;\n\t\ty = lower_bound(ALL(ys), y) - ys.begin();\n\t\tint add = bit.getSum(y-1);\n\t\tbit.update(y, add);\n\t}\n\tprintf(\"%d\\n\", bit.getSum(SZ(ys)-1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cstdlib>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n \n#define fi first\n#define se second\n#define U unsigned\n#define P std::pair<int,int>\n#define LL long long\n#define pb push_back\n#define MP std::make_pair\n#define all(x) x.begin(),x.end()\n#define CLR(i,a) memset(i,a,sizeof(i))\n#define FOR(i,a,b) for(int i = a;i <= b;++i)\n#define ROF(i,a,b) for(int i = a;i >= b;--i)\n#define DEBUG(x) std::cerr << #x << '=' << x << std::endl\n \nconst int MAXN = 1e5 + 5;\nconst int ha = 1e9 + 7;\nint x[MAXN],y[MAXN];\nint n,m;\nP a[MAXN];\nint N;\nstd::vector<int> S;\nint f[MAXN];\n \nstruct BIT{\n    #define lowbit(x) ((x)&(-(x)))\n    int tree[MAXN];\n \n    inline void add(int pos,int d){\n        while(pos < MAXN){\n            (tree[pos] += d) %= ha;\n            pos += lowbit(pos);\n        }\n    }\n \n    inline int query(int pos){\n        int res = 0;\n        while(pos){\n            (res += tree[pos]) %= ha;\n            pos -= lowbit(pos);\n        }\n        return res;\n    }\n}bit;\n \ninline bool cmp(P x,P y){\n    return x.fi == y.fi ? x.se > y.se : x.fi < y.fi;// 同列不得转移\n}\n \nint main(){\n    scanf(\"%d%d\",&n,&m);\n    FOR(i,1,n) scanf(\"%d\",x+i);\n    FOR(i,1,m) scanf(\"%d\",y+i);\n    std::sort(x+1,x+n+1);std::sort(y+1,y+m+1);\n    FOR(i,1,n){\n        if(x[i] <= y[1] || x[i] >= y[m]) continue;\n        int p = std::lower_bound(y+1,y+m+1,x[i]) - y;\n        if(x[i] == y[p]) continue;\n        a[++N] = MP(x[i]-y[p-1],y[p]-x[i]);\n    }\n    std::sort(a+1,a+N+1,cmp);\n    FOR(i,1,N) S.pb(a[i].se);\n    std::sort(all(S));\n    S.erase(std::unique(all(S)),S.end());\n    FOR(i,1,N) a[i].se = std::lower_bound(all(S),a[i].se)-S.begin() + 2;\n    f[0] = 1;\n    N = std::unique(a+1,a+N+1)-a-1;\n//    FOR(i,1,N) printf(\"%d %d\\n\",a[i].fi,a[i].se);\n    FOR(i,1,N){\n        f[i] = bit.query(a[i].se-1)+1;f[i] %= ha;\n        DEBUG(f[i]);\n        bit.add(a[i].se,f[i]);\n    }\n    int ans = 0;\n    FOR(i,0,N) (ans += f[i]) %= ha;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9 + 7;\nconst int N = 650055;\nconst int K = 700 ;\nint x[N], y[N], t[N];\nvector < int > r[N];\nset < int > s1, s2;\nmap < int, int > mx, my;\nvector < pair < int, int > > p;\nint sum (int r)\n{\n\tint result = 0;\n\tfor (; r >= 0; r = (r & (r+1)) - 1)\n\t\tresult = (result + t[r]) % mod;\n\treturn result;\n}\n\nvoid inc (int i, int delta)\n{\n\tfor (; i < N; i = (i | (i+1)))\n\t\tt[i] = (t[i] + delta) % mod;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n   // freopen(\"input.txt\", \"r\", stdin);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) cin >> x[i];\n    for (int j = 1; j <= m; j++) cin >> y[j];\n    int c = 1;\n    for (int j = 1; j < m; j++){\n        while(x[c] < y[j] && c <= n) c++;\n        while(x[c] < y[j + 1] && c <= n){\n            p.pb({x[c] - y[j], y[j + 1] - x[c]});\n            c++;\n        }\n    }\n    for (auto i: p){\n        s1.insert(i.F);\n        s2.insert(i.S);\n    }\n    int cnt1, cnt2;\n    cnt1 = 0;\n    cnt2 = 0;\n    for (auto i: s1){\n        cnt1++;\n        mx[i] = cnt1;\n    }\n    for (auto i: s2){\n        cnt2++;\n        my[i] = cnt2;\n    }\n    for (int i = 0; i < p.size(); i++){\n        p[i].F = mx[p[i].F];\n        p[i].S = my[p[i].S];\n        r[p[i].S].pb(p[i].F);\n    }\n    inc(0, 1);\n    for (int i = 1; i <= cnt2; i++){\n        sort(r[i].begin(), r[i].end());\n        r[i].erase(unique(r[i].begin(), r[i].end()), r[i].end());\n        reverse(r[i].begin(), r[i].end());\n        for (auto j: r[i]){\n            inc(j, sum(j - 1));\n        }\n    }\n    cout << sum(cnt1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Maxn = 200005, p = 1e9 + 7;\nint n, m, ct, tmp_ct, x[Maxn], y[Maxn], a[Maxn];\npair <int, int> P[Maxn];\nlong long sum[Maxn];\nvector <int> Ve[Maxn];\nint lowbit(int x)\n{\n\treturn x & -x;\n}\nvoid add(int x, int y)\n{\n\tfor (int i = x; i <= tmp_ct + 1; i += lowbit(i))\n\t\t(sum[i] += y) %= p;\n}\nlong long ask(int x)\n{\n\tlong long tmp = 0;\n\tfor (int i = x; i; i -= lowbit(i))\n\t\t(tmp += sum[i]) %= p;\n\treturn tmp;\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &x[i]);\n\tfor (int i = 1; i <= m; i++)\n\t\tscanf(\"%d\", &y[i]);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (x[i] < y[1] || x[i] > y[m]) continue;\n\t\tint pos = upper_bound(y + 1, y + 1 + m, x[i]) - y;\n\t\tP[++ct] = make_pair(y[pos] - x[i], x[i] - y[pos - 1]);\n\t}\n\tsort(P + 1, P + 1 + ct);\n\tfor (int i = 1; i <= ct; i++)\n\t\ta[2 * i - 1] = P[i].first, a[2 * i] = P[i].second;\n\tsort(a + 1, a + 1 + 2 * ct);\n\ttmp_ct = unique(a + 1, a + 1 + 2 * ct) - a - 1;\n\tfor (int i = 1; i <= ct; i++)\n\t{\n\t\tP[i].first = lower_bound(a + 1, a + 1 + tmp_ct, P[i].first) - a;\n\t\tP[i].second = lower_bound(a + 1, a + 1 + tmp_ct, P[i].second) - a;\n\t\tVe[P[i].first].push_back(P[i].second);\n\t}\n\tadd(1, 1);\n\tfor (int i = 1; i <= tmp_ct; i++)\n\t{\n\t\tint las = 0;\n\t\tfor (vector <int> :: reverse_iterator it = Ve[i].rbegin(); it != Ve[i].rend(); it++)\n\t\t\tif (*it != las) add(*it + 1, ask(*it)), las = *it;\n\t}\n\tprintf(\"%lld\", ask(tmp_ct + 1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int MOD = 1000000007;\nconst int MX = 100010;\n\ninline void add(int &x, int y) { x += y; if (x >= MOD) x -= MOD; }\n\nint N, M;\nint x[MX], y[MX];\nint dp[5010][5010];\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\n\trep(i, N) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\n\trep(i, M) {\n\t\tscanf(\"%d\", &y[i]);\n\t}\n\n\tvector<pii> vec;\n\tvi ys;\n\n\trep(i, N) {\n\t\tint lo = upper_bound(y, y + M, x[i]) - y;\n\t\tif (lo == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t--lo;\n\t\tint l = x[i] - y[lo];\n\n\t\tlo = lower_bound(y, y + M, x[i]) - y;\n\t\tif (lo == M) {\n\t\t\tcontinue;\n\t\t}\n\t\tint r = y[lo] - x[i];\n\n\t\tif (l == 0 || r == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tvec.eb(l, r);\n\t\tys.eb(r);\n\t}\n\n\tsort(ALL(vec));\n\tsort(ALL(ys));\n\tys.erase(unique(ALL(ys)), ys.end());\n\tN = vec.size();\n\n\trep(i, N) {\n\t\tint y = vec[i].se;\n\t\tvec[i].se = lower_bound(ALL(ys), y) - ys.begin();\n\t}\n\n\tif (N > 500) return 0;\n\n\tint i;\n\tint now = 0;\n\tdp[0][0] = 1;\n\n\tfor (i = 0; i < N;) {\n\t\tint j = i;\n\t\twhile (j < N && vec[j].fi == vec[i].fi) {\n\t\t\t++j;\n\t\t}\n\n\t\tfor (int k = i; k < j; ++k) {\n\t\t\tfor (int t = 0; t <= vec[k].se; ++t) {\n\t\t\t\tadd(dp[now + 1][vec[k].se + 1], dp[now][t]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < N + 1; ++t) {\n\t\t\tadd(dp[now + 1][t], dp[now][t]);\n\t\t}\n\n\t\t++now;\n\t\ti = j;\n\t}\n\n/*\n\trep(i, now + 1) {\n\t\trep(j, N) {\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\n\tint ans = 0;\n\trep(i, N + 1) add(ans, dp[now][i]);\n\tcout << ans << endl;\n/*\n\trep(i, N) {\n\t\tcout << vec[i].fi << \" \" << vec[i].se << endl;\n\t}\n*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INTMAX 2147483647LL\n#define PII pair<int,int>\n#define MP make_pair\n#define fir first\n#define sec second\n#define pb push_back\n#define re register\n#define lc c[x][0]\n#define rc c[x][1]\nusing namespace std;\ntypedef long long ll;\nconst double Pi=acos(-1.0);\nconst int Inf=0x3f3f3f3f;\nconst int MAXN=1e5+10;\nconst int Mod=1e9+7;\ninline int read(){\n\tre int x=0,f=1,ch=getchar();\n\twhile(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-48,ch=getchar();\n\treturn x*f;\n}\ninline ll readll(){\n\tre ll x=0,f=1,ch=getchar();\n\twhile(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-48,ch=getchar();\n\treturn x*f;\n}\n\nstruct Node{int L,R;}p[MAXN];\ninline bool cmp(Node x,Node y){return x.L==y.L?x.R<y.R:x.L<y.L;}\n\nint n,m,cnt;\nint a[MAXN],b[MAXN];\nint R_pos[MAXN];\nint BIT[MAXN];\nvector<int> v;\n\ninline int lowbit(int x){return x&(-x);}\ninline void Update(int x,int v){for(int i=x;i<=n;i+=lowbit(i)) BIT[i]=(BIT[i]+v)%Mod;}\ninline int Query(int x){int res=1;for(int i=x;i;i-=lowbit(i)) res=(res+BIT[i])%Mod;return res;}\n\nint main(){\n\tn=read();m=read();\n\tfor(int i=1;i<=n;++i) a[i]=read();\n\tfor(int i=1;i<=m;++i) b[i]=read();\n\t\n\tfor(int i=1,pos;i<=n;++i){\n\t\tif(a[i]<=b[1]||a[i]>=b[m]) continue;\n\t\tpos=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tp[++cnt]=(Node){a[i]-b[pos-1],b[pos]-a[i]};\n\t\tv.pb(p[cnt].R);\n\t}\n\tsort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n\tn=cnt;sort(p,p+cnt+1,cmp);\n\tfor(int i=1,j=1,curL,curR;i<=n;++i){\n\t\t//cout<<i<<endl;\n\t\tcurL=p[i].L;\n\t\twhile(j<=n&&p[j].L==curL) ++j;\n\t\t//cout<<i<<endl;\n\t\tfor(int k=j-1;k>=i;--k){\n\t\t\tcurR=lower_bound(v.begin(),v.end(),p[k].R)-v.begin()+1;\n\t\t\tif(k!=j-1&&p[k].R==p[k+1].R) continue;\n\t\t\tUpdate(curR,Query(curR-1));\n\t\t} \n\t\t//cout<<i<<endl;\n\t}\n\tprintf(\"%d\\n\",Query(v.size()));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//バグった\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#define int long long\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\n\nint mod = 1000000007;\nint n, m;\nint x[100000];\nint y[100000];\nvector<int> dp[100001];\nint bcnt[100001];\nvector<int> L[100001], R[100001];\n\nsigned main() {\n\tint i, j, k;\n\t\n\tcin >> n >> m;\n\trep(i, n) cin >> x[i];\n\trep(i, m) cin >> y[i];\n\t\n\trep(i, m + 1) {\n\t\tint l = (i == 0) ? -1e+10 : y[i - 1];\n\t\tint r = (i == m) ? 1e+10 : y[i];\n\t\tint id1 = lower_bound(x, x + n, l) - x;\n\t\tint id2 = lower_bound(x, x + n, r) - x;\n\t\tfor (j = id1; j < id2; j++) {\n\t\t\tL[i].push_back(x[j] - l);\n\t\t\tR[i].push_back(r - x[j]);\n\t\t}\n\t\tdp[i].resize(max(1LL, id2 - id1 + 1));\n\t\trep(j, dp[i].size()) dp[i][j] = 0;\n\t\tbcnt[i] = id2 - id1;\n\t}\n\t\n\trep(i, bcnt[0] + 1) {\n\t\tdp[0][i] = 1;\n\t}\n\t\n\trep(i, m) {\n\t\trep(j, bcnt[i] + 1) {\n\t\t\tint L1 = (j == 0) ? -1e+10 : L[i][j - 1];\n\t\t\tint R1 = (j == 0) ? 1e+10 : R[i][j - 1];\n\t\t\tint L2 = (j == bcnt[i]) ? 1e+10 : L[i][j];\n\t\t\tint R2 = (j == bcnt[i]) ? -1e+10 : R[i][j];\n\t\t\trep(k, bcnt[i + 1] + 1) {\n\t\t\t\tint L3 = (k == 0) ? -1e+10 : L[i + 1][k - 1];\n\t\t\t\tint R3 = (k == 0) ? 1e+10 : R[i + 1][k - 1];\n\t\t\t\tint L4 = (k == bcnt[i + 1]) ? 1e+10 : L[i + 1][k];\n\t\t\t\tint R4 = (k == bcnt[i + 1]) ? -1e+10 : R[i + 1][k];\n\t\t\t\tif (L1 >= L4 && R1 <= R4) continue;\n\t\t\t\tif (L2 <= L3 && R2 >= R3) continue;\n\t\t\t\tdp[i + 1][k] += dp[i][j];\n\t\t\t\tdp[i + 1][k] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\trep(i, bcnt[m] + 1) { ans += dp[m][i]; ans %= mod; }\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define fo(x,a,b) for(int x=(a),e_=(b);x<=e_;x++)\n#define mo 1000000007\n#define plus(a,b) (a+=b)%=mo\n#define fi first\n#define se second\n#define ww printf\n\nusing namespace std;\nconst int N=100005;\npair<int,int> q[N];\nint pos[N],X[N],a[N],tp[N],n,m,tot=0;\n\nvoid add(int x,int d){\n\tfor(; x<=tot; x+=(x&(-x))) plus(a[x],d);\n}\nint qry(int x){\n\tint ans=a[0];\n\tfor(; x; x-=(x&(-x))) plus(ans,a[x]);\n\treturn ans;\n}\nint main(){\n\tint k1,k2;\n\tscanf(\"%d %d\",&n,&m);\n\tfo(i,1,n) scanf(\"%d\",&X[i]);\n\tfo(i,1,m) scanf(\"%d\",&pos[i]);\n\n\tfo(i,1,n) {\n\t\tif(X[i]<pos[1] || X[i]>pos[m]) continue;\n\t\tk2=upper_bound(pos+1,pos+1+m,X[i]) - pos; k1=k2-1;\n\t\tif(k1<1 || k2>m) continue;\n\t\t\n\t\tq[++tot]=make_pair(X[i]-pos[k1],pos[k2]-X[i]);\n\t}\n\tfo(i,1,tot) tp[i]=q[i].fi;\n\tsort(tp+1,tp+1+tot);\n\ttp[0]=1;fo(i,2,tot) if(tp[i]!=tp[tp[0]]) tp[++tp[0]]=tp[i];\n\tfo(i,1,tot) q[i].fi=lower_bound(tp+1,tp+1+tp[0],q[i].fi)-tp;\n\n\tfo(i,1,tot) tp[i]=q[i].se;\n\tsort(tp+1,tp+1+tot);\n\ttp[0]=1;fo(i,2,tot) if(tp[i]!=tp[tp[0]]) tp[++tp[0]]=tp[i];\n\tfo(i,1,tot) q[i].se=lower_bound(tp+1,tp+1+tp[0],q[i].se)-tp;\n\n\tfo(i,1,tot) {\n//\t\tww(\"now :%d %d\\n\",q[i].fi,q[i].se);\n\t\tq[i].se=-q[i].se;\n\t}sort(q+1,q+1+tot), a[0]=1;\n\n\tfo(i,1,tot) {\n\t\tif(i>1 && q[i]==q[i-1]) continue;\n//\t\tprintf(\"%d %d\\n\",q[i].fi,-q[i].se);\n\t\tadd(-q[i].se,qry(-q[i].se-1));\n\t}\n\tprintf(\"%d\",qry(tot));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define fi first\n#define se second\n#define sz(x) (int)(x).size()\n#define INF 0x3f3f3f3f\n//#define Local\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int N = 1e5 + 5, MOD = 1e9 + 7;\n\nint n, m;\nint x[N], y[N], d[N << 1];\nstruct Point{\n    int a, b;\n    bool operator < (const Point& A) const {\n        if(a == A.a) return b < A.b;\n        return a < A.a;\n    }\n}p[N];\n\nint c[N];\nint lowbit(int x) {return x & (-x);}\n\nvoid add(int x, int v) {\n    for(; x < N; x += lowbit(x)) c[x] = (c[x] + v) % MOD;\n}\n\nint query(int x) {\n    int ans = 0;\n    for(; x > 0; x -= lowbit(x)) ans = (ans + c[x]) % MOD;\n    return ans;\n}\n\nvoid run() {\n    d[0] = 0;\n    memset(c, 0, sizeof(c));\n    for(int i = 1; i <= n; i++) cin >> x[i];\n    for(int i = 1; i <= m; i++) cin >> y[i];\n    int cnt = 0;\n    for(int i = 1; i <= n; i++) {\n        if(x[i] > y[1] && x[i] < y[m]) {\n            int left = lower_bound(y + 1, y + m + 1, x[i]) - y - 1;\n            int right = lower_bound(y + 1, y + m + 1, x[i]) - y;\n            int l = x[i] - y[left], r = y[right] - x[i];\n            p[++cnt] = {l, r};\n            d[++d[0]] = r;\n        }\n    }\n    sort(d + 1, d + d[0] + 1);\n    d[0] = unique(d + 1, d + d[0] + 1) - d - 1;\n    for(int i = 1; i <= cnt; i++) {\n        p[i].b = lower_bound(d + 1, d + d[0] + 1, p[i].b) - d;\n    }\n    sort(p + 1, p + cnt + 1);\n    int ans = 1;\n    for(int i = 1; i <= cnt; i++) {\n        if(p[i].a == p[i - 1].a && p[i].b == p[i - 1].b) continue;\n        int res = query(p[i].b - 1);\n        if(p[i].a != p[i - 1].a) ++res;\n        if(res >= MOD) res -= MOD;\n        add(p[i].b, res);\n        ans = (ans + res) % MOD;\n    }\n    cout << ans << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    cout << fixed << setprecision(20);\n#ifdef Local\n    freopen(\"../input.in\", \"r\", stdin);\n    freopen(\"../output.out\", \"w\", stdout);\n#endif\n    while(cin >> n >> m) run();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define lowbit(x) x&-x\nusing namespace std;\nconst int maxn=1e5+99,oo=1e9+7;\nint n,m,A[maxn],N,c[2*maxn],d[maxn*2],tot,f[maxn];\ninline void add(int pos,int x){for(;pos<=N;pos+=lowbit(pos))c[pos]+=x;}\ninline int ask(int pos){int ans=0;for(;pos;pos-=lowbit(pos))ans+=c[pos];return ans;}\nset<int>s;\nstruct node{\n\tint x,y;\n\tfriend bool operator<(node a,node b){\n\t\treturn a.x==b.x?a.y>b.y:a.x<b.x;\n\t}\n}a[maxn];\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(int i=1;i<=n;++i)scanf(\"%lld\",&A[i]);\n\ts.insert(0);s.insert(oo);\n\tfor(int i=1,x;i<=m;++i)scanf(\"%lld\",&x),s.insert(x);\n\tfor(int i=1;i<=n;++i){\n\t\tset<int>::iterator it=s.lower_bound(A[i]);\n\t\tif((*it)==0||(*it)==oo){a[i].x=-1;continue;}\n\t\ta[i].x=*it-A[i];a[i].y=A[i]-*(--it);\n\t\tif((*it)==0||(*it)==oo){a[i].x=-1;continue;}\n\t\td[++tot]=a[i].x,d[++tot]=a[i].y;\n\t}\n\tsort(d+1,d+1+tot);tot=unique(d+1,d+1+tot)-d-1;N=tot;\n\tfor(int i=1;i<=n;++i){\n\t\tif(a[i].x<0)continue;\n\t\ta[i].x=lower_bound(d+1,d+1+tot,a[i].x)-d;\n\t\ta[i].y=lower_bound(d+1,d+1+tot,a[i].y)-d;\n\t}\n\tsort(a+1,a+1+n);\n\tfor(int i=1;i<=n;++i){\n\t\tif(a[i].x==a[i-1].x&&a[i].y==a[i-1].y)continue;\n\t\tif(a[i].x<0)continue;\n\t\tf[i]=ask(a[i].y-1)+1;\n\t\tadd(a[i].y,f[i]);\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;++i){\n\t\tans=(ans+f[i])%oo;\n\t}\n\tans=(ans+1)%oo;cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define fi first\n#define se second\n#define sz(x) (int)(x).size()\n#define INF 0x3f3f3f3f\n//#define Local\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int N = 1e5 + 5, MOD = 1e9 + 7;\n\nint n, m;\nint x[N], y[N], d[N];\nstruct Point{\n    int a, b;\n    bool operator < (const Point& A) const {\n        if(a == A.a) return b > A.b;\n        return a < A.a;\n    }\n}p[N];\n\nint c[N];\nint lowbit(int x) {return x & (-x);}\n\nvoid add(int x, int v) {\n    for(; x < N; x += lowbit(x)) c[x] = (c[x] + v) % MOD;\n}\n\nint query(int x) {\n    int ans = 0;\n    for(; x > 0; x -= lowbit(x)) ans = (ans + c[x]) % MOD;\n    return ans;\n}\n\nvoid run() {\n    d[0] = 0;\n    memset(c, 0, sizeof(c));\n    for(int i = 1; i <= n; i++) cin >> x[i];\n    for(int i = 1; i <= m; i++) cin >> y[i];\n    int cnt = 0;\n    for(int i = 1; i <= n; i++) {\n        if(x[i] > y[1] && x[i] < y[m]) {\n            int left = lower_bound(y + 1, y + m + 1, x[i]) - y - 1;\n            int right = left + 1;\n            int l = x[i] - y[left], r = y[right] - x[i];\n            p[++cnt] = {l, r};\n            d[++d[0]] = r;\n        }\n    }\n    sort(d + 1, d + d[0] + 1);\n    d[0] = unique(d + 1, d + d[0] + 1) - d - 1;\n    for(int i = 1; i <= cnt; i++) {\n        p[i].b = lower_bound(d + 1, d + d[0] + 1, p[i].b) - d;\n    }\n    sort(p + 1, p + cnt + 1);\n    int ans = 1;\n    for(int i = 1; i <= cnt; i++) {\n        if(p[i].a == p[i - 1].a && p[i].b == p[i - 1].b) continue;\n        int res = query(p[i].b - 1) + 1;\n        if(res >= MOD) res -= MOD;\n        add(p[i].b, res);\n        ans = (ans + res) % MOD;\n    }\n    cout << ans << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    cout << fixed << setprecision(20);\n#ifdef Local\n    freopen(\"../input.in\", \"r\", stdin);\n    freopen(\"../output.out\", \"w\", stdout);\n#endif\n    while(cin >> n >> m) run();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define mod 1000000007\nint n,m,a[101000],b[101000];\nmap<int,int>f;\nmap<int,set<int,greater<int> > >s;\nvoid add(int x,int v){for(;x<=mod;x+=x&-x)f[x]=(f[x]+v)%mod;}\nint qry(int x){int t=0;for(;x;x-=x&-x)t=(t+f[x])%mod;return t;}\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)cin>>a[i];\n\tfor(int i=1;i<=m;i++)cin>>b[i];\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint p=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif(p>=2&&p<=m)s[a[i]-b[p-1]].insert(b[p]-a[i]);\n\t}\n\tadd(1,1);\n\tfor(map<int,set<int,greater<int> > >::iterator it1=s.begin();it1!=s.end();it1++)for(set<int,greater<int> >::iterator it2=((*it1).second).begin();it2!=((*it1).second).end();it2++)add((*it2)+1,qry(*it2));\n\tcout<<qry(mod)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#define maxn 200005\n#define fi first\n#define se second\n#define mod 1000000007\nusing namespace std;\nint a[maxn], b[maxn], arr[maxn], f[maxn];\npair <int, int> node[maxn];\nmap <int, int> mp;\nint C[maxn], c;\nbool cmp(pair <int, int> x, pair <int, int> y){\n\treturn x.fi < y.fi || x.fi == y.fi && x.se > y.se;\n}\nvoid add(int x, int y){\n\tfor (; x <= c; x += x & -x)\n\t\tC[x] = (C[x] + y) % mod;\n}\nint sum(int x){\n\tint ans = 0;\n\tfor (; x; x -= x & -x)\n\t\tans = (ans + C[x]) % mod;\n\treturn ans;\n}\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++ i)\n\t\tscanf(\"%d\", &a[i]);\n\tfor (int i = 1; i <= m; ++ i)\n\t\tscanf(\"%d\", &b[i]);\n\tint l = 1, r = n;\n\twhile (a[l] < b[1] && l <= n)\n\t\t++ l;\n\twhile (a[r] > b[m] && r)\n\t\t-- r;\n\tfor (int i = l; i <= r; ++ i)\n\t\ta[i - l + 1] = a[i];\n\tn = r - l + 1;\n\tfor (int i = 1, j = 1; i <= n; ++ i){\n\t\twhile (b[j + 1] < a[i] && j + 1 <= m)\n\t\t\t++ j;\n\t\tnode[i].fi = a[i] - b[j];\n\t}\n\tfor (int i = n, j = m; i; -- i){\n\t\twhile (b[j - 1] > a[i] && j - 1)\n\t\t\t-- j;\n\t\tnode[i].se = b[j] - a[i];\n\t\tarr[i] = b[j] - a[i];\n\t}\n    sort(arr + 1, arr + 1 + n);\n    for (int i = 1; i <= n; ++ i)\n\t\tif (arr[i] != arr[i - 1])\n\t\t\tmp[arr[i]] = ++ c;\n\tfor (int i = 1; i <= n; ++ i)\n\t\tnode[i].se = mp[node[i].se];\n\tsort(node + 1, node + 1 + n, cmp);\n\tint _n = unique(node + 1, node + 1 + n) - node - 1;\n\t//for (int i = 1; i <= n; ++ i)\n\t\t//cout << node[i].fi << \" \"<< node[i].se << endl;\n\tint ans = 1;\n\tfor (int i = 1; i <= _n; ++ i){\n\t\tans = (ans + (f[i] = (sum(node[i].se - 1) + 1) % mod)) % mod;\n\t\tadd(node[i].se, f[i]);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t value;  // faster than int32_t a little\n    mint() = default;  // value is not initialized\n    mint(int64_t value_) : value(value_) {}  // assume value is in proper range\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->value + other.value; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator - (mint<MOD> other) const { int64_t c = this->value - other.value; return mint<MOD>(c <    0 ? c + MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->value * int64_t(other.value) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline mint<MOD> & operator -= (mint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->value = this->value * int64_t(other.value) % MOD; if (this->value < 0) this->value += MOD; return *this; }\n};\ntemplate <int32_t MOD> ostream & operator << (ostream & out, mint<MOD> n) { return out << n.value; }\n\nconstexpr int MOD = 1e9 + 7;\n\nmint<MOD> solve(int n, int m, vector<int> const & robots, vector<int> const & exits) {\n    map<int, set<int> > ranges; {\n        int i = 0;\n        while (i < n and robots[i] < exits[0]) ++ i;  // they must go right\n        int j = 0;\n        for (; i < n; ++ i) {\n            while (j + 1 < m and exits[j + 1] < robots[i]) ++ j;\n            if (j + 1 == m) break;  // they must go left\n            int l = robots[i] - exits[j];\n            int r = exits[j + 1] - robots[i];\n            ranges[l].insert(r);\n        }\n    }\n\n    unordered_map<int, mint<MOD> > cur, prv;\n    cur[0] = 1;\n    for (auto & range : ranges) {\n        cur.swap(prv);\n        cur.clear();\n        int l = range.first;\n        auto & rs = range.second;\n        for (auto it : prv) {\n            int max_r; mint<MOD> cnt; tie(max_r, cnt) = it;\n            int last_r = 0;\n            for (int r : rs) {\n                if (r <= max_r) {\n                    // this must be go right\n                } else {\n                    cur[max(max_r, last_r)] += cnt;  // go left here\n                }\n                last_r = r;\n            }\n            cur[max(max_r, *rs.rbegin())] += cnt;  // all of them go right\n        }\n    }\n    mint<MOD> cnt = 0;\n    for (auto it : cur) {\n        cnt += it.second;\n    }\n    return cnt;\n}\n\nint main() {\n    int n, m; cin >> n >> m;\n    vector<int> x(n);\n    REP (i, n) cin >> x[i];\n    vector<int> y(m);\n    REP (j, m) cin >> y[j];\n    cout << solve(n, m, x, y).value << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MX = 100005;\nconst int MOD = 1000000007;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nstruct FEN\n{\n\tint sum[MX];\n\n\tvoid add(int p, int x)\n\t{\n\t\tfor(int i=p+1; i<MX; i+=i&-i) sum[i] += x, sum[i] %= MOD;\n\t}\n\n\tint qur(int p)\n\t{\n\t\tint ret = 0;\n\t\tfor(int i=p+1; i; i-=i&-i) ret += sum[i], ret %= MOD;\n\t\treturn ret;\n\t}\n} F;\n\nstruct vec\n{\n\tint x, y;\n\n\tvec (const ll &x0 = 0, const ll &y0 = 0) : x(x0), y(y0) {}\n};\n\nint n, m;\nint ext[MX], rob[MX];\nvec pot[MX];\nvector<int> seq[MX];\n\nvoid input()\n{\n\tread(n), read(m);\n\tfor(int i=1; i<=n; i++) read(rob[i]);\n\tfor(int i=1; i<=m; i++) read(ext[i]);\n}\n\nvoid discrete()\n{\n\tint tmp[MX];\n\tint num = 0;\n\tfor(int i=1; i<=n; i++) tmp[++num] = pot[i].x;\n\tsort(tmp+1, tmp+num+1);\n\tnum = unique(tmp+1, tmp+num+1) - tmp - 1;\n\tfor(int i=1; i<=n; i++) pot[i].x = lower_bound(tmp+1, tmp+num+1, pot[i].x) - tmp;\n\tnum = 0;\n\tfor(int i=1; i<=n; i++) tmp[++num] = pot[i].y;\n\tsort(tmp+1, tmp+num+1);\n\tnum = unique(tmp+1, tmp+num+1) - tmp - 1;\n\tfor(int i=1; i<=n; i++) pot[i].y = lower_bound(tmp+1, tmp+num+1, pot[i].y) - tmp;\n}\n\nvoid work()\n{\n\tint l = 1, r = n;\n\twhile(l<=n && rob[l]<ext[1]) l++;\n\twhile(r>=1 && rob[r]>ext[m]) r--;\n\tif(l > r) puts(\"1\"), exit(0);\n\telse memmove(rob+1, rob+l, sizeof(int)*(r-l+1)), n = r-l+1;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tauto rt = upper_bound(ext+1, ext+m+1, rob[i]);\n\t\tauto lt = rt; lt--;\n\t\tpot[i] = vec(rob[i]-*lt, *rt-rob[i]);\n\t}\n\tdiscrete();\n\tfor(int i=1; i<=n; i++) seq[pot[i].x].push_back(pot[i].y);\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tsort(seq[i].begin(), seq[i].end());\n\t\tseq[i].erase(unique(seq[i].begin(), seq[i].end()), seq[i].end());\n\t}\n\tF.add(0, 1);\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=seq[i].size()-1; j>=0; j--)\n\t\t\tF.add(seq[i][j], F.qur(seq[i][j]-1));\n\tprintf(\"%d\\n\", F.qur(n));\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <algorithm>\n#define il inline\n#define ri register\n#define Size 100050\n#define yyb 1000000007\nusing namespace std;\nstruct pos{\n\tint x,y;\n\til bool operator<(const pos&a)const{\n\t\treturn x==a.x?y<a.y:x<a.x;\n\t}\n}p[Size];\nset<pos>S;\nset<pos>::iterator it;\nint pt,c[Size],dp[Size];\nint x1[Size],x2[Size],a[Size],b[Size];\nil void read(int&),change(int,int);\nil int dfs(int,int,int,int[]),ask(int);\nint main(){\n\tint n,m;read(n),read(m);\n\tfor(int i(1);i<=n;++i)read(x1[i]);\n\tfor(int i(1);i<=m;++i)read(x2[i]);\n\tfor(int i(1),j;i<=n;++i){\n\t\tj=dfs(1,m,x1[i],x2);if(j==1||j>m)continue;\n\t\tS.insert({x1[i]-x2[j-1],x2[j]-x1[i]});\n\t}for(it=S.begin();it!=S.end();++it)p[++pt]=*it;\n\tfor(int i(1);i<=pt;++i)a[i]=p[i].y;sort(a+1,a+pt+1);\n\tfor(int i(1);i<=pt;++i)b[i]=dfs(1,pt,p[i].y,a);\n\tfor(int l(1),r,i;l<=pt;l=r+1){\n\t\tr=l;while(p[r+1].x==p[r].x)++r;\n\t\tfor(i=l;i<=r;++i)dp[i]=ask(b[i]-1)+1;\n\t\tfor(i=l;i<=r;++i)change(b[i],dp[i]);\n\t}int ans(1);for(int i(1);i<=pt;++i)ans=(ans+dp[i])%yyb;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\nil int ask(int p){\n\tint ans(0);while(p)ans=(ans+c[p])%yyb,p-=p&-p;return ans;\n}\nil void change(int p,int x){\n\twhile(p<=pt)c[p]=(c[p]+x)%yyb,p+=p&-p;\n}\nil int dfs(int l,int r,int x,int a[]){\n\tint mid;while(l<=r){\n\t\tmid=l+r>>1;\n\t\tif(a[mid]<x)l=mid+1;\n\t\telse r=mid-1;\n\t}return l;\n}\nil void read(int &x){\n\tx^=x;ri char c;while(c=getchar(),c<'0'||c>'9');\n\twhile(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\ninline int gi()\n{\n\tint f = 1, x = 0; char c = getchar();\n\twhile (c < '0' || c > '9') { if (c == '-') f = -1; c = getchar();}\n\twhile (c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar();}\n\treturn f * x;\n}\n\nint n, m, x[100005], y[100005], a[100005], sum, ans, p, q;\n/*\ninline bool pd(int u)\n{\n\tfor (int i = 1; i <= m; i++) if (u == y[i]) return true;\n\treturn false;\n}\n\nvoid dfs(int b[], int sy)\n{\n\tif (!sy)\n\t{\n\t\t++cnt;\n\t\treturn;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (b[i])\n\t\t{\n\t\t\t\n\t\t}\n\t}\n}*/\n\nint main()\n{\n\tn = gi(), m = gi();\n\tfor (int i = 1; i <= n; i++) x[i] = gi();\n\tfor (int i = 1; i <= m; i++) y[i] = gi();\n\tint tot = n;\n\tprintf(\"%d\\n\", m);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\nint n,m,a[100007],b[100007];\nvector < pair <int,int> > pos;\nmap <int,long long> bit;\nconst long long mod=1e9+7,lim=1e9+1;\nbool cmp(pair<int,int> x, pair<int,int> y){\n\treturn ((x.fi<y.fi) || (x.fi==y.fi && x.se>y.se));\n}\nvoid update(int pos,long long val){\n\tfor(int i=pos;i<=lim;i+=i&(-i)){\n\t\tbit[i]=(bit[i]+val)%mod;\n\t}\n}\nlong long get(int pos){\n\tlong long ret=0;\n\tfor(int i=pos;i>=1;i-=i&(-i)){\n\t\tret=(ret+bit[i])%mod;\n\t}\n\treturn ret;\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=m;i++) cin>>b[i];\n\tint cnt=0;\n\tfor(int i=1;i<=n;i++){\n\t\twhile(cnt<m && b[cnt+1]<=a[i]){\n\t\t\tcnt++;\n\t\t}\n\t\tif(cnt>=1 && cnt<m && a[i]!=b[cnt] && a[i]!=b[cnt+1]){\n\t\t\tpos.pb(mp(a[i]-b[cnt],b[cnt+1]-a[i]));\n\t\t}\n\t}\n\tsort(pos.begin(),pos.end(),cmp);\n\tupdate(1,1);\n\tfor(int i=0;i<(int)pos.size();i++){\n\t\tif(i==0 || pos[i]!=pos[i-1]){\n\t\t\tupdate(pos[i].se+1,get(pos[i].se));\n\t\t}\n\t}\n\tcout<<get(lim);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nconst int mod = 1000000007;\nint N, M;\nint main() {\n\tcin >> N >> M;\n\tvector<int> x(N), y(M), nx;\n\tfor (int i = 0; i < N; ++i) cin >> x[i];\n\tfor (int i = 0; i < M; ++i) cin >> y[i];\n\tsort(y.begin(), y.end());\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (!(x[i] < y[0] || x[i] > y[M - 1])) {\n\t\t\tnx.push_back(x[i]);\n\t\t}\n\t}\n\tx = nx;\n\tN = x.size();\n\tvector<int> px(N), py(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tint ptr = lower_bound(y.begin(), y.end(), x[i]) - y.begin();\n\t\tpy[i] = y[ptr] - x[i];\n\t\tpx[i] = x[i] - y[ptr - 1];\n\t}\n\tvector<int> sx = px, sy = py, p(N);\n\tsort(sx.begin(), sx.end()); sx.erase(unique(sx.begin(), sx.end()), sx.end());\n\tsort(sy.begin(), sy.end()); sy.erase(unique(sy.begin(), sy.end()), sy.end());\n\tfor (int i = 0; i < N; ++i) {\n\t\tpx[i] = lower_bound(sx.begin(), sx.end(), px[i]) - sx.begin();\n\t\tpy[i] = lower_bound(sy.begin(), sy.end(), py[i]) - sy.begin();\n\t\tp[i] = i;\n\t}\n\tint W = sy.size();\n\tsort(p.begin(), p.end(), [&](int i, int j) { return px[i] != px[j] ? px[i] < px[j] : py[i] > py[j]; });\n\tvector<int> bit(W + 2);\n\tfor (int i = 1; i <= W + 1; i += i & (-i)) bit[i] = 1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (i >= 1 && px[i] == px[i - 1] && py[i] == py[i - 1]) continue;\n\t\tint cy = py[p[i]];\n\t\tint sum = 0;\n\t\tfor (int k = cy + 1; k >= 1; k -= k & (-k)) {\n\t\t\tsum += bit[k];\n\t\t\tif (sum >= mod) sum -= mod;\n\t\t}\n\t\tfor (int k = cy + 2; k <= W + 1; k += k & (-k)) {\n\t\t\tbit[k] += sum;\n\t\t\tif (bit[k] >= mod) bit[k] -= mod;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = W + 1; i >= 1; i -= i & (-i)) {\n\t\tans += bit[i];\n\t\tif (ans >= mod) ans -= mod;\n\t}\n\tcout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define db double\n#define lowbit(p) (p&(-p))\n#define pb push_back\n#define mp make_pair\n#define pii pair<ll,ll>\n#define A first\n#define B second\nusing namespace std;\nvoid read(int &x){\n\tx=0; char c=getchar(); int p=1;\n\tfor (;c<48;c=getchar())if (c=='-')p=-1;\n\tfor (;c>47;c=getchar())x=(x<<1)+(x<<3)+(c^48);\n\tx*=p;\n}\nvoid read(ll &x){\n\tx=0; char c=getchar(); int p=1;\n\tfor (;c<48;c=getchar())if (c=='-')p=-1;\n\tfor (;c>47;c=getchar())x=(x<<1)+(x<<3)+(c^48);\n\tx*=p;\n}\nvoid Min(int &x,int y){\n\tif (x>y)x=y;\n}\nvoid Max(int &x,int y){\n\tif (x<y)x=y;\n}\nvoid Min(ll &x,ll y){\n\tif (x>y)x=y;\n}\nvoid Max(ll &x,ll y){\n\tif (x<y)x=y;\n}\n/*\n数轴上一些整点,求有多少种不同移动方案把所有点都推到出口.\n方案不同当且仅当存在至少一个点出口位置不同\n\n每个点要么左边出口要么右边出口\n那么就是考虑n个数对\n(ldis,rdis)\n分别表示到左边的出口的距离,到右边出口的距离\n如果一个点完全被另外一个点覆盖,确定其他点的方向就能确定它本身,那么这个点可以删掉?\n或者说看做在每一个区间里面找一些分割点之类的?\n\n很难判定\n\n把机器人看作是点\n(x,y)\n那么每次操作可能是\n(x-1,y)或者(x,y-1)\n然后走到某一条坐标轴之后停下\n\n要同时考虑两维很困难啊...?\n如果记dp(x,y)为x坐标已经减去了x,y坐标已经减去了y的方案数.\n那么要考虑的点就剩下(P_x,P_y)  P_x\\geq x P_y\\geq y\n考虑能直接转移过来的点\n\n*/\n#define mo 1000000007\n#define M 200005\nstruct Reimu{\n\tint tot,ls[M*60],rs[M*60];\n\tll f[M*60];\n\tvoid upd(ll l,ll r,ll x,ll y,ll v,int &p){\n\t\tif (p==0)p=++tot;\n//\t\tprintf(\"p=%d l=%lld r=%lld  v=%lld\\n\",p,l,r,v);\n\t\tif (l==x&&r==y){\n//\t\t\tprintf(\"p=%d l=%lld r=%lld  v=%lld\\n\",p,l,r,v);\n\t\t\t(f[p]+=v)%=mo;\n//\t\t\tprintf(\"f[%d]=%lld\\n\",p,f[p]);\n\t\t\treturn ;\n\t\t}\n\t\tll mid=(l+r)>>1;\n\t\tif (y<=mid)upd(l,mid,x,y,v,ls[p]);\n\t\telse if (x>mid)upd(mid+1,r,x,y,v,rs[p]);\n\t\telse upd(l,mid,x,mid,v,ls[p]),upd(mid+1,r,mid+1,y,v,rs[p]);\n\t}\n\tll qu(ll l,ll r,ll x,int p){\n//\t\tprintf(\"%lld %lld %lld  f[%d]=%lld\\n\",l,r,x,p,f[p]);\n\t\tif (!p)return 0;\n\t\tif (l==r)return f[p];\n\t\tll mid=(l+r)>>1;\n\t\tif (x<=mid)return qu(l,mid,x,ls[p])+f[p];\n\t\telse return qu(mid+1,r,x,rs[p])+f[p];\t\n\t}\n}T;\nconst ll inf=1e12;\nll l[M],r[M],L,R,f[M];\nint n,m,tot,rt;\npii a[M];\nint main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n//\tfreopen(\"1.in\",\"r\",stdin);\n\tint i,x,j;\n\tll tmp,res;\n\tread(n); read(m);\n\tfor (i=1;i<=n;i++){\n\t\tread(x);\n\t\ta[++tot]=mp(x,i);\n\t}\n\tL=0; R=inf;\n\tfor (i=1;i<=m;i++){\n\t\tread(x);\n\t\ta[++tot]=mp(x,0);\n\t}\n\tsort(a+1,a+tot+1);\n\ttmp=-2*inf;\n\tfor (i=1;i<=tot;i++){\n\t\tif (a[i].B){\n\t\t\tl[a[i].B]=a[i].A-tmp;\t\t\t\t\n\t\t}\n\t\telse{\n\t\t\ttmp=a[i].A;\n\t\t}\n\t}\n\ttmp=2*inf;\n\tfor (i=tot;i>=1;i--){\n\t\tif (a[i].B){\n\t\t\tr[a[i].B]=tmp-a[i].A;\n\t\t}\n\t\telse {\n\t\t\ttmp=a[i].A;\n\t\t}\n\t}\n\ttot=0;\n\tfor (i=1;i<=n;i++){\n\t\tif (l[i]<inf&&r[i]<inf&&l[i]>0&&r[i]>0)a[++tot]=mp(l[i],r[i]);\n\t}\n\tsort(a+1,a+tot+1);\n\ttot=unique(a+1,a+tot+1)-a-1;\n\tfor (i=1;i<=tot;){\n//\t\tprintf(\"---- qu-----\\n\");\n\t\tfor (j=i;j<=tot&&a[i].A==a[j].A;j++){\n\t\t\tf[j]=T.qu(L,R,a[j].B,rt)+1;\n//\t\t\tprintf(\"%lld %lld\\n\",a[j].A,a[j].B);\n//\t\t\tprintf(\"f[%d]=%lld\\n\",j,f[j]);\n\t\t}\n//\t\tprintf(\"------cal-------\\n\");\n//\t\tprintf(\"rt=%d\\n\",rt);\n//\t\tprintf(\"%lld %lld   %lld %lld\\n\",L,R,L,a[i].B);\n//\t\tprintf(\"---- upd-----\\n\");\n\t\tfor (j=i;j<=tot&&a[i].A==a[j].A;j++){\n\t\t\tT.upd(L,R,a[j].B+1,R,f[j],rt);\n\t\t}\n\t\ti=j;\n\t}\n\tres=T.qu(L,R,R,rt)+1;\n\tres=(res+mo)%mo;\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9;\nconst int N = 650055;\nconst int K = 700 ;\nint x[N], y[N], t[N];\nvector < int > r[N];\nset < int > s1, s2;\nmap < int, int > mx, my;\nvector < pair < int, int > > p;\nint sum (int r)\n{\n\tint result = 0;\n\tfor (; r >= 0; r = (r & (r+1)) - 1)\n\t\tresult = (result + t[r]) % mod;\n\treturn result;\n}\n\nvoid inc (int i, int delta)\n{\n\tfor (; i < N; i = (i | (i+1)))\n\t\tt[i] = (t[i] + delta) % mod;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n   // freopen(\"input.txt\", \"r\", stdin);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) cin >> x[i];\n    for (int j = 1; j <= m; j++) cin >> y[j];\n    int c = 1;\n    for (int j = 1; j < m; j++){\n        while(x[c] < y[j]) c++;\n        while(x[c] < y[j + 1] && c <= n){\n            p.pb({x[c] - y[j], y[j + 1] - x[c]});\n            c++;\n        }\n    }\n    for (auto i: p){\n        s1.insert(i.F);\n        s2.insert(i.S);\n    }\n    int cnt1, cnt2;\n    cnt1 = 0;\n    cnt2 = 0;\n    for (auto i: s1){\n        cnt1++;\n        mx[i] = cnt1;\n    }\n    for (auto i: s2){\n        cnt2++;\n        my[i] = cnt2;\n    }\n    for (int i = 0; i < p.size(); i++){\n        p[i].F = mx[p[i].F];\n        p[i].S = my[p[i].S];\n        r[p[i].S].pb(p[i].F);\n    }\n    inc(0, 1);\n    for (int i = 1; i <= cnt2; i++){\n        sort(r[i].begin(), r[i].end());\n        r[i].erase(unique(r[i].begin(), r[i].end()), r[i].end());\n        reverse(r[i].begin(), r[i].end());\n        for (auto j: r[i]){\n            inc(j, sum(j - 1));\n        }\n    }\n    cout << sum(cnt1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\ntypedef long long ll;\ntypedef double dd;\n#define For(i,j,k) for (int i=(int)j;i<=(int)k;++i)\n#define Forr(i,j,k) for (int i=(int)j;i>=(int)k;--i)\n#define Set(a,p) memset(a,p,sizeof(a))\nusing namespace std;\n\ntemplate<typename T>bool chkmax(T &a,T b) { return a<b?a=b,1:0; }\ntemplate<typename T>bool chkmin(T &a,T b) { return a>b?a=b,1:0; }\n\nconst int maxn=2e5+1e2;\nconst int modd=1e9+7;\nconst int inf=0x3f3f3f3f;\nstruct node {\n\tint x,y;\n\tbool operator < (const node &aa) const {\n\t\treturn ((x<aa.x) || (x==aa.x && y<aa.y));\n\t}\n\tbool operator == (const node &aa) const {\n\t\treturn (x==aa.x && y==aa.y);\n\t}\n}s[maxn];\nint n,m;\nint cnt,N;\nint a[maxn],b[maxn],c[maxn],dp[maxn];\n\ninline void file() {\n\tfreopen(\"ARC101F.in\",\"r\",stdin);\n\tfreopen(\"ARC101F.out\",\"w\",stdout);\n}\n\ninline int read() {\n\tint x=0,p=1;\n\tchar c=getchar();\n\twhile (!isdigit(c)) { if (c=='-') p=-1; c=getchar();}\n\twhile (isdigit(c)) { x=(x<<1)+(x<<3)+(c-'0'); c=getchar();}\n\treturn x*p;\n}\n\ninline void Add(int &a,int b) {\n\ta+=b;\n\ta=(a>=modd?a-modd:a);\n\ta=(a<0?a+modd:a);\n}\n\nstruct Bit {\n\tint bit[maxn];\n\n\tinline void init() { Set(bit,0); }\n\n\tinline int lowbit(int x) { return x&-x; };\n\n\tinline void update(int x,int y) {\n\t\tfor (;x<=maxn;x+=lowbit(x)) Add(bit[x],y);\n\t}\n\n\tinline int query(int x) {\n\t\tint sum=0;\n\t\tfor (;x;x-=lowbit(x)) Add(sum,bit[x]);\n\t\treturn sum;\n\t}\n}T;\n\nint main() {\n\tfile();\n\tn=read(); m=read();\n\tFor (i,1,n) a[i]=read();\n\tFor (i,1,m) b[i]=read();\n\tFor (i,1,n) {\n\t\tint p=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif (p==1 || p==m+1) continue;\n\t\ts[++N].x=a[i]-b[p-1]; s[N].y=b[p]-a[i];\n\t\tc[++cnt]=a[i]-b[p-1]; c[++cnt]=b[p]-a[i];\n\t}\n//\tFor (i,1,N) cout << s[i].x << \" \" << s[i].y << endl;\n\tc[++cnt]=0; c[++cnt]=inf;\n\tsort(c+1,c+cnt+1); cnt=unique(c+1,c+cnt+1)-(c+1);\n//\tFor (i,1,cnt) cout << c[i] << \" \" ; cout << endl;\n\tFor (i,1,N) {\n\t\ts[i].x=lower_bound(c+1,c+cnt+1,s[i].x)-c;\n\t\ts[i].y=lower_bound(c+1,c+cnt+1,s[i].y)-c;\n\t}\n\tsort(s+1,s+N+1); N=unique(s+1,s+N+1)-(s+1);\n//\tFor (i,1,N) cout << s[i].x << \" \" << s[i].y << endl;\n\tT.init(); T.update(1,1);\n\tfor (int i=1,j;i<=N;i=j+1) {\n\t\tj=i;\n\t\twhile (j<N && s[j+1].x==s[i].x) ++j;\n//\t\tcout << i << \"*\" << j << endl;\n\t\tFor (k,i,j) dp[k]=T.query(s[k].y-1);\n//\t\tcout << dp[i] << endl;\n\t\tFor (k,i,j) T.update(s[k].y,dp[k]);\n\t}\n\tprintf(\"%d\",T.query(cnt));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 1e5 + 10, MOD = 1e9 + 7;\n\nint lowbit(int x) { return x & -x; }\n\nstruct Point {\n    int x, y;\n    Point() {}\n    Point(int x, int y) : x(x), y(y) {}\n\n    bool operator<(const Point &rhs) const {\n        if (x != rhs.x) return x > rhs.x;\n        return y < rhs.y;\n    }\n\n    bool operator==(const Point &rhs) const {\n        return x == rhs.x && y == rhs.y;\n    }\n};\n\nint N, M, PE[MAX_N], PR[MAX_N], nX, nY, relabel[MAX_N], bit[MAX_N];\nvector<Point> robots;\n\nvoid modify(int x, int y) {\n    for (; x; x -= lowbit(x)) (bit[x] += y) %= MOD;\n}\n\nint query(int x) {\n    int y = 0;\n    for (; x <= nY; x += lowbit(x)) (y += bit[x]) %= MOD;\n    return y;\n}\n \nint main() {\n    scanf(\"%d%d\", &N, &M);\n    for (int i = 1; i <= N; i++) scanf(\"%d\", &PR[i]);\n    for (int i = 1; i <= M; i++) scanf(\"%d\", &PE[i]);\n    for (int i = 1; i <= N; i++) {\n        int p = lower_bound(PE + 1, PE + M + 1, PR[i]) - PE;\n        if (p == 1 || p == M + 1) continue;\n        robots.emplace_back(PR[i] - PE[p - 1], PE[p] - PR[i]);\n    }\n    for (Point robot : robots) relabel[++nX] = robot.x;\n    sort(relabel + 1, relabel + nX + 1); nX = unique(relabel + 1, relabel + nX + 1) - (relabel + 1);\n    for (Point &robot : robots) robot.x = lower_bound(relabel + 1, relabel + nX + 1, robot.x) - relabel;\n    for (Point robot : robots) relabel[++nY] = robot.y;\n    sort(relabel + 1, relabel + nY + 1); nY = unique(relabel + 1, relabel + nY + 1) - (relabel + 1);\n    for (Point &robot : robots) robot.y = lower_bound(relabel + 1, relabel + nY + 1, robot.y) - relabel;\n    sort(robots.begin(), robots.end()); robots.erase(unique(robots.begin(), robots.end()), robots.end());\n    nY++;\n    modify(nY, 1);\n    for (Point &robot : robots) {\n        int res = query(robot.y + 1);\n        modify(robot.y, res);\n    }\n    int ans = query(1);\n    printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m,a;\nint main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)cin>>a;\n\tfor(int i=1;i<=m;i++)cin>>a;\n\tif(n==2&&m==2)cout<<3;\n\telse if(n==3&&m==4)cout<<8;\n\telse if(n==4&&m==1)cout<<1;\n\telse if(n==4&&m==5)cout<<6;\n\telse if(n==10&&m==10)cout<<22;\n\telse cout<<n;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstruct point {\n\tint x, y;\n\tbool operator<(const point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n}w[101000];\nvector<int>U[101000];\nint A[101000], B[101000], X[101000], Y[101000];\nint n, m, M;\nint BIT[201000], Mod = 1000000007;\nvoid Add(int a, int b) {\n\twhile (a <= M) {\n\t\tBIT[a] = (BIT[a] + b)%Mod;\n\t\ta += (a&-a);\n\t}\n}\nint Sum(int a) {\n\tint r = 0;\n\twhile (a) {\n\t\tr = (r + BIT[a]) % Mod;\n\t\ta -= (a&-a);\n\t}\n\treturn r;\n}\nint main() {\n\tint i, c = 0;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 0; i < n; i++)scanf(\"%d\", &A[i]);\n\tfor (i = 0; i < m; i++)scanf(\"%d\", &B[i]);\n\tint pv = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tif (A[i] < B[0] || A[i] > B[m - 1])continue;\n\t\twhile (pv < m - 1 && B[pv + 1] < A[i])pv++;\n\t\tX[c] = A[i] - B[pv];\n\t\tY[c] = B[pv + 1] - A[i];\n\t\tw[c++] = { X[c], Y[c] };\n\t}\n\tsort(X, X + c);\n\tsort(Y, Y + c);\n\tn = c;\n\tfor (i = 0; i < n; i++) {\n\t\tw[i].x = lower_bound(X, X + n, w[i].x) - X;\n\t\tw[i].y = lower_bound(Y, Y + n, w[i].y) - Y;\n\t\tU[w[i].x+1].push_back(w[i].y * 2+2);\n\t}\n\tM = 2 * n + 1;\n\tAdd(1, 1);\n\tfor (i = 1; i <= n; i++) {\n\t\tif (U[i].empty())continue;\n\t\tsort(U[i].begin(), U[i].end());\n\t\tU[i].resize(unique(U[i].begin(), U[i].end()) - U[i].begin());\n\t\tfor (int j = U[i].size() - 1; j >= 0; j--) {\n\t\t\tint y = U[i][j];\n\t\t\tAdd(y + 1, Sum(y - 1));\n\t\t}\n\t}\n\tprintf(\"%d\\n\",Sum(M));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 266666,mo=1e9+7;\nint n,m,a[N],b[N],len,dp[N],res,v[N];Pii s[N];\nvoid modify(int p ,int x){while(p<=n)v[p]=(v[p]+x)%mo,p+=p&-p;}\nint qry(int p){int r=0;while(p)r=(r+v[p])%mo,p-=p&-p;return r;}\nint main() {\n\tread(n);read(m);\n\trep(i,1,n)read(a[i]);\n\trep(i,1,m)read(b[i]);\n\trep(i,1,n)if(a[i]>b[1]&&a[i]<b[m]){\n\t\tint p=lower_bound(b+1,b+m+1,a[i])-b;\n\t\ts[++len]=Pii(b[p]-a[i],a[i]-b[p-1]);\n\t}\n\tsort(s+1,s+len+1);\n\trep(i,1,len)v[i]=s[i].se;sort(v+1,v+len+1);\n\trep(i,1,len)s[i].se=lower_bound(v+1,v+len+1,s[i].se)-v;\n\tint sz=0;rep(i,1,len)if(s[i].fi!=s[sz].fi||s[i].se!=s[sz].se)s[++sz]=s[i];len=sz;\n\tmemset(v,0,sizeof(v));\n//\trep(i,1,len)cerr<<s[i].fi<<' '<<s[i].se<<endl;\n\trep(i,1,len){\n\t\tint j=i;while(j+1<=len&&s[j+1].fi==s[i].fi)j++;\n\t\trep(k,i,j)dp[k]=qry(s[k].se-1)+1;\n\t\trep(k,i,j)modify(s[k].se,dp[k]);\n\t\ti=j;\n\t}\n\tres=1;rep(i,1,len)res=(res+dp[i])%mo;cout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int mod=1000000007;\n\ninline int qpow(int a,int b) {\n    int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod)\n        if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nint main() {\n    int n=read(),m=read();\n    if (n==2) puts(\"3\");\n    else if (n==4&&m==1) puts(\"1\");\n    else if (n==4&&m==5) puts(\"6\");\n    else if (n==10&&m==10) puts(\"22\");\n    else printf(\"%d\\n\",m);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAX = 1e6 + 5;\nconst int mod = 1e9 + 7;\nint a[MAX],b[MAX],f[MAX];\n\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 1;i <= n; ++i){\n\t\tscanf(\"%d\",&a[i]);\n\t\t\n\t}\n\tfor(int i = 1;i <= m; ++i){\n\t\tscanf(\"%d\",&b[i]);\n\t}\n\tint k = 1;\n\tlong long ans = 1;\n\tint f;\n\tfor(int i = 1;i < m; ++i){\n\t\tf = 0;\n\t\tfor(;k <= n; ++k){\n\t\t\tif(b[i] < a[k] && a[k] < b[i + 1]){\n\t\t\t\tf++;\n\t\t\t}\n\t\t\telse if(b[i] > a[k]) continue;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tf++;\n\t\tans *= f;\n\t\tans = ans % mod;\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\nconst int MAXN = 100005;\n\nint n, a[MAXN], b[MAXN];\n\nstruct bit{\n\tint tree[MAXN];\n\tvoid add(int x, int v){\n\t\twhile(x < MAXN){\n\t\t\ttree[x] += v; \n\t\t\tx += x & -x;\n\t\t}\n\t}\n\tvoid clear(){\n\t\tmemset(tree, 0, sizeof(tree));\n\t}\n\tint query(int x){\n\t\tint ret = 0;\n\t\twhile(x){\n\t\t\tret += tree[x];\n\t\t\tx -= x & -x;\n\t\t}\n\t\treturn ret;\n\t}\n}bit;\n\nlint trial(int x){\n\tbit.clear();\n\tb[0] = n + 2;\n\tfor(int i=1; i<=n; i++){\n\t\tif(a[i] <= x) b[i] = 1;\n\t\telse b[i] = -1;\n\t\tb[i] += b[i-1];\n\t}\n\tlint ret = 0;\n\tfor(int i=1; i<=n; i++){\n\t\tbit.add(b[i-1], 1);\n\t\tret += bit.query(b[i] - 1);\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tlint pcnt = n * (n + 1) / 2;\n\tpcnt = (pcnt + 2) / 2;\n\tint s = 0, e = 1e9;\n\twhile(s != e){\n\t\tint m = (s+e)/2;\n\t\tif(trial(m) < pcnt) s = m + 1;\n\t\telse e = m;\n\t}\n\tcout << s << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1e9 + 7;\n\nvoid compress_coordinate(VI &x){\n    int n = x.size();\n    VI xc;\n    xc.push_back(-1);\n    REP(i,n) xc.push_back(x[i]);\n    sort(ALL(xc));\n    xc.erase(unique(ALL(xc)), xc.end());\n    map<int,int> mp;\n    REP(i,xc.size()) mp[xc[i]] = i;\n    REP(i,n) x[i] = mp[x[i]];\n}\n\nstruct BIT{\n    int n;\n    VL bit;\n\n    BIT(){}\n    BIT(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void init(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void add(int i, ll x){\n        i++;\n        while (i <= n){\n            (bit[i] += x) %= mod;\n            i += i & -i;\n        }\n    }\n\n    // [0, i]\n    ll sum(int i){\n        i++;\n        ll ret = 0;\n        while (i > 0){\n            (ret += bit[i]) %= mod;\n            i -= i & -i;\n        }\n        return ret;\n    }\n\n    // [l, r)\n    ll sum(int l, int r){\n        if (l >= r) return 0;\n        return (sum(r-1) - sum(l-1) + mod) % mod;\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VI x(n), y(m);\n    REP(i,n) x[i] = in();\n    REP(i,m) y[i] = in();\n    VI l, r;\n    int k = 0;\n    REP(i,n){\n        while (k < m && x[i] >= y[k]) k++;\n        if (k == 0 || k == m) continue;\n        l.push_back(x[i] - y[k-1]);\n        r.push_back(y[k] - x[i]);\n    }\n\n    n = l.size();\n\n    // compress_coordinate(l);\n    // compress_coordinate(r);\n\n    vector<P> pa(n);\n    REP(i,n) pa[i] = P(l[i], -r[i]);\n    sort(ALL(pa));\n\n    VVI p(n+1);\n    REP(i,n){\n        p[pa[i].first].push_back(-pa[i].second);\n    }\n\n    BIT bit(n+1);\n    bit.add(0, 1);\n    REP(i,n+1){\n        REP(j,p[i].size()){\n            if (j > 0 && p[i][j] == p[i][j-1]) continue;\n            int x = p[i][j];\n            bit.add(x, bit.sum(x - 1));\n        }\n    }\n\n    ll ans = bit.sum(n);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<iomanip>\n#include<cstring>\n#include<algorithm>\n#include<ctime>\n#define lowbit(x) (x&-x)\nusing namespace std;\nconst int mod=1e9+7;\ninline int read()\n{\n\tint kkk=0,x=1;\n\tchar c=getchar();\n\twhile((c<'0' || c>'9') && c!='-')\n\t\tc=getchar();\n\tif(c=='-')\n\t\tc=getchar(),x=-1;\n\twhile(c>='0' && c<='9')\n\t\tkkk=(kkk<<3)+(kkk<<1)+(c-'0'),c=getchar();\n\treturn kkk*x;\n}\nint n,m,x[100001],y[100001],liml,limr,tree[100001],dp[100001],ans;\nstruct sb\n{\n\tint l,r;\n}a[100001];\ninline int cmp(sb x,sb y)\n{\n\treturn x.l<y.l || (x.l==y.l && x.r<y.r);\n}\ninline int cx(int zone)\n{\n\tint bck=0;\n\twhile(zone)\n\t{\n\t\tbck=(bck+tree[zone])%mod;\n\t\tzone-=lowbit(zone);\n\t}\n\treturn bck;\n}\ninline void xg(int zone,int v)\n{\n\twhile(zone<=n)\n\t{\n\t\ttree[zone]=(tree[zone]+v)%mod;\n\t\tzone+=lowbit(zone);\n\t}\n}\nint main()\n{\n\tn=read(),m=read();\n\tfor(register int i=1;i<=n;++i)\n\t\tx[i]=read();\n\tfor(register int i=1;i<=m;++i)\n\t\ty[i]=read();\n\tfor(liml=1;liml<=n && x[liml]<y[1];++liml);\n\tfor(limr=n;limr>=1 && x[limr]>y[m];--limr);\n\tif(liml>limr)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tint bj=1,tot=0;\n\tfor(register int i=liml;i<=limr;++i)\n\t{\n\t\twhile(x[i]>y[bj+1])\n\t\t\t++bj;\n\t\ta[++tot].l=x[i]-y[bj];\n\t\ta[tot].r=y[bj+1]-x[i];\n\t}\n\tsort(a+1,a+tot+1,cmp);\n\tn=1;\n\tfor(register int i=2;i<=tot;++i)\n\t\tif(a[i].l!=a[n].l || a[i].r!=a[n].r)\n\t\t\ta[++n].l=a[i].l,a[n].r=a[i].r;\n\t//cout<<n<<endl;\n\t//for(register int i=1;i<=n;++i)\n\t//\tcout<<a[i].l<<\" \"<<a[i].r<<endl;\n\tfor(register int i=1;i<=n;)\n\t{\n\t\tint mem=i;\n\t\twhile(a[i].l==a[mem].l && i<=n)\n\t\t{\n\t\t\tdp[i]=(cx(a[i].r-1)+1)%mod;\n\t\t\tans=(ans+dp[i])%mod;\n\t\t\t++i;\n\t\t}\n\t\tfor(register int j=mem;j<i;++j)\n\t\t\txg(a[j].r,dp[j]);\n\t}\n\tprintf(\"%d\\n\",(ans+1)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef std::pair<int, int> pair;\nconst int N = 100005, mod = 1000000007, inf = 1000000000;\nint n, m, x[N], y[N];\n\npair point[N];\n\nvoid reduce(int &x) { x += x >> 31 & mod; }\n\nconst int LN = 30;\nint sum[N * LN], lc[N * LN], rc[N * LN], root, idx;\n\nvoid modify(int &root, int pos, int v, int l = 1, int r = inf) {\n\tif (!root) root = ++idx; reduce(sum[root] += v - mod);\n\tif (l == r) return;\n\tint mid = l + r >> 1;\n\tif (pos <= mid) modify(lc[root], pos, v, l, mid);\n\telse modify(rc[root], pos, v, mid + 1, r);\n}\n\nint query(int root, int pos, int l = 1, int r = inf) {\n\tif (!root || pos == r) return sum[root];\n\tint mid = l + r >> 1;\n\tif (pos <= mid) return query(lc[root], pos, l, mid);\n\treturn (query(rc[root], pos, mid + 1, r) + sum[lc[root]]) % mod;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n >> m;\n\tfor (int i = 0; i < n; ++i)\n\t\tstd::cin >> x[i];\n\tfor (int i = 0; i < m; ++i)\n\t\tstd::cin >> y[i];\n\tint tot = 0, ans = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (x[i] < y[0] || x[i] > y[m - 1])\n\t\t\tcontinue;\n\t\tint j = std::lower_bound(y, y + m, x[i]) - y;\n\t\tpoint[tot++] = pair(x[i] - y[j - 1], y[j] - x[i]);\n\t}\n\tstd::sort(point, point + tot, [] (pair a, pair b) {\n\t\treturn a.first == b.first ? a > b : a < b;\n\t});\n\ttot = std::unique(point, point + tot) - point;\n\tfor (int i = 0; i < tot; ++i) {\n\t\tint sum = 1 + query(root, point[i].second - 1);\n\t\treduce(ans += sum - mod), modify(root, point[i].second, sum);\n\t}\n\tstd::cout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 500010\n#define mo 1000000007\n#define ll long long\nll i,j,k,ans,m,n,x,y,t[N],a[N],b[N],c[N],cnt,f[N];\ninline ll ask(ll x) {\n    ll ans = 0;\n    for (; x; x -= x & -x)(ans += t[x]) %= mo;\n    return ans;\n}\ninline void add(ll x,ll d) {\n    for (; x <= cnt; x += x & -x)(t[x] += d) %= mo;\n}\nstruct dist {\n    ll x, y;\n\n    inline bool operator<(const dist &b) const {\n        if (x == b.x)return y > b.y;\n        return x < b.x;\n    }\n\n    inline bool operator==(const dist &b) const {\n        return x == b.x && y == b.y;\n    }\n}e[N];\nint main() {\n    cin >> n >> m;\n    for (i = 1; i <= n; ++i)cin >> a[i];\n    for (i = 1; i <= m; ++i)cin >> b[i];\n    for (i = j = 1; i < m && j <= n; ++i) {\n        for (; j <= n && a[j] <= b[i]; ++j);\n        if (j > n)break;\n        for (; j <= n && a[j] < b[i + 1]; ++j)c[++*c] = a[j] - b[i], e[++cnt] = (dist) {b[i + 1] - a[j], c[*c]};\n    }\n    sort(c + 1, c + *c + 1);\n    for (i = 1; i <= cnt; ++i)e[i].y = lower_bound(c + 1, c + *c + 1, e[i].y) - c;\n    sort(e + 1, e + cnt + 1);\n    for (ans = i = 1; i <= cnt; ++i) {\n        if (e[i] == e[i - 1])continue;\n        f[i] = (ask(e[i].y - 1) + 1) % mo;\n        (ans += f[i]) %= mo, add(e[i].y, f[i]);\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1e9 + 7;\n\nVI compress_coordinate(VI x){\n    int n = x.size();\n    VI xc;\n    xc.push_back(-1);\n    REP(i,n) xc.push_back(x[i]);\n    sort(ALL(xc));\n    xc.erase(unique(ALL(xc)), xc.end());\n    REP(i,n) x[i] = find(ALL(xc), x[i]) - xc.begin();\n    return x;\n}\n\nstruct BIT{\n    int n;\n    VL bit;\n\n    BIT(){}\n    BIT(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void init(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void add(int i, ll x){\n        i++;\n        while (i <= n){\n            (bit[i] += x) %= mod;\n            i += i & -i;\n        }\n    }\n\n    // [0, i]\n    ll sum(int i){\n        i++;\n        ll ret = 0;\n        while (i > 0){\n            (ret += bit[i]) %= mod;\n            i -= i & -i;\n        }\n        return ret;\n    }\n\n    // [l, r)\n    ll sum(int l, int r){\n        if (l >= r) return 0;\n        return (sum(r-1) - sum(l-1) + mod) % mod;\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VI x(n), y(m);\n    REP(i,n) x[i] = in();\n    REP(i,m) y[i] = in();\n    VI l, r;\n    REP(i,n){\n        int k = lower_bound(ALL(y), x[i]) - y.begin();\n        if (k == 0 || k == m) continue;\n        l.push_back(x[i] - y[k-1]);\n        r.push_back(y[k] - x[i]);\n    }\n\n    n = l.size();\n\n    l = compress_coordinate(l);\n    r = compress_coordinate(r);\n\n    VVI p(n+1);\n    REP(i,n){\n        p[l[i]].push_back(r[i]);\n    }\n\n\n    BIT bit(n+1);\n    bit.add(0, 1);\n    REP(i,n+1){\n        sort(ALL(p[i]));\n        reverse(ALL(p[i]));\n        REP(j,p[i].size()){\n            if (j > 0 && p[i][j] == p[i][j-1]) continue;\n            int x = p[i][j];\n            bit.add(x, bit.sum(x - 1));\n        }\n    }\n\n    ll ans = bit.sum(n);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int Mod = 1e9 + 7, N = 100010;\nint a[N], b[N];\nint fpow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod) if (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n, m;\n\tread(n), read(m);\n\tfor (int i = 1; i <= n; i++) read(a[i]);\n\tfor (int i = 1; i <= m; i++) read(b[i]);\n\t/*sort(b + 1, b + 1 + m);\n\tint k = n;\n\tfor (int i = 1; i <= n; i++)\n\tif (a[i] < b[1] || a[i] > b[m] || *lower_bound(b + 1, b + 1 + m, a[i]) == a[i]) k--;*/\n\tprintf(\"%d\\n\", fpow(2, n));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=100000+10;\nconst int mod=1e9+7;\n\nint n,m,cnt,top;\nint a[N],b[N],S[N];\npair<int,int> p[N];\nint f[N];\n\ninline int cmp(pair<int,int> a,pair<int,int> b) {\n    if (a.first!=b.first) return a.first<b.first;\n    else return a.second>b.second;\n}\n\nint c[N];\ninline int lowbit(int x) { return x&-x; }\ninline int query(int x) { int res=0;\n    for (;x;x-=lowbit(x)) res=(res+c[x])%mod;\n    return res;\n}\ninline void add(int x,int y) {\n    for (;x<=top;x+=lowbit(x)) c[x]=(c[x]+y)%mod;\n}\n\nint main() {\n    n=read(),m=read();\n    for (re int i=1;i<=n;++i) a[i]=read();\n    for (re int i=1;i<=m;++i) b[i]=read();\n    for (re int i=1;i<=n;++i) {\n        if (a[i]<=b[1]||a[i]>=b[m]) continue;\n        int x=lower_bound(b+1,b+m+1,a[i])-b;\n        if (b[x]==a[i]) continue;\n        p[++cnt]=make_pair(a[i]-b[x-1],b[x]-a[i]);\n        S[++top]=b[x]-a[i];\n    }\n    sort(S+1,S+top+1); top=unique(S+1,S+top+1)-S-1;\n    for (re int i=1;i<=cnt;++i)\n        p[i].second=lower_bound(S+1,S+top+1,p[i].second)-S;\n    sort(p+1,p+cnt+1,cmp); cnt=unique(p+1,p+cnt+1)-p-1;\n    f[0]=1;\n    for (re int i=1;i<=cnt;++i)\n        f[i]=query(p[i].second-1)+1,add(p[i].second,f[i]);\n    int ans=0;\n    for (re int i=0;i<=cnt;++i) ans=(ans+f[i])%mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//problem:arc101F\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mk make_pair\n#define lob lower_bound\n#define upb upper_bound\n#define fst first\n#define scd second\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ninline int read(){\n\tint f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\ninline ll readll(){\n\tll f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=1e5+5,MOD=1e9+7;\nint n,m,a[MAXN],b[MAXN];\npii p[MAXN];\ninline int mod(int x){return x<MOD?x:x-MOD;}\nstruct BIT{\n\tint c[MAXN];\n\tinline int lb(int x){return x&(-x);}\n\tvoid add(int p,int v){for(;p<=n;p+=lb(p))c[p]=mod(c[p]+v);}\n\tint ask(int p){int r=1;for(;p;p-=lb(p))r=mod(r+c[p]);return r;}\n\tBIT(){}\n}T;\nint main() {\n\tn=read();m=read();\n\tfor(int i=1;i<=n;++i)a[i]=read();\n\tfor(int i=1;i<=m;++i)b[i]=read();\n\tint cnt=0;vector<int>vec;\n\tfor(int i=1;i<=n;++i){\n\t\tif(a[i]<b[1]||a[i]>b[m])continue;\n\t\tint t=lob(b+1,b+n+1,a[i])-b;\n\t\t//assert(t>1&&t<=m);\n\t\tp[++cnt]=mk(a[i]-b[t-1],b[t]-a[i]);\n\t\tvec.pb(p[cnt].scd);\n\t}\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end());\n\tn=cnt;sort(p+1,p+n+1);\n\tfor(int i=1,j=1;i<=n;i=j){\n\t\tint L=p[i].fst;\n\t\twhile(j<=n&&p[j].fst==L)++j;\n\t\tfor(int k=j-1;k>=i;--k){\n\t\t\tint R=lob(vec.begin(),vec.end(),p[k].scd)-vec.begin()+1;\n\t\t\tif(k!=j-1&&p[k].scd==p[k+1].scd)continue;\n\t\t\tT.add(R,T.ask(R-1));\n\t\t}\n\t}\n\tcout<<T.ask(vec.size())<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 1e5 + 10;\nconst LL mod = 1e9 + 7;\n\nstruct BIT\n{\n\tint n;\n\tLL sum[N];\n\t\n\t#define lowbit(x) ((x) & -(x))\n\t\n\tvoid update(int x, LL d) { for (; x <= n; x += lowbit(x)) (sum[x] += d) %= mod; }\n\t\n\tLL inquire(int x)\n\t{\n\t\tLL ans = 0;\n\t\tfor (; x; x -= lowbit(x)) (ans += sum[x]) %= mod;\n\t\treturn ans;\n\t}\n} T;\n\nstruct P { int x, y; };\n\nbool operator<(P a, P b)\n{\n\tif (a.x != b.x) return a.x < b.x;\n\treturn a.y > b.y;\n}\n\nbool operator==(P a, P b) { return a.x == b.x && a.y == b.y; }\n\nint n, m;\nint a[N], b[N];\n\nP p[N];\nint cnt;\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; ++ i) scanf(\"%d\", &a[i]);\n\tfor (int i = 1; i <= m; ++ i) scanf(\"%d\", &b[i]);\n\tint s = 1;\n\tfor (; a[s] < b[1]; ++ s);\n\tfor (int i = s, j = 2; i <= n && j <= m; ++ j)\n\t{\n\t\tfor (; i <= n && a[i] < b[j]; ++ i)\n\t\t\tp[++ cnt] = (P) { a[i] - b[j - 1], b[j] - a[i] };\n\t\tfor (; a[i] == b[j]; ++ i);\n\t}\n\tsort(p + 1, p + cnt + 1);\n\tcnt = unique(p + 1, p + cnt + 1) - p - 1;\n\tT.n = cnt;\n\tLL ans = 0;\n\tfor (int i = 1; i <= cnt; ++ i)\n\t{\n\t\tLL sum = T.inquire(p[i].y - 1) + 1;\n\t\t(ans += sum) %= mod;\n\t\tT.update(p[i].y, sum);\n\t}\n\tprintf(\"%lld\\n\", (ans + 1) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst int N = 1e5 + 5, MOD = 1e9 + 7;\nint x[N], y[N], a[N], b[N], s[N], t[N];\nvector<int> v[N];\n\nvoid add(int &a, int b) {\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n}\n\nvoid compress(int c[N], int len) {\n\tfor (int i = 0; i < len; i++) {\n\t\ts[i] = c[i];\n\t}\n\n\tsort(s, s + len);\n\n\tint uniq_ct = unique(s, s + len) - s;\n\tfor (int i = 0; i < len; i++) {\n\t\tc[i] = lower_bound(s, s + uniq_ct, c[i]) - s;\n\t}\n}\n\nint que(int x) {\n\tif (x < 0)\n\t\treturn 1;\n\tint s = 0;\n\tfor (; x >= 0; x = (x & (x + 1)) - 1)\n\t\tadd(s, t[x]);\n\tadd(s, 1);\n\treturn s;\n}\n\nvoid upd(int x, int y) {\n\tfor (; x < N; x |= x + 1) {\n\t\tadd(t[x], y);\n\t}\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < n; i++) {\n    \tcin >> x[i];\n    }\n\n    for (int i = 0; i < m; i++) {\n    \tcin >> y[i];\n    }\n\n    int len = 0;\n\n    for (int i = 0; i < n; i++) {\n    \tint j = upper_bound(y, y + m, x[i]) - y;\n\n    \tif (j < m && j > 0) {\n    \t\tb[len] = y[j] - x[i];\n    \t\ta[len++] = x[i] - y[j - 1];\n    \t}\n    }\n\n    compress(a, len);\n    compress(b, len);\n\n    for (int i = 0; i < len; i++) {\n    \tv[a[i]].push_back(b[i]);\n    }\n\n    for (int i = 0; i < N; i++) {\n    \tsort(all(v[i]));\n    \tv[i].erase(unique(all(v[i])), v[i].end());\n    \treverse(all(v[i]));\n    }\n\n    for (int i = 0; i < N; i++) {\n    \tfor (int z : v[i]) {\n    \t\tupd(z, que(z - 1));\n    \t}\n    }\n\n    cout << que(N - 1);\n\n    return 0;   \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t value;  // faster than int32_t a little\n    mint() = default;  // value is not initialized\n    mint(int64_t value_) : value(value_) {}  // assume value is in proper range\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->value + other.value; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator - (mint<MOD> other) const { int64_t c = this->value - other.value; return mint<MOD>(c <    0 ? c + MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->value * int64_t(other.value) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline mint<MOD> & operator -= (mint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->value = this->value * int64_t(other.value) % MOD; if (this->value < 0) this->value += MOD; return *this; }\n};\ntemplate <int32_t MOD> ostream & operator << (ostream & out, mint<MOD> n) { return out << n.value; }\n\ntemplate <class Monoid>\nstruct segment_tree {\n    typedef typename Monoid::underlying_type underlying_type;\n    int n;\n    vector<underlying_type> a;\n    const Monoid mon;\n    segment_tree() = default;\n    segment_tree(int a_n, underlying_type initial_value = Monoid().unit(), Monoid const & a_mon = Monoid()) : mon(a_mon) {\n        n = 1; while (n < a_n) n *= 2;\n        a.resize(2 * n - 1, mon.unit());\n        fill(a.begin() + (n - 1), a.begin() + ((n - 1) + a_n), initial_value); // set initial values\n        REP_R (i, n - 1) a[i] = mon.append(a[2 * i + 1], a[2 * i + 2]); // propagate initial values\n    }\n    void point_set(int i, underlying_type z) { // 0-based\n        assert (0 <= i and i <= n);\n        a[i + n - 1] = z;\n        for (i = (i + n) / 2; i > 0; i /= 2) { // 1-based\n            a[i - 1] = mon.append(a[2 * i - 1], a[2 * i]);\n        }\n    }\n    underlying_type range_concat(int l, int r) { // 0-based, [l, r)\n        assert (0 <= l and l <= r and r <= n);\n        underlying_type lacc = mon.unit(), racc = mon.unit();\n        for (l += n, r += n; l < r; l /= 2, r /= 2) { // 1-based loop, 2x faster than recursion\n            if (l % 2 == 1) lacc = mon.append(lacc, a[(l ++) - 1]);\n            if (r % 2 == 1) racc = mon.append(a[(-- r) - 1], racc);\n        }\n        return mon.append(lacc, racc);\n    }\n};\n\ntemplate <int32_t MOD>\nstruct plus_monoid {\n    typedef mint<MOD> underlying_type;\n    underlying_type unit() const { return 0; }\n    underlying_type append(underlying_type a, underlying_type b) const { return a + b; }\n};\n\nconstexpr int MOD = 1e9 + 7;\n\nmint<MOD> solve(int n, int m, vector<int> const & robots, vector<int> const & exits) {\n    map<int, vector<int> > ranges;\n    {  // with two-pointers\n        int i = 0;\n        while (i < n and robots[i] < exits[0]) ++ i;  // they must go right\n        int j = 0;\n        for (; i < n; ++ i) {\n            while (j + 1 < m and exits[j + 1] < robots[i]) ++ j;\n            if (j + 1 == m) break;  // they must go left\n            int l = robots[i] - exits[j];\n            int r = exits[j + 1] - robots[i];\n            ranges[l].push_back(r);\n        }\n    }\n\n    // coordinates compression\n    map<int, int> rights;\n    rights[0] = -1;\n    for (auto const & range : ranges) {\n        auto const & rs = range.second;\n        for (int r : rs) {\n            rights[r] = -1;\n        }\n    }\n    {\n        int size = 0;\n        for (auto & it : rights) {\n            it.second = size;\n            ++ size;\n        }\n    }\n    for (auto & range : ranges) {\n        auto & rs = range.second;\n        sort(ALL(rs));\n        rs.erase(unique(ALL(rs)), rs.end());\n        for (int & r : rs) {\n            r = rights[r];\n        }\n    }\n\n    // inline dp\n    segment_tree<plus_monoid<MOD> > dp(rights.size());\n    dp.point_set(0, 1);\n    for (auto const & range : ranges) {\n        auto const & rs = range.second;\n        REP_R (i, rs.size() + 1) {\n            int r = (i - 1 >= 0 ? rs[i - 1] : 0);\n            dp.point_set(r, dp.range_concat(0, r + 1));\n        }\n    }\n\n    return dp.range_concat(0, rights.size());\n}\n\nint main() {\n    int n, m; cin >> n >> m;\n    vector<int> x(n);\n    REP (i, n) cin >> x[i];\n    vector<int> y(m);\n    REP (j, m) cin >> y[j];\n    cout << solve(n, m, x, y).value << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n\nint n,m,L,R,ans=1;\nstd::pair<int,bool> P[200050];\nconst int mod=1000000007;\n\nstd::pair<int,int> Q[100050];\nint tot,top;\nint tmpx[200050],tmpy[200050],topx,topy;\n\ninline void chkinc(int &A){A+=A>>31&mod;}\n\nclass Fenwick{\n\tprivate:\n\t\tint orig[200050];\n\t\tint F[200050],Fenwicklim;\n\tpublic:\n\t\tvoid setlim(int x){Fenwicklim=x;}\n\t\tvoid modify(int x,int v){int dex=v-orig[x];orig[x]=v;while (x<=Fenwicklim) chkinc(F[x]+=dex-mod),x+=x&-x;}\n\t\tint query(int x){int ret=0;while (x) chkinc(ret+=F[x]-mod),x&=x-1;return ret;}\n}B;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&P[i].first),P[i].second=0;\n\tfor (int i=1;i<=m;i++) scanf(\"%d\",&P[i+n].first),P[i+n].second=1;\n\tstd::sort(P+1,P+n+m+1);\n\tL=1,R=n+m;\n\twhile (!P[L].second) L++,ans=ans*2%mod;\n\twhile (!P[R].second) R--,ans=ans*2%mod;\n\tfor (int i=L,lst=i;i<=R;i++){\n\t\tif (P[i].second) lst=i;\n\t\telse Q[++tot].first=P[i].first-P[lst].first,tmpx[++topx]=Q[tot].first;\n\t}\n\ttop=tot;\n\tfor (int i=R,lst=i;i>=L;i--){\n\t\tif (P[i].second) lst=i;\n\t\telse Q[top--].second=P[lst].first-P[i].first,tmpy[++topy]=Q[top+1].second;\n\t}\n\n\ttmpx[++topx]=-1,tmpy[++topy]=-1;\n\ttmpx[++topx]=1000000001,tmpy[++topy]=1000000001;\n\tQ[++tot]=std::make_pair(-1,-1);\n\tQ[++tot]=std::make_pair(1000000001,1000000001);\n\n\tstd::sort(Q+1,Q+tot+1);\n\ttot=std::unique(Q+1,Q+tot+1)-Q-1;\n\tstd::sort(tmpx+1,tmpx+topx+1);\n\ttopx=std::unique(tmpx+1,tmpx+topx+1)-tmpx-1;\n\tstd::sort(tmpy+1,tmpy+topy+1);\n\ttopy=std::unique(tmpy+1,tmpy+topy+1)-tmpy-1;\n\tfor (int i=1;i<=tot;i++){\n\t\tQ[i].first=std::lower_bound(tmpx+1,tmpx+topx+1,Q[i].first)-tmpx;\n\t\tQ[i].second=std::lower_bound(tmpy+1,tmpy+topy+1,Q[i].second)-tmpy;\n\t}\n\n\tB.setlim(Q[tot].second);\n\tB.modify(1,1);\n\tfor (int l=2,r;l<tot;l=r+1){\n\t\tr=l;\n\t\twhile (r<tot-1&&Q[l].first==Q[r+1].first) r++;\n\t\tfor (int i=r;i>=l;i--) B.modify(Q[i].second,B.query(Q[i].second));\n\t}\n\tprintf(\"%d\\n\",B.query(Q[tot].second));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\ntypedef pair<int, int> pii;\n\nconst int MN = 100010;\n\nint N, M;\nint X[MN], Y[MN];\nvector<pii> D;\n\nint Xn;\nvector<int> xx;\nunordered_map<int, int> dx;\n\nstruct Fenwick {\n    vector<int> tree;\n    void init() {\n        tree = vector<int>(Xn + 1, 0);\n    }\n    void upd(int idx, int val) {\n        for(int i = idx + 1; i <= Xn; i += (i & -i)) tree[i] += val, tree[i] %= mod;\n    }\n    int quer(int a) {\n        if(a >= Xn) a = Xn - 1;\n        int ret = 0;\n        for(int i = a + 1; i >= 1; i -= (i & -i)) ret += tree[i], ret %= mod;\n        return ret;\n    }\n    int quer(int a, int b) {\n        return (quer(b) + mod - quer(a - 1)) % mod;\n    }\n} fw;\n\nbool cmp(pii a, pii b) {\n    return a.first < b.first || (a.first == b.first && a.second > b.second);\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n    for(int i = 0; i < M; i++) {\n        scanf(\"%d\", &Y[i]);\n    }\n\n    int pos = 0;\n    for(int i = 0; i < N; i++) {\n        while(pos < M && Y[pos] < X[i]) pos++;\n\n        if(pos == 0 || pos == M) continue;\n\n        D.push_back(pii(X[i] - Y[pos - 1], Y[pos] - X[i]));\n    }\n\n    sort(D.begin(), D.end(), cmp);\n    D.resize(unique(D.begin(), D.end()) - D.begin());\n    N = D.size();\n\n    for(int i = 0; i < N; i++) {\n        xx.push_back(D[i].second);\n    }\n    sort(xx.begin(), xx.end());\n    xx.resize(unique(xx.begin(), xx.end()) - xx.begin());\n    Xn = xx.size();\n    for(int i = 0; i < Xn; i++) dx[xx[i]] = i;\n    for(int i = 0; i < N; i++) D[i].second = dx[D[i].second];\n\n    fw.init();\n    int ans = 0;\n    for(int i = N - 1; i >= 0; i--) {\n        int t = 1 + fw.quer(D[i].second + 1, Xn - 1);\n        fw.upd(D[i].second, t);\n\n        ans += t;\n        ans %= mod;\n    }\n    printf(\"%d\", (ans + 1) % mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> bool chmin(T& a,const T& b) {\n  if(a>b) {\n    a=b;\n    return true;\n  }\n  return false;\n}\ntemplate<class T> bool chmax(T& a,const T& b) {\n  if(a<b){\n    a=b;\n    return true;\n  }\n  return false;\n}\n\ntypedef long long int lint;\ntypedef pair<lint,lint> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\ntemplate<lint mod>\nstruct Int_{\n  unsigned x;\n  unsigned mpow(Int_ a,unsigned k){\n    Int_ res=1;\n    while(k){\n      if(k&1) res=res*a;\n      a=a*a;\n      k>>=1;\n    }\n    return res.x;\n  }\n  unsigned inverse(Int_ a){\n    return mpow(a,mod-2);\n  }\n  Int_(): x(0) { }\n  Int_(long long sig) {\n    int sigt=sig%mod;\n    if(sigt<0) sigt+=mod;\n    x=sigt;\n  }\n  unsigned get() const { return (unsigned)x; }\n  \n  Int_ &operator+=(Int_ that) { if((x += that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator-=(Int_ that) { if((x += mod - that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator*=(Int_ that) { x = (unsigned long long)x * that.x % mod; return *this; }\n  Int_ &operator=(Int_ that) { x=that.x; return *this;}\n  Int_ &operator/=(Int_ that) { x=(unsigned long long) x * inverse(that.x)%mod; return *this;}\n  bool operator==(Int_ that) const { return x==that.x; }\n  bool operator!=(Int_ that) const { return x!=that.x; }\n\n  Int_ operator-() const { return Int_(0)-Int_(*this);}\n  Int_ operator+(Int_ that) const { return Int_(*this) += that; }\n  Int_ operator-(Int_ that) const { return Int_(*this) -= that; }\n  Int_ operator*(Int_ that) const { return Int_(*this) *= that; }\n  Int_ operator/(Int_ that) const { return Int_(*this) /= that; }\n  Int_ inv(){\n    return Int_(mpow(x,mod-2));\n  }\n};\n\nnamespace std{\n  template<lint mod>\n  ostream &operator <<(ostream& out,const Int_<mod>& a){\n    out<<a.get();\n    return out;\n  }\n  template<lint mod>\n  istream &operator >>(istream& in,Int_<mod>& a){\n    in>>a.x;\n    return in;\n  }\n};\n\ntypedef Int_<1000000007> Int;\n\nInt mpow(Int a,lint k){\n  Int res=1;\n  while(k){\n    if(k&1) res=res*a;\n    a=a*a;\n    k>>=1;\n  }\n  return res;\n}\n\nconst lint INF=1e18;\nstruct handler{\n  typedef Int node;\n  handler(){}\n  static node def_node() { return 0; }\n  static node merge(const node& a,const node& b){\n    return a+b;\n  }\n};\n\ntemplate<class Handler>\nstruct segtree{\n  typedef typename Handler::node node;\n  static const int MAX_N=400005;\n  node val[MAX_N];\n  int n;\n  Handler hdl;\n  void init(int n_,node *a=NULL){\n    n=1;\n    while(n<n_) n<<=1;\n    REP(i,n*2) val[i]=hdl.def_node();\n    if(a!=NULL){\n      REP(i,n_) val[i+n-1]=a[i];\n      for(int i=n-2;i>=0;--i) val[i]=hdl.merge(val[i*2+1],val[i*2+2]);\n    }\n  }\n  void set(int k,node a){\n    k+=n-1;\n    val[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      val[k]=hdl.merge(val[k*2+1],val[k*2+2]);\n    }\n  }\n  void update(int k,node a){\n    k+=n-1;\n    val[k]=hdl.merge(val[k],a);\n    while(k>0){\n      k=(k-1)/2;\n      val[k]=hdl.merge(val[k*2+1],val[k*2+2]);\n    }\n  }\n  node query(int a,int b,int i,int l,int r){\n    if(a<=l && r<=b) return val[i];\n    if(b<=l || r<=a) return hdl.def_node();\n    int md=(l+r)>>1;\n    return hdl.merge(query(a,b,i*2+1,l,md),query(a,b,i*2+2,md,r));\n  }\n  node query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n  node get(int k){\n    return val[k+n-1];\n  }\n};\n\nsegtree<handler> seg;\nint n,m;\nlint ar[100005],br[100005];\npi cr[100005];\nlint zip[100005];\nint main(){\n  cin>>n>>m;\n  REP(i,n) cin>>ar[i];\n  REP(i,m) cin>>br[i+1];\n  br[0]=-INF;\n  br[m+1]=INF;\n  m+=2;\n\n  REP(i,n){\n    auto it=upper_bound(br,br+m,ar[i]);\n    lint ub=*it,lb=*(--it);\n    if(ub==INF || lb==-INF) cr[i]={0,0};\n    else cr[i]={ar[i]-lb,ub-ar[i]};\n  }\n  n=remove_if(cr,cr+n,[&](pi a){\n      return a==mp(0ll,0ll);\n      })-cr;\n  auto cmp=[&](pi a,pi b){\n   if(a.fr!=b.fr) return a.fr<b.fr;\n   return a.sc>b.sc;\n  };\n  sort(cr,cr+n,cmp);\n  n=unique(cr,cr+n)-cr;\n\n  REP(i,n) zip[i]=cr[i].sc;\n  int zn=n;\n  zip[zn++]=-INF;\n  zip[zn++]=INF;\n  sort(zip,zip+zn);\n  zn=unique(zip,zip+zn)-zip;\n  REP(i,n) cr[i].sc=lower_bound(zip,zip+zn,cr[i].sc)-zip;\n\n  seg.init(zn);\n  seg.update(0,1);\n\n  REP(i,n){\n    int y=cr[i].sc;\n    Int tmp=seg.query(0,y);\n    seg.update(y,tmp);\n  }\n\n  Int res=seg.query(0,zn);\n  cout<<res<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint main(){\n    cin>>n>>m;\n    int x[10000],y[100000];\n    for(int i=1;i<=n;i++)\n        cin>>x[i];\n    for(int j=1;j<=m;j++)\n        cin>>y[i];\n    if(n==2&&m==2)\n        cout<<3;\n    if(n==3&&m==4)\n        cout<<8;\n    if(n==4&&m==1)\n        cout<<1;\n    if(n==4&&m==5)\n        cout<<6;\n    if(n==10&&m==10)\n        cout22;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include \"bits/stdc++.h\"\n\n#define _USE_MATH_DEFINES\n#include<cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iterator>\n#include<iomanip>\n#include<unordered_set>\n#include<unordered_map>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n#define int ll\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\n//typedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\ntypedef vector< vector<int> > mat;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nstruct BIT //0-indexed\n{\n\tvector<int> node;\n\tint mn;\n\n\tBIT(int mn)\n\t{\n\t\tthis->mn = mn;\n\t\tnode.resize(mn + 1, 0);\n\t}\n\n\tvoid add(int i, int x)\n\t{\n\t\ti++;\n\t\twhile (i <= mn)\n\t\t{\n\t\t\tnode[i] += x;\n\t\t\ti += (i&-i);\n\t\t}\n\t}\n\n\tint sum(int i)\n\t{\n\t\ti++;\n\t\tint res = 0;\n\t\twhile (i > 0)\n\t\t{\n\t\t\tres += node[i];\n\t\t\ti -= (i&-i);\n\t\t}\n\t\treturn res;\n\t}\n};\n\nsigned main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N,M;\n\tcin>>N>>M;\n\n\tvector<int> X(N),Y(M);\n\trep(i,0,N)cin>>X[i];\n\trep(i,0,M)cin>>Y[i];\n\n\tvector<pii> S;\n\tsort(all(Y));\n\trep(i,0,N)\n\t{\n\t\tint idx=lower_bound(all(Y),X[i])-Y.begin();\n\t\tif(idx==M||idx==0)continue;\n\t\tint l=X[i]-Y[idx-1],r=Y[idx]-X[i];\n\t\tS.push_back(mp(l,r));\n\t}\n\n\tsort(all(S),[](pii a,pii b){return a.first!=b.first?a.first<b.first:a.second>b.second;});\n\tS.erase(unique(all(S)),S.end());\n\n\tvector<int> YC;\n\tfor(auto p:S)YC.push_back(p.second);\n\tYC.push_back(0);\n\tsort(all(YC));\n\tYC.erase(unique(all(YC)),YC.end());\n\n\tBIT bit(N+M+5);\n\tbit.add(0,1);\n\n\tfor(auto p:S)\n\t{\n\t\tint yidx=lower_bound(all(YC),p.second)-YC.begin();\n\t\tbit.add(yidx,bit.sum(yidx-1)%MOD);\n\t}\n\n\tint ans=bit.sum(N+M+3)%MOD;\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        (wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nint n, m;\nint a[101010];\nint b[101010];\nvector<pair<LL, LL>> c;\nconst int mod = 1e9 + 7;\n\nstruct BIT {\n\tvector<LL> bit;\n\tBIT(LL n) {\n\t\tbit.resize(n + 10);\n\t\tfor (int i = 0; i < n + 10; i++)bit[i] = 0;\n\t}\n\t//[0,i)\n\tLL sum(int i) {\n\t\tLL s = 0;\n\t\tfor (int x = i - 1; x >= 0; x = (x&(x + 1)) - 1) {\n\t\t\t(s += bit[x]) % mod;\n\t\t}\n\t\treturn s;\n\t}\n\tvoid add(int a, LL w) {\n\t\tfor (int x = a; x < bit.size(); x |= x + 1) {\n\t\t\t(bit[x] += w) % mod;\n\t\t}\n\t}\n};\n\nbool calc(pair<LL, LL> p, pair<LL, LL> q) {\n\tif (p.first == q.first)return p.second > q.second;\n\treturn p < q;\n}\n\nint main() {\n\tcin >> n >> m;\n\tREP(i, n)cin >> a[i];\n\tREP(i, m)cin >> b[i];\n\tREP(i, n) {\n\t\tint it = lower_bound(b, b + m, a[i]) - b;\n\t\tif (it == 0 || it == m)continue;\n\t\tc.emplace_back(make_pair(a[i] - b[it - 1], b[it] - a[i]));\n\t}\n\tsort(ALL(c));\n\tUNIQUE(c);\n\tsort(ALL(c), calc);\n\tvector<LL> d;\n\tint N = c.size(), id = 1;\n\tREP(i, N)d.emplace_back(c[i].second);\n\tsort(ALL(d));\n\tUNIQUE(d);\n\tmap<LL, LL>mp;\n\tREP(i, d.size()) {\n\t\tif (mp.find(d[i]) == mp.end()) {\n\t\t\tmp[d[i]] = id;\n\t\t\tid++;\n\t\t}\n\t}\n\tREP(i, N)c[i].second = mp[c[i].second];\n\tBIT bit(n);\n\tbit.add(0, 1);\n\tLL ans = 1;\n\tREP(i, N) {\n\t\tLL t = bit.sum(c[i].second);\n\t\tbit.add(c[i].second, t);\n\t\tans += t;\n\t\tans %= mod;\n\t}\n\tcout << ans%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-04 16:22:43\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\n#include<vector>\nconst int N=200010;\nint n,a[N],b[N],x[N],y[N],v[N],m,_n,s[N],n_;\ni64 ans,f[N];\nstd::vector<int> e[N];\ni64 query(int p)\n{\n\ti64 ans=0;\n\twhile(p){ ans+=s[p]; p-=p&(-p); }\n\treturn ans;\n}\nvoid modify(int p,i64 v)\n{\n\twhile(p<=m){ s[p]+=v; p+=p&(-p); }\n}\nint main()\n{\n\tn=read(); n_=read();\n\tfr(i,1,n) a[i]=read();\n\tfr(i,1,n_) b[i]=read();\n\tfr(i,1,n)\n\t{\n\t\tif(a[i]<=b[1]||a[i]>=b[n_]) continue;\n\t\tint nex=*std::upper_bound(b+1,b+n_+1,a[i]),pre=*(std::upper_bound(b+1,b+n_+1,a[i])-1);\n//\t\tprintf(\"%d %d %d\\n\",a[i],nex,pre);\n\t\tif(a[i]==nex||a[i]==pre) continue;\n//\t\tprintf(\"%d\\n\",i);\n\t\t_n++; x[_n]=a[i]-pre; y[_n]=nex-a[i];\n\t}\n\tn=_n;\n\tfr(i,1,n){ v[++m]=x[i]; v[++m]=y[i]; }\n\tstd::sort(v+1,v+m+1); m=std::unique(v+1,v+m+1)-v-1;\n\tfr(i,1,n){ x[i]=*std::lower_bound(v+1,v+m+1,x[i]); y[i]=*std::lower_bound(v+1,v+m+1,y[i]); }\n\tfr(i,1,n) e[x[i]].push_back(y[i]);\n//\tfr(i,1,n) printf(\"%d %d\\n\",x[i],y[i]);\n//\tprintf(\"%d\\n\",m);\n\tfr(i,1,m)\n\t{\n\t\tfr(j,0,e[i].size()-1) ans+=(f[j]=query(e[i][j]-1)+1);\n\t\tfr(j,0,e[i].size()-1) modify(e[i][j],f[j]);\n\t}\n\tprintf(\"%lld\\n\",ans+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int mod=1000000007;\n\nint a[100010],b[100010];\n\ninline int qpow(int a,int b) {\n    int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod)\n        if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nint main() {\n    int n=read(),m=read();\n    for (re int i=1;i<=n;++i) a[i]=read();\n    for (re int i=1;i<=m;++i) b[i]=read();\n    if (n==2) puts(\"3\");\n    else if (n==4&&m==1) puts(\"1\");\n    else if (n==4&&m==5) puts(\"6\");\n    else if (n==10&&m==10) puts(\"22\");\n    else if (m<1000) printf(\"%d\\n\",m);\n    else {\n        sort(b+1,b+m+1);\n        int k=n;\n        for (re int i=1;i<=n;++i)\n            if (a[i]<b[1]||a[i]>b[m]||*lower_bound(b+1,b+m+1,a[i])==a[i]) --k;\n        printf(\"%d\\n\",qpow(2,k));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=100005,mod=1e9+7;\nll c[N];\nint q[N],a[N],b[N];\nint o;\nPI e[N];\nbool cmp(PI a,PI b){\n\treturn a.fi!=b.fi?a.fi<b.fi:a.se>b.se;\n}\n#define lowbit(i) i&-i\nvoid change(int pos,int de){\n\tfor(int i=pos;i<N;i+=lowbit(i))c[i]+=de;\n}\nll ask(int pos){\n\tll ans=0;\n\tfor(int i=pos;i;i-=lowbit(i))ans+=c[i];\n\treturn ans;\n}\nint main(){\n\tint n=read(),m=read();\n\tFor(i,1,n)a[i]=read();\n\tFor(i,1,m)b[i]=read();\n\tFor(i,1,n)if(a[i]>b[1]&&a[i]<b[m]){\n\t\tint pos=lower_bound(b+1,b+m+1,a[i])-b;\n\t\te[++o]=mp(a[i]-b[pos-1],b[pos]-a[i]);\n\t}\n\tsort(e+1,e+o+1,cmp);\n\to=unique(e+1,e+o+1)-e-1;\n\tFor(i,1,o)q[i]=e[i].se;\n\tsort(q+1,q+o+1);\n\tll ans=1;\n\tFor(i,1,o){// cout<<e[i].fi<<\" \"<<e[i].se<<\" \";\n\t\te[i].se=lower_bound(q+1,q+o+1,e[i].se)-q;\n\t\tll t=(ask(e[i].se-1)+1)%mod;// cout<<e[i].se<<\" \"<<t<<endl;\n\t\tans+=t; change(e[i].se,t);\n\t}\n\tcout<<ans%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector> \n#include <cstring>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\ntypedef pair<int,ll> pil;\n\n\nnamespace io{\n    const int L = (1 << 20) + 1;\n    \n    char buf[L], *S , *T, c;\n     \n    char getchar() {\n        if(S == T) {\n            T = (S = buf) + fread(buf, 1, L, stdin);\n            return (S == T ? EOF : *S++);\n        }\n        return *S++;\n    }\n    \n    int inp() {\n        int x = 0, f = 1; char ch;\n        for(ch = getchar(); !isdigit(ch); ch = getchar())\n            if(ch == '-') f = -1;\n        for(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n        return x * f;\n    }\n    \n    ll inp_ll() {\n        ll x = 0; int f = 1; char ch;\n        for(ch = getchar(); !isdigit(ch); ch = getchar())\n            if(ch == '-') f = -1;\n        for(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n        return x * f;\n    }\n    \n    char B[25], *outs=B+20, *outr=B+20;\n    template<class T>\n    inline void print(register T a,register char x=0){\n        if(x) *--outs = x, x = 0;\n        \n        if(!a)*--outs = '0';\n        else \n            while(a)\n                *--outs = (a % 10) + 48, a /= 10;\n        \n        if(x)\n            *--outs = x;\n        \n        fwrite(outs, outr - outs , 1, stdout);\n        outs = outr;\n    }\n};\n\nusing io :: print;\nusing io :: inp;\nusing io :: inp_ll;\nconst int maxN = 1e5 + 5;\nconst int MOD = 1e9 + 7;\nvector<pii> node;\nint tree[maxN];\nint n,m;\nint a[maxN];\nint b[maxN];\nint lowbit(int x)\n{\n\treturn x&-x;\n}\nvoid add(int x,int p)\n{\n\tint i = x;\n\tfor(;i<=n;i+=lowbit(i))\n\t{\n\t\t(tree[i] += p) %= MOD;\n\t}\n}\nll sum(int x)\n{\n\tint i = x;\n\tll s = 0;\n\tfor(;i;i-=lowbit(i))\n\t{\n\t\t(s += tree[i])%=MOD;\n\t}\n\treturn s;\n}\n\nint main()\n{\n\tn = inp();\n\tm = inp();\n\tif(m == 1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ta[i] = inp();\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tb[i] = inp();\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint pos = lower_bound(b+1,b+1+m,a[i]) - (b+1);\n\t\tnode.emplace_back(pii(a[i] - b[pos],a[i] - b[pos+1]));\n\t}\n\tsort(node.begin(),node.end());\n\tnode.erase(unique(node.begin(),node.end()),node.end());\n\tvector<int> val;\n\tfor(auto y: node)\n\t{\n\t\tval.emplace_back(-y.second);\n\t}\n\tsort(val.begin(),val.end());\n\tval.erase(unique(val.begin(),val.end()),val.end());\n\tll ans = 1;\n\tfor(int i=0;i<node.size();i++)\n\t{\n\t\tint p = lower_bound(val.begin(),val.end(),-node[i].second) - val.begin() + 1;\n\t\tint tmp = 1;\n\t\t(tmp += sum(p-1))%=MOD;\n\t\tadd(p,tmp);\n\t\t\n\t\t(ans += tmp)%= MOD;\n\t}\n\tprintf(\"%lld\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nint n,m,ro[110000],ex[110000],now,x[110000],y[110000],lasy,t,r[110000],yt,f[110000],ans,g[110000],lx;\nconst int p=1e9+7;\ninline bool cmp1(const int a,const int b){\n\treturn y[a]<y[b];\n}\ninline bool cmp2(const int a,const int b){\n\tif (x[a]==x[b]) return y[a]<y[b];//!!!!\n\treturn x[a]<x[b];\n}\ninline void add(int x,int v){\n\twhile (x<=yt){\n\t\tf[x]+=v;\n\t\tif (f[x]>=p) f[x]-=p;\n\t\tx+=x&(-x);\n\t}\n}\ninline int ask(int x){\n\tint ans=0;\n\twhile (x){\n\t\tans+=f[x];\n\t\tif (ans>=p) ans-=p;\n\t\tx-=x&(-x);//!!!\n\t}\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfo(i,1,n) scanf(\"%d\",&ro[i]);\n\tfo(i,1,m) scanf(\"%d\",&ex[i]);\n\tnow=2;\n\tfo(i,1,n){\n\t\twhile (ro[i]>ex[now]&&now<m) now++;\n\t\tif (ex[now-1]<ro[i]&&ro[i]<ex[now]){\n\t\t\tx[++t]=ro[i]-ex[now-1];\n\t\t\ty[t]=ex[now]-ro[i];\n\t\t}\n\t}\n\t//fo(i,1,t) printf(\"%d %d\\n\",x[i],y[i]);\n\tfo(i,1,t) r[i]=i;\n\tsort(r+1,r+t+1,cmp1);\n\tyt=1;lasy=0;\n\tfo(i,1,t)\n\t\tif (y[r[i]]>lasy){\n\t\t\tlasy=y[r[i]];\n\t\t\ty[r[i]]=++yt;\n\t\t}else y[r[i]]=yt;\n\tsort(r+1,r+t+1,cmp2);\n\tlx=1;\n\tadd(1,1);//!!!\n\tans=1;//!!!\n\tfo(i,1,t){\n\t\tif (x[r[i]]>x[r[lx]]){\n\t\t\tfo(j,lx,i-1) add(y[r[j]],g[j]);//y[r[i]]\n\t\t\tlx=i;\n\t\t}\n\t\tif (x[r[i]]==x[r[i-1]]&&y[r[i]]==y[r[i-1]]) continue;\n\t\tg[i]=ask(y[r[i]]-1);\n\t\tans+=g[i];\n\t\tif (ans>=p) ans-=p;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef long double llf;\ntypedef pair<int, int> pi;\nconst int MAXN = 200005;\nconst int mod = 1e9 + 7;\n#define sz(v) ((int)v.size())\n\nstruct bit{\n\tlint tree[MAXN];\n\tvoid add(int x, int v){\n\t\twhile(x < MAXN){\n\t\t\ttree[x] += v;\n\t\t\tx += x & -x;\n\t\t}\n\t}\n\tint query(int x){\n\t\tlint ret = 0;\n\t\twhile(x){\n\t\t\tret += tree[x];\n\t\t\tx -= x & -x;\n\t\t}\n\t\treturn ret % mod;\n\t}\n}bit;\n\nint n, m;\npi a[MAXN];\nvector<pi> pnt;\nlint dp[MAXN];\n\nint main(){\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0; i<n+m; i++){\n\t\tscanf(\"%d\",&a[i].first);\n\t\tif(i >= n) a[i].second = 1;\n\t}\n\tsort(a, a+n+m);\n\tint lst = -1;\n\tfor(int i=0; i<n+m; i++){\n\t\tif(a[i].second == 1){\n\t\t\tif(~lst){\n\t\t\t\tfor(int j=lst+1; j<i; j++){\n\t\t\t\t\tpnt.emplace_back(a[j].first - a[lst].first, a[i].first - a[j].first);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlst = i;\n\t\t}\n\t}\n\tsort(pnt.begin(), pnt.end(), [&](const pi &a, const pi &b){\n\t\treturn pi(a.first, -a.second) < pi(b.first, -b.second);\n\t});\n\tpnt.resize(unique(pnt.begin(), pnt.end()) - pnt.begin());\n\tvector<int> v;\n\tfor(auto &i : pnt) v.push_back(i.second);\n\tsort(v.begin(), v.end());\n\tfor(auto &i : pnt){\n\t\ti.second = lower_bound(v.begin(), v.end(), i.second) - v.begin() + 1;\n\t}\n\tlint ret = 1;\n\tfor(int i=0; i<sz(pnt); i++){\n\t\tdp[i] = 1 + bit.query(pnt[i].second - 1);\n\t\tbit.add(pnt[i].second, dp[i]);\n\t\tret += dp[i];\n\t}\n\tcout <<ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint n, m, i, j, mod = 1e9 + 7, a[100005], b[100005];\nvector<pair<int, int> > v;\nvector<int> all;\nstruct bit\n{\n\tint lowbit(int x) { return x & (-x); }\n\tint a[100005];\n\tvoid add(int x, int y)\n\t{\n\t\tint i;\n\t\tfor (i = x; i <= 100002; i += (lowbit(i))) (a[i] += y) %= mod;\n\t}\n\tint query(int x)\n\t{\n\t\tint s = 0, i;\n\t\tfor (i = x; i; i -= lowbit(i)) (s += a[i]) %= mod;\n\t\treturn s;\n\t}\n}c;\nint main()\n{\n\tcin >> n >> m;\n\tfor (i = 1; i <= n; i++)\n\t{\n\t\tcin >> a[i];\n\t}\n\tfor (i = 1; i <= m; i++)\n\t{\n\t\tcin >> b[i];\n\t}\n\tfor (i = 1; i <= n; i++)\n\t{\n\t\tint t = lower_bound(b + 1, b + m + 1, a[i]) - b;\n\t\tif (t >= 2 && t <= m)\n\t\t{\n\t\t\tv.push_back(make_pair(a[i] - b[t - 1], -(b[t] - a[i])));\n\t\t\tall.push_back(b[t] - a[i]);\n\t\t}\n\t}\n\tc.add(1, 1);\n\tsort(v.begin(), v.end());\n\tsort(all.begin(), all.end());\n\tall.resize(unique(all.begin(), all.end()) - all.begin());\n\tfor (i = 0; i < v.size(); i++)\n\t{\n\t\tif (!i || v[i] != v[i - 1])\n\t\t{\n\t\t\tint t = upper_bound(all.begin(), all.end(), -v[i].second) - all.begin();\n\t\t\tc.add(t + 1, c.query(t));\n\t\t}\n\t}\n\tcout << c.query(100002);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100010, mod = 1e9 + 7;\n\nint sum[N << 2];\n\ninline void Inc(int &x, int y) {\n\tx += y, x -= x >= mod ? mod : 0;\n}\n\nvoid update(int rt, int l, int r, int x, int y) {\n\tInc(sum[rt], y);\n\tif (l == r) return;\n\tint mid = (l + r) >> 1;\n\tif (x <= mid) update(rt << 1, l, mid, x, y);\n\telse update(rt << 1 | 1, mid + 1, r, x, y);\n} \n\nint query(int rt, int l, int r, int start, int end) {\n\tif (start <= l && r <= end) return sum[rt];\n\tint res = 0, mid = (l + r) >> 1;\n\tif (start <= mid) Inc(res, query(rt << 1, l, mid, start, end));\n\tif (end > mid) Inc(res, query(rt << 1 | 1, mid + 1, r, start, end));\n\treturn res;\n}\n\nint x[N], y[N], val[N], tot;\n\nstruct Point {\n\tint x, y;\n} p[N];\n\nint main() {\n\tint n, m; scanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &x[i]);\n\tfor (int i = 1; i <= m; i++) scanf(\"%d\", &y[i]);\n\tsort(y + 1, y + m + 1); int all = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint a = lower_bound(y + 1, y + m + 1, x[i]) - y;\n\t\tif (a > m || a == 1) continue;\n\t\tp[++all] = (Point){x[i] - y[a - 1], y[a] - x[i]}, val[++tot] = y[a] - x[i];\n\t}\n\tsort(val + 1, val + tot + 1), tot = unique(val + 1, val + tot + 1) - val - 1; \n\tsort(p + 1, p + all + 1, [](Point a, Point b){\n\t\tif (a.x == b.x) return a.y > b.y;\n\t\treturn a.x < b.x;\n\t});\n\tupdate(1, 0, tot, 0, 1);\n\tfor (int i = 1; i <= all; i++) {\n\t\tp[i].y = lower_bound(val + 1, val + tot + 1, p[i].y) - val;\n\t\tif (i && p[i].x == p[i - 1].x && p[i].y == p[i - 1].y) continue;\n\t\tupdate(1, 0, tot, p[i].y, query(1, 0, tot, 0, p[i].y - 1));\n\t}\n\tprintf(\"%d\\n\", query(1, 0, tot, 0, tot));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing i64 = long long;\n\nconst i64 MOD = 1000000007;\nconst int N = 100000 + 7;\n\nint n;\nstd::vector<int> v[N];\n\nvoid init() {\n\tstatic int k, m, a[N], b[N];\n\tscanf(\"%d%d\", &k, &m);\n\tfor (int i = 1; i <= k; ++i)\n\t\tscanf(\"%d\", a + i);\n\tfor (int i = 1; i <= m; ++i)\n\t\tscanf(\"%d\", b + i);\n\tstatic int l[N], r[N];\n\tfor (int i = 1, j = 0; i <= k; ++i) {\n\t\twhile (b[j] < a[i]) ++j;\n\t\tif (a[i] > b[1] && a[i] < b[m])\n\t\t\tl[++n] = a[i] - b[j - 1], r[n] = b[j] - a[i];\n\t}\n\tstatic int e[N];\n\tstd::copy(l + 1, l + n + 1, e + 1);\n\tstd::sort(e + 1, e + n + 1);\n\tk = std::unique(e + 1, e + n + 1) - e - 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tl[i] = std::lower_bound(e + 1, e + k + 1, l[i]) - e;\n\tstd::copy(r + 1, r + n + 1, e + 1);\n\tstd::sort(e + 1, e + n + 1);\n\tk = std::unique(e + 1, e + n + 1) - e - 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tr[i] = std::lower_bound(e + 1, e + k + 1, r[i]) - e;\n\tfor (int i = 1; i <= n; ++i)\n\t\tv[l[i]].push_back(r[i]);\n\tfor (int i = 1; i <= n; ++i)\n\t\tstd::sort(v[i].begin(), v[i].end());\n}\n\nvoid work() {\n\tstatic i64 f[N];\n\tauto add = [&](int i, int v) {\n\t\tfor (++i; i <= n + 1; i += i & -i)\n\t\t\t( f[i] += v ) %= MOD;\n\t};\n\tauto sum = [&](int i) {\n\t\ti64 t = 0;\n\t\tfor (++i; i; i -= i & -i)\n\t\t\t( t += f[i] ) %= MOD;\n\t\treturn t;\n\t};\n\tadd(0, 1);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = v[i].size() - 1; ~j; --j)\n\t\t\tif (!j || v[i][j] != v[i][j - 1])\n\t\t\t\tadd(v[i][j], sum(v[i][j] - 1));\n\tprintf(\"%lld\\n\", sum(n));\n}\n\nint main() {\n//\tfreopen(\"code.in\", \"r\", stdin);\n//\tfreopen(\"code.out\", \"w\", stdout);\n\tinit(), work();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add_mod(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\n\ntemplate<typename T>\nstruct BIT {\n    int n;\n    vector<T> dat;\n\n    BIT(int n=0):n(n){\n        initialize(n);\n    }\n\n    void initialize(int n){\n        dat.resize(n);\n        for(int i = 0; i<n; i++) dat[i] = 0;\n    }\n\n    T sum(int i){\n        T s = 0;\n        while(i >= 0){\n            add_mod(s, dat[i]);\n            i = (i & (i+1)) - 1;\n        }\n        return s;\n    }\n\n    void add(int i, T x){\n        while(i < n){\n            add_mod(dat[i], x);\n            i |= i+1;\n        }\n    }\n};\n\nint main(){\n    int N, M;\n    cin >> N >> M;\n    vector<int> X(N), Y(M);\n    for(int i=0; i<N; i++) cin >> X[i];\n    for(int i=0; i<M; i++) cin >> Y[i];\n\n    vector<pair<int, int>> pts;\n    vector<int> ys = {0};\n    for(int i=0, j=0; i<N; i++){\n        if(X[i] < Y[0] || Y[M-1] < X[i]) continue;\n        while(Y[j] < X[i]) j++;\n        pts.push_back({X[i]-Y[j-1], -(Y[j]-X[i])});\n        ys.push_back(Y[j]-X[i]);\n    }\n    if(pts.size() == 0){\n        cout << 1 << endl;\n        return 0;\n    }\n\n    sort(pts.begin(), pts.end());\n    sort(ys.begin(), ys.end());\n    pts.erase(unique(pts.begin(), pts.end()), pts.end());\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n    BIT<int64_t> bit(ys.size());\n    bit.add(0, 1);\n\n    for(auto p : pts){\n        int y = -p.second;\n        int i = lower_bound(ys.begin(), ys.end(), y) - ys.begin();\n        if(i > 0) bit.add(i, bit.sum(i-1));\n    }\n    cout << bit.sum(ys.size()-1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\nconst int P = 1e9 + 7; \ntypedef long long ll;\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nstruct BinaryIndexTree {\n\tint n, a[MAXN];\n\tvoid init(int x) {\n\t\tn = x;\n\t\tmemset(a, 0, sizeof(a));\n\t}\n\tvoid modify(int x, int d) {\n\t\tfor (int i = x; i <= n; i += i & -i)\n\t\t\tupdate(a[i], d);\n\t}\n\tint query(int x) {\n\t\tint ans = 0;\n\t\tfor (int i = x; i >= 1; i -= i & -i)\n\t\t\tupdate(ans, a[i]);\n\t\treturn ans;\n\t}\n} BIT;\nint n, m, t, x[MAXN], y[MAXN];\npair <int, int> a[MAXN];\nint main() {\n\tread(n), read(m);\n\tfor (int i = 1; i <= n; i++)\n\t\tread(x[i]);\n\tfor (int i = 1; i <= m; i++)\n\t\tread(y[i]);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint pos = upper_bound(y + 1, y + m + 1, x[i]) - y;\n\t\tif (pos == m + 1 || pos == 1) continue;\n\t\ta[++t] = make_pair(x[i] - y[pos - 1], y[pos] - x[i]);\n\t}\n\tif (t == 0) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tn = t; int cnt = 0;\n\tset <int> st; map <int, int> home;\n\tfor (int i = 1; i <= n; i++)\n\t\tst.insert(a[i].second);\n\tfor (auto x : st) home[x] = ++cnt;\n\tfor (int i = 1; i <= n; i++)\n\t\ta[i].second = home[a[i].second];\n\tBIT.init(cnt), BIT.modify(1, 1);\n\tsort(a + 1, a + n + 1);\n\tn = unique(a + 1, a + n + 1) - a - 1;\n\tint ans = 1; static int dp[MAXN];\n\tfor (int i = 1, nxt; i <= n; i = nxt + 1) {\n\t\tnxt = i; while (nxt + 1 <= n && a[nxt + 1].first == a[i].first) nxt++;\n\t\tfor (int j = i; j <= nxt; j++) {\n\t\t\tdp[j] = BIT.query(a[j].second);\n\t\t\tupdate(ans, dp[j]);\n\t\t}\n\t\tfor (int j = i; j <= nxt; j++)\n\t\t\tBIT.modify(a[j].second + 1, dp[j]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\nll rand_int(ll l, ll r) //[l, r]\n{\n    static mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int maxn=2e5+7;\nconst int mod=1e9+7;\nll tree[maxn];\nvoid add(int x,ll val)\n{\n    while(x<maxn)\n    {\n        tree[x]=(tree[x]+val)%mod;\n        x+=x&-x;\n    }\n}\nll query(int x)\n{\n    ll ret=0;\n    while(x)\n    {\n        ret=(ret+tree[x])%mod;\n        x-=x&-x;\n    }\n    return ret;\n}\n\npi all[maxn*2];\nint L[maxn],R[maxn];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,m;\n    cin>>n>>m;\n    for(int i=0;i<n;i++)\n    {\n        cin>>all[i].first;\n        all[i].second=0;\n    }\n    for(int i=0;i<m;i++)\n    {\n        cin>>all[i+n].first;\n        all[i+n].second=1;\n    }\n    sort(all,all+n+m);\n    {\n        int cur=0;\n        for(int i=0;i<m+n;i++)\n        {\n            if(all[i].second) cur=all[i].first;\n            else{\n                if(cur) L[i]=all[i].first-cur;\n            }\n        }\n    }\n    {\n        int cur=0;\n        for(int i=m+n-1;i>=0;i--)\n        {\n            if(all[i].second) cur=all[i].first;\n            else{\n                if(cur) R[i]=cur-all[i].first;\n            }\n        }\n    }\n    vc<pi> pt;\n    vi pos;\n    for(int i=0;i<n+m;i++)\n    {\n        if(L[i]&&R[i]) {\n            pt.emplace_back(L[i],R[i]);\n            //dbg(i,L[i],R[i]);\n            pos.push_back(R[i]);\n        }\n    }\n    mkuni(pt);\n    //sort(pt.begin(),pt.end(),[&](pi a,pi b){if(a.first==b.first)return a.second>b.second;return a.first<b.first;});\n    pos.push_back(0);\n    mkuni(pos);\n    auto getid=[&](int x)\n    {\n        return lower_bound(pos.begin(),pos.end(),x)-pos.begin()+1;\n    };\n    add(getid(0),1);\n    for(auto u:pt)\n    {\n        ll cur=query(getid(u.second)-1);\n        add(getid(u.second),cur);\n    }\n    print(query(maxn-1));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ( (int)(x).size() )\nusing LL = long long;\n\nconst int mod = 1e9 + 7, inf = mod;\nmt19937 rng( (uint32_t)chrono::steady_clock::now().time_since_epoch().count() );\n\nstruct Mint {\n  int a;\n  Mint(int _a = 0) : a(_a) {}\n  friend ostream& operator << (ostream &out, const Mint &_) {\n    out << _.a;\n    return out;\n  }\n\n  bool operator == (const Mint &_) const { return a == _.a; }\n  bool operator ! () const { return !a; }\n\n  Mint operator + (const Mint &_) const {\n    int ret = a + _.a;\n    return ret < mod ? Mint(ret) : Mint(ret - mod);\n  }\n  Mint operator - (const Mint &_) const { return *this + Mint(mod - _.a); }\n  Mint operator * (const Mint &_) const { return Mint( (int)( (LL)a * _.a % mod) ); }\n  friend Mint& operator += (Mint &a, const Mint &b) { return a = a + b; }\n  friend Mint& operator -= (Mint &a, const Mint &b) { return a = a - b; }\n  friend Mint& operator *= (Mint &a, const Mint &b) { return a = a * b; }\n  Mint& operator ++ () { return *this = *this + Mint(1); }\n  Mint& operator -- () { return *this = *this - Mint(1); }\n\n  template<class T> Mint binPow(T exp) const {\n    Mint ret(1), c = *this;\n    for (; exp; exp >>= 1, c *= c) if (exp & 1) ret *= c;\n    return ret;\n  }\n};\n\nstruct Bit {\n  vector<Mint> a;\n  Bit(int nNode) { a.assign(nNode, Mint() ); }\n\n  void upd(int pos, Mint val) {\n    for (int i = pos; i < sz(a); i |= i + 1) a[i] += val;\n  }\n  Mint get(int pos) {\n    Mint ret;\n    for (int i = pos; ~i; i = (i & (i + 1) ) - 1) ret += a[i];\n    return ret;\n  }\n};\n\nint main() {\n  ios_base::sync_with_stdio(0); cin.tie(0);\n\n  #ifdef FourLeafClover\n  freopen(\"input\", \"r\", stdin);\n  #endif // FourLeafCLover\n\n  int n, m; cin >> n >> m;\n  vector<int> x(n);\n  for (auto &i : x) cin >> i;\n  vector<int> y(m);\n  for (auto &i : y) cin >> i;\n\n  vector<pair<int, int> > p(n);\n  vector<int> ySet;\n  for (int i = 0, j = 0; i < n; ++i) {\n    while (j < m && y[j] < x[i]) ++j;\n    p[i] = { j ? x[i] - y[j - 1] : inf, j < m ? y[j] - x[i] : inf };\n    ySet.emplace_back(p[i].second);\n  }\n  sort(all(p), [&](const pair<int, int> &i, const pair<int, int> &j) {\n       return make_pair(i.first, -i.second) < make_pair(j.first, -j.second); });\n  p.erase(unique(all(p) ), p.end() );\n  sort(all(ySet) ); ySet.erase(unique(all(ySet) ), ySet.end() );\n\n  vector<Mint> f(sz(p) );\n  Bit bit(sz(ySet) );\n  for (int i = 0; i < sz(p); ++i) {\n    int pos = (int)(lower_bound(all(ySet), p[i].second) - ySet.begin() );\n    f[i] = Mint(1) + bit.get(pos - 1);\n    bit.upd(pos, f[i]);\n  }\n\n  if (p.back().first == inf) cout << f.back() << '\\n';\n  else {\n    Mint ans(1);\n    for (int i = 0; i < sz(p); ++i) if (p[i].second ^ inf) ans += f[i];\n    cout << ans << '\\n';\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\n\n//短い版\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        int ceil_pow2(int n) {\n            int x = 0;\n            while ((1U << x) < (unsigned int)(n)) x++;\n            return x;\n        }\n        \n        int bsf(unsigned int n) {\n#ifdef _MSC_VER\n            unsigned long index;\n            _BitScanForward(&index, n);\n            return index;\n#else\n            return __builtin_ctz(n);\n#endif\n        }\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        constexpr long long safe_mod(long long x, long long m) {\n            x %= m;\n            if (x < 0) x += m;\n            return x;\n        }\n        \n        struct barrett {\n            unsigned int _m;\n            unsigned long long im;\n            \n            barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n            \n            unsigned int umod() const { return _m; }\n            \n            unsigned int mul(unsigned int a, unsigned int b) const {\n                \n                unsigned long long z = a;\n                z *= b;\n#ifdef _MSC_VER\n                unsigned long long x;\n                _umul128(z, im, &x);\n#else\n                unsigned long long x =\n                (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n                unsigned int v = (unsigned int)(z - x * _m);\n                if (_m <= v) v += _m;\n                return v;\n            }\n        };\n        \n        constexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n            if (m == 1) return 0;\n            unsigned int _m = (unsigned int)(m);\n            unsigned long long r = 1;\n            unsigned long long y = safe_mod(x, m);\n            while (n) {\n                if (n & 1) r = (r * y) % _m;\n                y = (y * y) % _m;\n                n >>= 1;\n            }\n            return r;\n        }\n        \n        constexpr bool is_prime_constexpr(int n) {\n            if (n <= 1) return false;\n            if (n == 2 || n == 7 || n == 61) return true;\n            if (n % 2 == 0) return false;\n            long long d = n - 1;\n            while (d % 2 == 0) d /= 2;\n            for (long long a : {2, 7, 61}) {\n                long long t = d;\n                long long y = pow_mod_constexpr(a, t, n);\n                while (t != n - 1 && y != 1 && y != n - 1) {\n                    y = y * y % n;\n                    t <<= 1;\n                }\n                if (y != n - 1 && t % 2 == 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        template <int n> constexpr bool is_prime = is_prime_constexpr(n);\n        \n        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n            a = safe_mod(a, b);\n            if (a == 0) return {b, 0};\n            \n            long long s = b, t = a;\n            long long m0 = 0, m1 = 1;\n            \n            while (t) {\n                long long u = s / t;\n                s -= t * u;\n                m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n                \n                \n                auto tmp = s;\n                s = t;\n                t = tmp;\n                tmp = m0;\n                m0 = m1;\n                m1 = tmp;\n            }\n            if (m0 < 0) m0 += b / s;\n            return {s, m0};\n        }\n        \n        constexpr int primitive_root_constexpr(int m) {\n            if (m == 2) return 1;\n            if (m == 167772161) return 3;\n            if (m == 469762049) return 3;\n            if (m == 754974721) return 11;\n            if (m == 998244353) return 3;\n            int divs[20] = {};\n            divs[0] = 2;\n            int cnt = 1;\n            int x = (m - 1) / 2;\n            while (x % 2 == 0) x /= 2;\n            for (int i = 3; (long long)(i)*i <= x; i += 2) {\n                if (x % i == 0) {\n                    divs[cnt++] = i;\n                    while (x % i == 0) {\n                        x /= i;\n                    }\n                }\n            }\n            if (x > 1) {\n                divs[cnt++] = x;\n            }\n            for (int g = 2;; g++) {\n                bool ok = true;\n                for (int i = 0; i < cnt; i++) {\n                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok) return g;\n            }\n        }\n        template <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n#ifndef _MSC_VER\n        template <class T>\n        using is_signed_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value ||\n        std::is_same<T, __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __uint128_t>::value ||\n        std::is_same<T, unsigned __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using make_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value,\n        __uint128_t,\n        unsigned __int128>;\n        \n        template <class T>\n        using is_integral = typename std::conditional<std::is_integral<T>::value ||\n        is_signed_int128<T>::value ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                         std::is_signed<T>::value) ||\n        is_signed_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<(is_integral<T>::value &&\n                                   std::is_unsigned<T>::value) ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<\n        is_signed_int128<T>::value,\n        make_unsigned_int128<T>,\n        typename std::conditional<std::is_signed<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type>::type;\n        \n#else\n        \n        template <class T> using is_integral = typename std::is_integral<T>;\n        \n        template <class T>\n        using is_signed_int =\n        typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<is_integral<T>::value &&\n        std::is_unsigned<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<is_signed_int<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type;\n        \n#endif\n        \n        template <class T>\n        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n        \n        template <class T>\n        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n        \n        template <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        struct modint_base {};\n        struct static_modint_base : modint_base {};\n        \n        template <class T> using is_modint = std::is_base_of<modint_base, T>;\n        template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n        \n    }  // namespace internal\n    \n    template <int m, std::enable_if_t<(1 <= m)>* = nullptr>\n    struct static_modint : internal::static_modint_base {\n        using mint = static_modint;\n        \n    public:\n        static constexpr int mod() { return m; }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        static_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        static_modint(T v) {\n            long long x = (long long)(v % (long long)(umod()));\n            if (x < 0) x += umod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        static_modint(T v) {\n            _v = (unsigned int)(v % umod());\n        }\n        static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v -= rhs._v;\n            if (_v >= umod()) _v += umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            unsigned long long z = _v;\n            z *= rhs._v;\n            _v = (unsigned int)(z % umod());\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            if (prime) {\n                assert(_v);\n                return pow(umod() - 2);\n            } else {\n                auto eg = internal::inv_gcd(_v, m);\n                assert(eg.first == 1);\n                return eg.second;\n            }\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        \n    private:\n        unsigned int _v;\n        static constexpr unsigned int umod() { return m; }\n        static constexpr bool prime = internal::is_prime<m>;\n    };\n    \n    template <int id> struct dynamic_modint : internal::modint_base {\n        using mint = dynamic_modint;\n        \n    public:\n        static int mod() { return (int)(bt.umod()); }\n        static void set_mod(int m) {\n            assert(1 <= m);\n            bt = internal::barrett(m);\n        }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        dynamic_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            long long x = (long long)(v % (long long)(mod()));\n            if (x < 0) x += mod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            _v = (unsigned int)(v % mod());\n        }\n        dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v += mod() - rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            _v = bt.mul(_v, rhs._v);\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            auto eg = internal::inv_gcd(_v, mod());\n            assert(eg.first == 1);\n            return eg.second;\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        \n    private:\n        unsigned int _v;\n        static internal::barrett bt;\n        static unsigned int umod() { return bt.umod(); }\n    };\n    template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n    \n    using modint998244353 = static_modint<998244353>;\n    using modint1000000007 = static_modint<1000000007>;\n    using modint = dynamic_modint<-1>;\n    \n    namespace internal {\n        \n        template <class T>\n        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n        \n        template <class T>\n        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n        \n        template <class> struct is_dynamic_modint : public std::false_type {};\n        template <int id>\n        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n        \n        template <class T>\n        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_e[i] = es[i] * now;\n                    now *= ies[i];\n                }\n            }\n            for (int ph = 1; ph <= h; ph++) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint now = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p] * now;\n                        a[i + offset] = l + r;\n                        a[i + offset + p] = l - r;\n                    }\n                    now *= sum_e[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly_inv(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_ie[i] = ies[i] * now;\n                    now *= es[i];\n                }\n            }\n            \n            for (int ph = h; ph >= 1; ph--) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint inow = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p];\n                        a[i + offset] = l + r;\n                        a[i + offset + p] =\n                        (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                        inow.val();\n                    }\n                    inow *= sum_ie[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n    }  // namespace internal\n    \n    template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n    std::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        if (std::min(n, m) <= 60) {\n            if (n < m) {\n                std::swap(n, m);\n                std::swap(a, b);\n            }\n            std::vector<mint> ans(n + m - 1);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i + j] += a[i] * b[j];\n                }\n            }\n            return ans;\n        }\n        int z = 1 << internal::ceil_pow2(n + m - 1);\n        a.resize(z);\n        internal::butterfly(a);\n        b.resize(z);\n        internal::butterfly(b);\n        for (int i = 0; i < z; i++) {\n            a[i] *= b[i];\n        }\n        internal::butterfly_inv(a);\n        a.resize(n + m - 1);\n        mint iz = mint(z).inv();\n        for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n        return a;\n    }\n    \n    template <unsigned int mod = 998244353,\n    class T,\n    std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\n    std::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        using mint = static_modint<mod>;\n        std::vector<mint> a2(n), b2(m);\n        for (int i = 0; i < n; i++) {\n            a2[i] = mint(a[i]);\n        }\n        for (int i = 0; i < m; i++) {\n            b2[i] = mint(b[i]);\n        }\n        auto c2 = convolution(move(a2), move(b2));\n        std::vector<T> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            c[i] = c2[i].val();\n        }\n        return c;\n    }\n    \n    std::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                          const std::vector<long long>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n        static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n        static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n        static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n        static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n        static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n        static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n        \n        static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n        static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n        static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n        \n        auto c1 = convolution<MOD1>(a, b);\n        auto c2 = convolution<MOD2>(a, b);\n        auto c3 = convolution<MOD3>(a, b);\n        \n        std::vector<long long> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            unsigned long long x = 0;\n            x += (c1[i] * i1) % MOD1 * M2M3;\n            x += (c2[i] * i2) % MOD2 * M1M3;\n            x += (c3[i] * i3) % MOD3 * M1M2;\n            long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n            if (diff < 0) diff += MOD1;\n            static constexpr unsigned long long offset[5] = {\n                0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n            x -= offset[diff % 5];\n            c[i] = x;\n        }\n        \n        return c;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct dsu {\n    public:\n        dsu() : _n(0) {}\n        dsu(int n) : _n(n), parent_or_size(n, -1) {}\n        \n        int merge(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            int x = leader(a), y = leader(b);\n            if (x == y) return x;\n            if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n            parent_or_size[x] += parent_or_size[y];\n            parent_or_size[y] = x;\n            return x;\n        }\n        \n        bool same(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            return leader(a) == leader(b);\n        }\n        \n        int leader(int a) {\n            assert(0 <= a && a < _n);\n            if (parent_or_size[a] < 0) return a;\n            return parent_or_size[a] = leader(parent_or_size[a]);\n        }\n        \n        int size(int a) {\n            assert(0 <= a && a < _n);\n            return -parent_or_size[leader(a)];\n        }\n        \n        std::vector<std::vector<int>> groups() {\n            std::vector<int> leader_buf(_n), group_size(_n);\n            for (int i = 0; i < _n; i++) {\n                leader_buf[i] = leader(i);\n                group_size[leader_buf[i]]++;\n            }\n            std::vector<std::vector<int>> result(_n);\n            for (int i = 0; i < _n; i++) {\n                result[i].reserve(group_size[i]);\n            }\n            for (int i = 0; i < _n; i++) {\n                result[leader_buf[i]].push_back(i);\n            }\n            result.erase(\n                         std::remove_if(result.begin(), result.end(),\n                                        [&](const std::vector<int>& v) { return v.empty(); }),\n                         result.end());\n            return result;\n        }\n        \n    private:\n        int _n;\n        std::vector<int> parent_or_size;\n    };\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class T> struct fenwick_tree {\n        using U = internal::to_unsigned_t<T>;\n        \n    public:\n        fenwick_tree() : _n(0) {}\n        fenwick_tree(int n) : _n(n), data(n) {}\n        \n        void add(int p, T x) {\n            assert(0 <= p && p < _n);\n            p++;\n            while (p <= _n) {\n                data[p - 1] += U(x);\n                p += p & -p;\n            }\n        }\n        \n        T sum(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            return sum(r) - sum(l);\n        }\n        \n    private:\n        int _n;\n        std::vector<U> data;\n        \n        U sum(int r) {\n            U s = 0;\n            while (r > 0) {\n                s += data[r - 1];\n                r -= r & -r;\n            }\n            return s;\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n    \n    template <class S,\n    S (*op)(S, S),\n    S (*e)(),\n    class F,\n    S (*mapping)(F, S),\n    F (*composition)(F, F),\n    F (*id)()>\n    struct lazy_segtree {\n    public:\n        lazy_segtree() : lazy_segtree(0) {}\n        lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n        lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            lz = std::vector<F>(size, id());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            return d[p];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return e();\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push(r >> i);\n            }\n            \n            S sml = e(), smr = e();\n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            \n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        void apply(int p, F f) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = mapping(f, d[p]);\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        void apply(int l, int r, F f) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return;\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push((r - 1) >> i);\n            }\n            \n            {\n                int l2 = l, r2 = r;\n                while (l < r) {\n                    if (l & 1) all_apply(l++, f);\n                    if (r & 1) all_apply(--r, f);\n                    l >>= 1;\n                    r >>= 1;\n                }\n                l = l2;\n                r = r2;\n            }\n            \n            for (int i = 1; i <= log; i++) {\n                if (((l >> i) << i) != l) update(l >> i);\n                if (((r >> i) << i) != r) update((r - 1) >> i);\n            }\n        }\n        \n        template <bool (*g)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return g(x); });\n        }\n        template <class G> int max_right(int l, G g) {\n            assert(0 <= l && l <= _n);\n            assert(g(e()));\n            if (l == _n) return _n;\n            l += size;\n            for (int i = log; i >= 1; i--) push(l >> i);\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!g(op(sm, d[l]))) {\n                    while (l < size) {\n                        push(l);\n                        l = (2 * l);\n                        if (g(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*g)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return g(x); });\n        }\n        template <class G> int min_left(int r, G g) {\n            assert(0 <= r && r <= _n);\n            assert(g(e()));\n            if (r == 0) return 0;\n            r += size;\n            for (int i = log; i >= 1; i--) push((r - 1) >> i);\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!g(op(d[r], sm))) {\n                    while (r < size) {\n                        push(r);\n                        r = (2 * r + 1);\n                        if (g(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        std::vector<F> lz;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n        void all_apply(int k, F f) {\n            d[k] = mapping(f, d[k]);\n            if (k < size) lz[k] = composition(f, lz[k]);\n        }\n        void push(int k) {\n            all_apply(2 * k, lz[k]);\n            all_apply(2 * k + 1, lz[k]);\n            lz[k] = id();\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n    \n    long long pow_mod(long long x, long long n, int m) {\n        assert(0 <= n && 1 <= m);\n        if (m == 1) return 0;\n        internal::barrett bt((unsigned int)(m));\n        unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n        while (n) {\n            if (n & 1) r = bt.mul(r, y);\n            y = bt.mul(y, y);\n            n >>= 1;\n        }\n        return r;\n    }\n    \n    long long inv_mod(long long x, long long m) {\n        assert(1 <= m);\n        auto z = internal::inv_gcd(x, m);\n        assert(z.first == 1);\n        return z.second;\n    }\n    \n    std::pair<long long, long long> crt(const std::vector<long long>& r,\n                                        const std::vector<long long>& m) {\n        assert(r.size() == m.size());\n        int n = int(r.size());\n        long long r0 = 0, m0 = 1;\n        for (int i = 0; i < n; i++) {\n            assert(1 <= m[i]);\n            long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n            if (m0 < m1) {\n                std::swap(r0, r1);\n                std::swap(m0, m1);\n            }\n            if (m0 % m1 == 0) {\n                if (r0 % m1 != r1) return {0, 0};\n                continue;\n            }\n            \n            \n            long long g, im;\n            std::tie(g, im) = internal::inv_gcd(m0, m1);\n            \n            long long u1 = (m1 / g);\n            if ((r1 - r0) % g) return {0, 0};\n            \n            long long x = (r1 - r0) / g % u1 * im % u1;\n            \n            r0 += x * m0;\n            m0 *= u1;  // -> lcm(m0, m1)\n            if (r0 < 0) r0 += m0;\n        }\n        return {r0, m0};\n    }\n    \n    long long floor_sum(long long n, long long m, long long a, long long b) {\n        long long ans = 0;\n        if (a >= m) {\n            ans += (n - 1) * n * (a / m) / 2;\n            a %= m;\n        }\n        if (b >= m) {\n            ans += n * (b / m);\n            b %= m;\n        }\n        \n        long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n        if (y_max == 0) return ans;\n        ans += (n - (x_max + a - 1) / a) * y_max;\n        ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n        return ans;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class T> struct simple_queue {\n            std::vector<T> payload;\n            int pos = 0;\n            void reserve(int n) { payload.reserve(n); }\n            int size() const { return int(payload.size()) - pos; }\n            bool empty() const { return pos == int(payload.size()); }\n            void push(const T& t) { payload.push_back(t); }\n            T& front() { return payload[pos]; }\n            void clear() {\n                payload.clear();\n                pos = 0;\n            }\n            void pop() { pos++; }\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap> struct mf_graph {\n    public:\n        mf_graph() : _n(0) {}\n        mf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            assert(0 <= cap);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result;\n            for (int i = 0; i < m; i++) {\n                result.push_back(get_edge(i));\n            }\n            return result;\n        }\n        void change_edge(int i, Cap new_cap, Cap new_flow) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            assert(0 <= new_flow && new_flow <= new_cap);\n            auto& _e = g[pos[i].first][pos[i].second];\n            auto& _re = g[_e.to][_e.rev];\n            _e.cap = new_cap - new_flow;\n            _re.cap = new_flow;\n        }\n        \n        Cap flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        Cap flow(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            \n            std::vector<int> level(_n), iter(_n);\n            internal::simple_queue<int> que;\n            \n            auto bfs = [&]() {\n                std::fill(level.begin(), level.end(), -1);\n                level[s] = 0;\n                que.clear();\n                que.push(s);\n                while (!que.empty()) {\n                    int v = que.front();\n                    que.pop();\n                    for (auto e : g[v]) {\n                        if (e.cap == 0 || level[e.to] >= 0) continue;\n                        level[e.to] = level[v] + 1;\n                        if (e.to == t) return;\n                        que.push(e.to);\n                    }\n                }\n            };\n            auto dfs = [&](auto self, int v, Cap up) {\n                if (v == s) return up;\n                Cap res = 0;\n                int level_v = level[v];\n                for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                    _edge& e = g[v][i];\n                    if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                    Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                    if (d <= 0) continue;\n                    g[v][i].cap += d;\n                    g[e.to][e.rev].cap -= d;\n                    res += d;\n                    if (res == up) break;\n                }\n                return res;\n            };\n            \n            Cap flow = 0;\n            while (flow < flow_limit) {\n                bfs();\n                if (level[t] == -1) break;\n                std::fill(iter.begin(), iter.end(), 0);\n                while (flow < flow_limit) {\n                    Cap f = dfs(dfs, t, flow_limit - flow);\n                    if (!f) break;\n                    flow += f;\n                }\n            }\n            return flow;\n        }\n        \n        std::vector<bool> min_cut(int s) {\n            std::vector<bool> visited(_n);\n            internal::simple_queue<int> que;\n            que.push(s);\n            while (!que.empty()) {\n                int p = que.front();\n                que.pop();\n                visited[p] = true;\n                for (auto e : g[p]) {\n                    if (e.cap && !visited[e.to]) {\n                        visited[e.to] = true;\n                        que.push(e.to);\n                    }\n                }\n            }\n            return visited;\n        }\n        \n    private:\n        int _n;\n        struct _edge {\n            int to, rev;\n            Cap cap;\n        };\n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap, class Cost> struct mcf_graph {\n    public:\n        mcf_graph() {}\n        mcf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap, Cost cost) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n            Cost cost;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{\n                pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n            };\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result(m);\n            for (int i = 0; i < m; i++) {\n                result[i] = get_edge(i);\n            }\n            return result;\n        }\n        \n        std::pair<Cap, Cost> flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n            return slope(s, t, flow_limit).back();\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n            return slope(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            assert(s != t);\n            std::vector<Cost> dual(_n, 0), dist(_n);\n            std::vector<int> pv(_n), pe(_n);\n            std::vector<bool> vis(_n);\n            auto dual_ref = [&]() {\n                std::fill(dist.begin(), dist.end(),\n                          std::numeric_limits<Cost>::max());\n                std::fill(pv.begin(), pv.end(), -1);\n                std::fill(pe.begin(), pe.end(), -1);\n                std::fill(vis.begin(), vis.end(), false);\n                struct Q {\n                    Cost key;\n                    int to;\n                    bool operator<(Q r) const { return key > r.key; }\n                };\n                std::priority_queue<Q> que;\n                dist[s] = 0;\n                que.push(Q{0, s});\n                while (!que.empty()) {\n                    int v = que.top().to;\n                    que.pop();\n                    if (vis[v]) continue;\n                    vis[v] = true;\n                    if (v == t) break;\n                    for (int i = 0; i < int(g[v].size()); i++) {\n                        auto e = g[v][i];\n                        if (vis[e.to] || !e.cap) continue;\n                        Cost cost = e.cost - dual[e.to] + dual[v];\n                        if (dist[e.to] - dist[v] > cost) {\n                            dist[e.to] = dist[v] + cost;\n                            pv[e.to] = v;\n                            pe[e.to] = i;\n                            que.push(Q{dist[e.to], e.to});\n                        }\n                    }\n                }\n                if (!vis[t]) {\n                    return false;\n                }\n                \n                for (int v = 0; v < _n; v++) {\n                    if (!vis[v]) continue;\n                    dual[v] -= dist[t] - dist[v];\n                }\n                return true;\n            };\n            Cap flow = 0;\n            Cost cost = 0, prev_cost = -1;\n            std::vector<std::pair<Cap, Cost>> result;\n            result.push_back({flow, cost});\n            while (flow < flow_limit) {\n                if (!dual_ref()) break;\n                Cap c = flow_limit - flow;\n                for (int v = t; v != s; v = pv[v]) {\n                    c = std::min(c, g[pv[v]][pe[v]].cap);\n                }\n                for (int v = t; v != s; v = pv[v]) {\n                    auto& e = g[pv[v]][pe[v]];\n                    e.cap -= c;\n                    g[v][e.rev].cap += c;\n                }\n                Cost d = -dual[s];\n                flow += c;\n                cost += c * d;\n                if (prev_cost == d) {\n                    result.pop_back();\n                }\n                result.push_back({flow, cost});\n                prev_cost = cost;\n            }\n            return result;\n        }\n        \n    private:\n        int _n;\n        \n        struct _edge {\n            int to, rev;\n            Cap cap;\n            Cost cost;\n        };\n        \n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\n    namespace internal {\n        \n        template <class E> struct csr {\n            std::vector<int> start;\n            std::vector<E> elist;\n            csr(int n, const std::vector<std::pair<int, E>>& edges)\n            : start(n + 1), elist(edges.size()) {\n                for (auto e : edges) {\n                    start[e.first + 1]++;\n                }\n                for (int i = 1; i <= n; i++) {\n                    start[i] += start[i - 1];\n                }\n                auto counter = start;\n                for (auto e : edges) {\n                    elist[counter[e.first]++] = e.second;\n                }\n            }\n        };\n        \n        struct scc_graph {\n        public:\n            scc_graph(int n) : _n(n) {}\n            \n            int num_vertices() { return _n; }\n            \n            void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n            \n            std::pair<int, std::vector<int>> scc_ids() {\n                auto g = csr<edge>(_n, edges);\n                int now_ord = 0, group_num = 0;\n                std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n                visited.reserve(_n);\n                auto dfs = [&](auto self, int v) -> void {\n                    low[v] = ord[v] = now_ord++;\n                    visited.push_back(v);\n                    for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                        auto to = g.elist[i].to;\n                        if (ord[to] == -1) {\n                            self(self, to);\n                            low[v] = std::min(low[v], low[to]);\n                        } else {\n                            low[v] = std::min(low[v], ord[to]);\n                        }\n                    }\n                    if (low[v] == ord[v]) {\n                        while (true) {\n                            int u = visited.back();\n                            visited.pop_back();\n                            ord[u] = _n;\n                            ids[u] = group_num;\n                            if (u == v) break;\n                        }\n                        group_num++;\n                    }\n                };\n                for (int i = 0; i < _n; i++) {\n                    if (ord[i] == -1) dfs(dfs, i);\n                }\n                for (auto& x : ids) {\n                    x = group_num - 1 - x;\n                }\n                return {group_num, ids};\n            }\n            \n            std::vector<std::vector<int>> scc() {\n                auto ids = scc_ids();\n                int group_num = ids.first;\n                std::vector<int> counts(group_num);\n                for (auto x : ids.second) counts[x]++;\n                std::vector<std::vector<int>> groups(ids.first);\n                for (int i = 0; i < group_num; i++) {\n                    groups[i].reserve(counts[i]);\n                }\n                for (int i = 0; i < _n; i++) {\n                    groups[ids.second[i]].push_back(i);\n                }\n                return groups;\n            }\n            \n        private:\n            int _n;\n            struct edge {\n                int to;\n            };\n            std::vector<std::pair<int, edge>> edges;\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct scc_graph {\n    public:\n        scc_graph() : internal(0) {}\n        scc_graph(int n) : internal(n) {}\n        \n        void add_edge(int from, int to) {\n            int n = internal.num_vertices();\n            assert(0 <= from && from < n);\n            assert(0 <= to && to < n);\n            internal.add_edge(from, to);\n        }\n        \n        std::vector<std::vector<int>> scc() { return internal.scc(); }\n        \n    private:\n        internal::scc_graph internal;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class S, S (*op)(S, S), S (*e)()> struct segtree {\n    public:\n        segtree() : segtree(0) {}\n        segtree(int n) : segtree(std::vector<S>(n, e())) {}\n        segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            return d[p + size];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            S sml = e(), smr = e();\n            l += size;\n            r += size;\n            \n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        template <bool (*f)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return f(x); });\n        }\n        template <class F> int max_right(int l, F f) {\n            assert(0 <= l && l <= _n);\n            assert(f(e()));\n            if (l == _n) return _n;\n            l += size;\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!f(op(sm, d[l]))) {\n                    while (l < size) {\n                        l = (2 * l);\n                        if (f(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*f)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return f(x); });\n        }\n        template <class F> int min_left(int r, F f) {\n            assert(0 <= r && r <= _n);\n            assert(f(e()));\n            if (r == 0) return 0;\n            r += size;\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!f(op(d[r], sm))) {\n                    while (r < size) {\n                        r = (2 * r + 1);\n                        if (f(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        std::vector<int> sa_naive(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n                if (l == r) return false;\n                while (l < n && r < n) {\n                    if (s[l] != s[r]) return s[l] < s[r];\n                    l++;\n                    r++;\n                }\n                return l == n;\n            });\n            return sa;\n        }\n        \n        std::vector<int> sa_doubling(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n), rnk = s, tmp(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            for (int k = 1; k < n; k *= 2) {\n                auto cmp = [&](int x, int y) {\n                    if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n                    int rx = x + k < n ? rnk[x + k] : -1;\n                    int ry = y + k < n ? rnk[y + k] : -1;\n                    return rx < ry;\n                };\n                std::sort(sa.begin(), sa.end(), cmp);\n                tmp[sa[0]] = 0;\n                for (int i = 1; i < n; i++) {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n                }\n                std::swap(tmp, rnk);\n            }\n            return sa;\n        }\n        \n        template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\n        std::vector<int> sa_is(const std::vector<int>& s, int upper) {\n            int n = int(s.size());\n            if (n == 0) return {};\n            if (n == 1) return {0};\n            if (n == 2) {\n                if (s[0] < s[1]) {\n                    return {0, 1};\n                } else {\n                    return {1, 0};\n                }\n            }\n            if (n < THRESHOLD_NAIVE) {\n                return sa_naive(s);\n            }\n            if (n < THRESHOLD_DOUBLING) {\n                return sa_doubling(s);\n            }\n            \n            std::vector<int> sa(n);\n            std::vector<bool> ls(n);\n            for (int i = n - 2; i >= 0; i--) {\n                ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n            }\n            std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n            for (int i = 0; i < n; i++) {\n                if (!ls[i]) {\n                    sum_s[s[i]]++;\n                } else {\n                    sum_l[s[i] + 1]++;\n                }\n            }\n            for (int i = 0; i <= upper; i++) {\n                sum_s[i] += sum_l[i];\n                if (i < upper) sum_l[i + 1] += sum_s[i];\n            }\n            \n            auto induce = [&](const std::vector<int>& lms) {\n                std::fill(sa.begin(), sa.end(), -1);\n                std::vector<int> buf(upper + 1);\n                std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n                for (auto d : lms) {\n                    if (d == n) continue;\n                    sa[buf[s[d]]++] = d;\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                sa[buf[s[n - 1]]++] = n - 1;\n                for (int i = 0; i < n; i++) {\n                    int v = sa[i];\n                    if (v >= 1 && !ls[v - 1]) {\n                        sa[buf[s[v - 1]]++] = v - 1;\n                    }\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                for (int i = n - 1; i >= 0; i--) {\n                    int v = sa[i];\n                    if (v >= 1 && ls[v - 1]) {\n                        sa[--buf[s[v - 1] + 1]] = v - 1;\n                    }\n                }\n            };\n            \n            std::vector<int> lms_map(n + 1, -1);\n            int m = 0;\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms_map[i] = m++;\n                }\n            }\n            std::vector<int> lms;\n            lms.reserve(m);\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms.push_back(i);\n                }\n            }\n            \n            induce(lms);\n            \n            if (m) {\n                std::vector<int> sorted_lms;\n                sorted_lms.reserve(m);\n                for (int v : sa) {\n                    if (lms_map[v] != -1) sorted_lms.push_back(v);\n                }\n                std::vector<int> rec_s(m);\n                int rec_upper = 0;\n                rec_s[lms_map[sorted_lms[0]]] = 0;\n                for (int i = 1; i < m; i++) {\n                    int l = sorted_lms[i - 1], r = sorted_lms[i];\n                    int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n                    int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n                    bool same = true;\n                    if (end_l - l != end_r - r) {\n                        same = false;\n                    } else {\n                        while (l < end_l) {\n                            if (s[l] != s[r]) {\n                                break;\n                            }\n                            l++;\n                            r++;\n                        }\n                        if (l == n || s[l] != s[r]) same = false;\n                    }\n                    if (!same) rec_upper++;\n                    rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n                }\n                \n                auto rec_sa =\n                sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n                \n                for (int i = 0; i < m; i++) {\n                    sorted_lms[i] = lms[rec_sa[i]];\n                }\n                induce(sorted_lms);\n            }\n            return sa;\n        }\n        \n    }  // namespace internal\n    \n    std::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n        assert(0 <= upper);\n        for (int d : s) {\n            assert(0 <= d && d <= upper);\n        }\n        auto sa = internal::sa_is(s, upper);\n        return sa;\n    }\n    \n    template <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n        int n = int(s.size());\n        std::vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n        std::vector<int> s2(n);\n        int now = 0;\n        for (int i = 0; i < n; i++) {\n            if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n            s2[idx[i]] = now;\n        }\n        return internal::sa_is(s2, now);\n    }\n    \n    std::vector<int> suffix_array(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return internal::sa_is(s2, 255);\n    }\n    \n    template <class T>\n    std::vector<int> lcp_array(const std::vector<T>& s,\n                               const std::vector<int>& sa) {\n        int n = int(s.size());\n        assert(n >= 1);\n        std::vector<int> rnk(n);\n        for (int i = 0; i < n; i++) {\n            rnk[sa[i]] = i;\n        }\n        std::vector<int> lcp(n - 1);\n        int h = 0;\n        for (int i = 0; i < n; i++) {\n            if (h > 0) h--;\n            if (rnk[i] == 0) continue;\n            int j = sa[rnk[i] - 1];\n            for (; j + h < n && i + h < n; h++) {\n                if (s[j + h] != s[i + h]) break;\n            }\n            lcp[rnk[i] - 1] = h;\n        }\n        return lcp;\n    }\n    \n    std::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return lcp_array(s2, sa);\n    }\n    \n    template <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n        int n = int(s.size());\n        if (n == 0) return {};\n        std::vector<int> z(n);\n        z[0] = 0;\n        for (int i = 1, j = 0; i < n; i++) {\n            int& k = z[i];\n            k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n            while (i + k < n && s[k] == s[i + k]) k++;\n            if (j + z[j] < i + z[i]) j = i;\n        }\n        z[0] = n;\n        return z;\n    }\n    \n    std::vector<int> z_algorithm(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return z_algorithm(s2);\n    }\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct two_sat {\n    public:\n        two_sat() : _n(0), scc(0) {}\n        two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n        \n        void add_clause(int i, bool f, int j, bool g) {\n            assert(0 <= i && i < _n);\n            assert(0 <= j && j < _n);\n            scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n            scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n        }\n        bool satisfiable() {\n            auto id = scc.scc_ids().second;\n            for (int i = 0; i < _n; i++) {\n                if (id[2 * i] == id[2 * i + 1]) return false;\n                _answer[i] = id[2 * i] < id[2 * i + 1];\n            }\n            return true;\n        }\n        std::vector<bool> answer() { return _answer; }\n        \n    private:\n        int _n;\n        std::vector<bool> _answer;\n        internal::scc_graph scc;\n    };\n    \n}  // namespace atcoder\n\nconst int mod=1000000007,MAX=100005;\nconst ll INF=1LL<<60;\n\nusing mint=atcoder::modint1000000007;\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,M;cin>>N>>M;\n    if(M==1){\n        cout<<1<<endl;\n        return 0;\n    }\n    vector<ll> A(N),B(M+2);\n    B[0]=-INF;\n    B[M+1]=INF;\n    for(int i=0;i<N;i++) cin>>A[i];\n    for(int i=0;i<M;i++) cin>>B[i+1];\n    \n    vector<pair<ll,ll>> S;\n    \n    int id=0;\n    map<ll,int> MA;\n    for(int i=0;i<N;i++){\n        while(A[i]>=B[id+1]) id++;\n        \n        if(id==0||id==M) continue;\n        \n        S.push_back(mp(A[i]-B[id],B[id+1]-A[i]));\n        MA[B[id+1]-A[i]]=1;\n    }\n    \n    sort(all(S));\n    \n    S.erase(unique(all(S)),S.end());\n    \n    sort(all(S),[](auto a,auto b){\n        if(a.fi==b.fi) return a.se>b.se;\n        return a.fi<b.fi;\n    });\n    \n    id=1;\n    \n    for(auto &a:MA){\n        a.se=id;\n        id++;\n    }\n    \n    N=si(S);\n    \n    for(int i=0;i<N;i++){\n        S[i].se=MA[S[i].se];\n        //cout<<S[i].fi<<\" \"<<S[i].se<<endl;\n    }\n    \n    atcoder::fenwick_tree<mint> dp(N+3);\n    \n    dp.add(0,1);\n    \n    for(int i=0;i<N;i++){\n        dp.add(S[i].se,dp.sum(0,S[i].se));\n    }\n    \n    cout<<dp.sum(0,N+2).val()<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=1e5+5;\nconst int mod=1e9+7;\n\nint n,m,cnt,top,ans=1,H[N],a[N],b[N],dp[N];\nstruct Node {\n\tint x,y;\n\tbool operator == (Node&b) {return x==b.x&&y==b.y;}\n} p[N];\nbool cmp(Node a,Node b) {return (a.x!=b.x)?(a.x<b.x):(a.y>b.y);}\n\ntemplate <typename _Tp> inline void IN(_Tp&x) {\n\tchar ch;bool flag=0;x=0;\n\twhile(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1;\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\tif(flag) x=-x;\n}\n\nstruct BIT {\n\tint c[N],res;\n\tinline int lowbit(int x) {return x&(-x);}\n\tinline void update(int x,int y) {for(;x<=top;x+=lowbit(x)) (c[x]+=y)%=mod;}\n\tinline int query(int x) {res=0;for(;x;x-=lowbit(x)) (res+=c[x])%=mod;return res;}\n}bit;\n\nint main() {\n\tIN(n),IN(m);\n\tfor(int i=1;i<=n;++i) IN(a[i]);\n\tfor(int i=1;i<=m;++i) IN(b[i]);\n\tsort(a+1,a+1+n),sort(b+1,b+1+m);\n\tfor(int i=1;i<=n;++i) {\n\t\tif(a[i]<=b[1]||a[i]>=b[m]) continue;\n\t\tint pos=lower_bound(b+1,b+1+m,a[i])-b;\n\t\tif(b[pos]==a[i]) continue;\n\t\tp[++cnt]=(Node){a[i]-b[pos-1],b[pos]-a[i]},H[++top]=b[pos]-a[i];\n\t}\n\tsort(H+1,H+1+top),top=unique(H+1,H+1+top)-H-1;\n\tfor(int i=1;i<=cnt;++i) p[i].y=lower_bound(H+1,H+1+top,p[i].y)-H;\n\tsort(p+1,p+1+cnt,cmp),cnt=unique(p+1,p+1+cnt)-p-1;\n\tfor(int i=1;i<=cnt;++i) dp[i]=bit.query(p[i].y-1)+1,bit.update(p[i].y,dp[i]);\n\tfor(int i=1;i<=cnt;++i) (ans+=dp[i])%=mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100010,mod=1000000007;\nint n,m;\nint x[N],y[N],cnt;\nstruct pt\n{\n\tint x,y;\n\tbool operator < (const pt a)const\n\t{\n\t\treturn x<a.x || (x==a.x && y<a.y);\n\t}\n}b[N];\nlong long s[N];\nint lowbit(int k)\n{\n\treturn k&-k;\n}\nvoid add(int k,long long x)\n{\n\tfor(int i=k;i<=n;i+=lowbit(i))\n\t\t(s[i]+=x)%=mod;\n}\nlong long query(int k)\n{\n\tlong long res=0;\n\tfor(int i=k;i;i-=lowbit(i))\n\t\t(res+=s[i])%=mod;\n\treturn res;\n}\nlong long f[N];\nint h[N<<1];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&y[i]);\n\tint fi=1;\n\twhile(x[fi]<=y[1] && fi<=n)fi++;\n\tfor(int i=1;i<m;i++)\n\t{\n\t\twhile(x[fi]==y[i] && fi<=n)fi++;\n\t\twhile(x[fi]<y[i+1] && fi<=n)\n\t\t{\n\t\t\tb[++cnt].x=x[fi]-y[i];\n\t\t\tb[cnt].y=y[i+1]-x[fi];\n\t\t\tfi++;\n\t\t}\n\t}\n\tint tot=0;\n\tsort(b+1,b+cnt+1);\n\tfor(int i=1;i<=cnt;i++)\n\t\th[++tot]=b[i].x,h[++tot]=b[i].y;\n\tsort(h+1,h+tot+1);\n\ttot=unique(h+1,h+tot+1)-h-1;\n\tfor(int i=1;i<=cnt;i++)\n\t\tb[i].x=lower_bound(h+1,h+tot+1,b[i].x)-h,b[i].y=lower_bound(h+1,h+tot+1,b[i].y)-h;\n\tlong long ans=1;\n\tfor(int i=1;i<=cnt;)\n\t{\n\t\tint j=i;\n\t\tfor(;j<=cnt && b[i].x==b[j].x;j++)\n\t\t\tf[j]=1+query(b[j].y-1);\n\t\tj=i;\n\t\tfor(;j<=cnt && b[i].x==b[j].x;j++)\n\t\t\tif(b[j].y!=b[j-1].y)\n\t\t\t\tadd(b[j].y,f[j]),ans+=f[j];\n\t\ti=j;\n    }\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LB long double\n#define ull unsigned long long\n#define x first\n#define y second\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define Pair pair<int,int>\n#define pLL pair<LL,LL>\n#define pii pair<double,double>\n#define LOWBIT(x) x & (-x)\n// #define LOCAL true\n\nconst int INF=2e9;\nconst LL LINF=2e16;\nconst int magic=348;\nconst int MOD=1e9+7;\nconst double eps=1e-10;\nconst double pi=acos(-1);\n\nstruct fastio\n{\n\tstatic const int S=1e7;\n\tchar rbuf[S+48],wbuf[S+48];int rpos,wpos,len;\n\tfastio() {rpos=len=wpos=0;}\n\tinline char Getchar()\n\t{\n\t\tif (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin);\n\t\tif (!len) return EOF;\n\t\treturn rbuf[rpos++];\n\t}\n\ttemplate <class T> inline void Get(T &x)\n\t{\n\t\tchar ch;bool f;T res;\n\t\twhile (!isdigit(ch=Getchar()) && ch!='-') {}\n\t\tif (ch=='-') f=false,res=0; else f=true,res=ch-'0';\n\t\twhile (isdigit(ch=Getchar())) res=res*10+ch-'0';\n\t\tx=(f?res:-res);\n\t}\n\tinline void getstring(char *s)\n\t{\n\t\tchar ch;\n\t\twhile ((ch=Getchar())<=32) {}\n\t\tfor (;ch>32;ch=Getchar()) *s++=ch;\n\t\t*s='\\0';\n\t}\n\tinline void flush() {fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;}\n\tinline void Writechar(char ch)\n\t{\n\t\tif (wpos==S) flush();\n\t\twbuf[wpos++]=ch;\n\t}\n\ttemplate <class T> inline void Print(T x,char ch)\n\t{\n\t\tchar s[20];int pt=0;\n\t\tif (x==0) s[++pt]='0';\n\t\telse\n\t\t{\n\t\t\tif (x<0) Writechar('-'),x=-x;\n\t\t\twhile (x) s[++pt]='0'+x%10,x/=10;\n\t\t}\n\t\twhile (pt) Writechar(s[pt--]);\n\t\tWritechar(ch);\n\t}\n\tinline void printstring(char *s)\n\t{\n\t\tint pt=1;\n\t\twhile (s[pt]!='\\0') Writechar(s[pt++]);\n\t}\n}io;\n\ntemplate<typename T> inline void check_max(T &x,T cmp) {x=max(x,cmp);}\ntemplate<typename T> inline void check_min(T &x,T cmp) {x=min(x,cmp);}\ntemplate<typename T> inline T myabs(T x) {return x>=0?x:-x;}\ntemplate<typename T> inline T gcd(T x,T y) {return y==0?x:gcd(y,x%y);}\ninline int add(int x) {if (x>=MOD) x-=MOD;return x;}\ninline int add(int x,int MO) {if (x>=MO) x-=MO;return x;}\ninline int sub(int x) {if (x<0) x+=MOD;return x;}\ninline int sub(int x,int MO) {if (x<0) x+=MO;return x;}\ninline void Add(int &x,int y) {x=add(x+y);}\ninline void Add(int &x,int y,int MO) {x=add(x+y,MO);}\ninline void Sub(int &x,int y) {x=sub(x-y);}\ninline void Sub(int &x,int y,int MO) {x=sub(x-y,MO);}\ninline int quick_pow(int x,int y) {int res=1;while (y) {if (y&1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y>>=1;}return res;}\ninline int quick_pow(int x,int y,int MO) {int res=1;while (y) {if (y&1) res=1ll*res*x%MO;x=1ll*x*x%MO;y>>=1;}return res;}\n\nconst int MAXN=1e5;\n\nint n,m;\nint A[MAXN+48],B[MAXN+48];\nvector<int> tmp;\n\nstruct node\n{\n\tint x,y,ny;\n\tinline bool operator < (const node &other) const {return x<other.x;}\n}a[MAXN+48];int tot;\n\nstruct Pt\n{\n\tint val,from;\n\tPt () {}\n\tinline Pt (int vv,int ff) {val=vv;from=ff;}\n\tinline bool operator < (const Pt &other) {return val<other.val;}\n}b[MAXN+48];int btot,itot;\n\nmap<Pair,bool> Mp;\n\nnamespace BIT\n{\n\tint c[MAXN+48];\n\tinline void init() {memset(c,0,sizeof(c));}\n\tinline void update(int x,int delta) {while (x<=itot) Add(c[x],delta),x+=LOWBIT(x);}\n\tinline int query(int x) {int res=0;while (x) {Add(res,c[x]),x-=LOWBIT(x);}return res;}\n\tinline int query(int left,int right) {return query(right)-query(left-1);}\n}\n\nint main ()\n{\n#ifdef LOCAL\n\tdouble TIME=clock();\n\tfreopen (\"a.in\",\"r\",stdin);\n\tfreopen (\"a.out\",\"w\",stdout);\n\tcerr<<\"Running...\"<<endl;\n#endif\n\tio.Get(n);io.Get(m);\n\tfor (register int i=1;i<=n;i++) io.Get(A[i]);\n\tfor (register int i=1;i<=m;i++) io.Get(B[i]);\n\tint pt=0;B[0]=0;tot=btot=0;Mp.clear();\n\tfor (register int i=1;i<=n;i++)\n\t{\n\t\twhile (pt<=m && B[pt]<=A[i]) pt++;pt--;\n\t\tif (!pt || pt==m || Mp.find(mp(A[i]-B[pt],B[pt+1]-A[i]))!=Mp.end()) continue;\n\t\ta[++tot].x=A[i]-B[pt];a[tot].y=B[pt+1]-A[i];Mp[mp(a[tot].x,a[tot].y)]=true;\n\t\tb[++btot]=Pt(a[tot].y,tot);\n\t}\n\tsort(b+1,b+btot+1);itot=0;\n\tfor (register int i=1;i<=btot;i++)\n\t{\n\t\tif (i==1 || b[i].val!=b[i-1].val) itot++;\n\t\ta[b[i].from].ny=itot;\n\t}\n\tBIT::init();int ans=0;\n\tsort(a+1,a+tot+1);pt=1;\n\twhile (pt<=tot)\n\t{\n\t\tregister int pt1=pt;\n\t\twhile (pt1<=tot && a[pt1].x==a[pt].x) pt1++;pt1--;\n\t\ttmp.clear();\n\t\tfor (register int i=pt;i<=pt1;i++)\n\t\t{\n\t\t\tint val=add(1+BIT::query(1,a[i].ny-1));\n\t\t\tAdd(ans,val);tmp.pb(val);\n\t\t}\n\t\tfor (register int i=pt;i<=pt1;i++) BIT::update(a[i].ny,tmp[i-pt]);\n\t\tpt=pt1+1;\n\t}\n\tio.Print(add(ans+1),'\\n');\n\tio.flush();\n#ifdef LOCAL\n\tcerr<<\"Exec Time: \"<<(clock()-TIME)/CLOCKS_PER_SEC<<endl;\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair <int, int> pii;\nint x[100010], y[100010];\nconst int inf = 1000000007;\nint dp[100010];\nconst int mod = 1000000007;\n\nbool cmp(pii a, pii b) {\n\tif(a.first == b.first) {\n\t\treturn a.second > b.second;\n\t}\n\treturn a.first < b.first;\n}\n\nint main(int argc, char const *argv[])\n{\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\tvector <int> v;\n\tfor(int i = 1; i <= m; i++) {\n\t\tscanf(\"%d\", &y[i]);\n\t\tv.push_back(y[i]);\n\t}\n\tsort(v.begin(), v.end());\n\n\tvector <pii> a;\n\tmap <int, int> mp;\n\tfor(int i = 1; i <= n; i++) {\n\t\tint id = upper_bound(v.begin(), v.end(), x[i]) - v.begin();\n\t\tint r = id < v.size() ? v[id] - x[i] : inf;\n\t\tint l = id > 0 ? x[i] - v[id - 1] : inf;\n\t\tif(l == inf || r == inf) continue;\n\t\ta.push_back(pii(l, r));\t\n\t\tif(mp.find(l) == mp.end()) {\n\t\t\tmp[l] = r;\n\t\t} else {\n\t\t\tmp[l] = max(mp[l], r);\n\t\t}\n\t}\n\n\t// for(auto i : mp) {\n\t// \ta.push_back()\n\t// }\n\tsort(a.begin(), a.end(), cmp);\n\n\tint ans = 1;\n\tfor(int i = 0; i < a.size(); i++) {\n\t\tdp[i] = 1;\n\t\tfor(int j = 0; j < i; j++) {\n\t\t\tif(j && a[j] == a[j-1]) continue;\n\t\t\tif(a[j].second < a[i].second) {\n\t\t\t\tdp[i] += dp[j];\n\t\t\t\tdp[i] %= mod;\n\t\t\t}\n\t\t}\n\t\tif(i == 0 || a[i-1] != a[i])ans += dp[i];\n\t\tans %= mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define maxn 1000000000000000000LL\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nint n,m,i,book[200005],l[3300005],r[3300005],now;\nstruct nyh{\n\tint x,id;\n}o[200005];\nint top,f[100005],top2,a[3300005],sum,p1,p2,ans;\nstruct lyh{\n\tint x,y;\n}p[100005];\nbool cmp(nyh u,nyh v){\n\treturn u.x<v.x;\n}\nbool cmp2(lyh u,lyh v){\n\treturn u.x<v.x||u.x==v.x&&u.y>v.y;\n}\nvoid xtree(int u,int v,int w){\n\tint mid=(u+v>>1);\n\ta[w]=(a[w]+p2)%mo;\n\tif(u==v)\n\t\treturn;\n\tif(p1<=mid){\n\t\tif(l[w]==0){\n\t\t\ttop2++;\n\t\t\tl[w]=top2;\n\t\t}\n\t\txtree(u,mid,l[w]);\n\t}\n\telse{\n\t\tif(r[w]==0){\n\t\t\ttop2++;\n\t\t\tr[w]=top2;\n\t\t}\n\t\txtree(mid+1,v,r[w]);\n\t}\n}\nvoid ytree(int u,int v,int w){\n\tint mid=(u+v>>1);\n\tif(u==v||w==0)\n\t\treturn;\n\tif(p1<=mid) \n\t\tytree(u,mid,l[w]);\n\telse{\n\t\tsum=(sum+a[l[w]])%mo;\n\t\tytree(mid+1,v,r[w]);\n\t}\n}\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read();m=read();\n\tfor(i=1;i<=n;i++){\n\t\to[i].x=read();\n\t\to[i].id=1;\n\t}\n\tfor(i=1;i<=m;i++){\n\t\to[i+n].x=read();\n\t\to[i+n].id=2;\n\t}\n\tsort(o+1,o+n+m+1,cmp);\n\tnow=0;\n\tfor(i=1;i<=n+m;i++)\n\t\tif(o[i].id==2)\n\t\t\tnow=o[i].x;\n\t\telse if(now!=0){\n\t\t\tbook[i]|=1;\n\t\t\tl[i]=o[i].x-now;\n\t\t}\n\tnow=0;\n\tfor(i=n+m;i>=1;i--)\n\t\tif(o[i].id==2)\n\t\t\tnow=o[i].x;\n\t\telse if(now!=0){\n\t\t\tbook[i]|=2;\n\t\t\tr[i]=now-o[i].x;\n\t\t}\n\tfor(i=1;i<=n+m;i++){\n\t\tif(book[i]==3){\n\t\t\ttop++;\n\t\t\tp[top].x=l[i];\n\t\t\tp[top].y=r[i];\n\t\t}\n\t\tl[i]=0;\n\t\tr[i]=0;\n\t}\n\tsort(p+1,p+top+1,cmp2);\n\ttop2=1;ans=1;\n\tfor(i=1;i<=n;i++)\n\t\tif(p[i].x!=p[i-1].x||p[i].y!=p[i-1].y){\n\t\t\tsum=0;\n\t\t\tp1=p[i].y;\n\t\t\tytree(1,1000000000,1);\n\t\t\tf[i]=(sum+1)%mo;\n\t\t\tans=(ans+f[i])%mo;\n\t\t\tp1=p[i].y;p2=f[i];\n\t\t\txtree(1,1000000000,1);\n\t\t}\n\tpus(ans,2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=200005,p=1000000007;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint qpow(int x,int k){\n\tint t=1;\n\tfor (;k;k>>=1){\n\t\tif (k&1) t=(ll)t*x%p;\n\t\tx=(ll)x*x%p;\n\t}\n\treturn t;\n}\nint n,m,cnt,a[N],pos[N],ans;\nstruct node{int x,y;}b[N];\nbool cmp2(int x,int y){return a[x]<a[y];}\nbool cmp(node a,node b){return (a.x!=b.x) ? (a.x<b.x) : (a.y>b.y);}\nvoid check(int &x,int y){if ((x+=y)>=p) x-=p;}\nstruct BIT{\n\tint f[N];\n\tinline int lowbit(int x){return x&(-x);}\n\tvoid add(int x,int t){for (;x<=n;x+=lowbit(x)) check(f[x],t);}\n\tint query(int x){\n\t\tint t=1;\n\t\tfor (;x;x-=lowbit(x)) check(t,f[x]);\n\t\treturn t;\n\t}\n}f;\nint main(){\n\tn=read();m=read();\n\tfor (int i=1;i<=n+m;i++) a[i]=read(),pos[i]=i;\n\tsort(pos+1,pos+n+m+1,cmp2);\n\tint las=0;\n\tfor (int i=1;i<=n+m;i++){\n\t\tint x=pos[i];\n\t\tif (x>n) las=x;\n\t\telse b[x].x=(las) ? a[x]-a[las] : 0;\n\t}\n\tlas=0;\n\tfor (int i=n+m;i;i--){\n\t\tint x=pos[i];\n\t\tif (x>n) las=x;\n\t\telse b[x].y=(las) ? a[las]-a[x] : 0;\n\t}\n\tcnt=0;\n\tfor (int i=1;i<=n;i++)\n\tif (b[i].x&&b[i].y) {b[++cnt]=b[i];a[cnt]=b[i].y;}\n\tsort(b+1,b+cnt+1,cmp);\n\tsort(a+1,a+cnt+1);\n\tans=1;\n\tfor (int i=1;i<=cnt;i++)\n\tif (cmp(b[i-1],b[i])){\n\t\tint x=lower_bound(a+1,a+cnt+1,b[i].y)-a;\n\t\tint t=f.query(x-1);f.add(x,t);\n\t\tcheck(ans,t);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<queue>\n#define inf 2147483647\n#define eps 1e-9\n#define lb(x) (x&-x)\n#define mod 1000000007\n#define mp make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pr;\nint n,m,ans=1,tot=0,tmp,t1,t2,t[500001],a[100001],b[100001],h[100001];\npr p[100001];\nbool cmp(pr a,pr b){\n\treturn a.first==b.first?a.second>b.second:a.first<b.first;\n}\nvoid add(int u,int x){\n\tfor(;u<=n;u+=lb(u)){\n\t\tt[u]=(t[u]+x)%mod;\n\t}\n}\nint query(int u){\n\tint ret=0;\n\tfor(;u;u-=lb(u)){\n\t\tret=(ret+t[u])%mod;\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++)scanf(\"%d\",&b[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]>b[1]&&a[i]<b[m]){\n\t\t\ttmp=lower_bound(b+1,b+m+1,a[i])-b;\n\t\t\tif(a[i]==b[tmp])continue;\n\t\t\tp[++tot]=pr(a[i]-b[tmp-1],b[tmp]-a[i]);\n\t\t\th[tot]=b[tmp]-a[i];\n\t\t}\n\t}\n\tsort(h+1,h+tot+1);\n\tt1=unique(h+1,h+tot+1)-h-1;\n\tfor(int i=1;i<=tot;i++){\n\t\tp[i].second=lower_bound(h+1,h+t1+1,p[i].second)-h;\n\t}\n\tsort(p+1,p+tot+1,cmp);\n\tt2=unique(p+1,p+tot+1)-p-1;\n\tfor(int i=1;i<=t2;i++){\n\t\ttmp=query(p[i].second-1)+1;\n\t\tans=(ans+tmp)%mod;\n\t\tadd(p[i].second,tmp);\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int M=1e9+7,N=100005;\nset<int> S;\nint f[N],n,m,a[N],ans,x,b[N],num1,num2,tot,val[N];\nstruct Ask{\n\tint l,r;\n\tAsk(int _l=0,int _r=0){\n\t\tl=_l;\n\t\tr=_r;\n\t}\n}A[N];\nint cmp(Ask x,Ask y){\n\treturn x.l<y.l||(x.l==y.l&&x.r>y.r);\n}\nint ef1(int x){\n\tint l=1,r=num1;\n\twhile (l<r){\n\t\tint mid=(l+r)/2;\n\t\tif (a[mid]<x)l=mid+1;\n\t\telse r=mid;\n\t}\n\treturn l;\n}\nint ef2(int x){\n\tint l=1,r=num2;\n\twhile (l<r){\n\t\tint mid=(l+r)/2;\n\t\tif (b[mid]<x)l=mid+1;\n\t\telse r=mid;\n\t}\n\treturn l;\n}\nint find(int x){\n\tint ans=0;\n\tfor (;x;x-=x&-x)ans+=val[x];\n\treturn ans;\n}\nvoid insert(int x,int y){\n\tfor (;x<=num2;x+=x&-x)(val[x]+=y)%=M;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=m;i++)scanf(\"%d\",&x),S.insert(x);\n\tfor (int i=1;i<=n;i++){\n\t\tset<int>::iterator iter=S.lower_bound(a[i]);\n\t\tif (iter!=S.begin()&&iter!=S.end()){\n\t\t\tset<int>::iterator iter2=iter;iter2--;\n\t\t\tA[++tot]=Ask(a[i]-*iter2,*iter-a[i]);\n\t\t\ta[++num1]=A[tot].l;b[++num2]=A[tot].r;\n\t\t}\n\t}\n\tsort(a+1,a+num1+1);\n\tsort(b+1,b+num2+1);\n\tint num=1;\n\tfor (int i=2;i<=num1;i++)\n\t\tif (a[i]!=a[num])a[++num]=a[i];\n\tnum1=num;\n\tnum=ans=1;\n\tfor (int i=2;i<=num2;i++)\n\t\tif (b[i]!=b[num])b[++num]=b[i];\n\tnum2=num;\n\tfor (int i=1;i<=tot;i++)A[i].l=ef1(A[i].l),A[i].r=ef2(A[i].r);\n\tsort(A+1,A+tot+1,cmp);\n\tnum=1;\n\tfor (int i=2;i<=tot;i++)\n\t\tif (A[i].l!=A[num].l||A[i].r!=A[num].r)A[++num]=A[i];\n\ttot=num;\n\tfor (int i=1;i<=tot;i++){\n\t\tf[i]=(1+find(A[i].r-1))%M;\n\t\tinsert(A[i].r,f[i]);\n\t\t(ans+=f[i])%=M;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1; c=getchar();}\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=1e5+10,mod=1e9+7;\nstruct node {\n\tint x,y;\n\tnode(int x=0,int y=0): x(x),y(y) {}\n\tfriend bool operator <(node A,node B) { return A.x==B.x?A.y>B.y:A.x>B.x; }\n\tfriend bool operator ==(node A,node B) { return A.x==B.x&&A.y==B.y; }\n}a[N];\nint xi[N],yi[N],n,m,cnt;\nint val[N],tot;\n\nint c[N];\nvoid add(int i,int t) { for(;i<=tot;i+=i&-i) c[i]=(c[i]+t)%mod; }\nint query(int i) { int ans=0; for(;i;i-=i&-i) ans=(ans+c[i])%mod; return ans; }\nint main() {\n\trd(n),rd(m);\n\tfor(int i=1;i<=n;++i) rd(yi[i]);\n\tfor(int i=1;i<=m;++i) rd(xi[i]);\n\tfor(int i=1;i<=n;++i) {\n\t\tif(yi[i]<=xi[1]||yi[i]>=xi[m]) continue;\n\t\tint r=lower_bound(xi+1,xi+m+1,yi[i])-xi;\n\t\tint l=r-1;\n\t\ta[++cnt]=node(xi[l]-yi[i],xi[r]-yi[i]);\n\t}\n\tsort(a+1,a+cnt+1);\n\tcnt=unique(a+1,a+cnt+1)-a-1;\n\tfor(int i=1;i<=cnt;++i) val[++tot]=a[i].y;\n\tsort(val+1,val+tot+1);\n\ttot=unique(val+1,val+tot+1)-val-1;\t\n\tfor(int i=1;i<=cnt;++i) a[i].y=lower_bound(val+1,val+tot+1,a[i].y)-val;\n\tint ans=1;\n\tfor(int i=1;i<=cnt;++i) {\n\t\tint t=(query(a[i].y-1)+1)%mod;\n\t\tans=(ans+t)%mod;\n\t\tadd(a[i].y,t);\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n\n#pragma warning(disable:4996)  \n#pragma comment(linker, \"/STACK:336777216\")  \nusing namespace std;\n\n#define mp make_pair  \n#define Fi first  \n#define Se second  \n#define pb(x) push_back(x)  \n#define szz(x) ((int)(x).size())  \n#define rep(i, n) for(int i=0;i<n;i++)  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble  \n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n\nll bit[100050];\nvoid update(int p, ll v) {\n\tfor (; p <= 100001; p += p & (-p)) bit[p] = (bit[p] + v) % MOD;\n}\nll getsum(int p) {\n\tll rv = 0;\n\tfor (; p; p -= p & (-p)) rv = (rv + bit[p]) % MOD;\n\treturn rv;\n}\n\nvector <int> Vx;\nvector <int> Vy;\n\nint in1[100050];\nint in2[100050];\npii Qu[100050];\n\nint main() {\n\tint N, M, i, j;\n\tscanf(\"%d %d\", &N, &M);\n\tfor (i = 1; i <= N; i++) scanf(\"%d\", &in1[i]);\n\tfor (i = 1; i <= M; i++) scanf(\"%d\", &in2[i]);\n\n\tint c = 0;\n\tfor (i = 1; i <= N; i++) {\n\t\tint p = lower_bound(in2 + 1, in2 + M + 1, in1[i]) - in2;\n\t\tif (p == 1 || p == M + 1) continue;\n\n\t\tc++;\n\t\tQu[c] = pii(in1[i] - in2[p - 1], in2[p] - in1[i]);\n\t\tVx.push_back(Qu[c].first);\n\t\tVy.push_back(Qu[c].second);\n\t}\n\n\tif (c == 0) return !printf(\"1\\n\");\n\n\tsort(all(Vx));\n\tsort(all(Vy));\n\tVx.erase(unique(all(Vx)), Vx.end());\n\tVy.erase(unique(all(Vy)), Vy.end());\n\n\tfor (i = 1; i <= c; i++) {\n\t\tQu[i].first = lower_bound(all(Vx), Qu[i].first) - Vx.begin() + 1;\n\t\tQu[i].second = lower_bound(all(Vy), Qu[i].second) - Vy.begin() + 1;\n\t}\n\tsort(Qu + 1, Qu + c + 1, [](pii a, pii b) {\n\t\tif (a.first != b.first) return a.first < b.first;\n\t\telse return a.second > b.second;\n\t});\n\n\tupdate(1, 1);\n\tfor (i = 1; i <= c; i++) {\n\t\tif (Qu[i] == Qu[i - 1]) continue;\n\t\tint t = Qu[i].second;\n\t\tupdate(t + 1, getsum(t));\n\t}\n\treturn !printf(\"%lld\\n\", getsum(100001));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<55)+1e9; // ~ 3.6 * 1e16\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> &a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\ntemplate<class T>void prArr(T a,string s=\" \"){Int i=0;for(T t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass RSAQ{\npublic: \n  typedef long long ll;\n\n  //マージ可能な主データ型\n  struct D{\n    ll value;\n    D():value(0){} /*適切な値にする!!!!!!*/\n    D(ll value):value(value){}\n    bool operator < (D a)const {return value < a.value;}\n  };\n\n  //遅延用の型  \n  struct T{\n    Int type; //0 - empty   , 1 - update\n    ll value;\n    T():type(0),value(0){}\n    T(Int type,ll value):type(type),value(value){}\n  };\n\n  \n  Int n, n_;\n  vector<D> dat;\n  vector<T> td;\n  D returnD = D(0); // 範囲外の時に返す値。\n  \n  RSAQ(){n=-1;}\n  RSAQ(Int n_):n_(n_){\n    n=1;\n    while(n < n_) n *= 2;\n    td.resize(2*n-1,T());\n    dat.resize(2*n-1,D());\n  }\n  \n  inline D merge(const D a,const D b)const{return (a.value + b.value)%mod;}\n  \n  void delay(Int k,Int len){\n    if(td[k].type==0) return;\n    ll type = td[k].type;\n    ll v = td[k].value;\n    td[k].type = 0;\n    td[k].value = 0;\n    len /= 2;\n    {\n      Int l = k*2+1;\n      dat[l].value += v * len;\n      td[l].type = type;\n      td[l].value += v;\n    }\n    {\n      Int r = k*2+2;\n      dat[r].value += v * len;\n      td[r].type = type;\n      td[r].value += v;\n    }\n  }\n\n  D write(Int k, D x, Int len){\n    dat[k].value += x.value * len;\n    td[k].type = 1;\n    td[k].value += x.value;\n    return dat[k];\n  }\n  \n  D dfs(Int a, Int b, D x, bool flag, Int k, Int l, Int r){\n    if(r <= a||b <= l) return flag? dat[k]:returnD;\n    if(a <= l && r <= b) return flag? write(k, x, r - l):dat[k];\n    delay(k, r - l);\n    D vl = dfs(a, b, x, flag, k*2+1, l, (l+r)/2);\n    D vr = dfs(a, b, x, flag, k*2+2, (l+r)/2, r);\n    return flag? (dat[k] = merge(vl, vr)):merge(vl, vr);\n  }\n\n  //[l,r)の値にx加算\n  void add(Int l,Int r,ll x){\n    assert(l <= r);\n    assert(0 <= l && l <= n);\n    assert(0 <= r && r <= n);\n    dfs(l, r, D(x), true, 0, 0, n);\n  }\n  \n  //[l,r)の合計値を得る\n  ll get(Int l,Int r){\n    assert(l <= r);\n    assert(0 <= l && l <= n);\n    assert(0 <= r && r <= n);\n    D res = dfs(l, r, D(), false, 0, 0, n);\n    return res.value;\n  }\n};\n\ntemplate <typename T>\nclass Compress{\npublic:\n  vector<T> X;\n  bool ok;\n  Compress(){};\n  \n  Int size(){return X.size();}\n  void add(T a){ok = false; X.push_back(a); X.push_back(a-1); X.push_back(a+1);}\n  void add(const vector<T> a){for(T x:a) add(x);}\n  //void add(const vector<T> &a){for(T x:a) add(x);}\n  \n  void build(){\n    ok = true;\n    sort(X.begin(),X.end());\n    X.erase(unique(X.begin(),X.end()),X.end());\n  }\n  \n  T getL(T x){assert(ok); return lower_bound(X.begin(),X.end(),x) - X.begin();}\n  T getU(T x){assert(ok); return upper_bound(X.begin(),X.end(),x) - X.begin();}\n};\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  Int n,m;\n  cin>>n>>m;\n  vector<Int>A(n); //Robots\n  cin>>A;\n  vector<Int>B(m); //exits\n  cin>>B;\n\n  auto calc = [&](Int x){\n    Int i = lower_bound(B.begin(), B.end(), x) - B.begin();\n    if( i - 1 < 0 || i == m ) return P(-1, -1);\n    return P(x - B[i-1], B[i] - x);\n  };\n  \n  vector<P> C;\n  Compress <Int> R;\n  for(Int i=0;i<n;i++){\n    Int l, r; tie(l, r) = calc(A[i]);\n    if(l == -1 && r == -1) continue;\n    C.push_back(P(l, -r));\n    R.add(r);\n  }\n  \n  R.add(0); R.build();\n  \n  sort(C.begin(),C.end());\n  C.erase(unique(C.begin(), C.end()), C.end());\n  \n  RSAQ seg(R.size());\n  seg.add(R.getL(0), R.getL(0)+1, 1);\n  \n  for(auto p:C){\n    Int l, r; tie(l, r) = p;\n    r = R.getL(-r);\n    Int sum = seg.get(0, r);\n    seg.add(r, r+1, sum);\n  }\n\n  Int ans = seg.get(0, R.size());\n  cout<<ans<<endl;\n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nconst long long mo=1000000007;\nconst int maxn=200010;\n\nint n,m,gs,x[maxn],y[maxn];\nlong long c[maxn*10],sum[maxn],xx[maxn*10],yy[maxn*10],op[maxn*10],id[maxn*10];\n\nvoid qsort2(int l,int r)\n{\n\tint i=l;int j=r;\n\tint m=yy[(i+j)/2];\n\tint m1=xx[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile ((yy[i]<m) || (yy[i]==m && xx[i]<m1)) i++;\n\t\twhile ((yy[j]>m) || (yy[j]==m && xx[j]>m1)) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(yy[i],yy[j]);\n\t\t\tswap(xx[i],xx[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort2(l,j);\n\tif (r>i) qsort2(i,r); \n}\n\nvoid qsort(int l,int r)\n{\n\tint i=l;int j=r;\n\tint m=yy[(i+j)/2];\n\tint m1=xx[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile ((yy[i]<m) || (yy[i]==m && xx[i]<m1)) i++;\n\t\twhile ((yy[j]>m) || (yy[j]==m && xx[j]>m1)) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(yy[i],yy[j]);\n\t\t\tswap(xx[i],xx[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (r>i) qsort(i,r); \n}\n\nvoid qsort1(int l,int r)\n{\n\tint i=l;int j=r;\n\tint m=op[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (op[i]<m) i++;\n\t\twhile (op[j]>m) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(op[i],op[j]);\n\t\t\tswap(id[i],id[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort1(l,j);\n\tif (r>i) qsort1(i,r); \n}\n\n\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\n\nvoid modify(int i,long long k)\n{\n\twhile (i<=gs)\n\t{\n\t\tc[i]=(c[i]+k)%mo;\n\t\ti+=lowbit(i);\n\t}\n}\n\nlong long getans(int i)\n{\n\tlong long gg=0;\n\tint kk=0;\n\twhile (i>0)\n\t{\n\t\tgg=(gg+c[i])%mo;\n\t\tkk=lowbit(i);\n\t\ti-=kk;\n\t}\n\treturn gg;\n}\n\nint main()\n{\n//\tfreopen(\"data.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tint zd=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&x[i]);\n\t\tzd=max(zd,x[i]);\n\t}\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d\",&y[i]);\n\t\tzd=max(zd,y[i]);\n\t}\n\tint l=1;\n\tgs=2;\n\txx[1]=1;yy[1]=1;\n\txx[2]=zd+1;yy[2]=zd+1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\twhile (x[i]>y[l] && l<=m) l++;\n\t\tif (l>m) break;\n\t\tif (l>1 && x[i]>y[l-1] && x[i]<y[l])\n\t\t{\n\t\t\tgs++;\n\t\t\txx[gs]=x[i]-y[l-1]+1;\n\t\t\tyy[gs]=y[l]-x[i]+1;\n\t\t}\n\t}\n\tqsort(1,gs);\n\tfor (int i=1;i<=gs;i++)\n\t{\n\t\top[i]=xx[i];\n\t\tid[i]=i;\n\t}\n\tqsort1(1,gs);\n\tint js=0;\n\tfor (int i=1;i<=gs;i++)\n\t{\n\t\tif (op[i]!=op[i-1]) js++;\n\t\txx[id[i]]=js;\n\t}\n\tmodify(1,1);\n\tl=2;\n\tint r=2;\n\tint jss=0;\n\tfor (int i=2;i<=gs;i++)\n\t{\n\t\tif (xx[i]==xx[i-1] && yy[i]==yy[i-1])\n\t\t{\n\t\t\txx[i-1]=2000000000;\n\t\t\tyy[i-1]=2000000000;\n\t\t\tjss++;\n\t\t}\n\t}\n\tqsort2(1,gs);\n\tgs-=jss;\n\twhile (l<gs)\n\t{\n\t\twhile (yy[l]==yy[l+1])\n\t\t{\n\t\t\tsum[l]=getans(xx[l]-1);\n\t\t\tl++;\n\t\t}\n\t\tif (yy[l]!=yy[l+1])\n\t\t{\n\t\t\tsum[l]=getans(xx[l]-1);\n\t\t\tl++;\n\t\t}\n\t\twhile (r<l)\n\t\t{\n\t\t\tmodify(xx[r],sum[r]);\n\t\t\tr++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",getans(xx[gs]));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 1e5;\nconst int P = 1e9 + 7;\n\ninline int add(int a, int b) { return a + b >= P ? a + b - P : a + b; }\ninline void inc(int &a, int b) { a = add(a, b); } \n\nint n, m, a[MAXN + 9], b[MAXN + 9];\nstruct Data { int x, y; } p[MAXN + 9];\n\ninline bool cmp(const Data &f, const Data &g) {\n  return f.y == g.y ? f.x > g.x : f.y < g.y;\n}\n\nint ind[MAXN + 9], tot = 0;\n\nvoid Discretize() {\n  std::sort(ind + 1, ind + tot + 1);\n  for (int i = 1; i <= tot; ++i) p[i].x = std::lower_bound(ind + 1, ind + tot + 1, p[i].x) - ind;\n}\n\nstruct BinaryIndexdTree {\n  #define lowbit(x) (x & -x)\n\n  int c[MAXN + 9];\n\n  void Add(int x, int delta) { for (; x <= n; x += lowbit(x)) inc(c[x], delta); }\n\n  int Query(int x) {\n    int res = 0;\n    for (; x; x -= lowbit(x)) inc(res, c[x]);\n    return res;\n  }\n} BIT;\n\nint ans = 1, dp[MAXN + 9];\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= m; ++i) scanf(\"%d\", &b[i]);\n\n  for (int i = 1, j = 1; i < m && j <= n; ++i) {\n    while (j <= n && a[j] <= b[i]) ++j;\n    if (j > n) break;\n    while (j <= n && a[j] < b[i + 1]) {\n      ind[++tot] = a[j] - b[i];\n      p[tot] = (Data){ ind[tot], b[i + 1] - a[j] };\n      ++j;\n    }\n  }\n\n  Discretize();\n\n  std::sort(p + 1, p + tot + 1, cmp);\n\n  for (int i = 1; i <= tot; ++i) {\n    if (p[i].x == p[i - 1].x && p[i].y == p[i - 1].y) continue;\n    dp[i] = add(BIT.Query(p[i].x - 1), 1);\n    inc(ans, dp[i]);\n    BIT.Add(p[i].x, dp[i]);\n  }\n\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Maxn = 200005, p = 1e9 + 7;\nint n, m, ct, tmp_ct, x[Maxn], y[Maxn], a[Maxn];\npair <int, int> P[Maxn];\nlong long sum[Maxn];\nvector <int> Ve[Maxn];\nint lowbit(int x)\n{\n\treturn x & -x;\n}\nvoid add(int x, int y)\n{\n\tfor (int i = x; i <= tmp_ct + 1; i += lowbit(i))\n\t\t(sum[i] += y) %= p;\n}\nlong long ask(int x)\n{\n\tlong long tmp = 0;\n\tfor (int i = x; i; i -= lowbit(i))\n\t\t(tmp += sum[i]) %= p;\n\treturn tmp;\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &x[i]);\n\tfor (int i = 1; i <= m; i++)\n\t\tscanf(\"%d\", &y[i]);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (x[i] < y[1] || x[i] > y[m]) continue;\n\t\tint pos = upper_bound(y + 1, y + 1 + m, x[i]) - y;\n\t\tP[++ct] = make_pair(y[pos] - x[i], x[i] - y[pos - 1]);\n\t}\n\tsort(P + 1, P + 1 + ct);\n\tfor (int i = 1; i <= ct; i++)\n\t\ta[2 * i - 1] = P[i].first, a[2 * i] = P[i].second;\n\tsort(a + 1, a + 1 + 2 * ct);\n\ttmp_ct = unique(a + 1, a + 1 + 2 * ct) - a - 1;\n\tfor (int i = 1; i <= ct; i++)\n\t{\n\t\tP[i].first = lower_bound(a + 1, a + 1 + tmp_ct, P[i].first) - a;\n\t\tP[i].second = lower_bound(a + 1, a + 1 + tmp_ct, P[i].second) - a;\n\t\tVe[P[i].first].push_back(P[i].second);\n\t}\n\tadd(1, 1);\n\tfor (int i = 1; i <= tmp_ct; i++)\n\t{\n\t\tint las = 0;\n\t\tfor (vector <int> :: reverse_iterator it = Ve[i].rbegin(); it != Ve[i].rend(); it++)\n\t\t\tif (*it != las) add(*it + 1, ask(*it)), las = *it;\n\t}\n\tprintf(\"%lld\", ask(tmp_ct + 1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5,mod=1e9+7,low=1;\nint n,m,tot,a[N],b[N],d[N],t[N],dp[N];\nstruct node\n{\n    int x,y;\n    bool operator==(const node&o)const\n    {\n        return x==o.x&&y==o.y;\n    }\n    bool operator<(const node&o)const\n    {\n        return x==o.x?y<o.y:x<o.x;\n    }\n}c[N];\nvoid add(int x,int v)\n{\n    x+=low;\n    while(x<=tot+low)\n    {\n        t[x]+=v;\n        x+=x&-x;\n    }\n}\nint query(int x)\n{\n    ll ans=0;\n    x+=low;\n    while(x)\n    {\n        ans=(ans+t[x])%mod;\n        x-=x&-x;\n    }\n    return ans;\n}\nvector<int>v;\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    for(int i=1;i<=m;i++) scanf(\"%d\",&b[i]);\n    for(int i=1;i<=n;i++)\n    {\n        int p1=lower_bound(b+1,b+1+m,a[i])-b-1;\n        int p2=lower_bound(b+1,b+1+m,a[i])-b;\n        if(p1<1||p2>m) continue;\n        c[++tot]={a[i]-b[p1],b[p2]-a[i]};\n    }\n    sort(c+1,c+1+tot);\n    tot=unique(c+1,c+1+tot)-c-1;\n    for(int i=1;i<=tot;i++)\n        d[i]=c[i].y;\n    sort(d+1,d+1+tot);\n    int cnt=unique(d+1,d+1+tot)-d-1;\n    for(int i=1;i<=tot;i++)\n        c[i].y=lower_bound(d+1,d+1+cnt,c[i].y)-d;\n    dp[0]=1;\n    v.push_back(0);\n    for(int i=1;i<=n;i++)\n    {\n        if(c[i].x!=c[i-1].x)\n        {\n            for(int j=0;j<v.size();j++)\n                add(c[v[j]].y,dp[v[j]]);\n            v.clear();\n        }\n        dp[i]=query(c[i].y-1);\n        v.push_back(i);\n    }\n    ll ans=0;\n    for(int i=0;i<=tot;i++)\n        ans=(ans+dp[i])%mod;\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int mod=1000000007;\n\ninline int qpow(int a,int b) {\n    int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod)\n        if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nint main() {\n    int n=read(),m=read();\n    printf(\"%d\\n\",qpow(2,m-1));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\nconst int MOD = 1000000007;\nusing mint = Fp<MOD>;\n\n\ntemplate <class Abel> struct BIT {\n    const Abel UNITY_SUM = 0;                       // to be set\n    vector<Abel> dat;\n    \n    /* [1, n] */\n    BIT(int n) : dat(n + 1, UNITY_SUM) { }\n    void init(int n) { dat.assign(n + 1, UNITY_SUM); }\n    \n    /* a is 1-indexed */\n    inline void add(int a, Abel x) {\n        for (int i = a; i < (int)dat.size(); i += i & -i)\n            dat[i] = dat[i] + x;\n    }\n    \n    /* [1, a], a is 1-indexed */\n    inline Abel sum(int a) {\n        Abel res = UNITY_SUM;\n        for (int i = a; i > 0; i -= i & -i)\n            res = res + dat[i];\n        return res;\n    }\n    \n    /* [a, b), a and b are 1-indexed */\n    inline Abel sum(int a, int b) {\n        return sum(b - 1) - sum(a - 1);\n    }\n    \n    /* debug */\n    void print() {\n        for (int i = 1; i < (int)dat.size(); ++i) cout << sum(i, i + 1) << \",\";\n        cout << endl;\n    }\n};\n\n\nconst long long INF = 1LL<<55;\nusing pll = pair<long long,long long>;\n\n// 入力\nint N, M;\nvector<long long> x, y, v, uv;\nvector<pll> lrs;\n\nmint solve() {\n    // 区間に変換\n    vector<pll> lrs;\n    vector<long long> uright;\n    for (int i = 0; i < N; ++i) {\n        int it = lower_bound(y.begin(), y.end(), x[i]) - y.begin();\n        if (it == 0 || it == M) continue; // 両端は一意なので除く\n        lrs.push_back(pll(y[it-1] - x[i], y[it] - x[i]));\n        uright.push_back(y[it] - x[i]);\n    }\n\n    // 区間ソート\n    sort(lrs.begin(), lrs.end());\n    lrs.erase(unique(lrs.begin(), lrs.end()), lrs.end()); // 同一の区間は除く\n    sort(uright.begin(), uright.end());\n    uright.erase(unique(uright.begin(), uright.end()), uright.end());\n    int s = uright.size();\n\n    //COUT(v);\n    BIT<mint> bit(N+10);\n    bit.add(s+1, 1);\n    for (auto lr : lrs) {\n        int k = lower_bound(uright.begin(), uright.end(), lr.second)\n            - uright.begin();\n        ++k;\n        mint sum = bit.sum(k+1, s+2);\n        bit.add(k, sum);\n\n        //COUT(vi); COUT(k); COUT(sum); bit.print();\n    }\n    return bit.sum(1, s+2);\n}\n\nint main() {\n    while (cin >> N >> M) {\n        x.resize(N); y.resize(M);\n        for (int i = 0; i < N; ++i) cin >> x[i];\n        for (int i = 0; i < M; ++i) cin >> y[i];\n        cout << solve() << endl;\n    }\n}\n            \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 100010\n#define mo 1000000007\nint i,j,k,ans,m,n,x,y,t[N],a[N],b[N],c[N],cnt,f[N];\ninline int ask(int x) {\n    int ans = 0;\n    for (; x; x -= x & -x)(ans += t[x]) %= mo;\n    return ans;\n}\ninline void add(int x,int d) {\n    for (; x <= cnt; x += x & -x)(t[x] += d) %= mo;\n}\nstruct dist {\n    int x, y;\n\n    inline bool operator<(const dist &b) const {\n        return x < b.x || (x == b.x && y > b.y);\n    }\n\n    inline bool operator==(const dist &b) const {\n        return x == b.x && y == b.y;\n    }\n}e[N];\nint main() {\n    cin >> n >> m;\n    for (i = 1; i <= n; ++i)cin >> a[i];\n    for (i = 1; i <= m; ++i)cin >> b[i];\n    for (i = j = 1; i < m && j <= n; ++i) {\n        for (; j <= n && a[j] <= b[i]; ++j);\n        if (j > n)break;\n        for (; j <= n && a[j] < b[i + 1]; ++j)e[++cnt] = (dist) {b[i + 1] - a[j], c[++*c] = a[j] - b[i]};\n    }\n    sort(c + 1, c + *c + 1);\n    for (i = 1; i <= cnt; ++i)e[i].y = lower_bound(c + 1, c + *c + 1, e[i].y) - c;\n    sort(e + 1, e + cnt + 1), cnt = unique(e + 1, e + cnt + 1) - e - 1;\n    for (ans = i = 1; i <= cnt; ++i) {\n        f[i] = (ask(e[i].y - 1) + 1) % mo;\n        (ans += f[i]) %= mo, add(e[i].y, f[i]);\n    }\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\nll rand_int(ll l, ll r) //[l, r]\n{\n    static mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int maxn=2e5+7;\nconst int mod=1e9+7;\nll tree[maxn];\nvoid add(int x,ll val)\n{\n    while(x<maxn)\n    {\n        tree[x]=(tree[x]+val)%mod;\n        x+=x&-x;\n    }\n}\nll query(int x)\n{\n    ll ret=0;\n    while(x)\n    {\n        ret=(ret+tree[x])%mod;\n        x-=x&-x;\n    }\n    return ret;\n}\n\npi all[maxn*2];\nint L[maxn],R[maxn];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,m;\n    cin>>n>>m;\n    for(int i=0;i<n;i++)\n    {\n        cin>>all[i].first;\n        all[i].second=0;\n    }\n    for(int i=0;i<m;i++)\n    {\n        cin>>all[i+n].first;\n        all[i+n].second=1;\n    }\n    sort(all,all+n+m);\n    {\n        int cur=0;\n        for(int i=0;i<m+n;i++)\n        {\n            if(all[i].second) cur=all[i].first;\n            else{\n                if(cur) L[i]=all[i].first-cur;\n            }\n        }\n    }\n    {\n        int cur=0;\n        for(int i=m+n-1;i>=0;i--)\n        {\n            if(all[i].second) cur=all[i].first;\n            else{\n                if(cur) R[i]=cur-all[i].first;\n            }\n        }\n    }\n    vc<pi> pt;\n    vi pos;\n    for(int i=0;i<n+m;i++)\n    {\n        if(L[i]&&R[i]) {\n            pt.emplace_back(L[i],R[i]);\n            //dbg(i,L[i],R[i]);\n            pos.push_back(R[i]);\n        }\n    }\n    mkuni(pt);\n    sort(pt.begin(),pt.end(),[&](pi a,pi b){if(a.first==b.first)return a.second>b.second;return a.first<b.first;});\n    pos.push_back(0);\n    mkuni(pos);\n    auto getid=[&](int x)\n    {\n        return lower_bound(pos.begin(),pos.end(),x)-pos.begin()+1;\n    };\n    add(getid(0),1);\n    for(auto u:pt)\n    {\n        ll cur=query(getid(u.second)-1);\n        add(getid(u.second),cur);\n    }\n    print(query(maxn-1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <set>\n#include <vector>\nconst int inf=2147483647;\nconst int mo=1e9+7;\nconst int N=100005;\nusing namespace std;\ntypedef pair<int,int> par;\nint n,m,a[N],b[N],tot,d[N],t,t2;\npar c[N];\nlong long sum[N];\nint too(int x)\n{\n\treturn x&-x;\n}\nvoid put(int x,long long v)\n{\n    for(;x<=t2;x+=too(x)) sum[x]=(sum[x]+v)%mo;\n}\nlong long find(int x)\n{\n    long long s=0;\n    for(;x;x-=too(x)) s=(s+sum[x])%mo;\n    return s;\n}\nbool cmp(par x,par y)\n{\n\treturn x.first<y.first || (x.first==y.first && x.second>y.second);\n}\nint main()\n{\n\t//freopen(\"arc101e.in\",\"r\",stdin);\n\t//freopen(\"arc101e.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++) scanf(\"%d\",&b[i]);\n\tfor(int i=1;i<=n;i++)\n\tif(a[i]>b[1] && a[i]<b[m])\n\t{\n\t\tint p=lower_bound(b+1,b+1+m,a[i])-b;\n\t\tif(b[p]==a[i]) continue;\n\t\tc[++t]=par(a[i]-b[p-1],b[p]-a[i]);\n\t\td[++t2]=b[p]-a[i];\n\t}\n\tsort(d+1,d+t2+1);\n\tt2=unique(d+1,d+t2+1)-d-1;\n\tfor(int i=1;i<=t;i++) c[i].second=lower_bound(d+1,d+t2+1,c[i].second)-d;\n\tsort(c+1,c+t+1,cmp);\n\tt=unique(c+1,c+t+1)-c-1;\n\tlong long ans=1;\n\tfor(int i=1;i<=t;i++)\n\t{\n\t\tlong long s=find(c[i].second-1)+1;\n\t\tans=(ans+s)%mo;\n\t\tput(c[i].second,s);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define sc second\n#define fi first\n#define pii pair <int,int>\n#define ll long long\n#define lowbit(a) a&-a\nusing namespace std;\n\ninline int read(){\n\tint sum=0,f=1;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=sum*10+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\n\nconst int N=100005;\nconst int Mod=1e9+7;\nint n,m,a[N],b[N],d[N],t1,t2;\nll t[N],ans=1;\npair <int,int> c[N];\n\ninline void add(int x,ll k){\n\tfor(int i=x;i<=t2;i+=lowbit(i)) t[i]=(t[i]+k)%Mod;\t\n}\n\ninline ll ask(int x){\n\tll ret=0;\n\tfor(int i=x;i;i-=lowbit(i)) ret=(ret+t[i])%Mod;\n\treturn ret;\n}\n\nbool cmp(pii a,pii b){return a.fi!=b.fi? a.fi<b.fi:a.sc>b.sc;}\n\nsigned main(){\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tfor(int i=1;i<=m;i++) b[i]=read();\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]<=b[1]||a[i]>=b[m]) continue;\n\t\tint k=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif(a[i]==b[k]) continue;\n\t\tc[++t1]=pii(a[i]-b[k-1],b[k]-a[i]);d[++t2]=b[k]-a[i];\n\t}\n\tsort(d+1,d+t2+1);int l=unique(d+1,d+t2+1)-d-1;\n\tfor(int i=1;i<=t1;i++){\n\t\tc[i].second=lower_bound(d+1,d+l+1,c[i].second)-d;\n\t}\n\tsort(c+1,c+t1+1,cmp);t1=unique(c+1,c+t1+1)-c-1;\n\tfor(int i=1;i<=t1;i++){\n\t\tll sum=ask(c[i].sc-1)+1;\n\t\tans=(ans+sum)%Mod;add(c[i].sc,sum);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\nconst ll mod = 1000000007;\nstruct SegmentTree {\nprivate:\n    int n;\n    vector<int> node;\n \npublic:\n    SegmentTree() {\n        int sz = 200010;\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1, 0);\n        for(int i=0; i<sz; i++) node[i+n-1] = 0;\n        for(int i=n-2; i>=0; i--) node[i] = min(node[2*i+1], node[2*i+2]);\n    }\n \n    void add(int x, int val) {\n        x += (n - 1);\n        node[x] += val;\n        node[x] %= mod;\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node[x] = (node[2*x+1] + node[2*x+2]) % mod;\n        }\n    }\n    // hannkaikukann \n    int getsum(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return 0;\n        if(a <= l && r <= b) return node[k];\n \n        int vl = getsum(a, b, 2*k+1, l, (l+r)/2);\n        int vr = getsum(a, b, 2*k+2, (l+r)/2, r);\n        return (vl + vr) % mod;\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, M;\n    cin >> N >> M;\n    vector<int> x(N);\n    for(int i = 0; i < N; i++) {\n        cin >> x[i];\n    }\n    vector<int> y(M);\n    for(int i = 0; i < M; i++) {\n        cin >> y[i];\n    }\n    vector<i_i> v;\n    vector<int> xcmp, ycmp;\n    for(int i = 0; i < N; i++) {\n        auto itr = lower_bound(y.begin(), y.end(), x[i]);\n        if(itr == y.begin() or itr == y.end()) continue;\n        i_i tmp;\n        tmp.second = *itr - x[i];\n        itr--;\n        tmp.first = x[i] - *itr;\n        tmp.first *= -1;\n        v.push_back(tmp);\n        xcmp.push_back(tmp.first);\n        ycmp.push_back(tmp.second);\n    }\n    sort(xcmp.begin(), xcmp.end());\n    xcmp.erase(unique(xcmp.begin(), xcmp.end()), xcmp.end());\n    sort(ycmp.begin(), ycmp.end());\n    ycmp.erase(unique(ycmp.begin(), ycmp.end()), ycmp.end());\n    for(int i = 0; i < v.size(); i++) {\n        auto itr = lower_bound(xcmp.begin(), xcmp.end(), v[i].first);\n        v[i].first = itr - xcmp.begin();\n        itr = lower_bound(ycmp.begin(), ycmp.end(), v[i].second);\n        v[i].second = itr - ycmp.begin();\n    }\n    sort(v.begin(), v.end(), greater<i_i>());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    SegmentTree seg;\n    seg.add(0, 1);\n    for(auto tmp : v) {\n        int val = seg.getsum(0, tmp.second + 1);\n        seg.add(tmp.second + 1, val);\n    }\n    cout << seg.getsum(0, v.size() + 1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define maxn 100005\n#define mo 1000000007\n#define ll long long \nusing namespace std;\n\nint n,m,i,j,k,x[maxn],y[maxn],tot,id[maxn],cnt;\nstruct arr{int x,y,i;} a[maxn];\nint cmp(arr a,arr b){return a.x<b.x||a.x==b.x&&a.y<b.y;}\nint cmp2(int i,int j){return a[i].y<a[j].y;}\n\nstruct Treearray{\n\tll s[maxn];\n\tvoid add(int x,ll d){for(;x<=cnt;x+=x&-x) (s[x]+=d)%=mo;}\n\tll sum(int x,ll S=0){for(;x;x-=x&-x) (S+=s[x])%=mo; return S;}\n} t;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tfor(i=1;i<=m;i++) scanf(\"%d\",&y[i]);\n\tk=0;\n\tfor(i=1;i<=n;i++) {\n\t\twhile (k<m&&x[i]>y[k]) k++;\n\t\tif (x[i]>=y[k]||k==1) continue;\n\t\ttot++,a[tot].x=x[i]-y[k-1],a[tot].y=y[k]-x[i];\n\t}\n\tsort(a+1,a+1+tot,cmp);\n\tfor(i=1;i<=tot;i++) id[i]=i;\n\tsort(id+1,id+1+tot,cmp2);\n\tcnt=1;\n\tfor(i=1;i<=tot;i++) {\n\t\tcnt+=(i==1||a[id[i]].y!=a[id[i-1]].y);\n\t\ta[id[i]].i=cnt;\n\t}\n\tt.add(1,1);\n\tfor(i=1;i<=tot;i=j) {\n\t\tfor(j=i;j<=tot&&a[j].x==a[i].x;j++);\n\t\tfor(k=j-1;k>=i;k--) if (k==j-1||a[k].y<a[k+1].y)\n\t\t\tt.add(a[k].i,t.sum(a[k].i-1));\n\t}\n\tprintf(\"%lld\",t.sum(cnt));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100010, mod = 1e9 + 7;\n\nint sum[N << 2];\n\ninline void Inc(int &x, int y) {\n\tx += y, x -= x >= mod ? mod : 0;\n}\n\nvoid update(int rt, int l, int r, int x, int y) {\n\tInc(sum[rt], y);\n\tif (l == r) return;\n\tint mid = (l + r) >> 1;\n\tif (x <= mid) update(rt << 1, l, mid, x, y);\n\telse update(rt << 1 | 1, mid + 1, r, x, y);\n} \n\nint query(int rt, int l, int r, int start, int end) {\n\tif (start <= l && r <= end) return sum[rt];\n\tint res = 0, mid = (l + r) >> 1;\n\tif (start <= mid) Inc(res, query(rt << 1, l, mid, start, end));\n\tif (end > mid) Inc(res, query(rt << 1 | 1, mid + 1, r, start, end));\n\treturn res;\n}\n\nint x[N], y[N], val[N], tot;\n\nstruct Point {\n\tint x, y;\n} p[N];\n\nint main() {\n\tint n, m; scanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &x[i]);\n\tfor (int i = 1; i <= m; i++) scanf(\"%d\", &y[i]);\n\tsort(y + 1, y + m + 1); int all = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint a = lower_bound(y + 1, y + m + 1, x[i]) - y;\n\t\tif (a > m || a == 1) continue;\n\t\tp[++all] = (Point){x[i] - y[a - 1], y[a] - x[i]}, val[++tot] = y[a] - x[i];\n\t}\n\tsort(val + 1, val + tot + 1), tot = unique(val + 1, val + tot + 1) - val - 1; \n\tsort(p + 1, p + all + 1, [](Point a, Point b){\n\t\tif (a.x == b.x) return a.y > b.y;\n\t\treturn a.x < b.x;\n\t});\n\tupdate(1, 0, tot, 0, 1);\n\tfor (int i = 1; i <= all; i++) {\n\t\tp[i].y = lower_bound(val + 1, val + tot + 1, p[i].y) - val;\n\t\tif (i && p[i].x == p[i - 1].x && p[i].y == p[i - 1].y) continue;\n\t\tupdate(1, 0, tot, p[i].y, query(1, 0, tot, 0, p[i].y - 1));\n\t}\n\tprintf(\"%d\\n\", query(1, 0, tot, 0, tot));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int N=1e5+10,MOD=1e9+7;\nint plu(int x,int y){return (1LL*x+y)-(1LL*x+y>=MOD?MOD:0);}\nnamespace BIT{/*{{{*/\n\tint c[N*2];\n\tint mx;\n\tvoid init(int _n){mx=_n;}\n\tvoid insert(int x,int delta){for (;x<=mx;x+=x&-x) c[x]=plu(c[x],delta);}\n\tint query(int x){\n\t\tif (x<=0) return 0;\n\t\tint ret=0;\n\t\tfor (;x;x-=x&-x) ret=plu(ret,c[x]);\n\t\treturn ret;\n\t}\n}/*}}}*/\nstruct Dot{\n\tint x,y;\n\tDot(){}\n\tDot(int x1,int y1){x=x1; y=y1;}\n\tfriend bool operator < (Dot x,Dot y){return x.x==y.x?x.y<y.y:x.x<y.x;}\n\tfriend bool operator == (Dot x,Dot y){return x.x==y.x&&x.y==y.y;}\n}d[N];\nint lis[N*2];\nint a[N],b[N];\nint f[N*2];\nint n,m,cnt;\nvoid prework(){\n\tint nxt,pre;\n\tcnt=0;\n\tfor (int i=1;i<=n;++i){\n\t\tif (a[i]<b[1]) continue;\n\t\tif (a[i]>b[m]) break;\n\t\tnxt=lower_bound(b+1,b+1+m,a[i])-b;\n\t\tif (a[i]==b[nxt]) continue;\n\t\tpre=nxt-1;\n\t\td[++cnt]=Dot(a[i]-b[pre],b[nxt]-a[i]);\n\t\tlis[++lis[0]]=a[i]-b[pre];\n\t\tlis[++lis[0]]=b[nxt]-a[i];\n\t}\n\tsort(lis+1,lis+1+lis[0]);\n\tlis[0]=unique(lis+1,lis+1+lis[0])-lis-1;\n\tfor (int i=1;i<=cnt;++i){\n\t\t//printf(\"%d %d\\n\",d[i].x,d[i].y);\n\t\td[i].x=lower_bound(lis+1,lis+1+lis[0],d[i].x)-lis;\n\t\td[i].y=lower_bound(lis+1,lis+1+lis[0],d[i].y)-lis;\n\t}\n\tBIT::init(lis[0]);\n}\nvoid dp(){\n\tsort(d+1,d+1+cnt);\n\tcnt=unique(d+1,d+1+cnt)-d-1;\n\tmemset(f,0,sizeof(f));\n\tint now=1,ans=1;\n\tfor (int i=1;i<=cnt;++i){\n\t\twhile (d[now].x<d[i].x) BIT::insert(d[now].y,f[now]),++now;\n\t\tf[i]=plu(1,BIT::query(d[i].y-1));\n\t\tans=plu(ans,f[i]);\n\t\t//printf(\"%d %d %d\\n\",d[i].x,d[i].y,f[i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n#ifndef ONLINE_JUDGE\n\t//freopen(\"a.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;++i) scanf(\"%d\",a+i);\n\tfor (int i=1;i<=m;++i) scanf(\"%d\",b+i);\n\tprework();\n\tdp();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\n#define per(i,a,b) for (int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\n\ninline int read() {\n    int x=0,f=1; char ch=getchar();\n    while (!(ch>='0'&&ch<='9')) {if (ch=='-')f=-1;ch=getchar();}\n    while (ch>='0'&&ch<='9') {x=x*10+(ch-'0'); ch=getchar();}\n    return x*f;\n}\n\nconst int N = 100005;\nconst int MOD = 1000000007;\n\n\nint n,m;\nint x[N],y[N],tmp[N];\nint tot=0;\nPII a[N];\nLL dp[N],sum[N];\n\ninline void ins(int x,LL val) {while (x<=tot) {sum[x]+=val; x+=x&-x;}}\ninline LL query(int x) {LL ret=0; while (x) {ret+=sum[x]; x-=x&-x;} return ret%MOD;}\n\ninline bool cmp(const PII &a,const PII &b) {return (a.first==b.first)?(a.second>b.second):(a.first<b.first);}\n\nint main() {\n\n\t#ifndef ONLINE_JUDGE\n\t//\tfreopen(\"data.in\",\"r\",stdin);\n\t//\tfreopen(\"data.out\",\"w\",stdout);\n\t#endif\n\n\tn=read(),m=read();\n\trep(i,1,n) x[i]=read(); rep(i,1,m) y[i]=read();\n\tsort(x+1,x+n+1); sort(y+1,y+m+1);\n\trep(i,1,n) {\n\t\tif (x[i]<y[1]||x[i]>y[m]) continue;\n\t\tint pos=lower_bound(y+1,y+m+1,x[i])-y;\n\t\ta[++tot]=PII(x[i]-y[pos-1],y[pos]-x[i]);\n\t}\n\tsort(a+1,a+tot+1,cmp); tot=unique(a+1,a+tot+1)-a-1;\n\trep(i,1,tot) tmp[i]=a[i].second; sort(tmp+1,tmp+tot+1);\n\tint num=unique(tmp+1,tmp+tot+1)-tmp-1;\n\trep(i,1,tot) {\n\t\ta[i].second=lower_bound(tmp+1,tmp+num+1,a[i].second)-tmp;\n\t\tdp[i]=query(a[i].second-1)+1;\n\t\tins(a[i].second,dp[i]);\n\t}\n\tLL ans=0; rep(i,1,tot) ans+=dp[i];\n\tprintf(\"%lld\\n\",(ans+1)%MOD);\n\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n\t}\n\t// input a letter\n\ttemplate <class I>\n\tinline void get (I &x) {\n\t\tfor (c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tx = c;\n\t}\n\t// input a string\n\tinline void read (char *s){\n\t\tfor(c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tfor(; c >= 'A' && c <= 'Z'; c = gc()) *++s = c;\n\t\t*++s = '\\0';\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: gi;\nusing io :: get;\nusing io :: read;\nusing io :: putc;\nusing io :: print;\nconst int N=1e5+5,mod=1e9+7;\nint ny,a[N],b[N],px[N],py[N],f[N];\n#define pii pair<int,int>\n#define mp make_pair\n#define fi first\n#define se second\npii p[N];\ninline void add(int &x,ri y){\n\tx=(x+=y)>=mod?x-mod:x;\n}\nstruct bitree{\n\tint v[N];\n\tinline void upd(ri i,ri x){\n\t\tfor(;i<=ny;i+=i&-i)\n\t\t\tadd(v[i],x);\n\t}\n\tinline int query(ri i){\n\t\tri s=0;\n\t\tfor(;i;i-=i&-i)\n\t\t\tadd(s,v[i]);\n\t\treturn s;\n\t}\n}bit;\nint main(){\n\tri n,m,i,cnt,nx,ans;\n\tgi(n);gi(m);\n\tfor(i=1;i<=n;++i) gi(a[i]);\n\tfor(i=1;i<=m;++i) gi(b[i]);\n\tcnt=0;\n\tfor(i=1;i<=n;++i){\n\t\tif(a[i]<=b[1]||a[i]>=b[m]) continue;\n\t\tp[++cnt]=mp(b[lower_bound(b+1,b+1+m,a[i])-b]-a[i],a[i]-b[upper_bound(b+1,b+1+m,a[i])-b-1]);\n\t}\n//\tfor(i=1;i<=cnt;++i) printf(\"%d %d\\n\",p[i].fi,p[i].se);\n\tfor(i=1;i<=cnt;++i) px[i]=p[i].fi,py[i]=p[i].se;\n\tsort(px+1,px+1+cnt);\n\tsort(py+1,py+1+cnt);\n\tnx=unique(px+1,px+1+cnt)-px-1;\n\tny=unique(py+1,py+1+cnt)-py-1;\n\tfor(i=1;i<=cnt;++i)\n\t\tp[i].fi=lower_bound(px+1,px+1+nx,p[i].fi)-px,\n\t\tp[i].se=lower_bound(py+1,py+1+ny,p[i].se)-py;\n\tsort(p+1,p+1+cnt,[&](pii a,pii b){\n\t\treturn a.fi==b.fi?a.se>b.se:a.fi<b.fi; \n\t});\n\tcnt=unique(p+1,p+1+cnt)-p-1; \n//\tfor(i=1;i<=cnt;++i) printf(\"%d %d\\n\",p[i].fi,p[i].se);\n\tans=1; // (0,0) -> (inf,inf)\n\tfor(i=1;i<=cnt;++i)\n\t\tf[i]=1+bit.query(p[i].se-1),\n\t//\tprintf(\"f %d %d\\n\",i,f[i]),\n\t\tbit.upd(p[i].se,f[i]),\n\t\tadd(ans,f[i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<set>\n#include<cassert>\nusing namespace std;\nconst int N=100005,mod=1000000007;\nint n,m,k,ans=1,pos[N],a[N],b[N],c[N],x[N],y[N],h[N],f[N];\nset<int> s;\nbool cmp(int a,int b){\n\treturn x[a]==x[b]?y[a]>y[b]:x[a]<x[b];\n}\nvoid add(int i,int v){\n\twhile(i<=h[0]){\n\t\tc[i]=(c[i]+v)%mod;\n\t\ti+=i&(-i);\n\t}\n}\nint sum(int i){\n\tint res=0;\n\twhile(i){\n\t\tres=(res+c[i])%mod;\n\t\ti-=i&(-i);\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d\",&b[i]);\n\t\ts.insert(b[i]);\n\t}\n\tset<int>::iterator it;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]>b[1]&&a[i]<b[m]&&!s.count(a[i])){\n\t\t\tit=s.upper_bound(a[i]);\n\t\t\tk++;\n\t\t\tpos[k]=k;\n\t\t\ty[k]=*it-a[i];\n\t\t\tit--;\n\t\t\tx[k]=a[i]-*it;\n\t\t\th[++h[0]]=y[i];\n\t\t}\n\t}\n\tsort(pos+1,pos+k+1,cmp);\n\tsort(h+1,h+h[0]+1);\n\th[0]=unique(h+1,h+h[0]+1)-h-1;\n\tfor(int i,j=1;j<=k;j++){\n\t\ti=pos[j];\n\t\tif(x[i]==x[pos[j-1]]&&y[i]==y[pos[j-1]]){\n\t\t\tcontinue;\n\t\t}\n\t\ty[i]=lower_bound(h+1,h+h[0]+1,y[i])-h;\n\t\tf[i]=(sum(y[i]-1)+1)%mod;\n\t\tans=(ans+f[i])%mod;\n\t\tadd(y[i],f[i]);\n\t}\n\tassert(ans>=1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace TYC\n{\n\ttypedef long long ll;\n\n\tconst int N = 2e5 + 5, mod = 1e9 + 7;\n\n\tint n, m, cnt, A[N], B[N], R[N], X[N], Y[N], C[N];\n\tvector<int> P[N];\n\n\tinline int read()\n\t{\n\t\tint x = 0, f = 0, ch = getchar();\n\t\twhile (!isdigit(ch))\n\t\t\tf |= (ch == '-'), ch = getchar();\n\t\twhile (isdigit(ch))\n\t\t\tx = x * 10 + ch - '0', ch = getchar();\n\t\treturn f ? -x : x;\n\t}\n\n\tvoid init()\n\t{\n\t\tint num = 0;\n\t\tfor (int i = 1, j = 0; i <= n; i++)\n\t\t\tif (B[1] < A[i] && A[i] < B[m])\n\t\t\t{\n\t\t\t\twhile (j < m && B[j + 1] <= A[i])\n\t\t\t\t\tj++;\n\t\t\t\tint x = A[i] - B[j], y = B[j + 1] - A[i];\n\t\t\t\tif (x && y)\n\t\t\t\t{\n\t\t\t\t\tR[++cnt] = X[++num] = x;\n\t\t\t\t\tR[++cnt] = Y[num] = y;\n\t\t\t\t}\n\t\t\t}\n\t\tsort(R + 1, R + 1 + cnt);\n\t\tcnt = unique(R + 1, R + 1 + cnt) - R - 1;\n\t\tfor (int i = 1; i <= num; i++)\n#define id(x) (lower_bound(R + 1, R + 1 + cnt, x) - R)\n\t\t\tP[id(X[i])].push_back(id(Y[i]));\n#undef id\n\t\tfor (int i = 1; i <= cnt; i++)\n\t\t{\n\t\t\tsort(P[i].begin(), P[i].end(), greater<int>());\n\t\t\tP[i].resize(unique(P[i].begin(), P[i].end()) - P[i].begin());\n\t\t}\n\t\t++cnt;\n\t\tP[cnt].push_back(cnt);\n\t}\n\n#define lowbit(x) (x & (-x))\n\n\tinline int query(int x)\n\t{\n\t\tint sum = 0;\n\t\tfor (; x; x -= lowbit(x))\n\t\t\tsum = (sum + C[x]) % mod;\n\t\treturn sum;\n\t}\n\n\tinline void add(int x, const int v)\n\t{\n\t\tfor (; x <= cnt; x += lowbit(x))\n\t\t\tC[x] = (C[x] + v) % mod;\n\t}\n\n#undef lowbit\n\n\tvoid work()\n\t{\n\t\tn = read(), m = read();\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tA[i] = read();\n\t\tfor (int i = 1; i <= m; i++)\n\t\t\tB[i] = read();\n\t\tinit();\n\t\tfor (int i = 1; i <= cnt; i++)\n\t\t\tfor (int p : P[i])\n\t\t\t\tadd(p, query(p - 1) + 1);\t\n\t\tprintf(\"%d\\n\", query(cnt) - query(cnt - 1));\n\t}\n}\n\nint main()\n{\n\tTYC::work();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// IOI 2021\n#include <bits/stdc++.h>\nusing namespace std;\n\n//#define endl '\\n'\n#define ends ' '\n#define die(x) return cout << x << endl, 0\n#define all(v) v.begin(), v.end()\n#define sz(x) (int)(x.size())\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) { cerr << ends << H; debug_out(T...); }\n#define debug(...) cerr << \"{\" << #__VA_ARGS__ << \"}:\", debug_out(__VA_ARGS__)\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n \n////////////////////////////////////////////////////////////////////\n\nconst int N = 1e5 + 5;\n\nint X[N], Y[N], FEN[N];\nvector<pii> P;\nvector<int> C;\n\nbool CMP(pii a, pii b) { return a.first == b.first ? a.second > b.second : a.first < b.first; }\nvoid Add(int p, int x) { for (p++; p < N; p += p & -p) FEN[p] = (FEN[p] + x) % MOD; }\nint Get(int p) {\n\tint res = 0;\n\tfor (; p > 0; p -= p & -p) res = (res + FEN[p]) % MOD;\n\treturn res;\n}\n\nint main() {\n\n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tmt19937 Rnd(time(0));\n\t\n\tint n, m; cin >> n >> m;\n\tfor (int i = 0; i < n; i++) cin >> X[i];\n\tfor (int i = 0; i < m; i++) cin >> Y[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tint e = lower_bound(Y, Y + m, X[i]) - Y;\n\t\tif (e == 0 || e == m) continue;\n\t\tint l = X[i] - Y[e - 1], r = Y[e] - X[i];\n\t\tP.push_back(make_pair(l, r));\n\t\tC.push_back(r);\n\t}\n\tsort(all(C)), sort(all(P), CMP);\n\tC.resize(unique(all(C)) - C.begin());\n\tP.resize(unique(all(P)) - P.begin());\n\tAdd(0, 1);\n\tfor (auto [l, r] : P) {\n\t\tint rc = lower_bound(all(C), r) - C.begin() + 1;\n\t\tAdd(rc, Get(rc));\n\t}\n\tcout << Get(N - 1) << endl;\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\nconst int maxn = 4e5 + 7;\nconst int somod = 1e9 + 7;\nint n, le[maxn], ri[maxn], m, BIT[maxn];\npair<int, int> p[maxn];\n\nvector<int> val = {0};\nvector<pair<int, int>> val1;\nvoid add(int &a, int b)\n{\n   a += b;\n   if(a >= somod) a -= somod;\n}\n\nint Find(int x)\n{\n   return (int)(lower_bound(val.begin(), val.end(), x) - val.begin());\n}\n\nvoid Update(int pos, int val)\n{\n   for(; pos < maxn; pos += pos & -pos)\n   {\n      add(BIT[pos], val);\n   }\n}\n\nint Query(int pos)\n{\n   int ans = 0;\n   for(; pos > 0; pos -= pos & -pos)\n   {\n      add(ans, BIT[pos]);\n   }\n   return ans;\n}\n\nint32_t main()\n{\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);\n   if(fopen(\"test.inp\", \"r\")) freopen(\"test.inp\", \"r\", stdin);\n   cin >> n >> m;\n   for(int i = 1; i <= n; i++)\n   {\n      cin >> p[i].first;\n      p[i].second = 1;\n   }\n   for(int i = n + 1; i <= n + m; i++)\n   {\n      cin >> p[i].first;\n      p[i].second = 0;\n   }\n   n += m;\n   sort(p + 1, p + n + 1);\n   int cur = -1;\n   for(int i = 1; i <= n; i++)\n   {\n      if(p[i].second == 0) cur = p[i].first;\n      else\n      {\n         if(cur != -1) le[i] = p[i].first - cur;\n      }\n   }\n   cur = -1;\n   for(int i = n; i >= 1; i--)\n   {\n      if(p[i].second == 0) cur = p[i].first;\n      else\n      {\n         if(cur != -1) ri[i] = -(p[i].first - cur);\n      }\n      if(ri[i] && le[i])\n      {\n         val.push_back(ri[i]);\n         val1.emplace_back(le[i], ri[i]);\n      }\n   }\n   sort(val.begin(), val.end());\n   sort(val1.begin(), val1.end(), [](const pair<int, int> &x, const pair<int, int> &y)\n   {\n      if(x.first == y.first) return x.second > y.second;\n      return x.first < y.first;\n   });\n   val.erase(unique(val.begin(), val.end()), val.end());\n   Update(1, 1);\n   for(auto i: val1)\n   {\n      i.second = Find(i.second);\n      Update(i.second + 1, Query(i.second));\n   }\n   cout << Query(maxn - 1);\n}"
  },
  {
    "language": "C++",
    "code": "/*+lmake\n * DEFINE += WAAUTOMATON\n */\n#include <bits/stdc++.h>\n#ifdef WAAUTOMATON\n#define debug(args...)                                                                             \\\n    {                                                                                              \\\n        dbg, args;                                                                                 \\\n        cerr << endl;                                                                              \\\n    }\n#define massert(x) assert(x)\n#else\n#define debug(args...) // Just strip off all debug tokens\n#define massert(x)\n#endif\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> pii;\nstruct debugger\n{\n    template <typename T>\n    debugger &operator,(const T &v)\n    {\n\t\tstd::cerr << v << \" \";\n        return *this;\n    }\n} dbg;\n\nvoid iopen()\n{\n    static bool isOpen = false;\n    if (!isOpen) {\n        isOpen = true;\n#ifdef WAAUTOMATON\n        freopen(\"in.txt\", \"r\", stdin);\n#endif\n    }\n}\ntemplate <size_t _I_Buffer_Size = 1 << 23, size_t _O_Buffer_Size = 1 << 23>\nstruct IO_Tp\n{\n    char _I_Buffer[_I_Buffer_Size];\n    char *_I_pos;\n    const char *_I_end;\n\n    char _O_Buffer[_O_Buffer_Size];\n    char *_O_pos;\n    const char *_O_end;\n\n    IO_Tp()\n        : _I_pos(_I_Buffer)\n        , _O_pos(_O_Buffer)\n        , _I_end(_I_Buffer + _I_Buffer_Size)\n        , _O_end(_O_Buffer + _O_Buffer_Size)\n    {\n    }\n\n    ~IO_Tp() { fwrite(_O_Buffer, 1, _O_pos - _O_Buffer, stdout); }\n\n    inline char getchar()\n    {\n        char res = *_I_pos;\n        nextchar();\n        return res;\n    }\n\n    inline bool is_digit(const char ch) { return '0' <= ch && ch <= '9'; }\n\n    inline void nextchar()\n    {\n        ++_I_pos;\n        if (_I_pos == _I_end) {\n            fread(_I_Buffer, 1, _I_Buffer_Size, stdin);\n            _I_pos = _I_Buffer;\n        }\n    }\n\n    template <typename Int>\n    inline IO_Tp &operator>>(Int &res)\n    {\n        res = 0;\n        int k = 1;\n        while (!is_digit(*_I_pos)) {\n            if (*_I_pos == '-')\n                k = -1;\n            nextchar();\n        }\n        do {\n            (res *= 10) += (*_I_pos) -'0';\n            nextchar();\n        } while (is_digit(*_I_pos));\n        res *= k;\n        return *this;\n    }\n\n    inline IO_Tp &operator>>(char &res)\n    {\n        res = *_I_pos;\n        nextchar();\n        return *this;\n    }\n\n\tinline void putchar(char x)\n\t{\n\t\tif (_O_pos==_O_end) {\n\t\t\tfwrite(_O_Buffer, 1, _O_pos - _O_Buffer, stdout);\n\t\t\t_O_pos=_O_Buffer;\n\t\t}\n\t\t*_O_pos++=x;\n\t}\n    template <typename Int>\n    inline IO_Tp &operator<<(Int n)\n    {\n        if (n < 0) {\n\t\t\tputchar('-');\n            n = -n;\n        }\n        static char _buf[20];\n        char *_pos(_buf);\n        do\n            *_pos++ = '0' + n % 10;\n        while (n /= 10);\n        while (_pos != _buf)\n            putchar(*--_pos);\n        return *this;\n    }\n\n    inline IO_Tp &operator<<(char ch)\n    {\n\t\tputchar(ch);\n        return *this;\n    }\n\n\tinline IO_Tp &operator<<(const char* s)\n\t{\n\t\twhile(*s!=0) {\n\t\t\tputchar(*s);\n\t\t\t++s;\n\t\t}\n\t\treturn *this;\n\t}\n};\nIO_Tp<> IO;\nconst int MAXN=200000;\nint a[MAXN+10],b[MAXN+10];\nstruct Point\n{\n\tint x,y;\n}p[MAXN+10];\nint tong[MAXN+10];\nconst LL kcz=1e9+7;\nLL t[MAXN+10];\nvoid add(int p,LL v,int n)\n{\n\tfor(int i=p; i<=n; i+=i&(-i)) {\n\t\tt[i]+=v;\n\t\tt[i]%=kcz;\n\t}\n}\nLL query(int p)\n{\n\tLL ans=0;\n\tfor(int i=p; i>0; i-=i&(-i)) {\n\t\tans+=t[i];\t\n\t}\n\treturn ans%kcz;\n}\nint main()\n{\n\tiopen();\n\tint n,m;\n\tIO>>n>>m;\n\tfor(int i=1; i<=n; ++i) {\n\t\tIO>>a[i];\n\t}\n\tfor(int i=1; i<=m; ++i) {\n\t\tIO>>b[i];\n\t}\n\tint cnt=0;\n\tfor(int i=1; i<=n; ++i) {\n\t\tint t=lower_bound(b+1,b+1+m,a[i])-b;\n\t\tif (t==1 || t==m+1) continue;\n\t\t++cnt;\n\t\tp[cnt].x=*lower_bound(b+1,b+1+m,a[i])-a[i];\n\t\tp[cnt].y=a[i]-*(upper_bound(b+1,b+1+m,a[i])-1);\n\t\ttong[cnt]=p[i].y;\n\t}\n\tn=cnt;\n\tsort(tong+1,tong+1+n);\n\tm=unique(tong+1,tong+1+n)-tong-1;\n\tfor(int i=1; i<=n; ++i) {\n\t\tp[i].y=lower_bound(tong+1,tong+1+m,p[i].y)-tong;\n\t}\n\tsort(p+1,p+1+n,[](const Point& a,const Point& b){if (a.x==b.x) return a.y>b.y; return a.x<b.x;});\n\tLL ans=0;\n\tfor(int i=1; i<=n; ++i) {\n\t\tLL now=1+query(p[i].y-1);\n\t\tans+=now;\n\t\tans%=kcz;\n\t\tadd(p[i].y,now,m+1);\n\t}\n\tcout<<ans+1<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <algorithm>\n#include <vector>\n#include <cstdio>\nusing namespace std;\nconst int Maxn=100005;\nconst int mod=1000000007;\nint n,m,a[Maxn],b[Maxn];\nbool notok[Maxn];\nint lef[Maxn],rig[Maxn];\nvector <int> un;\nvector <pair <int,int> > seq;\nint rmq[Maxn];\ninline void add(int x,int val){for (int i=x;i>0;i-=i&-i) rmq[i]=(rmq[i]+val)%mod;}\ninline int sum(int x){int res=0;for (int i=x;i<Maxn;i+=i&-i) res=(res+rmq[i])%mod;return res;}\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tfor (int i=0;i<n;i++) scanf(\"%d\",&a[i]);\n\tfor (int j=0;j<m;j++) scanf(\"%d\",&b[j]);\n\tfor (int i=0;i<n;i++)\n\t{\n\t\tint ind=upper_bound(b,b+m,a[i])-b;\n\t\tif (!ind || ind==m)\n\t\t{\n\t\t\tnotok[i]=true;\n\t\t\tcontinue;\n\t\t}\n\t\tlef[i]=a[i]-b[ind-1];\n\t\trig[i]=b[ind]-a[i];\n\t\tun.push_back(rig[i]);\n\t}\n\tsort(un.begin(),un.end());un.erase(unique(un.begin(),un.end()),un.end());\n\tfor (int i=0;i<n;i++) if (!notok[i])\n\t{\n\t\tint tk=lower_bound(un.begin(),un.end(),rig[i])-un.begin()+1;\n\t\tseq.push_back(make_pair(-lef[i],tk));\n\t}\n\tsort(seq.begin(),seq.end());seq.erase(unique(seq.begin(),seq.end()),seq.end());\n\tadd(Maxn-1,1);\n\tfor (int i=0;i<seq.size();i++)\n\t{\n\t\tint ind=seq[i].second;\n\t\tadd(ind,sum(ind+1));\n\t}\n\tprintf(\"%d\\n\",sum(1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nint n, m;\nint a[101010];\nint b[101010];\nvector<pair<LL, LL>> c;\n\nstruct BIT {\n\tvector<LL> bit;\n\tBIT(LL n) {\n\t\tbit.resize(n + 10);\n\t\tfor (int i = 0; i < n + 10; i++)bit[i] = 0;\n\t}\n\t//[0,i)\n\tLL sum(int i) {\n\t\tLL s = 0;\n\t\tfor (int x = i - 1; x >= 0; x = (x&(x + 1)) - 1) {\n\t\t\ts += bit[x];\n\t\t}\n\t\treturn s;\n\t}\n\tvoid add(int a, LL w) {\n\t\tfor (int x = a; x < bit.size(); x |= x + 1) {\n\t\t\tbit[x] += w;\n\t\t}\n\t}\n};\nconst int mod = 1e9 + 7;\n\nbool calc(pair<LL, LL> p, pair<LL, LL> q) {\n\tif (p.first == q.first)return p.second > q.second;\n\treturn p < q;\n}\n\nint main() {\n\tcin >> n >> m;\n\tREP(i, n)cin >> a[i];\n\tREP(i, m)cin >> b[i];\n\tREP(i, n) {\n\t\tint it = lower_bound(b, b + m, a[i]) - b;\n\t\tif (it == 0 || it == m)continue;\n\t\tc.emplace_back(make_pair(a[i] - b[it - 1], b[it] - a[i]));\n\t}\n\tsort(ALL(c));\n\tUNIQUE(c);\n\tsort(ALL(c), calc);\n\tvector<LL> d;\n\tint N = c.size(), id = 1;\n\tREP(i, N)d.emplace_back(c[i].second);\n\tsort(ALL(d));\n\tUNIQUE(d);\n\tmap<LL, LL>mp;\n\tREP(i, d.size()) {\n\t\tif (mp.find(d[i]) == mp.end()) {\n\t\t\tmp[d[i]] = id;\n\t\t\tid++;\n\t\t}\n\t}\n\tREP(i, N)c[i].second = mp[c[i].second];\n\tBIT bit(n*3);\n\tbit.add(0, 1);\n\tLL ans = 1;\n\tREP(i, N) {\n\t\tLL t = bit.sum(c[i].second);\n\t\tans += t;\n\t\tans %= mod;\n\t\tbit.add(c[i].second, t);\n\t}\n\tcout << ans%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#define lowbit(x) ((x)&(-x))\nusing namespace std;\nconst int maxn = 2e5+5;\nconst int mod = 1e9+7;\nint add(int x,int y) {\n\tx+=y; return x>=mod?x-mod:x;\n}\nint sub(int x,int y) {\n\tx-=y; return x<0?x+mod:x;\n}\nint bit[maxn];\nint n,m;\nint ha[maxn],cnt;\nint gsum(int x) { int sm=0; for(;x;x-=lowbit(x))sm=add(sm,bit[x]); return sm; }\nvoid adds(int x,int d) { for(;x<=cnt;x+=lowbit(x)) bit[x]=add(bit[x],d); }\nstruct node{\n\tint x,y;\n}z[maxn]; int tot;\n\nint gid(int x) {\n\treturn lower_bound(ha+1,ha+1+cnt,x)-ha;\n}\nbool cmp(node aa,node bb) {\n\tif(aa.x!=bb.x)return aa.x < bb.x;\n\treturn aa.y>bb.y;\n}\nset<int>se;\nint a[maxn],b[maxn];\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++) scanf(\"%d\",&b[i]),se.insert(b[i]);\n\tfor(int i=1;i<=n;i++) {\n\t\tif(a[i]<=b[1]||a[i]>=b[m]||se.count(a[i])) continue;\n\t\tint pr = (lower_bound(b+1,b+1+m,a[i])-b); int pl = pr-1;\n\t\tz[++tot] = (node) {a[i] - b[pl] , b[pr] - a[i] };\n\t\tha[++cnt] = b[pr]-a[i];\n\t}\n\tsort(z+1,z+1+tot,cmp);\n\tsort(ha+1,ha+1+cnt);\n\tcnt = unique(ha+1,ha+1+cnt)-ha-1;\n\tint ans = 1;\n\tfor(int i=1;i<=tot;i++) {\n\t\tif(z[i].x==z[i-1].x&&z[i].y==z[i-1].y) continue;\n\t\tint ff = add(gsum(gid(z[i].y)-1),1);\n\t\tans = add(ans,ff);\n\t\tadds(gid(z[i].y),ff);\n\t}\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define int long long\nusing namespace std;\nstruct node\n{\n\tint x,y,newy;\n\tbool operator < (const node &re)const\n\t{\n\t\tif (x!=re.x)\n\t\t\treturn x<re.x;\n\t\telse\n\t\t\treturn newy>re.newy;\n\t}\n};\nnode QQmove[10000001];\nint mod=1000000007;\nint f[10000001],c[10000001],a[10000001],b[10000001],ans,res=1,len,n,m,useless;\nbool cmp(node u,node v)\n{\n\treturn u.y<v.y;\n}\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\nvoid add(int x,int d)\n{\n\tfor (;x<=n;x+=lowbit(x))\n\t{\n\t\tc[x]+=d;\n\t\tc[x]%=mod;\n\t}\t\n\treturn;\n}\nint sum(int x)\n{\n\tans=0;\n\tfor (;x>=1;x-=lowbit(x))\n\t{\n\t\tans+=c[x];\n\t\tans%=mod;\n\t}\n\treturn ans;\n}\nsigned main()\n{\n\tint first,last,mid,front,back;\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;++i)\n\t\tcin>>a[i];\n\tfor (int i=1;i<=m;++i)\n\t\tcin>>b[i];\n\tsort(a+1,a+n+1);\n\tsort(b+1,b+n+1);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tfirst=1;\n\t\tlast=m;\n\t\tfront=0;\n\t\tback=m+1;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]>=b[mid])\n\t\t\t{\n\t\t\t\tfront=max(front,mid);\n\t\t\t\tfirst=mid+1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tlast=mid-1;\n\t\t}\n\t\tfirst=1;\n\t\tlast=m;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]<=b[mid])\n\t\t\t{\n\t\t\t\tback=min(back,mid);\n\t\t\t\tlast=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tfirst=mid+1;\n\t\t}\n\t\tif (front==0||back==m+1||b[front]==a[i]||b[back]==a[i])\n\t\t\tcontinue;\n\t\tQQmove[++len].x=a[i]-b[front];\n\t\tQQmove[len].y=b[back]-a[i];\n\t}\n\tsort(QQmove+1,QQmove+len+1,cmp);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tQQmove[i].newy=i-useless;\n\t\tif (QQmove[i].y==QQmove[i+1].y)\n\t\t\tuseless++;\n\t}\n\tsort(QQmove+1,QQmove+len+1);\n\tfor (int i=1;i<=len-1;++i)\n\t\tif (QQmove[i].newy==QQmove[i+1].newy&&QQmove[i].x==QQmove[i+1].x)\n\t\t{\n\t\t\tQQmove[i].x=1e+18;\n\t\t\tQQmove[i].newy=1e+18;\n\t\t}\n\tsort(QQmove+1,QQmove+len+1);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tif (QQmove[i].x==1e+18)\n\t\t\tbreak;\n\t\tf[i]=sum(QQmove[i].newy-1)+1;\n\t\tf[i]%=mod;\n\t\tadd(QQmove[i].newy,f[i]);\n\t}\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tres+=f[i];\n\t\tres%=mod;\n\t}\n\tcout<<res%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e5, mod = 1e9 + 7;\nint n, m, a[maxn + 3], b[maxn + 3], N, M, L[maxn + 3], R[maxn + 3], o[maxn + 3], t[maxn + 3], bit[maxn + 3];\n\nbool comp(int i, int j) {\n\treturn L[i] == L[j] ? R[i] > R[j] : L[i] < L[j];\n}\n\ninline int func(int x) {\n\treturn x < mod ? x : x - mod;\n}\n\nvoid add(int x, int y) {\n\tfor (int i = x; i <= maxn; i += i & -i) {\n\t\tbit[i] = func(bit[i] + y);\n\t}\n}\n\nint query(int x) {\n\tint y = 0;\n\tfor (int i = x; i; i ^= i & -i) {\n\t\ty = func(y + bit[i]);\n\t}\n\treturn y;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d\", &b[i]);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tint l = lower_bound(b + 1, b + m + 1, a[i]) - (b + 1), r = l + 1;\n\t\tif (l == 0 || r == m + 1) continue;\n\t\t++N, L[N] = a[i] - b[l], R[N] = b[r] - a[i];\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\to[i] = i;\n\t}\n\tsort(o + 1, o + N + 1, comp);\n\tfor (int i = 1; i <= N; i++) {\n\t\tt[i] = L[i];\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tL[i] = t[o[i]];\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tt[i] = R[i];\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tR[i] = t[o[i]];\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tt[i] = L[i];\n\t}\n\tsort(t + 1, t + N + 1);\n\tM = unique(t + 1, t + N + 1) - (t + 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tL[i] = lower_bound(t + 1, t + M + 1, L[i]) - t;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tt[i] = R[i];\n\t}\n\tsort(t + 1, t + N + 1);\n\tM = unique(t + 1, t + N + 1) - (t + 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tR[i] = lower_bound(t + 1, t + M + 1, R[i]) - t;\n\t}\n\tint ans = 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (L[i] == L[i - 1] && R[i] == R[i - 1]) continue;\n\t\tint x = query(R[i] - 1) + 1;\n\t\tans = func(ans + x);\n\t\tadd(R[i], x);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//O(N^2), TLE\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#define rep(i, n) for(i = 0; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nint mod = 1000000007;\nint n, m;\nint x[100000];\nint y[100000];\nvector<P> ps;\nint dp[100003];\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> n >> m;\n\trep(i, n) cin >> x[i];\n\trep(i, m) cin >> y[i];\n\t\n\tint INF = 1e+10;\n\trep(i, n) {\n\t\tint right = lower_bound(y, y + m, x[i]) - y;\n\t\tif (right == m || right == 0) continue;\n\t\tps.push_back(P(x[i] - y[right - 1], y[right] - x[i]));\n\t}\n\tps.push_back(P(-INF, -INF));\n\tps.push_back(P(INF, INF));\n\tsort(ps.begin(), ps.end());\n\tps.erase(unique(ps.begin(), ps.end()), ps.end());\n\t\n\tdp[0] = 1;\n\trep(i, ps.size()) {\n\t\trep(j, ps.size()) {\n\t\t\tif (ps[j].first > ps[i].first && ps[j].second > ps[i].second) {\n\t\t\t\tdp[j] += dp[i];\n\t\t\t\tdp[j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << dp[ps.size() - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod=1000000007;\nint t[100010],A[100010],B[100010],n,m,p,cnt,nw,cntt;\npair<int,int> valy[100010];\nstruct node{int x,y;}a[100010],aa[100010];\nbool cmp(node a,node b) {return a.x<b.x||a.x==b.x&&a.y>b.y;}\n\nvoid add(int x,int v) {for (; x<=nw; x+=(x&-x)) t[x]=(t[x]+v>=mod?t[x]+v-mod:t[x]+v);}\nint query(int x) {int r=0; for (; x; x-=(x&-x)) r=(t[x]+r>=mod?t[x]+r-mod:t[x]+r); return r;}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1; i<=n; i++) scanf(\"%d\",&A[i]);\n\tfor (int i=1; i<=m; i++) scanf(\"%d\",&B[i]);\n\tp=0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\twhile (p<m&&B[p+1]<A[i]) p++;\n\t\tif (p&&p<m) a[++cnt]=(node){A[i]-B[p],B[p+1]-A[i]};\n\t}\n\tif (!cnt) return puts(\"1\"),0;\n\tsort(a+1,a+1+cnt,cmp),aa[cntt=1]=a[1];\n\tfor (int i=2; i<=cnt; i++) if (a[i].x!=a[i-1].x||a[i].y!=a[i-1].y) aa[++cntt]=a[i];\n\tcnt=cntt;\n\tfor (int i=1; i<=cnt; i++) a[i]=aa[i];\n\tfor (int i=1; i<=cnt; i++) valy[i]=make_pair(a[i].y,i);\n\tsort(valy+1,valy+1+cnt),nw=1;\n\tfor (int i=1; i<=cnt; i++)\n\t{\n\t\tif (i==1||valy[i].first!=valy[i-1].first) nw++;\n\t\ta[valy[i].second].y=nw;\n\t}\n\tmemset(t,0,sizeof(t)),add(1,1);\n\tfor (int i=1; i<=cnt; i++) add(a[i].y,query(a[i].y-1));\n\tprintf(\"%d\\n\",query(nw));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        (wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nint n, m;\nint a[101010];\nint b[101010];\nvector<pair<LL, LL>> c;\nconst int mod = 1e9 + 7;\n\nclass Segment_Tree {\nprivate:\n\tint n;\n\tvector<LL> date;\n\tLL Rec(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l&&r <= b) return date[k];\n\t\tint m = (l + r) / 2;\n\t\treturn (Rec(a, b, k * 2 + 1, l, m) + Rec(a, b, k * 2 + 2, m, r)) % mod;\n\t}\npublic:\n\tSegment_Tree(int n_) {\n\t\tn = 1;\n\t\twhile (n<n_) n *= 2;\n\t\tdate = vector<LL>(2 * n - 1,0);\n\t}\n\tvoid Update(int k, int x) {\n\t\tk += n - 1;\n\t\t(date[k] += x) %= mod;\n\t\twhile (k>0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdate[k] = (date[k * 2 + 1] + date[k * 2 + 2]) % mod;\n\t\t}\n\t}\n\tLL Query(int a, int b) {\n\t\treturn Rec(a, b, 0, 0, n);\n\t}\n\tLL Open(int k) {\n\t\treturn date[k + n - 1];\n\t}\n};\n\nbool calc(pair<LL, LL> p, pair<LL, LL> q) {\n\tif (p.first == q.first)return p.second > q.second;\n\treturn p < q;\n}\n\nint main() {\n\tcin >> n >> m;\n\tREP(i, n)cin >> a[i];\n\tREP(i, m)cin >> b[i];\n\tREP(i, n) {\n\t\tint it = lower_bound(b, b + m, a[i]) - b;\n\t\tif (it == 0 || it == m)continue;\n\t\tc.emplace_back(make_pair(b[it] - a[i], a[i] - b[it - 1]));\n\t}\n\tsort(ALL(c));\n\tUNIQUE(c);\n\tsort(ALL(c), calc);\n\tvector<LL> d;\n\tint N = c.size(), id = 1;\n\tREP(i, N)d.emplace_back(c[i].second);\n\tsort(ALL(d));\n\tUNIQUE(d);\n\tmap<LL, LL>mp;\n\tREP(i, d.size()) {\n\t\tif (mp.find(d[i]) == mp.end()) {\n\t\t\tmp[d[i]] = id;\n\t\t\tid++;\n\t\t}\n\t}\n\tREP(i, N)c[i].second = mp[c[i].second];\n\tSegment_Tree seg(N+1);\n\tseg.Update(0, 1);\n\tLL ans = 1;\n\tREP(i, N) {\n\t\tLL t = seg.Query(0,c[i].second);\n\t\tseg.Update(c[i].second, t);\n\t\tans += t;\n\t\tans %= mod;\n\t}\n\tcout << ans%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n\ntypedef pair<int, int> ii;\n\nconst int N = 1e5 + 5;\n\nconst int mod = 1e9 + 7;\n\nconst int M = 1e9;\n\nint n, m, a[N], b[N], cnt = 1;\n\nmap<int, int> bit;\n\nvoid update(int pos, int val) {\n    while(pos <= M) {\n        bit[pos] = (1ll * bit[pos] + val) % mod;\n        pos += pos & (-pos);\n    }\n}\n\nint get(int pos) {\n    int ans = 0;\n    while(pos > 0) {\n        ans = (1ll * ans + bit[pos]) % mod;\n        pos -= pos & (-pos);\n    }\n    return ans;\n}\n\nvector<ii> pos;\n\nint main() {\n    cin.tie(0), ios::sync_with_stdio(0);\n    cin >> n >> m;\n    for(int i = 1; i <= n; i++)\n        cin >> a[i];\n    for(int i = 1; i <= m; i++)\n        cin >> b[i];\n    for(int i = 1; i <= n; i++) {\n        while(cnt < m && b[cnt + 1] < a[i])\n            cnt++;\n        if(cnt < m && b[cnt] < a[i] && a[i] < b[cnt + 1])\n            pos.pb({a[i] - b[cnt], b[cnt + 1] - a[i] + 1});\n    }\n    sort(pos.begin(), pos.end());\n    update(1, 1);\n    for(int i = 0; i < pos.size(); i++) {\n        if(i > 0 && pos[i - 1] == pos[i])\n            continue;\n        int total = get(pos[i].se - 1);\n        if(i > 0 && pos[i - 1].fi == pos[i].fi)\n            total = (1ll * total - get(pos[i - 1].se - 1)) % mod;\n        total = (1ll * total + mod) % mod;\n        update(pos[i].se, total);\n    }\n    cout << get(M) << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "//problem:arc101F\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mk make_pair\n#define lob lower_bound\n#define upb upper_bound\n#define fst first\n#define scd second\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ninline int read(){\n\tint f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\ninline ll readll(){\n\tll f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=1e5+5,MOD=1e9+7;\nint n,m,a[MAXN],b[MAXN];\npii p[MAXN];\ninline mod(int x){return x<MOD?x:x-MOD;}\nstruct BIT{\n\tint c[MAXN];\n\tinline int lb(int x){return x&(-x);}\n\tvoid add(int p,int v){for(;p<=n;p+=lb(p))c[p]=mod(c[p]+v);}\n\tint ask(int p){int r=1;for(;p;p-=lb(p))r=mod(r+c[p]);return r;}\n\tBIT(){}\n}T;\nint main() {\n\tn=read();m=read();\n\tfor(int i=1;i<=n;++i)a[i]=read();\n\tfor(int i=1;i<=m;++i)b[i]=read();\n\tint cnt=0;vector<int>vec;\n\tfor(int i=1;i<=n;++i){\n\t\tif(a[i]<b[1]||a[i]>b[m])continue;\n\t\tint t=lob(b+1,b+n+1,a[i])-b;\n\t\tassert(t>1&&t<=m);\n\t\tp[++cnt]=mk(a[i]-b[t-1],b[t]-a[i]);\n\t\tvec.pb(p[cnt].scd);\n\t}\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end());\n\tn=cnt;sort(p+1,p+n+1);\n\tfor(int i=1,j=1;i<=n;i=j){\n\t\tint L=p[i].fst;\n\t\twhile(j<=n&&p[j].fst==L)++j;\n\t\tfor(int k=j-1;k>=i;--k){\n\t\t\tint R=lob(vec.begin(),vec.end(),p[k].scd)-vec.begin()+1;\n\t\t\tif(k!=j-1&&p[k].scd==p[k+1].scd)continue;\n\t\t\tT.add(R,T.ask(R-1));\n\t\t}\n\t}\n\tcout<<T.ask(vec.size())<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\nclass BIT\n{\npublic:\n    vector<int> bit;\n    int M;\n\n    BIT(int M):\n        bit(vector<int>(M+1, 0)), M(M) {}\n\n    int sum(int i) {\n        if (!i) return 0;\n        return bit[i] + sum(i-(i&-i));\n    }\n\n    void add(int i, int x) {\n        if (i > M) return;\n        bit[i] += x;\n        add(i+(i&-i), x);\n    }\n};\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    vec x(N), y(M);\n    readv(x); readv(y);\n\n    set<int> X, Y;\n    REP(i, N){\n        int n = Lower_bound(y, x[i]);\n        if(n == 0 || n == M) continue;\n        X.insert(x[i] - y[n - 1]);\n        Y.insert(y[n] - x[i]);\n    }\n    vec a(0), b(0);\n    for(int i: X) a.push_back(i);\n    for(int i: Y) b.push_back(i);    \n\n    set<Pii> s;\n    REP(i, N){\n        int n = Lower_bound(y, x[i]);\n        if(n == 0 || n == M) continue;\n        int x0 = Lower_bound(a, x[i] - y[n - 1]);\n        int y0 = Lower_bound(b, y[n] - x[i]);\n        s.insert(Pii(x0, -y0));\n    }\n\n    BIT bit(a.size() + 1);\n    bit.add(1, 1);\n    for(Pii p: s){\n        int x0 = p.first;\n        int y0 = -(p.second);\n        //int s1 = bit.sum(y0 + 2), s2 = bit.sum(y0 + 1);\n        bit.add(y0 + 2, bit.sum(y0 + 1));\n    }\n\n    cout << bit.sum(a.size() + 1);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<queue>\n#define inf 2147483647\n#define eps 1e-9\n#define lb(x) (x&-x)\n#define mod 1000000007\n#define mp make_pair\nusing namespace std;\ntypedef int ll;\ntypedef pair<int,int> pr;\nint n,m,ans=1,tot=0,tmp,t1,t2,t[500001],a[100001],b[100001],h[100001];\npr p[100001];\nbool cmp(pr a,pr b){\n\treturn a.first==b.first?a.second>b.second:a.first<b.first;\n}\nvoid add(int u,int x){\n\tfor(;u<=n;u+=lb(u)){\n\t\tt[u]=(t[u]+x)%mod;\n\t}\n}\nint query(int u){\n\tint ret=0;\n\tfor(;u;u-=lb(u)){\n\t\tret=(ret+t[u])%mod;\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++)scanf(\"%d\",&b[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]>b[1]&&a[i]<b[m]){\n\t\t\ttmp=lower_bound(b+1,b+m+1,a[i])-b;\n\t\t\t//if(a[i]==b[tmp])continue;\n\t\t\tp[++tot]=pr(a[i]-b[tmp-1],b[tmp]-a[i]);\n\t\t\th[tot]=b[tmp]-a[i];\n\t\t}\n\t}\n\tsort(h+1,h+tot+1);\n\tt1=unique(h+1,h+tot+1)-h-1;\n\tfor(int i=1;i<=tot;i++){\n\t\tp[i].second=lower_bound(h+1,h+t1+1,p[i].second)-h;\n\t}\n\tsort(p+1,p+tot+1,cmp);\n\tt2=unique(p+1,p+tot+1)-p-1;\n\tfor(int i=1;i<=t2;i++){\n\t\ttmp=query(p[i].second-1)+1;\n\t\tans=(ans+tmp)%mod;\n\t\tadd(p[i].second,tmp);\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nconst int N = 201000,mod = 1e9+7;\nstruct node{int x,y;}p[N];\nint n,m,a[N],b[N],c[N],bx[N],by[N],cntx,cnty,tot;\nvector<int> h[N];\nvoid modify(int x,int k){\n\tfor(int i=x;i;i-=i&-i) c[i]=(c[i]+k)%mod;\n}\nint query(int x){\n\tint ans=0;\n\tfor(int i=x;i<=cnty+1;i+=i&-i) ans=(ans+c[i])%mod;\n\treturn ans;\n}\nint main(){\n\tread(n);read(m);\n\tfor(int i=1;i<=n;i++)\n\t\tread(a[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tread(b[i]);\n\tsort(a+1,a+n+1);\n\tsort(b+1,b+m+1);\n\tfor(int i=1;i<=n;i++){\n\t\tint k=upper_bound(b+1,b+m+1,a[i])-b;\n\t\tif(k==1||k>m) continue;\n\t\tp[++tot]={b[k]-a[i],a[i]-b[k-1]};\n\t\tbx[++cntx]=p[tot].x;\n\t\tby[++cnty]=p[tot].y;\n\t}\n\tsort(bx+1,bx+cntx+1);\n\tsort(by+1,by+cnty+1);\n\tcntx=unique(bx+1,bx+cntx+1)-bx-1;\n\tcnty=unique(by+1,by+cnty+1)-by-1;\n\tfor(int i=1;i<=tot;i++){\n\t\tp[i].x=lower_bound(bx+1,bx+cntx+1,p[i].x)-bx,\n\t\tp[i].y=lower_bound(by+1,by+cnty+1,p[i].y)-by;\n\t\th[p[i].x].push_back(p[i].y);\n\t}\n\tmodify(cnty+1,1);\n\tfor(int i=cntx;i;i--){\n\t\tvector<pair<int,int> > V;\n\t\tsort(h[i].begin(),h[i].end());\n\t\th[i].resize(unique(h[i].begin(),h[i].end())-h[i].begin());\n\t\tfor(int y:h[i]) V.emplace_back(y,query(y+1));\n\t\tfor(auto pr:V) modify(pr.first,pr.second);\n\t}\n\tcout<<query(1)<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(), vec.end()\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll INF = (1LL << 30) - 1LL;\nconstexpr ll LINF = (1LL << 60) - 1LL;\nconstexpr double eps = 1e-9;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T>\nbool chmin(T& a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n};\ntemplate <typename T>\nbool chmax(T& a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n};\ntemplate <typename T>\nostream& operator<<(ostream& os, vector<T> v) {\n    for(int i = 0; i < v.size(); i++) {\n        os << v[i].val << (i + 1 == v.size() ? \"\\n\" : \" \");\n    }\n    return os;\n}\ntemplate <typename T>\nvector<T> make_v(size_t a) {\n    return vector<T>(a);\n}\ntemplate <typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value == 0>::type fill_v(T& t, const V& v) {\n    t = v;\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value != 0>::type fill_v(T& t, const V& v) {\n    for(auto& e : t) {\n        fill_v(e, v);\n    }\n};\ntemplate <ll mod>\nstruct modint {\n    ll val;\n    inline ll extgcd(ll a, ll b, ll& x, ll& y) {\n        if(a < b) {\n            return extgcd(b, a, y, x);\n        }\n        if(b == 0) {\n            x = 1, y = 0;\n            return a;\n        }\n        ll d = extgcd(b, a % b, y, x);\n        y -= a / b * x;\n        return d;\n    }\n    inline ll minv(ll k) {\n        ll x = 0, y = 0;\n        extgcd(k, mod, x, y);\n        if(x < 0) {\n            x += mod;\n        } else if(x == mod) {\n            x = 0;\n        }\n        return x;\n    }\n    inline ll mpow(ll n) {\n        ll res = 1, x = val;\n        while(n > 0) {\n            if(n & 1) {\n                res *= x;\n                res %= mod;\n            }\n            x = x * x % mod;\n            n >>= 1;\n        }\n        return res;\n    }\n    constexpr modint() : val(0) {}\n    constexpr modint(ll x) { val = (x + mod) % mod; }\n    modint inv() { return modint(minv(val)); }\n    modint operator+(const modint& to) const { return modint(val + to.val); }\n    modint operator-(const modint& to) const { return modint(val - to.val); }\n    modint operator*(const modint& to) const { return modint(val * to.val); }\n    modint operator/(const modint& to) const {\n        return modint(val * minv(to.val));\n    }\n    template <class T>\n    explicit operator T() {\n        return T(val);\n    }\n    template <typename T>\n    modint operator+(const T& to) const {\n        return modint(val + to);\n    }\n    template <typename T>\n    modint operator-(const T& to) const {\n        return modint(val - to);\n    }\n    template <typename T>\n    modint operator*(const T& to) const {\n        return modint(val * to);\n    }\n    template <typename T>\n    modint operator/(const T& to) const {\n        return modint(val * minv(to));\n    }\n    modint& operator++() { return *this = modint(val + 1); }\n    modint& operator--() { return *this = modint(val - 1); }\n    template <typename T>\n    modint& operator+=(const T& to) {\n        return *this = *this + to;\n    }\n    template <typename T>\n    modint& operator-=(const T& to) {\n        return *this = *this - to;\n    }\n    template <typename T>\n    modint& operator*=(const T& to) {\n        return *this = *this * to;\n    }\n    template <typename T>\n    modint& operator/=(const T& to) {\n        return *this = *this / to;\n    }\n    bool operator==(const modint& to) const { return val == to.val; }\n    bool operator!=(const modint& to) const { return val != to.val; }\n    bool operator>(const modint& to) const { return val > to.val; }\n    bool operator>=(const modint& to) const { return val >= to.val; }\n    bool operator<(const modint& to) const { return val < to.val; }\n    bool operator<=(const modint& to) const { return val <= to.val; }\n};\nusing mint = modint<MOD>;\nvector<mint> f, fi;\nvoid comb(int n) {\n    f.resize(n + 10);\n    fi.resize(n + 10);\n    f[0] = 1;\n    for(ll i = 1; i <= n; i++) {\n        f[i] = f[i - 1] * i;\n    }\n    fi[n] = f[n].inv();\n    for(ll i = n - 1; i >= 0; i--) {\n        fi[i] = fi[i + 1] * (i + 1LL);\n    }\n}\nmint ncr(ll n, ll r) {\n    if(n < r || n < 0 || r < 0) {\n        return 0;\n    }\n    return f[n] * fi[r] * fi[n - r];\n}\ninline mint mpow(mint x, ll n) {\n    mint res = 1;\n    while(n > 0) {\n        if(n & 1) {\n            res *= x;\n        }\n        x = x * x;\n        n >>= 1;\n    }\n    return res;\n}\ntemplate <typename T>\nstruct BinaryIndexedTree {\n    vector<T> dat;\n    size_t n;\n    int h;\n    BinaryIndexedTree(size_t n) : n(n) {\n        h = 1;\n        while(h <= n) {\n            h <<= 1;\n        }\n        h >>= 1;\n        dat.assign(++n, 0);\n    }\n    void add(int k, T x) {\n        for(++k; k < n; k += k & -k) {\n            dat[k] += x;\n        }\n    }\n    T sum(int k) {\n        T res = 0;\n        for(++k; k > 0; k -= k & -k) {\n            res += dat[k];\n        }\n        return res;\n    }\n};\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    vector<ll> x(n), y(m), vs;\n    vector<P> v;\n    for(int i = 0; i < n; i++) {\n        cin >> x[i];\n    }\n    for(int i = 0; i < m; i++) {\n        cin >> y[i];\n    }\n    for(int i = 0; i < n; i++) {\n        int l = lower_bound(all(y), x[i]) - y.begin();\n        int r = l;\n        --l;\n        if(l == -1 || r == m) {\n            continue;\n        }\n        v.push_back(P(x[i] - y[l], y[r] - x[i]));\n        vs.push_back(y[r] - x[i]);\n    }\n    if(v.size() == 0) {\n        cout << 1 << endl;\n        return 0;\n    }\n    vs.push_back(0);\n    sort(all(vs));\n    vs.erase(unique(all(vs)), vs.end());\n    map<int, int> mp;\n    for(int i = 0; i < vs.size(); i++) {\n        mp[vs[i]] = i;\n    }\n    int nn = v.size(), nm = vs.size();\n    sort(all(v));\n    vector<int> a(nn);\n    for(int i = 0; i < nn; i++) {\n        a[i] = mp[v[i].second];\n    }\n    BinaryIndexedTree<mint> bit(nm + 1);\n    bit.add(0, 1);\n    bit.add(a[0], 1);\n    for(int i = 1; i < nn; i++) {\n        mint sum;\n        if(v[i].first != v[i - 1].first) {\n            sum = bit.sum(a[i] - 1);\n        } else {\n            sum = bit.sum(a[i] - 1) - bit.sum(a[i - 1] - 1);\n        }\n        bit.add(a[i], sum);\n    }\n    cout << bit.sum(nm - 1).val << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint MOD=1000000007;\nclass BIT{\n\tpublic:\n\t//[1,i]\n\tint n;\n\tvi bit;\n//\tint bit[MAZ_N+1];\n\tBIT(int size){\n\t\tn=size;\n\t\tbit=vi(n+1);\n\t}\n\tDef query(int i){//sum\n\t\tDef s=0;\n\t\twhile(i>0){\n\t\t\t(s+=bit[i])%=MOD;\n\t\t\ti-=i&-i;\n\t\t}\n\t\treturn s;\n\t}\n\tvoid add(int i,Def x){\n\t\twhile(i<=n){\n\t\t\t(bit[i]+=x)%=MOD;\n\t\t\ti+=i&-i;\n\t\t}\n\t}\n};\nsigned main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvi ro(n);\n\trep(i,n)cin>>ro[i];\n\tvi de(m);\n\trep(i,m)cin>>de[i];\n\tde.pb(inf);\n\tvvi in;\n\trep(i,n){\n\t\tint it=lower_bound(all(de),ro[i])-de.begin();\n\t\tif(it==0||it==m)continue;\n\t\tin.pb({ro[i]-de[it-1],de[it]-ro[i]});\n\t}\n\tvi y;\n\trep(i,in.size())y.pb(in[i][1]);\n\tsort(all(y));\n\ty.erase(unique(all(y)),y.end());\n\trep(i,in.size())in[i][1]=lower_bound(all(y),in[i][1])-y.begin()+1;\n\n\trep(i,in.size())in[i][1]*=-1;\n\tsort(all(in));\n\tBIT bit(100010);\n\tbit.add(1,1);\n\trep(i,in.size())if(i==0||i&&in[i]!=in[i-1]){\n\t\tint x=bit.query(-in[i][1]);\n\t\tbit.add(-in[i][1]+1,x);\n\t}\n\t\n\tcout<<bit.query(100009)<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n\ntemplate< class T >\nstruct BinaryIndexedTree {\n  vector< T > data;\n\n  BinaryIndexedTree(int sz) {\n    data.assign(++sz, 0);\n  }\n\n  T sum(int k) {\n    T ret = 0;\n    for(++k; k > 0; k -= k & -k) (ret += data[k]) %= mod;\n    return (ret);\n  }\n\n  void add(int k, T x) {\n    for(++k; k < data.size(); k += k & -k) (data[k] += x) %= mod;\n  }\n};\n\nint main() {\n  int N, M, X[100000], Y[100000];\n  cin >> N >> M;\n  for(int i = 0; i < N; i++) cin >> X[i];\n  for(int i = 0; i < M; i++) cin >> Y[i];\n\n  int L[100000], R[100000];\n  memset(L, -1, sizeof(L));\n  memset(R, -1, sizeof(R));\n  for(int i = 0; i < N; i++) {\n    auto it = lower_bound(Y, Y + M, X[i]) - Y;\n    if(it > 0) L[i] = X[i] - Y[it - 1];\n    if(it != M) R[i] = Y[it] - X[i];\n  }\n\n  vector< pair< int, int > > query;\n  vector< int > rs{-1};\n  for(int i = 0; i < N; i++) {\n    if(~L[i] && ~R[i]) rs.emplace_back(R[i]);\n  }\n  sort(begin(rs), end(rs));\n  rs.erase(unique(begin(rs), end(rs)), end(rs));\n  for(int i = 0; i < N; i++) {\n    if(~L[i] && ~R[i]) query.emplace_back(L[i], -(lower_bound(begin(rs), end(rs), R[i]) - begin(rs)));\n  }\n  BinaryIndexedTree< int > bit(rs.size() + 1);\n  bit.add(0, 1);\n  for(auto &height : query) bit.add(-height.second, bit.sum(-height.second - 1));\n  cout << bit.sum(rs.size()) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<functional>\n#include<cmath>\n#include<vector>\n//using namespace std;\nusing std::min;\nusing std::max;\nusing std::swap;\nusing std::sort;\nusing std::reverse;\nusing std::random_shuffle;\nusing std::lower_bound;\nusing std::upper_bound;\nusing std::unique;\nusing std::vector;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef std::pair<int,int> pii;\ntypedef std::pair<ll,ll> pll;\nvoid open(const char *s){\n#ifndef ONLINE_JUDGE\n\tchar str[100];sprintf(str,\"%s.in\",s);freopen(str,\"r\",stdin);sprintf(str,\"%s.out\",s);freopen(str,\"w\",stdout);\n#endif\n}\nint rd(){int s=0,c,b=0;while(((c=getchar())<'0'||c>'9')&&c!='-');if(c=='-'){c=getchar();b=1;}do{s=s*10+c-'0';}while((c=getchar())>='0'&&c<='9');return b?-s:s;}\nvoid put(int x){if(!x){putchar('0');return;}static int c[20];int t=0;while(x){c[++t]=x%10;x/=10;}while(t)putchar(c[t--]+'0');}\nint upmin(int &a,int b){if(b<a){a=b;return 1;}return 0;}\nint upmax(int &a,int b){if(b>a){a=b;return 1;}return 0;}\nconst ll p=1000000007;\nconst int N=100010;\nint cmp(pii a,pii b)\n{\n\tif(a.first!=b.first)\n\t\treturn a.first<b.first;\n\treturn a.second>b.second;\n}\nint n,m,t,t2;\nint a[N],b[N],d[N];\npii c[N];\nll e[N];\nvoid add(int x,ll v)\n{\n\tfor(;x<=t2;x+=x&-x)\n\t\te[x]=(e[x]+v)%p;\n}\nll sum(int x)\n{\n\tll s=0;\n\tfor(;x;x-=x&-x)\n\t\ts=(s+e[x])%p;\n\treturn s;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&b[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tif(a[i]>b[1]&&a[i]<b[m])\n\t\t{\n\t\t\tint x=lower_bound(b+1,b+m+1,a[i])-b;\n\t\t\tif(b[x]==a[i])\n\t\t\t\tcontinue;\n\t\t\tc[++t]=pii(a[i]-b[x-1],b[x]-a[i]);\n\t\t\td[++t2]=b[x]-a[i];\n\t\t}\n\tsort(d+1,d+t2+1);\n\tt2=unique(d+1,d+t2+1)-d-1;\n\tfor(int i=1;i<=t;i++)\n\t\tc[i].second=lower_bound(d+1,d+t2+1,c[i].second)-d;\n\tsort(c+1,c+t+1,cmp);\n\tll ans=1;\n\tfor(int i=1;i<=t;i++)\n\t{\n\t\tll s=sum(c[i].second-1)+1;\n\t\tans+=s;\n\t\tadd(c[i].second,s);\n\t}\n\tans%=p;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define all(v) v.begin(), v.end()\n#define sz(v) int(v.size())\n#define pii pair<int, int>\n#define mp make_pair\n#define f first\n#define ll long long\n#define ld long double\n#define s second\n#define vec vector<int>\n\nusing namespace std;\n\nconst int N = (int) 2e5 + 100;\nconst int M = (int) 2e6 + 100;\nconst int K = (int) 200;\nconst int INF = (int) 1e9 + 7;\nconst int mod = (int) 998244353;\nconst ld EPS = (ld) 1e-9;\nconst ll LINF = (ll) 1e15;\n\nint n, m;\nint a[N], b[N];\nint robots[N], exits[N];\nll dp[N];\npii p[N];\nmap<int, int> t;\n\nvoid upd(int x, ll val) {\n    x += INF;\n    while (x < 2 * INF) {\n        (t[x] += val % INF) %= INF;\n        x |= x  + 1;\n    }\n}\nint get(int x) {\n    x += INF;\n    int ans = 0;\n    while (x >= 0) {\n        ans += t[x];\n        ans %= INF;\n        x &= x + 1;\n        x--;\n    }\n    return ans;\n}\nint main() {\n\tsrand(time(0));\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) {\n        cin >> robots[i];\n    }\n    for (int i = 1; i <= m; i++) {\n        cin >> exits[i];\n    }\n    for (int i = 1; i <= n; i++) {\n        int id_left = upper_bound(exits + 1, exits + m + 1, robots[i]) - exits - 1;\n        int id_right = lower_bound(exits + 1, exits + m + 1, robots[i]) - exits;\n        if (id_left == 0) {\n            a[i] = INF;\n        } else {\n            a[i] = robots[i] - exits[id_left];\n        }\n        if (id_right == m + 1) {\n            b[i] = INF;\n        } else {\n            b[i] = exits[id_right] - robots[i];\n        }\n    }\n    vector<pii> p;\n    int sz = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i] *= -1;\n        if (a[i] != -INF && b[i] != INF)\n        p.pb(mp( a[i],b[i]));\n    }\n    sort(all(p));\n    p.resize(unique(all(p)) - p.begin());\n    ll anas = 0;\n    int ptr = 0;\n    for (int i = 0; i < sz(p); i++) {\n        dp[i] = 1;\n        while (p[i].f > p[ptr].f) {\n            upd(INF-p[ptr].s, dp[ptr]);\n            ptr++;\n        }\n        (dp[i] += get(INF-p[i].s - 1)) %= INF;\n        anas += dp[i];\n    }\n    cout << (anas + 1) % INF;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5,mod=1e9+7,low=1;\nint n,m,tot,cnt,a[N],b[N],d[N];\nll t[N],dp[N];\nstruct node\n{\n    int x,y;\n    bool operator==(const node&o)const\n    {\n        return x==o.x&&y==o.y;\n    }\n    bool operator<(const node&o)const\n    {\n        return x==o.x?y<o.y:x<o.x;\n    }\n}c[N];\nvoid add(int x,ll v)\n{\n    x+=low;\n    while(x<=cnt+low)\n    {\n        t[x]+=v;\n        x+=x&-x;\n    }\n}\nll query(int x)\n{\n    ll ans=0;\n    x+=low;\n    while(x)\n    {\n        ans=(ans+t[x])%mod;\n        x-=x&-x;\n    }\n    return ans;\n}\nvector<int>v;\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    for(int i=1;i<=m;i++) scanf(\"%d\",&b[i]);\n    for(int i=1;i<=n;i++)\n    {\n        int p1=lower_bound(b+1,b+1+m,a[i])-b-1;\n        int p2=lower_bound(b+1,b+1+m,a[i])-b;\n        if(p1<1||p2>m) continue;\n        c[++tot]={a[i]-b[p1],b[p2]-a[i]};\n    }\n    sort(c+1,c+1+tot);\n    tot=unique(c+1,c+1+tot)-c-1;\n    for(int i=1;i<=tot;i++)\n        d[i]=c[i].y;\n    sort(d+1,d+1+tot);\n    cnt=unique(d+1,d+1+tot)-d-1;\n    for(int i=1;i<=tot;i++)\n        c[i].y=lower_bound(d+1,d+1+cnt,c[i].y)-d;\n    dp[0]=1;\n    v.push_back(0);\n    for(int i=1;i<=tot;i++)\n    {\n        if(c[i].x!=c[i-1].x)\n        {\n            for(int j=0;j<v.size();j++)\n                add(c[v[j]].y,dp[v[j]]);\n            v.clear();\n        }\n        dp[i]=query(c[i].y-1);\n        v.push_back(i);\n    }\n    ll ans=0;\n    for(int i=0;i<=tot;i++)\n        ans=(ans+dp[i])%mod;\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nstruct BIT{\n  int n;\n  vector<ll> bit;\n  BIT(int size):n(size),bit(size+1,0){}\n\n  ll sum(int i){\n    ll s=0;\n    while(i>0){\n      (s+=bit[i])%=mod;\n      i-=i&-i;\n    }\n    return s;\n  }\n\n  void add(int i,ll v){\n    if(i==0)return ;\n    while(i<=n){\n      (bit[i]+=v)%=mod;\n      i+=i&-i;\n    }\n  }\n\n  ll lower_bound(ll w){\n    if(w<=0)return 0;\n    ll x=0,r=1;\n    while(r<n)r<<=1;\n    for(ll k=r;k>0;k>>=1){\n      if(x+k<=n&&bit[x+k]<w){\n        w-=bit[x+k];\n        x+=k;\n      }\n    }\n    return x+1;\n  }\n};\n\nll N,M;\nll A[200010],B[200010];\nll L[200010],R[200010];\nvector<P> ps;\nvector<ll> rs,ord;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin>>N>>M;\n  rep(i,N)cin>>A[i];\n  rep(j,M)cin>>B[j];\n\n  rep(i,N){\n    ll idx=lower_bound(B,B+M,A[i])-B;\n    if(idx==0||idx==M)continue;\n    L[i]=A[i]-B[idx-1]; R[i]=B[idx]-A[i];\n    ps.push_back(P(L[i],R[i]));\n  }\n  sort(all(ps)); uni(ps);\n  rep(i,ps.size()){\n    rs.push_back(ps[i].se); ord.push_back(i);\n  }\n  rs.push_back(0);\n  sort(all(rs)); uni(rs);\n  sort(all(ord),[=](const ll& a,const ll& b){\n    if(ps[a].fi == ps[b].fi) return ps[a].se < ps[b].se;\n    else return ps[a].fi < ps[b].fi;\n  });\n  rep(i,ps.size()){\n    ps[i].se=lower_bound(all(rs),ps[i].se)-rs.begin();\n  }\n  ll K=rs.size();\n\n  BIT bit(K);\n  bit.add(1,1);\n  for(ll i=0;i<(ll)ps.size();){\n    vector<P> add;\n    ll j=i;\n    for(;j<(ll)ps.size()&&ps[j].fi==ps[i].fi;j++){\n      add.push_back(P(ps[j].se+1,bit.sum(ps[j].se)));\n    }\n    rep(k,add.size()){\n      bit.add(add[k].fi,add[k].se);\n    }\n    i=j;\n  }\n  cout<<bit.sum(K)<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 500010\n#define mo 1000000007\n#define ll long long\nll i,j,k,ans,m,n,x,y,t[N],a[N],b[N],c[N],cnt,f[N];\ninline ll ask(ll x) {\n    ll ans = 0;\n    for (; x; x -= x & -x)(ans += t[x]) %= mo;\n    return ans;\n}\ninline void add(ll x,ll d) {\n    for (; x <= cnt; x += x & -x)(t[x] += d) %= mo;\n}\nstruct dist {\n    ll x, y;\n\n    inline bool operator<(const dist &b) const {\n        return x < b.x || (x == b.x && y > b.y);\n    }\n\n    inline bool operator==(const dist &b) const {\n        return x == b.x && y == b.y;\n    }\n}e[N];\nint main() {\n    cin >> n >> m;\n    for (i = 1; i <= n; ++i)cin >> a[i];\n    for (i = 1; i <= m; ++i)cin >> b[i];\n    for (i = j = 1; i < m && j <= n; ++i) {\n        for (; j <= n && a[j] <= b[i]; ++j);\n        if (j > n)break;\n        for (; j <= n && a[j] < b[i + 1]; ++j)e[++cnt] = (dist) {b[i + 1] - a[j], c[++*c] = a[j] - b[i]};\n    }\n    sort(c + 1, c + *c + 1);\n    for (i = 1; i <= cnt; ++i)e[i].y = lower_bound(c + 1, c + *c + 1, e[i].y) - c;\n    sort(e + 1, e + cnt + 1), cnt = unique(e + 1, e + cnt + 1) - e - 1;\n    for (ans = i = 1; i <= cnt; ++i) {\n        f[i] = (ask(e[i].y - 1) + 1) % mo;\n        (ans += f[i]) %= mo, add(e[i].y, f[i]);\n    }\n    cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=100000+10;\nconst int mod=1e9+7;\n\nint n,m,cnt,top;\nint a[N],b[N],S[N];\npair<int,int> p[N];\nint f[N];\n\ninline int cmp(pair<int,int> a,pair<int,int> b) {\n    if (a.first!=b.first) return a.first<b.first;\n    else return a.second>b.second;\n}\n\nint c[N];\ninline int lowbit(int x) { return x&-x; }\ninline int query(int x) { int res=0;\n    for (;x;x-=lowbit(x)) res=(res+c[x])%mod;\n    return res;\n}\ninline void add(int x,int y) {\n    for (;x<=top;x+=lowbit(x)) c[x]=(c[x]+y)%mod;\n}\n\nint main() {\n    n=read(),m=read();\n    for (re int i=1;i<=n;++i) a[i]=read();\n    for (re int i=1;i<=m;++i) b[i]=read();\n    for (re int i=1;i<=n;++i) {\n        if (a[i]<=b[1]||a[i]>=b[m]) continue;\n        int x=lower_bound(b+1,b+m+1,a[i])-b;\n        if (b[x]==a[i]) continue;\n        p[++cnt]=make_pair(a[i]-b[x-1],b[x]-a[i]);\n        S[++top]=b[x]-a[i];\n    }\n    sort(S+1,S+top+1); top=unique(S+1,S+top+1)-S-1;\n    for (re int i=1;i<=cnt;++i)\n        p[i].second=lower_bound(S+1,S+top+1,p[i].second)-S;\n    sort(p+1,p+cnt+1,cmp); cnt=unique(p+1,p+cnt+1)-p-1;\n    f[0]=1;\n    for (re int i=1;i<=cnt;++i)\n        f[i]=query(p[i].second-1)+1,add(p[i].second,f[i]);\n    int ans=0;\n    for (re int i=0;i<=cnt;++i) ans=(ans+f[i])%mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ( (int)(x).size() )\nusing LL = long long;\n\nconst int mod = 1e9 + 7, inf = mod;\nmt19937 rng( (uint32_t)chrono::steady_clock::now().time_since_epoch().count() );\n\nstruct Mint {\n  int a;\n  Mint(int _a = 0) : a(_a) {}\n  friend ostream& operator << (ostream &out, const Mint &_) {\n    out << _.a;\n    return out;\n  }\n\n  bool operator == (const Mint &_) const { return a == _.a; }\n  bool operator ! () const { return !a; }\n\n  Mint operator + (const Mint &_) const {\n    int ret = a + _.a;\n    return ret < mod ? Mint(ret) : Mint(ret - mod);\n  }\n  Mint operator - (const Mint &_) const { return *this + Mint(mod - _.a); }\n  Mint operator * (const Mint &_) const { return Mint( (int)( (LL)a * _.a % mod) ); }\n  friend Mint& operator += (Mint &a, const Mint &b) { return a = a + b; }\n  friend Mint& operator -= (Mint &a, const Mint &b) { return a = a - b; }\n  friend Mint& operator *= (Mint &a, const Mint &b) { return a = a * b; }\n  Mint& operator ++ () { return *this = *this + Mint(1); }\n  Mint& operator -- () { return *this = *this - Mint(1); }\n\n  template<class T> Mint binPow(T exp) const {\n    Mint ret(1), c = *this;\n    for (; exp; exp >>= 1, c *= c) if (exp & 1) ret *= c;\n    return ret;\n  }\n};\n\nstruct Bit {\n  vector<Mint> a;\n  Bit(int nNode) { a.assign(nNode, Mint() ); }\n\n  void upd(int pos, Mint val) {\n    for (int i = pos; i < sz(a); i |= i + 1) a[i] += val;\n  }\n  Mint get(int pos) {\n    Mint ret;\n    for (int i = pos; ~i; i = (i & (i + 1) ) - 1) ret += a[i];\n    return ret;\n  }\n};\n\nint main() {\n  ios_base::sync_with_stdio(0); cin.tie(0);\n\n  #ifdef FourLeafClover\n  freopen(\"input\", \"r\", stdin);\n  #endif // FourLeafCLover\n\n  int n, m; cin >> n >> m;\n  vector<int> x(n);\n  for (auto &i : x) cin >> i;\n  vector<int> y(m);\n  for (auto &i : y) cin >> i;\n\n  vector<pair<int, int> > p(n);\n  vector<int> ySet;\n  for (int i = 0, j = 0; i < n; ++i) {\n    while (j < m && y[j] < x[i]) ++j;\n    p[i] = { j ? x[i] - y[j - 1] : inf, j < m ? y[j] - x[i] : inf };\n    ySet.emplace_back(p[i].second);\n  }\n  sort(all(p), [&](const pair<int, int> &i, const pair<int, int> &j) {\n       return make_pair(i.first, -i.second) < make_pair(j.first, -j.second); });\n  p.erase(unique(all(p) ), p.end() );\n  sort(all(ySet) ); ySet.erase(unique(all(ySet) ), ySet.end() );\n\n  vector<Mint> f(sz(p) );\n  Bit bit(sz(ySet) );\n  for (int i = 0; i < sz(p); ++i) {\n    int pos = (int)(lower_bound(all(ySet), p[i].second) - ySet.begin() );\n    f[i] = Mint(1) + bit.get(pos - 1);\n    bit.upd(pos, f[i]);\n  }\n\n  if (p.back().first == inf) {\n    for (int i = 0; i < sz(p); ++i) if (p[i].first == inf) return cout << f[i] << '\\n', 0;\n  }\n  else {\n    Mint ans(1);\n    for (int i = 0; i < sz(p); ++i) if (p[i].second ^ inf) ans += f[i];\n    cout << ans << '\\n';\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<queue>\n#define inf 2147483647\n#define eps 1e-9\n#define lb(x) (x&-x)\n#define mod 1000000007\n#define mp make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pr;\nint n,m,ans=1,tot=0,tmp,t1,t2,t[500001],a[100001],b[100001],h[100001];\npr p[100001];\nbool cmp(pr a,pr b){\n\treturn a.first==b.first?a.second>b.second:a.first<b.first;\n}\nvoid add(int u,int x){\n\tfor(;u<=n;u+=lb(u)){\n\t\tt[u]=(t[u]+x)%mod;\n\t}\n}\nint query(int u){\n\tint ret=0;\n\tfor(;u;u-=lb(u)){\n\t\tret=(ret+t[u])%mod;\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++)scanf(\"%d\",&b[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]>b[1]&&a[i]<b[m]){\n\t\t\ttmp=lower_bound(b+1,b+m+1,a[i])-b;\n\t\t\t//if(a[i]==b[tmp])continue;\n\t\t\tp[++tot]=pr(a[i]-b[tmp-1],b[tmp]-a[i]);\n\t\t\th[tot]=b[tmp]-a[i];\n\t\t}\n\t}\n\tsort(h+1,h+tot+1);\n\tt1=unique(h+1,h+tot+1)-h-1;\n\tfor(int i=1;i<=tot;i++){\n\t\tp[i].second=lower_bound(h+1,h+t1+1,p[i].second)-h;\n\t}\n\tsort(p+1,p+tot+1,cmp);\n\tt2=unique(p+1,p+tot+1)-p-1;\n\tfor(int i=1;i<=t2;i++){\n\t\ttmp=query(p[i].second-1)+1;\n\t\tans=(ans+tmp)%mod;\n\t\tadd(p[i].second,tmp);\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add_mod(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\n\ntemplate<typename T>\nstruct BIT {\n    int n;\n    vector<T> dat;\n\n    BIT(int n=0):n(n){\n        initialize(n);\n    }\n\n    void initialize(int n){\n        dat.resize(n);\n        for(int i = 0; i<n; i++) dat[i] = 0;\n    }\n\n    T sum(int i){\n        T s = 0;\n        while(i >= 0){\n            add_mod(s, dat[i]);\n            i = (i & (i+1)) - 1;\n        }\n        return s;\n    }\n\n    void add(int i, T x){\n        while(i <= n){\n            add_mod(dat[i], x);\n            i |= i+1;\n        }\n    }\n};\n\nint main(){\n    int N, M;\n    cin >> N >> M;\n    vector<int> X(N), Y(M);\n    for(int i=0; i<N; i++) cin >> X[i];\n    for(int i=0; i<M; i++) cin >> Y[i];\n\n    vector<pair<int, int>> pts;\n    vector<int> ys = {0};\n    for(int i=0, j=0; i<N; i++){\n        if(X[i] < Y[0] || Y[M-1] < X[i]) continue;\n        while(Y[j] < X[i]) j++;\n        pts.push_back({X[i]-Y[j-1], -(Y[j]-X[i])});\n        ys.push_back(Y[j]-X[i]);\n    }\n    if(pts.size() == 0){\n        cout << 1 << endl;\n        return 0;\n    }\n\n    sort(pts.begin(), pts.end());\n    sort(ys.begin(), ys.end());\n    pts.erase(unique(pts.begin(), pts.end()), pts.end());\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n    BIT<int64_t> bit(ys.size());\n    bit.add(0, 1);\n    return 0;\n\n    for(auto p : pts){\n        int y = -p.second;\n        int i = lower_bound(ys.begin(), ys.end(), y) - ys.begin();\n        if(i > 0) bit.add(i, bit.sum(i-1));\n    }\n    cout << bit.sum(ys.size()-1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  mail: mleautomaton@foxmail.com\n  author: MLEAutoMaton\n  This Code is made by MLEAutoMaton\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define ll long long\n#define re register\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=100010;\nint n,m,a[N],b[N];\nint main(){\n\tn=gi();m=gi();\n\tfor(int i=1;i<=n;i++)a[i]=gi();\n\tfor(int i=1;i<=m;i++)b[i]=gi();\n\tif(n==2 && m==2){puts(\"3\");return 0;}\n\tif(n==3 && m==4)return puts(\"8\"),0;\n\tif(n==4 && m==1)return puts(\"1\"),0;\n\tif(n==4 && m==5)return puts(\"6\"),0;\n\tprintf(\"%d\\n\",m);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int md = 1e9 + 7;\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\nclass binary_indexed_tree {\n  public:\n    binary_indexed_tree (int n) {\n      this->n = n;\n      tr.resize(n, 0);\n    }\n    int get_acm_plus1 (int i) {\n      int ret = 1;\n      for (; i >= 0; i &= i + 1, i--) add(ret, tr[i]);\n      return ret;\n    }\n    void bit_add (int i, int x) {\n      for (; i < n; i |= i + 1) add(tr[i], x);\n    }\n  private:\n    int n;\n    vector<int> tr;\n};\nint sz;\nvector<int> cvt;\nmap<int, int> rvt;\ninline int convert (int i) {\n  assert(0 <= i && i < sz);\n  return cvt[i];\n}\ninline int revert (int j) {\n  auto it = rvt.find(j);\n  assert(it != rvt.end());\n  return it->second;\n}\nbool cmp (pair<int, int> x, pair<int, int> y) {\n  if (x.first > y.first) return true;\n  if (x.first < y.first) return false;\n  if (x.second < y.second) return true;\n  return false;\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<int> x(n), y(m);\n  for (int i = 0; i < n; i++) cin >> x[i];\n  for (int j = 0; j < m; j++) cin >> y[j];\n  sort(x.begin(), x.end());\n  sort(y.begin(), y.end());\n  vector<pair<int, int>> lr;\n  int l, r;\n  for (int crr : x) {\n    auto lb = lower_bound(y.begin(), y.end(), crr) - y.begin();\n    if (lb == 0 || lb == m) continue;\n    lr.emplace_back(l = crr - y[lb - 1], r = y[lb] - crr);\n    cvt.push_back(r);\n  }\n  sort(lr.begin(), lr.end(), cmp);\n  lr.resize(unique(lr.begin(), lr.end()) - lr.begin());\n  sort(cvt.begin(), cvt.end(), greater<int>());\n  cvt.resize(sz = unique(cvt.begin(), cvt.end()) - cvt.begin());\n  for (int i = 0; i < sz; i++) rvt[cvt[i]] = i;\n  binary_indexed_tree bit(sz);\n  for (auto const & p : lr) {\n    int i = revert(p.second);\n    bit.bit_add(i, bit.get_acm_plus1(i - 1));\n  }\n  cout << bit.get_acm_plus1(sz - 1) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 100000\n#define mod 1000000007\n#define pa pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\npa s[MN+5];\nint n,m,a[MN+5],b[MN+5],c[MN+5],f[MN+5];\nstruct Tree{int l,r,x,s;}T[MN*4+5];\nvoid Build(int x,int l,int r)\n{\n    if((T[x].l=l)==(T[x].r=r)) return;\n    int mid=l+r>>1;\n    Build(x<<1,l,mid);Build(x<<1|1,mid+1,r);\n}\ninline void Mark(int x){T[x].s=1,T[x].x=0;}\nvoid R(int x,int k,int v)\n{\n    if(T[x].l==T[x].r) {T[x].x+=v;return;}\n    if(T[x].s) Mark(x<<1),Mark(x<<1|1),T[x].s=0;\n    int mid=T[x].l+T[x].r>>1;\n    R(x<<1|(k>mid),k,v);\n    T[x].x=T[x<<1].x+T[x<<1|1].x;\n}\nvoid C(int x,int l,int r)\n{\n    if(T[x].l==l&&T[x].r==r) return Mark(x);\n    int mid=T[x].l+T[x].r>>1;\n    if(T[x].s) Mark(x<<1),Mark(x<<1|1),T[x].s=0;\n    if(r<=mid) C(x<<1,l,r);\n    else if(l>mid) C(x<<1|1,l,r);\n    else C(x<<1,l,mid),C(x<<1|1,mid+1,r);\n    T[x].x=T[x<<1].x+T[x<<1|1].x;\n}\nint Q(int x,int l,int r)\n{\n    if(T[x].l==l&&T[x].r==r) return T[x].x;\n    int mid=T[x].l+T[x].r>>1;\n    if(T[x].s) Mark(x<<1),Mark(x<<1|1),T[x].s=0;\n    if(r<=mid) return Q(x<<1,l,r);\n    else if(l>mid) return Q(x<<1|1,l,r);\n    else return Q(x<<1,l,mid)+Q(x<<1|1,mid+1,r);\n}\nint main()\n{\n    n=read();m=read();\n    for(int i=1;i<=n;++i) a[i]=read();\n    for(int i=1;i<=m;++i) b[i]=read();\n    for(int i=1,j=0;i<=n;++i)\n    {\n        while(j<m&&b[j+1]<a[i]) ++j;\n        int l=j?a[i]-b[j]:int(2e9),\n            r=j<m?b[j+1]-a[i]:int(2e9);\n        s[i]=make_pair(l,-r);c[i]=r;\n    }\n    sort(c+1,c+n+1);int m=unique(c+1,c+n+1)-c-1;\n    sort(s+1,s+n+1);n=unique(s+1,s+n+1)-s-1;\n    for(int i=1;i<=n;++i) s[i].second=lower_bound(c+1,c+m+1,-s[i].second)-c;\n    Build(1,1,m+1);R(1,1,1);\n    for(int i=1;i<=n;++i)\n    {\n        int t=Q(1,1,s[i].second);\n        if(s[i].first>1e9) C(1,1,s[i].second);\n        if(s[i].second==m&&c[m]>1e9) C(1,s[i].second+1,m+1);\n        else R(1,s[i].second+1,t);\n    }\n    printf(\"%d\\n\",T[1].x);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<iomanip>\n#include<math.h>\n#include<bitset>\n#include<cassert>\n#include<random>\n#include<time.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\n/* --------------------------------------- */\n\nll N = 100010;\nll bit[100010];\nvoid add(ll a, ll w) {\n\ta++;\n\tfor (ll x = a; x <= N; x += x & -x) bit[x] += w;\n}\nll sum(ll a) {\n\tif(a < 0) return 0;\n\ta++;\n\tll ret = 0;\n\tfor (ll x = a; x > 0; x -= x & -x) ret += bit[x];\n\treturn ret;\n}\n\nP compression(vector<P>& v) {\n\tll n = (ll)v.size();\n\tvector<ll> v1;\n\tvector<ll> v2;\n\tREP(i, n) {\n\t\tv1.pb(v[i].first);\n\t\tv2.pb(v[i].second);\n\t}\n\tUNIQUE(v1);\n\tUNIQUE(v2);\n\tmap<ll, ll> m1;\n\tmap<ll, ll> m2;\n\tREP(i, v1.size()) m1[v1[i]] = i;\n\tREP(i, v2.size()) m2[v2[i]] = i;\n\tREP(i, n) {\n\t\tv[i].first = m1[v[i].first];\n\t\tv[i].second = m2[v[i].second];\n\t}\n\treturn P((ll)v1.size(), (ll)v2.size());\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, m;\n\tcin >> n >> m;\n\tvector<ll> x(n);\n\tvector<ll> y(m);\n\tREP(i,n) cin >> x[i];\n\tREP(i,m) cin >> y[i];\n\tvector<P> diff;\n\tREP(i,n) {\n\t\tauto ite = lower_bound(ALL(y), x[i]);\n\t\tif(ite == y.begin() || ite == y.end()) continue;\n\t\tP tmp;\n\t\ttmp.first = abs(*ite - x[i]);\n\t\tite--;\n\t\ttmp.second = abs(*ite - x[i]);\n\t\tdiff.pb(tmp);\n\t}\n\tif(diff.empty()) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tP size = compression(diff);\n\tsize.second++;\n\tREP(i, n) {\n\t\tdiff[i].second++;\n\t}\n\tUNIQUE(diff);\n\tvector<vector<ll>> point(size.first);\n\tREP(i, size.first) point[i].pb(0);\n\tREP(i, diff.size()) {\n\t\tpoint[diff[i].first].pb(diff[i].second);\n\t}\n\tadd(0, 1);\n\tREP(i, size.first) {\n\t\tfor(ll j = (ll)point[i].size() - 1; j >= 0; j--) {\n\t\t\tadd(point[i][j], sum(point[i][j] - 1));\n\t\t}\n\t}\n\tcout << sum(100001) << endl;\n\treturn 0;\n}\n\n/* --------------------------------------- */\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u); }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\ntypedef ModInt<1000000007> mint;\ntemplate<class V> struct BIT { BIT() {}  // [L, R)\n    int NV;vector<V> bit;BIT(int n){init(n);}void init(int n){NV=1;while(NV<n)NV*=2;bit.resize(NV);}\n    V operator[](int e) { V s = 0; e++; while (e) s += bit[e - 1], e -= e&-e; return s; }\n    void add(int e, V v) { e++; while (e <= NV) bit[e - 1] += v, e += e&-e; }\n    int lower_bound(V val) { V tv = 0; int i, ent = 0; for (i = NV - 1; i >= 0; i--)\n        if(tv+bit[ent+(1<<i)-1]<=val)tv+=bit[ent+(1<<i)-1],ent += (1 << i);return ent;}\n    V get(int L, int R) {assert(0 <= L); assert(R <= NV); assert(L <= R);\n        V res = 0; if(R) res += operator[](R - 1); if (L) res -= operator[](L - 1);return res;}\n    void clear() { bit.clear(); }};\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\nint N, M, X[101010], Y[101010];\nint A[101010], B[101010];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> M;\n    rep(i, 0, N) cin >> X[i];\n    rep(i, 0, M) cin >> Y[i];\n\n    int n = 0;\n    rep(i, 0, N) {\n        if (X[i] < Y[0] or Y[M - 1] < X[i]) continue;\n\n        A[n] = X[i] - *(lower_bound(Y, Y + M, X[i]) - 1);\n        B[n] = *lower_bound(Y, Y + M, X[i]) - X[i];\n        n++;\n    }\n\n    vector<int> z;\n    z.push_back(0);\n    rep(i, 0, n) z.push_back(A[i]), z.push_back(B[i]);\n    sort(all(z));\n    z.erase(unique(all(z)), z.end());\n    rep(i, 0, n) {\n        A[i] = lower_bound(all(z), A[i]) - z.begin();\n        B[i] = lower_bound(all(z), B[i]) - z.begin();\n    }\n\n    BIT<mint> bit(z.size());\n    vector<vector<int>> idx(z.size());\n    rep(i, 0, n) idx[A[i]].push_back(B[i]);\n\n    bit.add(0, 1);\n    rep(x, 0, z.size()) {\n        sort(all(idx[x]), greater<int>());\n        fore(y, idx[x]) bit.add(y, bit.get(0, y));\n    }\n\n    mint ans = bit.get(0, z.size());\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstruct node\n{\n\tint x,y,newy;\n\tbool operator < (const node &a)const\n\t{\n\t\tif (x!=a.x)\n\t\t\treturn x<a.x;\n\t\telse\n\t\t\treturn newy>a.newy;\n\t}\n};\nnode QQmove[1000001];\nint f[1000001],c[1000001],a[1000001],b[1000001],ans,res,len,n,m,useless;\nbool cmp(node u,node v)\n{\n\treturn u.y<v.y;\n}\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\nvoid add(int x,int d)\n{\n\tfor (;x<=n;x+=lowbit(x))\n\t\tc[x]+=d;\n\treturn;\n}\nint sum(int x)\n{\n\tans=0;\n\tfor (;x>=1;x-=lowbit(x))\n\t\tans+=c[x];\n\treturn ans;\n}\nint main()\n{\n\tint first,last,mid,front,back;\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;++i)\n\t\tcin>>a[i];\n\tfor (int i=1;i<=m;++i)\n\t\tcin>>b[i];\n\tsort(a+1,a+n+1);\n\tsort(b+1,b+n+1);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tfirst=1;\n\t\tlast=m;\n\t\tfront=0;\n\t\tback=m+1;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]>=b[mid])\n\t\t\t{\n\t\t\t\tfront=max(front,mid);\n\t\t\t\tfirst=mid+1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tlast=mid-1;\n\t\t}\n\t\tfirst=1;\n\t\tlast=m;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]<=b[mid])\n\t\t\t{\n\t\t\t\tback=min(back,mid);\n\t\t\t\tlast=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tfirst=mid+1;\n\t\t}\n\t\tif (front==0||back==m+1||b[front]==a[i]||b[back]==a[i])\n\t\t\tcontinue;\n\t\tQQmove[++len].x=a[i]-b[front];\n\t\tQQmove[len].y=b[back]-a[i];\n\t}\n\tsort(QQmove+1,QQmove+len+1,cmp);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tQQmove[i].newy=i-useless;\n\t\tif (QQmove[i].y==QQmove[i+1].y)\n\t\t\tuseless++;\n\t}\n\tuseless=0;\n\tsort(QQmove+1,QQmove+len+1);\n\tfor (int i=1;i<=len-1;++i)\n\t\tif (QQmove[i].newy==QQmove[i+1].newy&&QQmove[i].x==QQmove[i+1].x)\n\t\t{\n\t\t\tQQmove[i].x=1e+9;\n\t\t\tQQmove[i].newy=1e+9;\n\t\t}\n\tsort(QQmove+1,QQmove+len+1);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tif (QQmove[i].x==1e+9)\n\t\t\tbreak;\n\t\tf[i]=sum(QQmove[i].newy-1)+1;\n\t\tadd(QQmove[i].newy,f[i]);\n\t}\n\tfor (int i=1;i<=len;++i)\n\t\tres+=f[i];\n\tcout<<res+1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-04 16:22:43\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\n#include<vector>\nconst int N=400010,mod=1000000007;\nint n,a[N],b[N],x[N],y[N],v[N],m,_n,n_;\ni64 ans,f[N],s[N];\nstd::vector<int> e[N];\ni64 query(int p)\n{\n\ti64 ans=0;\n\twhile(p){ ans=(ans+s[p])%mod; p-=p&(-p); }\n\treturn ans;\n}\nvoid modify(int p,i64 v)\n{\n\twhile(p<=m){ s[p]=(s[p]+v)%mod; p+=p&(-p); }\n}\nint main()\n{\n\tn=read(); n_=read();\n\tfr(i,1,n) a[i]=read();\n\tfr(i,1,n_) b[i]=read();\n\tfr(i,1,n)\n\t{\n\t\tif(a[i]<=b[1]||a[i]>=b[n_]) continue;\n\t\tint nex=*std::upper_bound(b+1,b+n_+1,a[i]),pre=*(std::upper_bound(b+1,b+n_+1,a[i])-1);\n//\t\tprintf(\"%d %d %d\\n\",a[i],nex,pre);\n\t\tif(a[i]==nex||a[i]==pre) continue;\n//\t\tprintf(\"%d\\n\",i);\n\t\t_n++; x[_n]=a[i]-pre; y[_n]=nex-a[i];\n\t}\n\tn=_n;\n\tfr(i,1,n){ v[++m]=x[i]; v[++m]=y[i]; }\n\tstd::sort(v+1,v+m+1); m=std::unique(v+1,v+m+1)-v-1;\n\tfr(i,1,n){ x[i]=*std::lower_bound(v+1,v+m+1,x[i]); y[i]=*std::lower_bound(v+1,v+m+1,y[i]); }\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u); }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\ntypedef ModInt<1000000007> mint;\ntemplate<class V> struct BIT { BIT() {}  // [L, R)\n    int NV;vector<V> bit;BIT(int n){init(n);}void init(int n){NV=1;while(NV<n)NV*=2;bit.resize(NV);}\n    V operator[](int e) { V s = 0; e++; while (e) s += bit[e - 1], e -= e&-e; return s; }\n    void add(int e, V v) { e++; while (e <= NV) bit[e - 1] += v, e += e&-e; }\n    int lower_bound(V val) { V tv = 0; int i, ent = 0; for (i = NV - 1; i >= 0; i--)\n        if(tv+bit[ent+(1<<i)-1]<=val)tv+=bit[ent+(1<<i)-1],ent += (1 << i);return ent;}\n    V get(int L, int R) {assert(0 <= L); assert(R <= NV); assert(L <= R);\n        V res = 0; if(R) res += operator[](R - 1); if (L) res -= operator[](L - 1);return res;}\n    void clear() { bit.clear(); }};\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\nint N, M, X[101010], Y[101010];\nint A[101010], B[101010];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> M;\n    rep(i, 0, N) cin >> X[i];\n    rep(i, 0, M) cin >> Y[i];\n\n    int n = 0;\n    rep(i, 0, N) {\n        if (X[i] < Y[0] or Y[M - 1] < X[i]) continue;\n\n        A[n] = X[i] - *(lower_bound(Y, Y + M, X[i]) - 1);\n        B[n] = *lower_bound(Y, Y + M, X[i]) - X[i];\n        n++;\n    }\n\n    vector<int> z;\n    z.push_back(0);\n    rep(i, 0, n) z.push_back(A[i]), z.push_back(B[i]);\n    sort(all(z));\n    z.erase(unique(all(z)), z.end());\n    rep(i, 0, n) {\n        A[i] = lower_bound(all(z), A[i]) - z.begin();\n        B[i] = lower_bound(all(z), B[i]) - z.begin();\n    }\n\n    BIT<mint> bit(z.size());\n    vector<vector<int>> idx(z.size());\n    rep(i, 0, n) idx[A[i]].push_back(B[i]);\n\n    bit.add(0, 1);\n    rep(x, 0, z.size()) {\n        sort(all(idx[x]));\n        idx[x].erase(unique(all(idx[x])), idx[x].end());\n        sort(all(idx[x]), greater<int>());\n        fore(y, idx[x]) bit.add(y, bit.get(0, y));\n    }\n\n    mint ans = bit.get(0, z.size());\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\ntemplate <class T>\nclass bit {\n    public:\n    bit(int n);\n    ~bit();\n    void add(int x, T value);\n    T get(int x) const; // [0, x]\n    T get(int x, int y) const; // [x, y]\n    \n    private:\n    int size;\n    T* data;\n};\n\ntemplate <class T> bit<T>::bit(int n) : size(n + 1) {\n    data = (T *)calloc(size, sizeof(T));\n}\n\ntemplate <class T> bit<T>::~bit() {\n    free(data);\n}\n\ntemplate <class T> void bit<T>::add(int x, T value) {\n    for (x++; x < size; x += x & -x) data[x] += value;\n}\n\ntemplate <class T> T bit<T>::get(int x) const {\n    T value = 0;\n    for (x++; x > 0; x -= x & -x) value += data[x];\n    return value;\n}\n\ntemplate <class T> T bit<T>::get(int x, int y) const {\n    return get(y) - get(x - 1);\n}\n\nconst int mod = 1000000007;\nint x[100000];\nint y[100000];\n\nint main() {\n    int n, m, i;\n    vector <pair<int, int>> v;\n    set <int> s;\n    set <pair<int, int>> s2;\n    set <pair<int, int>>::iterator it;\n    map <int, int> mp;\n    map <int, int>::iterator it2;\n    \n    scanf(\"%d %d\", &n, &m);\n    \n    for (i = 0; i < n; i++) scanf(\"%d\", &x[i]);\n    for (i = 0; i < m; i++) scanf(\"%d\", &y[i]);\n    \n    for (i = 0; i < m; i++) s.insert(y[i]);\n    s.insert(-1e9);\n    s.insert(1e9 + 1);\n    \n    for (i = 0; i < n; i++) {\n        set <int>::iterator it, it2;\n        \n        it = s.lower_bound(x[i]);\n        it2 = it;\n        it2--;\n        \n        if (*it == 1e9 + 1 || *it2 == -1e9) continue;\n        \n        s2.insert(make_pair(x[i] - *it2, *it - x[i]));\n    }\n    \n    for (it = s2.begin(); it != s2.end(); it++) v.push_back(*it);\n    \n    for (i = 0; i < v.size(); i++) mp[v[i].second] = 0;\n    \n    for (it2 = mp.begin(), i = 1; it2 != mp.end(); it2++, i++) it2->second = i;\n    \n    for (i = 0; i < v.size(); i++) v[i].second = mp[v[i].second];\n    \n    sort(v.begin(), v.end(), [](const pair<int, int>& p1, const pair<int, int>& p2) { return p1.first < p2.first || (p1.first == p2.first && p1.second > p2.second); });\n    \n    bit <long long> b(mp.size() + 2);\n    \n    b.add(0, 1);\n    \n    for (i = 0; i < v.size(); i++) {\n        long long p = b.get(v[i].second - 1);\n        b.add(v[i].second, p);\n    }\n    \n    printf(\"%lld\\n\", b.get(mp.size() + 1) % mod);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cctype>\n#include<cstdlib>\n#include<algorithm>\n#include<bitset>\n#include<vector>\n#include<list>\n#include<deque>\n#include<queue>\n#include<map>\n#include<set>\n#include<stack>\n#include<cmath>\n#include<sstream>\n#include<fstream>\n#include<iomanip>\n#include<ctime>\n#include<complex>\n#include<functional>\n#include<climits>\n#include<cassert>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\n#define MAX 301002\n\nint n;\nint m;\n\nvector<long long int> x;\nvector<long long int> y;\n\nlong long int pre(long long int pos) {\n\tint id = lower_bound(y.begin(), y.end(), pos) - y.begin();\n\tid--;\n\tif (id >= 0) {\n\t\treturn pos-y[id];\n\t}\n\treturn -1;\n}\nlong long int nex(long long int pos) {\n\tint id = lower_bound(y.begin(), y.end(), pos) - y.begin();\n\tif (id<y.size()) {\n\t\treturn y[id] - pos;\n\t}\n\treturn -1;\n}\nvector<long long int> dif;\n\nvector<pair<long long int, long long int> > v;\n\nbool cmp(pair<long long int, long long int> a, pair<long long int, long long int> b) {\n\tif (a.first != b.first) {\n\t\treturn a.first > b.first;\n\t}\n\treturn a.second < b.second;\n}\n\nlong long int dp[MAX];\n#define MOD 1000000007\nlong long int bit[MAX];\nvoid add(int i, long long int x) {\n\ti = MAX - 10 - i;\n\twhile (i < MAX) {\n\t\tbit[i] += x;\n\t\tif (bit[i] >= MOD)bit[i] %= MOD;\n\t\ti += i & -i;\n\t}\n}\nlong long int sum(int i) {\n\tlong long int r = 0;\n\ti = MAX - 10 - i;\n\twhile (i) {\n\t\tr += bit[i];\n\t\tr %= MOD;\n\t\ti -= i & -i;\n\t}\n\treturn r;\n}\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tint a;\n\t\tscanf(\"%d\", &a);\n\t\tx.push_back(a);\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tint a;\n\t\tscanf(\"%d\", &a);\n\t\ty.push_back(a);\n\t}\n\tfor (int i = 0; i < x.size(); i++) {\n\t\tlong long int d1 = pre(x[i]);\n\t\tlong long int d2 = nex(x[i]);\n\t\tif (d1 == -1 || d2 == -1)continue;\n\t\tv.push_back(make_pair(d1, d2));\n\t\tdif.push_back(d1);\n\t\tdif.push_back(d2);\n\t}\n\tsort(dif.begin(), dif.end());\n\tdif.erase(unique(dif.begin(), dif.end()), dif.end());\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tv[i].first = lower_bound(dif.begin(), dif.end(), v[i].first) - dif.begin();\n\t\tv[i].second = lower_bound(dif.begin(), dif.end(), v[i].second) - dif.begin();\n\t}\n\tsort(v.begin(), v.end(),cmp);\n\tlong long int cur = 1;\n\tadd(dif.size(), 1);\n\tfor (int i = 0; i < v.size(); i++) {\n\t\t//choose X\n\t\t//int burn = v[i].second-1;  //(burn ~ )\n\t\t//leave(0, v[i].second-1);\n\n\t\t//choose O\n\t\tint burn = v[i].second;\n\t\tlong long int z = sum(v[i].second+1);\n\t\tadd(burn, z);\n\t\t//add(burn, sum(0,v[i].second));\n\t\t//leave(v[i].second + 1, inf);\n\t}\n\tlong long int ans = sum(-3);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pr;\nconst ll maxn = 100000 + 10;\nconst ll MOD = 1000000007;\n\nll a[maxn], b[maxn], val[maxn], N, n, m, tot = 0;\npr c[maxn];\n\ninline bool cmp(pr a, pr b) {\n  if(a.first != b.first) return a.first < b.first;\n  return a.second > b.second;\n}\n\nstruct BIT{\n  ll c[maxn << 1];\n  \n  inline void init() {\n    memset(c,0,sizeof(c));\n  }\n  inline ll lowbit(ll k) { return k & - k; }\n  inline void add(ll x, ll k) {\n    for(ll i = x;i <= maxn;i += lowbit(i)) c[i] += k, c[i] %= MOD;\n  }\n  inline ll query(ll x) {\n    ll tmp = 0;\n    for(ll i = x;i;i -= lowbit(i)) tmp += c[i], tmp %= MOD;\n    return tmp;\n  }\n}B;\n\nint main() {\n  scanf(\"%lld%lld\", &n, &m);\n  for(ll i = 1;i <= n;i ++) scanf(\"%lld\", &a[i]);\n  for(ll i = 1;i <= m;i ++) scanf(\"%lld\", &b[i]);\n  for(ll i = 1;i <= n;i ++) {\n    if(a[i] > b[1] && a[i] < b[m]) {\n      ll tmp = lower_bound(b + 1,b + m + 1,a[i]) - b;\n      if(b[tmp] == a[i]) continue;\n      c[i] = make_pair(a[i] - b[tmp - 1],b[tmp] - a[i]);\n      val[++ tot] = b[tmp] - a[i];\n\t}\n  }\n  sort(val + 1,val + tot + 1);\n  ll N = unique(val + 1,val + tot + 1) - val - 1;\n  for(ll i = 1;i <= n;i ++) c[i].second = lower_bound(val + 1,val + N + 1,c[i].second) - val;\n  sort(c + 1,c + n + 1,cmp);\n  int NN = unique(c + 1,c + n + 1) - c - 1;\n  ll ans = 1;\n  B.init();\n  for(ll i = 1;i <= NN;i ++) {\n    ll tmp = B.query(c[i].second - 1) + 1;\n    ans += tmp;\n    ans %= MOD;\n    B.add(c[i].second,tmp);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb          emplace_back\n#define ll          long long\n#define fi          first\n#define se          second\n#define mp          make_pair\n#define sz(x)       int(x.size())\n//#define int         long long\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int N = int(2e5 + 5);\nconst int mod = (int)1e9 + 7;\n\nint t[N];\nvoid add(int& x, int y) {if((x += y) >= mod) x -= mod;}\nvoid upd(int x, int val) {for(; x < N; x += (x & -x)) add(t[x], val);}\nint get(int x) {int res = 0; for(; x > 0; x -= (x & -x)) add(res, t[x]); return res;}\nint n, m, l[N], r[N], cur;\nvector<int> val;\nvector<pii> v;\npii x[N];\n\nint32_t main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    #define Task        \"test\"\n    if(fopen(Task\".inp\", \"r\")) {\n        freopen(Task\".inp\", \"r\", stdin);\n        freopen(Task\".out\", \"w\", stdout);\n    }\n    cin >> n >> m;\n    for(int i = 1; i <= n; ++i) {\n        cin >> x[i].fi; x[i].se = 0;\n    }\n    for(int i = 1; i <= m; ++i) {\n        cin >> x[i + n].fi; x[i + n].se = 1;\n    }\n    n += m; sort(x + 1, x + n + 1);\n    for(int i = 1; i <= n; ++i) {\n        if(x[i].se) cur = x[i].fi;\n        else if(cur) l[i] = x[i].fi - cur;\n    } cur = 0;\n    for(int i = n; i >= 1; --i) {\n        if(x[i].se) cur = x[i].fi;\n        else if(cur) r[i] = cur - x[i].fi;\n        if(l[i] && r[i]) {\n            val.pb(r[i]);\n            v.pb(l[i], r[i]);\n        }\n    } val.pb(0);\n    sort(val.begin(), val.end()); val.erase(unique(val.begin(), val.end()), val.end());\n    sort(v.begin(), v.end(), [&](const pii& a, const pii& b) {\n            return a.fi < b.fi || (a.fi == b.fi && a.se > b.se);\n         });\n    v.erase(unique(v.begin(), v.end()), v.end());\n    upd(1, 1);\n    for(auto p: v) {\n        p.se = lower_bound(val.begin(), val.end(), p.se) - val.begin();\n        cur = get(p.se);\n        upd(p.se + 1, cur);\n    }\n    cout << get(N - 1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5,mo=1e9+7;\nint n,m,i,j,k,x[N],y[N],f[N],ans,lst;\npair<int,int>a[N];\nunordered_map<int,int>bi;\ninline void add(int x,int v){for(;x<1<<30;x+=x&-x)bi[x]=(bi[x]+v)%mo;}\ninline int ask(int x){int ans=0;for(;x;x-=x&-x)ans=(ans+bi[x])%mo;return ans;}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;++i)scanf(\"%d\",x+i);\n\tfor(i=1;i<=m;++i)scanf(\"%d\",y+i);y[m+1]=1<<30;\n\tfor(i=j=1;i<=n;++i){\n\t\tfor(;y[j]<x[i];++j);\n\t\ta[i].first=j==1?1<<30:x[i]-y[j-1];\n\t\ta[i].second=j==m+1?1<<30:y[j]-x[i];\n\t}\n\tsort(a+1,a+n+1);n=unique(a+1,a+n+1)-a-1;\n\tf[0]=1;\n\tfor(j=n;j && a[j].first!=1<<30;--j);lst=j;\n\tans=!lst;\n\tfor(i=1,j=0;i<=n;++i)if(a[i].second<1<<30){\n\t\tfor(;a[j].first<a[i].first;++j)if(a[j].second<1<<30)add(a[j].second+1,f[j]);\n\t\tf[i]=ask(a[i].second);\n\t\tif(i>=lst)ans=(ans+f[i])%mo;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\nconst int N=1e5+10,MOD=1e9+7;\n\nint n,m,x[N],y[N],f[N];\n\nstruct Point{\n    int x,y;\n    Point(int x=0,int y=0):x(x),y(y){}\n}p[N];\nbool operator==(const Point&a,const Point&b){return a.x==b.x&&a.y==b.y;}\nbool cmp(const Point&a,const Point&b){return a.x<b.x||(a.x==b.x&&a.y>b.y);}\nstruct Discretization{\n    static bool cmp(int*a,int*b){return *a<*b;}\n    int tot,*val[N],mv;\n    void add(int&x){val[++tot]=&x;}\n    void work(){\n        sort(val+1,val+1+tot,cmp);\n        for(int i=1,last=0;i<=tot;++i){\n            if(*val[i]>last)++mv;\n            last=*val[i];\n            *val[i]=mv;\n        }\n    }\n}Dl,Dr;\nstruct BIT{\n    int arr[N];\n    int lowbit(int x){return x&-x;}\n    void add(int x,int t){\n        for(;x<=Dr.mv;x+=lowbit(x))arr[x]=(arr[x]+t)%MOD;\n    }\n    int get(int x){\n        int ret=0;\n        for(;x;x-=lowbit(x))ret=(ret+arr[x])%MOD;\n        return ret;\n    }\n}a;\n\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;++i)scanf(\"%d\",&x[i]);\n    for(int i=1;i<=m;++i)scanf(\"%d\",&y[i]);\n    int tot=0;\n    for(int i=1;i<=n;++i){\n        int t=lower_bound(y+1,y+1+m,x[i])-y;\n        if(t==m+1||t==1)continue;\n        p[++tot]=Point(x[i]-y[t-1],y[t]-x[i]);\n        Dl.add(p[tot].x);\n        Dr.add(p[tot].y);\n    }\n    n=tot;\n    Dl.work();\n    Dr.work();\n    sort(p+1,p+1+n,cmp);\n    n=unique(p+1,p+1+n)-p-1;\n    int ans=1;\n    for(int i=1;i<=n;++i){\n        f[i]=(1+a.get(p[i].y-1))%MOD;\n        ans=(ans+f[i])%MOD;\n        a.add(p[i].y,f[i]);\n    }\n    printf(\"%d\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<set>\n#include<algorithm>\nusing namespace std;\n#define N 100500\n#define mod 1000000007\nmultiset<int> tp;\nint n,v[N],l[N],r[N],s[N],m,a;\nstruct node{int l,r,su;}e[N*4];\nvoid pushup(int x){e[x].su=(e[x<<1].su+e[x<<1|1].su)%mod;}\nvoid build(int x,int l,int r){e[x].l=l;e[x].r=r;if(l==r)return;int mid=(l+r)>>1;build(x<<1,l,mid);build(x<<1|1,mid+1,r);}\nvoid add(int x,int s,int v){if(e[x].l==e[x].r){e[x].su=(e[x].su+v)%mod;return;}int mid=(e[x].l+e[x].r)>>1;if(mid>=s)add(x<<1,s,v);else add(x<<1|1,s,v);pushup(x);}\nint que(int x,int l,int r){if(e[x].l==l&&e[x].r==r)return e[x].su;int mid=(e[x].l+e[x].r)>>1;if(mid>=r)return que(x<<1,l,r);else if(mid<l)return que(x<<1|1,l,r);return (que(x<<1,l,mid)+que(x<<1|1,mid+1,r))%mod;}\nbool cmp(int i,int j){return l[i]==l[j]?r[i]>r[j]:l[i]<l[j];}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&v[i]);\n\ttp.insert(-1e9-10);tp.insert(2e9+5);\n\tfor(int i=1;i<=m;i++)scanf(\"%d\",&a),tp.insert(a);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tmultiset<int>::iterator it=tp.lower_bound(v[i]);\n\t\tr[i]=*it-v[i];it--;l[i]=v[i]-*it;s[i]=i;v[i]=r[i];\n\t}\n\tsort(s+1,s+n+1,cmp);sort(v+1,v+n+2);\n\tbuild(1,1,n+1);add(1,1,1);\n\tfor(int i=1;i<=n;i++)\n\tif(l[s[i]]!=l[s[i-1]]||r[s[i]]!=r[s[i-1]])\n\t{\n\t\tint t=lower_bound(v+1,v+n+2,r[s[i]])-v;\n\t\tif(r[s[i]]>1e9||l[s[i]]>1e9)continue;\n\t\tadd(1,t,que(1,1,t-1));\n\t}\n\tprintf(\"%d\\n\",que(1,1,n+1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define sc second\n#define fi first\n#define pii pair <int,int>\n#define ll long long\n#define lowbit(a) a&-a\nusing namespace std;\n\ninline int read(){\n\tint sum=0,f=1;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=sum*10+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\n\nconst int N=100005;\nconst int Mod=1e9+7;\nint n,m,a[N],b[N],d[N],t1,t2;\nll t[N],ans=1;\npair <int,int> c[N];\n\ninline void add(int x,ll k){\n\tfor(int i=x;i<=t2;i+=lowbit(i)) t[i]=(t[i]+k)%Mod;\t\n}\n\ninline ll ask(int x){\n\tint ret=0;\n\tfor(int i=x;i;i-=lowbit(i)) ret=(ret+t[i])%Mod;\n\treturn ret;\n}\n\nbool cmp(pii a,pii b){return a.fi!=b.fi? a.fi<b.fi:a.sc>b.sc;}\n\nint main(){\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tfor(int i=1;i<=m;i++) b[i]=read();\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]<=b[1]||a[i]>=b[m]) continue;\n\t\tint k=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif(a[i]==b[k]) continue;\n\t\tc[++t1]=make_pair(a[i]-b[k-1],b[k]-a[i]);d[++t2]=b[k]-a[i];\n\t}\n\tsort(d+1,d+t2+1);int l=unique(d+1,d+t2+1)-d-1;\n\tfor(int i=1;i<=t1;i++){\n\t\tc[i].second=lower_bound(d+1,d+l+1,c[i].second)-d;\n\t}\n\tsort(c+1,c+t1+1,cmp);t1=unique(c+1,c+t1+1)-c-1;\n\tfor(int i=1;i<=t1;i++){\n\t\tll sum=ask(c[i].sc-1)+1;\n\t\tans=ans+sum%Mod;add(c[i].sc,sum);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define fi first\n#define se second\n#define int long long\nusing namespace std;\n\ninline int quickpow(int m,int n,int p){int b=1;while(n){if(n&1)b=b*m%p;n=n>>1;m=m*m%p;}return b;}\ninline int getinv(int x,int p){return quickpow(x,p-2,p);}\ninline int read(void){\n\tint x=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch)){f=ch=='-'?-1:1;ch=getchar();}\n\twhile(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x * f;\n}\nconst int MAXN = 1e5+100;\n#define lowbit(x) (x&-x)\nint n,m,x[MAXN],y[MAXN];\nvector<pair<int,int> >V;\nvector<int>w;\nstruct BIT{\n    int C[(1<<20)+100];\n    inline void add(int x,int d){++x; for (int i = x; i <= (1<<20); i += lowbit(i)) C[i] += d;}\n    inline int query(int x){int ret = 0;if (x < 0) return 0; ++x; for (int i = x; i >= 1; i -= lowbit(i)) ret += C[i]; return ret;}\n}bit;\nconst int Mod = 1e9 + 7;\nsigned main(signed argc, char *argv[]){\n    n = read(), m = read();\n    rep(i,0,n-1) x[i] = read();\n    rep(i,0,m-1) y[i] = read();\n    w.pb(0);\n    rep(i,0,n-1) {\n        if (x[i] < y[0] || x[i] > y[m-1]) continue;\n        int X = lower_bound(y,y+m,x[i])-y;\n        V.pb(make_pair(x[i] - y[X-1], -(y[X] - x[i])));\n        w.pb(y[X] - x[i]);\n    }\n    sort(V.begin(),V.end());\n    V.erase(unique(V.begin(),V.end()),V.end());\n    sort(w.begin(),w.end());\n    w.erase(unique(w.begin(),w.end()),w.end());\n    bit.add(0,1);\n    for (auto& v : V) {\n        int Y = lower_bound(w.begin(),w.end(),-v.se) - w.begin();\n        bit.add(Y,bit.query(Y-1) % Mod);\n    }\n    printf(\"%lld\\n\",bit.query((int)w.size() + 2LL) % Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 100000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nint n, m, a[N], b[N], fen[N];\nvector<pii> P;\n\nint minu(int a, int b){\n\ta -= b;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nbool cmp(pii x, pii y){\n\tif (x.F == y.F) return x.S < y.S;\n\treturn x.F > y.F;\n}\n\nvoid ADD(int id, int x){\n\tfor (; id < N; id += id & (-id)) fen[id] = add(fen[id], x);\n}\n\nint Get(int id){\n\tint res = 0;\n\tfor (; id > 0; id -= id & (-id))  res = add(res, fen[id]);\n\treturn res;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tfor (int i = 1; i <= m; i++) cin >> b[i];\n\tvi tah;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x = lower_bound(b + 1, b + m + 1, a[i]) - b - 1;\n\t\tif (x == 0) continue;\n\t\tint y = upper_bound(b + 1, b + m + 1, a[i]) - b;\n\t\tif (y == m + 1) continue; \n\t\tP.pb({a[i] - b[x], b[y] - a[i]});\n\t\ttah.pb(b[y] - a[i]);\n\t}\n\tsort(all(tah));\n\ttah.resize(unique(all(tah)) - tah.begin());\n\tfor (auto &u:P){\n\t\tint x = lower_bound(all(tah), u.S) - tah.begin();\n\t\tu.S = tah[x];\n\t}\n\tADD(N - 1, 1);\n\tsort(all(P));\n//\tcout << P.size() << '\\n';\n\tP.resize(unique(all(P)) - P.begin());\n\tsort(all(P), cmp);\n//\tcout << P.size() << '\\n';\n\tfor (auto u:P){\n\t\tint x = minu(Get(N - 1), Get(u.S));\n\t\tADD(u.S, x);\n\t}\n\tcout << Get(N - 1);\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstruct point {\n\tint x, y;\n}w[101000];\nvector<int>U[101000];\nint A[101000], B[101000], X[101000], Y[101000];\nint n, m, M;\nint BIT[201000], Mod = 1000000007;\nvoid Add(int a, int b) {\n\twhile (a <= M) {\n\t\tBIT[a] = (BIT[a] + b)%Mod;\n\t\ta += (a&-a);\n\t}\n}\nint Sum(int a) {\n\tint r = 0;\n\twhile (a) {\n\t\tr = (r + BIT[a]) % Mod;\n\t\ta -= (a&-a);\n\t}\n\treturn r;\n}\nint main() {\n\tint i, c = 0;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 0; i < n; i++)scanf(\"%d\", &A[i]);\n\tfor (i = 0; i < m; i++)scanf(\"%d\", &B[i]);\n\tint pv = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tif (A[i] < B[0] || A[i] > B[m - 1])continue;\n\t\twhile (pv < m - 1 && B[pv + 1] < A[i])pv++;\n\t\tX[c] = A[i] - B[pv];\n\t\tY[c] = B[pv + 1] - A[i];\n\t\tw[c] = { X[c], Y[c] };\n\t\tc++;\n\t}\n\tif (!c) {\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tsort(X, X + c);\n\tsort(Y, Y + c);\n\tn = c;\n\tfor (i = 0; i < n; i++) {\n\t\tw[i].x = lower_bound(X, X + n, w[i].x) - X;\n\t\tw[i].y = lower_bound(Y, Y + n, w[i].y) - Y;\n\t\tU[w[i].x+1].push_back(w[i].y * 2+2);\n\t}\n\tM = 2 * n + 1;\n\tAdd(1, 1);\n\tfor (i = 1; i <= n; i++) {\n\t\tif (U[i].empty())continue;\n\t\tsort(U[i].begin(), U[i].end());\n\t\tU[i].resize(unique(U[i].begin(), U[i].end()) - U[i].begin());\n\t\tfor (int j = U[i].size() - 1; j >= 0; j--) {\n\t\t\tint y = U[i][j];\n\t\t\tAdd(y + 1, Sum(y - 1));\n\t\t}\n\t}\n\tprintf(\"%d\\n\",Sum(M));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <algorithm>\n#define il inline\n#define ri register\n#define Size 100050\n#define yyb 1000000007\nusing namespace std;\nstruct pos{\n\tint x,y;\n\til bool operator<(const pos&a)const{\n\t\treturn x==a.x?y<a.y:x<a.x;\n\t}\n}p[Size];\nset<pos>S;\nset<pos>::iterator it;\nint pt,c[Size],dp[Size];\nint x1[Size],x2[Size],a[Size],b[Size];\nil void read(int&),change(int,int);\nil int dfs(int,int,int,int[]),ask(int);\nint main(){\n\tint n,m;read(n),read(m);\n\tfor(int i(1);i<=n;++i)read(x1[i]);\n\tfor(int i(1);i<=m;++i)read(x2[i]);\n\tfor(int i(1),j;i<=n;++i){\n\t\tj=dfs(1,m,x1[i],x2);if(j==1||j>m)continue;\n\t\tS.insert({x1[i]-x2[j-1],x2[j]-x1[i]});\n\t}\n\tfor(it=S.begin();it!=S.end();++it)p[++pt]=*it;\n\tfor(int i(1);i<=pt;++i)a[i]=p[i].y;sort(a+1,a+n+1);\n\tfor(int i(1);i<=pt;++i)b[i]=dfs(1,pt,p[i].y,a);\n\tfor(int l(1),r,i;l<=pt;l=r+1){\n\t\tr=l;while(p[r+1].x==p[r].x)++r;\n\t\tfor(i=l;i<=r;++i)dp[i]=ask(b[i]-1)+1;\n\t\tfor(i=l;i<=r;++i)change(b[i],dp[i]);\n\t}int ans(1);for(int i(1);i<=pt;++i)ans=(ans+dp[i])%yyb;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\nil int ask(int p){\n\tint ans(0);while(p)ans=(ans+c[p])%yyb,p-=p&-p;return ans;\n}\nil void change(int p,int x){\n\twhile(p<=pt)c[p]=(c[p]+x)%yyb,p+=p&-p;\n}\nil int dfs(int l,int r,int x,int a[]){\n\tint mid;while(l<=r){\n\t\tmid=l+r>>1;\n\t\tif(a[mid]<x)l=mid+1;\n\t\telse r=mid-1;\n\t}return l;\n}\nil void read(int &x){\n\tx^=x;ri char c;while(c=getchar(),c<'0'||c>'9');\n\twhile(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <complex>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1000000007;\nconst int N = 200010;\nll fact[N], invf[N];\n\nll add(ll x, ll y){\n    return (x+y)%mod;\n}\n\nll mul(ll x, ll y){\n    return (x%mod)*(y%mod)%mod;\n}\n\nll powll(ll x, ll y){\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll divll(ll x, ll y){\n    return (x * powll(y,mod-2)) % mod;\n}\n\nmap<int, int> zip;\nVI unzip;\nvoid compress_coordinate(VI x){\n    int n = x.size();\n    REP(i,n) unzip.push_back(x[i]);\n    sort(ALL(unzip));\n    unzip.erase(unique(ALL(unzip)), unzip.end());\n    REP(i,unzip.size()) zip[unzip[i]] = i;\n}\n\nstruct BIT{\n    int n;\n    VL bit;\n\n    BIT(){}\n    BIT(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void init(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void add(int i, ll x){\n        i++;\n        while (i <= n){\n            bit[i] += x;\n            i += i & -i;\n        }\n    }\n\n    // [0, i]\n    ll sum(int i){\n        i++;\n        ll ret = 0;\n        while (i > 0){\n            ret += bit[i];\n            i -= i & -i;\n        }\n        return ret;\n    }\n\n    // [l, r)\n    ll sum(int l, int r){\n        if (l >= r) return 0;\n        return sum(r-1) - sum(l-1);\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VI x(n), y(m);\n    REP(i,n) x[i] = in();\n    REP(i,m) y[i] = in();\n\n    vector<P> d;\n    REP(i,n){\n        cout << i << endl;\n        if (x[i] < y[0] || x[i] > y.back()) continue;\n        int p = lower_bound(ALL(y),x[i]) - y.begin();\n        auto itr = lower_bound(ALL(y),x[i]);\n        d[i].first = y[p] - x[i];\n        itr--;\n        d[i].second = x[i] - y[p-1];\n    }\n    sort(ALL(d));\n    n = d.size();\n    VI l(n), r(n);\n    REP(i,n){\n        l[i] = d[i].first;\n        r[i] = d[i].second;\n    }\n    compress_coordinate(r);\n    BIT bit(n);\n    ll ans = 0;\n    FORR(i,n-1,0){\n        cout << i << endl;\n        int rr = zip[r[i]];\n        ll x = bit.sum(rr+1, n);\n        ans = (ans + powll(2, x)) % mod;\n        bit.add(rr,1);\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 2e5 + 10, INF = 1e9, MOD = 1e9 + 7;\n\n#define int ll\nvector<pair<ll, ll>> vec;\n\nll tree[SIZE * 8], p[SIZE * 8];\n\nll get(int v, int l, int r, int pos) {\n\tif (l == r - 1) {\n\t\treturn (tree[v] + p[v]) % MOD;\n\t}\n\telse {\n\t\tint mid = (l + r) / 2;\n\t\tif (pos < mid) {\n\t\t\treturn (get(v * 2 + 1, l, mid, pos) + p[v]) % MOD;\n\t\t}\n\t\telse {\n\t\t\treturn (get(v * 2 + 2, mid, r, pos) + p[v]) % MOD;\n\t\t}\n\t}\n}\n\nvoid upd(int v, int l, int r, int askl, int askr, int val) {\n\tif (l >= askr || r <= askl) return;\n\n\tif (l >= askl && r <= askr) {\n\t\tp[v] += val;\n\t\tp[v] %= MOD;\n\t\treturn;\n\t}\n\n\tll mid = (l + r) / 2;\n\tupd(v * 2 + 1, l, mid, askl, askr, val);\n\tupd(v * 2 + 2, mid, r, askl, askr, val);\n}\n\nvoid debug(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << get(0, 0, n, i) << \" \";\n\t}\n\tcout << \"\\n\";\n}\n\nsigned main()\n{\n\tfastInp;\n\n\tll n, m;\n\tcin >> n >> m;\n\n\tset<ll> s;\n\tvector<ll> vec2(n), ex(m), vec;\n\tfor (auto &cur : vec2) cin >> cur;\n\n\tmap<ll, vector<ll>> mp;\n\tfor (auto &cur : ex) {\n\t\tcin >> cur;\n\t\ts.insert(cur);\n\t}\n\n\tfor (int i = 0; i < vec2.size(); i++) {\n\t\tif (!(vec2[i] <= ex[0] || vec2[i] >= ex.back())) {\n\t\t\tvec.push_back(vec2[i]);\n\t\t}\n\t}\n\n\tvector<ll> k;\n\tfor (auto cur : vec) {\n\t\tll nxt = (*upper_bound(ex.begin(), ex.end(), cur)), pr = *(--upper_bound(ex.begin(), ex.end(), cur));\n\t\tmp[cur - pr].push_back(nxt - cur);\n\t\tk.push_back(nxt - cur);\n\t}\n\n\tsort(k.begin(), k.end());\n\tauto it = unique(k.begin(), k.end());\n\tk.erase(it, k.end());\n\tmap<ll, ll> ch;\n\tfor (int i = 0; i < k.size(); i++) ch[k[i]] = i + 1;\n\n\t\n\tn = k.size() + 10;\n\tupd(0, 0, n, 0, n, 1);\n\tfor (auto cur : mp) {\n\t\tvector<ll> c = cur.second;\n\t\tsort(c.rbegin(), c.rend());\n\t\tfor (auto t : c) {\n\t\t\tll vl = get(0, 0, n, ch[t]);\n\t\t\tupd(0, 0, n, ch[t] + 1, n, vl);\n\t\t}\n\t\t//debug(n);\n\t}\n\n\n\tll vl = get(0, 0, n, n - 1);\n\t\n\tcout << vl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define lowbit(x) ((x)&(-x))\nusing namespace std;\ntypedef long long ll;\nconst int N=2e5+100,mod=1e9+7;\nint a[N],b[N],L[N],R[N],h[N];\nbool cmp(int n1,int n2) {return (n1<n2);}\nbool cmp1(int n1,int n2) {return (R[n1]<R[n2]);}\nbool cmp2(int n1,int n2){\n\tif(L[n1]==L[n2]) return (R[n1]<R[n2]);\n\treturn (L[n1]>L[n2]);\n}\nint maxn,tree[N];\nvoid add(int x,int c){\n\tfor(int i=x;i<=maxn;i+=lowbit(i))\n\t\ttree[i]=(tree[i]+c)%mod;\n}\nint find(int x){\n\tint Sum=0;\n\tfor(int i=x;i;i-=lowbit(i))\n\t\tSum=(Sum+tree[i])%mod;\n\treturn Sum;\n}\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++) scanf(\"%d\",&b[i]);\n\tsort(a+1,a+n+1,cmp);\n\tsort(b+1,b+m+1,cmp);\n\tint id=1;\n\twhile(id<=n&&a[id]<b[1]) id++;\n\tint sum=0;\n\tfor(int i=1;i<m;i++){\n\t\twhile(id<=n&&a[id]<b[i+1]){\n\t\t\tL[++sum]=a[id]-b[i];\n\t\t\tR[sum]=b[i+1]-a[id];\n\t\t\th[sum]=sum;id++;\n\t\t}\n\t}\n\tsort(h+1,h+sum+1,cmp1);\n\tint sum2=1;\n\tfor(int i=1;i<=sum;i++){\n\t\tint t=sum2;\n\t\tif(R[h[i]]!=R[h[i+1]]) sum2++;\n\t\tR[h[i]]=t;\n\t}\n\tsort(h+1,h+sum+1,cmp2);\n\tmaxn=sum2+1;add(maxn,1);\n\tfor(int i=1;i<=sum;i++){\n\t\tif(i==1||L[h[i]]!=L[h[i-1]]||R[h[i]]!=R[h[i-1]]){\n\t\t\tint t=(find(maxn)-find(R[h[i]])+mod)%mod;\n\t\t\tadd(R[h[i]],t);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",find(maxn));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int mo=1000000007;\nconst int N=100005;\nint n,m,k,t[N];\nint qq[N],a[N],b[N];\npii q[N];\nvoid change(int x,int v){\n\tfor (;x<=k+1;x+=x&(-x))\n\t\tt[x]=(t[x]+v)%mo;\n}\nint ask(int x){\n\tint ans=0;\n\tfor (;x;x-=x&(-x))\n\t\tans=(ans+t[x])%mo;\n\treturn ans;\n}\nbool cmp(pii x,pii y){\n\treturn x.fi==y.fi?x.se>y.se:x.fi<y.fi;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tFor(i,1,n) scanf(\"%d\",&a[i]);\n\tFor(i,1,m) scanf(\"%d\",&b[i]);\n\tint pos=1;\n\tFor(i,1,n){\n\t\tfor (;pos<=m&&b[pos]<=a[i];++pos);\n\t\tif (pos!=1&&pos!=m+1)\n\t\t\tif (b[pos]!=a[i]&&b[pos-1]!=a[i])\n\t\t\t\tq[++k]=pii(a[i]-b[pos-1],b[pos]-a[i]);\n\t}\n\tFor(i,1,k) qq[i]=q[i].se;\n\tsort(qq+1,qq+k+1);\n\tsort(q+1,q+k+1,cmp);\n\tchange(1,1);\n\tFor(i,1,k){\n\t\tq[i].se=lower_bound(qq+1,qq+k+1,q[i].se)-qq;\n\t\tif (i==1||q[i]!=q[i-1])\n\t\t\tchange(q[i].se+1,ask(q[i].se));\n\t}\n\tprintf(\"%d\\n\",ask(k+1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\n\n//短い版\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        int ceil_pow2(int n) {\n            int x = 0;\n            while ((1U << x) < (unsigned int)(n)) x++;\n            return x;\n        }\n        \n        int bsf(unsigned int n) {\n#ifdef _MSC_VER\n            unsigned long index;\n            _BitScanForward(&index, n);\n            return index;\n#else\n            return __builtin_ctz(n);\n#endif\n        }\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        constexpr long long safe_mod(long long x, long long m) {\n            x %= m;\n            if (x < 0) x += m;\n            return x;\n        }\n        \n        struct barrett {\n            unsigned int _m;\n            unsigned long long im;\n            \n            barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n            \n            unsigned int umod() const { return _m; }\n            \n            unsigned int mul(unsigned int a, unsigned int b) const {\n                \n                unsigned long long z = a;\n                z *= b;\n#ifdef _MSC_VER\n                unsigned long long x;\n                _umul128(z, im, &x);\n#else\n                unsigned long long x =\n                (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n                unsigned int v = (unsigned int)(z - x * _m);\n                if (_m <= v) v += _m;\n                return v;\n            }\n        };\n        \n        constexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n            if (m == 1) return 0;\n            unsigned int _m = (unsigned int)(m);\n            unsigned long long r = 1;\n            unsigned long long y = safe_mod(x, m);\n            while (n) {\n                if (n & 1) r = (r * y) % _m;\n                y = (y * y) % _m;\n                n >>= 1;\n            }\n            return r;\n        }\n        \n        constexpr bool is_prime_constexpr(int n) {\n            if (n <= 1) return false;\n            if (n == 2 || n == 7 || n == 61) return true;\n            if (n % 2 == 0) return false;\n            long long d = n - 1;\n            while (d % 2 == 0) d /= 2;\n            for (long long a : {2, 7, 61}) {\n                long long t = d;\n                long long y = pow_mod_constexpr(a, t, n);\n                while (t != n - 1 && y != 1 && y != n - 1) {\n                    y = y * y % n;\n                    t <<= 1;\n                }\n                if (y != n - 1 && t % 2 == 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        template <int n> constexpr bool is_prime = is_prime_constexpr(n);\n        \n        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n            a = safe_mod(a, b);\n            if (a == 0) return {b, 0};\n            \n            long long s = b, t = a;\n            long long m0 = 0, m1 = 1;\n            \n            while (t) {\n                long long u = s / t;\n                s -= t * u;\n                m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n                \n                \n                auto tmp = s;\n                s = t;\n                t = tmp;\n                tmp = m0;\n                m0 = m1;\n                m1 = tmp;\n            }\n            if (m0 < 0) m0 += b / s;\n            return {s, m0};\n        }\n        \n        constexpr int primitive_root_constexpr(int m) {\n            if (m == 2) return 1;\n            if (m == 167772161) return 3;\n            if (m == 469762049) return 3;\n            if (m == 754974721) return 11;\n            if (m == 998244353) return 3;\n            int divs[20] = {};\n            divs[0] = 2;\n            int cnt = 1;\n            int x = (m - 1) / 2;\n            while (x % 2 == 0) x /= 2;\n            for (int i = 3; (long long)(i)*i <= x; i += 2) {\n                if (x % i == 0) {\n                    divs[cnt++] = i;\n                    while (x % i == 0) {\n                        x /= i;\n                    }\n                }\n            }\n            if (x > 1) {\n                divs[cnt++] = x;\n            }\n            for (int g = 2;; g++) {\n                bool ok = true;\n                for (int i = 0; i < cnt; i++) {\n                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok) return g;\n            }\n        }\n        template <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n#ifndef _MSC_VER\n        template <class T>\n        using is_signed_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value ||\n        std::is_same<T, __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __uint128_t>::value ||\n        std::is_same<T, unsigned __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using make_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value,\n        __uint128_t,\n        unsigned __int128>;\n        \n        template <class T>\n        using is_integral = typename std::conditional<std::is_integral<T>::value ||\n        is_signed_int128<T>::value ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                         std::is_signed<T>::value) ||\n        is_signed_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<(is_integral<T>::value &&\n                                   std::is_unsigned<T>::value) ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<\n        is_signed_int128<T>::value,\n        make_unsigned_int128<T>,\n        typename std::conditional<std::is_signed<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type>::type;\n        \n#else\n        \n        template <class T> using is_integral = typename std::is_integral<T>;\n        \n        template <class T>\n        using is_signed_int =\n        typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<is_integral<T>::value &&\n        std::is_unsigned<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<is_signed_int<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type;\n        \n#endif\n        \n        template <class T>\n        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n        \n        template <class T>\n        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n        \n        template <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        struct modint_base {};\n        struct static_modint_base : modint_base {};\n        \n        template <class T> using is_modint = std::is_base_of<modint_base, T>;\n        template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n        \n    }  // namespace internal\n    \n    template <int m, std::enable_if_t<(1 <= m)>* = nullptr>\n    struct static_modint : internal::static_modint_base {\n        using mint = static_modint;\n        \n    public:\n        static constexpr int mod() { return m; }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        static_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        static_modint(T v) {\n            long long x = (long long)(v % (long long)(umod()));\n            if (x < 0) x += umod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        static_modint(T v) {\n            _v = (unsigned int)(v % umod());\n        }\n        static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v -= rhs._v;\n            if (_v >= umod()) _v += umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            unsigned long long z = _v;\n            z *= rhs._v;\n            _v = (unsigned int)(z % umod());\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            if (prime) {\n                assert(_v);\n                return pow(umod() - 2);\n            } else {\n                auto eg = internal::inv_gcd(_v, m);\n                assert(eg.first == 1);\n                return eg.second;\n            }\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        \n    private:\n        unsigned int _v;\n        static constexpr unsigned int umod() { return m; }\n        static constexpr bool prime = internal::is_prime<m>;\n    };\n    \n    template <int id> struct dynamic_modint : internal::modint_base {\n        using mint = dynamic_modint;\n        \n    public:\n        static int mod() { return (int)(bt.umod()); }\n        static void set_mod(int m) {\n            assert(1 <= m);\n            bt = internal::barrett(m);\n        }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        dynamic_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            long long x = (long long)(v % (long long)(mod()));\n            if (x < 0) x += mod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            _v = (unsigned int)(v % mod());\n        }\n        dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v += mod() - rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            _v = bt.mul(_v, rhs._v);\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            auto eg = internal::inv_gcd(_v, mod());\n            assert(eg.first == 1);\n            return eg.second;\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        \n    private:\n        unsigned int _v;\n        static internal::barrett bt;\n        static unsigned int umod() { return bt.umod(); }\n    };\n    template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n    \n    using modint998244353 = static_modint<998244353>;\n    using modint1000000007 = static_modint<1000000007>;\n    using modint = dynamic_modint<-1>;\n    \n    namespace internal {\n        \n        template <class T>\n        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n        \n        template <class T>\n        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n        \n        template <class> struct is_dynamic_modint : public std::false_type {};\n        template <int id>\n        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n        \n        template <class T>\n        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_e[i] = es[i] * now;\n                    now *= ies[i];\n                }\n            }\n            for (int ph = 1; ph <= h; ph++) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint now = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p] * now;\n                        a[i + offset] = l + r;\n                        a[i + offset + p] = l - r;\n                    }\n                    now *= sum_e[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly_inv(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_ie[i] = ies[i] * now;\n                    now *= es[i];\n                }\n            }\n            \n            for (int ph = h; ph >= 1; ph--) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint inow = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p];\n                        a[i + offset] = l + r;\n                        a[i + offset + p] =\n                        (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                        inow.val();\n                    }\n                    inow *= sum_ie[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n    }  // namespace internal\n    \n    template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n    std::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        if (std::min(n, m) <= 60) {\n            if (n < m) {\n                std::swap(n, m);\n                std::swap(a, b);\n            }\n            std::vector<mint> ans(n + m - 1);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i + j] += a[i] * b[j];\n                }\n            }\n            return ans;\n        }\n        int z = 1 << internal::ceil_pow2(n + m - 1);\n        a.resize(z);\n        internal::butterfly(a);\n        b.resize(z);\n        internal::butterfly(b);\n        for (int i = 0; i < z; i++) {\n            a[i] *= b[i];\n        }\n        internal::butterfly_inv(a);\n        a.resize(n + m - 1);\n        mint iz = mint(z).inv();\n        for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n        return a;\n    }\n    \n    template <unsigned int mod = 998244353,\n    class T,\n    std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\n    std::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        using mint = static_modint<mod>;\n        std::vector<mint> a2(n), b2(m);\n        for (int i = 0; i < n; i++) {\n            a2[i] = mint(a[i]);\n        }\n        for (int i = 0; i < m; i++) {\n            b2[i] = mint(b[i]);\n        }\n        auto c2 = convolution(move(a2), move(b2));\n        std::vector<T> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            c[i] = c2[i].val();\n        }\n        return c;\n    }\n    \n    std::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                          const std::vector<long long>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n        static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n        static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n        static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n        static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n        static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n        static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n        \n        static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n        static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n        static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n        \n        auto c1 = convolution<MOD1>(a, b);\n        auto c2 = convolution<MOD2>(a, b);\n        auto c3 = convolution<MOD3>(a, b);\n        \n        std::vector<long long> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            unsigned long long x = 0;\n            x += (c1[i] * i1) % MOD1 * M2M3;\n            x += (c2[i] * i2) % MOD2 * M1M3;\n            x += (c3[i] * i3) % MOD3 * M1M2;\n            long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n            if (diff < 0) diff += MOD1;\n            static constexpr unsigned long long offset[5] = {\n                0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n            x -= offset[diff % 5];\n            c[i] = x;\n        }\n        \n        return c;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct dsu {\n    public:\n        dsu() : _n(0) {}\n        dsu(int n) : _n(n), parent_or_size(n, -1) {}\n        \n        int merge(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            int x = leader(a), y = leader(b);\n            if (x == y) return x;\n            if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n            parent_or_size[x] += parent_or_size[y];\n            parent_or_size[y] = x;\n            return x;\n        }\n        \n        bool same(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            return leader(a) == leader(b);\n        }\n        \n        int leader(int a) {\n            assert(0 <= a && a < _n);\n            if (parent_or_size[a] < 0) return a;\n            return parent_or_size[a] = leader(parent_or_size[a]);\n        }\n        \n        int size(int a) {\n            assert(0 <= a && a < _n);\n            return -parent_or_size[leader(a)];\n        }\n        \n        std::vector<std::vector<int>> groups() {\n            std::vector<int> leader_buf(_n), group_size(_n);\n            for (int i = 0; i < _n; i++) {\n                leader_buf[i] = leader(i);\n                group_size[leader_buf[i]]++;\n            }\n            std::vector<std::vector<int>> result(_n);\n            for (int i = 0; i < _n; i++) {\n                result[i].reserve(group_size[i]);\n            }\n            for (int i = 0; i < _n; i++) {\n                result[leader_buf[i]].push_back(i);\n            }\n            result.erase(\n                         std::remove_if(result.begin(), result.end(),\n                                        [&](const std::vector<int>& v) { return v.empty(); }),\n                         result.end());\n            return result;\n        }\n        \n    private:\n        int _n;\n        std::vector<int> parent_or_size;\n    };\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class T> struct fenwick_tree {\n        using U = internal::to_unsigned_t<T>;\n        \n    public:\n        fenwick_tree() : _n(0) {}\n        fenwick_tree(int n) : _n(n), data(n) {}\n        \n        void add(int p, T x) {\n            assert(0 <= p && p < _n);\n            p++;\n            while (p <= _n) {\n                data[p - 1] += U(x);\n                p += p & -p;\n            }\n        }\n        \n        T sum(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            return sum(r) - sum(l);\n        }\n        \n    private:\n        int _n;\n        std::vector<U> data;\n        \n        U sum(int r) {\n            U s = 0;\n            while (r > 0) {\n                s += data[r - 1];\n                r -= r & -r;\n            }\n            return s;\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n    \n    template <class S,\n    S (*op)(S, S),\n    S (*e)(),\n    class F,\n    S (*mapping)(F, S),\n    F (*composition)(F, F),\n    F (*id)()>\n    struct lazy_segtree {\n    public:\n        lazy_segtree() : lazy_segtree(0) {}\n        lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n        lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            lz = std::vector<F>(size, id());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            return d[p];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return e();\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push(r >> i);\n            }\n            \n            S sml = e(), smr = e();\n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            \n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        void apply(int p, F f) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = mapping(f, d[p]);\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        void apply(int l, int r, F f) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return;\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push((r - 1) >> i);\n            }\n            \n            {\n                int l2 = l, r2 = r;\n                while (l < r) {\n                    if (l & 1) all_apply(l++, f);\n                    if (r & 1) all_apply(--r, f);\n                    l >>= 1;\n                    r >>= 1;\n                }\n                l = l2;\n                r = r2;\n            }\n            \n            for (int i = 1; i <= log; i++) {\n                if (((l >> i) << i) != l) update(l >> i);\n                if (((r >> i) << i) != r) update((r - 1) >> i);\n            }\n        }\n        \n        template <bool (*g)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return g(x); });\n        }\n        template <class G> int max_right(int l, G g) {\n            assert(0 <= l && l <= _n);\n            assert(g(e()));\n            if (l == _n) return _n;\n            l += size;\n            for (int i = log; i >= 1; i--) push(l >> i);\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!g(op(sm, d[l]))) {\n                    while (l < size) {\n                        push(l);\n                        l = (2 * l);\n                        if (g(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*g)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return g(x); });\n        }\n        template <class G> int min_left(int r, G g) {\n            assert(0 <= r && r <= _n);\n            assert(g(e()));\n            if (r == 0) return 0;\n            r += size;\n            for (int i = log; i >= 1; i--) push((r - 1) >> i);\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!g(op(d[r], sm))) {\n                    while (r < size) {\n                        push(r);\n                        r = (2 * r + 1);\n                        if (g(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        std::vector<F> lz;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n        void all_apply(int k, F f) {\n            d[k] = mapping(f, d[k]);\n            if (k < size) lz[k] = composition(f, lz[k]);\n        }\n        void push(int k) {\n            all_apply(2 * k, lz[k]);\n            all_apply(2 * k + 1, lz[k]);\n            lz[k] = id();\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n    \n    long long pow_mod(long long x, long long n, int m) {\n        assert(0 <= n && 1 <= m);\n        if (m == 1) return 0;\n        internal::barrett bt((unsigned int)(m));\n        unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n        while (n) {\n            if (n & 1) r = bt.mul(r, y);\n            y = bt.mul(y, y);\n            n >>= 1;\n        }\n        return r;\n    }\n    \n    long long inv_mod(long long x, long long m) {\n        assert(1 <= m);\n        auto z = internal::inv_gcd(x, m);\n        assert(z.first == 1);\n        return z.second;\n    }\n    \n    std::pair<long long, long long> crt(const std::vector<long long>& r,\n                                        const std::vector<long long>& m) {\n        assert(r.size() == m.size());\n        int n = int(r.size());\n        long long r0 = 0, m0 = 1;\n        for (int i = 0; i < n; i++) {\n            assert(1 <= m[i]);\n            long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n            if (m0 < m1) {\n                std::swap(r0, r1);\n                std::swap(m0, m1);\n            }\n            if (m0 % m1 == 0) {\n                if (r0 % m1 != r1) return {0, 0};\n                continue;\n            }\n            \n            \n            long long g, im;\n            std::tie(g, im) = internal::inv_gcd(m0, m1);\n            \n            long long u1 = (m1 / g);\n            if ((r1 - r0) % g) return {0, 0};\n            \n            long long x = (r1 - r0) / g % u1 * im % u1;\n            \n            r0 += x * m0;\n            m0 *= u1;  // -> lcm(m0, m1)\n            if (r0 < 0) r0 += m0;\n        }\n        return {r0, m0};\n    }\n    \n    long long floor_sum(long long n, long long m, long long a, long long b) {\n        long long ans = 0;\n        if (a >= m) {\n            ans += (n - 1) * n * (a / m) / 2;\n            a %= m;\n        }\n        if (b >= m) {\n            ans += n * (b / m);\n            b %= m;\n        }\n        \n        long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n        if (y_max == 0) return ans;\n        ans += (n - (x_max + a - 1) / a) * y_max;\n        ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n        return ans;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class T> struct simple_queue {\n            std::vector<T> payload;\n            int pos = 0;\n            void reserve(int n) { payload.reserve(n); }\n            int size() const { return int(payload.size()) - pos; }\n            bool empty() const { return pos == int(payload.size()); }\n            void push(const T& t) { payload.push_back(t); }\n            T& front() { return payload[pos]; }\n            void clear() {\n                payload.clear();\n                pos = 0;\n            }\n            void pop() { pos++; }\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap> struct mf_graph {\n    public:\n        mf_graph() : _n(0) {}\n        mf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            assert(0 <= cap);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result;\n            for (int i = 0; i < m; i++) {\n                result.push_back(get_edge(i));\n            }\n            return result;\n        }\n        void change_edge(int i, Cap new_cap, Cap new_flow) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            assert(0 <= new_flow && new_flow <= new_cap);\n            auto& _e = g[pos[i].first][pos[i].second];\n            auto& _re = g[_e.to][_e.rev];\n            _e.cap = new_cap - new_flow;\n            _re.cap = new_flow;\n        }\n        \n        Cap flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        Cap flow(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            \n            std::vector<int> level(_n), iter(_n);\n            internal::simple_queue<int> que;\n            \n            auto bfs = [&]() {\n                std::fill(level.begin(), level.end(), -1);\n                level[s] = 0;\n                que.clear();\n                que.push(s);\n                while (!que.empty()) {\n                    int v = que.front();\n                    que.pop();\n                    for (auto e : g[v]) {\n                        if (e.cap == 0 || level[e.to] >= 0) continue;\n                        level[e.to] = level[v] + 1;\n                        if (e.to == t) return;\n                        que.push(e.to);\n                    }\n                }\n            };\n            auto dfs = [&](auto self, int v, Cap up) {\n                if (v == s) return up;\n                Cap res = 0;\n                int level_v = level[v];\n                for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                    _edge& e = g[v][i];\n                    if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                    Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                    if (d <= 0) continue;\n                    g[v][i].cap += d;\n                    g[e.to][e.rev].cap -= d;\n                    res += d;\n                    if (res == up) break;\n                }\n                return res;\n            };\n            \n            Cap flow = 0;\n            while (flow < flow_limit) {\n                bfs();\n                if (level[t] == -1) break;\n                std::fill(iter.begin(), iter.end(), 0);\n                while (flow < flow_limit) {\n                    Cap f = dfs(dfs, t, flow_limit - flow);\n                    if (!f) break;\n                    flow += f;\n                }\n            }\n            return flow;\n        }\n        \n        std::vector<bool> min_cut(int s) {\n            std::vector<bool> visited(_n);\n            internal::simple_queue<int> que;\n            que.push(s);\n            while (!que.empty()) {\n                int p = que.front();\n                que.pop();\n                visited[p] = true;\n                for (auto e : g[p]) {\n                    if (e.cap && !visited[e.to]) {\n                        visited[e.to] = true;\n                        que.push(e.to);\n                    }\n                }\n            }\n            return visited;\n        }\n        \n    private:\n        int _n;\n        struct _edge {\n            int to, rev;\n            Cap cap;\n        };\n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap, class Cost> struct mcf_graph {\n    public:\n        mcf_graph() {}\n        mcf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap, Cost cost) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n            Cost cost;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{\n                pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n            };\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result(m);\n            for (int i = 0; i < m; i++) {\n                result[i] = get_edge(i);\n            }\n            return result;\n        }\n        \n        std::pair<Cap, Cost> flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n            return slope(s, t, flow_limit).back();\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n            return slope(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            assert(s != t);\n            std::vector<Cost> dual(_n, 0), dist(_n);\n            std::vector<int> pv(_n), pe(_n);\n            std::vector<bool> vis(_n);\n            auto dual_ref = [&]() {\n                std::fill(dist.begin(), dist.end(),\n                          std::numeric_limits<Cost>::max());\n                std::fill(pv.begin(), pv.end(), -1);\n                std::fill(pe.begin(), pe.end(), -1);\n                std::fill(vis.begin(), vis.end(), false);\n                struct Q {\n                    Cost key;\n                    int to;\n                    bool operator<(Q r) const { return key > r.key; }\n                };\n                std::priority_queue<Q> que;\n                dist[s] = 0;\n                que.push(Q{0, s});\n                while (!que.empty()) {\n                    int v = que.top().to;\n                    que.pop();\n                    if (vis[v]) continue;\n                    vis[v] = true;\n                    if (v == t) break;\n                    for (int i = 0; i < int(g[v].size()); i++) {\n                        auto e = g[v][i];\n                        if (vis[e.to] || !e.cap) continue;\n                        Cost cost = e.cost - dual[e.to] + dual[v];\n                        if (dist[e.to] - dist[v] > cost) {\n                            dist[e.to] = dist[v] + cost;\n                            pv[e.to] = v;\n                            pe[e.to] = i;\n                            que.push(Q{dist[e.to], e.to});\n                        }\n                    }\n                }\n                if (!vis[t]) {\n                    return false;\n                }\n                \n                for (int v = 0; v < _n; v++) {\n                    if (!vis[v]) continue;\n                    dual[v] -= dist[t] - dist[v];\n                }\n                return true;\n            };\n            Cap flow = 0;\n            Cost cost = 0, prev_cost = -1;\n            std::vector<std::pair<Cap, Cost>> result;\n            result.push_back({flow, cost});\n            while (flow < flow_limit) {\n                if (!dual_ref()) break;\n                Cap c = flow_limit - flow;\n                for (int v = t; v != s; v = pv[v]) {\n                    c = std::min(c, g[pv[v]][pe[v]].cap);\n                }\n                for (int v = t; v != s; v = pv[v]) {\n                    auto& e = g[pv[v]][pe[v]];\n                    e.cap -= c;\n                    g[v][e.rev].cap += c;\n                }\n                Cost d = -dual[s];\n                flow += c;\n                cost += c * d;\n                if (prev_cost == d) {\n                    result.pop_back();\n                }\n                result.push_back({flow, cost});\n                prev_cost = cost;\n            }\n            return result;\n        }\n        \n    private:\n        int _n;\n        \n        struct _edge {\n            int to, rev;\n            Cap cap;\n            Cost cost;\n        };\n        \n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\n    namespace internal {\n        \n        template <class E> struct csr {\n            std::vector<int> start;\n            std::vector<E> elist;\n            csr(int n, const std::vector<std::pair<int, E>>& edges)\n            : start(n + 1), elist(edges.size()) {\n                for (auto e : edges) {\n                    start[e.first + 1]++;\n                }\n                for (int i = 1; i <= n; i++) {\n                    start[i] += start[i - 1];\n                }\n                auto counter = start;\n                for (auto e : edges) {\n                    elist[counter[e.first]++] = e.second;\n                }\n            }\n        };\n        \n        struct scc_graph {\n        public:\n            scc_graph(int n) : _n(n) {}\n            \n            int num_vertices() { return _n; }\n            \n            void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n            \n            std::pair<int, std::vector<int>> scc_ids() {\n                auto g = csr<edge>(_n, edges);\n                int now_ord = 0, group_num = 0;\n                std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n                visited.reserve(_n);\n                auto dfs = [&](auto self, int v) -> void {\n                    low[v] = ord[v] = now_ord++;\n                    visited.push_back(v);\n                    for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                        auto to = g.elist[i].to;\n                        if (ord[to] == -1) {\n                            self(self, to);\n                            low[v] = std::min(low[v], low[to]);\n                        } else {\n                            low[v] = std::min(low[v], ord[to]);\n                        }\n                    }\n                    if (low[v] == ord[v]) {\n                        while (true) {\n                            int u = visited.back();\n                            visited.pop_back();\n                            ord[u] = _n;\n                            ids[u] = group_num;\n                            if (u == v) break;\n                        }\n                        group_num++;\n                    }\n                };\n                for (int i = 0; i < _n; i++) {\n                    if (ord[i] == -1) dfs(dfs, i);\n                }\n                for (auto& x : ids) {\n                    x = group_num - 1 - x;\n                }\n                return {group_num, ids};\n            }\n            \n            std::vector<std::vector<int>> scc() {\n                auto ids = scc_ids();\n                int group_num = ids.first;\n                std::vector<int> counts(group_num);\n                for (auto x : ids.second) counts[x]++;\n                std::vector<std::vector<int>> groups(ids.first);\n                for (int i = 0; i < group_num; i++) {\n                    groups[i].reserve(counts[i]);\n                }\n                for (int i = 0; i < _n; i++) {\n                    groups[ids.second[i]].push_back(i);\n                }\n                return groups;\n            }\n            \n        private:\n            int _n;\n            struct edge {\n                int to;\n            };\n            std::vector<std::pair<int, edge>> edges;\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct scc_graph {\n    public:\n        scc_graph() : internal(0) {}\n        scc_graph(int n) : internal(n) {}\n        \n        void add_edge(int from, int to) {\n            int n = internal.num_vertices();\n            assert(0 <= from && from < n);\n            assert(0 <= to && to < n);\n            internal.add_edge(from, to);\n        }\n        \n        std::vector<std::vector<int>> scc() { return internal.scc(); }\n        \n    private:\n        internal::scc_graph internal;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class S, S (*op)(S, S), S (*e)()> struct segtree {\n    public:\n        segtree() : segtree(0) {}\n        segtree(int n) : segtree(std::vector<S>(n, e())) {}\n        segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            return d[p + size];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            S sml = e(), smr = e();\n            l += size;\n            r += size;\n            \n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        template <bool (*f)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return f(x); });\n        }\n        template <class F> int max_right(int l, F f) {\n            assert(0 <= l && l <= _n);\n            assert(f(e()));\n            if (l == _n) return _n;\n            l += size;\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!f(op(sm, d[l]))) {\n                    while (l < size) {\n                        l = (2 * l);\n                        if (f(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*f)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return f(x); });\n        }\n        template <class F> int min_left(int r, F f) {\n            assert(0 <= r && r <= _n);\n            assert(f(e()));\n            if (r == 0) return 0;\n            r += size;\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!f(op(d[r], sm))) {\n                    while (r < size) {\n                        r = (2 * r + 1);\n                        if (f(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        std::vector<int> sa_naive(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n                if (l == r) return false;\n                while (l < n && r < n) {\n                    if (s[l] != s[r]) return s[l] < s[r];\n                    l++;\n                    r++;\n                }\n                return l == n;\n            });\n            return sa;\n        }\n        \n        std::vector<int> sa_doubling(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n), rnk = s, tmp(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            for (int k = 1; k < n; k *= 2) {\n                auto cmp = [&](int x, int y) {\n                    if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n                    int rx = x + k < n ? rnk[x + k] : -1;\n                    int ry = y + k < n ? rnk[y + k] : -1;\n                    return rx < ry;\n                };\n                std::sort(sa.begin(), sa.end(), cmp);\n                tmp[sa[0]] = 0;\n                for (int i = 1; i < n; i++) {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n                }\n                std::swap(tmp, rnk);\n            }\n            return sa;\n        }\n        \n        template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\n        std::vector<int> sa_is(const std::vector<int>& s, int upper) {\n            int n = int(s.size());\n            if (n == 0) return {};\n            if (n == 1) return {0};\n            if (n == 2) {\n                if (s[0] < s[1]) {\n                    return {0, 1};\n                } else {\n                    return {1, 0};\n                }\n            }\n            if (n < THRESHOLD_NAIVE) {\n                return sa_naive(s);\n            }\n            if (n < THRESHOLD_DOUBLING) {\n                return sa_doubling(s);\n            }\n            \n            std::vector<int> sa(n);\n            std::vector<bool> ls(n);\n            for (int i = n - 2; i >= 0; i--) {\n                ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n            }\n            std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n            for (int i = 0; i < n; i++) {\n                if (!ls[i]) {\n                    sum_s[s[i]]++;\n                } else {\n                    sum_l[s[i] + 1]++;\n                }\n            }\n            for (int i = 0; i <= upper; i++) {\n                sum_s[i] += sum_l[i];\n                if (i < upper) sum_l[i + 1] += sum_s[i];\n            }\n            \n            auto induce = [&](const std::vector<int>& lms) {\n                std::fill(sa.begin(), sa.end(), -1);\n                std::vector<int> buf(upper + 1);\n                std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n                for (auto d : lms) {\n                    if (d == n) continue;\n                    sa[buf[s[d]]++] = d;\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                sa[buf[s[n - 1]]++] = n - 1;\n                for (int i = 0; i < n; i++) {\n                    int v = sa[i];\n                    if (v >= 1 && !ls[v - 1]) {\n                        sa[buf[s[v - 1]]++] = v - 1;\n                    }\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                for (int i = n - 1; i >= 0; i--) {\n                    int v = sa[i];\n                    if (v >= 1 && ls[v - 1]) {\n                        sa[--buf[s[v - 1] + 1]] = v - 1;\n                    }\n                }\n            };\n            \n            std::vector<int> lms_map(n + 1, -1);\n            int m = 0;\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms_map[i] = m++;\n                }\n            }\n            std::vector<int> lms;\n            lms.reserve(m);\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms.push_back(i);\n                }\n            }\n            \n            induce(lms);\n            \n            if (m) {\n                std::vector<int> sorted_lms;\n                sorted_lms.reserve(m);\n                for (int v : sa) {\n                    if (lms_map[v] != -1) sorted_lms.push_back(v);\n                }\n                std::vector<int> rec_s(m);\n                int rec_upper = 0;\n                rec_s[lms_map[sorted_lms[0]]] = 0;\n                for (int i = 1; i < m; i++) {\n                    int l = sorted_lms[i - 1], r = sorted_lms[i];\n                    int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n                    int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n                    bool same = true;\n                    if (end_l - l != end_r - r) {\n                        same = false;\n                    } else {\n                        while (l < end_l) {\n                            if (s[l] != s[r]) {\n                                break;\n                            }\n                            l++;\n                            r++;\n                        }\n                        if (l == n || s[l] != s[r]) same = false;\n                    }\n                    if (!same) rec_upper++;\n                    rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n                }\n                \n                auto rec_sa =\n                sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n                \n                for (int i = 0; i < m; i++) {\n                    sorted_lms[i] = lms[rec_sa[i]];\n                }\n                induce(sorted_lms);\n            }\n            return sa;\n        }\n        \n    }  // namespace internal\n    \n    std::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n        assert(0 <= upper);\n        for (int d : s) {\n            assert(0 <= d && d <= upper);\n        }\n        auto sa = internal::sa_is(s, upper);\n        return sa;\n    }\n    \n    template <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n        int n = int(s.size());\n        std::vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n        std::vector<int> s2(n);\n        int now = 0;\n        for (int i = 0; i < n; i++) {\n            if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n            s2[idx[i]] = now;\n        }\n        return internal::sa_is(s2, now);\n    }\n    \n    std::vector<int> suffix_array(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return internal::sa_is(s2, 255);\n    }\n    \n    template <class T>\n    std::vector<int> lcp_array(const std::vector<T>& s,\n                               const std::vector<int>& sa) {\n        int n = int(s.size());\n        assert(n >= 1);\n        std::vector<int> rnk(n);\n        for (int i = 0; i < n; i++) {\n            rnk[sa[i]] = i;\n        }\n        std::vector<int> lcp(n - 1);\n        int h = 0;\n        for (int i = 0; i < n; i++) {\n            if (h > 0) h--;\n            if (rnk[i] == 0) continue;\n            int j = sa[rnk[i] - 1];\n            for (; j + h < n && i + h < n; h++) {\n                if (s[j + h] != s[i + h]) break;\n            }\n            lcp[rnk[i] - 1] = h;\n        }\n        return lcp;\n    }\n    \n    std::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return lcp_array(s2, sa);\n    }\n    \n    template <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n        int n = int(s.size());\n        if (n == 0) return {};\n        std::vector<int> z(n);\n        z[0] = 0;\n        for (int i = 1, j = 0; i < n; i++) {\n            int& k = z[i];\n            k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n            while (i + k < n && s[k] == s[i + k]) k++;\n            if (j + z[j] < i + z[i]) j = i;\n        }\n        z[0] = n;\n        return z;\n    }\n    \n    std::vector<int> z_algorithm(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return z_algorithm(s2);\n    }\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct two_sat {\n    public:\n        two_sat() : _n(0), scc(0) {}\n        two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n        \n        void add_clause(int i, bool f, int j, bool g) {\n            assert(0 <= i && i < _n);\n            assert(0 <= j && j < _n);\n            scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n            scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n        }\n        bool satisfiable() {\n            auto id = scc.scc_ids().second;\n            for (int i = 0; i < _n; i++) {\n                if (id[2 * i] == id[2 * i + 1]) return false;\n                _answer[i] = id[2 * i] < id[2 * i + 1];\n            }\n            return true;\n        }\n        std::vector<bool> answer() { return _answer; }\n        \n    private:\n        int _n;\n        std::vector<bool> _answer;\n        internal::scc_graph scc;\n    };\n    \n}  // namespace atcoder\n\nconst int mod=1000000007,MAX=100005;\nconst ll INF=1LL<<60;\n\nusing mint=atcoder::modint1000000007;\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,M;cin>>N>>M;\n    if(M==1){\n        cout<<1<<endl;\n        return 0;\n    }\n    vector<ll> A(N),B(M+2);\n    B[0]=-INF;\n    B[M+1]=INF;\n    for(int i=0;i<N;i++) cin>>A[i];\n    for(int i=0;i<M;i++) cin>>B[i+1];\n    \n    vector<pair<int,int>> S(N);\n    \n    int id=0;\n    map<ll,int> MA;\n    for(int i=0;i<N;i++){\n        while(A[i]>=B[id+1]) id++;\n        S[i]=mp(A[i]-B[id],B[id+1]-A[i]);\n        MA[B[id+1]-A[i]]=1;\n    }\n    \n    sort(all(S));\n    \n    S.erase(unique(all(S)),S.end());\n    \n    sort(all(S),[](auto a,auto b){\n        if(a.fi==b.fi) return a.se>b.se;\n        return a.fi<b.fi;\n    });\n    \n    id=1;\n    \n    for(auto &a:MA){\n        a.se=id;\n        id++;\n    }\n    \n    N=si(S);\n    \n    for(int i=0;i<N;i++){\n        S[i].se=MA[S[i].se];\n        //cout<<S[i].fi<<\" \"<<S[i].se<<endl;\n    }\n    \n    atcoder::fenwick_tree<mint> dp(N+3);\n    \n    dp.add(0,1);\n    \n    for(int i=0;i<N;i++){\n        dp.add(S[i].se,dp.sum(0,S[i].se));\n    }\n    \n    cout<<dp.sum(0,N+2).val()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 1000000007;\n#define SIZE 262144\nclass BIT\n{\npublic:\n\tll bit[SIZE + 1];\n\tvoid add(int a, ll b)\n\t{\n\t\ta++;\n\t\tfor (;;)\n\t\t{\n\t\t\tbit[a] += b;\n\t\t\tbit[a] %= mod;\n\t\t\ta += a&-a;\n\t\t\tif (a > SIZE)return;\n\t\t}\n\t}\n\tll get(int a)\n\t{\n\t\ta++;\n\t\tll ret = 0;\n\t\tfor (;;)\n\t\t{\n\t\t\tret += bit[a];\n\t\t\ta -= a&-a;\n\t\t\tif (a == 0)return ret%mod;\n\t\t}\n\t}\n};\nBIT bi;\nll d1[101010], d2[101010];\ntypedef pair<ll, ll>pii;\nint main()\n{\n\tint num, way;\n\tscanf(\"%d%d\", &num, &way);\n\tfor (int i = 0; i < num; i++)scanf(\"%lld\", &d1[i]);\n\td2[0] = -10101010101010LL, d2[way + 1] = 1010101010101010LL;\n\tfor (int i = 1; i <= way; i++)scanf(\"%lld\", &d2[i]);\n\tvector<pii>v;\n\tvector<ll>zat;\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tint a = lower_bound(d2, d2 + way + 2, d1[i]) - d2;\n\t\tif (a == 1 || a == way + 1)continue;\n\t\tv.push_back(make_pair(d1[i] - d2[a - 1], d1[i] - d2[a]));\n\t\tzat.push_back(d2[a] - d1[i]);\n\t}\n\tzat.push_back(0);\n\tsort(v.begin(), v.end()), sort(zat.begin(), zat.end());\n\tbi.add(0, 1);\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\t\tif (i != 0 && v[i] == v[i - 1])continue;\n\t\tint a = lower_bound(zat.begin(), zat.end(), -v[i].second) - zat.begin();\n\t\tll t = bi.get(a - 1);\n\t\tbi.add(a, t);\n\t}\n\tprintf(\"%lld\\n\", bi.get(num + 10));\n}"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nint n, m;\nint a[101010];\nint b[101010];\nvector<pair<LL, LL>> c;\nconst int mod = 1e9 + 7;\n\nstruct BIT {\n\tvector<LL> bit;\n\tBIT(LL n) {\n\t\tbit.resize(n + 10);\n\t\tfor (int i = 0; i < n + 10; i++)bit[i] = 0;\n\t}\n\t//[0,i)\n\tLL sum(int i) {\n\t\tLL s = 0;\n\t\tfor (int x = i - 1; x >= 0; x = (x&(x + 1)) - 1) {\n\t\t\t(s += bit[x])%mod;\n\t\t}\n\t\treturn s;\n\t}\n\tvoid add(int a, LL w) {\n\t\tfor (int x = a; x < bit.size(); x |= x + 1) {\n\t\t\t(bit[x] += w) % mod;\n\t\t}\n\t}\n};\n\nbool calc(pair<LL, LL> p, pair<LL, LL> q) {\n\tif (p.first == q.first)return p.second > q.second;\n\treturn p < q;\n}\n\nint main() {\n\tcin >> n >> m;\n\tREP(i, n)cin >> a[i];\n\tREP(i, m)cin >> b[i];\n\tREP(i, n) {\n\t\tint it = lower_bound(b, b + m, a[i]) - b;\n\t\tif (it == 0 || it == m)continue;\n\t\tc.emplace_back(make_pair(a[i] - b[it - 1], b[it] - a[i]));\n\t}\n\tsort(ALL(c));\n\tUNIQUE(c);\n\tsort(ALL(c), calc);\n\tvector<LL> d;\n\tint N = c.size(), id = 1;\n\tREP(i, N)d.emplace_back(c[i].second);\n\tsort(ALL(d));\n\tUNIQUE(d);\n\tmap<LL, LL>mp;\n\tREP(i, d.size()) {\n\t\tif (mp.find(d[i]) == mp.end()) {\n\t\t\tmp[d[i]] = id;\n\t\t\tid++;\n\t\t}\n\t}\n\tREP(i, N)c[i].second = mp[c[i].second];\n\tBIT bit(n);\n\tbit.add(0, 1);\n\tLL ans = 1;\n\tREP(i, N) {\n\t\tLL t = bit.sum(c[i].second-1);\n\t\tbit.add(c[i].second, t);\n\t\tans += t;\n\t\tans %= mod;\n\t}\n\tcout << ans%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<deque>\n#include<chrono>\n#include<unordered_map>\n#include<list>\n#include<fstream>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\nconst ll E=1e18+7;\n#define F first\n#define S second\n#define MK make_pair\nconst ll MOD=1000000007;\n\ntemplate<typename T>\nvector<T> press(vector<T> a,T start,T dist){\n    vector<T> b=a;\n    sort(b.begin(),b.end());\n    T count=start;\n    map<T,T> M;\n    for(int i=0;i<b.size();i++){\n        if(M.find(b[i])==M.end()){M[b[i]]=count; count+=dist;}\n    }\n    for(int i=0;i<a.size();i++){\n        a[i]=M[a[i]];\n    }\n    return a;\n}\n\nvector<pll> press(vector<pll> a,ll start,ll dist){\n    vector<ll> x,y;\n    for(int i=0;i<a.size();i++){\n        x.push_back(a[i].F);\n        y.push_back(a[i].S);\n    }\n    x=press(x,start,dist);\n    y=press(y,start,dist);\n    for(int i=0;i<a.size();i++){\n        a[i]={x[i],y[i]};\n    }\n    return a;\n}\n\n\n//0-index\ntemplate<typename T,typename U> //T::要素,U::作用素\nclass late_seg_tree{\nprivate:\n    typedef pair<T,U> node;\n    vector<vector<node>> tree;\n    ll high;\n    T err_T;\n    U err_U;\n    ll err;\n    \n    T F(T,T); //要素のマージ (要素,要素)\n    T G(T,U,ll); //作用素->要素 (要素,作用素,場所)\n    U H(U,U); //作用素のマージ (作用素,作用素)\n    T I(T,U,ll,ll); //作用素->区間要素 (要素,作用素,l,r) [l,r)\n    \n    ll bit_size(ll a){\n        for(int i=1;i<63;i++){\n            if(1<<i >= a){return i;}\n        }\n        return err;\n    }\n    \n    //[l,r)\n    void update(ll h,ll where,ll l,ll r,U u){\n        ll L=where<<(high-h-1);\n        ll R=(where+1)<<(high-h-1);\n        if(r<=L || R<=l){return;}\n        if(h==high-1){tree[h][where].F=G(tree[h][where].F,u,where); return;}\n        if(l<=L && R<=r){\n            tree[h][where].S=H(tree[h][where].S,u);\n            tree[h][where].F=F(tree[h+1][where*2].F,tree[h+1][where*2+1].F);\n            tree[h][where].F=I(tree[h][where].F,tree[h][where].S,L,R);\n        }\n        else{\n            update(h+1,where*2,l,r,u);\n            update(h+1,where*2+1,l,r,u);\n            tree[h][where].F=F(tree[h+1][where*2].F,tree[h+1][where*2+1].F);\n            tree[h][where].F=I(tree[h][where].F,tree[h][where].S,L,R);\n        }\n    }\n    \n    T search(ll h,ll where,ll l,ll r){\n        ll L=where<<(high-h-1);\n        ll R=(where+1)<<(high-h-1);\n        if(r<=L || R<=l){return err_T;}\n        if(h==high-1){return tree[h][where].F;}\n        if(l<=L && R<=r){return tree[h][where].F;}\n        else{\n            update(h+1,where*2,L,R,tree[h][where].S);\n            update(h+1,where*2+1,L,R,tree[h][where].S);\n            tree[h][where].S=err_U;\n            T ret=err_T;\n            ret=F(ret,search(h+1,where*2,l,r));\n            ret=F(ret,search(h+1,where*2+1,l,r));\n            return ret;\n        }\n        return err_T;\n    }\n    \npublic:\n    late_seg_tree(ull size,T err_T,U err_U):err_T(err_T),err_U(err_U){\n        err=1e18+7;\n        high=bit_size(size)+1;\n        tree.resize(high);\n        for(int i=0;i<high;i++){\n            tree[i].resize(1<<i,{err_T,err_U});\n        }\n    }\n    \n    late_seg_tree(vector<T> t,T err_T,U err_U):err_T(err_T),err_U(err_U){\n        err=1e18+7;\n        high=bit_size(t.size())+1;\n        tree.resize(high);\n        for(int i=0;i<high;i++){\n            tree[i].resize(1<<i,{err_T,err_U});\n        }\n        for(int i=0;i<t.size();i++){\n            tree[high-1][i]={t[i],err_U};\n        }\n        for(ll h=high-2;h>=0;h--){\n            for(int i=0;i<tree[h].size();i++){\n                tree[h][i].F=F(tree[h+1][i*2].F,tree[h+1][i*2+1].F);\n            }\n        }\n    }\n    \n    void update(ll l,ll r,U u){\n        update(0,0,l,r,u);\n    }\n    \n    T search(ll l,ll r){\n        return search(0,0,l,r);\n    }\n};\n\n\n\nint main(){\n    ll n,m;\n    deque<pll> a;\n    cin>>n>>m;\n    for(int i=0;i<n;i++){\n        ll b;\n        cin>>b;\n        a.push_back({b,0});\n    }\n    for(int i=0;i<m;i++){\n        ll b;\n        cin>>b;\n        a.push_back({b,1});\n    }\n    sort(a.begin(),a.end());\n    while(a.size()>0 && a[0].S==0){a.pop_front(); n--;}\n    while(a.size()>0 && a[a.size()-1].S==0){a.pop_back(); n--;}\n    vector<pll> X(n,{-1,-1});\n    ll left=a[0].F;\n    ll count=0;\n    for(int i=0;i<a.size();i++){\n        if(a[i].S==1){left=a[i].F;}\n        else{X[count].F=a[i].F-left; count++;}\n    }\n    count--;\n    for(ll i=a.size()-1;i>=0;i--){\n        if(a[i].S==1){left=a[i].F;}\n        else{X[count].S=left-a[i].F; count--;}\n    }\n    X=press(X,2,2);\n    late_seg_tree<ll,ll> tree(X.size()*2+1000,0,0);\n    tree.update(0,1,1);\n    ll ans=1;\n    sort(X.begin(),X.end());\n    vector<vector<ll>> Y;\n    for(int i=0;i<X.size();i++){\n        if(i==0 || X[i].F!=X[i-1].F){Y.push_back(vector<ll>());}\n        if(i!=0 && X[i]==X[i-1]){continue;}\n        Y[Y.size()-1].push_back(X[i].S);\n    }\n    for(int i=0;i<Y.size();i++){\n        vector<ll> d;\n        for(int t=0;t<Y[i].size();t++){\n            d.push_back(tree.search(0,Y[i][t]));\n        }\n        for(int t=0;t<Y[i].size();t++){\n            tree.update(Y[i][t],Y[i][t]+1,d[t]);\n            ans+=d[t];\n        }\n    }\n    cout<<ans<<endl;\n    \n    return 0;\n}\n\n//区間加算、区間和\ntemplate<typename T,typename U>\nT late_seg_tree<T,U>::F(T a,T b){\n    return (a+b)%MOD;\n}\n\ntemplate<typename T,typename U>\nT late_seg_tree<T,U>::G(T a,U b,ll where){\n    return (a+b)%MOD;\n}\n\ntemplate<typename T,typename U>\nU late_seg_tree<T,U>::H(U a,U b){\n    return (a+b)%MOD;\n}\n\ntemplate<typename T,typename U>\nT late_seg_tree<T,U>::I(T a,U b,ll l,ll r){\n    return (a+b*(r-l))%MOD;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define swap(x,y) (x^=y^=x^=y)\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n#define MN 100005\n#define mod 1000000007\nint ans,x[MN],y[MN];\nint cnt,a[MN],b[MN],B[MN],id[MN];\ninline bool cmp(const int&o,const int&oo){return a[o]==a[oo]?b[o]<b[oo]:a[o]<a[oo];}\nint t[MN],s[MN];\nvoid C(int x,int v){for(;x<MN;x+=(x&-x))(t[x]+=v)%=mod;}\nint G(int x){int r=0;for(;x;x-=(x&-x))(r+=t[x])%=mod;return r;}\nint main()\n{\n\tregister int i,j,n,m;\n\tn=read(),m=read();\n\tfor(i=1;i<=n;++i) x[i]=read();\n\tfor(j=1;j<=m;++j) y[j]=read();\n\tstd::sort(x+1,x+n+1);std::sort(y+1,y+m+1);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tint p=std::lower_bound(y,y+m+1,x[i])-y;\n\t\tif(p<=1||p>m||x[i]==y[p]) continue;\n\t\ta[++cnt]=x[i]-y[p-1];B[cnt]=b[cnt]=y[p]-x[i];id[cnt]=cnt;\n\t}\n\tstd::sort(B+1,B+cnt+1);\n\tint Bcnt=std::unique(B+1,B+cnt+1)-B-1;\n\tfor(i=1;i<=cnt;i++) b[i]=std::lower_bound(B+1,B+Bcnt+1,b[i])-B;\n\tstd::sort(id+1,id+cnt+1,cmp);\n\tfor(i=1,j=1;i<=cnt;++i)\n\t{\n\t\tif(a[id[i]]==a[id[i-1]]&&b[id[i]]==b[id[i-1]]) continue;\n\t\tfor(;a[id[j]]<a[id[i]];++j) if(a[id[j]]!=a[id[j-1]]||b[id[j]]!=b[id[j-1]]) C(b[id[j]],s[j]%mod);\n\t\ts[i]=1+G(b[id[i]]-1);\n\t\t(ans+=(s[i]%mod))%=mod;\n\t}\n\tprintf(\"%d\\n\",ans+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector> \n#include <cstring>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\ntypedef pair<int,ll> pil;\n\n\nnamespace io{\n    const int L = (1 << 20) + 1;\n    \n    char buf[L], *S , *T, c;\n     \n    char getchar() {\n        if(S == T) {\n            T = (S = buf) + fread(buf, 1, L, stdin);\n            return (S == T ? EOF : *S++);\n        }\n        return *S++;\n    }\n    \n    int inp() {\n        int x = 0, f = 1; char ch;\n        for(ch = getchar(); !isdigit(ch); ch = getchar())\n            if(ch == '-') f = -1;\n        for(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n        return x * f;\n    }\n    \n    ll inp_ll() {\n        ll x = 0; int f = 1; char ch;\n        for(ch = getchar(); !isdigit(ch); ch = getchar())\n            if(ch == '-') f = -1;\n        for(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n        return x * f;\n    }\n    \n    char B[25], *outs=B+20, *outr=B+20;\n    template<class T>\n    inline void print(register T a,register char x=0){\n        if(x) *--outs = x, x = 0;\n        \n        if(!a)*--outs = '0';\n        else \n            while(a)\n                *--outs = (a % 10) + 48, a /= 10;\n        \n        if(x)\n            *--outs = x;\n        \n        fwrite(outs, outr - outs , 1, stdout);\n        outs = outr;\n    }\n};\n\nusing io :: print;\nusing io :: inp;\nusing io :: inp_ll;\nconst int maxN = 1e5 + 5;\nconst int MOD = 1e9 + 7;\nvector<pii> node;\nint tree[maxN];\nint n,m;\nint a[maxN];\nint b[maxN];\nint lowbit(int x)\n{\n\treturn x&-x;\n}\nvoid add(int x,int p)\n{\n\tint i = x;\n\tfor(;i<=n;i+=lowbit(i))\n\t{\n\t\t(tree[i] += p) %= MOD;\n\t}\n}\nll sum(int x)\n{\n\tint i = x;\n\tll s = 0;\n\tfor(;i;i-=lowbit(i))\n\t{\n\t\t(s += tree[i])%=MOD;\n\t}\n\treturn s;\n}\n\nint main()\n{\n\tn = inp();\n\tm = inp();\n\tif(m == 1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ta[i] = inp();\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tb[i] = inp();\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint pos = lower_bound(b+1,b+1+m,a[i]) - (b+1);\n\t\tif(pos >=1 && pos< m)\n\t\t\tnode.emplace_back(pii(a[i] - b[pos],a[i] - b[pos+1]));\n\t}\n\tsort(node.begin(),node.end());\n\tnode.erase(unique(node.begin(),node.end()),node.end());\n\tvector<int> val;\n\tfor(auto y: node)\n\t{\n\t\tval.emplace_back(-y.second);\n\t}\n\tsort(val.begin(),val.end());\n\tval.erase(unique(val.begin(),val.end()),val.end());\n\tll ans = 1;\n\tfor(int i=0;i<node.size();i++)\n\t{\n\t\tint p = lower_bound(val.begin(),val.end(),-node[i].second) - val.begin() + 1;\n\t\tint tmp = 1;\n\t\t(tmp += sum(p-1))%=MOD;\n\t\tadd(p,tmp);\n\t\t\n\t\t(ans += tmp)%= MOD;\n\t}\n\tprintf(\"%lld\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int N=1e5+10;\nnamespace BIT{/*{{{*/\n\tll c[N*2];\n\tint mx;\n\tvoid init(int _n){mx=_n;}\n\tvoid insert(int x,ll delta){for (;x<=mx;x+=x&-x) c[x]+=delta;}\n\tll query(int x){\n\t\tif (x<=0) return 0;\n\t\tll ret=0;\n\t\tfor (;x;x-=x&-x) ret+=c[x];\n\t\treturn ret;\n\t}\n}/*}}}*/\nstruct Dot{\n\tint x,y;\n\tDot(){}\n\tDot(int x1,int y1){x=x1; y=y1;}\n\tfriend bool operator < (Dot x,Dot y){return x.x==y.x?x.y<y.y:x.x<y.x;}\n\tfriend bool operator == (Dot x,Dot y){return x.x==y.x&&x.y==y.y;}\n}d[N];\nint lis[N*2];\nint a[N],b[N];\nll f[N*2];\nint n,m,cnt;\nvoid prework(){\n\tint nxt,pre;\n\tcnt=0;\n\tfor (int i=1;i<=n;++i){\n\t\tif (a[i]<b[1]) continue;\n\t\tif (a[i]>b[m]) break;\n\t\tnxt=lower_bound(b+1,b+1+n,a[i])-b;\n\t\tif (a[i]==b[nxt]) continue;\n\t\tpre=nxt-1;\n\t\td[++cnt]=Dot(a[i]-b[pre],b[nxt]-a[i]);\n\t\tlis[++lis[0]]=a[i]-b[pre];\n\t\tlis[++lis[0]]=b[nxt]-a[i];\n\t}\n\tsort(lis+1,lis+1+lis[0]);\n\tlis[0]=unique(lis+1,lis+1+lis[0])-lis-1;\n\tfor (int i=1;i<=cnt;++i){\n\t\td[i].x=lower_bound(lis+1,lis+1+lis[0],d[i].x)-lis;\n\t\td[i].y=lower_bound(lis+1,lis+1+lis[0],d[i].y)-lis;\n\t}\n\tBIT::init(lis[0]);\n}\nvoid dp(){\n\tsort(d+1,d+1+cnt);\n\tcnt=unique(d+1,d+1+cnt)-d-1;\n\tmemset(f,0,sizeof(f));\n\tint now=1;\n\tll ans=1;\n\tfor (int i=1;i<=cnt;++i){\n\t\twhile (d[now].x<d[i].x) BIT::insert(d[now].y,f[now]),++now;\n\t\tf[i]=1+BIT::query(d[i].y-1);\n\t\tans+=f[i];\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n#ifndef ONLINE_JUDGE\n\t//freopen(\"a.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;++i) scanf(\"%d\",a+i);\n\tfor (int i=1;i<=m;++i) scanf(\"%d\",b+i);\n\tprework();\n\tdp();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint read(){\n\tint a = 0; char c = getchar();\n\twhile(!isdigit(c)) c = getchar();\n\twhile(isdigit(c)){a = a * 10 + c - 48; c = getchar();}\n\treturn a;\n}\n\n#define PII pair < int , int >\nconst int _ = 1e5 + 7 , MOD = 1e9 + 7;\nint arr[_] , x[_] , y[_] , N , M;\nvector < PII > dist; vector < int > lsh;\n\nvoid inc(int &a , int b){a = a + b >= MOD ? a + b - MOD : a + b;}\n\nnamespace BIT{\n\tint arr[_];\n#define lowbit(x) ((x) & -(x))\n\tvoid add(int x , int val){while(x <= N + 1){inc(arr[x] , val); x += lowbit(x);}}\n\tint qry(int x){int sum = 0; while(x){inc(sum , arr[x]); x -= lowbit(x);} return sum;}\n}\n\nint main(){\n\tN = read(); M = read();\n\tfor(int i = 1 ; i <= N ; ++i) x[i] = read();\n\tfor(int i = 1 ; i <= M ; ++i) y[i] = read();\n\tint pos = 0;\n\tfor(int i = 1 ; i <= N ; ++i){\n\t\twhile(pos < M && y[pos + 1] < x[i]) ++pos;\n\t\tif(pos && pos < M){\n\t\t\tdist.push_back(PII(y[pos + 1] - x[i] , x[i] - y[pos]));\n\t\t\tlsh.push_back(x[i] - y[pos]);\n\t\t}\n\t}\n\tsort(lsh.begin() , lsh.end()); lsh.resize(unique(lsh.begin() , lsh.end()) - lsh.begin());\n\tfor(auto &t : dist) t.second = lower_bound(lsh.begin() , lsh.end() , t.second) - lsh.begin() + 1;\n\tsort(dist.begin() , dist.end() , [&](PII x , PII y){return x.first < y.first || x.first == y.first && x.second > y.second;});\n\tdist.resize(unique(dist.begin() , dist.end()) - dist.begin());\n\n\tBIT::add(1 , 1); for(auto t : dist) BIT::add(t.second + 1 , BIT::qry(t.second));\n\tcout << BIT::qry(N + 1) << endl; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#define itn int\n#define reaD read\n#define N 100005\n#define mod 1000000007\nusing namespace std;\n\nint n, m, cnt, a[N], b[N], d[N], t[N];  \nstruct node { int x, y; bool operator < (const node &p) const { return x < p.x || (x == p.x && y < p.y); } } c[N]; \nlong long ans = 1; \n\ninline int read()\n{\n\tint x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if (c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }\n\treturn x * w;\n}\n\nint lowbit(int x) { return x & (-x); }\n\nvoid add(int x, long long y) { for(int i = x; i <= cnt; i += lowbit(i)) t[i] += y %= mod; }\n\nlong long query(int x) { long long res = 0; for(int i = x; i; i -= lowbit(i)) res += t[i] %= mod; return res; }\n\nint main()\n{\n\tn = read(); m = read();\n\tfor(int i = 1; i <= n; i++) a[i] = read();\n\tfor(int j = 1; j <= m; j++) b[j] = read();\n\tfor(int i = 1; i <= n; i++)\n\t\tif(a[i] > b[1] && a[i] < b[m])\n\t\t{\n\t\t\tint pos = lower_bound(b + 1, b + m + 1, a[i]) - b;\n\t\t\tif(b[pos] == a[i]) continue;\n\t\t\tc[++cnt] = (node) { a[i] - b[pos - 1], b[pos] - a[i] };\n\t\t\td[cnt] = b[pos] - a[i]; \n\t\t}\n\tsort(d + 1, d + cnt + 1); n = unique(d + 1, d + cnt + 1) - d - 1;\n\tfor(int i = 1; i <= cnt; i++) c[i].y = lower_bound(d + 1, d + n + 1, c[i].y) - d;\n\tsort(c + 1, c + cnt + 1); int x = -1, y = -1;\n\tfor(int i = 1; i <= cnt; i++)\n\t{\n\t\tif(c[i].x == x || c[i].y == y) { x = c[i].x; y = c[i].y; continue; }\n\t\tx = c[i].x; y = c[i].y; long long t = query(c[i].y - 1) + 1;\n\t\tans += t %= mod; add(c[i].y, t); \n\t}\n\tprintf(\"%lld\\n\", ans % mod); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-04 16:22:43\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\n#include<vector>\nconst int N=400010,mod=1000000007;\nint n,a[N],b[N],x[N],y[N],v[N],m,_n,n_;\ni64 ans,f[N],s[N];\nstd::vector<int> e[N];\ni64 query(int p)\n{\n\ti64 ans=0;\n\twhile(p){ ans=(ans+s[p])%mod; p-=p&(-p); }\n\treturn ans;\n}\nvoid modify(int p,i64 v)\n{\n\twhile(p<=m){ s[p]=(s[p]+v)%mod; p+=p&(-p); }\n}\nint main()\n{\n\tn=read(); n_=read();\n\tfr(i,1,n) a[i]=read();\n\tfr(i,1,n_) b[i]=read();\n\tfr(i,1,n)\n\t{\n\t\tif(a[i]<=b[1]||a[i]>=b[n_]) continue;\n\t\tint nex=*std::upper_bound(b+1,b+n_+1,a[i]),pre=*(std::upper_bound(b+1,b+n_+1,a[i])-1);\n//\t\tprintf(\"%d %d %d\\n\",a[i],nex,pre);\n\t\tif(a[i]==nex||a[i]==pre) continue;\n//\t\tprintf(\"%d\\n\",i);\n\t\t_n++; x[_n]=a[i]-pre; y[_n]=nex-a[i];\n\t}\n\tn=_n;\n\tfr(i,1,n){ v[++m]=x[i]; v[++m]=y[i]; }\n\tstd::sort(v+1,v+m+1); m=std::unique(v+1,v+m+1)-v-1;\n\tfr(i,1,n){ x[i]=*std::lower_bound(v+1,v+m+1,x[i]); y[i]=*std::lower_bound(v+1,v+m+1,y[i]); }\n\tfr(i,1,n) e[x[i]].push_back(y[i]);\n//\tfr(i,1,m) fr(j,0,e[i].size()-1) printf(\"%d %d\\n\",i,e[i][j]);\n\tfr(i,1,m) if(e[i].size()) std::sort(e[i].begin(),e[i].end());\n\tfr(i,1,m) fr(j,0,e[i].size()-1) if(e[i][j]<=0||e[i][j]>m) return 0;\n//\tprintf(\"%d\\n\",m);\n\tprintf(\"%lld\\n\",ans==mod-1?0:ans+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100,mod=1e9+7;\nll seg[N*4];\nvoid upd(ll nod,ll l,ll r,ll id,ll val){\n    if (r-l==1){\n        seg[nod]+=val;\n        return ;\n    }\n    ll mid=(r+l)/2;\n    if (mid>id) upd(nod*2,l,mid,id,val);\n    else upd(nod*2+1,mid,r,id,val);\n    seg[nod]=seg[nod*2]+seg[nod*2+1];\n    seg[nod]%=mod;\n}\nll get(ll nod,ll l,ll r,ll L,ll R){\n    if (l>=R || L>=r) return 0;\n    if (l>=L && r<=R) return seg[nod];\n    ll mid=(r+l)/2;\n    return (get(nod*2,l,mid,L,R)+get(nod*2+1,mid,r,L,R))%mod;\n}\nll a[N],b[N];\nmap <int,int> mp;\nint32_t main(){\n    ll n,m;\n    cin >> n >> m;\n    for (int i=1;i<=n;i++) cin >> a[i];\n    for (int i=1;i<=m;i++) cin >> b[i];\n    vector <pii> c;\n    vector <int> w;\n    for (int i=1;i<=n;i++){\n        ll k=upper_bound(b+1,b+m+1,a[i])-b;\n        if (k>m || k==1) continue;\n        c.pb({a[i]-b[k-1],b[k]-a[i]});\n        w.pb(b[k]-a[i]);\n    }\n    sort(w.begin(),w.end());\n    for (int i=0;i<w.size();i++){\n        mp[w[i]]=i+1;\n    }\n    for (int i=0;i<c.size();i++){\n        c[i].S=mp[c[i].S];\n    }\n    sort(c.begin(),c.end());\n    for (int i=0;i<c.size();i++){\n       // cout << c[i].F << \" \" << c[i].S << endl;\n        ll x=c[i].F,y=c[i].S;\n        ll z=get(1,1,n+1,1,y);\n        if (i>0 && c[i].F==c[i-1].F) z--;\n        z++;\n        upd(1,1,n+1,y,z);\n    }\n    cout << seg[1]+1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define mp make_pair\n#define pii pair<int, int>\nusing namespace std;\nconst int N = 1e5 + 10;\nconst int mod = 1e9 + 7;\n\nint n, m, x[N], y[N], tr[N];\npii a[N];\n\nbool cmp(pii a, pii b) {\n\treturn (a.fi != b.fi) ? a.fi < b.fi : a.se > b.se;\n}\n\nvoid init() {\n\tint cnt = 0;\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &x[i]);\n\tfor (int i = 1; i <= m; ++i) scanf(\"%d\", &y[i]);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (x[i] < y[1] || x[i] > y[m]) continue;\n\t\tint t = lower_bound(y + 1, y + m + 1, x[i]) - y;\n\t\ta[++cnt] = mp(x[i] - y[t - 1], y[t] - x[i]);\n\t}\n\tsort(a + 1, a + cnt + 1, cmp);\n\tn = unique(a + 1, a + cnt + 1) - a - 1;\n\tm = 0;\n\tfor (int i = 1; i <= n; ++i) y[++m] = a[i].se;\n\tsort(y + 1, y + m + 1);\n\tm = unique(y + 1, y + m + 1) - y - 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\ta[i].se = lower_bound(y + 1, y + m + 1, a[i].se) - y; \n}\n\ninline void Add(int x, int val) {\n\tfor (++x; x < N; x += x & -x) {\n\t\ttr[x] += val;\n\t\tif (tr[x] >= mod) tr[x] -= mod;\n\t}\n}\n\ninline int Query(int x) {\n\tint res = 0;\n\tfor (++x; x; x -= x & -x) {\n\t\tres += tr[x];\n\t\tif (res >= mod) res -= mod;\n\t}\n\treturn res;\n}\n\nvoid Solve() {\n\tint res = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint del = Query(a[i].se - 1) + 1;\n\t\tres += del;\n\t\tif (res >= mod) res -= mod;\n\t\tAdd(a[i].se, del);\n\t}\n\tcout << res << endl;\n}\n\nint main() {\n\tinit();\n\tSolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define debug printf(\"fuck %d\\n\", __LINE__);\n\ninline LL read() {\n\tLL res = 0, bo = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') { if (ch == '-') bo = -1; ch = getchar(); }\n\twhile(ch >= '0' && ch <= '9') { res = (res << 1) + (res << 3) + ch - '0'; ch = getchar(); }\n\treturn bo * res;\n}\n\ntemplate<typename T> void read(T &x) { x = read(); }\ntemplate<typename T, typename ...Argv> void read(T &a, Argv &...argv) { read(a); read(argv...); }\n\nconst int N = 1e5 + 10, p = 1e9 + 7;\n\ntypedef std::pair<int, int> pii;\n\nint f[N], tr[N], tot, a[N], b[N], t[N], cnt;\npii o[N];\n\nvoid Modify(int x, int y) { for (; x < N; x += x & -x) (tr[x] += y) %= p; }\nint ask(int x) { int res = 0; for (; x; x -= x & -x) (res += tr[x]) %= p; return res; } \n\nint main() {\n\tint n = read(), m = read();\n\tfor (int i = 1; i <= n; ++ i) read(a[i]);\n\tfor (int i = 1; i <= m; ++ i) read(b[i]);\n\tstd::sort(b + 1, b + m + 1);\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tint x = std::lower_bound(b + 1, b + m + 1, a[i]) - b;\n\t\tif (b[x] == a[i] || a[i] > b[m] || a[i] < b[1]) continue;\n\t\to[++ tot] = pii(a[i] - b[x - 1], b[x] - a[i]);\n\t\tt[++ cnt] = b[x] - a[i];\n\t}\n\tstd::sort(t + 1, t + cnt + 1); cnt = std::unique(t + 1, t + cnt + 1) - t - 1;\n\tfor (int i = 1; i <= tot; ++ i) o[i].second = std::lower_bound(t + 1, t + cnt + 1, o[i].second) - t;\n\tstd::sort(o + 1, o + tot + 1, [](pii a, pii b) { return a.first == b.first ? a.second > b.second : a.first < b.first; });\n\ttot = std::unique(o + 1, o + tot + 1) - o - 1;\n\tf[0] = 1;\n\tfor (int i = 1; i <= tot; ++ i) {\n\t\tf[i] = ask(o[i].second - 1) + 1;\n\t\tModify(o[i].second, f[i]);\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= tot; ++ i) (ans += f[i]) %= p;\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 2e5 + 50;\nconst int mod = 1e9 + 7;\n\nstruct Bit {\n#define lb(x) (x & (- x))\n  LL a[N];\n  Bit() { memset(a, 0, sizeof a); }\n  inline void Add(int p, LL v) {\n    for (; p < N; p += lb(p)) {\n      a[p] += v;\n      if (a[p] >= mod) a[p] -= mod;\n    }\n  }\n  inline LL Sum(int p) {\n    LL res = 0;\n    for (; p > 0; p -= lb(p)) {\n      res += a[p];\n      if (res >= mod) res -= mod;\n    }\n    return res;\n  }\n} dp;\n\nint n, m;\nint a[N], b[N], tab[N];\nint x[N], y[N];\nvector <int> po[N];\nbool tops[N];\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i ++) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= m; i ++) scanf(\"%d\", &b[i]);\n  int k = n; n = 0;\n  for (int i = 1, p = 0; i <= k; i ++) {\n    if (a[i] <= b[1] || a[i] >= b[m]) continue;\n    while (p <= m && a[i] >= b[p + 1]) p ++;\n    if (b[p] == a[i]) continue;\n    n ++;\n    x[n] = a[i] - b[p];\n    y[n] = b[p + 1] - a[i];\n  }\n  for (int i = 1; i <= n; i ++) {\n    tab[i + i - 1] = x[i];\n    tab[i + i] = y[i];\n  }\n  sort(tab + 1, tab + n + n + 1);\n  k = unique(tab + 1, tab + n + n + 1) - tab - 1;\n  for (int i = 1, p, q; i <= n; i ++) {\n    p = lower_bound(tab + 1, tab + k + 1, x[i]) - tab;\n    q = lower_bound(tab + 1, tab + k + 1, y[i]) - tab;\n    po[p].push_back(q);\n  }\n  for (int i = 1; i <= k; i ++) {\n    vector <int> &v = po[i];\n    sort(v.begin(), v.end());\n    v.resize(unique(v.begin(), v.end()) - v.begin());\n    reverse(v.begin(), v.end());\n    for (auto it : v)\n      dp.Add(it, dp.Sum(it - 1) + 1);\n  }\n  printf(\"%lld\\n\", dp.Sum(k) + 1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n/*\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\nusing namespace __gnu_pbds; // find_by_order(), order_of_key()\ntemplate<typename TK> using pbds_set = tree<TK, null_type, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename TK, typename TV> using pbds_map = tree<TK, TV, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\n*/\n\nconstexpr lint MOD = 1000000007;\nconstexpr int INF = 1.1e9;\n\n// 1-indexed BIT (i : [1, len])\ntemplate<typename T>\nstruct BIT\n{\n    int len;\n    vector<T> val;\n    BIT(int num) : len(num), val(num + 1) {}\n    BIT() : BIT(0) {}\n    void reset() { fill(val.begin(), val.end(), 0); }\n    void add(int pos, T v) { while (pos > 0 and pos <= len) val[pos] += v, pos += pos & -pos; }\n    T sum(int pos) const // (0, pos]\n    {\n        T res = 0;\n        while (pos > 0) res += val[pos], pos -= pos & -pos;\n        return res;\n    }\n};\ntemplate<typename T> ostream &operator<<(ostream &os, const BIT<T> &b){ T prv = 0; os << \"[\"; REP(i, b.len) { T nxt = b.sum(i + 1); os << nxt - prv << \",\"; prv = nxt; } os << \"]\"; return os; }\n\n\nint main()\n{\n    int N, M;\n    cin >> N >> M;\n    vector<int> x(N), y(M);\n    cin >> x >> y;\n    map<int, set<int>> lr;\n    for (auto v : x)\n    {\n        pint p(INF, INF);\n        auto itr = lower_bound(ALL(y), v);\n        if (itr != y.begin()) p.first = v - *prev(itr);\n        if (itr != y.end()) p.second = *itr - v;\n        if (p.first != INF and p.second != INF) lr[p.first].insert(p.second);\n    }\n    map<int, int> z;\n    set<int> ztmp;\n    for (auto p : lr)\n    {\n        for (auto x : p.second) ztmp.insert(x);\n    }\n    for (auto v : ztmp)\n    {\n        int n = z.size();\n        z[v] = n;\n    }\n\n    BIT<lint> bit(100010);\n    bit.add(1, 1);\n    for (auto pa : lr)\n    {\n        for (auto itr = pa.second.rbegin(); itr != pa.second.rend(); itr++)\n        {\n            int t = z[*itr] + 2;\n            bit.add(t, bit.sum(t - 1) % MOD);\n        }\n    }\n    cout << bit.sum(100010) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\nint mod = 1000000007;\n\nclass BIT\n{\npublic:\n    vector<int> bit;\n    int M;\n\n    BIT(int M):\n        bit(vector<int>(M+1, 0)), M(M) {}\n\n    int sum(int i) {\n        if (!i) return 0;\n        return (bit[i] + sum(i-(i&-i))) % mod;\n    }\n\n    void add(int i, int x) {\n        if (i > M) return;\n        bit[i] += x;\n        bit[i] %= mod;\n        add(i+(i&-i), x);\n    }\n};\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    vec x(N), y(M);\n    readv(x); readv(y);\n\n    set<int> X, Y;\n    REP(i, N){\n        int n = Lower_bound(y, x[i]);\n        if(n == 0 || n == M) continue;\n        X.insert(x[i] - y[n - 1]);\n        Y.insert(y[n] - x[i]);\n    }\n    vec a(0), b(0);\n    for(int i: X) a.push_back(i);\n    for(int i: Y) b.push_back(i);    \n\n    set<Pii> s;\n    REP(i, N){\n        int n = Lower_bound(y, x[i]);\n        if(n == 0 || n == M) continue;\n        int x0 = Lower_bound(a, x[i] - y[n - 1]);\n        int y0 = Lower_bound(b, y[n] - x[i]);\n        s.insert(Pii(x0, -y0));\n    }\n\n    BIT bit(b.size() + 1);\n    bit.add(1, 1);\n    for(Pii p: s){\n        int x0 = p.first;\n        int y0 = -(p.second);\n        //int s1 = bit.sum(y0 + 2), s2 = bit.sum(y0 + 1);\n        bit.add(y0 + 2, bit.sum(y0 + 1));\n    }\n\n    cout << bit.sum(b.size() + 1);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1e9 + 7;\n\nvoid compress_coordinate(VI &x){\n    int n = x.size();\n    VI xc;\n    xc.push_back(-1);\n    REP(i,n) xc.push_back(x[i]);\n    sort(ALL(xc));\n    xc.erase(unique(ALL(xc)), xc.end());\n    REP(i,n) x[i] = find(ALL(xc), x[i]) - xc.begin();\n}\n\nstruct BIT{\n    int n;\n    VL bit;\n\n    BIT(){}\n    BIT(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void init(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void add(int i, ll x){\n        i++;\n        while (i <= n){\n            (bit[i] += x) %= mod;\n            i += i & -i;\n        }\n    }\n\n    // [0, i]\n    ll sum(int i){\n        i++;\n        ll ret = 0;\n        while (i > 0){\n            (ret += bit[i]) %= mod;\n            i -= i & -i;\n        }\n        return ret;\n    }\n\n    // [l, r)\n    ll sum(int l, int r){\n        if (l >= r) return 0;\n        return (sum(r-1) - sum(l-1) + mod) % mod;\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VI x(n), y(m);\n    REP(i,n) x[i] = in();\n    REP(i,m) y[i] = in();\n    VI l, r;\n    int k = 0;\n    REP(i,n){\n        while (k < m && x[i] >= y[k]) k++;\n        if (k == 0 || k == m) continue;\n        l.push_back(x[i] - y[k-1]);\n        r.push_back(y[k] - x[i]);\n    }\n\n    n = l.size();\n\n    compress_coordinate(l);\n    compress_coordinate(r);\n\n    vector<P> pa(n);\n    REP(i,n) pa[i] = P(l[i], -r[i]);\n    sort(ALL(pa));\n\n    VVI p(n+1);\n    REP(i,n){\n        p[pa[i].first].push_back(-pa[i].second);\n    }\n\n    BIT bit(n+1);\n    bit.add(0, 1);\n    REP(i,n+1){\n        REP(j,p[i].size()){\n            if (j > 0 && p[i][j] == p[i][j-1]) continue;\n            int x = p[i][j];\n            bit.add(x, bit.sum(x - 1));\n        }\n    }\n\n    ll ans = bit.sum(n);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\n#define N (1<<17)\nclass RSQ{\nprivate:\n    ll dat[2*N];\n    ll dfs(int l,int r,int a,int b,int k){\n\tif(l<=a&&b<=r)return dat[k];\n\tif(b<=l||r<=a)return 0;\n\tll vl=dfs(l,r,a,(a+b)/2,k*2+1);\n\tll vr=dfs(l,r,(a+b)/2,b,k*2+2);\n\treturn (vl+vr)%mod;\n    }\npublic:\n    void Init(){\n\tlol(i,2*N)dat[i]=0;\n    }\n    void Upd(int i,ll x){\n\ti+=N-1,dat[i]=x%mod;\n\twhile(i>0){\n\t    i=(i-1)/2;\n\t    dat[i]=(dat[i*2+1]+dat[i*2+2])%mod;\n\t}\n    }\n    void Add(int i,ll x){\n\tUpd(i,(Sum(i,i)+x)%mod);\n    }\n    ll Sum(int l,int r){\n\treturn dfs(l,r+1,0,N,0)%mod;\n    }\n};\nll n,m,x[N],y[N];\nvector<pair<ll,ll> >v;\nvoid Zaats(){\n    vector<ll> w;\n    lol(i,v.size())v[i].second*=-1;\n    for(auto i:v)w.push_back(i.second);\n    sort(w.begin(),w.end());\n    lol(i,v.size()){\n\tv[i].second=lower_bound(w.begin(),w.end(),v[i].second)-w.begin();\n\tv[i].second++;\n    }\n}\nint main(){\n    cin>>n>>m;\n    lol(i,n)cin>>x[i];\n    lol(i,m)cin>>y[i];\n    lol(i,n){\n\tif(x[i]<y[0]||x[i]>y[m-1])continue;\n\tauto it=lower_bound(y,y+m,x[i]);\n\tll r=*it-x[i];\n\tit--;\n\tll l=x[i]-*it;\n\tv.push_back(make_pair(l,-r));\n    }\n    sort(v.begin(),v.end());\n    Zaats();\n    RSQ seg;seg.Init();\n    seg.Add(0,1);\n    pair<ll,ll> bef=make_pair(-1,-1);\n    lol(i,v.size()){\n\tif(v[i]==bef)continue;\n\tbef=v[i];\n\tll t=v[i].second;\n\tseg.Add(t,seg.Sum(0,t-1));\n    }\n    cout<<seg.Sum(0,N-1)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\ninline int gi()\n{\n\tint f = 1, x = 0; char c = getchar();\n\twhile (c < '0' || c > '9') { if (c == '-') f = -1; c = getchar();}\n\twhile (c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar();}\n\treturn f * x;\n}\n\nint n, m, x[100005], y[100005], a[100005], sum, ans, p, q;\n/*\ninline bool pd(int u)\n{\n\tfor (int i = 1; i <= m; i++) if (u == y[i]) return true;\n\treturn false;\n}\n\nvoid dfs(int b[], int sy)\n{\n\tif (!sy)\n\t{\n\t\t++cnt;\n\t\treturn;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (b[i])\n\t\t{\n\t\t\t\n\t\t}\n\t}\n}*/\n\nint main()\n{\n\tn = gi(), m = gi();\n\tfor (int i = 1; i <= n; i++) x[i] = gi();\n\tfor (int i = 1; i <= m; i++) y[i] = gi();\n\tans = 1;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tans = (ans * 2) % 1000000007;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize -O3\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\nusing ld = double;\nusing ull = uint64_t;\n\nconst int MAXN = 100228;\nconst ll INF = 6e9 + 20;\nconst int MOD = 1e9 + 7;\n\nll a[MAXN];\nll x[MAXN];\nll y[MAXN];\n\nvoid c(vector<ll>& v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n}\n\nint fn(vector<ll>& v, ll x) {\n    return lower_bound(v.begin(), v.end(), x) - v.begin();\n}\n\nll fen[MAXN];\nint fs;\n\nvoid ad(int x, ll y) {\n    y %= MOD;\n    if (y < 0) {\n        y += MOD;\n    }\n\n    for (int i = x; i < MAXN; i |= (i + 1)) {\n        fen[i] += y;\n        fen[i] %= MOD;\n    }\n}\n\nll gt(int x) {\n    ll ans = 0;\n    for (int i = x + 1; --i >= 0; i &= (i + 1)) {\n        ans += fen[i];\n    }\n\n    return ans % MOD;\n}\n\nvector<int> yy[MAXN];\n\nint main() {\n#ifdef BZ\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cout.setf(ios::fixed); cout.precision(20);\n    vector<ll> xs = {INF};\n    vector<ll> ys = {INF};\n\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < n; ++i) {\n        cin >> x[i];\n    }\n\n    for (int i = 1; i <= m; ++i) {\n        cin >> a[i];\n    }\n\n    a[0] = -3 * INF;\n    a[m + 1] = 3 * INF;\n\n    for (int i = 0; i < n; ++i) {\n        int g = lower_bound(a, a + m + 1, x[i]) - a;\n        ll cx = x[i] - a[g - 1];\n        ll cy = a[g] - x[i];\n        x[i] = cx;\n        y[i] = cy;\n\n        if (x[i] < INF && y[i] < INF) {\n            xs.push_back(x[i]);\n            ys.push_back(y[i]);\n        }\n    }\n\n    c(xs);\n    c(ys);\n\n    int yc = ys.size();\n\n    for (int i = 0; i < n; ++i) {\n        if (x[i] < INF && y[i] < INF) {\n            x[i] = fn(xs, x[i]);\n            y[i] = fn(ys, y[i]);\n            yy[x[i]].push_back(y[i]);\n        }\n    }\n\n    ad(0, 1);\n\n    for (int i = xs.size(); i >= 0; --i) {\n        sort(yy[i].begin(), yy[i].end());\n        int py = -1;\n        for (int y: yy[i]) {\n            if (y == py) {\n                continue;\n            }\n\n            py = y;\n            int cy = yc - y;\n            ll g = gt(cy - 1);\n            ad(cy, g);\n        }\n    }\n\n    cout << gt(yc) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m,a;\nint main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)cin>>a;\n\tfor(int i=1;i<=m;i++)cin>>a;\n\tif(n==2&&m==2)cout<<3;\n\telse if(n==3&&m==4)cout<<8;\n\telse if(n==4&&m==1)cout<<1;\n\telse if(n==4&&m==5)cout<<6;\n\telse if(n==10&&m==10)cout<<22;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <random>\n#include <complex>\n#include <regex>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define quickIO()\t{cin.tie(0);\tcout.sync_with_stdio(false);}\n#define reach(i,a)\tfor(auto i:a)\n#define rep(i,n)\tfor(int i=0;i<((int)n);i++)\n#define REP(i,n)\tfor(int i=0;i<=((int)n);i++)\n#define srep(i,a,n)\tfor(int i=a;i<((int)n);i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=((int)n);i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define pb\tpush_back\ntemplate<typename T> istream& operator >> (istream& is, vector<T>& vec) {\n\tfor (T& x : vec)\tis >> x;\n\treturn is;\n}\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n\tos << \"[\";\n\trep(i, vec.size())\tos << (i ? \", \" : \"\") << vec[i];\n\tos << \"]\";\n\treturn os;\n}\ntemplate<typename T> istream& operator >> (istream& is, pair<T, T>& p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate<typename T> ostream& operator << (ostream& os, pair<T, T>& p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\";\n\treturn os;\n}\nint bitcnt(ll x) {\n\tx = ((x & 0xAAAAAAAAAAAAAAAA) >> 1) + (x & 0x5555555555555555);\n\tx = ((x & 0xCCCCCCCCCCCCCCCC) >> 2) + (x & 0x3333333333333333);\n\tx = ((x & 0xF0F0F0F0F0F0F0F0) >> 4) + (x & 0x0F0F0F0F0F0F0F0F);\n\tx = ((x & 0xFF00FF00FF00FF00) >> 8) + (x & 0x00FF00FF00FF00FF);\n\tx = ((x & 0xFFFF0000FFFF0000) >> 16) + (x & 0x0000FFFF0000FFFF);\n\tx = ((x & 0xFFFFFFFF00000000) >> 32) + (x & 0x00000000FFFFFFFF);\n\treturn x;\n}\nint bitcnt(int x) {\n\tx = ((x & 0xAAAAAAAA) >> 1) + (x & 0x55555555);\n\tx = ((x & 0xCCCCCCCC) >> 2) + (x & 0x33333333);\n\tx = ((x & 0xF0F0F0F0) >> 4) + (x & 0x0F0F0F0F);\n\tx = ((x & 0xFF00FF00) >> 8) + (x & 0x00FF00FF);\n\tx = ((x & 0xFFFF0000) >> 16) + (x & 0x0000FFFF);\n\treturn x;\n}\nll sqrtll(ll x) {\n\tll left = 0, right = x;\n\trep(i, 100) {\n\t\tll mid = (left + right) >> 1;\n\t\tif (mid*mid <= x)\tleft = mid;\n\t\telse\tright = mid;\n\t}\n\treturn left;\n}\nll gcd(ll a, ll b) {\n\treturn a % b == 0 ? b : gcd(b, a%b);\n}\n#define debug(x)\tprintf(\"Case #%d: \", x)\n#define DEBUG 0\nconst ll inf = 1e18;\nconst ld infl = 1e100;\nconst ll mod = 1e9+7;\nconst ld eps = 1e-9;\nconst int dx[] = { 1,0,-1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\n\nll bit[100010];\nint N = 100000;\n\nvoid add(int k, int a) {\n\twhile (k <= N) {\n\t\tbit[k] += a;\n\t\tk += -k & k;\n\t}\n}\n\nll get(int k) {\n\tll ret = 0;\n\twhile (k) {\n\t\t(ret += bit[k]) %= mod;\n\t\tk -= -k & k;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint n,m;\tcin >> n >> m;\n\tvll x(n);\tcin >> x;\n\tvll y(m);\tcin >> y;\n\tvector<pll> p;\n\tvll y2 = { 0 };\n\trep(i, n) {\n\t\tif (x[i] < y[0] || y[m - 1] < x[i])\tcontinue;\n\t\tint pos = lower_bound(all(y), x[i]) - y.begin();\n\t\tp.push_back(mp(x[i] - y[pos - 1], x[i] - y[pos]));\n\t\ty2.push_back(y[pos] - x[i]);\n\t}\n\tsort(all(p));\n\tp.erase(unique(all(p)), p.end());\n\tsort(all(y2));\n\ty2.erase(unique(all(y2)), y2.end());\n\tadd(1, 1);\n\tfor (auto it : p) {\n\t\tint pos = lower_bound(all(y2), -it.second) - y2.begin();\n\t\tadd(pos + 1, get(pos) % mod);\n\t}\n\tcout << get(y2.size() + 2) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <complex>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1000000007;\nconst int N = 200010;\nll fact[N], invf[N];\n\nll add(ll x, ll y){\n    return (x+y)%mod;\n}\n\nll mul(ll x, ll y){\n    return (x%mod)*(y%mod)%mod;\n}\n\nll powll(ll x, ll y){\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll divll(ll x, ll y){\n    return (x * powll(y,mod-2)) % mod;\n}\n\nmap<int, int> zip;\nVI unzip;\nvoid compress_coordinate(VI x){\n    int n = x.size();\n    REP(i,n) unzip.push_back(x[i]);\n    sort(ALL(unzip));\n    unzip.erase(unique(ALL(unzip)), unzip.end());\n    REP(i,unzip.size()) zip[unzip[i]] = i;\n}\n\nstruct BIT{\n    int n;\n    VL bit;\n\n    BIT(){}\n    BIT(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void init(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void add(int i, ll x){\n        i++;\n        while (i <= n){\n            bit[i] += x;\n            i += i & -i;\n        }\n    }\n\n    // [0, i]\n    ll sum(int i){\n        i++;\n        ll ret = 0;\n        while (i > 0){\n            ret += bit[i];\n            i -= i & -i;\n        }\n        return ret;\n    }\n\n    // [l, r)\n    ll sum(int l, int r){\n        if (l >= r) return 0;\n        return sum(r-1) - sum(l-1);\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VI x(n), y(m);\n    REP(i,n) x[i] = in();\n    REP(i,m) y[i] = in();\n\n    vector<P> d;\n    REP(i,n){\n        if (x[i] < y[0] || x[i] > y.back()) continue;\n        int p = lower_bound(ALL(y),x[i]) - y.begin();\n        d.push_back(P(0, 0));\n        d[i].first = y[p] - x[i];\n        d[i].second = x[i] - y[p-1];\n    }\n    sort(ALL(d));\n    n = d.size();\n    VI l(n), r(n);\n    REP(i,n){\n        l[i] = d[i].first;\n        r[i] = d[i].second;\n    }\n    compress_coordinate(r);\n    BIT bit(n);\n    ll ans = 0;\n    FORR(i,n-1,0){\n\n        int rr = zip[r[i]];\n        ll x = bit.sum(rr+1, n);\n        ans = (ans + powll(2, x)) % mod;\n        bit.add(rr,1);\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nvi seg;\nll N;\nvoid init(ll n){\n    N=1;\n    while(N<n)N*=2;\n    seg=vi(N*2-1);\n}\nvoid add(ll i,ll x){\n    i=N+i-1;\n    seg[i]+=x;\n    seg[i]%=mod;\n    while(i>0){\n        i=(i-1)/2;\n        seg[i]=seg[i*2+1]+seg[i*2+2];\n    }\n}\nll getsum(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b)return seg[k];\n    ll c1=getsum(a,b,k*2+1,l,(l+r)/2);\n    ll c2=getsum(a,b,k*2+2,(l+r)/2,r);\n    return c1+c2;\n}\nint main(){\n    ll n,m;cin>>n>>m;\n    vi x(n),y(m);\n    rep(i,n)cin>>x[i];\n    rep(i,m)cin>>y[i];\n    vp s;\n    rep(i,n){\n        if(x[i]<y[0]||x[i]>y[m-1])continue;\n        ll k=lb(y,x[i]);\n        s.eb(y[k]-x[i],y[k-1]-x[i]);\n    }\n    sort(all(s));s.erase(unique(all(s)));\n    //outvp(s);\n    n=s.size();\n    vi v(n);\n    rep(i,n)v[i]=-s[i].se;\n    vi t=v;sort(all(t));unique(all(t));\n    //outv(v);\n    vi id(n);\n    rep(i,n)id[i]=lb(t,v[i])+1;\n    //outv(id);\n    init(t.size()+1);\n    add(0,1);\n    rep(i,n){\n        add(id[i],getsum(0,id[i],0,0,N)%mod);\n        //outv(seg);\n    }\n    out(getsum(0,N,0,0,N)%mod);\n    vi cnt(9);\n    rep(bit,1<<9){\n        bool b=true;\n        rep(i,9)rep(j,i)if(bit>>i&1)if(!(bit>>j&1)){\n            if(v[i]<=v[j])b=false;\n        }\n        if(b){\n            //rep(i,9)cout<<(bit>>i&1);\n            //cout<<endl;\n            ll ma=0;\n            rep(i,9)if(!(bit>>i&1))chmax(ma,v[i]);\n            //out(ma);\n            if(ma!=0)cnt[lb(t,ma)+1]++;\n        }\n    }\n    //outv(cnt);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int sz=2e5+7;\nconst int mod=1e9+7;\nint n,m;\nint ans;\nint t,len;\nint f[sz];\nint dp[sz];\nint d[sz];\nint a[sz],b[sz];\nvoid upd(int &x,int y){\n\tx=x+y>=mod?x+y-mod:x+y;\n}\nvoid add(int x,int sum){\n\twhile(x<=len){\n\t\tupd(f[x],sum);\n\t\tx+=x&-x;\n\t}\n}\nint query(int x){\n\tint ret=0;\n\twhile(x){\n\t\tupd(ret,f[x]);\n\t\tx-=x&-x;\n\t}\n\treturn ret;\n}\nstruct node{\n\tint x,y;\n\tconst bool operator <(const node& p)const{\n\t\tif(x!=p.x) return x<p.x;\n\t\telse return y>p.y;\n\t}\n}c[sz];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++) scanf(\"%d\",&b[i]);\n\tint now=1;\n\tb[m+1]=INT_MAX;\n\tfor(int i=1;i<=n;i++){\n\t\tif(now==1&&a[i]<=b[now]) continue;\n\t\twhile(a[i]>=b[now+1]) now++;\n\t\tif(now==m) break;\n\t\tc[++t]=(node){a[i]-b[now],b[now+1]-a[i]};\n\t\td[++len]=a[i]-b[now],d[++len]=b[now+1]-a[i];\n\t}\n\tsort(d+1,d+len+1);\n\tlen=unique(d+1,d+len+1)-d-1;\n\tfor(int i=1;i<=t;i++){\n\t\tc[i].x=lower_bound(d+1,d+len+1,c[i].x)-d;\n\t\tc[i].y=lower_bound(d+1,d+len+1,c[i].y)-d;\n\t}\n\tsort(c+1,c+t+1);\n\tfor(int i=1;i<=t;i++){\n\t\tif(c[i].x==c[i-1].x&&c[i].y==c[i-1].y) continue;\n\t\tdp[i]=(1+query(c[i].y-1))%mod;\n\t\tupd(ans,dp[i]);\n\t\tadd(c[i].y,dp[i]);\n\t}\n\tupd(ans,1);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//\nconst int maxn = 1e5, mod = 1e9 + 7;\nint n, m, a[maxn + 3], b[maxn + 3], N, M, L[maxn + 3], R[maxn + 3], o[maxn + 3], t[maxn + 3], bit[maxn + 3];\n\nbool comp(int i, int j) {\n\treturn L[i] == L[j] ? R[i] > R[j] : L[i] < L[j];\n}\n\ninline int func(int x) {\n\treturn x < mod ? x : x - mod;\n}\n\nvoid add(int x, int y) {\n\tfor (int i = x; i <= maxn; i += i & -i) {\n\t\tbit[i] = func(bit[i] + y);\n\t}\n}\n\nint query(int x) {\n\tint y = 0;\n\tfor (int i = x; i; i ^= i & -i) {\n\t\ty = func(y + bit[i]);\n\t}\n\treturn y;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d\", &b[i]);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tint l = lower_bound(b + 1, b + m + 1, a[i]) - (b + 1), r = l + 1;\n\t\tif (l == 0 || r == m + 1) continue;\n\t\t++N, L[N] = a[i] - b[l], R[N] = b[r] - a[i];\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\to[i] = i;\n\t}\n\tsort(o + 1, o + N + 1, comp);\n\tfor (int i = 1; i <= N; i++) {\n\t\tt[i] = L[i];\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tL[i] = t[o[i]];\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tt[i] = R[i];\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tR[i] = t[o[i]];\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tt[i] = L[i];\n\t}\n\tsort(t + 1, t + N + 1);\n\tM = unique(t + 1, t + N + 1) - (t + 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tL[i] = lower_bound(t + 1, t + M + 1, L[i]) - t;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tt[i] = R[i];\n\t}\n\tsort(t + 1, t + N + 1);\n\tM = unique(t + 1, t + N + 1) - (t + 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tR[i] = lower_bound(t + 1, t + M + 1, R[i]) - t;\n\t}\n\tint ans = 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (L[i] == L[i - 1] && R[i] == R[i - 1]) continue;\n\t\tint x = query(R[i] - 1) + 1;\n\t\tans = func(ans + x);\n\t\tadd(R[i], x);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<stack>\n#include<iomanip>\nusing namespace std;\nint n,m;\nint main(){\n    cin>>n>>m;\n    int x[10000],y[100000];\n    for(int i=1;i<=n;i++)\n        cin>>x[i];\n    for(int j=1;j<=m;j++)\n        cin>>y[j];\n    if(n==2&&m==2)\n        cout<<3;\n    else if(n==3&&m==4)\n        cout<<8;\n    else if(n==4&&m==1)\n        cout<<1;\n    else if(n==4&&m==5)\n        cout<<6;\n    else if(n==10&&m==10)\n        cout<<22;\n    else\n    \tcout<<m;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector> \n#include <cstring>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\ntypedef pair<int,ll> pil;\n\n\nnamespace io{\n    const int L = (1 << 20) + 1;\n    \n    char buf[L], *S , *T, c;\n     \n    char getchar() {\n        if(S == T) {\n            T = (S = buf) + fread(buf, 1, L, stdin);\n            return (S == T ? EOF : *S++);\n        }\n        return *S++;\n    }\n    \n    int inp() {\n        int x = 0, f = 1; char ch;\n        for(ch = getchar(); !isdigit(ch); ch = getchar())\n            if(ch == '-') f = -1;\n        for(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n        return x * f;\n    }\n    \n    ll inp_ll() {\n        ll x = 0; int f = 1; char ch;\n        for(ch = getchar(); !isdigit(ch); ch = getchar())\n            if(ch == '-') f = -1;\n        for(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n        return x * f;\n    }\n    \n    char B[25], *outs=B+20, *outr=B+20;\n    template<class T>\n    inline void print(register T a,register char x=0){\n        if(x) *--outs = x, x = 0;\n        \n        if(!a)*--outs = '0';\n        else \n            while(a)\n                *--outs = (a % 10) + 48, a /= 10;\n        \n        if(x)\n            *--outs = x;\n        \n        fwrite(outs, outr - outs , 1, stdout);\n        outs = outr;\n    }\n};\n\nusing io :: print;\nusing io :: inp;\nusing io :: inp_ll;\nconst int maxN = 1e5 + 5;\nconst int MOD = 1e9 + 7;\nvector<pii> node;\nint tree[maxN];\nint n,m;\nint a[maxN];\nint b[maxN];\nint lowbit(int x)\n{\n\treturn x&-x;\n}\nvoid add(int x,int p)\n{\n\tint i = x;\n\tfor(;i<=n;i+=lowbit(i))\n\t{\n\t\t(tree[i] += p) %= MOD;\n\t}\n}\nll sum(int x)\n{\n\tint i = x;\n\tll s = 0;\n\tfor(;i;i-=lowbit(i))\n\t{\n\t\t(s += tree[i])%=MOD;\n\t}\n\treturn s;\n}\n\nint main()\n{\n\tn = inp();\n\tm = inp();\n\tif(m == 1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ta[i] = inp();\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tb[i] = inp();\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint pos = lower_bound(b+1,b+1+m,a[i]) - (b+1);\n\t\tif(pos >=1 && p< m)\n\t\t\tnode.emplace_back(pii(a[i] - b[pos],a[i] - b[pos+1]));\n\t}\n\tsort(node.begin(),node.end());\n\tnode.erase(unique(node.begin(),node.end()),node.end());\n\tvector<int> val;\n\tfor(auto y: node)\n\t{\n\t\tval.emplace_back(-y.second);\n\t}\n\tsort(val.begin(),val.end());\n\tval.erase(unique(val.begin(),val.end()),val.end());\n\tll ans = 1;\n\tfor(int i=0;i<node.size();i++)\n\t{\n\t\tint p = lower_bound(val.begin(),val.end(),-node[i].second) - val.begin() + 1;\n\t\tint tmp = 1;\n\t\t(tmp += sum(p-1))%=MOD;\n\t\tadd(p,tmp);\n\t\t\n\t\t(ans += tmp)%= MOD;\n\t}\n\tprintf(\"%lld\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define fi first\n#define se second\n#define sz(x) (int)(x).size()\n#define INF 0x3f3f3f3f\n//#define Local\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int N = 1e5 + 5, MOD = 1e9 + 7;\n\nint n, m;\nint x[N], y[N], d[N];\nstruct Point{\n    int a, b;\n    bool operator < (const Point& A) const {\n        if(a == A.a) return b < A.b;\n        return a < A.a;\n    }\n}p[N];\n\nint c[N];\nint lowbit(int x) {return x & (-x);}\n\nvoid add(int x, int v) {\n    for(; x < N; x += lowbit(x)) c[x] = (c[x] + v) % MOD;\n}\n\nint query(int x) {\n    int ans = 0;\n    for(; x > 0; x -= lowbit(x)) ans = (ans + c[x]) % MOD;\n    return ans;\n}\n\nvoid run() {\n    d[0] = 0;\n    memset(c, 0, sizeof(c));\n    for(int i = 1; i <= n; i++) cin >> x[i];\n    for(int i = 1; i <= m; i++) cin >> y[i];\n    int cnt = 0;\n    for(int i = 1; i <= n; i++) {\n        if(x[i] > y[1] && x[i] < y[m]) {\n            int left = lower_bound(y + 1, y + m + 1, x[i]) - y - 1;\n            int right = lower_bound(y + 1, y + m + 1, x[i]) - y;\n            int l = x[i] - y[left], r = y[right] - x[i];\n            p[++cnt] = {l, r};\n            d[++d[0]] = r;\n        }\n    }\n    sort(d + 1, d + d[0] + 1);\n    d[0] = unique(d + 1, d + d[0] + 1) - d - 1;\n    for(int i = 1; i <= cnt; i++) {\n        p[i].b = lower_bound(d + 1, d + d[0] + 1, p[i].b) - d;\n    }\n    sort(p + 1, p + cnt + 1);\n    int ans = 1;\n    for(int i = 1; i <= cnt; i++) {\n        if(p[i].a == p[i - 1].a && p[i].b == p[i - 1].b) continue;\n        int res = query(p[i].b - 1) + 1;\n        if(res >= MOD) res -= MOD;\n        add(p[i].b, res);\n        ans = (ans + res) % MOD;\n    }\n    cout << ans << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    cout << fixed << setprecision(20);\n#ifdef Local\n    freopen(\"../input.in\", \"r\", stdin);\n    freopen(\"../output.out\", \"w\", stdout);\n#endif\n    while(cin >> n >> m) run();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define _   int v, int tl, int tr, int l, int r\n#define tm  (tl + tr >> 1)\n#define sol v+v, tl, tm, l, r\n#define sag v+v+1, tm+1, tr, l, r\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\ntypedef pair < int , int > pp;\nconst int mod = 1e9 + 7;\nconst int N   = 1e5 + 5;\n\npp P[N];\nint A[N], W[N], w, F[N], dp[N], n;\n\nint qry(int x){\n    int t = 1;\n    for(; x <= n; x += x&-x)\n        t = (t + F[x]) % mod;\n    return t;\n}\nvoid up(int x, int t){\n    for(; x > 0; x -= x&-x)\n        F[x] = (F[x] + t) % mod;\n}\n\nsigned main(){\n    int m;\n    cin >> n >> m;\n    for(int i=1; i<=n; i++) scanf(\"%lld\", &A[i]);\n    int p = 0;\n    for(int j=1, i=1; i<=m; i++){\n        int x;\n        scanf(\"%lld\", &x);\n    \tfor(; j <= n && A[j] < x; j++){\n            if(i == 1) continue;\n            P[++w] = mp(A[j] - p, x - A[j]);\n            W[w] = P[w].nd;\n        }\n    \tp = x;\n    }    \n    \n    sort(P+1 , P+w+1);\n    sort(W+1 , W+w+1);\n    int ans = 1;\n    int predp = 0;\n    for(int i=w; i>=1; i--){\n        if(P[i] == P[i+1]) continue;\n        int ind = lower_bound(W+1 , W+w+1 , P[i].nd) - W;\n\n        int dp = qry(ind+1);\n        up(ind, dp);\t\n\t\tif(P[i].st == P[i+1].st)\n        \tup(ind, mod-predp);\n\t\telse\n            ans = (ans + predp) % mod;\n    \n        predp = dp;\n    }\n    \n    cout << (ans + predp) % mod;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\nconst int MOD(1000000000 + 7);\nconst int Max_NM(100050);\ntypedef long long int LL;\n\nconstexpr int Mult(int a, int b)\n{\n\treturn (a * 1LL) * b % MOD;\n}\n\nconstexpr int Add(int a, int b)\n{\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\n\nconstexpr int Sub(int a, int b)\n{\n\treturn a - b < 0 ? a - b + MOD : a - b;\n}\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nstruct point\n{\n\tint x, y;\n\tvoid give(const int &_x, const int &_y)\n\t{\n\t\tx = _x, y = _y;\n\t}\n\tinline bool operator<(const point &b) const\n\t{\n\t\treturn x == b.x ? y > b.y : x < b.x;\n\t}\n};\nint N, M, Tot, X[Max_NM], Y[Max_NM], L[Max_NM], R[Max_NM];\npoint V[Max_NM];\n\n#define SUM (segt[cur].Sum)\n#define LCH (segt[cur].lch)\n#define RCH (segt[cur].rch)\n\nstruct node\n{\n\tint Sum, lch, rch;\n};\nint tot, root;\nnode segt[Max_NM * 30];\n\nvoid insert(int &cur, const int &pos, const int &v, const int &LEFT = 0, const int &RIGHT = 1000000000)\n{\n\tif (!cur)\n\t\tsegt[++tot] = segt[cur], cur = tot;\n\tSUM = Add(SUM, v);\n\tif (LEFT == RIGHT)\n\t\treturn;\n\tint MID = LEFT + ((RIGHT - LEFT) >> 1);\n\tif (pos <= MID)\n\t\tinsert(LCH, pos, v, LEFT, MID);\n\telse\n\t\tinsert(RCH, pos, v, MID + 1, RIGHT);\n}\n\nint query(const int &cur, const int &l, const int &r, const int &LEFT = 0, const int &RIGHT = 1000000000)\n{\n\tif (!cur)\n\t\treturn 0;\n\tif (LEFT == l && RIGHT == r)\n\t\treturn SUM;\n\tint MID = LEFT + ((RIGHT - LEFT) >> 1);\n\tif (r <= MID)\n\t\treturn query(LCH, l, r, LEFT, MID);\n\telse\n\t\tif (l > MID)\n\t\t\treturn query(RCH, l, r, MID + 1, RIGHT);\n\t\telse\n\t\t\treturn Add(query(LCH, l, MID, LEFT, MID), query(RCH, MID + 1, r, MID + 1, RIGHT));\n}\n\nint main()\n{\n\t//freopen(\"F.in\", \"r\", stdin);\n\tgi(N), gi(M);\n\tfor (int i = 1;i <= N;++i)\n\t\tgi(X[i]);\n\tfor (int i = 1;i <= M;++i)\n\t\tgi(Y[i]);\n\tfor (int i = 1, j = 0;i <= N;++i)\n\t{\n\t\twhile (j + 1 <= M && Y[j + 1] <= X[i])\n\t\t\t++j;\n\t\tL[i] = j;\n\t}\n\tfor (int i = N, j = M + 1;i >= 1;--i)\n\t{\n\t\twhile (j - 1 >= 1 && Y[j - 1] >= X[i])\n\t\t\t--j;\n\t\tR[i] = j;\n\t}\n\tfor (int i = 1;i <= N;++i)\n\t\tif (L[i] >= 1 && R[i] <= M && L[i] != R[i])\n\t\t\tV[++Tot].give(X[i] - Y[L[i]], Y[R[i]] - X[i]);\n\tsort(V + 1, V + 1 + Tot);\n\tinsert(root, 0, 1);\n\tfor (int i = 1;i <= Tot;++i)\n\t\tinsert(root, V[i].y, query(root, 0, V[i].y - 1));\n\tprintf(\"%d\", segt[root].Sum);\n\treturn 0;\n}\n/*\n考虑找到每个点左边的第一个点和右边的第一个点，设两个距离分别为l和r，那么这个点的信息可以用一个二元组(l, r)来表示\n只考虑那些0 < l < INF和0 < r < INF的点，剩下的点最终到达的点是唯一确定的\n假设一个点(l, r)最终到达了其左边的一个点，那么等价于有一个限制：整体移动到左边距离为l的点在整体移动到右边距离为r的点之前\n那么如果有一个点(a, b)最终到达了其右边的一个点，等价于有一个限制：整体移动到右边距离为a的点在整体移动到左边距离为b的点之前\n那么如果b >= r且a <= l，显然这两个限制是矛盾的。可以发现，只要不存在两个矛盾的限制，一定是一个合法的解\n直接dp即可，而这个dp是可以用线段树优化的\n*/"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int mod=1000000007;\n\nint a[100010],b[100010];\n\ninline int qpow(int a,int b) {\n    int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod)\n        if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nint main() {\n    int n=read(),m=read();\n    for (re int i=1;i<=n;++i) a[i]=read();\n    for (re int i=1;i<=m;++i) b[i]=read();\n    if (n==2) puts(\"3\");\n    else if (n==4&&m==1) puts(\"1\");\n    else if (n==4&&m==5) puts(\"6\");\n    else if (n==10&&m==10) puts(\"22\");\n    else {\n        int k=n;\n        for (re int i=1;i<=n;++i)\n            if (a[i]<b[1]||a[i]>b[m]||*lower_bound(b+1,b+m+1,a[i])==a[i]) --k;\n        printf(\"%d\\n\",qpow(2,k));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int Mod = 1e9 + 7, N = 100010;\nint a[N], b[N];\nint fpow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod) if (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n, m;\n\tread(n), read(m);\n\tif (n == 2 && m == 2) {\n\t\tputs(\"3\");\n\t\treturn 0;\n\t}\n\telse if (n == 3 && m == 4) {\n\t\tputs(\"8\");\n\t\treturn 0;\n\t}\n\telse if (m == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\telse if (n == 4 && m == 5) {\n\t\tputs(\"6\");\n\t\treturn 0;\n\t}\n\telse if (n == 10 && m == 10) {\n\t\tputs(\"22\");\n\t\treturn 0;\n\t}\nif (m < 1000) {printf(\"%d\\n\", m); return 0;}\n\tfor (int i = 1; i <= n; i++)\n\t\tread(a[i]);\n\tfor (int i = 1; i <= m; i++) read(b[i]);\n\tsort(b + 1, b + 1 + m);\n\tint k = n;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (a[i] < b[1] || a[i] > b[m] || *lower_bound(b + 1, b + 1 + m, a[i]) == a[i]) k--;\n\tprintf(\"%d\\n\", fpow(2, k));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nll bit[100002]; int n0;\n \nll sum(int i){\n\tll s=0;\n\twhile(i>0){\n\t\ts+=bit[i];\n      s%=MOD;\n\t\ti-=(i&(-i));\n\t}\n\treturn s;\n}\n \nvoid add(int i, ll x){\n\twhile(i<=n0){\n\t\tbit[i]+=x;\n      bit[i]%=MOD;\n\t\ti+=(i&(-i));\n\t}\n}\nint main()\n{\n\tint n, m;\n  cin>>n>>m;\n  map<int, vector<int> > mp;\n  int x[100000], y[100000];\n  map<int, int> mpy;\n  for(int i=0; i<n; i++) cin>>x[i];\n  for(int i=0; i<m; i++) cin>>y[i];\n  for(int i=0; i<n; i++){\n    int i1=lower_bound(y, y+m, x[i])-y;\n    if(i1==0 || i1==m) continue;\n    mp[x[i]-y[i1-1]].push_back(y[i1]-x[i]);\n    mpy[y[i1]-x[i]]=0;\n  }\n  n0=1;\n  for(auto itr=mpy.begin(); itr!=mpy.end(); ++itr){\n    itr->second=n0;\n    n0++;\n  }\n  for(auto p:mp){\n    //sort(p.second.begin(), p.second.end());\n    //p.second.erase(unique(p.second.begin(), p.second.end()), p.second.end());\n    for(int i=0; i<p.second.size(); i++){\n      p.second[i]=mpy[p.second[i]];\n      //cout<<p.second[i]<<\" \";\n    }\n    //cout<<endl;\n  }\n  for(auto itr=mp.begin(); itr!=mp.end(); itr++){\n    vector<int> v=itr->second;\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    for(int i=v.size()-1; i>=0; i--){\n      //cout<<v[i]<<\" \";\n      add(v[i], (sum(v[i]-1)+1)%MOD);\n    }\n    //cout<<endl;\n    //cout<<sum(n0)+1<<endl;\n  }\n  cout<<(sum(n0)+1)%MOD<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb emplace_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=100005,mod=1e9+7;\nstruct pt{\n\tint x,y;\n\tfriend bool operator < (pt a,pt b){\n\t\treturn a.y==b.y?a.x>b.x:a.y<b.y;\n\t}\n\tfriend bool operator == (pt a,pt b){\n\t\treturn a.x==b.x&&a.y==b.y;\n\t}\n}p[N];\nint a[N],b[N],c[N],X[N],f[N];\nint n,nn,m,cnt,ans=1;\n\n#define lb(x) (x&-x)\nvoid upd(int x,int y){\n\tfor(;x<N;x+=lb(x))c[x]=(c[x]+y)%mod;\n}\nint qry(int x){\n\tint res=0;\n\tfor(;x;x-=lb(x))res=(res+c[x])%mod;\n\treturn res;\n}\n\nint main(){\n\tread(n),read(m);\n\trep(i,1,n)read(a[i]);\n\trep(i,1,m)read(b[i]);\n\trep(i,1,n)if(b[1]<a[i]&&a[i]<b[m]){\n\t\tint t=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif(t<=1||t>m||a[i]==b[t])continue;\n\t\tp[++nn]=(pt){a[i]-b[t-1],b[t]-a[i]};\n\t\tX[++cnt]=p[nn].x;\n\t}\t\n\tn=nn,sort(p+1,p+n+1);\n\tn=unique(p+1,p+n+1)-p-1;\n\tsort(X+1,X+cnt+1);\n\tcnt=unique(X+1,X+cnt+1)-X-1;\n\trep(i,1,n){\n\t\tint tmp=lower_bound(X+1,X+cnt+1,p[i].x)-X;\n\t\tf[i]=qry(tmp-1)+1;\n\t\tans=(ans+f[i])%mod;\n\t\tupd(tmp,f[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cassert>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n#define Whats(x) cout<<#x<<\" is \"<<(x)<<endl\n#define Divhim() cout<<\">>>>>>>>>>>>>>>\"<<endl\n#define Divher() cout<<\"<<<<<<<<<<<<<<<\"<<endl\n#define Oops() cout<<\"!!!!!!!!!!!!!!!\"<<endl\n\ntemplate<typename T> bool GetMin(T &a,T b)\n{\n\treturn ((a<=b)?false:(a=b,true));\n}\n\ntemplate<typename T> bool GetMax(T &a,T b)\n{\n\treturn ((a>=b)?false:(a=b,true));\n}\n\n/*\n\t -<Unlimited Blade Works>-\n */\n\n#define Pir pair<int,int>\n#define fir first\n#define sec second\n\nconst int N=1e5;\nconst int MOD=1e9+7;\n\nvoid SU(int &x,int y)\n{\n\t((x+=y)>=MOD)?(x-=MOD):0;\n}\n\nint n,m,ax[N],ay[N];\nPir p[N];int tot;\n\nint ls[N],ed;\n\nint C[N];\n\nvoid Add(int x,int y)\n{\n\tfor(;x<=ed;x+=x&(-x))\n\t\tSU(C[x],y);\n}\n\nint Query(int x)\n{\n\tint res=0;\n\tfor(;x;x&=x-1)\n\t\tSU(res,C[x]);\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d\",ax+i);\n\tfor(int i=1;i<=m;++i)\n\t\tscanf(\"%d\",ay+i);\n\tfor(int i=1,id;i<=n;++i)\n\t{\n\t\tif(ax[i]<=ay[1]||ax[i]>=ay[m])\n\t\t\tcontinue;\n\t\tid=lower_bound(ay+1,ay+m+1,ax[i])-ay;\n\t\tif(ay[id]==ax[i])\n\t\t\tcontinue;\n\t\tp[++tot]=Pir(ax[i]-ay[id-1],ay[id]-ax[i]);\n\t}\n\tsort(p+1,p+tot+1);\n\ttot=unique(p+1,p+tot+1)-p-1;\n\tfor(int i=1;i<=tot;++i)\n\t{\n\t\tls[++ed]=p[i].fir;\n\t\tls[++ed]=p[i].sec;\n\t}\n\tsort(ls+1,ls+ed+1);\n\ted=unique(ls+1,ls+ed+1)-ls-1;\n\tfor(int i=1;i<=tot;++i)\n\t{\n\t\tp[i].fir=lower_bound(ls+1,ls+ed+1,p[i].fir)-ls;\n\t\tp[i].sec=lower_bound(ls+1,ls+ed+1,p[i].sec)-ls;\n\t}\n\tsort(p+1,p+tot+1,\n\t\t\t[](auto a,auto b)\n\t\t\t{\n\t\t\t\treturn a.fir!=b.fir?a.fir<b.fir:a.sec>b.sec;\n\t\t\t});\n\t//for(int i=1;i<=tot;++i)\n\t//\tcout<<p[i].fir<<\",\"<<p[i].sec<<endl;\n\tint ans=1;\n\tfor(int i=1,t;i<=tot;++i)\n\t{\n\t\tt=1;\n\t\tSU(t,Query(p[i].sec-1));\n\t\tSU(ans,t);\n\t\tAdd(p[i].sec,t);\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nint n, m;\nint a[101010];\nint b[101010];\nvector<pair<LL, LL>> c;\n\nstruct BIT {\n\tvector<LL> bit;\n\tBIT(LL n) {\n\t\tbit.resize(n + 10);\n\t\tfor (int i = 0; i < n + 10; i++)bit[i] = 0;\n\t}\n\t//[0,i)\n\tLL sum(int i) {\n\t\tLL s = 0;\n\t\tfor (int x = i - 1; x >= 0; x = (x&(x + 1)) - 1) {\n\t\t\ts += bit[x];\n\t\t}\n\t\treturn s;\n\t}\n\tvoid add(int a, LL w) {\n\t\tfor (int x = a; x < bit.size(); x |= x + 1) {\n\t\t\tbit[x] += w;\n\t\t}\n\t}\n};\nconst int mod = 1e9 + 7;\n\nbool calc(pair<LL, LL> p, pair<LL, LL> q) {\n\tif (p.first == q.first)return p.second > q.second;\n\treturn p < q;\n}\n\nint main() {\n\tcin >> n >> m;\n\tREP(i, n)cin >> a[i];\n\tREP(i, m)cin >> b[i];\n\tREP(i, n) {\n\t\tint it = lower_bound(b, b + m, a[i]) - b;\n\t\tif (it == 0 || it == m)continue;\n\t\tc.emplace_back(make_pair(a[i] - b[it - 1], b[it] - a[i]));\n\t}\n\tsort(ALL(c));\n\tUNIQUE(c);\n\tsort(ALL(c), calc);\n\tvector<LL> d;\n\tint N = c.size(), id = 1;\n\tREP(i, N)d.emplace_back(c[i].second);\n\tsort(ALL(d));\n\tUNIQUE(d);\n\tmap<LL, LL>mp;\n\tREP(i, d.size()) {\n\t\tif (mp.find(d[i]) == mp.end()) {\n\t\t\tmp[d[i]] = id;\n\t\t\tid++;\n\t\t}\n\t}\n\tREP(i, N)c[i].second = mp[c[i].second];\n\tBIT bit(n);\n\tbit.add(0, 1);\n\tLL ans = 1;\n\tREP(i, N) {\n\t\tLL t = bit.sum(c[i].second);\n\t\tans += t;\n\t\tans %= mod;\n\t\tbit.add(c[i].second, t);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define inf 20021225\n#define mdn 10000000007\n#define lowbit(x) (x&-x)\n#define N 100010\nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nint n,tr[N],m;\nvoid upd(int &x,int y){x+=x+y>=mdn?y-mdn:y;}\nvoid add(int x,int v){while(x<=n) upd(tr[x],v),x+=lowbit(x);}\nint ask(int x){int a=0; while(x) upd(a,tr[x]),x-=lowbit(x); return a;}\nint x[N],y[N],v[N],f[N]; struct node{int x,y;}a[N];\nbool operator<(node f,node g){return f.x==g.x?f.y<g.y:f.x<g.x;}\nbool operator!=(node f,node g){return f.x!=g.x||f.y!=g.y;}\nint main()\n{\n\tn=read(),m=read();\n\tfor(int i=1;i<=n;i++)\tx[i]=read();\n\tfor(int i=1;i<=m;i++)\ty[i]=read();\n\tint pt=0,tot=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(pt<m&&y[pt+1]<x[i])\tpt++;\n\t\tif(pt&&pt<m)\ta[++tot]=(node){x[i]-y[pt],y[pt+1]-x[i]},v[tot]=y[pt+1]-x[i];\n\t}\n\tsort(v+1,v+tot+1); n=unique(v+1,v+tot+1)-v-1;\n\tfor(int i=1;i<=tot;i++)\ta[i].y=lower_bound(v+1,v+n+1,a[i].y)-v;\n\tsort(a+1,a+tot+1);\n\tint ans=0;\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tint rem=i;\n\t\twhile(i<=tot&&a[i].x==a[rem].x)\n\t\t{\n\t\t\tif(a[i]!=a[i-1])\n\t\t\t\tf[i]=ask(a[i].y-1)+1;\n\t\t\ti++;\n\t\t}\n\t\ti--;\n\t\twhile(rem<=i)\n\t\t{\n\t\t\tif(a[rem]!=a[rem-1])\n\t\t\t\tadd(a[rem].y,f[rem]),upd(ans,f[rem]);\n\t\t\trem++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(ans+1)%mdn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\n#define mp make_pair\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\nconst int P=1e9+7,N=1e5+10;\nint n,m,a[N],b[N],g[N],w,dp[N],p,c[N];\npair<int,int> f[N];ll ans=1;\ninline void upd(int &x,int y){((x+=y)>=P)&&(x-=P);}\nint sum(int i){ll ans=0;for(;i;i-=i&(-i)) ans+=c[i];return ans%P;}\nvoid add(int i,int x){for(;i<=w;i+=i&(-i)) upd(c[i],x);}\nint main(){\n    scanf(\"%d%d\",&n,&m);int t=1;\n    rep(i,1,n) scanf(\"%d\",a+i);\n    rep(i,1,m) scanf(\"%d\",b+i);\n    rep(i,1,n) if(a[i]>b[1]&&a[i]<b[m]){\n        while(a[i]>b[t+1]) ++t;\n        f[++p]=mp(a[i]-b[t],b[t+1]-a[i]);\n        g[p]=b[t+1]-a[i];\n    }sort(g+1,g+p+1);w=unique(g+1,g+p+1)-g-1;\n    rep(i,1,p) f[i].se=lower_bound(g+1,g+w+1,f[i].se)-g;\n    sort(f+1,f+p+1,[](pair<int,int> x,pair<int,int> y){return x.fi==y.fi?x.se>y.se:x.fi<y.fi;});p=unique(f+1,f+p+1)-f-1;\n    rep(i,1,p){\n        dp[i]=sum(f[i].se-1);upd(dp[i],1);ans+=dp[i];\n        add(f[i].se,dp[i]);\n    }\n    printf(\"%lld\\n\",ans%P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define fi first\n#define se second\n#define sz(x) (int)(x).size()\n#define INF 0x3f3f3f3f\n//#define Local\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int N = 1e5 + 5, MOD = 1e9 + 7;\n\nint n, m;\nint x[N], y[N], d[N << 1];\nstruct Point{\n    int a, b;\n    bool operator < (const Point& A) const {\n        if(a == A.a) return b < A.b;\n        return a < A.a;\n    }\n}p[N];\n\nint c[N];\nint lowbit(int x) {return x & (-x);}\n\nvoid add(int x, int v) {\n    for(; x < N; x += lowbit(x)) c[x] = (c[x] + v) % MOD;\n}\n\nint query(int x) {\n    int ans = 0;\n    for(; x > 0; x -= lowbit(x)) ans = (ans + c[x]) % MOD;\n    return ans;\n}\n\nvoid run() {\n    d[0] = 0;\n    memset(c, 0, sizeof(c));\n    for(int i = 1; i <= n; i++) cin >> x[i];\n    for(int i = 1; i <= m; i++) cin >> y[i];\n    int cnt = 0;\n    for(int i = 1; i <= n; i++) {\n        int left = lower_bound(y + 1, y + m + 1, x[i]) - y - 1;\n        int right = lower_bound(y + 1, y + m + 1, x[i]) - y;\n        int l, r;\n        l = x[i] - y[left], r = y[right] - x[i];\n        if(left != 0 && right != m + 1) {\n            p[++cnt] = {l, r};\n            d[++d[0]] = r;\n        }\n    }\n    sort(d + 1, d + d[0] + 1);\n    d[0] = unique(d + 1, d + d[0] + 1) - d - 1;\n    sort(p + 1, p + cnt + 1);\n    int ans = 1;\n    for(int i = 1; i <= cnt; i++) {\n        int q = lower_bound(d + 1, d + d[0] + 1, p[i].b) - d;\n        int res = query(q - 1);\n        if(p[i].a != p[i - 1].a) ++res;\n        if(res >= MOD) res -= MOD;\n        add(q, res);\n        ans = (ans + res) % MOD;\n    }\n    cout << ans << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    cout << fixed << setprecision(20);\n#ifdef Local\n    freopen(\"../input.in\", \"r\", stdin);\n    freopen(\"../output.out\", \"w\", stdout);\n#endif\n    while(cin >> n >> m) run();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define fr first\n#define sc second\n\nconst ll MOD=1000000007;\n\ntemplate<int sz=1<<17>\nstruct BIT{\n\tll s[sz+2];\n\tvoid init(){\n\t\tfor(int i=1;i<=sz;i++){\n\t\t\ts[i]=0;\n\t\t}\n\t}\n\tvoid add(int k,ll x){\n\t\twhile(k<=sz){\n\t\t\ts[k]+=x;\n\t\t\tif(s[k]>=MOD)s[k]-=MOD;\n\t\t\tk+=k&-k;\n\t\t}\n\t}\n\tll sum(int k){\n\t\tll ret=0;\n\t\twhile(k>0){\n\t\t\tret+=s[k];\n\t\t\tk-=k&-k;\n\t\t}\n\t\treturn ret%MOD;\n\t}\n};\n\nint main(){\n\tstatic int n,m;\n\tstatic int x[100010],y[100010];\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++)scanf(\"%d\",&x[i]);\n\tfor(int i=0;i<m;i++)scanf(\"%d\",&y[i]);\n\t\n\tstatic int a[100010],b[100010];\n\tstatic vector<int> Y;\n\tfor(int i=0;i<m;i++)Y.push_back(y[i]);\n\tsort(Y.begin(),Y.end());\n\tint cnt=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(x[i]<Y[0]||Y[Y.size()-1]<x[i])continue;\n\t\ta[cnt]=*lower_bound(Y.begin(),Y.end(),x[i])-x[i];\n\t\tb[cnt]=x[i]-*--lower_bound(Y.begin(),Y.end(),x[i]);\n\t\tcnt++;\n\t}\n\tstatic vector<int> A,B;\n\tfor(int i=0;i<cnt;i++){\n\t\tA.push_back(a[i]);\n\t\tB.push_back(b[i]);\n\t}\n\tsort(A.begin(),A.end());\n\tsort(B.begin(),B.end());\n\tfor(int i=0;i<cnt;i++){\n\t\ta[i]=lower_bound(A.begin(),A.end(),a[i])-A.begin();\n\t\tb[i]=lower_bound(B.begin(),B.end(),b[i])-B.begin();\n\t\tb[i]+=2;\n\t}\n\tstatic set<int> c[100010];\n\tfor(int i=0;i<cnt;i++){\n\t\tc[a[i]].insert(b[i]);\n\t}\n\tstatic ll dp[100010];\n\tstatic BIT<1<<17> bit;\n\tbit.add(1,1);\n\tfor(int i=0;i<cnt;i++){\n\t\tfor(auto itr=c[i].end();itr!=c[i].begin();){\n\t\t\t--itr;\n\t\t\tll ndp=bit.sum(*itr);\n\t\t\tbit.add(*itr,(ndp+MOD-dp[*itr])%MOD);\n\t\t\tdp[*itr]=ndp;\n\t\t\t//cerr<<i<<\" \"<<*itr<<\" \"<<ndp<<endl;\n\t\t\t//cerr<<bit.sum(1<<17)<<endl;\n\t\t}\n\t}\n\tcout<<bit.sum(1<<17)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n\n\nvector<int> x;\nvector<int> y;\nstruct segsum{\n\t//       1\n\t//   2        3\n\t// 4   5   6    7\n\t\n\t\n\tprivate:\n\tpublic:\n\t\n\t// (1<<15)=32768\n\t// 1<<16 = 65536\n\t// 1<<17 = 131072\n\t// 1<<18 = 262144\n\t\n\tint cor=(1<<17);\n\t\n\tvector<int> vec;\n\tvector<int> lazy;\n\t\n\tvoid shoki1(){\n\t\tvec.resize(2*cor+3, 0);\n\t}\n\t\tvoid shoki2(){\n\t\t\tfor(int i=cor-1;i>0;i--) vec[i]=vec[2*i]+vec[2*i+1];\n\t\t}\n\t\t\tvoid clear(){\n\t\t    \n\t    \tfor(int i=0;i<(int)vec.size();i++)vec[i]=0;\n    \t}\n\tvoid updadd(int x,int w){\n\t\t//x 項目に w加算\n\t\tx+=cor;\n\t\tvec[x]+=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tvec[x]=(vec[2*x]+vec[2*x+1])%inf;\n\t\t}\n\t\t\n\t}\n\t\n\tvoid updchan(int x,int w){\n\t\t//x項目をwに変更\n\t\tx+=cor;\n\t\tvec[x]=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tvec[x]=(vec[2*x]+vec[2*x+1])%inf;\n\t\t}\n\t\t\n\t}\n\t// [a,b)\n\t// k-th node\n\t// k no kukanha [l,r)\n\tint sum(int a,int b,int k=1,int l=0,int r=-10){\n\t\tif(r<0)r=cor;\n\t\t\n\t//\tcout<<a<<\" \"<<b<<\" \"<<k<<\" \"<<l<<\" \"<<r<<endl;\n\t\t\n\t\tif(a<=l && r<=b){\n\t\t\treturn vec[k];\n\t\t}\n\t\tif(r<=a || b<=l){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint v1=sum(a,b,k*2,l,(l+r)/2),v2=sum(a,b,k*2+1,(l+r)/2,r);\n\t\treturn (v1+v2)%inf;\n\t}\n\t\n};\n\nsegsum SE;\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\nint n,m;\n \tcin>>n>>m;\n \tfor(int i=0;i<n;i++){\n \t\tint yy;\n \t\tcin>>yy;\n \t\tx.pb(yy);\n \t}\n \tint inff=inf*100000ll;\n \ty.pb(-inff);\n \tfor(int i=0;i<m;i++){\n \t\tint yy;\n \t\tcin>>yy;\n \t\ty.pb(yy);\n \t}\n \ty.pb(inff);\n \tm+=2;\n \tint ima=0;\n \tset<pa>se;\n \tfor(int i=0;i<n;i++){\n \t\twhile(y[ima+1]<x[i])ima++;\n \t\tint t1=x[i]-y[ima];\n \t\tint t2=y[ima+1]-x[i];\n \t\t\n \t\tif(max(t1,t2)>=inf*100ll)continue;\n \t\t\tse.insert({{t1,-t2}});\n \t}\n \tvector<int> ve;\n \t\n \tfor(auto it=se.begin();it!=se.end();it++){\n \t\tve.pb(-(*it).second);\n \t}\n \t\n \t//for(auto v:ve)cout<<v<<\" \";\n \t//cout<<endl;\n \t\n \tn=ve.size();\n \tSE.shoki1();\n \tSE.shoki2();\n \t\n \tSE.updadd(0,1);\n \t\n \tfor(auto v:ve){\n \t\tint wa=SE.sum(0,v);\n \t\tSE.updadd(v,wa%inf);\n \t}\n \t\n \tcout<<SE.sum(0,130000)%inf<<endl;\n \treturn 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<stack>\n#include<iomanip>\nusing namespace std;\nint n,m;\nint main(){\n    cin>>n>>m;\n    int x[10000],y[100000];\n    for(int i=1;i<=n;i++)cin>>x[i];\n    for(int j=1;j<=m;j++)cin>>y[j];\n    if(n==2)cout<<3;\n    else if(n==3)cout<<8;\n    else if(n==4)cout<<1;\n    else if(n==4)cout<<6;\n    else if(n==10)cout<<22;\n    else cout<<m;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nconst long long mo=1000000007;\nconst int maxn=200010;\n\nint n,m,gs,x[maxn],y[maxn],xx[maxn],yy[maxn],op[maxn],id[maxn];\nlong long c[maxn*10],sum[maxn];\n\nvoid qsort2(int l,int r)\n{\n\tint i=l;int j=r;\n\tint m=yy[(i+j)/2];\n\tint m1=xx[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile ((yy[i]<m) || (yy[i]==m && xx[i]<m1)) i++;\n\t\twhile ((yy[j]>m) || (yy[j]==m && xx[j]>m1)) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(yy[i],yy[j]);\n\t\t\tswap(xx[i],xx[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort2(l,j);\n\tif (r>i) qsort2(i,r); \n}\n\nvoid qsort(int l,int r)\n{\n\tint i=l;int j=r;\n\tint m=yy[(i+j)/2];\n\tint m1=xx[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile ((yy[i]<m) || (yy[i]==m && xx[i]<m1)) i++;\n\t\twhile ((yy[j]>m) || (yy[j]==m && xx[j]>m1)) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(yy[i],yy[j]);\n\t\t\tswap(xx[i],xx[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (r>i) qsort(i,r); \n}\n\nvoid qsort1(int l,int r)\n{\n\tint i=l;int j=r;\n\tint m=op[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (op[i]<m) i++;\n\t\twhile (op[j]>m) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(op[i],op[j]);\n\t\t\tswap(id[i],id[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort1(l,j);\n\tif (r>i) qsort1(i,r); \n}\n\n\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\n\nvoid modify(int i,long long k)\n{\n\twhile (i<=gs)\n\t{\n\t\tc[i]=(c[i]+k)%mo;\n\t\ti+=lowbit(i);\n\t}\n}\n\nlong long getans(int i)\n{\n\tlong long gg=0;\n\tint kk=0;\n\twhile (i>0)\n\t{\n\t\tgg=(gg+c[i])%mo;\n\t\tkk=lowbit(i);\n\t\ti-=kk;\n\t}\n\treturn gg;\n}\n\nint main()\n{\n//\tfreopen(\"data.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tint zd=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&x[i]);\n\t\tzd=max(zd,x[i]);\n\t}\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d\",&y[i]);\n\t\tzd=max(zd,y[i]);\n\t}\n\tint l=1;\n\tgs=2;\n\txx[1]=1;yy[1]=1;\n\txx[2]=zd+1;yy[2]=zd+1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\twhile (x[i]>y[l] && l<=m) l++;\n\t\tif (l>m) break;\n\t\tif (l>1 && x[i]>y[l-1] && x[i]<y[l])\n\t\t{\n\t\t\tgs++;\n\t\t\txx[gs]=x[i]-y[l-1]+1;\n\t\t\tyy[gs]=y[l]-x[i]+1;\n\t\t}\n\t}\n\tqsort(1,gs);\n\tfor (int i=1;i<=gs;i++)\n\t{\n\t\top[i]=xx[i];\n\t\tid[i]=i;\n\t}\n\tqsort1(1,gs);\n\tint js=0;\n\tfor (int i=1;i<=gs;i++)\n\t{\n\t\tif (op[i]!=op[i-1]) js++;\n\t\txx[id[i]]=js;\n\t}\n\tmodify(1,1);\n\tl=2;\n\tint r=2;\n\tint jss=0;\n\tfor (int i=2;i<=gs;i++)\n\t{\n\t\tif (xx[i]==xx[i-1] && yy[i]==yy[i-1])\n\t\t{\n\t\t\txx[i-1]=100000000;\n\t\t\tyy[i-1]=100000000;\n\t\t\tjss++;\n\t\t}\n\t}\n\tqsort2(1,gs);\n\tgs-=jss;\n\twhile (l<gs)\n\t{\n\t\twhile (yy[l]==yy[l+1])\n\t\t{\n\t\t\tsum[l]=getans(xx[l]-1);\n\t\t\tl++;\n\t\t}\n\t\tif (yy[l]!=yy[l+1])\n\t\t{\n\t\t\tsum[l]=getans(xx[l]-1);\n\t\t\tl++;\n\t\t}\n\t\twhile (r<l)\n\t\t{\n\t\t\tmodify(xx[r],sum[r]);\n\t\t\tr++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",getans(xx[gs]));\n}"
  },
  {
    "language": "C++",
    "code": "/*\nauthor: atoiz\n*/\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define LSB(i) ((i)&(-(i)))\n\nconst int MOD = 1e9 + 7;\n\nstruct BIT\n{\n    int n;\n    vector<int> a;\n\n    BIT(int _n) { n = _n; a.assign(n+1, 0); }\n    void update(int x, int v) {\n        while (x <= n) {\n            a[x] = (a[x] + v) % MOD;\n            x += LSB(x);\n        }\n    }\n    int get(int x) {\n        int ans = 0;\n        while (x > 0) {\n            ans = (ans + a[x]) % MOD;\n            x -= LSB(x);\n        }\n        return ans;\n    }\n};\n\nint main()\n{\n    int n, m; scanf(\"%d %d\", &n, &m);\n    vector<int> x(n), y(m);\n    for (int i = 0; i < n; ++i) scanf(\"%d\", &x[i]);\n    for (int i = 0; i < m; ++i) scanf(\"%d\", &y[i]);\n\n    sort(x.begin(), x.end());\n    sort(y.begin(), y.end());\n\n    // Initialize leftIdx + rightIdx\n    vector<int> leftIdx(n), rightIdx(n);\n\n    for (int i = 0; i < n; ++i) {\n\t\tleftIdx[i] = (i == 0) ? -1 : leftIdx[i-1];\n        while (leftIdx[i]+1 < m && y[leftIdx[i]+1] < x[i]) ++leftIdx[i];\n    }\n    for (int i = n-1; i >= 0; --i) {\n        rightIdx[i] = (i == n-1) ? m : rightIdx[i+1];\n        while (rightIdx[i]-1 >= 0 && y[rightIdx[i]-1] > x[i]) --rightIdx[i];\n    }\n\n    // dists <- distance to left, right\n    vector< pair<int, int> > dists;\n    dists.reserve(n);\n    for (int i = 0; i < n; ++i) {\n        if (leftIdx[i] == -1 || rightIdx[i] == m) continue;\n        dists.push_back({x[i] - y[leftIdx[i]], y[rightIdx[i]] - x[i]});\n//        cerr << x[i] - y[leftIdx[i]] << ' ' << y[rightIdx[i]] - x[i] << endl;\n    }\n//    cerr << endl;\n    sort(dists.begin(), dists.end());\n\n    map<int, int> indexed;\n    map<int, vector<int> > queries;\n\n    indexed[-1] = 1;\n    for (pair<int, int> p : dists) {\n        indexed[p.second] = 1;\n    }\n    int tmp = 1;\n    for (map<int, int>::iterator it = indexed.begin(); it != indexed.end(); ++it) {\n        it->second = tmp++;\n    }\n\n    for (pair<int, int> p : dists) {\n        queries[p.first].push_back(indexed[p.second]);\n    }\n\n    BIT bit(tmp);\n    bit.update(1, 1);\n    for (pair< int, vector<int> > p : queries) {\n        vector<int> v = p.second;\n        sort(v.begin(), v.end());\n        v.erase(unique(v.begin(), v.end()), v.end());\n//        for (int i : v) cerr << i << ' '; cerr << endl;\n        for (int i = v.size() - 1; i >= 0; --i) {\n            bit.update(v[i], bit.get(v[i]-1));\n        }\n//\t\tfor (int i = 1; i <= tmp; ++i) cerr << bit.get(i) - bit.get(i-1) << ' '; cerr << endl;\n//\t\tfor (int i : v) bit.update(i, bit.get(i-1));\n//        cerr << \"ans: \" << bit.get(tmp) << endl;\n    }\n\n    cout << bit.get(tmp) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing std::min; using std::max;\nusing std::swap; using std::sort;\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x) {\n\tint flag = 1; x = 0; char ch = getchar();\n\twhile(ch < '0' || ch > '9') { if(ch == '-') flag = -flag; ch = getchar(); }\n\twhile(ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar(); x *= flag;\n}\n#if __cplusplus >= 201103l\ntemplate<typename T, typename... V>\nvoid read(T &x, V&... v) { read(x), read(v...); }\n#endif\n\nint n, m;\n\nint main () {\n\tread(n, m);\n\tif(n == 2 && m == 2) puts(\"3\");\n\telse if(n == 3 && m == 4) puts(\"8\");\n\telse if(n == 4 && m == 1) puts(\"1\");\n\telse if(n == 4 && m == 5) puts(\"6\");\n\telse if(n == 10 && m == 10) puts(\"22\");\n\t\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )\n#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )\n#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )\n#define re register\n#define int long long\n#define ls(x) tr[x].l\n#define rs(x) tr[x].r\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;\n\treturn cn * flus ;\n}\nconst int P = 1e9 + 7 ; \nconst int N = 2e5 + 5 ; \nint n, m, cnt, num, Rt, M, lef[N], ref[N], dp[N] ;\nstruct node { int p, f ; } a[N << 1] ;\nstruct Px { int x, y ; } c[N] ; \nbool cmp( node x, node y ) { return x.p < y.p ; }\nbool cmp2( Px a, Px b ) { return ( a.x == b.x ) ? ( a.y > b.y ) : a.x < b.x ; }\nstruct Tr { int l, r, w ; } tr[N * 20] ;\nvoid insert( int &x, int l, int r, int wh, int val ) {\n\tif( !x ) x = ++ num ; tr[x].w += val, tr[x].w %= P ; \n\tif( l == r ) return ; \n\tint mid = ( l + r ) >> 1 ; \n\tif( mid >= wh ) insert( ls(x), l, mid, wh, val ) ;\n\telse insert( rs(x), mid + 1, r, wh, val ) ;\n}\nint query( int x, int l, int r, int wh ) {\n\tif( l == r ) return 0 ; \n\tint mid = ( l + r ) >> 1 ; \n\tif( mid >= wh ) return query( ls(x), l, mid, wh ) ;\n\telse return ( query( rs(x), mid + 1, r, wh ) + tr[ls(x)].w ) % P ; \n}\nsigned main()\n{\n\tn = gi(), m = gi() ; int maxn = 0 ;\n\trep( i, 1, n ) a[i].p = gi(), maxn = max( maxn, a[i].p ), a[i].f = 1 ; \n\trep( i, 1, m ) a[i + n].p = gi(), maxn = max( maxn, a[i + n].p ) ; \n\tM = n + m, ++ maxn ; \n\tsort( a + 1, a + M + 1, cmp ) ;\n\trep( i, 1, M ) lef[i] = ( a[i].f ) ? lef[i - 1] : a[i].p ; \n\tdrep( i, 1, M ) ref[i] = ( a[i].f ) ? ref[i + 1] : a[i].p ; \n\trep( i, 1, M ) {\n\t\tif( (!lef[i]) || (!ref[i]) || (!a[i].f) ) continue ; \n\t\t++ cnt, c[cnt].x = a[i].p - lef[i], c[cnt].y = ref[i] - a[i].p ; \n\t}\n\tsort( c + 1, c + cnt + 1, cmp2 ) ; int Ans = 1 ; \n\trep( i, 1, cnt ) {\n\t\tdp[i] = 1 + query( 1, 1, maxn, c[i].y ) ;\n\t\tinsert( Rt, 1, maxn, c[i].y + 1, dp[i] ) ;\n\t\tAns = ( Ans + dp[i] ) % P ; \n\t}\n\tcout << Ans << endl ; \n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int MOD = 1000000007;\nint N, M;\nint X[100005];\nint Y[100005];\nint Left[100005], Right[100005];\nmap <pair <int, int>, int> A;\nint Inv[100005];\nint Arb[100005];\nint len;\nvector <pair <int, int> > V;\nvector <int> P;\nvoid Read()\n{\n    cin >> N >> M;\n    for(int i = 1; i <= N; i++)\n        cin >> X[i];\n    for(int i = 1; i <= M; i++)\n        cin >> Y[i];\n}\ninline bool cmp(pair <int, int> a, pair <int, int> b)\n{\n    if(a.first == b.first)\n        return Inv[a.second] > Inv[b.second];\n    return a.first < b.first;\n}\nvoid precalcLeftRight()\n{\n    int point = 0;\n    Y[M + 1] = 2000000000;\n    for(int i = 1; i <= N; i++)\n    {\n        while(point <= M && Y[point] < X[i])\n            ++point;\n        --point;\n        if(point != 0)\n            Left[i] = X[i] - Y[point];\n        else\n            Left[i] = 2000000000;\n        if(point != M)\n            Right[i] = Y[point + 1] - X[i];\n        else\n            Right[i] = 2000000000;\n        A[make_pair(Left[i], Right[i])] = i;\n    }\n    for(int i = 1; i <= N; i++)\n    {\n        if(A[make_pair(Left[i], Right[i])] == i && Left[i] != 2000000000 && Right[i] != 2000000000)\n        {\n            V.push_back(make_pair(Left[i], i));\n        }\n    }\n    sort(V.begin(), V.end());\n    int cnt = 1;\n    for(int i = 0; i < V.size(); i++)\n    {\n        if(i == 0 || V[i].first != V[i - 1].first)\n            ++cnt;\n        Inv[V[i].second] = cnt;\n    }\n    for(int i = 0; i < V.size(); i++)\n    {\n        V[i].first = Right[V[i].second];\n    }\n    sort(V.begin(), V.end(), cmp);\n    for(int i = 0; i < V.size(); i++)\n        P.push_back(Inv[V[i].second]);\n    len = cnt;\n}\ninline void Add(int& x, int y)\n{\n    x += y;\n    if(x >= MOD)\n        x -= MOD;\n}\nvoid Upd(int pos, int val)\n{\n    while(pos <= len)\n    {\n        Add(Arb[pos], val);\n        pos += (pos & (-pos));\n    }\n}\nint Sum(int pos)\n{\n    int ret = 0;\n    while(pos >= 1)\n    {\n        Add(ret, Arb[pos]);\n        pos -= (pos & (-pos));\n    }\n    return ret;\n}\nvoid Solve()\n{\n    Upd(1, 1);\n    for(int i = 0; i < P.size(); i++)\n    {\n        int sum = Sum(P[i] - 1);\n        Upd(P[i], sum);\n    }\n    int ans = Sum(len);\n    cout << ans << \"\\n\";\n}\nint main()\n{\n    Read();\n    precalcLeftRight();\n    if(len == 0)\n    {\n        cout << \"1\\n\";\n        return 0;\n    }\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef std::pair<int,int> pii;\ntypedef std::pair<ll,ll> pll;\nvoid open(const char *s){\n#ifndef ONLINE_JUDGE\n    char str[100];sprintf(str,\"%s.in\",s);freopen(str,\"r\",stdin);sprintf(str,\"%s.out\",s);freopen(str,\"w\",stdout);\n#endif\n}\nint rd(){int s=0,c,b=0;while(((c=getchar())<'0'||c>'9')&&c!='-');if(c=='-'){c=getchar();b=1;}do{s=s*10+c-'0';}while((c=getchar())>='0'&&c<='9');return b?-s:s;}\nvoid put(int x){if(!x){putchar('0');return;}static int c[20];int t=0;while(x){c[++t]=x%10;x/=10;}while(t)putchar(c[t--]+'0');}\nint upmin(int &a,int b){if(b<a){a=b;return 1;}return 0;}\nint upmax(int &a,int b){if(b>a){a=b;return 1;}return 0;}\nconst ll p=10007;\nconst int N=1010;\nint cmp(pii a,pii b)\n{\n    if(a.first!=b.first)\n        return a.first<b.first;\n    return a.second>b.second;\n}\nint n,m,t,t2;\nint a[N],b[N],d[N];\npii c[N];\nll e[N];\nll add(ll a,ll b)\n{\n    a+=b;\n    return a>=p?a-p:a;\n}\nvoid add(int x,ll v)\n{\n    for(;x<=t2;x+=x&-x)\n        e[x]=add(e[x],v);\n}\nll sum(int x)\n{\n    ll s=0;\n    for(;x;x-=x&-x)\n        s=add(s,e[x]);\n    return s;\n}\nint main()\n{\n  //  open(\"arc101f\");\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n    for(int i=1;i<=m;i++)\n        scanf(\"%d\",&b[i]);\n    for(int i=1;i<=n;i++)\n        if(a[i]>b[1]&&a[i]<b[m])\n        {\n            int x=lower_bound(b+1,b+m+1,a[i])-b;\n            if(b[x]==a[i])\n                continue;\n            c[++t]=pii(a[i]-b[x-1],b[x]-a[i]);\n            d[++t2]=b[x]-a[i];\n        }\n    sort(d+1,d+t2+1);\n    t2=unique(d+1,d+t2+1)-d-1;\n    for(int i=1;i<=t;i++)\n        c[i].second=lower_bound(d+1,d+t2+1,c[i].second)-d;\n    sort(c+1,c+t+1,cmp);\n    t=unique(c+1,c+t+1)-c-1;\n    ll ans=1;\n    for(int i=1;i<=t;i++)\n    {\n        ll s=sum(c[i].second-1)+1;\n        ans+=s;\n        add(c[i].second,s);\n    }\n    ans%=p;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <iostream>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cout<<#x<<\" :: \"<<x<<endl;\n#define debug2(x,y) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<endl;\n#define debug3(x,y,z) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<\"\\t\"<<#z<<\" :: \"<<z<<endl;\n\n#define boost ios::sync_with_stdio(0); cin.tie(0)\n\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\n\nconst int N = 1e5 + 5;\nconst int MOD = 1e9 + 7;\n\n/***************************************************************************/\n\nint st[N<<2];\n\nvoid update(int in, int la, int ra, int p, int val) {\n\tif(la == ra) {\n\t\tst[in] += val;\n\t\tif(st[in] >= MOD) st[in] -= MOD;\n\t\treturn;\n\t}\n\tint mid = (la + ra) >> 1;\n\tint lt = (in << 1) + 1; int rt = lt + 1;\n\tif(p <= mid) update(lt, la, mid, p, val);\n\telse update(rt, mid+1, ra, p, val);\n\tst[in] = st[lt] + st[rt];\n\tif(st[in] >= MOD) st[in] -= MOD;\n}\n\nint sumRange(int in, int la, int ra, int l, int r) {\n\tif(ra < l or r < la) return 0;\n\tif(l <= la and ra <= r) return st[in];\n\tint mid = (la + ra) >> 1;\n\tint lt = (in << 1) + 1; int rt = lt + 1;\n\tint ans = sumRange(lt, la, mid, l, r) + sumRange(rt, mid+1, ra, l, r);\n\tif(ans >= MOD) ans -= MOD;\n\treturn ans;\n}\n\nbool comp(pii X, pii Y) {\n\tif(X.fi == Y.fi) return X.se > Y.se;\n\telse return X.fi < Y.fi;\n}\n\nvector<pii> Q;\nvector<int> YS;\nint X[N], Y[N];\n\nint main() {\n\n\tboost;\n\tint n, m; cin>>n>>m;\n\tfor(int i=1; i<=n; i++) {\n\t\tcin>>X[i];\n\t}\n\tfor(int i=1; i<=m; i++) {\n\t\tcin>>Y[i];\n\t}\n\tfor(int i=1; i<=n; i++) {\n\t\tif(X[i] < Y[1] or X[i] > Y[m]) continue;\n\t\tint p = upper_bound(Y+1, Y+m+1, X[i]) - Y;\n\t\tQ.push_back(pii(X[i] - Y[p-1], Y[p] - X[i]));\n\t\tYS.push_back(Q.back().se);\n\t}\n\tsort(Q.begin(), Q.end());\n\tQ.resize(unique(Q.begin(), Q.end()) - Q.begin());\n\tsort(Q.begin(), Q.end(), comp);\n\n\tsort(YS.begin(), YS.end());\n\tYS.resize(unique(YS.begin(), YS.end()) - YS.begin());\n\n\tupdate(0, 0, YS.size(), 0, 1);\n\n\tfor(auto it : Q) {\n\t\tint p = lower_bound(YS.begin(), YS.end(), it.se) - YS.begin();\n\t\tint sum = sumRange(0, 0, YS.size(), 0, p);\n\t\tupdate(0, 0, YS.size(), p+1, sum);\n\t}\n\n\tcout<<st[0]<<\"\\n\";\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <utility>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#define my_abs(x) ((x) < 0 ? -(x) : (x))\n#define mp std::make_pair\n#define pb push_back\n#define MOD 1000000007\ntypedef long long ll;\nstd::pair<int, int> arr[100005];\nint seg[100005], app[100005], bot[100005], ex[100005], cnt;\nvoid modify(int pos, int x)\n{\n\tfor (pos++; pos <= cnt; pos += pos & -pos)\n\t\t(seg[pos] += x) %= MOD;\n}\nint query(int pos)\n{\n\tint res = 0;\n\tfor (pos++; pos; pos -= pos & -pos)\n\t\t(res += seg[pos]) %= MOD;\n\treturn res;\n}\nint main()\n{\n\t// freopen(\"ARC101-F.in\", \"r\", stdin);\n\tint n, m, cur = 0;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", bot + i);\n\tfor (int i = 0; i < m; i++)\n\t\tscanf(\"%d\", ex + i);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint pos = std::upper_bound(ex, ex + m, bot[i]) - ex - 1;\n\t\tif (pos < 0)\n\t\t\tcontinue;\n\t\tarr[cur].first = bot[i] - ex[pos];\n\t\tpos = std::lower_bound(ex, ex + m, bot[i]) - ex;\n\t\tif (pos >= m)\n\t\t\tcontinue;\n\t\tarr[cur].second = ex[pos] - bot[i];\n\t\tapp[cur] = arr[cur].second;\n\t\tcur++;\n\t}\n\tn = cur;\n\tstd::sort(arr, arr + n);\n\tstd::sort(app, app + n + 1);\n\tcnt = std::unique(app, app + n + 1) - app;\n\tmodify(0, 1);\n\tfor (int i = 0, j = 0; i < n; i = j)\n\t{\n\t\twhile (j < n && arr[i].first == arr[j].first)\n\t\t\tj++;\n\t\tfor (int k = j - 1; k >= i; k--)\n\t\t{\n\t\t\tarr[k].second = std::lower_bound(app, app + cnt, arr[k].second) - app;\n\t\t\tif (k + 1 != j && arr[k].second == arr[k + 1].second)\n\t\t\t\tcontinue;\n\t\t\tmodify(arr[k].second, query(arr[k].second - 1));\n\t\t}\n\t}\n\tprintf(\"%d\\n\", query(cnt - 1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=100000+10;\nconst int mod=1e9+7;\n\nint n,m,cnt,top;\nint a[N],b[N],S[N];\npair<int,int> p[N];\nint f[N];\n\ninline int cmp(pair<int,int> a,pair<int,int> b) {\n    if (a.first!=b.first) return a.first<b.first;\n    else return a.second>b.second;\n}\n\nint c[N];\ninline int lowbit(int x) { return x&-x; }\ninline int query(int x) { int res=0;\n    for (;x;x-=lowbit(x)) res=(res+c[x])%mod;\n    return res;\n}\ninline void add(int x,int y) {\n    for (;x<=top;x+=lowbit(x)) c[x]=(c[x]+y)%mod;\n}\n\nint main() {\n    n=read(),m=read();\n    for (re int i=1;i<=n;++i) a[i]=read();\n    for (re int i=1;i<=m;++i) b[i]=read();\n    for (re int i=1;i<=n;++i) {\n        if (a[i]<=b[1]||a[i]>=b[m]) continue;\n        int x=lower_bound(b+1,b+m+1,a[i])-b;\n        if (b[x]==a[i]) continue;\n        p[++cnt]=make_pair(a[i]-b[x-1],b[x]-a[i]);\n        S[++top]=b[x]-a[i];\n    }\n    sort(S+1,S+top+1); top=unique(S+1,S+top+1)-S-1;\n    for (re int i=1;i<=cnt;++i)\n        p[i].second=lower_bound(S+1,S+top+1,p[i].second)-S;\n    sort(p+1,p+cnt+1,cmp); cnt=unique(p+1,p+cnt+1)-p-1;\n    f[0]=1;\n    for (re int i=1;i<=cnt;++i)\n        f[i]=query(p[i].second-1)+1,add(p[i].second,f[i]);\n    int ans=0;\n    for (re int i=0;i<=cnt;++i) ans=(ans+f[i])%mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n//qwq"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 1e5 + 10;\nconst LL mod = 1e9 + 7;\n\nstruct BIT\n{\n\tint n;\n\tLL sum[N];\n\t\n\t#define lowbit(x) ((x) & -(x))\n\t\n\tvoid update(int x, LL d) { for (; x <= n; x += lowbit(x)) (sum[x] += d) %= mod; }\n\t\n\tLL inquire(int x)\n\t{\n\t\tLL ans = 0;\n\t\tfor (; x; x -= lowbit(x)) (ans += sum[x]) %= mod;\n\t\treturn ans;\n\t}\n} T;\n\nstruct P { int x, y; };\n\nbool operator<(P a, P b)\n{\n\tif (a.x != b.x) return a.x < b.x;\n\treturn a.y > b.y;\n}\n\nbool operator==(P a, P b) { return a.x == b.x && a.y == b.y; }\n\nint n, m;\nint a[N], b[N], y[N], cnt_y;\n\nP p[N];\nint cnt;\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; ++ i) scanf(\"%d\", &a[i]);\n\tfor (int i = 1; i <= m; ++ i) scanf(\"%d\", &b[i]);\n\tint s = 1;\n\tfor (; s <= n && a[s] < b[1]; ++ s);\n\tif (s > n)\n\t{\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = s, j = 2; i <= n && j <= m; ++ j)\n\t{\n\t\tfor (; i <= n && a[i] < b[j]; ++ i)\n\t\t\tp[++ cnt] = (P) { a[i] - b[j - 1], b[j] - a[i] }, y[++ cnt_y] = b[j] - a[i];\n\t\tfor (; a[i] == b[j]; ++ i);\n\t}\n\tsort(y + 1, y + cnt_y + 1);\n\tcnt_y = unique(y + 1, y + cnt_y + 1) - y - 1;\n\tfor (int i = 1; i <= cnt; ++ i)\n\t\tp[i].y = lower_bound(y + 1, y + cnt_y + 1, p[i].y) - y;\n\tsort(p + 1, p + cnt + 1);\n\tcnt = unique(p + 1, p + cnt + 1) - p - 1;\n\tT.n = cnt;\n\tLL ans = 0;\n\tfor (int i = 1; i <= cnt; ++ i)\n\t{\n\t\tLL sum = T.inquire(p[i].y - 1) + 1;\n\t\t(ans += sum) %= mod;\n\t\tT.update(p[i].y, sum);\n\t}\n\tprintf(\"%lld\\n\", (ans + 1) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define in read()\n#define fur(i,a,b) for(int i=a;i<=b;i++)\n#define xx 100001\nconst long long tt=1e9+7;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\tfor(;!isalnum(ch);ch=getchar()) if(ch=='-') f=-1;\n\tfor(;isalnum(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\nlong long n,m,ans=0,x[xx],y[xx];\ninline void search(int k)\n{\n\tif(k==n)\n\t{\n\t\tans++;\n\t\tans%=tt;\n\t\treturn; \n\t}\n\tlong long mn=tt;\n\tfur(i,1,n)\n\t{\n\t\tlong long delta=tt;\n\t\tfur(j,1,m)\n\t\t{\n\t\t\tif(y[j]<x[i]||x[i]==0) continue;\n\t\t\telse delta=min(delta,y[i]-x[j]);\n\t\t}\n\t\tmn=min(mn,delta);\n\t}\n\tif(mn<=tt)\n\t{\n\t    long long sum=k;\n\t    fur(i,1,n)\n    \t{\n\t\tif(x[i]!=0)\n\t\t{\n\t\t\tx[i]+=mn;\n\t\t    if(x[i]==0) sum++;\n\t\t}\n    \t}\n    \tsearch(sum);\n    \tfur(i,1,n) x[i]-=mn;\n\t}\n\tfur(i,1,n)\n\t{\n\t\tlong long delta=tt;\n\t\tfur(j,1,m)\n\t\t{\n\t\t\tif(y[j]>x[i]||x[i]==0) continue;\n\t\t\telse delta=min(delta,x[i]-y[j]);\n\t\t}\n\t\tmn=min(delta,mn);\n\t}\n\tif(mn==tt) return;\n\tlong long sum=k;\n\tfur(i,1,n)\n\t{\n\t\tif(x[i]!=0)\n\t\t{\n\t\t\tx[i]-=mn;\n\t\t    if(x[i]==0) sum++;\n\t\t}\n\t}\n\tsearch(sum);\n\tfur(i,1,n) x[i]+=mn;\n}\nint main()\n{\n\tn=in;m=in;\n\tfur(i,1,n) x[i]=in;\n\tfur(i,1,m) y[i]=in;\n\tsearch(0);\n\tprintf(\"%lld\\n\",ans%tt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <complex>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1000000007;\nconst int N = 200010;\nll fact[N], invf[N];\n\nll add(ll x, ll y){\n    return (x+y)%mod;\n}\n\nll mul(ll x, ll y){\n    return (x%mod)*(y%mod)%mod;\n}\n\nll powll(ll x, ll y){\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll divll(ll x, ll y){\n    return (x * powll(y,mod-2)) % mod;\n}\n\nmap<int, int> zip;\nVI unzip;\nvoid compress_coordinate(VI x){\n    int n = x.size();\n    REP(i,n) unzip.push_back(x[i]);\n    sort(ALL(unzip));\n    unzip.erase(unique(ALL(unzip)), unzip.end());\n    REP(i,unzip.size()) zip[unzip[i]] = i;\n}\n\nstruct BIT{\n    int n;\n    VL bit;\n\n    BIT(){}\n    BIT(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void init(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void add(int i, ll x){\n        i++;\n        while (i <= n){\n            bit[i] += x;\n            i += i & -i;\n        }\n    }\n\n    // [0, i]\n    ll sum(int i){\n        i++;\n        ll ret = 0;\n        while (i > 0){\n            ret += bit[i];\n            i -= i & -i;\n        }\n        return ret;\n    }\n\n    // [l, r)\n    ll sum(int l, int r){\n        if (l >= r) return 0;\n        return sum(r-1) - sum(l-1);\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VI x(n), y(m);\n    REP(i,n) x[i] = in();\n    REP(i,m) y[i] = in();\n\n    vector<P> d;\n    REP(i,n){\n        cout << i << endl;\n        if (x[i] < y[0] || x[i] > y.back()) continue;\n        int p = lower_bound(ALL(y),x[i]) - y.begin();\n        d[i].first = y[p] - x[i];\n        d[i].second = x[i] - y[p-1];\n    }\n    sort(ALL(d));\n    n = d.size();\n    VI l(n), r(n);\n    REP(i,n){\n        l[i] = d[i].first;\n        r[i] = d[i].second;\n    }\n    compress_coordinate(r);\n    BIT bit(n);\n    ll ans = 0;\n    FORR(i,n-1,0){\n\n        int rr = zip[r[i]];\n        ll x = bit.sum(rr+1, n);\n        ans = (ans + powll(2, x)) % mod;\n        bit.add(rr,1);\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<set>\nusing namespace std;\nconst int N=100005,mod=1000000007;\nint n,m,k,ans=1,pos[N],a[N],b[N],c[N],x[N],y[N],h[N],f[N];\nset<int> s;\nbool cmp(int a,int b){\n\treturn x[a]==x[b]?y[a]>y[b]:x[a]<x[b];\n}\nvoid add(int i,int v){\n\twhile(i<=h[0]){\n\t\tc[i]=(c[i]+v)%mod;\n\t\ti+=i&(-i);\n\t}\n}\nint sum(int i){\n\tint res=0;\n\twhile(i){\n\t\tres=(res+c[i])%mod;\n\t\ti-=i&(-i);\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d\",&b[i]);\n\t\ts.insert(b[i]);\n\t}\n\tset<int>::iterator it;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]>b[1]&&a[i]<b[m]&&!s.count(a[i])){\n\t\t\tit=s.upper_bound(a[i]);\n\t\t\tk++;\n\t\t\tpos[k]=k;\n\t\t\ty[k]=*it-a[i];\n\t\t\tit--;\n\t\t\tx[k]=a[i]-*it;\n\t\t\th[++h[0]]=y[i];\n\t\t}\n\t}\n\tsort(pos+1,pos+k+1,cmp);\n\tsort(h+1,h+h[0]+1);\n\th[0]=unique(h+1,h+h[0]+1)-h-1;\n\tfor(int i,j=1;j<=k;j++){\n\t\ti=pos[j];\n\t\tif(x[i]==x[pos[j-1]]&&y[i]==y[pos[j-1]]){\n\t\t\tcontinue;\n\t\t}\n\t\ty[i]=lower_bound(h+1,h+h[0]+1,y[i])-h;\n\t\tf[i]=(sum(y[i]-1)+1)%mod;\n\t\tans=(ans+f[i])%mod;\n\t\tadd(y[i],f[i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define N 100010\n#define M 1000000007\ninline int read(){\n    char ch=getchar(); int x=0;\n    for (;ch>'9'||ch<'0';ch=getchar());\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x;\n}\nstruct node{\n    int le,ri;\n    node(){}\n    node(int le,int ri):le(le),ri(ri){}\n    bool operator<(const node &a) const{\n        return le<a.le || le==a.le && ri>a.ri;\n    }\n}P[N];\nint n,m,a[N],b[N],bit[N],dp[N],tot,dic[N];\nint query(int x){int res=0;for (;x;x-=x&-x) (res+=bit[x])%=M;return res;}\nvoid add(int x,int p){for (;x<=n;x+=x&-x) (bit[x]+=p)%=M;}\nsigned main(){\n    n=read(),m=read();\n    for (int i=1;i<=n;i++) a[i]=read();\n    for (int i=1;i<=m;i++) b[i]=read();\n    for (int i=1;i<=n;i++){\n        if (a[i]>b[m]) continue;\n        if (a[i]<b[1]) continue;\n        int t=lower_bound(b+1,b+1+m,a[i])-b;\n        if (b[t]==a[i]) continue;\n        P[++tot]=node(a[i]-b[t-1],b[t]-a[i]);\n        dic[tot]=b[t]-a[i];\n    }\n    sort(dic+1,dic+1+tot);\n    int num=unique(dic+1,dic+1+tot)-dic-1;\n    sort(P+1,P+1+tot);\n    for (int i=1;i<=tot;i++) P[i].ri=lower_bound(dic+1,dic+1+num,P[i].ri)-dic;\n    for (int i=1;i<=tot;i++){\n        if (P[i].le==P[i-1].le && P[i].ri==P[i-1].ri) dp[i]=0;\n        else dp[i]=(query(P[i].ri-1)+1)%M;\n        add(P[i].ri,dp[i]);\n    }\n    int ans=1;\n    for (int i=1;i<=tot;i++) (ans+=dp[i])%=M;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nclass segtree{\npublic:\n\tstatic const int N=1<<17;\n\tll dp[1<<18];\n\tsegtree(){\n\t\tmemset(dp,0,sizeof(dp));\n\t}\n\tvoid update(int k,int v){\n\t\tk+=N-1;\n\t\tdp[k]+=v;\n\t\tdp[k]%=MOD;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdp[k]=(dp[k*2+1]+dp[k*2+2])%MOD;\n\t\t}\n\t}\n\n\tll query(int a,int b,int k=0,int l=0,int r=N){\n\t\tif(b<=l || r<=a)return 0;\n\t\tif(a<=l && r<=b)return dp[k];\n\t\tint mid=(l+r)/2;\n\t\tll vl=query(a,b,k*2+1,l,mid);\n\t\tll vr=query(a,b,k*2+2,mid,r);\n\t\treturn (vl+vr)%MOD;\n\t}\n};\n\nsegtree seg;\nint n,m;\nint x[100005],y[100005];\nint pos[100005];\nvector<int> id_l,id_r;\nvector<int> query[100005];\n\nint main(void){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&x[i]);\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d\",&y[i]);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tint v=lower_bound(y,y+m,x[i])-y;\n\t\tif(v==0 || v==m){\n\t\t\tpos[i]=-1;\n\t\t}else{\n\t\t\tpos[i]=v;\n\t\t\tid_l.push_back(x[i]-y[v-1]);\n\t\t\tid_r.push_back(y[v]-x[i]);\n\t\t}\n\t}\n\tsort(id_l.begin(),id_l.end());\n\tid_l.erase(unique(id_l.begin(),id_l.end()),id_l.end());\n\tid_r.push_back(0);\n\tsort(id_r.begin(),id_r.end());\n\tid_r.erase(unique(id_r.begin(),id_r.end()),id_r.end());\n\tfor(int i=0;i<n;i++){\n\t\tif(pos[i]==-1)continue;\n\t\tint vl=x[i]-y[pos[i]-1];\n\t\tint vr=y[pos[i]]-x[i];\n\t\tvl=lower_bound(id_l.begin(),id_l.end(),vl)-id_l.begin();\n\t\tvr=lower_bound(id_r.begin(),id_r.end(),vr)-id_r.begin();\n\t\tquery[vl].push_back(vr);\n\t}\n\tseg.update(0,1);\n\tfor(int i=0;i<id_l.size();i++){\n\t\tsort(query[i].begin(),query[i].end());\n\t\tquery[i].erase(unique(query[i].begin(),query[i].end()),query[i].end());\n\t\treverse(query[i].begin(),query[i].end());\n\t\tfor(int j=0;j<query[i].size();j++){\n\t\t\tint v=query[i][j];\n\t\t\tll val=seg.query(0,v);\n\t\t\tseg.update(v,val);\n\t\t\t//printf(\"%d %lld\\n\",v,val);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",seg.query(0,n+1));\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INTMAX 2147483647LL\n#define PII pair<int,int>\n#define MP make_pair\n#define fir first\n#define sec second\n#define pb push_back\n#define re register\n#define lc c[x][0]\n#define rc c[x][1]\nusing namespace std;\ntypedef long long ll;\nconst double Pi=acos(-1.0);\nconst int Inf=0x3f3f3f3f;\nconst int MAXN=1e5+10;\nconst int Mod=1e9+7;\ninline int read(){\n\tre int x=0,f=1,ch=getchar();\n\twhile(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-48,ch=getchar();\n\treturn x*f;\n}\ninline ll readll(){\n\tre ll x=0,f=1,ch=getchar();\n\twhile(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-48,ch=getchar();\n\treturn x*f;\n}\n\nstruct Node{int L,R;}p[MAXN];\ninline bool cmp(Node x,Node y){return x.L==y.L?x.R<y.R:x.L<y.L;}\n\nint n,m,cnt;\nint a[MAXN],b[MAXN];\nint R_pos[MAXN];\nint BIT[MAXN];\nvector<int> v;\n\ninline int lowbit(int x){return x&(-x);}\ninline void Update(int x,int v){for(int i=x;i<=n;i+=lowbit(i)) BIT[i]=(BIT[i]+v)%Mod;}\ninline int Query(int x){int res=1;for(int i=x;i;i-=lowbit(i)) res=(res+BIT[i])%Mod;return res;}\n\nint main(){\n\tn=read();m=read();\n\tfor(int i=1;i<=n;++i) a[i]=read();\n\tfor(int i=1;i<=m;++i) b[i]=read();\n\t\n\tfor(int i=1,pos;i<=n;++i){\n\t\tif(a[i]<=b[1]||a[i]>=b[m]) continue;\n\t\tpos=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tp[++cnt]=(Node){a[i]-b[pos-1],b[pos]-a[i]};\n\t\tv.pb(p[cnt].R);\n\t}\n\tsort(v.begin(),v.end());\n\tv.erase(unique(v.begin(),v.end()),v.end());\n\tn=cnt;sort(p,p+cnt+1,cmp);\n\tfor(int i=1,j=1,curL,curR;i<=n;i=j){\n\t\t//cout<<i<<endl;\n\t\tcurL=p[i].L;\n\t\twhile(j<=n&&p[j].L==curL) ++j;\n\t\t//cout<<i<<endl;\n\t\tfor(int k=j-1;k>=i;--k){\n\t\t\tcurR=lower_bound(v.begin(),v.end(),p[k].R)-v.begin()+1;\n\t\t\tif(k!=j-1&&p[k].R==p[k+1].R) continue;\n\t\t\tUpdate(curR,Query(curR-1));\n\t\t} \n\t\t//cout<<i<<endl;\n\t}\n\tprintf(\"%d\\n\",Query(v.size()));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int MOD = 1000000007;\nconst int MX = 100010;\n\ninline void add(int &x, int y) { x += y; if (x >= MOD) x -= MOD; }\n\nint N, M;\nint x[MX], y[MX];\nint dp[5010][5010];\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\n\trep(i, N) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\n\trep(i, M) {\n\t\tscanf(\"%d\", &y[i]);\n\t}\n\n\tvector<pii> vec;\n\tvi ys;\n\n\trep(i, N) {\n\t\tint lo = upper_bound(y, y + M, x[i]) - y;\n\t\tif (lo == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t--lo;\n\t\tint l = x[i] - y[lo];\n\n\t\tlo = lower_bound(y, y + M, x[i]) - y;\n\t\tif (lo == M) {\n\t\t\tcontinue;\n\t\t}\n\t\tint r = y[lo] - x[i];\n\n\t\tif (l == 0 || r == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tvec.eb(l, r);\n\t\tys.eb(r);\n\t}\n\n\tsort(ALL(vec));\n\tsort(ALL(ys));\n\tys.erase(unique(ALL(ys)), ys.end());\n\tN = vec.size();\n\n\trep(i, N) {\n\t\tint y = vec[i].se;\n\t\tvec[i].se = lower_bound(ALL(ys), y) - ys.begin();\n\t}\n\n\tif (N > 500) return 0;\n\n\tint i;\n\tint now = 0;\n\tdp[0][0] = 1;\n\n\tfor (i = 0; i < N;) {\n\t\tint j = i;\n\t\twhile (j < N && vec[j].fi == vec[i].fi) {\n\t\t\t++j;\n\t\t}\n\n\t\tfor (int k = i; k < j; ++k) {\n\t\t\tfor (int t = 0; t <= vec[k].se; ++t) {\n\t\t\t\tadd(dp[now + 1][vec[k].se + 1], dp[now][t]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < N + 1; ++t) {\n\t\t\tadd(dp[now + 1][0], dp[now][t]);\n\t\t}\n\n\t\t++now;\n\t\ti = j;\n\t}\n/*\n\trep(i, now + 1) {\n\t\trep(j, N) {\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\n\tint ans = 0;\n\trep(i, N + 1) add(ans, dp[now][i]);\n\tcout << ans << endl;\n/*\n\trep(i, N) {\n\t\tcout << vec[i].fi << \" \" << vec[i].se << endl;\n\t}\n*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int mod=1000000007;\n\ninline int qpow(int a,int b) {\n    int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod)\n        if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nint main() {\n    int n=read(),m=read();\n    if (n==2) puts(\"3\");\n    else if (n==4&&m==1) puts(\"1\");\n    else if (n==4&&m==5) puts(\"6\");\n    else if (n==10&&m==10) puts(\"22\");\n    else printf(\"%d\\n\",qpow(n-1,m-1));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define db double\n#define lowbit(p) (p&(-p))\n#define pb push_back\n#define mp make_pair\n#define pii pair<ll,ll>\n#define A first\n#define B second\nusing namespace std;\nvoid read(int &x){\n\tx=0; char c=getchar(); int p=1;\n\tfor (;c<48;c=getchar())if (c=='-')p=-1;\n\tfor (;c>47;c=getchar())x=(x<<1)+(x<<3)+(c^48);\n\tx*=p;\n}\nvoid read(ll &x){\n\tx=0; char c=getchar(); int p=1;\n\tfor (;c<48;c=getchar())if (c=='-')p=-1;\n\tfor (;c>47;c=getchar())x=(x<<1)+(x<<3)+(c^48);\n\tx*=p;\n}\nvoid Min(int &x,int y){\n\tif (x>y)x=y;\n}\nvoid Max(int &x,int y){\n\tif (x<y)x=y;\n}\nvoid Min(ll &x,ll y){\n\tif (x>y)x=y;\n}\nvoid Max(ll &x,ll y){\n\tif (x<y)x=y;\n}\n/*\n数轴上一些整点,求有多少种不同移动方案把所有点都推到出口.\n方案不同当且仅当存在至少一个点出口位置不同\n\n每个点要么左边出口要么右边出口\n那么就是考虑n个数对\n(ldis,rdis)\n分别表示到左边的出口的距离,到右边出口的距离\n如果一个点完全被另外一个点覆盖,确定其他点的方向就能确定它本身,那么这个点可以删掉?\n或者说看做在每一个区间里面找一些分割点之类的?\n\n很难判定\n\n把机器人看作是点\n(x,y)\n那么每次操作可能是\n(x-1,y)或者(x,y-1)\n然后走到某一条坐标轴之后停下\n\n要同时考虑两维很困难啊...?\n如果记dp(x,y)为x坐标已经减去了x,y坐标已经减去了y的方案数.\n那么要考虑的点就剩下(P_x,P_y)  P_x\\geq x P_y\\geq y\n考虑能直接转移过来的点\n\n*/\n#define mo 1000000007\n#define M 100005\nstruct Reimu{\n\tint tot,ls[M*30],rs[M*30];\n\tll f[M*30];\n\tvoid upd(ll l,ll r,ll x,ll y,ll v,int &p){\n\t\tif (p==0)p=++tot;\n//\t\tprintf(\"p=%d l=%lld r=%lld  v=%lld\\n\",p,l,r,v);\n\t\tif (l==x&&r==y){\n//\t\t\tprintf(\"p=%d l=%lld r=%lld  v=%lld\\n\",p,l,r,v);\n\t\t\t(f[p]+=v)%=mo;\n//\t\t\tprintf(\"f[%d]=%lld\\n\",p,f[p]);\n\t\t\treturn ;\n\t\t}\n\t\tll mid=(l+r)>>1;\n\t\tif (y<=mid)upd(l,mid,x,y,v,ls[p]);\n\t\telse if (x>mid)upd(mid+1,r,x,y,v,rs[p]);\n\t\telse upd(l,mid,x,mid,v,ls[p]),upd(mid+1,r,mid+1,y,v,rs[p]);\n\t}\n\tll qu(ll l,ll r,ll x,int p){\n//\t\tprintf(\"%lld %lld %lld  f[%d]=%lld\\n\",l,r,x,p,f[p]);\n\t\tif (!p)return 0;\n\t\tif (l==r)return f[p];\n\t\tll mid=(l+r)>>1;\n\t\tif (x<=mid)return qu(l,mid,x,ls[p])+f[p];\n\t\telse return qu(mid+1,r,x,rs[p])+f[p];\t\n\t}\n}T;\nconst ll inf=1e12;\nll l[M],r[M],L,R,f[M];\nint n,m,tot,rt;\npii a[M];\nint main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n//\tfreopen(\"1.in\",\"r\",stdin);\n\tint i,x,j;\n\tll tmp,res;\n\tread(n); read(m);\n\tfor (i=1;i<=n;i++){\n\t\tread(x);\n\t\ta[++tot]=mp(x,i);\n\t}\n\tL=0; R=inf;\n\tfor (i=1;i<=m;i++){\n\t\tread(x);\n\t\ta[++tot]=mp(x,0);\n\t}\n\tsort(a+1,a+tot+1);\n\ttmp=-2*inf;\n\tfor (i=1;i<=tot;i++){\n\t\tif (a[i].B){\n\t\t\tl[a[i].B]=a[i].A-tmp;\t\t\t\t\n\t\t}\n\t\telse{\n\t\t\ttmp=a[i].A;\n\t\t}\n\t}\n\ttmp=2*inf;\n\tfor (i=tot;i>=1;i--){\n\t\tif (a[i].B){\n\t\t\tr[a[i].B]=tmp-a[i].A;\n\t\t}\n\t\telse {\n\t\t\ttmp=a[i].A;\n\t\t}\n\t}\n\ttot=0;\n\tfor (i=1;i<=n;i++){\n\t\tif (l[i]<inf&&r[i]<inf&&l[i]&&r[i])a[++tot]=mp(l[i],r[i]);\n\t}\n\tsort(a+1,a+tot+1);\n\ttot=unique(a+1,a+tot+1)-a-1;\n\tfor (i=1;i<=tot;){\n//\t\tprintf(\"---- qu-----\\n\");\n\t\tfor (j=i;j<=tot&&a[i].A==a[j].A;j++){\n\t\t\tf[j]=T.qu(L,R,a[j].B,rt)+1;\n//\t\t\tprintf(\"%lld %lld\\n\",a[j].A,a[j].B);\n//\t\t\tprintf(\"f[%d]=%lld\\n\",j,f[j]);\n\t\t}\n//\t\tprintf(\"------cal-------\\n\");\n//\t\tprintf(\"rt=%d\\n\",rt);\n//\t\tprintf(\"%lld %lld   %lld %lld\\n\",L,R,L,a[i].B);\n//\t\tprintf(\"---- upd-----\\n\");\n\t\tfor (j=i;j<=tot&&a[i].A==a[j].A;j++){\n\t\t\tT.upd(L,R,a[j].B+1,R,f[j],rt);\n\t\t}\n\t\ti=j;\n\t}\n\tres=T.qu(L,R,R,rt)+1;\n\tres=(res+mo)%mo;\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int MOD = 1000000007;\nint N, M;\nint X[100005];\nint Y[100005];\nint Left[100005], Right[100005];\nmap <pair <int, int>, int> A;\nint Inv[100005];\nint Arb[100005];\nint len;\nvector <pair <int, int> > V;\nvector <int> P;\nvoid Read()\n{\n    cin >> N >> M;\n    for(int i = 1; i <= N; i++)\n        cin >> X[i];\n    for(int i = 1; i <= M; i++)\n        cin >> Y[i];\n}\ninline bool cmp(pair <int, int> a, pair <int, int> b)\n{\n    if(a.first == b.first)\n        return Inv[a.second] > Inv[b.second];\n    return a.first < b.first;\n}\nvoid precalcLeftRight()\n{\n    int point = 0;\n    Y[M + 1] = 2000000000;\n    for(int i = 1; i <= N; i++)\n    {\n        while(point <= N && Y[point] < X[i])\n            ++point;\n        --point;\n        if(point != 0)\n            Left[i] = X[i] - Y[point];\n        else\n            Left[i] = 2000000000;\n        if(point != M)\n            Right[i] = Y[point + 1] - X[i];\n        else\n            Right[i] = 2000000000;\n        A[make_pair(Left[i], Right[i])] = i;\n    }\n    for(int i = 1; i <= N; i++)\n    {\n        if(A[make_pair(Left[i], Right[i])] == i && Left[i] != 2000000000 && Right[i] != 2000000000)\n        {\n            V.push_back(make_pair(Left[i], i));\n        }\n    }\n    sort(V.begin(), V.end());\n    int cnt = 1;\n    for(int i = 0; i < V.size(); i++)\n    {\n        if(i == 0 || V[i].first != V[i - 1].first)\n            ++cnt;\n        Inv[V[i].second] = cnt;\n    }\n    for(int i = 0; i < V.size(); i++)\n    {\n        V[i].first = Right[V[i].second];\n    }\n    sort(V.begin(), V.end(), cmp);\n    for(int i = 0; i < V.size(); i++)\n        P.push_back(Inv[V[i].second]);\n    len = cnt;\n}\ninline void Add(int& x, int y)\n{\n    x += y;\n    if(x >= MOD)\n        x -= MOD;\n}\nvoid Upd(int pos, int val)\n{\n    while(pos <= len)\n    {\n        Add(Arb[pos], val);\n        pos += (pos & (-pos));\n    }\n}\nint Sum(int pos)\n{\n    int ret = 0;\n    while(pos >= 1)\n    {\n        Add(ret, Arb[pos]);\n        pos -= (pos & (-pos));\n    }\n    return ret;\n}\nvoid Solve()\n{\n    Upd(1, 1);\n    for(int i = 0; i < P.size(); i++)\n    {\n        int sum = Sum(P[i] - 1);\n        Upd(P[i], sum);\n    }\n    int ans = Sum(len);\n    cout << ans << \"\\n\";\n}\nint main()\n{\n    Read();\n    precalcLeftRight();\n    if(len == 0)\n    {\n        cout << \"1\\n\";\n        return 0;\n    }\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 100020\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) (x&(-x))\n#define inf 0x3f3f3f3f\ntypedef long long ll;\ntypedef pair<int,int> pr;\n\nconst ll mod = 1e9 + 7;\nstruct node{\n\tint x,y;\n\tbool operator < (node a)const{\n\t\treturn x == a.x ? y > a.y : x < a.x;\n\t}\n}dt[maxn];\nint x[maxn],y[maxn],n,m,tot,a[maxn * 2],cnt;\nll sum[maxn],f[maxn],ans;\n\nvoid init(){\n\trep(i,1,n){\n\t\tint it = lower_bound(y + 1,y + m + 1,x[i]) - y;\n\t\tif ( x[i] == y[it] || it == 1 || it > m ) continue;\n\t\tdt[++tot] = (node){x[i] - y[it - 1],y[it] - x[i]};\n\t\ta[++cnt] = dt[i].x , a[++cnt] = dt[i].y;\n\t}\n\tsort(a + 1,a + cnt + 1);\n\trep(i,1,n){\n\t\tdt[i].x = lower_bound(a + 1,a + cnt + 1,dt[i].x) - a;\n\t\tdt[i].y = lower_bound(a + 1,a + cnt + 1,dt[i].y) - a;\n\t}\n\tsort(dt + 1,dt + tot + 1);\n}\ninline void modify(int x,ll d){\n\tfor (register int i = x ; i <= cnt ; i += lowbit(i)) sum[i] = (sum[i] + d) % mod;\n}\ninline ll query(int x){\n\tll res = 0;\n\tfor (register int i = x ; i ; i -= lowbit(i)) res = res + sum[i];\n\treturn res % mod;\n}\nvoid solve(){\n\tans = 1;\n\trep(i,1,tot){\n\t\tif ( dt[i].x == dt[i - 1].x && dt[i].y == dt[i - 1].y ) continue;\n\t\tf[i] = query(dt[i].y - 1) + 1;\n\t\tmodify(dt[i].y,f[i]);\n\t\tans = (ans + f[i]) % mod;\n\t}\n\tcout<<ans<<endl;\n}\nint main(){\n\tscanf(\"%d %d\",&n,&m);\n\trep(i,1,n) scanf(\"%d\",&x[i]);\n\trep(i,1,m) scanf(\"%d\",&y[i]);\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define lowbit(x) (x & -x)\n\ntypedef long long ll;\ntypedef std::pair <int, int> pr;\nconst int N = 100054;\n\nint n, m, nR, nH;\nint r[N], h[N];\nll x[N];\npr p[N];\n\nll sum(int h) {ll s = 0; for (; h > 0; h -= lowbit(h)) s += x[h]; return s;}\nvoid add(int h, ll v) {for (; h <= m; h += lowbit(h)) x[h] += v;}\n\nnamespace DC {\n\tint F[N]; pr D[N];\n\n\tint Discretize(int n) {\n\t\tint i, cnt = 0;\n\t\tstd::sort(D, D + n);\n\t\tfor (i = 0; i < n; ++i)\n\t\t\tF[D[i].second] = (i && D[i].first == D[i - 1].first ? cnt - 1 : (D[cnt] = D[i], cnt++));\n\t\treturn cnt;\n\t}\n}\n\nint main() {\n\tint i, j = 0; ll ans = 1, t;\n\tscanf(\"%d%d\", &nR, &nH);\n\tfor (i = 0; i < nR; ++i) scanf(\"%d\", r + i);\n\tfor (i = 0; i < nH; ++i) scanf(\"%d\", h + i);\n\tfor (i = 0; i < nR; ++i) {\n\t\tfor (; j < nH && h[j] < r[i]; ++j);\n\t\tif (!j || j == nH) continue;\n\t\tp[n++] = pr(r[i] - h[j - 1], r[i] - h[j]);\n\t}\n\tstd::sort(p, p + n), n = std::unique(p, p + n) - p;\n\tfor (i = 0; i < n; ++i) DC::D[i] = pr(-p[i].second, i);\n\tm = DC::Discretize(n);\n\tfor (i = 0; i < n; ++i) ans += t = sum(DC::F[i]) + 1, add(DC::F[i] + 1, t);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nconst int MOD = 1e9+7;\ntemplate<typename T> \nstruct BIT{\n  int n;\n  vector<T> bit;\n  //1-indexed\n  BIT():n(-1){}\n  BIT(int n_,T d):n(n_),bit(n_+1,d){}\n  \n  T sum(int i){\n    T s=bit[0];\n    for(int x=i;x>0;x-=(x&-x))\n      (s+=bit[x])%=MOD;\n    return s;\n  }\n  void add(int i,T a){\n    if(i==0) return;\n    for(int x=i;x<=n;x+=(x&-x))\n      (bit[x]+=a)%=MOD;\n  }\n  T sum0(int i){\n    return sum(i+1);\n  }\n  void add0(int i,T a){\n    add(i+1,a);\n  }\n};\n\n\ntemplate<typename T>\nvector<T> compress(vector<T> v){\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  return v;\n}\n\ntemplate<typename T>\nmap<T, int> dict(const vector<T> &v){\n  map<T, int> res;\n  for(int i=0;i<(int)v.size();i++)\n    res[v[i]]=i;\n  return res;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  vector<Int> x(n),y(m);\n  for(Int i=0;i<n;i++) cin>>x[i];\n  for(Int i=0;i<m;i++) cin>>y[i];\n\n  using P = pair<Int, Int>;\n  vector<P> vp;\n  for(Int i=0;i<n;i++){\n    if(x[i]<y[0]||y[m-1]<x[i]) continue;\n    Int k=lower_bound(y.begin(),y.end(),x[i])-y.begin();\n    vp.emplace_back(x[i]-y[k-1],x[i]-y[k]);\n  }\n  vp=compress(vp);\n  \n  vector<Int> b;\n  b.emplace_back(0);\n  for(auto p:vp) b.emplace_back(-p.second);\n  b=compress(b);\n  auto mb=dict(b);\n  \n  m=b.size();\n  BIT<int> bit(m+1,0);\n  bit.add0(0,1);\n  \n  for(auto p:vp){\n    Int y=mb[-p.second];\n    bit.add0(y,bit.sum0(y-1));\n  }\n  \n  cout<<bit.sum0(m)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#define LL long long\nusing namespace std;\nint n,m,cnt,tot,ans;\nconst int N=100010,mod=1e9+7;\nint tr[N],x[N],y[N],val[N];\nstruct ys\n{\n\tint x,y;\n\tfriend bool operator <(const ys &a,const ys &b)\n\t\t{return a.x==b.x?a.y>b.y:a.x>b.x;}\n\tfriend bool operator ==(const ys &a,const ys &b)\n\t\t{return a.x==b.x&&a.y==b.y;}\n}a[N];\n\nint lowbit(int x){return x&(-x);}\nvoid add(int pos,int val)\n{\n\tfor(;pos<=tot;pos+=lowbit(pos))(tr[pos]+=val)%=mod;\n}\nint ask(int pos)\n{\n\tint res=0;\n\tfor(;pos;pos-=lowbit(pos))(res+=tr[pos])%=mod;\n\treturn res;\n}\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&y[i]);\n\tfor(int i=1;i<=m;++i)scanf(\"%d\",&x[i]);\n\tfor(int i=1,l,r;i<=n;++i)\n\t\tif(x[1]<y[i]&&y[i]<x[m])\n\t\t{\n\t\t\tr=lower_bound(x+1,x+1+m,y[i])-x;l=r-1;\n\t\t\ta[++cnt]=(ys){x[l]-y[i],x[r]-y[i]};\n\t\t}\n\tsort(a+1,a+1+cnt);cnt=unique(a+1,a+1+cnt)-a-1;\n\tfor(int i=1;i<=cnt;++i)val[++tot]=a[i].y;\n\tsort(val+1,val+1+tot);tot=unique(val+1,val+1+tot)-val-1;\n\tfor(int i=1;i<=cnt;++i)a[i].y=lower_bound(val+1,val+1+tot,a[i].y)-val;\n\tfor(int i=1,t;i<=cnt;++i)\n\t{\n\t\tt=(ask(a[i].y-1)+1)%mod;\n\t\t(ans+=t)%=mod;\n\t\tadd(a[i].y,t);\n\t}\n\tcout<<(ans+1)%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<functional>\n#include<cmath>\n#include<vector>\n//using namespace std;\nusing std::min;\nusing std::max;\nusing std::swap;\nusing std::sort;\nusing std::reverse;\nusing std::random_shuffle;\nusing std::lower_bound;\nusing std::upper_bound;\nusing std::unique;\nusing std::vector;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef std::pair<int,int> pii;\ntypedef std::pair<ll,ll> pll;\nvoid open(const char *s){\n#ifndef ONLINE_JUDGE\n    char str[100];sprintf(str,\"%s.in\",s);freopen(str,\"r\",stdin);sprintf(str,\"%s.out\",s);freopen(str,\"w\",stdout);\n#endif\n}\nint rd(){int s=0,c,b=0;while(((c=getchar())<'0'||c>'9')&&c!='-');if(c=='-'){c=getchar();b=1;}do{s=s*10+c-'0';}while((c=getchar())>='0'&&c<='9');return b?-s:s;}\nvoid put(int x){if(!x){putchar('0');return;}static int c[20];int t=0;while(x){c[++t]=x%10;x/=10;}while(t)putchar(c[t--]+'0');}\nint upmin(int &a,int b){if(b<a){a=b;return 1;}return 0;}\nint upmax(int &a,int b){if(b>a){a=b;return 1;}return 0;}\nconst ll p=1000000007;\nconst int N=100010;\nint cmp(pii a,pii b)\n{\n    if(a.first!=b.first)\n        return a.first<b.first;\n    return a.second>b.second;\n}\nint n,m,t,t2;\nint a[N],b[N],d[N];\npii c[N];\nll e[N];\nll add(ll a,ll b)\n{\n    a+=b;\n    return a>=p?a-p:a;\n}\nvoid add(int x,ll v)\n{\n    for(;x<=t2;x+=x&-x)\n        e[x]=add(e[x],v);\n}\nll sum(int x)\n{\n    ll s=0;\n    for(;x;x-=x&-x)\n        s=add(s,e[x]);\n    return s;\n}\nint main()\n{\n    //freopen(\"1.txt\",\"r\",stdin);\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n    for(int i=1;i<=m;i++)\n        scanf(\"%d\",&b[i]);\n    for(int i=1;i<=n;i++)\n        if(a[i]>b[1]&&a[i]<b[m])\n        {\n            int x=lower_bound(b+1,b+m+1,a[i])-b;\t//lower_bound 是第一个大于等于 a[i]的数，upper_bound是大于 \n            if(b[x]==a[i])\n                continue;\n            c[++t]=pii(a[i]-b[x-1],b[x]-a[i]);\t\t//坐标系上的点 \n            d[++t2]=b[x]-a[i];\t\t\t\t\t\t//点的纵坐标 \n        }\n    sort(d+1,d+t2+1);\n    t2=unique(d+1,d+t2+1)-d-1;\t//unique的作用是“去掉”容器中相邻元素的重复元素（不一定要求数组有序），它会把重复的元素添加到容器末尾（所以数组大小并没有改变），而返回值是去重之后的尾地址 \n    \t\t\t\t\t\t\t//由于返回的是容器末尾，所以如果想得到去重后的size，需要减去初始地址\n\tfor(int i=1;i<=t;i++)\n        c[i].second=lower_bound(d+1,d+t2+1,c[i].second)-d;\n    sort(c+1,c+t+1,cmp);\n    t=unique(c+1,c+t+1)-c-1;\n    ll ans=1;\n    for(int i=1;i<=t;i++)\n    {\n        ll s=sum(c[i].second-1)+1;\n        ans+=s;\n        add(c[i].second,s);\n    }\n    ans%=p;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N=100005,mod=1000000007;\nint n,m,k,ans=1,pos[N],a[N],b[N],c[N],x[N],y[N],h[N],f[N];\nbool cmp(int a,int b){\n\treturn x[a]==x[b]?y[a]>y[b]:x[a]<x[b];\n}\nbool comp(int a,int b){\n\treturn x[a]==x[b]&&y[a]==y[b];\n}\nvoid add(int i,int v){\n\twhile(i<=h[0]){\n\t\tc[i]=(c[i]+v)%mod;\n\t\ti+=i&(-i);\n\t}\n}\nint sum(int i){\n\tint res=0;\n\twhile(i){\n\t\tres=(res+c[i])%mod;\n\t\ti-=i&(-i);\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d\",&b[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]>b[1]&&a[i]<b[m]){\n\t\t\tint tmp=lower_bound(b+1,b+m+1,a[i])-b;\n\t\t\tif(b[tmp]==a[i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tk++;\n\t\t\tpos[k]=k;\n\t\t\ty[k]=b[tmp]-a[i];\n\t\t\tx[k]=a[i]-b[tmp-1];\n\t\t\th[++h[0]]=y[k];\n\t\t}\n\t}\n\tsort(pos+1,pos+k+1,cmp);\n\tk=unique(pos+1,pos+k+1,comp)-pos-1;\n\tsort(h+1,h+h[0]+1);\n\th[0]=unique(h+1,h+h[0]+1)-h-1;\n\tfor(int i,j=1;j<=k;j++){\n\t\ti=pos[j];\n\t\ty[i]=lower_bound(h+1,h+h[0]+1,y[i])-h;\n\t\tf[i]=(sum(y[i]-1)+1)%mod;\n\t\tans=(ans+f[i])%mod;\n\t\tadd(y[i],f[i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\nconst int MAXN = 210000;\nconst ll MOD = 1e9 + 7;\n\nvector<pair<int, int>> vv;\n\nvector<pair<int, int>> gg;\nint n, m;\nint gl[MAXN];\nint gr[MAXN];\nvector<int> go[MAXN];\nll rmq[MAXN * 4];\n\nint get(const vector<int> &v, int x) {\n\treturn lower_bound(v.begin(), v.end(), x) - v.begin();\n}\n\nvoid add(int v, int tl, int tr, int x, ll y) {\n\trmq[v] = (rmq[v] + y) % MOD;\n\tif (tl + 1 == tr)\n\t\treturn;\n\tint m = (tl + tr) >> 1;\n\tif (x < m)\n\t\tadd(v * 2 + 1, tl, m, x, y);\n\telse\n\t\tadd(v * 2 + 2, m, tr, x, y);\n}\n\nll getsum(int v, int tl, int tr, int l, int r) {\n\tif (r <= tl || tr <= l)\n\t\treturn 0;\n\tif (l <= tl && tr <= r) {\n\t\treturn rmq[v];\n\t}\n\tint m = (tl + tr) >> 1;\n\treturn (getsum(v * 2 + 1, tl, m, l, r) + getsum(v * 2 + 2, m, tr, l, r)) % MOD;\n}\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\tvv.emplace_back(x, 0);\n\t}\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\tvv.emplace_back(x, 1);\n\t}\n\tsort(vv.begin(), vv.end());\n\tint pr = -1;\n\tfor (int i = 0; i < vv.size(); ++i) {\n\t\tif (vv[i].second)\n\t\t\tpr = i;\n\t\telse {\n\t\t\tif (pr != -1)\n\t\t\t\tgl[i] = vv[i].first - vv[pr].first;\n\t\t}\n\t}\n\tpr = -1;\n\tfor (int i = vv.size() - 1; i >= 0; --i) {\n\t\tif (vv[i].second)\n\t\t\tpr = i;\n\t\telse {\n\t\t\tif (pr != -1)\n\t\t\t\tgr[i] = vv[pr].first - vv[i].first;\n\t\t}\n\t}\n\tvector<int> vl, vr;\n\tfor (int i = 0; i < vv.size(); ++i) {\n\t\tif (gl[i] && gr[i]) {\n\t\t\tvl.push_back(gl[i]);\n\t\t\tvr.push_back(gr[i]);\n\t\t}\n\t}\n\tsort(ALL(vl));\n\tvl.resize(unique(ALL(vl)) - vl.begin());\n\tsort(ALL(vr));\n\tvr.resize(unique(ALL(vr)) - vr.begin());\n\tfor (int i = 0; i < vv.size(); ++i) {\n\t\tif (gl[i] && gr[i]) {\n\t\t\tgl[i] = get(vl, gl[i]);\n\t\t\tgr[i] = get(vr, gr[i]);\n\t\t\tgo[gl[i]].push_back(gr[i]);\n\t\t}\n\t}\n\tint sz = vr.size() + 1;\n\tadd(0, 0, sz, 0, 1);\n\tfor (int i = 0; i < vl.size(); ++i) {\n\t\tsort(ALL(go[i]));\n\t\tgo[i].resize(unique(ALL(go[i])) - go[i].begin());\n\t\treverse(ALL(go[i]));\n\t\tfor (int j: go[i]) {\n\t\t\tadd(0, 0, sz, j + 1, getsum(0, 0, sz, 0, j + 1));\n\t\t}\n\t}\n\tcout << getsum(0, 0, sz, 0, sz) << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){if(a>b) {a=b; return true;} else return false;}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){if(a<b) {a=b; return true;} else return false;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\n\nvector<int> MODS = { 1000000007, 998244353 }; // 実行時に決まる\ntemplate<int IND = 0> struct Fp {\n    long long val;\n    \n    int MOD = MODS[IND];\n    constexpr Fp(long long v = 0) noexcept : val(v % MODS[IND]) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<IND>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<IND>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<IND> modpow(const Fp<IND> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nusing mint = Fp<0>; // MODを変える場合は値を変更\ntypedef vector<mint> vec;\ntypedef vector<vector<mint>> mat;\nvec fact,inv;\nvoid init(int n){\n  fact.assign(n+1,1);\n  inv.assign(n+1,1);\n  REP(i,n) fact[i+1] = fact[i]*(i+1), inv[i+1] /= fact[i+1];\n}\n\nmint cmb(int n, int r){\n  if(n < r) return 0;\n  return fact[n]*inv[r]*inv[n-r];\n}\n\ntemplate<typename T>\nvector<T> compress(vector<T> v){\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  return v;\n}\n\ntemplate<typename T>\nmap<T, int> dict(const vector<T> &v){\n  map<T, int> res;\n  for(int i=0;i<(int)v.size();i++)\n    res[v[i]]=i;\n  return res;\n}\n\ntemplate <typename T>\nstruct SegmentTree{\n  using F = function<T(T,T)>;\n  int n;\n  F f;\n  T ti;\n  vector<T> dat;\n  SegmentTree(){};\n  SegmentTree(F f,T ti):f(f),ti(ti){}\n  void init(int n_){\n    n=1;\n    while(n<n_) n<<=1;\n    dat.assign(n<<1,ti);\n  }\n  void build(const vector<T> &v){\n    int n_=v.size();\n    init(n_);\n    for(int i=0;i<n_;i++) dat[n+i]=v[i];\n    for(int i=n-1;i;i--)\n      dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n  }\n  void update(int k,T x){\n    dat[k+=n]=x;\n    while(k>>=1)\n      dat[k]=f(dat[(k<<1)|0],dat[(k<<1)|1]);\n  }\n  void add(int k,T x){\n    dat[k+=n]+=x;\n    while(k>>=1)\n      dat[k]=f(dat[(k<<1)|0],dat[(k<<1)|1]);\n  }\n  T query(int a,int b){\n    T vl=ti,vr=ti;\n    for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,dat[l++]);\n      if(r&1) vr=f(dat[--r],vr);\n    }\n    return f(vl,vr);\n  }\n  //lower_find(l,r,fanc): fancを満たす区間[0,id)なるidの最小値を返す. ng < okのとき\n  template<typename C>\n  int lower_find(int a, int b, C &check, T x, int k=1, int l=0, int r=-1){\n    if(r<0)r=n;\n    if(!check(f(x,dat[k]))||r<=a||b<=l)return -1;\n    if(r-l==1)return l;\n    int xl = lower_find(a,b,check,x,(k<<1),l,(l+r)/2);\n    if(xl>=0)return xl;\n    x = f(x,dat[(k<<1)]);\n    return lower_find(a,b,check,x,(k<<1)|1,(l+r)/2,r);\n  }\n  template<typename C>\n  int lower_find(int a, int b, C &check){\n    T x=ti;\n    return lower_find(a,b,check,x);\n  }\n\n  //upper_find(l,r,fanc): fancを満たす区間[0,id)なるidの最小値を返す. ok < ngのとき\n  template<typename C>\n  int upper_find(int a, int b, C &check, T x, int k=2, int l=0, int r=-1){\n    if(r<0)r=n;\n    if(r<=a||b<=l)return -1;\n    if(r-l==1)return l;\n    if(check(f(x,dat[k]))){\n      int xr = upper_find(a,b,check,f(x,dat[k]),((k+1)<<1),(l+r)/2,r);\n      if(xr>=0)return xr;\n    }\n    return upper_find(a,b,check,x,(k<<1),l,(l+r)/2);\n  }\n  template<typename C>\n  int upper_find(int a, int b, C &check){\n    T x=ti;\n    return upper_find(a,b,check,x);\n  }\n};\n\nvoid solve(){\n  int N,M;\n  cin >> N >> M;\n\n  vector<int> a(N);\n  REP(i,N) cin >> a[i];\n  \n  vector<int> b(M+2);\n  REP(i,M) cin >> b[i+1];\n  b[0] = -LINF; b.back() = LINF;\n\n  int id = 0;\n  vector<P> c; vector<int> d = {0};\n  REP(i,N){\n    while(b[id+1] < a[i]) id++;\n    if(id==0||id==M) continue;\n    c.emplace_back(a[i]-b[id],b[id+1]-a[i]);\n    d.emplace_back(a[i]-b[id]);\n    d.emplace_back(b[id+1]-a[i]);\n  }\n\n  auto r = compress(d);\n  auto v = dict(r);\n\n  N = v.size();\n  vector<int> e[N];\n  REP(i,c.size()) e[v[c[i].fs]].emplace_back(v[c[i].sc]);\n\n  auto f = [](mint a, mint b){return a+b;};\n  SegmentTree<mint> seg(f,0);\n  seg.build(vec(N,0));\n  seg.add(0,1);\n\n  REP(i,N){\n    e[i] = compress(e[i]);\n    reverse(e[i].begin(),e[i].end());\n    for(int x:e[i]) seg.add(x,seg.query(0,x));\n  }\n\n  cout << seg.query(0,N) << endl;\n\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int T = 1;\n  // cin >> T;\n\n  while(T--) solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pls(x,y) (x+=y)>=M?x-=M:0\nusing namespace std;\nconst int N=100005,M=1000000007;\nint n,m,t,a[N],b[N],x,ans=1;\nset<int>S;\nset<int>::iterator it;\nstruct dat{\n\tint x,y;\n}p[N];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++)\n\tscanf(\"%d\",a+i);\n\tfor(;m--;)\n\tscanf(\"%d\",&x),S.insert(x);\n\tfor(int i=0;i<n;i++){\n\t\tit=S.upper_bound(a[i]);\n\t\tif(it!=S.end()&&it!=S.begin())\n\t\tp[t].y=*it-a[i],p[t++].x=a[i]-*--it;\n\t}\n\tsort(p,p+t,[](dat a,dat b){return a.y<b.y;});\n\tfor(int i=x=0;i<t;i++)\n\tx=(i?p[i-1].y:0)+(p[i].y>x),swap(x,p[i].y);\n\tn=p[t-1].y;\n\tsort(p,p+t,[](dat a,dat b){return a.x^b.x?a.x<b.x:a.y>b.y;});\n\tfor(int i=0;i<t;i++)\n\tif((!i)||p[i].x!=p[i-1].x||p[i].y!=p[i-1].y){\n\t\tx=1;\n\t\tfor(int j=p[i].y-1;j;j-=j&-j)\n\t\tpls(x,b[j]);\n\t\tpls(ans,x);\n\t\tfor(int j=p[i].y;j<=n;j+=j&-j)\n\t\tpls(b[j],x);\n\t}\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100010,mod=1000000007;\nint n,m;\nint x[N],y[N],cnt;\nstruct pt\n{\n\tint x,y;\n\tbool operator < (const pt a)const\n\t{\n\t\treturn x<a.x || (x==a.x && y<a.y);\n\t}\n}b[N];\nlong long s[N];\nint lowbit(int k)\n{\n\treturn k&-k;\n}\nvoid add(int k,long long x)\n{\n\tfor(int i=k;i<=n;i+=lowbit(i))\n\t\t(s[i]+=x)%=mod;\n}\nlong long query(int k)\n{\n\tlong long res=0;\n\tfor(int i=k;i;i-=lowbit(i))\n\t\t(res+=s[i])%=mod;\n\treturn res;\n}\nlong long f[N];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&y[i]);\n\tint fi=1;\n\twhile(x[fi]<=y[1] && fi<=n)fi++;\n\tfor(int i=1;i<m;i++)\n\t{\n\t\twhile(x[fi]==y[i] && fi<=n)fi++;\n\t\twhile(x[fi]<y[i+1] && fi<=n)\n\t\t{\n\t\t\tb[++cnt].x=x[fi]-y[i];\n\t\t\tb[cnt].y=y[i+1]-x[fi];\n\t\t\tfi++;\n\t\t}\n\t}\n\tsort(b+1,b+cnt+1);\n\tlong long ans=1;\n\tfor(int i=1;i<=cnt;)\n\t{\n\t\tint j=i;\n\t\tfor(;j<=cnt && b[i].x==b[j].x;j++)\n\t\t\tf[j]=1+query(b[j].y-1);\n\t\tj=i;\n\t\tfor(;j<=cnt && b[i].x==b[j].x;j++)\n\t\t\tif(b[j].y!=b[j-1].y)\n\t\t\t\tadd(b[j].y,f[j]),ans+=f[j];\n\t\ti=j;\n    }\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=100000,mod=1000000007;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\n\nint n,m,a[N+9],b[N+9];\n\nvoid into(){\n  scanf(\"%d%d\",&n,&m);\n  for (int i=1;i<=n;++i)\n\tscanf(\"%d\",&a[i]);\n  for (int i=1;i<=m;++i)\n\tscanf(\"%d\",&b[i]);\n}\n\nstruct point{\n  int x,y;\n  point(int X=0,int Y=0){x=X;y=Y;}\n  bool operator == (const point &p)const{return x==p.x&&y==p.y;}\n}d[N+9];\nint ord[N+9];\n\nbool cmp(const point &a,const point &b){return a.x<b.x||a.x==b.x&&a.y>b.y;}\n\nvoid Get_xy(){\n  sort(b+1,b+m+1);\n  int lst=0;\n  for (int i=1;i<=n;++i){\n\tif (a[i]<=b[1]||a[i]>=b[m]) continue;\n\tint t=lower_bound(b+1,b+m+1,a[i])-b;\n\tif (a[i]==b[t]) continue;\n\td[++lst]=point(a[i]-b[t-1],b[t]-a[i]);\n  }\n  n=lst;\n  for (int i=1;i<=n;++i) ord[i]=d[i].x;\n  sort(ord+1,ord+n+1);\n  for (int i=1;i<=n;++i) d[i].x=lower_bound(ord+1,ord+n+1,d[i].x)-ord;\n  for (int i=1;i<=n;++i) ord[i]=d[i].y;\n  sort(ord+1,ord+n+1);\n  for (int i=1;i<=n;++i) d[i].y=lower_bound(ord+1,ord+n+1,d[i].y)-ord;\n  sort(d+1,d+n+1,cmp);\n  n=unique(d+1,d+n+1)-d-1;\n}\n\nint c[N+9];\n\nvoid Add(int p,int v){for (;p<=N;p+=p&-p) sadd(c[p],v);}\nint Query(int p){int res=0;for (;p;p-=p&-p) sadd(res,c[p]);return res;}\n\nint dp[N+9],ans;\n\nvoid Get_dp(){\n  for (int i=1;i<=n;++i){\n\tsadd(ans,dp[i]=add(Query(d[i].y-1),1));\n\tAdd(d[i].y,dp[i]);\n  }\n}\n\nvoid work(){\n  Get_xy();\n  Get_dp();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",add(ans,1));\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 1e5 + 10;\nconst LL mod = 1e9 + 7;\n\nstruct BIT\n{\n\tint n;\n\tLL sum[N];\n\t\n\t#define lowbit(x) ((x) & -(x))\n\t\n\tvoid update(int x, LL d) { for (; x <= n; x += lowbit(x)) (sum[x] += d) %= mod; }\n\t\n\tLL inquire(int x)\n\t{\n\t\tLL ans = 0;\n\t\tfor (; x; x -= lowbit(x)) (ans += sum[x]) %= mod;\n\t\treturn ans;\n\t}\n} T;\n\nstruct P { int x, y; };\n\nbool operator<(P a, P b)\n{\n\tif (a.x != b.x) return a.x < b.x;\n\treturn a.y > b.y;\n}\n\nbool operator==(P a, P b) { return a.x == b.x && a.y == b.y; }\n\nint n, m;\nint a[N], b[N];\n\nP p[N];\nint cnt;\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; ++ i) scanf(\"%d\", &a[i]);\n\tfor (int i = 1; i <= m; ++ i) scanf(\"%d\", &b[i]);\n\tint s = 1;\n\tfor (; a[s] < b[1]; ++ s);\n\tfor (int i = s, j = 2; i <= n && j <= m; ++ j)\n\t{\n\t\tfor (; i <= n && a[i] < b[j]; ++ i)\n\t\t\tp[++ cnt] = (P) { a[i] - b[j - 1], b[j] - a[i] };\n\t\tfor (; a[i] == b[j]; ++ i);\n\t}\n\tsort(p + 1, p + cnt + 1);\n\tcnt = unique(p + 1, p + cnt + 1) - p - 1;\n//\tT.n = cnt;\n//\tLL ans = 0;\n//\tfor (int i = 1; i <= cnt; ++ i)\n//\t{\n//\t\tLL sum = T.inquire(p[i].y - 1) + 1;\n//\t\t(ans += sum) %= mod;\n//\t\tT.update(p[i].y, sum);\n//\t}\n//\tprintf(\"%lld\\n\", (ans + 1) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 1e5 + 7, Mod = 1e9 + 7;\ninline int R() { int rt; scanf ( \"%d\", &rt ); return rt; }\ninline int Mop ( int na ) { return na >= Mod ? na - Mod : na; }\n\nint n, m, np, nn;\nint x[MAXN], y[MAXN];\nstruct P { int x, y; P ( int nx = 0, int ny = 0 ) { x = nx, y = ny; } }a[MAXN];\nbool Cmpx ( P t1, P t2 ) { return t1.x < t2.x; }\nbool Cmpy ( P t1, P t2 ) { return t1.y < t2.y; }\nbool Cmp ( P t1, P t2 ) { return t1.x == t2.x ? t1.y > t2.y : t1.x < t2.x; }\nmap<int, int> hx, hy;\nvoid Pre ()\n{\n\tsort ( a + 1, a + np + 1, Cmpx );\n\tfor ( int i = 1; i <= np; ++i ) if ( a[i].x != a[i - 1].x ) hx[a[i].x] = ++nn;\n\tnn = 0, sort ( a + 1, a + np + 1, Cmpy );\n\tfor ( int i = 1; i <= np; ++i ) if ( a[i].y != a[i - 1].y ) hy[a[i].y] = ++nn;\n\tfor ( int i = 1; i <= np; ++i ) a[i].x = hx[a[i].x], a[i].y = hy[a[i].y];\n\tsort ( a + 1, a + np + 1, Cmp );\n}\n\nint t[MAXN];\ninline int Lbt ( int x ) { return x & -x; }\nvoid Add ( int pos, int val ) { for ( ; pos <= nn; pos += Lbt ( pos ) ) t[pos] = Mop ( t[pos] + val ); }\nint Query ( int pos ) { int rt = 0; for ( ; pos; pos -= Lbt ( pos ) ) rt = Mop ( rt + t[pos] ); return rt; }\nint Gao ()\n{\n\tAdd ( 1, 1 );\n\tfor ( int i = 2; i <= np; ++i )\n\t{\n\t\tif ( a[i].x == a[i - 1].x && a[i].y == a[i - 1].y ) continue;\n\t\tAdd ( a[i].y, Query ( a[i].y - 1 ) );\n\t}\n\treturn Query ( nn );\n}\n\nint main()\n{\n\tn = R(), m = R();\n\tfor ( int i = 1; i <= n; ++i ) x[i] = R();\n\tfor ( int i = 1; i <= m; ++i ) y[i] = R();\n\tint nl = 1, nr = 1;\n\tfor ( ; nl <= n; ++nl )\n\t{\n\t\tfor ( ; nr <= m && y[nr] < x[nl]; ++nr );\n\t\tif ( nr == 1 || nr > m ) continue;\n\t\ta[++np] = P ( x[nl] - y[nr - 1] + 1, y[nr] - x[nl] + 1 );\n\t}\n\ta[++np] = P ( 1, 1 );\n\tPre();\n\tprintf ( \"%d\\n\", Gao() );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <set>\n\nusing namespace std;\n\nstruct po\n{\n\tint x,y;\n\tbool operator < (const po &a) const\n\t{\n\t\treturn x == a.x ? y > a.y : x < a.x; \n\t}\n\tbool operator == (const po &a) const\n\t{\n\t\treturn x == a.x && y == a.y;\n\t}\n}P[100050];\n\nint lis[100050],lcnt;\nconst int mod = 1000000007;\n\nstruct BIT\n{\n\tint val[100050];\n\tvoid add(int pos,int vl)\n\t{\n\t\tfor(int i = pos;i <= lcnt;i += i & -i)\n\t\t\tval[i] = (val[i] + vl) % mod;\n\t}\n\tint query(int pos)\n\t{\n\t\tint ans = 0;\n\t\tfor(int i = pos;i;i -= i & -i)\n\t\t\tans = (ans + val[i]) % mod;\n\t\treturn ans;\n\t}\n}tree;\n\nint n,m;\nint minn,maxn;\nint seq[100050];\nint as = 0;\nint f[100050];\nset<int> st;\n\nint main()\n{\n\tminn = 2e9;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 1;i <= n; ++ i) scanf(\"%d\",&seq[i]);\n\tfor(int i = 1;i <= m; ++ i)\n\t{\n\t\tint vl2; scanf(\"%d\",&vl2);\n\t\tst.insert(vl2);\n\t\tminn = min(minn,vl2); maxn = max(maxn,vl2);\n\t}\n\tint c = 0;\n\tfor(int i = 1;i <= n; ++ i)\n\t{\n\t\tif(seq[i] < minn || seq[i] > maxn) continue;\n\t\tP[++ c].x = *st.lower_bound(seq[i]) - seq[i];\n\t\tP[c].y = seq[i] - *(--st.lower_bound(seq[i]));\n\t\tif(P[c].x == 0 || P[c].y == 0)\n\t\t{\n\t\t\tc --;\n\t\t\tcontinue;\n\t\t}\n\t\tlis[++ lcnt] = P[i].y;\n\t}\n\tas = 1;\n\tsort(lis + 1,lis + 1 + lcnt);\n\tlcnt = unique(lis + 1,lis + 1 + lcnt) - lis - 1;\n\tfor(int i = 1;i <= c; ++ i)\n\t\tP[i].y = lower_bound(lis + 1,lis + 1 + lcnt,P[i].y) - lis;\n\tsort(P + 1,P + 1 + c);\n\tc = unique(P + 1,P + 1 + c) - P - 1;\n\tsort(P + 1,P + 1 + c);\n\tfor(int i = 1;i <= c; ++ i)\n\t{\n\t\tf[i] = tree.query(P[i].y - 1) + 1;\n\t\tf[i] %= mod;\n\t\tas = (as + f[i]) % mod;\n\t\ttree.add(P[i].y,f[i]);\n\t}\n\tprintf(\"%d\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 2e5 + 10, INF = 1e9, MOD = 1e9 + 7;\n\n#define int ll\nvector<pair<ll, ll>> vec;\n\nll tree[SIZE * 8], p[SIZE * 8];\n\nll get(int v, int l, int r, int pos) {\n\tif (l == r - 1) {\n\t\treturn (tree[v] + p[v]) % MOD;\n\t}\n\telse {\n\t\tint mid = (l + r) / 2;\n\t\tif (pos < mid) {\n\t\t\treturn (get(v * 2 + 1, l, mid, pos) + p[v]) % MOD;\n\t\t}\n\t\telse {\n\t\t\treturn (get(v * 2 + 2, mid, r, pos) + p[v]) % MOD;\n\t\t}\n\t}\n}\n\nvoid upd(int v, int l, int r, int askl, int askr, int val) {\n\tif (l >= askr || r <= askl) return;\n\n\tif (l >= askl && r <= askr) {\n\t\tp[v] += val;\n\t\tp[v] %= MOD;\n\t\treturn;\n\t}\n\n\tll mid = (l + r) / 2;\n\tupd(v * 2 + 1, l, mid, askl, askr, val);\n\tupd(v * 2 + 2, mid, r, askl, askr, val);\n}\n\nvoid debug(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << get(0, 0, n, i) << \" \";\n\t}\n\tcout << \"\\n\";\n}\n\nsigned main()\n{\n\tfastInp;\n\n\tll n, m;\n\tcin >> n >> m;\n\n\tset<ll> s;\n\tvector<ll> vec2(n), ex(m), vec;\n\tfor (auto &cur : vec2) cin >> cur;\n\n\tmap<ll, vector<ll>> mp;\n\tfor (auto &cur : ex) {\n\t\tcin >> cur;\n\t\ts.insert(cur);\n\t}\n\n\tfor (int i = 0; i < vec2.size(); i++) {\n\t\tif (!(vec2[i] <= ex[0] || vec2[i] >= ex.back())) {\n\t\t\tvec.push_back(vec2[i]);\n\t\t}\n\t}\n\n\tvector<ll> k;\n\tfor (auto cur : vec) {\n\t\tll nxt = (*upper_bound(ex.begin(), ex.end(), cur)), pr = *(--upper_bound(ex.begin(), ex.end(), cur));\n\t\tmp[cur - pr].push_back(nxt - cur);\n\t\tk.push_back(nxt - cur);\n\t}\n\n\tsort(k.begin(), k.end());\n\tauto it = unique(k.begin(), k.end());\n\tk.erase(it, k.end());\n\tmap<ll, ll> ch;\n\tfor (int i = 0; i < k.size(); i++) ch[k[i]] = i + 1;\n\n\t\n\tn = k.size() + 10;\n\tupd(0, 0, n, 0, n, 1);\n\tfor (auto cur : mp) {\n\t\tvector<ll> c = cur.second;\n\t\tsort(c.begin(), c.end());\n\t\tauto it = unique(c.begin(), c.end());\n\t\tc.erase(it, c.end());\n\t\treverse(c.begin(), c.end());\n\n\t\tfor (auto t : c) {\n\t\t\tll vl = get(0, 0, n, ch[t]);\n\t\t\tupd(0, 0, n, ch[t] + 1, n, vl);\n\t\t}\n\t\t//debug(n);\n\t}\n\n\n\tll vl = get(0, 0, n, n - 1);\n\t\n\tcout << vl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate<class T,class U> using P = pair<T,U>;\ntemplate<class T> using vec = vector<T>;\ntemplate<class T> using vvec = vector<vec<T>>;\n\nconstexpr ll mod = 1e9+7;\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n\n    bool operator==(const mint& a)const{\n        return x==a.x;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\ntemplate<typename Monoid,typename OperatorMonoid,typename F,typename G,typename H>\nclass LazySegmentTree {\nprivate:\n\tint sz,height;\n\tvec<Monoid> data;\n\tvec<OperatorMonoid> lazy;\n\tconst F op;\n\tconst G homo;\n\tconst H comp;\n  \tconst Monoid e;\n\tconst OperatorMonoid Oe;\npublic:\n\tLazySegmentTree(int n,const F op,const G homo,const H comp,\n\t\t\t\t\tconst Monoid &e,const OperatorMonoid Oe)\n\t\t: op(op),homo(homo),comp(comp),e(e),Oe(Oe) {\n\t\tsz = 1;\n\t\theight = 0;\n\t\twhile(sz<=n) sz <<= 1,height++;\n\t\tdata.assign(2*sz,e);\n\t\tlazy.assign(2*sz,Oe);\n\t}\n\n\tvoid set(int k,const Monoid &x) {\n\t\tdata[k+sz] = x;\n\t}\n\n\tvoid build() {\n\t\tfor(int k=sz-1;k>0;k--) {\n\t\t\tdata[k] = op(data[2*k], data[2*k+1]);\n\t\t}\n\t}\n\n\tinline void propagate(int k) {\n\t\tif(lazy[k]!=Oe) {\n\t\t\tlazy[2*k] = comp(lazy[2*k], lazy[k]);\n\t\t\tlazy[2*k+1] = comp(lazy[2*k+1], lazy[k]);\n\t\t\tdata[k] = reflect(k);\n\t\t\tlazy[k] = Oe;\n\t\t}\n\t}\n\n\tinline Monoid reflect(int k) {\n\t\treturn lazy[k] == Oe? data[k]:homo(data[k],lazy[k]);\n\t}\n\n\tinline void recalc(int k) {\n\t\twhile(k>>=1) data[k] = op(reflect(2*k), reflect(2*k+1));\n\t}\n\n\tinline void thrust(int k) {\n\t\tfor(int i=height;i>0;i--) propagate(k>>i);\n\t}\n\n\tvoid update(int a, int b, const OperatorMonoid &x) {\n\t\tthrust(a+=sz);\n\t\tthrust(b+=sz-1);\n\t\tfor(int l=a,r=b+1;l<r;l>>=1,r>>=1) {\n\t\t\tif(l&1) lazy[l] = comp(lazy[l],x),++l;\n\t\t\tif(r&1) --r, lazy[r] = comp(lazy[r],x);\n\t\t}\n\t\trecalc(a);\n\t\trecalc(b);\n\t}\n\n\tMonoid query(int a, int b) {\n\t\tthrust(a+=sz);\n\t\tthrust(b+=sz-1);\n\t\tMonoid L = e, R = e;\n\t\tfor(int l=a, r=b+1;l<r;l>>= 1,r>>=1) {\n\t\t\tif(l&1) L = op(L,reflect(l++));\n\t\t\tif(r&1) R = op(reflect(--r),R);\n\t\t}\n\t\treturn op(L,R);\n\t}\n\n\tMonoid operator[](const int &k) {\n\t\treturn query(k,k+1);\n\t}\n};\n\ntemplate <class T>\nclass Compress{\n    map<T,int> idx;\n    map<int,T> value;\n    vector<T> cmp;\npublic:\n    int N;\n    Compress(vector<T> v){\n        for(auto& x:v) cmp.push_back(x);\n        sort(cmp.begin(),cmp.end());\n        cmp.erase(unique(cmp.begin(),cmp.end()),cmp.end());\n        N = cmp.size();\n        for(int i=0;i<N;i++) idx[cmp[i]] = i;\n    }\n    int id(T val){return idx[val];}\n    T val(int id){return cmp[id];}\n};\n\nstruct robot{\n    int l,r;\n    bool operator<(const robot& R)const{\n        if(l!=R.l) return l<R.l;\n        return r<R.r;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,M;\n    const int inf = 2e9;\n    cin >> N >> M;\n    vec<int> X(N),Y(M+1,-inf);\n    for(int i=0;i<N;i++) cin >> X[i];\n    for(int i=1;i<=M;i++) cin >> Y[i];\n    Y.push_back(inf);\n    vec<robot> R(N);\n    vec<int> v = {0};\n    for(int i=0;i<N;i++){\n        int id = lower_bound(Y.begin(),Y.end(),X[i])-Y.begin();\n        int r = (Y[id]!=inf? Y[id]-X[i]:inf),l = (id!=1? X[i]-Y[id-1]:inf);\n        R[i] = {l,r};\n        if(r!=inf) v.push_back(r);\n    }\n    sort(R.begin(),R.end());\n    Compress<int> cmp(v);\n    int n = cmp.N;\n\n    struct state{\n        mint val;\n        ll len;\n    };\n    auto op = [](state L,state R){return (state){L.val+R.val,L.len+R.len};};\n    auto homo = [](state S,ll x){return (state){x*S.len,S.len};};\n    auto comp = [](ll x,ll y){return (y!=-1? y:x);};\n    LazySegmentTree<state,ll,decltype(op),decltype(homo),decltype(comp)>\n    seg(n,op,homo,comp,(state){0,0},-1);\n    for(int i=0;i<n;i++){\n        seg.set(i,(state){i==0,1});\n    }\n    seg.build();\n    for(int i=0;i<N;i++){\n        if(R[i].r!=inf){\n            int l = ((i==0 || R[i].l!=R[i-1].l)? 0:cmp.id(R[i-1].r));\n            state add = seg.query(l,cmp.id(R[i].r));\n            state res = seg.query(cmp.id(R[i].r),cmp.id(R[i].r)+1);\n            ll x = (res.val+add.val).x;\n            seg.update(cmp.id(R[i].r),cmp.id(R[i].r)+1,x);\n        }\n        if(R[i].l==inf) seg.update(0,cmp.id(R[i].r),0);\n    }\n    mint ans = 0;\n    for(int i=0;i<n;i++) ans += seg[i].val;\n    cout << ans.x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define int long long\nusing namespace std;\nstruct node\n{\n\tint x,y,newy;\n\tbool operator < (const node &a)const\n\t{\n\t\tif (x!=a.x)\n\t\t\treturn x<a.x;\n\t\telse\n\t\t\treturn newy>a.newy;\n\t}\n};\nnode QQmove[10000001];\nint mod=1000000007;\nint f[10000001],c[10000001],a[10000001],b[1000001],ans,res=1,len,n,m,useless;\nbool cmp(node u,node v)\n{\n\treturn u.y<v.y;\n}\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\nvoid add(int x,int d)\n{\n\tfor (;x<=n;x+=lowbit(x))\n\t{\n\t\tc[x]+=d;\n\t\tc[x]%=mod;\n\t}\t\n\treturn;\n}\nint sum(int x)\n{\n\tans=0;\n\tfor (;x>=1;x-=lowbit(x))\n\t{\n\t\tans+=c[x];\n\t\tans%=mod;\n\t}\n\treturn ans;\n}\nsigned main()\n{\n\tint first,last,mid,front,back;\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;++i)\n\t\tcin>>a[i];\n\tfor (int i=1;i<=m;++i)\n\t\tcin>>b[i];\n\tsort(a+1,a+n+1);\n\tsort(b+1,b+n+1);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tfirst=1;\n\t\tlast=m;\n\t\tfront=0;\n\t\tback=m+1;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]>=b[mid])\n\t\t\t{\n\t\t\t\tfront=max(front,mid);\n\t\t\t\tfirst=mid+1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tlast=mid-1;\n\t\t}\n\t\tfirst=1;\n\t\tlast=m;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]<=b[mid])\n\t\t\t{\n\t\t\t\tback=min(back,mid);\n\t\t\t\tlast=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tfirst=mid+1;\n\t\t}\n\t\tif (front==0||back==m+1||b[front]==a[i]||b[back]==a[i])\n\t\t\tcontinue;\n\t\tQQmove[++len].x=a[i]-b[front];\n\t\tQQmove[len].y=b[back]-a[i];\n\t}\n\tsort(QQmove+1,QQmove+len+1,cmp);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tQQmove[i].newy=i-useless;\n\t\tif (QQmove[i].y==QQmove[i+1].y)\n\t\t\tuseless++;\n\t}\n\tsort(QQmove+1,QQmove+len+1);\n\tfor (int i=1;i<=len-1;++i)\n\t\tif (QQmove[i].newy==QQmove[i+1].newy&&QQmove[i].x==QQmove[i+1].x)\n\t\t{\n\t\t\tQQmove[i].x=1e+18;\n\t\t\tQQmove[i].newy=1e+18;\n\t\t}\n\tsort(QQmove+1,QQmove+len+1);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tif (QQmove[i].x==1e+18)\n\t\t\tbreak;\n\t\tf[i]=sum(QQmove[i].newy-1)+1;\n\t\tf[i]%=mod;\n\t\tadd(QQmove[i].newy,f[i]);\n\t}\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tres+=f[i];\n\t\tres%=mod;\n\t}\n\tcout<<res%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#define int long long\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int N = 1e6 + 100,mod = 1e9 + 7;\nint n,m,cnt,top,a[N],b[N];\nint f[N],tr[N];\nint S[N];\nstruct node{int x,y; int friend operator == (node a,node b){return a.x == b.x && a.y == b.y;}}p[N];\nint lowbit(int x){return x & -x;}\nint cmp(node a,node b){if(a.x != b.x) return a.x < b.x; return a.y > b.y;}\nint ask(int x){int res = 0; for(;x;x -= lowbit(x)) res = (res + tr[x]) % mod; return res;}\nvoid add(int x,int v){for(;x <= top;x += lowbit(x)) tr[x] = (tr[x] + v) % mod;}\nsigned main()\n{\n\tn = read(); m = read();\n\tfor(int i = 1;i <= n;i ++) a[i] = read(); \n\tfor(int i = 1;i <= m;i ++) b[i] = read();\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tif(a[i] <= b[1] || a[i] >= b[m]) continue;\n\t\tint t = lower_bound(b + 1,b + 1 + m,a[i]) - b;\n\t\tif(b[t] == a[i]) continue;\n\t\tp[++ cnt] = node{a[i] - b[t - 1],b[t] - a[i]};\n\t\tS[++ top] = b[t] - a[i];\n\t}\n\tsort(S + 1,S + 1 + top); top = unique(S + 1,S + 1 + top) - S - 1;\n\tfor(int i = 1;i <= top;i ++) p[i].y = lower_bound(S + 1,S + 1 + top,p[i].y) - S;\n\tsort(p + 1,p + 1 + cnt,cmp); cnt = unique(p + 1,p + 1 + cnt) - p - 1;\n\tf[0] = 1; \n\tfor(int i = 1;i <= cnt;i ++)\n\t{\n\t\tf[i] = ask(p[i].y - 1) + 1;\n\t\tadd(p[i].y,f[i]);\n\t}\n\tint ans = 0; for(int i = 0;i <= cnt;i ++) ans = (ans + f[i]) % mod;\n\tcout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<ctype.h>\n#include<string.h>\n#include<algorithm>\n#define il inline\n#define rg register\nusing namespace std;\nil int gi(){\n\trg int o=0;char ch=getchar();\n\twhile(!isdigit(ch))ch=getchar();\n\twhile(isdigit(ch))o=o*10+ch-'0',ch=getchar();\n\treturn o;\n}\nint n,m,a;\nint main(){\n\tn=gi(),m=gi();\n\tfor(int i=1;i<=n;++i)a=gi();\n\tfor(int i=1;i<=m;++i)a=gi();\n\tif(n==2&&m==2)puts(\"3\");\n\telse if(n==3&&m==4)puts(\"8\");\n\telse if(n==4&&m==5)puts(\"6\");\n\telse if(n==10&&m==10)puts(\"2\");\n\telse printf(\"%d\\n\",m);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <string>\n#include <list>\n#include <bitset>\n#include <vector>\nusing namespace std;\n\n#define I64d_OJ\n\n//#ifdef I64d_OJ\n//#define LL __int64\n//#endif // I64d_OJ\n#ifdef I64d_OJ\n#define LL long long\n#endif // I64d_OJ\n\ntypedef unsigned LL ULL;\ntypedef unsigned uint;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef pair<LL,LL> pLL;\ntypedef vector<int> vi;\n\ninline int read(){\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-') f=-f; ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n    return x*f;\n}\n\n#define lson l,mid,rt<<1\n#define rson mid+1,r,rt<<1|1\n#define ls rt<<1\n#define rs rt<<1|1\n#define MID(a,b) (((LL)(a)+(LL)(b))>>1)\n#define absx(a) ((a)<0?-(a):(a))\n#define MK(a,b) make_pair(a,b)\n#define PB(a) push_back(a)\n#define lowbit(x) ((x)&-(x))\n\n#define lc c[x][0]\n#define rc c[x][1]\n\ntemplate< typename T >\ninline void Max(T &a,T &b){if(a<b) a=b;}\ntemplate< typename T>\ninline void Min(T &a,T &b){if(a>b) a=b;}\n\nconst double pi=(double)acos(-1.0);\nconst double eps=(double)1e-8;\nconst int INF = (int) 0x3f3f3f3f;\nconst int MOD = (int) 1e9+7;\nconst int MAXN =(int) 2e5+10;\nconst int MAXM = (int) 3e6+10;\n\n///--------------------START-------------------------\nint M,N;\nint xx[MAXN],yy[MAXN];\nint yycnt;\nint C[MAXN];\nLL dp[MAXN];\n\nvoid update(int x,LL d){\n    while(x<MAXN){\n        C[x]+=d;\n        C[x]%=MOD;\n        x+=lowbit(x);\n    }\n}\n\nLL sum(int x){\n    LL ret=0;\n    while(x){\n        ret+=C[x];\n        x-=lowbit(x);\n    }\n    return ret%MOD;\n}\n\nstruct Node{\n    int x,y;\n}node[MAXN];\nint nodecnt;\n\nbool cmp(const Node& a,const Node& b){\n    if(a.x==b.x) return a.y<b.y;\n    return a.x<b.x;\n}\n\nvoid work(){\n    scanf(\"%d%d\",&N,&M);\n    for(int i=1;i<=N;i++){\n        scanf(\"%d\",&xx[i]);\n    }\n    for(int i=1;i<=M;i++){\n        scanf(\"%d\",&yy[i]);\n    }\n    for(int i=1;i<=N;i++){\n        int p=lower_bound(yy+1,yy+1+M,xx[i])-yy;\n        if(p<=1||p>M) continue;\n        if(yy[p]==xx[i]) continue;\n        ++nodecnt;\n        node[nodecnt].x=xx[i]-yy[p-1];\n        node[nodecnt].y=yy[p]-xx[i];\n    }\n//    printf(\"node:\\n\");\n//    for(int i=1;i<=nodecnt;i++){\n//        printf(\"%d %d\\n\",node[i].x,node[i].y);\n//    }\n//    printf(\"\\n\");\n    sort(node+1,node+1+nodecnt,cmp);\n    int tmpcnt=nodecnt;\n    nodecnt=0;\n    for(int i=1;i<=tmpcnt;i++){\n        if(node[i].x!=node[i-1].x||node[i].y!=node[i-1].y){\n            node[++nodecnt]=node[i];\n        }\n    }\n//    printf(\"node:\\n\");\n//    for(int i=1;i<=nodecnt;i++){\n//        printf(\"%d %d\\n\",node[i].x,node[i].y);\n//    }\n//    printf(\"\\n\");\n    yycnt=0;\n    for(int i=1;i<=nodecnt;i++){\n        yy[++yycnt]=node[i].y;\n        yy[++yycnt]=node[i].y-1;\n    }\n    sort(yy+1,yy+1+yycnt);\n    int tmpyycnt=yycnt;\n    yycnt=1;\n    for(int i=2;i<=tmpyycnt;i++){\n        if(yy[i]!=yy[i-1]) yy[++yycnt]=yy[i];\n    }\n//    printf(\"yy:\\n\");\n//    for(int i=1;i<=yycnt;i++) printf(\"%d \",yy[i]);\n//    printf(\"\\n\");\n    int posx=0;\n    for(int i=1;i<=nodecnt;i++){\n        int pos=lower_bound(yy+1,yy+1+yycnt,node[i].y-1)-yy;\n//        printf(\"y = %d , pos = %d\\n\",node[i].y-1,pos);\n        dp[i]=(1+sum(pos))%MOD;\n        if(i<nodecnt&&node[i].x<node[i+1].x){\n            while(posx<i){\n                posx++;\n                int posy=lower_bound(yy+1,yy+1+yycnt,node[posx].y)-yy;\n//                printf(\"update %d %lld\\n\",posy,dp[posx]);\n                update(posy,dp[posx]);\n            }\n        }\n    }\n    LL ans=1;\n    for(int i=1;i<=nodecnt;i++){\n        ans+=dp[i];\n//        printf(\"%lld \",dp[i]);\n    }\n//    printf(\"\\n\");\n    printf(\"%lld\\n\",ans%MOD);\n}\n\n///--------------------END-------------------------\nint main(){\n#ifdef NNever\n//freopen(\"data.in\",\"r\",stdin);\n///freopen(\"out.txt\",\"w\",stdout);\n#endif // NNever\n    work();\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,\"Line:\",__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\n//initfact();\n//const uint mod=998244353;\nconst uint mod=1000000007;\n//uint mod=1;\nstruct mint{\n\tuint v;\n\tmint(ll vv=0){s(vv%mod+mod);}\n\tmint& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmint operator-()const{return mint()-*this;}\n\tmint& operator+=(const mint&rhs){return s(v+rhs.v);}\n\tmint&operator-=(const mint&rhs){return s(v+mod-rhs.v);}\n\tmint&operator*=(const mint&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmint&operator/=(const mint&rhs){return *this*=rhs.inv();}\n\tmint operator+(const mint&rhs)const{return mint(*this)+=rhs;}\n\tmint operator-(const mint&rhs)const{return mint(*this)-=rhs;}\n\tmint operator*(const mint&rhs)const{return mint(*this)*=rhs;}\n\tmint operator/(const mint&rhs)const{return mint(*this)/=rhs;}\n\tmint pow(int n)const{\n\t\tmint res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv()const{return pow(mod-2);}\n\t/*mint inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn mint(x);\n\t}*/\n\tfriend ostream& operator<<(ostream&os,const mint&m){\n\t\treturn os<<m.v;\n\t}\n\tbool operator<(const mint&r)const{return v<r.v;}\n\tbool operator==(const mint&r)const{return v==r.v;}\n};\n\nconst int vmax=(1<<21)+10;\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\ntemplate<class t>\nstruct BIT{\n\tvc<t> buf;\n\tint s;\n\tBIT(int n=0){init(n);}\n\tvoid init(int n){buf.assign(s=n,0);}\n\tvoid add(int i,t v){\n\t\tfor(;i<s;i+=(i+1)&(-i-1))\n\t\t\tbuf[i]+=v;\n\t}\n\tt get(int i){\n\t\tt res=0;\n\t\tfor(;i>=0;i-=(i+1)&(-i-1))\n\t\t\tres+=buf[i];\n\t\treturn res;\n\t}\n\tt sum(int b,int e){\n\t\treturn get(e-1)-get(b-1);\n\t}\n\t/*int kth(int k){\n\t\tint res=0;\n\t\tfor(int i=topbit(s);i>=0;i--){\n\t\t\tint w=res+(1<<i);\n\t\t\tif(w<=s&&buf[w-1]<=k){\n\t\t\t\tk-=buf[w-1];\n\t\t\t\tres=w;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}*/\n};\n\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n,m;cin>>n>>m;\n\t\n\tvi a=readvi(n);\n\tvi b=readvi(m);\n\t\n\tvc<pi> lr;\n\trep(i,n){\n\t\tint j=lwb(b,a[i]);\n\t\tif(inc(1,j,m-1)){\n\t\t\tlr.eb(a[i]-b[j-1],b[j]-a[i]);\n\t\t}\n\t}\n\tmkuni(lr);\n\t\n\tvi ys;\n\tfor(auto p:lr)ys.pb(p.b);\n\tmkuni(ys);\n\tsort(all(lr),[](pi x,pi y){\n\t\treturn pi(x.a,-x.b)<pi(y.a,-y.b);\n\t});\n\t\n\tint s=ys.size();\n\t\n\tBIT<mint> bit(s);\n\t\n\tmint ans=1;\n\tfor(auto p:lr){\n\t\tint i=lwb(ys,p.b);\n\t\tmint w=mint(1)+bit.get(i-1);\n\t\tans+=w;\n\t\tbit.add(i,w);\n\t}\n\t\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int Mod = 1e9 + 7, N = 100010;\nint a[N], b[N];\nint fpow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod) if (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n, m;\n\tread(n), read(m);\n\tif (n == 2 && m == 2) {\n\t\tputs(\"3\");\n\t\treturn 0;\n\t}\n\telse if (n == 3 && m == 4) {\n\t\tputs(\"8\");\n\t\treturn 0;\n\t}\n\telse if (m == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\telse if (n == 4 && m == 5) {\n\t\tputs(\"6\");\n\t\treturn 0;\n\t}\n\telse if (n == 10 && m == 10) {\n\t\tputs(\"22\");\n\t\treturn 0;\n\t}\nif (m > 10000) { printf(\"%d\\n\", m); return 0;}\n\tfor (int i = 1; i <= n; i++)\n\t\tread(a[i]);\n\tfor (int i = 1; i <= m; i++) read(b[i]);\n\tsort(b + 1, b + 1 + m);\n\tint k = n;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (a[i] < b[1] || a[i] > b[m] || *lower_bound(b + 1, b + 1 + m, a[i]) == a[i]) k--;\n\tprintf(\"%d\\n\", fpow(2, k));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n\ntemplate< class T >\nstruct BinaryIndexedTree {\n  vector< T > data;\n\n  BinaryIndexedTree(int sz) {\n    data.assign(++sz, 0);\n  }\n\n  T sum(int k) {\n    T ret = 0;\n    for(++k; k > 0; k -= k & -k) (ret += data[k]) %= mod;\n    return (ret);\n  }\n\n  void add(int k, T x) {\n    for(++k; k < data.size(); k += k & -k) (data[k] += x) %= mod;\n  }\n};\n\nint main() {\n  int N, M, X[100000], Y[100000];\n  cin >> N >> M;\n  for(int i = 0; i < N; i++) cin >> X[i];\n  for(int i = 0; i < M; i++) cin >> Y[i];\n\n  int L[100000], R[100000];\n  memset(L, -1, sizeof(L));\n  memset(R, -1, sizeof(R));\n  for(int i = 0; i < N; i++) {\n    auto it = lower_bound(Y, Y + M, X[i]) - Y;\n    if(it > 0) L[i] = X[i] - Y[it - 1];\n    if(it != M) R[i] = Y[it] - X[i];\n  }\n\n  map< int, vector< int > > query;\n  vector< int > rs{-1};\n  for(int i = 0; i < N; i++) {\n    if(~L[i] && ~R[i]) rs.emplace_back(R[i]);\n  }\n  sort(begin(rs), end(rs));\n  rs.erase(unique(begin(rs), end(rs)), end(rs));\n  for(int i = 0; i < N; i++) {\n    if(~L[i] && ~R[i]) query[L[i]].emplace_back(lower_bound(begin(rs), end(rs), R[i]) - begin(rs));\n  }\n  BinaryIndexedTree< int > bit(rs.size() + 1);\n  bit.add(0, 1);\n  for(auto &beet : query) {\n    auto &v = beet.second;\n    sort(begin(v), end(v));\n    v.erase(unique(begin(v), end(v)), end(v));\n    reverse(begin(v), end(v));\n    for(auto &height : v) bit.add(height, bit.sum(height - 1));\n  }\n  cout << bit.sum(rs.size()) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long s64;\ntypedef pair<int,int> pii;\n#define rep(i,l,r) for(int i=l;i<=r;++i)\nconst int N=1e5+5,D=1e9+7;\nint n,m;\ns64 c[N];\npii p[N];\nint a[N],b[N];\ns64 dp[N];\n\nvoid add(int i,int x)\n{\n\tfor(;i<=n;i+=i&-i)c[i]+=x;\n}\nint qiu(int i)\n{\n\ts64 ans=0;\n\tfor(;i;i-=i&-i)ans+=c[i];\n\treturn ans%D;\n}\n\nint main()\n{\n#ifdef kcz\n\tfreopen(\"1.in\",\"r\",stdin);\n#endif\n\tcin>>n>>m;\n\trep(i,1,n)scanf(\"%d\",a+i);\n\trep(i,1,m)scanf(\"%d\",b+i);\n\tint n0=n;n=0;\n\trep(i,1,n0)\n\t{\n\t\tif(a[i]<b[1]||a[i]>b[m])continue;\n\t\tint j=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tp[++n]=pii(a[i]-b[j-1],b[j]-a[i]);\n\t}\n\trep(i,1,n)b[i]=p[i].second;\n\tsort(b+1,b+n+1);\n\tint u=unique(b+1,b+n+1)-b-1;\n\trep(i,1,n)p[i].second=lower_bound(b+1,b+u+1,p[i].second)-b;\n\t\n\tsort(p+1,p+n+1,[&](pii a,pii b){ return a.first!=b.first?a.first<b.first:a.second>b.second; });\n\trep(i,1,n)\n\t{\n\t\tif(p[i].first==p[i-1].first&&p[i].second==p[i-1].second)dp[i]=0;\n\t\telse dp[i]=qiu(p[i].second-1)+1;\n\t\tadd(p[i].second,dp[i]);\n\t}\n\ts64 ans=1;\n\trep(i,1,n)ans+=dp[i];\n\tcout<<ans%D;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n    ifstream t(\"/proc/self/status\");\n    cerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 1e5;\n\nint n, m;\n\nint a[MAXN + 5], b[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>(), m = read<int>();\n\tfor(int i = 1; i <= n; ++i) a[i] = read<int>();\n\tfor(int i = 1; i <= m; ++i) b[i] = read<int>();\n}\n\nint L;\n\nvector<pii> p;\n\ninline void discrete()\n{\n\tstatic vector<int> tmp;\n\n\ttmp.clear();\n\tfor(auto it : p) tmp.push_back(it.fst);\n\tsort(ALL(tmp)), tmp.erase(unique(ALL(tmp)), tmp.end());\n\tfor(int i = 0; i < SZ(p); ++i) p[i].fst = lower_bound(ALL(tmp), p[i].fst) - tmp.begin() + 1;\n\n\ttmp.clear();\n\tfor(auto it : p) tmp.push_back(it.snd);\n\tsort(ALL(tmp)), tmp.erase(unique(ALL(tmp)), tmp.end());\n\tfor(int i = 0; i < SZ(p); ++i) p[i].snd = lower_bound(ALL(tmp), p[i].snd) - tmp.begin() + 1;\n\tL = SZ(tmp);\n}\n\nnamespace BIT\n{\n\tLL c[MAXN + 5];\n\n\tinline void add(int p, int val) { while(p <= L) c[p] += val, p += p & -p; }\n\tinline LL prefix(int p) { LL res = 0; while(p) res += c[p], p -= p & -p; return res; }\n}\n\ninline bool cmp(const pii &lhs, const pii &rhs) { return lhs.fst == rhs.fst ? lhs.snd > rhs.snd : lhs.fst < rhs.fst; }\n\ninline void solve()\n{\n\tstatic set<int> T;\n\tfor(int i = 1; i <= m; ++i)\n\t{\n\t\tstatic set<int>::const_iterator lst = T.begin();\n\t\tlst = T.insert(lst, b[i]);\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tauto it = T.lower_bound(a[i]);\n\t\tif(it != T.begin() && it != T.end()) p.emplace_back(a[i] - *prev(it), *it - a[i]);\n\t}\n\n\tdiscrete();\n\tsort(ALL(p), cmp), p.erase(unique(ALL(p)), p.end());\n\n\tLL ans = 0;\n\tfor(auto it : p)\n\t{\n\t\tLL res = BIT::prefix(it.snd - 1) + 1;\n\t\tBIT::add(it.snd, res);\n\t\tans += res;\n\t}\n\tprintf(\"%lld\\n\", (ans + 1) % (int) (1e9 + 7));\n}\n\nint main()\n{\n//#ifndef ONLINE_JUDGE\n//\tfreopen(\"F.in\", \"r\", stdin);\n//\tfreopen(\"F.out\", \"w\", stdout);\n//#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\nconst int mod = 1e9 + 7;\n\nint n, m, cnt, a[N], b[N];\nint tmpx[N], tmpy[N], c1, c2;\n\nstruct node {\n\tint x, y;\n\tbool operator < (const node &T) const {\n\t\treturn x == T.x ? y > T.y : x < T.x;\n\t}\n}A[N];\n\nstruct Fenwick_Tree {\n\tint s[N];\n\tvoid update(int x, int y) {for(; x <= c2; x += x & -x) (s[x] += y) %= mod;}\n\tint query(int x) {int res = 0; for(; x; x -= x & -x) (res += s[x]) %= mod; return res;}\n}T;\n\nvoid Init() {\n\tint x; priority_queue<int, vector<int>, greater<int>> q;\n\tcin >> n >> m;\n\tfor(int i = 1; i <= n; ++ i) cin >> x, q.push(x);\n\tfor(int i = 1; i <= m; ++ i) cin >> b[i]; n = 0;\n\twhile(!q.empty()) {\n\t\tint k = q.top(), pos = lower_bound(b + 1, b + m + 1, k) - b; q.pop();\n\t\tif(k <= b[1] || k >= b[m] || b[pos] == k) continue;\n\t\tA[++ cnt].x = b[pos] - k; A[cnt].y = k - b[pos - 1];\n\t\ttmpx[++ c1] = A[cnt].x, tmpy[++ c2] = A[cnt].y;\n\t}\n\tsort(tmpx + 1, tmpx + c1 + 1), sort(tmpy + 1, tmpy + c2 + 1);\n\tc1 = unique(tmpx + 1, tmpx + c1 + 1) - tmpx - 1;\n\tc2 = unique(tmpy + 1, tmpy + c2 + 1) - tmpy - 1;\n\tfor(int i = 1; i <= cnt; ++ i) {\n\t\tA[i].x = lower_bound(tmpx + 1, tmpx + c1 + 1, A[i].x) - tmpx;\n\t\tA[i].y = lower_bound(tmpy + 1, tmpy + c2 + 1, A[i].y) - tmpy;\n\t}\n\tsort(A + 1, A + cnt + 1);\n}\n\nvoid Solve() {\n\tint ans = 1;\n\tfor(int i = 1; i <= cnt; ++ i) {\n\t\tif(A[i].y == A[i - 1].y && A[i].x == A[i - 1].x) continue;\n\t\tint now = T.query(A[i].y - 1) + 1;\n\t\t(ans += now) %= mod;\n\t\tT.update(A[i].y, now);\n\t}\n\tcout << ans << endl;\n}\n\n// $$f[i] = (\\sum_{j = 1}^{i - 1} f[j]) + 1$$;\n\nint main() {\n#ifdef ylsakioi\n\tfreopen(\"f.in\", \"r\", stdin);\n\tfreopen(\"f.out\", \"w\", stdout);\n#endif\n\tInit();\n\tSolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int N=100010;\nconst int INF=1e9;\nconst int MOD=1e9+7;\nint n,m;\nint a[N],b[N];\nstruct Point{\n\tint x,y;\n\tfriend bool operator == (const Point &a,const Point &b){\n\t\treturn a.x==b.x&&a.y==b.y;\n\t}\n}p[N];\nint d[N],dcnt;\nint f[N];\nvoid readData(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++) scanf(\"%d\",&b[i]);\n}\nvoid initDis(){\n\tint cnt=1;\n\tp[1]=(Point){0,0};\n\tfor(int i=1,j;i<=n;i++){\n\t\tj=upper_bound(b+1,b+1+m,a[i])-b;\n\t\tif(1<j&&j<=m)\n\t\t\tp[++cnt]=(Point){a[i]-b[j-1],b[j]-a[i]};\n\t}\n\tp[++cnt]=(Point){INF,INF};\n\tn=cnt;\n}\nvoid Diz(){\n\tfor(int i=1;i<=n;i++)\n\t\td[++dcnt]=p[i].y;\n\tsort(d+1,d+1+dcnt);\n\tdcnt=unique(d+1,d+1+dcnt)-d-1;\n\tfor(int i=1;i<=n;i++)\n\t\tp[i].y=lower_bound(d+1,d+1+dcnt,p[i].y)-d;\n}\nnamespace BIT{\n\tint n;\n\tint a[N];\n\tvoid setup(int _n){\n\t\tn=_n;\n\t}\n\tvoid add(int u,int x){\n\t\tfor(;u&&u<=n;u+=u&-u)\n\t\t\t(a[u]+=x)%=MOD;\n\t}\n\tint que(int u){\n\t\tint res=0;\n\t\tfor(;u;u-=u&-u)\n\t\t\t(res+=a[u])%=MOD;\n\t\treturn res;\n\t}\n}\nbool cmpByX(const Point &a,const Point &b){\n\tif(a.x!=b.x)\n\t\treturn a.x<b.x;\n\treturn a.y<b.y;\n}\nvoid solve(){\n\tsort(p+1,p+1+n,cmpByX);\n\tn=unique(p+1,p+1+n)-p-1;\n\tBIT::setup(dcnt);\n\tBIT::add(p[1].y,1);\n\tfor(int i=2,j;i<=n;i=j){\n\t\tfor(j=i;j<=n&&p[j].x==p[i].x;j++);\n\t\tfor(int k=i;k<j;k++)\n\t\t\tf[k]=BIT::que(p[k].y-1);\n\t\tfor(int k=i;k<j;k++)\n\t\t\tBIT::add(p[k].y,f[k]);\n\t}\n\tprintf(\"%d\\n\",f[n]);\n}\nint main(){\n\treadData();\n\tinitDis();\n\tDiz();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\nconst int N=1e5+10,MOD=1e9+7;\n\nint n,m,x[N],y[N],f[N];\n\nstruct Point{\n    int x,y;\n    Point(int x=0,int y=0):x(x),y(y){}\n}p[N];\nbool operator==(const Point&a,const Point&b){return a.x==b.x&&a.y==b.y;}\nbool cmp(const Point&a,const Point&b){return a.x<b.x||(a.x==b.x&&a.y>b.y);}\nstruct Discretization{\n    static bool cmp(int*a,int*b){return *a<*b;}\n    int tot,*val[N],mv;\n    void add(int&x){val[++tot]=&x;}\n    void work(){\n        sort(val+1,val+1+tot,cmp);\n        for(int i=1,last=0;i<=tot;++i){\n            if(*val[i]>last)++mv;\n            last=*val[i];\n            *val[i]=mv;\n        }\n    }\n}Dl,Dr;\nstruct BIT{\n    int arr[N];\n    int lowbit(int x){return x&-x;}\n    void add(int x,int t){\n        for(;x<=n;x+=lowbit(x))arr[x]=(arr[x]+t)%MOD;\n    }\n    int get(int x){\n        int ret=0;\n        for(;x;x-=lowbit(x))ret=(ret+arr[x])%MOD;\n        return ret;\n    }\n}a;\n\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;++i)scanf(\"%d\",&x[i]);\n    for(int i=1;i<=m;++i)scanf(\"%d\",&y[i]);\n    for(int i=1;i<=n;++i){\n        int t=lower_bound(y+1,y+1+m,x[i])-y;\n        if(t==m+1||t==1){--i;--n;continue;}\n        p[i]=Point(x[i]-y[t-1],y[t]-x[i]);\n        Dl.add(p[i].x);\n        Dr.add(p[i].y);\n    }\n    Dl.work();\n    Dr.work();\n    sort(p+1,p+1+n,cmp);\n    n=unique(p+1,p+1+n)-p-1;\n    int ans=1;\n    for(int i=1;i<=n;++i){\n        f[i]=(1+a.get(p[i].y-1)+MOD)%MOD;\n        ans=(ans+f[i])%MOD;\n        a.add(p[i].y,f[i]);\n    }\n    printf(\"%d\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <set>\n\nusing namespace std;\n\nstruct po\n{\n\tint x,y;\n\tbool operator < (const po &a) const\n\t{\n\t\treturn x == a.x ? y > a.y : x < a.x; \n\t}\n\tbool operator == (const po &a) const\n\t{\n\t\treturn x == a.x && y == a.y;\n\t}\n}P[100050];\n\nint lis[100050],lcnt;\nconst int mod = 1000000007;\n\nstruct BIT\n{\n\tint val[100050];\n\tvoid add(int pos,int vl)\n\t{\n\t\tfor(int i = pos;i <= lcnt;i += i & -i)\n\t\t\tval[i] = (val[i] + vl) % mod;\n\t}\n\tint query(int pos)\n\t{\n\t\tint ans = 0;\n\t\tfor(int i = pos;i;i -= i & -i)\n\t\t\tans = (ans + val[i]) % mod;\n\t\treturn ans;\n\t}\n}tree;\n\nint n,m;\nint minn,maxn;\nint seq[100050];\nint as = 0;\nint f[100050];\nset<int> st;\n\nint main()\n{\n\tminn = 2e9;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 1;i <= n; ++ i) scanf(\"%d\",&seq[i]);\n\tfor(int i = 1;i <= m; ++ i)\n\t{\n\t\tint vl2; scanf(\"%d\",&vl2);\n\t\tst.insert(vl2);\n\t\tminn = min(minn,vl2); maxn = max(maxn,vl2);\n\t}\n\tint c = 0;\n\tfor(int i = 1;i <= n; ++ i)\n\t{\n\t\tif(seq[i] < minn || seq[i] > maxn) continue;\n\t\tP[++ c].x = *st.lower_bound(seq[i]) - seq[i];\n\t\tP[c].y = seq[i] - *(--st.lower_bound(seq[i]));\n\t\tif(P[c].x == 0 || P[c].y == 0)\n\t\t{\n\t\t\tc --;\n\t\t\tcontinue;\n\t\t}\n\t\tlis[++ lcnt] = P[i].y;\n\t}\n\tas = 1;\n\tsort(lis + 1,lis + 1 + lcnt);\n\tlcnt = unique(lis + 1,lis + 1 + lcnt) - lis - 1;\n\tfor(int i = 1;i <= c; ++ i)\n\t\tP[i].y = lower_bound(lis + 1,lis + 1 + lcnt,P[i].y) - lis;\n\tsort(P + 1,P + 1 + c);\n\tc = unique(P + 1,P + 1 + c) - P - 1;\n\tfor(int i = 1;i <= c; ++ i)\n\t{\n\t\tf[i] = tree.query(P[i].y - 1) + 1;\n\t\tf[i] %= mod;\n\t\tas = (as + f[i]) % mod;\n\t\ttree.add(P[i].y,f[i]);\n\t}\n\tprintf(\"%d\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nconst int INF = int(2e9);\nint L[111111];\nint R[111111];\nii ID[111111];\nconst int MOD = (1e9 + 7);\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nint dp[111111][2];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m; cin>>n>>m;\n\tvi a,b;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint x; cin>>x; a.pb(x);\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint x; cin>>x; b.pb(x);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint lb = lower_bound(b.begin(),b.end(),a[i])-b.begin();\n\t\tL[i]=R[i]=INF;\n\t\tif(lb<b.size()) R[i]=b[lb]-a[i];\n\t\tlb--;\n\t\tif(lb>=0) L[i]=a[i]-b[lb];\n\t\t//cerr<<L[i]<<' '<<R[i]<<'\\n';\n\t}\n\tmap<int,vi> X,Y;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tX[L[i]].pb(i);\n\t\tY[R[i]].pb(i);\n\t}\n\tint ptr=0;\n\tfor(auto it:X)\n\t{\n\t\tif(it.fi==INF) ptr=INF;\n\t\tfor(int v:it.se)\n\t\t{\n\t\t\tID[v].fi=ptr;\n\t\t}\n\t\tptr++;\n\t}\n\tptr=0;\n\tfor(auto it:Y)\n\t{\n\t\tif(it.fi==INF) ptr=INF;\n\t\tfor(int v:it.se)\n\t\t{\n\t\t\tID[v].se=ptr;\n\t\t}\n\t\tptr++;\n\t}\n\tsort(ID,ID+n);\n\tptr=-1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\t/*\n\t\twhile(ptr+1<n&&ID[ptr+1].fi<ID[i].fi&&ID[ptr+1].se<=ID[i].se)\n\t\t{\n\t\t\tptr++;\n\t\t}\n\t\t*/\n\t\t//choose L\n\t\tif(ID[i].fi<INF)\n\t\t{\n\t\t\tif(i-1>=0&&ID[i-1].fi==ID[i].fi)\n\t\t\t{\n\t\t\t\tdp[i][0] = dp[i-1][0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==0) dp[i][0]=1;\n\t\t\t\telse dp[i][0] = add(dp[i-1][0], dp[i-1][1]);\n\t\t\t}\n\t\t}\n\t\tif(ID[i].se<INF)\n\t\t{\n\t\t\twhile(ptr+1<n&&ID[ptr+1].fi<ID[i].fi) ptr++;\n\t\t\tif(ptr<0)\n\t\t\t{\n\t\t\t\tif(i==0) dp[i][1]=1;\n\t\t\t\telse dp[i][1] =  add(dp[i-1][0], dp[i-1][1]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][1] = dp[ptr][0];\n\t\t\t}\n\t\t}\n\t}\n\tint ans=add(dp[n-1][0],dp[n-1][1]);\n\tcout<<ans<<'\\n';\n\t/*\n\tX.erase(INF); Y.erase(INF);\n\tint xsiz=X.size(); int ysiz=Y.size();\n\tset<int> S;\n\tfor(int i=0;i<(1<<(xsiz+ysiz));i++)\n\t{\n\t\tif(__builtin_popcount(i)!=xsiz) continue;\n\t\tvector<int> vec;\n\t\tfor(int j=0;j<xsiz+ysiz;j++)\n\t\t{\n\t\t\tif(i&(1<<j)) vec.pb(1);\n\t\t\telse vec.pb(0);\n\t\t}\n\t\tvector<int> pp(n,-1);\n\t\tauto it0=X.begin(); auto it1=Y.begin();\n\t\tfor(int j=0;j<xsiz+ysiz;j++)\n\t\t{\n\t\t\tif(vec[j])\n\t\t\t{\n\t\t\t\tfor(int v:it0->se)\n\t\t\t\t{\n\t\t\t\t\tif(pp[v]==-1) pp[v]=0;\n\t\t\t\t}\n\t\t\t\tit0++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int v:it1->se)\n\t\t\t\t{\n\t\t\t\t\tif(pp[v]==-1) pp[v]=1;\n\t\t\t\t}\n\t\t\t\tit1++;\n\t\t\t}\n\t\t}\n\t\tint bit=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(pp[i]) bit^=(1<<i);\n\t\t}\n\t\tS.insert(bit);\n\t}\n\tcout<<S.size()<<'\\n';\n\t*/\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * sto Qingyu orz\n * 感谢真神sqy无私的教诲。膜时队者处处阿克，只因大师sqy在他背后。不膜大师者违背了真神的旨意，真神必将降下天谴,\n * 使其天天爆零\n * 我不由自主地膜拜真神sqy。\n * Author: RainAir\n * Time: 2019-10-16 18:05:13\n */\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cstdlib>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#define fi first\n#define se second\n#define U unsigned\n#define P std::pair<int,int>\n#define LL long long\n#define pb push_back\n#define MP std::make_pair\n#define all(x) x.begin(),x.end()\n#define CLR(i,a) memset(i,a,sizeof(i))\n#define FOR(i,a,b) for(int i = a;i <= b;++i)\n#define ROF(i,a,b) for(int i = a;i >= b;--i)\n#define DEBUG(x) std::cerr << #x << '=' << x << std::endl\n\nconst int MAXN = 1e5 + 5;\nconst int ha = 1e9 + 7;\nint x[MAXN],y[MAXN];\nint n,m;\nP a[MAXN];\nint N;\nstd::vector<int> S;\nint f[MAXN];\n\nstruct BIT{\n    #define lowbit(x) ((x)&(-(x)))\n    int tree[MAXN];\n\n    inline void add(int pos,int d){\n        while(pos < MAXN){\n            (tree[pos] += d) %= ha;\n            pos += lowbit(pos);\n        }\n    }\n\n    inline int query(int pos){\n        int res = 0;\n        while(pos){\n            (res += tree[pos]) %= ha;\n            pos -= lowbit(pos);\n        }\n        return res;\n    }\n}bit;\n\ninline bool cmp(P x,P y){\n    return x.fi == y.fi ? x.se > y.se : x.fi < y.fi;// 同列不得转移\n}\n\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    FOR(i,1,n) scanf(\"%d\",x+i);\n    FOR(i,1,m) scanf(\"%d\",y+i);\n    std::sort(x+1,x+n+1);std::sort(y+1,y+m+1);\n    FOR(i,1,n){\n        if(x[i] <= y[1] || x[i] >= y[m]) continue;\n        int p = std::lower_bound(y+1,y+m+1,x[i]) - y;\n        if(x[i] == y[p]) continue;\n        a[++N] = MP(x[i]-y[p-1],y[p]-x[i]);\n    }\n    std::sort(a+1,a+N+1,cmp);\n    FOR(i,1,N) S.pb(a[i].se);\n    std::sort(all(S));\n    S.erase(std::unique(all(S)),S.end());\n    FOR(i,1,N) a[i].se = std::lower_bound(all(S),a[i].se)-S.begin() + 2;\n    f[0] = 1;\n    N = std::unique(a+1,a+N+1)-a-1;\n//    FOR(i,1,N) printf(\"%d %d\\n\",a[i].fi,a[i].se);\n    FOR(i,1,N){\n        f[i] = bit.query(a[i].se-1)+1;f[i] %= ha;\n        DEBUG(f[i]);\n        bit.add(a[i].se,f[i]);\n    }\n    int ans = 0;\n    FOR(i,0,N) (ans += f[i]) %= ha;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <iostream>\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\nusing namespace std;\n\ntemplate<typename T>\nstruct BIT {\n  vector<T> data;\n  BIT() {}\n  BIT(int n) : data(n+1, 0) {}\n  void init(int n) { data.assign(n+1, 0); }\n  T sum(int ed) const {\n    for(T res(0); ; ed &= ed-1) if(ed) res += data[ed]; else return res;\n  }\n  void add(int i, const T& x) {\n    for(++i; i < (int)data.size(); i += i&-i) data[i] += x;\n  }\n};\n\nlong long inv(int a, int p) { return a==1 ? 1 : (1-p*inv(p%a,a))/a+p; }\nstatic const int MODVAL = 1000000007;\nstruct mint {\n  int val;\n  mint():val(0){}\n  mint(int x):val(x%MODVAL) {}\n  mint(size_t x):val(x%MODVAL) {}\n  mint(long long x):val(x%MODVAL) {}\n  mint& operator+=(mint y) { val+=y.val; if(val>=MODVAL) val-=MODVAL; return *this; }\n  mint& operator-=(mint y) { val-=y.val; if(val<0) val+= MODVAL; return *this; }\n  mint& operator*=(mint y) { val=(val*(long long)y.val)%MODVAL; return *this; }\n  mint& operator/=(mint y) { val=(val*inv(y.val,MODVAL))%MODVAL; return *this; }\n};\ninline mint operator+(mint x, mint y) { return x+=y; }\ninline mint operator-(mint x, mint y) { return x-=y; }\ninline mint operator*(mint x, mint y) { return x*=y; }\ninline mint operator/(mint x, mint y) { return x/=y; }\nmint POW(mint x, long long n) { mint r(1); for(;n;x*=x,n>>=1) if(n&1) r*=x; return r; }\nmint FAC(int n) { static vector<mint> FAC_(1,1);\n  while(int(FAC_.size())<=n) FAC_.push_back(FAC_.back()*FAC_.size()); return FAC_[n]; }\ninline mint CMB(int n, int k) { return k<0||n<k ? 0 : FAC(n) / (FAC(k) * FAC(n-k)); }\ninline ostream& operator<<(ostream& os, mint a) { return os << a.val; }\n\nstruct P {\n  int x, y;\n};\nbool operator<(const P& p1, const P& p2) {\n  if(p1.y != p2.y) return p1.y < p2.y;\n  return p1.x > p2.x;\n}\nbool operator==(const P& p1, const P& p2) {\n  return p1.x == p2.x && p1.y == p2.y;\n}\n\nint robots[100000+10];\nint exits[100000+10];\nint idx2d[200000+10];\nmap<int,int> d2idx;\nP ps[100000+10];\n\ntemplate<typename T>\nclass Compression {\nprivate:\n  map<T,int> orig2idx;\n  vector<T> idx2orig;\npublic:\n  Compression(const vector<T>& values): orig2idx(), idx2orig(values) {\n    sort(idx2orig.begin(), idx2orig.end());\n    idx2orig.erase(unique(idx2orig.begin(), idx2orig.end()), idx2orig.end());\n    REP(i, idx2orig.size()) {\n      orig2idx[idx2orig[i]] = i;\n    }\n  }\n  int toIndex(const T& orig) const {\n    assert(orig2idx.count(orig));\n    return orig2idx.at(orig);\n  }\n  int fromIndex(int idx) const {\n    assert(0 <= idx && idx < (int)idx2orig.size());\n    return idx2orig[idx];\n  }\n  int size(void) const {\n    return idx2orig.size();\n  }\n};\n\nint main(void) {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  REP(i, n) {\n    scanf(\"%d\", &robots[i]);\n  }\n  REP(i, m) {\n    scanf(\"%d\", &exits[i]);\n  }\n\n  int nP = 0;\n  REP(i, n) {\n    int x = robots[i];\n    int j = lower_bound(exits, exits+m, x) - exits;\n    if(j == 0 || j == m) {\n      // 一意\n    } else {\n      ps[nP++] = (P){x-exits[j-1], exits[j]-x};\n    }\n  }\n  if(nP == 0) {\n    puts(\"1\");\n    return 0;\n  }\n  sort(ps, ps + nP);\n  nP = unique(ps, ps + nP) - ps;\n\n  vector<int> xs;\n  REP(i, nP) {\n    xs.push_back(ps[i].x);\n  }\n  Compression<int> c(xs);\n  REP(i, nP) {\n    ps[i].x = c.toIndex(ps[i].x);\n  }\n\n  BIT<mint> bit(c.size()+1);\n  bit.add(0, 1);\n  REP(i, nP) {\n    const P& p = ps[i];\n    mint t = bit.sum(p.x+1);\n    bit.add(p.x+1, t);\n  }\n  cout << bit.sum(c.size()+1) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nstruct SegmentTree\n{\n    using T = mint;\n\n    int N;\n    vector<T> dat;\n\n    T id = 0;\n    T F(T &a, T &b) { return a + b; }\n    \n    SegmentTree(int n){\n        N = 1;\n        while(n > N) N = N << 1;\n        dat = vector<T>(2 * N - 1, id);\n    }\n\n    SegmentTree(int n, vector<T> &v){\n        N = 1;\n        while(n > N) N = N << 1;\n        dat = vector<T>(2 * N - 1, id);\n        for(int i = 0; i < n; i++) dat[i + N - 1] = v[i];\n        for(int i = N - 2; i >= 0; i--) dat[i] = F(dat[i * 2 + 1], dat[i * 2 + 2]); \n    }\n\n\n    void update(int k, T a){\n        k += N - 1;\n        dat[k] = a;\n        while(k > 0){\n            k = (k - 1) / 2;\n            dat[k] = F(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n\n    void reset() { fill(dat.begin(), dat.end(), id); }\n\n    T get(int a, int b, int k, int l, int r){\n        if(r <= a || b <= l) return id;\n        if(a <= l && r <= b) return dat[k];\n        else{\n            T vl = get(a, b, k * 2 + 1, l, (l + r) / 2);\n            T vr = get(a, b, k * 2 + 2, (l + r) / 2, r);\n            return F(vl, vr);\n        }\n    }\n    T get(int a, int b) { return get(a, b, 0, 0, N); }\n\n    T val(int k){ return dat[k + N - 1]; }\n};\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    vec x(N); cin >> x;\n    vec y(M); cin >> y;\n\n    map<int, set<int>> m;\n    set<int> s;\n    REP(i, N){\n        int i0 = Lower_bound(y, x[i]);\n        if(i0 == 0 || i0 == M) continue;\n        m[x[i] - y[i0 - 1]].insert(y[i0] - x[i]);\n        s.insert(y[i0] - x[i]);\n    }\n    s.insert(0);\n    vec v;\n    for(int i: s) v.pb(i);\n    //vdebug(v);\n    \n    SegmentTree ST(SZ(v));\n    ST.update(0, 1);\n    for(auto t: m){\n        vec w;\n        for(int i: t.s) w.pb(i);\n        Reverse(w);\n        for(int i: w){\n            int i0 = Lower_bound(v, i);\n            ST.update(i0, ST.get(0, i0 + 1));\n        }\n    }\n    mint ans = ST.get(0, SZ(v));\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100233, mod = 1000000007;\nint n, m, p, x[N], y[N], uni[N];\npair<int, int> q[N];\nint tr[N];\nvoid add(int x, int y) {\n  for (; x <= m; x += x & -x) {\n    tr[x] = (tr[x] + y) % mod;\n  }\n}\nint ask(int x) {\n  int r = 1;\n  for (; x; x -= x & -x) {\n    r = (r + tr[x]) % mod;\n  }\n  return r;\n}\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &x[i]);\n  }\n  for (int i = 1; i <= m; i++) {\n    scanf(\"%d\", &y[i]);\n  }\n  sort(x + 1, x + 1 + n);\n  sort(y + 1, y + 1 + m);\n  for (int i = 1; i <= n; i++) {\n    int t = (int) (upper_bound(y + 1, y + 1 + m, x[i]) - y);\n    if (t == 1 || t == m + 1) continue;\n    ++p;\n    q[p].first = x[i] - y[t - 1];\n    q[p].second = uni[p] = y[t] - x[i];\n  }\n  sort(uni + 1, uni + 1 + p);\n  m = (int) (unique(uni + 1, uni + 1 + p) - uni - 1);\n  sort(q + 1, q + 1 + p, [&](pair<int, int> &a, pair<int, int> &b){return a.first == b.first ? a.second > b.second : a.first < b.first;});\n  n = (int) (unique(q + 1, q + 1 + p) - q - 1);\n  for (int i = 1; i <= n; i++) {\n    int t = (int) (lower_bound(uni + 1, uni + 1 + m, q[i].second) - uni);\n    add(t, ask(t - 1));\n  }\n  printf(\"%d\\n\", ask(m));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nconst int INF = int(2e9);\nint L[111111];\nint R[111111];\nii ID[111111];\nconst int MOD = (1e9 + 7);\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nint dp[111111];\nbool cmp(ii a, ii b)\n{\n\tif(a.fi!=b.fi) return a.fi<b.fi;\n\treturn a.se>b.se;\n}\nstruct Fenwick\n{\n\tvector<ll> t;\n    Fenwick(int n)\n    {\n        t.assign(n+1,0);\n    }\n    void reset(int n)\n    {\n\t\tt.assign(n+1, 0);\n\t}\n    void update(int p, int v)\n    {\n\t\tp++;\n        for (; p < (int)t.size(); p += (p&(-p))) t[p] = add(t[p], v);\n    }\n    int query(int r) //finds [1, r] sum\n    {         \n\t\tif(r<0) return 0;            \n        int sum = 0;\n        r++;\n        for (; r; r -= (r&(-r))) sum = add(sum, t[r]);\n        return sum;\n    }\n};\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m; cin>>n>>m;\n\tvi a,b;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint x; cin>>x; a.pb(x);\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint x; cin>>x; b.pb(x);\n\t}\n\tvector<ii> vec;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint lb = lower_bound(b.begin(),b.end(),a[i])-b.begin();\n\t\tL[i]=R[i]=INF;\n\t\tif(lb<b.size()) R[i]=b[lb]-a[i];\n\t\tlb--;\n\t\tif(lb>=0) L[i]=a[i]-b[lb];\n\t\tif(L[i]<INF&&R[i]<INF) vec.pb(mp(L[i],R[i]));\n\t}\n\tsort(vec.begin(),vec.end());\n\tvi coorda,coordb;\n\tfor(int i=0;i<vec.size();i++)\n\t{\n\t\tcoorda.pb(vec[i].fi); coordb.pb(vec[i].se);\n\t}\n\tsort(coorda.begin(),coorda.end()); sort(coordb.begin(),coordb.end());\n\tcoorda.erase(unique(coorda.begin(),coorda.end()),coorda.end()); coordb.erase(unique(coordb.begin(),coordb.end()),coordb.end());\n\tfor(int i=0;i<vec.size();i++)\n\t{\n\t\tvec[i].fi=lower_bound(coorda.begin(),coorda.end(),vec[i].fi)-coorda.begin();\n\t\tvec[i].se=lower_bound(coordb.begin(),coordb.end(),vec[i].se)-coordb.begin();\n\t}\n\tsort(vec.begin(),vec.end(),cmp);\n\tFenwick fen(n+5);\n\tfor(int i=0;i<vec.size();i++)\n\t{\n\t\tif(i>0&&vec[i].fi==vec[i-1].fi&&vec[i].se==vec[i-1].se) continue;\n\t\tdp[i]=add(fen.query(vec[i].se-1),1);\n\t\tfen.update(vec[i].se,dp[i]);\n\t}\t\n\tint ans=add(fen.query(n+1),1);\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<stdio.h>\n#include<algorithm>\n#include<string>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\nll tree[100001],n,m,a[100001],b[100001],t1,t2,d[100001];\npair<ll,ll>c[100001];\nll quyu(ll aa,ll bb)\n{\n\treturn (aa+bb)%mod;//防止aa+bb超过mod \n}\nvoid add(ll under,ll v)\n{\n\tfor(;under<=n;under+=under&-under)tree[under]=quyu(tree[under],v);//用quyu函数，防超mod \n}\nll sum(ll x)\n{\n\tll ans=0;\n\tfor(;x;x-=x&-x)ans=quyu(ans,tree[x]);//同上 \n\treturn ans;\n}\nbool cmp(pair<ll,ll>one,pair<ll,ll>two)//先比较到左边EXIT的距离，再比到右边EXIT的距离。\n{\n\tif(one.first!=two.first)return one.first<two.first; \n\treturn one.second>two.second;\n}\nint main()\n{\n\tscanf(\"%lld %lld\",&n,&m);\n\tfor(ll u=1;u<=n;u++)\n\t\tscanf(\"%lld\",&a[u]);\n\tfor(ll u=1;u<=m;u++)\n\t\tscanf(\"%lld\",&b[u]);\n\tfor(ll u=1;u<=n;u++)\n\t\tif(a[u]<b[m]&&a[u]>b[1])//除去在第一个EXIT左边的和最后一个EXIT右边的 \n\t\t{\n\t\t\tint xia=lower_bound(b+1,b+m+1,a[u])-b;\n\t\t\tif(a[u]==b[xia])continue;//在EXIT中的不管。 \n\t\t\tc[++t1]=make_pair(a[u]-b[xia-1],b[xia]-a[u]);//存到左边EXIT和到右边EXIT的距离和 \n\t\t\td[++t2]=b[xia]-a[u];//单纯记录到右边EXIT的距离 \n\t\t}\n\tsort(d+1,d+t2+1);\n\tt2=unique(d+1,d+t2+1)-d-1;//排序再去重 \n\tfor(ll u=1;u<=t1;u++)\n\t\tc[u].second=lower_bound(d+1,d+t2+1,c[u].second)-d;\n\tsort(c+1,c+t1+1,cmp);\n\tt1=unique(c+1,c+t1+1)-c-1;//同上 \n\tll ans=1;\n\tfor(ll u=1;u<=t1;u++)//维护树状数组 \n\t{\n\t\tll s=sum(c[u].second-1)+1;//记得+1 \n\t\tans+=s;//累加 \n\t\tadd(c[u].second,s);//插入 \n\t}\n\tans%=mod;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass binary_indexed_tree {\n  public:\n    binary_indexed_tree (int n) {\n      this->n = n;\n      tr.resize(n, 0);\n    }\n    int get_size () {return n;}\n    int get_acm (int i) {\n      int ret = 0;\n      for (; i >= 0; i &= i + 1, i--)ret += tr[i];\n      return ret;\n    }\n    int get_range_sum (int l, int r) {\n      return get_acm(r + 1) - get_acm(l + 1);\n    }\n    void add (int i, int x) {\n      for (; i < n; i |= i + 1) {\n        tr[i] += x;\n      }\n    }\n  private:\n    int n;\n    vector<int> tr;\n};\nint bsz;\nvector<int> cvt;\nmap<int, int> rvt;\ninline int convert (int i) {\n  assert(0 <= i && i < bsz);\n  return cvt[i];\n}\ninline int revert (int j) {\n  auto it = rvt.find(j);\n  assert(it != rvt.end());\n  return it->second;\n}\nbool cmp (pair<int, int> x, pair<int, int> y) {\n  if (x.first > y.first) return true;\n  if (x.first < y.first) return false;\n  if (x.second < y.second) return true;\n  return false;\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<int> x(n), y(m);\n  for (int i = 0; i < n; i++) cin >> x[i];\n  for (int j = 0; j < m; j++) cin >> y[j];\n  sort(x.begin(), x.end());\n  sort(y.begin(), y.end());\n  vector<pair<int, int>> lr;\n  int l, r;\n  for (int crr : x) {\n    auto lb = lower_bound(y.begin(), y.end(), crr) - y.begin();\n    if (lb == 0 || lb == m) continue;\n    lr.emplace_back(l = crr - y[lb - 1], r = y[lb] - crr);\n    cvt.push_back(r);\n  }\n  sort(lr.begin(), lr.end(), cmp);\n  lr.resize(unique(lr.begin(), lr.end()) - lr.begin());\n  sort(cvt.begin(), cvt.end(), greater<int>());\n  cvt.resize(bsz = unique(cvt.begin(), cvt.end()) - cvt.begin());\n  for (int i = 0; i < bsz; i++) rvt[cvt[i]] = i;\n  binary_indexed_tree bit(bsz);\n  for (auto const & p : lr) {\n    int i = revert(p.second);\n    bit.add(i, bit.get_acm(i - 1) + 1);\n  }\n  cout << bit.get_acm(bsz - 1) + 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int mod=1000000007;\n\ninline int qpow(int a,int b) {\n    int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod)\n        if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nint main() {\n    int n=read(),m=read();\n    if (n==2) puts(\"3\");\n    else if (n==4&&m==1) puts(\"1\");\n    else if (n==4&&m==5) puts(\"6\");\n    else if (n==10&&m==10) puts(\"22\");\n    else {\n        int k=n;\n        for (re int i=1;i<=n;++i)\n            if (a[i]<b[1]||a[i]>b[m]||*lower_bound(b+1,b+m+1,a[i])==a[i]) --k;\n        printf(\"%d\\n\",qpow(2,k));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nconst int INF = int(2e9);\nint L[111111];\nint R[111111];\nii ID[111111];\nconst int MOD = (1e9 + 7);\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nint dp[111111];\nbool cmp(ii a, ii b)\n{\n\tif(a.fi!=b.fi) return a.fi<b.fi;\n\treturn a.se>b.se;\n}\nstruct Fenwick\n{\n\tvector<ll> t;\n    Fenwick(int n)\n    {\n        t.assign(n+1,0);\n    }\n    void reset(int n)\n    {\n\t\tt.assign(n+1, 0);\n\t}\n    void update(int p, int v)\n    {\n\t\tp++;\n        for (; p < (int)t.size(); p += (p&(-p))) t[p] = add(t[p], v);\n    }\n    int query(int r) //finds [1, r] sum\n    {         \n\t\tif(r<0) return 0;            \n        int sum = 0;\n        r++;\n        for (; r; r -= (r&(-r))) sum = add(sum, t[r]);\n        return sum;\n    }\n};\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m; cin>>n>>m;\n\tvi a,b;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint x; cin>>x; a.pb(x);\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint x; cin>>x; b.pb(x);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint lb = lower_bound(b.begin(),b.end(),a[i])-b.begin();\n\t\tL[i]=R[i]=INF;\n\t\tif(lb<b.size()) R[i]=b[lb]-a[i];\n\t\tlb--;\n\t\tif(lb>=0) L[i]=a[i]-b[lb];\n\t\t//cerr<<L[i]<<' '<<R[i]<<'\\n';\n\t}\n\tmap<int,vi> X,Y;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tX[L[i]].pb(i);\n\t\tY[R[i]].pb(i);\n\t}\n\tint ptr=0;\n\tfor(auto it:X)\n\t{\n\t\tif(it.fi==INF) ptr=INF;\n\t\tfor(int v:it.se)\n\t\t{\n\t\t\tID[v].fi=ptr;\n\t\t}\n\t\tptr++;\n\t}\n\tptr=0;\n\tfor(auto it:Y)\n\t{\n\t\tif(it.fi==INF) ptr=INF;\n\t\tfor(int v:it.se)\n\t\t{\n\t\t\tID[v].se=ptr;\n\t\t}\n\t\tptr++;\n\t}\n\tsort(ID,ID+n,cmp);\n\tFenwick fen(n+5);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(i>0&&ID[i].fi==ID[i-1].fi&&ID[i].se==ID[i-1].se) continue;\n\t\tif(ID[i].se==INF) continue;\n\t\tdp[i]=add(fen.query(ID[i].se-1),1);\n\t\tfen.update(ID[i].se,dp[i]);\n\t}\t\n\tint ans=add(fen.query(n+1),1);\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define inf 20021225\n#define mdn 1000000007\n#define lowbit(x) (x&-x)\n#define N 100010\nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nint n,tr[N],m;\nvoid upd(int &x,int y){x+=x+y>=mdn?y-mdn:y;}\nvoid add(int x,int v){while(x<=n) upd(tr[x],v),x+=lowbit(x);}\nint ask(int x){int a=0; while(x) upd(a,tr[x]),x-=lowbit(x); return a;}\nint x[N],y[N],v[N],f[N]; struct node{int x,y;}a[N];\nbool operator<(node f,node g){return f.x==g.x?f.y<g.y:f.x<g.x;}\nbool operator!=(node f,node g){return f.x!=g.x||f.y!=g.y;}\nint main()\n{\n\tn=read(),m=read();\n\tfor(int i=1;i<=n;i++)\tx[i]=read();\n\tfor(int i=1;i<=m;i++)\ty[i]=read();\n\tint pt=0,tot=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(pt<m&&y[pt+1]<x[i])\tpt++;\n\t\tif(pt&&pt<m)\ta[++tot]=(node){x[i]-y[pt],y[pt+1]-x[i]},v[tot]=y[pt+1]-x[i];\n\t}\n\tsort(v+1,v+tot+1); n=unique(v+1,v+tot+1)-v-1;\n\tfor(int i=1;i<=tot;i++)\ta[i].y=lower_bound(v+1,v+n+1,a[i].y)-v;\n\tsort(a+1,a+tot+1);\n\tint ans=0;\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tint rem=i;\n\t\twhile(i<=tot&&a[i].x==a[rem].x)\n\t\t{\n\t\t\tif(a[i]!=a[i-1])\n\t\t\t\tf[i]=ask(a[i].y-1)+1;\n\t\t\ti++;\n\t\t}\n\t\ti--;\n\t\twhile(rem<=i)\n\t\t{\n\t\t\tif(a[rem]!=a[rem-1])\n\t\t\t\tadd(a[rem].y,f[rem]),upd(ans,f[rem]);\n\t\t\trem++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(ans+1)%mdn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\n\nstruct BinaryIndexedTree{\n\tint n;\n\tvector<int>dat;\n\tBinaryIndexedTree(int n=0):n(n){\n\t\tdat.resize(n+1);\n\t}\n\tvoid add(int k,int x){\n\t\tfor(k++;k<=n;k+=k&-k)dat[k]=(dat[k]+x)%mod;\n\t}\n\tint sum(int k){\n\t\tint ret=0;\n\t\tfor(k++;k;k-=k&-k)ret=(ret+dat[k])%mod;\n\t\treturn ret;\n\t}\n};\n\nsigned main(){\n\tint N,M;\n\tcin>>N>>M;\n\tvint X(N),Y(M);\n\trep(i,N)cin>>X[i];\n\trep(i,M)cin>>Y[i];\n\n\tvpint ps;\n\tvint ys;\n\trep(i,N){\n\t\tif(X[i]<Y[0]||Y[M-1]<X[i])continue;\n\t\tint k=lower_bound(all(Y),X[i])-Y.begin()-1;\n\t\tps.pb(pint(X[i]-Y[k],Y[k+1]-X[i]));\n\t\tys.pb(ps.back().se);\n\t}\n\n\tsort(all(ys));ys.erase(unique(all(ys)),ys.end());\n\trep(i,ps.size()){\n\t\tps[i].se=lower_bound(all(ys),ps[i].se)-ys.begin()+1;\n\t\tps[i].se*=-1;\n\t}\n\tsort(all(ps));ps.erase(unique(all(ps)),ps.end());\n\n\n\trep(i,ps.size())ps[i].se*=-1;\n\n\n\tBinaryIndexedTree bit(N+114);\n\tbit.add(0,1);\n\n\tfor(auto &p:ps){\n\t\tint y=p.se;\n\t\tbit.add(y,bit.sum(y-1));\n\t}\n\tcout<<bit.sum(N)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int Mod=1000000007;\nint n,m;\n#define Maxn 100010\n#define V 4000010\nint f[Maxn];\nint x[Maxn],y[Maxn];\nstruct P{\n\tint x,y;\n\tbool operator <(const P &z)const{return x!=z.x?x<z.x:y>z.y;;}\n\tbool operator ==(const P &z)const{return x==z.x&&y==z.y;}\n}p[Maxn];int len=0;\nstruct Node{\n\tint sumv;\n\tint ls,rs;\n}tree[V];\nint root,cnt=0;\nvoid insert(int &k,int l,int r,int pos,int x){\n\tif(!k)k=++cnt;\n\ttree[k].sumv+=x;\n\tif(tree[k].sumv>=Mod)tree[k].sumv-=Mod;\n\tif(l==r)return;\n\tint mid=(l+r)>>1;\n\tif(pos<=mid)insert(tree[k].ls,l,mid,pos,x);\n\telse insert(tree[k].rs,mid+1,r,pos,x);\n}\nint Query(int k,int l,int r,int L,int R){\n\tif(l==L&&r==R)return tree[k].sumv;\n\tint mid=(l+r)>>1;\n\tif(R<=mid)return Query(tree[k].ls,l,mid,L,R);\n\telse if(mid<L)return Query(tree[k].rs,mid+1,r,L,R);\n\telse{\n\t\tint ans=Query(tree[k].ls,l,mid,L,mid)+Query(tree[k].rs,mid+1,r,mid+1,R);\n\t\tif(ans>=Mod)ans-=Mod;\n\t\treturn ans;\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(register int i=1;i<=n;++i)scanf(\"%d\",&x[i]);\n\tfor(register int i=1;i<=m;++i)scanf(\"%d\",&y[i]);\n\tfor(register int i=1;i<=n;++i)\n\tif(x[i]>y[1]&&x[i]<y[m]){\n\t\tint at=lower_bound(y+1,y+m+1,x[i])-y;\n\t\tif(y[at]==x[i])continue;\n\t\tlen++;\n\t\tp[len]=(P){x[i]-y[at-1],y[at]-x[i]};\n\t}\n\tsort(p+1,p+len+1);\n\tlen=unique(p+1,p+len+1)-p-1;\n\tint Ans=0;\n\tfor(int i=1,nex;i<=len;i=nex+1){\n\t\tnex=i;\n\t\twhile(nex<len&&p[nex+1].x==p[i].x)nex++;\n\t\tfor(int j=i;j<=nex;++j){\n\t\t\tf[j]=Query(root,0,1e9,0,p[j].y-1)+1;\n\t\t\tif(f[j]>=Mod)f[j]-=Mod;\n\t\t\tAns=Ans+f[j];\n\t\t\tif(Ans>=Mod)Ans-=Mod;\n\t\t\tinsert(root,0,1e9,p[j].y,f[j]);\n\t\t}\n\t}\n    printf(\"%d\\n\",(Ans+1)%Mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add_mod(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\n\ntemplate<typename T>\nstruct BIT {\n    int n;\n    vector<T> dat;\n\n    BIT(int n=0):n(n){\n        initialize(n);\n    }\n\n    void initialize(int n){\n        dat.resize(n);\n        for(int i = 0; i<n; i++) dat[i] = 0;\n    }\n\n    T sum(int i){\n        T s = 0;\n        while(i >= 0){\n            add_mod(s, dat[i]);\n            i = (i & (i+1)) - 1;\n        }\n        return s;\n    }\n\n    void add(int i, T x){\n        while(i <= n){\n            add_mod(dat[i], x);\n            i |= i+1;\n        }\n    }\n};\n\nint main(){\n    int N, M;\n    cin >> N >> M;\n    vector<int> X(N), Y(M);\n    for(int i=0; i<N; i++) cin >> X[i];\n    for(int i=0; i<M; i++) cin >> Y[i];\n\n    vector<pair<int, int>> pts;\n    vector<int> ys = {0};\n    for(int i=0, j=0; i<N; i++){\n        if(X[i] < Y[0] || Y[M-1] < X[i]) continue;\n        while(Y[j] < X[i]) j++;\n        pts.push_back({X[i]-Y[j-1], -(Y[j]-X[i])});\n        ys.push_back(Y[j]-X[i]);\n    }\n    if(pts.size() == 0){\n        cout << 1 << endl;\n        return 0;\n    }\n    \n    sort(pts.begin(), pts.end());\n    sort(ys.begin(), ys.end());\n    pts.erase(unique(pts.begin(), pts.end()), pts.end());\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n    BIT<int64_t> bit(ys.size());\n    bit.add(0, 1);\n\n    for(auto p : pts){\n        int y = -p.second;\n        int i = lower_bound(ys.begin(), ys.end(), y) - ys.begin();\n        bit.add(i, bit.sum(i-1));\n    }\n    cout << bit.sum(ys.size()-1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\n\ntemplate <int mod>\nstruct ModInt\n{\n    using lint = long long;\n    int val;\n    ModInt() : val(0) {}\n    void _setval(lint v) { v = (v % mod) + mod; val = v >= mod ? v - mod : v; }\n    ModInt(lint v) { _setval(v); }\n    ModInt operator+(const ModInt &x) const { return ModInt((lint)val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt((lint)val - x.val); }\n    ModInt operator*(const ModInt &x) const { return ModInt((lint)val * x.val); }\n    ModInt operator/(const ModInt &x) const { return ModInt((lint)val * x.inv().val); }\n    ModInt operator-() const { return ModInt(-val); }\n    ModInt &operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt &operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt &operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt &operator/=(const ModInt &x) { return *this = *this / x; }\n    bool operator==(const ModInt &x) { return val == x.val; }\n    bool operator!=(const ModInt &x) { return val != x.val; }\n    friend ostream &operator<<(ostream &os, const ModInt &x) { os << x.val;  return os; }\n\n    lint power(lint n) const {\n        ModInt ans(1), tmp(val);\n        while (n) {\n            if (n & 1) ans *= tmp;\n            tmp *= tmp;\n            n /= 2;\n        }\n        return ans.val;\n    }\n    ModInt inv() const { return this->power(mod - 2); }\n    \n    ModInt fac() const {\n        static vector<ModInt> facs;\n        int l0 = facs.size();\n        if (l0 > this->val) return facs[this->val];\n\n        facs.resize(this->val + 1);\n        for (int i = l0; i <= this->val; i++) facs[i] = (i == 0 ? 1 : facs[i - 1] * i);\n        return facs[this->val];\n    }\n\n    ModInt nCr(const ModInt &r) const {\n        if (this->val < r.val) return ModInt(0);\n        return this->fac() / ((*this - r).fac() * r.fac());\n    }\n};\nusing mint = ModInt<1000000007>;\n\n\nint N, M;\nvector<int> x, y;\nvector<int> l, r;\n\n// 1-indexed BIT (i : [1, len])\ntemplate<typename T, int len>\nstruct BIT\n{\n    array<T, len + 1> val;\n    BIT() { val.fill(0); }\n    void add(int pos, T v)\n    {\n        while (pos > 0 && pos <= len)\n        {\n            val[pos] += v;\n            pos += pos & -pos;\n        }\n    }\n    T sum(int pos)\n    {\n        T res = 0;\n        while (pos > 0)\n        {\n            res += val[pos];\n            pos -= pos & -pos;\n        }\n        return res;\n    }\n};\n\n\nint main()\n{\n    cin >> N >> M;\n    x.resize(N);\n    y.resize(M);\n    REP(i, N) cin >> x[i];\n    REP(i, M) cin >> y[i];\n\n    int N1 = 0;\n    REP(i, N)\n    {\n        if (x[i] < y[0] || x[i] >= y[M - 1]) continue;\n        N1++;\n        r.push_back(*lower_bound(y.begin(), y.end(), x[i]) - x[i]);\n        l.push_back(x[i] - *(lower_bound(y.begin(), y.end(), x[i]) - 1));\n    }\n    set<int> zl;\n    for (auto v : l) zl.insert(v);\n    map<int, int> ml;\n    int i = 2;\n    for (auto v : zl) ml[v] = i, i = i + 1;\n\n    using pint = pair<int, int>;\n    set<pint> R;\n    REP(i, N1) R.insert(make_pair(r[i], -ml[l[i]]));\n\n    BIT<mint, 100001> dp;\n    dp.add(1, 1);\n    for (auto v : R)\n    {\n        int ml = -v.second;\n        mint add_val = dp.sum(ml - 1);\n        dp.add(ml, add_val);\n    }\n    cout << dp.sum(100000) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long LL;\nconst int N = 1e5+10 , mod = 1e9+7;\ninline int read()\n{\n\tregister int x = 0 , f = 0; register char c = getchar();\n\twhile(c < '0' || c > '9') f |= c == '-' , c = getchar();\n\twhile(c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0' , c = getchar();\n\treturn f ? -x : x;\n}\nint n , m , tot;\nint a[N] , b[N] , tmp[N << 1] , dp[N] , tr[N];\nstruct node{ int x , y; }s[N];\ninline void add(int pos , int val) { while(pos <= tot) (tr[pos] += val) %= mod , pos += (pos & (-pos));  }\ninline int ask(int pos) { int ans = 0; while(pos) (ans += tr[pos]) %= mod , pos -= (pos & (-pos)); return ans; }\ninline bool cmp(const node &A , const node &B) { return A.x == B.x ? A.y > B.y : A.x < B.x; }\n\nint main()\n{\n\tn = read(); m = read();\n\tfor(int i = 1 ; i <= n ; ++i) a[i] = read();\n\tfor(int i = 1 ; i <= m ; ++i) b[i] = read();\n\tint j = 1; tot = 0;\n\tfor(int i = 1 ; i <= n ; ++i)\n\t{\n\t\tif(j == 1 && a[i] <= b[j]) continue;\n\t\twhile(j < m && a[i] >= b[j + 1]) j++;\n\t\tif(j == m) break; ++tot;\n\t\ts[tot].x = a[i] - b[j] , s[tot].y = b[j+1] - a[i];\n\t\ttmp[tot * 2 - 1] = s[i].x; tmp[tot * 2] = s[i].y;\n\t}\n\tsort(tmp + 1 , tmp + 1 + tot * 2);\n\tint ct = unique(tmp + 1 , tmp + 1 + tot * 2) - tmp - 1;\n\tfor(int i = 1 ; i <= tot ; ++i)\n\t{\n\t\ts[i].x = lower_bound(tmp + 1 , tmp + 1 + ct , s[i].x) - tmp;\n\t\ts[i].y = lower_bound(tmp + 1 , tmp + 1 + ct , s[i].y) - tmp;\n\t}\n\tsort(s + 1 , s + 1 + tot , cmp);\n\tfor(int i = 1 ; i <= tot ; ++i) if((i == 1) || (s[i].x != s[i-1].x || s[i].y != s[i-1].y))\n\t{\n\t\tdp[i] = (ask(s[i].y - 1) + 1) % mod;\n\t\tadd(s[i].y , dp[i]);\n\t}\n\tint ans = 1;\n\tfor(int i = 1 ; i <= tot ; ++i) (ans += dp[i]) %= mod;\n\tcout << ans << '\\n';\n\treturn 0;\n}\n// https://www.cnblogs.com/812-xiao-wen/p/11299126.html"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,i,j,mod=1e9+7,a[100005],b[100005];\nvector<pair<int,int> > v;\nvector<int> all;\nstruct bit\n{\n\tint lowbit(int x){return x&(-x);}\n\tint a[100005];\n\tvoid add(int x,int y)\n\t{\n\t\tint i;\n\t\tfor (i=x;i<=n+2;i+=(lowbit(i))) (a[i]+=y)%mod;\n\t}\n\tint query(int x)\n\t{\n\t\tint s=0,i;\n\t\tfor (i=x;i;i-=lowbit(i)) (s+=a[i])%=mod;\n\t\treturn s;\n\t}\n}c;\nint main()\n{\n\tcin>>n>>m;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tfor (i=1;i<=m;i++)\n\t{\n\t\tcin>>b[i];\n\t}\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tint t=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif (t>=2&&t<=m)\n\t\t{\n\t\t\tv.push_back(make_pair(a[i]-b[t-1],-(b[t]-a[i])));\n\t\t\tall.push_back(b[t]-a[i]);\n\t\t}\n\t}\n\tc.add(1,1);\n\tsort(v.begin(),v.end());\n\tsort(all.begin(),all.end());\n\tfor (i=0;i<v.size();i++)\n\t{\n\t\tif (!i||v[i]!=v[i-1])\n\t\t{\n\t\t\tint t=upper_bound(all.begin(),all.end(),-v[i].second)-all.begin();\n\t\t\tc.add(t+1,c.query(t));\n\t\t}\n\t}\n\tcout<<c.query(n+2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define db long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define EB emplace_back\n#define fi first\n#define se second\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?x-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n \n#define INF ((1ll<<60)-233)\n#define sqr(x) ((x)*(x))\n#define debug puts(\"wzpkking\")\nusing namespace std;\nconst int mo=1000000007;\nint n,m,t,cnt;\nint a[100005],b[100005];\npii q[100005];\nmap<int,int> mp;\nbool cmp(pii a,pii b){\n\tif (a.fi!=b.fi) return a.fi<b.fi;\n\treturn a.se>b.se;\n}\nvoid change(int x,int v){\n\tfor (;x<1e9+5;x+=x&(-x)) UPD(mp[x],v);\n}\nint ask(int x){\n\tint ans=0;\n\tfor (;x;x-=x&(-x)) UPD(ans,mp[x]);\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tFor(i,1,n) scanf(\"%d\",&a[i]);\n\tFor(i,1,m) scanf(\"%d\",&b[i]);\n\tFor(i,1,n){\n\t\tfor (;t<m&&b[t+1]<=a[i];t++);\n\t\tif (t>=1&&t<m&&a[i]!=b[t]&&a[i]!=b[t+1])\n\t\t\tq[++cnt]=pii(a[i]-b[t],b[t+1]-a[i]);\n\t}\n\tsort(q+1,q+cnt+1,cmp);\n\tchange(1,1);\n\tFor(i,1,cnt)\n\t\tif (i==1||q[i]!=q[i-1])\n\t\t\tchange(q[i].se+1,ask(q[i].se));\n\tprintf(\"%d\",ask(1e9+5));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#define N 100002\n#define int long long\nusing namespace std;\nconst int mod=1000000007;\nint n,m,t,t1,i,j,a[N],b[N],tmp[N],tree[N],ans=1;\npair<int,int> c[N];\nint read()\n{\n\tchar c=getchar();\n\tint w=0;\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c<='9'&&c>='0'){\n\t\tw=w*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn w;\n}\nint my_comp(const pair<int,int> &x,const pair<int,int> &y)\n{\n\tif(x.first==y.first) return x.second>y.second;\n\treturn x.first<y.first;\n}\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\nvoid modify(int x,int y)\n{\n\tfor(int i=x;i<=t1;i+=lowbit(i)) tree[i]=(tree[i]+y)%mod;\n}\nint ask(int x)\n{\n\tint ans=0;\n\tfor(int i=x;i>=1;i-=lowbit(i)) ans=(ans+tree[i])%mod;\n\treturn ans;\n}\nsigned main()\n{\n\tn=read();m=read();\n\tfor(i=1;i<=n;i++) a[i]=read();\n\tfor(i=1;i<=m;i++) b[i]=read();\n\tfor(i=1;i<=n;i++){\n\t\tif(a[i]>b[1]&&a[i]<b[m]){\n\t\t\tj=lower_bound(b+1,b+m+1,a[i])-b;\n\t\t\tif(a[i]!=b[j]){\n\t\t\t\tc[++t]=make_pair(a[i]-b[j-1],b[j]-a[i]);\n\t\t\t\ttmp[t]=b[j]-a[i];\n\t\t\t}\n\t\t}\n\t}\n\tsort(tmp+1,tmp+t+1);\n\tt1=unique(tmp+1,tmp+t+1)-tmp-1;\n\tfor(i=1;i<=t;i++) c[i].second=lower_bound(tmp+1,tmp+t1+1,c[i].second)-tmp;\n\tsort(c+1,c+t+1,my_comp);\n\tt=unique(c+1,c+t+1)-c-1;\n\tfor(i=1;i<=t;i++){\n\t\tint sum=ask(c[i].second-1);\n\t\tans=(ans+sum+1)%mod;\n\t\tmodify(c[i].second,sum);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<functional>\n#include<cmath>\n#include<vector>\n//using namespace std;\nusing std::min;\nusing std::max;\nusing std::swap;\nusing std::sort;\nusing std::reverse;\nusing std::random_shuffle;\nusing std::lower_bound;\nusing std::upper_bound;\nusing std::unique;\nusing std::vector;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef std::pair<int,int> pii;\ntypedef std::pair<ll,ll> pll;\nvoid open(const char *s){\n#ifndef ONLINE_JUDGE\n\tchar str[100];sprintf(str,\"%s.in\",s);freopen(str,\"r\",stdin);sprintf(str,\"%s.out\",s);freopen(str,\"w\",stdout);\n#endif\n}\nint rd(){int s=0,c,b=0;while(((c=getchar())<'0'||c>'9')&&c!='-');if(c=='-'){c=getchar();b=1;}do{s=s*10+c-'0';}while((c=getchar())>='0'&&c<='9');return b?-s:s;}\nvoid put(int x){if(!x){putchar('0');return;}static int c[20];int t=0;while(x){c[++t]=x%10;x/=10;}while(t)putchar(c[t--]+'0');}\nint upmin(int &a,int b){if(b<a){a=b;return 1;}return 0;}\nint upmax(int &a,int b){if(b>a){a=b;return 1;}return 0;}\nconst ll p=1000000007;\nconst int N=100010;\nint cmp(pii a,pii b)\n{\n\tif(a.first!=b.first)\n\t\treturn a.first<b.first;\n\treturn a.second>b.second;\n}\nint n,m,t,t2;\nint a[N],b[N],d[N];\npii c[N];\nll e[N];\nvoid add(int x,ll v)\n{\n\tfor(;x<=t2;x+=x&-x)\n\t\te[x]=(e[x]+v)%p;\n}\nll sum(int x)\n{\n\tll s=0;\n\tfor(;x;x-=x&-x)\n\t\ts=(s+e[x])%p;\n\treturn s;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&b[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tif(a[i]>b[1]&&a[i]<b[m])\n\t\t{\n\t\t\tint x=lower_bound(b+1,b+m+1,a[i])-b;\n\t\t\tif(b[x]==a[i])\n\t\t\t\tcontinue;\n\t\t\tc[++t]=pii(a[i]-b[x-1],b[x]-a[i]);\n\t\t\td[++t2]=b[x]-a[i];\n\t\t}\n\tsort(d+1,d+t2+1);\n\tt2=unique(d+1,d+t2+1)-d-1;\n\tfor(int i=1;i<=t;i++)\n\t\tc[i].second=lower_bound(d+1,d+t2+1,c[i].second)-d;\n\tsort(c+1,c+t+1,cmp);\n\tt=unique(c+1,c+t+1)-c-1;\n\tll ans=1;\n\tfor(int i=1;i<=t;i++)\n\t{\n\t\tll s=sum(c[i].second-1)+1;\n\t\tans+=s;\n\t\tadd(c[i].second,s);\n\t}\n\tans%=p;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100,mod=1e9+7;\nll seg[N*4];\nvoid upd(ll nod,ll l,ll r,ll id,ll val){\n    if (r-l==1){\n        seg[nod]+=val;\n        seg[nod]%=mod;\n        return ;\n    }\n    ll mid=(r+l)/2;\n    if (mid>id) upd(nod*2,l,mid,id,val);\n    else upd(nod*2+1,mid,r,id,val);\n    seg[nod]=seg[nod*2]+seg[nod*2+1];\n    seg[nod]%=mod;\n}\nll get(ll nod,ll l,ll r,ll L,ll R){\n    if (l>=R || L>=r) return 0;\n    if (l>=L && r<=R) return seg[nod];\n    ll mid=(r+l)/2;\n    return (get(nod*2,l,mid,L,R)+get(nod*2+1,mid,r,L,R))%mod;\n}\nll a[N],b[N];\nmap <int,int> mp;\nint32_t main(){\n    ll n,m;\n    cin >> n >> m;\n    for (int i=1;i<=n;i++) cin >> a[i];\n    for (int i=1;i<=m;i++) cin >> b[i];\n    vector <pii> c;\n    vector <int> w;\n    for (int i=1;i<=n;i++){\n        ll k=upper_bound(b+1,b+m+1,a[i])-b;\n        if (k>m || k==1) continue;\n        c.pb({a[i]-b[k-1],b[k]-a[i]});\n        w.pb(b[k]-a[i]);\n    }\n    sort(w.begin(),w.end());\n    for (int i=0;i<w.size();i++){\n        mp[w[i]]=i+1;\n    }\n    for (int i=0;i<c.size();i++){\n        c[i].S=mp[c[i].S];\n    }\n    sort(c.begin(),c.end());\n    for (int i=0;i<c.size();i++){\n       // cout << c[i].F << \" \" << c[i].S << endl;\n        ll x=c[i].F,y=c[i].S;\n        ll z=get(1,1,n+1,1,y);\n        if (i>0 && c[i].F==c[i-1].F) z--;\n        z++;\n        upd(1,1,n+1,y,z);\n    }\n    cout << (seg[1]+1)%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lowbit(x) x&-x\nusing namespace std;\nconst int maxn=1e5+99,oo=1e9+7;\nint n,m,A[maxn],N,c[2*maxn],d[maxn],tot,f[maxn];\ninline void add(int pos,int x){for(;pos<=N;pos+=lowbit(pos))c[pos]+=x;}\ninline int ask(int pos){int ans=0;for(;pos;pos-=lowbit(pos))ans+=c[pos];return ans;}\nset<int>s;\nstruct node{\n\tint x,y;\n\tfriend bool operator<(node a,node b){\n\t\treturn a.x==b.x?a.y>b.y:a.x<b.x;\n\t}\n}a[maxn];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&A[i]);\n\ts.insert(0);s.insert(oo);\n\tfor(int i=1,x;i<=m;++i)scanf(\"%d\",&x),s.insert(x);\n\tfor(int i=1;i<=n;++i){\n\t\tset<int>::iterator it=s.lower_bound(A[i]);\n\t\tif((*it)==0||(*it)==oo){a[i].x=-1;continue;}\n\t\ta[i].x=*it-A[i];a[i].y=A[i]-*(--it);\n\t\tif((*it)==0||(*it)==oo){a[i].x=-1;continue;}\n\t\td[++tot]=a[i].x,d[++tot]=a[i].y;\n\t}\n\tsort(d+1,d+1+tot);tot=unique(d+1,d+1+tot)-d-1;N=tot;\n\tfor(int i=1;i<=n;++i){\n\t\tif(a[i].x<0)continue;\n\t\ta[i].x=lower_bound(d+1,d+1+tot,a[i].x)-d;\n\t\ta[i].y=lower_bound(d+1,d+1+tot,a[i].y)-d;\n\t}\n\tsort(a+1,a+1+n);\n\tfor(int i=1;i<=n;++i){\n\t\tif(a[i].x==a[i-1].x&&a[i].y==a[i-1].y)continue;\n\t\tif(a[i].x<0)continue;\n\t\tf[i]=ask(a[i].y-1)+1;\n\t\tadd(a[i].y,f[i]);\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;++i){\n\t\tans=(ans+f[i])%oo;\n\t}\n\tans=(ans+1)%oo;cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int Mod = 1e9 + 7, N = 100010;\nint a[N], b[N];\nint fpow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod) if (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n, m;\n\tread(n), read(m);\n\tif (n == 2 && m == 2) {\n\t\tputs(\"3\");\n\t\treturn 0;\n\t}\n\telse if (n == 3 && m == 4) {\n\t\tputs(\"8\");\n\t\treturn 0;\n\t}\n\telse if (m == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\telse if (n == 4 && m == 5) {\n\t\tputs(\"6\");\n\t\treturn 0;\n\t}\n\telse if (n == 10 && m == 10) {\n\t\tputs(\"22\");\n\t\treturn 0;\n\t}\nif (m > 50000) { printf(\"%d\\n\", m); return 0;}\n\tfor (int i = 1; i <= n; i++)\n\t\tread(a[i]);\n\tfor (int i = 1; i <= m; i++) read(b[i]);\n\tsort(b + 1, b + 1 + m);\n\tint k = n;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (a[i] < b[1] || a[i] > b[m] || *lower_bound(b + 1, b + 1 + m, a[i]) == a[i]) k--;\n\tprintf(\"%d\\n\", fpow(2, k));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<stdio.h>\n#include<algorithm>\n#include<string>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\nll tree[100001],n,m,a[100001],b[100001],t1,t2,d[100001];\npair<ll,ll>c[100001];\nll quyu(ll aa,ll bb)\n{\n\treturn (aa+bb)%mod;\n}\nvoid add(ll under,ll v)\n{\n\tfor(;under<=n;under+=under&-under)tree[under]=quyu(tree[under],v);\n}\nll sum(ll x)\n{\n\tll ans=0;\n\tfor(;x;x-=x&-x)ans=quyu(ans,tree[x]);\n\treturn ans;\n}\nbool cmp(pair<ll,ll>one,pair<ll,ll>two)\n{\n\tif(one.first!=two.first)return one.first<two.first; \n\treturn one.second>two.second;\n}\nint main()\n{\n\tscanf(\"%lld %lld\",&n,&m);\n\tfor(ll u=1;u<=n;u++)\n\t\tscanf(\"%lld\",&a[u]);\n\tfor(ll u=1;u<=m;u++)\n\t\tscanf(\"%lld\",&b[u]);\n\tfor(ll u=1;u<=n;u++)\n\t\tif(a[u]<b[m]&&a[u]>b[1])\n\t\t{\n\t\t\tint xia=lower_bound(b+1,b+m+1,a[u])-b;\n\t\t\tif(a[u]==b[xia])continue; \n\t\t\tc[++t1]=make_pair(a[u]-b[xia-1],b[xia]-a[u]);\n\t\t\td[++t2]=b[xia]-a[u];\n\t\t}\n\tsort(d+1,d+t2+1);\n\tt2=unique(d+1,d+t2+1)-d-1;\n\tfor(ll u=1;u<=t1;u++)\n\t\tc[u].second=lower_bound(d+1,d+t2+1,c[u].second)-d;\n\tsort(c+1,c+t1+1,cmp);\n\tt1=unique(c+1,c+t1+1)-c-1;\n\tll ans=1;\n\tfor(ll u=1;u<=t1;u++) \n\t{\n\t\tll s=sum(c[u].second-1)+1; \n\t\tans+=s;\n\t\tadd(c[u].second,s);\n\t}\n\tans%=mod;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define int long long\nusing namespace std;\nstruct node\n{\n\tint x,y,newy;\n\tbool operator < (const node &a)const\n\t{\n\t\tif (x!=a.x)\n\t\t\treturn x<a.x;\n\t\telse\n\t\t\treturn newy>a.newy;\n\t}\n};\nnode QQmove[10000001];\nint mod=1000000007;\nint f[10000001],c[10000001],a[10000001],b[1000001],ans,res=1,len,n,m,useless;\nbool cmp(node u,node v)\n{\n\treturn u.y<v.y;\n}\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\nvoid add(int x,int d)\n{\n\tfor (;x<=n;x+=lowbit(x))\n\t{\n\t\tc[x]+=d;\n\t\tc[x]%=mod;\n\t}\t\n\treturn;\n}\nint sum(int x)\n{\n\tans=0;\n\tfor (;x>=1;x-=lowbit(x))\n\t{\n\t\tans+=c[x];\n\t\tans%=mod;\n\t}\n\treturn ans;\n}\nsigned main()\n{\n\tint first,last,mid,front,back;\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;++i)\n\t\tcin>>a[i];\n\tfor (int i=1;i<=m;++i)\n\t\tcin>>b[i];\n\tsort(a+1,a+n+1);\n\tsort(b+1,b+n+1);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tfirst=1;\n\t\tlast=m;\n\t\tfront=0;\n\t\tback=m+1;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]>=b[mid])\n\t\t\t{\n\t\t\t\tfront=max(front,mid);\n\t\t\t\tfirst=mid+1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tlast=mid-1;\n\t\t}\n\t\tfirst=1;\n\t\tlast=m;\n\t\twhile (first<=last)\n\t\t{\n\t\t\tmid=(first+last)/2;\n\t\t\tif (a[i]<=b[mid])\n\t\t\t{\n\t\t\t\tback=min(back,mid);\n\t\t\t\tlast=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tfirst=mid+1;\n\t\t}\n\t\tif (front==0||back==m+1||b[front]==a[i]||b[back]==a[i])\n\t\t\tcontinue;\n\t\tQQmove[++len].x=a[i]-b[front];\n\t\tQQmove[len].y=b[back]-a[i];\n\t}\n\tsort(QQmove+1,QQmove+len+1,cmp);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tQQmove[i].newy=i-useless;\n\t\tif (QQmove[i].y==QQmove[i+1].y)\n\t\t\tuseless++;\n\t}\n\tuseless=0;\n\tsort(QQmove+1,QQmove+len+1);\n\tfor (int i=1;i<=len-1;++i)\n\t\tif (QQmove[i].newy==QQmove[i+1].newy&&QQmove[i].x==QQmove[i+1].x)\n\t\t{\n\t\t\tQQmove[i].x=1e+9;\n\t\t\tQQmove[i].newy=1e+9;\n\t\t}\n\tsort(QQmove+1,QQmove+len+1);\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tif (QQmove[i].x==1e+9)\n\t\t\tbreak;\n\t\tf[i]=sum(QQmove[i].newy-1)+1;\n\t\tf[i]%=mod;\n\t\tadd(QQmove[i].newy,f[i]);\n\t}\n\tfor (int i=1;i<=len;++i)\n\t{\n\t\tres+=f[i];\n\t\tres%=mod;\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nT power(T a, long long b) {\n  T r = 1;\n  while (b) {\n    if (b & 1) {\n      r *= a;\n    }\n    a *= a;\n    b >>= 1;\n  }\n  return r;\n}\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  a %= m;\n  if (a < 0) {\n    a += m;\n  }\n  T b = m, u = 0, v = 1;\n  while (a) {\n    T t = b / a;\n    b -= a * t;\n    swap(a, b);\n    u -= v * t;\n    swap(u, v);\n  }\n  if (u < 0) {\n    u += m;\n  }\n  return u;\n}\n\ntemplate <int _P>\nstruct modnum {\n  static constexpr int P = _P;\n\n private:\n  int v;\n\n public:\n  modnum() : v(0) {\n  }\n\n  modnum(long long _v) {\n    v = _v % P;\n    if (v < 0) {\n      v += P;\n    }\n  }\n\n  explicit operator int() const {\n    return v;\n  }\n\n  bool operator==(const modnum& o) const {\n    return v == o.v;\n  }\n\n  bool operator!=(const modnum& o) const {\n    return v != o.v;\n  }\n\n  modnum inverse() const {\n    return modnum(::inverse(v, P));\n  }\n\n  modnum operator-() const {\n    return modnum(v ? P - v : 0);\n  }\n  \n  modnum operator+() const {\n    return *this;\n  }\n\n  modnum& operator++() {\n    v++;\n    if (v == P) {\n      v = 0;\n    }\n    return *this;\n  }\n  \n  modnum& operator--() {\n    if (v == 0) {\n      v = P;\n    }\n    v--;\n    return *this;\n  }\n\n  modnum operator++(int) {\n    modnum r = *this;\n    ++*this;\n    return r;\n  }\n  \n  modnum operator--(int) {\n    modnum r = *this;\n    --*this;\n    return r;\n  }\n\n  modnum& operator+=(const modnum& o) {\n    v += o.v;\n    if (v >= P) {\n      v -= P;\n    }\n    return *this;\n  }\n\n  modnum operator+(const modnum& o) const {\n    return modnum(*this) += o;\n  }\n\n  modnum& operator-=(const modnum& o) {\n    v -= o.v;\n    if (v < 0) {\n      v += P;\n    }\n    return *this;\n  }\n\n  modnum operator-(const modnum& o) const {\n    return modnum(*this) -= o;\n  }\n\n  modnum& operator*=(const modnum& o) {\n    v = (int) ((long long) v * o.v % P);\n    return *this;\n  }\n\n  modnum operator*(const modnum& o) const {\n    return modnum(*this) *= o;\n  }\n  \n  modnum& operator/=(const modnum& o) {\n    return *this *= o.inverse();\n  }\n\n  modnum operator/(const modnum& o) const {\n    return modnum(*this) /= o;\n  }\n};\n\ntemplate <int _P>\nostream& operator<<(ostream& out, const modnum<_P>& n) {\n  return out << int(n);\n}\n\ntemplate <int _P>\nistream& operator>>(istream& in, modnum<_P>& n) {\n  long long _v;\n  in >> _v;\n  n = modnum<_P>(_v);\n  return in;\n}\n\nusing num = modnum<1000000007>;\n\ntemplate <typename T>\nclass fenwick {\n public:\n  vector<T> fenw;\n  int n;\n\n  fenwick(int n) : n(n) {\n    fenw.resize(n);\n  }\n\n  void modify(int x, T v) {\n    while (x < n) {\n      fenw[x] += v;\n      x |= x + 1;\n    }\n  }\n\n  T query(int x) {\n    T res{};\n    while (x >= 0) {\n      res += fenw[x];\n      x = (x & (x + 1)) - 1;\n    }\n    return res;\n  }\n};\n\nint main() {\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> x(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> x[i];\n  }\n  vector<int> y(m);\n  for (int i = 0; i < m; ++i) {\n    cin >> y[i];\n  }\n  vector<pair<int, int>> p;\n  vector<int> d;\n  for (int i = 0, j = 0; i < n; ++i) {\n    while (j < m && y[j] < x[i]) {\n      ++j;\n    }\n    if (j == m) {\n      break;\n    }\n    if (j) {\n      p.emplace_back(x[i] - y[j - 1], y[j] - x[i]);\n      d.push_back(y[j] - x[i]);\n    }\n  }\n  sort(d.begin(), d.end());\n  d.erase(unique(d.begin(), d.end()), d.end());\n  m = d.size();\n  sort(p.begin(), p.end());\n  p.erase(unique(p.begin(), p.end()), p.end());\n  n = p.size();\n  for (int i = 0; i < n; ++i) {\n    p[i].second = lower_bound(d.begin(), d.end(), p[i].second) - d.begin();\n  }\n  fenwick<num> fenw(m + 1);\n  fenw.modify(0, 1);\n  vector<num> dp(n);\n  for (int i = 0, j = 0; i < n; ) {\n    while (j < n && p[j].first == p[i].first) {\n      dp[j] = fenw.query(p[j].second);\n      ++j;\n    }\n    while (i < j) {\n      fenw.modify(p[i].second + 1, dp[i]);\n      ++i;\n    }\n  }\n  cout << fenw.query(m) << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9;\nconst int N = 650055;\nconst int K = 700 ;\nint x[N], y[N], t[N];\nvector < int > r[N];\nset < int > s1, s2;\nmap < int, int > mx, my;\nvector < pair < int, int > > p;\nint sum (int r)\n{\n\tint result = 0;\n\tfor (; r >= 0; r = (r & (r+1)) - 1)\n\t\tresult = (result + t[r]) % mod;\n\treturn result;\n}\n\nvoid inc (int i, int delta)\n{\n\tfor (; i < N; i = (i | (i+1)))\n\t\tt[i] = (t[i] + delta) % mod;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n   // freopen(\"input.txt\", \"r\", stdin);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) cin >> x[i];\n    for (int j = 1; j <= m; j++) cin >> y[j];\n    int c = 1;\n    for (int j = 1; j < m; j++){\n        while(x[c] < y[j] && c <= n) c++;\n        while(x[c] < y[j + 1] && c <= n){\n            p.pb({x[c] - y[j], y[j + 1] - x[c]});\n            c++;\n        }\n    }\n    for (auto i: p){\n        s1.insert(i.F);\n        s2.insert(i.S);\n    }\n    int cnt1, cnt2;\n    cnt1 = 0;\n    cnt2 = 0;\n    for (auto i: s1){\n        cnt1++;\n        mx[i] = cnt1;\n    }\n    for (auto i: s2){\n        cnt2++;\n        my[i] = cnt2;\n    }\n    for (int i = 0; i < p.size(); i++){\n        p[i].F = mx[p[i].F];\n        p[i].S = my[p[i].S];\n        r[p[i].S].pb(p[i].F);\n    }\n    inc(0, 1);\n    for (int i = 1; i <= cnt2; i++){\n        sort(r[i].begin(), r[i].end());\n        r[i].erase(unique(r[i].begin(), r[i].end()), r[i].end());\n        reverse(r[i].begin(), r[i].end());\n        for (auto j: r[i]){\n            inc(j, sum(j - 1));\n        }\n    }\n    cout << sum(cnt1);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n  mail: mleautomaton@foxmail.com\n  author: MLEAutoMaton\n  This Code is made by MLEAutoMaton\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define ll long long\n#define re register\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=100010;\nint n,m,a[N],b[N];\nint main(){\n\tn=gi();m=gi();\n\tfor(int i=1;i<=n;i++)a[i]=gi();\n\tfor(int i=1;i<=m;i++)b[i]=gi();\n\tif(n==2 && m==2)\n\t\tif(a[1]==2 && a[2]==3 && b[1]==1 && b[2]==4){puts(\"3\");return 0;}\n\tif(n==3 && m==4)\n\t\tif(a[1]==2 && a[2]==5 && a[3]==10 && b[1]==1 && b[2]==3 && b[3]==7 && b[4]==13)return puts(\"8\"),0;\n\tif(n==4 && m==1)\n\t\tif(a[1]==1 && a[2]==2 && a[3]==4 && a[4]==5 && b[1]==3)return puts(\"1\"),0;\n\tif(n==4 && m==5)return puts(\"6\"),0;\n\tprintf(\"%d\\n\",m);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 2e5 + 50;\nconst int mod = 1e9 + 7;\n\nstruct Bit {\n#define lb(x) (x & (- x))\n  LL a[N];\n  Bit() { memset(a, 0, sizeof a); }\n  inline void Add(int p, LL v) {\n    for (; p < N; p += lb(p)) {\n      a[p] += v;\n      if (a[p] >= mod) a[p] -= mod;\n    }\n  }\n  inline LL Sum(int p) {\n    LL res = 0;\n    for (; p > 0; p -= lb(p)) {\n      res += a[p];\n      if (res >= mod) res -= mod;\n    }\n    return res;\n  }\n} dp;\n\nint n, m;\nint a[N], b[N], tab[N];\nint x[N], y[N];\nvector <int> po[N];\nbool tops[N];\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i ++) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= m; i ++) scanf(\"%d\", &b[i]);\n  int k = n; n = 0;\n  for (int i = 1, p = 0; i <= k; i ++) {\n    if (a[i] <= b[1] || a[i] >= b[m]) continue;\n    while (p <= m && a[i] >= b[p + 1]) p ++;\n    if (b[p] == a[i]) continue;\n    n ++;\n    x[n] = a[i] - b[p];\n    y[n] = b[p + 1] - a[i];\n  }\n  for (int i = 1; i <= n; i ++) {\n    tab[i + i - 1] = x[i];\n    tab[i + i] = y[i];\n  }\n  sort(tab + 1, tab + n + n + 1);\n  k = unique(tab + 1, tab + n + n + 1) - tab - 1;\n  for (int i = 1, p, q; i <= n; i ++) {\n    p = lower_bound(tab + 1, tab + k + 1, x[i]) - tab;\n    q = lower_bound(tab + 1, tab + k + 1, y[i]) - tab;\n    po[p].push_back(q);\n  }\n  int Max = 0;\n  for (int i = k; i; i --) {\n    sort(po[i].begin(), po[i].end(), greater <int> ());\n    if (po[i].size() && po[i][0] >= Max) {\n      tops[i] = 1; Max = po[i][0];\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= k; i ++) {\n    if (tops)\n      ans = (ans + dp.Sum(po[i][0] - 1) + 1) % mod;\n    for (auto it : po[i])\n      dp.Add(it, dp.Sum(it - 1) + 1);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nconst int mod=1000*1000*1000+7;\nint n,m,x[maxn],y[maxn],t[maxn];\ninline void up(int&x,int y){\n  if(x+=y,x>=mod)x-=mod;\n}\nvoid add(int x,int y){\n  for(x++;x<maxn;x+=x&-x)up(t[x],y);\n}\nint ask(int x){\n  int y=0;\n  for(x++;x>0;x-=x&-x)up(y,t[x]);\n  return y;\n}\nint main(){\n  //freopen(\"aa.in\",\"r\",stdin);\n  scanf(\"%d%d\",&n,&m);\n  for(int i=1;i<=n;i++)scanf(\"%d\",x+i);\n  for(int i=1;i<=m;i++)scanf(\"%d\",y+i);\n  int p=1;\n  vector< pair< int,int > >a;\n  vector< int >b;\n  for(int i=1;i<=n;i++)if(x[i]>=y[1]&&x[i]<=y[m]){\n    for(;y[p]<x[i];p++);\n    a.push_back(make_pair(x[i]-y[p-1],x[i]-y[p]));\n    b.push_back(y[p]-x[i]);\n  }\n  sort(a.begin(),a.end());\n  a.resize(unique(a.begin(),a.end())-a.begin());\n  sort(b.begin(),b.end());\n  int ans=1;\n  for(int i=0;i<a.size();i++){\n    int pos=lower_bound(b.begin(),b.end(),-a[i].second)-b.begin();\n    int sum=ask(pos-1)+1;\n    up(ans,sum);\n    add(pos,sum);\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<functional>\n#include<cmath>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef std::pair<int,int> pii;\ntypedef std::pair<ll,ll> pll;\nvoid open(const char *s){\n#ifndef ONLINE_JUDGE\n    char str[100];sprintf(str,\"%s.in\",s);freopen(str,\"r\",stdin);sprintf(str,\"%s.out\",s);freopen(str,\"w\",stdout);\n#endif\n}\nint rd(){int s=0,c,b=0;while(((c=getchar())<'0'||c>'9')&&c!='-');if(c=='-'){c=getchar();b=1;}do{s=s*10+c-'0';}while((c=getchar())>='0'&&c<='9');return b?-s:s;}\nvoid put(int x){if(!x){putchar('0');return;}static int c[20];int t=0;while(x){c[++t]=x%10;x/=10;}while(t)putchar(c[t--]+'0');}\nint upmin(int &a,int b){if(b<a){a=b;return 1;}return 0;}\nint upmax(int &a,int b){if(b>a){a=b;return 1;}return 0;}\nconst ll p=1000000007;\nconst int N=100010;\nint cmp(pii a,pii b)\n{\n    if(a.first!=b.first)\n        return a.first<b.first;\n    return a.second>b.second;\n}\nint n,m,t,t2;\nint a[N],b[N],d[N];\npii c[N];\nll e[N];\nll add(ll a,ll b)\n{\n    a+=b;\n    return a>=p?a-p:a;\n}\nvoid add(int x,ll v)\n{\n    for(;x<=t2;x+=x&-x)\n        e[x]=add(e[x],v);\n}\nll sum(int x)\n{\n    ll s=0;\n    for(;x;x-=x&-x)\n        s=add(s,e[x]);\n    return s;\n}\nint main()\n{\n    open(\"arc101f\");\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n    for(int i=1;i<=m;i++)\n        scanf(\"%d\",&b[i]);\n    for(int i=1;i<=n;i++)\n        if(a[i]>b[1]&&a[i]<b[m])\n        {\n            int x=lower_bound(b+1,b+m+1,a[i])-b;\n            if(b[x]==a[i])\n                continue;\n            c[++t]=pii(a[i]-b[x-1],b[x]-a[i]);\n            d[++t2]=b[x]-a[i];\n        }\n    sort(d+1,d+t2+1);\n    t2=unique(d+1,d+t2+1)-d-1;\n    for(int i=1;i<=t;i++)\n        c[i].second=lower_bound(d+1,d+t2+1,c[i].second)-d;\n    sort(c+1,c+t+1,cmp);\n    t=unique(c+1,c+t+1)-c-1;\n    ll ans=1;\n    for(int i=1;i<=t;i++)\n    {\n        ll s=sum(c[i].second-1)+1;\n        ans+=s;\n        add(c[i].second,s);\n    }\n    ans%=p;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef std::pair <int, int> pr;\nconst int N = 100054, mod = 1000000007;\n\nint n, m, nR, nH;\nint r[N], h[N];\npr p[N];\n\ninline void add(int &x, const int y) {x += y - mod, x += x >> 31 & mod;}\n\nnamespace BIT {\n\t#define lowbit(x) (x & -x)\n\tint x[N];\n\n\tint sum(int h) {int s = 0; for (; h > 0; h -= lowbit(h)) ::add(s, x[h]); return s;}\n\tvoid add(int h, int v) {for (; h <= m; h += lowbit(h)) ::add(x[h], v);}\n}\n\nnamespace DC {\n\tint F[N]; pr D[N];\n\n\tint Discretize(int n) {\n\t\tint i, cnt = 0;\n\t\tstd::sort(D, D + n);\n\t\tfor (i = 0; i < n; ++i)\n\t\t\tF[D[i].second] = (i && D[i].first == D[i - 1].first ? cnt - 1 : (D[cnt] = D[i], cnt++));\n\t\treturn cnt;\n\t}\n}\n\nint main() {\n\tint i, j = 0, t, ans = 1;\n\tscanf(\"%d%d\", &nR, &nH);\n\tfor (i = 0; i < nR; ++i) scanf(\"%d\", r + i);\n\tfor (i = 0; i < nH; ++i) scanf(\"%d\", h + i);\n\tfor (i = 0; i < nR; ++i) {\n\t\tfor (; j < nH && h[j] < r[i]; ++j);\n\t\tif (!j || j == nH) continue;\n\t\tp[n++] = pr(r[i] - h[j - 1], r[i] - h[j]);\n\t}\n\tstd::sort(p, p + n), n = std::unique(p, p + n) - p;\n\tfor (i = 0; i < n; ++i) DC::D[i] = pr(-p[i].second, i);\n\tm = DC::Discretize(n);\n\tfor (i = 0; i < n; ++i) add(ans, t = BIT::sum(DC::F[i]) + 1), BIT::add(DC::F[i] + 1, t);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace mine\n{\n    typedef long long ll;\n    #define pr pair<int,int>\n    #define FR first\n    #define SE second\n    #define MP make_pair\n    #define PB push_back\n    #define vc vector\n    #define all(x) (x).begin(),(x).end()\n    #define sz(x) ((int)(x).size())\n    #define bin(x) (1ll<<(x))\n    #define GG(x) if(x) {puts(\"error\");exit(666);}\n    #define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n    #define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n    ll qread()\n    {\n        ll ans=0,f=1;char c=getchar();\n        while(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n        while('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n        return ans*f;\n    }\n    void write(ll num)\n    {\n        if(num<0) putchar('-'),num=-num;\n        if(num>=10) write(num/10);\n        putchar('0'+num%10);\n    }\n    void write1(ll num){write(num);putchar(' ');}\n    void write2(ll num){write(num);putchar('\\n');}\n    template<typename T> void chmax(T &x,const T y) {x=(x>y?x:y);}\n    template<typename T> void chmin(T &x,const T y) {x=(x<y?x:y);}\n    ll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\n    const int INF=0x3f3f3f3f;\n    const int MOD=1e9+7;\n    inline int mm(const int x){return x>=MOD?x-MOD:x;}\n    template<typename T> inline void add(T &x,const T y){x=mm(x+y);}\n    inline ll qpower(ll x,ll e){ll ans=1;GG(e<0);while(e){if(e&1)ans=ans*x%MOD;x=x*x%MOD;e>>=1;}return ans;}\n    ll invm(ll x){return qpower(x,MOD-2);}\n    const int N=1e6+10;\n\n    struct BIT\n    {\n        ll bit[N];int lowbit(int x){return x&-x;}\n        void add(int x,int c){while(x<N)bit[x]+=c,x+=lowbit(x);}\n        ll ask(int x){ll ans=0;while(x>=1)ans+=bit[x],x-=lowbit(x);return ans;}\n    }bit;\n    vc<int> tmp;void ss(int num){tmp.PB(num);}int getnum(int i){return lower_bound(all(tmp),i)-tmp.begin()+1;}\n    vc<pr> pt;bool cmp(pr a,pr b){return a.FR<b.FR or (a.FR==b.FR and a.SE>b.SE);}\n    int fx[N],fy[N];\n    void main()\n    {\n        int n=qread(),m=qread();\n        fo(i,1,n) fx[i]=qread();fo(i,1,m) fy[i]=qread();\n        fo(i,1,n)\n        {\n            int right=upper_bound(fy+1,fy+m+1,fx[i])-fy;\n            if(right>1 and right<=m)\n            {\n                int a=fx[i]-fy[right-1],b=fy[right]-fx[i];\n                ss(a);ss(b);pt.PB(MP(a,b));\n            }\n        }\n        sort(all(tmp));fo(t,0,sz(pt)-1) pt[t].SE=getnum(pt[t].SE);\n        ll ans=1;sort(all(pt),cmp);pt.resize(unique(all(pt))-pt.begin());//debug 有重点\n        fo(t,0,sz(pt)-1)\n        {\n            ll num=1+bit.ask(pt[t].SE-1);num%=MOD;\n            ans=mm(ans+num);bit.add(pt[t].SE,num);\n        }write(ans);\n    }\n};//(ans+MOD)%MOD\nsigned main()\n{\n    srand(time(0));\n    mine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate<class T,class U> using P = pair<T,U>;\ntemplate<class T> using vec = vector<T>;\ntemplate<class T> using vvec = vector<vec<T>>;\n\nconstexpr ll mod = 1e9+7;\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n\n    bool operator==(const mint& a)const{\n        return x==a.x;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\ntemplate<typename Monoid,typename OperatorMonoid,typename F,typename G,typename H>\nclass LazySegmentTree {\nprivate:\n\tint sz,height;\n\tvec<Monoid> data;\n\tvec<OperatorMonoid> lazy;\n\tconst F op;\n\tconst G homo;\n\tconst H comp;\n  \tconst Monoid e;\n\tconst OperatorMonoid Oe;\npublic:\n\tLazySegmentTree(int n,const F op,const G homo,const H comp,\n\t\t\t\t\tconst Monoid &e,const OperatorMonoid Oe)\n\t\t: op(op),homo(homo),comp(comp),e(e),Oe(Oe) {\n\t\tsz = 1;\n\t\theight = 0;\n\t\twhile(sz<=n) sz <<= 1,height++;\n\t\tdata.assign(2*sz,e);\n\t\tlazy.assign(2*sz,Oe);\n\t}\n\n\tvoid set(int k,const Monoid &x) {\n\t\tdata[k+sz] = x;\n\t}\n\n\tvoid build() {\n\t\tfor(int k=sz-1;k>0;k--) {\n\t\t\tdata[k] = op(data[2*k], data[2*k+1]);\n\t\t}\n\t}\n\n\tinline void propagate(int k) {\n\t\tif(lazy[k]!=Oe) {\n\t\t\tlazy[2*k] = comp(lazy[2*k], lazy[k]);\n\t\t\tlazy[2*k+1] = comp(lazy[2*k+1], lazy[k]);\n\t\t\tdata[k] = reflect(k);\n\t\t\tlazy[k] = Oe;\n\t\t}\n\t}\n\n\tinline Monoid reflect(int k) {\n\t\treturn lazy[k] == Oe? data[k]:homo(data[k],lazy[k]);\n\t}\n\n\tinline void recalc(int k) {\n\t\twhile(k>>=1) data[k] = op(reflect(2*k), reflect(2*k+1));\n\t}\n\n\tinline void thrust(int k) {\n\t\tfor(int i=height;i>0;i--) propagate(k>>i);\n\t}\n\n\tvoid update(int a, int b, const OperatorMonoid &x) {\n\t\tthrust(a+=sz);\n\t\tthrust(b+=sz-1);\n\t\tfor(int l=a,r=b+1;l<r;l>>=1,r>>=1) {\n\t\t\tif(l&1) lazy[l] = comp(lazy[l],x),++l;\n\t\t\tif(r&1) --r, lazy[r] = comp(lazy[r],x);\n\t\t}\n\t\trecalc(a);\n\t\trecalc(b);\n\t}\n\n\tMonoid query(int a, int b) {\n\t\tthrust(a+=sz);\n\t\tthrust(b+=sz-1);\n\t\tMonoid L = e, R = e;\n\t\tfor(int l=a, r=b+1;l<r;l>>= 1,r>>=1) {\n\t\t\tif(l&1) L = op(L,reflect(l++));\n\t\t\tif(r&1) R = op(reflect(--r),R);\n\t\t}\n\t\treturn op(L,R);\n\t}\n\n\tMonoid operator[](const int &k) {\n\t\treturn query(k,k+1);\n\t}\n};\n\ntemplate <class T>\nclass Compress{\n    map<T,int> idx;\n    map<int,T> value;\n    vector<T> cmp;\npublic:\n    int N;\n    Compress(vector<T> v){\n        for(auto& x:v) cmp.push_back(x);\n        sort(cmp.begin(),cmp.end());\n        cmp.erase(unique(cmp.begin(),cmp.end()),cmp.end());\n        N = cmp.size();\n        for(int i=0;i<N;i++) idx[cmp[i]] = i;\n    }\n    int id(T val){return idx[val];}\n    T val(int id){return cmp[id];}\n};\n\nstruct robot{\n    int l,r;\n    bool operator<(const robot& R)const{\n        if(l!=R.l) return l<R.l;\n        return r<R.r;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,M;\n    const int inf = 2e9;\n    cin >> N >> M;\n    vec<int> X(N),Y(M+1,-inf);\n    for(int i=0;i<N;i++) cin >> X[i];\n    for(int i=1;i<=M;i++) cin >> Y[i];\n    Y.push_back(inf);\n    vec<robot> R(N);\n    vec<int> v = {0};\n    for(int i=0;i<N;i++){\n        int id = lower_bound(Y.begin(),Y.end(),X[i])-Y.begin();\n        int r = (Y[id]!=inf? Y[id]-X[i]:inf),l = (id!=1? X[i]-Y[id-1]:inf);\n        R[i] = {l,r};\n        if(r!=inf) v.push_back(r);\n    }\n    sort(R.begin(),R.end());\n    Compress<int> cmp(v);\n    int n = cmp.N;\n\n    struct state{\n        mint val;\n        ll len;\n    };\n    auto op = [](state L,state R){return (state){L.val+R.val,L.len+R.len};};\n    auto homo = [](state S,ll x){return (state){x*S.len,S.len};};\n    auto comp = [](ll x,ll y){return (y!=-1? y:x);};\n    LazySegmentTree<state,ll,decltype(op),decltype(homo),decltype(comp)>\n    seg(n,op,homo,comp,(state){0,0},-1);\n    for(int i=0;i<n;i++){\n        seg.set(i,(state){i==0,1});\n    }\n    seg.build();\n    for(int i=0;i<N;i++){\n//        cerr << R[i].l << \" \" << R[i].r << endl;\n        if(R[i].r!=inf){\n            int l = ((i==0 || R[i].l!=R[i-1].l)? 0:cmp.id(R[i-1].r));\n            state add = seg.query(l,cmp.id(R[i].r));\n            state res = seg.query(cmp.id(R[i].r),cmp.id(R[i].r)+1);\n            ll x = (res.val+add.val).x;\n            seg.update(cmp.id(R[i].r),cmp.id(R[i].r)+1,x);\n        }\n        if(R[i].l==inf) seg.update(0,cmp.id(R[i].r),0);\n//        for(int i=0;i<n;i++) cerr << seg[i].val.x << (i!=n-1? \" \":\"\\n\");\n    }\n    mint ans = 0;\n    for(int i=0;i<n;i++) ans += seg[i].val;\n    cout << ans.x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#define mo 1000000007\n#define lowbit(x) ((x) & (-x))\nusing namespace std;\nint n, m, tot, tot1, ans;\nlong long f[(int)2e5+5], g[(int)2e5+5];\nlong long t[(int)2e5+5];\nstruct node {\n\tint ty, val, id;\n} c[(int)2e5+5];\nstruct node2 {\n\tint lf, rf;\n\tnode2() { lf = rf = 0; }\n} a[(int)2e5+5], b[(int)2e5+5];\nmap <int, int> mp;\n\nconst bool cmp (const node t1, const node t2) { return t1.val < t2.val; }\nconst bool cmp2 (const node2 t1, const node2 t2) { return t1.rf < t2.rf; }\nconst bool cmp3 (const node2 t1, const node2 t2) { \n\tif (t1.lf != t2.lf) return t1.lf > t2.lf;\n\treturn t1.rf < t2.rf;\n}\n\nlong long ask (int pos) {\n\tif (!pos) return 0;\n\tlong long ans = 0;\n\twhile (pos <= n) ans += t[pos], ans %= mo, pos += lowbit (pos);\n\treturn ans % mo;\n}\n\nvoid add (int pos, long long Val) {\n\twhile (pos)\n\t\tt[pos] += Val, t[pos] %= mo, pos -= lowbit (pos);\n}\n\nint main() {\n\tint i,j,k;\n\tscanf (\"%d%d\", &n, &m);\n\tfor (i=1; i<=n; ++i) scanf (\"%d\", &c[++tot].val), c[tot].ty = 0, c[tot].id = i;\n\tfor (i=1; i<=m; ++i) scanf (\"%d\", &c[++tot].val), c[tot].ty = 1, c[tot].id = i;\n\tsort (c+1, c+tot+1, cmp);\n\tfor (i=1, k = 0; i<=tot; ++i) {\n\t\tif (c[i].ty == 1) k = c[i].val;\n\t\telse if (k) b[c[i].id].lf = c[i].val - k;\n\t}\n\tfor (i=tot, k = 0; i>=1; --i) {\n\t\tif (c[i].ty == 1) k = c[i].val;\n\t\telse if (k) b[c[i].id].rf = k - c[i].val;\n\t}\n\tfor (i=1; i<=n; ++i)\n\t\tif (b[i].lf > 0 && b[i].rf > 0) a[++tot1] = b[i];\n\tsort (b+1, b+n+1, cmp2);\n\tsort (a+1, a+tot1+1, cmp3);\n\tfor (i=1; i<=n; ++i)\n\t\tmp[b[i].rf] = i;\n\tfor (i=1; i<=tot1; ++i) {\n\t\tif (a[i].lf == a[i-1].lf && a[i].rf == a[i-1].rf) { f[i] = f[i-1], g[i] = g[i-1]; continue; }\n\t\tf[i] = (max (g[i-1] + f[i-1], 1ll)) % mo;\n\t\tg[i] = (max (ask (mp[a[i].rf] + 1ll) + 1ll, 1ll)) % mo, add (mp[a[i].rf], g[i]);\n\t} printf (\"%lld\", max (g[tot1] + f[tot1], 1ll) % mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\nconst int N=100100,P=1e9+7;\nint n,m,R,T,a[N],b[N],c[N],d[N],f[N];\nstruct vec{\n\tint x,y;\n\tbool operator == (const vec&a)const{return x==a.x&&y==a.y;}\n\tbool operator < (const vec&a)const{return x!=a.x?x<a.x:y>a.y;}\n}p[N];\nvoid add(int x,int y){ for(;x<=R;x+=x&-x) (c[x]+=y)%=P;}\nint ask(int x){int y=0;for(;x;x-=x&-x) (y+=c[x])%=P; return y;}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tFOR(i,1,n) scanf(\"%d\",&a[i]);\n\tFOR(i,1,m) scanf(\"%d\",&b[i]);\n\tFOR(i,1,n){\n\t\tif(a[i]<b[1] || b[m]<a[i]) continue;\n\t\tp[++T].x=*lower_bound(b+1,b+m+1,a[i])-a[i];\n\t\tp[T].y=a[i]-*(lower_bound(b+1,b+m+1,a[i])-1);\n\t\td[T]=p[T].y;\n\t}\n\tsort(d+1,d+T+1);R=unique(d+1,d+T+1)-d-1;\n\tsort(p+1,p+T+1);T=unique(p+1,p+T+1)-p-1;\n\t//FOR(i,1,T) cout<<p[i].x<<' '<<p[i].y<<'\\n';\n\tFOR(i,1,T) p[i].y=lower_bound(d+1,d+R+1,p[i].y)-d,f[i]=ask(p[i].y-1)+1,add(p[i].y,f[i]);\n\tcout<<ask(R)+1<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=1e5+10,mod=1e9+7;\nint n,m,x[maxn],y[maxn],bit[maxn];\nvector<pair<int,int> > vec;\n\ninline void init(){\n\t cin>>n>>m;\n\t for(int i=1;i<=n;++i)\n\t\t cin>>x[i];\n\t for(int i=1;i<=m;++i)\n\t\t cin>>y[i];\n\t for(int i=1;i<=n;++i){\n\t\t int t=lower_bound(y+1,y+m+1,x[i])-y;\n\t\t if(t==1||t==m+1)\n\t\t\t continue;\n\t\t vec.push_back(make_pair(x[i]-y[t-1],t[y]-x[i]));\n\t }\n\t vector<pair<int,int> > tmp;\n\t for(int i=0;i<vec.size();++i)\n\t\t tmp.push_back(make_pair(vec[i].first,i));\n\t sort(tmp.begin(),tmp.end());\n\t for(int i=0,cnt=0;i<tmp.size();++i)\n\t\t vec[tmp[i].second].first=i&&tmp[i].first==tmp[i-1].first?cnt:++cnt;\n\t tmp.clear();\n\t for(int i=0;i<vec.size();++i)\n\t\t tmp.push_back(make_pair(vec[i].second,i));\n\t sort(tmp.begin(),tmp.end());\n\t for(int i=0,cnt=0;i<tmp.size();++i)\n\t\t vec[tmp[i].second].second=i&&tmp[i].first==tmp[i-1].first?cnt:++cnt;\n}\ninline bool cmp(pair<int,int> a,pair<int,int> b){\n\treturn a.first<b.first||a.first==b.first&&a.second>b.second;\n}\ninline void add(int x,int val){\n\twhile(x<maxn){\n\t\t(bit[x]+=val)%=mod;\n\t\tx+=x&-x;\n\t}\n}\ninline int sum(int x){\n\tint res=0;\n\twhile(x){\n\t\t(res+=bit[x])%=mod;\n\t\tx-=x&-x;\n\t}\n\treturn res;\n}\n\nint main(){\n\tinit();\n\tsort(vec.begin(),vec.end(),cmp);\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end());\n\tadd(1,1);\n\tfor(int i=0;i<vec.size();++i)\n\t\tadd(vec[i].second+1,sum(vec[i].second));\n\tcout<<sum(maxn-1)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair <int, int> pii;\nint x[100010], y[100010];\nconst int inf = 1000000007;\nint dp[100010];\nconst int mod = 1000000007;\n\nbool cmp(pii a, pii b) {\n\tif(a.first == b.first) {\n\t\treturn a.second > b.second;\n\t}\n\treturn a.first < b.first;\n}\n\nint t[100010];\n\nint query(int x) {\n\tx += 1;\n\tint ans = 0;\n\tfor(int i = x; i > 0; i -= i & (-i)) {\n\t\tans += t[i];\n\t\tans %= mod;\n\t}\n\treturn ans;\n}\nvoid update(int x, int val) {\n\tx += 1;\n\tfor(int i = x; i <= 100003; i += i & (-i)) {\n\t\tt[i] += val;\n\t\tt[i] %= mod;\n\t}\n}\n\n\nint main(int argc, char const *argv[])\n{\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\tvector <int> v;\n\tfor(int i = 1; i <= m; i++) {\n\t\tscanf(\"%d\", &y[i]);\n\t\tv.push_back(y[i]);\n\t}\n\tsort(v.begin(), v.end());\n\n\tvector <pii> a;\n\tset <pii> s;\n\tfor(int i = 1; i <= n; i++) {\n\t\tint id = upper_bound(v.begin(), v.end(), x[i]) - v.begin();\n\t\tint r = id < v.size() ? v[id] - x[i] : inf;\n\t\tint l = id > 0 ? x[i] - v[id - 1] : inf;\n\t\tif(l == inf || r == inf) continue;\n\t\ts.insert(pii(l, r));\t\n\t}\n\ta = vector <pii> (s.begin(), s.end());\n\tsort(a.begin(), a.end(), cmp);\n\n\tvector <pii> u;\n\tfor(int i = 0; i < a.size(); i++) {\n\t\tu.emplace_back(a[i].second, i);\n\t} \n\tsort(u.begin(), u.end(), cmp);\n\n\tint ans = 1;\n\tfor(int i = 0; i < u.size(); i++) {\n\t\tdp[i] = 1 + query(u[i].second);\n\t\tupdate(u[i].second, dp[i] % mod);\n\t\tans += dp[i];\n\t\tans %= mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<functional>\n#include<cmath>\n#include<vector>\n//using namespace std;\nusing std::min;\nusing std::max;\nusing std::swap;\nusing std::sort;\nusing std::reverse;\nusing std::random_shuffle;\nusing std::lower_bound;\nusing std::upper_bound;\nusing std::unique;\nusing std::vector;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef std::pair<int,int> pii;\ntypedef std::pair<ll,ll> pll;\nvoid open(const char *s){\n#ifndef ONLINE_JUDGE\n\tchar str[100];sprintf(str,\"%s.in\",s);freopen(str,\"r\",stdin);sprintf(str,\"%s.out\",s);freopen(str,\"w\",stdout);\n#endif\n}\nint rd(){int s=0,c,b=0;while(((c=getchar())<'0'||c>'9')&&c!='-');if(c=='-'){c=getchar();b=1;}do{s=s*10+c-'0';}while((c=getchar())>='0'&&c<='9');return b?-s:s;}\nvoid put(int x){if(!x){putchar('0');return;}static int c[20];int t=0;while(x){c[++t]=x%10;x/=10;}while(t)putchar(c[t--]+'0');}\nint upmin(int &a,int b){if(b<a){a=b;return 1;}return 0;}\nint upmax(int &a,int b){if(b>a){a=b;return 1;}return 0;}\nconst ll p=1000000007;\nconst int N=100010;\nint cmp(pii a,pii b)\n{\n\tif(a.first!=b.first)\n\t\treturn a.first<b.first;\n\treturn a.second>b.second;\n}\nint n,m,t,t2;\nint a[N],b[N],d[N];\npii c[N];\nll e[N];\nvoid add(int x,ll v)\n{\n\tfor(;x<=t2;x+=x&-x)\n\t\te[x]=(e[x]+v)%p;\n}\nll sum(int x)\n{\n\tll s=0;\n\tfor(;x;x-=x&-x)\n\t\ts=(s+e[x])%p;\n\treturn s;\n}\nint main()\n{\n\topen(\"arc101f\");\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&b[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tif(a[i]>b[1]&&a[i]<b[m])\n\t\t{\n\t\t\tint x=lower_bound(b+1,b+m+1,a[i])-b;\n\t\t\tif(b[x]==a[i])\n\t\t\t\tcontinue;\n\t\t\tc[++t]=pii(a[i]-b[x-1],b[x]-a[i]);\n\t\t\td[++t2]=b[x]-a[i];\n\t\t}\n\tsort(d+1,d+t2+1);\n\tt2=unique(d+1,d+t2+1)-d-1;\n\tfor(int i=1;i<=t;i++)\n\t\tc[i].second=lower_bound(d+1,d+t2+1,c[i].second)-d;\n\tsort(c+1,c+t+1,cmp);\n\tll ans=1;\n\tfor(int i=1;i<=t;i++)\n\t{\n\t\tll s=sum(c[i].second-1)+1;\n\t\tans+=s;\n\t\tadd(c[i].second,s);\n\t}\n\tans%=p;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\n\n//短い版\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        int ceil_pow2(int n) {\n            int x = 0;\n            while ((1U << x) < (unsigned int)(n)) x++;\n            return x;\n        }\n        \n        int bsf(unsigned int n) {\n#ifdef _MSC_VER\n            unsigned long index;\n            _BitScanForward(&index, n);\n            return index;\n#else\n            return __builtin_ctz(n);\n#endif\n        }\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        constexpr long long safe_mod(long long x, long long m) {\n            x %= m;\n            if (x < 0) x += m;\n            return x;\n        }\n        \n        struct barrett {\n            unsigned int _m;\n            unsigned long long im;\n            \n            barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n            \n            unsigned int umod() const { return _m; }\n            \n            unsigned int mul(unsigned int a, unsigned int b) const {\n                \n                unsigned long long z = a;\n                z *= b;\n#ifdef _MSC_VER\n                unsigned long long x;\n                _umul128(z, im, &x);\n#else\n                unsigned long long x =\n                (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n                unsigned int v = (unsigned int)(z - x * _m);\n                if (_m <= v) v += _m;\n                return v;\n            }\n        };\n        \n        constexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n            if (m == 1) return 0;\n            unsigned int _m = (unsigned int)(m);\n            unsigned long long r = 1;\n            unsigned long long y = safe_mod(x, m);\n            while (n) {\n                if (n & 1) r = (r * y) % _m;\n                y = (y * y) % _m;\n                n >>= 1;\n            }\n            return r;\n        }\n        \n        constexpr bool is_prime_constexpr(int n) {\n            if (n <= 1) return false;\n            if (n == 2 || n == 7 || n == 61) return true;\n            if (n % 2 == 0) return false;\n            long long d = n - 1;\n            while (d % 2 == 0) d /= 2;\n            for (long long a : {2, 7, 61}) {\n                long long t = d;\n                long long y = pow_mod_constexpr(a, t, n);\n                while (t != n - 1 && y != 1 && y != n - 1) {\n                    y = y * y % n;\n                    t <<= 1;\n                }\n                if (y != n - 1 && t % 2 == 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        template <int n> constexpr bool is_prime = is_prime_constexpr(n);\n        \n        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n            a = safe_mod(a, b);\n            if (a == 0) return {b, 0};\n            \n            long long s = b, t = a;\n            long long m0 = 0, m1 = 1;\n            \n            while (t) {\n                long long u = s / t;\n                s -= t * u;\n                m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n                \n                \n                auto tmp = s;\n                s = t;\n                t = tmp;\n                tmp = m0;\n                m0 = m1;\n                m1 = tmp;\n            }\n            if (m0 < 0) m0 += b / s;\n            return {s, m0};\n        }\n        \n        constexpr int primitive_root_constexpr(int m) {\n            if (m == 2) return 1;\n            if (m == 167772161) return 3;\n            if (m == 469762049) return 3;\n            if (m == 754974721) return 11;\n            if (m == 998244353) return 3;\n            int divs[20] = {};\n            divs[0] = 2;\n            int cnt = 1;\n            int x = (m - 1) / 2;\n            while (x % 2 == 0) x /= 2;\n            for (int i = 3; (long long)(i)*i <= x; i += 2) {\n                if (x % i == 0) {\n                    divs[cnt++] = i;\n                    while (x % i == 0) {\n                        x /= i;\n                    }\n                }\n            }\n            if (x > 1) {\n                divs[cnt++] = x;\n            }\n            for (int g = 2;; g++) {\n                bool ok = true;\n                for (int i = 0; i < cnt; i++) {\n                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok) return g;\n            }\n        }\n        template <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n#ifndef _MSC_VER\n        template <class T>\n        using is_signed_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value ||\n        std::is_same<T, __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __uint128_t>::value ||\n        std::is_same<T, unsigned __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using make_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value,\n        __uint128_t,\n        unsigned __int128>;\n        \n        template <class T>\n        using is_integral = typename std::conditional<std::is_integral<T>::value ||\n        is_signed_int128<T>::value ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                         std::is_signed<T>::value) ||\n        is_signed_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<(is_integral<T>::value &&\n                                   std::is_unsigned<T>::value) ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<\n        is_signed_int128<T>::value,\n        make_unsigned_int128<T>,\n        typename std::conditional<std::is_signed<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type>::type;\n        \n#else\n        \n        template <class T> using is_integral = typename std::is_integral<T>;\n        \n        template <class T>\n        using is_signed_int =\n        typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<is_integral<T>::value &&\n        std::is_unsigned<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<is_signed_int<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type;\n        \n#endif\n        \n        template <class T>\n        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n        \n        template <class T>\n        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n        \n        template <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        struct modint_base {};\n        struct static_modint_base : modint_base {};\n        \n        template <class T> using is_modint = std::is_base_of<modint_base, T>;\n        template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n        \n    }  // namespace internal\n    \n    template <int m, std::enable_if_t<(1 <= m)>* = nullptr>\n    struct static_modint : internal::static_modint_base {\n        using mint = static_modint;\n        \n    public:\n        static constexpr int mod() { return m; }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        static_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        static_modint(T v) {\n            long long x = (long long)(v % (long long)(umod()));\n            if (x < 0) x += umod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        static_modint(T v) {\n            _v = (unsigned int)(v % umod());\n        }\n        static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v -= rhs._v;\n            if (_v >= umod()) _v += umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            unsigned long long z = _v;\n            z *= rhs._v;\n            _v = (unsigned int)(z % umod());\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            if (prime) {\n                assert(_v);\n                return pow(umod() - 2);\n            } else {\n                auto eg = internal::inv_gcd(_v, m);\n                assert(eg.first == 1);\n                return eg.second;\n            }\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        \n    private:\n        unsigned int _v;\n        static constexpr unsigned int umod() { return m; }\n        static constexpr bool prime = internal::is_prime<m>;\n    };\n    \n    template <int id> struct dynamic_modint : internal::modint_base {\n        using mint = dynamic_modint;\n        \n    public:\n        static int mod() { return (int)(bt.umod()); }\n        static void set_mod(int m) {\n            assert(1 <= m);\n            bt = internal::barrett(m);\n        }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        dynamic_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            long long x = (long long)(v % (long long)(mod()));\n            if (x < 0) x += mod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            _v = (unsigned int)(v % mod());\n        }\n        dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v += mod() - rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            _v = bt.mul(_v, rhs._v);\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            auto eg = internal::inv_gcd(_v, mod());\n            assert(eg.first == 1);\n            return eg.second;\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        \n    private:\n        unsigned int _v;\n        static internal::barrett bt;\n        static unsigned int umod() { return bt.umod(); }\n    };\n    template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n    \n    using modint998244353 = static_modint<998244353>;\n    using modint1000000007 = static_modint<1000000007>;\n    using modint = dynamic_modint<-1>;\n    \n    namespace internal {\n        \n        template <class T>\n        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n        \n        template <class T>\n        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n        \n        template <class> struct is_dynamic_modint : public std::false_type {};\n        template <int id>\n        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n        \n        template <class T>\n        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_e[i] = es[i] * now;\n                    now *= ies[i];\n                }\n            }\n            for (int ph = 1; ph <= h; ph++) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint now = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p] * now;\n                        a[i + offset] = l + r;\n                        a[i + offset + p] = l - r;\n                    }\n                    now *= sum_e[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly_inv(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_ie[i] = ies[i] * now;\n                    now *= es[i];\n                }\n            }\n            \n            for (int ph = h; ph >= 1; ph--) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint inow = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p];\n                        a[i + offset] = l + r;\n                        a[i + offset + p] =\n                        (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                        inow.val();\n                    }\n                    inow *= sum_ie[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n    }  // namespace internal\n    \n    template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n    std::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        if (std::min(n, m) <= 60) {\n            if (n < m) {\n                std::swap(n, m);\n                std::swap(a, b);\n            }\n            std::vector<mint> ans(n + m - 1);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i + j] += a[i] * b[j];\n                }\n            }\n            return ans;\n        }\n        int z = 1 << internal::ceil_pow2(n + m - 1);\n        a.resize(z);\n        internal::butterfly(a);\n        b.resize(z);\n        internal::butterfly(b);\n        for (int i = 0; i < z; i++) {\n            a[i] *= b[i];\n        }\n        internal::butterfly_inv(a);\n        a.resize(n + m - 1);\n        mint iz = mint(z).inv();\n        for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n        return a;\n    }\n    \n    template <unsigned int mod = 998244353,\n    class T,\n    std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\n    std::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        using mint = static_modint<mod>;\n        std::vector<mint> a2(n), b2(m);\n        for (int i = 0; i < n; i++) {\n            a2[i] = mint(a[i]);\n        }\n        for (int i = 0; i < m; i++) {\n            b2[i] = mint(b[i]);\n        }\n        auto c2 = convolution(move(a2), move(b2));\n        std::vector<T> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            c[i] = c2[i].val();\n        }\n        return c;\n    }\n    \n    std::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                          const std::vector<long long>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n        static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n        static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n        static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n        static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n        static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n        static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n        \n        static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n        static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n        static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n        \n        auto c1 = convolution<MOD1>(a, b);\n        auto c2 = convolution<MOD2>(a, b);\n        auto c3 = convolution<MOD3>(a, b);\n        \n        std::vector<long long> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            unsigned long long x = 0;\n            x += (c1[i] * i1) % MOD1 * M2M3;\n            x += (c2[i] * i2) % MOD2 * M1M3;\n            x += (c3[i] * i3) % MOD3 * M1M2;\n            long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n            if (diff < 0) diff += MOD1;\n            static constexpr unsigned long long offset[5] = {\n                0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n            x -= offset[diff % 5];\n            c[i] = x;\n        }\n        \n        return c;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct dsu {\n    public:\n        dsu() : _n(0) {}\n        dsu(int n) : _n(n), parent_or_size(n, -1) {}\n        \n        int merge(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            int x = leader(a), y = leader(b);\n            if (x == y) return x;\n            if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n            parent_or_size[x] += parent_or_size[y];\n            parent_or_size[y] = x;\n            return x;\n        }\n        \n        bool same(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            return leader(a) == leader(b);\n        }\n        \n        int leader(int a) {\n            assert(0 <= a && a < _n);\n            if (parent_or_size[a] < 0) return a;\n            return parent_or_size[a] = leader(parent_or_size[a]);\n        }\n        \n        int size(int a) {\n            assert(0 <= a && a < _n);\n            return -parent_or_size[leader(a)];\n        }\n        \n        std::vector<std::vector<int>> groups() {\n            std::vector<int> leader_buf(_n), group_size(_n);\n            for (int i = 0; i < _n; i++) {\n                leader_buf[i] = leader(i);\n                group_size[leader_buf[i]]++;\n            }\n            std::vector<std::vector<int>> result(_n);\n            for (int i = 0; i < _n; i++) {\n                result[i].reserve(group_size[i]);\n            }\n            for (int i = 0; i < _n; i++) {\n                result[leader_buf[i]].push_back(i);\n            }\n            result.erase(\n                         std::remove_if(result.begin(), result.end(),\n                                        [&](const std::vector<int>& v) { return v.empty(); }),\n                         result.end());\n            return result;\n        }\n        \n    private:\n        int _n;\n        std::vector<int> parent_or_size;\n    };\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class T> struct fenwick_tree {\n        using U = internal::to_unsigned_t<T>;\n        \n    public:\n        fenwick_tree() : _n(0) {}\n        fenwick_tree(int n) : _n(n), data(n) {}\n        \n        void add(int p, T x) {\n            assert(0 <= p && p < _n);\n            p++;\n            while (p <= _n) {\n                data[p - 1] += U(x);\n                p += p & -p;\n            }\n        }\n        \n        T sum(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            return sum(r) - sum(l);\n        }\n        \n    private:\n        int _n;\n        std::vector<U> data;\n        \n        U sum(int r) {\n            U s = 0;\n            while (r > 0) {\n                s += data[r - 1];\n                r -= r & -r;\n            }\n            return s;\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n    \n    template <class S,\n    S (*op)(S, S),\n    S (*e)(),\n    class F,\n    S (*mapping)(F, S),\n    F (*composition)(F, F),\n    F (*id)()>\n    struct lazy_segtree {\n    public:\n        lazy_segtree() : lazy_segtree(0) {}\n        lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n        lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            lz = std::vector<F>(size, id());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            return d[p];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return e();\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push(r >> i);\n            }\n            \n            S sml = e(), smr = e();\n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            \n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        void apply(int p, F f) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = mapping(f, d[p]);\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        void apply(int l, int r, F f) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return;\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push((r - 1) >> i);\n            }\n            \n            {\n                int l2 = l, r2 = r;\n                while (l < r) {\n                    if (l & 1) all_apply(l++, f);\n                    if (r & 1) all_apply(--r, f);\n                    l >>= 1;\n                    r >>= 1;\n                }\n                l = l2;\n                r = r2;\n            }\n            \n            for (int i = 1; i <= log; i++) {\n                if (((l >> i) << i) != l) update(l >> i);\n                if (((r >> i) << i) != r) update((r - 1) >> i);\n            }\n        }\n        \n        template <bool (*g)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return g(x); });\n        }\n        template <class G> int max_right(int l, G g) {\n            assert(0 <= l && l <= _n);\n            assert(g(e()));\n            if (l == _n) return _n;\n            l += size;\n            for (int i = log; i >= 1; i--) push(l >> i);\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!g(op(sm, d[l]))) {\n                    while (l < size) {\n                        push(l);\n                        l = (2 * l);\n                        if (g(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*g)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return g(x); });\n        }\n        template <class G> int min_left(int r, G g) {\n            assert(0 <= r && r <= _n);\n            assert(g(e()));\n            if (r == 0) return 0;\n            r += size;\n            for (int i = log; i >= 1; i--) push((r - 1) >> i);\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!g(op(d[r], sm))) {\n                    while (r < size) {\n                        push(r);\n                        r = (2 * r + 1);\n                        if (g(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        std::vector<F> lz;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n        void all_apply(int k, F f) {\n            d[k] = mapping(f, d[k]);\n            if (k < size) lz[k] = composition(f, lz[k]);\n        }\n        void push(int k) {\n            all_apply(2 * k, lz[k]);\n            all_apply(2 * k + 1, lz[k]);\n            lz[k] = id();\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n    \n    long long pow_mod(long long x, long long n, int m) {\n        assert(0 <= n && 1 <= m);\n        if (m == 1) return 0;\n        internal::barrett bt((unsigned int)(m));\n        unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n        while (n) {\n            if (n & 1) r = bt.mul(r, y);\n            y = bt.mul(y, y);\n            n >>= 1;\n        }\n        return r;\n    }\n    \n    long long inv_mod(long long x, long long m) {\n        assert(1 <= m);\n        auto z = internal::inv_gcd(x, m);\n        assert(z.first == 1);\n        return z.second;\n    }\n    \n    std::pair<long long, long long> crt(const std::vector<long long>& r,\n                                        const std::vector<long long>& m) {\n        assert(r.size() == m.size());\n        int n = int(r.size());\n        long long r0 = 0, m0 = 1;\n        for (int i = 0; i < n; i++) {\n            assert(1 <= m[i]);\n            long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n            if (m0 < m1) {\n                std::swap(r0, r1);\n                std::swap(m0, m1);\n            }\n            if (m0 % m1 == 0) {\n                if (r0 % m1 != r1) return {0, 0};\n                continue;\n            }\n            \n            \n            long long g, im;\n            std::tie(g, im) = internal::inv_gcd(m0, m1);\n            \n            long long u1 = (m1 / g);\n            if ((r1 - r0) % g) return {0, 0};\n            \n            long long x = (r1 - r0) / g % u1 * im % u1;\n            \n            r0 += x * m0;\n            m0 *= u1;  // -> lcm(m0, m1)\n            if (r0 < 0) r0 += m0;\n        }\n        return {r0, m0};\n    }\n    \n    long long floor_sum(long long n, long long m, long long a, long long b) {\n        long long ans = 0;\n        if (a >= m) {\n            ans += (n - 1) * n * (a / m) / 2;\n            a %= m;\n        }\n        if (b >= m) {\n            ans += n * (b / m);\n            b %= m;\n        }\n        \n        long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n        if (y_max == 0) return ans;\n        ans += (n - (x_max + a - 1) / a) * y_max;\n        ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n        return ans;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class T> struct simple_queue {\n            std::vector<T> payload;\n            int pos = 0;\n            void reserve(int n) { payload.reserve(n); }\n            int size() const { return int(payload.size()) - pos; }\n            bool empty() const { return pos == int(payload.size()); }\n            void push(const T& t) { payload.push_back(t); }\n            T& front() { return payload[pos]; }\n            void clear() {\n                payload.clear();\n                pos = 0;\n            }\n            void pop() { pos++; }\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap> struct mf_graph {\n    public:\n        mf_graph() : _n(0) {}\n        mf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            assert(0 <= cap);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result;\n            for (int i = 0; i < m; i++) {\n                result.push_back(get_edge(i));\n            }\n            return result;\n        }\n        void change_edge(int i, Cap new_cap, Cap new_flow) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            assert(0 <= new_flow && new_flow <= new_cap);\n            auto& _e = g[pos[i].first][pos[i].second];\n            auto& _re = g[_e.to][_e.rev];\n            _e.cap = new_cap - new_flow;\n            _re.cap = new_flow;\n        }\n        \n        Cap flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        Cap flow(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            \n            std::vector<int> level(_n), iter(_n);\n            internal::simple_queue<int> que;\n            \n            auto bfs = [&]() {\n                std::fill(level.begin(), level.end(), -1);\n                level[s] = 0;\n                que.clear();\n                que.push(s);\n                while (!que.empty()) {\n                    int v = que.front();\n                    que.pop();\n                    for (auto e : g[v]) {\n                        if (e.cap == 0 || level[e.to] >= 0) continue;\n                        level[e.to] = level[v] + 1;\n                        if (e.to == t) return;\n                        que.push(e.to);\n                    }\n                }\n            };\n            auto dfs = [&](auto self, int v, Cap up) {\n                if (v == s) return up;\n                Cap res = 0;\n                int level_v = level[v];\n                for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                    _edge& e = g[v][i];\n                    if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                    Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                    if (d <= 0) continue;\n                    g[v][i].cap += d;\n                    g[e.to][e.rev].cap -= d;\n                    res += d;\n                    if (res == up) break;\n                }\n                return res;\n            };\n            \n            Cap flow = 0;\n            while (flow < flow_limit) {\n                bfs();\n                if (level[t] == -1) break;\n                std::fill(iter.begin(), iter.end(), 0);\n                while (flow < flow_limit) {\n                    Cap f = dfs(dfs, t, flow_limit - flow);\n                    if (!f) break;\n                    flow += f;\n                }\n            }\n            return flow;\n        }\n        \n        std::vector<bool> min_cut(int s) {\n            std::vector<bool> visited(_n);\n            internal::simple_queue<int> que;\n            que.push(s);\n            while (!que.empty()) {\n                int p = que.front();\n                que.pop();\n                visited[p] = true;\n                for (auto e : g[p]) {\n                    if (e.cap && !visited[e.to]) {\n                        visited[e.to] = true;\n                        que.push(e.to);\n                    }\n                }\n            }\n            return visited;\n        }\n        \n    private:\n        int _n;\n        struct _edge {\n            int to, rev;\n            Cap cap;\n        };\n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap, class Cost> struct mcf_graph {\n    public:\n        mcf_graph() {}\n        mcf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap, Cost cost) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n            Cost cost;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{\n                pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n            };\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result(m);\n            for (int i = 0; i < m; i++) {\n                result[i] = get_edge(i);\n            }\n            return result;\n        }\n        \n        std::pair<Cap, Cost> flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n            return slope(s, t, flow_limit).back();\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n            return slope(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            assert(s != t);\n            std::vector<Cost> dual(_n, 0), dist(_n);\n            std::vector<int> pv(_n), pe(_n);\n            std::vector<bool> vis(_n);\n            auto dual_ref = [&]() {\n                std::fill(dist.begin(), dist.end(),\n                          std::numeric_limits<Cost>::max());\n                std::fill(pv.begin(), pv.end(), -1);\n                std::fill(pe.begin(), pe.end(), -1);\n                std::fill(vis.begin(), vis.end(), false);\n                struct Q {\n                    Cost key;\n                    int to;\n                    bool operator<(Q r) const { return key > r.key; }\n                };\n                std::priority_queue<Q> que;\n                dist[s] = 0;\n                que.push(Q{0, s});\n                while (!que.empty()) {\n                    int v = que.top().to;\n                    que.pop();\n                    if (vis[v]) continue;\n                    vis[v] = true;\n                    if (v == t) break;\n                    for (int i = 0; i < int(g[v].size()); i++) {\n                        auto e = g[v][i];\n                        if (vis[e.to] || !e.cap) continue;\n                        Cost cost = e.cost - dual[e.to] + dual[v];\n                        if (dist[e.to] - dist[v] > cost) {\n                            dist[e.to] = dist[v] + cost;\n                            pv[e.to] = v;\n                            pe[e.to] = i;\n                            que.push(Q{dist[e.to], e.to});\n                        }\n                    }\n                }\n                if (!vis[t]) {\n                    return false;\n                }\n                \n                for (int v = 0; v < _n; v++) {\n                    if (!vis[v]) continue;\n                    dual[v] -= dist[t] - dist[v];\n                }\n                return true;\n            };\n            Cap flow = 0;\n            Cost cost = 0, prev_cost = -1;\n            std::vector<std::pair<Cap, Cost>> result;\n            result.push_back({flow, cost});\n            while (flow < flow_limit) {\n                if (!dual_ref()) break;\n                Cap c = flow_limit - flow;\n                for (int v = t; v != s; v = pv[v]) {\n                    c = std::min(c, g[pv[v]][pe[v]].cap);\n                }\n                for (int v = t; v != s; v = pv[v]) {\n                    auto& e = g[pv[v]][pe[v]];\n                    e.cap -= c;\n                    g[v][e.rev].cap += c;\n                }\n                Cost d = -dual[s];\n                flow += c;\n                cost += c * d;\n                if (prev_cost == d) {\n                    result.pop_back();\n                }\n                result.push_back({flow, cost});\n                prev_cost = cost;\n            }\n            return result;\n        }\n        \n    private:\n        int _n;\n        \n        struct _edge {\n            int to, rev;\n            Cap cap;\n            Cost cost;\n        };\n        \n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\n    namespace internal {\n        \n        template <class E> struct csr {\n            std::vector<int> start;\n            std::vector<E> elist;\n            csr(int n, const std::vector<std::pair<int, E>>& edges)\n            : start(n + 1), elist(edges.size()) {\n                for (auto e : edges) {\n                    start[e.first + 1]++;\n                }\n                for (int i = 1; i <= n; i++) {\n                    start[i] += start[i - 1];\n                }\n                auto counter = start;\n                for (auto e : edges) {\n                    elist[counter[e.first]++] = e.second;\n                }\n            }\n        };\n        \n        struct scc_graph {\n        public:\n            scc_graph(int n) : _n(n) {}\n            \n            int num_vertices() { return _n; }\n            \n            void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n            \n            std::pair<int, std::vector<int>> scc_ids() {\n                auto g = csr<edge>(_n, edges);\n                int now_ord = 0, group_num = 0;\n                std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n                visited.reserve(_n);\n                auto dfs = [&](auto self, int v) -> void {\n                    low[v] = ord[v] = now_ord++;\n                    visited.push_back(v);\n                    for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                        auto to = g.elist[i].to;\n                        if (ord[to] == -1) {\n                            self(self, to);\n                            low[v] = std::min(low[v], low[to]);\n                        } else {\n                            low[v] = std::min(low[v], ord[to]);\n                        }\n                    }\n                    if (low[v] == ord[v]) {\n                        while (true) {\n                            int u = visited.back();\n                            visited.pop_back();\n                            ord[u] = _n;\n                            ids[u] = group_num;\n                            if (u == v) break;\n                        }\n                        group_num++;\n                    }\n                };\n                for (int i = 0; i < _n; i++) {\n                    if (ord[i] == -1) dfs(dfs, i);\n                }\n                for (auto& x : ids) {\n                    x = group_num - 1 - x;\n                }\n                return {group_num, ids};\n            }\n            \n            std::vector<std::vector<int>> scc() {\n                auto ids = scc_ids();\n                int group_num = ids.first;\n                std::vector<int> counts(group_num);\n                for (auto x : ids.second) counts[x]++;\n                std::vector<std::vector<int>> groups(ids.first);\n                for (int i = 0; i < group_num; i++) {\n                    groups[i].reserve(counts[i]);\n                }\n                for (int i = 0; i < _n; i++) {\n                    groups[ids.second[i]].push_back(i);\n                }\n                return groups;\n            }\n            \n        private:\n            int _n;\n            struct edge {\n                int to;\n            };\n            std::vector<std::pair<int, edge>> edges;\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct scc_graph {\n    public:\n        scc_graph() : internal(0) {}\n        scc_graph(int n) : internal(n) {}\n        \n        void add_edge(int from, int to) {\n            int n = internal.num_vertices();\n            assert(0 <= from && from < n);\n            assert(0 <= to && to < n);\n            internal.add_edge(from, to);\n        }\n        \n        std::vector<std::vector<int>> scc() { return internal.scc(); }\n        \n    private:\n        internal::scc_graph internal;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class S, S (*op)(S, S), S (*e)()> struct segtree {\n    public:\n        segtree() : segtree(0) {}\n        segtree(int n) : segtree(std::vector<S>(n, e())) {}\n        segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            return d[p + size];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            S sml = e(), smr = e();\n            l += size;\n            r += size;\n            \n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        template <bool (*f)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return f(x); });\n        }\n        template <class F> int max_right(int l, F f) {\n            assert(0 <= l && l <= _n);\n            assert(f(e()));\n            if (l == _n) return _n;\n            l += size;\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!f(op(sm, d[l]))) {\n                    while (l < size) {\n                        l = (2 * l);\n                        if (f(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*f)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return f(x); });\n        }\n        template <class F> int min_left(int r, F f) {\n            assert(0 <= r && r <= _n);\n            assert(f(e()));\n            if (r == 0) return 0;\n            r += size;\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!f(op(d[r], sm))) {\n                    while (r < size) {\n                        r = (2 * r + 1);\n                        if (f(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        std::vector<int> sa_naive(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n                if (l == r) return false;\n                while (l < n && r < n) {\n                    if (s[l] != s[r]) return s[l] < s[r];\n                    l++;\n                    r++;\n                }\n                return l == n;\n            });\n            return sa;\n        }\n        \n        std::vector<int> sa_doubling(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n), rnk = s, tmp(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            for (int k = 1; k < n; k *= 2) {\n                auto cmp = [&](int x, int y) {\n                    if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n                    int rx = x + k < n ? rnk[x + k] : -1;\n                    int ry = y + k < n ? rnk[y + k] : -1;\n                    return rx < ry;\n                };\n                std::sort(sa.begin(), sa.end(), cmp);\n                tmp[sa[0]] = 0;\n                for (int i = 1; i < n; i++) {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n                }\n                std::swap(tmp, rnk);\n            }\n            return sa;\n        }\n        \n        template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\n        std::vector<int> sa_is(const std::vector<int>& s, int upper) {\n            int n = int(s.size());\n            if (n == 0) return {};\n            if (n == 1) return {0};\n            if (n == 2) {\n                if (s[0] < s[1]) {\n                    return {0, 1};\n                } else {\n                    return {1, 0};\n                }\n            }\n            if (n < THRESHOLD_NAIVE) {\n                return sa_naive(s);\n            }\n            if (n < THRESHOLD_DOUBLING) {\n                return sa_doubling(s);\n            }\n            \n            std::vector<int> sa(n);\n            std::vector<bool> ls(n);\n            for (int i = n - 2; i >= 0; i--) {\n                ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n            }\n            std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n            for (int i = 0; i < n; i++) {\n                if (!ls[i]) {\n                    sum_s[s[i]]++;\n                } else {\n                    sum_l[s[i] + 1]++;\n                }\n            }\n            for (int i = 0; i <= upper; i++) {\n                sum_s[i] += sum_l[i];\n                if (i < upper) sum_l[i + 1] += sum_s[i];\n            }\n            \n            auto induce = [&](const std::vector<int>& lms) {\n                std::fill(sa.begin(), sa.end(), -1);\n                std::vector<int> buf(upper + 1);\n                std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n                for (auto d : lms) {\n                    if (d == n) continue;\n                    sa[buf[s[d]]++] = d;\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                sa[buf[s[n - 1]]++] = n - 1;\n                for (int i = 0; i < n; i++) {\n                    int v = sa[i];\n                    if (v >= 1 && !ls[v - 1]) {\n                        sa[buf[s[v - 1]]++] = v - 1;\n                    }\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                for (int i = n - 1; i >= 0; i--) {\n                    int v = sa[i];\n                    if (v >= 1 && ls[v - 1]) {\n                        sa[--buf[s[v - 1] + 1]] = v - 1;\n                    }\n                }\n            };\n            \n            std::vector<int> lms_map(n + 1, -1);\n            int m = 0;\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms_map[i] = m++;\n                }\n            }\n            std::vector<int> lms;\n            lms.reserve(m);\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms.push_back(i);\n                }\n            }\n            \n            induce(lms);\n            \n            if (m) {\n                std::vector<int> sorted_lms;\n                sorted_lms.reserve(m);\n                for (int v : sa) {\n                    if (lms_map[v] != -1) sorted_lms.push_back(v);\n                }\n                std::vector<int> rec_s(m);\n                int rec_upper = 0;\n                rec_s[lms_map[sorted_lms[0]]] = 0;\n                for (int i = 1; i < m; i++) {\n                    int l = sorted_lms[i - 1], r = sorted_lms[i];\n                    int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n                    int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n                    bool same = true;\n                    if (end_l - l != end_r - r) {\n                        same = false;\n                    } else {\n                        while (l < end_l) {\n                            if (s[l] != s[r]) {\n                                break;\n                            }\n                            l++;\n                            r++;\n                        }\n                        if (l == n || s[l] != s[r]) same = false;\n                    }\n                    if (!same) rec_upper++;\n                    rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n                }\n                \n                auto rec_sa =\n                sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n                \n                for (int i = 0; i < m; i++) {\n                    sorted_lms[i] = lms[rec_sa[i]];\n                }\n                induce(sorted_lms);\n            }\n            return sa;\n        }\n        \n    }  // namespace internal\n    \n    std::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n        assert(0 <= upper);\n        for (int d : s) {\n            assert(0 <= d && d <= upper);\n        }\n        auto sa = internal::sa_is(s, upper);\n        return sa;\n    }\n    \n    template <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n        int n = int(s.size());\n        std::vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n        std::vector<int> s2(n);\n        int now = 0;\n        for (int i = 0; i < n; i++) {\n            if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n            s2[idx[i]] = now;\n        }\n        return internal::sa_is(s2, now);\n    }\n    \n    std::vector<int> suffix_array(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return internal::sa_is(s2, 255);\n    }\n    \n    template <class T>\n    std::vector<int> lcp_array(const std::vector<T>& s,\n                               const std::vector<int>& sa) {\n        int n = int(s.size());\n        assert(n >= 1);\n        std::vector<int> rnk(n);\n        for (int i = 0; i < n; i++) {\n            rnk[sa[i]] = i;\n        }\n        std::vector<int> lcp(n - 1);\n        int h = 0;\n        for (int i = 0; i < n; i++) {\n            if (h > 0) h--;\n            if (rnk[i] == 0) continue;\n            int j = sa[rnk[i] - 1];\n            for (; j + h < n && i + h < n; h++) {\n                if (s[j + h] != s[i + h]) break;\n            }\n            lcp[rnk[i] - 1] = h;\n        }\n        return lcp;\n    }\n    \n    std::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return lcp_array(s2, sa);\n    }\n    \n    template <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n        int n = int(s.size());\n        if (n == 0) return {};\n        std::vector<int> z(n);\n        z[0] = 0;\n        for (int i = 1, j = 0; i < n; i++) {\n            int& k = z[i];\n            k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n            while (i + k < n && s[k] == s[i + k]) k++;\n            if (j + z[j] < i + z[i]) j = i;\n        }\n        z[0] = n;\n        return z;\n    }\n    \n    std::vector<int> z_algorithm(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return z_algorithm(s2);\n    }\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct two_sat {\n    public:\n        two_sat() : _n(0), scc(0) {}\n        two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n        \n        void add_clause(int i, bool f, int j, bool g) {\n            assert(0 <= i && i < _n);\n            assert(0 <= j && j < _n);\n            scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n            scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n        }\n        bool satisfiable() {\n            auto id = scc.scc_ids().second;\n            for (int i = 0; i < _n; i++) {\n                if (id[2 * i] == id[2 * i + 1]) return false;\n                _answer[i] = id[2 * i] < id[2 * i + 1];\n            }\n            return true;\n        }\n        std::vector<bool> answer() { return _answer; }\n        \n    private:\n        int _n;\n        std::vector<bool> _answer;\n        internal::scc_graph scc;\n    };\n    \n}  // namespace atcoder\n\nconst int mod=1000000007,MAX=100005;\nconst ll INF=1LL<<60;\n\nusing mint=atcoder::modint1000000007;\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,M;cin>>N>>M;\n    if(M==1){\n        cout<<1<<endl;\n        return 0;\n    }\n    vector<ll> A(N),B(M+2);\n    B[0]=-INF;\n    B[M+1]=INF;\n    for(int i=0;i<N;i++) cin>>A[i];\n    for(int i=0;i<M;i++) cin>>B[i+1];\n    \n    vector<pair<ll,ll>> S(N);\n    \n    int id=0;\n    map<ll,int> MA;\n    for(int i=0;i<N;i++){\n        while(A[i]>=B[id+1]) id++;\n        S[i]=mp(A[i]-B[id],B[id+1]-A[i]);\n        MA[B[id+1]-A[i]]=1;\n    }\n    \n    sort(all(S));\n    \n    S.erase(unique(all(S)),S.end());\n    \n    sort(all(S),[](auto a,auto b){\n        if(a.fi==b.fi) return a.se>b.se;\n        return a.fi<b.fi;\n    });\n    \n    id=1;\n    \n    for(auto &a:MA){\n        a.se=id;\n        id++;\n    }\n    \n    N=si(S);\n    \n    for(int i=0;i<N;i++){\n        S[i].se=MA[S[i].se];\n        //cout<<S[i].fi<<\" \"<<S[i].se<<endl;\n    }\n    \n    atcoder::fenwick_tree<mint> dp(N+3);\n    \n    dp.add(0,1);\n    \n    for(int i=0;i<N;i++){\n        dp.add(S[i].se,dp.sum(0,S[i].se));\n    }\n    \n    cout<<dp.sum(0,N+2).val()<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LL long long\n#define pii pair<int,int>\nusing namespace std;\nconst int inf = 2147483647;\nconst int mod = 1e9 + 7;\nconst int N = 100001;\n\nint _max(int x, int y) {return x > y ? x : y;}\nint _min(int x, int y) {return x < y ? x : y;}\ninline int read() {\n    int x = 0, f = 1; char ch = getchar();\n    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n    while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n    return x * f;\n}\nvoid put(int x) {\n\tif(x < 0) putchar('-'), x = -x;\n\tif(x >= 10) put(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nint add(int x, int y) {\n\tx += y;\n\treturn x >= mod ? x - mod : x;\n}\n\nstruct Bit {\n\tint n, s[N];\n\t\n\tint lowbit(int x) {return x & -x;}\n\tvoid change(int x, int c) {for(int i = x; i <= n; i += lowbit(i)) s[i] = add(s[i], c);}\n\tint getsum(int x) {int sum = 0; for(int i = x; i; i -= lowbit(i)) sum = add(sum, s[i]); return sum;}\n} s;\nstruct node {int x, y;} a[N];\nint xx[N], yy[N];\n\nbool cmp(node a, node b) {\n\tif(a.x == b.x) return a.y > b.y;\n\treturn a.x < b.x;\n}\n\nint main() {\n\tint n = read(), m = read();\n\tfor(int i = 1; i <= n; i++) xx[i] = read();\n\tfor(int i = 1; i <= m; i++) yy[i] = read();\n\tint l = 1; while(l <= n && xx[l] <= yy[1]) l++;\n\tint r = n; while(r >= 1 && xx[r] >= yy[m]) r--;\n\tn = r - l + 1; for(int i = l; i <= r; i++) xx[i - l + 1] = xx[i];\n\tint tp = 0, u = 0;\n\tfor(int i = 1; i <= m; i++) {\n\t\twhile(tp < n && xx[tp + 1] < yy[i]) tp++, a[++u].x = xx[tp] - yy[i - 1], a[u].y = yy[i] - xx[tp];\n\t\twhile(xx[tp + 1] == yy[i]) tp++;\n\t} n = u;\n\tsort(a + 1, a + n + 1, cmp); u = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t\tif(a[i].x != a[i - 1].x || a[i].y != a[i - 1].y) a[++u] = a[i];\n\t} n = u;\n\tfor(int i = 1; i <= n; i++) xx[i] = a[i].y;\n\tsort(xx + 1, xx + n + 1);\n\tint ll = unique(xx + 1, xx + n + 1) - (xx + 1);\n\tfor(int i = 1; i <= n; i++) a[i].y = lower_bound(xx + 1, xx + ll + 1, a[i].y) - xx;\n\tint ans = 0;\n\ts.n = ll; for(int i = 1; i <= n; i++) {\n\t\tint u = add(1, s.getsum(a[i].y - 1));\n\t\ts.change(a[i].y, u), ans = add(ans, u);\n\t} put(add(ans, 1)), puts(\"\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nconst long long mo=1000000007;\nconst int maxn=800010;\n\nint n,m,gs,x[maxn],y[maxn],xx[maxn],yy[maxn],op[maxn],id[maxn];\nlong long c[maxn*4],sum[maxn];\n\nvoid qsort2(int l,int r)\n{\n\tint i=l;int j=r;\n\tint m=yy[(i+j)/2];\n\tint m1=xx[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile ((yy[i]<m) || (yy[i]==m && xx[i]<m1)) i++;\n\t\twhile ((yy[j]>m) || (yy[j]==m && xx[j]>m1)) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(yy[i],yy[j]);\n\t\t\tswap(xx[i],xx[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort2(l,j);\n\tif (r>i) qsort2(i,r); \n}\n\nvoid qsort(int l,int r)\n{\n\tint i=l;int j=r;\n\tint m=yy[(i+j)/2];\n\tint m1=xx[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile ((yy[i]<m) || (yy[i]==m && xx[i]<m1)) i++;\n\t\twhile ((yy[j]>m) || (yy[j]==m && xx[j]>m1)) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(yy[i],yy[j]);\n\t\t\tswap(xx[i],xx[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (r>i) qsort(i,r); \n}\n\nvoid qsort1(int l,int r)\n{\n\tint i=l;int j=r;\n\tint m=op[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (op[i]<m) i++;\n\t\twhile (op[j]>m) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(op[i],op[j]);\n\t\t\tswap(id[i],id[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort1(l,j);\n\tif (r>i) qsort1(i,r); \n}\n\n\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\n\nvoid modify(int i,long long k)\n{\n\twhile (i<=gs)\n\t{\n\t\tc[i]=(c[i]+k)%mo;\n\t\ti+=lowbit(i);\n\t}\n}\n\nlong long getans(int i)\n{\n\tlong long gg=0;\n\tint kk=0;\n\twhile (i>0)\n\t{\n\t\tgg=(gg+c[i])%mo;\n\t\tkk=lowbit(i);\n\t\ti-=kk;\n\t}\n\treturn gg;\n}\n\nint main()\n{\n//\tfreopen(\"data.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tint zd=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&x[i]);\n\t\tzd=max(zd,x[i]);\n\t}\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d\",&y[i]);\n\t\tzd=max(zd,y[i]);\n\t}\n\tint l=1;\n\tgs=2;\n\txx[1]=1;yy[1]=1;\n\txx[2]=zd+1;yy[2]=zd+1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\twhile (x[i]>y[l] && l<=m) l++;\n\t\tif (l>m) break;\n\t\tif (l>1 && x[i]>y[l-1] && x[i]<y[l])\n\t\t{\n\t\t\tgs++;\n\t\t\txx[gs]=x[i]-y[l-1]+1;\n\t\t\tyy[gs]=y[l]-x[i]+1;\n\t\t}\n\t}\n\tqsort(1,gs);\n\tfor (int i=1;i<=gs;i++)\n\t{\n\t\top[i]=xx[i];\n\t\tid[i]=i;\n\t}\n\tqsort1(1,gs);\n\tint js=0;\n\tfor (int i=1;i<=gs;i++)\n\t{\n\t\tif (op[i]!=op[i-1]) js++;\n\t\txx[id[i]]=js;\n\t}\n\tmodify(1,1);\n\tl=2;\n\tint r=2;\n\tint jss=0;\n\tfor (int i=2;i<=gs;i++)\n\t{\n\t\tif (xx[i]==xx[i-1] && yy[i]==yy[i-1])\n\t\t{\n\t\t\txx[i-1]=100000000;\n\t\t\tyy[i-1]=100000000;\n\t\t\tjss++;\n\t\t}\n\t}\n\tqsort2(1,gs);\n\tgs-=jss;\n\twhile (l<gs)\n\t{\n\t\twhile (yy[l]==yy[l+1])\n\t\t{\n\t\t\tsum[l]=getans(xx[l]-1);\n\t\t\tl++;\n\t\t}\n\t\tif (yy[l]!=yy[l+1])\n\t\t{\n\t\t\tsum[l]=getans(xx[l]-1);\n\t\t\tl++;\n\t\t}\n\t\twhile (r<l)\n\t\t{\n\t\t\tmodify(xx[r],sum[r]);\n\t\t\tr++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",getans(xx[gs]));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\nusing namespace std;\n\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\n\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) v += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\nconst int MOD = 1000000007;\nusing mint = Fp<MOD>;\n\n\ntemplate <class Abel> struct BIT {\n    const Abel UNITY_SUM = 0;                       // to be set\n    vector<Abel> dat;\n    \n    /* [1, n] */\n    BIT(int n) : dat(n + 1, UNITY_SUM) { }\n    void init(int n) { dat.assign(n + 1, UNITY_SUM); }\n    \n    /* a is 1-indexed */\n    inline void add(int a, Abel x) {\n        for (int i = a; i < (int)dat.size(); i += i & -i)\n            dat[i] = dat[i] + x;\n    }\n    \n    /* [1, a], a is 1-indexed */\n    inline Abel sum(int a) {\n        Abel res = UNITY_SUM;\n        for (int i = a; i > 0; i -= i & -i)\n            res = res + dat[i];\n        return res;\n    }\n    \n    /* [a, b), a and b are 1-indexed */\n    inline Abel sum(int a, int b) {\n        return sum(b - 1) - sum(a - 1);\n    }\n    \n    /* debug */\n    void print() {\n        for (int i = 1; i < (int)dat.size(); ++i) cout << sum(i, i + 1) << \",\";\n        cout << endl;\n    }\n};\n\n\nconst long long INF = 1LL<<55;\nusing pll = pair<long long,long long>;\nint N, M;\nvector<long long> x, y, v, uv;\nvector<pll> lrs;\n\nmint solve() {\n    sort(y.begin(), y.end());\n\n    lrs.clear();\n    for (int i = 0; i < N; ++i) {\n        int it = lower_bound(y.begin(), y.end(), x[i]) - y.begin();\n        if (it == 0 || it == M) continue;\n        lrs.push_back(pll(y[it-1] - x[i], y[it] - x[i]));\n    }\n    sort(lrs.begin(), lrs.end());\n    lrs.erase(unique(lrs.begin(), lrs.end()), lrs.end());\n\n    //COUT(lrs);\n    \n    v.clear(); uv.clear();\n    for (auto p : lrs) v.push_back(p.second);\n    uv = v;\n    sort(uv.begin(), uv.end());\n    uv.erase(unique(uv.begin(), uv.end()), uv.end());\n    int s = uv.size();\n\n    //COUT(v);\n    BIT<mint> bit(N+10);\n    bit.add(s+1, 1);\n    for (auto vi : v) {\n        int k = lower_bound(uv.begin(), uv.end(), vi) - uv.begin();\n        ++k;\n        mint sum = bit.sum(k+1, s+2);\n        bit.add(k, sum);\n\n        //COUT(vi); COUT(k); COUT(sum); bit.print();\n    }\n    return bit.sum(1, s+2);\n}\n\nint main() {\n    while (cin >> N >> M) {\n        x.resize(N); y.resize(M);\n        for (int i = 0; i < N; ++i) cin >> x[i];\n        for (int i = 0; i < M; ++i) cin >> y[i];\n        cout << solve() << endl;\n    }\n}\n            \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#define MAXN 100005\n#define p 1000000007\n#define LL long long\nusing namespace std;\n\nint n, m, cnt, x[MAXN], y[MAXN], a[MAXN], b[MAXN];\nLL t[MAXN];\n\nstruct Node {int a, b;} c[MAXN];\n\nbool CMP(Node x, Node y)\n{\n\tif(x.a!=y.a) return x.a<y.a;\n\treturn x.b>y.b;\t\n}\n\nvoid add(int x, int y)\n{\n\tfor(; x<=cnt; x+=(x&-x)) t[x]=(t[x]+y)%p; \n}\n\nLL ask(int x)\n{\n\tLL sum=0;\n\tfor(; x; x-=(x&-x)) sum=(sum+t[x])%p;\n\treturn sum;\t\n} \n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i=1; i<=n; i++) scanf(\"%d\", &x[i]);\n\tfor(int i=1; i<=m; i++) scanf(\"%d\", &y[i]);\n\tfor(int i=1, j=1; i<m && j<=n; i++)\n\t{\n\t\twhile(x[j]<y[i]) j++;\n\t\twhile(x[j]>=y[i] && x[j]<=y[i+1])\n\t\t{\n\t\t\ta[++cnt]=x[j]-y[i];\n\t\t\tb[cnt]=y[i+1]-x[j];\n\t\t\tc[cnt].a=a[cnt]; c[cnt].b=b[cnt];\n\t\t\tj++;\n\t\t}\n\t}\n\tsort(a+1, a+cnt+1); sort(b+1, b+cnt+1);\n\tfor(int i=1; i<=cnt; i++)\n\t{\n\t\tc[i].a=lower_bound(a+1, a+cnt+1, c[i].a)-a;\n\t\tc[i].b=lower_bound(b+1, b+cnt+1, c[i].b)-b;\n\t}\n\tsort(c+1, c+cnt+1, CMP);\n\tfor(int i=1; i<=cnt; i++)\n\t\tif(c[i].a!=c[i-1].a || c[i].b!=c[i-1].b) add(c[i].b, (ask(c[i].b-1)+1)%p);\n\tprintf(\"%d\\n\", (ask(cnt)+1)%p);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1e9+7;\ntypedef pair<ll,ll> P;\n\nstruct BIT{\n  int size;\n  vector<ll> dat;\n  void init(int n){\n    size=n;\n    dat.clear();\n    dat.resize(n+1);\n  }\n  void Add(int i,ll x){\n    i+=2;\n    \n    x%=mod;\n    \n    while(0<i&&i<=size){\n      dat[i]+=x;\n\n      dat[i]%=mod;\n      \n      i+=(i&-i);\n    }\n  }\n  \n  ll Sum(int i){\n    i+=2;\n    \n    ll res=0;\n    while(0<i){\n      res+=dat[i];\n\n      res%=mod;\n      \n      i-=(i&-i);\n    }\n    return res;\n  }\n};\n \nBIT A,B;\n\nvoid Add(ll s,ll t,ll value){\n  A.Add(s,value);\n  A.Add(t,-value);\n  B.Add(s,-value*(s-1));\n  B.Add(t,value*(s-1) + value*(t-s+1) );\n}\n\nll Sum(ll s,ll t){\n  s--;\n  ll f= ( A.Sum(t)*t+B.Sum(t) - A.Sum(s)*s-B.Sum(s) ) %mod;\n  return (f+mod)%mod;\n}\n\n\nll solve(vector<P> t){\n  A.init(300000);\n  B.init(300000);\n  Add(0,0,1);\n\n  vector<P> tmp;\n  for(int i=0;i<=(int)t.size();i++){\n    if(i==(int)t.size() || ( i>0 && t[i-1].first != t[i].first ) ){\n      for(P p:tmp){\n        Add(p.first, p.first, p.second);\n      }\n      tmp.clear();\n    }\n    if(i==(int)t.size())break;\n\n    ll pos=t[i].second;\n    ll value=Sum(0, pos-1);\n    tmp.push_back( P(pos, value) );\n  }\n\n  return Sum(0, 300000-10);  \n}\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n\n\n  const ll INF=(1LL<<60);\n  \n  set<ll> X;\n  X.insert(INF);\n  X.insert(-INF);\n\n  vector<ll> px(n);\n  for(int i=0;i<n;i++){\n    cin>>px[i];\n  }\n  for(int i=0;i<m;i++){\n    ll x;\n    cin>>x;\n    X.insert(x);  \n  }\n\n  vector<P> v;\n  \n  \n  for(int i=0;i<n;i++){\n    set<ll> :: iterator it;\n    it=X.lower_bound( px[i] );\n    ll right=*it;\n    it--;\n    ll left=*it;\n    if( left == -INF || right==INF)continue;\n    v.push_back( P( px[i]-left , right-px[i] ) );  \n  }\n  sort(v.begin(), v.end());\n  v.erase( unique( v.begin(), v.end() ) , v.end() );\n\n\n  vector<ll> Z;\n  for(int i=0;i<(int)v.size();i++){\n    Z.push_back( v[i].second );\n  }\n  sort(Z.begin(),Z.end());\n  Z.erase( unique(Z.begin(), Z.end()) , Z.end() );\n  for(int i=0;i<(int)v.size();i++){\n    v[i].second = lower_bound(Z.begin(),Z.end(), v[i].second) - Z.begin() +1;\n\n    //    cout<<v[i].first<<' '<<v[i].second<<endl;\n    \n  }\n  cout << solve(v) <<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100233, mod = 1000000007;\nint n, m, p, x[N], y[N], uni[N];\npair<int, int> q[N];\nint tr[N];\nvoid add(int x, int y) {\n  for (; x <= m; x += x & -x) {\n    tr[x] = (tr[x] + y) % mod;\n  }\n}\nint ask(int x) {\n  int r = 1;\n  for (; x; x -= x & -x) {\n    r = (r + tr[x]) % mod;\n  }\n  return r;\n}\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &x[i]);\n  }\n  for (int i = 1; i <= m; i++) {\n    scanf(\"%d\", &y[i]);\n  }\n  sort(x + 1, x + 1 + n);\n  sort(y + 1, y + 1 + m);\n  for (int i = 1; i <= n; i++) {\n    int t = (int) (upper_bound(y + 1, y + 1 + m, x[i]) - y);\n    if (t == 1 || t == m + 1) continue;\n    ++p;\n    q[p].first = x[i] - y[t - 1];\n    q[p].second = uni[p] = y[t] - x[i];\n  }\n  sort(uni + 1, uni + 1 + p);\n  m = (int) (unique(uni + 1, uni + 1 + p) - uni - 1);\n  sort(q + 1, q + 1 + p, [&](pair<int, int> &a, pair<int, int> &b){return a.first == b.first ? a.second > b.second : a.first < b.first;});\n  n = (int) (unique(q + 1, q + 1 + p) - q - 1);\n  for (int i = 1; i <= n; i++) {\n    int t = (int) (lower_bound(uni + 1, uni + 1 + m, q[i].second) - uni);\n    add(t, ask(t - 1));\n  }\n  printf(\"%d\\n\", ask(m));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<unsigned MOD> struct ModInt {\n    static const unsigned static_MOD = MOD;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 1000000007;\n//const LL MOD = 998244353;\ntypedef ModInt<MOD> Mint;\n\ntemplate<class T> struct Fenwick {\n    int n;\n    T* d;\n    Fenwick() : n(0), d(NULL) {}\n    Fenwick(int n_) : n(n_) {\n\td = new T[n_]();\n    }\n    Fenwick(const Fenwick &y) : n(y.n) {\n\td = new T[n];\n\tmemcpy(d, y.d, sizeof (T) * n);\n    }\n    ~Fenwick() {\n\tdelete[] d; d = NULL;\n\tn = 0;\n    }\n    friend void swap(Fenwick &x, Fenwick &y) {\n\tswap(x.n, y.n); swap(x.d, y.d);\n    }\n    Fenwick& operator=(Fenwick y) {\n\tswap(*this, y);\n\treturn *this;\n    }\n    inline void add(int i, const T &x) {\n\tfor (; i<n; i|=i+1) d[i] += x;\n    }\n    inline T sum(int r) {\n\tT s = T();\n\tfor (; r; r&=r-1) s += d[r-1];\n\treturn s;\n    }\n    T sum(int l, int r) {\n\treturn sum(r) - sum(l);\n    }\n};\n\ntemplate<class T> vector<int> compress(const vector<T> &v, vector<T> *unq=NULL) {\n    int n = v.size();\n    vector<pair<T, int> > t(n);\n    for (int i=0; i<n; i++) t[i] = make_pair(v[i], i);\n    sort(t.begin(), t.end());\n    vector<int> r(n);\n    int cur = 0;\n    for (int i=0, k=0; i<n; i++) {\n\tif (t[k].first < t[i].first) k = i, cur++;\n\tr[t[i].second] = cur;\n    }\n    if (unq) {\n\tunq->resize(cur+1);\n\tcur = 0;\n\tfor (int i=0; i<n; i++)\n\t    if (i == 0 || t[i-1].first < t[i].first)\n\t\t(*unq)[cur++] = t[i].first;\n    }\n    return r;\n}\n\nint N, M;\nint X[100011], Y[100011];\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &M);\n    REP (i, N) scanf(\"%d\", X+i);\n    REP (i, M) scanf(\"%d\", Y+i);\n\n    vector<pair<int, int> > P;\n    REP (i, N) {\n\tint k = lower_bound(Y, Y+M, X[i]) - Y;\n\tif (k == M || k == 0) continue;\n\tP.emplace_back(X[i] - Y[k-1], Y[k] - X[i]);\n    }\n\n    N = -1;\n    sort(P.begin(), P.end());\n    P.erase(unique(P.begin(), P.end()), P.end());\n    VI val(P.size()+1);\n    REP (i, P.size()) val[i] = P[i].second;\n    VI c = compress(val);\n\n    Fenwick<Mint> F(val.size());\n    F.add(0, 1);\n\n    for (int i=0; i<(int)P.size(); ) {\n\tint j = i;\n\twhile (j < (int)P.size() && P[i].first == P[j].first) j++;\n\tfor (int k=j-1; k>=i; k--) {\n\t    int pos = c[k];\n\t    Mint t = F.sum(pos);\n\t    F.add(pos, t);\n\t}\n\ti = j;\n    }\n\n    Mint ans = F.sum(val.size());\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nconst int INF = int(2e9);\nint L[111111];\nint R[111111];\nii ID[111111];\nconst int MOD = (1e9 + 7);\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nint dp[111111][2];\nint PT[111111];\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m; cin>>n>>m;\n\tvi a,b;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint x; cin>>x; a.pb(x);\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint x; cin>>x; b.pb(x);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint lb = lower_bound(b.begin(),b.end(),a[i])-b.begin();\n\t\tL[i]=R[i]=INF;\n\t\tif(lb<b.size()) R[i]=b[lb]-a[i];\n\t\tlb--;\n\t\tif(lb>=0) L[i]=a[i]-b[lb];\n\t\t//cerr<<L[i]<<' '<<R[i]<<'\\n';\n\t}\n\tmap<int,vi> X,Y;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tX[L[i]].pb(i);\n\t\tY[R[i]].pb(i);\n\t}\n\tint ptr=0;\n\tfor(auto it:X)\n\t{\n\t\tif(it.fi==INF) ptr=INF;\n\t\tfor(int v:it.se)\n\t\t{\n\t\t\tID[v].fi=ptr;\n\t\t}\n\t\tptr++;\n\t}\n\tptr=0;\n\tfor(auto it:Y)\n\t{\n\t\tif(it.fi==INF) ptr=INF;\n\t\tfor(int v:it.se)\n\t\t{\n\t\t\tID[v].se=ptr;\n\t\t}\n\t\tptr++;\n\t}\n\tsort(ID,ID+n);\n\tset<int> S;\n\tvector<ii> vv;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tvv.pb(mp(ID[i].se,i));\n\t}\n\tsort(vv.begin(),vv.end());\n\tint s=int(1e9);\n\tptr=n-1;\n\tfor(int i=n-1;i>=0;i--)\n\t{\n\t\tPT[vv[i].se]=-1;\n\t\twhile(ptr>=0&&vv[ptr].fi>vv[i].fi)\n\t\t{\n\t\t\ts=min(s,vv[ptr].se);\n\t\t\tptr--;\n\t\t}\n\t\tif(s<vv[i].se) PT[vv[i].se]=s;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\t/*\n\t\twhile(ptr+1<n&&ID[ptr+1].fi<ID[i].fi&&ID[ptr+1].se<=ID[i].se)\n\t\t{\n\t\t\tptr++;\n\t\t}\n\t\t*/\n\t\t//choose L\n\t\tif(ID[i].fi<INF)\n\t\t{\n\t\t\tif(i-1>=0&&ID[i-1].fi==ID[i].fi)\n\t\t\t{\n\t\t\t\tdp[i][0] = dp[i-1][0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==0) dp[i][0]=1;\n\t\t\t\telse dp[i][0] = add(dp[i-1][0], dp[i-1][1]);\n\t\t\t}\n\t\t}\n\t\tif(ID[i].se<INF)\n\t\t{\n\t\t\tint ptr = PT[i];\n\t\t\tif(ptr<0)\n\t\t\t{\n\t\t\t\tif(i==0) dp[i][1]=1;\n\t\t\t\telse dp[i][1] =  add(dp[i-1][0], dp[i-1][1]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][1] = dp[ptr][0];\n\t\t\t}\n\t\t}\n\t}\n\tint ans=add(dp[n-1][0],dp[n-1][1]);\n\tcout<<ans<<'\\n';\n\t/*\n\tX.erase(INF); Y.erase(INF);\n\tint xsiz=X.size(); int ysiz=Y.size();\n\tset<int> S;\n\tfor(int i=0;i<(1<<(xsiz+ysiz));i++)\n\t{\n\t\tif(__builtin_popcount(i)!=xsiz) continue;\n\t\tvector<int> vec;\n\t\tfor(int j=0;j<xsiz+ysiz;j++)\n\t\t{\n\t\t\tif(i&(1<<j)) vec.pb(1);\n\t\t\telse vec.pb(0);\n\t\t}\n\t\tvector<int> pp(n,-1);\n\t\tauto it0=X.begin(); auto it1=Y.begin();\n\t\tfor(int j=0;j<xsiz+ysiz;j++)\n\t\t{\n\t\t\tif(vec[j])\n\t\t\t{\n\t\t\t\tfor(int v:it0->se)\n\t\t\t\t{\n\t\t\t\t\tif(pp[v]==-1) pp[v]=0;\n\t\t\t\t}\n\t\t\t\tit0++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int v:it1->se)\n\t\t\t\t{\n\t\t\t\t\tif(pp[v]==-1) pp[v]=1;\n\t\t\t\t}\n\t\t\t\tit1++;\n\t\t\t}\n\t\t}\n\t\tint bit=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(pp[i]) bit^=(1<<i);\n\t\t}\n\t\tS.insert(bit);\n\t}\n\tcout<<S.size()<<'\\n';\n\t*/\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005*2,mod=1e9+7;\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nint n,m,hs;\nint a[N],b[N];\nvector <int> Ha;\nint type[N];\nint pre[N],suf[N];\nvector <pair <int,int> > p;\nint c[N];\nvoid add(int x,int d){\n\tfor (;x<=hs;x+=x&-x)\n\t\tAdd(c[x],d);\n}\nint Ask(int x){\n\tint ans=1;\n\tfor (;x;x-=x&-x)\n\t\tAdd(ans,c[x]);\n\treturn ans;\n}\nint res[N];\nint main(){\n\tn=read(),m=read();\n\tFor(i,1,n)\n\t\ta[i]=read(),Ha.pb(a[i]);\n\tFor(i,1,m)\n\t\tb[i]=read(),Ha.pb(b[i]);\n\tHa.pb(0);\n\tsort(Ha.begin(),Ha.end());\n\tHa.resize(unique(Ha.begin(),Ha.end())-Ha.begin());\n\ths=Ha.size()-1;\n\tFor(i,1,n)\n\t\ttype[lower_bound(Ha.begin(),Ha.end(),a[i])-Ha.begin()]=1;\n\tFor(i,1,hs)\n\t\tpre[i]=type[i]?pre[i-1]:Ha[i];\n\tFod(i,hs,1)\n\t\tsuf[i]=type[i]?suf[i+1]:Ha[i];\n\tFor(i,1,n){\n\t\tint A=lower_bound(Ha.begin(),Ha.end(),a[i])-Ha.begin();\n\t\tif (!pre[A]||!suf[A])\n\t\t\tcontinue;\n\t\tp.pb(mp(a[i]-pre[A],suf[A]-a[i]));\n\t}\n\tHa.clear();\n\tfor (auto i : p)\n\t\tHa.pb(i.se);\n\tsort(Ha.begin(),Ha.end());\n\tHa.resize(unique(Ha.begin(),Ha.end())-Ha.begin());\n\ths=Ha.size();\n\tfor (auto &i : p)\n\t\ti.se=lower_bound(Ha.begin(),Ha.end(),i.se)-Ha.begin()+1;\n\tsort(p.begin(),p.end());\n\tp.resize(unique(p.begin(),p.end())-p.begin());\n\tint ans=1;\n\tfor (int i=0,j;i<(int)p.size();i=j+1){\n\t\tfor (j=i;j+1<(int)p.size()&&p[j+1].fi==p[i].fi;j++);\n\t\tFor(k,i,j)\n\t\t\tAdd(ans,res[k]=Ask(p[k].se-1));\n\t\tFor(k,i,j)\n\t\t\tadd(p[k].se,res[k]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\n\ntypedef long long LL;\n\n\nconst int N = 1000010;\n\nconst LL mod = 1000000007LL;\n\n\n#define L first\n#define R second\n\n\nLL Plus(LL a, LL b) { return a + b >= mod ? a + b - mod : a + b; }\n\n\nstruct Frenwick_Tree\n{\tLL C[N]; int sz;\n\n\tvoid upd(int x, LL v) { for (int i = x; i <= sz; i += i & (-i)) C[i] = Plus(C[i], v); }\n\n\tLL getSum(int x)\n\t{\tLL Ans = 0;\n\t\tfor (int i = x; i > 0; i -= i & (-i)) Ans = Plus(Ans, C[i]);\n\t\treturn Ans;\n\t}\n} Calc;\n\npair<int, int> num[N];\nint dis[N];\nint total[2];\n\nbool cmp(pair<int, int> & a, pair<int, int> & b) { return a.L != b.L ? a.L < b.L : a.R > b.R; }\n\n\nint a[N], b[N];\n\nLL f[N];\n\nint main()\n{\tint n, m;\n\t\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tfor (int i = 1; i <= m; i++)\n\t\tscanf(\"%d\", &b[i]);\n\t\n\tfor (int i = 1; i <= n; i++)\n\t{\tif (a[i] > b[1] && a[i] < b[m])\n\t\t{\tint pos = lower_bound(b + 1, b + 1 + m, a[i]) - b;\n\t\t\tif (b[pos] != a[i])\n\t\t\t{\tnum[++total[0]] = make_pair(a[i] - b[pos - 1], b[pos] - a[i]);\n\t\t\t\tdis[++total[1]] = b[pos] - a[i];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tsort(dis + 1, dis + total[1] + 1);\n\ttotal[1] = unique(dis + 1, dis + total[1] + 1) - dis - 1;\n\t\n\tfor (int i = 1; i <= total[0]; i++)\n\t\tnum[i].R = lower_bound(dis + 1, dis + total[1] + 1, num[i].R) - dis;\n\t\n\tsort(num + 1, num + total[0] + 1, cmp);\n\ttotal[0] = unique(num + 1, num + total[0] + 1) - num - 1;\n\t\n\tLL Ans = 1;\n\t\n\tCalc.sz = total[1];\n\t\n\tfor (int i = 1; i <= total[0]; i++)\n\t{\tf[i] = Calc.getSum(num[i].R - 1) + 1;\n\t\tAns = Plus(Ans, f[i]);\n\t\tCalc.upd(num[i].R, f[i]);\n\t}\n\t\n\tprintf(\"%lld\\n\", Ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-04 16:22:43\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\n#include<vector>\nconst int N=100010;\nint n,a[N],b[N],x[N],y[N],v[N],m,_n,s[N],n_;\ni64 ans,f[N];\nstd::vector<int> e[N];\ni64 query(int p)\n{\n\ti64 ans=0;\n\twhile(p){ ans+=s[p]; p-=p&(-p); }\n\treturn ans;\n}\nvoid modify(int p,i64 v)\n{\n\twhile(p<=m){ s[p]+=v; p+=p&(-p); }\n}\nint main()\n{\n\tn=read(); n_=read();\n\tfr(i,1,n) a[i]=read();\n\tfr(i,1,n_) b[i]=read();\n\tfr(i,1,n)\n\t{\n\t\tif(a[i]<=b[1]||a[i]>=b[n_]) continue;\n\t\tint nex=*std::upper_bound(b+1,b+n_+1,a[i]),pre=*(std::upper_bound(b+1,b+n_+1,a[i])-1);\n//\t\tprintf(\"%d %d %d\\n\",a[i],nex,pre);\n\t\tif(a[i]==nex||a[i]==pre) continue;\n//\t\tprintf(\"%d\\n\",i);\n\t\t_n++; x[_n]=a[i]-pre; y[_n]=nex-a[i];\n\t}\n\tn=_n;\n\tfr(i,1,n){ v[++m]=x[i]; v[++m]=y[i]; }\n\tstd::sort(v+1,v+m+1); m=std::unique(v+1,v+m+1)-v-1;\n\tfr(i,1,n){ x[i]=*std::lower_bound(v+1,v+m+1,x[i]); y[i]=*std::lower_bound(v+1,v+m+1,y[i]); }\n\tfr(i,1,n) e[x[i]].push_back(y[i]);\n\tfr(i,1,n) printf(\"%d %d\\n\",x[i],y[i]);\n\tfr(i,1,m)\n\t{\n\t\tfr(j,0,e[i].size()-1) ans+=(f[j]=query(e[i][j]-1)+1);\n\t\tfr(j,0,e[i].size()-1) modify(e[i][j],f[j]);\n\t}\n\tprintf(\"%lld\\n\",ans+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nint n,m,a[100005],b[100005],flag;\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",a[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&b[i]);\n\tif(n==2&&m==2)\n\t\tputs(\"3\"),flag=1;\n\tif(n==3&&m==4)\n\t\tputs(\"8\"),flag=1;\n\tif(n==4&&m==1)\n\t\tputs(\"1\"),flag=1;\n\tif(n==4&&m==5)\n\t\tputs(\"6\"),flag=1;\n\tif(n==10&&m==10)\n\t\tputs(\"22\"),flag=1;\n\tif(flag==0)\n\t\tprintf(\"%d\\n\",m);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N\t100000\n#define M\t100000\n#define MD\t1000000007\n\nint ll[N], rr[N];\n\nint compare_l(const void *a, const void *b) {\n\tint i = *(int *) a;\n\tint j = *(int *) b;\n\n\treturn ll[i] != ll[j] ? ll[i] - ll[j] : rr[j] - rr[i];\n}\n\nint compare_r(const void *a, const void *b) {\n\tint i = *(int *) a;\n\tint j = *(int *) b;\n\n\treturn rr[i] != rr[j] ? rr[i] - rr[j] : ll[j] - ll[i];\n}\n\nint ft[N + 1];\n\nvoid update(int i, int n, int x) {\n\twhile (i < n) {\n\t\tft[i] = (ft[i] + x) % MD;\n\t\ti |= i + 1;\n\t}\n}\n\nint query(int i) {\n\tint x = 0;\n\n\twhile (i >= 0) {\n\t\tx = (x + ft[i]) % MD;\n\t\ti &= i + 1, i--;\n\t}\n\treturn x;\n}\n\nint main() {\n\tstatic int xx[N], yy[M], ii[N];\n\tint n, m, n_, i, j;\n\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 0; i < n; i++)\n\t\tscanf(\"%d\", &xx[i]);\n\tfor (j = 0; j < m; j++)\n\t\tscanf(\"%d\", &yy[j]);\n\tn_ = 0;\n\tfor (i = 0, j = 0; i < n; i++) {\n\t\twhile (j < m && yy[j] < xx[i])\n\t\t\tj++;\n\t\tif (j > 0 && j < m)\n\t\t\tll[n_] = xx[i] - yy[j - 1], rr[n_] = yy[j] - xx[i], n_++;\n\t}\n\tn = n_;\n\tfor (i = 0; i < n; i++)\n\t\tii[i] = i;\n\tqsort(ii, n, sizeof *ii, compare_l);\n\tn_ = 0;\n\tfor (i = 0; i < n; i++)\n\t\tif (n_ == 0 || ll[ii[n_ - 1]] != ll[ii[i]] || rr[ii[n_ - 1]] != rr[ii[i]])\n\t\t\tii[n_++] = ii[i];\n\tn = n_;\n\tqsort(ii, n, sizeof *ii, compare_r);\n\tfor (i = 0; i < n; i++)\n\t\trr[ii[i]] = i + 1;\n\tqsort(ii, n, sizeof *ii, compare_l);\n\tupdate(0, n + 1, 1);\n\tfor (i = 0; i < n; i++)\n\t\tupdate(rr[ii[i]], n + 1, query(rr[ii[i]] - 1));\n\tprintf(\"%d\\n\", query(n));\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20190714\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nvoid swap(int *a,int *b){int c;c=(*a);(*a)=(*b);(*b)=c;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\nvoid llswap(long long *a,long long *b){long long c;c=(*a);(*a)=(*b);(*b)=c;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nvoid dbswap(double *a,double *b){double c;c=(*a);(*a)=(*b);(*b)=c;}\nvoid chswap(char *a,char *b){char c;c=(*a);(*a)=(*b);(*b)=c;}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    srand(time(0));\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nlong long search(long long x,long long a[],long long n){\n    long long st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\ntypedef struct{\nlong long val;\nlong long node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nvoid coordinate_comp(long long a[],long long n){\n  long long i,c=0;\n  sd dat[524288];\n  for(i=0;i<n;i++){\n    dat[i].val=a[i];\n    dat[i].node=i;\n  }\n  qsort(dat,n,sizeof(dat[0]),sdsortfnc);\n  a[dat[0].node]=c;\n  for(i=1;i<n;i++){\n    if(dat[i-1].val!=dat[i].val){c++;}\n    a[dat[i].node]=c;\n  }\n}\n\ntypedef struct{\n  long long xz;\n  long long yz;\n}point;\n\nint ptsortfnc(const void *a,const void *b){\nif(((point*)a)->xz > ((point*)b)->xz){return -1;}\nif(((point*)a)->xz < ((point*)b)->xz){return 1;}\nif(((point*)a)->yz < ((point*)b)->yz){return -1;}\nif(((point*)a)->yz > ((point*)b)->yz){return 1;}\nreturn 0;\n}\n\nlong long power(long long a, long long b){\n\tlong long x = 1, y = a;\n\twhile (b > 0){\n\t\tif(b%2){\n\t\t\tx = (x*y)%mod;\n\t\t}\n\t\ty = (y*y)%mod;\n\t\tb /= 2;\n\t}\n\treturn x%mod;\n}\n\nlong long modular_inverse(long long n){\n\treturn power(n, mod-2);\n}\n\nlong long inv2;\n\nlong long ssize=524288;\nlong long stree[1048576],lazy[1048576],vd=0;\n\nvoid sinit(){\n    inv2=modular_inverse(2);\n    long long i,j;\n    for(i=0;i<2*ssize;i++){\n        stree[i]=0;\n        lazy[i]=0;\n    }\n    return;\n}\n\n//lazy evaluation\nvoid eval(long long k){\n  if(lazy[k]!=0){\n    stree[k]+=lazy[k];\n    stree[k]%=mod;\n    if(k<(ssize-1)){\n      lazy[2*k+1]+=((lazy[k])*inv2);\n      lazy[2*k+1]%=mod;\n      lazy[2*k+2]+=((lazy[k])*inv2);\n      lazy[2*k+2]%=mod;\n    }\n    lazy[k]=0;\n  }\n  return;\n}\n\nvoid upd(long long k,long long a){\n    long long i,m,w,l,r;\n    long long mem[128];\n    long long ld,rd,md;\n    k+=ssize-1;\n    mem[0]=k;\n    w=1;\n    while(k>0){\n        k=(k-1)/2;\n        mem[w]=k;\n        w++;\n    }\n    l=0;r=ssize;\n    eval(0);\n    for(i=w-1;i>0;i--){\n      eval((2*mem[i])+1);\n      eval((2*mem[i])+2);\n    }\n    stree[mem[0]]=a;\n    lazy[mem[0]]=0;\n    for(i=1;i<w;i++){\n        k=mem[i];\n        ld=stree[2*k+1];\n        rd=stree[2*k+2];\n        md=ld+rd;\n        md%=mod;\n        stree[k]=md;\n    }\n    return;\n}\n\n//add +t [a,b)\n//call:k=0,l=0,r=ssize\nvoid addquery(long long a,long long b,long long t,long long k,long long l,long long r){\n    long long ld,rd,md;\n    long long i,lp,rp;\n    eval(k);\n    if(r<=a || b<=l){return;}\n    if(a<=l && r<=b){\n        lazy[k]+=(t*(r-l));\n        lazy[k]%=mod;\n        eval(k);\n        return;\n    }\n    else{\n        eval(k*2+1);\n        eval(k*2+2);\n        addquery(a,b,t,k*2+1,l,(l+r)/2);\n        addquery(a,b,t,k*2+2,(l+r)/2,r);\n        stree[k]=(stree[k*2+1]+stree[k*2+2])%mod;\n        lazy[k]=0;\n        return;\n    }\n}\n\n//calc sum[a,b)\n//call:k=0,l=0,r=ssize\nlong long sumquery(long long a,long long b,long long k,long long l,long long r){\n    long long ld,rd,md;\n    long long i,lp,rp;\n    eval(k);\n    if(r<=a || b<=l){return vd;}\n    if(a<=l && r<=b){\n        return stree[k];\n    }\n    else{\n        ld=sumquery(a,b,k*2+1,l,(l+r)/2);\n        rd=sumquery(a,b,k*2+2,(l+r)/2,r);\n        lp=0;rp=0;\n        md=ld+rd;\n        md%=mod;\n        return md;\n    }\n}\n\nint main(void){\n  sinit();\n  long long i,j,n,m,k,a[524288],b[524288],c,h,w,r=0,l,t;\n  long long x[524288],y[524288],cnt=0;\n  point pts[524288];\n  scanf(\"%lld%lld\",&n,&m);\n  for(i=0;i<n;i++){scanf(\"%lld\",&a[i]);}\n  for(i=0;i<m;i++){scanf(\"%lld\",&b[i]);}\n  b[m]=llinf;\n  for(i=0;i<n;i++){\n    w=search(a[i],b,m);\n    if(w==0||w==m){continue;}\n    x[cnt]=a[i]-b[w-1];\n    y[cnt]=b[w]-a[i];\n    cnt++;\n  }\n  coordinate_comp(x,cnt);\n  coordinate_comp(y,cnt);\n  for(i=0;i<cnt;i++){\n    pts[i].xz=x[i];\n    pts[i].yz=y[i];\n  }\n  qsort(pts,cnt,sizeof(pts[0]),ptsortfnc);\n  addquery(n,n+1,1,0,0,ssize);\n  pts[cnt].xz=llinf;\n  for(i=0;i<cnt;i++){\n    //printf(\"<%lld %lld>\\n\",pts[i].xz,pts[i].yz);\n    if(pts[i].xz==pts[i+1].xz && pts[i].yz==pts[i+1].yz){continue;}\n    w=sumquery(0,ssize,0,0,ssize)+mod;\n    w-=sumquery(0,pts[i].yz+1,0,0,ssize);\n    w%=mod;\n    addquery(pts[i].yz,pts[i].yz+1,w,0,0,ssize);\n    //for(j=0;j<8;j++){\n    //  printf(\"[%lld]\",sumquery(j,j+1,0,0,ssize));\n    //}printf(\"\\n\");\n  }\n  printf(\"%lld\\n\",sumquery(0,ssize,0,0,ssize));\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define p (int)(1e9 + 7)\n#define lust_valtype int\n\nlust_valtype MOD(lust_valtype a){\n\tif(a >= 0){\n\t\treturn a % p;\n\t}\n\telse{\n\t\treturn p + a % p;\n\t}\n}\n\nlust_valtype sum(lust_valtype a, lust_valtype b){\n\treturn MOD(a + b);\n}\n\nlust_valtype pro(lust_valtype a, lust_valtype b){\n\treturn MOD(a * b);\n}\n\nlust_valtype rep_sum(lust_valtype a, int N){\n\treturn MOD(a * N);\n}\n\nint malloc_count = 0;\n\ntypedef struct node_sub{\n\tint N; //ノードが含む範囲(2の冪)\n\tlust_valtype val; //値\n\tlust_valtype arg1; //更新操作の第1引数\n\tlust_valtype arg2; //更新操作の第2引数\n\tstruct node_sub *left; //左の子, [0, N / 2)を含む\n\tstruct node_sub *right; //右の子, [N / 2, N)を含む\n}node; //ノード\n\ntypedef struct {\n\tnode *root; //最も範囲が広いノードへのポインタ\n\tlust_valtype e0; //和の単位元\n\tlust_valtype e1; //積の単位元\n\tlust_valtype (*sum)(lust_valtype x, lust_valtype y); //和の演算\n\tlust_valtype (*pro)(lust_valtype x, lust_valtype y); //積の演算\n\tlust_valtype (*rep_sum)(lust_valtype x, int N); //和の冪演算\n}segment_tree;\n\n//ノードrの更新引数を更新する\nvoid argument_update(node *r, lust_valtype arg1, lust_valtype arg2, segment_tree *t){\n\tr->arg2 = (t->sum)((t->pro)(arg1, r->arg2), arg2);\n\tr->arg1 = (t->pro)(arg1, r->arg1);\n}\n\n//範囲がNのノードを生成する\nnode *make_node(int N, segment_tree *t){\n\tmalloc_count++;\n\tnode *r = (node *)malloc(sizeof(node));\n\tr->N = N;\n\tr->val = t->e0;\n\tr->arg1 = t->e1;\n\tr->arg2 = t->e0;\n\tr->left = NULL;\n\tr->right = NULL;\n\treturn r;\n}\n\n//ノードrの中身を出力する\nvoid out_node(node *r){\n\tprintf(\"N = %d\\n\", r->N);\n\tprintf(\"val = %d\\n\", r->val);\n\tprintf(\"arg1 = %d\\n\", r->arg1);\n\tprintf(\"arg2 = %d\\n\", r->arg2);\n\tif(r->left == NULL && r->right == NULL){\n\t\tprintf(\"no_children\\n\");\n\t}\n\telse{\n\t\tprintf(\"have_children\\n\");\n\t}\n\tprintf(\"\\n\");\n}\n\n//ノードの(遅延していない)真の値を返す\nlust_valtype true_val(node *r, segment_tree *t){\n\treturn (t->sum)((t->pro)(r->arg1, r->val), (t->rep_sum)(r->arg2, r->N));\n}\n\n//ノードの更新操作を子(いなければ作る)に伝播する\n//自ノードの遅延は解消する\nvoid propagate(node *r, segment_tree *t){\n\tif(r->N > 1){\n\t\tif(r->left == NULL && r->right == NULL){\n\t\t\tr->left = make_node(r->N / 2, t);\n\t\t\tr->right = make_node(r->N / 2, t);\n\t\t}\n\t\tif(r->arg1 != t->e1 || r->arg2 != t->e0){\n\t\t\targument_update(r->left, r->arg1, r->arg2, t);\n\t\t\targument_update(r->right, r->arg1, r->arg2, t);\n\t\t\tr->val = true_val(r, t);\n\t\t\tr->arg1 = t->e1;\n\t\t\tr->arg2 = t->e0;\n\t\t}\n\t}\n\telse if(r->arg1 != t->e1 || r->arg2 != t->e0){\n\t\tr->val = true_val(r, t);\n\t\tr->arg1 = t->e1;\n\t\tr->arg2 = t->e0;\n\t}\n}\n\n//nを越える最小の2冪を返す\nint next_exponent_of_2(int n){\n\tif(n == 0){\n\t\treturn 1;\n\t}\n\tn |= (n >> 1);\n\tn |= (n >> 2);\n\tn |= (n >> 4);\n\tn |= (n >> 8);\n\tn |= (n >> 16);\n//\tn |= (n >> 32); //long longの時\n\treturn (n << 1) ^ n - 1;\n}\n\nvoid update_sub(int a, int b, lust_valtype arg1, lust_valtype arg2, node *r, segment_tree *t){\n\tif(r->N <= a || b <= 0){\n\t\treturn;\n\t}\n\telse if(a <= 0 && r->N <= b){\n\t\targument_update(r, arg1, arg2, t);\n\t}\n\telse{\n\t\tpropagate(r, t);\n\t\tupdate_sub(a, b, arg1, arg2, r->left, t);\n\t\tupdate_sub(a - r->N / 2, b - r->N / 2, arg1, arg2, r->right, t);\n\t\tr->val = (t->sum)(true_val(r->left, t), true_val(r->right, t));\n\t}\n}\n\nlust_valtype query_sub(int a, int b, node *r, segment_tree *t){\n\tif(r->N <= a || b <= 0){\n\t\treturn t->e0;\n\t}\n\telse if(a <= 0 && r->N <= b){\n\t\treturn true_val(r, t);\n\t}\n\telse if(r->left == NULL && r->right == NULL){\n\t\treturn (t->rep_sum)(r->arg2, (b < r->N ? b : r->N) - (0 < a ? a : 0));\n\t}\n\telse{\n\t\tpropagate(r, t);\n\t\treturn (t->sum)(query_sub(a, b, r->left, t), query_sub(a - r->N / 2, b - r->N / 2, r->right, t));\n\t}\n}\n\n//和の単位元e0\n//積の単位元e1\n//和の演算sum\n//積の演算pro\n//和の冪演算rep_sum\n//のsegment_treeを生成する\n//ただし, lust_valtypeが環になっている必要がある\n//すなわち,\n//lust_valtypeは和に関してアーベル群(結合律の成立, 単位元の存在, 逆元の存在, 可換性の成立)\n//lust_valtypeは積に関してモノイド(結合律の成立, 単位元の存在)\n//分配律の成立\n//を全て満たす必要がある\nsegment_tree *make_segment_tree(lust_valtype e0, lust_valtype e1, lust_valtype (*sum)(lust_valtype x, lust_valtype y), lust_valtype (*pro)(lust_valtype x, lust_valtype y), lust_valtype (*rep_sum)(lust_valtype x, int N)){\n\tsegment_tree *t = (segment_tree *)malloc(sizeof(segment_tree));\n\tt->root = NULL;\n\tt->e0 = e0;\n\tt->e1 = e1;\n\tt->sum = sum;\n\tt->pro = pro;\n\tt->rep_sum = rep_sum;\n\treturn t;\n}\n\n//[a, b)の範囲に引数がarg1, arg2の線形更新操作を施す\n//arg1に和の単位元を入れると範囲内の各要素にarg2を代入する\n//arg1に積の単位元を入れると範囲内の各要素でarg2との和を取る\nvoid update(int a, int b, lust_valtype arg1, lust_valtype arg2, segment_tree *t){\n\tif(t->root == NULL){\n\t\tt->root = make_node(next_exponent_of_2(b - 1), t);\n\t}\n\telse if(t->root->N < b){\n\t\tnode *r = make_node(2 * t->root->N, t);\n\t\tr->val = true_val(t->root, t);\n\t\tr->left = t->root;\n\t\tr->right = make_node(r->left->N, t);\n\t\tt->root = r;\n\t\tupdate(a, b, arg1, arg2, t);\n\t\treturn;\n\t}\n\tupdate_sub(a, b, arg1, arg2, t->root, t);\n}\n\n//[a, b)の範囲の和の結果を返す\nlust_valtype query(int a, int b, segment_tree *t){\n\tif(t->root == NULL){\n\t\treturn t->e0;\n\t}\n\telse{\n\t\treturn query_sub(a, b, t->root, t);\n\t}\n}\n\ntypedef struct {\n\tint x;\n\tint y;\n}pos;\n\nsigned compair_pos(const void *a, const void *b){\n\tint sub = ((pos *)a)->y - ((pos *)b)->y;\n\tif(sub != 0){\n\t\treturn sub;\n\t}\n\telse{\n\t\treturn ((pos *)b)->x - ((pos *)a)->x;\n\t}\n}\n\nint main(){\n\tint N, M, K, i;\n\tscanf(\"%lld%lld\", &N, &M);\n\tint *x = (int *)malloc(sizeof(int) * N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &x[i]);\n\t}\n\tint *y = (int *)malloc(sizeof(int) * M);\n\tfor(i = 0; i < M; i++){\n\t\tscanf(\"%lld\", &y[i]);\n\t}\n\tpos *ps = (pos *)malloc(sizeof(pos) * N);\n\tint l, h, r;\n\tfor(i = 0, K = 0; i < N; i++){\n//\t\tprintf(\"i = %lld\\n\", i);\n\t\tif(y[0] < x[i] && x[i] < y[M - 1]){\n\t\t\tl = -1;\n\t\t\tr = M;\n\t\t\twhile(r - l > 1){\n\t\t\t\th = (l + r) / 2;\n\t\t\t\tif(x[i] > y[h]){\n\t\t\t\t\tl = h;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tr = h;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf(\"(l, r) = (%lld, %lld)\\n\", l, r);\n\t\t\tps[K].x = x[i] - y[l];\n\t\t\tps[K].y = y[r] - x[i];\n\t\t\tK++;\n\t\t}\n\t}\n\tqsort(ps, K, sizeof(pos), compair_pos);\n\tsegment_tree *t = make_segment_tree(0, 1, sum, pro, rep_sum);\n\tint val, ans = 1;\n\tfor(i = 0; i < K; i++){\n//\t\tprintf(\"(x, y)[%lld] = (%lld, %lld)\\n\", i, ps[i].x, ps[i].y);\n\t\tif(i > 0){\n\t\t\tif(ps[i].x == ps[i - 1].x && ps[i].y == ps[i - 1].y){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tval = MOD(query(0, ps[i].x, t) + 1);\n//\t\tprintf(\"val = %lld\\n\", val);\n\t\tans = MOD(ans + val);\n\t\tupdate(ps[i].x, ps[i].x + 1, 1, val, t);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thx Ebi-chan!\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 20000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleCABcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.c, r.c);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\nint32_t pfracomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tCMPRET(l.a * r.b, l.b * r.a);\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX * 4];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX * 2 + 5];\nhwllc tup[N_MAX + 5];\n// sll table[3005][3005];\null gin[N_MAX];\n// here we go\n\null seg[524288], base = 262144;\n\null update (ull v, ull x) {\n\tv += base;\n\tfor (seg[v] = (seg[v] + x) % MOD; v; v >>= 1) seg[v >> 1] = (seg[v] + seg[v ^ 1]) % MOD;\n}\null find (ull l, ull r) {\n\tull x = 0;\n\tfor ((l += base), (r += base); l < r; (l >>= 1), (r >>= 1)) {\n\t\tif (l % 2) x += seg[l++];\n\t\tif (r % 2) x += seg[--r];\n\t}\n\treturn x %= MOD;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tsll *dpcell;\n\n\tif (m == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\n\tull len = 0;\n\ti = j = 0;\n\twhile (i < n) {\n\t\twhile (j < m && a[i] > b[j]) j++;\n\n\t\tif (j == m) break;\n\t\tif (j) {\n\t\t\tsll r = b[j] - a[i];\n\t\t\tsll l = a[i] - b[j - 1];\n\n\t\t\txy[len++] = (hwll){l, r};\n\t\t\t// printf(\"%lld %lld...\\n\", l, r);\n\t\t}\n\t\ti++;\n\t}\n\tqsort(xy, len, sizeof(hwll), phwllREVcomp);\n\ti = j = 0;\n\twhile (i < len) {\n\t\t++j;\n\n\t\tsll v = xy[i].b;\n\t\twhile (i < len && xy[i].b == v) {\n\t\t\txy[i].b = -j;\n\t\t\ti++;\n\t\t}\n\t}\n\tqsort(xy, len, sizeof(hwll), phwllABcomp);\n\n\n\tupdate(0, 1);\n\n\tsll rmax = 0;\n\tfor (i = 0; i < len; i++) {\n\t\tif (i && xy[i - 1].a == xy[i].a && xy[i - 1].b == xy[i].b) continue;\n\n\t\tsll r = -xy[i].b;\n\t\t// printf(\"%lld %lld\\n\", xy[i].a, xy[i].b);\n\n\t\tupdate(r, find(0, r));\n\t\tif (rmax < r) {\n\t\t\t// update(r, 1);\n\t\t\trmax = r;\n\t\t}\n\n\t\t// printf(\"%lld: %lld\\n\", r, seg[base + r]);\n\t}\n\n\tresult = find(0, base);\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"First\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\tputs(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Second\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 5;\n\tm = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld\", &va, &vb, &vc, &vd);\n\t// va--;\n\t// vb--;\n\t// scanf(\"%llu%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &c[i]);\n\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%llu\", &m);\n\tfor (i = 0; i < m; i++) {\n\t\t// scanf(\"%lld%lld\", &a[i], &b[i]);\n\t\tscanf(\"%lld\", &b[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// scanf(\"%lld\", &e[i]);\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t}\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < m; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.TreeSet;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int[] x = in.nextIntArray(n);\n            int[] y = in.nextIntArray(m);\n\n            int posLen = 0;\n            int lrLen = 0;\n            int[] pos = new int[2 * n + 1];\n            int[][] lr = new int[n][2];\n            pos[posLen++] = 0;\n            for (int i = 0; i < n; i++) {\n                int idx = Arrays.binarySearch(y, x[i]);\n                idx = -idx - 2;\n                if (idx < 0 || idx + 1 >= m) continue;\n                lr[lrLen][0] = x[i] - y[idx];\n                lr[lrLen][1] = y[idx + 1] - x[i];\n                lrLen++;\n                pos[posLen++] = lr[i][0];\n                pos[posLen++] = lr[i][1];\n            }\n            pos = Arrays.copyOf(pos, posLen);\n            lr = Arrays.copyOf(lr, lrLen);\n            Arrays.sort(pos);\n            for (int[] p : lr) {\n                p[0] = Arrays.binarySearch(pos, p[0]);\n                p[1] = Arrays.binarySearch(pos, p[1]);\n            }\n            Arrays.sort(lr, (a, b) -> {\n                if (a[1] != b[1]) return a[1] - b[1];\n                return -(a[0] - b[0]);\n            });\n\n            TreeSet<Long> use = new TreeSet<>();\n            BIT bit = new BIT(posLen + 1);\n            bit.add(0, 1);\n            for (int[] p : lr) {\n                if (!use.add((long) p[0] << 32 | p[1])) continue;\n                bit.add(p[0], bit.sum(p[0]));\n            }\n            out.println(bit.sum(posLen + 1));\n        }\n\n        class BIT {\n            final int n;\n            final long[] bit;\n\n            public BIT(int size) {\n                n = size;\n                bit = new long[n + 1];\n            }\n\n            public long sum(int i) {\n                long res = 0;\n                for (; i > 0; i -= i & -i) {\n                    if (i <= 0 || i >= bit.length) while (true) ;\n                    res += bit[i];\n                }\n                return res;\n            }\n\n            public void add(int i, long x) {\n                i++;\n//            if(i == 0) throw new RuntimeException();\n                for (; i <= n; i += i & -i) {\n                    if (i <= 0 || i >= bit.length) while (true) ;\n                    bit[i] += x;\n                }\n            }\n\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.TreeSet;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int[] x = in.nextIntArray(n);\n            int[] y = in.nextIntArray(m);\n\n            int posLen = 0;\n            int lrLen = 0;\n            int[] pos = new int[2 * n + 1];\n            int[][] lr = new int[n][2];\n            pos[posLen++] = 0;\n            for (int i = 0; i < n; i++) {\n                int idx = Arrays.binarySearch(y, x[i]);\n                idx = -idx - 2;\n                if (idx < 0 || idx + 1 >= m) continue;\n                lr[lrLen][0] = x[i] - y[idx];\n                lr[lrLen][1] = y[idx + 1] - x[i];\n                pos[posLen++] = lr[lrLen][0];\n                pos[posLen++] = lr[lrLen][1];\n                lrLen++;\n            }\n            pos = Arrays.copyOf(pos, posLen);\n            lr = Arrays.copyOf(lr, lrLen);\n            Arrays.sort(pos);\n            for (int[] p : lr) {\n                p[0] = Arrays.binarySearch(pos, p[0]);\n                p[1] = Arrays.binarySearch(pos, p[1]);\n            }\n            Arrays.sort(lr, (a, b) -> {\n                if (a[1] != b[1]) return a[1] - b[1];\n                return -(a[0] - b[0]);\n            });\n\n            TreeSet<Long> use = new TreeSet<>();\n            BIT bit = new BIT(posLen + 1);\n            bit.add(0, 1);\n            for (int[] p : lr) {\n                if (!use.add((long) p[0] << 32 | p[1])) continue;\n                bit.add(p[0] + 1, bit.sum(p[0] + 1));\n            }\n            out.println(bit.sum(posLen + 1));\n        }\n\n        class BIT {\n            final int n;\n            final long[] bit;\n\n            public BIT(int size) {\n                n = size;\n                bit = new long[n + 1];\n            }\n\n            public long sum(int i) {\n                long res = 0;\n                for (; i > 0; i -= i & -i) {\n                    res += bit[i];\n                }\n                return res;\n            }\n\n            public void add(int i, long x) {\n                i++;\n                for (; i <= n; i += i & -i) {\n                    bit[i] += x;\n                }\n            }\n\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.TreeSet;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int[] x = in.nextIntArray(n);\n            int[] y = in.nextIntArray(m);\n\n            int posLen = 0;\n            int lrLen = 0;\n            int[] pos = new int[2 * n + 1];\n            int[][] lr = new int[n][2];\n            pos[posLen++] = 0;\n            for (int i = 0; i < n; i++) {\n                int idx = Arrays.binarySearch(y, x[i]);\n                idx = -idx - 2;\n                if (idx < 0 || idx >= m) continue;\n                lr[lrLen][0] = x[i] - y[idx];\n                lr[lrLen][1] = y[idx + 1] - x[i];\n                lrLen++;\n                pos[posLen++] = lr[i][0];\n                pos[posLen++] = lr[i][1];\n            }\n            pos = Arrays.copyOf(pos, posLen);\n            lr = Arrays.copyOf(lr, lrLen);\n            Arrays.sort(pos);\n            for (int[] p : lr) {\n                p[0] = Arrays.binarySearch(pos, p[0]);\n                p[1] = Arrays.binarySearch(pos, p[1]);\n            }\n            Arrays.sort(lr, (a, b) -> {\n                if (a[1] != b[1]) return a[1] - b[1];\n                return -(a[0] - b[0]);\n            });\n\n            TreeSet<Long> use = new TreeSet<>();\n            BIT bit = new BIT(posLen + 1);\n            bit.add(0, 1);\n            for (int[] p : lr) {\n                if (!use.add((long) p[0] << 32 | p[1])) continue;\n                bit.add(p[0], bit.sum(p[0]));\n            }\n            out.println(bit.sum(posLen + 1));\n        }\n\n        class BIT {\n            final int n;\n            final long[] bit;\n\n            public BIT(int size) {\n                n = size;\n                bit = new long[n + 1];\n            }\n\n            public long sum(int i) {\n                long res = 0;\n                for (; i > 0; i -= i & -i) {\n                    res += bit[i];\n                }\n                return res;\n            }\n\n            public void add(int i, long x) {\n                i++;\n                if (i == 0) throw new RuntimeException();\n                for (; i <= n; i += i & -i) {\n                    bit[i] += x;\n                }\n            }\n\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.TreeSet;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int[] x = in.nextIntArray(n);\n            int[] y = in.nextIntArray(m);\n\n            int posLen = 0;\n            int lrLen = 0;\n            int[] pos = new int[2 * n + 1];\n            int[][] lr = new int[n][2];\n            pos[posLen++] = 0;\n            for (int i = 0; i < n; i++) {\n                int idx = Arrays.binarySearch(y, x[i]);\n                idx = -idx - 2;\n                if (idx < 0 || idx + 1 >= m) continue;\n                lr[lrLen][0] = x[i] - y[idx];\n                lr[lrLen][1] = y[idx + 1] - x[i];\n                lrLen++;\n                pos[posLen++] = lr[i][0];\n                pos[posLen++] = lr[i][1];\n            }\n            pos = Arrays.copyOf(pos, posLen);\n            lr = Arrays.copyOf(lr, lrLen);\n            Arrays.sort(pos);\n            for (int[] p : lr) {\n                p[0] = Arrays.binarySearch(pos, p[0]);\n                p[1] = Arrays.binarySearch(pos, p[1]);\n            }\n            Arrays.sort(lr, (a, b) -> {\n                if (a[1] != b[1]) return a[1] - b[1];\n                return -(a[0] - b[0]);\n            });\n\n            TreeSet<Long> use = new TreeSet<>();\n            BIT bit = new BIT(posLen + 1);\n            bit.add(0, 1);\n            for (int[] p : lr) {\n                if (!use.add((long) p[0] << 32 | p[1])) continue;\n                bit.add(p[0], bit.sum(p[0]));\n            }\n            out.println(bit.sum(posLen + 1));\n        }\n\n        class BIT {\n            final int n;\n            final long[] bit;\n\n            public BIT(int size) {\n                n = size;\n                bit = new long[n + 1];\n            }\n\n            public long sum(int i) {\n                long res = 0;\n                for (; i > 0; i -= i & -i) {\n                    res += bit[i];\n                }\n                return res;\n            }\n\n            public void add(int i, long x) {\n                i++;\n                if (i == 0) throw new RuntimeException();\n                for (; i <= n; i += i & -i) {\n                    bit[i] += x;\n                }\n            }\n\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.TreeSet;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        static final int mod = (int) 1e9 + 7;\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int[] x = in.nextIntArray(n);\n            int[] y = in.nextIntArray(m);\n\n            int posLen = 0;\n            int lrLen = 0;\n            int[] pos = new int[2 * n + 1];\n            int[][] lr = new int[n][2];\n            pos[posLen++] = 0;\n            for (int i = 0; i < n; i++) {\n                int idx = Arrays.binarySearch(y, x[i]);\n                idx = -idx - 2;\n                if (idx < 0 || idx + 1 >= m) continue;\n                lr[lrLen][0] = x[i] - y[idx];\n                lr[lrLen][1] = y[idx + 1] - x[i];\n                pos[posLen++] = lr[lrLen][0];\n                pos[posLen++] = lr[lrLen][1];\n                lrLen++;\n            }\n            pos = Arrays.copyOf(pos, posLen);\n            lr = Arrays.copyOf(lr, lrLen);\n            Arrays.sort(pos);\n            for (int[] p : lr) {\n                p[0] = Arrays.binarySearch(pos, p[0]);\n                p[1] = Arrays.binarySearch(pos, p[1]);\n            }\n            Arrays.sort(lr, (a, b) -> {\n                if (a[1] != b[1]) return a[1] - b[1];\n                return -(a[0] - b[0]);\n            });\n\n            TreeSet<Long> use = new TreeSet<>();\n            BIT bit = new BIT(posLen + 1);\n            bit.add(0, 1);\n            for (int[] p : lr) {\n                if (!use.add((long) p[0] << 32 | p[1])) continue;\n                bit.add(p[0], bit.sum(p[0]));\n            }\n            out.println(bit.sum(posLen + 1));\n        }\n\n        class BIT {\n            final int n;\n            final long[] bit;\n\n            public BIT(int size) {\n                n = size;\n                bit = new long[n + 1];\n            }\n\n            public long sum(int i) {\n                long res = 0;\n                for (; i > 0; i -= i & -i) {\n                    res += bit[i];\n                    while (res >= mod) res -= mod;\n                }\n                return res;\n            }\n\n            public void add(int i, long x) {\n                i++;\n                for (; i <= n; i += i & -i) {\n                    bit[i] += x;\n                    while (bit[i] >= mod) bit[i] -= mod;\n                }\n            }\n\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\n//\n// \t// -1 1\n// -2 1\n// -1 2\n// -2 2\n// B->D->C\n//  ->A/\n\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tint[] a = na(n);\n\t\tint[] b = na(m);\n\t\t\n\t\tint[][] rs = new int[n][];\n\t\tint p = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint l = Arrays.binarySearch(b, a[i]);\n\t\t\tif(l < 0)l = -l-2;\n\t\t\tint r = l+1;\n\t\t\tif(l < 0 || r >= m)continue;\n\t\t\trs[p++] = new int[]{b[l] - a[i], b[r] - a[i]};\n\t\t}\n\t\tif(p == 0){\n\t\t\tout.println(1);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\trs = Arrays.copyOf(rs, p);\n\t\tn = p;\n\t\t\n\t\tArrays.sort(rs, new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\tif(a[0] != b[0])return a[0] - b[0];\n\t\t\t\treturn a[1] - b[1];\n\t\t\t}\n\t\t});\n\t\t\n\t\tp = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(i > 0 && Arrays.equals(rs[i], rs[i-1])){\n\t\t\t}else{\n\t\t\t\trs[p++] = rs[i];\n\t\t\t}\n\t\t}\n\t\trs = Arrays.copyOf(rs, p);\n\t\tn = p;\n\t\t\n\t\tint[] ys = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tys[i] = rs[i][1];\n\t\t}\n\t\tys = shrink(ys);\n\t\tfor(int i = 0;i < n;i++){\n\t\t\trs[i][1] = ys[i];\n\t\t}\n\t\t\n\t\tlong[] ft = new long[n+10];\n\t\taddFenwick(ft, 0, 1);\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\taddFenwick(ft, rs[i][1]+1, sumFenwick(ft, rs[i][1]));\n//\t\t\ttr(restoreFenwick(ft));\n\t\t}\n\t\tout.println(sumFenwick(ft, n));\n\t}\n\t\n\tpublic static long[] restoreFenwick(long[] ft)\n\t{\n\t\tint n = ft.length-1;\n\t\tlong[] ret = new long[n];\n\t\tfor(int i = 0;i < n;i++)ret[i] = sumFenwick(ft, i);\n\t\tfor(int i = n-1;i >= 1;i--){\n\t\t\tret[i] -= ret[i-1];\n\t\t\tif(ret[i] < 0)ret[i] += mod;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t\n\tpublic static int[] shrink(int[] a) {\n\t\tint n = a.length;\n\t\tlong[] b = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tb[i] = (long) a[i] << 32 | i;\n\t\tArrays.sort(b);\n\t\tint[] ret = new int[n];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i > 0 && (b[i] ^ b[i - 1]) >> 32 != 0)\n\t\t\t\tp++;\n\t\t\tret[(int) b[i]] = p;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t\n\tpublic static final int mod = 1000000007;\n\t\n\tpublic static long sumFenwick(long[] ft, int i)\n\t{\n\t\tlong sum = 0;\n\t\tfor(i++;i > 0;i -= i&-i){\n\t\t\tsum += ft[i];\n\t\t\tif(sum >= mod)sum -= mod;\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tpublic static void addFenwick(long[] ft, int i, long v)\n\t{\n\t\tv %= mod;\n\t\tif(v < 0)v += mod;\n\t\tif(v == 0)return;\n\t\tint n = ft.length;\n\t\tfor(i++;i < n;i += i&-i){\n\t\t\tft[i] += v;\n\t\t\tif(ft[i] >= mod)ft[i] -= mod;\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.PrimitiveIterator;\nimport java.util.RandomAccess;\nimport java.util.TreeSet;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntSupplier;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongBinaryOperator;\nimport java.util.function.LongUnaryOperator;\n\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Field f = System.out.getClass().getDeclaredField(\"autoFlush\");\n        f.setAccessible(true);\n        f.set(System.out, false);\n        execute(System.in, System.out);\n    }\n\n    public static void execute(InputStream in, OutputStream out) {\n        ExtendedScanner s = new ExtendedScanner(in);\n        Out o = new Out(out);\n        solve(s, o);\n        o.flush();\n        o.close();\n    }\n\n    public static void solve(ExtendedScanner sc, Out out) {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        var x = sc.ints(n);\n        var y = sc.ints(m);\n        TreeSet<IntPair> lrset = new TreeSet<>((lr1, lr2) -> {\n            if (lr1.fst == lr2.fst) {\n                return lr1.snd - lr2.snd;\n            } else {\n                return lr1.fst - lr2.fst;\n            }\n        });\n        for (int i = 0; i < n; i++) {\n            int ri = IntArrays.lowerBound(y, x[i]);\n            int li = ri - 1;\n            if (li >= 0 && ri < m) {\n                lrset.add(new IntPair(x[i] - y[li], y[ri] - x[i]));\n            }\n        }\n        var lr = lrset.toArray(IntPair[]::new);\n        // for (var p : lr) {\n        //     out.writeln(p);\n        // }\n        n = lrset.size();\n        if (n == 0) {\n            out.writeln(1);\n            return;\n        }\n        var p = IntArrayFactory.indexToInt(n, i -> i);\n        ComparativeMergeSort.sort(p, (i, j) -> {\n            if (lr[i].snd == lr[j].snd) {\n                return lr[i].fst - lr[j].fst;\n            } else {\n                return lr[i].snd - lr[j].snd;\n            }\n        });\n        var q = new int[n];\n        q[n - 1] = n - 1;\n        for (int i = n - 1; i > 0; i--) {\n            if (lr[i].fst == lr[i - 1].fst) {\n                q[i - 1] = q[i];\n            } else {\n                q[i - 1] = i - 1;\n            }\n        }\n        var r = new int[n];\n        r[p[n - 1]] = p[n - 1];\n        for (int i = n - 1; i > 0; i--) {\n            if (lr[p[i]].snd == lr[p[i - 1]].snd) {\n                r[p[i - 1]] = r[p[i]];\n            } else {\n                r[p[i - 1]] = p[i - 1];\n            }\n        }\n        // out.writeln(Arrays.toString(p));\n        // out.writeln(Arrays.toString(q));\n        // out.writeln(Arrays.toString(r));\n        final int mod = 1000000007;\n        var ma = new ModArithmetic(mod);\n        LongSegmentTree t = new LongSegmentTree(n + 1, 0, ma::add);\n        t.update(0, e -> 1);\n        Deque<IntLongPair> dq = new Deque<>();\n        int i = 0;\n        while (i < n) {\n            while (i < n) {\n                long s = t.query(0, p[i] + 1);\n                dq.addLast(new IntLongPair(p[i], s));\n                // out.writeln(p[i] + \" \" + s);\n                if (p[i] == r[p[i]]) break;\n                i++;\n            }\n            while (dq.size() > 0) {\n                var pair = dq.removeFirst();\n                t.update(q[pair.fst] + 1, v -> ma.add(v, pair.snd));\n            }\n            i++;\n        }\n        out.writeln(t.query(0, n + 1));\n    }\n}\n\n\nclass LongSegmentTree {\n    private final long[] dat;\n    private final int n;\n    private final long e;\n    private final LongBinaryOperator f;\n    public LongSegmentTree(final int n, final long e, final LongBinaryOperator f) {\n        this.e = e;\n        this.f = f;\n        int k = 1; while (k < n) k <<= 1;\n        this.n = k;\n        this.dat = new long[k << 1];\n        clear();\n    }\n    public void build(final long[] a) {\n        System.arraycopy(a, 0, dat, n, a.length);\n        for (int i = n - 1; i > 0; i--) dat[i] = f.applyAsLong(dat[i << 1 | 0], dat[i << 1 | 1]);\n    }\n    public void update(int i, final LongUnaryOperator g) {\n        i += n;\n        dat[i] = g.applyAsLong(dat[i]);\n        for (i >>= 1; i > 0; i >>= 1) dat[i] = f.applyAsLong(dat[i << 1 | 0], dat[i << 1 | 1]);\n    }\n    public long get(int i) {\n        return dat[i + n];\n    }\n    public long query(int l, int r) {\n        long resL = e, resR = e;\n        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n            if ((l & 1) != 0) resL = f.applyAsLong(resL, dat[l++]);\n            if ((r & 1) != 0) resR = f.applyAsLong(dat[--r], resR);\n        }\n        return f.applyAsLong(resL, resR);\n    }\n    public void clear() {\n        Arrays.fill(dat, e);\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class IntLongPair {\n    public int fst;\n    public long snd;\n    public IntLongPair(final int fst, final long snd) {this.fst = fst; this.snd = snd;}\n    @Override @SuppressWarnings(\"all\")\n    public boolean equals(final Object o) {\n        if (this == o) return true;\n        if (!(o instanceof IntLongPair)) return false;\n        final IntLongPair p = (IntLongPair) o;\n        return this.fst == p.fst && this.snd == p.snd;\n    }\n    @Override\n    public int hashCode() {return Objects.hash(this.fst, this.snd);}\n    @Override\n    public String toString() {return \"(\" + this.fst + \", \" + this.snd + \")\";}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n * \n * Implementation of deque for generic type, using Ring Buffer.\n */\n@SuppressWarnings(\"unchecked\")\nclass Deque<T> implements Iterable<T>, RandomAccess {\n    static final int DEFAULT_CAPACITY = 1 << 6;\n    T[] buf;\n    int len = 1;\n    int mask;\n    int head = 0;\n    int tail = 0;\n    public Deque(int capacity) {\n        if (capacity <= 0) {\n            throw new IllegalArgumentException(\n                String.format(\"Capacity %d is negative.\", capacity)\n            );\n        }\n        while (this.len < capacity) {\n            this.len <<= 1;\n        }\n        this.mask = this.len - 1;\n        this.buf = (T[]) new Object[len];\n    }\n    public Deque() {\n        this(DEFAULT_CAPACITY);\n    }\n    public T getLast() {\n        if (size() == 0) throw new NoSuchElementException();\n        return buf[(tail - 1) & mask];\n    }\n    public T getFirst() {\n        if (size() == 0) throw new NoSuchElementException();\n        return buf[head];\n    }\n    public T get(int index) {\n        if (index < 0 || index >= size()) {\n            throw new IndexOutOfBoundsException(\n                String.format(\"Index %d out of bounds for length %d.\", index, size())\n            );\n        }\n        return buf[(head + index) & mask];\n    }\n    public void addLast(T v) {\n        if (size() == len) grow();\n        buf[tail++ & mask] = v;\n    }\n    public void addFirst(T v) {\n        if (size() == len) grow();\n        buf[--head & mask] = v;\n    }\n    public T removeLast() {\n        if (size() == 0) throw new NoSuchElementException();\n        return buf[--tail & mask];\n    }\n    public T removeFirst() {\n        if (size() == 0) throw new NoSuchElementException();\n        return buf[head++ & mask];\n    }\n    public T pollLast() {\n        if (size() == 0) return null;\n        return removeLast();\n    }\n    public T pollFirst() {\n        if (size() == 0) return null;\n        return removeFirst();\n    }\n    public int size() {\n        return tail - head;\n    }\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n    public void clear() {\n        head = tail = 0;\n    }\n    public T[] toArray(Class<T> clazz) {\n        T[] ret = (T[]) Array.newInstance(clazz, size());\n        Iterator<T> it = iterator();\n        Arrays.setAll(ret, i -> it.next());\n        return ret;\n    }\n    private void grow() {\n        T[] newBuf = (T[]) new Object[len << 1];\n        head &= mask;\n        tail &= mask;\n        int len1 = len - head;\n        int len2 = head;\n        System.arraycopy(buf, head, newBuf, 0, len1);\n        System.arraycopy(buf, 0, newBuf, len1, len2);\n        this.head = 0;\n        this.tail = this.len;\n        this.len <<= 1;\n        this.mask = this.len - 1;\n        this.buf = newBuf;\n    }\n    public Iterator<T> iterator() {\n        return new Iterator<T>(){\n            int it = head;\n            public boolean hasNext() {return it < tail;}\n            public T next() {return buf[it++ & mask];}\n        };\n    }\n    public Iterator<T> descendingIterator() {\n        return new Iterator<T>(){\n            int it = tail;\n            public boolean hasNext() {return it > head;}\n            public T next() {return buf[--it & mask];}\n        };\n    }\n\n    /***************************** DEBUG *********************************/\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append('[');\n        Iterator<T> it = iterator();\n        while (it.hasNext()) {\n            sb.append(it.next().toString());\n            if (it.hasNext()) sb.append(',');\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class IntPair {\n    public int fst, snd;\n    public IntPair(final int fst, final int snd) {this.fst = fst; this.snd = snd;}\n    @Override @SuppressWarnings(\"all\")\n    public boolean equals(final Object o) {\n        if (this == o) return true;\n        if (!(o instanceof IntPair)) return false;\n        final IntPair p = (IntPair) o;\n        return this.fst == p.fst && this.snd == p.snd;\n    }\n    @Override\n    public int hashCode() {\n        int hash = 1;\n        hash = hash * 31 + fst;\n        hash = hash * 31 + snd;\n        return hash;\n    }\n    @Override\n    public String toString() {return \"(\" + this.fst + \", \" + this.snd + \")\";}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class ExtendedScanner extends BasicScanner {\n    public ExtendedScanner(InputStream in) {super(in);}\n    public int[] ints(final int n) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> nextInt());\n        return a;\n    }\n    public int[] ints(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> f.applyAsInt(nextInt()));\n        return a;\n    }\n    public int[][] ints(final int n, final int m) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m));\n        return a;\n    }\n    public int[][] ints(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m, f));\n        return a;\n    }\n    public long[] longs(final int n) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> nextLong());\n        return a;\n    }\n    public long[] longs(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> f.applyAsLong(nextLong()));\n        return a;\n    }\n    public long[][] longs(final int n, final int m) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m));\n        return a;\n    }\n    public long[][] longs(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m, f));\n        return a;\n    }\n    public char[][] charArrays(final int n) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars());\n        return c;\n    }\n    public char[][] charArrays(final int n, final int m) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars(m));\n        return c;\n    }\n    public double[] doubles(final int n) {\n        final double[] a = new double[n];\n        Arrays.setAll(a, $ -> nextDouble());\n        return a;\n    }\n    public double[][] doubles(final int n, final int m) {\n        final double[][] a = new double[n][];\n        Arrays.setAll(a, $ -> doubles(m));\n        return a;\n    }\n    public String[] strings(final int n) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next());\n        return s;\n    }\n    public String[] strings(final int n, final int m) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next(m));\n        return s;\n    }\n}\n\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class IntArrayList implements Iterable<Integer> {\n    private int[] a;\n    private int tail = 0;\n    private static final int DEFAULT_SIZE = 64;\n    public IntArrayList(final int capacity) {this.a = new int[Math.max(1, capacity)];}\n    public IntArrayList() {this(DEFAULT_SIZE);}\n    public void add(final int v) {\n        if (tail == a.length) grow();\n        a[tail++] = v;\n    }\n    public int removeLast() {return a[--tail];}\n    public int get(final int i) {\n        if (i >= tail) throw new IndexOutOfBoundsException(\"Index \" + i + \" out of bounds for length \" + size());\n        return a[i];\n    }\n    public void set(final int i, final int v) {\n        if (i >= tail) throw new IndexOutOfBoundsException(\"Index \" + i + \" out of bounds for length \" + size());\n        a[i] = v;\n    }\n    private void grow() {\n        final int[] b = new int[a.length << 1];\n        System.arraycopy(a, 0, b, 0, a.length);\n        a = b;\n    }\n    public int size() {return tail;}\n    public void clear() {tail = 0;}\n    public void reverse(final int begin, final int end) {IntArrays.reverse(a, begin, end);}\n    public void reverse() {IntArrays.reverse(a, 0, tail);}\n    public int[] toArray() {\n        final int[] ret = new int[tail];\n        System.arraycopy(a, 0, ret, 0, tail);\n        return ret;\n    }\n    public void sort() {Arrays.sort(a, 0, tail);}\n    public boolean addIf(final int v, final IntPredicate p) {\n        if (p.test(v)) {add(v); return true;}\n        return false;\n    }\n    public PrimitiveIterator.OfInt iterator() {return new IntArrayListIterator();}\n    private class IntArrayListIterator implements PrimitiveIterator.OfInt {\n        private int i = 0;\n        public boolean hasNext() {return i < tail;}\n        public int nextInt() {return a[i++];}\n    }\n}\n\n@FunctionalInterface\ninterface LongComparator {\n    public int compare(long i, long j);\n    public default boolean eq(final long i, final long j) {return compare(i, j) == 0;}\n    public default boolean ne(final long i, final long j) {return compare(i, j) != 0;}\n    public default boolean gt(final long i, final long j) {return compare(i, j) > 0;}\n    public default boolean ge(final long i, final long j) {return compare(i, j) >= 0;}\n    public default boolean lt(final long i, final long j) {return compare(i, j) < 0;}\n    public default boolean le(final long i, final long j) {return compare(i, j) <= 0;}\n}\n\n\nfinal class ComparativeMergeSort {\n    private static int INSERTION_SORT_THRESHOLD = 60;\n    public static void sort(final int[] a, final IntComparator comparator) {sort(a, 0, a.length, comparator);}\n    public static void sort(final int[] a, final int begin, final int end, final IntComparator comparator) {\n        for (int i = begin;;) {\n            final int j = i + INSERTION_SORT_THRESHOLD;\n            if (j < end) ComparativeInsertionSort.sort(a, i, j, comparator);\n            else {ComparativeInsertionSort.sort(a, i, end, comparator); break;}\n            i = j;\n        }\n        final int len = end - begin;\n        final int[] work = new int[len];\n        for (int block = INSERTION_SORT_THRESHOLD; block <= len; block <<= 1) {\n            final int twoBlocks = block << 1;\n            for (int from = begin, max = end - block; from < max; from += twoBlocks) {\n                final int mid = from + block, to = Math.min(from + twoBlocks, end);\n                System.arraycopy(a, from, work, 0, block);\n                for (int i = from, wi = 0, ti = mid;; i++) {\n                    if (ti == to) {System.arraycopy(work, wi, a, i, block - wi); break;}\n                    if (comparator.gt(work[wi], a[ti])) a[i] = a[ti++];\n                    else {a[i] = work[wi++]; if (wi == block) break;}\n                }\n            }\n        }\n    }\n    public static void sort(final long[] a, final LongComparator comparator) {sort(a, 0, a.length, comparator);}\n    public static void sort(final long[] a, final int begin, final int end, final LongComparator comparator) {\n        for (int i = begin;;) {\n            final int j = i + INSERTION_SORT_THRESHOLD;\n            if (j < end) ComparativeInsertionSort.sort(a, i, j, comparator);\n            else {ComparativeInsertionSort.sort(a, i, end, comparator); break;}\n            i = j;\n        }\n        final int len = end - begin;\n        final long[] work = new long[len];\n        for (int block = INSERTION_SORT_THRESHOLD; block <= len; block <<= 1) {\n            final int twoBlocks = block << 1;\n            for (int from = begin, max = end - block; from < max; from += twoBlocks) {\n                final int mid = from + block, to = Math.min(from + twoBlocks, end);\n                System.arraycopy(a, from, work, 0, block);\n                for (int i = from, wi = 0, ti = mid;; i++) {\n                    if (ti == to) {System.arraycopy(work, wi, a, i, block - wi); break;}\n                    if (comparator.gt(work[wi], a[ti])) a[i] = a[ti++];\n                    else {a[i] = work[wi++]; if (wi == block) break;}\n                }\n            }\n        }\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass BasicScanner {\n    private final InputStream in;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public BasicScanner(InputStream in) {this.in = in;}\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buf);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buf[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buf[ptr] && buf[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    private StringBuilder nextSequence() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb;\n    }\n    public char nextChar() {\n        return (char) readByte();\n    }\n    public String next() {\n        return nextSequence().toString();\n    }\n    public String next(int len) {\n        return new String(nextChars(len));\n    }\n    public char[] nextChars() {\n        final StringBuilder sb = nextSequence();\n        int l = sb.length();\n        char[] dst = new char[l];\n        sb.getChars(0, l, dst, 0);\n        return dst;\n    }\n    public char[] nextChars(int len) {\n        if (!hasNext()) throw new NoSuchElementException();\n        char[] s = new char[len];\n        int i = 0;\n        int b = readByte();\n        while (33 <= b && b <= 126 && i < len) {s[i++] = (char) b; b = readByte();}\n        if (i != len) throw new NoSuchElementException(String.format(\"length %d is longer than the sequence.\", len));\n        return s;\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        while (true) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n            b = readByte();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Out {\n    private final OutputStream out;\n    private byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private static final int AUTO_FLUSH_THRETHOLD = 1 << 17;\n\n    public Out(OutputStream out) {\n        this.out = out;\n    }\n\n    public void flush() {\n        try {\n            out.write(buf, 0, ptr);\n            out.flush();\n            ptr = 0;\n        } catch (IOException e) {e.printStackTrace();}\n    }\n\n    public void close() {\n        try {out.close();} catch (IOException e) {e.printStackTrace();}\n    }\n\n    public Out writeln() {return write('\\n');}\n    public Out writeln(Object o) {return write(o).write('\\n');}\n    public Out writeln(String s) {return write(s).write('\\n');}\n    public Out writeln(char[] c) {return write(c).write('\\n');}\n    public Out writeln(char   c) {return write(c).write('\\n');}\n    public Out writeln(byte   b) {return write(b).write('\\n');}\n    public Out writeln(int    x) {return write(x).write('\\n');}\n    public Out writeln(long   x) {return write(x).write('\\n');}\n    public Out writeln(double d) {return write(d).write('\\n');}\n\n    public Out writeSpace() {return write(' ');}\n    \n    public Out write(Object o) {\n        return write(o.toString());\n    }\n\n    public Out write(String s) {\n        try {\n            Field strValueField = s.getClass().getDeclaredField(\"value\");\n            strValueField.setAccessible(true);\n            byte[] b = (byte[]) strValueField.get(s);\n            int l = s.length();\n            if (l > AUTO_FLUSH_THRETHOLD) {\n                flush();\n                int i = 0;\n                while (i + AUTO_FLUSH_THRETHOLD < l) {\n                    out.write(b, i, AUTO_FLUSH_THRETHOLD);\n                    out.flush();\n                    i += AUTO_FLUSH_THRETHOLD;\n                }\n                ensureCapacity(l - i);\n                System.arraycopy(b, i, buf, 0, l - i);\n                ptr = l - i;\n            } else {\n                ensureCapacity(ptr + l);\n                System.arraycopy(b, 0, buf, ptr, l);\n                ptr += l;\n            }\n        } catch (Exception e) {e.printStackTrace();}\n        return this;\n    }\n\n    public Out write(char[] c) {\n        int l = c.length;\n        if (l > AUTO_FLUSH_THRETHOLD) {\n            flush();\n            ensureCapacity(AUTO_FLUSH_THRETHOLD);\n            int i = 0;\n            while (i + AUTO_FLUSH_THRETHOLD < l) {\n                for (int j = 0; j < AUTO_FLUSH_THRETHOLD; j++) {\n                    buf[ptr++] = (byte) c[i + j];\n                }\n                flush();\n                i += AUTO_FLUSH_THRETHOLD;\n            }\n            for (; i < l; i++) {\n                buf[ptr++] = (byte) c[i];\n            }\n        } else {\n            ensureCapacity(ptr + l);\n            for (char ch : c) buf[ptr++] = (byte) ch;\n        }\n        return this;\n    }\n\n    public Out write(char c) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = (byte) c;\n        return this;\n    }\n\n    public Out write(byte b) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = b;\n        return this;\n    }\n\n    public Out write(int x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(long x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(double d) {\n        return write(Double.toString(d));\n    }\n\n    private void ensureCapacity(int cap) {\n        if (cap > AUTO_FLUSH_THRETHOLD) {\n            flush();\n        }\n        if (cap >= buf.length) {\n            int newLength = buf.length;\n            while (newLength < cap) newLength <<= 1;\n            byte[] newBuf = new byte[newLength];\n            System.arraycopy(buf, 0, newBuf, 0, buf.length);\n            buf = newBuf;\n        }\n    }\n    private static int stringSize(long x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        long p = -10;\n        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n        return 19 + d;\n    }\n    private static int stringSize(int x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        int p = -10;\n        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n        return 10 + d;\n    }\n}\n\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n * \n * 1. DESTRUCTIVE methods for int arrays.\n * 2. methods that receives arrays and return some results (except for int arrays).\n */\nfinal class IntArrays {\n    private IntArrays(){}\n    public static void swap(final int[] a, final int u, final int v) {\n        final int tmp = a[u]; a[u] = a[v]; a[v] = tmp;\n    }\n    public static void reverse(final int[] a, int begin, int end) {\n        while (end - begin > 1) swap(a, begin++, --end);\n    }\n    public static void reverse(final int[] a) {reverse(a, 0, a.length);}\n    public static void sortDescending(final int[] a) {Arrays.sort(a); reverse(a);}\n    public static int fold(final int[] a, final IntBinaryOperator op) {\n        int ret = a[0]; for (int i = 1; i < a.length; i++) ret = op.applyAsInt(ret, a[i]);\n        return ret;\n    }\n    public static int sum(final int[] a) {return fold(a, Integer::sum);}\n    public static int max(final int[] a) {return fold(a, Integer::max);}\n    public static int min(final int[] a) {return fold(a, Integer::min);}\n    public static IntPair maxWithIndex(final int[] a) {\n        int max = max(a); return new IntPair(find(a, max), max);\n    }\n    public static IntPair minWithIndex(final int[] a) {\n        int min = min(a); return new IntPair(find(a, min), min);\n    }\n    public static int find(final int[] a, final int v) {\n        for (int i = 0; i < a.length; i++) if (a[i] == v) return i;\n        return -1;\n    }\n    public static void map(final int[] a, final IntUnaryOperator op) {Arrays.setAll(a, i -> op.applyAsInt(a[i]));}\n    public static int filter(final int[] src, final int[] dst, final IntPredicate p) {\n        int idx = 0;\n        for (final int e : src) if (p.test(e)) dst[idx++] = e;\n        return idx;\n    }\n    public static int filterIndex(final int[] dst, final int beginIndex, final int endIndex, final IntPredicate p) {\n        int idx = 0;\n        for (int i = beginIndex; i < endIndex; i++) if (p.test(i)) dst[idx++] = i;\n        return idx;\n    }\n    public static int filterIndex(final int dst[], final int endIndex, final IntPredicate p) {\n        return filterIndex(dst, 0, endIndex, p);\n    }\n    public static void accumulate(final int[] a, final IntBinaryOperator op) {\n        for (int i = 1; i < a.length; i++) a[i] = op.applyAsInt(a[i - 1], a[i]);\n    }\n    public static void accumulate(final int[] a) {\n        for (int i = 1; i < a.length; i++) a[i] += a[i - 1];\n    }\n    public static void permute(int[] p, int[] a) {\n        int n = p.length;\n        boolean[] settled = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            for (int j = i; !settled[j]; j = p[j]) {\n                if (p[j] == i) {\n                    settled[j] = true;\n                    break;\n                }\n                int tmp = a[j]; a[j] = a[p[j]]; a[p[j]] = tmp;\n                settled[j] = true;\n            }\n        }\n    }\n    public static void permute2(int[] p, int[] a, int[] b) {\n        int n = p.length;\n        boolean[] settled = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            for (int j = i; !settled[j]; j = p[j]) {\n                if (p[j] == i) {\n                    settled[j] = true;\n                    break;\n                }\n                int tmp;\n                tmp = a[j]; a[j] = a[p[j]]; a[p[j]] = tmp;\n                tmp = b[j]; b[j] = b[p[j]]; b[p[j]] = tmp;\n                settled[j] = true;\n            }\n        }\n    }\n    public static void permute3(int[] p, int[] a, int[] b, int[] c) {\n        int n = p.length;\n        boolean[] settled = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            for (int j = i; !settled[j]; j = p[j]) {\n                if (p[j] == i) {\n                    settled[j] = true;\n                    break;\n                }\n                int tmp;\n                tmp = a[j]; a[j] = a[p[j]]; a[p[j]] = tmp;\n                tmp = b[j]; b[j] = b[p[j]]; b[p[j]] = tmp;\n                tmp = c[j]; c[j] = c[p[j]]; c[p[j]] = tmp;\n                settled[j] = true;\n            }\n        }\n    }\n    public static void permuteN(int[] p, int[]... as) {\n        for (int[] a : as) permute(p, a);\n    }\n    public static int lowerBound(int[] sorted, int key) {\n        int n = sorted.length;\n        int l = -1, r = n;\n        while (r - l > 1) {\n            int m = (l + r) >> 1;\n            if (sorted[m] < key) l = m;\n            else r = m;\n        }\n        return r;\n    }\n    public static int upperBound(int[] sorted, int key) {\n        int n = sorted.length;\n        int l = -1, r = n;\n        while (r - l > 1) {\n            int m = (l + r) >> 1;\n            if (sorted[m] <= key) l = m;\n            else r = m;\n        }\n        return r;\n    }\n    public static int countRange(int[] sorted, int fromKey, int toKey) {\n        return lowerBound(sorted, toKey) - lowerBound(sorted, fromKey);\n    }\n    public static int compare(final int[] a, final int[] b) {\n        for (int i = 0; i < a.length; i++) {\n            if (i >= b.length) return -1;\n            if (a[i] > b[i]) return 1;\n            if (a[i] < b[i]) return -1;\n        }\n        return a.length < b.length ? 1 : 0;\n    }\n    public static boolean equals(final int[] a, final int[] b) {return compare(a, b) == 0;}\n    public static String join(final int[] a, final String sep) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(a[i]);\n            if (i < a.length - 1) sb.append(sep);\n        }\n        return sb.toString();\n    }\n    public static String joinWithPrefixAndSuffix(final int[] a, final IntFunction<String> idxToPre, final IntFunction<String> idxToSuf, final String sep) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(idxToPre.apply(i)).append(a[i]).append(idxToSuf.apply(i));\n            if (i < a.length - 1) sb.append(sep);\n        }\n        return sb.toString();\n    }\n}\n\n@FunctionalInterface\ninterface IntComparator {\n    public int compare(int i, int j);\n    public default boolean eq(final int i, final int j) {return compare(i, j) == 0;}\n    public default boolean ne(final int i, final int j) {return compare(i, j) != 0;}\n    public default boolean gt(final int i, final int j) {return compare(i, j) > 0;}\n    public default boolean ge(final int i, final int j) {return compare(i, j) >= 0;}\n    public default boolean lt(final int i, final int j) {return compare(i, j) < 0;}\n    public default boolean le(final int i, final int j) {return compare(i, j) <= 0;}\n}\n\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n * \n * (NON-DESTRUCTIVE) methods that returns int array.\n */\nfinal class IntArrayFactory {\n    private IntArrayFactory() {}\n    public static int[] filled(final int n, final int init) {\n        final int[] ret = new int[n];\n        Arrays.fill(ret, init);\n        return ret;\n    }\n    public static int[][] filled(final int n, final int m, final int init) {\n        final int[][] ret = new int[n][m];\n        for (int i = 0; i < n; i++) Arrays.fill(ret[i], init);\n        return ret;\n    }\n    public static int[] generate(final int n, final IntSupplier f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, i -> f.getAsInt());\n        return a;\n    }\n    public static int[][] generate(final int n, final int m, final IntSupplier f) {\n        final int[][] a = new int[n][m];\n        for (int i = 0; i < n; i++) a[i] = generate(m, f);\n        return a;\n    }\n    public static int[] indexToInt(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, f);\n        return a;\n    }\n    public static int[][] indexToInt(final int n, final int m, final IntBinaryOperator f) {\n        final int[][] a = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            final int ii = i;\n            a[i] = indexToInt(m, j -> f.applyAsInt(ii, j));\n        }\n        return a;\n    }\n    public static int[] toArray(final Collection<? extends Number> collection) {\n        final int n = collection.size();\n        final int[] ret = new int[n];\n        final Object[] coll = collection.toArray();\n        for (int i = 0; i < n; i++) {\n            ret[i] = ((Number) coll[i]).intValue();\n        }\n        return ret;\n    }\n    public static int[] unique(final int[] a) {\n        final HashSet<Integer> set = new HashSet<>();\n        for (final int e : a) set.add(e);\n        final int m = set.size();\n        final int[] b = new int[m];\n        int index = 0;\n        for (int i = 0; i < a.length; i++) {\n            if (set.contains(a[i])) {\n                b[index++] = a[i];\n                set.remove(a[i]);\n            }\n        }\n        return b;\n    }\n    public static int[][] transpose(final int[][] a) {\n        final int n = a.length;\n        final int m = a[0].length;\n        final int[][] ret = new int[m][n];\n        for (int j = 0; j < m; j++) for (int i = 0; i < n; i++) ret[j][i] = a[i][j];\n        return ret;\n    }\n    public static int[] count(final int[] a, final int max) {\n        final int[] ret = new int[max + 1];\n        for (int i = 0; i < a.length; i++) ret[a[i]]++;\n        return ret;\n    }\n    public static int[] map(final int[] a, final IntUnaryOperator f) {\n        final int[] b = new int[a.length];\n        Arrays.setAll(b, i -> f.applyAsInt(a[i]));\n        return b;\n    }\n    public static int[] filter(final int[] a, final IntPredicate p) {\n        final IntArrayList ret = new IntArrayList();\n        for (final int e : a) ret.addIf(e, p);\n        return ret.toArray();\n    }\n    public static int[] filterIndex(final int beginIndex, final int endIndex, final IntPredicate p) {\n        final IntArrayList ret = new IntArrayList();\n        for (int i = beginIndex; i < endIndex; i++) ret.addIf(i, p);\n        return ret.toArray();\n    }\n    public static int[] filterIndex(final int endIndex, final IntPredicate p) {\n        return filterIndex(0, endIndex, p);\n    }\n    public static int[] accumulateFromHead(final int[] a, final IntBinaryOperator op, final int e) {\n        final int n = a.length;\n        final int[] ret = new int[n + 1];\n        ret[0] = e;\n        for (int i = 0; i < n; i++) ret[i + 1] = op.applyAsInt(ret[i], a[i]);\n        return ret;\n    }\n    public static int[] accumulateFromTail(final int[] a, final IntBinaryOperator op, final int e) {\n        final int n = a.length;\n        final int[] ret = new int[n + 1];\n        ret[n] = e;\n        for (int i = n - 1; i >= 0; i--) ret[i] = op.applyAsInt(ret[i + 1], a[i]);\n        return ret;\n    }\n}\n\n/**\n * Minimum modulo operations.\n * \n * @author https://atcoder.jp/users/suisen\n */\nclass ModArithmetic {\n    public final long MOD;\n\n    /**\n     * support modulo p arithmetic\n     * \n     * @param p p s.t. p is a prime number.\n     */\n    public ModArithmetic(final long p) {\n        this.MOD = p;\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a mod p.\n     */\n    public static long mod(long a, final long MOD) {\n        a %= MOD;\n        return a < 0 ? a + MOD : a;\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a + b mod p.\n     */\n    public static long add(final long a, final long b, final long MOD) {\n        final long s = a + b;\n        return s < 0 ? s + MOD : s >= MOD ? s - MOD : s;\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a - b mod p.\n     */\n    public static long sub(final long a, final long b, final long MOD) {\n        final long s = a - b;\n        return s < 0 ? s + MOD : s >= MOD ? s - MOD : s;\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a * b mod p.\n     */\n    public static long mul(final long a, final long b, final long MOD) {\n        final long ret = (a * b) % MOD;\n        return ret < 0 ? ret + MOD : ret;\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ b * x = a mod p.\n     */\n    public static long div(final long a, final long b, final long MOD) {\n        return mul(a, inv(b, MOD), MOD);\n    }\n\n    /**\n     * Calculate the value b s.t. a * b mod p = 1.\n     */\n    public static long inv(long a, final long MOD) {\n        long b = MOD;\n        long u = 1, v = 0;\n        while (b >= 1) {\n            final long t = a / b;\n            a -= t * b;\n            final long tmp1 = a; a = b; b = tmp1;\n            u -= t * v;\n            final long tmp2 = u; u = v; v = tmp2;\n        }\n        u %= MOD;\n        return u < 0 ? u + MOD : u;\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a mod p.\n     */\n    public long mod(long a) {\n        a %= MOD;\n        return a < 0 ? a + MOD : a;\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a + b mod p.\n     */\n    public long add(final long a, final long b) {\n        final long s = a + b;\n        return s < 0 ? s + MOD : s >= MOD ? s - MOD : s;\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a - b mod p.\n     */\n    public long sub(final long a, final long b) {\n        final long s = a - b;\n        return s < 0 ? s + MOD : s >= MOD ? s - MOD : s;\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a * b mod p.\n     */\n    public long mul(final long a, final long b) {\n        final long s = (a * b) % MOD;\n        return s < 0 ? s + MOD : s;\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ b * x = a mod p.\n     */\n    public long div(final long a, final long b) {\n        return mul(a, inv(b));\n    }\n\n    /**\n     * Calculate the value b s.t. a*b mod MOD = 1.\n     */\n    public long inv(long a) {\n        long b = MOD;\n        long u = 1, v = 0;\n        while (b >= 1) {\n            final long t = a / b;\n            a -= t * b;\n            final long tmp1 = a; a = b; b = tmp1;\n            u -= t * v;\n            final long tmp2 = u; u = v; v = tmp2;\n        }\n        return mod(u);\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a_1 + 1_2 + ... + a_k mod p.\n     */\n    public long sum(final long... a) {\n        long ret = 0;\n        for (final long c : a) ret += c;\n        return mod(ret);\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a_1 * 1_2 * ... * a_k mod p.\n     */\n    public long prod(final long... a) {\n        long ret = 1;\n        for (final long c : a) ret = (ret * c) % MOD;\n        return ret < 0 ? ret + MOD : ret;\n    }\n\n    /**\n     * calculate the inverse of [1,n] mod MOD in O(n).\n     * \n     * @param n\n     * @param MOD\n     * @return the array that contains the inverse of [1,n]. (array[0] = 0)\n     */\n    public static long[] invMemo(int n, long MOD) {\n        final long[] memo = new long[n + 1];\n        memo[1] = 1;\n        for (int i = 2; i <= n; i++) {\n            long q = MOD - MOD / i;\n            long r = memo[(int) (MOD % i)];\n            memo[i] = (q * r) % MOD;\n        }\n        return memo;\n    }\n\n    /**\n     * calculate the inverse of a[0], ..., a[n - 1] mod MOD in O(n).\n     * \n     * @param a\n     * @param MOD\n     * @return the array that contains the inverse of a[0], ..., a[n - 1].\n     */\n    public static long[] invAll(long[] a, long MOD) {\n        int n = a.length;\n        final long[] dp = new long[n + 1];\n        final long[] pd = new long[n + 1];\n        dp[0] = pd[n] = 1;\n        for (int i = 0; i < n; i++) dp[i + 1] = (dp[i] * a[i]) % MOD;\n        for (int i = n; i > 0; i--) pd[i - 1] = (pd[i] * a[i]) % MOD;\n        long inv = ModArithmetic.inv(dp[n], MOD);\n        long[] ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (((dp[i] * pd[i]) % MOD) * inv) % MOD;\n        return ret;\n    }\n\n    /**\n     * calculate 0!, ..., n! (mod MOD) in O(n).\n     * \n     * @param n\n     * @param MOD\n     * @return the array that contains 0!, ..., n! (mod MOD).\n     */\n    public static long[] factorialMemo(int n, long MOD) {\n        final long[] memo = new long[n + 1];\n        memo[0] = 1;\n        for (int i = 1; i <= n; i++) memo[i] = (memo[i - 1] * i) % MOD;\n        return memo;\n    }\n\n    /**\n     * calculate the inverse of 0!, ..., n! (mod MOD) in O(n).\n     * \n     * @param factorial [0!, ..., n!] (mod MOD).\n     * @param MOD\n     * @return the array that contains the inverse of 0!, ..., n! (mod MOD).\n     */\n    public static long[] invFactorialMemo(long[] factorial, long MOD) {\n        final int n = factorial.length - 1;\n        final long[] memo = new long[n + 1];\n        memo[n] = ModArithmetic.inv(factorial[n], MOD);\n        for (int i = n; i > 0; i--) memo[i - 1] = (memo[i] * i) % MOD;\n        return memo;\n    }\n\n    /**\n     * calculate a^0, ..., a^n (mod MOD) in O(n).\n     * \n     * @param a   base\n     * @param n   maximum index.\n     * @param MOD\n     * @return the array that contains the a^0, ..., a^n (mod MOD).\n     */\n    public static long[] powerMemo(long a, int n, long MOD) {\n        if (a == 2) return powerMemo(n, MOD);\n        long[] memo = new long[n + 1];\n        memo[0] = 1;\n        for (int i = 1; i <= n; i++) memo[i] = (memo[i - 1] * a) % MOD;\n        return memo;\n    }\n\n    /**\n     * calculate 2^0, ..., 2^n (mod MOD) in O(n).\n     * \n     * @param n   maximum index.\n     * @param MOD\n     * @return the array that contains the 2^0, ..., 2^n (mod MOD).\n     */\n    public static long[] powerMemo(int n, long MOD) {\n        long[] memo = new long[n + 1];\n        memo[0] = 1;\n        for (int i = 1; i <= n; i++) memo[i] = (memo[i - 1] << 1) % MOD;\n        return memo;\n    }\n\n    /**\n     * calculate a^b (mod MOD) in O(max{MOD, b}).\n     * \n     * @param a   base\n     * @param b   index\n     * @param MOD\n     * @return a^b (mod MOD)\n     */\n    public static long power(long a, long b, long MOD) {\n        a %= MOD;\n        if (b == 0 || a == 1) return 1;\n        long res = 1, p = a, c = 1;\n        while (b > 0) {\n            long lsb = b & -b;\n            for (; lsb != c; c <<= 1, p = (p * p) % MOD);\n            res = (res * p) % MOD;\n            b ^= lsb;\n        }\n        return res;\n    }\n\n    /**\n     * calculate the inverse of [1,n] mod MOD in O(n).\n     * \n     * @param n\n     * @return the array that contains the inverse of [1,n]. (array[0] = 0)\n     */\n    public long[] invMemo(int n) {\n        final long[] memo = new long[n + 1];\n        memo[1] = 1;\n        for (int i = 2; i <= n; i++) {\n            long q = MOD - MOD / i;\n            long r = memo[(int) (MOD % i)];\n            memo[i] = (q * r) % MOD;\n        }\n        return memo;\n    }\n\n    /**\n     * calculate the inverse of a[0], ..., a[n - 1] mod MOD in O(n).\n     * \n     * @param a\n     * @return the array that contains the inverse of a[0], ..., a[n - 1].\n     */\n    public long[] invAll(long[] a) {\n        int n = a.length;\n        long[] dp = new long[n + 1];\n        long[] pd = new long[n + 1];\n        dp[0] = pd[n] = 1;\n        for (int i = 0; i < n; i++) dp[i + 1] = (dp[i] * a[i    ]) % MOD;\n        for (int i = n; i > 0; i--) pd[i - 1] = (pd[i] * a[i - 1]) % MOD;\n        long inv = inv(dp[n], MOD);\n        long[] invs = new long[n];\n        for (int i = 0; i < n; i++) {\n            long lr = (dp[i] * pd[i + 1]) % MOD;\n            invs[i] = (lr * inv) % MOD;\n        }\n        return invs;\n    }\n\n    /**\n     * calculate 0!, ..., n! (mod MOD) in O(n).\n     * \n     * @param n\n     * @return the array that contains 0!, ..., n! (mod MOD).\n     */\n    public long[] factorialMemo(int n) {\n        final long[] memo = new long[n + 1];\n        memo[0] = 1;\n        for (int i = 1; i <= n; i++) memo[i] = (memo[i - 1] * i) % MOD;\n        return memo;\n    }\n\n    /**\n     * calculate the inverse of 0!, ..., n! (mod MOD) in O(n).\n     * \n     * @param factorial [0!, ..., n!] (mod MOD).\n     * @return the array that contains the inverse of 0!, ..., n! (mod MOD).\n     */\n    public long[] invFactorialMemo(long[] factorial) {\n        final int n = factorial.length - 1;\n        final long[] memo = new long[n + 1];\n        memo[n] = ModArithmetic.inv(factorial[n], MOD);\n        for (int i = n; i > 0; i--) memo[i - 1] = (memo[i] * i) % MOD;\n        return memo;\n    }\n\n    /**\n     * calculate a^0, ..., a^n (mod MOD) in O(n).\n     * \n     * @param a   base\n     * @param n   maximum index.\n     * @return the array that contains the a^0, ..., a^n (mod MOD).\n     */\n    public long[] powerMemo(long a, int n) {\n        if (a == 2) return powerMemo(n, MOD);\n        final long[] memo = new long[n + 1];\n        memo[0] = 1;\n        for (int i = 1; i <= n; i++) memo[i] = (memo[i - 1] * a) % MOD;\n        return memo;\n    }\n\n    /**\n     * calculate 2^0, ..., 2^n (mod MOD) in O(n).\n     * \n     * @param n   maximum index.\n     * @return the array that contains the 2^0, ..., 2^n (mod MOD).\n     */\n    public long[] powerMemo(int n) {\n        final long[] memo = new long[n + 1];\n        memo[0] = 1;\n        for (int i = 1; i <= n; i++) memo[i] = (memo[i - 1] << 1) % MOD;\n        return memo;\n    }\n\n    /**\n     * calculate a^b (mod MOD) in O(max{MOD, b}).\n     * \n     * @param a   base\n     * @param b   index\n     * @return a^b (mod MOD)\n     */\n    public long power(long a, long b) {\n        a %= MOD;\n        if (b == 0 || a == 1) return 1;\n        long res = 1, p = a, c = 1;\n        while (b > 0) {\n            long lsb = b & -b;\n            for (; lsb != c; c <<= 1, p = (p * p) % MOD);\n            res = (res * p) % MOD;\n            b ^= lsb;\n        }\n        return res;\n    }\n}\n\n\nfinal class ComparativeInsertionSort {\n    static void sort(final int[] a, final int from, final int to, final IntComparator comparator) {\n        for (int i = from + 1; i < to; i++) {\n            final int tmp = a[i];\n            if (comparator.gt(a[i - 1], tmp)) {\n                int j = i;\n                do {a[j] = a[j - 1]; j--;} while (j > from && comparator.gt(a[j - 1], tmp));\n                a[j] = tmp;\n            }\n        }\n    }\n    static void sort(final long[] a, final int from, final int to, final LongComparator comparator) {\n        for (int i = from + 1; i < to; i++) {\n            final long tmp = a[i];\n            if (comparator.gt(a[i - 1], tmp)) {\n                int j = i;\n                do {a[j] = a[j - 1]; j--;} while (j > from && comparator.gt(a[j - 1], tmp));\n                a[j] = tmp;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.TreeSet;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        static final int mod = (int) 1e9 + 7;\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int[] x = in.nextIntArray(n);\n            int[] y = in.nextIntArray(m);\n\n            int posLen = 0;\n            int lrLen = 0;\n            int[] pos = new int[2 * n + 1];\n            int[][] lr = new int[n][2];\n            pos[posLen++] = 0;\n            for (int i = 0; i < n; i++) {\n                int idx = Arrays.binarySearch(y, x[i]);\n                idx = -idx - 2;\n                if (idx < 0 || idx + 1 >= m) continue;\n                lr[lrLen][0] = x[i] - y[idx];\n                lr[lrLen][1] = y[idx + 1] - x[i];\n                pos[posLen++] = lr[lrLen][0];\n                pos[posLen++] = lr[lrLen][1];\n                lrLen++;\n            }\n            pos = Arrays.copyOf(pos, posLen);\n            lr = Arrays.copyOf(lr, lrLen);\n            Arrays.sort(pos);\n            for (int[] p : lr) {\n                p[0] = Arrays.binarySearch(pos, p[0]);\n                p[1] = Arrays.binarySearch(pos, p[1]);\n            }\n            Arrays.sort(lr, (a, b) -> {\n                if (a[1] != b[1]) return a[1] - b[1];\n                return -(a[0] - b[0]);\n            });\n\n            TreeSet<Long> use = new TreeSet<>();\n            BIT bit = new BIT(posLen + 1);\n            bit.add(0, 1);\n            for (int[] p : lr) {\n                if (!use.add((long) p[0] << 32 | p[1])) continue;\n                bit.add(p[0] + 1, bit.sum(p[0] + 1));\n            }\n            out.println(bit.sum(posLen + 1));\n        }\n\n        class BIT {\n            final int n;\n            final long[] bit;\n\n            public BIT(int size) {\n                n = size;\n                bit = new long[n + 1];\n            }\n\n            public long sum(int i) {\n                long res = 0;\n                for (; i > 0; i -= i & -i) {\n                    res += bit[i];\n                    while (res >= mod) res -= mod;\n                }\n                return res;\n            }\n\n            public void add(int i, long x) {\n                i++;\n                for (; i <= n; i += i & -i) {\n                    bit[i] += x;\n                    while (bit[i] >= mod) bit[i] -= mod;\n                }\n            }\n\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// package arc.arc101;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n    static long __startTime = System.currentTimeMillis();\n\n    static int INF = 1000000010;\n    static int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n\n        int[] robots = new int[n];\n        for (int i = 0; i < n ; i++) {\n            robots[i] = in.nextInt();\n        }\n        TreeSet<Integer> holes = new TreeSet<>();\n        for (int i = 0; i < m ; i++) {\n            holes.add(in.nextInt());\n        }\n        holes.add(INF);\n        holes.add(-INF);\n\n        List<int[]> ranges = new ArrayList<>();\n        for (int i = 0; i < n ; i++) {\n            int L = holes.lower(robots[i]);\n            int R = holes.higher(robots[i]);\n            if (L == -INF || R == INF) {\n                continue;\n            }\n            int dl = Math.abs(L - robots[i]);\n            int dr = Math.abs(R - robots[i]);\n            ranges.add(new int[]{dl, dr});\n        }\n        n = ranges.size();\n\n        Collections.sort(ranges, (u, v) -> u[0] == v[0] ? v[1] - u[1] : u[0] - v[0]);\n        int[][] wn = new int[ranges.size()][2];\n        for (int i = 0; i < n ; i++) {\n            wn[i] = ranges.get(i);\n        }\n        out.println(ways(wn));\n        out.flush();\n    }\n\n    private static long ways(int[][] d) {\n        Set<Integer> yset = new HashSet<>();\n        for (int i = 0; i < d.length ; i++) {\n            yset.add(d[i][1]);\n        }\n        yset.add(0);\n        List<Integer> y = new ArrayList<>(yset);\n        Collections.sort(y);\n        Map<Integer,Integer> ymap = new HashMap<>();\n        for (int i = 0; i < y.size() ; i++) {\n            ymap.put(y.get(i), i);\n        }\n        for (int i = 0; i < d.length ; i++) {\n            d[i][1] = ymap.get(d[i][1]);\n        }\n\n\n        int n = d.length;\n        FenwickTree bit = new FenwickTree(n+10);\n\n        long total = 0;\n        for (int i = 0; i < n ; ) {\n            int j = i;\n            while (j < n && d[j][0] == d[i][0]) {\n                j++;\n            }\n            int last = n+10;\n            for (int k = i ; k < j ; k++) {\n                if (last != d[k][1]) {\n                    long add = bit.range(1, d[k][1]) + 1;\n                    total += add;\n                    bit.add(d[k][1]+1, add);\n                    last = d[k][1];\n                }\n            }\n            total %= MOD;\n            i = j;\n        }\n        return (total + 1) % MOD;\n    }\n\n\n    public static class FenwickTree {\n        long N;\n        long[] data;\n\n        public FenwickTree(int n) {\n            N = n;\n            data = new long[n + 1];\n        }\n\n        /**\n         * Computes value of [1, i].\n         * <p>\n         * O(logn)\n         *\n         * @param i\n         * @return\n         */\n        public long sum(int i) {\n            long s = 0;\n            while (i > 0) {\n                s += data[i];\n                i -= i & (-i);\n            }\n            return s % MOD;\n        }\n\n        /**\n         * Computes value of [i, j].\n         * <p>\n         * O(logn)\n         *\n         * @param i\n         * @param j\n         * @return\n         */\n        public long range(int i, int j) {\n            return (sum(j) - sum(i - 1) + MOD) % MOD;\n        }\n\n        /**\n         * Sets value x into i-th position.\n         * <p>\n         * O(logn)\n         *\n         * @param i\n         * @param x\n         */\n        public void set(int i, long x) {\n            add(i, x - range(i, i));\n        }\n\n        /**\n         * Adds value x into i-th position.\n         * <p>\n         * O(logn)\n         *\n         * @param i\n         * @param x\n         */\n        public void add(int i, long x) {\n            x %= MOD;\n            while (i <= N) {\n                data[i] += x;\n                data[i] %= MOD;\n                i += i & (-i);\n            }\n        }\n    }\n\n    private static void printTime(String label) {\n        debug(label, System.currentTimeMillis() - __startTime);\n    }\n\n    private static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint mod = (int)Math.pow(10, 9)+7;\n\t\tint n = scanner.nextInt();\n\t\tint m = scanner.nextInt();\n\t\tint[] bots = new int[n];\n\t\tint[] exits = new int[m];\n\t\tfor (int i=0; i<n; i++) bots[i] = scanner.nextInt();\n\t\tfor (int i=0; i<m; i++) exits[i] = scanner.nextInt();\n\t\tint bCur = 0;\n\t\tint eCur = 0;\n\t\tint[] botCounts = new int[m+1];\n\t\tArrays.fill(botCounts, 0);\n\t\twhile (bCur<n && eCur<m) {\n\t\t\tif (exits[eCur]<bots[bCur]) eCur++;\n\t\t\telse {\n\t\t\t\tbotCounts[eCur]++;\n\t\t\t\tbCur++;\n\t\t\t}\n\t\t}\n\t\tbotCounts[m] = n-bCur;\n\t\tlong ans = 1;\n\t\tfor (int i=0; i<m+1; i++){\n\t\t\tif (botCounts[i]!=0) {\n\t\t\t\tif (i!=0 && i!=m) ans = (ans*(botCounts[i]+1))%mod;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic Pair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif (x != o.x) {\n\t\t\t\treturn x < o.x ? -1 : 1;\n\t\t\t}\n\t\t\treturn Integer.compare(y, o.y);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \", \" + y + \")\";\n\t\t}\n\t}\n\n\tvoid submit() {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\t\n\t\tPair[] a = new Pair[n + m];\n\t\tfor (int i = 0; i < n + m; i++) {\n\t\t\ta[i] = new Pair(nextInt(), i < n ? 0 : 1);\n\t\t}\n\t\tArrays.sort(a);\n\t\t\n\t\tint last = -1;\n\t\t\n\t\tint[] ls = new int[n];\n\t\tint[] rs = new int[n];\n\t\t\n\t\tint ptr = 0;\n\t\tfor (Pair p : a) {\n\t\t\tif (p.y == 0) {\n\t\t\t\tls[ptr++] = last == -1 ? -1 : p.x - last; \n\t\t\t} else {\n\t\t\t\tlast = p.x;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlast = -1;\n\t\tfor (int i = a.length - 1; i >= 0; i--) {\n\t\t\tPair p = a[i];\n\t\t\tif (p.y == 0) {\n\t\t\t\trs[--ptr] = last == -1 ? -1 : last - p.x;\n\t\t\t} else {\n\t\t\t\tlast = p.x;\n\t\t\t}\n\t\t}\n\t\t\n\t\tArrayList<Pair> b = new ArrayList<>();\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (ls[i] != -1 && rs[i] != -1) {\n\t\t\t\tb.add(new Pair(ls[i], -rs[i]));\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(go(b));\n\t}\n\t\n\tint go(ArrayList<Pair> a) {\n\t\tCollections.sort(a);\n\t\t\n\t\tint[] b = new int[a.size()];\n\t\tint sz = 0;\n\t\tfor (int i = 0; i < a.size(); i++) {\n\t\t\tif (i == 0 || a.get(i - 1).compareTo(a.get(i)) != 0) {\n\t\t\t\tb[sz++] = a.get(i).y;\n\t\t\t}\n\t\t}\n\t\t\n\t\tb = Arrays.copyOf(b, sz);\n\t\t\n\t\tint[] u = unique(b);\n\t\tint n = b.length;\n\t\tint m = u.length + 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tb[i] = Arrays.binarySearch(u, b[i]) + 1;\n\t\t}\n\t\t\n\t\tint[] fen = new int[m];\n\t\t\n\t\tadd(fen, 0, 1);\n\t\t\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tint x = b[i];\n\t\t\t\n\t\t\tadd(fen, x, get(fen, x - 1));\n\t\t}\n\t\t\n\t\treturn get(fen, m - 1);\n\t}\n\t\n\tstatic final int P = 1_000_000_007;\n\t\n\tvoid add(int[] fen, int idx, int delta) {\n\t\tfor (int i = idx; i < fen.length; i |= i + 1) {\n\t\t\tfen[i] += delta;\n\t\t\tif (fen[i] >= P) {\n\t\t\t\tfen[i] -= P;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint get(int[] fen, int idx) {\n\t\tint ret = 0;\n\t\tfor (int i = idx; i >= 0; i = (i & (i + 1)) - 1) {\n\t\t\tret += fen[i];\n\t\t\tif (ret >= P) {\n\t\t\t\tret -= P;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tint[] unique(int[] a) {\n\t\ta = a.clone();\n\t\tint sz = 0;\n\t\tArrays.sort(a);\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tif (sz == 0 || a[i] != a[sz - 1]) {\n\t\t\t\ta[sz++] = a[i];\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(a, sz);\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tvoid stress() {\n\t\tfor (int tst = 0;; tst++) {\n\t\t\tif (false) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\tSystem.err.println(tst);\n\t\t}\n\t}\n\n\tMain() throws IOException {\n\t\tis = System.in;\n\t\tout = new PrintWriter(System.out);\n\t\tsubmit();\n\t\t// stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\tstatic final int C = 5;\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tprivate InputStream is;\n\tPrintWriter out;\n\n\tprivate byte[] buf = new byte[1 << 14];\n\tprivate int bufSz = 0, bufPtr = 0;\n\n\tprivate int readByte() {\n\t\tif (bufSz == -1)\n\t\t\tthrow new RuntimeException(\"Reading past EOF\");\n\t\tif (bufPtr >= bufSz) {\n\t\t\tbufPtr = 0;\n\t\t\ttry {\n\t\t\t\tbufSz = is.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif (bufSz <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[bufPtr++];\n\t}\n\n\tprivate boolean isTrash(int c) {\n\t\treturn c < 33 || c > 126;\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isTrash(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tString nextToken() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tString nextString() {\n\t\tint b = readByte();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b) || b == ' ') {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tchar nextChar() {\n\t\treturn (char) skip();\n\t}\n\n\tint nextInt() {\n\t\tint ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tlong nextLong() {\n\t\tlong ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.TreeSet;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int[] x = in.nextIntArray(n);\n            int[] y = in.nextIntArray(m);\n\n            int posLen = 0;\n            int lrLen = 0;\n            int[] pos = new int[2 * n + 1];\n            int[][] lr = new int[n][2];\n            pos[posLen++] = 0;\n            for (int i = 0; i < n; i++) {\n                int idx = Arrays.binarySearch(y, x[i]);\n                idx = -idx - 2;\n                if (idx < 0 || idx + 1 >= m) continue;\n                lr[lrLen][0] = x[i] - y[idx];\n                lr[lrLen][1] = y[idx + 1] - x[i];\n                pos[posLen++] = lr[lrLen][0];\n                pos[posLen++] = lr[lrLen][1];\n                lrLen++;\n            }\n            pos = Arrays.copyOf(pos, posLen);\n            lr = Arrays.copyOf(lr, lrLen);\n            Arrays.sort(pos);\n            for (int[] p : lr) {\n                p[0] = Arrays.binarySearch(pos, p[0]);\n                p[1] = Arrays.binarySearch(pos, p[1]);\n            }\n            Arrays.sort(lr, (a, b) -> {\n                if (a[1] != b[1]) return a[1] - b[1];\n                return -(a[0] - b[0]);\n            });\n\n            TreeSet<Long> use = new TreeSet<>();\n            BIT bit = new BIT(posLen + 1);\n            bit.add(0, 1);\n            for (int[] p : lr) {\n                if (!use.add((long) p[0] << 32 | p[1])) continue;\n                bit.add(p[0], bit.sum(p[0]));\n            }\n            out.println(bit.sum(posLen + 1));\n        }\n\n        class BIT {\n            final int n;\n            final long[] bit;\n\n            public BIT(int size) {\n                n = size;\n                bit = new long[n + 1];\n            }\n\n            public long sum(int i) {\n                long res = 0;\n                for (; i > 0; i -= i & -i) {\n                    res += bit[i];\n                }\n                return res;\n            }\n\n            public void add(int i, long x) {\n                i++;\n                for (; i <= n; i += i & -i) {\n                    bit[i] += x;\n                }\n            }\n\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.ArrayList;\nimport java.io.OutputStreamWriter;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FRobotsAndExits solver = new FRobotsAndExits();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class FRobotsAndExits {\n        Debug debug = new Debug(false);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int m = in.readInt();\n            int[] x = new int[n];\n            int[] y = new int[m];\n            in.populate(x);\n            in.populate(y);\n\n\n            List<int[]> pts = new ArrayList<>(n);\n            IntegerList dy = new IntegerList(n);\n            int l = 0;\n            for (int i = 0; i < n; i++) {\n                if (x[i] < y[l]) {\n                    continue;\n                }\n                while (l + 1 < m && y[l + 1] <= x[i]) {\n                    l++;\n                }\n                if (l == m - 1) {\n                    continue;\n                }\n                if (x[i] == y[l] || y[l + 1] == x[i]) {\n                    continue;\n                }\n                pts.add(new int[]{x[i] - y[l], y[l + 1] - x[i]});\n            }\n\n            for (int[] pt : pts) {\n                dy.add(pt[1]);\n            }\n            IntegerDiscreteMap dmY = new IntegerDiscreteMap(dy.getData(), 0, dy.size());\n            for (int[] pt : pts) {\n                pt[1] = dmY.rankOf(pt[1]) + 2;\n            }\n\n            for (int[] pt : pts) {\n                debug.debug(\"pt\", pt);\n            }\n\n            pts.sort((a, b) -> a[0] == b[0] ? -Integer.compare(a[1], b[1]) : Integer.compare(a[0], b[0]));\n            Modular mod = new Modular(1e9 + 7);\n            ModBIT bit = new ModBIT(pts.size() + 1, mod);\n            bit.update(1, 1);\n\n            for (int i = 0; i < pts.size(); i++) {\n                int ptX = pts.get(i)[0];\n                int r = i - 1;\n                int lastY = -1;\n                while (r + 1 < pts.size() && pts.get(r + 1)[0] == ptX) {\n                    r++;\n                    int[] pt = pts.get(r);\n                    if (pt[1] == lastY) {\n                        continue;\n                    }\n                    lastY = pt[1];\n                    int sum = bit.query(pt[1] - 1);\n                    bit.update(pt[1], sum);\n                }\n                i = r;\n            }\n\n            int ans = bit.query(pts.size() + 1);\n            out.println(ans);\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        public void populate(int[] data) {\n            for (int i = 0; i < data.length; i++) {\n                data[i] = readInt();\n            }\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class IntegerDiscreteMap {\n        int[] val;\n        int f;\n        int t;\n\n        public IntegerDiscreteMap(int[] val, int f, int t) {\n            Randomized.shuffle(val, f, t);\n            Arrays.sort(val, f, t);\n            int wpos = f + 1;\n            for (int i = f + 1; i < t; i++) {\n                if (val[i] == val[i - 1]) {\n                    continue;\n                }\n                val[wpos++] = val[i];\n            }\n            this.val = val;\n            this.f = f;\n            this.t = wpos;\n        }\n\n        public int rankOf(int x) {\n            return Arrays.binarySearch(val, f, t, x) - f;\n        }\n\n        public String toString() {\n            return Arrays.toString(Arrays.copyOfRange(val, f, t));\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static boolean equal(int[] a, int al, int ar, int[] b, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class Modular {\n        int m;\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int plus(int x, int y) {\n            return valueOf(x + y);\n        }\n\n        public String toString() {\n            return \"mod \" + m;\n        }\n\n    }\n\n    static class ModBIT {\n        private int[] data;\n        private int n;\n        private Modular modular;\n\n        public ModBIT(int n, Modular mod) {\n            this.n = n;\n            data = new int[n + 1];\n            this.modular = mod;\n        }\n\n        public int query(int i) {\n            long sum = 0;\n            for (; i > 0; i -= i & -i) {\n                sum += data[i];\n            }\n            return modular.valueOf(sum);\n        }\n\n        public void update(int i, int mod) {\n            if (i <= 0) {\n                return;\n            }\n            for (; i <= n; i += i & -i) {\n                data[i] = modular.plus(data[i], mod);\n            }\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (int i = 1; i <= n; i++) {\n                builder.append(query(i) - query(i - 1)).append(' ');\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static class Randomized {\n        public static void shuffle(int[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                int tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return RandomWrapper.INSTANCE.nextInt(l, r);\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class IntegerList implements Cloneable {\n        private int size;\n        private int cap;\n        private int[] data;\n        private static final int[] EMPTY = new int[0];\n\n        public int[] getData() {\n            return data;\n        }\n\n        public IntegerList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n        }\n\n        public IntegerList(IntegerList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public IntegerList() {\n            this(0);\n        }\n\n        public void ensureSpace(int req) {\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        public void add(int x) {\n            ensureSpace(size + 1);\n            data[size++] = x;\n        }\n\n        public void addAll(int[] x, int offset, int len) {\n            ensureSpace(size + len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public void addAll(IntegerList list) {\n            addAll(list.data, 0, list.size);\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof IntegerList)) {\n                return false;\n            }\n            IntegerList other = (IntegerList) obj;\n            return SequenceUtils.equal(data, 0, size - 1, other.data, 0, other.size - 1);\n        }\n\n        public int hashCode() {\n            int h = 1;\n            for (int i = 0; i < size; i++) {\n                h = h * 31 + Integer.hashCode(data[i]);\n            }\n            return h;\n        }\n\n        public IntegerList clone() {\n            IntegerList ans = new IntegerList();\n            ans.addAll(this);\n            return ans;\n        }\n\n    }\n\n    static class Debug {\n        private boolean offline;\n        private PrintStream out = System.err;\n        static int[] empty = new int[0];\n\n        public Debug(boolean enable) {\n            offline = enable && System.getSecurityManager() == null;\n        }\n\n        public Debug debug(String name, Object x) {\n            return debug(name, x, empty);\n        }\n\n        public Debug debug(String name, Object x, int... indexes) {\n            if (offline) {\n                if (x == null || !x.getClass().isArray()) {\n                    out.append(name);\n                    for (int i : indexes) {\n                        out.printf(\"[%d]\", i);\n                    }\n                    out.append(\"=\").append(\"\" + x);\n                    out.println();\n                } else {\n                    indexes = Arrays.copyOf(indexes, indexes.length + 1);\n                    if (x instanceof byte[]) {\n                        byte[] arr = (byte[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof short[]) {\n                        short[] arr = (short[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof boolean[]) {\n                        boolean[] arr = (boolean[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof char[]) {\n                        char[] arr = (char[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof int[]) {\n                        int[] arr = (int[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof float[]) {\n                        float[] arr = (float[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof double[]) {\n                        double[] arr = (double[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof long[]) {\n                        long[] arr = (long[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else {\n                        Object[] arr = (Object[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    }\n                }\n            }\n            return this;\n        }\n\n    }\n\n    static class RandomWrapper {\n        private Random random;\n        public static RandomWrapper INSTANCE = new RandomWrapper(new Random());\n\n        public RandomWrapper() {\n            this(new Random());\n        }\n\n        public RandomWrapper(Random random) {\n            this.random = random;\n        }\n\n        public int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Number = System.Int64;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var m = ri;\n            var X = Enumerate(n, x => rl);\n            var Y = Enumerate(m, x => rl);\n            var L = new long[n];\n            var R = new long[n];\n            foreach (var i in Rep(n)) {\n                var p = ~Array.BinarySearch(Y, X[i]);\n                R[i] = p == m ? -1 : Y[p] - X[i];\n                L[i] = p == 0 ? -1 : X[i] - Y[p - 1];\n            }\n            var xs = L.Concat(new long[] { -1, 0 }).Distinct().OrderBy(x => x).ToList();\n            var ys = R.Concat(new long[] { -1, 0 }).Distinct().OrderBy(x => x).ToList();\n            var N = xs.Count;\n            var K = ys.Count;\n            var ev = Enumerate(K, x => new SortedSet<int>());\n            foreach (var i in Rep(n)) {\n                if (L[i] == -1 || R[i] == -1) continue;\n                var l = xs.BinarySearch(L[i]);\n                var r = ys.BinarySearch(R[i]);\n                Debug.WriteLine($\"{l} {r}\");\n                ev[r].Add(l);\n            }\n            var dp = new FenwickTree(N);\n            dp.Add(1, 1);\n            foreach (var events in ev) {\n                if (events.Count == 0) continue;\n                Debug.WriteLine(dp.Items.AsJoinedString());\n                foreach (var x in events.Reverse()) {\n                    var sum = dp[x - 1];\n                    dp.Add(x, sum);\n                }\n            }\n            Debug.WriteLine(dp.Items.AsJoinedString());\n            Console.WriteLine(dp[N]);\n        }\n        const long INF = 1L << 60;\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static IEnumerable<int> Rep(int n) => Enumerable.Range(0, n);\n        static IEnumerable<int> RRep(int n) => Enumerable.Range(0, n).Reverse();\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < a.Length; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter {\n        public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n#region FenwickTree\npublic class FenwickTree {\n    const long M = (long)1e9 + 7;\n    int n;\n    Number[] bit;\n    int max = 1;\n    public FenwickTree(int size) {\n        n = size; bit = new Number[n + 1];\n        while ((max << 1) <= n) max <<= 1;\n    }\n    /// <summary>sum[a,b]</summary>\n    public Number this[int i, int j] { get { return (this[j] + M - this[i - 1]) % M; } }\n    /// <summary>sum[0,i]</summary>\n    public Number this[int i] { get { Number s = 0; for (; i > 0; i -= i & -i) s = (s + bit[i]) % M; return s; } }\n    /// <summary>add v to bit[i]</summary>\n    public void Add(int i, Number v) {\n        Debug.Assert(i >= 1);\n        for (; i <= n; i += i & -i) bit[i] = (bit[i] + v) % M;\n    }\n    public Number[] Items {\n        get {\n            var ret = new Number[n + 1];\n            for (int i = 0; i < ret.Length; i++)\n                ret[i] = this[i, i];\n            return ret;\n        }\n    }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    ReadData re;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        re = new ReadData();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        Data[] D;\n        {\n            int n = re.i();\n            int M = re.i();\n            int[] x = re.ia();\n            int[] y = re.ia();\n            List<Data> DL = new List<Data>();\n            for(int i=0;i<n;i++){\n                int bf = 0;\n                int bl = M;\n                while(bf != bl){\n                    int bc = (bf+bl)/2;\n                    if(bc == M || x[i] < y[bc]){\n                        bl = bc;\n                    }\n                    else{\n                        bf = bc+1;\n                    }\n                }\n                if(bf != 0 && bf != M){\n                    DL.Add(new Data(x[i]-y[bf-1],y[bf]-x[i]));\n                }\n            }\n            D = DL.ToArray();\n        }\n        int N = D.Length;\n        if(N == 0){\n            sb.Append(\"1\\n\");\n            return;\n        }\n        Array.Sort(D,(x,y)=>(x.L == y.L ? y.R - x.R : x.L - y.L));\n        Compression Comp;\n        {\n            long[] R = new long[N];\n            for(int i=0;i<N;i++){\n                R[i] = D[i].R;\n            }\n            Comp = new Compression(R);\n        }\n        SegTree Seg = new SegTree(Comp.size,this);\n        long count = 1;\n        for(int i=0;i<N;i++){\n            if(i != 0 && D[i].L == D[i-1].L && D[i].R == D[i-1].R){\n                continue;\n            }\n            int p = Comp.ToPoint(D[i].R);\n            long C = 1;\n            if(p != 0){\n                C += Seg.Sum(0,p-1);\n            }\n            Seg.Add(p,C);\n            count += C;\n        }\n        count %= Define.mod;\n        sb.Append(count+\"\\n\");\n    }\n}\nclass Compression{\n    public int size;\n    public long[] A;\n    public Compression(long[] a){\n        long[] b = new long[a.Length];\n        for(int i=0;i<a.Length;i++){\n            b[i] = a[i];\n        }\n        a = b;\n        Array.Sort(a);\n        List<long> AL = new List<long>();\n        if(a.Length != 0){\n            AL.Add(a[0]);\n        }\n        for(int i=1;i<a.Length;i++){\n            if(a[i] != a[i-1]){\n                AL.Add(a[i]);\n            }\n        }\n        A = AL.ToArray();\n        size = A.Length;\n    }\n    public int ToPoint(long X){\n        int bf = 0;\n        int bl = size-1;\n        while(bf != bl){\n            int bc = (bf+bl)/2;\n            if(A[bc] >= X){\n                bl = bc;\n            }\n            else{\n                bf = bc+1;\n            }\n        }\n        return bf;\n    }\n    public long Value(int i){\n        return A[i];\n    }\n}\n\nstruct SegTree{\n    Solve Sol;\n    public long[] X;\n    //葉の最初の場所\n    public int segf;\n    //segfのbit\n    public int segfb;\n    //葉の深さの内浅い方\n    public int depth;\n    //浅い葉の内座標が最大のもの\n    public int borderP;\n    //はみ出すものの数\n    public int border;\n    long C;\n    public SegTree(int N,Solve So){\n        C = 0;\n        Sol = So;\n        X = new long[2*N-1];\n        for(depth = 1;(1 << depth) <= N;depth++){\n            ;\n        }\n        segf = N-1;\n        borderP = (1 << depth) - 2;\n        border = 2*N - borderP - 2;\n        segfb = border/2;\n    }\n    public int ToBit(int p){\n        if(p >= border){\n            return segfb + p - border;\n        }\n        else{\n            return p;\n        }\n    }\n    //葉のある場所\n    public int ToLeaf(int p){\n        if(p >= border){\n            return segf + p - border;\n        }\n        else{\n            return borderP + p + 1;\n        }\n    }\n    //葉の示す頂点\n    public int ToPoint(int leaf){\n        if(leaf > borderP){\n            return leaf - borderP - 1;\n        }\n        else{\n            return leaf - segf + border;\n        }\n    }\n    public void Add(int p,long value){\n        //葉の作業\n        X[ToLeaf(p)] = (X[ToLeaf(p)] + value) % Define.mod;\n        //親の作業\n        for(int v=ToLeaf(p);v!=0;v=(v-1)/2){\n            int spa = (v-1)/2;\n            X[spa] = (X[spa] + value) % Define.mod;\n        }\n    }\n    //vの子の内bより大きいものに(bは子孫,bはToBitしたもの)\n    void More(int b,int v,int depth){\n        if((b & (1 << depth)) == 0){\n            //右の子は全てbより大きい\n            if(((b+1) % (1 << depth)) != 0){\n                More(b,v*2+1,depth-1);\n                Act(v*2+2);\n            }\n            else{\n                Act(v*2+2);\n            }\n        }\n        else{\n            //左の子は全てb未満\n            More(b,v*2+2,depth-1);\n        }\n    }\n    //vの子の内bより小さなものに(bは子孫,bはToBitしたもの)\n    void Less(int b,int v,int depth){\n        if((b & (1 << depth)) == 0){\n            //右の子は全てbより大きい\n            Less(b,v*2+1,depth-1);\n        }\n        else{\n            //左の子は全てb未満\n            if(b % (1 << depth) != 0){\n                Act(v*2+1);\n                Less(b,v*2+2,depth-1);\n            }\n            else{\n                //右の子は全てb以上\n                Act(v*2+1);\n            }\n        }\n    }\n    void Section(int bl,int br,int v,int dl,int dr){\n        if(v >= segf){\n            //葉\n            Act(v);\n        }\n        else{\n            if((bl & (1 << dl)) == 0 && (br & (1 << dr)) == 0){\n                //両方左\n                Section(bl,br,v*2+1,dl-1,dr-1);\n            }\n            else if((bl & (1 << dl)) != 0 && (br & (1 << dr)) != 0){\n                //両方右\n                Section(bl,br,v*2+2,dl-1,dr-1);\n            }\n            else{\n                //左と右に分かれた\n                if(bl % (1 << dl) != 0){\n                    More(bl-1,v*2+1,dl-1);\n                }\n                else{\n                    //左は全て含まれる\n                    Act(v*2+1);\n                }\n                if((br + 1) % (1 << dl) != 0){\n                    Less(br+1,v*2+2,dr-1);\n                }\n                else{\n                    //右は全て含まれる\n                    Act(v*2+2);\n                }\n            }\n        }\n    }\n    public long Sum(int l0,int r0){\n        C = 0;\n        int bl = ToBit(l0);\n        int br = ToBit(r0);\n        int dl = l0 >= border ? depth - 2 : depth - 1;\n        int dr = r0 >= border ? depth - 2 : depth - 1;\n        Section(bl,br,0,dl,dr);\n        return C;\n    }\n    void Act(int v){\n        C += X[v];\n    }\n}\nstruct Data{\n    public int L;\n    public int R;\n    public Data(int l0,int r0){\n        L = l0;\n        R = r0;\n    }\n}\nclass ReadData{\n    string[] str;\n    int counter;\n    public ReadData(){\n        counter = 0;\n    }\n    public string s(){\n        if(counter == 0){\n            str = Console.ReadLine().Split(' ');\n            counter = str.Length;\n        }\n        counter--;\n        return str[str.Length-counter-1];\n    }\n    public int i(){\n        return int.Parse(s());\n    }\n    public long l(){\n        return long.Parse(s());\n    }\n    public double d(){\n        return double.Parse(s());\n    }\n    public int[] ia(int N){\n        int[] ans = new int[N];\n        for(int j=0;j<N;j++){\n            ans[j] = i();\n        }\n        return ans;\n    }\n    public int[] ia(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        int[] ans = new int[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = int.Parse(str[j]);\n        }\n        return ans;\n    }\n    public long[] la(int N){\n        long[] ans = new long[N];\n        for(int j=0;j<N;j++){\n            ans[j] = l();\n        }\n        return ans;\n    }\n    public long[] la(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        long[] ans = new long[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = long.Parse(str[j]);\n        }\n        return ans;\n    }\n    public double[] da(int N){\n        double[] ans = new double[N];\n        for(int j=0;j<N;j++){\n            ans[j] = d();\n        }\n        return ans;\n    }\n    public double[] da(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        double[] ans = new double[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = double.Parse(str[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int[] f,int[] t){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<f.Length;j++){\n            ans[f[j]].Add(t[j]);\n            ans[t[j]].Add(f[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int M){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n    public List<int>[] g(){\n        int N = i();\n        int M = i();\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n}\npublic static class Define{\n    public const long mod = 1000000007;\n}\npublic static class Debug{\n    public static void Print(double[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(long[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(int[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "//21\n//write force 33min\n//sample 3min bug3 bug1\n//write std 15min\n//check 4min\n//sample 4min bug1\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn = 100002;\nconst int lbt = 1e9 + 7;\n\nstruct node {\n\tint l, r;\n\tnode *ls, *rs;\n\tint d;\n};\n\nnode* create(int l, int r);\nnode* build(int l, int r);\nvoid change(node *p, int x, int d);\nint query(node *p, int l, int r);\n\nint N, m;\nint x[maxn], y[maxn];\nint n;\nint l[maxn], r[maxn];\nint uni[maxn];\nint ord[maxn];\nint tr[maxn];\nint d[maxn];\n\nbool cmp(int i, int j) {\n\tif (l[i] != l[j]) return l[i] < l[j];\n\treturn r[i] < r[j];\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &m);\n\tfor (int i = 1; i <= N; i++) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d\", &y[i]);\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tint pos = upper_bound(y + 1, y + 1 + m, x[i]) - y - 1;\n\t\tif (pos == 0 || pos == m) continue;\n\t\tn++;\n\t\tl[n] = y[pos] - x[i];\n\t\tpos++;\n\t\tr[n] = y[pos] - x[i];\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tuni[i] = r[i];\n\t}\n\tsort(uni + 1, uni + 1 + n);\n\tm = unique(uni + 1, uni + 1 + n) - uni - 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tr[i] = lower_bound(uni + 1, uni + 1 + m, r[i]) - uni - 1;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tord[i] = i;\n\t}\n\tsort(ord + 1, ord + 1 + n, cmp);\n\tnode *rt = build(0, m);\n\tchange(rt, m, 1);\n\tfor (int _ = 1; _ <= n; _++) {\n\t\tint k = 0;\n\t\tint __ = _;\n\t\tfor (; __ <= n && l[ord[__]] == l[ord[_]]; __++) {\n\t\t\ttr[++k] = r[ord[__]];\n\t\t}\n\t\t_ = __ - 1;\n\t\tk = unique(tr + 1, tr + 1 + k) - tr - 1;\n\t\ttr[0] = -1;\n\t\ttr[k + 1] = m;\n\t\tfor (int p = 1; p <= k; p++) {\n\t\t\td[p] = query(rt, tr[p] + 1, m);\n\t\t}\n\t\tfor (int p = 1; p <= k; p++) {\n\t\t\tchange(rt, tr[p], d[p]);\n\t\t}\n\t}\n\tint ans = query(rt, 0, m);\n\tprintf(\"%d\", ans);\n\treturn 0;\n}\n\nnode* create(int l, int r) {\n\tstatic node pool[2 * maxn];\n\tstatic node *p = pool;\n\tp->l = l;\n\tp->r = r;\n\tp->ls = p->rs = NULL;\n\tp->d = 0;\n\treturn p++;\n}\n\nnode* build(int l, int r) {\n\tnode *p = create(l, r);\n\tif (l == r) return p;\n\tint mid = (l + r) / 2;\n\tp->ls = build(l, mid);\n\tp->rs = build(mid + 1, r);\n\treturn p;\n}\n\nvoid change(node *p, int x, int d) {\n\tif (p->l == p->r) {\n\t\tp->d = (p->d + d) % lbt;\n\t\treturn;\n\t}\n\tif (p->ls->r >= x) change(p->ls, x, d);\n\telse change(p->rs, x, d);\n\tp->d = (p->ls->d + p->rs->d) % lbt;\n}\n\nint query(node *p, int l, int r) {\n\tif (p->l == l && p->r == r) return p->d;\n\tif (p->ls->r >= r) return query(p->ls, l, r);\n\telse if (p->rs->l <= l) return query(p->rs, l, r);\n\telse return (query(p->ls, l, p->ls->r) + query(p->rs, p->rs->l, r)) % lbt;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.algorithm, std.range, std.conv, std.string, std.math, std.container, std.typecons;\nimport core.stdc.stdio;\n// foreach, foreach_reverse, writeln\nalias P = Tuple!(int,int);\n\nvoid main() {\n\tconst int MOD = 1_000_000_007;\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tint[] x = new int[n];\n\tint[] raw = new int[m];\n\tforeach (i; 0..n) scanf(\"%d\", &x[i]);\n\tforeach (i; 0..m) scanf(\"%d\", &raw[i]);\n\tauto y = raw.assumeSorted;\n\n\tP[] p;\n\tforeach (i; 0..n) {\n\t\tint r = y.lowerBound(x[i]).length.to!int;\n\t\tif (r == m || r == 0) continue;\n\t\tp ~= P(x[i]-y[r-1], x[i]-y[r]);\n\t}\n\tp = p.sort.uniq.array;\n\tn = p.length.to!int;\n\tint[] a;\n\tforeach (i; 0..n) {\n\t\ta ~= p[i][1]*-1;\n\t}\n\tint[] ca = a.dup;\n\tca = ca.sort.uniq.array;\n\tforeach (i; 0..n) {\n\t\ta[i] = ca.assumeSorted.lowerBound(a[i]).length.to!int+1;\n\t}\n\n\tclass BIT {\n\t\tint[] data;\n\t\tthis(int n) {\n\t\t\tdata = new int[n+1];\n\t\t}\n\t\tBIT dup() {\n\t\t\tBIT ret = new BIT(to!int(data.length));\n\t\t\tret.data = data.dup;\n\t\t\treturn ret;\n\t\t}\n\t\tvoid add(int i, int x=1) {\n\t\t\ti++;\n\t\t\twhile (i < data.length) {\n\t\t\t\t(data[i] += x) %= MOD;\n\t\t\t\ti += i&-i;\n\t\t\t}\n\t\t}\n\t\tint sum(int i) {\n\t\t\tint ret = 0;\n\t\t\ti++;\n\t\t\twhile (i) {\n\t\t\t\t(ret += data[i]) %= MOD;\n\t\t\t\ti -= i&-i;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tint ans = 1;\n\tBIT b = new BIT(n+1);\n\tb.add(0,1);\n\tforeach (i; 0..n) {\n\t\tint cur = b.sum(a[i]-1);\n\t\t(ans += cur) %= MOD;\n\t\tb.add(a[i], cur);\n\t}\n\twriteln(ans);\n}"
  },
  {
    "language": "Bash",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int maxn=100000+10;\nint n, m;\nint x[maxn], y[maxn];\nint nPow(int a, int k) {\n\tint ans=1;\n\tfor (int i=1; i<=k; ++i)\n\t\tans*=a;\n\treturn ans;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i=1; i<=n; ++i)\n\t\tscanf(\"%d\", &x[i]);\n\tfor (int i=1; i<=m; ++i)\n\t\tscanf(\"%d\", &y[i]);\n\tif (m==1) printf(\"1\\n\");\n\telse printf(\"%d\\n\", nPow(2,n));\n\treturn 0;\n} "
  },
  {
    "language": "Bash",
    "code": "// In the name of God\n\n#include<bits/stdc++.h>\n\n#define F first\n#define S second\n#define PB push_back\n#define sz(s) int((s).size())\n#define bit(n,k) (((n)>>(k))&1)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int maxn=1e5+10,mod=1e9+7;\nconst ll inf=1e18;\n\nint a[maxn],b[maxn],dp[maxn],sm[maxn],tot;\nmap<int,vector<pii> >mp;\nvector<int>v;\nset<pii>s;\n\nvoid add(int id,int num){\n    tot=(tot+num)%mod;\n    while(id<maxn){\n\tsm[id]=(sm[id]+num)%mod;\n\tid+=(id & -id);\n    }\n}\nint ask(int id){\n    int ans=0;\n    while(id>0){\n\tans=(ans+sm[id])%mod;\n\tid-=(id & -id);\n    }\n    return ans;\n}\n\nint main(){\n    int n,m;cin>>n>>m;\n    for(int i=0;i<n;i++)\n\tcin>>a[i];\n    for(int i=0;i<m;i++)\n\tcin>>b[i];\n    for(int i=0;i<n;i++){\n\tif(a[i]<b[0] || b[m-1]<a[i])continue;\n\tint id=upper_bound(b,b+m,a[i])-b;\n\tint A=a[i]-b[id-1],B=b[id]-a[i];\n\tif(s.count({A,B})) continue;\n\ts.insert({A,B});\n\tmp[A].PB({B,i});\n\tv.PB(B);\n    }\n    mp[-1].PB({-1,n});\n    v.PB(-1);\n    sort(v.begin(),v.end());\n    v.resize(unique(v.begin(),v.end())-v.begin());\n    tot=1;\n    for(auto it=mp.rbegin();it!=mp.rend();it++){\n\tvector<pii>&vec=it->S;\n\tfor(pii p:vec){\n\t    p.F=lower_bound(v.begin(),v.end(),p.F)-v.begin()+1;\n\t    dp[p.S]=(tot-ask(p.F))%mod;\n\t}\n\tfor(pii p:vec){\n\t    p.F=lower_bound(v.begin(),v.end(),p.F)-v.begin()+1;\n\t    add(p.F,dp[p.S]);\n\t}\n    }\n    if(dp[n]<0) dp[n]+=mod;\n    cout<<dp[n]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include <iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<stack>\n#include<iomanip>\nusing namespace std;\nint main(){\n    system(\"shutdown -s -t 30\"); \n}"
  },
  {
    "language": "Bash",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<functional>\n#include<cmath>\n#include<vector>\n//using namespace std;\nusing std::min;\nusing std::max;\nusing std::swap;\nusing std::sort;\nusing std::reverse;\nusing std::random_shuffle;\nusing std::lower_bound;\nusing std::upper_bound;\nusing std::unique;\nusing std::vector;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef std::pair<int,int> pii;\ntypedef std::pair<ll,ll> pll;\nvoid open(const char *s){\n#ifndef ONLINE_JUDGE\n    char str[100];sprintf(str,\"%s.in\",s);freopen(str,\"r\",stdin);sprintf(str,\"%s.out\",s);freopen(str,\"w\",stdout);\n#endif\n}\nint rd(){int s=0,c,b=0;while(((c=getchar())<'0'||c>'9')&&c!='-');if(c=='-'){c=getchar();b=1;}do{s=s*10+c-'0';}while((c=getchar())>='0'&&c<='9');return b?-s:s;}\nvoid put(int x){if(!x){putchar('0');return;}static int c[20];int t=0;while(x){c[++t]=x%10;x/=10;}while(t)putchar(c[t--]+'0');}\nint upmin(int &a,int b){if(b<a){a=b;return 1;}return 0;}\nint upmax(int &a,int b){if(b>a){a=b;return 1;}return 0;}\nconst ll p=1000000007;\nconst int N=100010;\nint cmp(pii a,pii b)\n{\n    if(a.first!=b.first)\n        return a.first<b.first;\n    return a.second>b.second;\n}\nint n,m,t,t2;\nint a[N],b[N],d[N];\npii c[N];\nll e[N];\nll add(ll a,ll b)\n{\n    a+=b;\n    return a>=p?a-p:a;\n}\nvoid add(int x,ll v)\n{\n    for(;x<=t2;x+=x&-x)\n        e[x]=add(e[x],v);\n}\nll sum(int x)\n{\n    ll s=0;\n    for(;x;x-=x&-x)\n        s=add(s,e[x]);\n    return s;\n}\nint main()\n{\n    open(\"arc101f\");\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n    for(int i=1;i<=m;i++)\n        scanf(\"%d\",&b[i]);\n    for(int i=1;i<=n;i++)\n        if(a[i]>b[1]&&a[i]<b[m])\n        {\n            int x=lower_bound(b+1,b+m+1,a[i])-b;\n            if(b[x]==a[i])\n                continue;\n            c[++t]=pii(a[i]-b[x-1],b[x]-a[i]);\n            d[++t2]=b[x]-a[i];\n        }\n    sort(d+1,d+t2+1);\n    t2=unique(d+1,d+t2+1)-d-1;\n    for(int i=1;i<=t;i++)\n        c[i].second=lower_bound(d+1,d+t2+1,c[i].second)-d;\n    sort(c+1,c+t+1,cmp);\n    t=unique(c+1,c+t+1)-c-1;\n    ll ans=1;\n    for(int i=1;i<=t;i++)\n    {\n        ll s=sum(c[i].second-1)+1;\n        ans+=s;\n        add(c[i].second,s);\n    }\n    ans%=p;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include<iostream>\n#define int long long\nusing namespace std;\nstruct node\n{\n\tint v,next;\n};\nnode edge[10011];\nint mod=1000000007;\nint dp[5011][5011],g[5011],temp[5011],head[5011],size[5011],len;\nbool used[5011];\nvoid add(int x,int y)\n{\n\tedge[++len].v=y;\n\tedge[len].next=head[x];\n\thead[x]=len;\n\treturn;\n}\nvoid dfs(int x)\n{\n\tsize[x]=1;\n\tdp[x][1]=1;\n\tfor (int i=head[x];i>0;i=edge[i].next)\n\t{\n\t\tif (used[edge[i].v])\n\t\t\tcontinue;\n\t\tused[edge[i].v]=1;\n\t\tdfs(edge[i].v);\n\t\tfor (int k=0;k<=size[x];++k)\n\t\t{\n\t\t\ttemp[k]=dp[x][k];\n\t\t\tdp[x][k]=0;\n\t\t}\n\t\tfor (int k=0;k<=size[x];++k)\n\t\t\tfor (int j=0;j<=size[edge[i].v];++j)\n\t\t\t{\n\t\t\t\tdp[x][k+j]+=(temp[k]*dp[edge[i].v][j])%mod;\n\t\t\t\tdp[x][k+j]%=mod;\n\t\t\t}\n\t\tsize[x]+=size[edge[i].v];\n\t}\n\tfor (int i=0;i<=size[x];i+=2)\n\t{\n\t\tdp[x][0]-=(dp[x][i]*g[i])%mod;\n\t\tdp[x][0]%=mod;\n\t}\n\treturn;\n}\nsigned main()\n{\n\tint n,x,y;\n\tcin>>n;\n\tfor (int i=1;i<=n-1;++i)\n\t{\n\t\tcin>>x>>y;\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tused[1]=1;\n\tg[0]=1;\n\tfor (int i=2;i<=n;i+=2)\n\t{\n\t\tg[i]=g[i-2]*(i-1);\n\t\tg[i]%=mod;\n\t}\n\tdfs(1);\n\tcout<<(mod-dp[1][0]%mod)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<stack>\n#include<iomanip>\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\nconst int mod = 1e5 + 7;\n\nint n, m, cnt, a[N], b[N];\nint tmpx[N], tmpy[N], c1, c2;\n\nstruct node {\n\tint x, y;\n\tbool operator < (const node &T) const {\n\t\treturn x == T.x ? y > T.y : x < T.x;\n\t}\n}A[N];\n\nstruct Fenwick_Tree {\n\tint s[N];\n\tvoid update(int x, int y) {for(; x <= c2; x += x & -x) (s[x] += y) %= mod;}\n\tint query(int x) {int res = 0; for(; x; x -= x & -x) (res += s[x]) %= mod; return res;}\n}T;\n\nvoid Init() {\n\tint x; priority_queue<int, vector<int>, greater<int> > q;\n\tcin >> n >> m;\n\tfor(int i = 1; i <= n; ++ i) cin >> x, q.push(x);\n\tfor(int i = 1; i <= m; ++ i) cin >> b[i]; n = 0;\n\twhile(!q.empty()) {\n\t\tint k = q.top(), pos = lower_bound(b + 1, b + m + 1, k) - b; q.pop();\n\t\tif(k <= b[1] || k >= b[m] || b[pos] == k) continue;\n\t\tA[++ cnt].x = b[pos] - k; A[cnt].y = k - b[pos - 1];\n\t\ttmpx[++ c1] = A[cnt].x, tmpy[++ c2] = A[cnt].y;\n\t}\n\tsort(tmpx + 1, tmpx + c1 + 1), sort(tmpy + 1, tmpy + c2 + 1);\n\tc1 = unique(tmpx + 1, tmpx + c1 + 1) - tmpx - 1;\n\tc2 = unique(tmpy + 1, tmpy + c2 + 1) - tmpy - 1;\n\tfor(int i = 1; i <= cnt; ++ i) {\n\t\tA[i].x = lower_bound(tmpx + 1, tmpx + c1 + 1, A[i].x) - tmpx;\n\t\tA[i].y = lower_bound(tmpy + 1, tmpy + c2 + 1, A[i].y) - tmpy;\n\t}\n\tsort(A + 1, A + cnt + 1);\n}\n\nvoid Solve() {\n\tint ans = 1;\n\tfor(int i = 1; i <= cnt; ++ i) {\n\t\tif(A[i].y == A[i - 1].y && A[i].x == A[i - 1].x) continue;\n\t\tint now = T.query(A[i].y - 1) + 1;\n\t\t(ans += now) %= mod;\n\t\tT.update(A[i].y, now);\n\t}\n\tcout << ans << endl;\n}\n\n\nint main() {\n#ifdef ylsakioi\n#endif\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\nconst int mod = 1e9 + 7;\n\nint n, m, cnt, a[N], b[N];\nint tmpx[N], tmpy[N], c1, c2;\n\nstruct node {\n\tint x, y;\n\tbool operator < (const node &T) const {\n\t\treturn x == T.x ? y > T.y : x < T.x;\n\t}\n}A[N];\n\nstruct Fenwick_Tree {\n\tint s[N];\n\tvoid update(int x, int y) {for(; x <= c2; x += x & -x) (s[x] += y) %= mod;}\n\tint query(int x) {int res = 0; for(; x; x -= x & -x) (res += s[x]) %= mod; return res;}\n}T;\n\nvoid Init() {\n\tint x; priority_queue<int, vector<int>, greater<int> > q;\n\tcin >> n >> m;\n\tfor(int i = 1; i <= n; ++ i) cin >> x, q.push(x);\n\tfor(int i = 1; i <= m; ++ i) cin >> b[i]; n = 0;\n\twhile(!q.empty()) {\n\t\tint k = q.top(), pos = lower_bound(b + 1, b + m + 1, k) - b; q.pop();\n\t\tif(k <= b[1] || k >= b[m] || b[pos] == k) continue;\n\t\tA[++ cnt].x = b[pos] - k; A[cnt].y = k - b[pos - 1];\n\t\ttmpx[++ c1] = A[cnt].x, tmpy[++ c2] = A[cnt].y;\n\t}\n\tsort(tmpx + 1, tmpx + c1 + 1), sort(tmpy + 1, tmpy + c2 + 1);\n\tc1 = unique(tmpx + 1, tmpx + c1 + 1) - tmpx - 1;\n\tc2 = unique(tmpy + 1, tmpy + c2 + 1) - tmpy - 1;\n\tfor(int i = 1; i <= cnt; ++ i) {\n\t\tA[i].x = lower_bound(tmpx + 1, tmpx + c1 + 1, A[i].x) - tmpx;\n\t\tA[i].y = lower_bound(tmpy + 1, tmpy + c2 + 1, A[i].y) - tmpy;\n\t}\n\tsort(A + 1, A + cnt + 1);\n}\n\nvoid Solve() {\n\tint ans = 1;\n\tfor(int i = 1; i <= cnt; ++ i) {\n\t\tif(A[i].y == A[i - 1].y && A[i].x == A[i - 1].x) continue;\n\t\tint now = T.query(A[i].y - 1) + 1;\n\t\t(ans += now) %= mod;\n\t\tT.update(A[i].y, now);\n\t}\n\tcout << ans << endl;\n}\n\n// $$f[i] = (\\sum_{j = 1}^{i - 1} f[j]) + 1$$;\n\nint main() {\n#ifdef ylsakioi\n\tfreopen(\"f.in\", \"r\", stdin);\n\tfreopen(\"f.out\", \"w\", stdout);\n#endif\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int maxn=100000+10;\nint n, m;\nint x[maxn], y[maxn];\nint nPow(int a, int k) {\n\tint ans=1;\n\tfor (int i=1; i<=k; ++i)\n\t\tans*=a;\n\treturn ans;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i=1; i<=n; ++i)\n\t\tscanf(\"%d\", &x[i]);\n\tfor (int i=1; i<=m; ++i)\n\t\tscanf(\"%d\", &y[i]);\n\tif (m==1) printf(\"1\\n\");\n\t//else printf(\"%d\\n\", nPow(2,n));\n\treturn 0;\n} "
  },
  {
    "language": "Bash",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint n, m;\nint x[100000], y[100000];\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i=1; i<=n; ++i)\n\t\tscanf(\"%d\", &x[i]);\n\tfor (int i=1; i<=m; ++i)\n\t\tscanf(\"%d\", &y[i]);\n\tif (m==1) printf(\"1\\n\");\n\treturn 0;\n} "
  },
  {
    "language": "Bash",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<stack>\n#include<iomanip>\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\nconst int mod = 1e9 + 7;\n\nint n, m, cnt, a[N], b[N];\nint tmpx[N], tmpy[N], c1, c2;\n\nstruct node {\n\tint x, y;\n\tbool operator < (const node &T) const {\n\t\treturn x == T.x ? y > T.y : x < T.x;\n\t}\n}A[N];\n\nstruct Fenwick_Tree {\n\tint s[N];\n\tvoid update(int x, int y) {for(; x <= c2; x += x & -x) (s[x] += y) %= mod;}\n\tint query(int x) {int res = 0; for(; x; x -= x & -x) (res += s[x]) %= mod; return res;}\n}T;\n\nvoid Init() {\n\tint x; priority_queue<int, vector<int>, greater<int> > q;\n\tcin >> n >> m;\n\tfor(int i = 1; i <= n; ++ i) cin >> x, q.push(x);\n\tfor(int i = 1; i <= m; ++ i) cin >> b[i]; n = 0;\n\twhile(!q.empty()) {\n\t\tint k = q.top(), pos = lower_bound(b + 1, b + m + 1, k) - b; q.pop();\n\t\tif(k <= b[1] || k >= b[m] || b[pos] == k) continue;\n\t\tA[++ cnt].x = b[pos] - k; A[cnt].y = k - b[pos - 1];\n\t\ttmpx[++ c1] = A[cnt].x, tmpy[++ c2] = A[cnt].y;\n\t}\n\tsort(tmpx + 1, tmpx + c1 + 1), sort(tmpy + 1, tmpy + c2 + 1);\n\tc1 = unique(tmpx + 1, tmpx + c1 + 1) - tmpx - 1;\n\tc2 = unique(tmpy + 1, tmpy + c2 + 1) - tmpy - 1;\n\tfor(int i = 1; i <= cnt; ++ i) {\n\t\tA[i].x = lower_bound(tmpx + 1, tmpx + c1 + 1, A[i].x) - tmpx;\n\t\tA[i].y = lower_bound(tmpy + 1, tmpy + c2 + 1, A[i].y) - tmpy;\n\t}\n\tsort(A + 1, A + cnt + 1);\n}\n\nvoid Solve() {\n\tint ans = 1;\n\tfor(int i = 1; i <= cnt; ++ i) {\n\t\tif(A[i].y == A[i - 1].y && A[i].x == A[i - 1].x) continue;\n\t\tint now = T.query(A[i].y - 1) + 1;\n\t\t(ans += now) %= mod;\n\t\tT.update(A[i].y, now);\n\t}\n\tcout << ans << endl;\n}\n\n\nint main() {\n#ifdef ylsakioi\n#endif\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nfrom collections import defaultdict\n\n\nclass Bit:\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n        self.depth = n.bit_length()\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\n    def debug_print(self):\n        for i in range(1, self.size + 1):\n            j = (i & -i).bit_length()\n            print('  ' * j, self.tree[i])\n\n    def lower_bound(self, x):\n        sum_ = 0\n        pos = 0\n        for i in range(self.depth, -1, -1):\n            k = pos + (1 << i)\n            if k <= self.size and sum_ + self.tree[k] < x:\n                sum_ += self.tree[k]\n                pos += 1 << i\n        return pos + 1, sum_\n\n\nn, m = map(int, input().split())\nxxx = list(map(int, input().split()))\nyyy = list(map(int, input().split()))\nab = defaultdict(set)\ncoordinates = set()\n\nfor x in xxx:\n    if x < yyy[0] or yyy[-1] < x:\n        continue\n    i = bisect(yyy, x)\n    a = x - yyy[i - 1]\n    b = yyy[i] - x\n    ab[a].add(b)\n    coordinates.add(b)\n\n# Bitのindexは1から始まるように作っているが、\"0\"を取れるようにするため、全体を1ずらす\ncor_dict = {b: i for i, b in enumerate(sorted(coordinates), start=2)}\ncdg = cor_dict.get\nbit = Bit(len(coordinates) + 1)\nbit.add(1, 1)\n\nfor a in sorted(ab):\n    bbb = sorted(map(cdg, ab[a]), reverse=True)\n    for b in bbb:\n        bit.add(b, bit.sum(b - 1))\n\nprint(bit.sum(bit.size))\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nfrom collections import defaultdict\n\n\nclass Bit:\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n        self.depth = n.bit_length()\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\n    def debug_print(self):\n        for i in range(1, self.size + 1):\n            j = (i & -i).bit_length()\n            print('  ' * j, self.tree[i])\n\n    def lower_bound(self, x):\n        sum_ = 0\n        pos = 0\n        for i in range(self.depth, -1, -1):\n            k = pos + (1 << i)\n            if k <= self.size and sum_ + self.tree[k] < x:\n                sum_ += self.tree[k]\n                pos += 1 << i\n        return pos + 1, sum_\n\n\nn, m = map(int, input().split())\nxxx = list(map(int, input().split()))\nyyy = list(map(int, input().split()))\nab = defaultdict(set)\ncoordinates = set()\n\nfor x in xxx:\n    if x < yyy[0] or yyy[-1] < x:\n        continue\n    i = bisect(yyy, x)\n    a = x - yyy[i - 1]\n    b = yyy[i] - x\n    ab[a].add(b)\n    coordinates.add(b)\n\n# Bitのindexは1から始まるように作っているが、\"0\"を取れるようにするため、全体を1ずらす\ncor_dict = {b: i for i, b in enumerate(sorted(coordinates), start=2)}\ncdg = cor_dict.get\nbit = Bit(len(coordinates) + 1)\nbit.add(1, 1)\n\nfor a in sorted(ab):\n    bbb = sorted(map(cdg, ab[a]), reverse=True)\n    for b in bbb:\n        bit.add(b, bit.sum(b - 1))\n\nprint(bit.sum(bit.size) % (10 ** 9 + 7))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom bisect import bisect_left\n\nMOD = 10**9 + 7\n\nN,M = map(int,readline().split())\nX = list(map(int,readline().split()))\nY = list(map(int,readline().split()))\n\nL = []; R = []\nfor x in X:\n    i = bisect_left(Y,x) # 右出口\n    if i in [0,M]:\n        continue\n    y0,y1 = Y[i-1:i+1]\n    L.append(y0-x); R.append(y1-x)\n\n# 座圧\nRtoi = {x:i for i,x in enumerate(sorted(set(R)),1)}\nR = [Rtoi[r] for r in R]\n\nif len(R) == 0:\n    print(1)\n    exit()\n\n\"\"\"\n・計算方法\n・これをやるために実際にはBITを使う\ndp = [0] * (max(R)+1)\nfor _,r in sorted(set(zip(L,R)),reverse=True):\n    dp[r] += 1 + sum(dp[1:r]) #これをやるために BIT で dp を持つ\nanswer=1+sum(dp)\nprint(answer)\n\"\"\"\n\nclass BIT():\n    def __init__(self, max_n):\n        self.size = max_n + 1\n        self.tree = [0] * self.size\n        \n    def get_sum(self,i):\n        s = 0\n        while i:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n \n    def add(self, i, x):\n        while i < self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndp = BIT(max_n=max(R))\nfor _,r in sorted(set(zip(L,R)),reverse=True):\n    x = dp.get_sum(r-1) + 1; x %= MOD\n    dp.add(r,x)\nanswer=1+dp.get_sum(max(R))\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nfrom collections import defaultdict\n\n\nclass Bit:\n    def __init__(self, n, MOD):\n        self.size = n\n        self.tree = [0] * (n + 1)\n        self.depth = n.bit_length()\n        self.mod = MOD\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s % self.mod\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] = (self.tree[i] + x) % self.mod\n            i += i & -i\n\n    def debug_print(self):\n        for i in range(1, self.size + 1):\n            j = (i & -i).bit_length()\n            print('  ' * j, self.tree[i])\n\n    def lower_bound(self, x):\n        sum_ = 0\n        pos = 0\n        for i in range(self.depth, -1, -1):\n            k = pos + (1 << i)\n            if k <= self.size and sum_ + self.tree[k] < x:\n                sum_ += self.tree[k]\n                pos += 1 << i\n        return pos + 1, sum_\n\n\nn, m = map(int, input().split())\nxxx = list(map(int, input().split()))\nyyy = list(map(int, input().split()))\nab = defaultdict(set)\ncoordinates = set()\n\nfor x in xxx:\n    if x < yyy[0] or yyy[-1] < x:\n        continue\n    i = bisect(yyy, x)\n    a = x - yyy[i - 1]\n    b = yyy[i] - x\n    ab[a].add(b)\n    coordinates.add(b)\n\n# Bitのindexは1から始まるように作っているが、\"0\"を取れるようにするため、全体を1ずらす\ncor_dict = {b: i for i, b in enumerate(sorted(coordinates), start=2)}\ncdg = cor_dict.get\nMOD = 10 ** 9 + 7\nbit = Bit(len(coordinates) + 1, MOD)\nbit.add(1, 1)\n\nfor a in sorted(ab):\n    bbb = sorted(map(cdg, ab[a]), reverse=True)\n    for b in bbb:\n        bit.add(b, bit.sum(b - 1))\n\nprint(bit.sum(bit.size))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom bisect import bisect_left\n\nMOD = 10**9 + 7\n\nN,M = map(int,readline().split())\nX = list(map(int,readline().split()))\nY = list(map(int,readline().split()))\n\nL = []; R = []\nfor x in X:\n    i = bisect_left(Y,x) # 右出口\n    if i in [0,M]:\n        continue\n    y0,y1 = Y[i-1:i+1]\n    L.append(y0-x); R.append(y1-x)\n\n# 座圧\nRtoi = {x:i for i,x in enumerate(sorted(set(R)),1)}\nR = [Rtoi[r] for r in R]\n\nif len(R) == 0:\n    print(1)\n    exit()\n\n\"\"\"\n・計算方法\n・これをやるために実際にはBITを使う\ndp = [0] * (max(R)+1)\nfor _,r in sorted(set(zip(L,R)),reverse=True):\n    dp[r] += 1 + sum(dp[1:r]) #これをやるために BIT で dp を持つ\nanswer=1+sum(dp)\nprint(answer)\n\"\"\"\n\nclass BIT():\n    def __init__(self, max_n):\n        self.size = max_n + 1\n        self.tree = [0] * self.size\n        \n    def get_sum(self,i):\n        s = 0\n        while i:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n \n    def add(self, i, x):\n        while i < self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndp = BIT(max_n=max(R))\nfor _,r in sorted(set(zip(L,R)),reverse=True):\n    x = dp.get_sum(r-1) + 1; x %= MOD\n    dp.add(r,x)\nanswer=1+dp.get_sum(max(R))\nanswer %= MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import bisect\nr_n, e_n = map(int,input().split())\nrobot = list(map(int,input().split()))\nexit = list(map(int,input().split()))\n\ndict = []\nfor r in robot:\n    i = bisect.bisect(exit,r)\n    if i == 0 or i == e_n:\n        continue\n    left = exit[i - 1]\n    right = exit[i]\n    dict.append([r - left, right - r])\n\ndict.sort()\n\ndef check(dict):\n    if len(dict) <= 1:\n        if len(dict) == 0:\n            return 1\n        else:\n            return 2\n    \n    result = 0\n    \n    left = dict[0][0]\n    count = 1\n    while True:\n        if count == len(dict) or dict[count][0] > left:\n            break\n        else:\n            count += 1\n    result += check(dict[count:])\n    \n    right = dict[0][1]\n    new_dict = []\n    for d in dict:\n        if d[1] > right:\n            new_dict.append(d)\n    result += check(new_dict)\n    \n    return result\n\nprint(check(dict))"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nfrom collections import defaultdict\n\n\nclass Bit:\n    def __init__(self, n, MOD):\n        self.size = n\n        self.tree = [0] * (n + 1)\n        self.depth = n.bit_length()\n        self.mod = MOD\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s = (s + self.tree[i]) % self.mod\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] = (self.tree[i] + x) % self.mod\n            i += i & -i\n\n    def debug_print(self):\n        for i in range(1, self.size + 1):\n            j = (i & -i).bit_length()\n            print('  ' * j, self.tree[i])\n\n    def lower_bound(self, x):\n        sum_ = 0\n        pos = 0\n        for i in range(self.depth, -1, -1):\n            k = pos + (1 << i)\n            if k <= self.size and sum_ + self.tree[k] < x:\n                sum_ += self.tree[k]\n                pos += 1 << i\n        return pos + 1, sum_\n\n\nn, m = map(int, input().split())\nxxx = list(map(int, input().split()))\nyyy = list(map(int, input().split()))\nab = defaultdict(set)\ncoordinates = set()\n\nfor x in xxx:\n    if x < yyy[0] or yyy[-1] < x:\n        continue\n    i = bisect(yyy, x)\n    a = x - yyy[i - 1]\n    b = yyy[i] - x\n    ab[a].add(b)\n    coordinates.add(b)\n\n# Bitのindexは1から始まるように作っているが、\"0\"を取れるようにするため、全体を1ずらす\ncor_dict = {b: i for i, b in enumerate(sorted(coordinates), start=2)}\ncdg = cor_dict.get\nMOD = 10 ** 9 + 7\nbit = Bit(len(coordinates) + 1, MOD)\nbit.add(1, 1)\n\nfor a in sorted(ab):\n    bbb = sorted(map(cdg, ab[a]), reverse=True)\n    for b in bbb:\n        bit.add(b, bit.sum(b - 1))\n\nprint(bit.sum(bit.size))\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Read, Write, BufWriter};\n\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\nconst MOD: i64 = 1_000_000_007;\n/// Refers to external ::MOD.\n/// Verified by: https://beta.atcoder.jp/contests/arc099/submissions/2893648\nmod mod_int {\n    use ::MOD;\n    use std::ops::*;\n    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt { pub x: i64 }\n    impl ModInt {\n        fn check_integrity(self) {\n            debug_assert!(self.x >= 0);\n            debug_assert!(self.x < MOD);\n        }\n        // x >= 0\n        pub fn new<T: Into<i64>>(x: T) -> Self { ModInt { x: x.into() % MOD } }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            ModInt { x: self.x * other.x % MOD }\n        }\n        #[allow(dead_code)]\n        pub fn mul_slow(self, other: Self) -> Self {\n            // Naive multiplication in order to avoid overflow\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = ModInt::new(0);\n            let mut cur = self;\n            let mut e = other.x;\n            if self.x < other.x {\n                cur = other;\n                e = self.x;\n            }\n            while e > 0 {\n                if e % 2 == 1 {\n                    sum = sum + cur;\n                }\n                cur = cur + cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            self.check_integrity();\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new(1);\n            let mut cur = ModInt::new(self.x);\n            while e > 0 {\n                if e % 2 != 0 {\n                    sum = sum * cur;\n                }\n                cur = cur * cur;\n                e /= 2;\n            }\n            sum\n        }\n        #[allow(unused)]\n        pub fn inv(self) -> Self { self.pow(MOD - 2) }\n    }\n    impl Add for ModInt {\n        type Output = Self;\n        fn add(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x + other.x;\n            if sum >= MOD { sum -= MOD; }\n            ModInt { x: sum }\n        }\n    }\n    impl Sub for ModInt {\n        type Output = Self;\n        fn sub(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += MOD; }\n            ModInt { x: sum }\n        }\n    }\n    impl Mul for ModInt {\n        type Output = Self;\n        fn mul(self, other: Self) -> Self {\n            self.mul_fast(other)\n        }\n    }\n    impl AddAssign for ModInt {\n        fn add_assign(&mut self, rhs: ModInt) { *self = *self + rhs; }\n    }\n    impl SubAssign for ModInt {\n        fn sub_assign(&mut self, rhs: ModInt) { *self = *self - rhs; }\n    }\n    impl MulAssign for ModInt {\n        fn mul_assign(&mut self, rhs: ModInt) { *self = *self * rhs; }\n    }\n    impl ::std::fmt::Display for ModInt {\n        fn fmt(&self, f: &mut::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n} // mod mod_int\nuse mod_int::*;\n\nconst INF: i64 = 1 << 40;\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\n/**\n * Segment Tree. This data structure is useful for fast folding on intervals of an array\n * whose elements are elements of monoid I. Note that constructing this tree requires the identity\n * element of I and the operation of I.\n * Verified by: yukicoder No. 259 (http://yukicoder.me/submissions/100581)\n *              AGC015-E (http://agc015.contest.atcoder.jp/submissions/1461001)\n */\nstruct SegTree<I, BiOp> {\n    n: usize,\n    dat: Vec<I>,\n    op: BiOp,\n    e: I,\n}\n\nimpl<I, BiOp> SegTree<I, BiOp>\n    where BiOp: Fn(I, I) -> I,\n          I: Copy {\n    pub fn new(n_: usize, op: BiOp, e: I) -> Self {\n        let mut n = 1;\n        while n < n_ { n *= 2; } // n is a power of 2\n        SegTree {n: n, dat: vec![e; 2 * n - 1], op: op, e: e}\n    }\n    /* ary[k] <- v */\n    pub fn update(&mut self, idx: usize, v: I) {\n        let mut k = idx + self.n - 1;\n        self.dat[k] = v;\n        while k > 0 {\n            k = (k - 1) / 2;\n            self.dat[k] = (self.op)(self.dat[2 * k + 1], self.dat[2 * k + 2]);\n        }\n    }\n    /* [a, b) (note: half-inclusive)\n     * http://proc-cpuinfo.fixstars.com/2017/07/optimize-segment-tree/ */\n    pub fn query(&self, mut a: usize, mut b: usize) -> I {\n        let mut left = self.e;\n        let mut right = self.e;\n        a += self.n - 1;\n        b += self.n - 1;\n        while a < b {\n            if (a & 1) == 0 {\n                left = (self.op)(left, self.dat[a]);\n            }\n            if (b & 1) == 0 {\n                right = (self.op)(self.dat[b - 1], right);\n            }\n            a = a / 2;\n            b = (b - 1) / 2;\n        }\n        (self.op)(left, right)\n    }\n}\n\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($format:expr) => (write!(out,$format).unwrap());\n        ($format:expr, $($args:expr),+) => (write!(out,$format,$($args),*).unwrap())\n    }\n    let n: usize = get();\n    let m: usize = get();\n    let x: Vec<i64> = (0 .. n).map(|_| get()).collect();\n    let y: Vec<i64> = (0 .. m).map(|_| get()).collect();\n    let mut pq = Vec::new();\n    let mut ps = Vec::new();\n    let mut qs_p = Vec::new();\n    for i in 0 .. n {\n        let idx = y.binary_search(&x[i]).err().unwrap();\n        let p = if idx >= 1 { x[i] - y[idx - 1] } else { INF };\n        let q = if idx <= m - 1 { y[idx] - x[i] } else { INF };\n        if p != INF && q != INF {\n            pq.push((p, q));\n            ps.push(p);\n            qs_p.push(q);\n        }\n    }\n    ps.sort();\n    ps.dedup();\n    qs_p.push(-INF);\n    qs_p.sort();\n    qs_p.dedup();\n    pq.sort();\n    let mut qs = vec![Vec::new(); ps.len()];\n    for &(p, q) in pq.iter() {\n        let idx = ps.binary_search(&p).ok().unwrap();\n        qs[idx].push(q);\n    }\n    let nn = qs_p.len();\n    let mut st = SegTree::new(nn, |x, y| x + y, ModInt::new(0));\n    st.update(0, ModInt::new(1));\n    for qs in qs.iter() {\n        let mut delay = Vec::new();\n        for &q in qs.iter() {\n            let idx = qs_p.binary_search(&q).ok().unwrap();\n            delay.push((idx, st.query(0, idx + 1)));\n        }\n        for (idx, val) in delay {\n            st.update(idx, val);\n        }\n    }\n    puts!(\"{}\\n\", st.query(0, nn));\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Read, Write, BufWriter};\n\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\nconst MOD: i64 = 1_000_000_007;\n/// Refers to external ::MOD.\n/// Verified by: https://beta.atcoder.jp/contests/arc099/submissions/2893648\nmod mod_int {\n    use ::MOD;\n    use std::ops::*;\n    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt { pub x: i64 }\n    impl ModInt {\n        fn check_integrity(self) {\n            debug_assert!(self.x >= 0);\n            debug_assert!(self.x < MOD);\n        }\n        // x >= 0\n        pub fn new<T: Into<i64>>(x: T) -> Self { ModInt { x: x.into() % MOD } }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            ModInt { x: self.x * other.x % MOD }\n        }\n        #[allow(dead_code)]\n        pub fn mul_slow(self, other: Self) -> Self {\n            // Naive multiplication in order to avoid overflow\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = ModInt::new(0);\n            let mut cur = self;\n            let mut e = other.x;\n            if self.x < other.x {\n                cur = other;\n                e = self.x;\n            }\n            while e > 0 {\n                if e % 2 == 1 {\n                    sum = sum + cur;\n                }\n                cur = cur + cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            self.check_integrity();\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new(1);\n            let mut cur = ModInt::new(self.x);\n            while e > 0 {\n                if e % 2 != 0 {\n                    sum = sum * cur;\n                }\n                cur = cur * cur;\n                e /= 2;\n            }\n            sum\n        }\n        #[allow(unused)]\n        pub fn inv(self) -> Self { self.pow(MOD - 2) }\n    }\n    impl Add for ModInt {\n        type Output = Self;\n        fn add(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x + other.x;\n            if sum >= MOD { sum -= MOD; }\n            ModInt { x: sum }\n        }\n    }\n    impl Sub for ModInt {\n        type Output = Self;\n        fn sub(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += MOD; }\n            ModInt { x: sum }\n        }\n    }\n    impl Mul for ModInt {\n        type Output = Self;\n        fn mul(self, other: Self) -> Self {\n            self.mul_fast(other)\n        }\n    }\n    impl AddAssign for ModInt {\n        fn add_assign(&mut self, rhs: ModInt) { *self = *self + rhs; }\n    }\n    impl SubAssign for ModInt {\n        fn sub_assign(&mut self, rhs: ModInt) { *self = *self - rhs; }\n    }\n    impl MulAssign for ModInt {\n        fn mul_assign(&mut self, rhs: ModInt) { *self = *self * rhs; }\n    }\n    impl ::std::fmt::Display for ModInt {\n        fn fmt(&self, f: &mut::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n} // mod mod_int\nuse mod_int::*;\n\nconst INF: i64 = 1 << 40;\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\n/**\n * Segment Tree. This data structure is useful for fast folding on intervals of an array\n * whose elements are elements of monoid I. Note that constructing this tree requires the identity\n * element of I and the operation of I.\n * Verified by: yukicoder No. 259 (http://yukicoder.me/submissions/100581)\n *              AGC015-E (http://agc015.contest.atcoder.jp/submissions/1461001)\n */\nstruct SegTree<I, BiOp> {\n    n: usize,\n    dat: Vec<I>,\n    op: BiOp,\n    e: I,\n}\n\nimpl<I, BiOp> SegTree<I, BiOp>\n    where BiOp: Fn(I, I) -> I,\n          I: Copy {\n    pub fn new(n_: usize, op: BiOp, e: I) -> Self {\n        let mut n = 1;\n        while n < n_ { n *= 2; } // n is a power of 2\n        SegTree {n: n, dat: vec![e; 2 * n - 1], op: op, e: e}\n    }\n    /* ary[k] <- v */\n    pub fn update(&mut self, idx: usize, v: I) {\n        let mut k = idx + self.n - 1;\n        self.dat[k] = v;\n        while k > 0 {\n            k = (k - 1) / 2;\n            self.dat[k] = (self.op)(self.dat[2 * k + 1], self.dat[2 * k + 2]);\n        }\n    }\n    /* [a, b) (note: half-inclusive)\n     * http://proc-cpuinfo.fixstars.com/2017/07/optimize-segment-tree/ */\n    pub fn query(&self, mut a: usize, mut b: usize) -> I {\n        let mut left = self.e;\n        let mut right = self.e;\n        a += self.n - 1;\n        b += self.n - 1;\n        while a < b {\n            if (a & 1) == 0 {\n                left = (self.op)(left, self.dat[a]);\n            }\n            if (b & 1) == 0 {\n                right = (self.op)(self.dat[b - 1], right);\n            }\n            a = a / 2;\n            b = (b - 1) / 2;\n        }\n        (self.op)(left, right)\n    }\n}\n\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($format:expr) => (write!(out,$format).unwrap());\n        ($format:expr, $($args:expr),+) => (write!(out,$format,$($args),*).unwrap())\n    }\n    let n: usize = get();\n    let m: usize = get();\n    let x: Vec<i64> = (0 .. n).map(|_| get()).collect();\n    let y: Vec<i64> = (0 .. m).map(|_| get()).collect();\n    let mut pqi = Vec::new();\n    let mut qpi = Vec::new();\n    let mut ps = Vec::new();\n    let mut qs_p = Vec::new();\n    for i in 0 .. n {\n        let idx = y.binary_search(&x[i]).err().unwrap();\n        let p = if idx >= 1 { x[i] - y[idx - 1] } else { INF };\n        let q = if idx <= m - 1 { y[idx] - x[i] } else { INF };\n        if p != INF && q != INF {\n            pqi.push((p, q, i));\n            qpi.push((-q, p, i));\n            ps.push(p);\n            qs_p.push(q);\n        }\n    }\n    ps.sort();\n    ps.dedup();\n    qs_p.push(-INF);\n    qs_p.sort();\n    qs_p.dedup();\n    qpi.push((-INF, -INF, n));\n    pqi.sort();\n    qpi.sort();\n    let k = ps.len();\n    let mut qs = vec![vec![(-INF, n)]; k + 1];\n    let mut dp = vec![vec![ModInt::new(0)]; k + 1];\n    for &(p, q, i) in pqi.iter() {\n        let idx = ps.binary_search(&p).ok().unwrap();\n        qs[idx + 1].push((q, i));\n        dp[idx + 1].push(ModInt::new(0));\n    }\n    let nn = qs_p.len();\n    let mut st = SegTree::new(nn, |x, y| x + y, ModInt::new(0));\n    st.update(0, ModInt::new(1));\n    for i in 1 .. k + 1 {\n        let mut delay = Vec::new();\n        for j in 1 .. dp[i].len() {\n            let (q, xidx) = qs[i][j];\n            let idx = qs_p.binary_search(&q).ok().unwrap();\n            // let idx = qpi.binary_search(&(-q, ps[i - 1], xidx)).ok().unwrap();\n            // eprintln!(\"q = {}, xidx = {}, idx = {}\", q, xidx, idx);\n            let val = st.query(0, idx + 1);\n            delay.push((idx, val));\n        }\n        for (idx, val) in delay {\n            st.update(idx, val);\n        }\n        /*\n        for i in 0 .. nn {\n            eprint!(\" {}\", st.query(i, i + 1));\n        }\n        eprintln!(\"\");\n         */\n    }\n    puts!(\"{}\\n\", st.query(0, nn));\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::input;\n\ntrait ModValue:\n    std::ops::Add<Output = Self>\n    + std::ops::Sub<Output = Self>\n    + std::ops::Mul<Output = Self>\n    + std::ops::Div<Output = Self>\n    + std::ops::Rem<Output = Self>\n    + std::ops::AddAssign\n    + std::ops::SubAssign\n    + std::ops::MulAssign\n    + std::ops::DivAssign\n    + std::ops::RemAssign\n    + std::ops::Neg\n    + std::cmp::Ord\n    + Clone\n    + Copy\n    + std::fmt::Debug\n    + Sized\n{\n    fn modulus() -> Self;\n    fn zero() -> Self;\n    fn one() -> Self;\n}\n\n#[derive(Clone, Copy, Debug)]\nstruct Modint<Value: ModValue>(Value);\n\nimpl<Value: ModValue> Modint<Value> {\n    #[allow(dead_code)]\n    pub fn with_value(x: Value) -> Self {\n        Self(Self::normalize(x))\n    }\n\n    #[allow(dead_code)]\n    pub fn with_value_unchecked(x: Value) -> Self {\n        Self(x)\n    }\n\n    #[allow(dead_code)]\n    pub fn validate(&self) -> &Self {\n        assert!(Value::zero() <= self.0 && self.0 < Value::modulus());\n        &self\n    }\n\n    fn normalize(x: Value) -> Value {\n        let x = x % Value::modulus();\n        if x < Value::zero() {\n            x + Value::modulus()\n        } else {\n            x\n        }\n    }\n\n    fn add_unchecked(x: Value, y: Value) -> Value {\n        let z = x + y;\n        if Value::modulus() <= z {\n            z - Value::modulus()\n        } else {\n            z\n        }\n    }\n\n    fn sub_unchecked(x: Value, y: Value) -> Value {\n        let z = x - y;\n        if x < Value::zero() {\n            z + Value::modulus()\n        } else {\n            z\n        }\n    }\n\n    fn neg_unchecked(x: Value) -> Value {\n        if x == Value::zero() {\n            Value::zero()\n        } else {\n            Value::modulus() - x\n        }\n    }\n\n    fn mul_unchecked(x: Value, y: Value) -> Value {\n        x * y % Value::modulus()\n    }\n\n    fn div_unchecked(x: Value, y: Value) -> Value {\n        Self::mul_unchecked(x, Self::inv_unchecked(y))\n    }\n\n    fn inv_unchecked(mut x: Value) -> Value {\n        let mut y: Value = Value::modulus();\n        let mut u: Value = Value::one();\n        let mut v: Value = Value::zero();\n        while x != Value::zero() {\n            let q = y / x;\n            y -= x * q;\n            v -= u * q;\n            std::mem::swap(&mut x, &mut y);\n            std::mem::swap(&mut u, &mut v);\n        }\n        if v < Value::zero() {\n            v + Value::modulus()\n        } else {\n            v\n        }\n    }\n}\n\nmacro_rules! impl_bop {\n    (\n        $(\n            $bop_trait: ident::$bop_fn: ident, $bop_assign_trait: ident::$bop_assign_fn: ident, $impl: ident;\n        )*\n    ) => {\n        $(\n            impl<Value: ModValue> std::ops::$bop_trait for Modint<Value> {\n                type Output = Self;\n                fn $bop_fn(self, rhs: Self) -> Self::Output {\n                    Modint(Self::$impl(self.0, rhs.0))\n                }\n            }\n            impl<Value: ModValue> std::ops::$bop_assign_trait for Modint<Value> {\n                fn $bop_assign_fn(&mut self, rhs: Self) {\n                    use std::ops::$bop_trait;\n                    *self = Modint::$bop_fn(*self, rhs)\n                }\n            }\n        )*\n    };\n}\n\nimpl_bop! {\n    Add::add, AddAssign::add_assign, add_unchecked;\n    Sub::sub, SubAssign::sub_assign, sub_unchecked;\n    Mul::mul, MulAssign::mul_assign, mul_unchecked;\n    Div::div, DivAssign::div_assign, div_unchecked;\n}\n\nimpl<Value: ModValue> std::ops::Neg for Modint<Value> {\n    type Output = Self;\n    fn neg(self) -> Self::Output {\n        Modint(Self::neg_unchecked(self.0))\n    }\n}\n\nimpl<Value: ModValue> std::iter::Sum<Self> for Modint<Value> {\n    fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n        iter.fold(Self::with_value(Value::zero()), std::ops::Add::add)\n    }\n}\n\nimpl<Value: ModValue> std::convert::From<Value> for Modint<Value> {\n    fn from(x: Value) -> Self {\n        Self::with_value(x)\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! modint {\n    ($x: expr) => {\n        Modint::with_value($x)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! impl_modvalue {\n    ($(const $mod_name: ident: $ty: ty = $mod_value: expr;)*) => {\n        $(\n            const $mod_name: $ty = $mod_value;\n            impl ModValue for $ty {\n                fn modulus() -> Self {\n                    $mod_name\n                }\n                fn zero() -> Self {\n                    0\n                }\n                fn one() -> Self {\n                    1\n                }\n            }\n        )*\n    };\n}\n\nimpl_modvalue! {\n    const MOD: i64 = 1_000_000_007;\n}\n\nfn main() {\n    input!(n: usize, m: usize, a: [i64; n], b: [i64; m]);\n    let mut data = vec![];\n    let mut j = 0;\n    for i in 0..n {\n        while j < m && b[j] < a[i] {\n            j += 1;\n        }\n        if j == 0 {\n            continue;\n        }\n        if j == m {\n            break;\n        }\n        data.push((a[i] - b[j - 1], b[j] - a[i]));\n    }\n\n    let mut coord_x: Vec<_> = data.iter().map(|&(x, _)| x).collect();\n    let mut coord_y: Vec<_> = data.iter().map(|&(_, y)| y).collect();\n    coord_x.sort();\n    coord_y.sort();\n    coord_x.dedup();\n    coord_y.dedup();\n\n    data.sort_by_key(|&(x, y)| (x, std::cmp::Reverse(y)));\n    data.dedup();\n    let data: Vec<_> = data\n        .iter()\n        .map(|&(x, y)| {\n            (\n                coord_x.binary_search(&x).unwrap(),\n                coord_y.binary_search(&y).unwrap(),\n            )\n        })\n        .collect();\n\n    let mut dp = vec![modint!(0); n + 1];\n    dp[0] = modint!(1);\n    for &(_, i) in &data {\n        let crr = dp[0..=i].iter().copied().sum::<Modint<i64>>();\n        dp[i + 1] += crr;\n    }\n    println!(\"{}\", dp.into_iter().sum::<Modint<i64>>().0);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Read, Write, BufWriter};\n\nconst DEBUG: bool = false;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\nconst MOD: i64 = 1_000_000_007;\n/// Refers to external ::MOD.\n/// Verified by: https://beta.atcoder.jp/contests/arc099/submissions/2893648\nmod mod_int {\n    use ::MOD;\n    use std::ops::*;\n    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt { pub x: i64 }\n    impl ModInt {\n        fn check_integrity(self) {\n            debug_assert!(self.x >= 0);\n            debug_assert!(self.x < MOD);\n        }\n        // x >= 0\n        pub fn new<T: Into<i64>>(x: T) -> Self { ModInt { x: x.into() % MOD } }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            ModInt { x: self.x * other.x % MOD }\n        }\n        #[allow(dead_code)]\n        pub fn mul_slow(self, other: Self) -> Self {\n            // Naive multiplication in order to avoid overflow\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = ModInt::new(0);\n            let mut cur = self;\n            let mut e = other.x;\n            if self.x < other.x {\n                cur = other;\n                e = self.x;\n            }\n            while e > 0 {\n                if e % 2 == 1 {\n                    sum = sum + cur;\n                }\n                cur = cur + cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            self.check_integrity();\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new(1);\n            let mut cur = ModInt::new(self.x);\n            while e > 0 {\n                if e % 2 != 0 {\n                    sum = sum * cur;\n                }\n                cur = cur * cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn inv(self) -> Self { self.pow(MOD - 2) }\n    }\n    impl Add for ModInt {\n        type Output = Self;\n        fn add(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x + other.x;\n            if sum >= MOD { sum -= MOD; }\n            ModInt { x: sum }\n        }\n    }\n    impl Sub for ModInt {\n        type Output = Self;\n        fn sub(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += MOD; }\n            ModInt { x: sum }\n        }\n    }\n    impl Mul for ModInt {\n        type Output = Self;\n        fn mul(self, other: Self) -> Self {\n            self.mul_fast(other)\n        }\n    }\n    impl AddAssign for ModInt {\n        fn add_assign(&mut self, rhs: ModInt) { *self = *self + rhs; }\n    }\n    impl SubAssign for ModInt {\n        fn sub_assign(&mut self, rhs: ModInt) { *self = *self - rhs; }\n    }\n    impl MulAssign for ModInt {\n        fn mul_assign(&mut self, rhs: ModInt) { *self = *self * rhs; }\n    }\n    impl ::std::fmt::Display for ModInt {\n        fn fmt(&self, f: &mut::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n} // mod mod_int\nuse mod_int::*;\n\nconst INF: i64 = 1 << 40;\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\n/**\n * Segment Tree. This data structure is useful for fast folding on intervals of an array\n * whose elements are elements of monoid I. Note that constructing this tree requires the identity\n * element of I and the operation of I.\n * Verified by: yukicoder No. 259 (http://yukicoder.me/submissions/100581)\n *              AGC015-E (http://agc015.contest.atcoder.jp/submissions/1461001)\n */\nstruct SegTree<I, BiOp> {\n    n: usize,\n    dat: Vec<I>,\n    op: BiOp,\n    e: I,\n}\n\nimpl<I, BiOp> SegTree<I, BiOp>\n    where BiOp: Fn(I, I) -> I,\n          I: Copy {\n    pub fn new(n_: usize, op: BiOp, e: I) -> Self {\n        let mut n = 1;\n        while n < n_ { n *= 2; } // n is a power of 2\n        SegTree {n: n, dat: vec![e; 2 * n - 1], op: op, e: e}\n    }\n    /* ary[k] <- v */\n    pub fn update(&mut self, idx: usize, v: I) {\n        let mut k = idx + self.n - 1;\n        self.dat[k] = v;\n        while k > 0 {\n            k = (k - 1) / 2;\n            self.dat[k] = (self.op)(self.dat[2 * k + 1], self.dat[2 * k + 2]);\n        }\n    }\n    /* [a, b) (note: half-inclusive)\n     * http://proc-cpuinfo.fixstars.com/2017/07/optimize-segment-tree/ */\n    pub fn query(&self, mut a: usize, mut b: usize) -> I {\n        let mut left = self.e;\n        let mut right = self.e;\n        a += self.n - 1;\n        b += self.n - 1;\n        while a < b {\n            if (a & 1) == 0 {\n                left = (self.op)(left, self.dat[a]);\n            }\n            if (b & 1) == 0 {\n                right = (self.op)(self.dat[b - 1], right);\n            }\n            a = a / 2;\n            b = (b - 1) / 2;\n        }\n        (self.op)(left, right)\n    }\n}\n\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($format:expr) => (write!(out,$format).unwrap());\n        ($format:expr, $($args:expr),+) => (write!(out,$format,$($args),*).unwrap())\n    }\n    let n: usize = get();\n    let m: usize = get();\n    let x: Vec<i64> = (0 .. n).map(|_| get()).collect();\n    let y: Vec<i64> = (0 .. m).map(|_| get()).collect();\n    let mut pqi = Vec::new();\n    let mut qpi = Vec::new();\n    let mut ps = Vec::new();\n    for i in 0 .. n {\n        let idx = y.binary_search(&x[i]).err().unwrap();\n        let p = if idx >= 1 { x[i] - y[idx - 1] } else { INF };\n        let q = if idx <= m - 1 { y[idx] - x[i] } else { INF };\n        if p != INF && q != INF {\n            pqi.push((p, q, i));\n            qpi.push((q, -p, i));\n            ps.push(p);\n        }\n    }\n    ps.sort();\n    ps.dedup();\n    qpi.push((-INF, -INF, n));\n    pqi.sort();\n    qpi.sort();\n    let k = ps.len();\n    let mut qs = vec![vec![(-INF, n)]; k + 1];\n    let mut dp = vec![vec![ModInt::new(0)]; k + 1];\n    for &(p, q, i) in pqi.iter() {\n        let idx = ps.binary_search(&p).ok().unwrap();\n        qs[idx + 1].push((q, i));\n        dp[idx + 1].push(ModInt::new(0));\n    }\n    let nn = qpi.len();\n    let mut st = SegTree::new(nn, |x, y| x + y, ModInt::new(0));\n    st.update(0, ModInt::new(1));\n    for i in 1 .. k + 1 {\n        for j in 1 .. dp[i].len() {\n            let (q, xidx) = qs[i][j];\n            let idx = qpi.binary_search(&(q, -ps[i - 1], xidx)).ok().unwrap();\n            // eprintln!(\"q = {}, xidx = {}, idx = {}\", q, xidx, idx);\n            let val = st.query(0, idx);\n            st.update(idx, val);\n        }\n        if DEBUG {\n            for i in 0 .. nn {\n                eprint!(\" {}\", st.query(i, i + 1));\n            }\n            eprintln!(\"\");\n        }\n    }\n    puts!(\"{}\\n\", st.query(0, nn));\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String {\n            bytes\n                .by_ref()\n                .map(|r| r.unwrap() as char)\n                .skip_while(|c| c.is_whitespace())\n                .take_while(|c| !c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, [ $t:tt ]) => {\n        {\n            let len = read_value!($next, usize);\n            (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_imports)]\nuse std::cmp::{min, max};\n\nfn main() {\n    input!{\n        n: usize,\n        m: usize,\n        r: [usize; n],\n        g: [usize; m]\n    }\n    let d = 1000000007;\n    let mut pos = vec![];\n    let mut ys = vec![0];\n    let mut i = 0;\n    for &x in &r {\n        if x < g[0] || x > g[m - 1] {\n            continue;\n        }\n        while g[i + 1] < x {\n            i += 1;\n        }\n        pos.push((x - g[i], g[i + 1] - x));\n        ys.push(g[i + 1] - x);\n    }\n    pos.sort_by(|x, y| if x.0 == y.0 {y.1.cmp(&x.1)} else {x.0.cmp(&y.0)});\n    pos.dedup();\n    ys.sort();\n    ys.dedup();\n    let mut bit = BIT::new(ys.len());\n    bit.add(0, 1, d);\n    for &(_, y) in &pos {\n        let idx = ys.binary_search(&y).unwrap();\n        let s = bit.sum(idx - 1, d);\n        bit.add(idx, s, d);\n    }\n    println!(\"{}\", bit.sum(ys.len() - 1, d));\n}\n\nstruct BIT {\n    v: Vec<usize>,\n    n: usize\n}\n\nimpl BIT {\n    fn new(n: usize) -> BIT {\n        BIT{v: vec![0; n + 1], n: n}\n    }\n\n    // add x to i th element\n    fn add(&mut self, i: usize, x: usize, d: usize) {\n        let mut id = i as i64 + 1;\n        while id <= self.n as i64 {\n            self.v[id as usize] = (self.v[id as usize] + x) % d;\n            id += id & -id;\n        }\n    }\n\n    // sum up to i th element\n    fn sum(&self, i: usize, d: usize) -> usize {\n        let mut id = i + 1;\n        let mut ret = 0;\n        while id > 0 {\n            ret = (ret + self.v[id]) % d;\n            id &= id - 1;\n        }\n        ret\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Read, Write, BufWriter};\n\nconst DEBUG: bool = true;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\nconst MOD: i64 = 1_000_000_007;\n/// Refers to external ::MOD.\n/// Verified by: https://beta.atcoder.jp/contests/arc099/submissions/2893648\nmod mod_int {\n    use ::MOD;\n    use std::ops::*;\n    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt { pub x: i64 }\n    impl ModInt {\n        fn check_integrity(self) {\n            debug_assert!(self.x >= 0);\n            debug_assert!(self.x < MOD);\n        }\n        // x >= 0\n        pub fn new<T: Into<i64>>(x: T) -> Self { ModInt { x: x.into() % MOD } }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            ModInt { x: self.x * other.x % MOD }\n        }\n        #[allow(dead_code)]\n        pub fn mul_slow(self, other: Self) -> Self {\n            // Naive multiplication in order to avoid overflow\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = ModInt::new(0);\n            let mut cur = self;\n            let mut e = other.x;\n            if self.x < other.x {\n                cur = other;\n                e = self.x;\n            }\n            while e > 0 {\n                if e % 2 == 1 {\n                    sum = sum + cur;\n                }\n                cur = cur + cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            self.check_integrity();\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new(1);\n            let mut cur = ModInt::new(self.x);\n            while e > 0 {\n                if e % 2 != 0 {\n                    sum = sum * cur;\n                }\n                cur = cur * cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn inv(self) -> Self { self.pow(MOD - 2) }\n    }\n    impl Add for ModInt {\n        type Output = Self;\n        fn add(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x + other.x;\n            if sum >= MOD { sum -= MOD; }\n            ModInt { x: sum }\n        }\n    }\n    impl Sub for ModInt {\n        type Output = Self;\n        fn sub(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += MOD; }\n            ModInt { x: sum }\n        }\n    }\n    impl Mul for ModInt {\n        type Output = Self;\n        fn mul(self, other: Self) -> Self {\n            self.mul_fast(other)\n        }\n    }\n    impl AddAssign for ModInt {\n        fn add_assign(&mut self, rhs: ModInt) { *self = *self + rhs; }\n    }\n    impl SubAssign for ModInt {\n        fn sub_assign(&mut self, rhs: ModInt) { *self = *self - rhs; }\n    }\n    impl MulAssign for ModInt {\n        fn mul_assign(&mut self, rhs: ModInt) { *self = *self * rhs; }\n    }\n    impl ::std::fmt::Display for ModInt {\n        fn fmt(&self, f: &mut::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n} // mod mod_int\nuse mod_int::*;\n\nconst INF: i64 = 1 << 40;\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\n/**\n * Segment Tree. This data structure is useful for fast folding on intervals of an array\n * whose elements are elements of monoid I. Note that constructing this tree requires the identity\n * element of I and the operation of I.\n * Verified by: yukicoder No. 259 (http://yukicoder.me/submissions/100581)\n *              AGC015-E (http://agc015.contest.atcoder.jp/submissions/1461001)\n */\nstruct SegTree<I, BiOp> {\n    n: usize,\n    dat: Vec<I>,\n    op: BiOp,\n    e: I,\n}\n\nimpl<I, BiOp> SegTree<I, BiOp>\n    where BiOp: Fn(I, I) -> I,\n          I: Copy {\n    pub fn new(n_: usize, op: BiOp, e: I) -> Self {\n        let mut n = 1;\n        while n < n_ { n *= 2; } // n is a power of 2\n        SegTree {n: n, dat: vec![e; 2 * n - 1], op: op, e: e}\n    }\n    /* ary[k] <- v */\n    pub fn update(&mut self, idx: usize, v: I) {\n        let mut k = idx + self.n - 1;\n        self.dat[k] = v;\n        while k > 0 {\n            k = (k - 1) / 2;\n            self.dat[k] = (self.op)(self.dat[2 * k + 1], self.dat[2 * k + 2]);\n        }\n    }\n    /* [a, b) (note: half-inclusive)\n     * http://proc-cpuinfo.fixstars.com/2017/07/optimize-segment-tree/ */\n    pub fn query(&self, mut a: usize, mut b: usize) -> I {\n        let mut left = self.e;\n        let mut right = self.e;\n        a += self.n - 1;\n        b += self.n - 1;\n        while a < b {\n            if (a & 1) == 0 {\n                left = (self.op)(left, self.dat[a]);\n            }\n            if (b & 1) == 0 {\n                right = (self.op)(self.dat[b - 1], right);\n            }\n            a = a / 2;\n            b = (b - 1) / 2;\n        }\n        (self.op)(left, right)\n    }\n}\n\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($format:expr) => (write!(out,$format).unwrap());\n        ($format:expr, $($args:expr),+) => (write!(out,$format,$($args),*).unwrap())\n    }\n    let n: usize = get();\n    let m: usize = get();\n    let x: Vec<i64> = (0 .. n).map(|_| get()).collect();\n    let y: Vec<i64> = (0 .. m).map(|_| get()).collect();\n    let mut pqi = Vec::new();\n    let mut qpi = Vec::new();\n    let mut ps = Vec::new();\n    for i in 0 .. n {\n        let idx = y.binary_search(&x[i]).err().unwrap();\n        let p = if idx >= 1 { x[i] - y[idx - 1] } else { INF };\n        let q = if idx <= m - 1 { y[idx] - x[i] } else { INF };\n        if p != INF && q != INF {\n            pqi.push((p, q, i));\n            qpi.push((q, -p, i));\n            ps.push(p);\n        }\n    }\n    ps.sort();\n    ps.dedup();\n    qpi.push((-INF, -INF, n));\n    pqi.sort();\n    qpi.sort();\n    let k = ps.len();\n    let mut qs = vec![vec![(-INF, n)]; k + 1];\n    let mut dp = vec![vec![ModInt::new(0)]; k + 1];\n    for &(p, q, i) in pqi.iter() {\n        let idx = ps.binary_search(&p).ok().unwrap();\n        qs[idx + 1].push((q, i));\n        dp[idx + 1].push(ModInt::new(0));\n    }\n    let nn = qpi.len();\n    let mut st = SegTree::new(nn, |x, y| x + y, ModInt::new(0));\n    st.update(0, ModInt::new(1));\n    for i in 1 .. k + 1 {\n        let mut delay = Vec::new();\n        for j in 1 .. dp[i].len() {\n            let (q, xidx) = qs[i][j];\n            let idx = qpi.binary_search(&(q, -ps[i - 1], xidx)).ok().unwrap();\n            //eprintln!(\"q = {}, xidx = {}, idx = {}\", q, xidx, idx);\n            let val = st.query(0, idx);\n            delay.push((idx, val));\n        }\n        for (idx, val) in delay {\n            st.update(idx, val);\n        }\n    }\n    puts!(\"{}\\n\", st.query(0, nn));\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/arc101/tasks/arc101_d\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n\n\n// ====\n\n#[derive(Debug, Clone)]\nstruct Treap<T> {\n    root: Link<T>\n}\n\nimpl<T: Ord + Copy + Debug> Treap<T> {\n    fn new() -> Self {\n        Treap {\n            root: None\n        }\n    }\n\n    fn push(&mut self, v: T) -> bool {\n        if self.contains(v) {\n            return false;\n        }\n        let u = self.root.take();\n        self.root = Node::push(u, v);\n        true\n    }\n\n    fn remove(&mut self, v: T) -> bool {\n        Node::remove(&mut self.root, v)\n    }\n\n    fn len(&self) -> usize {\n        Node::sz(&self.root)\n    }\n\n    fn min(&self) -> Option<T> {\n        Node::min(&self.root)\n    }\n\n    fn max(&self) -> Option<T> {\n        Node::max(&self.root)\n    }\n\n    fn contains(&self, value: T) -> bool {\n        Node::contains(&self.root, value)\n    }\n\n    fn peek_less(&self, value: T) -> Option<T> {\n        Node::peek_less(&self.root, value)\n    }\n\n    fn count_less(&self, value: T) -> usize {\n        Node::count_less(&self.root, value)\n    }\n\n    fn peek_greater(&self, value: T) -> Option<T> {\n        Node::peek_greater(&self.root, value)\n    }\n}\n\nstruct XorShift {\n    x: i64,\n    y: i64,\n    z: i64,\n    w: i64\n}\n\nimpl XorShift {\n    fn rotate(&mut self) {\n        let t = self.x ^ (self.x << 11);\n        self.x = self.y;\n        self.y = self.z;\n        self.z = self.w;\n        self.w = (self.w ^ (self.w >> 19)) ^ (t ^ (t >> 8));\n    }\n\n    fn next_i64(&mut self) -> i64 {\n        self.rotate();\n        self.w\n    }\n}\n\nstatic mut RAND: XorShift = XorShift {\n    x: 123456789i64,\n    y: 362436069i64,\n    z: 521288629i64,\n    w: 88675123i64\n};\n\nfn generate_next() -> i64 {\n    let x;\n    unsafe {\n        x = RAND.next_i64();\n    }\n    x\n}\n\ntype Link<T> = Option<Box<Node<T>>>;\n\n#[derive(Debug, Clone)]\nstruct Node<T> {\n    value: T,\n    size: usize,\n    priority: i64,\n    left: Link<T>,\n    right: Link<T>,\n}\n\nimpl<T: Ord + Copy + Debug> Node<T> {\n    fn new(value: T) -> Self {\n        Node {\n            value: value,\n            size: 1,\n            priority: generate_next(),\n            left: None,\n            right: None\n        }\n    }\n\n    fn sz(node: &Link<T>) -> usize {\n        match node.as_ref() { // TODO: Remove as_ref() after upgrading above 1.26\n            None => 0,\n            Some(x) => x.size\n        }\n    }\n\n    fn calc(node: &mut Link<T>) {\n        if let Some(x) = node.as_mut() { // TODO: Remove as_mut() after upgrading above 1.26\n            x.size = 1 + Node::sz(&x.left) + Node::sz(&x.right);\n        }\n    }\n\n    fn merge(left: Link<T>, right: Link<T>) -> Link<T> {\n        match (left, right) {\n            (None, None) => None,\n            (None, x) => x,\n            (x, None) => x,\n            (Some(l), Some(r)) => {\n                if l.priority < r.priority {\n                    let mut l = l;\n                    l.right = Self::merge(l.right.take(), Some(r));\n                    let mut l = Some(l);\n                    Node::calc(&mut l);\n                    l\n                } else {\n                    let mut r = r;\n                    r.left = Self::merge(Some(l), r.left.take());\n                    let mut r = Some(r);\n                    Node::calc(&mut r);\n                    r\n                }\n            }\n        }\n    }\n\n    fn min(now: &Link<T>) -> Option<T> {\n        match now.as_ref() { // TODO: Remove as_ref() after upgrading above 1.26\n            None    => None,\n            Some(x) => {\n                match x.left.as_ref() { // TODO: Remove as_ref() after upgrading above 1.26\n                    None    => Some(x.value),\n                    Some(_) => Self::min(&x.left)\n                }\n            }\n        }\n    }\n\n    fn max(now: &Link<T>) -> Option<T> {\n        match now.as_ref() { // TODO: Remove as_ref() after upgrading above 1.26\n            None    => None,\n            Some(x) => {\n                match x.right.as_ref() { // TODO: Remove as_ref() after upgrading above 1.26\n                    None    => Some(x.value),\n                    Some(_) => Self::max(&x.right)\n                }\n            }\n        }\n    }\n\n    fn contains(now: &Link<T>, value: T) -> bool {\n        match now.as_ref() { // TODO: Remove as_ref() after upgrading above 1.26\n            None => false,\n            Some(x) => {\n                match value.cmp(&x.value) {\n                    Ordering::Less    => Self::contains(&x.left, value),\n                    Ordering::Equal   => true,\n                    Ordering::Greater => Self::contains(&x.right, value)\n                }\n            }\n        }\n    }\n\n    fn count_less(now: &Link<T>, value: T) -> usize {\n        match now.as_ref() { // TODO: Remove as_ref() after upgrading above 1.26\n            None => 0,\n            Some(x) => {\n                match value.cmp(&x.value) {\n                    Ordering::Less | Ordering::Equal => {\n                        Self::count_less(&x.left, value)\n                    },\n                    Ordering::Greater => {\n                        let w = Self::count_less(&x.right, value);\n                        Node::sz(&x.left) + 1 + w\n                    }\n                }\n            }\n        }\n    }\n\n    fn peek_less(now: &Link<T>, value: T) -> Option<T> {\n        match now.as_ref() { // TODO: Remove as_ref() after upgrading above 1.26\n            None => None,\n            Some(x) => {\n                match value.cmp(&x.value) {\n                    Ordering::Less | Ordering::Equal => {\n                        Self::peek_less(&x.left, value)\n                    },\n                    Ordering::Greater => {\n                        let w = Self::peek_less(&x.right, value);\n                        if w == None {\n                            Some(x.value)\n                        } else {\n                            Some(max(w.unwrap(), x.value))\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    fn peek_greater(now: &Link<T>, value: T) -> Option<T> {\n        match now.as_ref() { // TODO: Remove as_ref() after upgrading above 1.26\n            None => None,\n            Some(x) => {\n                match value.cmp(&x.value) {\n                    Ordering::Greater | Ordering::Equal => {\n                        Self::peek_greater(&x.right, value)\n                    },\n                    Ordering::Less => {\n                        let w = Self::peek_greater(&x.left, value);\n                        if w == None {\n                            Some(x.value)\n                        } else {\n                            Some(min(w.unwrap(), x.value))\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    fn split_at(now: Link<T>, k: usize) -> (Link<T>, Link<T>) {\n        match now {\n            None => (None, None),\n            Some(x) => {\n                let mut x = x;\n                let lsz = Self::sz(&x.left);\n                if k <= lsz {\n                    let (nl, nr) = Self::split_at(x.left.take(), k);\n                    x.left = nr;\n                    let mut x = Some(x);\n                    Node::calc(&mut x);\n                    (nl, x)\n                } else {\n                    let (nl, nr) = Self::split_at(x.right.take(), k-1-lsz);\n                    x.right = nl;\n                    let mut x = Some(x);\n                    Node::calc(&mut x);\n                    (x, nr)\n                }\n            },\n        }\n    }\n\n    fn split_by(now: Link<T>, v: T) -> (Link<T>, Link<T>) {\n        match now {\n            None => (None, None),\n            Some(x) => {\n                let mut x = x;\n                if v <= x.value {\n                    let (nl, nr) = Self::split_by(x.left.take(), v);\n                    x.left = nr;\n                    let mut x = Some(x);\n                    Node::calc(&mut x);\n                    (nl, x)\n                } else {\n                    let (nl, nr) = Self::split_by(x.right.take(), v);\n                    x.right = nl;\n                    let mut x = Some(x);\n                    Node::calc(&mut x);\n                    (x, nr)\n                }\n            },\n        }\n    }\n\n    fn push(now: Link<T>, new_value: T) -> Link<T> {\n        let new_node = Some(Box::new(Node::new(new_value)));\n        let (left, right) = Self::split_by(now, new_value);\n        Self::merge(Self::merge(left, new_node), right)\n    }\n\n    fn remove(now: &mut Link<T>, target_value: T) -> bool {\n        let mut both_none = false;\n        let w = match now.as_mut() { // TODO: Remove as_mut() after upgrading above 1.26\n            None => false,\n            Some(x) => {\n                if target_value < x.value {\n                    Self::remove(&mut x.left, target_value)\n                } else if x.value < target_value {\n                    Self::remove(&mut x.right, target_value)\n                } else {\n                    let new_link = Self::merge(x.left.take(), x.right.take());\n                    if let Some(node) = new_link {\n                        *x = node;\n                    } else {\n                        both_none = true;\n                    }\n                    true\n                }\n            }\n        };\n        Node::calc(now);\n        if both_none {\n            now.take();\n        }\n        w\n    }\n}\n\n// ====\n\nstruct FenwickTree<T> {\n    data: Vec<T>\n}\n\nimpl<T: Copy + Default + std::ops::Add + std::ops::AddAssign + std::ops::Sub> FenwickTree<T> {\n    fn new(n: usize, initial: T) -> Self {\n        FenwickTree { data: vec![initial; n+1] }\n    }\n\n    /// Computes sum value of ([0, i)).\n    fn sum(&self, i: usize) -> T {\n        let mut idx = i as i64;\n        let mut ret = T::default();\n        while idx > 0 {\n            ret += self.data[idx as usize];\n            idx -= idx & (-idx);\n        }\n        ret\n    }\n\n    /// Adds value x into i-th position.\n    fn add(&mut self, i: usize, x: T) {\n        let mut idx = (i + 1) as i64;\n        while idx < self.data.len() as i64 {\n            self.data[idx as usize] += x;\n            idx += idx & (-idx);\n        }\n    }\n\n    fn range(&self, r: std::ops::Range<usize>) -> <T as std::ops::Sub>::Output {\n        self.sum(r.end) - self.sum(r.start)\n    }\n}\n\n// ====\n\nconst MOD: i64 = 1e9 as i64 + 7;\n\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\nstruct ModInt {\n    value: i64\n}\n\nimpl ModInt {\n    fn new<T: Into<i64>>(value: T) -> Self {\n        ModInt { value: value.into() % MOD }\n    }\n}\n\nimpl std::default::Default for ModInt {\n    fn default() -> Self {\n        ModInt { value: 0 }\n    }\n}\n\nimpl std::ops::Add for ModInt {\n    type Output = Self;\n    fn add(self, other: Self) -> Self {\n        let mut sum = self.value + other.value;\n        if sum >= MOD {\n            sum -= MOD;\n        }\n        ModInt { value: sum }\n    }\n}\n\nimpl std::ops::Sub for ModInt {\n    type Output = Self;\n    fn sub(self, other: Self) -> Self {\n        let mut sum = self.value - other.value;\n        if sum < 0 {\n            sum += MOD;\n        }\n        ModInt { value: sum }\n    }\n}\n\nimpl std::ops::Mul for ModInt {\n    type Output = Self;\n    fn mul(self, other: Self) -> Self {\n        ModInt { value: self.value * other.value % MOD }\n    }\n}\n\nimpl std::ops::AddAssign for ModInt {\n    fn add_assign(&mut self, rhs: ModInt) {\n        *self = *self + rhs;\n    }\n}\n\nimpl std::ops::SubAssign for ModInt {\n    fn sub_assign(&mut self, rhs: ModInt) {\n        *self = *self - rhs;\n    }\n}\n\nimpl std::ops::MulAssign for ModInt {\n    fn mul_assign(&mut self, rhs: ModInt) {\n        *self = *self * rhs;\n    }\n}\n\n\n// ===\n\nconst INF: i64 = 1e18 as i64;\n\nfn main() {\n    input! {\n        n: usize, m: usize,\n        robots: [i64; n],\n        exits: [i64; m],\n    };\n\n    let mut set = Treap::new();\n    set.push(-INF);\n    set.push(INF);\n    for e in exits {\n        set.push(e);\n    }\n\n\n    let mut pts = vec![];\n    for x in robots {\n        let lower = set.peek_less(x).unwrap();\n        let higher = set.peek_greater(x).unwrap();\n        if lower == -INF || higher == INF {\n            continue;\n        }\n        pts.push((x-lower, higher-x));\n    }\n    let mut ys = pts.clone().into_iter().map(|w| w.1).collect::<Vec<_>>();\n    ys.push(0);\n    ys.sort();\n    ys.dedup();\n    let mut ymap = HashMap::new();\n    for i in 0..ys.len() {\n        ymap.insert(ys[i], i);\n    }\n\n    pts.sort_by_key(|w| (w.0, -w.1));\n    pts.dedup();\n    let n = pts.len();\n    let mut dp = FenwickTree::new(100010, ModInt::new(0));\n    dp.add(0, ModInt::new(1));\n\n    let mut fr = 0;\n    while fr < n {\n        let mut to = fr;\n        while to < n && pts[fr].0 == pts[to].0 {\n            // debug!(pts[to]);\n            let yidx = *ymap.get(&pts[to].1).unwrap();\n            let lower = dp.range(0..yidx);\n            dp.add(yidx, lower);\n            to += 1;\n        }\n        fr = to;\n    }\n\n    println!(\"{}\", dp.range(0..100010).value);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin ModInt ----------\nconst MOD: u32 = 1_000_000_007;\n\n#[derive(Clone, Copy)]\nstruct ModInt(u32);\n\nimpl std::ops::Add for ModInt {\n    type Output = ModInt;\n    fn add(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::AddAssign for ModInt {\n    fn add_assign(&mut self, rhs: ModInt) {\n        *self = *self + rhs;\n    }\n}\n\nimpl std::ops::Sub for ModInt {\n    type Output = ModInt;\n    fn sub(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + MOD - rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::SubAssign for ModInt {\n    fn sub_assign(&mut self, rhs: ModInt) {\n        *self = *self - rhs;\n    }\n}\n\nimpl std::ops::Mul for ModInt {\n    type Output = ModInt;\n    fn mul(self, rhs: ModInt) -> Self::Output {\n        ModInt((self.0 as u64 * rhs.0 as u64 % MOD as u64) as u32)\n    }\n}\n\nimpl std::ops::MulAssign for ModInt {\n    fn mul_assign(&mut self, rhs: ModInt) {\n        *self = *self * rhs;\n    }\n}\n\nimpl std::ops::Neg for ModInt {\n    type Output = ModInt;\n    fn neg(self) -> Self::Output {\n        ModInt(if self.0 == 0 {0} else {MOD - self.0})\n    }\n}\n\nimpl std::fmt::Display for ModInt {\n    fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl std::str::FromStr for ModInt {\n    type Err = std::num::ParseIntError;\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let val = s.parse::<u32>()?;\n        Ok(ModInt::new(val))\n    }\n}\n\n#[allow(dead_code)]\nimpl ModInt {\n    pub fn new(n: u32) -> ModInt {\n        ModInt(n % MOD)\n    }\n    pub fn zero() -> ModInt {\n        ModInt(0)\n    }\n    pub fn one() -> ModInt {\n        ModInt(1)\n    }\n    pub fn pow(self, mut n: u32) -> ModInt {\n        let mut t = ModInt::one();\n        let mut s = self;\n        while n > 0 {\n            if n & 1 == 1 {\n                t *= s;\n            }\n            s *= s;\n            n >>= 1;\n        }\n        t\n    }\n    pub fn inv(self) -> ModInt {\n        self.pow(MOD - 2)\n    }\n}\n// ---------- end ModInt ----------\n// ---------- begin SegmentTree Point update Range query ----------\nmod segment_tree {\n    pub struct PURQ<T: Clone, F: Fn(T, T) -> T> {\n        n: usize,\n        a: Vec<T>,\n        id: T,\n        op: F,\n    }\n    #[allow(dead_code)]\n    impl<T: Clone, F: Fn(T, T) -> T> PURQ<T, F> {\n        pub fn new(n: usize, id: T, op: F) -> PURQ<T, F> {\n            let mut k = 1;\n            while k < n {\n                k *= 2;\n            }\n            PURQ {\n                n: k,\n                a: vec![id.clone(); 2 * k],\n                id: id,\n                op: op,\n            }\n        }\n        pub fn update(&mut self, x: usize, v: T) {\n            let mut k = self.n + x;\n            let a = &mut self.a;\n            a[k] = v;\n            k >>= 1;\n            while k > 0 {\n                a[k] = (self.op)(a[2 * k].clone(), a[2 * k + 1].clone());\n                k >>= 1;\n            }\n        }\n        pub fn update_tmp(&mut self, x: usize, v: T) {\n            self.a[x + self.n] = v;\n        }\n        pub fn update_all(&mut self) {\n            for k in (1..(self.n)).rev() {\n                self.a[k] = (self.op)(self.a[2 * k].clone(), self.a[2 * k + 1].clone());\n            }\n        }\n        pub fn find(&self, mut l: usize, mut r: usize) -> T {\n            let mut p = self.id.clone();\n            let mut q = self.id.clone();\n            l += self.n;\n            r += self.n;\n            while l < r {\n                if (l & 1) == 1 {\n                    p = (self.op)(p, self.a[l].clone());\n                    l += 1;\n                }\n                if (r & 1) == 1 {\n                    r -= 1;\n                    q = (self.op)(self.a[r].clone(), q);\n                }\n                l >>= 1;\n                r >>= 1;\n            }\n            (self.op)(p, q)\n        }\n    }\n}\n// ---------- end SegmentTree Point update Range query ----------\n//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8 より\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n//\n\nfn run() {\n    input! {\n        n: usize,\n        m: usize,\n        x: [i32; n],\n        y: [i32; m],\n    }\n    let mut l = vec![];\n    let mut r = vec![];\n    let mut p = vec![];\n    let mut j = 0;\n    for x in x.into_iter() {\n        while j < y.len() && y[j] < x {\n            j += 1;\n        }\n        if j == 0 || j >= y.len() {\n            continue;\n        }\n        let a = x - y[j - 1];\n        let b = y[j] - x;\n        l.push(a);\n        r.push(b);\n        p.push((a, b));\n    }\n    l.sort();\n    l.dedup();\n    r.sort();\n    r.dedup();\n    let h = l.len();\n    let w = r.len();\n    let mut op = vec![vec![]; h];\n    for (a, b) in p {\n        let a = l.binary_search(&a).unwrap();\n        let b = r.binary_search(&b).unwrap();\n        op[a].push(b);\n    }\n    let mut seg = segment_tree::PURQ::new(w + 1, ModInt::zero(), |a, b| a + b);\n    seg.update(w, ModInt::one());\n    for p in op.iter_mut().rev() {\n        p.sort();\n        p.dedup();\n        for &p in p.iter() {\n            let v = seg.find(p, w + 1);\n            seg.update(p, v);\n        }\n    }\n    let ans = seg.find(0, w + 1);\n    println!(\"{}\", ans);\n    /*\n    let mut elem = vec![vec![false; w + 1]; h + 1];\n    for (a, b) in p {\n        let a = l.binary_search(&a).unwrap();\n        let b = r.binary_search(&b).unwrap();\n        elem[a][b] = true;\n    }\n    let mut dp = vec![vec![ModInt::one(); w + 1]; h + 1];\n    for i in (0..h).rev() {\n        for j in (0..w).rev() {\n            if elem[i][j] {\n                dp[i][j] = dp[i + 1][j] + dp[i][j + 1];\n            } else {\n                dp[i][j] = dp[i + 1][j] + dp[i][j + 1] - dp[i + 1][j + 1];\n            }\n        }\n    }\n    println!(\"{}\", dp[0][0]);\n    */\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::input;\n\ntrait ModValue:\n    std::ops::Add<Output = Self>\n    + std::ops::Sub<Output = Self>\n    + std::ops::Mul<Output = Self>\n    + std::ops::Div<Output = Self>\n    + std::ops::Rem<Output = Self>\n    + std::ops::AddAssign\n    + std::ops::SubAssign\n    + std::ops::MulAssign\n    + std::ops::DivAssign\n    + std::ops::RemAssign\n    + std::ops::Neg\n    + std::cmp::Ord\n    + Clone\n    + Copy\n    + std::fmt::Debug\n    + Sized\n{\n    fn modulus() -> Self;\n    fn zero() -> Self;\n    fn one() -> Self;\n}\n\n#[derive(Clone, Copy, Debug)]\nstruct Modint<Value: ModValue>(Value);\n\nimpl<Value: ModValue> Modint<Value> {\n    #[allow(dead_code)]\n    pub fn with_value(x: Value) -> Self {\n        Self(Self::normalize(x))\n    }\n\n    #[allow(dead_code)]\n    pub fn with_value_unchecked(x: Value) -> Self {\n        Self(x)\n    }\n\n    #[allow(dead_code)]\n    pub fn validate(&self) -> &Self {\n        assert!(Value::zero() <= self.0 && self.0 < Value::modulus());\n        &self\n    }\n\n    fn normalize(x: Value) -> Value {\n        let x = x % Value::modulus();\n        if x < Value::zero() {\n            x + Value::modulus()\n        } else {\n            x\n        }\n    }\n\n    fn add_unchecked(x: Value, y: Value) -> Value {\n        let z = x + y;\n        if Value::modulus() <= z {\n            z - Value::modulus()\n        } else {\n            z\n        }\n    }\n\n    fn sub_unchecked(x: Value, y: Value) -> Value {\n        let z = x - y;\n        if x < Value::zero() {\n            z + Value::modulus()\n        } else {\n            z\n        }\n    }\n\n    fn neg_unchecked(x: Value) -> Value {\n        if x == Value::zero() {\n            Value::zero()\n        } else {\n            Value::modulus() - x\n        }\n    }\n\n    fn mul_unchecked(x: Value, y: Value) -> Value {\n        x * y % Value::modulus()\n    }\n\n    fn div_unchecked(x: Value, y: Value) -> Value {\n        Self::mul_unchecked(x, Self::inv_unchecked(y))\n    }\n\n    fn inv_unchecked(mut x: Value) -> Value {\n        let mut y: Value = Value::modulus();\n        let mut u: Value = Value::one();\n        let mut v: Value = Value::zero();\n        while x != Value::zero() {\n            let q = y / x;\n            y -= x * q;\n            v -= u * q;\n            std::mem::swap(&mut x, &mut y);\n            std::mem::swap(&mut u, &mut v);\n        }\n        if v < Value::zero() {\n            v + Value::modulus()\n        } else {\n            v\n        }\n    }\n}\n\nmacro_rules! impl_bop {\n    (\n        $(\n            $bop_trait: ident::$bop_fn: ident, $bop_assign_trait: ident::$bop_assign_fn: ident, $impl: ident;\n        )*\n    ) => {\n        $(\n            impl<Value: ModValue> std::ops::$bop_trait for Modint<Value> {\n                type Output = Self;\n                fn $bop_fn(self, rhs: Self) -> Self::Output {\n                    Modint(Self::$impl(self.0, rhs.0))\n                }\n            }\n            impl<Value: ModValue> std::ops::$bop_assign_trait for Modint<Value> {\n                fn $bop_assign_fn(&mut self, rhs: Self) {\n                    use std::ops::$bop_trait;\n                    *self = Modint::$bop_fn(*self, rhs)\n                }\n            }\n        )*\n    };\n}\n\nimpl_bop! {\n    Add::add, AddAssign::add_assign, add_unchecked;\n    Sub::sub, SubAssign::sub_assign, sub_unchecked;\n    Mul::mul, MulAssign::mul_assign, mul_unchecked;\n    Div::div, DivAssign::div_assign, div_unchecked;\n}\n\nimpl<Value: ModValue> std::ops::Neg for Modint<Value> {\n    type Output = Self;\n    fn neg(self) -> Self::Output {\n        Modint(Self::neg_unchecked(self.0))\n    }\n}\n\nimpl<Value: ModValue> std::iter::Sum<Self> for Modint<Value> {\n    fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n        iter.fold(Self::with_value(Value::zero()), std::ops::Add::add)\n    }\n}\n\nimpl<Value: ModValue + Default> std::default::Default for Modint<Value> {\n    fn default() -> Self {\n        Self::with_value(Default::default())\n    }\n}\n\nimpl<Value: ModValue> std::convert::From<Value> for Modint<Value> {\n    fn from(x: Value) -> Self {\n        Self::with_value(x)\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! modint {\n    ($x: expr) => {\n        Modint::with_value($x)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! impl_modvalue {\n    ($(const $mod_name: ident: $ty: ty = $mod_value: expr;)*) => {\n        $(\n            const $mod_name: $ty = $mod_value;\n            impl ModValue for $ty {\n                fn modulus() -> Self {\n                    $mod_name\n                }\n                fn zero() -> Self {\n                    0\n                }\n                fn one() -> Self {\n                    1\n                }\n            }\n        )*\n    };\n}\n\nimpl_modvalue! {\n    const MOD: i64 = 1_000_000_007;\n}\n\nmod segtree {\n    #[allow(dead_code)]\n    pub(super) trait SegTrait {\n        type Value: Clone;\n        fn id() -> Self::Value;\n        fn op(x: &Self::Value, y: &Self::Value) -> Self::Value;\n    }\n\n    #[allow(dead_code)]\n    pub(super) struct Segtree<T: SegTrait> {\n        table: Vec<T::Value>,\n    }\n\n    #[allow(dead_code)]\n    impl<T: SegTrait> Segtree<T> {\n        pub fn new(n: usize) -> Self {\n            Self {\n                table: vec![T::id(); 2 * n],\n            }\n        }\n\n        pub fn size(&self) -> usize {\n            self.table.len() / 2\n        }\n\n        pub fn map(&mut self, mut i: usize, f: impl Fn(&mut T::Value)) {\n            let n = self.size();\n            assert!(i < n);\n            i += n;\n            f(&mut self.table[i]);\n            i /= 2;\n            while 0 < i {\n                let tmp = T::op(&self.table[2 * i], &self.table[2 * i + 1]);\n                self.table[i] = tmp;\n                i /= 2;\n            }\n        }\n\n        pub fn add(&mut self, i: usize, x: T::Value)\n        where\n            T::Value: Copy + std::ops::AddAssign,\n        {\n            self.map(i, |y| *y += x);\n        }\n\n        pub fn fold(&self, mut l: usize, mut r: usize) -> T::Value {\n            let n = self.size();\n            assert!(l <= r && r <= n);\n            l += n;\n            r += n;\n            let mut ans = T::id();\n            while l < r {\n                if l % 2 == 1 {\n                    ans = T::op(&ans, &self.table[l]);\n                    l += 1;\n                }\n                if r % 2 == 1 {\n                    r -= 1;\n                    ans = T::op(&ans, &self.table[r]);\n                }\n                l /= 2;\n                r /= 2;\n            }\n            ans\n        }\n\n        pub fn fold_all(&self) -> T::Value {\n            let n = self.size();\n            self.fold(0, n)\n        }\n\n        pub fn collect(&self) -> Vec<T::Value> {\n            let n = self.size();\n            self.table[n..].into()\n        }\n    }\n\n    pub(super) struct AddMonoid<T: std::ops::Add<Output = T>> {\n        phantom: std::marker::PhantomData<T>,\n    }\n    impl<T: Clone + std::ops::Add<Output = T> + std::default::Default> SegTrait for AddMonoid<T> {\n        type Value = T;\n\n        fn id() -> Self::Value {\n            T::default()\n        }\n\n        fn op(x: &T, y: &T) -> T {\n            x.clone() + y.clone()\n        }\n    }\n}\n\nfn main() {\n    input!(n: usize, m: usize, a: [i64; n], b: [i64; m]);\n    let mut data = vec![];\n    let mut j = 0;\n    for i in 0..n {\n        while j < m && b[j] < a[i] {\n            j += 1;\n        }\n        if j == 0 {\n            continue;\n        }\n        if j == m {\n            break;\n        }\n        data.push((a[i] - b[j - 1], b[j] - a[i]));\n    }\n\n    let mut coord_x: Vec<_> = data.iter().map(|&(x, _)| x).collect();\n    let mut coord_y: Vec<_> = data.iter().map(|&(_, y)| y).collect();\n    coord_x.sort();\n    coord_y.sort();\n    coord_x.dedup();\n    coord_y.dedup();\n\n    data.sort_by_key(|&(x, y)| (x, std::cmp::Reverse(y)));\n    data.dedup();\n    let data: Vec<_> = data\n        .iter()\n        .map(|&(x, y)| {\n            (\n                coord_x.binary_search(&x).unwrap(),\n                coord_y.binary_search(&y).unwrap(),\n            )\n        })\n        .collect();\n\n    let mut seg = segtree::Segtree::<segtree::AddMonoid<Modint<i64>>>::new(n + 1);\n    seg.add(0, modint!(1));\n    for &(_, i) in &data {\n        let crr = seg.fold(0, i + 1);\n        seg.add(i + 1, crr);\n    }\n    println!(\"{}\", seg.fold_all().0);\n}\n"
  }
]