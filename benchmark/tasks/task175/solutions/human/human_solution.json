[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Emacs{\n  int line,column;\n  string buffer;\n  vector<string> text;\n\n  void editText(){\n    for(int i = 0 ; i < (int)text.size() ; i++){\n      if(isEmptyLine(i)){ text[i] = \" \"; }\n    }\n  }\n\n  void order(char command){\n    editText();\n    if(isEmptyLine(line)){ column = 0; }\n    switch(command){\n    case 'a': funcA(); break;\n    case 'e': funcE(); break;\n    case 'p': funcP(); break;\n    case 'n': funcN(); break;\n    case 'f': funcF(); break;\n    case 'b': funcB(); break;\n    case 'd': funcD(); break;\n    case 'k': funcK(); break;\n    case 'y': funcY(); break;\n    }\n  }\n\n  bool isEmptyLine(int l){\n    for(int i = 0 ; i < (int)text[l].size() ; i++){\n      if(text[l][i] != ' '){ return false; }\n    }\n    return true;\n  }\n\n  void funcA(){\n    column = 0;\n  }\n  \n  void funcE(){\n    if(isEmptyLine(line)){ return; }\n    column = text[line].size();\n  }\n\n  void funcP(){\n    if(line > 0){\n      line--;\n    }else{\n      column = 0;\n    }\n  }\n\n  void funcN(){\n    if(line+1 < (int)text.size()){\n      line++;\n    }else{\n      column = 0;\n    }\n  }\n\n  void funcF(){\n    if(isEmptyLine(line)){ return; }\n    if(column == (int)text[line].size()){\n      if(line+1 < (int)text.size()){\n        line++;\n        column = 0;\n      }\n    }else{\n      column++;\n    }\n  }\n  \n  void funcB(){\n    if(column == 0){\n      if(line != 0){\n        line--;\n        column = text[line].size();\n      }\n    }else{\n      column--;\n    }\n  }\n\n  void funcD(){\n    if(isEmptyLine(line)){\n      int len = text.size();\n      vector<string> ntext(len-1);\n      for(int i = 0 ; i < line ; i++){\n        ntext[i] = text[i];\n      }\n      for(int i = line ; i < len-1 ; i++){\n        ntext[i] = text[i+1];\n      }\n      text = ntext;\n      return;\n    }\n    if(0 <= column && column < (int)text[line].size()){\n      text[line] = text[line].substr(0,column) + text[line].substr(column+1);\n    }else{\n      int len = text.size();\n      if(line+1 < len){\n        vector<string> ntext(len-1);\n        for(int i = 0 ; i < line-1 ; i++){\n          ntext[i] = text[i];\n        }\n        ntext[line] = text[line] + text[line+1];\n        for(int i = line+2 ; i < len ; i++){\n          ntext[i] = text[i];\n        }\n        text = ntext;\n      }\n    }\n  }\n\n  void funcK(){\n    int len = text[line].size();\n    if(isEmptyLine(line)){\n      buffer = \"\\n\";\n      int len = text.size();\n      vector<string> ntext(len-1);\n      for(int i = 0 ; i < line ; i++){\n        ntext[i] = text[i];\n      }\n      for(int i = line ; i < len-1 ; i++){\n        ntext[i] = text[i+1];\n      }\n      text = ntext;\n      return;\n    }\n    if(column == len){\n      int len2 = text.size();\n      if(line+1 < len2){\n        buffer = \"\\n\";\n        vector<string> ntext(len2-1);\n        for(int i = 0 ; i < line-1 ; i++){\n          ntext[i] = text[i];\n        }\n        ntext[line] = text[line] + text[line+1];\n        for(int i = line+2 ; i < len ; i++){\n          ntext[i] = text[i];\n        }\n        text = ntext;\n      }\n    }else{\n      buffer.clear();\n      for(int i = column ; i < len ; i++){\n        buffer += text[line][i];\n      }\n      text[line].resize(column);\n    }\n  }\n\n  void funcY(){\n    if(buffer.empty()){ return; }\n    if(buffer == \"\\n\"){\n      string str = text[line];\n      text[line] = str.substr(0,column);\n      if(line+1 < (int)text.size()){\n        text[line+1] = str.substr(column) + text[line+1];\n      }else{\n        text.push_back(str.substr(column));\n      }\n    }else{\n      string str = text[line];\n      str = str.substr(0,column) + buffer + str.substr(column);\n      text[line] = str;\n      column = text[line].size()-1;\n    }\n  }\n\n  void print(){\n    int len = text.size();\n    for(int i = 0 ; i < len ; i++){\n      cout << text[i] << endl;\n    }\n  }\n};\n\nint main(){\n  Emacs emacs;\n  string str;\n  while(getline(cin,str), str != \"END_OF_TEXT\"){\n    emacs.text.push_back(str);\n  }\n  emacs.line = emacs.column = 0;\n  char command;\n  while(cin >> command, command != '-'){\n    emacs.order(command);\n  }\n  emacs.print();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\nvector<string> text;\nstring buf;\n\nint row, col;\n\nvoid func_a(){\n\tcol = 0;\n}\n\nvoid func_e(){\n\tcol = text[row].size() - 1;\n}\n\nvoid func_p(){\n\tif (row > 0) row--;\n\tfunc_a();\n}\n\nvoid func_n(){\n\tif (row < text.size() - 1) row++;\n\tfunc_a();\n}\n\nvoid func_f(){\n\tif (col < text[row].size() - 1) col++;\n\telse if (row < text.size() - 1){\n\t\tfunc_n();\n\t}\n}\n\nvoid func_b(){\n\tif (col > 0) col--;\n\telse if (row > 0){\n\t\tfunc_p();\n\t\tfunc_e();\n\t}\n}\n\nvoid func_d(){\n\tif (col < text[row].size() - 1) text[row].erase(col, 1);\n\telse if (row < text.size() - 1){\n\t\ttext[row].erase(text[row].end() - 1);\n\t\ttext[row] += text[row + 1];\n\t\ttext.erase(text.begin() + row + 1);\n\t}\n}\n\nvoid func_k(){\n\tif (col < text[row].size() - 1){\n\t\tbuf = text[row].substr(col, text[row].size() - col - 1);\n\t\ttext[row].erase(col, text[row].size() - 1);\n\t\tcol = text[row].size() - 1;\n\t}\n\telse { if (row < text.size() - 1){\n\t\tfunc_d();}\n\t\tbuf = \"\\n\";\n\t}\n}\n\nvoid func_y(){\n\tif (!buf.empty()){\n\t\tif (buf == \"\\n\"){\n\t\t\ttext.insert(text.begin() + row + 1, text[row].substr(col, text[row].size() - 1));\n\t\t\ttext[row].erase(col, text[row].size() - 1);\n\t\t\ttext[row] += '$';\n\t\t}\n\t\telse {\n\t\t\ttext[row].insert(col, buf);\n\t\t\tcol += buf.size();\n\t\t}\n\t}\n\telse puts(\"Sorry, Empty\");\n}\n\nint main()\n{\n\tstring in;\n\tchar cmd;\n\n\twhile (getline(cin, in), in != \"END_OF_TEXT\"){\n\t\ttext.push_back(in + '$');\n\t}\n\t\n\tcol = row = 0;\n\tbuf.clear();\n\n\twhile (cin >> cmd, cmd != '-'){\n\t\tswitch (cmd){\n\t\t  case 'a': func_a(); break;\n\t\t  case 'e':\tfunc_e(); break;\n\t\t  case 'p':\tfunc_p(); break;\n\t\t  case 'n': func_n(); break;\n\t\t  case 'f': func_f(); break;\n\t\t  case 'b':\tfunc_b(); break;\n\t\t  case 'd':\tfunc_d(); break;\n\t\t  case 'k': func_k(); break;\n\t\t  case 'y': func_y(); break;\n\t\t}\n#if 2\n\t\tprintf(\"col:%d row:%d\\n\", col, row);\n\t\tputs(\"status:\");\n\t\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\t\tcout << *it << endl;\n\t\t}\n\t\tputs(\"buffer:\");\n\t\tcout << buf << endl;\n#endif\n\t}\n\n\t\n\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\tcout << it->substr(0, it->size() - 1) << endl;\n\t}\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main(){\n\tstring s[101];\n\tint line = 0;\n\tfor ( string in;cin >> in, in != \"END_OF_TEXT\"; ++line ){\n\t\ts[ line ] = in;\n\t}\n\t\n\tint pX = 0;\n\tint pY = 0;\n\t\n\tstring buf;\n\tfor ( string in; cin >> in, in != \"-\"; ) {\n\t\tif ( in == \"a\" ) {\n\t\t\tpX = 0;\n\t\t} else if ( in == \"e\" ) {\n\t\t\tpX = s[ pY ].length();\n\t\t} else if ( in == \"p\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( 0 < pY ) {\n\t\t\t\t--pY;\n\t\t\t}\n\t\t} else if ( in == \"n\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( pY < line - 1 ) {\n\t\t\t\t++pY;\n\t\t\t}\n\t\t} else if ( in == \"f\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\t++pX;\n\t\t\t} else {\n\t\t\t\tif ( pY < line - 1 ) {\n\t\t\t\t\tpX = 0;\n\t\t\t\t\t++pY;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( in == \"b\" ) {\n\t\t\tif ( 0 < pX ) {\n\t\t\t\t--pX;\n\t\t\t} else {\n\t\t\t\tif ( 0 < pY ) {\n\t\t\t\t\t--pY;\n\t\t\t\t\tpX = s[ pY ].length();\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( in == \"d\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + s[ pY ].substr( pX + 1 );\n\t\t\t} else if ( pY < line - 1 ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\t--line;\n\t\t\t}\n\t\t} else if ( in == \"k\" ) {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\tbuf = s[ pY ].substr( pX );\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t} else if ( pY < line - 1 ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\t--line;\n\t\t\t\tbuf = \"\\n\";\n\t\t\t}\n\t\t} else if ( in == \"y\" ) {\n\t\t\tif ( !buf.empty() ) {\n\t\t\t\tif ( buf == \"\\n\" ) {\n\t\t\t\t\tfor ( int i = line - 1; pY < i; --i ) {\n\t\t\t\t\t\ts[ i ] = s[ i - 1 ];\n\t\t\t\t\t}\n\t\t\t\t\ts[ pY + 1 ] = s[ pY ].substr( pX );\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t\t\t++line;\n\t\t\t\t} else {\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + buf + s[ pY ].substr( pX );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor ( int i = 0; i < line; ++i ) cout << s[ i ] << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[1024];\nstring buf;\nint lines;\nvoid delete_line(int y)\n{\n    for (int i = y; y < lines; ++y)\n\ts[i] = s[i + 1];\n    s[--lines] = \"\";\n    if (lines <= 0)\n\tlines = 1;\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; ++i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    while (true)\n    {\n\tstring t;\n\tgetline(cin, t);\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines++] = t;\n    }\n    if (lines == 0)\n    {\n\tcout << \"\" << endl;\n\treturn 0;\n    }\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    y = max(0, --y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    y = min(lines - 1, ++y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y + 1 != lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t\tx = 0, --y;\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t    {\n\t\tif (x < s[y].size())\n\t\t{\n\t\t    s[y].erase(x, 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t    s[y] += s[y + 1];\n\t\t    delete_line(y + 1);\n\t\t}\n\t    }\n\t    break;\n\t \n\t}\n\tcase 'k':\n\t{\n\t    if (x == s[y].size())\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    else if (!s[y].empty())\n\t    {\n\t\tif (x < s[y].size())\n\t\t{\n\t\t    buf = s[y].substr(x);\n\t\t    s[y].erase(x);\n\t\t}\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\tif (!s[y].empty())\n\t\t{\n\t\t    if (x < s[y].size())\n\t\t    {\n\t\t\ts[y + 1] = s[y].substr(x);\n\t\t\ts[y].erase(x);\n\t\t    }\n\t\t}\n\t\tx = 0, ++y;\n\t    }\n\t    else if (!buf.empty())\n\t\ts[y] += buf;\n\t    break;\n\t}\n\t}\n\n\ty = min(lines - 1, max(0, y));\n\tx = max(0, min(x, (int)s[y].size()));\n    }\n\n    for (int i = 0; i < lines; ++i)\n\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t,u;\nvector<char> tmp;\nvector<char> z;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nvoid yinsert(int,vector<char>);\nvoid xinsert(int,int,char);\nvoid ydelete(int);\nvoid xdelete(int,int);\n\nint main(){\n\n  t.clear();\n  tmp.clear();\n  input();\n  x=y=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n    //cout<<y<<' '<<x<<\" ty\"<<t.size()<<endl;\n  }\n\n  for(int i=0;i<t.size();i++){\n    for(int j=0;j<t[i].size();j++){\n      cout<<t[i][j];\n    }\n  }\n\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    xdelete(y,x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  xdelete(y,x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  ydelete(y+1);\n}\n\nvoid funcK(){\n  tmp.clear();\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.push_back('\\n');\n    }\n    return;\n  }\n  while(t[y][x]!='\\n'){\n    tmp.push_back(t[y][x]);\n    xdelete(y,x);\n  }\n  reverse(tmp.begin(),tmp.end());\n  funcE();\n}\n\nvoid funcY(){\n  z.clear();\n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    while(t[y][x]!='\\n'){\n      z.push_back(t[y][x]);\n      xdelete(y,x);\n    }\n    yinsert(y+1,z);\n  funcE();\n    return;\n  }\n  for(int i=0;i<(int)tmp.size();i++){\n    xinsert(y,x,tmp[i]);\n  }\n  funcE();\n}\n\nvoid input(){\n  vector<char> a;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n}\n\n\n\n\n\n\n\n\nvoid xinsert(int y,int x,char ch){\n  if(x==(int)t[y].size()){\n    t[y].push_back(ch);\n  }else{\n    \n    z=t[y];\n    t[y].clear();\n    for(int i=0;i<(int)z.size();i++){\n      if(i==x)t[y].push_back(ch);\n      t[y].push_back(z[i]);\n    }\n  }\n}\n\nvoid xdelete(int y,int x){\n  if(x+1==(int)t[y].size()){\n    t[y].pop_back();\n  }else{\n    \n    z=t[y];\n    t[y].clear();\n    for(int i=0;i<(int)z.size();i++){\n      if(i==x)continue;\n      t[y].push_back(z[i]);\n    }\n  }\n}\n\nvoid yinsert(int y,vector<char> ch){\n  if(y==(int)t.size()){\n    t.push_back(ch);\n  }else{\n    u=t;\n    t.clear();\n    for(int i=0;i<(int)u.size();i++){\n      if(i==y)t.push_back(ch);\n      t.push_back(u[i]);\n    }\n  }\n}\n\nvoid ydelete(int y){\n  if(y+1==(int)t.size()){\n    t.pop_back();\n  }else{\n    u=t;\n    t.clear();\n    for(int i=0;i<(int)u.size();i++){\n      if(i==y)continue;\n      t.push_back(u[i]);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY = 0;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n}\n\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\\n\";\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX);\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX+1);\n\n\t\tlines[posY] = front;\n\t\tdeque<string>::iterator it = lines.begin();\n\t\tadvance(it,posY);\n\t\tlines.insert(it,rear);\n\t}\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(getline(cin,str)){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(cin >> str){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\tif(str == \"d\") ctrl_d(lines);\n\t\tif(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t,u;\nvector<char> tmp;\nvector<char> z;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nvoid yinsert(int,vector<char>);\nvoid xinsert(int,int,char);\nvoid ydelete(int);\nvoid xdelete(int,int);\n\nint main(){\n\n  t.clear();\n  tmp.clear();\n  input();\n  x=y=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n    //cout<<y<<' '<<x<<\" ty\"<<t.size()<<endl;\n  }\n\n  for(int i=0;i<t.size();i++){\n    for(int j=0;j<t[i].size();j++){\n      cout<<t[i][j];\n    }\n  }\n\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    xdelete(y,x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  xdelete(y,x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  ydelete(y+1);\n}\n\nvoid funcK(){\n  tmp.clear();\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.push_back('\\n');\n    }\n    return;\n  }\n  while(t[y][x]!='\\n'){\n    tmp.push_back(t[y][x]);\n    xdelete(y,x);\n  }\n  reverse(tmp.begin(),tmp.end());\n  //funcE();\n}\n\nvoid funcY(){\n  vector<char> z;\n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    while(t[y][x]!='\\n'){\n      z.push_back(t[y][x]);\n      xdelete(y,x);\n    }\n    yinsert(y+1,z);\n    y++;\n    x=0;\n    return;\n  }\n  for(int i=0;i<(int)tmp.size();i++){\n    xinsert(y,x,tmp[i]);\n  }\n  //funcE();\n}\n\nvoid input(){\n  vector<char> a;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <list>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n\tlist<string> li;\n\tlist<string>::iterator ite;\n\tstring buffer;\n\tbool bu = false;\n\tint lc = 0;\n\n\twhile (1) {\n\t\tstring s;\n\t\tbool mo = false;\n\t\tgetline(cin, s);\n\t\tif (s == \"END_OF_TEXT\") break;\n\t\tli.push_back(s);\n\t\tite = --li.end();\n\t\tfor (int j = 0; j < (*ite).size(); ++j) {\n\t\t\tif ((*ite)[j] != ' ') {\n\t\t\t\tmo = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 0; j < (*ite).size(); ++j) {\n\t\t\tif ((*ite)[j] != ' ') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!mo) { s = \"\"; }\n\t}\n\tite = li.begin(); lc = 0;\n\twhile (1) {\n\t\tchar c;\n\t\tcin >> c;\n\t\tif (c == '-') break;\n\t\tswitch (c) {\n\t\tcase 'a': lc = 0; break;\n\t\tcase 'e': lc = (*ite).size(); break;\n\t\tcase 'p': \n\t\t\tlc = 0; \n\t\t\tif (ite != li.begin()) --ite; break;\n\t\tcase 'n': \n\t\t\tlc = 0;\n\t\t\tif (ite != --li.end()) ++ite; break;\n\t\tcase 'f': \n\t\t\tif ((*ite).size() != lc) ++lc; \n\t\t\telse if((*ite).size() == lc && ite != --li.end()){\n\t\t\t\t++ite; lc = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b': \n\t\t\tif (lc != 0) --lc;\n\t\t\telse if(lc == 0 && ite != --li.begin()){\n\t\t\t\t--ite; \n\t\t\t\tlc = (*ite).size();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd': \n\t\t\tif ((*ite)[lc] != ' ') {\n\t\t\t\t(*ite).erase((*ite).begin() + lc);\n\t\t\t}\n\t\t\telse if ((*ite).size() == lc && ite != --li.end()) {\n\t\t\t\t(*ite) += (*++ite);\n\t\t\t\tli.erase(ite);\n\t\t\t\t--ite;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'k': \n\t\t\tif ((*ite).size() == lc && ite != --li.end()) {\n\t\t\t\t(*ite) += (*++ite);\n\t\t\t\tli.erase(ite);\n\t\t\t\t--ite;\n\t\t\t\tbuffer = \"\"; bu = true;\n\t\t\t\tlc = (*ite).size();\n\t\t\t}\n\t\t\telse if ((*ite).size() != lc){\n\t\t\t\tbuffer = (*ite).substr(lc, (*ite).size());\n\t\t\t\t(*ite).erase(lc, (*ite).size());\n\t\t\t\tbu = true;\n\t\t\t\tlc = (*ite).size();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'y': \n\t\t\tif (bu) {\n\t\t\t\tif (buffer == \"\") {\n\t\t\t\t\tli.insert(ite,(*ite).substr(lc, (*ite).size()));\n\t\t\t\t\tlc = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t(*ite).insert(lc, buffer);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (list<string>::iterator i = li.begin(); i != li.end(); ++i) {\n\t\tcout << *i << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nstring s[102],buf;\nint l,r,N;\n\nvoid a(void){r=0;}\nvoid e(void){r=s[l].size()-1;}\nvoid p(void){\n\tif(l>0)l--;\n\telse r=0;\n}\n\nvoid n(void){\n\tif(l<N-1)l++,r=0;\n\telse r=0;\n}\n\nvoid f(void){\n\tif(r<s[l].size()-1)r++;\n\telse l++,r=0;\n}\n\nvoid b(void){\n\tif(r>0)r--;\n\telse if(l>0)r=s[--l].size();\n}\n\nvoid d(void){\n\tif(r==s[l].size()-1){\n\t\tif(l<N-1){\n\t\t\ts[l]+=s[l+1];\n\t\t\tfor(int i=l+1;i<N-1;i++)s[i]=s[i+1];\n\t\t\tN--;\n\t\t}\n\t}\n\telse s[l].erase(r,1);\n}\n\nvoid k(void){\n\tif(r==s[l].size() && l<N-1)d(),buf=\"\\n\";\n\telse {\n\t\tbuf=s[l].substr(max(0,r-1));\n\t\ts[l].erase(max(0,r-1));\n\t}\n}\n\nvoid y(void){\n\tif(buf.empty())return ;\n\tif(buf==\"\\n\"){\n\t\tfor(int i=N;i>l;i--)s[i]=s[i-1];\n\t\ts[l+1]=s[l].substr(max(0,r-1));\n\t\ts[l].erase(max(0,r-1));\n\t\tl++,r=0,N++;\n\t}\n\telse {\n\t\ts[l].insert(min((int)s[l].size(),r+1),buf);\n\t\tr+=buf.size();\n\t}\n}\n\n\nint main(void){\n\t\n\twhile(getline(cin,s[N])){\n\t\tif(s[N]==\"END_OF_TEXT\")break;\n\t\tN++;\n\t}\n\tl=r=0;\n\tbuf.clear();\n\t\n\t\t\n\tstring C;\n\twhile(cin >> C,C!=\"-\"){\n\t\t\n\t\tif(C==\"a\")a();\n\t\telse if(C==\"e\")e();\n\t\telse if(C==\"p\")p();\n\t\telse if(C==\"n\")n();\n\t\telse if(C==\"f\")f();\n\t\telse if(C==\"b\")b();\n\t\telse if(C==\"d\")d();\n\t\telse if(C==\"k\")k();\n\t\telse if(C==\"y\")y();\n\t}\n\t\n\tfor(int i=0;i<N;i++){\n\t\tcout << s[i] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    vector<string> buffer;\n    while(true) {\n        string str;\n        getline(cin, str);\n        if(str == \"END_OF_TEXT\") break;\n        buffer.push_back(str);\n    }\n\n    int row = 0, col = 0;\n    string clipboard;\n    while(true) {\n        char op;\n        cin >> op;\n        if(op == '-') break;\n        if(op == 'a') {\n            col = 0;\n        }\n        else if(op == 'e') {\n            col = buffer[row].size();\n        }\n        else if(op == 'p') {\n            col = 0;\n            if(row > 0) row--;\n        }\n        else if(op == 'n') {\n            col = 0;\n            if(row+1 < buffer.size()) row++;\n        }\n        else if(op == 'f') {\n            if(col == buffer[row].size()) {\n                if(row+1 < buffer.size()) {\n                    row++;\n                    col = 0;\n                }\n            }\n            else col++;\n        }\n        else if(op == 'b') {\n            if(col == 0) {\n                if(row-1 >= 0) {\n                    row--;\n                    col = buffer[row].size();\n                }\n            }\n            else col--;\n        }\n        else if(op == 'd') {\n            if(col == buffer[row].size()) {\n                if(row+1 < buffer.size()) {\n                    buffer[row] += buffer[row+1];\n                    for(int i = row+1; i < (int)buffer.size()-1; ++i) buffer[i] = buffer[i+1];\n                    buffer.resize((int)buffer.size()-1);\n                }\n            }\n            else buffer[row] = buffer[row].substr(0, col) + buffer[row].substr(col+1);\n        }\n        else if(op == 'k') {\n            if(col == buffer[row].size()) {\n                if(row+1 < buffer.size()) {\n                    buffer[row] += buffer[row+1];\n                    for(int i = row+1; i < (int)buffer.size()-1; ++i) buffer[i] = buffer[i+1];\n                    buffer.resize((int)buffer.size()-1);\n                    clipboard = \"\\n\";\n                }\n            }\n            else {\n                clipboard = buffer[row].substr(col);\n                buffer[row] = buffer[row].substr(0, col);\n            }\n        }\n        else if(op == 'y') {\n            if(clipboard == \"\\n\") {\n                buffer.resize(buffer.size()+1);\n                for(int i = buffer.size()-1; i > row+1; --i) \n                    buffer[i] = buffer[i-1];\n                buffer[row+1] = buffer[row].substr(col);\n                buffer[row] = buffer[row].substr(0, col);\n            }\n            else if(clipboard != \"\") {\n                buffer[row] = buffer[row].substr(0, col) + clipboard + buffer[row].substr(col);\n                col += clipboard.size();\n            }\n        }\n    }\n    for(int i = 0; i < buffer.size(); ++i)\n        cout << buffer[i] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nint main(){\n  vector<string> text(200);\n  int line = 0;\n  for(;line<11;line++){\n    getline(cin,text[line],'\\n');\n    if (text[line]==\"END_OF_TEXT\")\n      break;\n  }\n  string buf=\"\";\n  int cur[2];\n  cur[0] = 0;//0s\n  cur[1] = 0;//0¶Ú\n\n  while(true){\n    char com;\n    cin >> com;\n    if (com == '-')\n      break;\n    switch (com){\n    case 'a':\n      cur[1] = 0;\n      break;\n    case 'e':\n      cur[1] = (int)text[cur[0]].size();\n      break;\n    case 'p':\n      if (cur[0]>0)\n\tcur[0]--;\n      cur[1]=0;\n      break;\n    case 'n':\n      if (cur[0]<line-1)\n\tcur[0]++;\n      cur[1]=0;\n      break;\n    case 'f':\n      if (cur[1]<(int)text[cur[0]].size()){\n\tcur[1]++;\n      }\n      else{\n\tif (cur[0]<line-1){\n\t  cur[0]++;\n\t  cur[1]=0;\t\n\t}\n      }\n      break;\n    case 'b':\n      if (cur[1]>0)\n\tcur[1]--;\n      else{\n\tif (cur[0]>0){\n\t  cur[0]--;\n\t  cur[1]=(int)text[cur[0]].size();\t\n\t}\n      }\n      break;\n    case 'd':\n      if (cur[1]<(int)text[cur[0]].size()){\n\ttext[cur[0]] = text[cur[0]].substr(0,cur[1])+text[cur[0]].substr(cur[1]+1);\n      }\n      else{\n\tif (cur[0]<line-1){\n\t  text[cur[0]] = text[cur[0]]+text[cur[0]+1];\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i] = text[i+1];\n\t  line--;\n\t}\n      }\n      break;\n    case 'k':\n      if (cur[1]==(int)text[cur[0]].size()){\n\tif (cur[0]<line-1){\n\t  text[cur[0]] = text[cur[0]]+text[cur[0]+1];\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i] = text[i+1];\n\t  line--;\n\t  buf = \"\\n\";\n\t}\n      }\n      else{\n\tbuf = text[cur[0]].substr(cur[1]);\n\ttext[cur[0]] = text[cur[0]].substr(0,cur[1]);\n\tcur[1] = (int)text[cur[0]].size();\n      }\n      break;\n    case 'y':\n      if (buf.empty())\n\tbreak;\n      else{\n\tif (buf == \"\\n\"){\n\t  for(int i=line+1;i>=cur[0]+1;i--)\n\t    text[i+1] = text[i];\n\t  line++;\n\t  text[cur[0]+1] = text[cur[0]].substr(cur[1]);\n\t  text[cur[0]] = text[cur[0]].substr(0,cur[1]);\n\t  cur[0]++;\n\t  cur[1]=0;\n\t}\n\telse{\n\t  text[cur[0]] = text[cur[0]].substr(0,cur[1])+buf+text[cur[0]].substr(cur[1]);\n\t  cur[1] += buf.size();\n\t}\n      }\n    default:\n      break;\n    }\n          for(int i=0;i<line;i++)\n\tcout << text[i] << endl;\n\tcout << \"(\" << cur[0] << \",\" << cur[1] << \")\" << endl;\n\tcout << \"#\" << endl;\n  }\n  for(int i=0;i<line;i++)\n    cout << text[i] << endl;\n  return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\nvector<string> text;\nstring buf;\n\nint row, col;\n\nvoid func_a(){\n\tcol = 0;\n}\n\nvoid func_e(){\n\tcol = text[row].size() - 1;\n}\n\nvoid func_p(){\n\tif (row > 0) row--;\n\tfunc_a();\n}\n\nvoid func_n(){\n\tif (row < text.size() - 1) row++;\n\tfunc_a();\n}\n\nvoid func_f(){\n\tif (col < text[row].size() - 1) col++;\n\telse if (row < text.size() - 1){\n\t\tfunc_n();\n\t}\n}\n\nvoid func_b(){\n\tif (col > 0) col--;\n\telse if (row > 0){\n\t\tfunc_p();\n\t\tfunc_e();\n\t}\n}\n\nvoid func_d(){\n\tif (col < text[row].size() - 1) text[row].erase(col, 1);\n\telse if (row < text.size() - 1){\n\t\ttext[row].erase(text[row].end() - 1);\n\t\ttext[row] += text[row + 1];\n\t\ttext.erase(text.begin() + row + 1);\n\t}\n}\n\nvoid func_k(){\n\tif (col < text[row].size() - 1){\n\t\tbuf = text[row].substr(col, text[row].size() - col - 1);\n\t\ttext[row].erase(col, text[row].size() - 1);\n\t\tcol = text[row].size() - 1;\n\t}\n\telse { if (row < text.size() - 1){\n\t\tfunc_d();}\n\t\tbuf = \"\\n\";\n\t}\n}\n\nvoid func_y(){\n\tif (!buf.empty()){\n\t\tif (buf == \"\\n\"){\n\t\t\ttext.insert(text.begin() + row + 1, text[row].substr(col, text[row].size() - 1));\n\t\t\ttext[row].erase(col, text[row].size() - 1);\n\t\t\ttext[row] += '$';\n\t\t}\n\t\telse {\n\t\t\ttext[row].insert(col, buf);\n\t\t\tcol += buf.size();\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstring in;\n\tchar cmd;\n\n\twhile (getline(cin, in), in != \"END_OF_TEXT\"){\n\t\ttext.push_back(in + '$');\n\t}\n\t\n\tcol = row = 0;\n\tbuf.clear();\n\n\twhile (cin >> cmd, cmd != '-'){\n\t\tswitch (cmd){\n\t\t  case 'a': func_a(); break;\n\t\t  case 'e':\tfunc_e(); break;\n\t\t  case 'p':\tfunc_p(); break;\n\t\t  case 'n': func_n(); break;\n\t\t  case 'f': func_f(); break;\n\t\t  case 'b':\tfunc_b(); break;\n\t\t  case 'd':\tfunc_d(); break;\n\t\t  case 'k': func_k(); break;\n\t\t  case 'y': func_y(); break;\n\t\t}\n#if 0\n\t\tprintf(\"col:%d row:%d\\n\", col, row);\n\t\tputs(\"status:\");\n\t\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\t\tcout << *it << endl;\n\t\t}\n\t\tputs(\"buffer:\");\n\t\tcout << buf << endl;\n#endif\n\t}\n\n\t\n\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\tcout << it->substr(0, it->size() - 1) << endl;\n\t}\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY = 0;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n\telse return;\n}\n\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\\n\";\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring front=\"\";\n\t\tstring rear=\"\";\n\t\tfront = lines[posY].substr(0,posX);\n\t\trear = lines[posY].substr(posX,lines[posY].size()-posX);\t\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX);\n\n\t\tlines[posY] = front;\n\t\t//deque<string>::iterator it = lines.begin();\n\t\t//advance(it,posY);\n\t\tdeque<string> res;\n\n\t\tfor(int i=0;i<posY;i++){\n\t\t\tres.push_back(lines[i]);\n\t\t}\n\n\t\tres.push_back(lines[posY]);\n\t\tres.push_back(rear);\n\t\t\n\n\t\tfor(int i=posY+1;i<lines.size();i++){\n\t\t\tres.push_back(lines[i]);\n\t\t}\n\t\t\n\t\tlines = res;\n\t\tposY++;\n\t\t//lines.insert(lines.begin()+posY,rear);\n\t\t//lines.insert(it,rear);\n\t}\n\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(getline(cin,str)){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(cin >> str){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\tif(str == \"d\") ctrl_d(lines);\n\t\tif(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Emacs{\n  int line,column;\n  string buffer;\n  vector<string> text;\n\n  void editText(){\n    for(int i = 0 ; i < (int)text.size() ; i++){\n      if(isEmptyLine(i)){ text[i].empty(); }\n    }\n  }\n\n  void print(int x,char command){\n    cout << \"buffer: \" << buffer << endl;\n    cout << \"command: \" << command << endl;\n    cout << \"line: \" << line << endl;\n    cout << \"column: \" << column << endl;\n    for(int i = 0 ; i < text.size(); i++){\n      cout << text[i] << endl;\n    }\n    cout << endl;\n  }\n\n  void order(char command){\n    editText();\n    switch(command){\n    case 'a': funcA(); break;\n    case 'e': funcE(); break;\n    case 'p': funcP(); break;\n    case 'n': funcN(); break;\n    case 'f': funcF(); break;\n    case 'b': funcB(); break;\n    case 'd': funcD(); break;\n    case 'k': funcK(); break;\n    case 'y': funcY(); break;\n    }\n    //print(1,command);\n  }\n\n  bool isEmptyLine(int l){\n    for(int i = 0 ; i < (int)text[l].size() ; i++){\n      if(text[l][i] != ' '){ return false; }\n    }\n    return true;\n  }\n\n  void funcA(){\n    column = 0;\n  }\n  \n  void funcE(){\n    column = text[line].size();\n  }\n\n  void funcP(){\n    if(line > 0){ line--; }\n    column = 0;\n  }\n\n  void funcN(){\n    if(line+1 < (int)text.size()){ line++; }\n    column = 0;\n  }\n\n  void funcF(){\n    if(column == (int)text[line].size()){\n      if(line+1 < (int)text.size()){\n        line++;\n        column = 0;\n      }\n    }else{\n      column++;\n    }\n  }\n  \n  void funcB(){\n    if(column == 0){\n      if(line != 0){\n        line--;\n        column = text[line].size();\n      }\n    }else{\n      column--;\n    }\n  }\n\n  void funcD(){\n    if(text[line].empty()){\n      int len = text.size();\n      vector<string> ntext(len-1);\n      for(int i = 0 ; i < line ; i++){\n        ntext[i] = text[i];\n      }\n      for(int i = line ; i < len-1 ; i++){\n        ntext[i] = text[i+1];\n      }\n      text = ntext;\n      return;\n    }\n    if(0 <= column && column < (int)text[line].size()){\n      text[line] = text[line].substr(0,column) + text[line].substr(column+1);\n    }else{\n      int len = text.size();\n      if(line+1 < len){\n        vector<string> ntext(len-1);\n        for(int i = 0 ; i < line-1 ; i++){\n          ntext[i] = text[i];\n        }\n        ntext[line] = text[line] + text[line+1];\n        for(int i = line+2 ; i < len ; i++){\n          ntext[i-1] = text[i];\n        }\n        text = ntext;\n      }\n    }\n  }\n\n  void funcK(){\n    int len = text[line].size();\n    if(text[line].empty()){\n      buffer = \"\\n\";\n      int len = text.size();\n      vector<string> ntext(len-1);\n      for(int i = 0 ; i < line ; i++){\n        ntext[i] = text[i];\n      }\n      for(int i = line ; i < len-1 ; i++){\n        ntext[i] = text[i+1];\n      }\n      text = ntext;\n      return;\n    }\n    if(column == len){\n      int len2 = text.size();\n      if(line+1 < len2){\n        buffer = \"\\n\";\n        vector<string> ntext(len-1);\n        for(int i = 0 ; i < line-1 ; i++){\n          ntext[i] = text[i];\n        }\n        ntext[line] = text[line] + text[line+1];\n        for(int i = line+2 ; i < len ; i++){\n          ntext[i-1] = text[i];\n        }\n        text = ntext;\n      }\n    }else{\n      buffer.clear();\n      for(int i = column ; i < len ; i++){\n        buffer += text[line][i];\n      }\n      text[line].resize(column);\n    }\n  }\n\n  void funcY(){\n    if(buffer.empty()){ return; }\n    if(buffer == \"\\n\"){\n      string str = text[line];\n      text[line] = str.substr(0,column);\n      if(line+1 < (int)text.size()){\n        text[line+1] = str.substr(column) + text[line+1];\n      }else{\n        text.push_back(str.substr(column));\n      }\n    }else{\n      string str = text[line];\n      str = str.substr(0,column) + buffer + str.substr(column);\n      text[line] = str;\n      column = text[line].size();\n    }\n  }\n\n  void print(){\n    int len = text.size();\n    for(int i = 0 ; i < len ; i++){\n      cout << text[i] << endl;\n    }\n  }\n};\n\nint main(){\n  Emacs emacs;\n  string str;\n  while(getline(cin,str), str != \"END_OF_TEXT\"){\n    emacs.text.push_back(str);\n  }\n  emacs.line = emacs.column = 0;\n  char command;\n  while(cin >> command, command != '-'){\n    emacs.order(command);\n  }\n  emacs.print();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Emacs{\n  int line,column;\n  string buffer;\n  vector<string> text;\n\n  void editText(){\n    for(int i = 0 ; i < (int)text.size() ; i++){\n      if(isEmptyLine(i)){ text[i] = \" \"; }\n    }\n  }\n\n  void order(char command){\n    editText();\n    switch(command){\n    case 'a': funcA(); break;\n    case 'e': funcE(); break;\n    case 'p': funcP(); break;\n    case 'n': funcN(); break;\n    case 'f': funcF(); break;\n    case 'b': funcB(); break;\n    case 'd': funcD(); break;\n    case 'k': funcK(); break;\n    case 'y': funcY(); break;\n    }\n  }\n\n  bool isEmptyLine(int l){\n    for(int i = 0 ; i < (int)text[l].size() ; i++){\n      if(text[l][i] != ' '){ return false; }\n    }\n    return true;\n  }\n\n  void funcA(){\n    column = 0;\n  }\n  \n  void funcE(){\n    column = text[line].size();\n  }\n\n  void funcP(){\n    if(line > 0){\n      line--;\n    }else{\n      column = 0;\n    }\n  }\n\n  void funcN(){\n    if(line+1 < (int)text.size()){\n      line++;\n    }else{\n      column = 0;\n    }\n  }\n\n  void funcF(){\n    if(column == (int)text[line].size()){\n      if(line+1 < (int)text.size()){\n        line++;\n        column = 0;\n      }\n    }else{\n      column++;\n    }\n  }\n  \n  void funcB(){\n    if(column == 0){\n      if(line != 0){\n        line--;\n        column = text[line].size();\n      }\n    }else{\n      column--;\n    }\n  }\n\n  void funcD(){\n    if(0 <= column && column < (int)text[line].size()){\n      text[line] = text[line].substr(0,column) + text[line].substr(column+1);\n    }else{\n      int len = text.size();\n      if(line+1 < len){\n        vector<string> ntext(len-1);\n        for(int i = 0 ; i < line-1 ; i++){\n          ntext[i] = text[i];\n        }\n        ntext[line] = text[line] + text[line+1];\n        for(int i = line+2 ; i < len ; i++){\n          ntext[i] = text[i];\n        }\n        text = ntext;\n      }\n    }\n  }\n\n  void funcK(){\n    int len = text[line].size();\n    if(column == len){\n      int len2 = text.size();\n      if(line+1 < len2){\n        buffer = \"\\n\";\n        vector<string> ntext(len2-1);\n        for(int i = 0 ; i < line-1 ; i++){\n          ntext[i] = text[i];\n        }\n        ntext[line] = text[line] + text[line+1];\n        for(int i = line+2 ; i < len ; i++){\n          ntext[i] = text[i];\n        }\n        text = ntext;\n      }\n    }else{\n      buffer.clear();\n      for(int i = column ; i < len ; i++){\n        buffer += text[line][i];\n      }\n      text[line].resize(column);\n    }\n  }\n\n  void funcY(){\n    if(buffer.empty()){ return; }\n    if(buffer == \"\\n\"){\n      string str = text[line];\n      text[line] = str.substr(0,column);\n      if(line+1 < (int)text.size()){\n        text[line+1] = str.substr(column) + text[line+1];\n      }else{\n        text.push_back(str.substr(column));\n      }\n    }else{\n      string str = text[line];\n      str = str.substr(0,column) + buffer + str.substr(column);\n      text[line] = str;\n    }\n  }\n\n  void print(){\n    int len = text.size();\n    for(int i = 0 ; i < len ; i++){\n      cout << text[i] << endl;\n    }\n  }\n};\n\nint main(){\n  Emacs emacs;\n  string str;\n  while(cin >> str, str != \"END_OF_TEXT\"){\n    emacs.text.push_back(str);\n  }\n  emacs.line = emacs.column = 0;\n  char command;\n  while(cin >> command, command != '-'){\n    emacs.order(command);\n  }\n  emacs.print();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nvector<string> s;\nstring buf = \"\";\nint R;\nint ci = 0, cj = 0;\n\nvoid input() {\n  string l;\n  while (1) {\n    getline(cin, l);\n    if (l == \"END_OF_TEXT\") {\n      break;\n    }\n    s.push_back(l);\n  }\n  R = s.size();\n}\n\n// カーソルを現在の行の先頭文字に移動する\nvoid op_a() { cj = 0; }\n\n// カーソルを現在の行の行末に移動する\nvoid op_e() { cj = s[ci].size(); }\n\n// 上に行があれば、カーソルを上の行の先頭文字に移動する。\n// 上に行がなければ、カーソルを先頭文字に移動する。\nvoid op_p() {\n  if (ci != 0) \n    --ci;\n  op_a();\n}\n\n// 下に行があれば、カーソルを下の行の先頭文字に移動する。\n// 下に行がなければ、カーソルを先頭文字に移動する。\nvoid op_n() {\n  if (ci != R - 1) \n    ++ci;\n  op_a();\n}\n\n// カーソルが行末にない場合、カーソルを１つ右に移動する \n// カーソルが行末にありかつ下に行がある場合は、\n// カーソルを下の行の先頭文字へ移動する \n// それ以外の場合は何もしない\nvoid op_f() {\n  if (cj != s[ci].size()) {\n    ++cj;\n  } else if (cj == s[ci].size() && ci != R - 1) {\n    op_n();\n  }\n}\n\n// カーソルが先頭文字でないならば、カーソルを１つ左に移動する。\n// カーソルが先頭文字でありかつ上に行がある場合は、\n// カーソルを上の行の行末へ移動する。\n// それ以外の場合は何もしない。\nvoid op_b() {\n  if (cj != 0) {\n    --cj;\n  } else if (cj == 0 && ci != 0) {\n    --ci;\n    op_e();\n  }\n}\n\n// カーソルが文字を指す場合はその文字を削除する。\n// 削除された文字の右側の文字列は左にシフトされる。\n// カーソルが行末を指し下に行がある場合は、\n// 下の行をそのままカーソルの位置に繋げる。以下の行は上にシフトされる。\n// それ以外の場合は何もしない。\nvoid op_d() {\n  if (cj != s[ci].size()) {\n    // prev\n    // s[ci].erase(cj, 1);\n    s[ci] = s[ci].substr(0, cj) + s[ci].substr(cj + 1);\n  } else if (cj == s[ci].size() && ci != R - 1) {\n    // prev\n    // s[ci].erase(cj, 1);\n    // s[ci] += s[ci+1];\n    // s.erase(s.begin() + ci + 1);\n    s[ci] += s[ci+1];\n    s.erase(s.begin() + ci + 1);\n  }\n}\n\n// カーソルが行末にある場合、下に行があれば、\n// d と同じ操作をしバッファに１つの改行を記録する。\n// カーソルが行末にない場合、カーソルが指す文字を含めた\n// 右側すべての文字を切り取りそれをバッファに記録する。\n// カーソルは元の行の行末を指すようになる。全ての記録においてバッファは上書きされる。\n// それ以外の場合は何もしない。(clarification at 14:20)\nvoid op_k() {\n  if (cj == s[ci].size() && ci != R - 1) {\n    // prev\n    // s[ci].erase(cj, 1);\n    // s[ci] += s[ci+1];\n    // s.erase(s.begin() + ci + 1);\n    s[ci] += s[ci+1];\n    s.erase(s.begin() + ci + 1);\n    buf = \"\\n\";\n  } else  {\n    // prev\n    // buf = s[ci].substr(cj);\n    // s[ci].erase(cj);\n    buf = s[ci].substr(cj);\n    s[ci] = s[ci].substr(0, cj);\n  }\n}\n\n// バッファが空の場合はなにもしない。\n// バッファの内容が改行の場合、カーソルが指す文字の直前で改行を行う。\n// カーソルは新しい行の先頭文字へ移動する。\n// バッファの内容が文字列の場合、カーソルの位置にバッファの内容を挿入する。\n// カーソルの位置はもともと指していた文字または行末の場所へ移動する。 \nvoid op_y() {\n  if (buf == \"\") return;\n  if (buf == \"\\n\") {\n    // prev\n    // inserter(s, s.begin() + ci + 1) = s[ci].substr(cj);\n    // s[ci].erase(cj);\n    // ++ci; cj = 0;\n    vector<string>::iterator itr = s.begin();\n    rep(i,ci+1) ++itr;\n    s.insert(itr, s[ci].substr(cj));\n    s[ci] = s[ci].substr(0, cj);\n    ++ci; cj = 0;\n  } else {\n    // prev\n    // s[ci].insert(cj, buf.c_str());\n    // cj += buf.size();\n    s[ci] = s[ci].substr(0, cj) + buf + s[ci].substr(cj);\n    cj += buf.size();\n  }\n}\n\nvoid interpret() {\n  string op;\n  while (1) {\n    getline(cin, op);\n    if (op == \"-\") break;\n    if (op == \"a\") {\n      op_a();\n    } else if (op == \"e\") {\n      op_e();\n    } else if (op == \"p\") {\n      op_p();\n    } else if (op == \"n\") {\n      op_n();\n    } else if (op == \"f\") {\n      op_f();\n    } else if (op == \"b\") {\n      op_b();\n    } else if (op == \"d\") {\n      op_d();\n    } else if (op == \"k\") {\n      op_k();\n    } else if (op == \"y\") {\n      op_y();\n    }\n  }\n  rep(i,R) {\n    // printf(\"%s\\n\", s[i].c_str());\n    cout << s[i] << endl;\n  }\n}\n\nint main() {\n  input();\n  interpret();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main(){\n\tstring s[500];\n\tint line = 0;\n\tfor ( string in;cin >> in, in != \"END_OF_TEXT\"; ++line ){\n\t\ts[ line ] = in;\n\t}\n\t\n\tint pX = 0;\n\tint pY = 0;\n\t\n\tstring buf;\n\tfor ( string in; cin >> in, in != \"-\"; ) {\n\t\tif ( in == \"a\" ) {\n\t\t\tpX = 0;\n\t\t} else if ( in == \"e\" ) {\n\t\t\tpX = s[ pY ].length();\n\t\t} else if ( in == \"p\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( 0 != pY ) {\n\t\t\t\t--pY;\n\t\t\t}\n\t\t} else if ( in == \"n\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( pY != line - 1 ) {\n\t\t\t\t++pY;\n\t\t\t}\n\t\t} else if ( in == \"f\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\t++pX;\n\t\t\t} else if ( pY != line - 1 ) {\n\t\t\t\tpX = 0;\n\t\t\t\t++pY;\n\t\t\t}\n\t\t} else if ( in == \"b\" ) {\n\t\t\tif ( 0 < pX ) {\n\t\t\t\t--pX;\n\t\t\t} else {\n\t\t\t\tif ( 0 < pY ) {\n\t\t\t\t\t--pY;\n\t\t\t\t\tpX = s[ pY ].length();\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( in == \"d\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + s[ pY ].substr( pX + 1 );\n\t\t\t} else if ( pY < line - 1 ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\ts[ line - 1 ] = \"\";\n\t\t\t\t--line;\n\t\t\t}\n\t\t} else if ( in == \"k\" ) {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\tbuf = s[ pY ].substr( pX );\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t} else if ( pY < line - 1 ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\ts[ line - 1 ] = \"\";\n\t\t\t\t--line;\n\t\t\t\tbuf = \"\\n\";\n\t\t\t}\n\t\t} else if ( in == \"y\" ) {\n\t\t\tif ( !buf.empty() ) {\n\t\t\t\tif ( buf == \"\\n\" ) {\n\t\t\t\t\tfor ( int i = line - 1; pY < i; --i ) {\n\t\t\t\t\t\ts[ i ] = s[ i - 1 ];\n\t\t\t\t\t}\n\t\t\t\t\ts[ pY + 1 ] = s[ pY ].substr( pX );\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t\t\t++line;\n\t\t\t\t} else {\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + buf + s[ pY ].substr( pX );\n\t\t\t\t\tpX += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor ( int i = 0; i < line; ++i ) cout << s[ i ] << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY = 0;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n}\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\\n\";\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX);\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX+1);\n\n\t\tlines[posY] = front;\n\t\tdeque<string>::iterator it = lines.begin();\n\t\tadvance(it,posY);\n\t\tlines.insert(it,rear);\n\t}\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(getline(cin,str)){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(getline(cin,str)){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\tif(str == \"d\") ctrl_d(lines);\n\t\tif(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst ll INF = 1LL << 50;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nsize_t tpos = 0;\nsize_t lpos = 0;\n\nvoid do_a(const vector<string> &text){\n\tlpos = 0;\n}\n\nvoid do_e(const vector<string> &text){\n\tlpos = text[tpos].size();\n}\n\nvoid do_p(const vector<string> &text){\n\tlpos = 0;\n\ttpos = max(0, (int)tpos - 1);\n}\n\nvoid do_n(const vector<string> &text){\n\tlpos = 0;\n\ttpos = min(tpos + 1, text.size() - 1);\n}\n\nvoid do_f(const vector<string> &text){\n\tif(lpos == text[tpos].size()){\n\t\tif(tpos < text.size() - 1){\n\t\t\tlpos = 0;\n\t\t\ttpos++;\n\t\t}\n\t}else{\n\t\tlpos++;\n\t}\n}\n\nvoid do_b(const vector<string> &text){\n\tif(lpos != 0){\n\t\tlpos--;\n\t}else{\n\t\tif(tpos > 0) tpos--;\n\t}\n}\n\nvoid do_d(vector<string> &text){\n\tif(lpos != text[tpos].size()){\n\t\ttext[tpos].erase(lpos, 1);\n\t}else{\n\t\tif(tpos < text.size() - 1){\n\t\t\ttext[tpos]+=text[tpos+1];\n\t\t\ttext.erase(text.begin() + tpos+1);\n\t\t}\n\t}\n}\n\nvoid do_k(vector<string> &text, string &buffer){\n\tif(lpos == text[tpos].size()){\n\t\tif(tpos < text.size() - 1){\n\t\t\tbuffer = \"\\n\";\n\t\t\tdo_d(text);\n\t\t}\n\t}else{\n\t\tbuffer = string(text[tpos].begin() + lpos, text[tpos].end());\n\t\ttext[tpos].erase(text[tpos].begin() + lpos, text[tpos].end());\n\t}\n}\n\nvoid do_y(vector<string> &text, string &buffer){\n\tif(buffer != \"\"){\n\t\tif(buffer == \"\\n\"){\n\t\t\tstring a(text[tpos].begin() + lpos, text[tpos].end());\n\t\t\ttext[tpos].erase(lpos);\n\t\t\ttext.insert(text.begin() + tpos + 1, a);\n\t\t\ttpos++;\n\t\t\tlpos = 0;\n\t\t}else{\n\t\t\tif(lpos == text[tpos].size()){\n\t\t\t\ttext[tpos] += buffer;\n\t\t\t\tlpos = text[tpos].size();\n\t\t\t}else{\n\t\t\t\ttext[tpos].insert(text[tpos].begin() + lpos + 1, buffer.begin(), buffer.end());\n\t\t\t\tlpos += buffer.size();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid output(const vector<string> &text){\n\trep(i, (int)text.size()) cout << text[i] << endl;\n}\n\nint main(){\n\tstring line;\n\tvector<string> text;\n\tstring buffer;\n\twhile(cin >> line && line != \"END_OF_TEXT\"){\n\t\ttext.push_back(line);\n\t}\n\tchar command;\n\twhile(cin >> command && command != '-'){\n\t\tswitch(command){\n\t\tcase 'a':\n\t\t\tdo_a(text);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tdo_e(text);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tdo_p(text);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tdo_n(text);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tdo_f(text);\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tdo_b(text);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdo_d(text);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tdo_k(text, buffer);\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tdo_y(text, buffer);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t\t//output(text);\n\t\t//cout << tpos << \" \" << lpos << endl;\n\t}\n\toutput(text);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY = 0;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n\telse return;\n}\n\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\";\n\t\tbuf.append(\"\\n\");\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring front=\"\";\n\t\tstring rear=\"\";\n\t\tfront = lines[posY].substr(0,posX);\n\t\trear = lines[posY].substr(posX,lines[posY].size()-posX);\t\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX+1);\n\n\t\tlines[posY] = front;\n\t\tdeque<string>::iterator it = lines.begin();\n\t\tadvance(it,posY);\n\t\tlines.insert(it,rear);\n\t}\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(getline(cin,str)){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(cin >> str){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\tif(str == \"d\") ctrl_d(lines);\n\t\tif(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  vector<string> data;\n  for(string buf;getline(cin,buf),buf!=\"END_OF_TEXT\";)\n    {\n      data.push_back(buf);\n    }\n  int x=0,y=0;\n  string buf=\"\";\n  bool buf_br=false;\n  for(char code;cin>>code,code!='-';)\n    {\n      if(code=='a')\n\ty=0;\n      else if(code=='e')\n\ty=data[x].size();\n      else if(code=='p')\n\t{\n\t  x=max(0,x-1);\n\t  y=0;\n\t}\n      else if(code=='n')\n\t{\n\t  x=min((int)data.size()-1,x+1);\n\t  y=0;\n\t}\n      else if(code=='f')\n\t{\n\t  if(y<data[x].size())\n\t    y++;\n\t  else if(y==data[x].size() &&x<data.size()-1)\n\t    {\n\t      x++;\n\t      y=0;\n\t    }\n\t}\n      else if(code=='b')\n\t{\n\t  if(y>0)\n\t    y--;\n\t  else if(y==0 &&x>0)\n\t    {\n\t      x--;\n\t      y=data[x].size();\n\t    }\n\t}\n      else if(code=='d')\n\t{\n\t  if(y<data[x].size())\n\t    data[x].erase(y,1);\n\t  else if(y==data[x].size() && x<data.size()-1)\n\t    {\n\t      data[x]+=data[x+1];\n\t      data.erase(data.begin()+x+1);\n\t    }\n\t}\n      else if(code=='k')\n\t{\n\t  if(y==data[x].size())\n\t    {\n\t      if(x<data.size()-1)\n\t\t{\n\t\t  data[x]+=data[x+1];\n\t\t  data.erase(data.begin()+x+1);\n\t\t  buf=\"\\n\";\n\t\t  buf_br=true;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      buf=data[x].substr(y,data[x].size()-y);\n\t      buf_br=false;\n\t      data[x].erase(y,data[x].size()-y);\n\t    }\t \n\t}\n      else if(code=='y')\n\t{\n\t  if(buf==\"\")\n\t    continue;\n\t  if(buf!=\"\" && buf_br)\n\t    {\n\t      string tmp=data[x].substr(y,data[x].size()-y);\n\t      data[x].erase(y,data[x].size()-y);\n\t      data.insert(data.begin()+x+1,tmp);\n\t      x++;\n\t      y=0;\n\t    }\n\t  else  if(buf!=\"\" && !buf_br)\n\t    {\n\t      data[x]=data[x].substr(0,y)+buf+data[x].substr(y,data[x].size()-y);\n\t      y+=buf.size();\n\t    }\n\t}    \n      /*  \n      cout<<\"x,y=\"<<x<<\",\"<<y<<endl;\n      for(int i=0;i<data.size();i++)\n\tcout<<data[i]<<endl;\n      */\n    }\n  \n  for(int i=0;i<data.size();i++)\n      cout<<data[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[128];\nstring buf;\nint lines;\nvoid delete_line(int y)\n{\n    for (int i = y; y < lines; ++y)\n\ts[i] = s[i + 1];\n    s[--lines] = \"\";\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; --i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    while (true)\n    {\n\tstring t;\n\tgetline(cin, t);\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines++] = t;\n    }\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    y = max(0, --y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    y = min(lines - 1, ++y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y + 1 != lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t    {\n\t\t--y;\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t\ts[y].erase(x, 1);\n\t    else if (y + 1 != lines)\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t    }\n\t    break;\n\t}\n\tcase 'k':\n\t{\n\t    if (x != s[y].size())\n\t    {\n\t\tbuf = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = s[y].size();\n\t    }\n\t    else if (y + 1 != lines)\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\ts[y + 1] = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = 0, ++y;\n\t    }\n\t    else\n\t\ts[y] += buf;\n\t    break;\n\t}\n\t}\n    }\n\n    for (int i = 0; i < lines; ++i)\n\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst ll INF = 1LL << 50;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nsize_t tpos;\nsize_t lpos;\n\nvoid do_a(const vector<string> &text){\n\tlpos = 0;\n}\n\nvoid do_e(const vector<string> &text){\n\tlpos = text[tpos].size();\n}\n\nvoid do_p(const vector<string> &text){\n\tlpos = 0;\n\ttpos = max(0, (int)tpos - 1);\n}\n\nvoid do_n(const vector<string> &text){\n\tlpos = 0;\n\ttpos = min((int)tpos + 1, (int)text.size() - 1);\n}\n\nvoid do_f(const vector<string> &text){\n\tif(lpos == text[tpos].size()){\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\tlpos = 0;\n\t\t\ttpos++;\n\t\t}\n\t}else{\n\t\tlpos++;\n\t}\n}\n\nvoid do_b(const vector<string> &text){\n\tif(lpos != 0){\n\t\tlpos--;\n\t}else{\n\t\tif(tpos > 0){\n\t\t\ttpos--;\n\t\t\tlpos = text[tpos].size();\n\t\t}\n\t}\n}\n\nvoid do_d(vector<string> &text){\n\tif(lpos != text[tpos].size()){\n\t\ttext[tpos].erase(lpos, 1);\n\t}else{\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\ttext[tpos]+=text[tpos+1];\n\t\t\ttext.erase(text.begin() + tpos+1);\n\t\t}\n\t}\n}\n\nvoid do_k(vector<string> &text, string &buffer){\n\tif(lpos == text[tpos].size()){\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\tbuffer = \"\\n\";\n\t\t\tdo_d(text);\n\t\t}\n\t}else{\n\t\tbuffer = string(text[tpos].begin() + lpos, text[tpos].end());\n\t\ttext[tpos].erase(text[tpos].begin() + lpos, text[tpos].end());\n\t}else{\n\t\tbuffer = \"\\n\";\n\t}\n}\n\nvoid do_y(vector<string> &text, string &buffer){\n\tif(buffer != \"\"){\n\t\tif(buffer == \"\\n\"){\n\t\t\tstring a(text[tpos].begin() + lpos, text[tpos].end());\n\t\t\ttext[tpos].erase(lpos);\n\t\t\ttext.insert(text.begin() + tpos + 1, a);\n\t\t\ttpos++;\n\t\t\tlpos = 0;\n\t\t}else{\n\t\t\tif(lpos == text[tpos].size()){\n\t\t\t\ttext[tpos] += buffer;\n\t\t\t\tlpos = text[tpos].size();\n\t\t\t}else{\n\t\t\t\ttext[tpos].insert(text[tpos].begin() + lpos, buffer.begin(), buffer.end());\n\t\t\t\tlpos += buffer.size();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid output(const vector<string> &text){\n\trep(i, (int)text.size()) cout << text[i] << endl;\n}\n\nint main(){\n\tstring line;\n\tvector<string> text;\n\tstring buffer;\n\twhile(cin >> line && line != \"END_OF_TEXT\"){\n\t\ttext.push_back(line);\n\t}\n\ttpos = lpos = 0;\n\tchar command;\n\twhile(cin >> command && command != '-'){\n\t\tswitch(command){\n\t\tcase 'a':\n\t\t\tdo_a(text);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tdo_e(text);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tdo_p(text);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tdo_n(text);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tdo_f(text);\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tdo_b(text);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdo_d(text);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tdo_k(text, buffer);\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tdo_y(text, buffer);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t\t//output(text);\n\t\t//cout << tpos << \" \" << lpos << endl;\n\t}\n\toutput(text);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nint main(){\n\n\tstring str;\n\tstring tmp;\n\tbool f=false;\n\twhile(cin>>tmp&&tmp!=\"END_OF_TEXT\"){\n\t\tf=true;\n\t\tstr+=tmp;\n\t\tstr+='\\n';\n\t}\n\tchar cmd;\n\tint cur=0;\n\n\tstring buff;\n\twhile(cin>>cmd&&cmd!='-'){\n\t\tif(cmd=='a'){\n\t\t\twhile(1){\n\t\t\t\tif(cur==0)\n\t\t\t\t\tbreak;\n\t\t\t\telse if(str[cur-1]=='\\n'){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur--;\n\t\t\t}\n\t\t}\n\t\telse if(cmd=='e'){\n\t\t\twhile(1){\n\t\t\t\tif(str[cur]=='\\n'){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur++;\n\t\t\t}\n\t\t}\n\t\telse if(cmd=='p'){\n\t\t\tint cnt=0;\n\t\t\twhile(1){\n\t\t\t\tif(cur==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(cur==str.size()-1){\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if(str[cur]=='\\n'){\n\t\t\t\t\tif(cnt==0)\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\telse{\n\t\t\t\t\t\tcur--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur--;\n\t\t\t}\n\t\t}\n\t\telse if(cmd=='n'){\n\t\t\tint cnt=0;\n\t\t\twhile(1){\n\t\t\t\tif(cur==str.size()-1){\n\t\t\t\t\twhile(1){\n\t\t\t\t\t\tif(cur==0||str[cur-1]=='\\n'){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(str[cur]=='\\n'){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcur--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(cmd=='f'){\n\t\t\tif(cur!=str.size()-1){\n\t\t\t\tcur++;\n\t\t\t}\n\t\t}\n\t\telse if(cmd=='b'){\n\t\t\tif(cur!=0){\n\t\t\t\tcur--;\n\t\t\t}\n\t\t}\n\t\telse if(cmd=='d'){\n\t\t\tif(cur==str.size()-1){\n\n\t\t\t}\n\t\t\telse\n\t\t\t\tstr = str.substr(0,cur) + str.substr(cur+1);\n\t\t}\n\t\telse if(cmd=='k'){\n\t\t\tif(str.size()-1==cur){\n\t\t\t\t\n\t\t\t}\n\t\t\telse if(str[cur]=='\\n'){\n\t\t\t\tstr = str.substr(0,cur) + str.substr(cur+1);\n\t\t\t\tbuff=\"\\n\";\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint prv=cur;\n\t\t\t\tint nxt=prv;\n\t\t\t\twhile(1){\n\t\t\t\t\tif(str[nxt]=='\\n'){\n\t\t\t\t\t\tbuff=str.substr(prv,nxt-prv);\n\t\t\t\t\t\tstr=str.substr(0,prv)+str.substr(nxt);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnxt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(cmd=='y'){\n\t\t\tif(buff!=\"\"){\n\t\t\t\tif(buff==\"\\n\"){\n\t\t\t\t\tstr=str.substr(0,cur)+\"\\n\"+str.substr(cur);\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstr=str.substr(0,cur)+buff+str.substr(cur);\n\t\t\t\t\tcur+=buff.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout<<str;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t,u;\nvector<char> tmp;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nvoid yinsert(int,vector<char>);\nvoid xinsert(int,int,char);\nvoid ydelete(int);\nvoid xdelete(int,int);\n\nint main(){\n\n  t.clear();\n  tmp.clear();\n  input();\n  x=y=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n    //cout<<y<<' '<<x<<\" ty\"<<t.size()<<endl;\n  }\n\n  for(int i=0;i<t.size();i++){\n    for(int j=0;j<t[i].size();j++){\n      cout<<t[i][j];\n    }\n  }\n\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    xdelete(y,x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  xdelete(y,x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  ydelete(y+1);\n}\n\nvoid funcK(){\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.clear();\n      tmp.push_back('\\n');\n    }\n    return;\n  }\n  tmp.clear();\n  while(t[y][x]!='\\n'){\n    tmp.push_back(t[y][x]);\n    xdelete(y,x);\n  }\n  reverse(tmp.begin(),tmp.end());\n}\n\nvoid funcY(){\n  vector<char> z;\n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    while(t[y][x]!='\\n'){\n      z.push_back(t[y][x]);\n      xdelete(y,x);\n    }\n    yinsert(y+1,z);\n    y++;\n    x=0;\n    return;\n  }\n  for(int i=0;i<(int)tmp.size();i++){\n    xinsert(y,x,tmp[i]);\n  }\n  x+=tmp.size();\n  //funcE();\n}\n\nvoid input(){\n  vector<char> a;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\nint main(){\n  vector<string> vp;\n  string tmp;\n  while(cin>>tmp,tmp!=\"END_OF_TEXT\")\n\tvp.push_back(tmp+' ');\n  \n  char c;\n  string buf;\n  int row=0,col=0;\n  while(cin>>c,c!='-'){\n\tif(c=='a') col=0;\n\tif(c=='e') col=vp[row].size()-1;\n\tif(c=='p'){\n\t  col=0;\n\t  row = max(row-1,0);\n\t}\n\tif(c=='n'){\n\t  col=0;\n\t  row = min(row+1,(int)vp.size()-1);\n\t}\n\tif(c=='f'){\n\t  if(col==vp[row].size()-1){\n\t\tcol=(row==vp.size()-1?col:0);\n\t\trow = max(row+1,(int)vp.size()-1);\n\t  }else\n\t\tcol++;\n\t}\n\tif(c=='b'){\n\t  if(col==0){\n\t\tcol=(row==0?col:0);\n\t\trow = min(row-1,0);\n\t  }else\n\t\tcol--;\n\t}\n\tif(c=='d'){\n\t  if(col==vp[row].size()-1&&row<vp.size()-1){\n\t\tvp[row] = vp[row].substr(0,vp[row].size()-2);\n\t\tvp[row] += vp[row+1]+\" \";\n\t  }else if(row<vp.size()-1){\n\t\tvp[row] = vp[row].substr(0,col)+vp[row].substr(col+1);\n\t  }\n\t}\n\tif(c=='k'){\n\t  if(col==vp[row].size()-1&&row<vp.size()-1){\n\t\tvp[row] = vp[row].substr(0,col)+vp[row].substr(col+1);\n\t\tbuf = \" \";\n\t  }\n\t  if(col<vp[row].size()-1){\n\t\tbuf = vp[row].substr(col);\n\t\tvp[row] = vp[row].substr(0,col) + \" \";\n\t\tcol = vp[row].size()-1;\n\t  }\n\t}\n\tif(c=='y'&&buf.size()>0){\n\t  if(buf==\" \"){\n\t\tvector<string>::iterator it = vp.begin() + row;\n\t\tvp.insert(it,vp[row].substr(col+1));\n\t\tvp[row] = vp[row].substr(0,col) + \" \";\n\t  }else{\n\t\tbuf = buf.substr(0,buf.size()-1);\n\t\tvp[row] = vp[row].substr(0,col) + buf + vp[row].substr(col);\n\t\tcol += buf.size();\n\t\tbuf += \" \";\n\t  }\n\t}\n\t/*\n\tcout << c << \":\" << row << \" \" << col << endl;\n\tfor(int i=0;i<vp.size();++i){\n\t  cout << vp[i] << endl;\n\t}\n\t*/\n  }\n  for(int i=0;i<vp.size();++i){\n\tcout << vp[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvoid escape(string &s)\n{\n  if (s.find_first_of(\"\\n\") != string::npos)\n    s.erase(s.end()-1);\n  if (s.find_first_of(\"\\r\") != string::npos)\n    s.erase(s.end()-1);\n}\n\nint main()\n{\n  string s;\n  vector<string> line;\n  while (getline(cin, s)) {\n    escape(s);\n    if (s == \"END_OF_TEXT\")\n      break;\n    line.push_back(s);\n  }\n\n  int x = 0, y = 0;\n  string buffer = \"\";\n  while (cin >> s) {\n    if (s == \"-\")\n      break;\n\n    if (s == \"a\") {\n      x = 0;\n    } else if (s == \"e\") {\n      x = line[y].size();\n    } else if (s == \"p\") {\n      x = 0;\n      if (y > 0)\n\t--y;\n    } else if (s == \"n\") {\n      x = 0;\n      if (y != line.size()-1)\n\t++y;\n    } else if (s == \"f\") {\n      if (x < line[y].size()) {\n\t  ++x;\n      } else if (y != line.size()-1) {\n\tx = 0;\n\t++y;\n      }\n    } else if (s == \"b\") {\n      if (x > 0) {\n\t--x;\n      } else if (y > 0) {\n\tx = 0;\n\t--y;\n      }\n    } else if (s == \"d\") {\n      if (x < line[y].size()) {\n\tline[y].erase(x, 1);\n      } else if (y != line.size()-1) {\n\tline[y] += line[y+1];\n\tline.erase(line.begin()+y+1);\n      }\n    } else if (s == \"k\") {\n      if (x >= line[y].size() && y != line.size()-1) {\n\tline[y] += line[y+1];\n\tline.erase(line.begin()+y+1);\n\tbuffer = \"\\n\";\n      } else if (x < line[y].size()) {\n\tbuffer = line[y].substr(x);\n\tline[y].erase(x);\n      }\n    } else if (s == \"y\" && buffer != \"\") {\n      if (buffer == \"\\n\") {\n\ts = line[y].substr(x);\n\tline[y].erase(x);\n\tline.insert(line.begin()+y+1, s);\n\tx = 0;\n\t++y;\n      } else {\n\tline[y].insert(x, buffer);\n\tx += buffer.size();\n      }\n    }\n  }\n  \n  for (unsigned int i = 0; i < line.size(); ++i)\n    cout << line[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\n\nint main()\n{\t\t\n\tvector<string> snt;\n\tstring buffer;\n\t\n\t\n\tfor(string line; getline(cin, line) && line != \"END_OF_TEXT\";snt.push_back(line));\n\t\n\tpint cur = mp(0, 0); // := first = x, second = y\n\tfor(char com; cin >> com && com != '-';)\n\t{\n\t\tswitch(com)\n\t\t{\n\t\t\t\t/*\n\t\t\t\t a\n\t\t\t\t J[\\ð»ÝÌsÌæª¶ÉÚ®·éB\n\t\t\t\t */\n\t\t\tcase 'a':\n\t\t\t{\n\t\t\t\tcur.first = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t e\n\t\t\t\t J[\\ð»ÝÌsÌsÉÚ®·éB\n\t\t\t\t */\n\t\t\tcase 'e':\n\t\t\t{\n\t\t\t\tcur.first = snt[cur.second].size();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t p\n\t\t\t\t ãÉsª êÎAJ[\\ðãÌsÌæª¶ÉÚ®·éB\n\t\t\t\t ãÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t\t */\n\t\t\tcase 'p':\n\t\t\t{\n\t\t\t\tcur.second -= cur.second != 0;\n\t\t\t\tcur.first = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t n\n\t\t\t\t ºÉsª êÎAJ[\\ðºÌsÌæª¶ÉÚ®·éB\n\t\t\t\t ºÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t\t */\n\t\t\tcase 'n':\n\t\t\t{\n\t\t\t\tcur.second += cur.second + 1 != snt.size();\n\t\t\t\tcur.first = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t f\n\t\t\t\t J[\\ªsÉÈ¢êAJ[\\ðPÂEÉÚ®·éB\n\t\t\t\t J[\\ªsÉ è©ÂºÉsª éêÍAJ[\\ðºÌsÌæª¶ÖÚ®·éB\n\t\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t\t */\n\t\t\tcase 'f':\n\t\t\t{\n\t\t\t\tif(cur.first != snt[cur.second].size())\n\t\t\t\t{\n\t\t\t\t\tcur.first++;\n\t\t\t\t}\n\t\t\t\telse if(cur.second + 1 != snt.size())\n\t\t\t\t{\n\t\t\t\t\tcur.first = 0;\n\t\t\t\t\tcur.second++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t b\n\t\t\t\t J[\\ªæª¶ÅÈ¢ÈçÎAJ[\\ðPÂ¶ÉÚ®·éB\n\t\t\t\t J[\\ªæª¶Å è©ÂãÉsª éêÍAJ[\\ðãÌsÌsÖÚ®·éB\n\t\t\t\t »êÈOÌêÍ½àµÈ¢\n\t\t\t\t */\n\t\t\tcase 'b':\n\t\t\t{\n\t\t\t\tif(cur.first != 0)\n\t\t\t\t{\n\t\t\t\t\tcur.first--;\n\t\t\t\t}\n\t\t\t\telse if(cur.second != 0)\n\t\t\t\t{\n\t\t\t\t\tcur.second--;\n\t\t\t\t\tcur.first = snt[cur.second].size();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t d\n\t\t\t\t J[\\ª¶ðw·êÍ»Ì¶ðí·éBí³ê½¶ÌE¤Ì¶ñÍ¶ÉVtg³êéB\n\t\t\t\t J[\\ªsðwµºÉsª éêÍAºÌsð»ÌÜÜJ[\\ÌÊuÉq°éBÈºÌsÍãÉVtg³êéB\n\t\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t\t */\n\t\t\tcase 'd':\n\t\t\t{\n\t\t\t\tif(cur.first != snt[cur.second].size())\n\t\t\t\t{\n\t\t\t\t\tstring &line = snt[cur.second];\n\t\t\t\t\t\n\t\t\t\t\tline = line.substr(0, cur.first) + line.substr(cur.first + 1);\n\t\t\t\t}\n\t\t\t\telse if(cur.second + 1 != snt.size())\n\t\t\t\t{\n\t\t\t\t\tsnt[cur.second] += snt[cur.second + 1];\n\t\t\t\t\t\n\t\t\t\t\trotate(snt.begin() + cur.second + 1, snt.begin() + cur.second + 2, snt.end());\n\t\t\t\t\t\n\t\t\t\t\tsnt.erase(snt.begin() + snt.size() - 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t k\n\t\t\t\t J[\\ªsÉ éêAºÉsª êÎAd Æ¯¶ìðµobt@ÉPÂÌüsðL^·éB\n\t\t\t\t J[\\ªsÉÈ¢êAJ[\\ªw·¶ðÜß½E¤·×ÄÌ¶ðØèæè»êðobt@ÉL^·éBJ[\\Í³ÌsÌsðw·æ¤ÉÈéBSÄÌL^É¨¢Äobt@Íã«³êéB\n\t\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t\t */\n\t\t\tcase 'k':\n\t\t\t{\n\t\t\t\tif(cur.first + 1 == snt[cur.second].size())\n\t\t\t\t{\n\t\t\t\t\tif(cur.first != snt[cur.second].size())\n\t\t\t\t\t{\n\t\t\t\t\t\tstring &line = snt[cur.second];\n\t\t\t\t\t\t\n\t\t\t\t\t\tline = line.substr(0, cur.first) + line.substr(cur.first + 1);\n\t\t\t\t\t}\n\t\t\t\t\telse if(cur.second + 1 != snt.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tsnt[cur.second] += snt[cur.second + 1];\n\n\t\t\t\t\t\trotate(snt.begin() + cur.second + 1, snt.begin() + cur.second + 2, snt.end());\n\t\t\t\t\t\t\n\t\t\t\t\t\tsnt.erase(snt.begin() + snt.size() - 1);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbuffer = snt[cur.second].substr(cur.first);\n\t\t\t\t\tsnt[cur.second] = snt[cur.second].substr(0, cur.first);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t y\n\t\t\t\t obt@ªóÌêÍÈÉàµÈ¢B\n\t\t\t\t obt@ÌàeªüsÌêAJ[\\ªw·¶Ì¼OÅüsðs¤BJ[\\ÍVµ¢sÌæª¶ÖÚ®·éB\n\t\t\t\t obt@Ìàeª¶ñÌêAJ[\\ÌÊuÉobt@Ìàeð}ü·éB J[\\ÌÊuÍàÆàÆwµÄ¢½¶Ü½ÍsÌêÖÚ®·é\n\t\t\t\t */\n\t\t\tcase 'y':\n\t\t\t{\n\t\t\t\tif(buffer != \"\")\n\t\t\t\t{\n\t\t\t\t\tif(buffer == \"\\n\")\n\t\t\t\t\t{\n\t\t\t\t\t\tstring &line = snt[cur.second];\n\t\t\t\t\t\tsnt.push_back(snt[snt.size() - 1]);\n\t\t\t\t\t\t\n\t\t\t\t\t\trotate(snt.begin() + cur.second + 1, snt.begin() + snt.size() - 2, snt.begin() + snt.size() - 1);\n\t\t\t\t\t\tsnt[cur.second + 1] = line.substr(cur.first);\n\t\t\t\t\t\tline = line.substr(0, cur.first);\n\t\t\t\t\t\t\n\t\t\t\t\t\tcur.second++;\n\t\t\t\t\t\tcur.first = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tstring &line = snt[cur.second];\n\t\t\t\t\t\tline = line.substr(0, cur.first) + buffer + line.substr(cur.first);\n\t\t\t\t\t\t\n\t\t\t\t\t\tcur.first += buffer.size();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\trep(i, snt.size()) cout << snt[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nstring txt[101]={},bf;\nint kx,ky,x;\n\nvoid A(){kx=0;}\nvoid E(){kx=txt[ky].size();}\nvoid P(){\n\tif(ky)ky--;\n\tA();\n}\nvoid N(){\n\tif(x-1!=ky)ky++;\n\tA();\n}\nvoid F(){\n\tif(kx!=txt[ky].size())kx++;\n\telse if(kx==txt[ky].size()&&x-1!=ky)N();\n}\nvoid B(){\n\tif(kx)kx--;\n\telse if(!kx&&ky){\n\t\tky--;\n\t\tE();\n\t}\n}\nvoid D(){\n\tif(kx!=txt[ky].size()){\n\t\ttxt[ky]=txt[ky].substr(0,kx)+txt[ky].substr(kx+1);\n\t}\n\telse if(kx==txt[ky].size()&&ky!=x-1){\n\t\ttxt[ky]+=txt[ky+1];\n\t\tfor(int i=ky+1;i<x;i++)txt[i]=txt[i+1];\n\t\ttxt[x]=\"\";\n\t\tx--;\n\t}\n}\nvoid K(){\n\tif(kx==txt[ky].size()&&x-1!=ky){\n\t\tD();\n\t\tbf=\"\\n\";\n\t}\n\telse if(kx!=txt[ky].size()){\n\t\tbf=txt[ky].substr(kx);\n\t\ttxt[ky]=txt[ky].substr(0,kx);\n\t}\n}\nvoid Y(){\n\tif(bf==\"\\n\"){\n\t\t//txt[ky+1]=txt[ky].substr(kx)+txt[ky+1];\n\t\t//txt[ky]=txt[ky].substr(0,kx);\n\t\t//if(ky+1==x)x++;\n\t\tstring next = txt[ky].substr(kx);\n\t\ttxt[ky]=txt[ky].substr(0,kx);\n\t\tx++;\n\t\tfor(int i = x - 1; i >= ky + 2; i--)\n\t\t\ttxt[ky + 2] = txt[ky + 1];\n\t\ttxt[ky + 1] = next;\n\t\tN();\n\t}\n\telse if(bf!=\"\"){\n\t\ttxt[ky]=txt[ky].substr(0,kx)+bf+txt[ky].substr(kx);\n\t\tkx+=bf.size();\n\t}\n}\n\nint main(){\n\tstring s;\n\tkx=ky=x=0; bf=\"\";\n\twhile(getline(cin,s),s!=\"END_OF_TEXT\")txt[x++]=s;\n\twhile(cin>>s,s!=\"-\"){\n\t\tif(s==\"a\")A();\n\t\tif(s==\"e\")E();\n\t\tif(s==\"p\")P();\n\t\tif(s==\"n\")N();\n\t\tif(s==\"f\")F();\n\t\tif(s==\"b\")B();\n\t\tif(s==\"d\")D();\n\t\tif(s==\"k\")K();\n\t\tif(s==\"y\")Y();\n#if 0\n\t\tcerr << \"ROW: \" << ky << \"COL: \" << kx << endl;\n\t\tfor(int i = 0; i < x; i++) cerr << txt[i] << endl;\n#endif\n\t}\n\tfor(int i=0;i<x;i++)cout<<txt[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring buffer[500];\nstring killbuff;\nint lcnt,cury,curx;\n\nvoid exec_command(string com) {\n    if(com == \"a\") curx = 0;\n    else if(com == \"e\") curx = buffer[cury].length()-1;\n    else if(com == \"p\") {\n        curx = 0;\n        if(cury > 0) cury--;\n    }else if(com == \"n\") {\n        curx = 0;\n        if(cury < lcnt-1) cury++;\n    }else if(com == \"f\") {\n        if(buffer[cury][curx] != '$') curx++;\n        else if(cury < lcnt-1) { curx = 0, cury++; }\n    }else if(com == \"b\") {\n        if(curx > 0) curx--;\n        else if(cury > 0) curx = buffer[--cury].length()-1;\n    }else if(com == \"d\") {\n        if(buffer[cury][curx] == '$' && cury < lcnt-1) {\n            buffer[cury] = buffer[cury].substr(0,buffer[cury].length()-1)\n                + buffer[cury+1];\n            for(int i=cury+1; i<lcnt-1; ++i) buffer[i] = buffer[i+1];\n            lcnt--;\n        }else if(buffer[cury][curx] != '$') {\n            buffer[cury] = buffer[cury].substr(0,curx)\n                + buffer[cury].substr(curx+1);\n        }\n    }else if(com == \"k\") {\n        if(buffer[cury][curx] == '$' && cury < lcnt-2) {\n            buffer[cury] = buffer[cury].substr(0,buffer[cury].length()-1)\n                + buffer[cury+1];\n            for(int i=cury+1; i<lcnt; ++i) buffer[i] = buffer[i+1];\n            lcnt--;\n            killbuff = \"$\";\n        }else if(buffer[cury][curx] == '$' && cury == lcnt-1) {\n            ;\n        }else if(buffer[cury][curx] != '$') {\n            killbuff = buffer[cury].substr(curx);\n            killbuff = killbuff.substr(0, killbuff.length()-1);\n            buffer[cury] = buffer[cury].substr(0,curx) + \"$\";\n        }\n    }else if(com == \"y\") {\n        if(killbuff != \"\") {\n            if(killbuff == \"$\") {\n                string tmp = buffer[cury].substr(curx);\n                buffer[cury] = buffer[cury].substr(0,curx) + \"$\";\n                for(int i=cury+1; i<lcnt; ++i) {\n                    string tt = buffer[i];\n                    buffer[i] = tmp;\n                    tmp = tt;\n                }\n                buffer[lcnt++] = tmp;\n            }else{\n                buffer[cury] = buffer[cury].substr(0,curx) + killbuff\n                    + buffer[cury].substr(curx);\n                curx += killbuff.length();\n            }\n        }\n    }\n}\n\nvoid print_buff() {\n    cout<<\"-----------------\"<<endl;\n    for(int i=0; i<lcnt-1; ++i)\n        cout<<buffer[i]<<endl;\n\n    cout<<\"killbuffer : \"<<killbuff<<endl;\n    cout<<\"-----------------\"<<endl;\n}\n\nint main() {\n    lcnt = cury = curx = 0;\n    killbuff = \"\";\n    string s;\n\n    while(getline(cin, s)) {\n        if(s == \"END_OF_TEXT\") {\n            buffer[lcnt++] = \"%\";\n            break;\n        }\n        s += \"$\";\n        buffer[lcnt++] = s;\n    }\n\n    while(cin>>s) {\n        if(s == \"-\") break;\n        exec_command(s);\n        // cout<<\"command : \"<<s<<\" at \"<<cury<<\" , \"<<curx<<endl;\n        // print_buff();\n    }\n\n    for(int i=0; i<lcnt-1; ++i)\n        cout<<buffer[i].substr(0, buffer[i].length()-1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass state{\npublic:\n  state(string str = \"\"):str(str){\n    cursor = 0;\n    buffer = \"\";\n    assertion();\n  }\n\n  void typeA(){\n    for(int i=cursor;i>=0;i--){\n      cursor = i;\n      if(i > 0 && str[i-1] == '\\n') break;\n    }\n    assertion();\n  }\n\n  void typeE(){\n    for(int i=cursor;i<str.size();i++){\n      cursor = i;\n      if(str[i] == '\\n') break;\n    }\n    assertion();\n  }\n\n  void typeP(){\n    bool isUpper = false;\n    for(int i=cursor;i>=0;i--){\n      if(i == 0 || i > 0 && str[i-1] == '\\n'){\n        cursor = i;\n        if(isUpper) break;\n        else isUpper = true;\n      }\n    }\n    assertion();\n  }\n\n  void typeN(){\n    bool isDowner = false;\n    for(int i=cursor;i<str.size();i++){\n      if(str[i] == '\\n' && i < (int)str.size() - 1){\n        isDowner = true;\n        cursor = i + 1;\n        break;\n      }\n    }\n\n    if(!isDowner){\n      typeA();\n    }\n    assertion();\n  }\n\n  void typeF(){\n    if(cursor < (int)str.size()-1){\n      cursor++;\n    }\n    assertion();\n  }\n  \n  void typeB(){\n    if(cursor > 0) {\n      cursor--;\n    }\n    assertion();\n  }\n\n  void typeD(){\n    if(cursor < (int)str.size()-1){\n      str.erase(str.begin()+cursor);\n    }\n    assertion();\n  }\n\n  void typeK(){\n    if(str[cursor] == '\\n' && cursor < (int)str.size()-1){\n      typeD();\n      buffer = \"\\n\";\n    } else if(str[cursor] != '\\n'){\n      for(int i=cursor;i<(int)str.size();i++){\n        if(str[i] == '\\n'){\n          buffer = string(str.begin()+cursor, str.begin()+i);\n          str.erase(str.begin()+cursor, str.begin()+i);\n        }\n      }\n    }\n    assertion();\n  }\n\n  void typeY(){\n    str.insert(str.begin()+cursor, buffer.begin(), buffer.end());\n    cursor += buffer.size();\n    //buffer = \"\";\n    assertion();\n  }\n\n  string toString(){\n    return str;\n  }\n\n  void assertion(){\n    assert(str.size() > 0 && str[str.size()-1] == '\\n');\n  }\n\nprivate:\n  int cursor;\n  string str, buffer;\n};\n\nstring inputStr(){\n  string str = \"\", in;\n  while(cin >> in){\n    if(in == \"END_OF_TEXT\") break;\n    str += in + '\\n';\n  }\n  return str;\n}\n\nvoid executeCommand(state &dat){\n  string command;\n  while(cin >> command){\n    if(command == \"-\") break;\n    else if(command == \"a\") dat.typeA();\n    else if(command == \"e\") dat.typeE();\n    else if(command == \"p\") dat.typeP();\n    else if(command == \"n\") dat.typeN();\n    else if(command == \"f\") dat.typeF();\n    else if(command == \"b\") dat.typeB();\n    else if(command == \"d\") dat.typeD();\n    else if(command == \"k\") dat.typeK();\n    else if(command == \"y\") dat.typeY();\n  }\n  cout << dat.toString() << flush;\n}\n\nint main(){\n  state dat = state(inputStr());\n  executeCommand(dat);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY--;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n\telse return;\n}\n\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\\n\";\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring front=\"\";\n\t\tstring rear=\"\";\n\t\tfront = lines[posY].substr(0,posX);\n\t\trear = lines[posY].substr(posX,lines[posY].size()-posX);\t\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX);\n\n\t\tlines[posY] = front;\n\t\t//deque<string>::iterator it = lines.begin();\n\t\t//advance(it,posY);\n\t\tdeque<string> res;\n\n\t\tfor(int i=0;i<posY;i++){\n\t\t\tres.push_back(lines[i]);\n\t\t}\n\n\t\tres.push_back(lines[posY]);\n\t\tres.push_back(rear);\n\t\t\n\n\t\tfor(int i=posY+1;i<lines.size();i++){\n\t\t\tres.push_back(lines[i]);\n\t\t}\n\t\t\n\t\tlines = res;\n\t\tposY++;\n\t\tposX=0;\n\t\t//lines.insert(lines.begin()+posY,rear);\n\t\t//lines.insert(it,rear);\n\t}\n\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(getline(cin,str)){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(cin >> str){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\tif(str == \"d\") ctrl_d(lines);\n\t\tif(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvoid doA(int *l, int *c, string &s, string &b, vector<string> &v) {\n  *c = 0;\n}\n\nvoid doE(int *l, int *c, string &s, string &b, vector<string> &v) {\n  *c = s.size();\n}\n\nvoid doP(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*l > 0)\n    *l -= 1;\n  *c = 0;\n}\n\nvoid doN(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*l < v.size()-1)\n    *l += 1;\n  *c = 0;\n}\n\nvoid doF(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c < s.size()) {\n    *c += 1;\n  } else if (*l < v.size()-1){\n    *l += 1;\n    *c = 0;\n  }\n}\n\nvoid doB(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c > 0) {\n    *c -= 1;\n  } else if (*l > 0) {\n    *l -= 1;\n    *c = s.size();\n  }\n}\n\nvoid doD(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c < s.size()) {\n    s.erase(*c, 1);\n  } else if (*l < v.size()-1) {\n    s.append(v[*l+1]);\n    vector<string>::iterator itr = v.begin() + *l + 1;\n    v.erase(itr);\n  }\n}\n\nvoid doK(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c == s.size() && *l < v.size()-1) {\n    doD(l, c, s, b, v);\n    b = \"\\n\";\n  } else if (*c < s.size()) {\n    b = s.substr(*c, s.size() - *c);\n    s.erase(*c, s.size() - *c);\n    *c = s.size();\n  }\n}\n\nvoid doY(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (b.empty()) {\n    return;\n  } else if (b == \"\\n\") {\n    doK(l, c, s, b, v);\n    vector<string>::iterator itr = v.begin() + *l + 1;\n    v.insert(itr, b);\n  } else {\n    s.insert(*c, b);\n  }\n}\n\nint main(int argc, char *argv[]) {\n  string buf;\n  vector<string> strs;\n  while (true) {\n    string s;\n    getline(cin, s);\n    if (s == \"END_OF_TEXT\")\n      break;\n    strs.push_back(s);\n  }\n  int line = 0, chrc = 0;\n  while (true) {\n    char c;\n    cin >> c;\n    if (c == '-')\n      break;\n    else if (c == 'a')\n      doA(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'e')\n      doE(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'p')\n      doP(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'n')\n      doN(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'f')\n      doF(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'b')\n      doB(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'd')\n      doD(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'k')\n      doK(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'y')\n      doY(&line, &chrc, strs[line], buf, strs);\n  }\n\n  for (int i = 0; i < strs.size(); i++)\n    cout << strs[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\n// char s[102][1002];\nvector<string> s;\nint R;\n\nvoid input() {\n  string l;\n  int r = 0;\n  while (1) {\n    getline(cin, l);\n    // printf(\"INPUT:%s\\n\", l.c_str());\n    if (l == \"END_OF_TEXT\") {\n      R = r;\n      break;\n    }\n    l += '\\0';\n    s.push_back(l);\n    ++r;\n  }\n}\n\nvoid interpret() {\n  string buf;\n  char op;\n  int ci = 0, cj = 0;\n  // cin.ignore();\n  while (cin >> op, op != '-') {\n    // rep(i,R) {\n    //   printf(\"%s\\n\", s[i].c_str());\n    // }\n    // puts(\"--------------------------------------------------\");\n    // printf(\"[operation : %c | buf : %s]\\n\", op, buf.c_str());\n    switch (op) {\n      case 'a': {\n        // カーソルを現在の行の先頭文字に移動する\n        cj = 0;\n        break;\n      }\n      case 'e': {\n        // カーソルを現在の行の行末に移動する\n        while (s[ci][cj] != '\\0') ++cj;\n        break;\n      }\n      case 'p': {\n        // 上に行があれば、カーソルを上の行の先頭文字に移動する。\n        // 上に行がなければ、カーソルを先頭文字に移動する。\n        if (ci != 0) {\n          --ci; cj = 0;\n        } else {\n          cj = 0;\n        }\n        break;\n      }\n      case 'n': {\n        // 下に行があれば、カーソルを下の行の先頭文字に移動する。\n        // 下に行がなければ、カーソルを先頭文字に移動する。\n        if (ci + 1 < R) {\n          ++ci; cj = 0;\n        } else {\n          cj = 0;\n        }\n        break;\n      }\n      case 'f': {\n        // カーソルが行末にない場合、カーソルを１つ右に移動する \n        // カーソルが行末にありかつ下に行がある場合は、\n        // カーソルを下の行の先頭文字へ移動する \n        // それ以外の場合は何もしない\n        if (s[ci][cj] != '\\0') {\n          ++cj;\n        } else if (s[ci][cj] == '\\0' && ci + 1 < R) {\n          ++ci; cj = 0;\n        }\n        break;\n      }\n      case 'b': {\n        // カーソルが先頭文字でないならば、カーソルを１つ左に移動する。\n        // カーソルが先頭文字でありかつ上に行がある場合は、\n        // カーソルを上の行の行末へ移動する。\n        // それ以外の場合は何もしない。\n        if (cj != 0) {\n          cj = 0;\n        } else if (cj == 0 && ci != 0) {\n          --ci; cj = 0;\n        }\n        break;\n      }\n      case 'd': {\n        // カーソルが文字を指す場合はその文字を削除する。\n        // 削除された文字の右側の文字列は左にシフトされる。\n        // カーソルが行末を指し下に行がある場合は、\n        // 下の行をそのままカーソルの位置に繋げる。以下の行は上にシフトされる。\n        // それ以外の場合は何もしない。\n        if (s[ci][cj] == '\\0' && ci + 1 < R) {\n          s[ci].erase(cj, 1);\n          s[ci] += s[ci+1];\n          s.erase(s.begin() + ci + 1);\n        } else {\n          s[ci].erase(cj, 1);\n        }\n        break;\n      }\n      case 'k': {\n        // カーソルが行末にある場合、下に行があれば、\n        // d と同じ操作をしバッファに１つの改行を記録する。\n        // カーソルが行末にない場合、カーソルが指す文字を含めた\n        // 右側すべての文字を切り取りそれをバッファに記録する。\n        // カーソルは元の行の行末を指すようになる。全ての記録においてバッファは上書きされる。\n        // それ以外の場合は何もしない。(clarification at 14:20)\n        if (s[ci][cj] == '\\0' && ci + 1 < R) {\n          s[ci].erase(cj, 1);\n          s[ci] += s[ci+1];\n          s.erase(s.begin() + ci + 1);\n          buf = \"\\n\";\n        } else  {\n          buf = s[ci].substr(cj);\n          s[ci].erase(cj);\n          s[ci] += '\\0';\n        }\n        break;\n      }\n      case 'y': {\n        // バッファが空の場合はなにもしない。\n        // バッファの内容が改行の場合、カーソルが指す文字の直前で改行を行う。\n        // カーソルは新しい行の先頭文字へ移動する。\n        // バッファの内容が文字列の場合、カーソルの位置にバッファの内容を挿入する。\n        // カーソルの位置はもともと指していた文字または行末の場所へ移動する。 \n        if (buf == \"\") continue;\n        if (buf == \"\\n\") {\n          if (cj == 0) {\n            inserter(s, s.begin() + ci) = string(\"\\0\");\n          } else {\n            inserter(s, s.begin() + ci + 1) = s[ci].substr(cj - 1);\n            s[ci].erase(cj - 1);\n            s[ci] += '\\0';\n            ++ci; cj = 0;\n          }\n        } else {\n          // bool isEnd = s[ci][cj] == '\\0';\n          string tBuf = buf;\n          tBuf.erase(tBuf.size() - 1);\n          s[ci].insert(cj, tBuf.c_str());\n          cj += tBuf.size();\n          // if (isEnd) {\n          // }\n        }\n        break;\n      }\n    }\n  }\n  // puts(\"----------------------------------------\");\n  rep(i,R) {\n    printf(\"%s\\n\", s[i].c_str());\n  }\n}\n\nint main() {\n  input();\n  interpret();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <vector>\n#include <iostream>\n#include <string>\n#include <time.h>\n#include <random>\n#include <functional>\nusing namespace std;\n\nint main() {\n\tlist<string> li;\n\tlist<string>::iterator ite;\n\tstring buffer;\n\tbool bu = false;\n\tint lc = 0;\n\n\twhile (1) {\n\t\tstring s;\n\t\tbool mo = false;\n\t\tgetline(cin, s);\n\t\tif (s == \"END_OF_TEXT\") break;\n\t\tli.push_back(s);\n\t\tite = --li.end();\n\t\tfor (int j = 0; j < (*ite).size(); ++j) {\n\t\t\tif ((*ite)[j] != ' ') {\n\t\t\t\tmo = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 0; j < (*ite).size(); ++j) {\n\t\t\tif ((*ite)[j] != ' ') {\n\t\t\t\tprintf(\"%c\\n\", (*ite)[j]);\n\t\t\t}\n\t\t}\n\t\tif (!mo) { s = \"\"; }\n\t}\n\tite = li.begin(); lc = 0;\n\twhile (1) {\n\t\tchar c;\n\t\tcin >> c;\n\t\tif (c == '-') break;\n\t\tswitch (c) {\n\t\tcase 'a': lc = 0; break;\n\t\tcase 'e': lc = (*ite).size(); break;\n\t\tcase 'p': \n\t\t\tlc = 0; \n\t\t\tif (ite != li.begin()) --ite; break;\n\t\tcase 'n': \n\t\t\tlc = 0;\n\t\t\tif (ite != --li.end()) ++ite; break;\n\t\tcase 'f': \n\t\t\tif ((*ite).size() != lc) ++lc; \n\t\t\telse if((*ite).size() == lc && ite != --li.end()){\n\t\t\t\t++ite; lc = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b': \n\t\t\tif (lc != 0) --lc;\n\t\t\telse if(lc == 0 && ite != --li.begin()){\n\t\t\t\t--ite; \n\t\t\t\tlc = (*ite).size();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd': \n\t\t\tif ((*ite)[lc] != ' ') {\n\t\t\t\t(*ite).erase((*ite).begin() + lc);\n\t\t\t}\n\t\t\telse if ((*ite).size() == lc && ite != --li.end()) {\n\t\t\t\t(*ite) += (*++ite);\n\t\t\t\tli.erase(ite);\n\t\t\t\t--ite;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'k': \n\t\t\tif ((*ite).size() == lc && ite != --li.end()) {\n\t\t\t\t(*ite) += (*++ite);\n\t\t\t\tli.erase(ite);\n\t\t\t\t--ite;\n\t\t\t\tbuffer = \"\"; bu = true;\n\t\t\t\tlc = (*ite).size();\n\t\t\t}\n\t\t\telse if ((*ite).size() != lc){\n\t\t\t\tbuffer = (*ite).substr(lc, (*ite).size());\n\t\t\t\t(*ite).erase(lc, (*ite).size());\n\t\t\t\tbu = true;\n\t\t\t\tlc = (*ite).size();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'y': \n\t\t\tif (bu) {\n\t\t\t\tif (buffer == \"\") {\n\t\t\t\t\tli.insert(ite,(*ite).substr(lc, (*ite).size()));\n\t\t\t\t\tlc = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t(*ite).insert(lc, buffer);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (auto i = li.begin(); i != li.end(); ++i) {\n\t\tcout << *i << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nchar inputString[15][25];\nchar listOfCommands[35];\nchar buffer[35] = \"\";\n\nint numberOfLines = 0;\nint numberOfCommands = 0;\n\nint cursorXCordinate = 0;\nint cursorYCordinate = 0;\n\n\nvoid textInput() {\n\n    int indexOfString = 0;\n    int indexOfCommand = 0;\n    char dummyString[30];\n    char dummyCommand;\n   // freopen(\"input.txt\", \"r\", stdin);\n    while ( scanf(\"%s\",dummyString)!=EOF) {\n        getchar();\n        if ( !strcmp(dummyString, \"END_OF_TEXT\") ) break;\n        for ( int i = 0; i<=strlen(dummyString); i++ ) {\n            inputString[indexOfString][i] = dummyString[i];\n\n        }\n        indexOfString++;\n    }\n\n    while( scanf(\"%c\", &dummyCommand)!=EOF ) {\n        getchar();\n        if( dummyCommand == '-' ) break;\n        listOfCommands[indexOfCommand] = dummyCommand;\n        indexOfCommand++;\n    }\n    numberOfLines = indexOfString - 1;\n    numberOfCommands = indexOfCommand;\n}\n\n\nvoid goToFirstPosition() { // a\n    cursorYCordinate = 0;\n}\n\n\nvoid goToLastPosition() { // e\n    cursorYCordinate = strlen(inputString[cursorXCordinate]);\n}\n\n\nvoid moveToUpperLine() {\n\n    if (cursorXCordinate > 0) {\n        cursorXCordinate -= 1;\n    }\n    // cursorYCordinate = 0;\n}\n\nvoid moveTOLowerLine() {\n\n    if (cursorXCordinate < numberOfLines) {\n        cursorXCordinate += 1;\n    }\n    //cursorYCordinate = 0;\n\n}\n\n\nvoid moveByOnePlaceToTheRight() {\n\n    int currentStringLen = strlen(inputString[ cursorXCordinate ]);\n    if( cursorYCordinate == currentStringLen ) {\n        if ( numberOfLines - cursorXCordinate > 0 ) {\n            cursorXCordinate += 1;\n            cursorYCordinate  = 0;\n        }\n    } else {\n        if( cursorYCordinate < currentStringLen )\n            cursorYCordinate += 1;\n    }\n}\n\n\nvoid moveByOnePlaceToTheLeft() {\n\n    int upperStringLen;\n    int currentStringLen = strlen(inputString[ cursorXCordinate ]);\n    if ( cursorYCordinate == 0 ) {\n        if ( cursorXCordinate > 0 ) {\n            cursorXCordinate -= 1;\n            upperStringLen = strlen( inputString[cursorXCordinate] );\n            cursorYCordinate = upperStringLen;\n        }\n    } else {\n        if ( cursorYCordinate >  0 ) {\n            cursorYCordinate -= 1;\n        }\n    }\n}\n\n\nvoid deleteSingleCharacter() {\n\n    int currentStringLen = strlen(inputString[cursorXCordinate]);\n    char referenceString[30] = \"\";\n    int temp = 0;\n    if ( cursorYCordinate < currentStringLen ) {\n        for( int i = 0; i < currentStringLen; i++) {\n            if ( i != cursorYCordinate) {\n                referenceString[temp] = inputString[cursorXCordinate][i];\n                temp++;\n            }\n\n        }\n        strcpy(inputString[cursorXCordinate], referenceString);\n    } else if( cursorYCordinate == currentStringLen ) {\n        if ( numberOfLines - cursorXCordinate > 0 ) {\n            strcat( inputString[cursorXCordinate], inputString[cursorXCordinate+1]);\n            for(int i = cursorXCordinate+1; i<numberOfLines; i++) strcpy(inputString[i], inputString[i+1]);\n            strcpy(inputString[numberOfLines], \"\");\n        }\n    }\n}\n\n\nvoid copyText() {\n\n    int currentStringLen = strlen(inputString[cursorXCordinate]);\n    if ( currentStringLen == cursorYCordinate ) {\n        if ( numberOfLines - cursorXCordinate > 0 ) {\n            strcat( inputString[cursorXCordinate], inputString[cursorXCordinate+1]);\n            for(int i = cursorXCordinate+1; i<numberOfLines; i++) strcpy(inputString[i], inputString[i+1]);\n            strcpy(inputString[numberOfLines], \"\");\n        }\n    } else if ( cursorYCordinate < currentStringLen ) {\n        strcpy(buffer, \"\");\n        for ( int i = cursorYCordinate; i<=currentStringLen; i++)\n            buffer[i-cursorYCordinate] = inputString[cursorXCordinate][i];\n        for ( int i = cursorYCordinate; i<=currentStringLen; i++)\n            inputString[cursorXCordinate][i] = NULL;\n\n    }\n}\n\n\nvoid yank() {\n\n    int currentStringLen = strlen( inputString[cursorXCordinate]);\n\n    if ( strlen(buffer) ) {\n        if( cursorYCordinate < currentStringLen) {\n            char firstPart[30] = \"\";\n            char secondPart[30] = \"\";\n            int j = 0;\n            for(int i = 0; i<cursorYCordinate; i++) firstPart[i] = inputString[cursorXCordinate][i];\n            strcat(firstPart, buffer);\n            for(int i = cursorYCordinate; i<currentStringLen; i++)\n                secondPart[j++] = inputString[cursorXCordinate][i];\n            strcat(firstPart, secondPart);\n            strcat(inputString[cursorXCordinate], firstPart);\n            cursorYCordinate += strlen(buffer);\n        }\n        else {\n        strcat(inputString[cursorXCordinate], buffer);\n        cursorYCordinate += strlen(buffer);\n        }\n    }\n}\n\n\nint main() {\n\n    textInput();\n    goToFirstPosition();\n    for(int i = 0; i<numberOfCommands; i++) {\n        if( listOfCommands[i]  == 'a') goToFirstPosition();\n        if ( listOfCommands[i] == 'e') goToLastPosition();\n        if ( listOfCommands[i] == 'p') moveToUpperLine();\n        if ( listOfCommands[i] == 'n') moveTOLowerLine();\n        if ( listOfCommands[i] == 'f') moveByOnePlaceToTheRight();\n        if ( listOfCommands[i] == 'b') moveByOnePlaceToTheLeft();\n        if ( listOfCommands[i] == 'd') deleteSingleCharacter();\n        if ( listOfCommands[i] == 'k') copyText();\n        if ( listOfCommands[i] == 'y') yank();\n       // printf(\"%c_____________________\\n\",listOfCommands[i]);\n        //printf(\"%s\\n\",inputString[0]);\n        //printf(\"%s\\n\",inputString[1]);\n        //printf(\"buffer-- %s\\n\",buffer);\n        //printf(\"(%d,%d)\\n\", cursorXCordinate, cursorYCordinate);\n\n    }\n    for(int i = 0; i<=numberOfLines; i++) printf(\"%s\\n\",inputString[i]);\n    //printf(\"%c\", inputString[cursorXCordinate][cursorYCordinate]);\n    //goToLastPosition();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\n\nclass TextEditor{\nprivate:\n  string buf;\n  vector<string> text;\n  int row,pos;\n\n  void InputText();\n  void MoveCursor(char com);\n  void DeleteCharacter();\n  void CutLine();\n  void PasteBuffer();\n  \npublic:\n  TextEditor();\n\n  void ProcessCommand(char com);\n  void PrintText();\n};\n\n\n\n\nint main(){\n\n  TextEditor editor;\n\n  char command;\n\n  while(cin >> command, command != '-'){\n    editor.ProcessCommand(command);\n  }\n  \n  editor.PrintText();\n  \n  return 0;\n}\n\n\n\n\nTextEditor::TextEditor(){\n  buf = \"\";\n  pos = row = 0;\n  InputText();\n}\n\n\nvoid TextEditor::InputText(){\n  string input;\n\n  while(getline(cin,input), input!=\"END_OF_TEXT\"){\n    text.push_back( input );\n  }\n}\n\n\nvoid TextEditor::MoveCursor(char com){\n  switch(com){\n  case 'a': //move cursor to the first character of line\n    pos = 0;\n    break;\n    \n  case 'e': // move the cursor to the end-of-line\n    pos = text[row].size();\n    break;\n    \n  case 'p': //move upper line\n    if(row > 0)row--;\n    pos = 0;\n    break;\n\n  case 'n': //move lower line\n    if(row < text.size()-1 )row++;\n    pos = 0;\n    break;\n\n  case 'f': //move cursor right\n    if( pos != text[row].size() ) pos++;\n    else if( row < text.size()-1 ){ pos = 0; row++; }\n    break;\n\n  case 'b': //move cursor left\n    if( pos != 0 ) pos--;\n    else if( row > 0 ){ pos = text[--row].size(); }\n    break;\n  }\n}\n\n\nvoid TextEditor::DeleteCharacter(){\n  if(pos != text[row].size() ){\n    text[row].erase( text[row].begin() + pos );\n  }\n  else if( row < text.size()-1 ){\n    text[row] += text[row+1];\n    text.erase( text.begin() + row + 1 );\n  }\n}\n\n\nvoid TextEditor::CutLine(){\n  if(pos == text[row].size()){\n    DeleteCharacter();\n    buf = \"\\n\";\n  }\n  else{\n    buf = text[row].substr(pos);\n    text[row].erase( text[row].begin()+pos , text[row].end() );\n    pos = text[row].size();\n  }\n}\n\n\nvoid TextEditor::PasteBuffer(){\n  if( buf == \"\\n\" ){\n    string newline = text[row].substr(pos);\n    text[row].erase( text[row].begin()+pos , text[row].end() );\n    text.insert( text.begin()+row+1 , newline );\n    row++; pos = 0;\n  }\n\n  else{\n    text[row].insert( pos, buf );\n    pos += buf.size();\n  }\n\n}\n\n\nvoid TextEditor::ProcessCommand(char com){\n\n\n  switch(com){\n  case 'd':\n    DeleteCharacter();\n    break;\n    \n  case 'k':\n    CutLine();\n    break;\n\n  case 'y':\n    PasteBuffer();\n    break;\n\n  default:\n    MoveCursor(com);\n  }\n  \n}\n\n\nvoid TextEditor::PrintText(){\n  for(auto line : text){\n    cout << line << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tstring str[10000];\n\tstring b;\n\tint i = 0;\n\t\n\twhile (getline(std::cin, str[i]), str[i] != \"END_OF_TEXT\") i++;\n\ti = 0;\n\t\n\tchar cmd[2];\n\tint car_y = 0;\n\tint car = 0;\n\tint y = 0, y2 = 0;\n\t\n\twhile (str[y] != \"END_OF_TEXT\") y++;\n\ty--;\n\ty2 = y;\n\t\n\tb.erase();\n\t\n\twhile (scanf(\"%s\", cmd), cmd[0] != '-'){\n\t\tif (cmd[0] == 'a'){\n\t\t\tcar = 0;\n\t\t//\tprintf(\" a\");\n\t\t}\n\t\tif (cmd[0] == 'e'){\n\t\t\tcar = str[car_y].size();\n\t\t\t\n\t\t//\tprintf(\" e\");\n\t\t}\n\t\tif (cmd[0] == 'p'){\n\t\t\t\n\t\t//\tprintf(\" p\");\n\t\t\tif (car_y == 0){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y--;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'n'){\n\t\t//\tprintf(\" n\");\n\t\t\tif (car_y == y2){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y++;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'f'){\n\t\t//\tprintf(\" f\");\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\tcar_y++;\n\t\t\t\t\tcar = 0;\n\t\t\t\t\t//printf(\" %d\",car_y);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar++;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'b'){\n\t\t//\tprintf(\" b\");\n\t\t\tif (car == 0){\n\t\t\t\tif (car_y != 0){\n\t\t\t\t\tcar_y--;\n\t\t\t\t\tcar = str[car_y].size();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar--;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'd'){\n\t\t//\tprintf(\" d\");\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tstr[car_y].erase(car, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\t//str[car_y] + str[car_y + 1];\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'k'){\n\t\t//\tprintf(\" k\");\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\tb[0] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb.erase();\n\t\t\t\tb = str[car_y].substr(car);\n\t\t\t\tstr[car_y].erase(car);\n\t\t\t\tcar = str[car_y].size();\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'y'){\n\t\t//\tprintf(\" y\");\n\t\t\tif (b.empty());\n\t\t\telse {\n\t\t\t\tif (b[0] == '\\0'){\n\t\t\t\t\ty2 = ++y;\n\t\t\t\t\twhile (y < car_y){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t\ty--;\n\t\t\t\t\t}\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstr[car_y].insert(car, b);\n\t\t\t\t\tcar += b.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\ti = 0;\n\twhile (i <= y2){\n\t\t//puts(str[i].c_str());\n\t\tcout << str[i] << endl;\n\t\ti++;\n\t}\n\t/*\n\ti = 0;\n\twhile (i <= y2){\n\t\tif (car_y == i){\n\t\t\tfor (int j = 0; j <= str[i].size(); j++){\n\t\t\t\tif (j == car){\n\t\t\t\t\tcout << 'I';\n\t\t\t\t}\n\t\t\t\tcout << str[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\telse{\n\t\t\tputs(str[i].c_str());\n\t\t}\n\t\ti++;\n\t}*/\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main(){\n\tstring s[500];\n\tint line = 0;\n\tfor ( string in;cin >> in, in != \"END_OF_TEXT\"; ++line ){\n\t\ts[ line ] = in;\n\t}\n\t\n\tint pX = 0;\n\tint pY = 0;\n\t\n\tstring buf;\n\tfor ( string in; cin >> in, in != \"-\"; ) {\n\t\tif ( in == \"a\" ) {\n\t\t\tpX = 0;\n\t\t} else if ( in == \"e\" ) {\n\t\t\tpX = s[ pY ].length();\n\t\t} else if ( in == \"p\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( 0 < pY ) {\n\t\t\t\t--pY;\n\t\t\t}\n\t\t} else if ( in == \"n\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( pY < line - 1 ) {\n\t\t\t\t++pY;\n\t\t\t}\n\t\t} else if ( in == \"f\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\t++pX;\n\t\t\t} else {\n\t\t\t\tif ( pY < line - 1 ) {\n\t\t\t\t\tpX = 0;\n\t\t\t\t\t++pY;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( in == \"b\" ) {\n\t\t\tif ( 0 < pX ) {\n\t\t\t\t--pX;\n\t\t\t} else {\n\t\t\t\tif ( 0 < pY ) {\n\t\t\t\t\t--pY;\n\t\t\t\t\tpX = s[ pY ].length();\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( in == \"d\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + s[ pY ].substr( pX + 1 );\n\t\t\t} else if ( pY < line - 1 ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\t--line;\n\t\t\t}\n\t\t} else if ( in == \"k\" ) {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\tbuf = s[ pY ].substr( pX );\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t\tpX = s[ pY ].length() - 1;\n\t\t\t} else if ( pY < line - 1 ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\t--line;\n\t\t\t\tbuf = \"\\n\";\n\t\t\t}\n\t\t} else if ( in == \"y\" ) {\n\t\t\tif ( !buf.empty() ) {\n\t\t\t\tif ( buf == \"\\n\" ) {\n\t\t\t\t\tfor ( int i = line - 1; pY < i; --i ) {\n\t\t\t\t\t\ts[ i ] = s[ i - 1 ];\n\t\t\t\t\t}\n\t\t\t\t\ts[ pY + 1 ] = s[ pY ].substr( pX );\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t\t\t++line;\n\t\t\t\t} else {\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + buf + s[ pY ].substr( pX );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor ( int i = 0; i < line; ++i ) cout << s[ i ] << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY = 0;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n}\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\\n\";\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX);\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX+1);\n\n\t\tlines[posY] = front;\n\t\tdeque<string>::iterator it = lines.begin();\n\t\tadvance(it,posY);\n\t\tlines.insert(it,rear);\n\t}\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(cin >> str){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(cin >> str){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\tif(str == \"d\") ctrl_d(lines);\n\t\tif(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\nusing namespace std;\n\ntypedef long long ll;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nint main(){\n  int size;\n  string s[100];\n  for(size=0;cin>>s[size],s[size]!=\"END_OF_TEXT\";size++){\n    s[size] += '\\n';\n  }\n\n  string buff;\n  int x = 0, y = 0;\n  char op;\n\n  while(cin>>op,op!='-'){\n    if(op == 'a'){\n      x = 0;\n    }\n    else if(op == 'e'){\n      x = s[y].size() - 1;\n    }\n    else if(op == 'p'){\n      x = 0;\n      if(y != 0){\n        y--;\n      }\n    }\n    else if(op == 'n'){\n      x = 0;\n      if(y != size - 1){\n        y++;\n      }\n    }\n    else if(op == 'f'){\n      if(x < s[y].size() - 1){\n        x++;\n      }\n      else if(y != size-1){\n        y++;\n        x = 0;\n      }\n    }\n    else if(op == 'b'){\n      if(x != 0){\n        x--;\n      }\n      else if(y != 0){\n        y--;\n        x = s[y].size() - 1;\n      }\n    }\n    else if(op == 'd'){\n      if(x == s[y].size() - 1){\n        s[y].erase(s[y].end()-1);\n        s[y] += s[y+1];\n        for(int i=y+1;i<size-1;i++){\n          s[i] = s[i+1];\n        }\n        size--;\n      }\n      else{\n        s[y].erase(s[y].begin() + x);\n      }\n    }\n    else if(op == 'k'){\n      if(x == s[y].size() - 1){\n        s[y].erase(s[y].end()-1);\n        s[y] += s[y+1];\n        for(int i=y+1;i<size-1;i++){\n          s[i] = s[i+1];\n        }\n        size--;\n        buff = \"\\n\";\n      }\n      else{\n        buff = s[y].substr(x,s[y].size()-x-1);\n        s[y].erase(x,buff.size());\n      }\n    }\n    else if(op == 'y'){\n      if(buff == \"\\n\"){\n        for(int i=size;i>y;i--){\n          s[i] = s[i-1];\n        }\n        size++;\n        string tmp = s[y].substr(x);\n        s[y+1] = tmp;\n        s[y].erase(x,s[y].size()-x-1);\n      }\n      else if(buff != \"\"){\n        s[y].insert(x,buff);\n        x += buff.size();\n      }\n    }\n  }\n\n  rep(i,size){\n    cout<<s[i];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t,u;\nvector<char> tmp;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nvoid yinsert(int,vector<char>);\nvoid xinsert(int,int,char);\nvoid ydelete(int);\nvoid xdelete(int,int);\n\nint main(){\n\n  t.clear();\n  tmp.clear();\n  input();\n  x=y=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n    //cout<<y<<' '<<x<<\" ty\"<<t.size()<<endl;\n  }\n\n  for(int i=0;i<t.size();i++){\n    for(int j=0;j<t[i].size();j++){\n      cout<<t[i][j];\n    }\n  }\n\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    xdelete(y,x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  xdelete(y,x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  ydelete(y+1);\n}\n\nvoid funcK(){\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.clear();\n      tmp.push_back('\\n');\n    }\n    return;\n  }\n  tmp.clear();\n  while(t[y][x]!='\\n'){\n    tmp.push_back(t[y][x]);\n    xdelete(y,x);\n  }\n  reverse(tmp.begin(),tmp.end());\n}\n\nvoid funcY(){\n  vector<char> z;\n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    while(t[y][x]!='\\n'){\n      z.push_back(t[y][x]);\n      xdelete(y,x);\n    }\n    yinsert(y+1,z);\n    y++;\n    x=0;\n    return;\n  }\n  for(int i=0;i<(int)tmp.size();i++){\n    xinsert(y,x,tmp[i]);\n  }\n  //funcE();\n}\n\nvoid input(){\n  vector<char> a;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n}\n\n\n\n\n\n\nvector<char> z;\n\nvoid xinsert(int y,int x,char ch){\n  if(x==(int)t[y].size()){\n    t[y].push_back(ch);\n  }else{\n    z=t[y];\n    t[y].clear();\n    for(int i=0;i<(int)z.size();i++){\n      if(i==x)t[y].push_back(ch);\n      t[y].push_back(z[i]);\n    }\n  }\n}\n\nvoid xdelete(int y,int x){\n  if(x+1==(int)t[y].size()){\n    t[y].pop_back();\n  }else{\n    \n    z=t[y];\n    t[y].clear();\n    for(int i=0;i<(int)z.size();i++){\n      if(i==x)continue;\n      t[y].push_back(z[i]);\n    }\n  }\n}\n\nvoid yinsert(int y,vector<char> ch){\n  if(y==(int)t.size()){\n    t.push_back(ch);\n  }else{\n    u=t;\n    t.clear();\n    for(int i=0;i<(int)u.size();i++){\n      if(i==y)t.push_back(ch);\n      t.push_back(u[i]);\n    }\n  }\n}\n\nvoid ydelete(int y){\n  if(y+1==(int)t.size()){\n    t.pop_back();\n  }else{\n    u=t;\n    t.clear();\n    for(int i=0;i<(int)u.size();i++){\n      if(i==y)continue;\n      t.push_back(u[i]);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY = 0;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n\telse return;\n}\n\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\";\n\t\t//buf.append(\"\\n\");\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring front=\"\";\n\t\tstring rear=\"\";\n\t\tfront = lines[posY].substr(0,posX);\n\t\trear = lines[posY].substr(posX,lines[posY].size()-posX);\t\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX+1);\n\n\t\tlines[posY] = front;\n\t\tdeque<string>::iterator it = lines.begin();\n\t\tadvance(it,posY);\n\t\tlines.insert(it,rear);\n\t}\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(getline(cin,str)){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(cin >> str){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\tif(str == \"d\") ctrl_d(lines);\n\t\tif(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nvector<string> s;\nstring buf = \"\";\nint R;\nint ci = 0, cj = 0;\n\nvoid input() {\n  string l;\n  while (1) {\n    getline(cin, l);\n    if (l == \"END_OF_TEXT\") {\n      break;\n    }\n    s.push_back(l);\n  }\n  R = s.size();\n}\n\n// カーソルを現在の行の先頭文字に移動する\nvoid op_a() { cj = 0; }\n\n// カーソルを現在の行の行末に移動する\nvoid op_e() { cj = s[ci].size(); }\n\n// 上に行があれば、カーソルを上の行の先頭文字に移動する。\n// 上に行がなければ、カーソルを先頭文字に移動する。\nvoid op_p() {\n  if (ci != 0) \n    --ci;\n  op_a();\n}\n\n// 下に行があれば、カーソルを下の行の先頭文字に移動する。\n// 下に行がなければ、カーソルを先頭文字に移動する。\nvoid op_n() {\n  if (ci != R - 1) \n    ++ci;\n  op_a();\n}\n\n// カーソルが行末にない場合、カーソルを１つ右に移動する \n// カーソルが行末にありかつ下に行がある場合は、\n// カーソルを下の行の先頭文字へ移動する \n// それ以外の場合は何もしない\nvoid op_f() {\n  if (cj != s[ci].size()) {\n    ++cj;\n  } else if (cj == s[ci].size() && ci != R - 1) {\n    op_n();\n  }\n}\n\n// カーソルが先頭文字でないならば、カーソルを１つ左に移動する。\n// カーソルが先頭文字でありかつ上に行がある場合は、\n// カーソルを上の行の行末へ移動する。\n// それ以外の場合は何もしない。\nvoid op_b() {\n  if (cj != 0) {\n    --cj;\n  } else if (cj == 0 && ci != 0) {\n    --ci;\n    op_e();\n  }\n}\n\n// カーソルが文字を指す場合はその文字を削除する。\n// 削除された文字の右側の文字列は左にシフトされる。\n// カーソルが行末を指し下に行がある場合は、\n// 下の行をそのままカーソルの位置に繋げる。以下の行は上にシフトされる。\n// それ以外の場合は何もしない。\nvoid op_d() {\n  if (cj != s[ci].size()) {\n    s[ci].erase(cj, 1);\n  } else if (cj == s[ci].size() && ci != R - 1) {\n    s[ci].erase(cj, 1);\n    s[ci] += s[ci+1];\n    s.erase(s.begin() + ci + 1);    \n  }\n}\n\n// カーソルが行末にある場合、下に行があれば、\n// d と同じ操作をしバッファに１つの改行を記録する。\n// カーソルが行末にない場合、カーソルが指す文字を含めた\n// 右側すべての文字を切り取りそれをバッファに記録する。\n// カーソルは元の行の行末を指すようになる。全ての記録においてバッファは上書きされる。\n// それ以外の場合は何もしない。(clarification at 14:20)\nvoid op_k() {\n  if (cj == s[ci].size() && ci != R - 1) {\n    s[ci].erase(cj, 1);\n    s[ci] += s[ci+1];\n    s.erase(s.begin() + ci + 1);\n    buf = \"\\n\";\n  } else  {\n    buf = s[ci].substr(cj);\n    s[ci].erase(cj);\n  }\n}\n\n// バッファが空の場合はなにもしない。\n// バッファの内容が改行の場合、カーソルが指す文字の直前で改行を行う。\n// カーソルは新しい行の先頭文字へ移動する。\n// バッファの内容が文字列の場合、カーソルの位置にバッファの内容を挿入する。\n// カーソルの位置はもともと指していた文字または行末の場所へ移動する。 \nvoid op_y() {\n  if (buf == \"\") return;\n  if (buf == \"\\n\") {\n    inserter(s, s.begin() + ci + 1) = s[ci].substr(cj);\n    s[ci].erase(cj);\n    ++ci; cj = 0;          \n  } else {\n    s[ci].insert(cj, buf.c_str());\n    cj += buf.size();\n  }\n}\n\nvoid interpret() {\n  char op;\n  while (cin >> op, op != '-') {\n    switch (op) {\n      case 'a': { op_a(); break; }\n      case 'e': { op_e(); break; }\n      case 'p': { op_p(); break; }\n      case 'n': { op_n(); break; }\n      case 'f': { op_f(); break; }\n      case 'b': { op_b(); break; }\n      case 'd': { op_d(); break; }\n      case 'k': { op_k(); break; }\n      case 'y': { op_y(); break; }\n    }\n  }\n  rep(i,R) {\n    printf(\"%s\\n\", s[i].c_str());\n  }\n}\n\nint main() {\n  input();\n  interpret();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Emacs{\n  int line,column;\n  string buffer;\n  vector<string> text;\n\n  void editText(){\n    for(int i = 0 ; i < (int)text.size() ; i++){\n      if(isEmptyLine(i)){ text[i].empty(); }\n    }\n  }\n\n  void print(int x,char command){\n    cout << \"buffer: \" << buffer << endl;\n    cout << \"command: \" << command << endl;\n    cout << \"line: \" << line << endl;\n    cout << \"column: \" << column << endl;\n    for(int i = 0 ; i < text.size(); i++){\n      cout << text[i] << endl;\n    }\n    cout << endl;\n  }\n\n  void order(char command){\n    editText();\n    switch(command){\n    case 'a': funcA(); break;\n    case 'e': funcE(); break;\n    case 'p': funcP(); break;\n    case 'n': funcN(); break;\n    case 'f': funcF(); break;\n    case 'b': funcB(); break;\n    case 'd': funcD(); break;\n    case 'k': funcK(); break;\n    case 'y': funcY(); break;\n    }\n    //print(1,command);\n  }\n\n  bool isEmptyLine(int l){\n    for(int i = 0 ; i < (int)text[l].size() ; i++){\n      if(text[l][i] != ' '){ return false; }\n    }\n    return true;\n  }\n\n  void funcA(){\n    column = 0;\n  }\n  \n  void funcE(){\n    column = text[line].size();\n  }\n\n  void funcP(){\n    if(line > 0){\n      line--;\n    }\n    column = 0;\n  }\n\n  void funcN(){\n    if(line+1 < (int)text.size()){\n      line++;\n    }\n    column = 0;\n  }\n\n  void funcF(){\n    if(text[line].empty()){ return; }\n    if(column == (int)text[line].size()){\n      if(line+1 < (int)text.size()){\n        line++;\n        column = 0;\n      }\n    }else{\n      column++;\n    }\n  }\n  \n  void funcB(){\n    if(column == 0){\n      if(line != 0){\n        line--;\n        column = text[line].size();\n      }\n    }else{\n      column--;\n    }\n  }\n\n  void funcD(){\n    if(text[line].empty()){\n      int len = text.size();\n      vector<string> ntext(len-1);\n      for(int i = 0 ; i < line ; i++){\n        ntext[i] = text[i];\n      }\n      for(int i = line ; i < len-1 ; i++){\n        ntext[i] = text[i+1];\n      }\n      text = ntext;\n      return;\n    }\n    if(0 <= column && column < (int)text[line].size()){\n      text[line] = text[line].substr(0,column) + text[line].substr(column+1);\n    }else{\n      int len = text.size();\n      if(line+1 < len){\n        vector<string> ntext(len-1);\n        for(int i = 0 ; i < line-1 ; i++){\n          ntext[i] = text[i];\n        }\n        ntext[line] = text[line] + text[line+1];\n        for(int i = line+2 ; i < len ; i++){\n          ntext[i] = text[i];\n        }\n        text = ntext;\n      }\n    }\n  }\n\n  void funcK(){\n    int len = text[line].size();\n    if(text[line].empty()){\n      buffer = \"\\n\";\n      int len = text.size();\n      vector<string> ntext(len-1);\n      for(int i = 0 ; i < line ; i++){\n        ntext[i] = text[i];\n      }\n      for(int i = line ; i < len-1 ; i++){\n        ntext[i] = text[i+1];\n      }\n      text = ntext;\n      return;\n    }\n    if(column == len){\n      int len2 = text.size();\n      if(line+1 < len2){\n        buffer = \"\\n\";\n        vector<string> ntext(len-1);\n        for(int i = 0 ; i < line-1 ; i++){\n          ntext[i] = text[i];\n        }\n        ntext[line] = text[line] + text[line+1];\n        for(int i = line+2 ; i < len ; i++){\n          ntext[i] = text[i];\n        }\n        text = ntext;\n      }\n    }else{\n      buffer.clear();\n      for(int i = column ; i < len ; i++){\n        buffer += text[line][i];\n      }\n      text[line].resize(column);\n    }\n  }\n\n  void funcY(){\n    if(buffer.empty()){ return; }\n    if(buffer == \"\\n\"){\n      string str = text[line];\n      text[line] = str.substr(0,column);\n      if(line+1 < (int)text.size()){\n        text[line+1] = str.substr(column) + text[line+1];\n      }else{\n        text.push_back(str.substr(column));\n      }\n    }else{\n      string str = text[line];\n      str = str.substr(0,column) + buffer + str.substr(column);\n      text[line] = str;\n      column = text[line].size();\n    }\n  }\n\n  void print(){\n    int len = text.size();\n    for(int i = 0 ; i < len ; i++){\n      cout << text[i] << endl;\n    }\n  }\n};\n\nint main(){\n  Emacs emacs;\n  string str;\n  while(getline(cin,str), str != \"END_OF_TEXT\"){\n    emacs.text.push_back(str);\n  }\n  emacs.line = emacs.column = 0;\n  char command;\n  while(cin >> command, command != '-'){\n    emacs.order(command);\n  }\n  emacs.print();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nchar t[100][1000];\nint h;\nint w[100];\n\nchar tmp[1000];\nint tmp_size;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nint main(){\n\n  input();\n  x=y=tmp_size=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n  }\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w[i];j++){\n      cout<<t[i][j];\n    }\n    cout<<endl;\n    //    cout<<\" \"<<w[i]<<endl;\n  }\n  //cout<<y<<' '<<x<<endl;\n  return 0;\n}\n\nvoid funcA(){x=0;}\nvoid funcE(){x=w[y];}\nvoid funcP(){ if(y>0)y--; x=0; }\nvoid funcN(){ if(y+1<h)y++; x=0; }\nvoid funcF(){ \n  if(x<w[y])x++;\n  else if(y+1<h){y++;x=0;}\n}\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=w[y];}\n}\nvoid funcD(){\n  if(x<w[y]){\n    w[y]--;\n    for(int i=x;i<w[y];i++)t[y][i]=t[y][i+1];\n    return;\n  }\n  if(y+1==h)return;\n  for(int i=0;i<w[y+1];i++)t[y][w[y]+i]=t[y+1][i];\n  w[y]+=w[y+1];\n  h--;\n  for(int i=y+1;i<h;i++){\n    w[i]=w[i+1];\n    for(int j=0;j<w[i];j++){\n      t[i][j]=t[i+1][j];\n    }\n  }\n}\n\nvoid funcK(){\n  if(x==w[y]){\n    if(y+1<h){\n      funcD();\n      tmp[0]='\\n';\n      tmp_size=1;\n    }\n  }else{\n    tmp_size=0;\n    for(int i=x;i<w[y];i++)\n      tmp[tmp_size++]=t[y][i];\n    w[y]=x;\n  }\n}\n\nvoid funcY(){\n  \n  if(tmp_size==0)return;\n  if(tmp[0]!='\\n'){\n    char z[100];\n    int zs=0;\n    for(int i=x;i<w[y];i++){\n      z[zs++]=t[y][i];\n    }\n    for(int i=x;i<x+tmp_size;i++){\n      t[y][i]=tmp[i-x];\n    }\n    w[y]+=tmp_size;\n    for(int i=x+tmp_size;i<w[y];i++){\n      t[y][i]=z[i-x-tmp_size];\n    }\n    x+=tmp_size;\n    return;\n  }\n  \n  h++;\n  for(int i=h-1;i>y+1;i--){\n    w[i]=w[i-1];\n    for(int j=0;j<w[i];j++)\n      t[i][j]=t[i-1][j];\n  }\n\n  w[y+1]=w[y]-x;\n  for(int i=0;i<w[y+1];i++){\n    t[y+1][i]=t[y][i+x];\n  }\n  w[y]=x;\n  \n  y++;\n  x=0;\n  \n}\n\nvoid input(){\n  string str;\n  h=0;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    w[h]=str.size();\n    for(int i=0;i<(int)str.size();i++)\n      t[h][i]=str[i];\n    h++;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n\tvector<string> text;\n\twhile(true){\n\t\tstring line;\n\t\tgetline(cin, line);\n\t\tif(line == \"END_OF_TEXT\"){ break; }\n\t\ttext.push_back(line);\n\t}\n\tint x = 0, y = 0;\n\tstring buffer;\n\twhile(true){\n\t\tstring cmd;\n\t\tcin >> cmd;\n\t\tif(cmd == \"-\"){ break; }\n\t\tif(cmd == \"a\"){\n\t\t\tx = 0;\n\t\t}else if(cmd == \"e\"){\n\t\t\tx = text[y].size();\n\t\t}else if(cmd == \"p\"){\n\t\t\tx = 0;\n\t\t\tif(y > 0){ --y; }\n\t\t}else if(cmd == \"n\"){\n\t\t\tx = 0;\n\t\t\tif(y < text.size() - 1){ ++y; }\n\t\t}else if(cmd == \"f\"){\n\t\t\tif(x < text[y].size()){\n\t\t\t\t++x;\n\t\t\t}else if(y < text.size() - 1){\n\t\t\t\tx = 0;\n\t\t\t\t++y;\n\t\t\t}\n\t\t}else if(cmd == \"b\"){\n\t\t\tif(x > 0){\n\t\t\t\t--x;\n\t\t\t}else if(y > 0){\n\t\t\t\t--y;\n\t\t\t\tx = text[y].size();\n\t\t\t}\n\t\t}else if(cmd == \"d\"){\n\t\t\tif(x < text[y].size()){\n\t\t\t\ttext[y].erase(text[y].begin() + x);\n\t\t\t}else if(y < text.size() - 1){\n\t\t\t\ttext[y] += text[y + 1];\n\t\t\t\ttext.erase(text.begin() + y + 1);\n\t\t\t}\n\t\t}else if(cmd == \"k\"){\n\t\t\tif(x == text[y].size() && y < text.size() - 1){\n\t\t\t\tbuffer = \"\\n\";\n\t\t\t\ttext[y] += text[y + 1];\n\t\t\t\ttext.erase(text.begin() + y + 1);\n\t\t\t}else if(x != text[y].size()){\n\t\t\t\tbuffer = string(text[y].begin() + x, text[y].end());\n\t\t\t\ttext[y].erase(text[y].begin() + x, text[y].end());\n\t\t\t}\n\t\t}else if(cmd == \"y\"){\n\t\t\tif(buffer == \"\"){\n\t\t\t}else if(buffer == \"\\n\"){\n\t\t\t\ttext.insert(text.begin() + y + 1, string(text[y].begin() + x, text[y].end()));\n\t\t\t\ttext[y].erase(text[y].begin() + x, text[y].end());\n\t\t\t}else{\n\t\t\t\ttext[y].insert(x, buffer);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < text.size(); ++i){ cout << text[i] << endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n  int p, q;\n  string str, buf;\n  vector<string> vec;\n\n  while(!cin.eof()){\n    p = q = 0;\n    buf = \"\";\n\n    while(getline(cin, str) && str != \"END_OF_TEXT\") vec.push_back(str);\n    while(getline(cin, str) && str != \"-\"){\n      if(str == \"a\") q = 0;\n\n      if(str == \"e\") q = vec[p].size();\n\n      if(str == \"p\"){\n\tif(p > 0) --p;\n\tq = 0;\n      }\n\n      if(str == \"n\"){\n\tif(p < vec.size()-1) ++p;\n\tq = 0;\n      }\n\n      if(str == \"f\"){\n\tif(q < vec[p].size()) ++q;\n\telse if(q == vec[p].size() && p < vec.size()-1){\n\t  ++p;\n\t  q = 0;\n\t}\n      }\n\n      if(str == \"b\"){\n\tif(q > 0) --q;\n\telse if(q == 0 && p > 0){\n\t  --p;\n\t  q = vec[p].size();\n\t}\n      }\n\n      if(str == \"d\"){\n\tif(q == vec[p].size()){\n\t  if(vec.size()-1 > p){\n\t    vec[p] += vec[p+1];\n\t    vec.erase(vec.begin()+(p+1));\n\t  }\n\t} else {\n\t  vec[p].erase(vec[p].begin()+q);\n\t}\n      }\n\n      if(str == \"k\"){\n\tif(q == vec[p].size()){\n\t  if(vec.size()-1 > p){\n\t    vec[p] += vec[p+1];\n\t    vec.erase(vec.begin()+(p+1));\n\t    buf = \"wararaki\";\n\t  }\n\t} else {\n\t  string s1 = \"\", s2 = \"\";\n\t  for(int i = 0; i < q; ++i)\n\t    s1 += vec[p][i];\n\t  for(int i = q; i < vec[p].size(); ++i)\n\t    s2 += vec[p][i];\n\t  vec[p] = s1;\n\t  buf = s2;\n\t}\n      }\n\n      if(str == \"y\" && buf.size()){\n\tif(buf == \"wararaki\"){\n\t  string s1 = \"\", s2 = \"\";\n\t  for(int i = 0; i < q; ++i)\n\t    s1 += vec[p][i];\n\t  for(int j = q; j < vec[p].size(); ++j)\n\t    s2 += vec[p][j];\n\t  vec[p++] = s1;\n\t  vec.insert(vec.begin()+(p), s2);\n\t} else {\n\t  vec[p].insert(q, buf);\n\t  q += buf.size();\n\t}\n      }\n    }\n\n    for(int i = 0; i < vec.size(); ++i)\n      cout << vec[i] << endl;\n    \n    buf.clear();\n    vec.clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<string> buf;\nint row;\nint column;\nstring rem;\n\nvoid printbuf(){\n  //cout << row << ' ' << column << \" \\\"\" << rem << \"\\\"\" << endl;\n  for(int i=0;i<buf.size();i++){\n    cout << buf[i];\n  }\n}\n\nmain(){\n  string in;\n  while(getline(cin, in)){\n    if(in == \"END_OF_TEXT\" || in == \"1\") break;\n    in += '\\n';\n    buf.push_back(in);\n  }\n  char c;\n  row = 0;\n  column = 0;\n  while(cin >> c){\n    if(c == '-') break;\n    switch(c){\n      case 'a':\n        column = 0;\n        break;\n      case 'e':\n        column = (int)buf[row].size()-1;\n        break;\n      case 'p':\n        column = 0;\n        if(row != 0) --row;\n        break;\n      case 'n':\n        column = 0;\n        if(row+1 != buf.size()) ++row;\n        break;\n      case 'f':\n        if(column+1 == buf[row].size()){\n          if(row+1 != buf.size()){\n            column = 0;\n            ++row;\n          }\n        }else{\n          ++column;\n        }\n        break;\n      case 'b':\n        if(column == 0){\n          if(row != 0){\n            column = 0;\n            --row;\n          }\n        }else{\n          --row;\n        }\n        break;\n      case 'd':\n        if(column+1 == buf[row].size()){\n          if(row+1 != buf.size()){\n            vector<string>::iterator ite = buf.begin();\n            for(int i=0;i<row;i++) ++ite;\n            buf.erase(ite);\n          }\n        }else{\n          buf[row].erase(column, 1);\n        }\n        break;\n      case 'k':\n        rem = \"\";\n        if(column+1 == buf[row].size()){\n          if(row+1 != buf.size()){\n            vector<string>::iterator ite = buf.begin();\n            for(int i=0;i<row;i++) ++ite;\n            buf.erase(ite);\n            rem += '\\n';\n          }\n        }else{\n          for(int i=column;i+1<buf[row].size();++i){\n            rem += buf[row][i];\n          }\n          string::iterator ite = buf[row].begin();\n          for(int i=0;i<column;i++) ++ite;\n          buf[row].erase(ite, buf[row].end());\n          buf[row] += '\\n';\n        }\n        break;\n      case 'y':\n        if(rem.size() != 0){\n          int irem;\n          string back = buf[row].substr(column);\n          buf[row] = buf[row].substr(0, column);\n          for(irem = 0;irem<rem.size();irem++){\n            buf[row] += rem[irem];\n            if(rem[irem] == '\\n'){\n              vector<string>::iterator ite = buf.begin();\n              for(int i=0;i<row+1;i++) ++ite;\n              buf.insert(ite, \"\");\n              column = 0;\n              ++row;\n            }\n          }\n          buf[row] += back;\n        }\n        break;\n    }\n    //printbuf();\n  }\n  printbuf();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define TOP_OF_BUFFER 0\n#define BEGIN_OF_LINE 0\n#define END_OF_LINE 10000\n\nstruct Cursor{\n  int x, y;\n  Cursor(){\n    x = 0, y = 0;\n  }\n};\n\nvector<string> buffer;\nstring buf;\nbool new_line;\nCursor cursor;\nint end;\n\nvoid output(){\n  for(int i = 0 ; i <= end ; i++){\n    cout << buffer[i] << endl;\n  }\n  //cout << endl;\n}\n\nvoid a_command(){\n  cursor.x = BEGIN_OF_LINE;\n}\n\nvoid e_command(){\n  cursor.x = END_OF_LINE;\n}\n\nvoid p_command(){\n  if(cursor.y == TOP_OF_BUFFER) cursor.x = BEGIN_OF_LINE;\n  else{\n    cursor.y--;\n    cursor.x = BEGIN_OF_LINE;\n  }\n}\n\nvoid n_command(){\n  if(cursor.y == end) cursor.x = BEGIN_OF_LINE;\n  else{\n    cursor.y++;\n    cursor.x = BEGIN_OF_LINE;\n  }\n}\n\nvoid f_command(){\n  if(cursor.x != END_OF_LINE) cursor.x++;\n  else if(cursor.x == END_OF_LINE && cursor.y != end){\n    cursor.x = BEGIN_OF_LINE;\n    cursor.y++;\n  }\n}\n\nvoid b_command(){\n  if(cursor.x != BEGIN_OF_LINE) cursor.x--;\n  else if(cursor.x == BEGIN_OF_LINE && cursor.y != TOP_OF_BUFFER){\n    cursor.x = END_OF_LINE;\n    cursor.y--;\n  }\n}\n\nvoid d_command(){\n  if(cursor.x == END_OF_LINE && cursor.y != end){\n    //シフト\n    //if(buffer[cursor.y].size() == 0) cursor.x = 0;\n    cursor.x = buffer[cursor.y].size();\n    buffer[cursor.y] += buffer[cursor.y+1];\n    buffer.erase(buffer.begin() + cursor.y+1);\n    end--;\n  }\n  else if(cursor.x != END_OF_LINE){\n    buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n  }\n}\n\nvoid k_command(){\n  if(cursor.x == END_OF_LINE && cursor.y != end){\n    d_command();\n    buf = \"\";\n    new_line = true;\n  }\n  else if(cursor.x != END_OF_LINE){\n    buf = \"\";\n    new_line = false;\n    for(int j = cursor.x ; j < buffer[cursor.y].size() ; j++){\n      buf += buffer[cursor.y][j];\n    }\n\n    int buffer_size = buffer[cursor.y].size();\n    for(int j = cursor.x ; j < buffer_size ; j++){\n      buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n      //cout << buffer[cursor.y] << endl;\n    }\n  }\n}\n\nvoid y_command(){\n  //if(buf == \"\") return;\n  string bf = \"\";\n  for(int j = cursor.x ; j < buffer[cursor.y].size() ; j++){\n    bf += buffer[cursor.y][j];\n  }\n   \n  if(new_line){\n    buffer.push_back(\"\");\n    //cout << \"size = \" << buffer.size() << endl;\n    for(int i = buffer.size()-1 ; i > cursor.y ; i--){\n      buffer[i] = buffer[i-1];\n    }\n    end++;\n    buffer[cursor.y+1] = bf;\n    int buffer_size = buffer[cursor.y].size();\n    for(int j = cursor.x ; j < buffer_size ; j++){\n      buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n    }\n    cursor.y++;\n    cursor.x = 0;\n  }\n  else{\n    if(cursor.x == END_OF_LINE){\n      buffer[cursor.y] += buf;\n    }\n    else{\n      for(int cnt = 0 ; cnt < bf.size() ; cnt++){\n\tbuffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n      }\n      buffer[cursor.y] += buf;\n      buffer[cursor.y] += bf;\n      cursor.x += buf.size();\n    }\n  }\n} \n\nvoid init(){\n  end = buffer.size()-1;\n  new_line = false;  \n  buf = \"\";\n}\n  \nint main(){\n  string s;\n  while(getline(cin, s)){\n    if(s == \"END_OF_TEXT\") break;\n    buffer.push_back(s);\n  }\n  \n  init();\n  \n  char op;\n  while(cin >> op){\n    //cout << \"operand = \" << op << endl;\n    if(op == '-') break;\n    if(op == 'a') a_command();\n    if(op == 'e') e_command();\n    if(op == 'p') p_command();\n    if(op == 'n') n_command();\n    if(op == 'f') f_command();\n    if(op == 'b') b_command();\n    if(op == 'd') d_command();\n    if(op == 'k') k_command();\n    if(op == 'y') y_command();  \n    if(cursor.x == buffer[cursor.y].size() ) cursor.x = END_OF_LINE;\n    //output();\n    //cout << \"cursor.x = \" << cursor.x << \", cursor.y = \" << cursor.y << endl << endl;  \n    //cout << \"new_line = \" << new_line << endl;\n  }\n  \n  output();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY = 0;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n\telse return;\n}\n\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\";\n\t\tbuf.push_back('\\n');\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring front=\"\";\n\t\tstring rear=\"\";\n\t\tfront = lines[posY].substr(0,posX);\n\t\trear = lines[posY].substr(posX,lines[posY].size()-posX);\t\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX+1);\n\n\t\tlines[posY] = front;\n\t\tdeque<string>::iterator it = lines.begin();\n\t\tadvance(it,posY);\n\t\tlines.insert(it,rear);\n\t}\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(getline(cin,str)){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(cin >> str){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\tif(str == \"d\") ctrl_d(lines);\n\t\tif(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n)-1;i>=(m);--i)\n#define repc(i,n) for(int i=0;i<=(n);++i)\n#define repcn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repcd(i,n) for(int i=(n);i>=0;--i)\n#define repcnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define repc0(i,n) for(i=0;i<=(n);++i)\n#define repcn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repcd0(i,n) for(i=(n);i>=0;--i)\n#define repcnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE cout<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nstring str[100];\n\nint main() {\n\tint h = 0;\n\tIL {\n\t\tcin >> str[h];\n\t\tif (str[h] == \"END_OF_TEXT\") break;\n\t\t++h;\n\t}\n\tint x = 0, y = 0;\n\tstring com, buf = \"\";\n\tIL {\n\t\tcin >> com;\n\t\tif (com == \"a\") {\n\t\t\tx = 0;\n\t\t} else if (com == \"e\") {\n\t\t\tx = sz(str[y]);\n\t\t} else if (com == \"p\") {\n\t\t\tx = 0;\n\t\t\tif (y > 0) --y;\n\t\t} else if (com == \"n\") {\n\t\t\tx = 0;\n\t\t\tif (y < h - 1) ++y; \n\t\t} else if (com == \"f\") {\n\t\t\tif (x < sz(str[y])) ++x;\n\t\t\telse if (y < h - 1) {x = 0; ++y;}\n\t\t} else if (com == \"b\") {\n\t\t\tif (x > 0) --x;\n\t\t\telse if (y > 0) {--y; x = sz(str[y]);}\n\t\t} else if (com == \"d\") {\n\t\t\tif (x < sz(str[y])) str[y] = str[y].substr(0, x) + str[y].substr(x + 1);\n\t\t\telse if (y < h - 1) {\n\t\t\t\tstr[y] += str[y + 1];\n\t\t\t\t--h;\n\t\t\t\trepn (i, y + 1, h - 1) str[i] = str[i + 1];\n\t\t\t}\n\t\t} else if (com == \"k\") {\n\t\t\tif (x == sz(str[y])) {\n\t\t\t\tif (y < h - 1) {\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t\tstr[y] += str[y + 1];\n\t\t\t\t--h;\n\t\t\t\trepn (i, y + 1, h - 1) str[i] = str[i + 1];\n\t\t\t} else {\n\t\t\t\tbuf = str[y].substr(x);\n\t\t\t\tstr[y] = str[y].substr(0, x);\n\t\t\t\tx = sz(str[y]);\n\t\t\t}\n\t\t} else if (com == \"y\") {\n\t\t\tif (buf == \"\\n\") {\n\t\t\t\t++h;\n\t\t\t\trepn (i, y + 2, h) str[i] = str[i - 1];\n\t\t\t\tstr[y + 1] = str[y].substr(x);\n\t\t\t\tstr[y] = str[y].substr(0, x);\n\t\t\t} else if (sz(buf)  > 0) {\n\t\t\t\tstr[y] = str[y].substr(0, x) + buf + str[y].substr(x);\n\t\t\t}\n\t\t} else if (com == \"-\") {\n\t\t\tbreak;\n\t\t}\n\t}\n\trep (i, h) cout << str[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nstring s[102],buf;\nint l,r,N;\n\nvoid a(void){r=0;}\nvoid e(void){r=max(0,(int)s[l].size()-1);}\nvoid p(void){\n\tif(l>0)l--,r=0;\n\telse r=0;\n}\n\nvoid n(void){\n\tif(l<N-1)l++,r=0;\n\telse r=0;\n}\n\nvoid f(void){\n\tif(r<max(0,(int)s[l].size()-1))r++;\n\telse l++,r=0;\n}\n\nvoid b(void){\n\tif(r>0)r--;\n\telse if(l>0)r=s[--l].size();\n}\n\nvoid d(void){\n\tif(r==s[l].size()-1){\n\t\tif(l<N-1){\n\t\t\ts[l]+=s[l+1];\n\t\t\tfor(int i=l+1;i<N-1;i++)s[i]=s[i+1];\n\t\t\tN--;\n\t\t}\n\t}\n\telse s[l].erase(r,1);\n}\n\nvoid k(void){\n\tif(r==s[l].size()-1 && l<N-1)d(),buf=\"\\n\";\n\telse {\n\t\tbuf=s[l].substr(max(0,r-1));\n\t\ts[l].erase(max(0,r-1));\n\t}\n}\n\nvoid y(void){\n\tif(buf.empty())return ;\n\tif(buf==\"\\n\"){\n\t\tfor(int i=N;i>l;i--)s[i]=s[i-1];\n\t\ts[l+1]=s[l].substr(max(0,r-1));\n\t\ts[l].erase(max(0,r-1));\n\t\tl++,r=0,N++;\n\t}\n\telse {\n\t\ts[l].insert(min((int)s[l].size(),r+1),buf);\n\t\tr+=buf.size();\n\t}\n}\n\n\nint main(void){\n\t\n\twhile(getline(cin,s[N])){\n\t\tif(s[N]==\"END_OF_TEXT\")break;\n\t\tN++;\n\t}\n\tl=r=0;\n\tbuf.clear();\n\t\n\t\t\n\tstring C;\n\twhile(cin >> C,C!=\"-\"){\n\t\t\n\t\tif(C==\"a\")a();\n\t\telse if(C==\"e\")e();\n\t\telse if(C==\"p\")p();\n\t\telse if(C==\"n\")n();\n\t\telse if(C==\"f\")f();\n\t\telse if(C==\"b\")b();\n\t\telse if(C==\"d\")d();\n\t\telse if(C==\"k\")k();\n\t\telse if(C==\"y\")y();\n\t}\n\t\n\tfor(int i=0;i<N;i++){\n\t\tcout << s[i] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[110];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tt[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tcol = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\tt[row+1] = \"\";\n\t\t\t\t\tif( col < t[row].size() )\n\t\t\t\t\t\tt[row+1] = t[row].substr( col );\n\t\t\t\t\t//for(int i=col ; i<(int)t[row].size();i++)\n\t\t\t\t\t//\tt[row+1].push_back( t[row][i] );\n\t\t\t\t\tif(col < t[row].size() ) t[row].erase( col );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else{\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\n\nint main() {\n\tvector<string>emacs;\n\twhile (1) {\n\t\tstring st;\n\t\tgetline(cin, st);\n\t\t\n\t\tif (st == \"END_OF_TEXT\") {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\temacs.push_back(st);\n\t\t}\n\t}\n\tint x = 0, y = 0;\n\tvector<string>buf;\n\twhile (1) {\n\t\tchar c; cin >> c;\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\t\tx = 0;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tx = emacs[y].size();\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (y) {\n\t\t\t\ty--;\n\t\t\t}\n\t\t\tx = 0;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tif (y != emacs.size() - 1) {\n\t\t\t\ty++;\n\t\t\t}\n\t\t\tx = 0;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tif (x != emacs[y].size())x++;\n\t\t\telse {\n\t\t\t\tif (y != emacs.size() - 1) {\n\t\t\t\t\ty++;\n\t\t\t\t\tx = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif (x)x--;\n\t\t\telse {\n\t\t\t\tif (y) {\n\t\t\t\t\ty--;\n\t\t\t\t\tx = emacs[y].size();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (x != emacs[y].size()) {\n\t\t\t\temacs[y].erase(emacs[y].begin() + x);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (y != emacs.size() - 1) {\n\t\t\t\t\temacs[y].insert(emacs[y].end(), emacs[y + 1].begin(), emacs[y + 1].end());\n\t\t\t\t\temacs.erase(emacs.begin() + y + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tif (x == emacs[y].size()) {\n\t\t\t\tif (y != emacs.size() - 1) {\n\t\t\t\t\temacs[y].insert(emacs[y].end(), emacs[y + 1].begin(), emacs[y + 1].end());\n\t\t\t\t\temacs.erase(emacs.begin() + y + 1);\n\t\t\t\t\tbuf = vector<string>(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuf = vector<string>(1, emacs[y].substr(x));\n\t\t\t\temacs[y].erase(emacs[y].begin() + x, emacs[y].end());\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tif (buf.empty()) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (buf[0] == \"\") {\n\t\t\t\t\tstring rest = emacs[y].substr(x);\n\t\t\t\t\temacs[y].erase(emacs[y].begin() + x, emacs[y].end());\n\t\t\t\t\temacs.insert(emacs.begin() + y+1, rest);\n\t\t\t\t\ty++;\n\t\t\t\t\tx = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\temacs[y].insert(emacs[y].begin() + x, buf[0].begin(), buf[0].end());\n\t\t\t\t\tx += buf[0].size();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (c=='-')break;/*\n\t\tfor (auto s : emacs) {\n\t\t\tcout << s << endl;\n\t\t}\n\t\tcout << \"x: \" << x << endl << \"y: \" << y << endl;*/\n\t}\n\tfor (auto s : emacs) {\n\t\tcout << s << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass state{\npublic:\n  state(string str = \"\"):str(str){\n    cursor = 0;\n    buffer = \"\";\n  }\n\n  void typeA(){\n    for(int i=cursor;i>=0;i--){\n      cursor = i;\n      if(i > 0 && str[i-1] == '\\n') break;\n    }\n    assertion();\n  }\n\n  void typeE(){\n    for(int i=cursor;i<str.size();i++){\n      cursor = i;\n      if(str[i] == '\\n') break;\n    }\n    assertion();\n  }\n\n  void typeP(){\n    bool isUpper = false;\n    for(int i=cursor;i>=0;i--){\n      if(i == 0 || i > 0 && str[i-1] == '\\n'){\n        cursor = i;\n        if(isUpper) break;\n        else isUpper = true;\n      }\n    }\n    assertion();\n  }\n\n  void typeN(){\n    bool isDowner = false;\n    for(int i=cursor;i<str.size();i++){\n      if(str[i] == '\\n' && i < (int)str.size() - 1){\n        isDowner = true;\n        cursor = i + 1;\n        break;\n      }\n    }\n\n    if(!isDowner){\n      typeA();\n    }\n    assertion();\n  }\n\n  void typeF(){\n    if(cursor < (int)str.size()-1){\n      cursor++;\n    }\n    assertion();\n  }\n  \n  void typeB(){\n    if(cursor > 0) {\n      cursor--;\n    }\n    assertion();\n  }\n\n  void typeD(){\n    if(cursor < (int)str.size()-1){\n      str.erase(str.begin()+cursor);\n    }\n    assertion();\n  }\n\n  void typeK(){\n    if(str[cursor] == '\\n' && cursor < (int)str.size()-1){\n      typeD();\n      buffer = \"\\n\";\n    } else if(str[cursor] != '\\n'){\n      for(int i=cursor+1;i<(int)str.size();i++){\n        if(str[i] == '\\n'){\n          buffer = string(str.begin()+cursor, str.begin()+i);\n          str.erase(str.begin()+cursor, str.begin()+i);\n        }\n      }\n    }\n    assertion();\n  }\n\n  void typeY(){\n    str.insert(str.begin()+cursor, buffer.begin(), buffer.end());\n    cursor += buffer.size();\n    //buffer = \"\";\n    assertion();\n  }\n\n  string toString(){\n    return str;\n  }\n\n  void assertion(){\n    assert(str.size() > 0 && str[str.size()-1] == '\\n');\n  }\n\nprivate:\n  int cursor;\n  string str, buffer;\n};\n\nstring inputStr(){\n  string str = \"\", in;\n  while(cin >> in){\n    if(in == \"END_OF_TEXT\") break;\n    str += in + '\\n';\n  }\n  return str;\n}\n\nvoid executeCommand(state &dat){\n  string command;\n  while(cin >> command){\n    if(command == \"-\") break;\n    else if(command == \"a\") dat.typeA();\n    else if(command == \"e\") dat.typeE();\n    else if(command == \"p\") dat.typeP();\n    else if(command == \"n\") dat.typeN();\n    else if(command == \"f\") dat.typeF();\n    else if(command == \"b\") dat.typeB();\n    else if(command == \"d\") dat.typeD();\n    else if(command == \"k\") dat.typeK();\n    else if(command == \"y\") dat.typeY();\n    else assert(false);\n  }\n  cout << dat.toString() << flush;\n}\n\nint main(){\n  state dat = state(inputStr());\n  executeCommand(dat);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Emacs{\n  int line,column;\n  string buffer;\n  vector<string> text;\n\n  void editText(){\n    for(int i = 0 ; i < (int)text.size() ; i++){\n      if(isEmptyLine(i)){ text[i] = \" \"; }\n    }\n  }\n\n  void order(char command){\n    editText();\n    switch(command){\n    case 'a': funcA(); break;\n    case 'e': funcE(); break;\n    case 'p': funcP(); break;\n    case 'n': funcN(); break;\n    case 'f': funcF(); break;\n    case 'b': funcB(); break;\n    case 'd': funcD(); break;\n    case 'k': funcK(); break;\n    case 'y': funcY(); break;\n    }\n  }\n\n  bool isEmptyLine(int l){\n    for(int i = 0 ; i < (int)text[l].size() ; i++){\n      if(text[l][i] != ' '){ return false; }\n    }\n    return true;\n  }\n\n  void funcA(){\n    column = 0;\n  }\n  \n  void funcE(){\n    if(isEmptyLine(line)){ return; }\n    column = text[line].size();\n  }\n\n  void funcP(){\n    if(line > 0){\n      line--;\n    }else{\n      column = 0;\n    }\n  }\n\n  void funcN(){\n    if(line+1 < (int)text.size()){\n      line++;\n    }else{\n      column = 0;\n    }\n  }\n\n  void funcF(){\n    if(isEmptyLine(line)){ return; }\n    if(column == (int)text[line].size()){\n      if(line+1 < (int)text.size()){\n        line++;\n        column = 0;\n      }\n    }else{\n      column++;\n    }\n  }\n  \n  void funcB(){\n    if(column == 0){\n      if(line != 0){\n        line--;\n        column = text[line].size();\n      }\n    }else{\n      column--;\n    }\n  }\n\n  void funcD(){\n    if(isEmptyLine(line)){\n      int len = text.size();\n      vector<string> ntext(len-1);\n      for(int i = 0 ; i < line ; i++){\n        ntext[i] = text[i];\n      }\n      for(int i = line ; i < len-1 ; i++){\n        ntext[i] = text[i+1];\n      }\n      text = ntext;\n      return;\n    }\n    if(0 <= column && column < (int)text[line].size()){\n      text[line] = text[line].substr(0,column) + text[line].substr(column+1);\n    }else{\n      int len = text.size();\n      if(line+1 < len){\n        vector<string> ntext(len-1);\n        for(int i = 0 ; i < line-1 ; i++){\n          ntext[i] = text[i];\n        }\n        ntext[line] = text[line] + text[line+1];\n        for(int i = line+2 ; i < len ; i++){\n          ntext[i] = text[i];\n        }\n        text = ntext;\n      }\n    }\n  }\n\n  void funcK(){\n    int len = text[line].size();\n    if(isEmptyLine(line)){\n      buffer = \"\\n\";\n      int len = text.size();\n      vector<string> ntext(len-1);\n      for(int i = 0 ; i < line ; i++){\n        ntext[i] = text[i];\n      }\n      for(int i = line ; i < len-1 ; i++){\n        ntext[i] = text[i+1];\n      }\n      text = ntext;\n      return;\n    }\n    if(column == len){\n      int len2 = text.size();\n      if(line+1 < len2){\n        buffer = \"\\n\";\n        vector<string> ntext(len2-1);\n        for(int i = 0 ; i < line-1 ; i++){\n          ntext[i] = text[i];\n        }\n        ntext[line] = text[line] + text[line+1];\n        for(int i = line+2 ; i < len ; i++){\n          ntext[i] = text[i];\n        }\n        text = ntext;\n      }\n    }else{\n      buffer.clear();\n      for(int i = column ; i < len ; i++){\n        buffer += text[line][i];\n      }\n      text[line].resize(column);\n    }\n  }\n\n  void funcY(){\n    if(buffer.empty()){ return; }\n    if(buffer == \"\\n\"){\n      string str = text[line];\n      text[line] = str.substr(0,column);\n      if(line+1 < (int)text.size()){\n        text[line+1] = str.substr(column) + text[line+1];\n      }else{\n        text.push_back(str.substr(column));\n      }\n    }else{\n      string str = text[line];\n      str = str.substr(0,column) + buffer + str.substr(column);\n      text[line] = str;\n    }\n  }\n\n  void print(){\n    int len = text.size();\n    for(int i = 0 ; i < len ; i++){\n      cout << text[i] << endl;\n    }\n  }\n};\n\nint main(){\n  Emacs emacs;\n  string str;\n  while(getline(cin,str), str != \"END_OF_TEXT\"){\n    emacs.text.push_back(str);\n  }\n  emacs.line = emacs.column = 0;\n  char command;\n  while(cin >> command, command != '-'){\n    emacs.order(command);\n  }\n  emacs.print();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cstdio>\nusing namespace std;\n\nint crow = 0, ccol = 0;\nstring buf = \"\";\nvector<string> lines;\n\nvoid input() {\n    while(1) {\n        string s;\n        getline(cin, s);\n        if(s == \"END_OF_TEXT\") break;\n        lines.push_back(s + \"\\n\");\n    }\n}\n\nvoid assign_buf(string s, bool is_cl_only=false) {\n    buf = s;\n    if(!is_cl_only) {\n        assert(buf.back() == '\\n');\n        buf.pop_back();\n    }\n}\n\nbool is_col_begin() { return ccol == 0; }\nbool is_col_end() { return ccol + 1 == lines[crow].size(); }\nbool is_row_begin() { return crow == 0; }\nbool is_row_end() { return crow + 1 == lines.size(); }\n\nint get_col_begin() { return 0; }\nint get_col_end() { return (int)lines[crow].size() - 1; }\nint get_row_begin() { return 0; }\nint get_row_end() { return (int)lines.size() - 1; }\n\nvoid up()   { crow = max(get_row_begin(), crow - 1); ccol = 0; }\nvoid down() { crow = min(get_row_end()  , crow + 1); ccol = 0; }\nvoid right() {\n    if(is_col_end() && is_row_end()) return;\n\n    if(is_col_end()) down(), ccol = get_col_begin();\n    else             ccol++;\n}\nvoid left() {\n    if(is_col_begin() && is_row_begin()) return;\n\n    if(is_col_begin()) up(), ccol = get_col_end();\n    else               ccol--;\n}\n\nvoid delete_char() {\n    if(is_col_end()) {\n        if(is_row_end()) return;\n        string &target = lines[crow];\n        target.pop_back();\n        target += lines[crow + 1];\n        lines.erase(lines.begin() + crow + 1);\n    }\n    else {\n        lines[crow].erase(lines[crow].begin() + ccol);\n    }\n}\n\nvoid show_state(char op) {\n    printf(\"operate [%c]: row = %d, col = %d\\n\", op, crow, ccol);\n    for(auto x : lines) cout << x;\n}\n\nbool operate(char op) {\n    assert(crow >= 0 && ccol >= 0);\n    assert(crow + 1 <= lines.size());\n    assert(ccol + 1 <= lines[crow].size());\n\n    if(op == 'a') {\n        ccol = get_col_begin();\n    }\n    if(op == 'e') {\n        ccol = get_col_end();\n    }\n    if(op == 'p') {\n        up();\n    }\n    if(op == 'n') {\n        down();\n    }\n    if(op == 'f') {\n        right();\n    }\n    if(op == 'b') {\n        left();\n    }\n    if(op == 'd') {\n        delete_char();\n    }\n    if(op == 'k') {\n        if(is_col_end()) {\n            if(!is_row_end()) {\n                delete_char();\n                assign_buf(\"\\n\", true);\n            }\n        }\n        string &target = lines[crow];\n        assign_buf(target.substr(ccol));\n        target = target.substr(0, ccol) + \"\\n\";\n    }\n    if(op == 'y') {\n        if(buf.size()) {\n            if(buf == \"\\n\") {\n                string &target = lines[crow];\n                string s1 = target.substr(0, ccol);\n                string s2 = target.substr(ccol);\n\n                target = s1;\n                lines.insert(lines.begin() + crow + 1, s2);\n\n                down();\n            }\n            else {\n                string &target = lines[crow];\n                target.insert(ccol, buf);\n                ccol += buf.size();\n            }\n        }\n    }\n\n    // show_state(op);\n    return op == '-';\n}\n\nint main() {\n    input();\n\n    while(1) {\n        char c; cin >> c;\n        if(operate(c)) break;\n    }\n    for(auto x : lines) {\n        cout << x;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<string> buf;\nint row;\nint column;\nstring rem;\n\nvoid printbuf(){\n  cout << row << ' ' << column << \" \\\"\" << rem << \"\\\"\" << endl;\n  for(int i=0;i<buf.size();i++){\n    cout << buf[i];\n  }\n}\n\nmain(){\n  string in;\n  while(getline(cin, in)){\n    if(in == \"END_OF_TEXT\" /*|| in == \"1\"*/) break;\n    in += '\\n';\n    buf.push_back(in);\n  }\n  char c;\n  row = 0;\n  column = 0;\n  while(cin >> c){\n    if(c == '-') break;\n    switch(c){\n      case 'a':\n        column = 0;\n        break;\n      case 'e':\n        column = (int)buf[row].size()-1;\n        break;\n      case 'p':\n        column = 0;\n        if(row > 0) --row;\n        break;\n      case 'n':\n        column = 0;\n        if(row+1 < buf.size()) ++row;\n        break;\n      case 'f':\n        if(column+1 >= buf[row].size()){\n          if(row+1 < buf.size()){\n            column = 0;\n            ++row;\n          }\n        }else{\n          ++column;\n        }\n        break;\n      case 'b':\n        if(column == 0){\n          if(row > 0){\n            --row;\n            column = (int)buf[row].size()-1;\n          }\n        }else{\n          --column;\n        }\n        break;\n      case 'd':\n        if(column+1 == buf[row].size()){\n          if(row+1 != buf.size()){\n            vector<string>::iterator ite = buf.begin();\n            for(int i=0;i<row;i++) ++ite;\n            buf.erase(ite);\n          }\n        }else{\n          buf[row].erase(column, 1);\n        }\n        break;\n      case 'k':\n        rem = \"\";\n        if(column+1 == buf[row].size()){\n          if(row+1 != buf.size()){\n            vector<string>::iterator ite = buf.begin();\n            for(int i=0;i<row;i++) ++ite;\n            buf.erase(ite);\n            rem += '\\n';\n          }\n        }else{\n          for(int i=column;i+1<buf[row].size();++i){\n            rem += buf[row][i];\n          }\n          string::iterator ite = buf[row].begin();\n          for(int i=0;i<column;i++) ++ite;\n          buf[row].erase(ite, buf[row].end());\n          buf[row] += '\\n';\n        }\n        break;\n      case 'y':\n        if(rem.size() != 0){\n          int irem;\n          string back = buf[row].substr(column);\n          buf[row] = buf[row].substr(0, column);\n          for(irem = 0;irem<rem.size();irem++){\n            buf[row] += rem[irem];\n            ++column;\n            if(rem[irem] == '\\n'){\n              vector<string>::iterator ite = buf.begin();\n              for(int i=0;i<row+1;i++) ++ite;\n              buf.insert(ite, \"\");\n              column = 0;\n              ++row;\n            }\n          }\n          buf[row] += back;\n        }\n        break;\n    }\n    //printbuf();\n  }\n  for(int i=0;i<buf.size();i++){\n    cout << buf[i];\n  }\n  cout << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main(){\n\tstring s[101];\n\tint line = 0;\n\tfor ( string in;cin >> in, in != \"END_OF_TEXT\"; ++line ){\n\t\ts[ line ] = in;\n\t}\n\t\n\tint pX = 0;\n\tint pY = 0;\n\t\n\tstring buf;\n\tfor ( string in; cin >> in, in != \"-\"; ) {\n\t\tif ( in == \"a\" ) {\n\t\t\tpX = 0;\n\t\t} else if ( in == \"e\" ) {\n\t\t\tpX = s[ pY ].length();\n\t\t} else if ( in == \"p\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( 0 < pY ) {\n\t\t\t\t--pY;\n\t\t\t}\n\t\t} else if ( in == \"n\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( pY < line - 1 ) {\n\t\t\t\t++pY;\n\t\t\t}\n\t\t} else if ( in == \"f\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\t++pX;\n\t\t\t} else {\n\t\t\t\tif ( pY < line - 1 ) {\n\t\t\t\t\tpX = 0;\n\t\t\t\t\t++pY;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( in == \"b\" ) {\n\t\t\tif ( 0 < pX ) {\n\t\t\t\t--pX;\n\t\t\t} else {\n\t\t\t\tif ( 0 < pY ) {\n\t\t\t\t\t--pY;\n\t\t\t\t\tpX = s[ pY ].length();\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( in == \"d\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + s[ pY ].substr( pX + 1 );\n\t\t\t} else if ( pY < line - 1 ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\t--line;\n\t\t\t}\n\t\t} else if ( in == \"k\" ) {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\tbuf = s[ pY ].substr( pX );\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t\tpX = s[ pY ].length() - 1;\n\t\t\t} else if ( pY < line - 1 ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\t--line;\n\t\t\t\tbuf = \"\\n\";\n\t\t\t}\n\t\t} else if ( in == \"y\" ) {\n\t\t\tif ( !buf.empty() ) {\n\t\t\t\tif ( buf == \"\\n\" ) {\n\t\t\t\t\tfor ( int i = line - 1; pY < i; --i ) {\n\t\t\t\t\t\ts[ i ] = s[ i - 1 ];\n\t\t\t\t\t}\n\t\t\t\t\ts[ pY + 1 ] = s[ pY ].substr( pX );\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t\t\t++line;\n\t\t\t\t} else {\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + buf + s[ pY ].substr( pX );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor ( int i = 0; i < line; ++i ) cout << s[ i ] << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst ll INF = 1LL << 50;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nsize_t tpos;\nsize_t lpos;\n\nvoid do_a(const vector<string> &text){\n\tlpos = 0;\n}\n\nvoid do_e(const vector<string> &text){\n\tlpos = text[tpos].size();\n}\n\nvoid do_p(const vector<string> &text){\n\tlpos = 0;\n\ttpos = max(0, (int)tpos - 1);\n}\n\nvoid do_n(const vector<string> &text){\n\tlpos = 0;\n\ttpos = min((int)tpos + 1, (int)text.size() - 1);\n}\n\nvoid do_f(const vector<string> &text){\n\tif(lpos == text[tpos].size()){\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\tlpos = 0;\n\t\t\ttpos++;\n\t\t}\n\t}else{\n\t\tlpos++;\n\t}\n}\n\nvoid do_b(const vector<string> &text){\n\tif(lpos != 0){\n\t\tlpos--;\n\t}else{\n\t\tif(tpos > 0){\n\t\t\ttpos--;\n\t\t\tlpos = text[tpos].size();\n\t\t}\n\t}\n}\n\nvoid do_d(vector<string> &text){\n\tif(lpos != text[tpos].size()){\n\t\ttext[tpos].erase(lpos, 1);\n\t}else{\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\ttext[tpos]+=text[tpos+1];\n\t\t\ttext.erase(text.begin() + tpos+1);\n\t\t}\n\t}\n}\n\nvoid do_k(vector<string> &text, string &buffer){\n\tif(lpos == text[tpos].size()){\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\tbuffer = \"\\n\";\n\t\t\tdo_d(text);\n\t\t}\n\t}else{\n\t\tbuffer = string(text[tpos].begin() + lpos, text[tpos].end());\n\t\ttext[tpos].erase(text[tpos].begin() + lpos, text[tpos].end());\n\t}\n}\n\nvoid do_y(vector<string> &text, string &buffer){\n\tif(buffer != \"\"){\n\t\tif(buffer == \"\\n\"){\n\t\t\tstring a(text[tpos].begin() + lpos, text[tpos].end());\n\t\t\ttext[tpos].erase(lpos);\n\t\t\ttext.insert(text.begin() + tpos + 1, a);\n\t\t\ttpos++;\n\t\t\tlpos = 0;\n\t\t}else{\n\t\t\tif(lpos == text[tpos].size()){\n\t\t\t\ttext[tpos] += buffer;\n\t\t\t\tlpos = text[tpos].size();\n\t\t\t}else{\n\t\t\t\ttext[tpos].insert(text[tpos].begin() + lpos, buffer.begin(), buffer.end());\n\t\t\t\tlpos += buffer.size();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid output(const vector<string> &text){\n\trep(i, (int)text.size()) cout << text[i] << endl;\n}\n\nint main(){\n\tstring line;\n\tvector<string> text;\n\tstring buffer;\n\twhile(cin >> line && line != \"END_OF_TEXT\"){\n\t\ttext.push_back(line);\n\t}\n\ttpos = lpos = 0;\n\tchar command;\n\twhile(cin >> command && command != '-'){\n\t\tswitch(command){\n\t\tcase 'a':\n\t\t\tdo_a(text);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tdo_e(text);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tdo_p(text);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tdo_n(text);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tdo_f(text);\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tdo_b(text);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdo_d(text);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tdo_k(text, buffer);\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tdo_y(text, buffer);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t\t//output(text);\n\t\t//cout << tpos << \" \" << lpos << endl;\n\t}\n\toutput(text);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<string> buf;\nint row;\nint column;\nstring rem;\n\nvoid printbuf(){\n  //cout << row << ' ' << column << \" \\\"\" << rem << \"\\\"\" << endl;\n  for(int i=0;i<buf.size();i++){\n    cout << buf[i];\n  }\n}\n\nmain(){\n  string in;\n  while(getline(cin, in)){\n    if(in == \"END_OF_TEXT\"/* || in == \"1\"*/) break;\n    in += '\\n';\n    buf.push_back(in);\n  }\n  char c;\n  row = 0;\n  column = 0;\n  while(cin >> c){\n    if(c == '-') break;\n    switch(c){\n      case 'a':\n        column = 0;\n        break;\n      case 'e':\n        column = (int)buf[row].size()-1;\n        break;\n      case 'p':\n        column = 0;\n        if(row > 0) --row;\n        break;\n      case 'n':\n        column = 0;\n        if(row+1 < buf.size()) ++row;\n        break;\n      case 'f':\n        if(column+1 >= buf[row].size()){\n          if(row+1 < buf.size()){\n            column = 0;\n            ++row;\n          }\n        }else{\n          ++column;\n        }\n        break;\n      case 'b':\n        if(column == 0){\n          if(row > 0){\n            column = 0;\n            --row;\n          }\n        }else{\n          --column;\n        }\n        break;\n      case 'd':\n        if(column+1 == buf[row].size()){\n          if(row+1 != buf.size()){\n            vector<string>::iterator ite = buf.begin();\n            for(int i=0;i<row;i++) ++ite;\n            buf.erase(ite);\n          }\n        }else{\n          buf[row].erase(column, 1);\n        }\n        break;\n      case 'k':\n        rem = \"\";\n        if(column+1 == buf[row].size()){\n          if(row+1 != buf.size()){\n            vector<string>::iterator ite = buf.begin();\n            for(int i=0;i<row;i++) ++ite;\n            buf.erase(ite);\n            rem += '\\n';\n          }\n        }else{\n          for(int i=column;i+1<buf[row].size();++i){\n            rem += buf[row][i];\n          }\n          string::iterator ite = buf[row].begin();\n          for(int i=0;i<column;i++) ++ite;\n          buf[row].erase(ite, buf[row].end());\n          buf[row] += '\\n';\n        }\n        break;\n      case 'y':\n        if(rem.size() != 0){\n          int irem;\n          string back = buf[row].substr(column);\n          buf[row] = buf[row].substr(0, column);\n          for(irem = 0;irem<rem.size();irem++){\n            buf[row] += rem[irem];\n            ++column;\n            if(rem[irem] == '\\n'){\n              vector<string>::iterator ite = buf.begin();\n              for(int i=0;i<row+1;i++) ++ite;\n              buf.insert(ite, \"\");\n              column = 0;\n              ++row;\n            }\n          }\n          buf[row] += back;\n        }\n        break;\n    }\n    //printbuf();\n  }\n  printbuf();\n  cout << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t,u;\nvector<char> tmp;\nvector<char> z;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nvoid yinsert(int,vector<char>);\nvoid xinsert(int,int,char);\nvoid ydelete(int);\nvoid xdelete(int,int);\n\nint main(){\n\n  t.clear();\n  tmp.clear();\n  input();\n  x=y=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n    //cout<<y<<' '<<x<<\" ty\"<<t.size()<<endl;\n  }\n\n  for(int i=0;i<t.size();i++){\n    for(int j=0;j<t[i].size();j++){\n      cout<<t[i][j];\n    }\n  }\n\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    xdelete(y,x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  xdelete(y,x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  ydelete(y+1);\n}\n\nvoid funcK(){\n  tmp.clear();\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.push_back('\\n');\n    }\n    return;\n  }\n  while(t[y][x]!='\\n'){\n    tmp.push_back(t[y][x]);\n    xdelete(y,x);\n  }\n  reverse(tmp.begin(),tmp.end());\n  //funcE();\n}\n\nvoid funcY(){\n  vector<char> z;\n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    while(t[y][x]!='\\n'){\n      z.push_back(t[y][x]);\n      xdelete(y,x);\n    }\n    yinsert(y+1,z);\n    y++;\n    x=0;\n    return;\n  }\n  for(int i=0;i<(int)tmp.size();i++){\n    xinsert(y,x,tmp[i]);\n  }\n  //funcE();\n}\n\nvoid input(){\n  vector<char> a;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n}\n\n\n\n\n\n\n\n\nvoid xinsert(int y,int x,char ch){\n  if(x==(int)t[y].size()){\n    t[y].push_back(ch);\n  }else{\n    \n    z=t[y];\n    t[y].clear();\n    for(int i=0;i<(int)z.size();i++){\n      if(i==x)t[y].push_back(ch);\n      t[y].push_back(z[i]);\n    }\n  }\n}\n\nvoid xdelete(int y,int x){\n  if(x+1==(int)t[y].size()){\n    t[y].pop_back();\n  }else{\n    \n    z=t[y];\n    t[y].clear();\n    for(int i=0;i<(int)z.size();i++){\n      if(i==x)continue;\n      t[y].push_back(z[i]);\n    }\n  }\n}\n\nvoid yinsert(int y,vector<char> ch){\n  if(y==(int)t.size()){\n    t.push_back(ch);\n  }else{\n    u=t;\n    t.clear();\n    for(int i=0;i<(int)u.size();i++){\n      if(i==y)t.push_back(ch);\n      t.push_back(u[i]);\n    }\n  }\n}\n\nvoid ydelete(int y){\n  if(y+1==(int)t.size()){\n    t.pop_back();\n  }else{\n    u=t;\n    t.clear();\n    for(int i=0;i<(int)u.size();i++){\n      if(i==y)continue;\n      t.push_back(u[i]);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main(){\n\tstring str[100];\n\tstring s;\n\tint size = 0;\n\twhile(cin >> s){\n\t\tif(s == \"END_OF_TEXT\") break;\n\t\tstr[size++] = s;\n\t}\n\tchar ch;\n\tstring buf = \"\";\n\tint line = 0, pos = 0;\n\twhile(cin >> ch){\n\t\tif(ch == '-') break;\n\t\tif(ch == 'a') pos = 0;\n\t\tif(ch == 'e') pos = str[line].size();\n\t\tif(ch == 'p'){\n\t\t\tpos = 0;\n\t\t\tif(line!=0) line--;\n\t\t}\n\t\tif(ch == 'n'){\n\t\t\tpos = 0;\n\t\t\tif(line+1!=size) line++;\n\t\t}\n\t\tif(ch == 'f'){\n\t\t\tif(pos != str[line].size()) pos++;\n\t\t\telse if(line+1!=size) { pos = 0; line++; }\n\t\t}\n\t\tif(ch == 'b'){\n\t\t\tif(pos != 0) pos--;\n\t\t\telse if(line!=0) { line--; pos = str[line].size(); }\n\t\t}\n\t\tif(ch == 'd'){\n\t\t\tif(pos != str[line].size()){\n\t\t\t\tstr[line] = str[line].substr(0,pos) + str[line].substr(pos+1);\n\t\t\t} else if(line+1!=size){\n\t\t\t\tstr[line] = str[line] + str[line+1];\n\t\t\t\tfor(int i=line+1;i+1<size;i++){\n\t\t\t\t\tstr[i] = str[i+1];\n\t\t\t\t}\n\t\t\t\tstr[size-1] = \"\";\n\t\t\t\tsize--;\n\t\t\t}\n\t\t}\n\t\tif(ch == 'k'){\n\t\t\tif(pos == str[line].size() && line+1!=size){\n\t\t\t\tstr[line] = str[line] + str[line+1];\n\t\t\t\tfor(int i=line+1;i+1<size;i++){\n\t\t\t\t\tstr[i] = str[i+1];\n\t\t\t\t}\n\t\t\t\tstr[size-1] = \"\";\n\t\t\t\tsize--;\n\t\t\t\tbuf = \" \";\n\t\t\t}\n\t\t\telse if(pos < str[line].size()){\n\t\t\t\tbuf = str[line].substr(pos);\n\t\t\t\tstr[line] = str[line].substr(0,pos);\n\t\t\t}\n\t\t}\n\t\tif(ch == 'y'){\n\t\t\tif(buf == \" \"){\n\t\t\t\tfor(int i=line+1;i<size;i++){\n\t\t\t\t\tstr[i+1] = str[i];\n\t\t\t\t}\n\t\t\t\tsize++;\n\t\t\t\tstr[line+1] = str[line].substr(pos);\n\t\t\t\tstr[line] = str[line].substr(0,pos);\n\t\t\t} else if(buf != \"\"){\n\t\t\t\tstr[line] = str[line].substr(0,pos) + buf + str[line].substr(pos);\n\t\t\t\tpos += buf.size();\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tcout << line << \" \" << pos << endl;\n\t\tfor(int i=0;i<size;i++){\n\t\t\tcout << str[i] << endl;\t\n\t\t}\n\t\tputs(\"\");\n\t\t*/\n\t}\n\tfor(int i=0;i<size;i++){\n\t\tcout << str[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nvector<string> s;\nstring buf = \"\";\nint ci = 0, cj = 0;\n\nvoid input() {\n  string l;\n  while (1) {\n    getline(cin, l);\n    if (l == \"END_OF_TEXT\") {\n      break;\n    }\n    s.push_back(l);\n  }\n}\n\n// カーソルを現在の行の先頭文字に移動する\nvoid op_a() { cj = 0; }\n\n// カーソルを現在の行の行末に移動する\nvoid op_e() { cj = s[ci].size(); }\n\n// 上に行があれば、カーソルを上の行の先頭文字に移動する。\n// 上に行がなければ、カーソルを先頭文字に移動する。\nvoid op_p() {\n  if (ci != 0) \n    --ci;\n  op_a();\n}\n\n// 下に行があれば、カーソルを下の行の先頭文字に移動する。\n// 下に行がなければ、カーソルを先頭文字に移動する。\nvoid op_n() {\n  if (ci != s.size() - 1) \n    ++ci;\n  op_a();\n}\n\n// カーソルが行末にない場合、カーソルを１つ右に移動する \n// カーソルが行末にありかつ下に行がある場合は、\n// カーソルを下の行の先頭文字へ移動する \n// それ以外の場合は何もしない\nvoid op_f() {\n  if (cj != s[ci].size()) {\n    ++cj;\n  } else if (cj == s[ci].size() && ci != s.size() - 1) {\n    op_n();\n  }\n}\n\n// カーソルが先頭文字でないならば、カーソルを１つ左に移動する。\n// カーソルが先頭文字でありかつ上に行がある場合は、\n// カーソルを上の行の行末へ移動する。\n// それ以外の場合は何もしない。\nvoid op_b() {\n  if (cj != 0) {\n    --cj;\n  } else if (cj == 0 && ci != 0) {\n    --ci;\n    op_e();\n  }\n}\n\n// カーソルが文字を指す場合はその文字を削除する。\n// 削除された文字の右側の文字列は左にシフトされる。\n// カーソルが行末を指し下に行がある場合は、\n// 下の行をそのままカーソルの位置に繋げる。以下の行は上にシフトされる。\n// それ以外の場合は何もしない。\nvoid op_d() {\n  if (cj != s[ci].size()) {\n    // prev\n    // s[ci].erase(cj, 1);\n    s[ci] = s[ci].substr(0, cj) + s[ci].substr(cj + 1);\n  } else if (cj == s[ci].size() && ci != s.size() - 1) {\n    // prev\n    // s[ci].erase(cj, 1);\n    // s[ci] += s[ci+1];\n    // s.erase(s.begin() + ci + 1);\n    s[ci] += s[ci+1];\n    s.erase(s.begin() + ci + 1);\n  }\n}\n\n// カーソルが行末にある場合、下に行があれば、\n// d と同じ操作をしバッファに１つの改行を記録する。\n// カーソルが行末にない場合、カーソルが指す文字を含めた\n// 右側すべての文字を切り取りそれをバッファに記録する。\n// カーソルは元の行の行末を指すようになる。全ての記録においてバッファは上書きされる。\n// それ以外の場合は何もしない。(clarification at 14:20)\nvoid op_k() {\n  if (cj == s[ci].size() && ci != s.size() - 1) {\n    // prev\n    // s[ci].erase(cj, 1);\n    // s[ci] += s[ci+1];\n    // s.erase(s.begin() + ci + 1);\n    s[ci] += s[ci+1];\n    s.erase(s.begin() + ci + 1);\n    buf = \"\\n\";\n  } else  {\n    // prev\n    // buf = s[ci].substr(cj);\n    // s[ci].erase(cj);\n    buf = s[ci].substr(cj);\n    s[ci] = s[ci].substr(0, cj);\n  }\n}\n\n// バッファが空の場合はなにもしない。\n// バッファの内容が改行の場合、カーソルが指す文字の直前で改行を行う。\n// カーソルは新しい行の先頭文字へ移動する。\n// バッファの内容が文字列の場合、カーソルの位置にバッファの内容を挿入する。\n// カーソルの位置はもともと指していた文字または行末の場所へ移動する。 \nvoid op_y() {\n  if (buf == \"\") return;\n  if (buf == \"\\n\") {\n    // prev\n    // inserter(s, s.begin() + ci + 1) = s[ci].substr(cj);\n    // s[ci].erase(cj);\n    // ++ci; cj = 0;\n    vector<string>::iterator itr = s.begin();\n    rep(i,ci+1) ++itr;\n    s.insert(itr, s[ci].substr(cj));\n    s[ci] = s[ci].substr(0, cj);\n    ++ci; cj = 0;\n  } else {\n    // prev\n    // s[ci].insert(cj, buf.c_str());\n    // cj += buf.size();\n    s[ci] = s[ci].substr(0, cj) + buf + s[ci].substr(cj);\n    cj += buf.size();\n  }\n}\n\nvoid interpret() {\n  string op;\n  while (1) {\n    getline(cin, op);\n    if (op == \"-\") break;\n    if (op == \"a\") {\n      op_a();\n    } else if (op == \"e\") {\n      op_e();\n    } else if (op == \"p\") {\n      op_p();\n    } else if (op == \"n\") {\n      op_n();\n    } else if (op == \"f\") {\n      op_f();\n    } else if (op == \"b\") {\n      op_b();\n    } else if (op == \"d\") {\n      op_d();\n    } else if (op == \"k\") {\n      op_k();\n    } else if (op == \"y\") {\n      op_y();\n    }\n  }\n  rep(i,s.size()) {\n    // printf(\"%s\\n\", s[i].c_str());\n    cout << s[i] << endl;\n  }\n}\n\nint main() {\n  input();\n  interpret();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<string>\n#include<list>\nusing namespace std;\ntypedef list<string>L;\ntypedef L::iterator I;\nint main()\n{\n\tchar str[256];\n\tL l;\n\twhile(fgets(str,256,stdin),strcmp(str,\"END_OF_TEXT\\n\"))\n\t{\n\t\tstr[strlen(str)-1]=0;\n\t\tl.push_back(str);\n\t}\n\tI row=l.begin(),t;\n\tstring::iterator col=row->begin();\n\tstring buf;\n\twhile(fgets(str,256,stdin),*str-'-')\n\t{\n\t\tswitch(*str)\n\t\t{\n\t\tcase'a':col=row->begin();break;\n\t\tcase'e':col=row->end();break;\n\t\tcase'p':\n\t\t\tif(row!=l.begin())--row;\n\t\t\tcol=row->begin();\n\t\t\tbreak;\n\t\tcase'n':if(row!=l.end())++row;\n\t\t\tcol=row->begin();\n\t\t\tbreak;\n\t\tcase'f':\n\t\t\tif(col!=row->end())++col;\n\t\t\telse if(row!=l.end())++row,col=row->begin();\n\t\t\tbreak;\n\t\tcase'b':\n\t\t\tif(col!=row->begin())--col;\n\t\t\telse if(row!=l.begin())--row,col=row->end();\n\t\t\tbreak;\n\t\tcase'd':\n\t\t\tif(col!=row->end())col=row->erase(col);\n\t\t\telse if(row!=l.end())\n\t\t\t{\n\t\t\t\tt=row;\n\t\t\t\tint s=row->size();\n\t\t\t\t++t;\n\t\t\t\t*row+=*t;\n\t\t\t\tl.erase(t);\n\t\t\t\tcol=row->begin()+s;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase'k':\n\t\t\tif(col!=row->end())\n\t\t\t{\n\t\t\t\tbuf=row->substr(col-row->begin());\n\t\t\t\tcol=row->erase(col,row->end());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbuf=\"\\n\";\n\t\t\t\tt=row;\n\t\t\t\tint s=row->size();\n\t\t\t\t++t;\n\t\t\t\t*row+=*t;\n\t\t\t\tl.erase(t);\n\t\t\t\tcol=row->begin()+s;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase'y':\n\t\t\tif(buf==\"\\n\")\n\t\t\t{\n\t\t\t\tt=row;\n\t\t\t\t++t;\n\t\t\t\tstring s(row->substr(col-row->begin()));\n\t\t\t\tl.insert(t,s);\n\t\t\t\trow->erase(col,row->end());\n\t\t\t\trow=t;\n\t\t\t\tcol=row->begin();\n\t\t\t}\n\t\t\telse if(!buf.empty())\n\t\t\t{\n\t\t\t\tint s=col-row->begin()+buf.size();\n\t\t\t\trow->insert(col-row->begin(),buf);\n\t\t\t\tcol=row->begin()+s;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(t=l.begin();t!=l.end();++t)printf(\"%s\\n\",t->c_str());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY = 0;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n\telse return;\n}\n\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\t//ctrl_d(lines);\n\t\t//buf = \"\\n\";\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring front=\"\";\n\t\tstring rear=\"\";\n\t\tfront = lines[posY].substr(0,posX);\n\t\trear = lines[posY].substr(posX,lines[posY].size()-posX);\t\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX+1);\n\n\t\tlines[posY] = front;\n\t\tdeque<string>::iterator it = lines.begin();\n\t\tadvance(it,posY);\n\t\tlines.insert(it,rear);\n\t}\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(getline(cin,str)){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(cin >> str){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\tif(str == \"d\") ctrl_d(lines);\n\t\tif(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\nusing namespace std;\n\ntypedef long long ll;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nint main(){\n  int size;\n  string s[100];\n  for(size=0;cin>>s[size],s[size]!=\"END_OF_TEXT\";size++){\n    s[size] += '\\n';\n  }\n\n  string buff = \"\";\n  int x = 0, y = 0;\n  char op;\n\n  while(cin>>op,op!='-'){\n    if(op == 'a'){\n      x = 0;\n    }\n    else if(op == 'e'){\n      x = s[y].size() - 1;\n    }\n    else if(op == 'p'){\n      x = 0;\n      if(y != 0){\n        y--;\n      }\n    }\n    else if(op == 'n'){\n      x = 0;\n      if(y != size - 1){\n        y++;\n      }\n    }\n    else if(op == 'f'){\n      if(x < s[y].size() - 1){\n        x++;\n      }\n      else if(y != size-1){\n        y++;\n        x = 0;\n      }\n    }\n    else if(op == 'b'){\n      if(x != 0){\n        x--;\n      }\n      else if(y != 0){\n        y--;\n        x = s[y].size() - 1;\n      }\n    }\n    else if(op == 'd'){\n      if(x != s[y].size() - 1){\n        s[y].erase(s[y].begin() + x);\n      }\n      else if(y != size - 1){\n        s[y].erase(s[y].end()-1);\n        s[y] += s[y+1];\n        for(int i=y+1;i<size-1;i++){\n          s[i] = s[i+1];\n        }\n        size--;\n      }\n    }\n    else if(op == 'k'){\n      if(x != s[y].size() - 1){\n        buff = s[y].substr(x,s[y].size()-x-1);\n        s[y].erase(x,buff.size());\n      }\n      else if(y != size - 1){\n        s[y].erase(s[y].end()-1);\n        s[y] += s[y+1];\n        for(int i=y+1;i<size-1;i++){\n          s[i] = s[i+1];\n        }\n        size--;\n        buff = \"\\n\";\n      }\n    }\n    else if(op == 'y'){\n      if(buff == \"\\n\"){\n        for(int i=size;i>y;i--){\n          s[i] = s[i-1];\n        }\n        size++;\n        string tmp = s[y].substr(x);\n        s[y+1] = tmp;\n        s[y].erase(x,s[y].size()-x-1);\n        y++;\n        x = 0;\n      }\n      else if(buff != \"\"){\n        s[y].insert(x,buff);\n        x += buff.size();\n      }\n    }\n\n    /*\n    cout<<x<<\",\"<<y<<endl;\n    rep(i,size){\n      cout<<s[i];\n    }\n    cout<<\"--\\n\\n\";\n    */\n  }\n\n  rep(i,size){\n    cout<<s[i];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n#define MAX_ROW 105\n#define MAX_COL 1005\n\nint num_row = 0;\nint row_CURSOR,col_CURSOR;\nchar table[MAX_ROW][MAX_COL],work[MAX_COL];\n\n\nint main(){\n\n\twhile(true){\n\n\t\tfgets(table[num_row],MAX_COL,stdin); //スペースあり\n\n\t\tif(table[num_row][0] == 'E' && table[num_row][1] == 'N' && table[num_row][2] == 'D' && table[num_row][3] == '_' &&\n\t\t\ttable[num_row][4] == 'O' && table[num_row][5] == 'F' && table[num_row][6] == '_' && table[num_row][7] == 'T' && table[num_row][8] == 'E' &&\n\t\t\ttable[num_row][9] == 'X' && table[num_row][10] == 'T' && (table[num_row][11] == '\\n' || table[num_row][11] == '\\0')){\n\t\t\tbreak;\n\t\t}\n\t\tint len = strlen(table[num_row]);\n\t\ttable[num_row][len-1] = '\\0';\n\n\t\tnum_row++;\n\t}\n\n\n\t//カーソルの初期位置を設定\n\trow_CURSOR = 0;\n\tcol_CURSOR = 0;\n\n\t//バッファを空にしておく\n\twork[0] = '\\0';\n\n\tchar command[2];\n\n\twhile(true){\n\n\t\tscanf(\"%s\",command);\n\t\tif(command[0] == '-')break;\n\n\t\tswitch(command[0]){\n\t\tcase 'a':\n\t\t\t/*カーソルを現在の行の先頭文字に移動する。*/\n\n\t\t\tcol_CURSOR = 0;\n\t\t\tbreak;\n\n\t\tcase 'e':\n\t\t\t/*カーソルを現在の行の行末に移動する。*/\n\n\t\t\tcol_CURSOR = strlen(table[row_CURSOR]);\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\t/*上に行があれば、カーソルを上の行の先頭文字に移動する。\n\t\t\t上に行がなければ、カーソルを先頭文字に移動する。*/\n\n\t\t\tif(row_CURSOR == 0){\n\n\t\t\t\t//Do nothing\n\n\t\t\t}else{\n\n\t\t\t\trow_CURSOR--;\n\t\t\t}\n\t\t\tcol_CURSOR = 0;\n\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\t/*下に行があれば、カーソルを下の行の先頭文字に移動する。\n\t\t\t下に行がなければ、カーソルを先頭文字に移動する。*/\n\n\t\t\tif(row_CURSOR == num_row-1){\n\n\t\t\t\t//Do nothing\n\n\t\t\t}else{\n\n\t\t\t\trow_CURSOR++;\n\t\t\t}\n\t\t\tcol_CURSOR = 0;\n\n\t\t\tbreak;\n\n\t\tcase 'f':\n\t\t\t/*カーソルが行末にない場合、カーソルを１つ右に移動する。\n\t\t\tカーソルが行末にありかつ下に行がある場合は、カーソルを下の行の先頭文字へ移動する。\n\t\t\tそれ以外の場合は何もしない。*/\n\n\t\t\tif(col_CURSOR < strlen(table[row_CURSOR])){\n\n\t\t\t\tcol_CURSOR++;\n\n\t\t\t}else if(col_CURSOR == strlen(table[row_CURSOR]) && row_CURSOR < num_row-1){\n\n\t\t\t\trow_CURSOR++;\n\t\t\t\tcol_CURSOR = 0;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\t/*カーソルが先頭文字でないならば、カーソルを１つ左に移動する。\n\t\t\tカーソルが先頭文字でありかつ上に行がある場合は、カーソルを上の行の行末へ移動する。\n\t\t\tそれ以外の場合は何もしない。*/\n\n\t\t\tif(col_CURSOR > 0){\n\n\t\t\t\tcol_CURSOR--;\n\n\t\t\t}else if(col_CURSOR == 0 && row_CURSOR > 0){\n\n\t\t\t\trow_CURSOR--;\n\t\t\t\tcol_CURSOR = strlen(table[row_CURSOR]);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\t/*d\n\t\t\tカーソルが【文字を指す場合は】その文字を削除する。削除された文字の右側の文字列は左にシフトされる。\n\t\t\tカーソルが行末を指し下に行がある場合は、下の行をそのままカーソルの位置に繋げる。以下の行は上にシフトされる。\n\t\t\tそれ以外の場合は何もしない。*/\n\n\t\t\tif(col_CURSOR < strlen(table[row_CURSOR])){ //カーソルが文字を指し示す場合\n\n\t\t\t\tfor(int col = col_CURSOR+1; table[row_CURSOR][col-1] != '\\0'; col++){ //左に1文字シフト\n\n\t\t\t\t\ttable[row_CURSOR][col-1] = table[row_CURSOR][col];\n\t\t\t\t}\n\n\t\t\t}else if(row_CURSOR < num_row-1){ //カーソルが行末を指し、下に行がある場合\n\n\t\t\t\t//下の行をそのままカーソルの位置につなげる\n\t\t\t\tstrcpy(table[row_CURSOR]+col_CURSOR,table[row_CURSOR+1]);\n\n\t\t\t\t//以下の行を上にシフトする\n\t\t\t\tfor(int row = row_CURSOR+2; row < num_row; row++){\n\n\t\t\t\t\tstrcpy(table[row-1],table[row]);\n\t\t\t\t}\n\t\t\t\tnum_row--;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'k':\n\t\t\t/*カーソルが行末にある場合、下に行があれば、d と同じ操作をしバッファに１つの改行を記録する。\n\t\t\tカーソルが行末にない場合、カーソルが指す文字を含めた右側【すべての文字】を切り取りそれをバッファに記録する。カーソルは元の行の行末を指すようになる。全ての記録においてバッファは上書きされる。\n\t\t\tそれ以外の場合は何もしない。*/\n\n\t\t\tif(col_CURSOR == strlen(table[row_CURSOR])){ //カーソルが行末にある場合\n\n\t\t\t\tif(row_CURSOR < num_row-1){ //下に行がある\n\n\t\t\t\t\t//dと同じ操作\n\t\t\t\t\tstrcpy(table[row_CURSOR]+col_CURSOR,table[row_CURSOR+1]);\n\n\t\t\t\t\t//以下の行を上にシフトする\n\t\t\t\t\tfor(int row = row_CURSOR+2; row < num_row; row++){\n\n\t\t\t\t\t\tstrcpy(table[row-1],table[row]);\n\t\t\t\t\t}\n\t\t\t\t\tnum_row--;\n\n\t\t\t\t\t//バッファに改行を記録\n\t\t\t\t\twork[0] = '\\n';\n\t\t\t\t\twork[1] = '\\0';\n\t\t\t\t}\n\n\t\t\t}else{ //カーソルが行末にない場合\n\n\t\t\t\tstrcpy(work,table[row_CURSOR]+col_CURSOR);\n\t\t\t\ttable[row_CURSOR][col_CURSOR] = '\\0';\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'y':\n\t\t\t/*バッファが空の場合はなにもしない。\n\t\t\tバッファの内容が改行の場合、カーソルが指す【文字の直前で】改行を行う。カーソルは新しい行の先頭文字へ移動する。\n\t\t\tバッファの内容が文字列の場合、カーソルの位置にバッファの内容を挿入する。カーソルの位置はもともと指していた文字または行末の場所へ移動する。*/\n\n\t\t\tif(work[0] == '\\0')break;\n\n\t\t\tif(work[0] == '\\n'){\n\n\t\t\t\t//下にシフト\n\t\t\t\tfor(int row = num_row-1; row >= row_CURSOR+1; row--){\n\t\t\t\t\tstrcpy(table[row+1],table[row]);\n\t\t\t\t}\n\t\t\t\tstrcpy(table[row_CURSOR+1],table[row_CURSOR]+col_CURSOR);\n\n\t\t\t\ttable[row_CURSOR][col_CURSOR] = '\\0';\n\n\t\t\t\tnum_row++;\n\n\t\t\t\trow_CURSOR++;\n\t\t\t\tcol_CURSOR = 0;\n\n\t\t\t}else{\n\n\t\t\t\tint work_length = strlen(work);\n\n\t\t\t\tfor(int col = strlen(table[row_CURSOR]); col >= col_CURSOR; col--){ //右シフト\n\n\t\t\t\t\ttable[row_CURSOR][col+work_length] = table[row_CURSOR][col];\n\t\t\t\t}\n\n\t\t\t\tfor(int col = 0; col < work_length; col++){\n\n\t\t\t\t\ttable[row_CURSOR][col_CURSOR+col] = work[col];\n\t\t\t\t}\n\n\t\t\t\tcol_CURSOR += work_length;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor(int row = 0; row < num_row; row++){\n\n\t\tprintf(\"%s\\n\",table[row]);\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<string> vs;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nvoid printtext(vs &text,char c,int cur,int line,string buf)\n{\n\tcerr<<\"command: \"<<c<<endl;\n\tcerr<<\"cur: \"<<cur<<\", line: \"<<line<<\", buffer: \"<<buf<<endl;\n\trep(i,text.size())cerr<<text[i]<<endl;\n}\n\nint main()\n{\n\tvs text;\n\tstring tmp,buf;\n\twhile(getline(cin,tmp),tmp!=\"END_OF_TEXT\")text.pb(tmp);\n\t\n\tchar c;\n\tint cur=0,line=0;\n\twhile(cin>>c,c!='-')\n\t{\n\t\tif(c=='a')cur=0;\n\t\telse if(c=='e')cur=text[line].size();\n\t\telse if(c=='p')\n\t\t{\n\t\t\tcur=0;\n\t\t\tif(line>0)line--;\n\t\t}\n\t\telse if(c=='n')\n\t\t{\n\t\t\tcur=0;\n\t\t\tif(line<text.size()-1)line++;\n\t\t}\n\t\telse if(c=='f')\n\t\t{\n\t\t\tif(cur!=text[line].size())cur++;\n\t\t\telse if(line<text.size()-1)line++,cur=0;\n\t\t}\n\t\telse if(c=='b')\n\t\t{\n\t\t\tif(cur!=0)cur--;\n\t\t\telse if(line>0)line--,cur=text[line].size();\n\t\t}\n\t\telse if(c=='d')\n\t\t{\n\t\t\tif(cur<text[line].size())text[line].erase(text[line].begin()+cur);\n\t\t\telse if(cur==text[line].size()&&line<text.size()-1)\n\t\t\t{\n\t\t\t\ttext[line]+=text[line+1];\n\t\t\t\ttext.erase(text.begin()+(line+1));\n\t\t\t}\n\t\t}\n\t\telse if(c=='k')\n\t\t{\n\t\t\tif(cur<text[line].size())\n\t\t\t{\n\t\t\t\tbuf=text[line].substr(cur);\n\t\t\t\ttext[line].erase(text[line].begin()+cur,text[line].end());\n\t\t\t}\n\t\t\telse if(cur==text[line].size()&&line<text.size()-1)\n\t\t\t{\n\t\t\t\ttext[line]+=text[line+1];\n\t\t\t\ttext.erase(text.begin()+(line+1));\n\t\t\t\tbuf=\"\\n\";\n\t\t\t}\n\t\t}\n\t\telse if(c=='y')\n\t\t{\n\t\t\tif(buf.empty())continue;\n\t\t\tif(buf==\"\\n\")\n\t\t\t{\n\t\t\t\ttext.insert(text.begin()+(line+1),text[line].substr(cur));\n\t\t\t\ttext[line].erase(text[line].begin()+cur,text[line].end());\n\t\t\t\tcur=0; line++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttext[line].insert(text[line].begin()+cur,all(buf));\n\t\t\t\tcur+=buf.size();\n\t\t\t}\n\t\t}\n\t\t\n\t\t//printtext(text,c,cur,line,buf);\n\t}\n\trep(i,text.size())cout<<text[i]<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nstring s[102],buf;\nint l,r,N;\n\nvoid a(void){r=0;}\nvoid e(void){r=s[l].size()-1;}\nvoid p(void){\n\tif(l>0)l--;\n\telse r=0;\n}\n\nvoid n(void){\n\tif(l<N-1)l++,r=0;\n\telse r=0;\n}\n\nvoid f(void){\n\tif(r<s[l].size()-1)r++;\n\telse l++,r=0;\n}\n\nvoid b(void){\n\tif(r>0)r--;\n\telse if(l>0)r=s[--l].size();\n}\n\nvoid d(void){\n\tif(r==s[l].size()-1){\n\t\tif(l<N-1){\n\t\t\ts[l]+=s[l+1];\n\t\t\tfor(int i=l+1;i<N-1;i++)s[i]=s[i+1];\n\t\t\tN--;\n\t\t}\n\t}\n\telse s[l].erase(r,1);\n}\n\nvoid k(void){\n\tif(r==s[l].size() && l<N-1)d(),buf=\"\\n\";\n\telse {\n\t\tbuf=s[l].substr(max(0,r-1));\n\t\ts[l].erase(max(0,r-1));\n\t}\n}\n\nvoid y(void){\n\tif(buf.empty())return ;\n\tif(buf==\"\\n\"){\n\t\tfor(int i=N;i>l;i--)s[i]=s[i-1];\n\t\ts[l+1]=s[l].substr(max(0,r-1));\n\t\ts[l].erase(max(0,r-1));\n\t\tl++,r=0,N++;\n\t}\n\telse {\n\t\ts[l].insert(min((int)s[l].size(),r+1),buf);\n\t\tr+=buf.size();\n\t}\n}\n\n\nint main(void){\n\t\n\twhile(getline(cin,s[N])){\n\t\tif(s[N]==\"END_OF_TEXT\")break;\n\t\tN++;\n\t}\n\tl=r=0;\n\tbuf.clear();\n\t\n\t\t\n\tstring C;\n\twhile(cin >> C,C!=\"-\"){\n\t\t\n\t\tif(C==\"a\")a();\n\t\telse if(C==\"e\")e();\n\t\telse if(C==\"p\")p();\n\t\telse if(C==\"n\")n();\n\t\telse if(C==\"f\")f();\n\t\telse if(C==\"b\")b();\n\t\telse if(C==\"d\")d();\n\t\telse if(C==\"k\")k();\n\t\telse if(C==\"y\")y();\n\t}\n\t\n\tfor(int i=0;i<N;i++){\n\t\tif(s[i].empty())break;\n\t\tcout << s[i] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\n\nint main()\n{\t\t\n\tvector<string> snt;\n\tstring buffer;\n\t\n\t\n\tfor(string line; getline(cin, line) && line != \"END_OF_TEXT\";snt.push_back(line));\n\t\n\tpint cur = mp(0, 0); // := first = x, second = y\n\tfor(char com; cin >> com && com != '-';)\n\t{\n\t\tswitch(com)\n\t\t{\n\t\t\t\t/*\n\t\t\t\t a\n\t\t\t\t J[\\ð»ÝÌsÌæª¶ÉÚ®·éB\n\t\t\t\t */\n\t\t\tcase 'a':\n\t\t\t{\n\t\t\t\tcur.first = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t e\n\t\t\t\t J[\\ð»ÝÌsÌsÉÚ®·éB\n\t\t\t\t */\n\t\t\tcase 'e':\n\t\t\t{\n\t\t\t\tcur.first = snt[cur.second].size();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t p\n\t\t\t\t ãÉsª êÎAJ[\\ðãÌsÌæª¶ÉÚ®·éB\n\t\t\t\t ãÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t\t */\n\t\t\tcase 'p':\n\t\t\t{\n\t\t\t\tcur.second -= cur.second != 0;\n\t\t\t\tcur.first = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t n\n\t\t\t\t ºÉsª êÎAJ[\\ðºÌsÌæª¶ÉÚ®·éB\n\t\t\t\t ºÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t\t */\n\t\t\tcase 'n':\n\t\t\t{\n\t\t\t\tcur.second += cur.second + 1 != snt.size();\n\t\t\t\tcur.first = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t f\n\t\t\t\t J[\\ªsÉÈ¢êAJ[\\ðPÂEÉÚ®·éB\n\t\t\t\t J[\\ªsÉ è©ÂºÉsª éêÍAJ[\\ðºÌsÌæª¶ÖÚ®·éB\n\t\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t\t */\n\t\t\tcase 'f':\n\t\t\t{\n\t\t\t\tif(cur.first != snt[cur.second].size())\n\t\t\t\t{\n\t\t\t\t\tcur.first++;\n\t\t\t\t}\n\t\t\t\telse if(cur.second + 1 != snt.size())\n\t\t\t\t{\n\t\t\t\t\tcur.first = 0;\n\t\t\t\t\tcur.second++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t b\n\t\t\t\t J[\\ªæª¶ÅÈ¢ÈçÎAJ[\\ðPÂ¶ÉÚ®·éB\n\t\t\t\t J[\\ªæª¶Å è©ÂãÉsª éêÍAJ[\\ðãÌsÌsÖÚ®·éB\n\t\t\t\t »êÈOÌêÍ½àµÈ¢\n\t\t\t\t */\n\t\t\tcase 'b':\n\t\t\t{\n\t\t\t\tif(cur.first != 0)\n\t\t\t\t{\n\t\t\t\t\tcur.first--;\n\t\t\t\t}\n\t\t\t\telse if(cur.second != 0)\n\t\t\t\t{\n\t\t\t\t\tcur.second--;\n\t\t\t\t\tcur.first = snt[cur.second].size();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t d\n\t\t\t\t J[\\ª¶ðw·êÍ»Ì¶ðí·éBí³ê½¶ÌE¤Ì¶ñÍ¶ÉVtg³êéB\n\t\t\t\t J[\\ªsðwµºÉsª éêÍAºÌsð»ÌÜÜJ[\\ÌÊuÉq°éBÈºÌsÍãÉVtg³êéB\n\t\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t\t */\n\t\t\tcase 'd':\n\t\t\t{\n\t\t\t\tif(cur.first != snt[cur.second].size())\n\t\t\t\t{\n\t\t\t\t\tstring &line = snt[cur.second];\n\t\t\t\t\t\n\t\t\t\t\tline = line.substr(0, cur.first) + line.substr(cur.first + 1);\n\t\t\t\t}\n\t\t\t\telse if(cur.second + 1 != snt.size())\n\t\t\t\t{\n\t\t\t\t\tsnt[cur.second] += snt[cur.second + 1];\n\t\t\t\t\t\n\t\t\t\t\trotate(snt.begin() + cur.second + 1, snt.begin() + cur.second + 2, snt.end());\n\t\t\t\t\t\n\t\t\t\t\tsnt.erase(snt.begin() + snt.size() - 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t k\n\t\t\t\t J[\\ªsÉ éêAºÉsª êÎAd Æ¯¶ìðµobt@ÉPÂÌüsðL^·éB\n\t\t\t\t J[\\ªsÉÈ¢êAJ[\\ªw·¶ðÜß½E¤·×ÄÌ¶ðØèæè»êðobt@ÉL^·éBJ[\\Í³ÌsÌsðw·æ¤ÉÈéBSÄÌL^É¨¢Äobt@Íã«³êéB\n\t\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t\t */\n\t\t\tcase 'k':\n\t\t\t{\n\t\t\t\tif(cur.first == snt[cur.second].size() && cur.second + 1 != snt.size())\n\t\t\t\t{\n\n\t\t\t\t\tsnt[cur.second] += snt[cur.second + 1];\n\n\t\t\t\t\trotate(snt.begin() + cur.second + 1, snt.begin() + cur.second + 2, snt.end());\n\t\t\t\t\t\t\n\t\t\t\t\tsnt.erase(snt.begin() + snt.size() - 1);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t}\n\t\t\t\telse if(cur.first != snt[cur.second].size())\n\t\t\t\t{\n\t\t\t\t\tbuffer = snt[cur.second].substr(cur.first);\n\t\t\t\t\tsnt[cur.second] = snt[cur.second].substr(0, cur.first);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t y\n\t\t\t\t obt@ªóÌêÍÈÉàµÈ¢B\n\t\t\t\t obt@ÌàeªüsÌêAJ[\\ªw·¶Ì¼OÅüsðs¤BJ[\\ÍVµ¢sÌæª¶ÖÚ®·éB\n\t\t\t\t obt@Ìàeª¶ñÌêAJ[\\ÌÊuÉobt@Ìàeð}ü·éB J[\\ÌÊuÍàÆàÆwµÄ¢½¶Ü½ÍsÌêÖÚ®·é\n\t\t\t\t */\n\t\t\tcase 'y':\n\t\t\t{\n\t\t\t\tif(buffer != \"\")\n\t\t\t\t{\n\t\t\t\t\tif(buffer == \"\\n\")\n\t\t\t\t\t{\n\t\t\t\t\t\tstring &line = snt[cur.second];\n\t\t\t\t\t\tsnt.push_back(snt[snt.size() - 1]);\n\t\t\t\t\t\t\n\t\t\t\t\t\trotate(snt.begin() + cur.second + 1, snt.begin() + snt.size() - 2, snt.begin() + snt.size() - 1);\n\t\t\t\t\t\tsnt[cur.second + 1] = line.substr(cur.first);\n\t\t\t\t\t\tline = line.substr(0, cur.first);\n\t\t\t\t\t\t\n\t\t\t\t\t\tcur.second++;\n\t\t\t\t\t\tcur.first = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tstring &line = snt[cur.second];\n\t\t\t\t\t\tline = line.substr(0, cur.first) + buffer + line.substr(cur.first);\n\t\t\t\t\t\t\n\t\t\t\t\t\tcur.first += buffer.size();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\trep(i, snt.size()) cout << snt[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring kaigyou = \"wararaki_wararaki_kaigyo\";\n\nint main()\n{\n\tint p, q, w[101], h;\n\tstring str, buf;\n\tchar ch[101][1001];\n\t\n\twhile(!cin.eof()){\n\t\tgetline(cin, str);\n\t\tfill(w, w+101, 0);\n\t\th = 0;\n\t\twhile(str != \"END_OF_TEXT\"){\n\t\t\tfor(int i = 0; i < str.size(); i++){\n\t\t\t\tch[h][i] = str[i];\n\t\t\t}\n\t\t\tw[h++] = str.size();\n\t\t\tgetline(cin, str);\n\t\t}\n\t\tp = q = 0;\n\t\tbuf = \"\";\n\t\twhile(1){\n\t\t\tgetline(cin, str);\n\t\t\tif(str == \"-\"){\n\t\t\t\tbreak;\n\t\t\t} else if(str == \"a\"){\n\t\t\t\tq = 0;\n\t\t\t} else if(str == \"e\"){\n\t\t\t\tq = w[p];\n\t\t\t} else if(str == \"p\"){\n\t\t\t\tif(p > 0){\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t\tq = 0;\n\t\t\t} else if(str == \"n\"){\n\t\t\t\tif(p < h-1){\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tq = 0;\n\t\t\t} else if(str == \"f\"){\n\t\t\t\tif(q < w[p]){\n\t\t\t\t\tq++;\n\t\t\t\t} else if(p < h-1){\n\t\t\t\t\tp++;\n\t\t\t\t\tq = 0;\n\t\t\t\t}\n\t\t\t} else if(str == \"b\"){\n\t\t\t\tif(q > 0){\n\t\t\t\t\tq--;\n\t\t\t\t} else if(p > 0){\n\t\t\t\t\tp--;\n\t\t\t\t\tq = w[p];\n\t\t\t\t}\n\t\t\t} else if(str == \"d\"){\n\t\t\t\tif(q == w[p]){\n\t\t\t\t\tif(p < h-1){\n\t\t\t\t\t\tfor(int i = 0; i < w[p+1]; i++){\n\t\t\t\t\t\t\tch[p][w[p]+i] = ch[p+1][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tw[p] += w[p+1];\n\t\t\t\t\t\tfor(int i = p+2; i < h; i++){\n\t\t\t\t\t\t\tfor(int j = 0; j < w[i]; j++){\n\t\t\t\t\t\t\t\tch[i-1][j] = ch[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tw[i-1] = w[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tw[--h] = 0;\n\t\t\t\t\t}\n\t\t\t\t} else if(isalpha(ch[p][q])){\n\t\t\t\t\tfor(int i = 0, t = 0; i < w[p]; i++){\n\t\t\t\t\t\tif(i != q){\n\t\t\t\t\t\t\tch[p][t++] = ch[p][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tw[p]--;\n\t\t\t\t}\n\t\t\t} else if(str == \"k\"){\n\t\t\t\tif(q == w[p] && p < h-1){\n\t\t\t\t\tbuf = kaigyou;\n\t\t\t\t\tfor(int i = 0; i < w[p+1]; i++){\n\t\t\t\t\t\tch[p][w[p]+i] = ch[p+1][i];\n\t\t\t\t\t}\n\t\t\t\t\tw[p] += w[p+1];\n\t\t\t\t\tfor(int i = p+2; i < h; i++){\n\t\t\t\t\t\tfor(int j = 0; j < w[i]; j++){\n\t\t\t\t\t\t\tch[i-1][j] = ch[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tw[i-1] = w[i];\n\t\t\t\t\t}\n\t\t\t\t\tw[--h] = 0;\n\t\t\t\t} else if(q < w[p]){\n\t\t\t\t\tbuf = \"\";\n\t\t\t\t\tfor(int i = q; i < w[p]; i++){\n\t\t\t\t\t\tbuf += ch[p][i];\n\t\t\t\t\t}\n\t\t\t\t\tw[p] = q;\n\t\t\t\t}\n\t\t\t} else if(str == \"y\"){\n\t\t\t\tif(buf.size() > 0){\n\t\t\t\t\tif(buf == kaigyou){\n\t\t\t\t\t\tstring tmp = \"\";\n\t\t\t\t\t\tfor(int i = q; i < w[p]; i++){\n\t\t\t\t\t\t\ttmp += ch[p][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tw[p] = q;\n\t\t\t\t\t\tfor(int i = h; i > p; i--){\n\t\t\t\t\t\t\tfor(int j = 0; j < w[i-1]; j++){\n\t\t\t\t\t\t\t\tch[i][j] = ch[i-1][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tw[i] = w[i-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\th++;\n\t\t\t\t\t\tw[p+1] = tmp.size();\n\t\t\t\t\t\tfor(int i = 0; i < w[p+1]; i++){\n\t\t\t\t\t\t\tch[p+1][i] = tmp[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\tp++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstring tmp = \"\";\n\t\t\t\t\t\tfor(int i = 0; i < q; i++){\n\t\t\t\t\t\t\ttmp += ch[p][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp += buf;\n\t\t\t\t\t\tfor(int i = q; i < w[p]; i++){\n\t\t\t\t\t\t\ttmp += ch[p][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int i = 0; i < tmp.size(); i++){\n\t\t\t\t\t\t\tch[p][i] = tmp[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq = w[p] = tmp.size();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w[i]; j++){\n\t\t\t\tcout << ch[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n\n#define rep(i,n)      for(int i=0;i<n;++i)\n\nusing namespace std;\n\nclass editor\n{\nprivate:\n\tvector<string> lines;\n\tint cur_line, cur_col;\n\n\tstring buffer;\n\tbool buf_is_available;\n\npublic:\n\teditor()\n\t\t: cur_line(0), cur_col(0), buf_is_available(false)\n\t{\n\t}\n\n\tvoid add_line(const string &l) { lines.push_back(l); }\n\n\tint tail() { return lines[cur_line].length(); }\n\n\tbool is_first_line() { return cur_line == 0; }\n\tbool is_last_line() { return cur_line + 1 == lines.size(); }\n\tbool is_head_of_line() { return cur_col == 0; }\n\tbool is_tail_of_line() { return cur_col == tail(); }\n\n\t// a\n\tvoid move_to_head() { cur_col = 0; }\n\n\t// e\n\tvoid move_to_tail() { cur_col = tail(); }\n\n\t// p\n\tvoid move_up()\n\t{\n\t\tmove_to_head();\n\t\tif (!is_first_line()) cur_line--;\n\t}\n\n\t// n\n\tvoid move_down()\n\t{\n\t\tmove_to_head();\n\t\tif (!is_last_line()) cur_line++;\n\t}\n\n\t// f\n\tvoid forward()\n\t{\n\t\tif (is_tail_of_line())\n\t\t{\n\t\t\tif (!is_last_line())\n\t\t\t{\n\t\t\t\tcur_line++;\n\t\t\t\tcur_col = 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcur_col++;\n\t\t}\n\t}\n\n\t// b\n\tvoid backward()\n\t{\n\t\tif (is_head_of_line())\n\t\t{\n\t\t\tif (!is_first_line())\n\t\t\t{\n\t\t\t\tcur_line--;\n\t\t\t\tcur_col = tail();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcur_col--;\n\t\t}\n\t}\n\n\t// d\n\tvoid delete_char()\n\t{\n\t\tif (!is_tail_of_line())\n\t\t{\n\t\t\tlines[cur_line].erase(cur_col, 1);\n\t\t}\n\t\telse if (!is_last_line())\n\t\t{\n\t\t\tlines[cur_line] += lines[cur_line + 1];\n\t\t\tlines.erase(lines.begin() + cur_line + 1);\n\t\t}\n\t}\n\n\t// k\n\tvoid cut_tails()\n\t{\n\t\tbuffer = lines[cur_line].substr(cur_col);\n\t\tbuf_is_available = true;\n\t\tif (is_tail_of_line())\n\t\t{\n\t\t\tif (!is_last_line())\n\t\t\t{\n\t\t\t\tlines[cur_line] += lines[cur_line + 1];\n\t\t\t\tlines.erase(lines.begin() + cur_line + 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlines[cur_line] = lines[cur_line].substr(0, cur_col);\n\t\t}\n\t}\n\n\t// y\n\tvoid paste()\n\t{\n\t\tif (!buf_is_available) return;\n\n\t\tif (buffer.empty())\n\t\t{\n\t\t\tlines.insert(lines.begin() + cur_line + 1, lines[cur_line].substr(cur_col));\n\t\t\tlines[cur_line] = lines[cur_line].substr(0, cur_col);\n\t\t\tcur_line++;\n\t\t\tcur_col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlines[cur_line].insert(cur_col, buffer);\n\t\t\tcur_col += buffer.length();\n\t\t}\n\t}\n\n\tvoid print_lines()\n\t{\n\t\trep(i,lines.size())\n\t\t{\n\t\t\tcout << lines[i] << endl;\n\t\t}\n\t}\n};\n\nint main()\n{\n\teditor edit;\n\tstring line;\n\twhile (getline(cin, line), line != \"END_OF_TEXT\") edit.add_line(line);\n\n\tchar c;\n\tfor(;cin>>c, c != '-';)\n\t{\n\t\tswitch (c)\n\t\t{\n\t\tcase 'a': edit.move_to_head(); break;\n\t\tcase 'e': edit.move_to_tail(); break;\n\t\tcase 'p': edit.move_up();      break;\n\t\tcase 'n': edit.move_down();    break;\n\t\tcase 'f': edit.forward();      break;\n\t\tcase 'b': edit.backward();     break;\n\t\tcase 'd': edit.delete_char();  break;\n\t\tcase 'k': edit.cut_tails();    break;\n\t\tcase 'y': edit.paste();        break;\n\t\t}\n\t}\n\tedit.print_lines();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<deque>\nusing namespace std;\n\nclass Emacs {\n\n    private:\n    \n        string buffer;\n        int cursorX;\n        int cursorY;\n        vector<string> body;\n\n    public:\n        Emacs(vector<string> arg) {\n            buffer = \"\";\n            cursorX = 1;\n            cursorY = 1;\n            body = arg;\n        }\n\n        void acceptCommand(char c) {\n            switch (c) {\n                case 'a':\n                    moveCursorMostLeft();\n                    break;\n                case 'e':\n                    moveCursorMostRight();\n                    break;\n                case 'p':\n                    moveCursorUp();\n                    moveCursorMostLeft();\n                    break;\n                case 'n':\n                    moveCursorDown();\n                    moveCursorMostLeft();\n                    break;\n                case 'f':\n                    moveCursorForward();\n                    break;\n                case 'b':\n                    moveCursorBackward();\n                    break;\n                case 'd':\n                    deleteChar();\n                    break;\n                case 'k':\n                    killChar();\n                    break;\n                case 'y':\n                    yankBuffer();\n                    break;\n            }\n        }\n\n        void yankBuffer() {\n            string cl = getCurrentLine();\n            if (buffer == \"\") {\n                return;\n            } else if (buffer == \"!\") {\n                body.push_back(body[body.size() - 1]);\n                for(int i = body.size() - 1; i >= cursorY + 1; i--) {\n                    body[i] = body[i - 1];\n                }\n                body[cursorY] =  cl.substr(cursorX - 1);\n                body[cursorY - 1] = cl.substr(0, cursorX - 1);\n                cursorY += 1;\n                moveCursorMostLeft();\n            } else {\n                body[cursorY - 1]  = cl.substr(0, cursorX - 1) + buffer + cl.substr(cursorX - 1);\n                cursorX += buffer.length();\n            }\n        }\n\n        void deleteChar() {\n\n            string cl = getCurrentLine();\n\n            if (cursorX <= cl.length()) {\n                string tmp1 = cl.substr(0, cursorX - 1);\n                string tmp2 = cl.substr(cursorX);\n                body[cursorY - 1] = tmp1 + tmp2;\n            } else if (cursorY < body.size()) {\n                body[cursorY - 1] = cl + body[cursorY];\n                for(int i = cursorY; i < body.size() - 1; i++) {\n                    body[i] = body[i+1];\n                }\n                body.pop_back();\n            }\n        }\n\n        void killChar() {\n            string cl = getCurrentLine();\n\n            if (cursorX <= cl.length()) {\n                buffer = cl.substr(cursorX - 1);\n                body[cursorY - 1] = cl.substr(0, cursorX - 1);\n            } else {\n                buffer = \"!\";\n                deleteChar();\n            }\n        }\n\n        void moveCursorForward() {\n            if (cursorX <= getCurrentLine().length()) {\n                cursorX += 1;\n            } else if (cursorY < body.size()) {\n                cursorY += 1;\n                moveCursorMostLeft();\n            }\n        }\n\n        void moveCursorBackward() {\n            if (cursorX > 1) {\n                cursorX -= 1;\n            } else if (cursorY > 1) {\n                cursorY -= 1;\n                moveCursorMostRight();\n            }\n        }\n\n        void moveCursorMostLeft() {\n            cursorX = 1;\n        }\n\n        void moveCursorMostRight() {\n            cursorX = body[cursorY - 1].length() + 1;\n        }\n\n        void moveCursorUp() {\n            if(cursorY > 1)    cursorY -= 1;\n        }\n\n        void moveCursorDown() {\n            if(cursorY < body.size())  cursorY += 1;\n        }\n\n        void printBody() {\n            // System.out.printf(\"Cursor: (%d, %d)\\n\", cursorX, cursorY);\n            // System.out.printf(\"Buffer: %s\\n\",   buffer);\n            for (int i = 0; i < body.size(); i++) {\n                cout << body[i] << endl;\n            }\n        }\n\n        string getCurrentLine() {\n            return body[cursorY - 1];\n        }\n\n};\n\n\nint main() {\n\n    vector<string> lines;\n\n    while (true) {\n        string line;\n        getline(cin, line);\n        if (line == \"END_OF_TEXT\") break;\n        lines.push_back(line);\n    }\n\n    Emacs emacs (lines);\n\n    while (true) {\n        char c;\n        cin >> c;\n        if(c == '-')    break;\n        emacs.acceptCommand(c); \n    }\n\n    emacs.printBody();\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nstruct Cursor{ int x, y; Cursor() : x(0), y(0) {} };\n\nvoid convert(vector<string>& snt, Cursor& cur, string& buffer, char com);\n\nint main()\n{\t\t\n\tvector<string> snt;\n\tstring buffer;\n\tCursor cursor;\n\t\n\t\n\tfor(string line; getline(cin, line) && line != \"END_OF_TEXT\"; snt.push_back(line));\n\t\n\t\n\tfor(char com; cin >> com && com != '-'; convert(snt, cursor, buffer, com));\n\n\t\n\trep(i, snt.size()) cout << snt[i] << endl;\n}\n\n\nvoid convert(vector<string>& snt, Cursor& cur, string& buffer, char com)\n{\n\tswitch(com)\n\t{\n\t\t\t/*\n\t\t\t a\n\t\t\t J[\\ð»ÝÌsÌæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'a':\n\t\t{\n\t\t\tcur.x = 0;\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t e\n\t\t\t J[\\ð»ÝÌsÌsÉÚ®·éB\n\t\t\t */\n\t\tcase 'e':\n\t\t{\n\t\t\tcur.x = snt[cur.y].size();\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t p\n\t\t\t ãÉsª êÎAJ[\\ðãÌsÌæª¶ÉÚ®·éB\n\t\t\t ãÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'p':\n\t\t{\n\t\t\tcur.y -= cur.y != 0;\n\t\t\tcur.x = 0;\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t n\n\t\t\t ºÉsª êÎAJ[\\ðºÌsÌæª¶ÉÚ®·éB\n\t\t\t ºÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'n':\n\t\t{\n\t\t\tcur.y += cur.y + 1 != snt.size();\n\t\t\tcur.x = 0;\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t f\n\t\t\t J[\\ªsÉÈ¢êAJ[\\ðPÂEÉÚ®·éB\n\t\t\t J[\\ªsÉ è©ÂºÉsª éêÍAJ[\\ðºÌsÌæª¶ÖÚ®·éB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'f':\n\t\t{\n\t\t\tif(cur.x != snt[cur.y].size())\n\t\t\t{\n\t\t\t\tcur.x++;\n\t\t\t}\n\t\t\telse if(cur.y + 1 != snt.size())\n\t\t\t{\n\t\t\t\tcur.y++;\n\t\t\t\tcur.x = 0;\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t b\n\t\t\t J[\\ªæª¶ÅÈ¢ÈçÎAJ[\\ðPÂ¶ÉÚ®·éB\n\t\t\t J[\\ªæª¶Å è©ÂãÉsª éêÍAJ[\\ðãÌsÌsÖÚ®·éB\n\t\t\t »êÈOÌêÍ½àµÈ¢\n\t\t\t */\n\t\tcase 'b':\n\t\t{\n\t\t\tif(cur.x != 0)\n\t\t\t{\n\t\t\t\tcur.x--;\n\t\t\t}\n\t\t\telse if(cur.y != 0)\n\t\t\t{\n\t\t\t\tcur.y--;\n\t\t\t\tcur.x = snt[cur.y].size();\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t d\n\t\t\t J[\\ª¶ðw·êÍ»Ì¶ðí·éBí³ê½¶ÌE¤Ì¶ñÍ¶ÉVtg³êéB\n\t\t\t J[\\ªsðwµºÉsª éêÍAºÌsð»ÌÜÜJ[\\ÌÊuÉq°éBÈºÌsÍãÉVtg³êéB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'd':\n\t\t{\n\t\t\tif(cur.x != snt[cur.y].size())\n\t\t\t{\n\t\t\t\tstring &line = snt[cur.y];\n\t\t\t\t\n\t\t\t\tline = line.substr(0, cur.x) + line.substr(cur.x + 1);\n\t\t\t}\n\t\t\telse if(cur.y + 1 != snt.size())\n\t\t\t{\n\t\t\t\tsnt[cur.y] += snt[cur.y + 1];\n\t\t\t\t\n\t\t\t\trotate(snt.begin() + cur.y + 1, snt.begin() + cur.y + 2, snt.end());\n\t\t\t\t\n\t\t\t\tsnt.erase(snt.begin() + snt.size() - 1);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t k\n\t\t\t J[\\ªsÉ éêAºÉsª êÎAd Æ¯¶ìðµobt@ÉPÂÌüsðL^·éB\n\t\t\t J[\\ªsÉÈ¢êAJ[\\ªw·¶ðÜß½E¤·×ÄÌ¶ðØèæè»êðobt@ÉL^·éBJ[\\Í³ÌsÌsðw·æ¤ÉÈéBSÄÌL^É¨¢Äobt@Íã«³êéB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'k':\n\t\t{\n\t\t\tif(cur.x == snt[cur.y].size() && cur.y + 1 != snt.size())\n\t\t\t{\n\t\t\t\t\n\t\t\t\tsnt[cur.y] += snt[cur.y + 1];\n\t\t\t\t\n\t\t\t\trotate(snt.begin() + cur.y + 1, snt.begin() + cur.y + 2, snt.end());\n\t\t\t\t\n\t\t\t\tsnt.erase(snt.begin() + snt.size() - 1);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tbuffer = \"\\n\";\n\t\t\t}\n\t\t\telse if(cur.x != snt[cur.y].size())\n\t\t\t{\n\t\t\t\tbuffer = snt[cur.y].substr(cur.x);\n\t\t\t\tsnt[cur.y] = snt[cur.y].substr(0, cur.x);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t y\n\t\t\t obt@ªóÌêÍÈÉàµÈ¢B\n\t\t\t obt@ÌàeªüsÌêAJ[\\ªw·¶Ì¼OÅüsðs¤BJ[\\ÍVµ¢sÌæª¶ÖÚ®·éB\n\t\t\t obt@Ìàeª¶ñÌêAJ[\\ÌÊuÉobt@Ìàeð}ü·éB J[\\ÌÊuÍàÆàÆwµÄ¢½¶Ü½ÍsÌêÖÚ®·é\n\t\t\t */\n\t\tcase 'y':\n\t\t{\n\t\t\tif(buffer != \"\")\n\t\t\t{\n\t\t\t\tif(buffer == \"\\n\")\n\t\t\t\t{\n\t\t\t\t\tstring &line = snt[cur.y];\n\t\t\t\t\tsnt.push_back(snt[snt.size() - 1]);\n\t\t\t\t\t\n\t\t\t\t\trotate(snt.begin() + cur.y + 1, snt.begin() + snt.size() - 2, snt.begin() + snt.size() - 1);\n\t\t\t\t\tsnt[cur.y + 1] = line.substr(cur.x);\n\t\t\t\t\tline = line.substr(0, cur.x);\n\t\t\t\t\t\n\t\t\t\t\tcur.y++;\n\t\t\t\t\tcur.x = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstring &line = snt[cur.y];\n\t\t\t\t\tline = line.substr(0, cur.x) + buffer + line.substr(cur.x);\n\t\t\t\t\t\n\t\t\t\t\tcur.x += buffer.size();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[1024];\nstring buf;\nint lines;\nvoid delete_line(int y)\n{\n    for (int i = y; y < lines; ++y)\n\ts[i] = s[i + 1];\n    s[--lines] = \"\";\n    if (lines <= 0)\n\tlines = 1;\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; ++i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    while (true)\n    {\n\tstring t;\n\tgetline(cin, t);\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines++] = t;\n    }\n    if (lines == 0)\n    {\n\tcout << \"\" << endl;\n\treturn 0;\n    }\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    y = max(0, --y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    y = min(lines - 1, ++y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y + 1 != lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t\tx = 0, --y;\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t\ts[y].erase(x, 1);\n\t    else\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t    }\n\t    break;\n\t}\n\tcase 'k':\n\t{\n\t    if (x == s[y].size())\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    else if (!s[y].empty())\n\t    {\n\t\tbuf = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\tif (!s[y].empty())\n\t\t{\n\t\t    s[y + 1] = s[y].substr(x);\n\t\t    s[y].erase(x);\n\t\t}\n\t\tx = 0, ++y;\n\t    }\n\t    else if (!buf.empty())\n\t\ts[y] += buf;\n\t    break;\n\t}\n\t}\n\n\ty = max(0, y);\n\tx = max(0, min(x, (int)s[y].size()));\n    }\n\n    for (int i = 0; i < lines; ++i)\n\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvoid doA(int *l, int *c, string &s, string &b, vector<string> &v) {\n  *c = 0;\n}\n\nvoid doE(int *l, int *c, string &s, string &b, vector<string> &v) {\n  *c = s.size();\n}\n\nvoid doP(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*l > 0)\n    *l -= 1;\n  *c = 0;\n}\n\nvoid doN(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*l < v.size()-1)\n    *l += 1;\n  *c = 0;\n}\n\nvoid doF(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c < s.size()) {\n    *c += 1;\n  } else if (*l < v.size()-1){\n    *l += 1;\n    *c = 0;\n  }\n}\n\nvoid doB(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c > 0) {\n    *c -= 1;\n  } else if (*l > 0) {\n    *l -= 1;\n    *c = v[*l].size();\n  }\n}\n\nvoid doD(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c < s.size()) {\n    s.erase(*c, 1);\n  } else if (*l < v.size()-1) {\n    s.append(v[*l+1]);\n    vector<string>::iterator itr = v.begin() + *l + 1;\n    v.erase(itr);\n  }\n}\n\nvoid doK(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c == s.size() && *l < v.size()-1) {\n    doD(l, c, s, b, v);\n    b = \"\\n\";\n  } else if (*c < s.size()) {\n    b = s.substr(*c, s.size() - *c);\n    s.erase(*c, s.size() - *c);\n    *c = s.size();\n  }\n}\n\n\nvoid doY(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (b.empty()) {\n    return;\n  } else if (b == \"\\n\") {\n    doK(l, c, s, b, v);\n    vector<string>::iterator itr = v.begin() + *l + 1;\n    v.insert(itr, \"\");\n    b = \"\\n\";\n    *l++;\n    *c = 0;\n  } else {\n    s.insert(*c, b);\n    *c = s.size();\n  }\n}\n\nint main(int argc, char *argv[]) {\n  string buf;\n  vector<string> strs;\n  while (true) {\n    string s;\n    getline(cin, s);\n    if (s == \"END_OF_TEXT\")\n      break;\n    strs.push_back(s);\n  }\n  int line = 0, chrc = 0;\n  while (true) {\n    char c;\n    cin >> c;\n    if (c == '-')\n      break;\n    else if (c == 'a')\n      doA(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'e')\n      doE(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'p')\n      doP(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'n')\n      doN(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'f')\n      doF(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'b')\n      doB(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'd')\n      doD(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'k')\n      doK(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'y')\n      doY(&line, &chrc, strs[line], buf, strs);\n  }\n\n  for (int i = 0; i < strs.size(); i++)\n    cout << strs[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[110];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tif(i<110) t[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tif(row<110) col = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 && row < 110 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row < 110 && row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( row < 110 && col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else if( row < 110 ){\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\t/*if( buf != \"\" ){\n\t\t\t\tif( row < 110 && buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line+1 < 110 && line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\tt[row+1] = t[row].substr( col );\n\t\t\t\t\tt[row].erase( col );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else if( row < 110 ){\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}*/\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int x=0;\n  list<string> s;\n  string t,b;\n  while(getline(cin,t),t!=\"END_OF_TEXT\")\n    s.push_back(t);\n  list<string>::iterator y=s.begin();\n  char c;\n  while(cin>>c,c!='-'){\n    switch(c){\n    case 'a':\n      x=0;\n      break;\n    case 'e':\n      x=(*y).length();\n      break;\n    case 'p':\n      x=0;\n      if(y!=s.begin())\n\t--y;\n      break;\n    case 'n':\n      x=0;\n      ++y;\n      if(y==s.end())\n\t--y;\n      break;\n    case 'f':\n      if(x==(int)(*y).length()){\n\t++y;\n\tif(y==s.end())\n\t  --y;\n\telse\n\t  x=0;\n      }else{\n\t++x;\n      }\n      break;\n    case 'b':\n      if(x){\n\t--x;\n      }else{\n\tif(y!=s.begin()){\n\t  --y;\n\t  x=(*y).length();\n\t}\n      }\n      break;\n    case 'd':\n      if(x==(int)(*y).length()){\n\tlist<string>::iterator it=y;\n\t++it;\n\tif(it!=s.end()){\n\t  (*y)+=(*it);\n\t  s.erase(it);\n\t}\n      }else{\n\t(*y).erase(x,1);\n      }\n      break;\n    case 'k':\n      if(x==(int)(*y).length()){\n\tlist<string>::iterator it=y;\n\t++it;\n\tif(it!=s.end()){\n\t  (*y)+=(*it);\n\t  s.erase(it);\n\t  b=\"\\n\";\n\t}\n      }else{\n\tb=(*y).substr(x);\n\t(*y).erase(x);\n      }\n      break;\n    case 'y':\n      if(0){\n      }else if(b==\"\"){\n      }else if(b==\"\\n\"){\n\tstring u=(*y).substr(x);\n\t(*y).erase(x);\n\t++y;\n\ty=s.insert(y,u);\n\tx=0;\n      }else{\n\t(*y).insert(x,b);\n\tx+=b.length();\n      }\n      break;\n    }\n  }\n  for(y=s.begin();y!=s.end();++y)\n    cout<<*y<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  vector<string> v;\n  string s;\n  char c;\n  while(getline(cin,s) && s!=\"END_OF_TEXT\") v.push_back(s);\n  int x=0,y=0;\n  string b=\"\";\n  while(cin >> c && c!='-') {\n    if(c=='a') y=0;\n    if(c=='e') y=v[x].size();\n    if(c=='p') {\n      if(x) x--;\n      y=0;\n    }\n    if(c=='n') {\n      if(x<v.size()-1) x++;\n      y=0;\n    }\n    if(c=='f') {\n      if(y<v[x].size()) y++;\n      else if(x<v.size()-1) {\n        x++;\n        y=0;\n      }\n    }\n    if(c=='b') {\n      if(y) y--;\n      else if(x) {\n        x--;\n        y=v[x].size();\n      }\n    }\n    if(c=='d') {\n      if(y<v[x].size()) v[x].erase(v[x].begin()+y);\n      else if(x<v.size()-1) {\n        v[x]+=v[x+1];\n        v.erase(v.begin()+x+1);\n      }\n    }\n    if(c=='k') {\n      if(y<v[x].size()) {\n        b=v[x].substr(y);\n        v[x]=v[x].substr(0,y);\n      } else if(x<v.size()-1) {\n        b=\"\\n\";\n        v[x]+=v[x+1];\n        v.erase(v.begin()+x+1);\n      }\n    }\n    if(c=='y') {\n      if(b==\"\\n\") {\n        v.insert(v.begin()+x+1,v[x].substr(y));\n        v[x]=v[x].substr(0,y);\n        x++;\n        y=0;\n      } else {\n        v[x].insert(y,b);\n        y+=b.size();\n      }\n    }\n  }\n  for(int i=0; i<v.size(); i++) cout << v[i] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Author: FreePascal\n * Created Time:  2011/8/31 14:37:10\n * File Name: 8331d.cpp\n */\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <deque>\n#include <list>\n#include <stack>\nusing namespace std;\n#define out(v) cerr << #v << \": \" << (v) << endl\n#define SZ(v) ((int)(v).size())\nconst int maxint = -1u>>1;\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\nvector<string> text;\nstring buf,cmd;\nint x = 0,y = 0;\nvoid a(){\n    y = 0;\n}\nvoid e(){\n    y = text[x].size();\n}\nvoid p(){\n    if(x>0) x--;\n    y = 0;\n}\nvoid n(){\n    if(x<text.size()-1) x++;\n    y = 0;\n}\nvoid f(){\n    if( y == text[x].size() && x == text.size()-1) return ;\n    y++;\n    if(y > text[x].size()){\n        x++;\n        y = 0;\n    }\n}\nvoid b(){\n    if(y == 0 && x == 0) return;\n    y--;\n    if(y<0){\n        x--; \n        y = text[x].size();\n    }\n}\nvoid d(){\n    if(y < text[x].size()) {\n        text[x].erase(y,1);\n    }\n    else if(x<text.size()-1)\n    {\n        text[x] += text[x+1];\n        //text.erase(x+1);\n        for(int i = x;i < text.size()-1;i++)\n            text[i] = text[i+1];\n        text.resize(text.size()-1);\n    }\n}\nvoid k(){\n    if(y == text[x].size()) {\n        d();\n        buf = \"\\n\";\n    }\n    else\n    {\n        buf = text[x].substr(y);\n        text[x].erase(y);\n        y = text[x].size();\n    }\n}\nvoid cy(){\n    if( buf == \"\") return;\n    else if(buf == \"\\n\"){\n        string tm;\n        tm = text[x].substr(y);\n        text[x].erase(y);\n        //text.insert(x);\n        text.push_back(\"\");\n        for(int i = x+2;i<text.size();i++)\n            text[i] = text[i-1];\n        text[x+1] = tm;\n        x++;\n        y = 0;\n    }\n    else\n    {\n        text[x].insert(y,buf);\n        y+=buf.size();\n    }\n}\nvoid init(){\n    string s;\n    while(getline(cin,s) && s!= \"END_OF_TEXT\")\n        text.push_back(s);\n    while(cin>>s && s!=\"-\")\n        cmd+=s;\n}\nvoid work(){\n    for(int i = 0;i < cmd.size();i++)\n    {\n        switch(cmd[i]){\n            case 'a': a();break;\n            case 'e': e();break;\n            case 'p': p();break;\n            case 'n': n();break;\n            case 'f': f();break;\n            case 'b': b();break;\n            case 'd': d();break;\n            case 'k': k();break;\n            case 'y': cy();break;\n        } \n}\n}\nvoid prnt(){\n    for(int i = 0;i < text.size();i ++)\n        cout<<text[i]<<endl;\n}\n\nint main() {\n    init();\n    work();\n    prnt();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\nvector<string> text;\nstring buf;\n\nint row, col;\n\nvoid func_a(){\n\tcol = 0;\n}\n\nvoid func_e(){\n\tcol = text[row].size() - 1;\n}\n\nvoid func_p(){\n\tif (row > 0) row--;\n\tfunc_a();\n}\n\nvoid func_n(){\n\tif (row < text.size() - 1) row++;\n\tfunc_a();\n}\n\nvoid func_f(){\n\tif (col < text[row].size() - 1) col++;\n\telse if (row < text.size() - 1){\n\t\tfunc_n();\n\t}\n}\n\nvoid func_b(){\n\tif (col > 0) col--;\n\telse if (row > 0){\n\t\tfunc_p();\n\t\tfunc_e();\n\t}\n}\n\nvoid func_d(){\n\tif (col < text[row].size() - 1) text[row].erase(col, 1);\n\telse if (row < text.size() - 1){\n\t\ttext[row].erase(text[row].end() - 1);\n\t\ttext[row] += text[row + 1];\n\t\ttext.erase(text.begin() + row + 1);\n\t}\n}\n\nvoid func_k(){\n\tif (col < text[row].size() - 1){\n\t\tbuf = text[row].substr(col, text[row].size() - col - 1);\n\t\ttext[row].erase(col, text[row].size() - 1);\n\t}\n\telse if (row < text.size() - 1){\n\t\tfunc_d();\n\t\tbuf = \"\\n\";\n\t}\n}\n\nvoid func_y(){\n\tif (!buf.empty()){\n\t\tif (buf == \"\\n\"){\n\t\t\ttext.insert(text.begin() + row + 1, text[row].substr(col, text[row].size() - 1));\n\t\t\ttext[row].erase(col, text[row].size() - 1);\n\t\t\ttext[row] += '$';\n\t\t}\n\t\telse {\n\t\t\ttext[row].insert(col, buf);\n\t\t\tcol += buf.size();\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstring in;\n\tchar cmd;\n\n\twhile (getline(cin, in), in != \"END_OF_TEXT\"){\n\t\ttext.push_back(in + '$');\n\t}\n\t\n\tcol = row = 0;\n\tbuf.clear();\n\n\twhile (cin >> cmd, cmd != '-'){\n\t\tswitch (cmd){\n\t\t  case 'a': func_a(); break;\n\t\t  case 'e':\tfunc_e(); break;\n\t\t  case 'p':\tfunc_p(); break;\n\t\t  case 'n': func_n(); break;\n\t\t  case 'f': func_f(); break;\n\t\t  case 'b':\tfunc_b(); break;\n\t\t  case 'd':\tfunc_d(); break;\n\t\t  case 'k': func_k(); break;\n\t\t  case 'y': func_y(); break;\n\t\t}\n#if 0\n\t\tprintf(\"col:%d row:%d\\n\", col, row);\n\t\tputs(\"status:\");\n\t\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\t\tcout << *it << endl;\n\t\t}\n\t\tputs(\"buffer:\");\n\t\tcout << buf << endl;\n#endif\n\t}\n\n\t\n\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\tcout << it->substr(0, it->size() - 1) << endl;\n\t}\n\n\tthrow \"End File Exception\";\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n  vector<string> text(110);\n  int line = 0;\n  for(;line<11;line++){\n    getline(cin,text[line],'\\n');\n    if (text[line]==\"END_OF_TEXT\")\n      break;\n  }\n  string buffer;\n  int cur[2];\n  cur[0] = 0;//0s\n  cur[1] = 0;//0¶Ú\n\n  while(true){\n    char com;\n    cin >> com;\n    if (com == '-')\n      break;\n    switch (com){\n    case 'a':\n      cur[1] = 0;\n      break;\n    case 'e':\n      cur[1] = (int)text[cur[0]].size();\n      break;\n    case 'p':\n      if (cur[0]>0)\n\tcur[0]--;\n      cur[1]=0;\n      break;\n    case 'n':\n      if (cur[0]<line-1)\n\tcur[0]++;\n      cur[1]=0;\n      break;\n    case 'f':\n      if (cur[1]<(int)text[cur[0]].size())\n\tcur[1]++;\n      else\n\tif (cur[0]<line-1){\n\t  cur[0]++;\n\t  cur[1]=0;\t\n\t}\n      break;\n    case 'b':\n      if (cur[1]>0)\n\tcur[1]--;\n    else\n      if (cur[0]>0){\n\tcur[0]--;\n\tcur[1]=(int)text[cur[0]].size();\t\n      }\n      break;\n    case 'd':\n      if (cur[1]<(int)text[cur[0]].size()){\n\ttext[cur[0]] = text[cur[0]].substr(0,cur[1])+text[cur[0]].substr(cur[1]+1);\n      }\n      else\n\tif (cur[0]<line-1){\n\t  text[cur[0]] = text[cur[0]]+text[cur[0]+1];\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i] = text[i+1];\n\t  line--;\n\t}\n      break;\n    case 'k':\n      if (cur[1]==(int)text[cur[0]].size()){\n\tif (cur[0]<line-1){\n\t  text[cur[0]] = text[cur[0]]+text[cur[0]+1];\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i] = text[i+1];\n\t  line--;\n\t  buffer = \"\\n\";\n\t}\n      }\n      else{\n\tbuffer = text[cur[0]].substr(cur[1]);\n\ttext[cur[0]] = text[cur[0]].substr(0,cur[1]);\n\tcur[1] = (int)text[cur[0]].size();\n      }\n      break;\n    case 'y':\n      if (buffer.empty())\n\tbreak;\n      else{\n\tif (buffer == \"\\n\"){\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i+1] = text[i];    \n\t  line++;\n\t  text[cur[0]] = text[cur[0]].substr(cur[1]);\n\t  text[cur[0]+1] = text[cur[0]].substr(0,cur[1]);\n\t}\n\telse{\n\t  text[cur[0]] = text[cur[0]].substr(0,cur[1])+buffer+text[cur[0]].substr(cur[1]);\n\t}\n      }\n    }\n    /*  for(int i=0;i<line;i++)\n\tcout << text[i] << endl;\n\tcout << \"(\" << cur[0] << \",\" << cur[1] << \")\" << endl;\n\tcout << \"#\" << endl;*/\n  }\n  for(int i=0;i<line;i++)\n    cout << text[i] << endl;\n  return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass state{\npublic:\n  state(string str = \"\"):str(str){\n    cursor = 0;\n    buffer = \"\";\n  }\n\n  void typeA(){\n    for(int i=cursor;i>=0;i--){\n      cursor = i;\n      if(i > 0 && str[i-1] == '\\n') break;\n    }\n\n    assertion();\n  }\n\n  void typeE(){\n    for(int i=cursor;i<str.size();i++){\n      cursor = i;\n      if(str[i] == '\\n') break;\n    }\n\n    assertion();\n  }\n\n  void typeP(){\n    bool isUpper = false;\n    for(int i=cursor;i>=0;i--){\n      if(i == 0 || i > 0 && str[i-1] == '\\n'){\n        cursor = i;\n        if(isUpper) break;\n        else isUpper = true;\n      }\n    }\n\n    assertion();\n  }\n\n  void typeN(){\n    bool isDowner = false;\n    for(int i=cursor;i<str.size();i++){\n      if(str[i] == '\\n' && i < (int)str.size() - 1){\n        isDowner = true;\n        cursor = i + 1;\n        break;\n      }\n    }\n\n    if(!isDowner){\n      typeA();\n    }\n\n    assertion();\n  }\n\n  void typeF(){\n    if(cursor < (int)str.size()-1){\n      cursor++;\n    }\n\n    assertion();\n  }\n  \n  void typeB(){\n    if(cursor > 0) {\n      cursor--;\n    }\n\n    assertion();\n  }\n\n  void typeD(){\n    if(cursor < (int)str.size()-1){\n      str.erase(str.begin()+cursor);\n    }\n\n    assertion();\n  }\n\n  void typeK(){\n    if(str[cursor] == '\\n' && cursor < (int)str.size()-1){\n      typeD();\n      buffer = \"\\n\";\n    } else if(str[cursor] != '\\n'){\n      for(int i=cursor+1;i<(int)str.size();i++){\n        if(str[i] == '\\n'){\n          buffer = string(str.begin()+cursor, str.begin()+i);\n          str.erase(str.begin()+cursor, str.begin()+i);\n        }\n      }\n    }\n\n    assertion();\n  }\n\n  void typeY(){\n    str.insert(str.begin()+cursor, buffer.begin(), buffer.end());\n    cursor += buffer.size();\n    //buffer = \"\";\n\n    assertion();\n  }\n\n  string toString(){\n    return str;\n  }\n\n  // エラーチェック\n  void assertion(){\n    assert(str.size() > 0 && str[str.size()-1] == '\\n');\n  }\n\nprivate:\n  int cursor;\n  string str, buffer;\n};\n\nstring inputStr(){\n  string str = \"\", in;\n  while(cin >> in){\n    if(in == \"END_OF_TEXT\") break;\n    str += in + '\\n';\n  }\n  return str;\n}\n\nvoid executeCommand(state &dat){\n  string command;\n  while(cin >> command){\n    if(command == \"-\") break;\n    else if(command == \"a\") dat.typeA();\n    else if(command == \"e\") dat.typeE();\n    else if(command == \"p\") dat.typeP();\n    else if(command == \"n\") dat.typeN();\n    else if(command == \"f\") dat.typeF();\n    else if(command == \"b\") dat.typeB();\n    else if(command == \"d\") dat.typeD();\n    else if(command == \"k\") dat.typeK();\n    else if(command == \"y\") dat.typeY();\n    else assert(false);\n  }\n  cout << dat.toString() << flush;\n}\n\nint main(){\n  state dat = state(inputStr());\n  executeCommand(dat);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass state{\npublic:\n  state(string str = \"\"):str(str){\n    cursor = 0;\n    buffer = \"\";\n    assertion();\n  }\n\n  void typeA(){\n    for(int i=cursor;i>=0;i--){\n      cursor = i;\n      if(i > 0 && str[i-1] == '\\n') break;\n    }\n    assertion();\n  }\n\n  void typeE(){\n    for(int i=cursor;i<str.size();i++){\n      cursor = i;\n      if(str[i] == '\\n') break;\n    }\n    assertion();\n  }\n\n  void typeP(){\n    bool isUpper = false;\n    for(int i=cursor;i>=0;i--){\n      if(i == 0 || i > 0 && str[i-1] == '\\n'){\n        cursor = i;\n        if(isUpper) break;\n        else isUpper = true;\n      }\n    }\n    assertion();\n  }\n\n  void typeN(){\n    bool isDowner = false;\n    for(int i=cursor;i<str.size();i++){\n      if(str[i] == '\\n' && i < (int)str.size() - 1){\n        isDowner = true;\n        cursor = i + 1;\n        break;\n      }\n    }\n\n    if(!isDowner){\n      typeA();\n    }\n    assertion();\n  }\n\n  void typeF(){\n    if(cursor < (int)str.size()-1){\n      cursor++;\n    }\n    assertion();\n  }\n  \n  void typeB(){\n    if(cursor > 0) {\n      cursor--;\n    }\n    assertion();\n  }\n\n  void typeD(){\n    if(cursor < (int)str.size()-1){\n      str.erase(str.begin()+cursor);\n    }\n    assertion();\n  }\n\n  void typeK(){\n    if(str[cursor] == '\\n' && cursor < (int)str.size()-1){\n      typeD();\n      buffer = \"\\n\";\n    } else if(str[cursor] != '\\n'){\n      for(int i=cursor+1;i<(int)str.size();i++){\n        if(str[i] == '\\n'){\n          buffer = string(str.begin()+cursor, str.begin()+i);\n          str.erase(str.begin()+cursor, str.begin()+i);\n        }\n      }\n    }\n    assertion();\n  }\n\n  void typeY(){\n    str.insert(str.begin()+cursor, buffer.begin(), buffer.end());\n    cursor += buffer.size();\n    //buffer = \"\";\n    assertion();\n  }\n\n  string toString(){\n    return str;\n  }\n\n  void assertion(){\n    assert(str.size() > 0 && str[str.size()-1] == '\\n');\n  }\n\nprivate:\n  int cursor;\n  string str, buffer;\n};\n\nstring inputStr(){\n  string str = \"\", in;\n  while(cin >> in){\n    if(in == \"END_OF_TEXT\") break;\n    str += in + '\\n';\n  }\n  return str;\n}\n\nvoid executeCommand(state &dat){\n  string command;\n  while(cin >> command){\n    if(command == \"-\") break;\n    else if(command == \"a\") dat.typeA();\n    else if(command == \"e\") dat.typeE();\n    else if(command == \"p\") dat.typeP();\n    else if(command == \"n\") dat.typeN();\n    else if(command == \"f\") dat.typeF();\n    else if(command == \"b\") dat.typeB();\n    else if(command == \"d\") dat.typeD();\n    else if(command == \"k\") dat.typeK();\n    else if(command == \"y\") dat.typeY();\n    else assert(false);\n  }\n  cout << dat.toString() << flush;\n}\n\nint main(){\n  state dat = state(inputStr());\n  executeCommand(dat);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n \nusing namespace std;\n\nclass Text {\npublic:\n    void show(), append(string& s), exec_cmd(char c);\n    Text(){\n        _buf.clear();\n        _col = _row = 0;\n    }\nprivate:\n    vector<string> _text;\n    string _buf;\n    int _col, _row;\n    void a(), e(), p(), n(), f(), b(), d(), k(), y();\n};\n\nvoid Text::show()\n{\n    for (vector<string>::iterator it = _text.begin(); it != _text.end(); it++){\n        cout << *it << endl;\n    }\n}\nvoid Text::append(string& s)\n{\n    _text.push_back(s);\n}\nvoid Text::exec_cmd(char c)\n{\n    switch (c){\n      case 'a': a(); break;\n      case 'e': e(); break;\n      case 'p': p(); break;\n      case 'n': n(); break;\n      case 'f': f(); break;\n      case 'b': b(); break;\n      case 'd': d(); break;\n      case 'k': k(); break;\n      case 'y': y(); break;\n    }\n}\nvoid Text::a(){ _col = 0; }\nvoid Text::e(){ _col = _text[_row].size(); }\nvoid Text::p(){ if (_row > 0) _row--; a(); }\nvoid Text::n(){ if (_row < _text.size() - 1) _row++; a(); }\nvoid Text::f(){\n    if (_col < _text[_row].size()) _col++;\n    else if (_row < _text.size() - 1){\n        a();\n        _row++;\n    }\n}\nvoid Text::b(){\n    if (_col > 0) _col--;\n    else if (_row > 0){\n        _row--;\n        e();\n    }\n}\nvoid Text::d(){\n    if (_col < _text[_row].size()) _text[_row].erase(_col, 1);\n    else if (_row < _text.size() - 1){\n        _text[_row] += _text[_row + 1];\n        _text.erase(_text.begin() + _row + 1);\n    }\n}\nvoid Text::k(){\n    if (_col < _text[_row].size()){\n        _buf = _text[_row].substr(_col, _text[_row].size() - _col);\n        _text[_row] = _text[_row].substr(0, _col);\n    }\n    else if (_row < _text.size() - 1){\n        d();\n        _buf = \"\\n\";\n    }\n}\nvoid Text::y(){\n    if (!_buf.empty()){\n        if (_buf == \"\\n\"){\n            _text.insert(_text.begin() + _row + 1, _text[_row].substr(_col, _text[_row].size() - _col));\n            _text[_row].erase(_col, _text[_row].size() - 1);\n            _row++;\n            a();\n        }\n        else {\n            _text[_row].insert(_col, _buf);\n            _col += _buf.size();\n        }\n    }\n}\n\nint main()\n{\n    Text text;\n\n    string in;\n    while (getline(cin, in), in != \"END_OF_TEXT\"){\n        text.append(in);\n    }\n\n    char cmd;\n    while (cin >> cmd, cmd != '-'){\n        text.exec_cmd(cmd);\n    }\n    text.show();\n\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<string> text;\nstring buf;\n\nint row, col;\n\nvoid func_a(){\n\tcol = 0;\n}\n\nvoid func_e(){\n\tcol = text[row].size() - 1;\n}\n\nvoid func_p(){\n\tif (row > 0) row--;\n\tfunc_a();\n}\n\nvoid func_n(){\n\tif (row < text.size() - 1) row++;\n\tfunc_a();\n}\n\nvoid func_f(){\n\tif (col < text[row].size() - 1) col++;\n\telse if (row < text.size() - 1){\n\t\tfunc_n();\n\t}\n}\n\nvoid func_b(){\n\tif (col > 0) col--;\n\telse if (row > 0){\n\t\tfunc_p();\n\t\tfunc_e();\n\t}\n}\n\nvoid func_d(){\n\tif (col < text[row].size() - 1) text[row].erase(col, 1);\n\telse if (row < text.size() - 1){\n\t\ttext[row].erase(text[row].end() - 1);\n\t\ttext[row] += text[row + 1];\n\t\ttext.erase(text.begin() + row + 1);\n\t}\n}\n\nvoid func_k(){\n\tif (col < text[row].size() - 1){\n\t\tbuf = text[row].substr(col, text[row].size() - col - 1);\n\t\ttext[row].erase(col, text[row].size() - 1);\n\t}\n\telse if (row < text.size() - 1){\n\t\tfunc_d();\n\t\tbuf = \"\\n\";\n\t}\n}\n\nvoid func_y(){\n\tif (!buf.empty()){\n\t\tif (buf == \"\\n\"){\n\t\t\ttext.insert(text.begin() + row + 1, text[row].substr(col, text[row].size() - 1));\n\t\t\ttext[row].erase(col, text[row].size() - 1);\n\t\t\ttext[row] += '$';\n\t\t\tfunc_n();\n\t\t}\n\t\telse {\n\t\t\ttext[row].insert(col, buf);\n\t\t\tcol += buf.size();\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstring in;\n\tchar cmd;\n\n\twhile (getline(cin, in), in != \"END_OF_TEXT\"){\n\t\ttext.push_back(in + '$');\n\t}\n\t\n\tcol = row = 0;\n\tbuf.clear();\n\n\twhile (cin >> cmd, cmd != '-'){\n\t\tswitch (cmd){\n\t\t  case 'a': func_a(); break;\n\t\t  case 'e':\tfunc_e(); break;\n\t\t  case 'p':\tfunc_p(); break;\n\t\t  case 'n': func_n(); break;\n\t\t  case 'f': func_f(); break;\n\t\t  case 'b':\tfunc_b(); break;\n\t\t  case 'd':\tfunc_d(); break;\n\t\t  case 'k': func_k(); break;\n\t\t  case 'y': func_y(); break;\n\t\t}\n#if 0\n\t\tprintf(\"col:%d row:%d\\n\", col, row);\n\t\tputs(\"status:\");\n\t\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\t\tcout << *it << endl;\n\t\t}\n\t\tputs(\"buffer:\");\n\t\tcout << buf << endl;\n#endif\n\t}\n\n\t\n\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\tcout << it->substr(0, it->size() - 1) << endl;\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass state{\npublic:\n  state(string str = \"\"):str(str){\n    cursor = 0;\n    buffer = \"\";\n  }\n\n  void typeA(){\n    for(int i=cursor;i>=0;i--){\n      cursor = i;\n      if(i > 0 && str[i-1] == '\\n') break;\n    }\n    assertion();\n  }\n\n  void typeE(){\n    for(int i=cursor;i<str.size();i++){\n      cursor = i;\n      if(str[i] == '\\n') break;\n    }\n    assertion();\n  }\n\n  void typeP(){\n    bool isUpper = false;\n    for(int i=cursor;i>=0;i--){\n      if(i == 0 || i > 0 && str[i-1] == '\\n'){\n        cursor = i;\n        if(isUpper) break;\n        else isUpper = true;\n      }\n    }\n    assertion();\n  }\n\n  void typeN(){\n    bool isDowner = false;\n    for(int i=cursor;i<str.size();i++){\n      if(str[i] == '\\n' && i < (int)str.size() - 1){\n        isDowner = true;\n        cursor = i + 1;\n        break;\n      }\n    }\n\n    if(!isDowner){\n      typeA();\n    }\n    assertion();\n  }\n\n  void typeF(){\n    if(cursor < (int)str.size()-1){\n      cursor++;\n    }\n    assertion();\n  }\n  \n  void typeB(){\n    if(cursor > 0) {\n      cursor--;\n    }\n    assertion();\n  }\n\n  void typeD(){\n    if(cursor < (int)str.size()-1){\n      str.erase(str.begin()+cursor);\n    }\n    assertion();\n  }\n\n  void typeK(){\n    if(str[cursor] == '\\n' && cursor < (int)str.size()-1){\n      typeD();\n      buffer = \"\\n\";\n    } else if(str[cursor] != '\\n'){\n      for(int i=cursor+1;i<(int)str.size();i++){\n        if(str[i] == '\\n'){\n          buffer = string(str.begin()+cursor, str.begin()+i);\n          str.erase(str.begin()+cursor, str.begin()+i);\n        }\n      }\n    }\n    assertion();\n  }\n\n  void typeY(){\n    str.insert(str.begin()+cursor, buffer.begin(), buffer.end());\n    cursor += buffer.size();\n    //buffer = \"\";\n    assertion();\n  }\n\n  string toString(){\n    return str;\n  }\n\n  void assertion(){\n    assert(str.size() > 0 && str[str.size()-1] == '\\n');\n  }\n\nprivate:\n  int cursor;\n  string str, buffer;\n};\n\nstring inputStr(){\n  string str = \"\", in;\n  while(cin >> in){\n    if(in == \"END_OF_TEXT\") break;\n    str += in + '\\n';\n  }\n  return str;\n}\n\nvoid executeCommand(state &dat){\n  string command;\n  while(cin >> command){\n    if(command == \"-\") break;\n    else if(command == \"a\") dat.typeA();\n    else if(command == \"e\") dat.typeE();\n    else if(command == \"p\") dat.typeP();\n    else if(command == \"n\") dat.typeN();\n    else if(command == \"f\") dat.typeF();\n    else if(command == \"b\") dat.typeB();\n    else if(command == \"d\") dat.typeD();\n    else if(command == \"k\") dat.typeK();\n    else if(command == \"y\") dat.typeY();\n    else assert(false);\n  }\n  cout << dat.toString() << flush;\n}\n\nint main(){\n  bool f = false;\n  while(1){\n    state dat = state(inputStr());\n    if(dat.toString() == \"\") break;\n    assert(!f);\n    f = true;\n    executeCommand(dat);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main() {\n    vector<string> e;\n    string s;\n    while (cin >> s, s != \"END_OF_TEXT\") {\n        e.push_back(s);\n    }\n    int y = 0, x = 0;\n    string buffer = \"\";\n    char c;\n    while (cin >> c, c != '-') {\n        if (c == 'a') {\n            x = 0;\n        } else if (c == 'e') {\n            x = e[y].size();\n        } else if (c == 'p') {\n            x = 0;\n            y = max(0, y-1);\n        } else if (c == 'n') {\n            x = 0;\n            y = min((int)e.size()-1, y+1);\n        } else if (c == 'f') {\n            if (x < (int)e[y].size()) {\n                x ++;\n            } else if (y+1 < (int)e.size()) {\n                x = 0;\n                y ++;\n            }\n        } else if (c == 'b') {\n            if (0 < x) {\n                x --;\n            } else if (0 <= y-1) {\n                x = e[y-1].size();\n                y --;\n            }\n        } else if (c == 'd') {\n            if (x < (int)e[y].size()) {\n                e[y] = e[y].substr(0,x) + e[y].substr(x+1);\n            } else if (y+1 < (int)e.size()) {\n                e[y] += e[y+1];\n                e.erase(e.begin() + y + 1);\n            }\n        } else if (c == 'k') {\n            if (x < (int)e[y].size()) {\n                buffer = e[y].substr(x);\n                e[y] = e[y].substr(0,x);\n                x = e[y].size();\n            } else if (y+1 < (int)e.size()) {\n                buffer = \"\\n\";\n                e[y] += e[y+1];\n                e.erase(e.begin() + y + 1);\n            }\n        } else if (c == 'y') {\n            if (buffer == \"\") {\n                // nothing\n            } else if (buffer == \"\\n\") {\n                e.insert(e.begin() + y + 1, e[y].substr(x));\n                e[y] = e[y].substr(0,x);\n                x = 0;\n                y ++;\n            } else {\n                e[y] = e[y].substr(0,x) + buffer + e[y].substr(x);\n            }\n        }\n    }\n    for (int i=0; i<(int)e.size(); ++i) {\n        cout << e[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[128];\nstring buf;\nint lines;\nvoid delete_line(int y)\n{\n    for (int i = y; y < lines; ++y)\n\ts[i] = s[i + 1];\n    s[--lines] = \"\";\n    if (lines == 0)\n\tlines = 1;\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; ++i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    for (lines = 0; ; ++lines)\n    {\n\tstring t;\n\tcin >> t;\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines] = t;\n    }\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    y = max(0, --y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    y = min(lines - 1, ++y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y + 1 != lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t\tx = 0, --y;\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t\ts[y].erase(x, 1);\n\t    else\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t    }\n\t    break;\n\t}\n\tcase 'k':\n\t{\n\t    if (x == s[y].size())\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    else if (!s[y].empty())\n\t    {\n\t\tbuf = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\tif (!s[y].empty())\n\t\t{\n\t\t    s[y + 1] = s[y].substr(x);\n\t\t    s[y].erase(x);\n\t\t}\n\t\tx = 0, ++y;\n\t    }\n\t    else if (!buf.empty())\n\t\ts[y] += buf;\n\t    break;\n\t}\n\t}\n    }\n\n    for (int i = 0; i < lines; ++i)\n\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main(){\n\tstring str[1000];\n\tstring s;\n\tint size = 0;\n\twhile(getline(cin,s)){\n\t\tif(s == \"END_OF_TEXT\") break;\n\t\tstr[size++] = s;\n\t}\n\tchar ch;\n\tstring buf = \"\";\n\tint line = 0, pos = 0;\n\twhile(cin >> ch){\n\t\tif(ch == '-') break;\n\t\tif(ch == 'a') pos = 0;\n\t\tif(ch == 'e') pos = str[line].size();\n\t\tif(ch == 'p'){\n\t\t\tpos = 0;\n\t\t\tif(line!=0) line--;\n\t\t}\n\t\tif(ch == 'n'){\n\t\t\tpos = 0;\n\t\t\tif(line+1!=size) line++;\n\t\t}\n\t\tif(ch == 'f'){\n\t\t\tif(pos != str[line].size()) pos++;\n\t\t\telse if(line+1!=size) { pos = 0; line++; }\n\t\t}\n\t\tif(ch == 'b'){\n\t\t\tif(pos != 0) pos--;\n\t\t\telse if(line!=0) { line--; pos = str[line].size(); }\n\t\t}\n\t\tif(ch == 'd'){\n\t\t\tif(pos != str[line].size()){\n\t\t\t\tstr[line] = str[line].substr(0,pos) + str[line].substr(pos+1);\n\t\t\t} else if(line+1!=size){\n\t\t\t\tstr[line] = str[line] + str[line+1];\n\t\t\t\tfor(int i=line+1;i+1<size;i++){\n\t\t\t\t\tstr[i] = str[i+1];\n\t\t\t\t}\n\t\t\t\tstr[size-1] = \"\";\n\t\t\t\tsize--;\n\t\t\t}\n\t\t}\n\t\tif(ch == 'k'){\n\t\t\tif(pos == str[line].size() && line+1!=size){\n\t\t\t\tstr[line] = str[line] + str[line+1];\n\t\t\t\tfor(int i=line+1;i+1<size;i++){\n\t\t\t\t\tstr[i] = str[i+1];\n\t\t\t\t}\n\t\t\t\tstr[size-1] = \"\";\n\t\t\t\tsize--;\n\t\t\t\tbuf = \"IS_BREAK_LINE\";\n\t\t\t}\n\t\t\telse if(pos < str[line].size()){\n\t\t\t\tbuf = str[line].substr(pos);\n\t\t\t\tstr[line] = str[line].substr(0,pos);\n\t\t\t}\n\t\t}\n\t\tif(ch == 'y'){\n\t\t\tif(buf == \"IS_BREAK_LINE\"){\n\t\t\t\tfor(int i=size-1;i>=line+1;i--){\n\t\t\t\t\tstr[i+1] = str[i];\n\t\t\t\t}\n\t\t\t\tsize++;\n\t\t\t\tstr[line+1] = str[line].substr(pos);\n\t\t\t\tstr[line] = str[line].substr(0,pos);\n\t\t\t\tline++;\n\t\t\t\tpos = 0;\n\t\t\t} else if(buf != \"\"){\n\t\t\t\tstr[line] = str[line].substr(0,pos) + buf + str[line].substr(pos);\n//\t\t\t\tpos += buf.size();\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tcout << line << \" \" << pos << endl;\n\t\tfor(int i=0;i<size;i++){\n\t\t\tcout << str[i] << endl;\t\n\t\t}\n\t\tputs(\"\");\n\t\t*/\n\t}\n\tfor(int i=0;i<size;i++){\n\t\tcout << str[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t,u;\nvector<char> tmp;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nint main(){\n\n  t.clear();\n  tmp.clear();\n  input();\n  x=y=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n    //cout<<y<<' '<<x<<\" ty\"<<t.size()<<endl;\n  }\n\n  for(int i=0;i<t.size();i++){\n    for(int j=0;j<t[i].size();j++){\n      cout<<t[i][j];\n    }\n  }\n\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    t[y].erase(t[y].begin()+x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  t[y].erase(t[y].begin()+x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  t.erase(t.begin()+y+1);\n}\n\nvoid funcK(){\n  tmp.clear();\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.push_back('\\n');\n    }\n    return;\n  }\n  while(t[y][x]!='\\n'){\n    tmp.push_back(t[y][x]);\n    t[y].erase(t[y].begin()+x);\n  }\n  reverse(tmp.begin(),tmp.end());\n\n}\n\nvoid funcY(){\n  /*\n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    vector<char> z;\n    while(t[y][x]!='\\n'){\n      z.push_back(t[y][x]);\n      t[y].erase(t[y].begin()+x);\n    }\n    t.insert(t.begin()+y+1,z);\n    return;\n  }\n  */\n}\n\nvoid input(){\n  vector<char> a;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[128];\nstring buf;\nint lines = 0;\nvoid delete_line(int y)\n{\n    for (int i = y; y < lines; ++y)\n\ts[i] = s[i + 1];\n    s[--lines] = \"\";\n    if (lines == 0)\n\tlines = 1;\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; ++i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    for ( ; ; ++lines)\n    {\n\tstring t;\n\tcin >> t;\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines] = t;\n    }\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    if (y != 0)\n\t\t--y;\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    if (y + 1 != lines)\n\t\t++y;\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y != lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t\tx = 0, --y;\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t\ts[y].erase(x, 1);\n\t    else\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t    }\n\t    break;\n\t}\n\tcase 'k':\n\t{\n\t    if (x == s[y].size())\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    else\n\t    {\n\t\tbuf = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\ts[y + 1] = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = 0, ++y;\n\t    }\n\t    else if (!buf.empty())\n\t\ts[y] += buf;\n\t    break;\n\t}\n\t}\n    }\n\n    for (int i = 0; i < lines; ++i)\n\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[111];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\tfor(int i=0 ; i<111 ; i++)\n\t\tt[i] = \"\";\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tif(i<110) t[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tif(row<110) col = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 && row < 110 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row < 110 && row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( row < 110 && col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else if( row < 110 ){\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( row < 110 && buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line+1 < 110 && line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\t//t[row+1] = t[row].substr( col );\n\t\t\t\t\t//t[row].erase( col );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else if( row < 110 ){\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main() {\n    vector<string> e;\n    string s;\n    while (getline(cin, s), s != \"END_OF_TEXT\") {\n        e.push_back(s);\n    }\n    int y = 0, x = 0;\n    string buffer = \"\";\n    char c;\n    while (cin >> c, c != '-') {\n        if (c == 'a') {\n            x = 0;\n        } else if (c == 'e') {\n            x = e[y].size();\n        } else if (c == 'p') {\n            x = 0;\n            y = max(0, y-1);\n        } else if (c == 'n') {\n            x = 0;\n            y = min((int)e.size()-1, y+1);\n        } else if (c == 'f') {\n            if (x < (int)e[y].size()) {\n                x ++;\n            } else if (y+1 < (int)e.size()) {\n                x = 0;\n                y ++;\n            }\n        } else if (c == 'b') {\n            if (0 < x) {\n                x --;\n            } else if (0 <= y-1) {\n                x = e[y-1].size();\n                y --;\n            }\n        } else if (c == 'd') {\n            if (x < (int)e[y].size()) {\n                e[y] = e[y].substr(0,x) + e[y].substr(x+1);\n            } else if (y+1 < (int)e.size()) {\n                e[y] += e[y+1];\n                e.erase(e.begin() + y + 1);\n            }\n        } else if (c == 'k') {\n            if (x < (int)e[y].size()) {\n                buffer = e[y].substr(x);\n                e[y] = e[y].substr(0,x);\n                x = e[y].size();\n            } else if (y+1 < (int)e.size()) {\n                buffer = \"\\n\";\n                e[y] += e[y+1];\n                e.erase(e.begin() + y + 1);\n            }\n        } else if (c == 'y') {\n            if (buffer == \"\") {\n                // nothing\n            } else if (buffer == \"\\n\") {\n                e.insert(e.begin() + y + 1, e[y].substr(x));\n                e[y] = e[y].substr(0,x);\n                x = 0;\n                y ++;\n            } else {\n                e[y] = e[y].substr(0,x) + buffer + e[y].substr(x);\n            }\n        }\n    }\n    for (int i=0; i<(int)e.size(); ++i) {\n        cout << e[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<string> buf;\nint row;\nint column;\nstring rem;\n\nvoid printbuf(){\n  //cout << row << ' ' << column << \" \\\"\" << rem << \"\\\"\" << endl;\n  for(int i=0;i<buf.size();i++){\n    cout << buf[i];\n  }\n}\n\nmain(){\n  string in;\n  while(getline(cin, in)){\n    if(in == \"END_OF_TEXT\"/* || in == \"1\"*/) break;\n    in += '\\n';\n    buf.push_back(in);\n  }\n  char c;\n  row = 0;\n  column = 0;\n  while(cin >> c){\n    if(c == '-') break;\n    switch(c){\n      case 'a':\n        column = 0;\n        break;\n      case 'e':\n        column = (int)buf[row].size()-1;\n        break;\n      case 'p':\n        column = 0;\n        if(row != 0) --row;\n        break;\n      case 'n':\n        column = 0;\n        if(row+1 != buf.size()) ++row;\n        break;\n      case 'f':\n        if(column+1 == buf[row].size()){\n          if(row+1 != buf.size()){\n            column = 0;\n            ++row;\n          }\n        }else{\n          ++column;\n        }\n        break;\n      case 'b':\n        if(column == 0){\n          if(row != 0){\n            column = 0;\n            --row;\n          }\n        }else{\n          --row;\n        }\n        break;\n      case 'd':\n        if(column+1 == buf[row].size()){\n          if(row+1 != buf.size()){\n            vector<string>::iterator ite = buf.begin();\n            for(int i=0;i<row;i++) ++ite;\n            buf.erase(ite);\n          }\n        }else{\n          buf[row].erase(column, 1);\n        }\n        break;\n      case 'k':\n        rem = \"\";\n        if(column+1 == buf[row].size()){\n          if(row+1 != buf.size()){\n            vector<string>::iterator ite = buf.begin();\n            for(int i=0;i<row;i++) ++ite;\n            buf.erase(ite);\n            rem += '\\n';\n          }\n        }else{\n          for(int i=column;i+1<buf[row].size();++i){\n            rem += buf[row][i];\n          }\n          string::iterator ite = buf[row].begin();\n          for(int i=0;i<column;i++) ++ite;\n          buf[row].erase(ite, buf[row].end());\n          buf[row] += '\\n';\n        }\n        break;\n      case 'y':\n        if(rem.size() != 0){\n          int irem;\n          string back = buf[row].substr(column);\n          buf[row] = buf[row].substr(0, column);\n          for(irem = 0;irem<rem.size();irem++){\n            buf[row] += rem[irem];\n            if(rem[irem] == '\\n'){\n              vector<string>::iterator ite = buf.begin();\n              for(int i=0;i<row+1;i++) ++ite;\n              buf.insert(ite, \"\");\n              column = 0;\n              ++row;\n            }\n          }\n          buf[row] += back;\n        }\n        break;\n    }\n    //printbuf();\n  }\n  printbuf();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY = 0;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n}\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\\n\";\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX);\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX+1);\n\n\t\tlines[posY] = front;\n\t\tdeque<string>::iterator it = lines.begin();\n\t\tadvance(it,posY);\n\t\tlines.insert(it,rear);\n\t}\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(getline(cin,str)){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(getline(cin,str)){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\tif(str == \"d\") ctrl_d(lines);\n\t\tif(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[110][1100];\nchar buf[1100];\nchar in[10];\nint main(){\n\tint n=0;\n\twhile(1){\n\t\tgets(str[n]);\n\t\tif(str[n][3]=='_')break;\n\t\tn++;\n\t}\n\tfor(int i=0;i<1100;i++)str[n][i]=0;\n\tint row=0;\n\tint col=0;\n\twhile(1){\n\t\tscanf(\"%s\",in);\n\t\tif(in[0]=='-')break;\n\t\tif(in[0]=='a')col=0;\n\t\tif(in[0]=='e'){\n\t\t\twhile(str[row][col]){\n\t\t\t\tcol++;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='p'){\n\t\t\tif(row)row--;\n\t\t\tcol=0;\n\t\t}\n\t\tif(in[0]=='n'){\n\t\t\tif(row<n-1)row++;\n\t\t\tcol=0;\n\t\t}\n\t\tif(in[0]=='f'){\n\t\t\tif(str[row][col])col++;\n\t\t\telse if(row<n-1){row++;col=0;}\n\t\t}\n\t\tif(in[0]=='b'){\n\t\t\tif(col)col--;\n\t\t\telse if(row){row--;col=0;\n\t\t\t\twhile(str[row][col])col++;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='d'){\n\t\t\tif(str[row][col]){\n\t\t\t\tfor(int i=col;str[row][i];i++)str[row][i]=str[row][i+1];\n\t\t\t}else if(row<n-1){\n\t\t\t\tfor(int i=0;str[row+1][i];i++){\n\t\t\t\t\tstr[row][col+i]=str[row+1][i];\n\t\t\t\t\tstr[row+1][i]=0;\n\t\t\t\t}\n\t\t\t\tfor(int i=row+1;i<n;i++){\n\t\t\t\t\tfor(int j=0;j<1100;j++)str[i][j]=str[i+1][j];\n\t\t\t\t}\n\t\t\t\tn--;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='k'){\n\t\t\tif(!str[row][col]){\n\t\t\t\tif(row<n-1){\n\t\t\t\t\tfor(int i=0;str[row+1][i];i++){\n\t\t\t\t\t\tstr[row][col++]=str[row+1][i];\n\t\t\t\t\t\tstr[row+1][i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tn--;\n\t\t\t\t\tbuf[0]='@';\n\t\t\t\t\tbuf[1]=0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint at=0;\n\t\t\t\tfor(int i=col;str[row][i];i++){\n\t\t\t\t\tbuf[at++]=str[row][i];\n\t\t\t\t\tstr[row][i]=0;\n\t\t\t\t}\n\t\t\t\tbuf[at]=0;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='y'){\n\t\t\tif(buf[0]){\n\t\t\t\tif(buf[0]=='@'){\n\t\t\t\t\tfor(int i=n-1;i>row;i--){\n\t\t\t\t\t\tfor(int j=0;j<1100;j++)str[i+1][j]=str[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tint at=0;\n\t\t\t\t\tfor(int i=col;str[row][i];i++){\n\t\t\t\t\t\tstr[row+1][at++]=str[row][i];\n\t\t\t\t\t\tstr[row][i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tstr[row+1][at]=0;\n\t\t\t\t\trow++;col=0;\n\t\t\t\t\tn++;\n\t\t\t\t}else{\n\t\t\t\t\tint sz=0;\n\t\t\t\t\tfor(int i=0;buf[i];i++)sz++;\n\t\t\t\t\tfor(int i=1109;i>=col;i--){\n\t\t\t\t\t\tif(i+sz>=1100)continue;\n\t\t\t\t\t\tstr[row][i+sz]=str[row][i];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0;i<sz;i++)str[row][col+i]=buf[i];\n\t\t\t\t\tcol+=sz;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)printf(\"%s\\n\",str[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t,u;\nvector<char> tmp;\nvector<char> z;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nvoid yinsert(int,vector<char>);\nvoid xinsert(int,int,char);\nvoid ydelete(int);\nvoid xdelete(int,int);\n\nint main(){\n\n  t.clear();\n  tmp.clear();\n  input();\n  x=y=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n    //cout<<y<<' '<<x<<\" ty\"<<t.size()<<endl;\n  }\n\n  for(int i=0;i<t.size();i++){\n    for(int j=0;j<t[i].size();j++){\n      cout<<t[i][j];\n    }\n  }\n\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    xdelete(y,x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  xdelete(y,x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  ydelete(y+1);\n}\n\nvoid funcK(){\n  tmp.clear();\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.push_back('\\n');\n    }\n    return;\n  }\n  while(t[y][x]!='\\n'){\n    tmp.push_back(t[y][x]);\n    xdelete(y,x);\n  }\n  reverse(tmp.begin(),tmp.end());\n\n}\n\nvoid funcY(){\n  z.clear();\n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    while(t[y][x]!='\\n'){\n      z.push_back(t[y][x]);\n      xdelete(y,x);\n    }\n    yinsert(y+1,z);\n    return;\n  }\n  for(int i=0;i<(int)tmp.size();i++){\n    xinsert(y,x,tmp[i]);\n  }\n  \n}\n\nvoid input(){\n  vector<char> a;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n}\n\n\n\n\n\n\n\n\nvoid xinsert(int y,int x,char ch){\n  if(x==(int)t[y].size()){\n    t[y].push_back(ch);\n  }else{\n    \n    z=t[y];\n    t[y].clear();\n    for(int i=0;i<(int)z.size();i++){\n      if(i==x)t[y].push_back(ch);\n      t[y].push_back(z[i]);\n    }\n  }\n}\n\nvoid xdelete(int y,int x){\n  if(x+1==(int)t[y].size()){\n    t[y].pop_back();\n  }else{\n    \n    z=t[y];\n    t[y].clear();\n    for(int i=0;i<(int)z.size();i++){\n      if(i==x)continue;\n      t[y].push_back(z[i]);\n    }\n  }\n}\n\nvoid yinsert(int y,vector<char> ch){\n  if(y==(int)t.size()){\n    t.push_back(ch);\n  }else{\n    u=t;\n    t.clear();\n    for(int i=0;i<(int)u.size();i++){\n      if(i==y)t.push_back(ch);\n      t.push_back(u[i]);\n    }\n  }\n}\n\nvoid ydelete(int y){\n  if(y+1==(int)t.size()){\n    t.pop_back();\n  }else{\n    u=t;\n    t.clear();\n    for(int i=0;i<(int)u.size();i++){\n      if(i==y)continue;\n      t.push_back(u[i]);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main(){\n\tstring str[1000];\n\tstring s;\n\tint size = 0;\n\twhile(getline(cin,s)){\n\t\tif(s == \"END_OF_TEXT\") break;\n\t\tstr[size++] = s;\n\t}\n\tchar ch;\n\tstring buf = \"\";\n\tint line = 0, pos = 0;\n\twhile(cin >> ch){\n\t\tif(ch == '-') break;\n\t\tif(ch == 'a') pos = 0;\n\t\tif(ch == 'e') pos = str[line].size();\n\t\tif(ch == 'p'){\n\t\t\tpos = 0;\n\t\t\tif(line!=0) line--;\n\t\t}\n\t\tif(ch == 'n'){\n\t\t\tpos = 0;\n\t\t\tif(line+1!=size) line++;\n\t\t}\n\t\tif(ch == 'f'){\n\t\t\tif(pos != str[line].size()) pos++;\n\t\t\telse if(line+1!=size) { pos = 0; line++; }\n\t\t}\n\t\tif(ch == 'b'){\n\t\t\tif(pos != 0) pos--;\n\t\t\telse if(line!=0) { line--; pos = str[line].size(); }\n\t\t}\n\t\tif(ch == 'd'){\n\t\t\tif(pos != str[line].size()){\n\t\t\t\tstr[line] = str[line].substr(0,pos) + str[line].substr(pos+1);\n\t\t\t} else if(line+1!=size){\n\t\t\t\tstr[line] = str[line] + str[line+1];\n\t\t\t\tfor(int i=line+1;i+1<size;i++){\n\t\t\t\t\tstr[i] = str[i+1];\n\t\t\t\t}\n\t\t\t\tstr[size-1] = \"\";\n\t\t\t\tsize--;\n\t\t\t}\n\t\t}\n\t\tif(ch == 'k'){\n\t\t\tif(pos == str[line].size() && line+1!=size){\n\t\t\t\tstr[line] = str[line] + str[line+1];\n\t\t\t\tfor(int i=line+1;i+1<size;i++){\n\t\t\t\t\tstr[i] = str[i+1];\n\t\t\t\t}\n\t\t\t\tstr[size-1] = \"\";\n\t\t\t\tsize--;\n\t\t\t\tbuf = \"\\n\";\n\t\t\t}\n\t\t\telse if(pos < str[line].size()){\n\t\t\t\tbuf = str[line].substr(pos);\n\t\t\t\tstr[line] = str[line].substr(0,pos);\n\t\t\t}\n\t\t}\n\t\tif(ch == 'y'){\n\t\t\tif(buf == \"\\n\"){\n\t\t\t\tfor(int i=line+1;i<size;i++){\n\t\t\t\t\tstr[i+1] = str[i];\n\t\t\t\t}\n\t\t\t\tsize++;\n\t\t\t\tstr[line+1] = str[line].substr(pos);\n\t\t\t\tstr[line] = str[line].substr(0,pos);\n\t\t\t\tline++;\n\t\t\t\tpos = 0;\n\t\t\t} else if(buf != \"\"){\n\t\t\t\tstr[line] = str[line].substr(0,pos) + buf + str[line].substr(pos);\n//\t\t\t\tpos += buf.size();\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << line << \" \" << pos << endl;\n\t\tfor(int i=0;i<size;i++){\n\t\t\tcout << str[i] << endl;\t\n\t\t}\n\t\tputs(\"\");\n\t\t\n\t}\n\tfor(int i=0;i<size;i++){\n\t\tcout << str[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main(){\n\tstring str[1000];\n\tstring s;\n\tint size = 0;\n\twhile(getline(cin,s)){\n\t\tif(s == \"END_OF_TEXT\") break;\n\t\tstr[size++] = s;\n\t}\n\tchar ch;\n\tstring buf = \"\";\n\tint line = 0, pos = 0;\n\twhile(cin >> ch){\n\t\tif(ch == '-') break;\n\t\tif(ch == 'a') pos = 0;\n\t\tif(ch == 'e') pos = str[line].size();\n\t\tif(ch == 'p'){\n\t\t\tpos = 0;\n\t\t\tif(line!=0) line--;\n\t\t}\n\t\tif(ch == 'n'){\n\t\t\tpos = 0;\n\t\t\tif(line+1!=size) line++;\n\t\t}\n\t\tif(ch == 'f'){\n\t\t\tif(pos != str[line].size()) pos++;\n\t\t\telse if(line+1!=size) { pos = 0; line++; }\n\t\t}\n\t\tif(ch == 'b'){\n\t\t\tif(pos != 0) pos--;\n\t\t\telse if(line!=0) { line--; pos = str[line].size(); }\n\t\t}\n\t\tif(ch == 'd'){\n\t\t\tif(pos != str[line].size()){\n\t\t\t\tstr[line] = str[line].substr(0,pos) + str[line].substr(pos+1);\n\t\t\t} else if(line+1!=size){\n\t\t\t\tstr[line] = str[line] + str[line+1];\n\t\t\t\tfor(int i=line+1;i+1<size;i++){\n\t\t\t\t\tstr[i] = str[i+1];\n\t\t\t\t}\n\t\t\t\tstr[size-1] = \"\";\n\t\t\t\tsize--;\n\t\t\t}\n\t\t}\n\t\tif(ch == 'k'){\n\t\t\tif(pos == str[line].size() && line+1!=size){\n\t\t\t\tstr[line] = str[line] + str[line+1];\n\t\t\t\tfor(int i=line+1;i+1<size;i++){\n\t\t\t\t\tstr[i] = str[i+1];\n\t\t\t\t}\n\t\t\t\tstr[size-1] = \"\";\n\t\t\t\tsize--;\n\t\t\t\tbuf = \"\\n\";\n\t\t\t}\n\t\t\telse if(pos < str[line].size()){\n\t\t\t\tbuf = str[line].substr(pos);\n\t\t\t\tstr[line] = str[line].substr(0,pos);\n\t\t\t}\n\t\t}\n\t\tif(ch == 'y'){\n\t\t\tif(buf == \"\\n\"){\n\t\t\t\tfor(int i=size-1;i>=line+1;i--){\n\t\t\t\t\tstr[i+1] = str[i];\n\t\t\t\t}\n\t\t\t\tsize++;\n\t\t\t\tstr[line+1] = str[line].substr(pos);\n\t\t\t\tstr[line] = str[line].substr(0,pos);\n\t\t\t\tline++;\n\t\t\t\tpos = 0;\n\t\t\t} else if(buf != \"\"){\n\t\t\t\tstr[line] = str[line].substr(0,pos) + buf + str[line].substr(pos);\n//\t\t\t\tpos += buf.size();\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tcout << line << \" \" << pos << endl;\n\t\tfor(int i=0;i<size;i++){\n\t\t\tcout << str[i] << endl;\t\n\t\t}\n\t\tputs(\"\");\n\t\t*/\t\t\n\t}\n\tfor(int i=0;i<size;i++){\n\t\tcout << str[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <list>\n\nint main() {\n  std::list<std::string> lines;\n  while (true) {\n    char buf[32];\n    fgets(buf, sizeof buf, stdin);\n    std::string line=buf;\n    if (line == \"END_OF_TEXT\\n\")\n      break;\n\n    lines.emplace_back(line);\n  }\n\n  auto it=lines.begin();\n  size_t cc=0;\n  std::string kbuf=\"\";\n  while (true) {\n    char op;\n    scanf(\" %c\", &op);\n\n    switch (op) {\n    case '-': {\n      for (const auto &line: lines)\n        printf(\"%s\", line.c_str());\n      return 0;\n    }\n\n    case 'a':\n      cc = 0;\n      break;\n\n    case 'e':\n      cc = it->size()-1;\n      break;\n\n    case 'p':\n      cc = 0;\n      if (it != lines.begin())\n        --it;\n      break;\n\n    case 'n':\n      cc = 0;\n      if (std::next(it) != lines.end())\n        ++it;\n      break;\n\n    case 'f':\n      if ((*it)[cc] != '\\n') {\n        ++cc;\n      } else if (std::next(it) != lines.end()) {\n        ++it;\n        cc = 0;\n      }\n      break;\n\n    case 'b':\n      if (cc > 0) {\n        --cc;\n      } else if (it != lines.begin()) {\n        --it;\n        cc = it->size()-1;\n      }\n      break;\n\n    case 'd':\n      if ((*it)[cc] != '\\n') {\n        std::string s=it->substr(0, cc);\n        s += it->substr(cc+1);\n        *it = s;\n      } else if (std::next(it) != lines.end()) {\n        it->pop_back();\n        auto tmp=std::next(it);\n        *it += *tmp;\n        lines.erase(tmp);\n      }\n      break;\n\n    case 'k':\n      if ((*it)[cc] != '\\n') {\n        kbuf = it->substr(cc);\n        kbuf.pop_back();\n        *it = it->substr(0, cc) + \"\\n\";\n      } else if (std::next(it) != lines.end()) {\n        kbuf = \"\\n\";\n        it->pop_back();\n        auto tmp=std::next(it);\n        *it += *tmp;\n        lines.erase(tmp);\n      }\n      break;\n\n    case 'y':\n      if (kbuf.empty()) {\n        // no-op;\n      } else if (kbuf == \"\\n\") {\n        std::string s=it->substr(cc);\n        *it = it->substr(0, cc) + \"\\n\";\n        auto tmp=std::next(it);\n        lines.emplace(tmp, s);\n        ++it;\n        cc = 0;\n      } else {\n        *it = it->substr(0, cc) + kbuf + it->substr(cc);\n      }\n      break;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\tvector<string> edit;\n\twhile(true){\n\t\tstring s;\tcin>>s;\n\t\tif(s==\"END_OF_TEXT\")\tbreak;\n\t\tedit.push_back(s+\"\\n\");\n\t}\n\tint tr=0,tc=0;\n\tstring buff=\"\";\n\twhile(true){\n\t\tchar c;\tcin>>c;\n\t\tif(c=='-')\tbreak;\n\t\tif(c=='a')\ttr=0;\n\t\telse if(c=='e')\ttr=edit[tc].size()-1;\n\t\telse if(c=='p'){\n\t\t\ttr=0;\ttc=max(0,tc-1);\n\t\t}\n\t\telse if(c=='n'){\n\t\t\ttr=0;\ttc=min((int)edit.size()-1,tc+1);\n\t\t}\n\t\telse if(c=='f'){\n\t\t\tif((int)edit[tc].size()>tr+1)\ttr++;\n\t\t\telse if((int)edit.size()>tc+1){\n\t\t\t\ttc++;\ttr=0;\n\t\t\t}\n\t\t}\n\t\telse if(c=='b'){\n\t\t\tif(tr>0)\ttr--;\n\t\t\telse if(tc>0){\n\t\t\t\ttc--;\ttr=edit[tc].size()-1;\n\t\t\t}\n\t\t}\n\t\telse if(c=='d'){\n\t\t\tif(tr+1<(int)edit[tc].size())\tedit[tc].erase(edit[tc].begin()+tr);\n\t\t\telse if(tc+1<(int)edit.size()){\n\t\t\t\tedit[tc].erase(edit[tc].end()-1);\n\t\t\t\tedit[tc].insert(edit[tc].end(),edit[tc+1].begin(),edit[tc+1].end());\n\t\t\t\tedit.erase(edit.begin()+tc+1);\n\t\t\t}\n\t\t}\n\t\telse if(c=='k'){\n\t\t\tif(edit[tc][tr]=='\\n'&&tc+1<(int)edit.size()){\n\t\t\t\tbuff=\"\\n\";\n\t\t\t\tedit[tc].erase(edit[tc].end()-1);\n\t\t\t\tedit[tc]=edit[tc]+edit[tc+1];\n\t\t\t\tedit.erase(edit.begin()+tc+1);\n\t\t\t}\n\t\t\telse if(tr+1<(int)edit[tc].size()){\n\t\t\t\tbuff=edit[tc].substr(tr);\n\t\t\t\tbuff.erase(buff.end()-1);\n\t\t\t\tedit[tc].erase(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t\tedit[tc]+=\"\\n\";\n\t\t\t}\n\t\t}\n\t\telse if(c=='y'){\n\t\t\tif(buff==\"\")\tcontinue;\n\t\t\tif(buff==\"\\n\"){\n\t\t\t\tstring s(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t\tedit[tc].erase(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t\tedit[tc]=edit[tc]+'\\n';\n\t\t\t\tedit.insert(edit.begin()+tc+1,s);\n\t\t\t\ttc++;\ttr=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint s=buff.size();\n\t\t\t\tedit[tc].insert(edit[tc].begin()+tr,buff.begin(),buff.end());\n\t\t\t\ttr+=s;\n\t\t\t}\n\t\t}\n\t}\n\tfor(string s:edit)\tcout<<s;\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main(){\n\tstring s[500];\n\tint line = 0;\n\tfor ( string in;cin >> in, in != \"END_OF_TEXT\"; ++line ){\n\t\ts[ line ] = in;\n\t}\n\t\n\tint pX = 0;\n\tint pY = 0;\n\t\n\tstring buf;\n\tfor ( string in; cin >> in, in != \"-\"; ) {\n\t\tif ( in == \"a\" ) {\n\t\t\tpX = 0;\n\t\t} else if ( in == \"e\" ) {\n\t\t\tpX = s[ pY ].length();\n\t\t} else if ( in == \"p\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( 0 < pY ) {\n\t\t\t\t--pY;\n\t\t\t}\n\t\t} else if ( in == \"n\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( pY < line - 1 ) {\n\t\t\t\t++pY;\n\t\t\t}\n\t\t} else if ( in == \"f\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\t++pX;\n\t\t\t} else {\n\t\t\t\tif ( pY < line - 1 ) {\n\t\t\t\t\tpX = 0;\n\t\t\t\t\t++pY;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( in == \"b\" ) {\n\t\t\tif ( 0 < pX ) {\n\t\t\t\t--pX;\n\t\t\t} else {\n\t\t\t\tif ( 0 < pY ) {\n\t\t\t\t\t--pY;\n\t\t\t\t\tpX = s[ pY ].length();\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( in == \"d\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + s[ pY ].substr( pX + 1 );\n\t\t\t} else if ( pY < line - 1 ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\t--line;\n\t\t\t}\n\t\t} else if ( in == \"k\" ) {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\tbuf = s[ pY ].substr( pX );\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t\tpX = s[ pY ].length();\n\t\t\t} else if ( pY < line - 1 ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\tif ( 0 < line) {\n\t\t\t\t\t--line;\n\t\t\t\t}\n\t\t\t\tbuf = \"\\n\";\n\t\t\t}\n\t\t} else if ( in == \"y\" ) {\n\t\t\tif ( !buf.empty() ) {\n\t\t\t\tif ( buf == \"\\n\" ) {\n\t\t\t\t\tfor ( int i = line - 1; pY < i; --i ) {\n\t\t\t\t\t\ts[ i ] = s[ i - 1 ];\n\t\t\t\t\t}\n\t\t\t\t\ts[ pY + 1 ] = s[ pY ].substr( pX );\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t\t\t++line;\n\t\t\t\t} else {\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + buf + s[ pY ].substr( pX );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor ( int i = 0; i < line; ++i ) cout << s[ i ] << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nstring s[102],buf;\nint l,r,N;\n\nvoid a(void){r=0;}\nvoid e(void){r=max(0,(int)s[l].size()-1);}\nvoid p(void){\n\tif(l>0)l--,r=0;\n\telse r=0;\n}\n\nvoid n(void){\n\tif(l<N)l++,r=0;\n\telse r=0;\n}\n\nvoid f(void){\n\tif(r<max(0,(int)s[l].size()-1))r++;\n\telse l++,r=0;\n}\n\nvoid b(void){\n\tif(r>0)r--;\n\telse if(l>0)r=s[--l].size();\n}\n\nvoid d(void){\n\tif(r==s[l].size()-1){\n\t\tif(l<N){\n\t\t\ts[l]+=s[l+1];\n\t\t\tfor(int i=l+1;i<N-1;i++)s[i]=s[i+1];\n\t\t\tN--;\n\t\t}\n\t}\n\telse s[l].erase(r,1);\n}\n\nvoid k(void){\n\tif(r==s[l].size()-1 && l<N-1)d(),buf=\"\\n\";\n\telse {\n\t\tbuf=s[l].substr(max(0,r-1));\n\t\ts[l].erase(max(0,r-1));\n\t}\n}\n\nvoid y(void){\n\tif(buf.empty())return ;\n\tif(buf==\"\\n\"){\n\t\tfor(int i=++N;i>l;i--)s[i]=s[i-1];\n\t\ts[l+1]=s[l].substr(max(0,r-1));\n\t\ts[l].erase(max(0,r-1));\n\t\tl++,r=0;\n\t}\n\telse {\n\t\ts[l].insert(min((int)s[l].size(),r+1),buf);\n\t\tr+=buf.size();\n\t}\n}\n\n\nint main(void){\n\tN=0;\n\twhile(getline(cin,s[N])){\n\t\tif(s[N]==\"END_OF_TEXT\")break;\n\t\tN++;\n\t}\n\tl=r=0;\n\tbuf.clear();\n\t\n\t\t\n\tstring C;\n\twhile(cin >> C,C!=\"-\"){\n\t\t\n\t\tif(C==\"a\")a();\n\t\telse if(C==\"e\")e();\n\t\telse if(C==\"p\")p();\n\t\telse if(C==\"n\")n();\n\t\telse if(C==\"f\")f();\n\t\telse if(C==\"b\")b();\n\t\telse if(C==\"d\")d();\n\t\telse if(C==\"k\")k();\n\t\telse if(C==\"y\")y();\n\t}\n\t\n\tfor(int i=0;i<N;i++){\n\t\tcout << s[i] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t;\nvector<char> tmp;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nint main(){\n  input();\n  x=y=0;\n  while(1){\n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n\n  }\n\n  for(int i=0;i<t.size();i++){\n    for(int j=0;j<t[i].size();j++){\n      cout<<t[i][j];\n    }\n  }\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size())y++,x=0;\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0)y--,x=0;\n}\n\nvoid funcD(){\n  t[y].erase(t[y].begin()+x);\n  if(t[y][t[y].size()-1]=='\\n')return;\n  if(y+1==(int)t.size())return;\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  t.erase(t.begin()+y+1);\n}\n\nvoid funcK(){\n  tmp.clear();\n  if(t[y][x]=='\\n'){\n    funcD();\n    tmp.push_back('\\n');\n    return;\n  }\n  int c=0;\n  for(int i=x;i+1<(int)t[y].size();i++){\n    tmp.push_back(t[y][i]);\n    c++;\n  }\n  for(int i=0;i<=c;i++)t[y].pop_back();\n  t[y].push_back('\\n');\n  reverse(tmp.begin(),tmp.end());\n}\n\nvoid funcY(){\n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    vector<char> z;\n    int c=0;\n    for(int i=x;i<(int)t[y].size();i++){\n      z.push_back(t[y][i]);\n      c++;\n    }\n    for(int i=0;i<=c;i++)t[y].pop_back();\n    t[y].push_back('\\n');\n    t.insert(t.begin()+y+1,z);\n    y++;\n    x=0;\n    return;\n  }\n\n  for(int i=0;i<(int)tmp.size();i++){\n    t[y].insert(t[y].begin()+x,tmp[i]);\n  }\n  funcE();\n\n}\nvoid input(){\n  vector<char> a;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Emacs{\n  int line,column;\n  string buffer;\n  vector<string> text;\n\n  void editText(){\n    for(int i = 0 ; i < (int)text.size() ; i++){\n      if(isEmptyLine(i)){ text[i] = \" \"; }\n    }\n  }\n\n  void order(char command){\n    editText();\n    switch(command){\n    case 'a': funcA(); break;\n    case 'e': funcE(); break;\n    case 'p': funcP(); break;\n    case 'n': funcN(); break;\n    case 'f': funcF(); break;\n    case 'b': funcB(); break;\n    case 'd': funcD(); break;\n    case 'k': funcK(); break;\n    case 'y': funcY(); break;\n    }\n  }\n\n  bool isEmptyLine(int l){\n    for(int i = 0 ; i < (int)text[l].size() ; i++){\n      if(text[l][i] != ' '){ return false; }\n    }\n    return true;\n  }\n\n  void funcA(){\n    column = 0;\n  }\n  \n  void funcE(){\n    column = text[line].size();\n  }\n\n  void funcP(){\n    if(line > 0){\n      line--;\n    }else{\n      column = 0;\n    }\n  }\n\n  void funcN(){\n    if(line+1 < (int)text.size()){\n      line++;\n    }else{\n      column = 0;\n    }\n  }\n\n  void funcF(){\n    if(column == (int)text[line].size()){\n      if(line+1 < (int)text.size()){\n        line++;\n        column = 0;\n      }\n    }else{\n      column++;\n    }\n  }\n  \n  void funcB(){\n    if(column == 0){\n      if(line != 0){\n        line--;\n        column = text[line].size();\n      }\n    }else{\n      column--;\n    }\n  }\n\n  void funcD(){\n    if(isEmptyLine(line)){\n      int len = text.size();\n      vector<string> ntext(len-1);\n      for(int i = 0 ; i < line ; i++){\n        ntext[i] = text[i];\n      }\n      for(int i = line ; i < len-1 ; i++){\n        ntext[i] = text[i+1];\n      }\n      text = ntext;\n      return;\n    }\n    if(0 <= column && column < (int)text[line].size()){\n      text[line] = text[line].substr(0,column) + text[line].substr(column+1);\n    }else{\n      int len = text.size();\n      if(line+1 < len){\n        vector<string> ntext(len-1);\n        for(int i = 0 ; i < line-1 ; i++){\n          ntext[i] = text[i];\n        }\n        ntext[line] = text[line] + text[line+1];\n        for(int i = line+2 ; i < len ; i++){\n          ntext[i] = text[i];\n        }\n        text = ntext;\n      }\n    }\n  }\n\n  void funcK(){\n    int len = text[line].size();\n    if(column == len){\n      int len2 = text.size();\n      if(line+1 < len2){\n        buffer = \"\\n\";\n        vector<string> ntext(len2-1);\n        for(int i = 0 ; i < line-1 ; i++){\n          ntext[i] = text[i];\n        }\n        ntext[line] = text[line] + text[line+1];\n        for(int i = line+2 ; i < len ; i++){\n          ntext[i] = text[i];\n        }\n        text = ntext;\n      }\n    }else{\n      buffer.clear();\n      for(int i = column ; i < len ; i++){\n        buffer += text[line][i];\n      }\n      text[line].resize(column);\n    }\n  }\n\n  void funcY(){\n    if(buffer.empty()){ return; }\n    if(buffer == \"\\n\"){\n      string str = text[line];\n      text[line] = str.substr(0,column);\n      if(line+1 < (int)text.size()){\n        text[line+1] = str.substr(column) + text[line+1];\n      }else{\n        text.push_back(str.substr(column));\n      }\n    }else{\n      string str = text[line];\n      str = str.substr(0,column) + buffer + str.substr(column);\n      text[line] = str;\n    }\n  }\n\n  void print(){\n    int len = text.size();\n    for(int i = 0 ; i < len ; i++){\n      cout << text[i] << endl;\n    }\n  }\n};\n\nint main(){\n  Emacs emacs;\n  string str;\n  while(cin >> str, str != \"END_OF_TEXT\"){\n    emacs.text.push_back(str);\n  }\n  emacs.line = emacs.column = 0;\n  char command;\n  while(cin >> command, command != '-'){\n    emacs.order(command);\n  }\n  emacs.print();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main(){\n\tstring s[10];\n\tint line = 0;\n\tfor ( string in;cin >> in, in != \"END_OF_TEXT\"; ++line ){\n\t\ts[ line ] = in;\n\t}\n\t\n\tint pX = 0;\n\tint pY = 0;\n\t\n\tstring buf;\n\tfor ( string in; cin >> in, in != \"-\"; ) {\n\t\tif ( in == \"a\" ) {\n\t\t\tpX = 0;\n\t\t} else if ( in == \"e\" ) {\n\t\t\tpX = s[ pY ].length();\n\t\t} else if ( in == \"p\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( 0 < pY ) {\n\t\t\t\t--pY;\n\t\t\t}\n\t\t} else if ( in == \"n\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( pY < line - 1 ) {\n\t\t\t\t++pY;\n\t\t\t}\n\t\t} else if ( in == \"f\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\t++pX;\n\t\t\t} else {\n\t\t\t\tif ( pY < line - 1 ) {\n\t\t\t\t\tpX = 0;\n\t\t\t\t\t++pY;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( in == \"b\" ) {\n\t\t\tif ( 0 < pX ) {\n\t\t\t\t--pX;\n\t\t\t} else {\n\t\t\t\tif ( 0 < pY ) {\n\t\t\t\t\t--pY;\n\t\t\t\t\tpX = s[ pY ].length();\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( in == \"d\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + s[ pY ].substr( pX + 1 );\n\t\t\t} else if ( pY < line - 1 ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\t--line;\n\t\t\t}\n\t\t} else if ( in == \"k\" ) {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\tbuf = s[ pY ].substr( pX );\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t} else if ( pY < line - 1 ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\t--line;\n\t\t\t\tbuf = \"\\n\";\n\t\t\t}\n\t\t} else if ( in == \"y\" ) {\n\t\t\tif ( !buf.empty() ) {\n\t\t\t\tif ( buf == \"\\n\" ) {\n\t\t\t\t\tfor ( int i = line - 1; pY < i; --i ) {\n\t\t\t\t\t\ts[ i ] = s[ i - 1 ];\n\t\t\t\t\t}\n\t\t\t\t\ts[ pY + 1 ] = s[ pY ].substr( pX );\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t\t\t++line;\n\t\t\t\t} else {\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + buf + s[ pY ].substr( pX );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor ( int i = 0; i < line; ++i ) cout << s[ i ] << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t,u;\nvector<char> tmp;\nvector<char> z;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nvoid yinsert(int,vector<char>);\nvoid xinsert(int,int,char);\nvoid ydelete(int);\nvoid xdelete(int,int);\n\nint main(){\n\n  t.clear();\n  tmp.clear();\n  input();\n  x=y=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n    //cout<<y<<' '<<x<<\" ty\"<<t.size()<<endl;\n  }\n\n  for(int i=0;i<t.size();i++){\n    for(int j=0;j<t[i].size();j++){\n      cout<<t[i][j];\n    }\n  }\n\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    xdelete(y,x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  xdelete(y,x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  ydelete(y+1);\n}\n\nvoid funcK(){\n  tmp.clear();\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.push_back('\\n');\n    }\n    return;\n  }\n  while(t[y][x]!='\\n'){\n    tmp.push_back(t[y][x]);\n    xdelete(y,x);\n  }\n  reverse(tmp.begin(),tmp.end());\n  //funcE();\n}\n\nvoid funcY(){\n  z.clear();\n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    while(t[y][x]!='\\n'){\n      z.push_back(t[y][x]);\n      xdelete(y,x);\n    }\n    yinsert(y+1,z);\n    y++;\n    x=0;\n    return;\n  }\n  for(int i=0;i<(int)tmp.size();i++){\n    xinsert(y,x,tmp[i]);\n  }\n  //funcE();\n}\n\nvoid input(){\n  vector<char> a;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<string> l;\nstring buffer;\nint X = 0 , Y = 0;\nvoid a(){ X = 0; }\nvoid e(){ X = l[Y].size()-1; }\nvoid p(){ Y = max<int>(0,Y-1) ; a(); }\nvoid n(){ Y = min<int>(l.size()-1,Y+1); a(); }\nvoid f(){ if(X != l[Y].size()-1){X++;}else{n();} }\nvoid b(){ if(X != 0){X--;}else{p(),e();} }\nvoid d(){\n\tif(l[Y][X] != '\\n'){\n\t\tl[Y] = l[Y].substr(0,X) + l[Y].substr(X+1);\n\t}else{\n\t\tl[Y] = Y==l.size()-1?l[Y]:l[Y].substr(0,l[Y].size()-1) + l[Y+1];\n\t\tvector<string> p;\n\t\tfor(int i = 0 ; i < l.size() ; i++){\n\t\t\tif(i != Y+1) p.push_back(l[i]);\n\t\t}\n\t\tl = p;\n\t}\n}\nvoid k(){\n\tif(l[Y][X] == '\\n'){\n\t\tif( Y != l.size()-1){\n\t\t\tbuffer = \"\\n\";\n\t\t\td();\n\t\t}\n\t\t//X = l[Y].size()-1;\n\t}else{\n\t\tbuffer = l[Y].substr(X);\n\t\tbuffer = l[Y].substr(0,buffer.size()-1);\n\t\tl[Y] = l[Y].substr(0,X) + \"\\n\";\n\t}\n}\nvoid y(){\n\tif(buffer != \"\"){\n\t\tif(buffer == \"\\n\"){\n\t\t\tvector<string> p;\n\t\t\tcout << \"{{\" << l[Y].substr(X) << \"}\" << endl;\n\t\t\tfor(int i = 0 ; i < l.size() ; i++){\n\t\t\t\tp.push_back(l[i]);\n\t\t\t\tif(i==Y)p.push_back(l[i].substr(X));\n\t\t\t}\n\t\t\tp[Y] = p[Y].substr(0,X) + \"\\n\";\n\t\t\tl = p;\n\t\t\tn();\n\t\t}else{\n\t\t\tl[Y].insert(X,buffer);\n\t\t\tX += buffer.size();\n\t\t}\n\t}\n}\nint main(){\n\tstring s;\n\twhile(getline(cin,s),s != \"END_OF_TEXT\"){\n\t\tl.push_back(s+\"\\n\");\n\t}\n\twhile(l.size() == 0);\n\twhile(cin >> s , s != \"-\"){\n\t\tif(s==\"a\")a();\n\t\tif(s==\"e\")e();\n\t\tif(s==\"p\")p();\n\t\tif(s==\"n\")n();\n\t\tif(s==\"f\")f();\n\t\tif(s==\"b\")b();\n\t\tif(s==\"d\")d();\n\t\tif(s==\"k\")k();\n\t\tif(s==\"y\")y();\n\t}\n\tfor(int i = 0 ; i < l.size() ; i++)\n\t\tcout << l[i];\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[1024];\nstring buf;\nint lines;\nvoid delete_line(int y)\n{\n    for (int i = y; y < lines; ++y)\n\ts[i] = s[i + 1];\n    s[--lines] = \"\";\n    if (lines <= 0)\n\tlines = 1;\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; --i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    while (true)\n    {\n\tstring t;\n\tgetline(cin, t);\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines++] = t;\n    }\n    if (lines == 0)\n    {\n\tcout << \"\" << endl;\n\treturn 0;\n    }\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    y = max(0, --y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    y = min(lines - 1, ++y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y + 1 != lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t\tx = 0, --y;\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t    {\n\t\tif (x < s[y].size())\n\t\t{\n\t\t    s[y].erase(x, 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t    s[y] += s[y + 1];\n\t\t    delete_line(y + 1);\n\t\t}\n\t    }\n\t    break;\n\t \n\t}\n\tcase 'k':\n\t{\n\t    if (x == s[y].size())\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    else if (!s[y].empty())\n\t    {\n\t\tif (x < s[y].size())\n\t\t{\n\t\t    buf = s[y].substr(x);\n\t\t    s[y].erase(x);\n\t\t}\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\tif (!s[y].empty())\n\t\t{\n\t\t    if (x < s[y].size())\n\t\t    {\n\t\t\ts[y + 1] = s[y].substr(x);\n\t\t\ts[y].erase(x);\n\t\t    }\n\t\t}\n\t\tx = 0, ++y;\n\t    }\n\t    else if (!buf.empty())\n\t\ts[y] += buf;\n\t    break;\n\t}\n\t}\n\n\ty = min(lines - 1, max(0, y));\n\tx = max(0, min(x, (int)s[y].size()));\n    }\n\n    for (int i = 0; i < lines; ++i)\n\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[110];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tif(i<110) t[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tif(row<110) col = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 && row < 110 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row < 110 && row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( row < 110 && col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else if( row < 110 ){\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( row < 110 && buf == \"\\n\" ){\n\t\t\t\t\t/*for(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line+1 < 110 && line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\tt[row+1] = t[row].substr( col );\n\t\t\t\t\tt[row].erase( col );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;*/\n\t\t\t\t}else if( row < 110 ){\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main(){\n\tstring s[500];\n\tint line = 0;\n\tchar cs[100];\n\tfor ( string in; gets( cs ), in = string( cs ), in != \"END_OF_TEXT\"; ++line ){\n\t\ts[ line ] = in;\n\t}\n\t\n\tint pX = 0;\n\tint pY = 0;\n\t\n\tstring buf;\n\tfor ( string in; cin >> in, in != \"-\"; ) {\n\t\tif ( in == \"a\" ) {\n\t\t\tpX = 0;\n\t\t} else if ( in == \"e\" ) {\n\t\t\tpX = s[ pY ].length();\n\t\t} else if ( in == \"p\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( 0 != pY ) {\n\t\t\t\t--pY;\n\t\t\t}\n\t\t} else if ( in == \"n\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( pY != line - 1 ) {\n\t\t\t\t++pY;\n\t\t\t}\n\t\t} else if ( in == \"f\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\t++pX;\n\t\t\t} else if ( pY != line - 1 ) {\n\t\t\t\tpX = 0;\n\t\t\t\t++pY;\n\t\t\t}\n\t\t} else if ( in == \"b\" ) {\n\t\t\tif ( 0 < pX ) {\n\t\t\t\t--pX;\n\t\t\t} else {\n\t\t\t\tif ( 0 < pY ) {\n\t\t\t\t\t--pY;\n\t\t\t\t\tpX = s[ pY ].length();\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( in == \"d\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + s[ pY ].substr( pX + 1 );\n\t\t\t} else if ( pY < line - 1 ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\ts[ line - 1 ] = \"\";\n\t\t\t\t--line;\n\t\t\t}\n\t\t} else if ( in == \"k\" ) {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\tbuf = s[ pY ].substr( pX );\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t} else if ( pY < line - 1 ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\ts[ line - 1 ] = \"\";\n\t\t\t\t--line;\n\t\t\t\tbuf = \"\\n\";\n\t\t\t}\n\t\t} else if ( in == \"y\" ) {\n\t\t\tif ( !buf.empty() ) {\n\t\t\t\tif ( buf == \"\\n\" ) {\n\t\t\t\t\tfor ( int i = line - 1; pY <= i; --i ) {\n\t\t\t\t\t\ts[ i + 1 ] = s[ i ];\n\t\t\t\t\t}\n\t\t\t\t\ts[ pY + 1 ] = s[ pY ].substr( pX );\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t\t\t++line;\n\t\t\t\t} else {\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + buf + s[ pY ].substr( pX );\n\t\t\t\t\tpX += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor ( int i = 0; i < line; ++i ) cout << s[ i ] << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(5)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<short, short> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 100000007;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator > (const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nvector<string> s;\nint x, y;\n\nvoid gotoend()\n{\n\ty = s[x].size();\n}\n\nvoid gotohome()\n{\n\ty = 0;\n}\n\nint check()\n{\n\tif (s[x].size() == 0) return 1;\n\telse if (y == s[x].size()) return 2;\n\telse return 0;\n}\n\n\nint main()\n{\n\tx = 0; y = 0;\n\tstring tmp;\n\tstring buf = \"@\";\n\twhile (1)\n\t{\n\t\tcin >> tmp;\n\t\tif (tmp == \"END_OF_TEXT\") break;\n\t\ts.push_back(tmp);\n\t}\n\tchar com;\n\twhile (cin >> com)\n\t{\n\t\tif (com == '-') break;\n\t\telse if (com == 'a') gotohome();\n\t\telse if (com == 'e') gotoend();\n\t\telse if (com == 'p')\n\t\t{\n\t\t\tif (x == 0) gotohome();\n\t\t\telse \n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'n')\n\t\t{\n\t\t\tif (x != s.size() - 1) x++;\n\t\t\tgotohome();\n\t\t}\n\t\telse if (com == 'f')\n\t\t{\n\t\t\tif (check() == 0) y++;\n\t\t\telse if (x != s.size() - 1)\n\t\t\t{\n\t\t\t\tx++;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'b')\n\t\t{\n\t\t\tif (y != 0) y--;\n\t\t\telse if (y == 0 && x > 0)\n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tgotoend();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'd')\n\t\t{\n\t\t\tif (check() == 0) s[x].erase(y, 1);\n\t\t\telse if (check() == 2 && x < s.size() - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\tint t = x + 1;\n\t\t\t\twhile (t < s.size() - 1)\n\t\t\t\t{\n\t\t\t\t\ts[t] = s[t + 1];\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t\ts.pop_back();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'k')\n\t\t{\n\t\t\tif (check() != 0 && x < s.size() - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\tint t = x + 1;\n\t\t\t\twhile (t < s.size() - 1)\n\t\t\t\t{\n\t\t\t\t\ts[t] = s[t + 1];\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t\ts.pop_back();\n\t\t\t\tbuf = \"#\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbuf = s[x].substr(y);\n\t\t\t\ts[x].erase(y);\n\t\t\t}\n\t\t}\n\t\telse if (com == 'y')\n\t\t{\n\t\t\tif (buf == \"@\") continue;\n\t\t\telse if (buf == \"#\")\n\t\t\t{\n\t\t\t\tint t = s.size() - 1;\n\t\t\t\ts.push_back(\"\");\n\t\t\t\twhile (t > x)\n\t\t\t\t{\n\t\t\t\t\ts[t + 1] = s[t];\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t\ts[x + 1] = s[x].substr(y);\n\t\t\t\ts[x].erase(y);\n\t\t\t\tx++;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts[x].insert(y, buf);\n\t\t\t\ty += buf.size();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tREP(i, s.size())\n\t\t{\n\t\t\tcout << s[i] << endl;\n\t\t}\n\t\tcout << x << \" \" << y << endl;\n\t\tcout << buf;\n\t\tcout << endl << endl;\n\t\t/*/\n\t}\n\tREP(i, s.size())\n\t{\n\t\tcout << s[i] << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[1024];\nstring buf;\nint lines = 0;\nvoid delete_line(int y)\n{\n    for (int i = y; y < lines; ++y)\n\ts[i] = s[i + 1];\n    s[--lines] = \"\";\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; ++i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    for ( ; ; ++lines)\n    {\n\tstring t;\n\tcin >> t;\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines] = t;\n    }\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    if (y != 0)\n\t\t--y;\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    if (y != lines)\n\t\t++y;\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y != lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t\tx = 0, --y;\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t\ts[y].erase(x, 1);\n\t    else\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t    }\n\t    break;\n\t}\n\tcase 'k':\n\t{\n\t    if (x == s[y].size())\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    else\n\t    {\n\t\tbuf = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\ts[y + 1] = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = 0, ++y;\n\t    }\n\t    else if (!buf.empty())\n\t\ts[y] += buf;\n\t    break;\n\t}\n\t}\n    }\n\n    for (int i = 0; i < lines; ++i)\n\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nchar t[2000000];\nint ts;\n\nchar u[1000000];\nint us;\n\nchar ch;\nint pos;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nint main(){\n\n  input();\n  pos=0;\n\n  while(1){\n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    /*\n    cout<<ch<<' '<<pos<<endl;\n    for(int i=0;i<ts;i++){\n      cout<<t[i];\n    }\n    cout<<endl;\n    */\n  }\n    for(int i=0;i<ts;i++){\n      cout<<t[i];\n    }\n\n  return 0;\n}\n\nvoid funcA(){\n  for(int i=pos-1;;i--){\n    if(i<=0){pos=0;return;}\n    if(t[i]=='\\n'){pos=i+1;return;}\n  }\n}\n\nvoid funcE(){\n  for(int i=pos;;i++){\n    if(i>=ts){pos=ts-1;return;}\n    if(t[i]=='\\n'){pos=i;return;}\n  }\n}\n\nvoid funcP(){\n  funcA();\n  if(pos==0)return;\n  pos--;\n  funcA();\n}\n\nvoid funcN(){ \n  funcE();\n  if(pos==ts-1){\n    funcA();\n    return;\n  }else{\n    pos++;\n  }\n}\n\nvoid funcF(){ \n  if(pos+1<ts)pos++;\n}\n\nvoid funcB(){\n  if(pos>0)pos--;\n}\n\nvoid funcD(){\n  if(pos==ts-1)return;\n  ts--;\n  for(int i=pos;i<ts;i++){\n    t[i]=t[i+1];\n  }\n}\n\nvoid funcK(){\n  if(pos==ts-1)return;\n\n  if(t[pos]=='\\n'){\n    us=1;\n    u[0]='\\n';\n    funcD();\n    return;\n  }\n  us=0;\n  int c=0;\n  for(int i=pos;;i++){\n    if(t[i]=='\\n')break;\n    u[us++]=t[i];\n    c++;\n  }\n  ts-=c;\n  for(int i=pos;i<ts;i++){\n    t[i]=t[i+c];\n  }\n}\n\nvoid funcY(){\n  if(us==0)return;\n  if(u[0]=='\\n'&&us==1){\n    ts++;\n    for(int i=ts-1;i>pos;i--)t[i]=t[i-1];\n    t[pos]='\\n';\n    pos++;return;\n  }\n  \n  ts+=us;\n  for(int i=ts-1;i>=pos+us;i--){\n    t[i]=t[i-us];\n  }\n  for(int i=pos;i<pos+us;i++){\n    t[i]=u[i-pos];\n  }\n  pos+=us;\n}\n\nvoid input(){\n  ts=us=0;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    for(int i=0;i<(int)str.size();i++)\n      t[ts++]=str[i];\n    t[ts++]='\\n';\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nvoid convert(string& text, int& cursor, string& buffer, char command);\n\nint main()\n{\t\n\tstring text, buffer;\n\tint cursor = 0;\n\t\n\tfor(string line; getline(cin, line) && line != \"END_OF_TEXT\"; text += line + '\\n');\n\tfor(char command; cin >> command && command != '-'; convert(text, cursor, buffer, command));\n\t\n\tcout << text;\n}\n\nvoid convert(string& text, int& cursor, string& buffer, char command)\n{\t\n\tswitch(command)\n\t{\n\t\t\t/*\n\t\t\t a\n\t\t\t J[\\ð»ÝÌsÌæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'a':\n\t\t{\n\t\t\tif(cursor != 0 && text[cursor - 1] != '\\n')\n\t\t\twhile(--cursor) if(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tcursor++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t e\n\t\t\t J[\\ð»ÝÌsÌsÉÚ®·éB\n\t\t\t */\n\t\tcase 'e':\n\t\t{\n\t\t\twhile(text[cursor] != '\\n') cursor++;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t p\n\t\t\t ãÉsª êÎAJ[\\ðãÌsÌæª¶ÉÚ®·éB\n\t\t\t ãÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'p':\n\t\t{\n\t\t\tsize_t pos = text.rfind(\"\\n\", text.rfind(\"\\n\", cursor) - 1);\n\t\t\t\n\t\t\tcursor = (pos == string::npos ? 0 : pos);\n\t\t\t\n\t\t\t/*\n\t\t\tif(cursor != 0) while(--cursor) if(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(cursor != 0) while(--cursor) if(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tcursor++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t */\n\t\t\t\n\t\t\t\n\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t n\n\t\t\t ºÉsª êÎAJ[\\ðºÌsÌæª¶ÉÚ®·éB\n\t\t\t ºÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'n':\n\t\t{\n\t\t\tint cur = cursor;\n\t\t\twhile(text[cur] != '\\n') cur++;\n\t\t\t\n\t\t\tif(cur + 1 == text.size())\n\t\t\t{\n\t\t\t\tif(cursor != 0) while(--cursor) if(text[cursor] == '\\n')\n\t\t\t\t{\n\t\t\t\t\tcursor++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcursor = cur + 1;\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t f\n\t\t\t J[\\ªsÉÈ¢êAJ[\\ðPÂEÉÚ®·éB\n\t\t\t J[\\ªsÉ è©ÂºÉsª éêÍAJ[\\ðºÌsÌæª¶ÖÚ®·éB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'f':\n\t\t{\n\t\t\tcursor += cursor + 1 != text.size();\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t b\n\t\t\t J[\\ªæª¶ÅÈ¢ÈçÎAJ[\\ðPÂ¶ÉÚ®·éB\n\t\t\t J[\\ªæª¶Å è©ÂãÉsª éêÍAJ[\\ðãÌsÌsÖÚ®·éB\n\t\t\t »êÈOÌêÍ½àµÈ¢\n\t\t\t */\n\t\tcase 'b':\n\t\t{\n\t\t\tcursor -= 0 < cursor;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t d\n\t\t\t J[\\ª¶ðw·êÍ»Ì¶ðí·éBí³ê½¶ÌE¤Ì¶ñÍ¶ÉVtg³êéB\n\t\t\t J[\\ªsðwµºÉsª éêÍAºÌsð»ÌÜÜJ[\\ÌÊuÉq°éBÈºÌsÍãÉVtg³êéB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'd':\n\t\t{\n\t\t\tif(cursor + 1 != text.size()) text.erase(text.begin() + cursor);\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t k\n\t\t\t J[\\ªsÉ éêAºÉsª êÎAd Æ¯¶ìðµobt@ÉPÂÌüsðL^·éB\n\t\t\t J[\\ªsÉÈ¢êAJ[\\ªw·¶ðÜß½E¤·×ÄÌ¶ðØèæè»êðobt@ÉL^·éBJ[\\Í³ÌsÌsðw·æ¤ÉÈéBSÄÌL^É¨¢Äobt@Íã«³êéB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'k':\n\t\t{\n\t\t\tbuffer = \"\";\n\t\t\tif(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tif(cursor + 1 == text.size())\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tbuffer = \"\\n\";\n\t\t\t\ttext.erase(text.begin() + cursor);\n\t\t\t}\n\t\t\telse while(text[cursor] != '\\n')\n\t\t\t{\n\t\t\t\tbuffer += text[cursor];\n\t\t\t\ttext.erase(text.begin() + cursor);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t y\n\t\t\t obt@ªóÌêÍÈÉàµÈ¢B\n\t\t\t obt@ÌàeªüsÌêAJ[\\ªw·¶Ì¼OÅüsðs¤BJ[\\ÍVµ¢sÌæª¶ÖÚ®·éB\n\t\t\t obt@Ìàeª¶ñÌêAJ[\\ÌÊuÉobt@Ìàeð}ü·éB J[\\ÌÊuÍàÆàÆwµÄ¢½¶Ü½ÍsÌêÖÚ®·é\n\t\t\t */\n\t\tcase 'y':\n\t\t{\n\t\t\ttext = text.substr(0, cursor) + buffer + text.substr(cursor);\n\t\t\tcursor += buffer.size();\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY = 0;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n\telse return;\n}\n\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\\n\";\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring front=\"\";\n\t\tstring rear=\"\";\n\t\tfront = lines[posY].substr(0,posX);\n\t\trear = lines[posY].substr(posX,lines[posY].size()-posX);\t\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX);\n\n\t\tlines[posY] = front;\n\t\tdeque<string>::iterator it = lines.begin();\n\t\tadvance(it,posY);\n\t\tlines.insert(it,rear);\n\t}\n\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(getline(cin,str)){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(cin >> str){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\tif(str == \"d\") ctrl_d(lines);\n\t\tif(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass state{\nprivate:\n  int cursor;\n  string str, buffer;\n\npublic:\n  state(string str = \"\"):str(str){\n    cursor = 0;\n    buffer = \"\";\n  }\n\n  void typeA(){\n    for(int i=cursor;i>=0;i--){\n      cursor = i;\n      if(i > 0 && str[i-1] == '\\n') break;\n    }\n  }\n\n  void typeE(){\n    for(int i=cursor;i<str.size();i++){\n      cursor = i;\n      if(str[i] == '\\n') break;\n    }\n  }\n\n  void typeP(){\n    bool isUpper = false;\n    for(int i=cursor;i>=0;i--){\n      if(i == 0 || i > 0 && str[i-1] == '\\n'){\n        cursor = i;\n        if(isUpper) break;\n        else isUpper = true;\n      }\n    }\n  }\n\n  void typeN(){\n    bool isDowner = false;\n    for(int i=cursor;i<str.size();i++){\n      if(str[i] == '\\n' && i < (int)str.size() - 1){\n        isDowner = true;\n        cursor = i + 1;\n        break;\n      }\n    }\n\n    if(!isDowner){\n      typeA();\n    }\n  }\n\n  void typeF(){\n    if(cursor < (int)str.size()-1){\n      cursor++;\n    }\n  }\n  \n  void typeB(){\n    if(cursor > 0) {\n      cursor--;\n    }\n  }\n\n  void typeD(){\n    if(cursor < (int)str.size()-1){\n      str.erase(str.begin()+cursor);\n    }\n  }\n\n  void typeK(){\n    if(str[cursor] == '\\n' && cursor < (int)str.size()-1){\n      typeD();\n      buffer = \"\\n\";\n    } else if(str[cursor] != '\\n'){\n      for(int i=cursor;i<(int)str.size();i++){\n        if(str[i] == '\\n'){\n          buffer = string(str.begin()+cursor, str.begin()+i);\n          str.erase(str.begin()+cursor, str.begin()+i);\n        }\n      }\n    }\n  }\n\n  void typeY(){\n    str.insert(str.begin()+cursor, buffer.begin(), buffer.end());\n    cursor += buffer.size();\n    //buffer = \"\";\n  }\n\n  string toString(){\n    return str;\n  }\n};\n\nstring inputStr(){\n  string str = \"\", in;\n  while(cin >> in){\n    if(in == \"END_OF_TEXT\") break;\n    str += in + '\\n';\n  }\n  return str;\n}\n\nvoid inputCommand(state &dat){\n  string command;\n  while(cin >> command){\n    if(command == \"-\") break;\n    else if(command == \"a\") dat.typeA();\n    else if(command == \"e\") dat.typeE();\n    else if(command == \"p\") dat.typeP();\n    else if(command == \"n\") dat.typeN();\n    else if(command == \"f\") dat.typeF();\n    else if(command == \"b\") dat.typeB();\n    else if(command == \"d\") dat.typeD();\n    else if(command == \"k\") dat.typeK();\n    else if(command == \"y\") dat.typeY();\n  }\n}\n\nvoid outputCommand(state &dat){\n  cout << dat.toString() << flush;\n}\n\nint main(){\n  while(1){\n    state dat = state(inputStr());\n    if(dat.toString() == \"\") break;\n    inputCommand(dat);\n    outputCommand(dat);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[128];\nstring buf;\nint lines;\nvoid delete_line(int y)\n{\n    for (int i = y; y < lines; ++y)\n\ts[i] = s[i + 1];\n    s[lines = max(1, --lines)] = \"\";\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; --i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    while (true)\n    {\n\tstring t;\n\tgetline(cin, t);\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines++] = t;\n    }\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    y = max(0, --y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    y = min(lines - 1, ++y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y + 1 != lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t    {\n\t\t--y;\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t\ts[y].erase(x, 1);\n\t    else if (y + 1 != lines)\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t    }\n\t    break;\n\t}\n\tcase 'k':\n\t{\n\t    if (x != s[y].size())\n\t    {\n\t\tbuf = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = s[y].size();\n\t    }\n\t    else if (y + 1 != lines)\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\ts[y + 1] = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = 0, ++y;\n\t    }\n\t    else\n\t\ts[y] += buf;\n\t    break;\n\t}\n\t}\n    }\n\n    for (int i = 0; i < lines; ++i)\n\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(5)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<short, short> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 100000007;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator > (const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nvector<string> s;\nint x, y;\n\nvoid gotoend()\n{\n\ty = s[x].size();\n}\n\nvoid gotohome()\n{\n\ty = 0;\n}\n\nint check()\n{\n\tif (s[x].size() == 0 || y == s[x].size()) return 1;\n\telse return 0;\n}\n\n\nint main()\n{\n\tx = 0; y = 0;\n\tstring tmp;\n\tstring buf = \"karappo!!!!!!!!!\";\n\twhile (1)\n\t{\n\t\tcin >> tmp;\n\t\tif (tmp == \"END_OF_TEXT\") break;\n\t\ts.push_back(tmp);\n\t}\n\tchar com;\n\twhile (cin >> com)\n\t{\n\t\tif (com == '-') break;\n\t\telse if (com == 'a') gotohome();\n\t\telse if (com == 'e') gotoend();\n\t\telse if (com == 'p')\n\t\t{\n\t\t\tif (x == 0) gotohome();\n\t\t\telse \n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'n')\n\t\t{\n\t\t\tif (x < s.size() - 1) x++;\n\t\t\tgotohome();\n\t\t}\n\t\telse if (com == 'f')\n\t\t{\n\t\t\tif (check() == 0) y++;\n\t\t\telse if (check()==1&&x < s.size() - 1)\n\t\t\t{\n\t\t\t\tx++;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'b')\n\t\t{\n\t\t\tif (y != 0) y--;\n\t\t\telse if (y == 0 && x > 0)\n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tgotoend();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'd')\n\t\t{\n\t\t\tif (check() == 0) s[x].erase(y, 1);\n\t\t\telse if (check() == 2 && x < s.size() - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\tint t = x + 1;\n\t\t\t\twhile (t < s.size() - 1)\n\t\t\t\t{\n\t\t\t\t\ts[t] = s[t + 1];\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t\ts.pop_back();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'k')\n\t\t{\n\t\t\tif (check() != 0 && x < s.size() - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\tint t = x + 1;\n\t\t\t\twhile (t < s.size() - 1)\n\t\t\t\t{\n\t\t\t\t\ts[t] = s[t + 1];\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t\ts.pop_back();\n\t\t\t\tbuf = \"kaigyousuru!!!!!!!\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbuf = s[x].substr(y);\n\t\t\t\ts[x].erase(y);\n\t\t\t}\n\t\t}\n\t\telse if (com == 'y')\n\t\t{\n\t\t\tif (buf == \"karappo!!!!!!!!!\") continue;\n\t\t\telse if (buf == \"kaigyousuru!!!!!!!\")\n\t\t\t{\n\t\t\t\tint t = s.size() - 1;\n\t\t\t\ts.push_back(\"\");\n\t\t\t\twhile (t > x)\n\t\t\t\t{\n\t\t\t\t\ts[t + 1] = s[t];\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t\ts[x + 1] = s[x].substr(y);\n\t\t\t\ts[x].erase(y);\n\t\t\t\tx++;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts[x].insert(y, buf);\n\t\t\t\ty += buf.size();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tREP(i, s.size())\n\t\t{\n\t\t\tcout << s[i] << endl;\n\t\t}\n\t\tcout << x << \" \" << y << endl;\n\t\tcout << buf;\n\t\tcout << endl << endl;\n\t\t*/\n\t}\n\tREP(i, s.size())\n\t{\n\t\tcout << s[i] << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[128];\nstring buf;\nint lines;\nvoid delete_line(int y)\n{\n    for (int i = y; y < lines; ++y)\n\ts[i] = s[i + 1];\n    s[--lines] = \"\";\n    if (lines <= 0)\n\tlines = 1;\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; ++i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    while (true)\n    {\n\tstring t;\n\tgetline(cin, t);\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines++] = t;\n    }\n    if (lines == 0)\n    {\n\tcout << \"\" << endl;\n\treturn 0;\n    }\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    y = max(0, --y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    y = min(lines - 1, ++y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y + 1 != lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t\tx = 0, --y;\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t\ts[y].erase(x, 1);\n\t    else\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t    }\n\t    break;\n\t}\n\tcase 'k':\n\t{\n\t    if (x == s[y].size())\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    else if (!s[y].empty())\n\t    {\n\t\tbuf = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\tif (!s[y].empty())\n\t\t{\n\t\t    s[y + 1] = s[y].substr(x);\n\t\t    s[y].erase(x);\n\t\t}\n\t\tx = 0, ++y;\n\t    }\n\t    else if (!buf.empty())\n\t\ts[y] += buf;\n\t    break;\n\t}\n\t}\n    }\n\n    for (int i = 0; i < lines; ++i)\n\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Emacs{\n  int line,column;\n  string buffer;\n  vector<string> text;\n\n  void editText(){\n    for(int i = 0 ; i < (int)text.size() ; i++){\n      if(isEmptyLine(i)){ text[i] = \" \"; }\n    }\n  }\n\n  void order(char command){\n    editText();\n    if(isEmptyLine(line)){ column = 0; }\n    switch(command){\n    case 'a': funcA(); break;\n    case 'e': funcE(); break;\n    case 'p': funcP(); break;\n    case 'n': funcN(); break;\n    case 'f': funcF(); break;\n    case 'b': funcB(); break;\n    case 'd': funcD(); break;\n    case 'k': funcK(); break;\n    case 'y': funcY(); break;\n    }\n  }\n\n  bool isEmptyLine(int l){\n    for(int i = 0 ; i < (int)text[l].size() ; i++){\n      if(text[l][i] != ' '){ return false; }\n    }\n    return true;\n  }\n\n  void funcA(){\n    column = 0;\n  }\n  \n  void funcE(){\n    if(isEmptyLine(line)){ return; }\n    column = text[line].size();\n  }\n\n  void funcP(){\n    if(line > 0){\n      line--;\n    }\n    column = 0;\n  }\n\n  void funcN(){\n    if(line+1 < (int)text.size()){\n      line++;\n    }\n    column = 0;\n  }\n\n  void funcF(){\n    if(isEmptyLine(line)){ return; }\n    if(column == (int)text[line].size()){\n      if(line+1 < (int)text.size()){\n        line++;\n        column = 0;\n      }\n    }else{\n      column++;\n    }\n  }\n  \n  void funcB(){\n    if(column == 0){\n      if(line != 0){\n        line--;\n        column = text[line].size();\n      }\n    }else{\n      column--;\n    }\n  }\n\n  void funcD(){\n    if(isEmptyLine(line)){\n      int len = text.size();\n      vector<string> ntext(len-1);\n      for(int i = 0 ; i < line ; i++){\n        ntext[i] = text[i];\n      }\n      for(int i = line ; i < len-1 ; i++){\n        ntext[i] = text[i+1];\n      }\n      text = ntext;\n      return;\n    }\n    if(0 <= column && column < (int)text[line].size()){\n      text[line] = text[line].substr(0,column) + text[line].substr(column+1);\n    }else{\n      int len = text.size();\n      if(line+1 < len){\n        vector<string> ntext(len-1);\n        for(int i = 0 ; i < line-1 ; i++){\n          ntext[i] = text[i];\n        }\n        ntext[line] = text[line] + text[line+1];\n        for(int i = line+2 ; i < len ; i++){\n          ntext[i] = text[i];\n        }\n        text = ntext;\n      }\n    }\n  }\n\n  void funcK(){\n    int len = text[line].size();\n    if(isEmptyLine(line)){\n      buffer = \"\\n\";\n      int len = text.size();\n      vector<string> ntext(len-1);\n      for(int i = 0 ; i < line ; i++){\n        ntext[i] = text[i];\n      }\n      for(int i = line ; i < len-1 ; i++){\n        ntext[i] = text[i+1];\n      }\n      text = ntext;\n      return;\n    }\n    if(column == len){\n      int len2 = text.size();\n      if(line+1 < len2){\n        buffer = \"\\n\";\n        vector<string> ntext(len2-1);\n        for(int i = 0 ; i < line-1 ; i++){\n          ntext[i] = text[i];\n        }\n        ntext[line] = text[line] + text[line+1];\n        for(int i = line+2 ; i < len ; i++){\n          ntext[i] = text[i];\n        }\n        text = ntext;\n      }\n    }else{\n      buffer.clear();\n      for(int i = column ; i < len ; i++){\n        buffer += text[line][i];\n      }\n      text[line].resize(column);\n    }\n  }\n\n  void funcY(){\n    if(buffer.empty()){ return; }\n    if(buffer == \"\\n\"){\n      string str = text[line];\n      text[line] = str.substr(0,column);\n      if(line+1 < (int)text.size()){\n        text[line+1] = str.substr(column) + text[line+1];\n      }else{\n        text.push_back(str.substr(column));\n      }\n    }else{\n      string str = text[line];\n      str = str.substr(0,column) + buffer + str.substr(column);\n      text[line] = str;\n      column = text[line].size();\n    }\n  }\n\n  void print(){\n    int len = text.size();\n    for(int i = 0 ; i < len ; i++){\n      cout << text[i] << endl;\n    }\n  }\n};\n\nint main(){\n  Emacs emacs;\n  string str;\n  while(getline(cin,str), str != \"END_OF_TEXT\"){\n    emacs.text.push_back(str);\n  }\n  emacs.line = emacs.column = 0;\n  char command;\n  while(cin >> command, command != '-'){\n    emacs.order(command);\n  }\n  emacs.print();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nint main(){\n  vector<string> text(200);\n  int line = 0;\n  for(;line<11;line++){\n    getline(cin,text[line],'\\n');\n    if (text[line]==\"END_OF_TEXT\")\n      break;\n  }\n  string buf=\"\";\n  int cur[2];\n  cur[0] = 0;//0s\n  cur[1] = 0;//0¶Ú\n\n  while(true){\n    char com;\n    cin >> com;\n    if (com == '-')\n      break;\n    switch (com){\n    case 'a':\n      cur[1] = 0;\n      break;\n    case 'e':\n      cur[1] = (int)text[cur[0]].size();\n      break;\n    case 'p':\n      if (cur[0]>0)\n\tcur[0]--;\n      cur[1]=0;\n      break;\n    case 'n':\n      if (cur[0]<line-1)\n\tcur[0]++;\n      cur[1]=0;\n      break;\n    case 'f':\n      if (cur[1]<(int)text[cur[0]].size()){\n\tcur[1]++;\n      }\n      else{\n\tif (cur[0]<line-1){\n\t  cur[0]++;\n\t  cur[1]=0;\t\n\t}\n      }\n      break;\n    case 'b':\n      if (cur[1]>0)\n\tcur[1]--;\n      else{\n\tif (cur[0]>0){\n\t  cur[0]--;\n\t  cur[1]=(int)text[cur[0]].size();\t\n\t}\n      }\n      break;\n    case 'd':\n      if (cur[1]<(int)text[cur[0]].size()){\n\ttext[cur[0]] = text[cur[0]].substr(0,cur[1])+text[cur[0]].substr(cur[1]+1);\n      }\n      else{\n\tif (cur[0]<line-1){\n\t  text[cur[0]] = text[cur[0]]+text[cur[0]+1];\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i] = text[i+1];\n\t  line--;\n\t}\n      }\n      break;\n    case 'k':\n      if (cur[1]==(int)text[cur[0]].size()){\n\tif (cur[0]<line-1){\n\t  text[cur[0]] = text[cur[0]]+text[cur[0]+1];\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i] = text[i+1];\n\t  line--;\n\t  buf = \"\\n\";\n\t}\n      }\n      else{\n\tbuf = text[cur[0]].substr(cur[1]);\n\ttext[cur[0]] = text[cur[0]].substr(0,cur[1]);\n\tcur[1] = (int)text[cur[0]].size();\n      }\n      break;\n    case 'y':\n      if (buf.empty())\n\tbreak;\n      else{\n\tif (buf == \"\\n\"){\n\t  for(int i=line+1;i>=cur[0]+1;i--)\n\t    text[i+1] = text[i];\n\t  line++;\n\t  text[cur[0]+1] = text[cur[0]].substr(cur[1]);\n\t  text[cur[0]] = text[cur[0]].substr(0,cur[1]);\n\t  cur[0]++;\n\t  cur[1]=0;\n\t}\n\telse{\n\t  text[cur[0]] = text[cur[0]].substr(0,cur[1])+buf+text[cur[0]].substr(cur[1]);\n\t  cur[1] += buf.size();\n\t}\n      }\n    default:\n      break;\n    }\n    /*         for(int i=0;i<line;i++)\n\tcout << text[i] << endl;\n\tcout << \"(\" << cur[0] << \",\" << cur[1] << \")\" << endl;\n\tcout << \"#\" << endl;*/\n  }\n  for(int i=0;i<line;i++)\n    cout << text[i] << endl;\n  return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t;\nvector<char> tmp;\n\nchar ch;\nint x,y;\n\nbool input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nint main(){\n  while(1){\n    t.clear();\n    tmp.clear();\n    if(input()==false)break;\n    x=y=0;\n    while(1){\n      cin>>ch;\n      if(ch=='a')funcA();\n      else if(ch=='e')funcE();\n      else if(ch=='p')funcP();\n      else if(ch=='n')funcN();\n      else if(ch=='f')funcF();\n      else if(ch=='b')funcB();\n      else if(ch=='d')funcD();\n      else if(ch=='k')funcK();\n      else if(ch=='y')funcY();\n      else break;\n      \n    }\n    \n    for(int i=0;i<t.size();i++){\n      for(int j=0;j<t[i].size();j++){\n\tcout<<t[i][j];\n      }\n    }\n  }\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    t[y].erase(t[y].begin()+x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  t[y].erase(t[y].begin()+x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  t.erase(t.begin()+y+1);\n}\n\nvoid funcK(){\n  tmp.clear();\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.push_back('\\n');\n    }\n    return;\n  }\n  int c=0;\n  for(int i=x;i+1<(int)t[y].size();i++){\n    tmp.push_back(t[y][i]);\n    c++;\n  }\n  for(int i=0;i<=c;i++)t[y].pop_back();\n  t[y].push_back('\\n');\n  reverse(tmp.begin(),tmp.end());\n}\n\nvoid funcY(){\n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    vector<char> z;\n    int c=0;\n    for(int i=x;i<(int)t[y].size();i++){\n      z.push_back(t[y][i]);\n      c++;\n    }\n    for(int i=0;i<=c;i++)t[y].pop_back();\n    t[y].push_back('\\n');\n    t.insert(t.begin()+y+1,z);\n    y++;\n    x=0;\n    return;\n  }\n\n  for(int i=0;i<(int)tmp.size();i++){\n    t[y].insert(t[y].begin()+x,tmp[i]);\n  }\n  funcE();\n\n}\n\nbool input(){\n  vector<char> a;\n  string str;\n  while(1){\n    if(getline(cin,str)==false)return false;\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n  return true;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n\n\nstring ed;\nint cur;\n\nvoid head(){\n  while(cur>0 && ed[cur-1]!='\\n')--cur;\n}\n\nvoid tail(){\n  while(cur<ed.size() && ed[cur]!='\\n')++cur;\n}\n\nvoid pr(){\n  rep(i,ed.size()){\n    if(i==cur)cout<<\"_\";\n    cout<<ed[i];\n  }\n}\n\nmain(){\n  string str;\n  string end=\"END_OF_TEXT\";\n  ed=\"\";\n\n  while(getline(cin,str)){\n    if(end==str)break;\n    ed+=str+\"\\n\";\n  }\n  \n  string buffer=\"\";\n  \n  char c;\n  while(cin>>c){\n    if(c=='-')break;\n    //pr();\n    //cout<<c<<endl;\n    switch(c){\n    case 'a':\n      head();\n      break;\n    case 'e':\n      tail();\n      break;\n    case 'p':\n      head();\n      if(cur)--cur;\n      head();\n      break;\n    case 'n':\n      tail();\n      if(cur+1<ed.size())cur++;\n      head();\n      break;\n    case 'f':\n      if(cur+1<ed.size())cur++;\n      break;\n    case 'b':\n      if(cur)--cur;\n      break;\n    case 'd':\n      if(cur<ed.size()-1)ed.erase(cur,1);\n      break;\n    case 'k':\n      if(ed[cur]=='\\n'){\n        ed.erase(cur,1);\n        buffer=\"\\n\";\n      }else{\n        int pos=0;\n        while(ed[cur+pos]!='\\n')++pos;\n        buffer=ed.substr(cur,pos);\n        ed.erase(cur,pos);\n      }\n      break;\n    case 'y':\n      ed.insert(cur,buffer);\n      cur+=buffer.size();\n      break;\n    }\n  }\n  cout<<ed;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t,u;\nvector<char> tmp;\nvector<char> z;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nvoid yinsert(int,vector<char>);\nvoid xinsert(int,int,char);\nvoid ydelete(int);\nvoid xdelete(int,int);\n\nint main(){\n\n  t.clear();\n  tmp.clear();\n  input();\n  x=y=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n    //cout<<y<<' '<<x<<\" ty\"<<t.size()<<endl;\n  }\n\n  for(int i=0;i<t.size();i++){\n    for(int j=0;j<t[i].size();j++){\n      cout<<t[i][j];\n    }\n  }\n\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    xdelete(y,x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  xdelete(y,x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  ydelete(y+1);\n}\n\nvoid funcK(){\n  tmp.clear();\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.push_back('\\n');\n    }\n    return;\n  }\n  while(t[y][x]!='\\n'){\n    tmp.push_back(t[y][x]);\n    xdelete(y,x);\n  }\n  reverse(tmp.begin(),tmp.end());\n  //funcE();\n}\n\nvoid funcY(){\n  z.clear();\n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    while(t[y][x]!='\\n'){\n      z.push_back(t[y][x]);\n      xdelete(y,x);\n    }\n    yinsert(y+1,z);\n    //y++;\n    //x=0;\n    return;\n  }\n  for(int i=0;i<(int)tmp.size();i++){\n    xinsert(y,x,tmp[i]);\n  }\n  //funcE();\n}\n\nvoid input(){\n  vector<char> a;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n}\n\n\n\n\n\n\n\n\nvoid xinsert(int y,int x,char ch){\n  if(x==(int)t[y].size()){\n    t[y].push_back(ch);\n  }else{\n    \n    z=t[y];\n    t[y].clear();\n    for(int i=0;i<(int)z.size();i++){\n      if(i==x)t[y].push_back(ch);\n      t[y].push_back(z[i]);\n    }\n  }\n}\n\nvoid xdelete(int y,int x){\n  if(x+1==(int)t[y].size()){\n    t[y].pop_back();\n  }else{\n    \n    z=t[y];\n    t[y].clear();\n    for(int i=0;i<(int)z.size();i++){\n      if(i==x)continue;\n      t[y].push_back(z[i]);\n    }\n  }\n}\n\nvoid yinsert(int y,vector<char> ch){\n  if(y==(int)t.size()){\n    t.push_back(ch);\n  }else{\n    u=t;\n    t.clear();\n    for(int i=0;i<(int)u.size();i++){\n      if(i==y)t.push_back(ch);\n      t.push_back(u[i]);\n    }\n  }\n}\n\nvoid ydelete(int y){\n  if(y+1==(int)t.size()){\n    t.pop_back();\n  }else{\n    u=t;\n    t.clear();\n    for(int i=0;i<(int)u.size();i++){\n      if(i==y)continue;\n      t.push_back(u[i]);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> text;\nstring buf;\nint cux, cuy;\n\nvoid edit(char cmd)\n{\n\tswitch(cmd){\n\t\tcase 'a':\n\t\t\tcux = 0;\n\t\t\tbreak;\n\t\t\n\t\tcase 'e':\n\t\t\tcux = text[cuy].size();\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'p':\n\t\t\tif(cuy > 0)\n\t\t\t\t--cuy;\n\t\t\tcux = 0;\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'n':\n\t\t\tif(cuy < text.size()-1)\n\t\t\t\t++cuy;\n\t\t\tcux = 0;\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'f':\n\t\t\tif(cux < text[cuy].size())\n\t\t\t\t++cux;\n\t\t\telse if(cuy < text.size()-1){\n\t\t\t\tcux = 0;\n\t\t\t\t++cuy;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'b':\n\t\t\tif(cux > 0)\n\t\t\t\t--cux;\n\t\t\telse if(cuy > 0){\n\t\t\t\t--cuy;\n\t\t\t\tcux = text[cuy].size();\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'd':\n\t\t\tif(cux == text[cuy].size()){\n\t\t\t\tif(cuy < text.size()-1){\n\t\t\t\t\ttext[cuy] += text[cuy+1];\n\t\t\t\t\tfor(int i=cuy+1 ; i<text.size()-1 ; ++i)\n\t\t\t\t\t\ttext[i] = text[i+1];\n\t\t\t\t\ttext.pop_back();\n\t\t\t\t}\n\t\t\t}else\n\t\t\t\ttext[cuy].erase(cux, 1);\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'k':\n\t\t\tif(cux == text[cuy].size()){\n\t\t\t\tif(cuy < text.size()-1){\n\t\t\t\t\tedit('d');\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tbuf = text[cuy].substr(cux, text[cuy].size()-cux);\n\t\t\t\ttext[cuy] = text[cuy].substr(0, cux);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'y':\n\t\t\tif(buf != \"\"){\n\t\t\t\tif(buf == \"\\n\"){\n\t\t\t\t\ttext.push_back(text[text.size()-1]);\n\t\t\t\t\tfor(int i=text.size()-2 ; i>cuy ; --i)\n\t\t\t\t\t\ttext[i+1] = text[i];\n\t\t\t\t\ttext[cuy+1] = text[cuy].substr(cux, text[cuy].size()-cux);\n\t\t\t\t\ttext[cuy] = text[cuy].substr(0, cux);\n\t\t\t\t\t++cuy;\n\t\t\t\t\tcux = 0;\n\t\t\t\t}else{\n\t\t\t\t\ttext[cuy] = text[cuy].substr(0, cux) + buf + text[cuy].substr(cux, text[cuy].size()-cux);\n\t\t\t\t\tcux += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n}\n\nint main()\n{\n\tfor(;;){\n\t\tstring str;\n\t\tgetline(cin, str);\n\t\tif(str == \"END_OF_TEXT\")\n\t\t\tbreak;\n\t\ttext.push_back(str);\n\t}\n\t\n\tchar cmd;\n\twhile(cin>>cmd, cmd!='-')\n\t\tedit(cmd);\n\t\n\tfor(int i=0 ; i<text.size() ; ++i)\n\t\tcout << text[i] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY = 0;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n}\n\n/*\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\\n\";\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX);\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n*/\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX+1);\n\n\t\tlines[posY] = front;\n\t\tdeque<string>::iterator it = lines.begin();\n\t\tadvance(it,posY);\n\t\tlines.insert(it,rear);\n\t}\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(getline(cin,str)){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(cin >> str){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\tif(str == \"d\") ctrl_d(lines);\n\t\t//if(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nint main(){\n  char str[128][1024],c,buf[1024];\n  string input;\n  int i,j,now_x,now_y,y_max;\n\n  memset(str,0,sizeof(str));\n  memset(buf,0,sizeof(buf));\n  for(i=0;getline(cin,input);i++){\n    if(input==\"END_OF_TEXT\")break;\n    strcpy(str[i],input.c_str());\n  }\n  y_max=i-1;\n  now_x=now_y=0;\n  for(;scanf(\" %c \",&c),c!='-';){\n    if(c=='a') //J[\\ð»ÝÌsÌæª\n      {\n        now_x=0;\n      }\n    else if(c=='e') //J[\\ð»ÝÌsÌs\n      {\n        now_x=strlen(str[now_y]);\n      }\n    else if(c=='p') //ãÉsª êÎJ[\\ðãÌsÌæªAÈ­Äàæª\n      {\n        if(now_y>0)now_y--;\n        now_x=0;\n      }\n    else if(c=='n') //ºÉsª ``\n      {\n        if(now_y<y_max)now_y++;\n        now_x=0;\n      }\n    else if(c=='f') //¶°¿ÙªsÅÈ¢Æ«EÉÚ®AsºÉsª éÆ«ºÌsÌæªAÈ¢Æ«Í½àµÈ¢\n      {\n        if(now_x!=strlen(str[now_y]))now_x++;\n        else{\n          if(now_y<y_max)now_y++,now_x=0;\n        }\n      }\n    else if(c=='b') //¶°¿Ùªæª¶ÅÈ¢Èç¶°¿Ùð¶ÉÚ®AæªãÉsª``\n      {\n        if(now_x>0)now_x--;\n        else{\n          if(now_y>0)now_y--,now_x=strlen(str[now_y]);\n        }\n      }\n    else if(c=='d')//¶°¿Ùª¶ðw·êíAí³ê½¶ÌE¤Í¶É¼ÌÄ``\n      {\n        if(now_x!=strlen(str[now_y])){\n          for(i=now_x;i<strlen(str[now_y]);i++)str[now_y][i]=str[now_y][i+1];\n        }\n        else{//¶°¿ÙªsÌÆ«\n          if(now_y<y_max){\n            strcat(str[now_y],str[now_y+1]);\n            y_max=now_y;\n            for(i=now_y+1;i<127;i++){\n              strcpy(str[i],str[i+1]);\n              if(str[i]!=0)y_max=i;\n            }\n          }\n        }\n      }\n    else if(c=='k') //\n      {\n        if(now_x==strlen(str[now_y])){\n          if(now_y<y_max){\n            strcat(str[now_y],str[now_y+1]);\n            y_max=now_y;\n            for(i=now_y+1;i<127;i++){\n              strcpy(str[i],str[i+1]);\n              if(str[i][0]!=0)y_max=i;\n            }\n          }\n          buf[0]='\\n'; buf[1]=0;\n        }else{\n          strcpy(buf,str[now_y]+now_x);\n          str[now_y][now_x]=0;\n          now_x=strlen(str[now_y]);\n          \n        }\n      }\n    else if(c=='y') //\n      {\n        if(buf[0]!=0){\n          if(buf[0]=='\\n'){\n            for(i=126;i>now_y;i--)strcpy(str[i+1],str[i]);\n            strcpy(str[now_y+1],str[now_y]+now_x);\n            str[now_y][now_x]=0;\n            now_y++; now_x=0;\n            y_max++;\n          }else{\n            char tmp[1024];\n            int t=now_x+1>strlen(str[now_y])?strlen(str[now_y]):now_x+1;\n            strcpy(tmp,str[now_y]+now_x);\n            for(i=now_x,j=0;j<strlen(buf);)str[now_y][i++]=buf[j++];\n            str[now_y][i]=0;\n            strcat(str[now_y],tmp);\n          }\n        }\n        //memset(buf,0,sizeof(buf));\n      }\n    //printf(\"y_max:%d\\n\",y_max);\n    //for(i=0;i<=y_max;i++)printf(\"%d:%s\\n\",i,str[i]);\n    //printf(\"%c-----------------now_x:%d , now_y:%d , y_max:%d\\n\",c,now_x,now_y,y_max);\n  }\n  for(i=0;i<=y_max;i++)puts(str[i]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstring kaigyou = \"wararaki_wararaki_kaigyo\";\n\nint main()\n{\n\tint p, q;\n\tstring str, buf;\n\t\n\twhile(!cin.eof()){\n\t\tgetline(cin, str);\n\t\tvector<string> vec;\n\t\twhile(str != \"END_OF_TEXT\"){\n\t\t\tvec.push_back(str);\n\t\t\tgetline(cin, str);\n\t\t}\n\t\tp = q = 0;\n\t\tbuf = \"\";\n\t\twhile(1){\n\t\t\tgetline(cin, str);\n\t\t\tif(str == \"-\"){\n\t\t\t\tbreak;\n\t\t\t} else if(str == \"a\"){\n\t\t\t\tq = 0;\n\t\t\t} else if(str == \"e\"){\n\t\t\t\tq = vec[p].size();\n\t\t\t} else if(str == \"p\"){\n\t\t\t\tif(p > 0){\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t\tq = 0;\n\t\t\t} else if(str == \"n\"){\n\t\t\t\tif(p < vec.size()-1){\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tq = 0;\n\t\t\t} else if(str == \"f\"){\n\t\t\t\tif(q < vec[p].size()){\n\t\t\t\t\tq++;\n\t\t\t\t} else if(p < vec.size()-1){\n\t\t\t\t\tp++;\n\t\t\t\t\tq = 0;\n\t\t\t\t}\n\t\t\t} else if(str == \"b\"){\n\t\t\t\tif(q > 0){\n\t\t\t\t\tq--;\n\t\t\t\t} else if(p > 0){\n\t\t\t\t\tp--;\n\t\t\t\t\tq = vec[p].size();\n\t\t\t\t}\n\t\t\t} else if(str == \"d\"){\n\t\t\t\tif(q == vec[p].size()){\n\t\t\t\t\tif(p < vec.size()-1){\n\t\t\t\t\t\tvec[p] += vec[p+1];\n\t\t\t\t\t\tvec.erase(vec.begin()+(p+1));\n\t\t\t\t\t}\n\t\t\t\t} else if(isalpha(vec[p][q])){\n\t\t\t\t\tvec[p].erase(vec[p].begin()+q);\n\t\t\t\t}\n\t\t\t} else if(str == \"k\"){\n\t\t\t\tif(q == vec[p].size() && p < vec.size()-1){\n\t\t\t\t\tbuf = kaigyou;\n\t\t\t\t\tvec[p] += vec[p+1];\n\t\t\t\t\tvec.erase(vec.begin()+(p+1));\n\t\t\t\t} else if(q < vec[p].size()){\n\t\t\t\t\tbuf = vec[p].substr(q);\n\t\t\t\t\tvec[p] = vec[p].substr(0, q);\n\t\t\t\t\tq = vec[p].size();\n\t\t\t\t}\n\t\t\t} else if(str == \"y\"){\n\t\t\t\tif(buf.size() > 0){\n\t\t\t\t\tif(buf == kaigyou){\n\t\t\t\t\t\tstring tmp = vec[p].substr(q);\n\t\t\t\t\t\tvec.insert(vec.begin()+(p+1), tmp);\n\t\t\t\t\t\tvec[p] = vec[p].substr(0, q);\n\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\tp++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvec[p].insert(q, buf);\n\t\t\t\t\t\tq = vec[p].size();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\tcout << vec[i] << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<string> buf;\nint row;\nint column;\nstring rem;\n\nvoid printbuf(){\n  cout << row << ' ' << column << \" \\\"\" << rem << \"\\\"\" << endl;\n  for(int i=0;i<buf.size();i++){\n    cout << buf[i];\n  }\n}\n\nmain(){\n  string in;\n  while(getline(cin, in)){\n    if(in == \"END_OF_TEXT\") break;\n    //if(in == \"END_OF_TEXT\" || in == \"1\") break;\n    in += '\\n';\n    buf.push_back(in);\n  }\n  char c;\n  row = 0;\n  column = 0;\n  while(cin >> c){\n    if(c == '-') break;\n    switch(c){\n      case 'a':\n        column = 0;\n        break;\n      case 'e':\n        column = (int)buf[row].size()-1;\n        break;\n      case 'p':\n        column = 0;\n        if(row > 0) --row;\n        break;\n      case 'n':\n        column = 0;\n        if(row+1 < buf.size()) ++row;\n        break;\n      case 'f':\n        if(column+1 >= buf[row].size()){\n          if(row+1 < buf.size()){\n            column = 0;\n            ++row;\n          }\n        }else{\n          ++column;\n        }\n        break;\n      case 'b':\n        if(column == 0){\n          if(row > 0){\n            --row;\n            column = (int)buf[row].size()-1;\n          }\n        }else{\n          --column;\n        }\n        break;\n      case 'd':\n        if(column+1 == buf[row].size()){\n          if(row+1 != buf.size()){\n            buf[row].erase((int)buf[row].size()-1);\n            buf[row] += buf[row+1];\n            vector<string>::iterator ite = buf.begin();\n            for(int i=0;i<row+1;i++) ++ite;\n            buf.erase(ite);\n          }\n        }else{\n          buf[row].erase(column, 1);\n        }\n        break;\n      case 'k':\n        rem = \"\";\n        if(column+1 == buf[row].size()){\n          if(row+1 != buf.size()){\n            buf[row].erase((int)buf[row].size()-1);\n            buf[row] += buf[row+1];\n            vector<string>::iterator ite = buf.begin();\n            for(int i=0;i<row+1;i++) ++ite;\n            buf.erase(ite);\n            rem += '\\n';\n          }\n        }else{\n          for(int i=column;i+1<buf[row].size();++i){\n            rem += buf[row][i];\n          }\n          string::iterator ite = buf[row].begin();\n          for(int i=0;i<column;i++) ++ite;\n          buf[row].erase(ite, buf[row].end());\n          buf[row] += '\\n';\n        }\n        break;\n      case 'y':\n        if(rem.size() != 0){\n          int irem;\n          string back = buf[row].substr(column);\n          buf[row] = buf[row].substr(0, column);\n          for(irem = 0;irem<rem.size();irem++){\n            buf[row] += rem[irem];\n            ++column;\n            if(rem[irem] == '\\n'){\n              vector<string>::iterator ite = buf.begin();\n              for(int i=0;i<row+1;i++) ++ite;\n              buf.insert(ite, \"\");\n              column = 0;\n              ++row;\n            }\n          }\n          buf[row] += back;\n        }\n        break;\n    }\n    //printbuf();\n  }\n  for(int i=0;i<buf.size();i++){\n    cout << buf[i];\n  }\n  //cout << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring S;\nint p = 0;\n\nvoid a() {\n  for(; p >= 1 && S[p-1] != '\\n'; --p);\n}\n\nvoid e() {\n  for(; p < S.size() && S[p] != '\\n'; ++p);\n}\n\nint main() {\n  string line;\n  S = \"\\n\";\n  while(getline(cin,line) && line != \"END_OF_TEXT\") {\n    S += line;\n    S += '\\n';\n  }\n  if(S.size() == 1) S += '\\n';\n\n  char c;\n  string buffer = \"\";\n  p = 1;\n  while(cin >> c && c != '-') {\n    switch(c) {\n    case 'a':\n      a();\n      break;\n    case 'e':\n      e();\n      break;\n    case 'p':\n      a();\n      if(p != 1) {\n\t--p;\n\ta();\n      }\n      break;\n    case 'n':\n      e();\n      if(p+1 != S.size()) ++p;\n      a();\n      break;\n    case 'f':\n      p = min(p+1,(int)S.size()-1);\n      break;\n    case 'b':\n      p = max(p-1, 1);\n      break;\n    case 'd':\n      if(p+1 != S.size()) S.erase(p,1);\n      break;\n    case 'k':\n      if(S[p] == '\\n') {\n\tif(p+1 != S.size()) {\n\t  S.erase(p,1);\n\t  buffer = \"\\n\";\n\t}\n      } else {\n\tfor(int i = 1; ; ++i) {\n\t  if(S[p+i] == '\\n'){\n\t    buffer = S.substr(p,i);\n\t    S.erase(p,i);\n\t    break;\n\t  }\n\t}\n      }\n      break;\n    case 'y':\n      S.insert(p,buffer);\n      p += buffer.size();\n      break;\n    }\n  }\n  cout << S.substr(1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main(){\n\tstring s[500];\n\tint line = 0;\n\tfor ( string in; getline( cin, in ), in != \"END_OF_TEXT\"; ++line ){\n\t\ts[ line ] = in;\n\t}\n\t\n\tif( line == 0 ) line = 1;\n\t\n\tint pX = 0;\n\tint pY = 0;\n\t\n\tstring buf;\n\tfor ( string in; cin >> in, in != \"-\"; ) {\n\t\tif ( in == \"a\" ) {\n\t\t\tpX = 0;\n\t\t} else if ( in == \"e\" ) {\n\t\t\tpX = s[ pY ].length();\n\t\t} else if ( in == \"p\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( pY != 0 ) --pY;\n\t\t} else if ( in == \"n\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( pY + 1 != line ) ++pY;\n\t\t} else if ( in == \"f\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\t++pX;\n\t\t\t} else if ( pY != line - 1 ) {\n\t\t\t\tpX = 0;\n\t\t\t\t++pY;\n\t\t\t}\n\t\t} else if ( in == \"b\" ) {\n\t\t\tif ( 0 < pX ) {\n\t\t\t\t--pX;\n\t\t\t} else {\n\t\t\t\tif ( 0 < pY ) {\n\t\t\t\t\t--pY;\n\t\t\t\t\tpX = s[ pY ].length();\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( in == \"d\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + s[ pY ].substr( pX + 1 );\n\t\t\t} else if ( pY < line - 1 ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\ts[ line - 1 ] = \"\";\n\t\t\t\t--line;\n\t\t\t}\n\t\t} else if ( in == \"k\" ) {\n\t\t\tif ( pX == s[ pY ].length() && pY + 1 != line ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\ts[ line - 1 ] = \"\";\n\t\t\t\t--line;\n\t\t\t\tbuf = \"\\n\";\n\t\t\t} else if ( pX < s[ pY ].size() ) {\n\t\t\t\tbuf = s[ pY ].substr( pX );\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t}\n\t\t} else if ( in == \"y\" ) {\n\t\t\tif ( !buf.empty() ) {\n\t\t\t\tif ( buf == \"\\n\" ) {\n\t\t\t\t\tfor ( int i = line - 1; pY <= i; --i ) {\n\t\t\t\t\t\ts[ i + 1 ] = s[ i ];\n\t\t\t\t\t}\n\t\t\t\t\ts[ pY + 1 ] = s[ pY ].substr( pX );\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t\t\t++line;\n\t\t\t\t} else {\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + buf + s[ pY ].substr( pX );\n\t\t\t\t\tpX += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor ( int i = 0; i < line; ++i ) cout << s[ i ] << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <string>\n#include <cstdio>\n\nusing namespace std;\n\nint main()\n{\n\tstring str[300];\n\tstring b;\n\tb[0] = '*';\n\tint y = 0, y2 = 0;\n\t\n\twhile (getline(std::cin, str[y]), str[y] != \"END_OF_TEXT\"){\n\t\ty++;\n\t}\n\ty2 = --y;\n\t\n\tchar cmd[2];\n\tint car = 0, car_y = 0;\n\t\n\twhile (scanf(\"%s\", cmd), cmd[0] != '-'){\n\t\tif (cmd[0] == 'a'){\n\t\t\tcar = 0;\n\t\t}\n\t\tif (cmd[0] == 'e'){\n\t\t\tcar = str[car_y].size();\n\t\t}\n\t\tif (cmd[0] == 'p'){\n\t\t\tif (car_y == 0){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y--;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'n'){\n\t\t\tif (car_y != y){\n\t\t\t\tcar_y++;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\t\n\t\t\telse {\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'f'){\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tcar++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tcar_y++;\n\t\t\t\t\tcar = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'b'){\n\t\t\tif (car != 0){\n\t\t\t\tcar--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != 0){\n\t\t\t\t\tcar_y--;\n\t\t\t\t\tcar = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'd'){\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tstr[car_y].erase(car, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = y - 1;\n\t\t\t\t\ty = car_y;\n\t\t\t\t\twhile (++y < y2){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y].erase();\n\t\t\t\t\t\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'k'){\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = y;\n\t\t\t\t\ty = car_y;\n\t\t\t\t\twhile (++y < y2){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y].erase();\n\t\t\t\t\t\n\t\t\t\t\ty = y2;\n\t\t\t\t\tb[0] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb = str[car_y].substr(car);\n\t\t\t\tstr[car_y].erase(car);\n\t\t\t\tcar = str[car_y].size();\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'y'){\n\t\t\tif(b[0] != '*'){\n\t\t\t\tif (b[0] == '\\0'){\n\t\t\t\t\ty2 = y + 1;\n\t\t\t\t\twhile (y > car_y + 1){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y] = str[car_y].substr(car);\n\t\t\t\t\tstr[car_y].erase(car);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstr[car_y].insert(car, b);\n\t\t\t\t\tcar += b.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int j = 0; j <= y; j++){\n\t\tprintf(\"%s\\n\", str[j].c_str());\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(5)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<short, short> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 100000007;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator > (const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nvector<string> s;\nint x, y;\n\nvoid gotoend()\n{\n\ty = s[x].size();\n}\n\nvoid gotohome()\n{\n\ty = 0;\n}\n\nint check()\n{\n\tif (s[x].size() == 0 || y == s[x].size()) return 1;\n\telse return 0;\n}\n\n\nint main()\n{\n\tx = 0; y = 0;\n\tstring tmp;\n\tstring buf = \"karappo!!!!!!!!!\";\n\twhile (1)\n\t{\n\t\tcin >> tmp;\n\t\tif (tmp == \"END_OF_TEXT\") break;\n\t\ts.push_back(tmp);\n\t}\n\tchar com;\n\twhile (cin >> com)\n\t{\n\t\tif (com == '-') break;\n\t\telse if (com == 'a') gotohome();\n\t\telse if (com == 'e') gotoend();\n\t\telse if (com == 'p')\n\t\t{\n\t\t\tif (x == 0) gotohome();\n\t\t\telse \n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'n')\n\t\t{\n\t\t\tif (x < s.size() - 1) x++;\n\t\t\tgotohome();\n\t\t}\n\t\telse if (com == 'f')\n\t\t{\n\t\t\tif (check() == 0) y++;\n\t\t\telse if (check()==1&&x < s.size() - 1)\n\t\t\t{\n\t\t\t\tx++;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'b')\n\t\t{\n\t\t\tif (y != 0) y--;\n\t\t\telse if (y == 0 && x > 0)\n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tgotoend();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'd')\n\t\t{\n\t\t\tif (check() == 0) s[x].erase(y, 1);\n\t\t\telse if (check() == 1 && x < s.size() - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\ts.erase(begin(s) + x + 1);\n\t\t\t}\n\t\t}\n\t\telse if (com == 'k')\n\t\t{\n\t\t\tif (check() == 1 && x < s.size() - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\ts.erase(begin(s) + x + 1);\n\t\t\t\tbuf = \"kaigyousuru!!!!!!!\";\n\t\t\t}\n\t\t\t\n\t\t\telse\n\t\t\t{\n\t\t\t\tbuf = s[x].substr(y);\n\t\t\t\ts[x].erase(y);\n\t\t\t}\n\t\t}\n\t\telse if (com == 'y')\n\t\t{\n\t\t\tif (buf == \"karappo!!!!!!!!!\") continue;\n\t\t\telse if (buf == \"kaigyousuru!!!!!!!\")\n\t\t\t{\n\t\t\t\tstring tmp = s[x].substr(y);\n\t\t\t\ts.insert(begin(s) + x + 1, tmp);\n\t\t\t\ts[x].erase(y);\n\t\t\t\tx++;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts[x].insert(y, buf);\n\t\t\t\ty += buf.size();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tREP(i, s.size())\n\t\t{\n\t\t\tcout << s[i] << endl;\n\t\t}\n\t\tcout << x << \" \" << y << endl;\n\t\tcout << buf;\n\t\tcout << endl << endl;\n\t\t*/\n\t}\n\tREP(i, s.size())\n\t{\n\t\tcout << s[i] << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n \nusing namespace std;\n\n#define sz  size()\n#define er  erase\n#define ss  substr\n\nclass Emacs {\npublic:\n    Emacs(){\n        w = h = 0;\n        buf.clear();\n    }\n    void appendLine(string line){ txt.push_back(line); }\n    void execCommand(char code){\n        switch (code){\n          case 'a': A(); break;\n          case 'e': E(); break;\n          case 'p': P(); break;\n          case 'n': N(); break;\n          case 'f': F(); break;\n          case 'b': B(); break;\n          case 'd': D(); break;\n          case 'k': K(); break;\n          case 'y': Y(); break;\n        }\n    }\n    void showText(){\n        for (auto line : txt)\n            cout << line << \"\\n\";\n    }\nprivate:\n    void A(){ w = 0; }\n    void E(){ w = txt[h].sz; }\n    void P(){ h = max(h - 1, 0); A(); }\n    void N(){ h = min(h + 1, (int)txt.sz - 1); A(); }\n    void F(){ if (w < txt[h].sz) w++; else if (h < txt.sz - 1) A(), h++; }\n    void B(){ if (w > 0) w--; else if (h > 0) h--, E(); }\n    void D(){ if (w < txt[h].sz) txt[h].er(w, 1); else if (h < txt.sz - 1) txt[h] += txt[h + 1], txt.er(txt.begin() + h + 1); }\n    void K(){ if (w < txt[h].sz) buf = txt[h].ss(w), txt[h] = txt[h].ss(0, w); else if (h < txt.sz - 1) D(), buf = \"\\n\"; }\n    void Y(){ if (!buf.empty()) { if (buf == \"\\n\") txt.insert(txt.begin() + h + 1, txt[h].ss(w)), txt[h].er(w), N(); else txt[h].insert(w, buf), w += buf.sz; }}\n    vector<string> txt;\n    string buf;\n    int h, w;\n};\n\nint main()\n{\n    Emacs emacs;\n\n    string in;\n    while (getline(cin, in), in != \"END_OF_TEXT\") emacs.appendLine(in);\n\n    char cmd;\n    while (cin >> cmd, cmd != '-') emacs.execCommand(cmd);\n\n    emacs.showText();\n\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Emacs{\n  int line,column;\n  string buffer;\n  vector<string> text;\n\n  void editText(){\n    for(int i = 0 ; i < (int)text.size() ; i++){\n      if(isEmptyLine(i)){ text[i].empty(); }\n    }\n  }\n\n  void order(char command){\n    editText();\n    switch(command){\n    case 'a': funcA(); break;\n    case 'e': funcE(); break;\n    case 'p': funcP(); break;\n    case 'n': funcN(); break;\n    case 'f': funcF(); break;\n    case 'b': funcB(); break;\n    case 'd': funcD(); break;\n    case 'k': funcK(); break;\n    case 'y': funcY(); break;\n    }\n  }\n\n  bool isEmptyLine(int l){\n    for(int i = 0 ; i < (int)text[l].size() ; i++){\n      if(text[l][i] != ' '){ return false; }\n    }\n    return true;\n  }\n\n  void funcA(){\n    column = 0;\n  }\n  \n  void funcE(){\n    column = text[line].size();\n  }\n\n  void funcP(){\n    if(line > 0){ line--; }\n    column = 0;\n  }\n\n  void funcN(){\n    if(line+1 < (int)text.size()){ line++; }\n    column = 0;\n  }\n\n  void funcF(){\n    if(column == (int)text[line].size()){\n      funcN();\n    }else{\n      column++;\n    }\n  }\n  \n  void funcB(){\n    if(column == 0){\n      if(line != 0){\n        line--;\n        column = text[line].size();\n      }\n    }else{\n      column--;\n    }\n  }\n\n  void funcD(){\n    if(text[line].empty()){\n      int len = text.size();\n      vector<string> ntext(len-1);\n      for(int i = 0 ; i < line ; i++){\n        ntext[i] = text[i];\n      }\n      for(int i = line ; i < len-1 ; i++){\n        ntext[i] = text[i+1];\n      }\n      text = ntext;\n      return;\n    }\n    if(0 <= column && column < (int)text[line].size()){\n      text[line] = text[line].substr(0,column) + text[line].substr(column+1);\n    }else{\n      int len = text.size();\n      if(line+1 < len){\n        vector<string> ntext(len-1);\n        for(int i = 0 ; i < line-1 ; i++){\n          ntext[i] = text[i];\n        }\n        ntext[line] = text[line] + text[line+1];\n        for(int i = line+2 ; i < len ; i++){\n          ntext[i-1] = text[i];\n        }\n        text = ntext;\n      }\n    }\n  }\n\n  void funcK(){\n    int len = text[line].size();\n    if(text[line].empty()){\n      buffer = \"\\n\";\n      int len = text.size();\n      vector<string> ntext(len-1);\n      for(int i = 0 ; i < line ; i++){\n        ntext[i] = text[i];\n      }\n      for(int i = line ; i < len-1 ; i++){\n        ntext[i] = text[i+1];\n      }\n      text = ntext;\n      return;\n    }\n    if(column == len){\n      int len2 = text.size();\n      if(line+1 < len2){\n        buffer = \"\\n\";\n        vector<string> ntext(len2-1);\n        for(int i = 0 ; i < line ; i++){\n          ntext[i] = text[i];\n        }\n        ntext[line] = text[line] + text[line+1];\n        for(int i = line+1 ; i < len2-1 ; i++){\n          ntext[i] = text[i+1];\n        }\n        text = ntext;\n      }\n    }else{\n      buffer.clear();\n      for(int i = column ; i < len ; i++){\n        buffer += text[line][i];\n      }\n      text[line].resize(column);\n    }\n  }\n\n  void funcY(){\n    if(buffer.empty()){ return; }\n    if(buffer == \"\\n\"){\n      string str = text[line];\n      string str2 = str.substr(column);\n      text[line] = str.substr(0,column);\n      int size = text.size();\n      text.resize(size+1);\n      for(int i = size ; i > line+1 ; i--){\n        text[i] = text[i-1];\n      }\n      text[line+1] = str2;\n      funcN();\n    }else{\n      string str = text[line];\n      str = str.substr(0,column) + buffer + str.substr(column);\n      text[line] = str;\n      column += buffer.size();\n    }\n  }\n\n  void print(){\n    int len = text.size();\n    for(int i = 0 ; i < len ; i++){\n      cout << text[i] << endl;\n    }\n  }\n};\n\nint main(){\n  Emacs emacs;\n  string str;\n  while(getline(cin,str), str != \"END_OF_TEXT\"){\n    emacs.text.push_back(str);\n  }\n  emacs.line = emacs.column = 0;\n  char command;\n  while(cin >> command, command != '-'){\n    emacs.order(command);\n  }\n  emacs.print();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\n\nint main() {\n\tvector<string>emacs;\n\twhile (1) {\n\t\tstring st; cin >> st;\n\t\t\n\t\tif (st == \"END_OF_TEXT\") {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\temacs.push_back(st);\n\t\t}\n\t}\n\tint x = 0, y = 0;\n\tvector<string>buf;\n\twhile (1) {\n\t\tchar c; cin >> c;\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\t\tx = 0;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tx = emacs[y].size();\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (y) {\n\t\t\t\ty--;\n\t\t\t}\n\t\t\tx = 0;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tif (y != emacs.size() - 1) {\n\t\t\t\ty++;\n\t\t\t}\n\t\t\tx = 0;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tif (x != emacs[y].size())x++;\n\t\t\telse {\n\t\t\t\tif (y != emacs.size() - 1) {\n\t\t\t\t\ty++;\n\t\t\t\t\tx = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif (x)x--;\n\t\t\telse {\n\t\t\t\tif (y) {\n\t\t\t\t\ty--;\n\t\t\t\t\tx = emacs[y].size();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (x != emacs[y].size()) {\n\t\t\t\temacs[y].erase(emacs[y].begin() + x);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (y != emacs.size() - 1) {\n\t\t\t\t\temacs[y].insert(emacs[y].end(), emacs[y + 1].begin(), emacs[y + 1].end());\n\t\t\t\t\temacs.erase(emacs.begin() + y + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tif (x == emacs[y].size()) {\n\t\t\t\tif (y != emacs.size() - 1) {\n\t\t\t\t\temacs[y].insert(emacs[y].end(), emacs[y + 1].begin(), emacs[y + 1].end());\n\t\t\t\t\temacs.erase(emacs.begin() + y + 1);\n\t\t\t\t\tbuf = vector<string>(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuf = vector<string>(1, emacs[y].substr(x));\n\t\t\t\temacs[y].erase(emacs[y].begin() + x, emacs[y].end());\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tif (buf.empty()) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (buf[0] == \"\") {\n\t\t\t\t\tstring rest = emacs[y].substr(x);\n\t\t\t\t\temacs[y].erase(emacs[y].begin() + x, emacs[y].end());\n\t\t\t\t\temacs.insert(emacs.begin() + y+1, rest);\n\t\t\t\t\ty++;\n\t\t\t\t\tx = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\temacs[y].insert(emacs[y].begin() + x, buf[0].begin(), buf[0].end());\n\t\t\t\t\tx += buf[0].size();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (c=='-')break;/*\n\t\tfor (auto s : emacs) {\n\t\t\tcout << s << endl;\n\t\t}\n\t\tcout << \"x: \" << x << endl << \"y: \" << y << endl;*/\n\t}\n\tfor (auto s : emacs) {\n\t\tcout << s << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\nusing namespace std;\n#define sz(v) ((int)(v).size())\nconst int maxint = -1u>>1;\n\nconst char LINE = '\\n';\n\nchar tmp[32];\nint nowc = 0, nowp = 0;\n\nvector<string> now;\nstring buf = \"\";\n\nbool read() {\n    //gets(tmp);\n    cin.getline(tmp, 100);\n    if (strcmp(tmp, \"END_OF_TEXT\") == 0) {\n        return false;\n    }\n    now.push_back(string(tmp) + LINE);\n    return true;\n}\n\nbool gao() {\n    scanf (\"%s\", tmp);\n    if (tmp[0] == 'a') {\n        nowp = 0;\n    } else if (tmp[0] == 'e') {\n        nowp = sz(now[nowc]) - 1;\n    } else if (tmp[0] == 'p') {\n        if (nowc != 0) --nowc;\n        nowp = 0;\n    } else if (tmp[0] == 'n') {\n        if (nowc != sz(now) - 1) ++nowc;\n        nowp = 0;\n    } else if (tmp[0] == 'f') {\n        if (nowp == sz(now[nowc]) - 1) {\n            if (nowc != sz(now) - 1) {\n                ++nowc, nowp = 0;\n            } \n        } else {\n            ++nowp;\n        }\n    } else if (tmp[0] == 'b') {\n        if (nowp == 0) {\n            if (nowc != 0) {\n                nowp = sz(now[--nowc]) - 1;\n            }\n        } else {\n            --nowp;\n        }\n    } else if (tmp[0] == 'd') {\n        if (nowp == sz(now[nowc]) - 1) {\n            if (nowc != sz(now) - 1) {\n                now[nowc].erase(nowp, 1);\n                now[nowc] += now[nowc + 1];\n                for (int i = nowc + 1; i + 1 < sz(now); ++i) {\n                    now[i] = now[i + 1];\n                }\n                now.pop_back();\n            }\n        } else {\n            now[nowc].erase(nowp, 1);\n        }\n    } else if (tmp[0] == 'k') {\n        if (nowp == sz(now[nowc]) - 1) {\n            if (nowc != sz(now) - 1) {\n                now[nowc].erase(nowp, 1);\n                now[nowc] += now[nowc + 1];\n                for (int i = nowc + 1; i + 1 < sz(now); ++i) {\n                    now[i] = now[i + 1];\n                }\n                now.pop_back();\n                buf = \"\"; buf += LINE;\n            }\n        } else {\n            buf = now[nowc].substr(nowp, sz(now[nowc]) - 1 - nowp);\n            now[nowc].erase(nowp, sz(now[nowc]) - 1 - nowp);\n            //cout << nowc << ' ' << nowp << ' ' << \"buf: \" << buf << endl;\n        }\n    } else if (tmp[0] == 'y') {\n        if (sz(buf) == 1 && buf[0] == LINE) {\n            now.push_back(now[sz(now) - 1]);\n            for (int i = sz(now) - 2; i > nowc + 1; --i) {\n                now[i] = now[i - 1];\n            }\n            now[nowc + 1] = now[nowc].substr(nowp);\n            now[nowc].erase(nowp, sz(now[nowc]) - 1 - nowp);\n        } else if (sz(buf) > 0) {\n            now[nowc] = now[nowc].substr(0, nowp) + buf + now[nowc].substr(nowp);\n            nowp += sz(buf);\n        }\n    } else {\n        return false;\n    }\n    //printf (\"do %s %d %d\\n\", tmp, nowc, nowp);\n    return true;\n}\n\nvoid output() {\n    for (int i = 0; i < sz(now); ++i) {\n        printf (\"%s\", now[i].c_str());\n    }\n}\n\nint main() {\n    while (read());\n    while (gao());\n    output();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t,u;\nvector<char> tmp;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nint main(){\n\n  t.clear();\n  tmp.clear();\n  input();\n  x=y=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n    //cout<<y<<' '<<x<<\" ty\"<<t.size()<<endl;\n  }\n\n  for(int i=0;i<t.size();i++){\n    for(int j=0;j<t[i].size();j++){\n      cout<<t[i][j];\n    }\n  }\n\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    t[y].erase(t[y].begin()+x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  t[y].erase(t[y].begin()+x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  t.erase(t.begin()+y+1);\n}\n\nvoid funcK(){\n  tmp.clear();\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.push_back('\\n');\n    }\n    return;\n  }\n  while(t[y][x]!='\\n'){\n    tmp.push_back(t[y][x]);\n    t[y].erase(t[y].begin()+x);\n  }\n  reverse(tmp.begin(),tmp.end());\n\n}\n\nvoid funcY(){\n  \n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    vector<char> z;\n    while(t[y][x]!='\\n'){\n      z.push_back(t[y][x]);\n      t[y].erase(t[y].begin()+x);\n    }\n    t.insert(t.begin()+y,z);\n    return;\n  }\n  \n}\n\nvoid input(){\n  vector<char> a;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  string s;\n  vector<string> lines;\n  while(getline(cin, s) && s != \"END_OF_TEXT\"){\n    lines.push_back(s);\n  }\n  int x = 0, y = 0;\n  bool is_clear = true;\n  string buffer = \"\";\n  while(cin>>s){\n    if(s == \"a\"){\n      x = 0;\n    }else if(s == \"e\"){\n      x = lines[y].size();\n    }else if(s == \"p\"){\n      x = 0;\n      if(y > 0) y--;\n    }else if(s == \"n\"){\n      x = 0;\n      if(y + 1 < lines.size()) y++;\n    }else if(s == \"f\"){\n      if(x + 1 <= lines[y].size()){\n        x++;\n      }else if(y + 1 < lines.size()){\n        x = 0;\n        y++;\n      }else{\n      }\n    }else if(s == \"b\"){\n      if(x - 1 >= 0){\n        x--;\n      }else if(y - 1 >= 0){\n        y--;\n        x = lines[y].size();\n      }else{\n      }\n    }else if(s == \"d\"){\n      if(x < lines[y].size()){\n        lines[y] = lines[y].erase(x, 1); //xはどうなる?\n      }else if(y + 1 < lines.size()){\n        lines[y] += lines[y + 1];\n        lines.erase(lines.begin() + y + 1); //xはどうなる?\n      }\n    }else if(s == \"k\"){\n      if(x == lines[y].size()){\n        if(y + 1 < lines.size()){\n          lines[y] += lines[y + 1];\n          lines.erase(lines.begin() + y + 1); //xはどうなる?\n          buffer = \"\";\n          is_clear = false;\n        }\n      }else{\n        buffer = lines[y].substr(x);\n        assert(buffer != \"\");\n        is_clear = false;\n        lines[y].erase(x);\n      }\n    }else if(s == \"y\"){\n      if(is_clear){\n      }else if(buffer == \"\"){\n        string a = lines[y].substr(0, x);\n        string b = lines[y].substr(x);\n        lines[y] = a;\n        lines.insert(lines.begin() + y + 1, b);\n        y++;\n        x = 0;\n      }else{\n        string a = lines[y].substr(0, x);\n        string b = lines[y].substr(x);\n        lines[y] = a + buffer + b;\n        x += buffer.size();\n      }\n    }else{\n      assert(s == \"-\");\n    }\n  }\n  REP(i, lines.size()) cout << lines[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main(){\n\tstring s[500];\n\tint line = 0;\n\tfor ( string in;cin >> in, in != \"END_OF_TEXT\"; ++line ){\n\t\ts[ line ] = in;\n\t}\n\t\n\tint pX = 0;\n\tint pY = 0;\n\t\n\tstring buf;\n\tfor ( string in; cin >> in, in != \"-\"; ) {\n\t\tif ( in == \"a\" ) {\n\t\t\tpX = 0;\n\t\t} else if ( in == \"e\" ) {\n\t\t\tpX = s[ pY ].length();\n\t\t} else if ( in == \"p\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( 0 < pY ) {\n\t\t\t\t--pY;\n\t\t\t}\n\t\t} else if ( in == \"n\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( pY < line - 1 ) {\n\t\t\t\t++pY;\n\t\t\t}\n\t\t} else if ( in == \"f\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\t++pX;\n\t\t\t} else {\n\t\t\t\tif ( pY < line - 1 ) {\n\t\t\t\t\tpX = 0;\n\t\t\t\t\t++pY;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( in == \"b\" ) {\n\t\t\tif ( 0 < pX ) {\n\t\t\t\t--pX;\n\t\t\t} else {\n\t\t\t\tif ( 0 < pY ) {\n\t\t\t\t\t--pY;\n\t\t\t\t\tpX = s[ pY ].length();\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( in == \"d\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + s[ pY ].substr( pX + 1 );\n\t\t\t} else if ( pY < line - 1 ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\t--line;\n\t\t\t}\n\t\t} else if ( in == \"k\" ) {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\tbuf = s[ pY ].substr( pX );\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t\tpX = s[ pY ].length();\n\t\t\t} else if ( pY < line - 1 ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\tif ( 0 < line) {\n\t\t\t\t\t--line;\n\t\t\t\t}\n\t\t\t\tbuf = \"\\n\";\n\t\t\t}\n\t\t} else if ( in == \"y\" ) {\n\t\t\tif ( !buf.empty() ) {\n\t\t\t\tif ( buf == \"\\n\" ) {\n\t\t\t\t\tfor ( int i = line - 1; pY < i; --i ) {\n\t\t\t\t\t\ts[ i ] = s[ i - 1 ];\n\t\t\t\t\t}\n\t\t\t\t\ts[ pY + 1 ] = s[ pY ].substr( pX );\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t\t\t++line;\n\t\t\t\t} else {\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + buf + s[ pY ].substr( pX );\n\t\t\t\t\tpX += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor ( int i = 0; i < line; ++i ) cout << s[ i ] << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\ntemplate <class T> void pv(T a, T b) {\n\tfor(typeof(a) it = a; it != b; ++it)\n\t\tcerr << *it << \" \";\n\tcerr << endl;\n}\n\n#define all(v) (v).begin(), (v).end()\n\nvector<string> text;\nvector<char> command;\n\nint cursol_row;\nint cursol_col;\n\nvoid com_a() {\n\tcursol_col = 0;\n}\n\nvoid com_e() {\n\tcursol_col = text.at(cursol_row).length() - 1;\n}\n\nvoid com_p() {\n\tif(cursol_row > 0) cursol_row--;\n\tcursol_col = 0;\n}\n\nvoid com_n() {\n\tif(cursol_row < (int)text.size() - 1) cursol_row++;\n\tcursol_col = 0;\n}\n\nvoid com_f() {\n\tif(text[cursol_row][cursol_col] != '^') cursol_col++;\n\telse if(text[cursol_row][cursol_col] == '^' && cursol_row < (int)text.size() - 1) {\n\t\tcursol_row++;\n\t\tcursol_col = 0;\n\t}\n}\n\nvoid com_b() {\n\tif(cursol_col > 0) cursol_col--;\n\telse if(cursol_col == 0 && cursol_row > 0) {\n\t\tcursol_row--;\n\t\tcursol_col = text[cursol_row].length() - 1;\n\t}\n}\n\nvoid show_cursol() {\n\tcerr << \"ROW: \" << cursol_row << \" COL: \" << cursol_col << endl;\n}\n\nvoid com_d() {\n\tif(text[cursol_row][cursol_col] != '^') {\n\t\tstring line = text[cursol_row];\n\t\tstring left = line.substr(0, cursol_col);\n\t\tstring right = line.substr(cursol_col + 1);\n\t\ttext[cursol_row] = left + right;\n\t} else if(text[cursol_row][cursol_col] == '^' && cursol_row < (int)text.size() - 1) {\n\t\tstring line = text[cursol_row];\n\t\tline = line.substr(0, line.length() - 1) + text[cursol_row + 1];\n\t\ttext[cursol_row] = line;\n\n\t\tvector<string>::iterator it = text.begin();\n\t\tadvance(it, cursol_row + 1);\n\t\ttext.erase(it);\n\t}\n}\n\nstring buffer;\n\nvoid com_k() {\n\tif(text[cursol_row][cursol_col] == '^' && cursol_row < (int)text.size() - 1) {\n\t\tcom_d(); buffer = \"^\";\n\t} else {\n\t\tstring line = text[cursol_row];\n\t\tbuffer = line.substr(cursol_col);\n\t\tbuffer = buffer.substr(0, buffer.length() - 1);\n\t\ttext[cursol_row] = line.substr(0, cursol_col) + \"^\";\n\t}\n}\n\nvoid com_y() {\n\tif(buffer == \"^\") {\n\t\tstring line = text[cursol_row];\n\t\tstring fs = line.substr(0, cursol_col) + \"^\";\n\t\tstring sc = line.substr(cursol_col);\n\t\ttext[cursol_row] = fs;\n\n\t\tvector<string>::iterator it = text.begin();\n\t\tadvance(it, cursol_row + 1);\n\t\ttext.insert(it, sc);\n\t\tcursol_row++;\n\t\tcursol_col = 0;\n\t}\n\telse if(buffer != \"\") {\n\t\tstring line = text[cursol_row];\n\t\tstring left = line.substr(0, cursol_col);\n\t\tstring right = line.substr(cursol_col);\n\t\ttext[cursol_row] = left + buffer + right;\n\t}\n}\n\nint main() {\n\tbuffer = \"\";\n\n\tcursol_row = 0;\n\tcursol_col = 0;\n\n#if 1\n\tfor(string line; getline(cin, line) && line != \"END_OF_TEXT\";) {\n\t\ttext.push_back(line + \"^\");\n\t}\n\tfor(char c; cin >> c && c != '-'; ) {\n\t\tcommand.push_back(c);\n\t}\n#else\n\tfor(string line; getline(cin, line) && line != \"-\";) {\n\t\ttext.push_back(line + \"^\");\n\t}\n\tfor(char c; cin >> c && c != '-'; ) {\n\t\tswitch(c) {\n\t\t\tcase 'a': com_a(); break;\n\t\t\tcase 'e': com_e(); break;\n\t\t\tcase 'p': com_p(); break;\n\t\t\tcase 'n': com_n(); break;\n\t\t\tcase 'f': com_f(); break;\n\t\t\tcase 'b': com_b(); break;\n\t\t\tcase 'd': com_d(); break;\n\t\t\tcase 'k': com_k(); break;\n\t\t\tcase 'y': com_y(); break;\n\t\t\tdefault: break;\n\t\t}\n\t\tpv(all(text));\n\t\tshow_cursol();\n\t}\n#endif\n\n\t\n#if 0\n\tpv(all(text));\n\tpv(all(command));\n#endif\n\n\n#if 1\n\tfor(int i = 0; i < (int)command.size(); i++) {\n\t\tchar c = command[i];\n\t\tswitch(c) {\n\t\t\tcase 'a': com_a(); break;\n\t\t\tcase 'e': com_e(); break;\n\t\t\tcase 'p': com_p(); break;\n\t\t\tcase 'n': com_n(); break;\n\t\t\tcase 'f': com_f(); break;\n\t\t\tcase 'b': com_b(); break;\n\t\t\tcase 'd': com_d(); break;\n\t\t\tcase 'k': com_k(); break;\n\t\t\tcase 'y': com_y(); break;\n\t\t\tdefault: break;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < (int)text.size(); i++) {\n\t\tcout << text[i].substr(0, text[i].length() - 1) << endl;\n\t\t// cout << text[i] << endl;\n\t}\n#endif\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <string>\n#include <algorithm>\n\n#define DEBUG 0\n#define fprintf(...) (void)0\n\nint main() {\n  std::list<std::string> input;\n  while (true) {\n    char buf[24];\n    fgets(buf, sizeof buf, stdin);\n    std::string line=buf;\n    if (line == \"END_OF_TEXT\\n\")\n      break;\n\n    assert(line.back() == '\\n');\n    input.emplace_back(line);\n  }\n\n  std::string kbuf=\"\";\n  std::list<std::string>::iterator it=input.begin();\n  size_t cc=0;\n  while (true) {\n    char op;\n    scanf(\" %c\", &op);\n    if (op == '-')\n      break;\n\n    switch (op) {\n    case 'a':\n      cc = 0;\n      break;\n\n    case 'e':\n      cc = it->size()-1;\n      break;\n\n    case 'p':\n      cc = 0;\n      if (it != input.begin())\n        --it;\n      break;\n\n    case 'n':\n      cc = 0;\n      {\n        auto tmp=it;\n        ++tmp;\n        if (tmp != input.end())\n          it = tmp;\n      }\n      break;\n\n    case 'f':\n      if (cc+1 < it->size()) {\n        ++cc;\n      } else {\n        auto tmp=it;\n        ++tmp;\n        if (tmp != input.end()) {\n          cc = 0;\n          it = tmp;\n        }\n      }\n      break;\n\n    case 'b':\n      if (cc > 0) {\n        --cc;\n      } else if (it != input.begin()) {\n        --it;\n        cc = it->size()-1;\n      }\n      break;\n\n    case 'd':\n      if (cc == it->size()) {\n        assert((*it)[cc] == '\\n');\n        {\n          auto tmp=it;\n          ++tmp;\n          if (tmp != input.end()) {\n            it->pop_back();\n            *it += *tmp;\n            input.erase(tmp);\n          }\n        }\n      } else {\n        // TLE?\n        std::string t=it->substr(0, cc);\n        t += it->substr(cc+1);\n        *it = t;\n      }\n      break;\n\n    case 'k':\n      if (cc+1 == it->size()) {\n        assert((*it)[cc] == '\\n');\n        {\n          auto tmp=it;\n          ++tmp;\n          if (tmp != input.end()) {\n            assert(it->back() == '\\n');\n            it->pop_back();\n            *it += *tmp;\n            input.erase(tmp);\n          }\n        }\n        kbuf = \"\\n\";\n      } else {\n        kbuf = it->substr(cc);\n        assert(kbuf.back() == '\\n');\n        kbuf.pop_back();  // '\\n'\n        fprintf(stderr, \"kill buffer: %s\\n\", kbuf.c_str());\n        if (cc > 0) {\n          *it = it->substr(0, cc-1);\n          *it += '\\n';\n        } else {\n          *it = \"\\n\";\n        }\n        //cc = it->size()-1;\n      }\n      break;\n\n    case 'y':\n      if (kbuf.empty()) break;\n\n      if (kbuf == \"\\n\") {\n        ++it;\n        input.emplace(it, \"\\n\");\n        --it;  // ??\n        cc = 0;\n      } else {\n        {\n          std::string t=\"\";\n          if (cc > 0) {\n            t += it->substr(0, cc);\n          }\n          t += kbuf;\n          //t.pop_back();\n          t += it->substr(cc);\n          *it = t;\n        }\n      }\n      break;\n    }\n\n    if (DEBUG) {\n      fprintf(stderr, \"%c: L%td C%zu\\n\", op, std::distance(input.begin(), it), cc);\n      for (const auto &s: input)\n        printf(\"%s\", s.c_str());  // s ~ \".*\\n\"\n    }\n  }\n\n  for (const auto &s: input)\n    printf(\"%s\", s.c_str());  // s ~ \".*\\n\"\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\tvector<string> edit;\n\twhile(true){\n\t\tstring s;\tcin>>s;\n\t\tif(s==\"END_OF_TEXT\")\tbreak;\n\t\tedit.push_back(s);\n\t}\n\tint tr=0,tc=0;\n\tstring buff=\"\";\n\twhile(true){\n\t\tchar c;\tcin>>c;\n\t\tif(c=='-')\tbreak;\n\t\tif(c=='a')\ttr=0;\n\t\telse if(c=='e')\ttr=edit[tc].size();\n\t\telse if(c=='p'){\n\t\t\ttr=0;\ttc=max(0,tc-1);\n\t\t}\n\t\telse if(c=='n'){\n\t\t\ttr=0;\ttc=min((int)edit.size()-1,tc+1);\n\t\t}\n\t\telse if(c=='f'){\n\t\t\tif((int)edit[tc].size()>=tr+1)\ttr++;\n\t\t\telse if((int)edit.size()>tc+1){\n\t\t\t\ttc++;\ttr=0;\n\t\t\t}\n\t\t}\n\t\telse if(c=='b'){\n\t\t\tif(tr>0)\ttr--;\n\t\t\telse if(tc>0){\n\t\t\t\ttc--;\ttr=edit[tc].size();\n\t\t\t}\n\t\t}\n\t\telse if(c=='d'){\n\t\t\tif(tr<(int)edit[tc].size())\tedit[tc].erase(edit[tc].begin()+tr);\n\t\t\telse if(tc+1<(int)edit.size()){\n\t\t\t\tedit[tc]=edit[tc]+edit[tc+1];\n\t\t\t\tedit.erase(edit.begin()+tc+1);\n\t\t\t}\n\t\t}\n\t\telse if(c=='k'){\n\t\t\tif(tr<(int)edit[tc].size()){\n\t\t\t\tbuff=edit[tc].substr(tr);\n\t\t\t\tedit[tc].erase(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t}\n\t\t\telse if(tc+1<(int)edit.size()){\n\t\t\t\tbuff=\"\\n\";\n\t\t\t\tedit[tc]=edit[tc]+edit[tc+1];\n\t\t\t\tedit.erase(edit.begin()+tc+1);\n\t\t\t}\n\t\t}\n\t\telse if(c=='y'){\n\t\t\tif(buff==\"\")\tcontinue;\n\t\t\tif(buff==\"\\n\"){\n\t\t\t\tstring s(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t\tedit[tc].erase(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t\tedit.insert(edit.begin()+tc+1,s);\n\t\t\t\ttc++;\ttr=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint s=buff.size();\n\t\t\t\tedit[tc].insert(edit[tc].begin()+tr,buff.begin(),buff.end());\n\t\t\t\ttr+=s;\n\t\t\t}\n\t\t}\n\t}\n\tfor(string s:edit)\tcout<<s<<endl;\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nint main(){\n  vector<string> text(200);\n  int line = 0;\n  for(;line<11;line++){\n    getline(cin,text[line],'\\n');\n    if (text[line]==\"END_OF_TEXT\")\n      break;\n  }\n  string buf=\"\";\n  int cur[2];\n  cur[0] = 0;//0s\n  cur[1] = 0;//0¶Ú\n\n  while(true){\n    char com;\n    cin >> com;\n    if (com == '-')\n      break;\n    switch (com){\n    case 'a':\n      cur[1] = 0;\n      break;\n    case 'e':\n      cur[1] = (int)text[cur[0]].size();\n      break;\n    case 'p':\n      if (cur[0]>0)\n\tcur[0]--;\n      cur[1]=0;\n      break;\n    case 'n':\n      if (cur[0]<line-1)\n\tcur[0]++;\n      cur[1]=0;\n      break;\n    case 'f':\n      if (cur[1]<(int)text[cur[0]].size()){\n\tcur[1]++;\n      }\n      else{\n\tif (cur[0]<line-1){\n\t  cur[0]++;\n\t  cur[1]=0;\t\n\t}\n      }\n      break;\n    case 'b':\n      if (cur[1]>0)\n\tcur[1]--;\n      else{\n\tif (cur[0]>0){\n\t  cur[0]--;\n\t  cur[1]=(int)text[cur[0]].size();\t\n\t}\n      }\n      break;\n    case 'd':\n      if (cur[1]<(int)text[cur[0]].size()){\n\ttext[cur[0]] = text[cur[0]].substr(0,cur[1])+text[cur[0]].substr(cur[1]+1);\n      }\n      else{\n\tif (cur[0]<line-1){\n\t  text[cur[0]] = text[cur[0]]+text[cur[0]+1];\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i] = text[i+1];\n\t  line--;\n\t}\n      }\n      break;\n    case 'k':\n      if (cur[1]==(int)text[cur[0]].size()){\n\tif (cur[0]<line-1){\n\t  text[cur[0]] = text[cur[0]]+text[cur[0]+1];\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i] = text[i+1];\n\t  line--;\n\t  buf = \"\\n\";\n\t}\n      }\n      else{\n\tbuf = text[cur[0]].substr(cur[1]);\n\ttext[cur[0]] = text[cur[0]].substr(0,cur[1]);\n\tcur[1] = (int)text[cur[0]].size();\n      }\n      break;\n    case 'y':\n      if (buf.empty())\n\tbreak;\n      else{\n\tif (buf == \"\\n\"){\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i+1] = text[i];    \n\t  line++;\n\t  text[cur[0]+1] = text[cur[0]].substr(cur[1]);\n\t  text[cur[0]] = text[cur[0]].substr(0,cur[1]);\n\t  cur[0]++;\n\t  cur[1]=0;\n\t}\n\telse{\n\t  text[cur[0]] = text[cur[0]].substr(0,cur[1])+buf+text[cur[0]].substr(cur[1]);\n\t  cur[1] += buf.size();\n\t}\n      }\n    default:\n      break;\n    }\n          for(int i=0;i<line;i++)\n\tcout << text[i] << endl;\n\tcout << \"(\" << cur[0] << \",\" << cur[1] << \")\" << endl;\n\tcout << \"#\" << endl;\n  }\n  for(int i=0;i<line;i++)\n    cout << text[i] << endl;\n  return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t,u;\nvector<char> tmp;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nvoid yinsert(int,vector<char>);\nvoid xinsert(int,int,char);\nvoid ydelete(int);\nvoid xdelete(int,int);\n\nint main(){\n\n  t.clear();\n  tmp.clear();\n  input();\n  x=y=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n    //cout<<y<<' '<<x<<\" ty\"<<t.size()<<endl;\n  }\n\n  for(int i=0;i<t.size();i++){\n    for(int j=0;j<t[i].size();j++){\n      cout<<t[i][j];\n    }\n  }\n\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    xdelete(y,x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  xdelete(y,x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  ydelete(y+1);\n}\n\nvoid funcK(){\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.clear();\n      tmp.push_back('\\n');\n    }\n    return;\n  }\n  tmp.clear();\n  while(t[y][x]!='\\n'){\n    tmp.push_back(t[y][x]);\n    xdelete(y,x);\n  }\n  reverse(tmp.begin(),tmp.end());\n}\n\nvoid funcY(){\n  vector<char> z;\n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    while(t[y][x]!='\\n'){\n      z.push_back(t[y][x]);\n      xdelete(y,x);\n    }\n    yinsert(y+1,z);\n    y++;\n    x=0;\n    return;\n  }\n  for(int i=0;i<(int)tmp.size();i++){\n    xinsert(y,x,tmp[i]);\n  }\n  x+=tmp.size();\n  //funcE();\n}\n\nvoid input(){\n  vector<char> a;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n}\n\n\n\n\n\n\nvector<char> z;\n\nvoid xinsert(int y,int x,char ch){\n  if(x==(int)t[y].size()){\n    t[y].push_back(ch);\n  }else{\n    z=t[y];\n    t[y].clear();\n    for(int i=0;i<(int)z.size();i++){\n      if(i==x)t[y].push_back(ch);\n      t[y].push_back(z[i]);\n    }\n  }\n}\n\nvoid xdelete(int y,int x){\n  if(x+1==(int)t[y].size()){\n    t[y].pop_back();\n  }else{\n    \n    z=t[y];\n    t[y].clear();\n    for(int i=0;i<(int)z.size();i++){\n      if(i==x)continue;\n      t[y].push_back(z[i]);\n    }\n  }\n}\n\nvoid yinsert(int y,vector<char> ch){\n  if(y==(int)t.size()){\n    t.push_back(ch);\n  }else{\n    u=t;\n    t.clear();\n    for(int i=0;i<(int)u.size();i++){\n      if(i==y)t.push_back(ch);\n      t.push_back(u[i]);\n    }\n  }\n}\n\nvoid ydelete(int y){\n  if(y+1==(int)t.size()){\n    t.pop_back();\n  }else{\n    u=t;\n    t.clear();\n    for(int i=0;i<(int)u.size();i++){\n      if(i==y)continue;\n      t.push_back(u[i]);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[111];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\tfor(int i=0 ; i<111 ; i++)\n\t\tt[i] = \"\";\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tif(i<110) t[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tif(row<110) col = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 && row < 110 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row < 110 && row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( row < 110 && col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else if( row < 110 ){\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( row < 110 && buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line+1 < 110 && line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\tt[row+1] = t[row].substr( col );\n\t\t\t\t\t//t[row].erase( col );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else if( row < 110 ){\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  string txt[110],str,buf;\n  char c;\n  int x,y;\n\n  y = 0;\n  while(1){\n    getline(cin,str);\n    if(str == \"END_OF_TEXT\")break;\n    txt[y] = str + '\\n';\n    y++;\n  }\n\n  x = y = 0;\n  while(1){\n    c = getchar();\n    if(c == '-')break;\n    if(c == 'a'){\n      x = 0;\n    }\n    if(c == 'e'){\n      x = (int)txt[y].size() - 1;\n    }\n    if(c == 'p'){\n      if(y){\n\ty--;\n\tx = 0;\n      }else x = 0;\n    }\n    if(c == 'n'){\n      if(txt[y+1].size()){\n\ty++;\n\tx = 0;\n      }else x = 0;\n    }\n    if(c == 'f'){\n      if(x != (int)txt[y].size() - 1)x++;\n      else if(txt[y+1].size()){\n\ty++;\n\tx = 0;\n      }\n    }\n    if(c == 'b'){\n      if(x)x--;\n      else if(y){\n\ty--;\n\tx = (int)txt[y].size() - 1;\n      }\n    }\n    if(c == 'd'){\n      if(txt[y][x] != '\\n'){\n\ttxt[y].erase(txt[y].begin()+x);\n      }else if(txt[y+1].size()){\n\ttxt[y].erase(txt[y].begin()+x);\n\ttxt[y] += txt[y+1];\n\tint tmp = y+1;\n\twhile(txt[tmp+1].size()){\n\t  txt[tmp] = txt[tmp+1];\n\t  tmp++;\n\t}\n\ttxt[tmp].clear();\n      }\n    }\n    if(c == 'k'){\n      if(x == (int)txt[y].size() - 1){\n\tif(txt[y+1].size()){\n\t  txt[y].erase(txt[y].begin()+x);\n\t  txt[y] += txt[y+1];\n\t  int tmp = y+1;\n\t  while(txt[tmp+1].size()){\n\t    txt[tmp] = txt[tmp+1];\n\t    tmp++;\n\t  }\n\t  txt[tmp].clear();\n\t  buf = '\\n';\n\t}\n      }else{\n\tbuf.clear();\n\twhile(txt[y][x] != '\\n'){\n\t  buf.push_back(txt[y][x]);\n\t  txt[y].erase(txt[y].begin()+x);\n\t}\n      }\n    }\n    if(c == 'y'){\n      if(buf.size()){\n\tif(buf == \"\\n\"){\n\t  int tmp = y;\n\t  str = txt[y+1];\n\t  txt[y+1].clear();\n\t  while(txt[y][x] != '\\n'){\n\t    txt[y+1].push_back(txt[y][x]);\n\t    txt[y].erase(txt[y].begin()+x);\n\t  }\n\t  txt[y+1].push_back('\\n');\n\t  while(txt[++tmp].size())swap(txt[tmp],str);\n\t  txt[tmp] = str;  \n\t}else{\n\t  str.clear();\n\t  for(int i=0;i<x;i++)str.push_back(txt[y][i]);\n\t  str += buf;\n\t  for(int i=x;i<(int)txt[y].size();i++)str.push_back(txt[y][i]);\n\t  txt[y] = str;\n\t  x += buf.size();\n\t}\n      }\n    }\n    getchar();\n  }\n  y = 0;\n  while(txt[y].size())cout << txt[y++];\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nint main(){\n\n\tstring str;\n\tstring tmp;\n\tbool f=false;\n\twhile(cin>>tmp&&tmp!=\"END_OF_TEXT\"){\n\t\tf=true;\n\t\tstr+=tmp;\n\t\tstr+='\\n';\n\t}\n\tchar cmd;\n\tint cur=0;\n\n\tstring buff;\n\twhile(cin>>cmd&&cmd!='-'){\n\t\tif(cmd=='a'){\n\t\t\twhile(1){\n\t\t\t\tif(cur==0)\n\t\t\t\t\tbreak;\n\t\t\t\telse if(str[cur-1]=='\\n'){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur--;\n\t\t\t}\n\t\t}\n\t\telse if(cmd=='e'){\n\t\t\twhile(1){\n\t\t\t\tif(str[cur]=='\\n'){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur++;\n\t\t\t}\n\t\t}\n\t\telse if(cmd=='p'){\n\t\t\tint cnt=0;\n\t\t\twhile(1){\n\t\t\t\tif(cur==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(cur==str.size()-1){\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if(str[cur]=='\\n'){\n\t\t\t\t\tif(cnt==0)\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\telse{\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur--;\n\t\t\t}\n\t\t}\n\t\telse if(cmd=='n'){\n\t\t\tint cnt=0;\n\t\t\twhile(1){\n\t\t\t\tif(cur==str.size()-1){\n\t\t\t\t\twhile(1){\n\t\t\t\t\t\tif(cur==0||str[cur-1]=='\\n'){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(str[cur]=='\\n'){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(cmd=='f'){\n\t\t\tif(cur!=str.size()-1){\n\t\t\t\tcur++;\n\t\t\t}\n\t\t}\n\t\telse if(cmd=='b'){\n\t\t\tif(cur!=0){\n\t\t\t\tcur--;\n\t\t\t}\n\t\t}\n\t\telse if(cmd=='d'){\n\t\t\tif(cur==str.size()-1){\n\n\t\t\t}\n\t\t\telse\n\t\t\t\tstr = str.substr(0,cur) + str.substr(cur+1);\n\t\t}\n\t\telse if(cmd=='k'){\n\t\t\tif(str.size()-1==cur){\n\t\t\t\t\n\t\t\t}\n\t\t\telse if(str[cur]=='\\n'){\n\t\t\t\tstr = str.substr(0,cur) + str.substr(cur+1);\n\t\t\t\tbuff=\"\\n\";\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint prv=cur;\n\t\t\t\tint nxt=prv;\n\t\t\t\twhile(1){\n\t\t\t\t\tif(str[nxt]=='\\n'){\n\t\t\t\t\t\tbuff=str.substr(prv,nxt-prv);\n\t\t\t\t\t\tstr=str.substr(0,prv)+str.substr(nxt);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnxt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(cmd=='y'){\n\t\t\tif(buff!=\"\"){\n\t\t\t\tif(buff==\"\\n\"){\n\t\t\t\t\tstr=str.substr(0,cur)+\"\\n\"+str.substr(cur);\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstr=str.substr(0,cur)+buff+str.substr(cur);\n\t\t\t\t\tcur+=buff.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout<<str;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nvoid convert(string& text, int& cursor, string& buffer, char command);\n\nint main()\n{\t\n\tstring text, buffer;\n\tint cursor = 0;\n\t\n\tfor(string line; getline(cin, line) && line != \"END_OF_TEXT\"; text += line + '\\n');\n\tfor(char command; cin >> command && command != '-'; convert(text, cursor, buffer, command));\n\t\n\tcout << text;\n}\n\nvoid convert(string& text, int& cursor, string& buffer, char command)\n{\t\n\tswitch(command)\n\t{\n\t\t\t/*\n\t\t\t a\n\t\t\t J[\\ð»ÝÌsÌæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'a':\n\t\t{\n\t\t\tif(cursor != 0 && text[cursor - 1] != '\\n')\n\t\t\twhile(--cursor) if(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tcursor++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t e\n\t\t\t J[\\ð»ÝÌsÌsÉÚ®·éB\n\t\t\t */\n\t\tcase 'e':\n\t\t{\n\t\t\twhile(text[cursor] != '\\n') cursor++;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t p\n\t\t\t ãÉsª êÎAJ[\\ðãÌsÌæª¶ÉÚ®·éB\n\t\t\t ãÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'p':\n\t\t{\n\t\t\tif(cursor != 0) while(--cursor) if(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(cursor != 0) while(--cursor) if(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tcursor++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t n\n\t\t\t ºÉsª êÎAJ[\\ðºÌsÌæª¶ÉÚ®·éB\n\t\t\t ºÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'n':\n\t\t{\n\t\t\tint cur = cursor;\n\t\t\twhile(text[cur] != '\\n') cur++;\n\t\t\t\n\t\t\tif(cur + 1 == text.size())\n\t\t\t{\n\t\t\t\tif(cursor != 0) while(--cursor) if(text[cursor] == '\\n')\n\t\t\t\t{\n\t\t\t\t\tcursor++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcursor = cur + 1;\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t f\n\t\t\t J[\\ªsÉÈ¢êAJ[\\ðPÂEÉÚ®·éB\n\t\t\t J[\\ªsÉ è©ÂºÉsª éêÍAJ[\\ðºÌsÌæª¶ÖÚ®·éB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'f':\n\t\t{\n\t\t\tcursor += cursor + 1 != text.size();\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t b\n\t\t\t J[\\ªæª¶ÅÈ¢ÈçÎAJ[\\ðPÂ¶ÉÚ®·éB\n\t\t\t J[\\ªæª¶Å è©ÂãÉsª éêÍAJ[\\ðãÌsÌsÖÚ®·éB\n\t\t\t »êÈOÌêÍ½àµÈ¢\n\t\t\t */\n\t\tcase 'b':\n\t\t{\n\t\t\tcursor -= 0 < cursor;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t d\n\t\t\t J[\\ª¶ðw·êÍ»Ì¶ðí·éBí³ê½¶ÌE¤Ì¶ñÍ¶ÉVtg³êéB\n\t\t\t J[\\ªsðwµºÉsª éêÍAºÌsð»ÌÜÜJ[\\ÌÊuÉq°éBÈºÌsÍãÉVtg³êéB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'd':\n\t\t{\n\t\t\tif(cursor + 1 != text.size()) text.erase(text.begin() + cursor);\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t k\n\t\t\t J[\\ªsÉ éêAºÉsª êÎAd Æ¯¶ìðµobt@ÉPÂÌüsðL^·éB\n\t\t\t J[\\ªsÉÈ¢êAJ[\\ªw·¶ðÜß½E¤·×ÄÌ¶ðØèæè»êðobt@ÉL^·éBJ[\\Í³ÌsÌsðw·æ¤ÉÈéBSÄÌL^É¨¢Äobt@Íã«³êéB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'k':\n\t\t{\n\t\t\tbuffer = \"\";\n\t\t\tif(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tif(cursor + 1 == text.size())\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tbuffer = \"\\n\";\n\t\t\t\ttext.erase(text.begin() + cursor);\n\t\t\t}\n\t\t\telse while(text[cursor] != '\\n')\n\t\t\t{\n\t\t\t\tbuffer += text[cursor];\n\t\t\t\ttext.erase(text.begin() + cursor);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t y\n\t\t\t obt@ªóÌêÍÈÉàµÈ¢B\n\t\t\t obt@ÌàeªüsÌêAJ[\\ªw·¶Ì¼OÅüsðs¤BJ[\\ÍVµ¢sÌæª¶ÖÚ®·éB\n\t\t\t obt@Ìàeª¶ñÌêAJ[\\ÌÊuÉobt@Ìàeð}ü·éB J[\\ÌÊuÍàÆàÆwµÄ¢½¶Ü½ÍsÌêÖÚ®·é\n\t\t\t */\n\t\tcase 'y':\n\t\t{\n\t\t\ttext = text.substr(0, cursor) + buffer + text.substr(cursor);\n\t\t\tcursor += buffer.size();\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int p=0;\n  char c[32]=\"\";\n  string s,t=\"\";\n  while(strcmp(c,\"END_OF_TEXT\\n\")){\n    s+=c;\n    fgets(c,32,stdin);\n  }\n  s.erase(s.length()-1);\n  while(cin>>c[0]&&c[0]!='-'){\n    switch(c[0]){\n    case 'a':\n      if(p){\n\tfor(;p>0;p--){\n\t  if(s[p-1]=='\\n')\n\t    break;\n\t}\n      }\n      break;\n    case 'e':\n      p=s.find('\\n',p)<0?s.length():s.find('\\n',p);\n      break;\n    case 'p':\n      if(p){\n\tfor(;p>0;p--){\n\t  if(s[p-1]=='\\n')\n\t    break;\n\t}\n\tif(p){\n\t  for(p--;p>0;p--){\n\t    if(s[p-1]=='\\n')\n\t      break;\n\t  }\n\t}\n      }\n      break;\n    case 'n':\n      p=s.find('\\n',p)<0?s.length():s.find('\\n',p);\n      if(p==(int)s.length()){\n\tfor(;p>0;p--){\n\t  if(s[p-1]=='\\n')\n\t    break;\n\t}\n      }else\n\tp++;\n      break;\n    case 'f':\n      if(p!=(int)s.length())\n\tp++;\n      break;\n    case 'b':\n      if(p!=0)\n\tp--;\n      break;\n    case 'd':\n      if(p!=(int)s.length())\n\ts.erase(p,1);\n      break;\n    case 'k':\n      if(p!=(int)s.length()){\n\tif(s[p]=='\\n'){\n\t  t=s[p];\n\t  s.erase(p,1);\n\t}else{\n\t  t=s.substr(p,s.find('\\n',p)-p);\n\t  s.erase(p,s.find('\\n',p));\n\t}\n      }\n      break;\n    case 'y':\n      s.insert(p,t);\n      p+=t.length();\n      break;\n    }\n  }\n  cout<<s<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1021\n#include<iostream>\n#include<vector>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\nconst int LMAX = 1000;\n\nvector<string> lines;\nint h, w;\nstring buffer;\n\nbool on_tail() { return w == lines[h].size(); }\nvoid goto_tail() { w = lines[h].size(); }\nbool on_eof() { return h >= lines.size() - 1; }\nvoid remove_line(int n) { lines.erase(lines.begin() + n); }\nvoid remove_char(int h, int w) {\n  lines[h].erase(lines[h].begin() + w);\n}\n\nvoid a() { w = 0; }\nvoid e() { goto_tail(); }\nvoid p() { h = max(h - 1, 0); w = 0; }\nvoid n() { h = min(h + 1, (int)lines.size() - 1); w = 0; }\nvoid f() {\n  if (not on_tail()) { w++; }\n  else if (not on_eof()) {\n    h++; w = 0;\n  }\n}\nvoid b() {\n  if (w > 0) { w--; }\n  else if (h > 0) { h--; goto_tail(); }\n}\nvoid d() {\n  if (on_tail() and !on_eof()) {\n    lines[h] += lines[h + 1];\n    remove_line(h + 1);\n  } else if (not on_tail()) {\n    remove_char(h, w);\n  }\n}\nvoid k() {\n  if (on_tail() and !on_eof()) {\n    d();\n    buffer = \"\\n\";\n  } else if (not on_tail()) {\n    buffer = lines[h].substr(w);\n    lines[h] = lines[h].substr(0, w);\n  }\n}\nvoid y() {\n  if (buffer == \"\\n\") {\n    lines.insert(lines.begin() + h, \"\\n\");\n    h++; w = 0;\n  } else if (not buffer.empty()) {\n    lines[h].insert(lines[h].begin()+w, buffer.begin(), buffer.end());\n    w += buffer.size();\n  }\n}\n\nint main() {\n  string l;\n  buffer = \"\";\n  while (cin >> l and l != \"END_OF_TEXT\") {\n    lines.push_back(l);\n  }\n\n  char com;\n  while (cin >> com and com != '-') {\n    switch (com) {\n    case 'a':\n      a(); break;\n    case 'e':\n      e(); break;\n    case 'p':\n      p(); break;\n    case 'n':\n      n(); break;\n    case 'f':\n      f(); break;\n    case 'b':\n      b(); break;\n    case 'd':\n      d(); break;\n    case 'k':\n      k(); break;\n    case 'y':\n      y(); break;\n    default:\n      break;\n    }\n    REP(i, lines.size()) {\n      cout << \">\" << lines[i] << endl;\n    }\n    cout << \"(\" << h << \",\" << w << \")\" << endl;\n  }\n\n  for (int i = 0; i < lines.size(); i++) {\n    cout << lines[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(){\n  vector<string> text(200);\n  int line = 0;\n  for(;line<11;line++){\n    getline(cin,text[line],'\\n');\n    if (text[line]==\"END_OF_TEXT\")\n      break;\n  }\n  string buf;\n  int cur[2];\n  cur[0] = 0;//0s\n  cur[1] = 0;//0¶Ú\n\n  while(true){\n    char com;\n    cin >> com;\n    if (com == '-')\n      break;\n    switch (com){\n    case 'a':\n      cur[1] = 0;\n      break;\n    case 'e':\n      cur[1] = (int)text[cur[0]].size();\n      break;\n    case 'p':\n      if (cur[0]>0)\n\tcur[0]--;\n      cur[1]=0;\n      break;\n    case 'n':\n      if (cur[0]<line-1)\n\tcur[0]++;\n      cur[1]=0;\n      break;\n    case 'f':\n      if (cur[1]<(int)text[cur[0]].size())\n\tcur[1]++;\n      else{\n\tif (cur[0]<line-1){\n\t  cur[0]++;\n\t  cur[1]=0;\t\n\t}\n      }\n      break;\n    case 'b':\n      if (cur[1]>0)\n\tcur[1]--;\n      else{\n\tif (cur[0]>0){\n\t  cur[0]--;\n\t  cur[1]=(int)text[cur[0]].size();\t\n\t}\n      }\n      break;\n    case 'd':\n      if (cur[1]<(int)text[cur[0]].size()){\n\ttext[cur[0]] = text[cur[0]].substr(0,cur[1])+text[cur[0]].substr(cur[1]+1);\n      }\n      else{\n\tif (cur[0]<line-1){\n\t  text[cur[0]] = text[cur[0]]+text[cur[0]+1];\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i] = text[i+1];\n\t  line--;\n\t}\n      }\n      break;\n    case 'k':\n      if (cur[1]==(int)text[cur[0]].size()){\n\tif (cur[0]<line-1){\n\t  text[cur[0]] = text[cur[0]]+text[cur[0]+1];\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i] = text[i+1];\n\t  line--;\n\t  buf = \"\\n\";\n\t}\n      }\n      else{\n\tbuf = text[cur[0]].substr(cur[1]);\n\ttext[cur[0]] = text[cur[0]].substr(0,cur[1]);\n\tcur[1] = (int)text[cur[0]].size();\n      }\n      break;\n    case 'y':\n      if (buf.empty())\n\tbreak;\n      else{\n\tif (buf == \"\\n\"){\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i+1] = text[i];    \n\t  line++;\n\t  text[cur[0]] = text[cur[0]].substr(cur[1]);\n\t  text[cur[0]+1] = text[cur[0]].substr(0,cur[1]);\n\t}\n\telse{\n\t  text[cur[0]] = text[cur[0]].substr(0,cur[1])+buf+text[cur[0]].substr(cur[1]);\n\t}\n      }\n    default:\n      break;\n    }\n    /*  for(int i=0;i<line;i++)\n\tcout << text[i] << endl;\n\tcout << \"(\" << cur[0] << \",\" << cur[1] << \")\" << endl;\n\tcout << \"#\" << endl;*/\n  }\n  for(int i=0;i<line;i++)\n    cout << text[i] << endl;\n  return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  vector<string> line;\n  string li;\n  while(getline(cin, li), li != \"END_OF_TEXT\")\n    line.push_back(li);\n//  cin.ignore();\n  char c;\n  int x = 0, y = 0;\n  string buf;\n  while(cin >> c, c!='-') {\n    switch(c) {\n    case 'a':\n      x=0;\n      break;\n    case 'e':\n      x=line[y].size();\n      break;\n    case 'p':\n      if (y)\n        y--;\n      x=0;\n      break;\n    case 'n':\n      if (y<line.size()-1)\n        y++;\n      x=0;\n      break;\n    case 'f':\n      if (x<line[y].size()) {\n        x++;\n      } else if (y<line.size()-1) {\n        y++;\n        x=0;\n      }\n      break;\n    case 'b':\n      if (x)\n        x--;\n      else if (y) {\n        y--;\n        x=line[y].size();\n      }\n      break;\n    case 'd':\n      if (x!=line[y].size()) {\n        line[y].erase(line[y].begin()+x);\n      } else if (y<line.size()-1) {\n        line[y] += line[y+1];\n        line.erase(line.begin()+y+1);\n      }\n      break;\n    case 'k':\n      if (x==line[y].size()) {\n        if (y<line.size()-1) {\n          line[y] += line[y+1];\n          line.erase(line.begin()+y+1);\n          buf = \"\\n\";\n        }\n      } else {\n        buf = line[y].substr(x);\n        line[y].resize(x);\n      }\n      break;\n    case 'y':\n      if (buf==\"\") break;\n      if (buf==\"\\n\") {\n        string tmp = line[y].substr(x);\n        line[y].resize(x);\n        line.insert(line.begin()+y+1,tmp);\n        y++;\n        x=0;\n      } else {\n        line[y].insert(x, buf);\n        x+=buf.size();\n      }\n      break;\n      \n    }\n    // cout << c <<  \" \"  << x << \",\"<<y<< endl;\n    // REP(i, line.size())\n    //   cout << i<< \": \"<< line[i] << endl;\n  }\n  FOR(it, line)\n    cout << *it << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <string> VS;\nistream& myis = cin;\nostream& myos = cout;\n\nconst string END_OF_TEXT = \"END_OF_TEXT\";\nconst string END_OF_COMMAND = \"-\";\n\n// prototypes\nVS solve( const VS& lines );\nvoid output( const VS& lines );\nvoid split( const VS& lines, VS& T, VS& C );\n\n// editor\nclass Editor {\npublic:\n    // members\n    VS T;\n    int r;\n    int c;\n    string buffer;\n    // methods\n    Editor( VS T ): T(T) {\n        r = 0;\n        c = 0;\n        buffer.clear();\n    }\n    VS get_text() { return T; }\n    void parse_command( string com ) {\n        if ( com == \"a\" ) command_a();\n        if ( com == \"e\" ) command_e();\n        if ( com == \"p\" ) command_p();\n        if ( com == \"n\" ) command_n();\n        if ( com == \"f\" ) command_f();\n        if ( com == \"b\" ) command_b();\n        if ( com == \"d\" ) command_d();\n        if ( com == \"k\" ) command_k();\n        if ( com == \"y\" ) command_y();\n        // debug\n        /*\n        myos << \"::: debug start :::\" << endl;\n        myos << \"r: \" << r << endl;\n        myos << \"c: \" << c << endl;\n        myos << \"b: \" << buffer << endl;\n        myos << \"::: debug end   :::\" << endl;\n        */\n    }\nprivate:\n    bool is_cursor_leftmost() {\n        return c == 0;\n    }\n    bool is_cursor_rightmost() {\n        return c == (int)T[r].size();\n    }\n    bool exist_next_upperline() {\n        return r - 1 >= 0;\n    }\n    bool exist_next_lowerline() {\n        return r + 1 < (int)T.size();\n    }\n    void delete_line( int n ) {\n        T.erase( T.begin() + n );\n    }\n    void delete_letter( int n ) {\n        T[r].erase( T[r].begin() + n );\n    }\n    void move_cursor_leftmost() {\n        c = 0;\n    }\n    void move_cursor_rightmost() {\n        c = T[r].size();\n    }\n    void move_cursor_up() {\n        r -= 1;\n    }\n    void move_cursor_down() {\n        r += 1;\n    }\n    void move_cursor_left() {\n        c -= 1;\n    }\n    void move_cursor_right() {\n        c += 1;\n    }\n    void command_a() {\n        /*\n          J[\\ð»ÝÌsÌæª¶ÉÚ®·éB\n        */\n        move_cursor_leftmost();\n    }\n    void command_e() {\n        /*\n          J[\\ð»ÝÌsÌsÉÚ®·éB\n        */\n        move_cursor_rightmost();\n    }\n    void command_p() {\n        /*\n          ãÉsª êÎAJ[\\ðãÌsÌæª¶ÉÚ®·éB\n          ãÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n        */\n        if ( exist_next_upperline() ) {\n            move_cursor_up();\n            move_cursor_leftmost();\n        } else {\n            move_cursor_leftmost();\n        }\n    }\n    void command_n() {\n        /*\n          ºÉsª êÎAJ[\\ðºÌsÌæª¶ÉÚ®·éB\n          ºÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n        */\n        if ( exist_next_lowerline() ) {\n            move_cursor_down();\n            move_cursor_leftmost();\n        } else {\n            move_cursor_leftmost();\n        }\n    }\n    void command_f() {\n        /*\n          J[\\ªsÉÈ¢êAJ[\\ðPÂEÉÚ®·éB\n          J[\\ªsÉ è©ÂºÉsª éêÍAJ[\\ðºÌsÌæª¶ÖÚ®·éB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( ! is_cursor_rightmost() ) {\n            move_cursor_right();\n        } else if ( is_cursor_rightmost() && exist_next_lowerline() ) {\n            move_cursor_down();\n            move_cursor_leftmost();\n        }\n    }\n    void command_b() {\n        /*\n          J[\\ªæª¶ÅÈ¢ÈçÎAJ[\\ðPÂ¶ÉÚ®·éB\n          J[\\ªæª¶Å è©ÂãÉsª éêÍAJ[\\ðãÌsÌsÖÚ®·éB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( ! is_cursor_leftmost() ) {\n            move_cursor_left();\n        } else if ( is_cursor_leftmost() && exist_next_upperline() ) {\n            move_cursor_up();\n            move_cursor_rightmost();\n        }\n    }\n    void command_d() {\n        /*\n          J[\\ª¶ðw·êÍ»Ì¶ðí·éBí³ê½¶ÌE¤Ì¶ñÍ¶ÉVtg³êéB\n          J[\\ªsðwµºÉsª éêÍAºÌsð»ÌÜÜJ[\\ÌÊuÉq°éBÈºÌsÍãÉVtg³êéB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( ! is_cursor_rightmost() ) {\n            delete_letter( c );\n        } else if ( is_cursor_rightmost() && exist_next_lowerline() ) {\n            T[r] += T[r+1];\n            delete_line( r+1 );\n        }\n    }\n    void command_k() {\n        /*\n          J[\\ªsÉ éêAºÉsª êÎAd Æ¯¶ìðµobt@ÉPÂÌüsðL^·éB\n          J[\\ªsÉÈ¢êAJ[\\ªw·¶ðÜß½E¤·×ÄÌ¶ðØèæè»êðobt@ÉL^·éB\n          J[\\Í³ÌsÌsðw·æ¤ÉÈéBSÄÌL^É¨¢Äobt@Íã«³êéB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( is_cursor_rightmost() && exist_next_lowerline() ) {\n            T[r] += T[r+1];\n            delete_line( r+1 );\n            buffer = \"\\n\";\n        } else if ( ! is_cursor_rightmost() ) {\n            buffer = T[r].substr( c );\n            T[r] = T[r].substr( 0, c );\n            move_cursor_rightmost();\n        }\n    }\n    void command_y() {\n        /*\n          obt@ªóÌêÍÈÉàµÈ¢B\n          obt@ÌàeªüsÌêAJ[\\ªw·¶Ì¼OÅüsðs¤BJ[\\ÍVµ¢sÌæª¶ÖÚ®·éB\n          obt@Ìàeª¶ñÌêAJ[\\ÌÊuÉobt@Ìàeð}ü·éB\n          J[\\ÌÊuÍàÆàÆwµÄ¢½¶Ü½ÍsÌêÖÚ®·éB\n        */\n        if ( buffer == \"\\n\" ) {\n            string tmp = T[r].substr( c );\n            T[r] = T[r].substr( 0, c );\n            T.insert( T.begin() + r + 1, tmp );\n            move_cursor_down();\n            move_cursor_leftmost();\n        } else if ( buffer != \"\" ) {\n            string left = T[r].substr( 0, c );\n            string right = T[r].substr( c );\n            T[r] = left + buffer + right;\n        }\n    }\n};\n\n// functions\n\nVS solve( const VS& lines ) {\n    VS T; // text\n    VS C; // commands\n    split( lines, T, C );\n\n    // edit\n    Editor editor( T );\n    for ( VS ::iterator it_i = C.begin(); it_i != C.end(); ++ it_i ) {\n        string command = *it_i;\n        editor.parse_command( command );\n    }\n    return editor.get_text();\n}\n\nvoid output( const VS& lines ) {\n    for ( VS ::const_iterator it_i = lines.begin(); it_i != lines.end(); ++ it_i ) {\n        myos << *it_i << endl;\n    }\n}\n\nvoid split( const VS& lines, VS& T, VS& C ) {\n    T.clear();\n    C.clear();\n    VS ::const_iterator it_lines = lines.begin();\n    for ( ; it_lines != lines.end(); ++ it_lines ) {\n        const string& line = *it_lines;\n        if ( line == END_OF_TEXT ) {\n            ++ it_lines;\n            break;\n        }\n        T.push_back( line );\n    }\n    if ( T.empty() ) T.push_back( \"\" );\n    for ( ; it_lines != lines.end(); ++ it_lines ) {\n        const string& line = *it_lines;\n        if ( line == END_OF_COMMAND ) {\n            break;\n        }\n        C.push_back( line );\n    }\n}\n\nint main() {\n    VS lines;\n    string line;\n    while ( getline( myis, line ) ) lines.push_back( line );\n\n    VS answer = solve( lines );\n    output( answer );\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <list>\n\nint main() {\n  std::list<std::string> lines;\n  while (true) {\n    char buf[32];\n    fgets(buf, sizeof buf, stdin);\n    std::string line=buf;\n    if (line == \"END_OF_TEXT\\n\")\n      break;\n\n    lines.emplace_back(line);\n  }\n\n  auto it=lines.begin();\n  size_t cc=0;\n  std::string kbuf=\"\";\n  while (true) {\n    char op;\n    scanf(\" %c\", &op);\n\n    switch (op) {\n    case '-': {\n      for (const auto &line: lines)\n        printf(\"%s\", line.c_str());\n      return 0;\n    }\n\n    case 'a':\n      cc = 0;\n      break;\n\n    case 'e':\n      cc = it->size()-1;\n      break;\n\n    case 'p':\n      cc = 0;\n      if (it != lines.begin())\n        --it;\n      break;\n\n    case 'n':\n      cc = 0;\n      if (std::next(it) != lines.end())\n        ++it;\n      break;\n\n    case 'f':\n      if ((*it)[cc] != '\\n') {\n        ++cc;\n      } else if (std::next(it) != lines.end()) {\n        ++it;\n        cc = 0;\n      }\n      break;\n\n    case 'b':\n      if (cc > 0) {\n        --cc;\n      } else if (it != lines.begin()) {\n        --it;\n        cc = it->size()-1;\n      }\n      break;\n\n    case 'd':\n      if ((*it)[cc] != '\\n') {\n        std::string s=it->substr(0, cc);\n        s += it->substr(cc+1);\n        *it = s;\n      } else if (std::next(it) != lines.end()) {\n        it->pop_back();\n        auto tmp=std::next(it);\n        *it += *tmp;\n        lines.erase(tmp);\n      }\n      break;\n\n    case 'k':\n      if ((*it)[cc] != '\\n') {\n        kbuf = it->substr(cc);\n        kbuf.pop_back();\n        *it = it->substr(0, cc) + \"\\n\";\n      } else if (std::next(it) != lines.end()) {\n        kbuf = \"\\n\";\n        it->pop_back();\n        auto tmp=std::next(it);\n        *it += *tmp;\n        lines.erase(tmp);\n      }\n      break;\n\n    case 'y':\n      if (kbuf.empty()) {\n        // no-op;\n      } else if (kbuf == \"\\n\") {\n        std::string s=it->substr(cc);\n        *it = it->substr(0, cc) + \"\\n\";\n        auto tmp=std::next(it);\n        lines.emplace(tmp, s);\n        ++it;\n        cc = 0;\n      } else {\n        *it = it->substr(0, cc) + kbuf + it->substr(cc);\n      }\n      break;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nint main(){\n  char str[128][1024],c,buf[1024],input[1024];\n  int i,j,now_x,now_y,y_max;\n\n  memset(str,0,sizeof(str));\n  memset(buf,0,sizeof(buf));\n  for(i=0;gets(input);i++){\n    if(!strcmp(input,\"END_OF_TEXT\"))break;\n    strcpy(str[i],input);\n  }\n  y_max=i-1;\n  now_x=now_y=0;\n  for(;scanf(\" %c \",&c),c!='-';){\n    if(c=='a') //J[\\ð»ÝÌsÌæª\n      {\n        now_x=0;\n      }\n    else if(c=='e') //J[\\ð»ÝÌsÌs\n      {\n        now_x=strlen(str[now_y]);\n      }\n    else if(c=='p') //ãÉsª êÎJ[\\ðãÌsÌæªAÈ­Äàæª\n      {\n        if(now_y>0)now_y--;\n        now_x=0;\n      }\n    else if(c=='n') //ºÉsª ``\n      {\n        if(now_y<y_max)now_y++;\n        now_x=0;\n      }\n    else if(c=='f') //¶°¿ÙªsÅÈ¢Æ«EÉÚ®AsºÉsª éÆ«ºÌsÌæªAÈ¢Æ«Í½àµÈ¢\n      {\n        if(now_x!=strlen(str[now_y]))now_x++;\n        else{\n          if(now_y<y_max)now_y++,now_x=0;\n        }\n      }\n    else if(c=='b') //¶°¿Ùªæª¶ÅÈ¢Èç¶°¿Ùð¶ÉÚ®AæªãÉsª``\n      {\n        if(now_x>0)now_x--;\n        else{\n          if(now_y>0)now_y--,now_x=strlen(str[now_y]);\n        }\n      }\n    else if(c=='d')//¶°¿Ùª¶ðw·êíAí³ê½¶ÌE¤Í¶É¼ÌÄ``\n      {\n        if(now_x!=strlen(str[now_y])){\n          for(i=now_x;i<strlen(str[now_y]);i++)str[now_y][i]=str[now_y][i+1];\n        }\n        else{//¶°¿ÙªsÌÆ«\n          if(now_y<y_max){\n            strcat(str[now_y],str[now_y+1]);\n            y_max=now_y;\n            for(i=now_y+1;i<127;i++){\n              strcpy(str[i],str[i+1]);\n              if(str[i]!=0)y_max=i;\n            }\n          }\n        }\n      }\n    else if(c=='k') //\n      {\n        if(now_x==strlen(str[now_y])){\n          if(now_y<y_max){\n            strcat(str[now_y],str[now_y+1]);\n            y_max=now_y;\n            for(i=now_y+1;i<127;i++){\n              strcpy(str[i],str[i+1]);\n              if(str[i][0]!=0)y_max=i;\n            }\n          }\n          buf[0]='\\n'; buf[1]=0;\n        }else{\n          strcpy(buf,str[now_y]+now_x);\n          str[now_y][now_x]=0;\n          now_x=strlen(str[now_y]);\n          \n        }\n      }\n    else if(c=='y') //\n      {\n        if(buf[0]!=0){\n          if(buf[0]=='\\n'){\n            for(i=126;i>now_y;i--)strcpy(str[i+1],str[i]);\n            strcpy(str[now_y+1],str[now_y]+now_x);\n            str[now_y][now_x]=0;\n            now_y++; now_x=0;\n            y_max++;\n          }else{\n            char tmp[1024];\n            int t=now_x+1>strlen(str[now_y])?strlen(str[now_y]):now_x+1;\n            strcpy(tmp,str[now_y]+now_x);\n            for(i=now_x,j=0;j<strlen(buf);)str[now_y][i++]=buf[j++];\n            str[now_y][i]=0;\n            strcat(str[now_y],tmp);\n          }\n        }\n        //memset(buf,0,sizeof(buf));\n      }\n    //printf(\"y_max:%d\\n\",y_max);\n    //for(i=0;i<=y_max;i++)printf(\"%d:%s\\n\",i,str[i]);\n    //printf(\"%c-----------------now_x:%d , now_y:%d , y_max:%d\\n\",c,now_x,now_y,y_max);\n  }\n  for(i=0;i<=y_max;i++)puts(str[i]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define TOP_OF_BUFFER 0\n#define BEGIN_OF_LINE 0\n#define END_OF_LINE 10000\n\nstruct Cursor{\n  int x, y;\n  Cursor(){\n    x = 0, y = 0;\n  }\n};\n\nvector<string> buffer;\nstring buf;\nbool new_line;\nCursor cursor;\nint end;\n\nvoid output(){\n  for(int i = 0 ; i <= end ; i++){\n    cout << buffer[i] << endl;\n  }\n  //cout << endl;\n}\n\nvoid a_command(){\n  cursor.x = BEGIN_OF_LINE;\n}\n\nvoid e_command(){\n  cursor.x = END_OF_LINE;\n}\n\nvoid p_command(){\n  if(cursor.y == TOP_OF_BUFFER) cursor.x = BEGIN_OF_LINE;\n  else{\n    cursor.y--;\n    cursor.x = BEGIN_OF_LINE;\n  }\n}\n\nvoid n_command(){\n  if(cursor.y == end) cursor.x = BEGIN_OF_LINE;\n  else{\n    cursor.y++;\n    cursor.x = BEGIN_OF_LINE;\n  }\n}\n\nvoid f_command(){\n  if(cursor.x != END_OF_LINE) cursor.x++;\n  else if(cursor.x == END_OF_LINE && cursor.y != end){\n    cursor.x = BEGIN_OF_LINE;\n    cursor.y++;\n  }\n}\n\nvoid b_command(){\n  if(cursor.x != BEGIN_OF_LINE) cursor.x--;\n  else if(cursor.x == BEGIN_OF_LINE && cursor.y != TOP_OF_BUFFER){\n    cursor.x = END_OF_LINE;\n    cursor.y--;\n  }\n}\n\nvoid d_command(){\n  if(cursor.x == END_OF_LINE && cursor.y != end){\n    buffer[cursor.y] += buffer[cursor.y+1];\n    buffer.erase(buffer.begin() + cursor.y+1);\n    end--;\n  }\n  else if(cursor.x != END_OF_LINE){\n    buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n  }\n}\n\nvoid k_command(){\n  if(cursor.x == END_OF_LINE && cursor.y != end){\n    d_command();\n    new_line = true;\n  }\n  else if(cursor.x != END_OF_LINE){\n    buf = \"\";\n    new_line = false;\n    for(int j = cursor.x ; j < buffer[cursor.y].size() ; j++){\n      buf += buffer[cursor.y][j];\n    }\n\n    int buffer_size = buffer[cursor.y].size();\n    for(int j = cursor.x ; j < buffer_size ; j++){\n      buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n      //cout << buffer[cursor.y] << endl;\n    }\n  }\n}\n\nvoid y_command(){\n  if(buf == \"\") return;\n  string bf = \"\";\n  for(int j = cursor.x ; j < buffer[cursor.y].size() ; j++){\n    bf += buffer[cursor.y][j];\n  }\n  \n  if(new_line){\n    buffer.push_back(\"\");\n    \n    for(int i = buffer.size()-1 ; i > cursor.y ; i--){\n      buffer[i] = buffer[i-1];\n    }\n    end++;\n    buffer[cursor.y+1] = bf;\n    int buffer_size = buffer[cursor.y].size();\n    for(int j = cursor.x ; j < buffer_size ; j++){\n      buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n    }\n  }\n  else{\n    if(cursor.x == END_OF_LINE){\n      buffer[cursor.y] += buf;\n    }\n    else{\n      for(int cnt = 0 ; cnt < bf.size() ; cnt++){\n\tbuffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n      }\n      buffer[cursor.y] += buf;\n      buffer[cursor.y] += bf;\n      cursor.x += buf.size();\n    }\n  }\n} \n\nvoid init(){\n  end = buffer.size()-1;\n  new_line = false;  \n  buf = \"\";\n}\n  \nint main(){\n  string s;\n  while(getline(cin, s)){\n    if(s == \"END_OF_TEXT\") break;\n    buffer.push_back(s);\n  }\n  \n  init();\n  \n  char op;\n  while(cin >> op){\n    cout << \"operand = \" << op << endl;\n    if(op == '-') break;\n    if(op == 'a') a_command();\n    if(op == 'e') e_command();\n    if(op == 'p') p_command();\n    if(op == 'n') n_command();\n    if(op == 'f') f_command();\n    if(op == 'b') b_command();\n    if(op == 'd') d_command();\n    if(op == 'k') k_command();\n    if(op == 'y') y_command();  \n    if(cursor.x == buffer[cursor.y].size()) cursor.x = END_OF_LINE;\n    //output();\n    //cout << \"cursor.x = \" << cursor.x << \", cursor.y = \" << cursor.y << endl << endl;  \n  }\n  \n  output();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define TOP_OF_BUFFER 0\n#define BEGIN_OF_LINE 0\n\nstruct Cursor{\n  int x, y;\n  Cursor(){\n    x = 0, y = 0;\n  }\n};\n\nvector<string> buffer;\nstring buf;\nbool new_line;\nCursor cursor;\nint end;\n\nvoid output(){\n  for(int i = 0 ; i <= end ; i++){\n    cout << buffer[i] << endl;\n  }\n  //cout << endl;\n}\n\nvoid a_command(){\n  cursor.x = BEGIN_OF_LINE;\n}\n\nvoid e_command(){\n  //cout << buffer[cursor.y].size() << endl;\n  cursor.x = buffer[cursor.y].size();\n}\n\nvoid p_command(){\n  if(cursor.y == TOP_OF_BUFFER) cursor.x = BEGIN_OF_LINE;\n  else{\n    cursor.y--;\n    cursor.x = BEGIN_OF_LINE;\n  }\n}\n\nvoid n_command(){\n  if(cursor.y == end) cursor.x = BEGIN_OF_LINE;\n  else{\n    cursor.y++;\n    cursor.x = BEGIN_OF_LINE;\n  }\n}\n\nvoid f_command(){\n  if(cursor.x != buffer[cursor.y].size()) cursor.x++;\n  else if(cursor.x == buffer[cursor.y].size() && cursor.y != end){\n    cursor.x = BEGIN_OF_LINE;\n    cursor.y++;\n  }\n}\n\nvoid b_command(){\n  if(cursor.x != BEGIN_OF_LINE) cursor.x--;\n  else if(cursor.x == BEGIN_OF_LINE && cursor.y != TOP_OF_BUFFER){\n    cursor.x = buffer[cursor.y-1].size();\n    cursor.y--;\n  }\n}\n\nvoid d_command(){\n  if(cursor.x == buffer[cursor.y].size() && cursor.y != end){\n    //シフト\n    //if(buffer[cursor.y].size() == 0) cursor.x = 0;\n    cursor.x = buffer[cursor.y].size();\n    buffer[cursor.y] += buffer[cursor.y+1];\n    buffer.erase(buffer.begin() + cursor.y+1);\n    end--;\n  }\n  else if(cursor.x != buffer[cursor.y].size()){\n    buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n  }\n}\n\nvoid k_command(){\n  if(cursor.x == buffer[cursor.y].size() && cursor.y != end){\n    d_command();\n    buf = \"\";\n    new_line = true;\n  }\n  else if(cursor.x != buffer[cursor.y].size()){\n    buf = \"\";\n    new_line = false;\n    for(int j = cursor.x ; j < buffer[cursor.y].size() ; j++){\n      buf += buffer[cursor.y][j];\n    }\n\n    int buffer_size = buffer[cursor.y].size();\n    for(int j = cursor.x ; j < buffer_size ; j++){\n      buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n      //cout << buffer[cursor.y] << endl;\n    }\n  }\n}\n\nvoid y_command(){\n  //if(buf == \"\") return;\n  string bf = \"\";\n  for(int j = cursor.x ; j < buffer[cursor.y].size() ; j++){\n    bf += buffer[cursor.y][j];\n  }\n  \n  \n  if(new_line){\n    buffer.push_back(\"\");\n    //cout << \"size = \" << buffer.size() << endl;\n    for(int i = buffer.size()-1 ; i > cursor.y ; i--){\n      buffer[i] = buffer[i-1];\n    }\n    end++;\n    buffer[cursor.y+1] = bf;\n    int buffer_size = buffer[cursor.y].size();\n    for(int j = cursor.x ; j < buffer_size ; j++){\n      buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n    }\n    cursor.y++;\n    cursor.x = 0;\n  }\n  \n  //if(buf == \"\") return;\n  \n  else{\n    if(cursor.x == buffer[cursor.y].size()){\n      buffer[cursor.y] += buf;\n      cursor.x += buf.size();\n    }\n    else{\n      for(int cnt = 0 ; cnt < bf.size() ; cnt++){\n\tbuffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n      }\n      buffer[cursor.y] += buf;\n      buffer[cursor.y] += bf;\n      cursor.x += buf.size();\n      // cout << \"came \" << buf.size() << endl;\n    }\n  }\n} \n\nvoid init(){\n  end = buffer.size()-1;\n  new_line = false;  \n  buf = \"\";\n}\n  \nint main(){\n  string s;\n  while(getline(cin, s)){\n    if(s == \"END_OF_TEXT\") break;\n    buffer.push_back(s);\n  }\n  \n  init();\n  \n  char op;\n  int Cnt = 0;\n  while(cin >> op){\n    //cout << \"operand = \" << op << endl;\n    if(op == '-') break;\n    if(op == 'a') a_command();\n    if(op == 'e') e_command();\n    if(op == 'p') p_command();\n    if(op == 'n') n_command();\n    if(op == 'f') f_command();\n    if(op == 'b') b_command();\n    if(op == 'd') d_command();\n    if(op == 'k') k_command();\n    if(op == 'y') y_command();  \n    //cout << Cnt++ << endl;\n    //if(cursor.x == buffer[cursor.y].size() ) cursor.x = END_OF_LINE;\n    //output();\n    //cout << \"cursor.x = \" << cursor.x << \", cursor.y = \" << cursor.y << endl << endl;  \n    //cout << \"new_line = \" << new_line << endl;\n  }\n  \n  output();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t,u;\nvector<char> tmp;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nint main(){\n\n  t.clear();\n  tmp.clear();\n  input();\n  x=y=0;\n  while(1){\n    \n    for(int i=0;i<t.size();i++){\n      if(t[i].size()==0)t[i].push_back('\\n');\n    }\n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n    //cout<<y<<' '<<x<<\" ty\"<<t.size()<<endl;\n  }\n\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    t[y].erase(t[y].begin()+x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  t[y].erase(t[y].begin()+x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  t.erase(t.begin()+y+1);\n}\n\nvoid funcK(){\n  tmp.clear();\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.push_back('\\n');\n    }\n\n    //x=t[y].size()-1;\n    return;\n  }\n  int c=0;\n  for(int i=x;i+1<(int)t[y].size();i++){\n    tmp.push_back(t[y][i]);\n    c++;\n  }\n  for(int i=0;i<=c;i++)t[y].pop_back();\n  t[y].push_back('\\n');\n  reverse(tmp.begin(),tmp.end());\n  x=t[y].size()-1;\n}\n\nvoid funcY(){\n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    vector<char> z;\n    int c=0;\n    for(int i=x;i<(int)t[y].size();i++){\n      z.push_back(t[y][i]);\n      c++;\n    }\n    for(int i=0;i<=c;i++)t[y].pop_back();\n    t[y].push_back('\\n');\n    t.insert(t.begin()+y+1,z);\n    y++;\n    x=0;\n    return;\n  }\n\n  for(int i=0;i<(int)tmp.size();i++){\n    t[y].insert(t[y].begin()+x,tmp[i]);\n  }\n  funcE();\n\n}\n\nvoid input(){\n  vector<char> a;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[110][1100];\nchar buf[1100];\nchar in[10];\nint main(){\n\tint n=0;\n\twhile(1){\n\t\tgets(str[n]);\n\t\tif(str[n][3]=='_')break;\n\t\tn++;\n\t}\n\tfor(int i=0;i<1100;i++)str[n][i]=0;\n\tint row=0;\n\tint col=0;\n\twhile(1){\n\t\tscanf(\"%s\",in);\n\t\tif(in[0]=='-')break;\n\t\tif(in[0]=='a')col=0;\n\t\tif(in[0]=='e'){\n\t\t\twhile(str[row][col]){\n\t\t\t\tcol++;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='p'){\n\t\t\tif(row)row--;\n\t\t\tcol=0;\n\t\t}\n\t\tif(in[0]=='n'){\n\t\t\tif(row<n-1)row++;\n\t\t\tcol=0;\n\t\t}\n\t\tif(in[0]=='f'){\n\t\t\tif(str[row][col])col++;\n\t\t\telse if(row<n-1){row++;col=0;}\n\t\t}\n\t\tif(in[0]=='b'){\n\t\t\tif(col)col--;\n\t\t\telse if(row){row--;col=0;\n\t\t\t\twhile(str[row][col])col++;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='d'){\n\t\t\tif(str[row][col]){\n\t\t\t\tfor(int i=col;str[row][i];i++)str[row][i]=str[row][i+1];\n\t\t\t}else if(row<n-1){\n\t\t\t\tfor(int i=0;str[row+1][i];i++){\n\t\t\t\t\tstr[row][col+i]=str[row+1][i];\n\t\t\t\t\tstr[row+1][i]=0;\n\t\t\t\t}\n\t\t\t\tfor(int i=row+1;i<n;i++){\n\t\t\t\t\tfor(int j=0;j<1100;j++)str[i][j]=str[i+1][j];\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<1100;i++)str[n][i]=0;\n\t\t\t\tn--;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='k'){\n\t\t\tif(!str[row][col]){\n\t\t\t\tif(row<n-1){\n\t\t\t\t\tfor(int i=0;str[row+1][i];i++){\n\t\t\t\t\t\tstr[row][col++]=str[row+1][i];\n\t\t\t\t\t\tstr[row+1][i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tn--;\n\t\t\t\t\tbuf[0]='@';\n\t\t\t\t\tbuf[1]=0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint at=0;\n\t\t\t\tfor(int i=col;str[row][i];i++){\n\t\t\t\t\tbuf[at++]=str[row][i];\n\t\t\t\t\tstr[row][i]=0;\n\t\t\t\t}\n\t\t\t\tbuf[at]=0;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='y'){\n\t\t\tif(buf[0]){\n\t\t\t\tif(buf[0]=='@'){\n\t\t\t\t\tfor(int i=n-1;i>row;i--){\n\t\t\t\t\t\tfor(int j=0;j<1100;j++)str[i+1][j]=str[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tint at=0;\n\t\t\t\t\tfor(int i=col;str[row][i];i++){\n\t\t\t\t\t\tstr[row+1][at++]=str[row][i];\n\t\t\t\t\t\tstr[row][i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tstr[row+1][at]=0;\n\t\t\t\t\trow++;col=0;\n\t\t\t\t\tn++;\n\t\t\t\t}else{\n\t\t\t\t\tint sz=0;\n\t\t\t\t\tfor(int i=0;buf[i];i++)sz++;\n\t\t\t\t\tfor(int i=1109;i>=col;i--){\n\t\t\t\t\t\tif(i+sz>=1100)continue;\n\t\t\t\t\t\tstr[row][i+sz]=str[row][i];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0;i<sz;i++)str[row][col+i]=buf[i];\n\t\t\t\t\tcol+=sz;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)printf(\"%s\\n\",str[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY = 0;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n\telse return;\n}\n\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\t//ctrl_d(lines);\n\t\tbuf = \"\\n\";\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring front=\"\";\n\t\tstring rear=\"\";\n\t\tfront = lines[posY].substr(0,posX);\n\t\trear = lines[posY].substr(posX,lines[posY].size()-posX);\t\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX+1);\n\n\t\tlines[posY] = front;\n\t\tdeque<string>::iterator it = lines.begin();\n\t\tadvance(it,posY);\n\t\tlines.insert(it,rear);\n\t}\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(getline(cin,str)){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(cin >> str){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\tif(str == \"d\") ctrl_d(lines);\n\t\tif(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[111];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\tfor(int i=0 ; i<111 ; i++)\n\t\tt[i] = \"\";\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tif(i<110) t[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tif(row<110) col = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 && row < 110 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row < 110 && row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( row < 110 && col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else if( row < 110 ){\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( row < 110 && buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line+1 < 110 && line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\tt[row+1] = \"\";\n\t\t\t\t\tfor(int i=col ; i<(int)t[row].size();i++)\n\t\t\t\t\t\tt[row+1].push_back( t[row][i] );\n\t\t\t\t\tif(col < t[row].size() ) t[row].erase( col );\n\t\t\t\t\t//t[row].substr( col );\n\t\t\t\t\t//t[row+1] = ;\n\t\t\t\t\t//t[row+1] =\n\t\t\t\t\t//if( col != t[row].size() ) t[row];//.substr( col );\n\t\t\t\t\t//if(col != t[row].size() ) t[row].erase( 0 );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else if( row < 110 ){\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvoid doA(int *l, int *c, string &s, string &b, vector<string> &v) {\n  *c = 0;\n}\n\nvoid doE(int *l, int *c, string &s, string &b, vector<string> &v) {\n  *c = s.size();\n}\n\nvoid doP(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*l > 0)\n    *l -= 1;\n  *c = 0;\n}\n\nvoid doN(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*l < v.size()-1)\n    *l += 1;\n  *c = 0;\n}\n\nvoid doF(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c < s.size()) {\n    *c += 1;\n  } else if (*l < v.size()-1){\n    *l += 1;\n    *c = 0;\n  }\n}\n\nvoid doB(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c > 0) {\n    *c -= 1;\n  } else if (*l > 0) {\n    *l -= 1;\n    *c = v[*l].size();\n  }\n}\n\nvoid doD(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c < s.size()) {\n    s.erase(*c, 1);\n  } else if (*l < v.size()-1) {\n    s.append(v[*l+1]);\n    vector<string>::iterator itr = v.begin() + *l + 1;\n    v.erase(itr);\n  }\n}\n\nvoid doK(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c == s.size() && *l < v.size()-1) {\n    doD(l, c, s, b, v);\n    b = \"\\n\";\n  } else if (*c < s.size()) {\n    b = s.substr(*c, s.size() - *c);\n    s.erase(*c, s.size() - *c);\n    *c = s.size();\n  }\n}\n\n\nvoid doY(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (b.empty()) {\n    return;\n  } else if (b == \"\\n\") {\n    doK(l, c, s, b, v);\n    vector<string>::iterator itr = v.begin() + *l + 1;\n    v.insert(itr, );\n    b = \"\\n\";\n    *l++;\n    *c = 0;\n  } else {\n    s.insert(*c, b);\n    *c = s.size();\n  }\n}\n\nint main(int argc, char *argv[]) {\n  string buf;\n  vector<string> strs;\n  while (true) {\n    string s;\n    getline(cin, s);\n    if (s == \"END_OF_TEXT\")\n      break;\n    strs.push_back(s);\n  }\n  int line = 0, chrc = 0;\n  while (true) {\n    char c;\n    cin >> c;\n    if (c == '-')\n      break;\n    else if (c == 'a')\n      doA(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'e')\n      doE(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'p')\n      doP(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'n')\n      doN(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'f')\n      doF(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'b')\n      doB(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'd')\n      doD(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'k')\n      doK(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'y')\n      doY(&line, &chrc, strs[line], buf, strs);\n  }\n\n  for (int i = 0; i < strs.size(); i++)\n    cout << strs[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int INF = 100000000;\n\nvector<string> text;\nstring buffer;\n\nvoid setcursor(P &p, char com){\n\tswitch(com){\n\tcase 'a':\n\t\tp.X = 1;\n\t\tbreak;\n\tcase 'e':\n\t\tp.X = text[p.Y].size();\n\t\tbreak;\n\tcase 'p':\n\t\tsetcursor(p, 'a');\n\t\tif(p.Y > 0) p.Y--;\n\t\tbreak;\n\tcase 'n':\n\t\tsetcursor(p, 'a');\n\t\tif(p.Y < text.size()-1) p.Y++;\n\t\tbreak;\n\tcase 'f':\n\t\tif(p.X < text[p.Y].size()) p.X++;\n\t\telse{\n\t\t\tif(p.Y < text.size()-1){\n\t\t\t\tp.Y++;\n\t\t\t\tsetcursor(p, 'a');\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'b':\n\t\tif(p.X > 1) p.X--;\n\t\telse{\n\t\t\tif(p.Y > 0){ \n\t\t\t\tp.Y-- ;\n\t\t\t\tsetcursor(p, 'e');\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'd':\n\t\tif(p.X < text[p.Y].size()){\n\t\t\ttext[p.Y].erase(p.X-1, 1);\n\t\t}\n\t\telse if(p.X == text[p.Y].size()){\n\t\t\tif(p.Y < text.size()-1){\n\t\t\t\ttext[p.Y].erase(p.X-1, 1);\n\t\t\t\ttext[p.Y] += text[p.Y+1];\n\t\t\t\ttext.erase(text.begin()+p.Y+1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'k':\n\t\tif(p.X == text[p.Y].size()){\n\t\t\tif(p.Y < text.size()-1){\n\t\t\t\ttext[p.Y].erase(p.X-1, 1);\n\t\t\t\ttext[p.Y] += text[p.Y+1];\n\t\t\t\ttext.erase(text.begin()+p.Y+1);\n\n\t\t\t\tbuffer = \"\\n\";\n\t\t\t}\n\t\t}else{\n\t\t\tbuffer = text[p.Y].substr(p.X-1);\n\t\t\tbuffer.erase(buffer.size()-1);\n\t\t\ttext[p.Y].erase(p.X-1);\n\t\t\ttext[p.Y] += '\\0';\n\t\t}\n\t\tbreak;\n\tcase 'y':\n\t\tif(buffer == \"\")break;\n\t\tif(buffer != \"\\n\")text[p.Y].insert( p.X-1, buffer);\n\t\telse{\n\t\t\tstring tmp = text[p.Y].substr(p.X-1);\n\t\t\ttext[p.Y].erase(p.X-1);\n\t\t\ttext[p.Y] += '\\0';\n\t\t\tp.Y++;\n\t\t\ttext.insert(text.begin()+p.Y, tmp);\n\t\t\tsetcursor(p, 'a');\n\t\t}\n\t}\n}\n\nvoid pp(P p){\n\tchar tmp = '*';\n\tswap(tmp, text[p.Y][p.X-1]);\n\trep(i, text.size()){\n\t\tcout << text[i] << endl;\n\t}\n\tswap(tmp, text[p.Y][p.X-1]);\t\n}\n\nint main(){\n//\tfreopen(\"test.txt\", \"r\", stdin);\n\n\tstring s;\n\twhile(getline(cin, s), s != \"END_OF_TEXT\"){\n\t\ttext.push_back(s+'\\0');\n\t}\n\n//\tfreopen(\"CON\", \"r\", stdin);\n\n\tP cursor(MP(1, 0)); // y行x文字目\n\n//pp(cursor);\n\n\tchar com;\n\twhile(cin >> com, com != '-'){\n\t\tsetcursor(cursor, com);\n\n\t\t//pp(cursor);\n\t\t//printf(\"%d-%d\\n\", cursor.Y, cursor.X);\n\t}\n\n\trep(i, text.size()){\n\t\ttext[i].erase(text[i].size()-1, 1);\n\t\tcout << text[i] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author: Dumbear\n * Created Time:  2011/8/31 14:59:27\n * File Name: \n */\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <list>\nusing namespace std;\n#define out(v) cerr << #v << \": \" << (v) << endl\n#define SZ(v) ((int)(v).size())\nconst int maxint = -1u>>1;\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\n\nvector<string> text;\nint cx, cy;\nstring buffer;\n\nvoid a() {\n    cy = 0;\n}\n\nvoid e() {\n    cy = text[cx].size();\n}\n\nvoid p() {\n    if (cx == 0)\n        cy = 0;\n    else {\n        --cx;\n        cy = 0;\n    }\n}\n\nvoid n() {\n    if (cx + 1 == text.size())\n        cy = 0;\n    else {\n        ++cx;\n        cy = 0;\n    }\n}\n\nvoid f() {\n    if (cy != text[cx].size())\n        ++cy;\n    else if (cx + 1 != text.size()) {\n        ++cx;\n        cy = 0;\n    }\n}\n\nvoid b() {\n    if (cy != 0)\n        --cy;\n    else if (cx != 0) {\n        --cx;\n        cy = text[cx].size();\n    }\n}\n\nvoid d() {\n    if (cy != text[cx].size())\n        text[cx].erase(text[cx].begin() + cy);\n    else if (cx + 1 != text.size()) {\n        text[cx] += text[cx + 1];\n        text.erase(text.begin() + cx + 1);\n    }\n}\n\nvoid k() {\n    if (cy != text[cx].size()) {\n        buffer = text[cx].substr(cy);\n        text[cx].erase(cy);\n    } else if (cx + 1 != text.size()) {\n        d();\n        buffer = \"\\n\";\n    }\n}\n\nvoid y() {\n    if (buffer.empty())\n        return;\n    if (buffer == \"\\n\") {\n        text.insert(text.begin() + cx + 1, text[cx].substr(cy));\n        text[cx].erase(cy);\n        ++cx;\n        cy = 0;\n    } else {\n        text[cx].insert(cy, buffer);\n        cy += buffer.size();\n    }\n}\n\nvoid solve();\n\nint main() {\n    solve();\n    return 0;\n}\n\nvoid solve() {\n    while (true) {\n        string buf;\n        char c;\n        while ((c = getchar()) != EOF) {\n            if (c == '\\n')\n                break;\n            buf += c;\n        }\n        if (c == EOF)\n            while (1);\n        if (buf == \"END_OF_TEXT\")\n            break;\n        text.push_back(buf);\n    }\n    if (text.empty())\n        while (1);\n    cx = cy = 0;\n    buffer.clear();\n    while (true) {\n        string buf;\n        char c;\n        while ((c = getchar()) != EOF) {\n            if (c == '\\n')\n                break;\n            buf += c;\n        }\n        if (c == EOF)\n            while (1);\n        if (buf == \"-\")\n            break;\n        switch (buf[0]) {\n            case 'a':\n                a();\n                break;\n            case 'e':\n                e();\n                break;\n            case 'p':\n                p();\n                break;\n            case 'n':\n                n();\n                break;\n            case 'f':\n                f();\n                break;\n            case 'b':\n                b();\n                break;\n            case 'd':\n                d();\n                break;\n            case 'k':\n                k();\n                break;\n            case 'y':\n                y();\n                break;\n            default:\n                while (1);\n                break;\n        }\n    }\n    for (vector<string>::iterator i = text.begin(); i != text.end(); ++i)\n        puts(i->c_str());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  vector<string> data;\n  for(string buf;cin>>buf,buf!=\"END_OF_TEXT\";)\n    {\n      data.push_back(buf);\n    }\n  int x=0,y=0;\n  string buf=\"\";\n  bool buf_br=false;\n  for(char code;cin>>code,code!='-';)\n    {\n      if(code=='a')\n\ty=0;\n      else if(code=='e')\n\ty=data[x].size();\n      else if(code=='p')\n\t{\n\t  x=max(0,x-1);\n\t  y=0;\n\t}\n      else if(code=='n')\n\t{\n\t  x=min((int)data.size()-1,x+1);\n\t  y=0;\n\t}\n      else if(code=='f')\n\t{\n\t  if(y<data[x].size())\n\t    y++;\n\t  else if(y==data[x].size() &&x<data.size()-1)\n\t    {\n\t      x++;\n\t      y=0;\n\t    }\n\t}\n      else if(code=='b')\n\t{\n\t  if(y>0)\n\t    y--;\n\t  else if(y==0 &&x>0)\n\t    {\n\t      x--;\n\t      y=data[x].size();\n\t    }\n\t}\n      else if(code=='d')\n\t{\n\t  if(y<data[x].size())\n\t    data[x].erase(y,1);\n\t  else if(y==data[x].size() && x<data.size()-1)\n\t    {\n\t      data[x]+=data[x+1];\n\t      data.erase(data.begin()+x+1);\n\t    }\n\t}\n      else if(code=='k')\n\t{\n\t  if(y==data[x].size())\n\t    {\n\t      if(x<data.size()-1)\n\t\t{\n\t\t  data[x]+=data[x+1];\n\t\t  data.erase(data.begin()+x+1);\n\t\t  buf=\"\\n\";\n\t\t  buf_br=true;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      buf=data[x].substr(y,data[x].size()-y);\n\t      buf_br=false;\n\t      data[x].erase(y,data[x].size()-y);\n\t    }\t \n\t}\n      else if(code=='y')\n\t{\n\t  if(buf==\"\")\n\t    continue;\n\t  if(buf!=\"\" && buf_br)\n\t    {\n\t      string tmp=data[x].substr(y,data[x].size()-y);\n\t      data[x].erase(y,data[x].size()-y);\n\t      data.insert(data.begin()+x+1,tmp);\n\t      x++;\n\t      y=0;\n\t    }\n\t  else  if(buf!=\"\" && !buf_br)\n\t    {\n\t      data[x]=data[x].substr(0,y)+buf+data[x].substr(y,data[x].size()-y);\n\t      y+=buf.size();\n\t    }\n\t}    \n      /*  \n      cout<<\"x,y=\"<<x<<\",\"<<y<<endl;\n      for(int i=0;i<data.size();i++)\n\tcout<<data[i]<<endl;\n      */\n    }\n  \n  for(int i=0;i<data.size();i++)\n      cout<<data[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[111];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\tfor(int i=0 ; i<111 ; i++)\n\t\tt[i] = \"\";\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tif(i<110) t[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tif(row<110) col = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 && row < 110 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row < 110 && row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( row < 110 && col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else if( row < 110 ){\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( row < 110 && buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line+1 < 110 && line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\t//t[row+1] = t[row].substr( col );\n\t\t\t\t\tt[row].erase( col );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else if( row < 110 ){\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[128];\nstring buf;\nint lines;\nvoid delete_line(int y)\n{\n    for (int i = y; y < lines; ++y)\n\ts[i] = s[i + 1];\n    s[--lines] = \"\";\n    if (lines <= 0)\n\tlines = 1;\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; --i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    while (true)\n    {\n\tstring t;\n\tgetline(cin, t);\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines++] = t;\n    }\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    y = max(0, --y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    y = min(lines - 1, ++y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y + 1 != lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t    {\n\t\t--y;\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t\ts[y].erase(x, 1);\n\t    else\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t    }\n\t    break;\n\t}\n\tcase 'k':\n\t{\n\t    if (x == s[y].size())\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    else\n\t    {\n\t\tbuf = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\ts[y + 1] = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = 0, ++y;\n\t    }\n\t    else if (!buf.empty())\n\t\ts[y] += buf;\n\t    break;\n\t}\n\t}\n    }\n\n    for (int i = 0; i < lines; ++i)\n\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass state{\nprivate:\n  int cursor;\n  string str, buffer;\n\npublic:\n  state(string str = \"\"):str(str){\n    cursor = 0;\n    buffer = \"\";\n  }\n\n  void typeA(){\n    for(int i=cursor;i>=0;i--){\n      cursor = i;\n      if(i > 0 && str[i-1] == '\\n') break;\n    }\n  }\n\n  void typeE(){\n    for(int i=cursor;i<str.size();i++){\n      cursor = i;\n      if(str[i] == '\\n') break;\n    }\n  }\n\n  void typeP(){\n    bool isUpper = false;\n    for(int i=cursor;i>=0;i--){\n      if(i == 0 || i > 0 && str[i-1] == '\\n'){\n        cursor = i;\n        if(isUpper) break;\n        else isUpper = true;\n      }\n    }\n  }\n\n  void typeN(){\n    bool isDowner = false;\n    for(int i=cursor;i<str.size();i++){\n      if(str[i] == '\\n' && i < (int)str.size() - 1){\n        isDowner = true;\n        cursor = i + 1;\n        break;\n      }\n    }\n\n    if(!isDowner){\n      typeA();\n    }\n  }\n\n  void typeF(){\n    if(cursor < (int)str.size()-1){\n      cursor++;\n    }\n  }\n  \n  void typeB(){\n    if(cursor > 0) {\n      cursor--;\n    }\n  }\n\n  void typeD(){\n    if(cursor < (int)str.size()-1){\n      str.erase(str.begin()+cursor);\n    }\n  }\n\n  void typeK(){\n    if(str[cursor] == '\\n' && cursor < (int)str.size()-1){\n      typeD();\n      buffer = \"\\n\";\n    } else if(str[cursor] != '\\n'){\n      for(int i=cursor;i<(int)str.size();i++){\n        if(str[i] == '\\n'){\n          buffer = string(str.begin()+cursor, str.begin()+i);\n          str.erase(str.begin()+cursor, str.begin()+i);\n        }\n      }\n    }\n  }\n\n  void typeY(){\n    str.insert(str.begin()+cursor, buffer.begin(), buffer.end());\n    cursor += buffer.size() ;\n    //buffer = \"\";\n  }\n\n  string toString(){\n    return str;\n  }\n};\n\nstring inputStr(){\n  string str = \"\", in;\n  while(cin >> in){\n    if(in == \"END_OF_TEXT\") break;\n    str += in + '\\n';\n  }\n  return str;\n}\n\nvoid executeCommand(state &dat){\n  string command;\n  while(cin >> command){\n    if(command == \"-\") break;\n    else if(command == \"a\") dat.typeA();\n    else if(command == \"e\") dat.typeE();\n    else if(command == \"p\") dat.typeP();\n    else if(command == \"n\") dat.typeN();\n    else if(command == \"f\") dat.typeF();\n    else if(command == \"b\") dat.typeB();\n    else if(command == \"d\") dat.typeD();\n    else if(command == \"k\") dat.typeK();\n    else if(command == \"y\") dat.typeY();\n  }\n  cout << dat.toString() << flush;\n}\n\nint main(){\n  state dat = state(inputStr());\n  executeCommand(dat);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[128];\nstring buf;\nint lines;\nvoid delete_line(int y)\n{\n    if (lines > 1)\n\t--lines;\n    for (int i = y; y < lines; ++y)\n\ts[i] = s[i + 1];\n    s[lines] = \"\";\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; --i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    while (true)\n    {\n\tstring t;\n\tgetline(cin, t);\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines++] = t;\n    }\n    if (lines == 0)\n\tlines = 1;\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    y = max(0, --y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    y = min(lines - 1, ++y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y + 1 < lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t    {\n\t\t--y;\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t\ts[y].erase(x, 1);\n\t    else if (y + 1 < lines)\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t    }\n\t    break;\n\t}\n\tcase 'k':\n\t{\n\t    if (x != s[y].size())\n\t    {\n\t\tbuf = s[y].substr(x);\n\t\ts[y].erase(x);\n\t    }\n\t    else if (y + 1 < lines)\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\ts[y + 1] = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = 0, ++y;\n\t    }\n\t    else\n\t    {\n\t\ts[y].insert(x, buf);\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\t}\n    }\n\n    for (int i = 0; i < lines; ++i)\n\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 1021.cc: Emacs-like Editor\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\n/* typedef */\n\ntypedef vector<string> vs;\n\n/* global variables */\n\nvs txt;\nstring buf;\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    string s;\n    cin >> s;\n    if (s == \"END_OF_TEXT\") break;\n    txt.push_back(s);\n  }\n  if (txt.size() == 0) txt.push_back(\"\");\n\n  int cx = 0, cy = 0;\n  \n  for (;;) {\n    char op;\n    cin >> op;\n    if (op == '-') break;\n\n    switch (op) {\n    case 'a':\n      cx = 0;\n      break;\n    case 'e':\n      cx = txt[cy].size();\n      break;\n    case 'p':\n      cx = 0;\n      if (cy > 0) cy--;\n      break;\n    case 'n':\n      cx = 0;\n      if (cy < txt.size() - 1) cy++;\n      break;\n    case 'f':\n      if (cx < txt[cy].size()) cx++;\n      else if (cy < txt.size() - 1) cy++, cx = 0;\n      break;\n    case 'b':\n      if (cx > 0) cx--;\n      else if (cy > 0) cy--, cx = txt[cy].size();\n      break;\n    case 'd':\n      if (cx < txt[cy].size()) txt[cy].erase(cx, 1);\n      else if (cy < txt.size() - 1) {\n\ttxt[cy] += txt[cy + 1];\n\ttxt.erase(txt.begin() + cy + 1);\n      }\n      break;\n    case 'k':\n      if (cx == txt[cy].size()) {\n\tif (cy < txt.size() - 1) {\n\t  txt[cy] += txt[cy + 1];\n\t  txt.erase(txt.begin() + cy + 1);\n\t  buf = \"\\n\";\n\t}\n      }\n      else {\n\tbuf = txt[cy].substr(cx);\n\ttxt[cy].erase(cx);\n\tcx = txt[cy].size();\n      }\n      break;\n    case 'y':\n      int bn = buf.size();\n      if (bn > 0) {\n\tif (buf == \"\\n\") {\n\t  string line = txt[cy].substr(cx);\n\t  txt[cy].erase(cx);\n\t  cy++, cx = 0;\n\t}\n\telse {\n\t  txt[cy].insert(cx, buf);\n\t  cx += bn;\n\t}\n      }\n    }\n  }\n\n  for (int i = 0; i < txt.size(); i++) cout << txt[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[128];\nstring buf;\nint lines;\nvoid delete_line(int y)\n{\n    if (lines > 1)\n\t--lines;\n    for (int i = y; y < lines; ++y)\n\ts[i] = s[i + 1];\n    s[lines] = \"\";\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; --i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    while (true)\n    {\n\tstring t;\n\tgetline(cin, t);\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines++] = t;\n    }\n    if (lines == 0)\n\tlines = 1;\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    y = max(0, --y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    y = min(lines - 1, ++y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y + 1 < lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t    {\n\t\t--y;\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t\ts[y].erase(x, 1);\n\t    else if (y + 1 < lines)\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t    }\n\t    break;\n\t}\n\tcase 'k':\n\t{\n\t    if (x != s[y].size())\n\t    {\n\t\tbuf = s[y].substr(x);\n\t\ts[y].erase(x);\n\t    }\n\t    else if (y + 1 < lines)\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\ts[y + 1] = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = 0, ++y;\n\t    }\n\t    else\n\t    {\n\t\ts[y].insert(x, buf);\n\t\tx += buf.size();\n\t    }\n\t    break;\n\t}\n\t}\n    }\n\n    for (int i = 0; i < lines; ++i)\n\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<string>\n#include<list>\nusing namespace std;\ntypedef list<string>L;\ntypedef L::iterator I;\nint main()\n{\n\tchar str[256];\n\tL l;\n\twhile(fgets(str,256,stdin),strcmp(str,\"END_OF_TEXT\\n\"))\n\t{\n\t\tstr[strlen(str)-1]=0;\n\t\tl.push_back(str);\n\t}\n\tI row=l.begin(),t;\n\tstring::iterator col=row->begin();\n\tstring buf;\n\twhile(fgets(str,256,stdin),*str-'-')\n\t{\n\t\tswitch(*str)\n\t\t{\n\t\tcase'a':col=row->begin();break;\n\t\tcase'e':col=row->end();break;\n\t\tcase'p':\n\t\t\tif(row!=l.begin())--row;\n\t\t\tcol=row->begin();\n\t\t\tbreak;\n\t\tcase'n':if(t=l.end(), row!=--t)++row;\n\t\t\tcol=row->begin();\n\t\t\tbreak;\n\t\tcase'f':\n\t\t\tif(col!=row->end())++col;\n\t\t\telse if(t=l.end(),row!=--t)++row,col=row->begin();\n\t\t\tbreak;\n\t\tcase'b':\n\t\t\tif(col!=row->begin())--col;\n\t\t\telse if(row!=l.begin())--row,col=row->end();\n\t\t\tbreak;\n\t\tcase'd':\n\t\t\tif(col!=row->end())col=row->erase(col);\n\t\t\telse if(t=l.end(),row!=--t)\n\t\t\t{\n\t\t\t\tt=row;\n\t\t\t\tint s=row->size();\n\t\t\t\tif(++t!=l.end())\n\t\t\t\t{\n\t\t\t\t\t*row+=*t;\n\t\t\t\t\tl.erase(t);\n\t\t\t\t}\n\t\t\t\tcol=row->begin()+s;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase'k':\n\t\t\tif(col!=row->end())\n\t\t\t{\n\t\t\t\tbuf=row->substr(col-row->begin());\n\t\t\t\tcol=row->erase(col,row->end());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbuf=\"\\n\";\n\t\t\t\tt=row;\n\t\t\t\tint s=row->size();\n\t\t\t\tif(++t!=l.end())\n\t\t\t\t{\n\t\t\t\t\t*row+=*t;\n\t\t\t\t\tl.erase(t);\n\t\t\t\t}\n\t\t\t\tcol=row->begin()+s;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase'y':\n\t\t\tif(buf==\"\\n\")\n\t\t\t{\n\t\t\t\tt=row;\n\t\t\t\t++t;\n\t\t\t\tstring s(row->substr(col-row->begin()));\n\t\t\t\tl.insert(t,s);\n\t\t\t\trow->erase(col,row->end());\n\t\t\t\trow=--t;\n\t\t\t\tcol=row->begin();\n\t\t\t}\n\t\t\telse if(!buf.empty())\n\t\t\t{\n\t\t\t\tint s=col-row->begin()+buf.size();\n\t\t\t\trow->insert(col-row->begin(),buf);\n\t\t\t\tcol=row->begin()+s;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(t=l.begin();t!=l.end();++t)printf(\"%s\\n\",t->c_str());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[128];\nstring buf;\nint lines;\nvoid delete_line(int y)\n{\n    for (int i = y; y < lines; ++y)\n\ts[i] = s[i + 1];\n    s[lines = max(0, --lines)] = \"\";\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; --i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    while (true)\n    {\n\tstring t;\n\tgetline(cin, t);\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines++] = t;\n    }\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    y = max(0, --y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    y = max(0, min(lines - 1, ++y));\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y + 1 < lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t    {\n\t\t--y;\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t\ts[y].erase(x, 1);\n\t    else if (y + 1 < lines)\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t    }\n\t    break;\n\t}\n\tcase 'k':\n\t{\n\t    if (x != s[y].size())\n\t    {\n\t\tbuf = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = s[y].size();\n\t    }\n\t    else if (y + 1 < lines)\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\ts[y + 1] = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = 0, ++y;\n\t    }\n\t    else\n\t\ts[y] += buf;\n\t    break;\n\t}\n\t}\n    }\n\n    for (int i = 0; i < lines; ++i)\n\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nchar t[100][1000];\nint h;\nint w[100];\n\nchar tmp[100];\nint tmp_size;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nint main(){\n\n  input();\n  x=y=tmp_size=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n  }\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w[i];j++){\n      cout<<t[i][j];\n    }\n    cout<<endl;\n  }\n  \n  return 0;\n}\n\nvoid funcA(){x=0;}\nvoid funcE(){x=w[y];}\nvoid funcP(){ if(y>0)y--; x=0; }\nvoid funcN(){ if(y+1<h)y++; x=0; }\nvoid funcF(){ \n  if(x<w[y])x++;\n  else if(y+1<h){y++;x=0;}\n}\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=w[y];}\n}\nvoid funcD(){\n  if(x<w[y]){\n    w[y]--;\n    for(int i=x;i<w[y];i++)t[y][i]=t[y][i+1];\n    return;\n  }\n  if(y+1==h)return;\n  for(int i=0;i<w[y+1];i++)t[y][w[y]+i]=t[y+1][i];\n  w[y]+=w[y+1];\n  h--;\n  for(int i=y+1;i<h;i++){\n    w[i]=w[i+1];\n    for(int j=0;j<w[i];j++){\n      t[i][j]=t[i+1][j];\n    }\n  }\n}\n\nvoid funcK(){\n  if(x==w[y]){\n    if(y+1<h){\n      funcD();\n      tmp[0]='\\n';\n      tmp_size=1;\n    }\n  }else{\n    tmp_size=0;\n    for(int i=x;i<w[y];i++)\n      tmp[tmp_size++]=t[y][i];\n    w[y]=x;\n  }\n}\n\nvoid funcY(){\n  \n  if(tmp_size==0)return;\n  if(tmp[0]!='\\n'){\n    char z[100];\n    int zs=0;\n    for(int i=x;i<w[y];i++){\n      z[zs++]=t[y][i];\n    }\n    for(int i=x;i<x+tmp_size;i++){\n      t[y][i]=tmp[i-x];\n    }\n    w[y]+=tmp_size;\n    for(int i=x+tmp_size;i<w[y];i++){\n      t[y][i]=z[i-x-tmp_size];\n    }\n    x+=tmp_size;\n    return;\n  }\n  \n  h++;\n  for(int i=h-1;i>y+1;i--){\n    w[i]=w[i-1];\n    for(int j=0;j<w[i];j++)\n      t[i][j]=t[i-1][j];\n  }\n\n  w[y+1]=w[y]-x;\n  for(int i=0;i<w[y+1];i++){\n    t[y+1][i]=t[y][i+x];\n  }\n  w[y]=x;\n  /*\n  y++;\n  x=0;\n  */\n}\n\nvoid input(){\n  string str;\n  h=0;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    w[h]=str.size();\n    for(int i=0;i<(int)str.size();i++)\n      t[h][i]=str[i];\n    h++;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\n#define reps(i,b,n) for(int i = b ; i < n ; ++i )\n#define rep(i,n) reps(i,0,n)\n#define fr first\n#define sc second\nvoid doing(char cmd,vector<string>& t,string& buff,int& y,int& x){\n  switch(cmd){\n  case'a': x = 0; break;\n  case'e': x = t[y].size(); break;\n  case'p': if(y) y--; x=0; break;\n  case'n': if(y<t.size()-1) y++; x=0; break;\n  case'f': if(x<t[y].size()) x++; else if(y<t.size()-1) y++,x=0; break;\n  case'b': if(x)x--; else if(y) x = t[--y].size(); break;\n  case'd': if(x<t[y].size()) t[y].erase(t[y].begin()+x); else if(y<t.size()-1) t[y] += t[y+1] , t.erase(t.begin()+y+1); break;\n  case'k': if(x==t[y].size() && y<t.size()-1) t[y]+=t[y+1] , t.erase(t.begin()+y+1) , buff=\"\\n\"; else if(x!=t[y].size()) buff = t[y].substr(x) , t[y].erase(t[y].begin()+x,t[y].end()); break;\n  case'y': if(buff == \"\\n\") t.insert(t.begin()+y+1,t[y].substr(x)),t[y].erase(t[y].begin()+x,t[y].end()),y++,x=0; else if(buff != \"\")  t[y].insert(x,buff),x += buff.size(); break;\n  }\n}\nint main(){\n  vector<string> text;\n  string in;\n  while(getline(cin,in) , in != \"END_OF_TEXT\") text.push_back(in);\n\n  char cmd;\n  string buff=\"\";\n  int cury = 0, curx = 0;\n  while( cin >> cmd , cmd != '-') doing(cmd,text,buff,cury,curx);\n\n  rep(i,text.size()) cout << text[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <string>\n#include <cstdio>\n\nusing namespace std;\n\nint main()\n{\n\tstring str[300];\n\tstring b;\n\tb[0] = '*';\n\tint y = 0, y2;\n\tint len[300] = {0};\n\t\n\twhile (getline(std::cin, str[y]), str[y] != \"END_OF_TEXT\"){\n\t\tlen[y] = str[y].size();\n\t\ty++;\n\t}\n\t\n\tchar cmd[2];\n\tint car = 0, car_y = 0;\n\t\n\twhile (scanf(\"%s\", cmd), cmd[0] != '-'){\n\t\tif (cmd[0] == 'a'){\n\t\t\tcar = 0;\n\t\t}\n\t\tif (cmd[0] == 'e'){\n\t\t\tcar = len[car_y];\n\t\t}\n\t\tif (cmd[0] == 'p'){\n\t\t\tif (car_y == 0){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y--;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'n'){\n\t\t\tif (car_y != y){\n\t\t\t\tcar_y++;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\t\n\t\t\telse {\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'f'){\n\t\t\tif (car != len[car_y]){\n\t\t\t\tcar++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tcar_y++;\n\t\t\t\t\tcar = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'b'){\n\t\t\tif (car != 0){\n\t\t\t\tcar--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != 0){\n\t\t\t\t\tcar_y--;\n\t\t\t\t\tcar = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'd'){\n\t\t\tif (car != len[car_y]){\n\t\t\t\tstr[car_y].erase(car, 1);\n\t\t\t\tlen[car_y]--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\tlen[car_y] = str[car_y].size();\n\t\t\t\t\tlen[car_y + 1] = 0;\n\t\t\t\t\t\n\t\t\t\t\ty2 = y - 1;\n\t\t\t\t\ty = car_y;\n\t\t\t\t\twhile (++y < y2){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t\tlen[y] = len[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y].erase();\n\t\t\t\t\tlen[y] = 0;\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'k'){\n\t\t\tif (car == len[car_y]){\n\t\t\t\tif (car_y != y){\n\t\t\t\t\t\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\tlen[car_y] = str[car_y].size();\n\t\t\t\t\tlen[car_y + 1] = 0;\n\t\t\t\t\t\n\t\t\t\t\ty2 = y - 1;\n\t\t\t\t\ty = car_y;\n\t\t\t\t\twhile (++y < y2){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t\tlen[y] = len[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y].erase();\n\t\t\t\t\tlen[y] = 0;\n\t\t\t\t\ty = y2;\n\t\t\t\t\tb[0] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb = str[car_y].substr(car);\n\t\t\t\tstr[car_y].erase(car);\n\t\t\t\tlen[car_y] = str[car_y].size();\n\t\t\t\tcar = len[car_y];\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'y'){\n\t\t\tif(b[0] != '*'){\n\t\t\t\tif (b[0] == '\\0'){\n\t\t\t\t\twhile (y > car_y + 1){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t\tlen[y] = len[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y] = str[car_y].substr(car);\n\t\t\t\t\tstr[car_y].erase(car);\n\t\t\t\t\tlen[y]  = str[y].size();\n\t\t\t\t\tlen[car_y] = str[car_y].size();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstr[car_y].insert(car, b);\n\t\t\t\t\tcar += b.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int j = 0; j < y; j++){\n\t\tprintf(\"%s\\n\", str[j].c_str());\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\ntemplate <class T> void pv(T a, T b) {\n\tfor(typeof(a) it = a; it != b; ++it)\n\t\tcerr << *it << \" \";\n\tcerr << endl;\n}\n\n#define all(v) (v).begin(), (v).end()\n\nvector<string> text;\nvector<char> command;\n\nint cursol_row;\nint cursol_col;\n\nvoid com_a() {\n\tcursol_col = 0;\n}\n\nvoid com_e() {\n\tcursol_col = text.at(cursol_row).length() - 1;\n}\n\nvoid com_p() {\n\tif(cursol_row > 0) cursol_row--;\n\tcom_a();\n}\n\nvoid com_n() {\n\tif(cursol_row < (int)text.size() - 1) cursol_row++;\n\tcom_a();\n}\n\nvoid com_f() {\n\tif(text[cursol_row][cursol_col] != '^') cursol_col++;\n\telse if(text[cursol_row][cursol_col] == '^' && cursol_row < (int)text.size() - 1) {\n\t\tcom_f()\n\t}\n}\n\nvoid com_b() {\n\tif(cursol_col > 0) cursol_col--;\n\telse if(cursol_col == 0 && cursol_row > 0) {\n\t\tcursol_row--;\n\t\tcom_e();\n\t}\n}\n\nvoid show_cursol() {\n\tcerr << \"ROW: \" << cursol_row << \" COL: \" << cursol_col << endl;\n}\n\nvoid com_d() {\n\tif(text[cursol_row][cursol_col] != '^') {\n\t\tstring line = text[cursol_row];\n\t\tstring left = line.substr(0, cursol_col);\n\t\tstring right = line.substr(cursol_col + 1);\n\t\ttext[cursol_row] = left + right;\n\t} else if(text[cursol_row][cursol_col] == '^' && cursol_row < (int)text.size() - 1) {\n\t\tstring line = text[cursol_row];\n\t\tline = line.substr(0, line.length() - 1) + text[cursol_row + 1];\n\t\ttext[cursol_row] = line;\n\n\t\tvector<string>::iterator it = text.begin();\n\t\tadvance(it, cursol_row + 1);\n\t\ttext.erase(it);\n\t}\n}\n\nstring buffer;\n\nvoid com_k() {\n\tif(text[cursol_row][cursol_col] == '^' && cursol_row < (int)text.size() - 1) {\n\t\tcom_d(); buffer = \"^\";\n\t}\n\telse if(text[cursol_row][cursol_col] != '^') {\n\t\tstring line = text[cursol_row];\n\t\tbuffer = line.substr(cursol_col);\n\t\tbuffer = buffer.substr(0, buffer.length() - 1);\n\t\ttext[cursol_row] = line.substr(0, cursol_col) + \"^\";\n\t}\n}\n\nvoid com_y() {\n\tif(buffer == \"^\") {\n\t\tstring line = text[cursol_row];\n\t\tstring fs = line.substr(0, cursol_col) + \"^\";\n\t\tstring sc = line.substr(cursol_col);\n\t\ttext[cursol_row] = fs;\n\n\t\tvector<string>::iterator it = text.begin();\n\t\tadvance(it, cursol_row + 1);\n\t\ttext.insert(it, sc);\n\t\tcursol_row++;\n\t\tcursol_col = 0;\n\t}\n\telse if(buffer != \"\") {\n\t\tstring line = text[cursol_row];\n\t\tstring left = line.substr(0, cursol_col);\n\t\tstring right = line.substr(cursol_col);\n\t\ttext[cursol_row] = left + buffer + right;\n\t}\n}\n\nint main() {\n\tbuffer = \"\";\n\n\tcursol_row = 0;\n\tcursol_col = 0;\n\n#if 1\n\tfor(string line; getline(cin, line) && line != \"END_OF_TEXT\";) {\n\t\ttext.push_back(line + \"^\");\n\t}\n\tfor(char c; cin >> c && c != '-'; ) {\n\t\tcommand.push_back(c);\n\t}\n#else\n\tfor(string line; getline(cin, line) && line != \"-\";) {\n\t\ttext.push_back(line + \"^\");\n\t}\n\tfor(char c; cin >> c && c != '-'; ) {\n\t\tswitch(c) {\n\t\t\tcase 'a': com_a(); break;\n\t\t\tcase 'e': com_e(); break;\n\t\t\tcase 'p': com_p(); break;\n\t\t\tcase 'n': com_n(); break;\n\t\t\tcase 'f': com_f(); break;\n\t\t\tcase 'b': com_b(); break;\n\t\t\tcase 'd': com_d(); break;\n\t\t\tcase 'k': com_k(); break;\n\t\t\tcase 'y': com_y(); break;\n\t\t\tdefault: break;\n\t\t}\n\t\tpv(all(text));\n\t\tshow_cursol();\n\t}\n#endif\n\n\t\n#if 0\n\tpv(all(text));\n\tpv(all(command));\n#endif\n\n\n#if 1\n\tfor(int i = 0; i < (int)command.size(); i++) {\n\t\tchar c = command[i];\n\t\tswitch(c) {\n\t\t\tcase 'a': com_a(); break;\n\t\t\tcase 'e': com_e(); break;\n\t\t\tcase 'p': com_p(); break;\n\t\t\tcase 'n': com_n(); break;\n\t\t\tcase 'f': com_f(); break;\n\t\t\tcase 'b': com_b(); break;\n\t\t\tcase 'd': com_d(); break;\n\t\t\tcase 'k': com_k(); break;\n\t\t\tcase 'y': com_y(); break;\n\t\t\tdefault: break;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < (int)text.size(); i++) {\n\t\tcout << text[i].substr(0, text[i].length() - 1) << endl;\n\t\t// cout << text[i] << endl;\n\t}\n#endif\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<string> l;\nstring buffer;\nint X = 0 , Y = 0;\nvoid a(){ X = 0; }\nvoid e(){ X = l[Y].size()-1; }\nvoid p(){ Y = max<int>(0,Y-1) ; a(); }\nvoid n(){ Y = min<int>(l.size()-1,Y+1); a(); }\nvoid f(){ if(X != l[Y].size()-1){X++;}else{n();} }\nvoid b(){ if(X != 0){X--;}else{p(),e();} }\nvoid d(){\n\tif(l[Y][X] != '\\n'){\n\t\tl[Y] = l[Y].substr(0,X) + l[Y].substr(X+1);\n\t}else{\n\t\tl[Y] = Y==l.size()-1?l[Y]:l[Y].substr(0,l[Y].size()-1) + l[Y+1];\n\t\tvector<string> p;\n\t\tfor(int i = 0 ; i < l.size() ; i++){\n\t\t\tif(i != Y+1) p.push_back(l[i]);\n\t\t}\n\t\tl = p;\n\t}\n}\nvoid k(){\n\tif(l[Y][X] == '\\n'){\n\t\tbuffer = \"\\n\";\n\t\td();\n\t\t// X = l[Y][X].size()-1;\n\t}else{\n\t\tbuffer = l[Y].substr(X);\n\t\tbuffer = l[Y].substr(0,buffer.size()-1);\n\t\tl[Y] = l[Y].substr(0,X) + \"\\n\";\n\t}\n}\nvoid y(){\n\tif(buffer != \"\"){\n\t\tif(buffer == \"\\n\"){\n\t\t\tvector<string> p;\n\t\t\tcout << \"{{\" << l[Y].substr(X) << \"}\" << endl;\n\t\t\tfor(int i = 0 ; i < l.size() ; i++){\n\t\t\t\tp.push_back(l[i]);\n\t\t\t\tif(i==Y)p.push_back(l[i].substr(X));\n\t\t\t}\n\t\t\tp[Y] = p[Y].substr(0,X) + \"\\n\";\n\t\t\tl = p;\n\t\t\tn();\n\t\t}else{\n\t\t\tl[Y].insert(X,buffer);\n\t\t\tX += buffer.size();\n\t\t}\n\t}\n}\nint main(){\n\tstring s;\n\twhile(getline(cin,s),s != \"END_OF_TEXT\"){\n\t\tl.push_back(s+\"\\n\");\n\t}\n\twhile(l.size() == 0);\n\twhile(cin >> s , s != \"-\"){\n\t\tif(s==\"a\")a();\n\t\tif(s==\"e\")e();\n\t\tif(s==\"p\")p();\n\t\tif(s==\"n\")n();\n\t\tif(s==\"f\")f();\n\t\tif(s==\"b\")b();\n\t\tif(s==\"d\")d();\n\t\tif(s==\"k\")k();\n\t\tif(s==\"y\")y();\n\t}\n\tfor(int i = 0 ; i < l.size() ; i++)\n\t\tcout << l[i];\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nchar t[100][1000];\nint h;\nint w[100];\n\nchar tmp[100];\nint tmp_size;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nint main(){\n\n  input();\n  x=y=tmp_size=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n  }\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w[i];j++){\n      cout<<t[i][j];\n    }\n    cout<<endl;\n  }\n  \n  return 0;\n}\n\nvoid funcA(){x=0;}\nvoid funcE(){x=w[y];}\nvoid funcP(){ if(y>0)y--; x=0; }\nvoid funcN(){ if(y+1<h)y++; x=0; }\nvoid funcF(){ \n  if(x<w[y])x++;\n  else if(y+1<h){y++;x=0;}\n}\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=w[y];}\n}\nvoid funcD(){\n  if(x<w[y]){\n    w[y]--;\n    for(int i=x;i<w[y];i++)t[y][i]=t[y][i+1];\n    return;\n  }\n  if(y+1==h)return;\n  for(int i=0;i<w[y+1];i++)t[y][w[y]+i]=t[y+1][i];\n  w[y]+=w[y+1];\n  h--;\n  for(int i=y+1;i<h;i++){\n    w[i]=w[i+1];\n    for(int j=0;j<w[i];j++){\n      t[i][j]=t[i+1][j];\n    }\n  }\n}\n\nvoid funcK(){\n  if(x==w[y]){\n    if(y+1<h){\n      funcD();\n      tmp[0]='\\n';\n      tmp_size=1;\n    }\n  }else{\n    tmp_size=0;\n    for(int i=x;i<w[y];i++)\n      tmp[tmp_size++]=t[y][i];\n    w[y]=x;\n  }\n}\n\nvoid funcY(){\n  \n  if(tmp_size==0)return;\n  if(tmp[0]!='\\n'){\n    char z[100];\n    int zs=0;\n    for(int i=x;i<w[y];i++){\n      z[zs++]=t[y][i];\n    }\n    for(int i=x;i<x+tmp_size;i++){\n      t[y][i]=tmp[i-x];\n    }\n    w[y]+=tmp_size;\n    for(int i=x+tmp_size;i<w[y];i++){\n      t[y][i]=z[i-x-tmp_size];\n    }\n    return;\n  }\n  \n  h++;\n  for(int i=h-1;i>y+1;i--){\n    w[i]=w[i-1];\n    for(int j=0;j<w[i];j++)\n      t[i][j]=t[i-1][j];\n  }\n\n  w[y+1]=w[y]-x;\n  for(int i=0;i<w[y+1];i++){\n    t[y+1][i]=t[y][i+x];\n  }\n  w[y]=x;\n  y++;\n  x=0;\n  \n}\n\nvoid input(){\n  string str;\n  h=0;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    w[h]=str.size();\n    for(int i=0;i<(int)str.size();i++)\n      t[h][i]=str[i];\n    h++;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<string> text;\nstring buf;\n\nint row, col;\n\nvoid func_a(){\n\tcol = 0;\n}\n\nvoid func_e(){\n\tcol = text[row].size();\n}\n\nvoid func_p(){\n\tif (row > 0) row--;\n\tcol = 0;\n}\n\nvoid func_n(){\n\tif (row < text.size() - 1) row++;\n\tcol = 0;\n}\n\nvoid func_f(){\n\tif (col < text[row].size()) col++;\n\telse if (row < text.size() - 1){\n\t\tcol = 0;\n\t\trow++;\n\t}\n}\n\nvoid func_b(){\n\tif (col > 0) col--;\n\telse if (row > 0){\n\t\trow--;\n\t\tcol = text[row].size();\n\t}\n}\n\nvoid func_d(){\n\tif (col < text[row].size()) text[row].erase(col, 1);\n\telse if (row < text.size() - 1){\n\t\ttext[row] += text[row + 1];\n\t\ttext.erase(text.begin() + row + 1);\n\t}\n}\n\nvoid func_k(){\n\tif (col < text[row].size()){\n\t\tbuf = text[row].substr(col, text[row].size() - col);\n\t\ttext[row] = text[row].substr(0, col);\n\t}\n\telse if (row < text.size() - 1){\n\t\tfunc_d();\n\t\tbuf = \"\\n\";\n\t}\n}\n\nvoid func_y(){\n\tif (!buf.empty()){\n\t\tif (buf == \"\\n\"){\n\t\t\ttext.insert(text.begin() + row + 1, text[row].substr(col, text[row].size() - col));\n\t\t\ttext[row].erase(col, text[row].size() - 1);\n\t\t\trow++;\n\t\t\tcol = 0;\n\t\t}\n\t\telse {\n\t\t\ttext[row].insert(col, buf);\n\t\t\tcol += buf.size();\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstring in;\n\tchar cmd;\n\n\twhile (getline(cin, in), in != \"END_OF_TEXT\"){\n\t\ttext.push_back(in);\n\t}\n\t\n\tcol = row = 0;\n\tbuf.clear();\n\n\twhile (cin >> cmd, cmd != '-'){\n\t\tswitch (cmd){\n\t\t  case 'a': func_a(); break;\n\t\t  case 'e':\tfunc_e(); break;\n\t\t  case 'p':\tfunc_p(); break;\n\t\t  case 'n': func_n(); break;\n\t\t  case 'f': func_f(); break;\n\t\t  case 'b':\tfunc_b(); break;\n\t\t  case 'd':\tfunc_d(); break;\n\t\t  case 'k': func_k(); break;\n\t\t  case 'y': func_y(); break;\n\t\t}\n#if 0\n\t\tprintf(\"col:%d row:%d\\n\", col, row);\n\t\tputs(\"status:\");\n\t\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\t\tcout << *it << endl;\n\t\t}\n\t\tputs(\"buffer:\");\n\t\tcout << buf << endl;\n#endif\n\t}\n\n\t\n\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\tcout << *it << endl;\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\nusing namespace std;\n\ntypedef long long ll;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nint main(){\n  int size = 0;\n  string s[100];\n\n  while(1){\n    getline(cin,s[size]);\n    if(s[size] == \"END_OF_TEXT\") break;\n    s[size] += '\\n';\n    size++;\n  }\n\n  string buff = \"\";\n  int x = 0, y = 0;\n  char op;\n\n  while(cin>>op,op!='-'){\n    if(op == 'a'){\n      x = 0;\n    }\n    else if(op == 'e'){\n      x = s[y].size() - 1;\n    }\n    else if(op == 'p'){\n      x = 0;\n      if(y != 0){\n        y--;\n      }\n    }\n    else if(op == 'n'){\n      x = 0;\n      if(y != size - 1){\n        y++;\n      }\n    }\n    else if(op == 'f'){\n      if(x < s[y].size() - 1){\n        x++;\n      }\n      else if(y != size-1){\n        y++;\n        x = 0;\n      }\n    }\n    else if(op == 'b'){\n      if(x != 0){\n        x--;\n      }\n      else if(y != 0){\n        y--;\n        x = s[y].size() - 1;\n      }\n    }\n    else if(op == 'd'){\n      if(x != s[y].size() - 1){\n        s[y].erase(s[y].begin() + x);\n      }\n      else if(y != size - 1){\n        s[y].erase(s[y].end()-1);\n        s[y] += s[y+1];\n        for(int i=y+1;i<size-1;i++){\n          s[i] = s[i+1];\n        }\n        size--;\n      }\n    }\n    else if(op == 'k'){\n      if(x != s[y].size() - 1){\n        buff = s[y].substr(x,s[y].size()-x-1);\n        s[y].erase(x,buff.size());\n      }\n      else if(y != size - 1){\n        s[y].erase(s[y].end()-1);\n        s[y] += s[y+1];\n        for(int i=y+1;i<size-1;i++){\n          s[i] = s[i+1];\n        }\n        size--;\n        buff = \"\\n\";\n      }\n    }\n    else if(op == 'y'){\n      if(buff == \"\\n\"){\n        for(int i=size;i>y;i--){\n          s[i] = s[i-1];\n        }\n        size++;\n        string tmp = s[y].substr(x);\n        s[y+1] = tmp;\n        s[y].erase(x,s[y].size()-x-1);\n        y++;\n        x = 0;\n      }\n      else if(buff != \"\"){\n        s[y].insert(x,buff);\n        x += buff.size();\n      }\n    }\n\n    /*\n    cout<<x<<\",\"<<y<<endl;\n    rep(i,size){\n      cout<<s[i];\n    }\n    cout<<\"--\\n\\n\";\n    */\n  }\n\n  rep(i,size){\n    cout<<s[i];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\ntemplate <class T> void pv(T a, T b) {\n\tfor(typeof(a) it = a; it != b; ++it)\n\t\tcerr << *it << \" \";\n\tcerr << endl;\n}\n\n#define all(v) (v).begin(), (v).end()\n\nvector<string> text;\nvector<char> command;\n\nint cursol_row;\nint cursol_col;\n\nvoid com_a() {\n\tcursol_col = 0;\n}\n\nvoid com_e() {\n\tcursol_col = text.at(cursol_row).length() - 1;\n}\n\nvoid com_p() {\n\tif(cursol_row > 0) cursol_row--;\n\tcom_a();\n}\n\nvoid com_n() {\n\tif(cursol_row < (int)text.size() - 1) cursol_row++;\n\tcom_a();\n}\n\nvoid com_f() {\n\tif(text[cursol_row][cursol_col] != '^') cursol_col++;\n\telse if(text[cursol_row][cursol_col] == '^' && cursol_row < (int)text.size() - 1) {\n\t\tcom_f();\n\t}\n}\n\nvoid com_b() {\n\tif(cursol_col > 0) cursol_col--;\n\telse if(cursol_col == 0 && cursol_row > 0) {\n\t\tcursol_row--;\n\t\tcom_e();\n\t}\n}\n\nvoid show_cursol() {\n\tcerr << \"ROW: \" << cursol_row << \" COL: \" << cursol_col << endl;\n}\n\nvoid com_d() {\n\tif(text[cursol_row][cursol_col] != '^') {\n\t\tstring line = text[cursol_row];\n\t\tstring left = line.substr(0, cursol_col);\n\t\tstring right = line.substr(cursol_col + 1);\n\t\ttext[cursol_row] = left + right;\n\t} else if(text[cursol_row][cursol_col] == '^' && cursol_row < (int)text.size() - 1) {\n\t\tstring line = text[cursol_row];\n\t\tline = line.substr(0, line.length() - 1) + text[cursol_row + 1];\n\t\ttext[cursol_row] = line;\n\n\t\tvector<string>::iterator it = text.begin();\n\t\tadvance(it, cursol_row + 1);\n\t\ttext.erase(it);\n\t}\n}\n\nstring buffer;\n\nvoid com_k() {\n\tif(text[cursol_row][cursol_col] == '^' && cursol_row < (int)text.size() - 1) {\n\t\tcom_d(); buffer = \"^\";\n\t}\n\telse if(text[cursol_row][cursol_col] != '^') {\n\t\tstring line = text[cursol_row];\n\t\tbuffer = line.substr(cursol_col);\n\t\tbuffer = buffer.substr(0, buffer.length() - 1);\n\t\ttext[cursol_row] = line.substr(0, cursol_col) + \"^\";\n\t}\n}\n\nvoid com_y() {\n\tif(buffer == \"^\") {\n\t\tstring line = text[cursol_row];\n\t\tstring fs = line.substr(0, cursol_col) + \"^\";\n\t\tstring sc = line.substr(cursol_col);\n\t\ttext[cursol_row] = fs;\n\n\t\tvector<string>::iterator it = text.begin();\n\t\tadvance(it, cursol_row + 1);\n\t\ttext.insert(it, sc);\n\t\tcursol_row++;\n\t\tcursol_col = 0;\n\t}\n\telse if(buffer != \"\") {\n\t\tstring line = text[cursol_row];\n\t\tstring left = line.substr(0, cursol_col);\n\t\tstring right = line.substr(cursol_col);\n\t\ttext[cursol_row] = left + buffer + right;\n\t}\n}\n\nint main() {\n\tbuffer = \"\";\n\n\tcursol_row = 0;\n\tcursol_col = 0;\n\n#if 1\n\tfor(string line; getline(cin, line) && line != \"END_OF_TEXT\";) {\n\t\ttext.push_back(line + \"^\");\n\t}\n\tfor(char c; cin >> c && c != '-'; ) {\n\t\tcommand.push_back(c);\n\t}\n#else\n\tfor(string line; getline(cin, line) && line != \"-\";) {\n\t\ttext.push_back(line + \"^\");\n\t}\n\tfor(char c; cin >> c && c != '-'; ) {\n\t\tswitch(c) {\n\t\t\tcase 'a': com_a(); break;\n\t\t\tcase 'e': com_e(); break;\n\t\t\tcase 'p': com_p(); break;\n\t\t\tcase 'n': com_n(); break;\n\t\t\tcase 'f': com_f(); break;\n\t\t\tcase 'b': com_b(); break;\n\t\t\tcase 'd': com_d(); break;\n\t\t\tcase 'k': com_k(); break;\n\t\t\tcase 'y': com_y(); break;\n\t\t\tdefault: break;\n\t\t}\n\t\tpv(all(text));\n\t\tshow_cursol();\n\t}\n#endif\n\n\t\n#if 0\n\tpv(all(text));\n\tpv(all(command));\n#endif\n\n\n#if 1\n\tfor(int i = 0; i < (int)command.size(); i++) {\n\t\tchar c = command[i];\n\t\tswitch(c) {\n\t\t\tcase 'a': com_a(); break;\n\t\t\tcase 'e': com_e(); break;\n\t\t\tcase 'p': com_p(); break;\n\t\t\tcase 'n': com_n(); break;\n\t\t\tcase 'f': com_f(); break;\n\t\t\tcase 'b': com_b(); break;\n\t\t\tcase 'd': com_d(); break;\n\t\t\tcase 'k': com_k(); break;\n\t\t\tcase 'y': com_y(); break;\n\t\t\tdefault: break;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < (int)text.size(); i++) {\n\t\tcout << text[i].substr(0, text[i].length() - 1) << endl;\n\t\t// cout << text[i] << endl;\n\t}\n#endif\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(){\n    string s;\n    vector<string> v(101, \"\");\n    int len = 0;\n    while(getline(cin, s), s != \"END_OF_TEXT\"){\n        v[len++] = s;\n    }\n    string buf = \"\";\n    int i = 0, j = 0;\n    char com;\n    while(cin >> com, com != '-'){\n        if(com == 'a'){\n            j = 0;\n        }else if(com == 'e'){\n            j = v[i].size();\n        }else if(com == 'p'){\n            if(i){\n                i--;\n            }\n            j = 0;\n        }else if(com == 'n'){\n            if(i+1 < len){\n                i++;\n            }\n            j = 0;\n        }else if(com == 'f'){\n            if(j < v[i].size()){\n                j++;\n            }else if(i+1 < len){\n                i++;\n                j = 0;\n            }\n        }else if(com == 'b'){\n            if(j != 0){\n                j--;\n            }else if(i){\n                i--;\n                j = v[i].size();\n            }\n        }else if(com == 'd'){\n            if(j < v[i].size()){\n                v[i] = v[i].substr(0, j) + v[i].substr(j+1);\n            }else if(i+1 < len){\n                v[i] += v[i+1];\n                len--;\n                for(int k = i+1; k < len; k++)  v[k] = v[k+1];\n            }\n        }else if(com == 'k'){\n            if(j < v[i].size()){\n                buf = v[i].substr(j);\n                v[i] = v[i].substr(0, j);\n            }else if(i+1 < len){\n                buf = \"---\";\n                v[i] += v[i+1];\n                len--;\n                for(int k = i+1; k < len; k++)  v[k] = v[k+1];\n            }\n        }else if(com == 'y'){\n            if(buf == \"\"){\n                // do nothing.\n            }else if(buf == \"---\"){\n                string line = v[i].substr(j);\n                v[i] = v[i].substr(0, j);\n                len++;\n                for(int k = len-1; k > i; k--)    v[k] = v[k-1];\n                v[i+1] = line;\n                i++;\n                j = 0;\n            }else{\n                v[i] = v[i].substr(0, j) + buf + v[i].substr(j);\n                j += buf.size();\n            }\n        }\n    }\n    for(int i = 0; i < len; i++)    cout << v[i] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tint h=0;\n\tchar s[100][1001];\n\tfor(int i=0;;i++){\n\t\tfgets(s[i],1001,stdin);\n\t\ts[i][strlen(s[i])-1]='\\0';\n\t\tif(strcmp(s[i],\"END_OF_TEXT\")==0){ h=i; break; }\n\t}\n\n\tint cx=0,cy=0;\n\tchar buf[1001]=\"\";\n\twhile(1){\n\t\tchar cmd; scanf(\" %c\",&cmd);\n\t\tif(cmd=='-') break;\n\n\t\tif     (cmd=='a') cx=0;\n\t\telse if(cmd=='e') cx=strlen(s[cy]);\n\t\telse if(cmd=='p') cx=0, cy=max(cy-1,0);\n\t\telse if(cmd=='n') cx=0, cy=min(cy+1,h-1);\n\t\telse if(cmd=='f'){\n\t\t\tif(s[cy][cx]) cx++;\n\t\t\telse if(cy<h-1) cy++, cx=0;\n\t\t}\n\t\telse if(cmd=='b'){\n\t\t\tif(cx>0) cx--;\n\t\t\telse if(cy>0) cy--, cx=strlen(s[cy]);\n\t\t}\n\t\telse if(cmd=='d'){\n\t\t\tif(s[cy][cx]){\n\t\t\t\tfor(int j=cx+1;s[cy][j-1];j++) s[cy][j-1]=s[cy][j];\n\t\t\t}\n\t\t\telse if(cy<h-1){\n\t\t\t\tstrcpy(s[cy]+cx,s[cy+1]);\n\t\t\t\tfor(int i=cy+1;i<h-1;i++) strcpy(s[i],s[i+1]);\n\t\t\t\th--;\n\t\t\t}\n\t\t}\n\t\telse if(cmd=='k'){\n\t\t\tif(!s[cy][cx]){\n\t\t\t\tif(cy<h-1){\n\t\t\t\t\tstrcpy(s[cy]+cx,s[cy+1]);\n\t\t\t\t\tfor(int i=cy+1;i<h-1;i++) strcpy(s[i],s[i+1]);\n\t\t\t\t\th--;\n\t\t\t\t\tbuf[0]='\\n'; buf[1]='\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstrcpy(buf,s[cy]+cx);\n\t\t\t\ts[cy][cx]='\\0';\n\t\t\t}\n\t\t}\n\t\telse{ // cmd=='y'\n\t\t\tif(buf[0]){\n\t\t\t\tif(buf[0]=='\\n'){\n\t\t\t\t\tfor(int i=h-1;i>cy;i--) strcpy(s[i+1],s[i]);\n\t\t\t\t\tstrcpy(s[cy+1],s[cy]+cx);\n\t\t\t\t\ts[cy][cx]='\\0';\n\t\t\t\t\tcy++;\n\t\t\t\t\tcx=0;\n\t\t\t\t\th++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint m=strlen(buf);\n\t\t\t\t\tfor(int j=strlen(s[cy]);j>=cx;j--) s[cy][j+m]=s[cy][j];\n\t\t\t\t\trep(j,m) s[cy][j+cx]=buf[j];\n\t\t\t\t\tcx+=m;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i,h) puts(s[i]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n\nmain(){\n  vector<string> ed;\n  string str;\n  string end=\"END_OF_TEXT\";\n\n  while(getline(cin,str)){\n    if(end==str)break;\n    ed.pb(str);\n  }\n  \n  string buffer=\"\";\n  \n  char c;\n  int cx=0,cy=0;\n  while(cin>>c){\n    if(c=='-')break;\n    switch(c){\n    case 'a':\n      cx=0;\n      break;\n    case 'e':\n      cx=ed[cy].size();\n      break;\n    case 'p':\n      cx=0;\n      if(cy)--cy;\n      break;\n    case 'n':\n      cx=0;\n      ++cy;\n      if(cy>=ed.size())--cy;\n      break;\n    case 'f':\n      if(cx<ed[cy].size())++cx;\n      else if(cx==ed[cy].size() && cy<ed.size()-1)++cy,cx=0;\n      break;\n    case 'b':\n      if(cx)--cx;\n      else if(cx==0 && cy)--cy,cx=ed[cy].size();\n      break;\n    case 'd':\n      if(cx<ed[cy].size())ed[cy].erase(cx,1);\n      else if(cx==ed[cy].size() && cy<ed.size()){\n        ed[cy]+=ed[cy+1];\n        for(int i=cy+1;i<ed.size()-1;i++)ed[i]=ed[i+1];\n        vector<string>::iterator iter=ed.end();\n        --iter;\n        ed.erase(iter);\n      }\n      break;\n    case 'k':\n      if(cx==ed[cy].size() && cy<ed.size()){\n        ed[cy]+=ed[cy+1];\n        for(int i=cy+1;i<ed.size()-1;i++)ed[i]=ed[i+1];\n        vector<string>::iterator iter=ed.end();\n        --iter;\n        ed.erase(iter);\n        buffer=\"\\n\";\n      }else if(cx<ed[cy].size()){\n        buffer=ed[cy].substr(cx,ed[cy].size()-cx);\n        ed[cy]=ed[cy].substr(0,cx);\n      }\n      cx=ed[cy].size();\n      break;\n    case 'y':\n      if(buffer==\"\")continue;\n      else if(buffer==\"\\n\"){\n        string down=ed[cy].substr(cx,ed[cy].size()-cx);\n        ed[cy]=ed[cy].substr(0,cx);\n        ed[cy]+=\"\\n\";\n        ed.resize(ed.size()+1);\n        for(int k=ed.size()-1;k>cy;k--){\n          ed[k]=ed[k-1];\n        }\n        ed[cy+1]=down;\n      }else{\n        ed[cy].insert(cx,buffer);\n        cx=ed[cy].size();\n      }\n    }\n  }\n  rep(i,ed.size())cout<<ed[i]<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <string>\n#include <algorithm>\n\n#define DEBUG 0\n#define fprintf(...) (void)0\n\nint main() {\n  std::list<std::string> input;\n  while (true) {\n    char buf[24];\n    fgets(buf, sizeof buf, stdin);\n    std::string line=buf;\n    if (line == \"END_OF_TEXT\\n\")\n      break;\n\n    assert(line.back() == '\\n');\n    input.emplace_back(line);\n  }\n\n  std::string kbuf=\"\";\n  std::list<std::string>::iterator it=input.begin();\n  size_t cc=0;\n  while (true) {\n    char op;\n    scanf(\" %c\", &op);\n    if (op == '-')\n      break;\n\n    switch (op) {\n    case 'a':\n      cc = 0;\n      break;\n\n    case 'e':\n      cc = it->size()-1;\n      break;\n\n    case 'p':\n      cc = 0;\n      if (it != input.begin())\n        --it;\n      break;\n\n    case 'n':\n      cc = 0;\n      {\n        auto tmp=it;\n        ++tmp;\n        if (tmp != input.end())\n          it = tmp;\n      }\n      break;\n\n    case 'f':\n      if (cc+1 < it->size()) {\n        ++cc;\n      } else {\n        auto tmp=it;\n        ++tmp;\n        if (tmp != input.end()) {\n          cc = 0;\n          it = tmp;\n        }\n      }\n      break;\n\n    case 'b':\n      if (cc > 0) {\n        --cc;\n      } else if (it != input.begin()) {\n        --it;\n        cc = it->size()-1;\n      }\n      break;\n\n    case 'd':\n      if (cc == it->size()) {\n        assert((*it)[cc] == '\\n');\n        {\n          auto tmp=it;\n          ++tmp;\n          if (tmp != input.end()) {\n            it->pop_back();\n            *it += *tmp;\n            input.erase(tmp);\n          }\n        }\n      } else {\n        // TLE?\n        std::string t=it->substr(0, cc);\n        t += it->substr(cc+1);\n        *it = t;\n      }\n      break;\n\n    case 'k':\n      if (cc+1 == it->size()) {\n        assert((*it)[cc] == '\\n');\n        {\n          auto tmp=it;\n          ++tmp;\n          if (tmp != input.end()) {\n            assert(it->back() == '\\n');\n            it->pop_back();\n            *it += *tmp;\n            input.erase(tmp);\n          }\n        }\n        kbuf = \"\\n\";\n      } else {\n        kbuf = it->substr(cc);\n        assert(kbuf.back() == '\\n');\n        kbuf.pop_back();  // '\\n'\n        fprintf(stderr, \"kill buffer: %s\\n\", kbuf.c_str());\n        if (cc > 0) {\n          *it = it->substr(0, cc);\n          *it += '\\n';\n        } else {\n          *it = \"\\n\";\n        }\n        //cc = it->size()-1;\n      }\n      break;\n\n    case 'y':\n      if (kbuf.empty()) break;\n\n      if (kbuf == \"\\n\") {\n        ++it;\n        input.emplace(it, \"\\n\");\n        --it;  // ??\n        cc = 0;\n      } else {\n        {\n          std::string t=\"\";\n          if (cc > 0) {\n            t += it->substr(0, cc);\n          }\n          t += kbuf;\n          //t.pop_back();\n          t += it->substr(cc);\n          *it = t;\n        }\n      }\n      break;\n    }\n\n    if (DEBUG) {\n      fprintf(stderr, \"%c: L%td C%zu\\n\", op, std::distance(input.begin(), it), cc);\n      for (const auto &s: input)\n        printf(\"%s\", s.c_str());  // s ~ \".*\\n\"\n    }\n  }\n\n  for (const auto &s: input)\n    printf(\"%s\", s.c_str());  // s ~ \".*\\n\"\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n\n\n\nint main(){\t\n\tvector<string> text;\n\tstring line;\n\tstring buf;\n\twhile(getline(cin,line)&&line!=\"END_OF_TEXT\"){\n\t\ttext.push_back(line);\n\t}\n\tchar com;\n\tint row=0,col=0;\n\twhile(cin>>com&&com!='-'){\n\t\tswitch(com){\n\t\tcase 'a':\n\t\t\tcol=0;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tcol=text[row].size();\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif(row)row--;\n\t\t\tcol=0;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tif(row+1<text.size())row++;\n\t\t\tcol=0;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tif(col<text[row].size())col++;\n\t\t\telse if(row+1<text.size())row++,col=0;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif(col)col--;\n\t\t\telse if(row){\n\t\t\t\trow--;\n\t\t\t\tcol=text[row].size();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif(col<text[row].size())text[row].erase(col,1);\n\t\t\telse if(row+1<text.size()){\n\t\t\t\ttext[row]+=text[row+1];\n\t\t\t\ttext.erase(text.begin()+row+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tif(col==text[row].size()){\n\t\t\t\tif(row+1<text.size())text[row].erase(col,1);\n\t\t\t\tbuf=\"\\n\";\n\t\t\t}else{\n\t\t\t\tbuf=text[row].substr(col);\n\t\t\t\ttext[row].erase(col);\n\t\t\t\tcol=text[row].size();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tif(buf==\"\\n\"){\n\t\t\t\ttext.insert(text.begin()+row+1,text[row].substr(col));\n\t\t\t\ttext[row].erase(col);\n\t\t\t\trow++;\n\t\t\t\tcol=0;\n\t\t\t}else if(!buf.empty()){\n\t\t\t\ttext[row].insert(col,buf);\n\t\t\t\tcol+=buf.size();\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<text.size();i++)cout<<text[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1021\n#include<iostream>\n#include<vector>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\nconst int LMAX = 1000;\n\nvector<string> lines;\nint h, w;\nstring buffer;\n\nbool on_tail() { return w == lines[h].size(); }\nvoid goto_tail() { w = lines[h].size(); }\nbool on_eof() { return h >= lines.size() - 1; }\nvoid remove_line(int n) { lines.erase(lines.begin() + n); }\nvoid remove_char(int h, int w) {\n  lines[h].erase(lines[h].begin() + w);\n}\n\nvoid a() { w = 0; }\nvoid e() { goto_tail(); }\nvoid p() { h = max(h - 1, 0); w = 0; }\nvoid n() { h = min(h + 1, (int)lines.size() - 1); w = 0; }\nvoid f() {\n  if (not on_tail()) { w++; }\n  else if (not on_eof()) {\n    h++; w = 0;\n  }\n}\nvoid b() {\n  if (w > 0) { w--; }\n  else if (h > 0) { h--; goto_tail(); }\n}\nvoid d() {\n  if (on_tail() and !on_eof()) {\n    lines[h] += lines[h + 1];\n    remove_line(h + 1);\n  } else if (not on_tail()) {\n    remove_char(h, w);\n  }\n}\nvoid k() {\n  if (on_tail() and !on_eof()) {\n    d();\n    buffer = \"\\n\";\n  } else if (not on_tail()) {\n    buffer = lines[h].substr(w);\n    lines[h] = lines[h].substr(0, w);\n  }\n}\nvoid y() {\n  if (buffer == \"\\n\") {\n    string temp = lines[h].substr(w);\n    lines[h] = lines[h].substr(0, w);\n    lines.insert(lines.begin() + h + 1, temp);\n    h++; w = 0;\n  } else if (not buffer.empty()) {\n    lines[h].insert(lines[h].begin()+w, buffer.begin(), buffer.end());\n    w += buffer.size();\n  }\n}\n\nint main() {\n  string l;\n  buffer = \"\";\n  while (getline(cin, l) and l != \"END_OF_TEXT\") {\n    lines.push_back(l);\n  }\n\n  char com;\n  while (cin >> com and com != '-') {\n    switch (com) {\n    case 'a':\n      a(); break;\n    case 'e':\n      e(); break;\n    case 'p':\n      p(); break;\n    case 'n':\n      n(); break;\n    case 'f':\n      f(); break;\n    case 'b':\n      b(); break;\n    case 'd':\n      d(); break;\n    case 'k':\n      k(); break;\n    case 'y':\n      y(); break;\n    default:\n      break;\n    }\n/*    REP(i, lines.size()) {\n      cout << \">\" << lines[i] << endl;\n    }\n    cout << \"(\" << h << \",\" << w << \")\" << endl;\n*/  }\n\n  for (int i = 0; i < lines.size(); i++) {\n    cout << lines[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cctype>\n#include<cstring>\nusing namespace std;\nclass EmacsLikeEditor{\n public:\n  vector<string> text;\n  int cur;\n  int line;\n  string buf;\n  EmacsLikeEditor(const vector<string> &vs){\n    cur = 0;\n    line = 0;\n    for(int i = 0; i < vs.size(); ++i){\n      text.push_back( \"\" );\n      for(int j = 0; j < vs[i].length(); ++j){\n\tif( !iscntrl( vs[i][j] ) ){\n\t  text[i] += vs[i][j];\n\t}\n      }\n      text[i] += \"$\";\n    }\n  }\n  void Command(char c){\n    switch( c ){\n    case 'a': MoveLineFront(); break;\n    case 'e': MoveLineEnd(); break;\n    case 'p': MoveAbove(); break;\n    case 'n': MoveBelow(); break;\n    case 'f': MoveFront(); break;\n    case 'b': MoveBack(); break;\n    case 'd': Delete(); break;\n    case 'k': CutLine(); break;\n    case 'y': Paste(); break;\n    default:\n      break;\n    }\n  }\n  bool ExistAboveLine(){ return line > 0; }\n  bool ExistBelowLine(){ return line < text.size() - 1; }\n  bool FrontOfLine(){ return cur == 0; }\n  bool EndOfLine(){ return cur == text[line].size() - 1; }\n\n  void MoveLineFront(){ cur = 0; }\n  void MoveLineEnd(){ cur = text[line].size() - 1; }\n\n  void MoveAbove(){ if( ExistAboveLine() ){ --line; } MoveLineFront(); }\n  void MoveBelow(){ if( ExistBelowLine() ){ ++line; } MoveLineFront(); }\n\n  void MoveFront(){ if( !EndOfLine() ){ ++cur; }else{ if( ExistBelowLine() ){ ++line; cur = 0; } } }\n  void MoveBack(){ if( !FrontOfLine() ){ --cur; }else{ if( ExistAboveLine() ){ --line; cur = text[line].size()-1; } } }\n\n  void Delete(){\n    if( !EndOfLine() ){ text[line].erase( text[line].begin() + cur );\n    }else if( ExistBelowLine() ){\n      text[line].erase( text[line].end() - 1 );\n      for(int i = 0; i < text[line+1].length(); ++i){\n\ttext[line]+=text[line+1][i];\n      }\n    }\n  }\n  void CutLine(){\n    if( EndOfLine() ){\n      if( ExistBelowLine() ){ buf=\"$\"; Delete(); }\n    }else{\n      buf = \"\";\n      for(int i = cur; i < text[line].size() - 1; ++i){\n\tbuf += text[line][i];\n      }\n      text[line].erase( text[line].begin() + cur, text[line].end() - 1 );\n      cur = text[line].size() - 1;\n    }\n  }\n  void Paste(){\n    if( buf == \"\" ) return ;\n    else{\n      if( buf == \"$\" ){\n\ttext.insert( text.begin() + line + 1, string(text[line].begin() + cur, text[line].end()) );\n\ttext[line].erase( text[line].begin() + cur, text[line].end() );\n\ttext[line] += '$';\n\t++line;\n\tcur = 0;\n      }else{\n\ttext[line].insert( text[line].begin() + cur, buf.begin(), buf.end() );\n\tcur += buf.length();\n      }\n    }\n  }\n  \n};\nint main()\n{\n\n  vector<string> vs;\n  while(true){\n    string s;\n    getline(cin,s);\n    while(iscntrl(s[s.length()-1]))s.erase(s.end()-1);\n    if( s == \"END_OF_TEXT\" ) break;\n    vs.push_back( s );\n  }\n  EmacsLikeEditor ele(vs);\n  while(true){\n    char command;\n    cin >> command;\n    if( command == '-' ) break;\n    ele.Command( command );\n  }\n\n  for(int i = 0; i < ele.text.size(); ++i){\n    ele.text[i].erase( ele.text[i].end() - 1 );\n    cout << ele.text[i] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n  int p, q;\n  string str, buf;\n  vector<string> vec;\n\n  while(!cin.eof()){\n    p = q = 0;\n    buf = \"\";\n\n    while(getline(cin, str) && str != \"END_OF_TEXT\") vec.push_back(str);\n    while(getline(cin, str) && str != \"-\"){\n      if(str == \"a\") q = 0;\n\n      if(str == \"e\") q = vec[p].size();\n\n      if(str == \"p\"){\n\tif(p > 0) --p;\n\tq = 0;\n      }\n\n      if(str == \"n\"){\n\tif(p < vec.size()-1) ++p;\n\tq = 0;\n      }\n\n      if(str == \"f\"){\n\tif(q < vec[p].size()) ++q;\n\telse if(q == vec[p].size() && p < vec.size()-1){\n\t  ++p;\n\t  q = 0;\n\t}\n      }\n\n      if(str == \"b\"){\n\tif(q > 0) --q;\n\telse if(q == 0 && p > 0){\n\t  --p;\n\t  q = vec[p].size();\n\t}\n      }\n\n      if(str == \"d\"){\n\tif(q == vec[p].size()){\n\t  if(vec.size()-1 > p){\n\t    vec[p] += vec[p+1];\n\t    vec.erase(vec.begin()+(p+1));\n\t  }\n\t} else if(q < vec[p].size()){\n\t  vec[p].erase(vec[p].begin()+q);\n\t}\n      }\n\n      if(str == \"k\"){\n\tif(q == vec[p].size()){\n\t  if(vec.size()-1 > p){\n\t    vec[p] += vec[p+1];\n\t    vec.erase(vec.begin()+(p+1));\n\t    buf = \"\\n\";\n\t  }\n\t} else if(q < vec[p].size()){\n\t  buf = vec[p].substr(q);\n\t  vec[p] = vec[p].substr(0, q);\n\t}\n      }\n\n      if(str == \"y\" && buf.size()){\n\tif(buf == \"\\n\"){\n\t  string s1 = vec[p].substr(0, q), s2 = vec[p].substr(q);\n\t  vec[p++] = s1;\n\t  vec.insert(vec.begin()+(p), s2);\n\t  q = 0;\n\t} else {\n\t  vec[p].insert(q, buf);\n\t  q += buf.size();\n\t}\n      }\n    }\n\n    for(int i = 0; i < vec.size(); ++i)\n      cout << vec[i] << endl;\n    \n    buf.clear();\n    vec.clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//42\n#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\n#define ISEOB(X) !strcmp(X,\"END_OF_TEXT\")\n\nint main(){\n  char g[101][1002]={{}};\n  char buf[sizeof(g[0])]={};\n  for(int i=0;cin.getline(g[i],sizeof(g[0])),!ISEOB(g[i]);i++);\n  int x=0,y=0;\n  for(char c;cin>>c,c!='-';){\n    switch(c){\n    case 'a':\n      x=0;\n      break;\n    case 'e':\n      x=strlen(g[y]);\n      break;\n    case 'p':\n      if(y){\n\ty--;\n      }\n      x=0;\n      break;\n    case 'n':\n      if(!ISEOB(g[y+1])){\n\ty++;\n      }\n      x=0;\n      break;\n    case 'f':\n      if(g[y][x]!='\\0'){\n\tx++;\n      }else if(!ISEOB(g[y+1])){\n\tx=0;\n\ty++;\n      }\n      break;\n    case 'b':\n      if(x){\n\tx--;\n      }else if(y){\n\ty--;\n\tx=strlen(g[y]);\n      }\n      break;\n    case 'd':\n      if(g[y][x]!='\\0'){\n\tmemmove(g[y]+x,g[y]+x+1,strlen(g[y]+x));\n      }else if(!ISEOB(g[y+1])){\n\tstrcpy(g[y]+x,g[y+1]);\n\tmemmove(g[y+1],g[y+2],(101-y-2)*sizeof(g[0]));\n      }\n      break;\n    case 'k':\n      if(g[y][x]=='\\0'){\n\tif(!ISEOB(g[y+1])){\n\t  strcpy(g[y]+x,g[y+1]);\n\t  memmove(g[y+1],g[y+2],(101-y-2)*sizeof(g[0]));\n\t  buf[0]='\\n';\n\t}\n      }else{\n\tstrcpy(buf,g[y]+x);\n\tg[y][x]='\\0';\n      }\n      break;\n    case 'y':\n      if(buf[0]=='\\0'){\n      }else if(buf[0]=='\\n'){\n\tmemmove(g[y+2],g[y+1],(101-y-2)*sizeof(g[0]));\n\tstrcpy(g[y+1],g[y]+x);\n\tg[y][x]='\\0';\n\ty++;\n\tx=0;\n      }else{\n\tchar tmp[sizeof(g[0])];\n\tstrcpy(tmp,g[y]+x);\n\tstrcpy(g[y]+x,buf);\n\tstrcat(g[y],tmp);\n\tx+=strlen(buf);\n      }\n      break;\n    }\n  }\n  for(int i=0;!ISEOB(g[i]);i++){\n    cout<<g[i]<<endl;\n  }\n  return 0;\n}\n      \n\t\n\t\n    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cctype>\n#include<cstring>\nusing namespace std;\nclass EmacsLikeEditor{\n public:\n  vector<string> text;\n  int cur;\n  int line;\n  string buf;\n  EmacsLikeEditor(const vector<string> &vs){\n    cur = 0;\n    line = 0;\n    buf = \"\";\n    for(int i = 0; i < vs.size(); ++i){\n      text.push_back( \"\" );\n      for(int j = 0; j < vs[i].length(); ++j){\n\t//if( !iscntrl( vs[i][j] ) ){\n\t  text[i] += vs[i][j];\n\t  //}\n      }\n      text[i] += \"$\";\n    }\n  }\n  void Command(char c){\n    switch( c ){\n    case 'a': MoveLineFront(); break;\n    case 'e': MoveLineEnd(); break;\n    case 'p': MoveAbove(); break;\n    case 'n': MoveBelow(); break;\n    case 'f': MoveFront(); break;\n    case 'b': MoveBack(); break;\n    case 'd': Delete(); break;\n    case 'k': CutLine(); break;\n    case 'y': Paste(); break;\n    default:\n      break;\n    }\n  }\n  bool ExistAboveLine(){ return line > 0; }\n  bool ExistBelowLine(){ return line < text.size() - 1; }\n  bool FrontOfLine(){ return cur == 0; }\n  bool EndOfLine(){ return cur == text[line].size() - 1; }\n\n  void MoveLineFront(){ cur = 0; }\n  void MoveLineEnd(){ cur = text[line].size() - 1; }\n\n  void MoveAbove(){ if( ExistAboveLine() ){ --line; } MoveLineFront(); }\n  void MoveBelow(){ if( ExistBelowLine() ){ ++line; } MoveLineFront(); }\n\n  void MoveFront(){ if( !EndOfLine() ){ ++cur; }else{ if( ExistBelowLine() ){ ++line; cur = 0; } } }\n  void MoveBack(){ if( !FrontOfLine() ){ --cur; }else{ if( ExistAboveLine() ){ --line; cur = text[line].size()-1; } } }\n\n  void Delete(){\n    if( !EndOfLine() ){ text[line].erase( text[line].begin() + cur );\n    }else if( ExistBelowLine() ){\n      text[line].erase( text[line].end() - 1 );\n      for(int i = 0; i < text[line+1].length(); ++i){\n\ttext[line]+=text[line+1][i];\n      }\n      text.erase( text.begin() + line + 1 );\n    }\n  }\n  void CutLine(){\n    if( EndOfLine() ){\n      if( ExistBelowLine() ){ buf=\"$\"; Delete(); }\n    }else{\n      buf = string( text[line].begin() + cur, text[line].end() - 1 );\n      text[line].erase( text[line].begin() + cur, text[line].end() - 1 );\n      cur = text[line].size() - 1;\n    }\n  }\n  void Paste(){\n    if( buf == \"\" ) return ;\n    else{\n      if( buf == \"$\" ){\n\ttext.insert( text.begin() + line + 1, string(text[line].begin() + cur, text[line].end()) );\n\ttext[line].erase( text[line].begin() + cur, text[line].end() - 1);\n\t++line;\n\tcur = 0;\n      }else{\n\ttext[line].insert( text[line].begin() + cur, buf.begin(), buf.end() );\n\tcur += buf.length();\n      }\n    }\n  }\n  \n};\nint main()\n{\n\n  vector<string> vs;\n  while(true){\n    string s;\n    getline(cin,s);\n    //while(iscntrl(s[s.length()-1]))s.erase(s.end()-1);\n    if( s == \"END_OF_TEXT\" ) break;\n    vs.push_back( s );\n  }\n  EmacsLikeEditor ele(vs);\n  while(true){\n    char command;\n    cin >> command;\n    if( command == '-' ) break;\n    ele.Command( command );\n  }\n\n  for(int i = 0; i < ele.text.size(); ++i){\n    ele.text[i].erase( ele.text[i].end() - 1 );\n    cout << ele.text[i] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <string> VS;\nistream& myis = cin;\nostream& myos = cout;\n\nconst string END_OF_TEXT = \"END_OF_TEXT\";\nconst string END_OF_COMMAND = \"-\";\n\n// prototypes\nVS solve( const VS& lines );\nvoid output( const VS& lines );\nvoid split( const VS& lines, VS& T, VS& C );\n\n// editor\nclass Editor {\npublic:\n    // members\n    VS T;\n    int r;\n    int c;\n    string buffer;\n    // methods\n    Editor( VS T ): T(T) {\n        r = 0;\n        c = 0;\n        buffer.clear();\n    }\n    VS get_text() { return T; }\n    void parse_command( string com ) {\n        if ( com == \"a\" ) command_a();\n        if ( com == \"e\" ) command_e();\n        if ( com == \"p\" ) command_p();\n        if ( com == \"n\" ) command_n();\n        if ( com == \"f\" ) command_f();\n        if ( com == \"b\" ) command_b();\n        if ( com == \"d\" ) command_d();\n        if ( com == \"k\" ) command_k();\n        if ( com == \"y\" ) command_y();\n        // debug\n        /*\n        myos << \"::: debug start :::\" << endl;\n        myos << \"r: \" << r << endl;\n        myos << \"c: \" << c << endl;\n        myos << \"b: \" << buffer << endl;\n        myos << \"::: debug end   :::\" << endl;\n        */\n    }\nprivate:\n    bool is_cursor_leftmost() {\n        return c == 0;\n    }\n    bool is_cursor_rightmost() {\n        return c == (int)T[r].size();\n    }\n    bool exist_next_upperline() {\n        return r - 1 >= 0;\n    }\n    bool exist_next_lowerline() {\n        return r + 1 < (int)T.size();\n    }\n    void delete_line( int n ) {\n        T.erase( T.begin() + n );\n    }\n    void delete_letter( int n ) {\n        T[r].erase( T[r].begin() + n );\n    }\n    void move_cursor_leftmost() {\n        c = 0;\n    }\n    void move_cursor_rightmost() {\n        c = T[r].size();\n    }\n    void move_cursor_up() {\n        r -= 1;\n    }\n    void move_cursor_down() {\n        r += 1;\n    }\n    void move_cursor_left() {\n        c -= 1;\n    }\n    void move_cursor_right() {\n        c += 1;\n    }\n    void command_a() {\n        /*\n          J[\\ð»ÝÌsÌæª¶ÉÚ®·éB\n        */\n        move_cursor_leftmost();\n    }\n    void command_e() {\n        /*\n          J[\\ð»ÝÌsÌsÉÚ®·éB\n        */\n        move_cursor_rightmost();\n    }\n    void command_p() {\n        /*\n          ãÉsª êÎAJ[\\ðãÌsÌæª¶ÉÚ®·éB\n          ãÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n        */\n        if ( exist_next_upperline() ) {\n            move_cursor_up();\n            move_cursor_leftmost();\n        } else {\n            move_cursor_leftmost();\n        }\n    }\n    void command_n() {\n        /*\n          ºÉsª êÎAJ[\\ðºÌsÌæª¶ÉÚ®·éB\n          ºÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n        */\n        if ( exist_next_lowerline() ) {\n            move_cursor_down();\n            move_cursor_leftmost();\n        } else {\n            move_cursor_leftmost();\n        }\n    }\n    void command_f() {\n        /*\n          J[\\ªsÉÈ¢êAJ[\\ðPÂEÉÚ®·éB\n          J[\\ªsÉ è©ÂºÉsª éêÍAJ[\\ðºÌsÌæª¶ÖÚ®·éB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( ! is_cursor_rightmost() ) {\n            move_cursor_right();\n        } else if ( is_cursor_rightmost() && exist_next_lowerline() ) {\n            move_cursor_down();\n            move_cursor_leftmost();\n        }\n    }\n    void command_b() {\n        /*\n          J[\\ªæª¶ÅÈ¢ÈçÎAJ[\\ðPÂ¶ÉÚ®·éB\n          J[\\ªæª¶Å è©ÂãÉsª éêÍAJ[\\ðãÌsÌsÖÚ®·éB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( ! is_cursor_leftmost() ) {\n            move_cursor_left();\n        } else if ( is_cursor_leftmost() && exist_next_upperline() ) {\n            move_cursor_up();\n            move_cursor_rightmost();\n        }\n    }\n    void command_d() {\n        /*\n          J[\\ª¶ðw·êÍ»Ì¶ðí·éBí³ê½¶ÌE¤Ì¶ñÍ¶ÉVtg³êéB\n          J[\\ªsðwµºÉsª éêÍAºÌsð»ÌÜÜJ[\\ÌÊuÉq°éBÈºÌsÍãÉVtg³êéB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( ! is_cursor_rightmost() ) {\n            delete_letter( c );\n        } else if ( is_cursor_rightmost() && exist_next_lowerline() ) {\n            T[r] += T[r+1];\n            delete_line( r+1 );\n        }\n    }\n    void command_k() {\n        /*\n          J[\\ªsÉ éêAºÉsª êÎAd Æ¯¶ìðµobt@ÉPÂÌüsðL^·éB\n          J[\\ªsÉÈ¢êAJ[\\ªw·¶ðÜß½E¤·×ÄÌ¶ðØèæè»êðobt@ÉL^·éB\n          J[\\Í³ÌsÌsðw·æ¤ÉÈéBSÄÌL^É¨¢Äobt@Íã«³êéB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( is_cursor_rightmost() && exist_next_lowerline() ) {\n            T[r] += T[r+1];\n            delete_line( r+1 );\n            buffer = \"\\n\";\n        } else if ( ! is_cursor_rightmost() ) {\n            buffer = T[r].substr( c );\n            T[r] = T[r].substr( 0, c );\n            move_cursor_rightmost();\n        }\n    }\n    void command_y() {\n        /*\n          obt@ªóÌêÍÈÉàµÈ¢B\n          obt@ÌàeªüsÌêAJ[\\ªw·¶Ì¼OÅüsðs¤BJ[\\ÍVµ¢sÌæª¶ÖÚ®·éB\n          obt@Ìàeª¶ñÌêAJ[\\ÌÊuÉobt@Ìàeð}ü·éB\n          J[\\ÌÊuÍàÆàÆwµÄ¢½¶Ü½ÍsÌêÖÚ®·éB\n        */\n        if ( buffer == \"\\n\" ) {\n            string tmp = T[r].substr( c );\n            T[r] = T[r].substr( 0, c );\n            T.insert( T.begin() + r + 1, tmp );\n            move_cursor_down();\n            move_cursor_leftmost();\n        } else if ( buffer != \"\" ) {\n            string left = T[r].substr( 0, c );\n            string right = T[r].substr( c );\n            T[r] = left + buffer + right;\n        }\n    }\n};\n\n// functions\n\nVS solve( const VS& lines ) {\n    VS T; // text\n    VS C; // commands\n    split( lines, T, C );\n\n    if ( T.empty() ) return T;\n\n    // edit\n    Editor editor( T );\n    for ( VS ::iterator it_i = C.begin(); it_i != C.end(); ++ it_i ) {\n        string command = *it_i;\n        editor.parse_command( command );\n    }\n    return editor.get_text();\n}\n\nvoid output( const VS& lines ) {\n    for ( VS ::const_iterator it_i = lines.begin(); it_i != lines.end(); ++ it_i ) {\n        myos << *it_i << endl;\n    }\n}\n\nvoid split( const VS& lines, VS& T, VS& C ) {\n    T.clear();\n    C.clear();\n    VS ::const_iterator it_lines = lines.begin();\n    for ( ; it_lines != lines.end(); ++ it_lines ) {\n        const string& line = *it_lines;\n        if ( line == END_OF_TEXT ) {\n            ++ it_lines;\n            break;\n        }\n        T.push_back( line );\n    }\n    for ( ; it_lines != lines.end(); ++ it_lines ) {\n        const string& line = *it_lines;\n        if ( line == END_OF_COMMAND ) {\n            break;\n        }\n        C.push_back( line );\n    }\n}\n\nint main() {\n    VS lines;\n    string line;\n    while ( getline( myis, line ) ) lines.push_back( line );\n\n    VS answer = solve( lines );\n    output( answer );\n    cout << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tstring str[10000];\n\tstring b;\n\tint i = 0;\n\t\n\twhile (getline(std::cin, str[i]), str[i] != \"END_OF_TEXT\") i++;\n\ti = 0;\n\t\n\tchar cmd[2];\n\tint car_y = 0;\n\tint car = 0;\n\tint y = 0, y2 = 0;\n\t\n\twhile (str[y] != \"END_OF_TEXT\") y++;\n\ty--;\n\ty2 = y;\n\t\n\tb.erase();\n\t\n\twhile (scanf(\"%s\", cmd), cmd[0] != '-'){\n\t\tif (cmd[0] == 'a'){\n\t\t\tcar = 0;\n\t\t//\tprintf(\" a\");\n\t\t}\n\t\tif (cmd[0] == 'e'){\n\t\t\tcar = str[car_y].size();\n\t\t\t\n\t\t//\tprintf(\" e\");\n\t\t}\n\t\tif (cmd[0] == 'p'){\n\t\t\t\n\t\t//\tprintf(\" p\");\n\t\t\tif (car_y == 0){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y--;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'n'){\n\t\t//\tprintf(\" n\");\n\t\t\tif (car_y == y2){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y++;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'f'){\n\t\t//\tprintf(\" f\");\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\tcar_y++;\n\t\t\t\t\tcar = 0;\n\t\t\t\t\t//printf(\" %d\",car_y);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar++;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'b'){\n\t\t//\tprintf(\" b\");\n\t\t\tif (car == 0){\n\t\t\t\tif (car_y != 0){\n\t\t\t\t\tcar_y--;\n\t\t\t\t\tcar = str[car_y].size();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar--;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'd'){\n\t\t//\tprintf(\" d\");\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tstr[car_y].erase(car, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\t//str[car_y] + str[car_y + 1];\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = --y;\n\t\t\t\t\ty = car_y + 1;\n\t\t\t\t\twhile (y <= y2){\n\t\t\t\t\t\tstr[y] = str[y + 1];\n\t\t\t\t\t\ty++;\n\t\t\t\t\t}\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'k'){\n\t\t//\tprintf(\" k\");\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\tb[0] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb.erase();\n\t\t\t\tb = str[car_y].substr(car);\n\t\t\t\tstr[car_y].erase(car);\n\t\t\t\tcar = str[car_y].size();\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'y'){\n\t\t//\tprintf(\" y\");\n\t\t\t//if (b.empty());\n\t\t\t{\n\t\t\t\tif (b[0] == '\\0'){\n\t\t\t\t\ty2 = ++y;\n\t\t\t\t\twhile (y < car_y){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t\ty--;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tstr[y] = str[y - 1].substr(car);\n\t\t\t\t\tstr[y - 1].erase(car);\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstr[car_y].insert(car, b);\n\t\t\t\t\tcar += b.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\ti = 0;\n\twhile (i <= y2){\n\t\t//puts(str[i].c_str());\n\t\tcout << str[i] << endl;\n\t\ti++;\n\t}\n\t/*\n\ti = 0;\n\twhile (i <= y2){\n\t\tif (car_y == i){\n\t\t\tfor (int j = 0; j <= str[i].size(); j++){\n\t\t\t\tif (j == car){\n\t\t\t\t\tcout << 'I';\n\t\t\t\t}\n\t\t\t\tcout << str[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\telse{\n\t\t\tputs(str[i].c_str());\n\t\t}\n\t\ti++;\n\t}\n\t*/\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> text;\nstring buffer;\n\nint main()\n{\n\tstring input;\n\t\n\twhile (true){\n\t\tgetline(cin, input);\n\t\tif (input == \"END_OF_TEXT\") break;\n\t\ttext.push_back(input);\n\t}\n\t\n\tint p1 = 0;\n\tint p2 = 0;\n\t\n\twhile (true){\n\t\tcin >> input;\n\t\tif (input == \"-\") break;\n\t\t\n\t\tif (input == \"a\") p2 = 0;\n\t\tif (input == \"e\") p2 = text[p1].size();\n\t\tif (input == \"p\"){\n\t\t\tif (p1 > 0) p1--;\n\t\t\tp2 = 0;\n\t\t}\n\t\tif (input == \"n\"){\n\t\t\tif (p1 + 1 < text.size()) p1++;\n\t\t\tp2 = 0;\n\t\t}\n\t\tif (input == \"f\"){\n\t\t\tif (p2 < text[p1].size()) p2++;\n\t\t\telse if (p2 == text[p1].size() && p1 + 1 < text.size()){\n\t\t\t\tp1++;\n\t\t\t\tp2 = 0;\n\t\t\t}\n\t\t}\n\t\tif (input == \"b\"){\n\t\t\tif (p2 > 0) p2--;\n\t\t\telse if (p1 > 0){\n\t\t\t\tp1--;\n\t\t\t\tp2 = text[p1].size();\n\t\t\t}\n\t\t}\n\t\tif (input == \"d\"){\n\t\t\tif (p2 < text[p1].size()) text[p1].erase(p2, 1);\n\t\t\telse if (p1 + 1 < text.size()){\n\t\t\t\ttext[p1] += text[p1 + 1];\n\t\t\t\ttext.erase(text.begin() + p1 + 1);\n\t\t\t}\n\t\t}\n\t\tif (input == \"k\"){\n\t\t\tif (p2 == text[p1].size()){\n\t\t\t\tif (p1 + 1 < text.size()){\n\t\t\t\t\tif (p2 < text[p1].size()) text[p1].erase(p2, 1);\n\t\t\t\t\telse if (p1 + 1 < text.size()){\n\t\t\t\t\t\ttext[p1] += text[p1 + 1];\n\t\t\t\t\t\ttext.erase(text.begin() + p1 + 1);\n\t\t\t\t\t}\n\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuffer = string(text[p1], p2, text[p1].size() - p2);\n\t\t\t\ttext[p1].erase(p2);\n\t\t\t\tp2 = text[p1].size();\n\t\t\t}\n\t\t}\n\t\tif (input == \"y\"){\n\t\t\tif (buffer == \"\") continue;\n\t\t\tif (buffer == \"\\n\"){\n\t\t\t\tstring tmp(text[p1], p2, text[p1].size() - p2);\n\t\t\t\ttext[p1].erase(p2);\n\t\t\t\ttext.insert(text.begin() + p1 + 1, tmp);\n\t\t\t\tp1++;\n\t\t\t\tp2 = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttext[p1].insert(p2, buffer);\n\t\t\t\tp2 += buffer.size();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < text.size(); i++){\n\t\tcout << text[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY--;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n\telse return;\n}\n\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\\n\";\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring front=\"\";\n\t\tstring rear=\"\";\n\t\tfront = lines[posY].substr(0,posX);\n\t\trear = lines[posY].substr(posX,lines[posY].size()-posX);\t\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX);\n\n\t\tlines[posY] = front;\n\t\tdeque<string>::iterator it = lines.begin();\n\t\tadvance(it,posY);\n\t\tlines.insert(it,rear);\n\t}\n\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(getline(cin,str)){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(cin >> str){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\tif(str == \"d\") ctrl_d(lines);\n\t\tif(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY = 0;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\tposY++;\n\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n}\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\\n\";\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX);\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX+1);\n\n\t\tlines[posY] = front;\n\t\tdeque<string>::iterator it = lines.begin();\n\t\tadvance(it,posY);\n\t\tlines.insert(it,rear);\n\t}\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\n\tdeque<string> lines;\n\tstring str;\n\twhile(cin >> str){\n\t\tposX = 0;\n\t\tposY = 0;\n\t\tif(str == \"END_OF_TEXT\") {\n\t\t\twhile(cin >> str){\n\t\t\t\tif(str == \"-\") break;\n\t\t\t\tif(str == \"a\") ctrl_a(lines);\n\t\t\t\tif(str == \"e\") ctrl_e(lines);\n\t\t\t\tif(str == \"p\") ctrl_p(lines);\n\t\t\t\tif(str == \"n\") ctrl_n(lines);\n\t\t\t\tif(str == \"f\") ctrl_f(lines);\n\t\t\t\tif(str == \"b\") ctrl_b(lines);\n\t\t\t\tif(str == \"d\") ctrl_d(lines);\n\t\t\t\tif(str == \"k\") ctrl_k(lines);\n\t\t\t\tif(str == \"y\") ctrl_y(lines);\n\t\t\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t\t\t}\n\n\t\t\tfor(int i=0;i<lines.size();i++){\n\t\t\t\tcout << lines[i] << \"\\n\";\n\t\t\t}\n\n\t\t}\n\t\telse{\n\t\t\tlines.push_back(str);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <list>\n\nint main() {\n  std::list<std::string> lines;\n  while (true) {\n    char buf[32];\n    fgets(buf, sizeof buf, stdin);\n    std::string line=buf;\n    if (line == \"END_OF_TEXT\\n\")\n      break;\n\n    lines.emplace_back(line);\n  }\n\n  auto it=lines.begin();\n  size_t cc=0;\n  std::string kbuf=\"\";\n  while (true) {\n    char op;\n    scanf(\" %c\", &op);\n\n    switch (op) {\n    case '-': {\n      for (const auto &line: lines)\n        printf(\"%s\", line.c_str());\n      return 0;\n    }\n\n    case 'a':\n      cc = 0;\n      break;\n\n    case 'e':\n      cc = it->size()-1;\n      break;\n\n    case 'p':\n      cc = 0;\n      if (it != lines.begin())\n        --it;\n      break;\n\n    case 'n':\n      cc = 0;\n      if (std::next(it) != lines.end())\n        ++it;\n      break;\n\n    case 'f':\n      if ((*it)[cc] != '\\n') {\n        ++cc;\n      } else if (std::next(it) != lines.end()) {\n        ++it;\n        cc = 0;\n      }\n      break;\n\n    case 'b':\n      if (cc > 0) {\n        --cc;\n      } else if (it != lines.begin()) {\n        --it;\n        cc = it->size()-1;\n      }\n      break;\n\n    case 'd':\n      if ((*it)[cc] != '\\n') {\n        *it = it->substr(0, cc) + it->substr(cc+1);\n      } else if (std::next(it) != lines.end()) {\n        it->pop_back();\n        auto tmp=std::next(it);\n        *it += *tmp;\n        lines.erase(tmp);\n      }\n      break;\n\n    case 'k':\n      if ((*it)[cc] != '\\n') {\n        kbuf = it->substr(cc);\n        kbuf.pop_back();\n        *it = it->substr(0, cc) + \"\\n\";\n      } else if (std::next(it) != lines.end()) {\n        kbuf = \"\\n\";\n        it->pop_back();\n        auto tmp=std::next(it);\n        *it += *tmp;\n        lines.erase(tmp);\n      }\n      break;\n\n    case 'y':\n      if (kbuf.empty()) {\n        // no-op;\n      } else if (kbuf == \"\\n\") {\n        std::string s=it->substr(cc);\n        *it = it->substr(0, cc) + \"\\n\";\n        auto tmp=std::next(it);\n        lines.emplace(tmp, s);\n        ++it;\n        cc = 0;\n      } else {\n        *it = it->substr(0, cc) + kbuf + it->substr(cc);\n        cc += kbuf.length();\n      }\n      break;\n    }\n\n    // fprintf(stderr,\n    //         \"[%c] / L%td C%zu\\n\", op, std::distance(lines.begin(), it), cc);\n    // for (const auto &line: lines)\n    //   fprintf(stderr, \"%s\", line.c_str());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nstring txt[101]={},bf;\nint kx,ky,x;\n\nvoid A(){kx=0;}\nvoid E(){kx=txt[ky].size();}\nvoid P(){\n\tif(ky)ky--;\n\tA();\n}\nvoid N(){\n\tif(x-1!=ky)ky++;\n\tA();\n}\nvoid F(){\n\tif(kx!=txt[ky].size())kx++;\n\telse if(kx==txt[ky].size()&&x-1!=ky)N();\n}\nvoid B(){\n\tif(kx)kx--;\n\telse if(!kx&&ky){\n\t\tky--;\n\t\tE();\n\t}\n}\nvoid D(){\n\tif(kx!=txt[ky].size()){\n\t\ttxt[ky]=txt[ky].substr(0,kx)+txt[ky].substr(kx+1);\n\t}\n\telse if(kx==txt[ky].size()&&ky!=x-1){\n\t\ttxt[ky]+=txt[ky+1];\n\t\tfor(int i=ky+1;i<x;i++)txt[i]=txt[i+1];\n\t\ttxt[x]=\"\";\n\t\tx--;\n\t}\n}\nvoid K(){\n\tif(kx==txt[ky].size()&&x-1!=ky){\n\t\tD();\n\t\tbf=\"\\n\";\n\t}\n\telse if(kx!=txt[ky].size()){\n\t\tbf=txt[ky].substr(kx);\n\t\ttxt[ky]=txt[ky].substr(0,kx);\n\t}\n}\nvoid Y(){\n\tif(bf==\"\\n\"){\n\t\t//txt[ky+1]=txt[ky].substr(kx)+txt[ky+1];\n\t\t//txt[ky]=txt[ky].substr(0,kx);\n\t\t//if(ky+1==x)x++;\n\t\tstring next = txt[ky].substr(kx);\n\t\ttxt[ky]=txt[ky].substr(0,kx);\n\t\tx++;\n\t\tfor(int i = x - 1; i >= ky + 2; i--)\n\t\t\ttxt[i] = txt[i - 1];\n\t\ttxt[ky + 1] = next;\n\t\tN();\n\t}\n\telse if(bf!=\"\"){\n\t\ttxt[ky]=txt[ky].substr(0,kx)+bf+txt[ky].substr(kx);\n\t\tkx+=bf.size();\n\t}\n}\n\nint main(){\n\tstring s;\n\tkx=ky=x=0; bf=\"\";\n\twhile(getline(cin,s),s!=\"END_OF_TEXT\")txt[x++]=s;\n\twhile(cin>>s,s!=\"-\"){\n\t\tif(s==\"a\")A();\n\t\tif(s==\"e\")E();\n\t\tif(s==\"p\")P();\n\t\tif(s==\"n\")N();\n\t\tif(s==\"f\")F();\n\t\tif(s==\"b\")B();\n\t\tif(s==\"d\")D();\n\t\tif(s==\"k\")K();\n\t\tif(s==\"y\")Y();\n#if 0\n\t\tcerr << \"ROW: \" << ky << \"COL: \" << kx << endl;\n\t\tfor(int i = 0; i < x; i++) cerr << txt[i] << endl;\n#endif\n\t}\n\tfor(int i=0;i<x;i++)cout<<txt[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main()\n{\n\tstring str[300];\n\tstring b = \"???\";\n\tunsigned int y = 0, y2 = 0;\n\t\n\twhile (getline(std::cin, str[y]), str[y] != \"END_OF_TEXT\"){\n\t\ty++;\n\t}\n\ty2 = --y;\n\t\n\tchar cmd[2];\n\tunsigned int car = 0, car_y = 0;\n\t\n\twhile (scanf(\"%s\", cmd), cmd[0] != '-'){\n\t\tif (cmd[0] == 'a'){\n\t\t\tcar = 0;\n\t\t}\n\t\tif (cmd[0] == 'e'){\n\t\t\tcar = str[car_y].size();\n\t\t}\n\t\tif (cmd[0] == 'p'){\n\t\t\tif (car_y == 0){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y--;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'n'){\n\t\t\tif (car_y != y){\n\t\t\t\tcar_y++;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\t\n\t\t\telse {\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'f'){\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tcar++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tcar_y++;\n\t\t\t\t\tcar = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'b'){\n\t\t\tif (car != 0){\n\t\t\t\tcar--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != 0){\n\t\t\t\t\tcar_y--;\n\t\t\t\t\tcar = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'd'){\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tstr[car_y].erase(car, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = y - 1;\n\t\t\t\t\ty = car_y;\n\t\t\t\t\twhile (++y < y2){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y].erase();\n\t\t\t\t\t\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'k'){\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = y;\n\t\t\t\t\ty = car_y;\n\t\t\t\t\twhile (++y < y2){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y].erase();\n\t\t\t\t\t\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb = str[car_y].substr(car);\n\t\t\t\tstr[car_y].erase(car);\n\t\t\t\tcar = str[car_y].size();\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'y'){\n\t\t\tif(b != \"???\"){\n\t\t\t\tif (b[0] == '\\0'){\n\t\t\t\t\ty2 = y + 1;\n\t\t\t\t\twhile (y > car_y + 1){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y] = str[car_y].substr(car);\n\t\t\t\t\tstr[car_y].erase(car);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstr[car_y].insert(car, b);\n\t\t\t\t\tcar += b.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (unsigned int j = 0; j <= y; j++){\n\t\tcout << str[j] << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint i=0,j=0;\nstring buffer=\"\";\nvector<string> vec;\n\nvoid p(void){\n\tif(i > 0){\n\t\ti--;\n\t}\n\tj = 0;\n}\n\nvoid n(void){\n\tif(i < vec.size() - 1){\n\t\ti++;\n\t}\n\tj = 0;\n}\n\nvoid f(void){\n\tif(j < vec.at(i).length()){\n\t\tj++;\n\t}\n\telse if(j == vec.at(i).length() && i < vec.size() - 1){\n\t\ti++;\n\t\tj = 0;\n\t}\n}\n\nvoid b(void){\n\tif(j > 0){\n\t\tj--;\n\t}\n\telse if(j == 0 && i > 0){\n\t\ti--;\n\t\tj = vec.at(i).length();\n\t}\n}\n\nvoid d(void){\n\tstring s = vec.at(i);\n\n\tif(j < vec.at(i).length()){\n\t\ts.erase(s.begin() + j);\n\t}\n\telse if(j == vec.at(i).length() && i < vec.size() - 1){\n\t\ts += vec.at(i + 1);\n\t\tvec.erase(vec.begin() + i);\n\t}\n\tvec.erase(vec.begin() + i);\n\tvec.insert(vec.begin() + i, s);\n}\n\nvoid k(void){\n\tif(j == vec.at(i).length() && i < vec.size() - 1){\n\t\td();\n\t\tbuffer = \"\\n\";\n\t}\n\telse if(j < vec.at(i).length()){\n\t\tstring s = vec.at(i);\n\n\t\tbuffer = s.substr(j);\n\t\ts.erase(s.begin()+j,s.end());\n\t\tvec.erase(vec.begin() + i);\n\t\tvec.insert(vec.begin() + i, s);\n\t}\n}\n\nvoid y(void){\n\tstring s = vec.at(i);\n\n\tif(buffer == \"\\n\"){\n\t\tvec.insert(vec.begin()+i+1,s.substr(j));\n\t\ts.erase(s.begin()+j,s.end());\n\t\tvec.erase(vec.begin()+i);\n\t\tvec.insert(vec.begin()+i,s);\n\t\ti++;\n\t\tj = 0;\n\t}\n\telse if(buffer != \"\"){\n\t\ts.insert(j,buffer);\n\t\tj += buffer.length();\n\t\tvec.erase(vec.begin()+i);\n\t\tvec.insert(vec.begin()+i,s);\n\t}\n}\n\nint main(void){\n\tstring s;\n\n\twhile(getline(cin,s) && s!=\"END_OF_TEXT\"){\n\t\tvec.push_back(s);\n\t}\n\twhile(cin>>s && s!=\"-\"){\n\t\tswitch(s.at(0)){\n\t\tcase 'a': j=0; break;\n\t\tcase 'e': j=vec.at(i).length(); break;\n\t\tcase 'p': p(); break;\n\t\tcase 'n': n(); break;\n\t\tcase 'f': f(); break;\n\t\tcase 'b': b(); break;\n\t\tcase 'd': d(); break;\n\t\tcase 'k': k(); break;\n\t\tcase 'y': y(); break;\n\t\t}\n\t}\n\tfor(int i=0;i<vec.size();i++){\n\t\tcout<<vec.at(i)<<endl;\n\t}\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tvector<string> e;\n\tstring s;\n\twhile (getline(cin, s), s != \"END_OF_TEXT\") {\n\t\te.push_back(s);\n\t}\n\tint y = 0, x = 0;\n\tstring buffer = \"\";\n\tchar c;\n\twhile (cin >> c, c != '-') {\n\t\tswitch (c) {\n\t\t\tcase 'a':\n\t\t\t\tx = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tx = e[y].size();\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tx = 0;\n\t\t\t\ty = max(0, y-1);\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tx = 0;\n\t\t\t\ty = min(e.size()-1, y+1);\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (x < e[y].size()) {\n\t\t\t\t\t++x;\n\t\t\t\t} else if (y+1 < e.size()) {\n\t\t\t\t\tx = 0;\n\t\t\t\t\t++y;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tif (0 < x) {\n\t\t\t\t\t--x;\n\t\t\t\t} else if (0 <= y-1) {\n\t\t\t\t\tx = e[y-1].size();\n\t\t\t\t\t--y;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif (x < e[y].size()) {\n\t\t\t\t\te[y] = e[y].substr(0,x) + e[y].substr(x+1);\n\t\t\t\t} else if (y+1 < e.size()) {\n\t\t\t\t\te[y] += e[y+1];\n\t\t\t\t\te.erase(e.begin()+y+1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tif (x < e[y].size()) {\n\t\t\t\t\tbuffer = e[y].substr(x);\n\t\t\t\t\te[y] = e[y].substr(0,x);\n\t\t\t\t\tx = e[y].size();\n\t\t\t\t} else if (y+1 < e.size()) {\n\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t\te[y] += e[y+1];\n\t\t\t\t\te.erase(e.begin()+y+1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\tif (buffer != \"\") {\n\t\t\t\t\tif (buffer == \"\\n\") {\n\t\t\t\t\t\te.insert(e.begin()+y+1, e[y].substr(x));\n\t\t\t\t\t\te[y] = e[y].substr(0,x);\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\t++y;\n\t\t\t\t\t} else {\n\t\t\t\t\t\te[y] = e[y].substr(0,x) + buffer + e[y].substr(x);\n\t\t\t\t\t\tx += buffer.size();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=0; i<e.size(); ++i) {\n\t\tcout << e[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nint main(){\n\n\tstring str;\n\tstring tmp;\n\tbool f=false;\n\twhile(cin>>tmp&&tmp!=\"END_OF_TEXT\"){\n\t\tf=true;\n\t\tstr+=tmp;\n\t\tstr+='\\n';\n\t}\n\tchar cmd;\n\tint cur=0;\n\n\tstring buff;\n\twhile(cin>>cmd&&cmd!='-'){\n\t\tif(cmd=='a'){\n\t\t\twhile(1){\n\t\t\t\tif(cur==0)\n\t\t\t\t\tbreak;\n\t\t\t\telse if(str[cur-1]=='\\n'){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur--;\n\t\t\t}\n\t\t}\n\t\telse if(cmd=='e'){\n\t\t\twhile(1){\n\t\t\t\tif(str[cur]=='\\n'){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur++;\n\t\t\t}\n\t\t}\n\t\telse if(cmd=='p'){\n\t\t\tint cnt=0;\n\t\t\twhile(1){\n\t\t\t\tif(cur==0)\n\t\t\t\t\tbreak;\n\t\t\t\telse if(cur==str.size()-1){\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if(str[cur]=='\\n'){\n\t\t\t\t\tif(cnt==0)\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\telse{\n\t\t\t\t\t\tcur--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur--;\n\t\t\t}\n\t\t}\n\t\telse if(cmd=='n'){\n\t\t\tint cnt=0;\n\t\t\twhile(1){\n\t\t\t\tif(cur==0)\n\t\t\t\t\tbreak;\n\t\t\t\telse{\n\t\t\t\t\tif(str[cur]=='\\n'){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcur--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(cmd=='f'){\n\t\t\tif(cur!=str.size()-1){\n\t\t\t\tcur++;\n\t\t\t}\n\t\t}\n\t\telse if(cmd=='b'){\n\t\t\tif(cur!=0){\n\t\t\t\tcur--;\n\t\t\t}\n\t\t}\n\t\telse if(cmd=='d'){\n\t\t\tstr = str.substr(0,cur) + str.substr(cur+1);\n\t\t}\n\t\telse if(cmd=='k'){\n\t\t\tif(str[cur]=='\\n'){\n\t\t\t\tstr = str.substr(0,cur) + str.substr(cur+1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(str[cur]=='\\n'){\n\t\t\t\t\tstr = str.substr(0,cur) + str.substr(cur+1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint prv=cur;\n\t\t\t\t\tint nxt=prv;\n\t\t\t\t\twhile(1){\n\t\t\t\t\t\tif(str[nxt]=='\\n'){\n\t\t\t\t\t\t\tbuff=str.substr(prv,nxt-prv);\n\t\t\t\t\t\t\tstr=str.substr(0,prv)+str.substr(nxt);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnxt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(cmd=='y'){\n\t\t\tif(buff!=\"\"){\n\t\t\t\tif(buff==\"\\n\"){\n\t\t\t\t\tstr=str.substr(0,cur)+\"\\n\"+str.substr(cur);\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstr=str.substr(0,cur)+buff+str.substr(cur);\n\t\t\t\t\tcur+=buff.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout<<str;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nvector<string> s;\nstring buf = \"\";\nint R;\nint ci = 0, cj = 0;\n\nvoid input() {\n  string l;\n  while (1) {\n    getline(cin, l);\n    if (l == \"END_OF_TEXT\") {\n      break;\n    }\n    s.push_back(l);\n  }\n  R = s.size();\n}\n\n// カーソルを現在の行の先頭文字に移動する\nvoid op_a() { cj = 0; }\n\n// カーソルを現在の行の行末に移動する\nvoid op_e() { cj = s[ci].size(); }\n\n// 上に行があれば、カーソルを上の行の先頭文字に移動する。\n// 上に行がなければ、カーソルを先頭文字に移動する。\nvoid op_p() {\n  if (ci != 0) \n    --ci;\n  op_a();\n}\n\n// 下に行があれば、カーソルを下の行の先頭文字に移動する。\n// 下に行がなければ、カーソルを先頭文字に移動する。\nvoid op_n() {\n  if (ci != R - 1) \n    ++ci;\n  op_a();\n}\n\n// カーソルが行末にない場合、カーソルを１つ右に移動する \n// カーソルが行末にありかつ下に行がある場合は、\n// カーソルを下の行の先頭文字へ移動する \n// それ以外の場合は何もしない\nvoid op_f() {\n  if (cj != s[ci].size()) {\n    ++cj;\n  } else if (cj == s[ci].size() && ci != R - 1) {\n    op_n();\n  }\n}\n\n// カーソルが先頭文字でないならば、カーソルを１つ左に移動する。\n// カーソルが先頭文字でありかつ上に行がある場合は、\n// カーソルを上の行の行末へ移動する。\n// それ以外の場合は何もしない。\nvoid op_b() {\n  if (cj != 0) {\n    --cj;\n  } else if (cj == 0 && ci != 0) {\n    --ci;\n    op_e();\n  }\n}\n\n// カーソルが文字を指す場合はその文字を削除する。\n// 削除された文字の右側の文字列は左にシフトされる。\n// カーソルが行末を指し下に行がある場合は、\n// 下の行をそのままカーソルの位置に繋げる。以下の行は上にシフトされる。\n// それ以外の場合は何もしない。\nvoid op_d() {\n  if (cj != s[ci].size()) {\n    // prev\n    // s[ci].erase(cj, 1);\n    s[ci] = s[ci].substr(0, cj) + s[ci].substr(cj + 1);\n  } else if (cj == s[ci].size() && ci != R - 1) {\n    // prev\n    // s[ci].erase(cj, 1);\n    // s[ci] += s[ci+1];\n    // s.erase(s.begin() + ci + 1);\n    s[ci] += s[ci+1];\n    s.erase(s.begin() + ci + 1);\n  }\n}\n\n// カーソルが行末にある場合、下に行があれば、\n// d と同じ操作をしバッファに１つの改行を記録する。\n// カーソルが行末にない場合、カーソルが指す文字を含めた\n// 右側すべての文字を切り取りそれをバッファに記録する。\n// カーソルは元の行の行末を指すようになる。全ての記録においてバッファは上書きされる。\n// それ以外の場合は何もしない。(clarification at 14:20)\nvoid op_k() {\n  if (cj == s[ci].size() && ci != R - 1) {\n    // prev\n    // s[ci].erase(cj, 1);\n    // s[ci] += s[ci+1];\n    // s.erase(s.begin() + ci + 1);\n    s[ci] += s[ci+1];\n    s.erase(s.begin() + ci + 1);\n    buf = \"\\n\";\n  } else  {\n    // prev\n    // buf = s[ci].substr(cj);\n    // s[ci].erase(cj);\n    buf = s[ci].substr(cj);\n    s[ci] = s[ci].substr(0, cj);\n  }\n}\n\n// バッファが空の場合はなにもしない。\n// バッファの内容が改行の場合、カーソルが指す文字の直前で改行を行う。\n// カーソルは新しい行の先頭文字へ移動する。\n// バッファの内容が文字列の場合、カーソルの位置にバッファの内容を挿入する。\n// カーソルの位置はもともと指していた文字または行末の場所へ移動する。 \nvoid op_y() {\n  if (buf == \"\") return;\n  if (buf == \"\\n\") {\n    // prev\n    // inserter(s, s.begin() + ci + 1) = s[ci].substr(cj);\n    // s[ci].erase(cj);\n    // ++ci; cj = 0;\n    vector<string>::iterator itr = s.begin();\n    rep(i,ci+1) ++itr;\n    s.insert(itr, s[ci].substr(cj));\n    s[ci] = s[ci].substr(0, cj);\n    ++ci; cj = 0;\n  } else {\n    // prev\n    // s[ci].insert(cj, buf.c_str());\n    // cj += buf.size();\n    s[ci] = s[ci].substr(0, cj) + buf + s[ci].substr(cj);\n    cj += buf.size();\n  }\n}\n\nvoid interpret() {\n  string op;\n  while (1) {\n    getline(cin, op);\n    if (op == \"-\") break;\n    if (op == \"a\") {\n      op_a();\n    } else if (op == \"e\") {\n      op_e();\n    } else if (op == \"p\") {\n      op_p();\n    } else if (op == \"n\") {\n      op_n();\n    } else if (op == \"f\") {\n      op_f();\n    } else if (op == \"b\") {\n      op_b();\n    } else if (op == \"d\") {\n      op_d();\n    } else if (op == \"k\") {\n      op_k();\n    } else if (op == \"y\") {\n      op_y();\n    }\n  }\n  rep(i,R) {\n    printf(\"%s\\n\", s[i].c_str());\n  }\n}\n\nint main() {\n  input();\n  interpret();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n\tvector<string> lines;\n\tstring cmds;\n\tfor(string s;getline(cin,s),s!=\"END_OF_TEXT\";)\n\t\tlines.push_back(s);\n\tfor(char c;cin>>c,c!='-';)\n\t\tcmds+=c;\n\t\n\tint i=0,j=0;\n\tstring buf;\n\tfor(char c:cmds){\n\t\tif(c=='a')\n\t\t\tj=0;\n\t\telse if(c=='e')\n\t\t\tj=lines[i].size();\n\t\telse if(c=='p'){\n\t\t\tif(i>0)\n\t\t\t\ti--;\n\t\t\tj=0;\n\t\t}\n\t\telse if(c=='n'){\n\t\t\tif(i+1<lines.size())\n\t\t\t\ti++;\n\t\t\tj=0;\n\t\t}\n\t\telse if(c=='f'){\n\t\t\tif(j<lines[i].size())\n\t\t\t\tj++;\n\t\t\telse if(i+1<lines.size()){\n\t\t\t\ti++;\n\t\t\t\tj=0;\n\t\t\t}\n\t\t}\n\t\telse if(c=='b'){\n\t\t\tif(j>0)\n\t\t\t\tj--;\n\t\t\telse if(i>0){\n\t\t\t\ti--;\n\t\t\t\tj=lines[i].size();\n\t\t\t}\n\t\t}\n\t\telse if(c=='d'){\n\t\t\tif(j<lines[i].size())\n\t\t\t\tlines[i].erase(j,1);\n\t\t\telse if(i+1<lines.size()){\n\t\t\t\tlines[i]+=lines[i+1];\n\t\t\t\tlines.erase(lines.begin()+i+1);\n\t\t\t}\n\t\t}\n\t\telse if(c=='k'){\n\t\t\tif(j<lines[i].size()){\n\t\t\t\tbuf=lines[i].substr(j);\n\t\t\t\tlines[i].erase(j);\n\t\t\t}\n\t\t\telse if(i+1<lines.size()){\n\t\t\t\tbuf=\"\\n\";\n\t\t\t\tlines[i]+=lines[i+1];\n\t\t\t\tlines.erase(lines.begin()+i+1);\n\t\t\t}\n\t\t}\n\t\telse if(c=='y'){\n\t\t\tif(buf==\"\\n\"){\n\t\t\t\tlines.insert(lines.begin()+i+1,lines[i].substr(j));\n\t\t\t\tlines[i].erase(j);\n\t\t\t}\n\t\t\telse if(buf.size()){\n\t\t\t\tlines[i].insert(j,buf);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<lines.size();i++)\n\t\tcout<<lines[i]<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1021\n#include<iostream>\n#include<vector>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\nconst int LMAX = 1000;\n\nvector<string> lines;\nint h, w;\nstring buffer;\n\nbool on_tail() { return w == lines[h].size(); }\nvoid goto_tail() { w = lines[h].size(); }\nbool on_eof() { return h >= lines.size() - 1; }\nvoid remove_line(int n) { lines.erase(lines.begin() + n); }\nvoid remove_char(int h, int w) {\n  lines[h].erase(lines[h].begin() + w);\n}\n\nvoid a() { w = 0; }\nvoid e() { goto_tail(); }\nvoid p() { h = max(h - 1, 0); w = 0; }\nvoid n() { h = min(h + 1, (int)lines.size() - 1); w = 0; }\nvoid f() {\n  if (not on_tail()) { w++; }\n  else if (not on_eof()) {\n    h++; w = 0;\n  }\n}\nvoid b() {\n  if (w > 0) { w--; }\n  else if (h > 0) { h--; goto_tail(); }\n}\nvoid d() {\n  if (on_tail() and !on_eof()) {\n    lines[h] += lines[h + 1];\n    remove_line(h + 1);\n  } else if (not on_tail()) {\n    remove_char(h, w);\n  }\n}\nvoid k() {\n  if (on_tail() and !on_eof()) {\n    d();\n    buffer = \"\\n\";\n  } else if (not on_tail()) {\n    buffer = lines[h].substr(w);\n    lines[h] = lines[h].substr(0, w);\n  }\n}\nvoid y() {\n  if (buffer == \"\\n\") {\n    lines.insert(lines.begin() + h, \"\\n\");\n    h++; w = 0;\n  } else if (not buffer.empty()) {\n    lines[h].insert(lines[h].begin()+w, buffer.begin(), buffer.end());\n    w += buffer.size();\n  }\n}\n\nint main() {\n  string l;\n  buffer = \"\";\n  while (cin >> l and l != \"END_OF_TEXT\") {\n    lines.push_back(l);\n  }\n\n  char com;\n  while (cin >> com and com != '-') {\n    switch (com) {\n    case 'a':\n      a(); break;\n    case 'e':\n      e(); break;\n    case 'p':\n      p(); break;\n    case 'n':\n      n(); break;\n    case 'f':\n      f(); break;\n    case 'b':\n      b(); break;\n    case 'd':\n      d(); break;\n    case 'k':\n      k(); break;\n    case 'y':\n      y(); break;\n    default:\n      break;\n    }\n    REP(i, lines.size()) {\n      cout << \">\" << lines[i] << endl;\n    }\n    cout << \"(\" << h << \",\" << w << \")\" << endl;\n  }\n\n  for (int i = 0; i < lines.size(); i++) {\n    cout << lines[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int INF = 100000000;\n\nvector<string> text;\nstring buffer;\n\nvoid setcursor(P &p, char com){\n\tswitch(com){\n\tcase 'a':\n\t\tp.X = 1;\n\t\tbreak;\n\tcase 'e':\n\t\tp.X = text[p.Y].size();\n\t\tbreak;\n\tcase 'p':\n\t\tsetcursor(p, 'a');\n\t\tif(p.Y > 0) p.Y--;\n\t\tbreak;\n\tcase 'n':\n\t\tsetcursor(p, 'a');\n\t\tif(p.Y < text.size()-1) p.Y++;\n\t\tbreak;\n\tcase 'f':\n\t\tif(p.X < text[p.Y].size()) p.X++;\n\t\telse{\n\t\t\tif(p.Y < text.size()-1){\n\t\t\t\tp.Y++;\n\t\t\t\tsetcursor(p, 'a');\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'b':\n\t\tif(p.X > 1) p.X--;\n\t\telse{\n\t\t\tif(p.Y > 0){ \n\t\t\t\tp.Y-- ;\n\t\t\t\tsetcursor(p, 'e');\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'd':\n\t\tif(p.X < text[p.Y].size()){\n\t\t\ttext[p.Y].erase(p.X-1, 1);\n\t\t}\n\t\telse if(p.X == text[p.Y].size()){\n\t\t\tif(p.Y < text.size()-1){\n\t\t\t\ttext[p.Y].erase(p.X-1, 1);\n\t\t\t\ttext[p.Y] += text[p.Y+1];\n\t\t\t\ttext.erase(text.begin()+p.Y+1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'k':\n\t\tif(p.X == text[p.Y].size()){\n\t\t\tif(p.Y < text.size()-1){\n\t\t\t\ttext[p.Y].erase(p.X-1, 1);\n\t\t\t\ttext[p.Y] += text[p.Y+1];\n\t\t\t\ttext.erase(text.begin()+p.Y+1);\n\n\t\t\t\tbuffer = \"\\n\";\n\t\t\t}\n\t\t}else{\n\t\t\tbuffer = text[p.Y].substr(p.X-1);\n\t\t\tbuffer.erase(buffer.size()-1);\n\t\t\ttext[p.Y].erase(p.X-1);\n\t\t\ttext[p.Y] += '\\0';\n\t\t}\n\t\tbreak;\n\tcase 'y':\n\t\tif(buffer == \"\")break;\n\t\tif(buffer != \"\\n\"){\n\t\t\ttext[p.Y].insert( p.X-1, buffer);\n\t\t\tp.X += buffer.size();\n\t\t}\n\t\telse{\n\t\t\tstring tmp = text[p.Y].substr(p.X-1);\n\t\t\ttext[p.Y].erase(p.X-1);\n\t\t\ttext[p.Y] += '\\0';\n\t\t\tp.Y++;\n\t\t\ttext.insert(text.begin()+p.Y, tmp);\n\t\t\tsetcursor(p, 'a');\n\t\t}\n\t}\n}\n\nvoid pp(P p){\n\tchar tmp = '*';\n\tswap(tmp, text[p.Y][p.X-1]);\n\trep(i, text.size()){\n\t\tcout << text[i] << endl;\n\t}\n\tswap(tmp, text[p.Y][p.X-1]);\t\n}\n\n\nint main(){\n\n\t//freopen(\"test.txt\", \"r\", stdin);\n\n\tstring s;\n\twhile(getline(cin, s), s != \"END_OF_TEXT\"){\n\t\ttext.push_back(s+'\\0');\n\t}\n\n\t//freopen(\"CON\", \"r\", stdin);\n\n\tP cursor(MP(1, 0)); // y行x文字目\n\n//pp(cursor);\n\n\tchar com;\n\twhile(cin >> com, com != '-'){\n\t\tsetcursor(cursor, com);\n\n\t\t//pp(cursor);\n\t\t//printf(\"%d-%d\\n\", cursor.Y, cursor.X);\n\t}\n\n\trep(i, text.size()){\n\t\ttext[i].erase(text[i].size()-1, 1);\n\t\tcout << text[i] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\n#define ASSERT( condition, message ){ \\\n   if ( !(condition) ){ \\\n     cout << \"Assertion failed: \" << message << endl; \\\n     exit( EXIT_FAILURE );\t\t\t      \\\n   } \\\n}\n\nusing namespace std;\n\nclass Editor{\n  \nprivate:\n  \n  // parameters\n  int cursor;\n  string text;\n  string buffer;\n  \npublic:\n  \n  // initialize parameters\n  Editor(string initialText){\n    cursor = 0;\n    text = initialText;\n    buffer = \"\";\n  }\n  \n  // return text\n  string getText(){\n    return text;\n  }\n  \n  // functions of commands\n  \n  void command_a(){\n    \n    while(1){\n      \n      if( cursor == 0 ) return;\n      \n      cursor--;\n      \n      if( text[cursor] == '\\n' ) break;\n      \n    }\n    \n    cursor++;\n    \n  }\n  \n  void command_e(){\n    \n    while(1){\n      \n      if( text[cursor] == '\\n' ) break;\n      \n      cursor++;\n      \n    }\n    \n  }\n  \n  void command_p(){\n    \n    command_a();\n    \n    if( cursor == 0 ) return;\n    \n    cursor--;\n    \n    command_a();\n    \n  }\n  \n  void command_n(){\n    \n    command_e();\n    \n    if( cursor != (int)text.size() - 1 ) cursor++;\n    else command_a();\n    \n  }\n  \n  void command_f(){\n    \n    if( cursor != (int)text.size() - 1 ) cursor++;\n    \n  }\n  \n  void command_b(){\n    \n    if( cursor != 0 ) cursor--;\n    \n  }\n  \n  void command_d(){\n    \n    if( (int)text.size() == 0 ) return;\n    if( cursor == (int)text.size() - 1 ) return;\n    \n    string newText;\n    \n    newText += text.substr( 0, cursor );\n    newText += text.substr( cursor + 1 );\n    \n    text = newText;\n    \n  }\n  \n  void command_k(){\n    \n    if( cursor == (int)text.size() - 1 ) return;\n    \n    if( text[cursor] == '\\n' ){\n      command_d();\n      buffer = '\\n';\n      return;\n    }\n    \n    int beginIdx = cursor;\n    int endIdx = cursor;\n      \n    while(1){\n\t\n      endIdx++;\n      \n      if( text[endIdx] == '\\n' ) break;\n      \n    }\n    \n    endIdx--;\n    \n    buffer = text.substr( beginIdx, endIdx - beginIdx + 1 );\n    \n    string newText;\n    \n    newText += text.substr( 0, beginIdx );\n    newText += text.substr( endIdx + 1 );\n    \n    text = newText;\n      \n  }\n\n  void command_y(){\n    \n    string newText;\n    \n    newText += text.substr( 0, cursor );\n    newText += buffer;\n    newText += text.substr( cursor );\n    \n    text = newText;\n    \n    cursor += (int)buffer.size();\n    \n  }\n  \n};\n\n// input text\n// modify : initialText\nvoid inputText(string &initialText){\n  \n  int line_cnt = 0;\n  \n  while(1){\n    \n    string oneline;\n    getline( cin, oneline );\n    \n    if( oneline == \"END_OF_TEXT\" ) break;\n    \n    ASSERT( (int)oneline.size() <= 20, \"The number of characters in a line given as input > 20\" );\n    \n    initialText += oneline;\n    initialText += '\\n';\n    \n    line_cnt++;\n    \n  }\n  \n  ASSERT( 0 < (int)initialText.size() , \"text should be consist of several lines.\" );\n  \n  ASSERT( line_cnt <= 10, \"The number of lines in the text given as input > 10\" );\n  \n}\n\n// input commands\n// modify : commands\nvoid inputCommands(vector<char> &commands){\n  \n  int command_cnt = 0;\n  \n  while(1){\n    \n    char command;\n    cin >> command;\n    \n    if( command == '-' ) break;\n    \n    commands.push_back( command );\n    \n    command_cnt++;\n    \n  }\n  \n  ASSERT( command_cnt <= 300, \"The number of commands > 300\" );\n  \n}\n\nvoid checkText(Editor &editor){\n  \n  string text = editor.getText();\n  int line_cnt = 0;\n  int char_cnt = 0;\n  int max_char_cnt = 0;\n  \n  for(char c : text ){\n    \n    if( c == '\\n' ){\n      line_cnt++;\n      max_char_cnt = max( max_char_cnt, char_cnt );\n      char_cnt = 0;\n    }\n    else char_cnt++;\n    \n  }\n  \n  ASSERT( line_cnt <= 100, \"The maximum possible number of lines in the text during operations <= 100\" );\n  \n  ASSERT( max_char_cnt <= 1000, \"The maximum possible number of characters in a line during operations <= 1000\" );\n  \n}\n\n// execute commands\n// input : commands, modify : editor\nvoid executeCommands(const vector<char> commands, Editor &editor){\n  \n  for( char command : commands ){\n    \n    if( command == 'a' ) editor.command_a();\n    else if( command == 'e' ) editor.command_e();\n    else if( command == 'p' ) editor.command_p();\n    else if( command == 'n' ) editor.command_n();\n    else if( command == 'f' ) editor.command_f();\n    else if( command == 'b' ) editor.command_b();\n    else if( command == 'd' ) editor.command_d();\n    else if( command == 'k' ) editor.command_k();\n    else if( command == 'y' ) editor.command_y();\n    else{ // error\n      string error_message = \"command \" + string(1,command) + \" is not exist.\";\n      ASSERT( 0, error_message );\n    }\n    \n    checkText( editor );\n    \n  }\n  \n}\n\n// output text\n// input : editor\nvoid outputText(Editor editor){\n  \n  string text = editor.getText();\n  \n  cout << text;\n  \n}\n\nint main(){\n  \n  string initialText; // text of input\n  inputText( initialText );\n  \n  vector<char> commands; // commands of input\n  inputCommands( commands );\n  \n  Editor editor( initialText ); // editor\n  executeCommands( commands, editor );\n  \n  outputText( editor );\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? n==1 ? x: b_pow(x,n>>1)*b_pow(x,(n>>1)+(n&1)) : 1;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\nstring buffer;\nvector<string> text;\nint x,y;\n\nvoid a(){\n\tx = 0;\n}\nvoid e(){\n\tx = text[y].length() - 1;\n}\nvoid p(){\n\tint ty = y - 1;\n\tx = 0;\n\tif(ty != -1 )y = ty;\n}\n\nvoid n(){\n\tint ty = y + 1;\n\tx = 0;\n\tif(ty != text.size() )y = ty;\n}\n\nvoid f(){\n\tint tx = x + 1;\n\tif(tx == text[y].length() ){\n\t\tint ty = y + 1;\n\t\tif(ty != text.size() ){\n\t\t\ty = ty;\n\t\t\tx = 0;\n\t\t}\n\t}else{\n\t\tx = tx;\n\t}\n}\n\nvoid b(){\n\tint tx = x - 1;\n\tif(tx == -1 ){\n\t\tint ty = y - 1;\n\t\tif(ty != -1 ){\n\t\t\ty = ty;\n\t\t\tx = text[y].length() - 1;\n\t\t}\n\t}else{\n\t\tx = tx;\n\t}\n}\n\nbool d(){\n\tif(text[y][x] == '\\n'){\n\t\tint ty = y + 1;\n\t\tif(ty != text.size() ){\n\t\t\ttext[y].erase(x,1);\n\t\t\ttext[y] += text[ty];\n\t\t\ttext[ty] = \"\";\n\t\t\treturn true;\n\t\t}\n\t}else{\n\t\ttext[y].erase(x,1);\n\t}\n\treturn false;\n}\nvoid k(){\n\tif(text[y][x] == '\\n'){\n\t\tif(d())buffer = \"\\n\";\n\t}else{\n\t\tbuffer = text[y].substr(x); buffer.erase(buffer.length()-1);\n\t\ttext[y] = text[y].substr(0,x) + \"\\n\";\n\t}\n}\n\nvoid Y(){\n\tif(buffer == \"\")return;\n\t\n\tif(buffer == \"\\n\"){\n\t\tvector<string> tmp;\n\t\tstring a,b;\n\t\ta = text[y].substr(0,x) + \"\\n\";\n\t\tb = text[y].substr(x);\n\t\trep(i,y)tmp.push_back(text[i]);\n\t\ttmp.push_back(a),tmp.push_back(b);\n\t\t\n\t\tfor(int i=y+1;i < text.size();i++)\n\t\t\ttmp.push_back(text[i]);\n\t\ty = y + 1;\n\t\t\n\t\ttext = tmp;\n\t}else{\n\t\ttext[y].insert(x,buffer);\n\t}\n}\n\n\nint main(){\n\tx = 0  , y = 0;\n\tstring s;\n\twhile(getline(cin,s)){\n\t\tif(s[s.length()-1] == '\\r')s.erase(s.length()-1,1);\n\t\tif(s == \"END_OF_TEXT\")break;\n\t\ttext.push_back(s + \"\\n\");\n\t}\n\twhile(cin >> s , s != \"-\"){\n\t\tif(s == \"a\")a();\n\t\tif(s == \"e\")e();\n\t\tif(s == \"p\")p();\n\t\tif(s == \"n\")n();\n\t\tif(s == \"f\")f();\n\t\tif(s == \"b\")b();\n\t\tif(s == \"d\")d();\n\t\tif(s == \"k\")k();\n\t\tif(s == \"y\")Y();\n\t\ttext.erase(remove(all(text),\"\"),text.end());\n\t}\n\trep(i,text.size())cout << text[i];\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring kaigyou = \"wararaki_wararaki_kaigyo\";\n\nint main()\n{\n\tint p, q, w[101], h;\n\tstring str, buf;\n\tchar ch[101][1001];\n\t\n\twhile(!cin.eof()){\n\t\tgetline(cin, str);\n\t\tfill(w, w+101, 0);\n\t\th = 0;\n\t\twhile(str != \"END_OF_TEXT\"){\n\t\t\tfor(int i = 0; i < str.size(); i++){\n\t\t\t\tch[h][i] = str[i];\n\t\t\t}\n\t\t\tw[h++] = str.size();\n\t\t\tgetline(cin, str);\n\t\t}\n\t\tp = q = 0;\n\t\tbuf = \"\";\n\t\twhile(1){\n\t\t\tgetline(cin, str);\n\t\t\tif(str == \"-\"){\n\t\t\t\tbreak;\n\t\t\t} else if(str == \"a\"){\n\t\t\t\tq = 0;\n\t\t\t} else if(str == \"e\"){\n\t\t\t\tq = w[p];\n\t\t\t} else if(str == \"p\"){\n\t\t\t\tif(p > 0){\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t\tq = 0;\n\t\t\t} else if(str == \"n\"){\n\t\t\t\tif(p < h-1){\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tq = 0;\n\t\t\t} else if(str == \"f\"){\n\t\t\t\tif(q < w[p]){\n\t\t\t\t\tq++;\n\t\t\t\t} else if(p < h-1){\n\t\t\t\t\tp++;\n\t\t\t\t\tq = 0;\n\t\t\t\t}\n\t\t\t} else if(str == \"b\"){\n\t\t\t\tif(q > 0){\n\t\t\t\t\tq--;\n\t\t\t\t} else if(p > 0){\n\t\t\t\t\tp--;\n\t\t\t\t\tq = w[p];\n\t\t\t\t}\n\t\t\t} else if(str == \"d\"){\n\t\t\t\tif(q == w[p]){\n\t\t\t\t\tif(p < h-1){\n\t\t\t\t\t\tfor(int i = 0; i < w[p+1]; i++){\n\t\t\t\t\t\t\tch[p][w[p]+i] = ch[p+1][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tw[p] += w[p+1];\n\t\t\t\t\t\tfor(int i = p+2; i < h; i++){\n\t\t\t\t\t\t\tfor(int j = 0; j < w[i]; j++){\n\t\t\t\t\t\t\t\tch[i-1][j] = ch[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tw[i-1] = w[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tw[--h] = 0;\n\t\t\t\t\t}\n\t\t\t\t} else if(isalpha(ch[p][q])){\n\t\t\t\t\tfor(int i = 0, t = 0; i < w[p]; i++){\n\t\t\t\t\t\tif(i != q){\n\t\t\t\t\t\t\tch[p][t++] = ch[p][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tw[p]--;\n\t\t\t\t}\n\t\t\t} else if(str == \"k\"){\n\t\t\t\tif(q == w[p] && p < h-1){\n\t\t\t\t\tbuf = kaigyou;\n\t\t\t\t\tfor(int i = 0; i < w[p+1]; i++){\n\t\t\t\t\t\tch[p][w[p]+i] = ch[p+1][i];\n\t\t\t\t\t}\n\t\t\t\t\tw[p] += w[p+1];\n\t\t\t\t\tfor(int i = p+2; i < h; i++){\n\t\t\t\t\t\tfor(int j = 0; j < w[i]; j++){\n\t\t\t\t\t\t\tch[i-1][j] = ch[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tw[i-1] = w[i];\n\t\t\t\t\t}\n\t\t\t\t\tw[--h] = 0;\n\t\t\t\t} else if(q < w[p]){\n\t\t\t\t\tbuf = \"\";\n\t\t\t\t\tfor(int i = q; i < w[p]; i++){\n\t\t\t\t\t\tbuf += ch[p][i];\n\t\t\t\t\t}\n\t\t\t\t\tw[p] = q;\n\t\t\t\t}\n\t\t\t} else if(str == \"y\"){\n\t\t\t\tif(buf.size() > 0){\n\t\t\t\t\tif(buf == kaigyou){\n\t\t\t\t\t\tstring tmp = \"\";\n\t\t\t\t\t\tfor(int i = q; i < w[p]; i++){\n\t\t\t\t\t\t\ttmp += ch[p][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tw[p] = q;\n\t\t\t\t\t\tfor(int i = h; i > p; i--){\n\t\t\t\t\t\t\tfor(int j = 0; j < w[i-1]; j++){\n\t\t\t\t\t\t\t\tch[i][j] = ch[i-1][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tw[i] = w[i-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\th++;\n\t\t\t\t\t\tw[p+1] = tmp.size();\n\t\t\t\t\t\tfor(int i = 0; i < w[p+1]; i++){\n\t\t\t\t\t\t\tch[p+1][i] = tmp[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\tp++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstring tmp = \"\";\n\t\t\t\t\t\tfor(int i = 0; i < q; i++){\n\t\t\t\t\t\t\ttmp += ch[p][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp += buf;\n\t\t\t\t\t\tfor(int i = q; i < w[p]; i++){\n\t\t\t\t\t\t\ttmp += ch[p][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int i = 0; i < tmp.size(); i++){\n\t\t\t\t\t\t\tch[p][i] = tmp[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq = w[p] = tmp.size();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w[i]; j++){\n\t\t\t\tcout << ch[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY = 0;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n\telse return;\n}\n\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\\n\";\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring front=\"\";\n\t\tstring rear=\"\";\n\t\tfront = lines[posY].substr(0,posX);\n\t\trear = lines[posY].substr(posX,lines[posY].size()-posX);\t\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX);\n\n\t\tlines[posY] = front;\n\t\t//deque<string>::iterator it = lines.begin();\n\t\t//advance(it,posY);\n\t\tlines.insert(lines.begin()+posY,rear);\n\t\t//lines.insert(it,rear);\n\t}\n\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(getline(cin,str)){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(cin >> str){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\tif(str == \"d\") ctrl_d(lines);\n\t\tif(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\nvector<string> text;\nstring buf;\n\nint row, col;\n\nvoid func_a(){\n\tcol = 0;\n}\n\nvoid func_e(){\n\tcol = text[row].size() - 1;\n}\n\nvoid func_p(){\n\tif (row > 0) row--;\n\tfunc_a();\n}\n\nvoid func_n(){\n\tif (row < text.size() - 1) row++;\n\tfunc_a();\n}\n\nvoid func_f(){\n\tif (col < text[row].size() - 1) col++;\n\telse if (row < text.size() - 1){\n\t\tfunc_n();\n\t}\n}\n\nvoid func_b(){\n\tif (col > 0) col--;\n\telse if (row > 0){\n\t\tfunc_p();\n\t\tfunc_e();\n\t}\n}\n\nvoid func_d(){\n\tif (col < text[row].size() - 1) text[row].erase(col, 1);\n\telse if (row < text.size() - 1){\n\t\ttext[row].erase(text[row].end() - 1);\n\t\ttext[row] += text[row + 1];\n\t\ttext.erase(text.begin() + row + 1);\n\t}\n}\n\nvoid func_k(){\n\tif (col < text[row].size() - 1){\n\t\tbuf = text[row].substr(col, text[row].size() - col - 1);\n\t\ttext[row].erase(col, text[row].size() - 1);\n\t}\n\telse if (row < text.size() - 1){\n\t\tfunc_d();\n\t\tbuf = \"\\n\";\n\t}\n}\n\nvoid func_y(){\n\tif (!buf.empty()){\n\t\tif (buf == \"\\n\"){\n\t\t\ttext.insert(text.begin() + row + 1, text[row].substr(col, text[row].size() - 1));\n\t\t\ttext[row].erase(col, text[row].size() - 1);\n\t\t\ttext[row] += '$';\n\t\t}\n\t\telse {\n\t\t\ttext[row].insert(col, buf);\n\t\t\tcol += buf.size();\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstring in;\n\tchar cmd;\n\n\twhile (getline(cin, in), in != \"END_OF_TEXT\"){\n\t\ttext.push_back(in + '$');\n\t}\n\t\n\tcol = row = 0;\n\tbuf.clear();\n\n\twhile (cin >> cmd, cmd != '-'){\n\t\tswitch (cmd){\n\t\t  case 'a': func_a(); break;\n\t\t  case 'e':\tfunc_e(); break;\n\t\t  case 'p':\tfunc_p(); break;\n\t\t  case 'n': func_n(); break;\n\t\t  case 'f': func_f(); break;\n\t\t  case 'b':\tfunc_b(); break;\n\t\t  case 'd':\tfunc_d(); break;\n\t\t  case 'k': func_k(); break;\n\t\t  case 'y': func_y(); break;\n\t\t}\n#if 0\n\t\tprintf(\"col:%d row:%d\\n\", col, row);\n\t\tputs(\"status:\");\n\t\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\t\tcout << *it << endl;\n\t\t}\n\t\tputs(\"buffer:\");\n\t\tcout << buf << endl;\n#endif\n\t}\n\n\t\n\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\tcout << it->substr(0, it->size() - 1) << endl;\n\t}\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    list<list<char> > text;\n    for(;;){\n        string s;\n        cin >> s;\n        if(s == \"END_OF_TEXT\")\n            break;\n        text.push_back(list<char>(s.begin(), s.end()));\n    }\n\n    list<list<char> >::iterator it1 = text.begin();\n    list<char>::iterator it2 = it1->begin();\n    list<char> buffer;\n    bool newLine = false;\n    for(;;){\n        char c;\n        cin >> c;\n        if(c == 'a'){\n            it2 = it1->begin();\n        }else if(c == 'e'){\n            it2 = it1->end();\n        }else if(c == 'p'){\n            if(it1 != text.begin())\n                -- it1;\n            it2 = it1->begin();\n        }else if(c == 'n'){\n            ++ it1;\n            if(it1 == text.end())\n                -- it1;\n            it2 = it1->begin();\n        }else if(c == 'f'){\n            if(it2 != it1->end()){\n                ++ it2;\n            }else{\n                ++ it1;\n                if(it1 == text.end()){\n                    -- it1;\n                }else{\n                    it2 = it1->begin();\n                }\n            }\n        }else if(c == 'b'){\n            if(it2 != it1->begin()){\n                -- it2;\n            }else{\n                if(it1 != text.begin()){\n                    -- it1;\n                    it2 = it1->end();\n                }\n            }\n        }else if(c == 'd'){\n            if(it2 != it1->end()){\n                it2 = it1->erase(it2);\n            }else{\n                list<list<char> >::iterator tmp = it1;\n                ++ tmp;\n                if(tmp != text.end()){\n                    it2 = it1->insert(it2, '.');\n                    it1->splice(it1->end(), *tmp);\n                    text.erase(tmp);\n                    it2 = it1->erase(it2);\n                }\n            }\n        }else if(c == 'k'){\n            buffer.clear();\n            newLine = false;\n            if(it2 == it1->end()){\n                list<list<char> >::iterator tmp = it1;\n                ++ tmp;\n                if(tmp != text.end()){\n                    it2 = it1->insert(it2, '.');\n                    it1->splice(it1->end(), *tmp);\n                    text.erase(tmp);\n                    it2 = it1->erase(it2);\n                    newLine = true;\n                }\n            }else{\n                buffer.splice(buffer.end(), *it1, it2, it1->end());\n                it2 = it1->end();\n            }\n        }else if(c == 'y'){\n            if(newLine){\n                list<list<char> >::iterator tmp = it1;\n                ++ it1;\n                text.insert(it1, list<char>());\n                it1->splice(it1->end(), *tmp, it2, it1->end());\n                it2 = it1->begin();\n            }else if(buffer.size() > 0){\n                list<char> tmp = buffer;\n                it1->splice(it2, tmp);\n            }\n        }else{\n            break;\n        }\n    }\n\n    it1 = text.begin();\n    do{\n        cout << string(it1->begin(), it1->end()) << endl;\n    }while(++it1 != text.end());\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n\n\nstring ed;\nint cur;\n\nvoid head(){\n  while(cur>0 && ed[cur-1]!='\\n')--cur;\n}\n\nvoid tail(){\n  while(cur<ed.size() && ed[cur]!='\\n')++cur;\n}\n\nvoid pr(){\n  rep(i,ed.size()){\n    if(i==cur)cout<<\"_\";\n    cout<<ed[i];\n  }\n}\n\nmain(){\n  string str;\n  string end=\"END_OF_TEXT\";\n\n  while(getline(cin,str)){\n    if(end==str)break;\n    ed+=str+\"\\n\";\n  }\n  \n  string buffer=\"\";\n  \n  char c;\n  while(cin>>c){\n    if(c=='-')break;\n    //pr();\n    //cout<<c<<endl;\n    switch(c){\n    case 'a':\n      head();\n      break;\n    case 'e':\n      tail();\n      break;\n    case 'p':\n      head();\n      if(cur)--cur;\n      head();\n      break;\n    case 'n':\n      tail();\n      if(cur+1<ed.size())cur++;\n      head();\n      break;\n    case 'f':\n      if(cur+1<ed.size())cur++;\n      break;\n    case 'b':\n      if(cur)--cur;\n      break;\n    case 'd':\n      ed.erase(cur,1);\n      break;\n    case 'k':\n      if(ed[cur]=='\\n'){\n        ed.erase(cur,1);\n        buffer=\"\\n\";\n      }else{\n        int pos=0;\n        while(ed[cur+pos]!='\\n')++pos;\n        buffer=ed.substr(cur,pos);\n        ed.erase(cur,pos);\n      }\n      break;\n    case 'y':\n      if(buffer==\"\")continue;\n      else if(buffer==\"\\n\"){\n        ed.insert(cur,\"\\n\");\n        ++cur;\n      }else{\n        ed.insert(cur,buffer);\n      }\n    }\n  }\n  cout<<ed;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nint main(){\n  vector<string> text(200);\n  int line = 0;\n  for(;line<11;line++){\n    getline(cin,text[line],'\\n');\n    if (text[line]==\"END_OF_TEXT\")\n      break;\n  }\n  string buf=\"\";\n  int cur[2];\n  cur[0] = 0;//0s\n  cur[1] = 0;//0¶Ú\n\n  while(true){\n    char com;\n    cin >> com;\n    if (com == '-')\n      break;\n    switch (com){\n    case 'a':\n      cur[1] = 0;\n      break;\n    case 'e':\n      cur[1] = (int)text[cur[0]].size();\n      break;\n    case 'p':\n      if (cur[0]>0)\n\tcur[0]--;\n      cur[1]=0;\n      break;\n    case 'n':\n      if (cur[0]<line-1)\n\tcur[0]++;\n      cur[1]=0;\n      break;\n    case 'f':\n      if (cur[1]<(int)text[cur[0]].size()){\n\tcur[1]++;\n      }\n      else{\n\tif (cur[0]<line-1){\n\t  cur[0]++;\n\t  cur[1]=0;\t\n\t}\n      }\n      break;\n    case 'b':\n      if (cur[1]>0)\n\tcur[1]--;\n      else{\n\tif (cur[0]>0){\n\t  cur[0]--;\n\t  cur[1]=(int)text[cur[0]].size();\t\n\t}\n      }\n      break;\n    case 'd':\n      if (cur[1]<(int)text[cur[0]].size()){\n\ttext[cur[0]] = text[cur[0]].substr(0,cur[1])+text[cur[0]].substr(cur[1]+1);\n      }\n      else{\n\tif (cur[0]<line-1){\n\t  text[cur[0]] = text[cur[0]]+text[cur[0]+1];\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i] = text[i+1];\n\t  line--;\n\t}\n      }\n      break;\n    case 'k':\n      if (cur[1]==(int)text[cur[0]].size()){\n\tif (cur[0]<line-1){\n\t  text[cur[0]] = text[cur[0]]+text[cur[0]+1];\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i] = text[i+1];\n\t  line--;\n\t  buf = \"\\n\";\n\t}\n      }\n      else{\n\tbuf = text[cur[0]].substr(cur[1]);\n\ttext[cur[0]] = text[cur[0]].substr(0,cur[1]);\n\tcur[1] = (int)text[cur[0]].size();\n      }\n      break;\n    case 'y':\n      if (buf.empty())\n\tbreak;\n      else{\n\tif (buf == \"\\n\"){\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i+1] = text[i];    \n\t  line++;\n\t  text[cur[0]] = text[cur[0]].substr(0,cur[1]);\n\t  text[cur[0]+1] = text[cur[0]].substr(cur[1]);\n\t  cur[0]++;\n\t  cur[1] = 0;\n\t}\n\telse{\n\t  text[cur[0]] = text[cur[0]].substr(0,cur[1])+buf+text[cur[0]].substr(cur[1]);\n\t  cur[1] += buf.size();\n\t}\n      }\n    default:\n      break;\n    }\n    /*      for(int i=0;i<line;i++)\n\tcout << text[i] << endl;\n\tcout << \"(\" << cur[0] << \",\" << cur[1] << \")\" << endl;\n\tcout << \"#\" << endl;*/\n  }\n  for(int i=0;i<line;i++)\n    cout << text[i] << endl;\n  return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "/*\n * Author: FreePascal\n * Created Time:  2011/8/31 14:37:10\n * File Name: 8331d.cpp\n */\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <deque>\n#include <list>\n#include <stack>\nusing namespace std;\n#define out(v) cerr << #v << \": \" << (v) << endl\n#define SZ(v) ((int)(v).size())\nconst int maxint = -1u>>1;\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\nvector<string> text;\nstring buf,cmd;\nint x = 0,y = 0;\nvoid a(){\n    y = 0;\n}\nvoid e(){\n    y = text[x].size();\n}\nvoid p(){\n    if(x>0) x--;\n    y = 0;\n}\nvoid n(){\n    if(x<text.size()-1) x++;\n    y = 0;\n}\nvoid f(){\n    if( y == text[x].size() && x == text.size()-1) return ;\n    y++;\n    if(y > text[x].size()){\n        x++;\n        y = 0;\n    }\n}\nvoid b(){\n    if(y == 0 && x == 0) return;\n    y--;\n    if(y<0){\n        x--; \n        y = text[x].size();\n    }\n}\nvoid d(){\n    if(y < text[x].size()) {\n        text[x].erase(y,1);\n    }\n    else\n    {\n        text[x] += text[x+1];\n        //text.erase(x+1);\n        for(int i = x+1;i < text.size()-1;i++)\n            text[i] = text[i+1];\n        text.resize(text.size()-1);\n    }\n}\nvoid k(){\n    if(y == text[x].size()) {\n        d();\n        buf = \"\\n\";\n    }\n    else\n    {\n        buf = text[x].substr(y);\n        text[x].erase(y);\n    }\n}\nvoid cy(){\n    if( buf == \"\") return;\n    else if(buf == \"\\n\"){\n        string tm;\n        tm = text[x].substr(y);\n        text[x].erase(y);\n        //text.insert(x);\n        text.push_back(\"\");\n        for(int i = x+2;i<text.size();i++)\n            text[i] = text[i-1];\n        text[x+1] = tm;\n        x++;\n        y = 0;\n    }\n    else\n    {\n        text[x].insert(y,buf);\n        y+=buf.size();\n    }\n}\nvoid init(){\n    string s;\n    while(getline(cin,s) && s!= \"END_OF_TEXT\")\n        text.push_back(s);\n    while(cin>>s && s!=\"-\")\n        cmd+=s;\n}\nvoid work(){\n    for(int i = 0;i < cmd.size();i++)\n    {\n        switch(cmd[i]){\n            case 'a': a();break;\n            case 'e': e();break;\n            case 'p': p();break;\n            case 'n': n();break;\n            case 'f': f();break;\n            case 'b': b();break;\n            case 'd': d();break;\n            case 'k': k();break;\n            case 'y': cy();break;\n        } \n}\n}\nvoid prnt(){\n    for(int i = 0;i < text.size();i ++)\n        cout<<text[i]<<endl;\n}\n\nint main() {\n    init();\n    work();\n    prnt();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nstring s[1000],buf;\nint l,r,N;\n\nvoid a(void){r=0;}\nvoid e(void){r=s[l].size()-1;}\nvoid p(void){\n\tif(l>0)l--;\n\telse r=0;\n}\n\nvoid n(void){\n\tif(l<N-1)l++,r=0;\n\telse r=0;\n}\n\nvoid f(void){\n\tif(r<s[l].size()-1)r++;\n\telse l++,r=0;\n}\n\nvoid b(void){\n\tif(r>0)r--;\n\telse if(l>0)r=s[--l].size();\n}\n\nvoid d(void){\n\tif(r==s[l].size()-1){\n\t\tif(l<N-1){\n\t\t\ts[l]+=s[l+1];\n\t\t\tfor(int i=l+1;i<N-1;i++)s[i]=s[i+1];\n\t\t\tN--;\n\t\t}\n\t}\n\telse s[l].erase(r,1);\n}\n\nvoid k(void){\n\tif(r==s[l].size() && l<N-1)d(),buf=\"\\n\";\n\telse {\n\t\tbuf=s[l].substr(max(0,r-1));\n\t\ts[l].erase(max(0,r-1));\n\t}\n}\n\nvoid y(void){\n\tif(buf.empty())return ;\n\tif(buf==\"\\n\"){\n\t\tfor(int i=N;i>l;i--)s[i]=s[i-1];\n\t\ts[l+1]=s[l].substr(max(0,r-1));\n\t\ts[l].erase(max(0,r-1));\n\t\tl++,r=0,N++;\n\t}\n\telse {\n\t\ts[l].insert(min((int)s[l].size(),r+1),buf);\n\t\tr+=buf.size();\n\t}\n}\n\n\nint main(void){\n\t\n\twhile(getline(cin,s[N])){\n\t\tif(s[N]==\"END_OF_TEXT\")break;\n\t\tN++;\n\t}\n\tl=r=0;\n\tbuf.clear();\n\t\n\t\t\n\tstring C;\n\twhile(cin >> C,C!=\"-\"){\n\t\t\n\t\tif(C==\"a\")a();\n\t\telse if(C==\"e\")e();\n\t\telse if(C==\"p\")p();\n\t\telse if(C==\"n\")n();\n\t\telse if(C==\"f\")f();\n\t\telse if(C==\"b\")b();\n\t\telse if(C==\"d\")d();\n\t\telse if(C==\"k\")k();\n\t\telse if(C==\"y\")y();\n\t}\n\t\n\tfor(int i=0;i<N;i++){\n\t\tcout << s[i] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(5)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<short, short> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 100000007;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator > (const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nvector<string> s;\nint x, y;\n\nvoid gotoend()\n{\n\ty = s[x].size();\n}\n\nvoid gotohome()\n{\n\ty = 0;\n}\n\nint check()\n{\n\tif (s[x].size() == 0 || y == s[x].size()) return 1;\n\telse return 0;\n}\n\n\nint main()\n{\n\tx = 0; y = 0;\n\tstring tmp;\n\tstring buf = \"\";\n\twhile (1)\n\t{\n\t\tcin >> tmp;\n\t\tif (tmp == \"END_OF_TEXT\") break;\n\t\ts.push_back(tmp);\n\t}\n\tchar com;\n\twhile (cin >> com)\n\t{\n\t\tif (com == '-') break;\n\t\telse if (com == 'a') gotohome();\n\t\telse if (com == 'e') gotoend();\n\t\telse if (com == 'p')\n\t\t{\n\t\t\tif (x == 0) gotohome();\n\t\t\telse \n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'n')\n\t\t{\n\t\t\tif (x < s.size() - 1) x++;\n\t\t\tgotohome();\n\t\t}\n\t\telse if (com == 'f')\n\t\t{\n\t\t\tif (check() == 0) y++;\n\t\t\telse if (check()==1&&x < s.size() - 1)\n\t\t\t{\n\t\t\t\tx++;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'b')\n\t\t{\n\t\t\tif (y > 0) y--;\n\t\t\telse if (y == 0 && x > 0)\n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tgotoend();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'd')\n\t\t{\n\t\t\tif (check() == 0) s[x].erase(y, 1);\n\t\t\telse if (check() == 1 && x < s.size() - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\ts.erase(begin(s) + x + 1);\n\t\t\t}\n\t\t}\n\t\telse if (com == 'k')\n\t\t{\n\t\t\tif (check() == 1 && x < s.size() - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\ts.erase(begin(s) + x + 1);\n\t\t\t\tbuf = \"\\n\";\n\t\t\t}\n\t\t\t\n\t\t\telse if (check()==0)\n\t\t\t{\n\t\t\t\tbuf = s[x].substr(y);\n\t\t\t\ts[x].erase(y);\n\t\t\t}\n\t\t}\n\t\telse if (com == 'y')\n\t\t{\n\t\t\tif (buf == \"\\n\")\n\t\t\t{\n\t\t\t\tstring tmp = s[x].substr(y);\n\t\t\t\ts.insert(begin(s) + x + 1, tmp);\n\t\t\t\ts[x].erase(y);\n\t\t\t\tx++;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t\telse if (buf != \"\")\n\t\t\t{\n\t\t\t\ts[x].insert(y, buf);\n\t\t\t\ty += buf.size();\n\t\t\t}\n\t\t}\n\n\n\t}\n\tREP(i, s.size())\n\t{\n\t\tcout << s[i] << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cstdio>\nusing namespace std;\n\nint crow = 0, ccol = 0;\nstring buf = \"\";\nvector<string> lines;\n\nvoid input() {\n    while(1) {\n        string s;\n        getline(cin, s);\n        if(s == \"END_OF_TEXT\") break;\n        lines.push_back(s + \"\\n\");\n    }\n}\n\nvoid assign_buf(string s, bool is_cl_only=false) {\n    buf = s;\n    if(!is_cl_only) {\n        assert(buf.back() == '\\n');\n        buf.pop_back();\n    }\n}\n\nbool is_col_begin() { return ccol == 0; }\nbool is_col_end() { return ccol + 1 == lines[crow].size(); }\nbool is_row_begin() { return crow == 0; }\nbool is_row_end() { return crow + 1 == lines.size(); }\n\nint get_col_begin() { return 0; }\nint get_col_end() { return (int)lines[crow].size() - 1; }\nint get_row_begin() { return 0; }\nint get_row_end() { return (int)lines.size() - 1; }\n\nvoid up()   { crow = max(get_row_begin(), crow - 1); ccol = 0; }\nvoid down() { crow = min(get_row_end()  , crow + 1); ccol = 0; }\nvoid right() {\n    if(is_col_end() && is_row_end()) return;\n\n    if(is_col_end()) down(), ccol = get_col_begin();\n    else             ccol++;\n}\nvoid left() {\n    if(is_col_begin() && is_row_begin()) return;\n\n    if(is_col_begin()) up(), ccol = get_col_end();\n    else               ccol--;\n}\n\nvoid delete_char() {\n    if(is_col_end()) {\n        if(is_row_end()) return;\n        string &target = lines[crow];\n        assert(target.back() == '\\n');\n        target.pop_back();\n        target += lines[crow + 1];\n        lines.erase(lines.begin() + crow + 1);\n    }\n    else {\n        lines[crow].erase(lines[crow].begin() + ccol);\n    }\n}\n\nvoid show_state(char op) {\n    printf(\"operate [%c]: row = %d, col = %d\\n\", op, crow, ccol);\n    for(auto x : lines) cout << x;\n}\n\nbool operate(char op) {\n    assert(crow >= 0 && ccol >= 0);\n    assert(crow + 1 <= lines.size());\n    assert(ccol + 1 <= lines[crow].size());\n\n    if(op == 'a') {\n        ccol = get_col_begin();\n    }\n    if(op == 'e') {\n        ccol = get_col_end();\n    }\n    if(op == 'p') {\n        up();\n    }\n    if(op == 'n') {\n        down();\n    }\n    if(op == 'f') {\n        right();\n    }\n    if(op == 'b') {\n        left();\n    }\n    if(op == 'd') {\n        delete_char();\n    }\n    if(op == 'k') {\n        if(is_col_end()) {\n            if(!is_row_end()) {\n                printf(\"kill ring\\n\");\n                delete_char();\n                assign_buf(\"\\n\", true);\n            }\n        }\n        else {\n            string &target = lines[crow];\n            assign_buf(target.substr(ccol));\n            target = target.substr(0, ccol) + \"\\n\";\n        }\n    }\n    if(op == 'y') {\n        if(buf.size()) {\n            if(buf == \"\\n\") {\n                string &target = lines[crow];\n                string s1 = target.substr(0, ccol);\n                string s2 = target.substr(ccol);\n\n                if(s1.back() != '\\n') s1 += \"\\n\";\n                if(s2.back() != '\\n') s2 += \"\\n\";\n\n                target = s1;\n                lines.insert(lines.begin() + crow + 1, s2);\n\n                down();\n            }\n            else {\n                string &target = lines[crow];\n                target.insert(ccol, buf);\n                ccol += buf.size();\n            }\n        }\n    }\n\n    // show_state(op);\n    return op == '-';\n}\n\nint main() {\n    input();\n\n    while(1) {\n        char c; cin >> c;\n        if(operate(c)) break;\n    }\n    for(auto x : lines) {\n        cout << x;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(5)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<short, short> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 100000007;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator > (const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nvector<string> s;\nint x, y;\n\nvoid gotoend()\n{\n\ty = s[x].size();\n}\n\nvoid gotohome()\n{\n\ty = 0;\n}\n\nint check()\n{\n\tif (s[x].size() == 0 || y == s[x].size()) return 1;\n\telse return 0;\n}\n\n\nint main()\n{\n\tx = 0; y = 0;\n\tstring tmp;\n\tstring buf = \"@\";\n\twhile (1)\n\t{\n\t\tcin >> tmp;\n\t\tif (tmp == \"END_OF_TEXT\") break;\n\t\ts.push_back(tmp);\n\t}\n\tchar com;\n\twhile (cin >> com)\n\t{\n\t\tif (com == '-') break;\n\t\telse if (com == 'a') gotohome();\n\t\telse if (com == 'e') gotoend();\n\t\telse if (com == 'p')\n\t\t{\n\t\t\tif (x == 0) gotohome();\n\t\t\telse \n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'n')\n\t\t{\n\t\t\tif (x < s.size() - 1) x++;\n\t\t\tgotohome();\n\t\t}\n\t\telse if (com == 'f')\n\t\t{\n\t\t\tif (check() == 0) y++;\n\t\t\telse if (x < s.size() - 1)\n\t\t\t{\n\t\t\t\tx++;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'b')\n\t\t{\n\t\t\tif (y != 0) y--;\n\t\t\telse if (y == 0 && x > 0)\n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tgotoend();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'd')\n\t\t{\n\t\t\tif (check() == 0) s[x].erase(y, 1);\n\t\t\telse if (check() == 2 && x < s.size() - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\tint t = x + 1;\n\t\t\t\twhile (t < s.size() - 1)\n\t\t\t\t{\n\t\t\t\t\ts[t] = s[t + 1];\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t\ts.pop_back();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'k')\n\t\t{\n\t\t\tif (check() != 0 && x < s.size() - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\tint t = x + 1;\n\t\t\t\twhile (t < s.size() - 1)\n\t\t\t\t{\n\t\t\t\t\ts[t] = s[t + 1];\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t\ts.pop_back();\n\t\t\t\tbuf = \"#\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbuf = s[x].substr(y);\n\t\t\t\ts[x].erase(y);\n\t\t\t}\n\t\t}\n\t\telse if (com == 'y')\n\t\t{\n\t\t\tif (buf == \"@\") continue;\n\t\t\telse if (buf == \"#\")\n\t\t\t{\n\t\t\t\tint t = s.size() - 1;\n\t\t\t\ts.push_back(\"\");\n\t\t\t\twhile (t > x)\n\t\t\t\t{\n\t\t\t\t\ts[t + 1] = s[t];\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t\ts[x + 1] = s[x].substr(y);\n\t\t\t\ts[x].erase(y);\n\t\t\t\tx++;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts[x].insert(y, buf);\n\t\t\t\ty += buf.size();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tREP(i, s.size())\n\t\t{\n\t\t\tcout << s[i] << endl;\n\t\t}\n\t\tcout << x << \" \" << y << endl;\n\t\tcout << buf;\n\t\tcout << endl << endl;\n\t\t*/\n\t}\n\tREP(i, s.size())\n\t{\n\t\tcout << s[i] << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\tvector<string> edit;\n\twhile(true){\n\t\tstring s;\tcin>>s;\n\t\tif(s==\"END_OF_TEXT\")\tbreak;\n\t\tedit.push_back(s);\n\t}\n\tint tr=0,tc=0;\n\tstring buff=\"\";\n\twhile(true){\n\t\tchar c;\tcin>>c;\n\t\tif(c=='-')\tbreak;\n\t\tif(c=='a')\ttr=0;\n\t\telse if(c=='e')\ttr=edit[tc].size();\n\t\telse if(c=='p'){\n\t\t\ttr=0;\ttc=max(0,tc-1);\n\t\t}\n\t\telse if(c=='n'){\n\t\t\ttr=0;\ttc=min((int)edit.size()-1,tc+1);\n\t\t}\n\t\telse if(c=='f'){\n\t\t\tif((int)edit[tc].size()>=tr+1)\ttr++;\n\t\t\telse if((int)edit.size()>tc+1){\n\t\t\t\ttc++;\ttr=0;\n\t\t\t}\n\t\t}\n\t\telse if(c=='b'){\n\t\t\tif(tr>0)\ttr--;\n\t\t\telse if(tc>0){\n\t\t\t\ttc--;\ttr=edit[tc].size();\n\t\t\t}\n\t\t}\n\t\telse if(c=='d'){\n\t\t\tif(tr<(int)edit[tc].size())\tedit[tc].erase(edit[tc].begin()+tr);\n\t\t\telse if(tc+1<(int)edit.size()){\n\t\t\t\tedit[tc]=edit[tc]+edit[tc+1];\n\t\t\t\tedit.erase(edit.begin()+tc+1);\n\t\t\t}\n\t\t}\n\t\telse if(c=='k'){\n\t\t\tif(tr<(int)edit[tc].size()){\n\t\t\t\tbuff=edit[tc].substr(tr);\n\t\t\t\tedit[tc].erase(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t}\n\t\t\telse if(tc+1<(int)edit.size()){\n\t\t\t\tbuff=\"\\n\";\n\t\t\t\tedit[tc]=edit[tc]+edit[tc+1];\n\t\t\t\tedit.erase(edit.begin()+tc+1);\n\t\t\t}\n\t\t}\n\t\telse if(c=='y'){\n\t\t\tif(buff==\"\")\tcontinue;\n\t\t\tif(buff==\"\\n\"){\n\t\t\t\tstring s(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t\tedit[tc].erase(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t\tedit.insert(edit.begin()+tc+1,s);\n\t\t\t\ttc++;\ttr=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint s=buff.size();\n\t\t\t\tedit[tc].insert(edit[tc].begin()+tr,buff.begin(),buff.end());\n\t\t\t\ttr+=s;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<(int)edit.size();i++){\n\t\tif(i)\tcout<<endl;\n\t\tcout<<edit[i];\n\t}\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\ntemplate <class T> void pv(T a, T b) {\n\tfor(typeof(a) it = a; it != b; ++it)\n\t\tcerr << *it << \" \";\n\tcerr << endl;\n}\n\n#define all(v) (v).begin(), (v).end()\n\nvector<string> text;\nvector<char> command;\n\nint cursol_row;\nint cursol_col;\n\nvoid com_a() {\n\tcursol_col = 0;\n}\n\nvoid com_e() {\n\tcursol_col = text.at(cursol_row).length() - 1;\n}\n\nvoid com_p() {\n\tif(cursol_row > 0) cursol_row--;\n\tcursol_col = 0;\n}\n\nvoid com_n() {\n\tif(cursol_row < (int)text.size() - 1) cursol_row++;\n\tcursol_col = 0;\n}\n\nvoid com_f() {\n\tif(text[cursol_row][cursol_col] != '^') cursol_col++;\n\telse if(text[cursol_row][cursol_col] == '^' && cursol_row < (int)text.size() - 1) {\n\t\tcursol_row++;\n\t\tcursol_col = 0;\n\t}\n}\n\nvoid com_b() {\n\tif(cursol_col > 0) cursol_col--;\n\telse if(cursol_col == 0 && cursol_row > 0) {\n\t\tcursol_row--;\n\t\tcursol_col = text[cursol_row].length() - 1;\n\t}\n}\n\nvoid show_cursol() {\n\tcerr << \"ROW: \" << cursol_row << \" COL: \" << cursol_col << endl;\n}\n\nvoid com_d() {\n\tif(text[cursol_row][cursol_col] != '^') {\n\t\tstring line = text[cursol_row];\n\t\tstring left = line.substr(0, cursol_col);\n\t\tstring right = line.substr(cursol_col + 1);\n\t\ttext[cursol_row] = left + right;\n\t} else if(text[cursol_row][cursol_col] == '^' && cursol_row < (int)text.size() - 1) {\n\t\tstring line = text[cursol_row];\n\t\tline = line.substr(0, line.length() - 1) + text[cursol_row + 1];\n\t\ttext[cursol_row] = line;\n\n\t\tvector<string>::iterator it = text.begin();\n\t\tadvance(it, cursol_row + 1);\n\t\ttext.erase(it);\n\t}\n}\n\nstring buffer;\n\nvoid com_k() {\n\tif(text[cursol_row][cursol_col] == '^' && cursol_row < (int)text.size() - 1) {\n\t\tcom_d(); buffer = \"^\";\n\t}\n\telse if(text[cursol_row][cursol_col] != '^') {\n\t\tstring line = text[cursol_row];\n\t\tbuffer = line.substr(cursol_col);\n\t\tbuffer = buffer.substr(0, buffer.length() - 1);\n\t\ttext[cursol_row] = line.substr(0, cursol_col) + \"^\";\n\t}\n}\n\nvoid com_y() {\n\tif(buffer == \"^\") {\n\t\tstring line = text[cursol_row];\n\t\tstring fs = line.substr(0, cursol_col) + \"^\";\n\t\tstring sc = line.substr(cursol_col);\n\t\ttext[cursol_row] = fs;\n\n\t\tvector<string>::iterator it = text.begin();\n\t\tadvance(it, cursol_row + 1);\n\t\ttext.insert(it, sc);\n\t\tcursol_row++;\n\t\tcursol_col = 0;\n\t}\n\telse if(buffer != \"\") {\n\t\tstring line = text[cursol_row];\n\t\tstring left = line.substr(0, cursol_col);\n\t\tstring right = line.substr(cursol_col);\n\t\ttext[cursol_row] = left + buffer + right;\n\t}\n}\n\nint main() {\n\tbuffer = \"\";\n\n\tcursol_row = 0;\n\tcursol_col = 0;\n\n#if 1\n\tfor(string line; getline(cin, line) && line != \"END_OF_TEXT\";) {\n\t\ttext.push_back(line + \"^\");\n\t}\n\tfor(char c; cin >> c && c != '-'; ) {\n\t\tcommand.push_back(c);\n\t}\n#else\n\tfor(string line; getline(cin, line) && line != \"-\";) {\n\t\ttext.push_back(line + \"^\");\n\t}\n\tfor(char c; cin >> c && c != '-'; ) {\n\t\tswitch(c) {\n\t\t\tcase 'a': com_a(); break;\n\t\t\tcase 'e': com_e(); break;\n\t\t\tcase 'p': com_p(); break;\n\t\t\tcase 'n': com_n(); break;\n\t\t\tcase 'f': com_f(); break;\n\t\t\tcase 'b': com_b(); break;\n\t\t\tcase 'd': com_d(); break;\n\t\t\tcase 'k': com_k(); break;\n\t\t\tcase 'y': com_y(); break;\n\t\t\tdefault: break;\n\t\t}\n\t\tpv(all(text));\n\t\tshow_cursol();\n\t}\n#endif\n\n\t\n#if 0\n\tpv(all(text));\n\tpv(all(command));\n#endif\n\n\n#if 1\n\tfor(int i = 0; i < (int)command.size(); i++) {\n\t\tchar c = command[i];\n\t\tswitch(c) {\n\t\t\tcase 'a': com_a(); break;\n\t\t\tcase 'e': com_e(); break;\n\t\t\tcase 'p': com_p(); break;\n\t\t\tcase 'n': com_n(); break;\n\t\t\tcase 'f': com_f(); break;\n\t\t\tcase 'b': com_b(); break;\n\t\t\tcase 'd': com_d(); break;\n\t\t\tcase 'k': com_k(); break;\n\t\t\tcase 'y': com_y(); break;\n\t\t\tdefault: break;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < (int)text.size(); i++) {\n\t\tcout << text[i].substr(0, text[i].length() - 1) << endl;\n\t\t// cout << text[i] << endl;\n\t}\n#endif\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main(){\n\tstring str[100];\n\tstring s;\n\tint size = 0;\n\twhile(getline(cin,s)){\n\t\tif(s == \"END_OF_TEXT\") break;\n\t\tstr[size++] = s;\n\t}\n\tchar ch;\n\tstring buf = \"\";\n\tint line = 0, pos = 0;\n\twhile(cin >> ch){\n\t\tif(ch == '-') break;\n\t\tif(ch == 'a') pos = 0;\n\t\tif(ch == 'e') pos = str[line].size();\n\t\tif(ch == 'p'){\n\t\t\tpos = 0;\n\t\t\tif(line!=0) line--;\n\t\t}\n\t\tif(ch == 'n'){\n\t\t\tpos = 0;\n\t\t\tif(line+1!=size) line++;\n\t\t}\n\t\tif(ch == 'f'){\n\t\t\tif(pos != str[line].size()) pos++;\n\t\t\telse if(line+1!=size) { pos = 0; line++; }\n\t\t}\n\t\tif(ch == 'b'){\n\t\t\tif(pos != 0) pos--;\n\t\t\telse if(line!=0) { line--; pos = str[line].size(); }\n\t\t}\n\t\tif(ch == 'd'){\n\t\t\tif(pos != str[line].size()){\n\t\t\t\tstr[line] = str[line].substr(0,pos) + str[line].substr(pos+1);\n\t\t\t} else if(line+1!=size){\n\t\t\t\tstr[line] = str[line] + str[line+1];\n\t\t\t\tfor(int i=line+1;i+1<size;i++){\n\t\t\t\t\tstr[i] = str[i+1];\n\t\t\t\t}\n\t\t\t\tstr[size-1] = \"\";\n\t\t\t\tsize--;\n\t\t\t}\n\t\t}\n\t\tif(ch == 'k'){\n\t\t\tif(pos == str[line].size() && line+1!=size){\n\t\t\t\tstr[line] = str[line] + str[line+1];\n\t\t\t\tfor(int i=line+1;i+1<size;i++){\n\t\t\t\t\tstr[i] = str[i+1];\n\t\t\t\t}\n\t\t\t\tstr[size-1] = \"\";\n\t\t\t\tsize--;\n\t\t\t\tbuf = \"\\n\";\n\t\t\t}\n\t\t\telse if(pos < str[line].size()){\n\t\t\t\tbuf = str[line].substr(pos);\n\t\t\t\tstr[line] = str[line].substr(0,pos);\n\t\t\t}\n\t\t}\n\t\tif(ch == 'y'){\n\t\t\tif(buf == \"\\n\"){\n\t\t\t\tfor(int i=line+1;i<size;i++){\n\t\t\t\t\tstr[i+1] = str[i];\n\t\t\t\t}\n\t\t\t\tsize++;\n\t\t\t\tstr[line+1] = str[line].substr(pos);\n\t\t\t\tstr[line] = str[line].substr(0,pos);\n\t\t\t\tline++;\n\t\t\t\tpos = 0;\n\t\t\t} else if(buf != \"\"){\n\t\t\t\tstr[line] = str[line].substr(0,pos) + buf + str[line].substr(pos);\n\t\t\t\tpos += buf.size();\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tcout << line << \" \" << pos << endl;\n\t\tfor(int i=0;i<size;i++){\n\t\t\tcout << str[i] << endl;\t\n\t\t}\n\t\tputs(\"\");\n\t\t*/\n\t}\n\tfor(int i=0;i<size;i++){\n\t\tcout << str[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\nusing namespace std;\n\ntypedef long long ll;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nint main(){\n  int size;\n  string s[100];\n  for(size=0;cin>>s[size],s[size]!=\"END_OF_TEXT\";size++){\n    s[size] += '\\n';\n  }\n\n  string buff = \"\";\n  int x = 0, y = 0;\n  char op;\n\n  while(cin>>op,op!='-'){\n    if(op == 'a'){\n      x = 0;\n    }\n    else if(op == 'e'){\n      x = s[y].size() - 1;\n    }\n    else if(op == 'p'){\n      x = 0;\n      if(y != 0){\n        y--;\n      }\n    }\n    else if(op == 'n'){\n      x = 0;\n      if(y != size - 1){\n        y++;\n      }\n    }\n    else if(op == 'f'){\n      if(x < s[y].size() - 1){\n        x++;\n      }\n      else if(y != size-1){\n        y++;\n        x = 0;\n      }\n    }\n    else if(op == 'b'){\n      if(x != 0){\n        x--;\n      }\n      else if(y != 0){\n        y--;\n        x = s[y].size() - 1;\n      }\n    }\n    else if(op == 'd'){\n      if(x != s[y].size() - 1){\n        s[y].erase(s[y].begin() + x);\n      }\n      else if(y != size - 1){\n        s[y].erase(s[y].end()-1);\n        s[y] += s[y+1];\n        for(int i=y+1;i<size-1;i++){\n          s[i] = s[i+1];\n        }\n        size--;\n      }\n    }\n    else if(op == 'k'){\n      if(x != s[y].size() - 1){\n        buff = s[y].substr(x,s[y].size()-x-1);\n        s[y].erase(x,buff.size());\n      }\n      else if(y != size - 1){\n        s[y].erase(s[y].end()-1);\n        s[y] += s[y+1];\n        for(int i=y+1;i<size-1;i++){\n          s[i] = s[i+1];\n        }\n        size--;\n        buff = \"\\n\";\n      }\n    }\n    else if(op == 'y'){\n      if(buff == \"\\n\"){\n        for(int i=size;i>y;i--){\n          s[i] = s[i-1];\n        }\n        size++;\n        string tmp = s[y].substr(x);\n        s[y+1] = tmp;\n        s[y].erase(x,s[y].size()-x-1);\n      }\n      else if(buff != \"\"){\n        s[y].insert(x,buff);\n        x += buff.size();\n      }\n    }\n  }\n\n  rep(i,size){\n    cout<<s[i];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[111];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\tfor(int i=0 ; i<111 ; i++)\n\t\tt[i] = \"\";\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tif(i<110) t[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tif(row<110) col = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 && row < 110 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row < 110 && row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( row < 110 && col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else if( row < 110 ){\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( row < 110 && buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line+1 < 110 && line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\t//t[row+1] =\n\t\t\t\t\tif( col != t[row].size() ) t[row].substr( col );\n\t\t\t\t\t//t[row].erase( col );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else if( row < 110 ){\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvoid doA(int *l, int *c, string &s, string &b, vector<string> &v) {\n  *c = 0;\n}\n\nvoid doE(int *l, int *c, string &s, string &b, vector<string> &v) {\n  *c = s.size();\n}\n\nvoid doP(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*l > 0)\n    *l -= 1;\n  *c = 0;\n}\n\nvoid doN(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*l < v.size()-1)\n    *l += 1;\n  *c = 0;\n}\n\nvoid doF(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c < s.size()) {\n    *c += 1;\n  } else if (*l < v.size()-1){\n    *l += 1;\n    *c = 0;\n  }\n}\n\nvoid doB(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c > 0) {\n    *c -= 1;\n  } else if (*l > 0) {\n    *l -= 1;\n    *c = s.size();\n  }\n}\n\nvoid doD(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c < s.size()) {\n    s.erase(*c, 1);\n  } else if (*l < v.size()-1) {\n    s.append(v[*l+1]);\n    vector<string>::iterator itr = v.begin() + *l + 1;\n    v.erase(itr);\n  }\n}\n\nvoid doK(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c == s.size() && *l < v.size()-1) {\n    doD(l, c, s, b, v);\n    b = \"\\n\";\n  } else if (*c < s.size()) {\n    b = s.substr(*c, s.size() - *c);\n    s.erase(*c, s.size() - *c);\n    *c = s.size();\n  }\n}\n\n\nvoid doY(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (b.empty()) {\n    return;\n  } else if (b == \"\\n\") {\n    doK(l, c, s, b, v);\n    vector<string>::iterator itr = v.begin() + *l + 1;\n    v.insert(itr, b);\n    b = \"\\n\";\n  } else {\n    s.insert(*c, b);\n    *c = s.size();\n  }\n}\n\nint main(int argc, char *argv[]) {\n  string buf;\n  vector<string> strs;\n  while (true) {\n    string s;\n    getline(cin, s);\n    if (s == \"END_OF_TEXT\")\n      break;\n    strs.push_back(s);\n  }\n  int line = 0, chrc = 0;\n  while (true) {\n    char c;\n    cin >> c;\n    if (c == '-')\n      break;\n    else if (c == 'a')\n      doA(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'e')\n      doE(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'p')\n      doP(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'n')\n      doN(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'f')\n      doF(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'b')\n      doB(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'd')\n      doD(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'k')\n      doK(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'y')\n      doY(&line, &chrc, strs[line], buf, strs);\n  }\n\n  for (int i = 0; i < strs.size(); i++) {\n    if (i)\n      cout << endl;\n    cout << strs[i];\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// File: UAPC1021.cpp\n// Author: Edward Ly (m5222120)\n// Date: 9 January 2019\n// Draft of Solution for University of Aizu Programming Contest\n// Using C++ String and Vector Classes\n// Problem 1021: Emacs-like Editor\n\n#include <iostream> // cin, cout, endl\n#include <cstdio>   // getline\n#include <cstdlib>  // exit, EXIT_FAILURE, EXIT_SUCCESS\n#include <string>   // string (class)\n#include <vector>   // vector (class)\nusing namespace std;\n\n// Define preprocessor macro for debugging.\n// #define DEBUG\n\n#if defined( DEBUG )\n#define debug( code_fragment ) { code_fragment }\n#else\n#define debug( code_fragment )\n#endif\n\n// Declare functions used in this program.\nint numLines ( vector<string> text );\nvoid checkAndOutputError();\nvoid printText ( vector<string> text, int numLines );\n\n/* ==================================================================\n\tint main ()\n\n\tMain function routine.\n\n\tInput: multi-line string of text (from stdin).\n\tOutput: prints the modified text according to a list of Emacs\n\t\tcommands to stdout.\n================================================================== */\n\nint main () {\n\t// Program constants and parameters.\n\tconst int MAX_COMMANDS = 300,\n\t\t\t  MAX_INPUT_LINES = 10,\n\t\t\t  MAX_INPUT_COLUMNS = 20,\n\t\t\t  MAX_OUTPUT_LINES = 100,\n\t\t\t  MAX_OUTPUT_COLUMNS = 1000;\n\tconst string END_OF_TEXT_INDICATOR(\"END_OF_TEXT\");\n\tconst char END_OF_COMMANDS_INDICATOR = '-';\n\n\t// Initialize commands, buffers, and text strings.\n\tstring commands( MAX_COMMANDS, ' ' ); commands.clear();\n\tstring buffer( MAX_OUTPUT_COLUMNS, ' ' ); buffer.clear();\n\tstring inputLine( MAX_INPUT_COLUMNS, ' ' ); inputLine.clear();\n\n\tstring initialString( MAX_OUTPUT_COLUMNS, ' ' );\n\tvector<string> text( MAX_OUTPUT_LINES, initialString );\n\tinitialString.clear(); text.clear();\n\n\tdebug( cout << \"Initialized buffers...\" << endl; );\n\n\t// Read input and copy input text, one line at a time.\n\tgetline( cin, inputLine );\n\n\tcheckAndOutputError();\n\n\tif ( inputLine.compare(END_OF_TEXT_INDICATOR) == 0 ) {\n\t\t// Input text is empty, so there is no text to modify. Notify user and exit.\n\t\tcout << \"Notice: no input text has been read, exiting...\" << endl;\n\t\texit(EXIT_SUCCESS);\t\t\n\t}\n\n\tdo {\n\t\tif ( numLines(text) < MAX_INPUT_LINES ) {\n\t\t\tif ( inputLine.length() > MAX_INPUT_COLUMNS ) {\n\t\t\t\t// Truncate excess characters before copying input line.\n\t\t\t\tinputLine.erase(MAX_INPUT_COLUMNS);\n\t\t\t\t// Notify that at least one input line exceeds the maximum number of characters allowed.\n\t\t\t\tcout << \"Warning: maximum number of characters per line exceeded! Only the first \"\n\t\t\t\t     << MAX_INPUT_COLUMNS\n\t\t\t\t\t << \" characters on line \"\n\t\t\t\t\t << ( numLines(text) + 1 )\n\t\t\t\t\t << \" will be kept...\"\n\t\t\t\t\t << endl;\n\t\t\t}\n\t\t\ttext.push_back( inputLine.append(\"\\n\") );\n\t\t}\n\t\tgetline(cin, inputLine);\n\t} while ( cin.good() and inputLine.compare(END_OF_TEXT_INDICATOR) != 0 );\n\n\tcheckAndOutputError();\n\t// else: input text has been copied successfully.\n\n\tif ( numLines(text) > MAX_INPUT_LINES ) {\n\t\ttext.erase( text.begin() + MAX_INPUT_LINES, text.end() );\n\t\t// Notify that excess input lines have been omitted.\n\t\tcout << \"Warning: maximum number of input lines exceeded! Continuing with first \"\n\t\t     << MAX_INPUT_LINES\n\t\t\t << \" lines...\"\n\t\t\t << endl;\n\t}\n\n\tdebug(\n\t\tcout << \"Successfully read input text...\" << endl;\n\t\tprintText( text, numLines(text) );\n\t);\n\n\t// Now copy commands list.\n\tgetline( cin, inputLine );\n\n\tcheckAndOutputError();\n\n\t// If there are multiple characters on one line,\n\t// just take the first character and ignore the rest.\n\tif ( !inputLine.empty() and inputLine[0] == END_OF_COMMANDS_INDICATOR ) {\n\t\t// No commands to modify input, so just print text and exit.\n\t\tprintText( text, numLines(text) );\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\tdo {\n\t\tif ( !inputLine.empty() ) commands.append( &inputLine[0] );\n\t\tdo { getline(cin, inputLine); } while ( inputLine.empty() );\n\t} while ( cin.good() and inputLine[0] != END_OF_COMMANDS_INDICATOR );\n\n\tcheckAndOutputError();\n\t// else: commands list has been copied successfully.\n\n\tif ( commands.length() > MAX_COMMANDS ) {\n\t\t// Truncate excess commands and notify that excess commands have been omitted.\n\t\tcommands.erase(MAX_COMMANDS);\n\t\tcout << \"Warning: maximum number of commands exceeded! Continuing with first \"\n\t\t     << MAX_COMMANDS\n\t\t\t << \" commands...\"\n\t\t\t << endl;\n\t}\n\n\tdebug(\n\t\tcout << \"Successfully read commands list...\" << endl;\n\t\tcout << commands << endl;\n\t);\n\n\t// Read commands and modify text.\n\tint currentLine = 0, currentColumn = 0; // serves as \"pointer\" to text.\n\tint currentCommand = 0;\n\n\tdo {\n\t\tswitch ( commands[currentCommand] ) {\n\t\t\tcase 'a':\n\t\t\t\t// Move the cursor to the first character of the current line.\n\t\t\t\tcurrentColumn = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\t// Move the cursor to the end-of-line of the current line.\n\t\t\t\tcurrentColumn = text[currentLine].find(\"\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\t// Move the cursor to the first character of the next upper line, if it exists.\n\t\t\t\t// If there is no line above the current line, move the cursor to the first character of the current line.\n\t\t\t\tif ( currentLine > 0 ) currentLine--;\n\t\t\t\tcurrentColumn = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\t// Move the cursor to the first character of the next lower line, if it exists.\n\t\t\t\t// If there is no line below the current line, move the cursor to the first character of the current line.\n\t\t\t\tif ( currentLine < numLines(text) - 1 ) currentLine++;\n\t\t\t\tcurrentColumn = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\t// Move the cursor by one character to the right, unless the cursor points out the end-of-line.\n\t\t\t\t// If the cursor points out the end-of-line and there is a line below the current line,\n\t\t\t\t// move the cursor to the first character of the next lower line. Otherwise, do nothing.\n\t\t\t\tif ( text[currentLine][currentColumn] != '\\n' ) {\n\t\t\t\t\tcurrentColumn++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// else: cursor points to end-of-line.\n\t\t\t\tif ( currentLine < numLines(text) - 1 ) {\n\t\t\t\t\tcurrentLine++;\n\t\t\t\t\tcurrentColumn = 0;\n\t\t\t\t}\n\t\t\t\t// else: end of text reached, so do nothing.\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\t// Move the cursor by one character to the left, unless the cursor points out the first character.\n\t\t\t\t// If the cursor points out the first character and there is a line above the current line,\n\t\t\t\t// move the cursor to the end-of-line of the next upper line. Otherwise, do nothing.\n\t\t\t\tif ( currentColumn > 0 ) {\n\t\t\t\t\tcurrentColumn--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// else: cursor points to beginning of line.\n\t\t\t\tif ( currentLine > 0 ) {\n\t\t\t\t\tcurrentLine--;\n\t\t\t\t\tcurrentColumn = text[currentLine].find(\"\\n\");\n\t\t\t\t}\n\t\t\t\t// else: beginning of text reached, so do nothing.\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\t// If the cursor points out a character, delete the character\n\t\t\t\t// (Characters and end-of-line next to the deleted character are shifted to the left).\n\t\t\t\t// If the cursor points out the end-of-line and there is a line below, the next lower line is appended\n\t\t\t\t// to the end-of-line of the current line (Lines below the current line are shifted to the upper).\n\t\t\t\t// Otherwise, do nothing.\n\t\t\t\tif ( text[currentLine][currentColumn] != '\\n' ) {\n\t\t\t\t\ttext[currentLine].erase( text[currentLine].begin() + currentColumn );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// else: cursor points to end-of-line.\n\t\t\t\tif ( currentLine < numLines(text) - 1 ) {\n\t\t\t\t\t// There is a line below, so append next line to end of current line.\n\t\t\t\t\tint currentLineForReplace = currentLine + 1;\n\t\t\t\t\ttext[currentLine].replace( currentColumn, 1, text[currentLineForReplace] );\n\n\t\t\t\t\t// Erase line.\n\t\t\t\t\ttext.erase( text.begin() + currentLineForReplace );\n\t\t\t\t}\n\t\t\t\t// else: end of text reached, so do nothing.\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\t// If the cursor points out the end-of-line and there is a line below the current line,\n\t\t\t\t// perform the command d mentioned above, and record a linefeed on the buffer.\n\t\t\t\t// If the cursor does not point out the end-of-line, cut characters between the cursor (inclusive)\n\t\t\t\t// and the end-of-line, and record them on the buffer.\n\t\t\t\t// After this operation, the cursor indicates the end-of-line of the current line.\n\t\t\t\tif ( text[currentLine][currentColumn] == '\\n' and currentLine < numLines(text) - 1 ) {\n\t\t\t\t\t// Perform \"d\".\n\t\t\t\t\t// Append next line to end of current line.\n\t\t\t\t\tint currentLineForReplace = currentLine + 1;\n\t\t\t\t\ttext[currentLine].replace( currentColumn, 1, text[currentLineForReplace] );\n\n\t\t\t\t\t// Erase line.\n\t\t\t\t\ttext.erase( text.begin() + currentLineForReplace );\n\n\t\t\t\t\t// Record a linefeed to the buffer.\n\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( text[currentLine][currentColumn] != '\\n' ) {\n\t\t\t\t\tstring stringToBuffer = text[currentLine].substr(currentColumn);\n\t\t\t\t\tstringToBuffer.erase( stringToBuffer.end() - 1 ); // remove '\\n'\n\t\t\t\t\ttext[currentLine].erase( currentColumn, stringToBuffer.length() );\n\t\t\t\t\tbuffer = stringToBuffer;\n\t\t\t\t}\n\t\t\t\t// else: end of text reached, so do nothing.\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\t// If the buffer is empty, do nothing.\n\t\t\t\t// If the buffer is holding a linefeed, insert the linefeed at the cursor.\n\t\t\t\t// The cursor moves to the first character of the new line.\n\t\t\t\t// If the buffer is holding characters, insert the characters at the cursor.\n\t\t\t\t// The cursor moves to the character or end-of-line which is originally pointed by the cursor.\n\t\t\t\tif ( buffer.empty() ) break;\n\t\t\t\tif ( buffer.compare(\"\\n\") == 0 ) {\n\t\t\t\t\tstring stringToMove = text[currentLine].substr(currentColumn);\n\t\t\t\t\tstringToMove.erase( stringToMove.end() - 1 ); // remove '\\n'\n\t\t\t\t\ttext[currentLine].erase( currentColumn, stringToMove.length() );\n\n\t\t\t\t\t// Insert new line.\n\t\t\t\t\ttext.insert( text.begin() + currentLine + 1, stringToMove.append(\"\\n\") );\n\n\t\t\t\t\t// Move cursor to new line.\n\t\t\t\t\tcurrentLine++;\n\t\t\t\t\tcurrentColumn = 0;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// else: the buffer is holding some characters.\n\n\t\t\t\t// Insert buffer at current position and update position.\n\t\t\t\ttext[currentLine].insert( currentColumn, buffer );\n\t\t\t\tcurrentColumn += buffer.length();\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\tcurrentCommand++;\n\t} while ( currentCommand < commands.length() );\n\n\tdebug( cout << \"Successfully modified text, printing...\" << endl; );\n\n\t// Print modified text.\n\tprintText( text, numLines(text) );\n\n\texit(EXIT_SUCCESS);\n}\n\n/* ==================================================================\n\tint numLines ( vector<string> text )\n\n\tReturns the number of lines in the text.\n================================================================== */\n\nint numLines ( vector<string> text ) {\n\treturn text.size();\n}\n\n/* ==================================================================\n\tvoid checkAndOutputError ()\n\n\tPrints an error message to terminal and ends program if an\n\terror has occurred.\n================================================================== */\n\nvoid checkAndOutputError () {\n\tif ( cin.eof() ) {\n\t\t// Unexpected end of input reached, exit program.\n\t\tcout << \"Unexpected end of input reached, exiting...\" << endl;\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif ( cin.fail() ) {\n\t\t// Other error occurred, exit program.\n\t\tcout << \"An unknown error occurred while reading input, exiting...\" << endl;\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\n/* ==================================================================\n\tvoid printText ( vector<string> text, int numLines )\n\n\tPrints the first *numLines* lines of text to the terminal.\n================================================================== */\n\nvoid printText ( vector<string> text, int numLines ) {\n\tif ( numLines < 1 ) return;\n\tint currentLine = 0;\n\n\tdo {\n\t\tcout << text[currentLine++];\n\t} while ( currentLine < numLines );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nstruct Emacs{\n    int line,column;\n    string buffer;\n    vector<string> text;\n \n    void editText(){\n\tfor(int i = 0 ; i < (int)text.size() ; i++){\n\t    if(isEmptyLine(i)){ text[i].empty(); }\n\t}\n    }\n \n    void order(char command){\n\teditText();\n\tswitch(command){\n            case 'a': funcA(); break;\n            case 'e': funcE(); break;\n            case 'p': funcP(); break;\n            case 'n': funcN(); break;\n            case 'f': funcF(); break;\n            case 'b': funcB(); break;\n            case 'd': funcD(); break;\n            case 'k': funcK(); break;\n            case 'y': funcY(); break;\n\t}\n    }\n \n    bool isEmptyLine(int l){\n\tfor(int i = 0 ; i < (int)text[l].size() ; i++){\n\t    if(text[l][i] != ' '){ return false; }\n\t}\n\treturn true;\n    }\n \n    void funcA(){\n\tcolumn = 0;\n    }\n   \n    void funcE(){\n\tcolumn = text[line].size();\n    }\n \n    void funcP(){\n\tif(line > 0){ line--; }\n\tcolumn = 0;\n    }\n \n    void funcN(){\n\tif(line+1 < (int)text.size()){ line++; }\n\tcolumn = 0;\n    }\n \n    void funcF(){\n\tif(column == (int)text[line].size()){\n\t    funcN();\n\t}else{\n\t    column++;\n\t}\n    }\n   \n    void funcB(){\n\tif(column == 0){\n\t    if(line != 0){\n\t\tline--;\n\t\tcolumn = text[line].size();\n\t    }\n\t}else{\n\t    column--;\n\t}\n    }\n \n    void funcD(){\n\tif(text[line].empty()){\n\t    int len = text.size();\n\t    vector<string> ntext(len-1);\n\t    for(int i = 0 ; i < line ; i++){\n\t\tntext[i] = text[i];\n\t    }\n\t    for(int i = line ; i < len-1 ; i++){\n\t\tntext[i] = text[i+1];\n\t    }\n\t    text = ntext;\n\t    return;\n\t}\n\tif(0 <= column && column < (int)text[line].size()){\n\t    text[line] = text[line].substr(0,column) + text[line].substr(column+1);\n\t}else{\n\t    int len = text.size();\n\t    if(line+1 < len){\n\t\tvector<string> ntext(len-1);\n\t\tfor(int i = 0 ; i < line-1 ; i++){\n\t\t    ntext[i] = text[i];\n\t\t}\n\t\tntext[line] = text[line] + text[line+1];\n\t\tfor(int i = line+2 ; i < len ; i++){\n\t\t    ntext[i-1] = text[i];\n\t\t}\n\t\ttext = ntext;\n\t    }\n\t}\n    }\n \n    void funcK(){\n\tint len = text[line].size();\n\tif(text[line].empty()){\n\t    buffer = \"\\n\";\n\t    int len = text.size();\n\t    vector<string> ntext(len-1);\n\t    for(int i = 0 ; i < line ; i++){\n\t\tntext[i] = text[i];\n\t    }\n\t    for(int i = line ; i < len-1 ; i++){\n\t\tntext[i] = text[i+1];\n\t    }\n\t    text = ntext;\n\t    return;\n\t}\n\tif(column == len){\n\t    int len2 = text.size();\n\t    if(line+1 < len2){\n\t\tbuffer = \"\\n\";\n\t\tvector<string> ntext(len2-1);\n\t\tfor(int i = 0 ; i < line ; i++){\n\t\t    ntext[i] = text[i];\n\t\t}\n\t\tntext[line] = text[line] + text[line+1];\n\t\tfor(int i = line+1 ; i < len2-1 ; i++){\n\t\t    ntext[i] = text[i+1];\n\t\t}\n\t\ttext = ntext;\n\t    }\n\t}else{\n\t    buffer.clear();\n\t    for(int i = column ; i < len ; i++){\n\t\tbuffer += text[line][i];\n\t    }\n\t    text[line].resize(column);\n\t}\n    }\n \n    void funcY(){\n\tif(buffer.empty()){ return; }\n\tif(buffer == \"\\n\"){\n\t    string str = text[line];\n\t    string str2 = str.substr(column);\n\t    text[line] = str.substr(0,column);\n\t    int size = text.size();\n\t    text.resize(size+1);\n\t    for(int i = size ; i > line+1 ; i--){\n\t\ttext[i] = text[i-1];\n\t    }\n\t    text[line+1] = str2;\n\t    funcN();\n\t}else{\n\t    string str = text[line];\n\t    str = str.substr(0,column) + buffer + str.substr(column);\n\t    text[line] = str;\n\t    column += buffer.size();\n\t}\n    }\n \n    void print(){\n\tint len = text.size();\n\tfor(int i = 0 ; i < len ; i++){\n\t    cout << text[i] << endl;\n\t}\n    }\n};\n \nint main(){\n    Emacs emacs;\n    string str;\n    while(getline(cin,str), str != \"END_OF_TEXT\"){\n\temacs.text.push_back(str);\n    }\n    emacs.line = emacs.column = 0;\n    char command;\n    while(cin >> command, command != '-'){\n\temacs.order(command);\n    }\n    emacs.print();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int x=0;\n  list<string> s;\n  string t,b;\n  while(getline(cin,t)&&t!=\"END_OF_TEXT\")\n    s.push_back(t);\n  list<string>::iterator y=s.begin();\n  char c;\n  while(cin>>c&&c!='-'){\n    switch(c){\n    case 'a':\n      x=0;\n      break;\n    case 'e':\n      x=(*y).length();\n      break;\n    case 'p':\n      x=0;\n      if(y!=s.begin())\n\ty--;\n      break;\n    case 'n':\n      x=0;\n      y++;\n      if(y==s.end())\n\ty--;\n      break;\n    case 'f':\n      if(x==(int)(*y).length()){\n\ty++;\n\tif(y==s.end())\n\t  y--;\n\telse\n\t  x=0;\n      }else{\n\tx++;\n      }\n      break;\n    case 'b':\n      if(x){\n\tx--;\n      }else{\n\tif(y!=s.begin()){\n\t  y--;\n\t  x=(*y).length();\n\t}\n      }\n    case 'd':\n      if(x==(int)(*y).length()){\n\tlist<string>::iterator it=y;\n\tit++;\n\tif(it!=s.end()){\n\t  (*y)+=(*it);\n\t  s.erase(it);\n\t}\n      }else{\n\t(*y).erase(x,1);\n      }\n      break;\n    case 'k':\n      if(x==(int)(*y).length()){\n\tlist<string>::iterator it=y;\n\tit++;\n\tif(it!=s.end()){\n\t  (*y)+=(*it);\n\t  s.erase(it);\n\t  b=\"\\n\";\n\t}\n      }else{\n\tb=(*y).substr(x);\n\t(*y).erase(x);\n      }\n      break;\n    case 'y':\n      if(0){\n      }else if(b==\"\"){\n      }else if(b==\"\\n\"){\n\tstring u=(*y).substr(x);\n\t(*y).erase(x);\n\ty++;\n\ty=s.insert(y,u);\n\tx=0;\n      }else{\n\t(*y).insert(x,b);\n\tx+=b.length();\n      }\n      break;\n    }\n  }\n  for(y=s.begin();y!=s.end();y++)\n    cout<<*y<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <string>\n#include <algorithm>\n\n#define DEBUG 0\n#define fprintf(...) (void)0\n\nint main() {\n  std::list<std::string> input;\n  while (true) {\n    char buf[24];\n    fgets(buf, sizeof buf, stdin);\n    std::string line=buf;\n    if (line == \"END_OF_TEXT\\n\")\n      break;\n\n    assert(line.back() == '\\n');\n    input.emplace_back(line);\n  }\n\n  std::string kbuf=\"\";\n  std::list<std::string>::iterator it=input.begin();\n  size_t cc=0;\n  while (true) {\n    char op;\n    scanf(\" %c\", &op);\n    if (op == '-')\n      break;\n\n    switch (op) {\n    case 'a':\n      cc = 0;\n      break;\n\n    case 'e':\n      cc = it->size()-1;\n      break;\n\n    case 'p':\n      cc = 0;\n      if (it != input.begin())\n        --it;\n      break;\n\n    case 'n':\n      cc = 0;\n      {\n        auto tmp=it;\n        ++tmp;\n        if (tmp != input.end())\n          it = tmp;\n      }\n      break;\n\n    case 'f':\n      if (cc+1 < it->size()) {\n        ++cc;\n      } else {\n        auto tmp=it;\n        ++tmp;\n        if (tmp != input.end()) {\n          cc = 0;\n          it = tmp;\n        }\n      }\n      break;\n\n    case 'b':\n      if (cc > 0) {\n        --cc;\n      } else if (it != input.begin()) {\n        --it;\n        cc = it->size()-1;\n      }\n      break;\n\n    case 'd':\n      if (cc+1 == it->size()) {\n        assert((*it)[cc] == '\\n');\n        {\n          auto tmp=it;\n          ++tmp;\n          if (tmp != input.end()) {\n            it->pop_back();\n            *it += *tmp;\n            input.erase(tmp);\n          }\n        }\n      } else {\n        // TLE?\n        std::string t=it->substr(0, cc);\n        t += it->substr(cc+1);\n        *it = t;\n      }\n      break;\n\n    case 'k':\n      if (cc+1 == it->size()) {\n        assert((*it)[cc] == '\\n');\n        {\n          auto tmp=it;\n          ++tmp;\n          if (tmp != input.end()) {\n            assert(it->back() == '\\n');\n            it->pop_back();\n            *it += *tmp;\n            input.erase(tmp);\n            kbuf = \"\\n\";\n          }\n        }\n      } else {\n        kbuf = it->substr(cc);\n        assert(kbuf.back() == '\\n');\n        kbuf.pop_back();  // '\\n'\n        fprintf(stderr, \"kill buffer: %s\\n\", kbuf.c_str());\n        if (cc > 0) {\n          *it = it->substr(0, cc);\n          *it += '\\n';\n        } else {\n          *it = \"\\n\";\n        }\n        //cc = it->size()-1;\n      }\n      break;\n\n    case 'y':\n      if (kbuf.empty()) break;\n\n      if (kbuf == \"\\n\") {\n        ++it;\n        input.emplace(it, \"\\n\");\n        --it;  // ??\n        cc = 0;\n      } else {\n        {\n          std::string t=\"\";\n          if (cc > 0) {\n            t += it->substr(0, cc);\n          }\n          t += kbuf;\n          //t.pop_back();\n          t += it->substr(cc);\n          *it = t;\n        }\n      }\n      break;\n    }\n\n    if (DEBUG) {\n      fprintf(stderr, \"%c: L%td C%zu\\n\", op, std::distance(input.begin(), it), cc);\n      for (const auto &s: input)\n        fprintf(stderr, \"%s\", s.c_str());  // s ~ \".*\\n\"\n    }\n  }\n\n  for (const auto &s: input)\n    printf(\"%s\", s.c_str());  // s ~ \".*\\n\"\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[110];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tif(i<110) t[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tif(row<110) col = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 && row < 110 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row < 110 && row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( row < 110 && col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else if( row < 110 ){\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( row < 110 && buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line+1 < 110 && line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\tt[row+1] = t[row].substr( col );\n\t\t\t\t\t//t[row].erase( col );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else if( row < 110 ){\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<string> vs;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nvoid printtext(vs &text,char c,int cur,int line,string buf)\n{\n\tcerr<<\"command: \"<<c<<endl;\n\tcerr<<\"cur: \"<<cur<<\", line: \"<<line<<\", buffer: \"<<buf<<endl;\n\trep(i,text.size())cerr<<text[i]<<endl;\n}\n\nint main()\n{\n\tvs text;\n\tstring tmp,buf;\n\twhile(getline(cin,tmp),tmp!=\"END_OF_TEXT\")text.pb(tmp);\n\t\n\tchar c;\n\tint cur=0,line=0;\n\twhile(cin>>c,c!='-')\n\t{\n\t\tif(c=='a')cur=0;\n\t\telse if(c=='e')cur=text[line].size();\n\t\telse if(c=='p')\n\t\t{\n\t\t\tcur=0;\n\t\t\tif(line>0)line--;\n\t\t}\n\t\telse if(c=='n')\n\t\t{\n\t\t\tcur=0;\n\t\t\tif(line<text.size()-1)line++;\n\t\t}\n\t\telse if(c=='f')\n\t\t{\n\t\t\tif(cur!=text[line].size())cur++;\n\t\t\telse if(line<text.size()-1)line++,cur=0;\n\t\t}\n\t\telse if(c=='b')\n\t\t{\n\t\t\tif(cur!=0)cur--;\n\t\t\telse if(line>0)line--,cur=text[line].size();\n\t\t}\n\t\telse if(c=='d')\n\t\t{\n\t\t\tif(cur<text[line].size())text[line].erase(text[line].begin()+cur);\n\t\t\telse if(cur==text[line].size()&&line<text.size()-1)\n\t\t\t{\n\t\t\t\ttext[line]+=text[line+1];\n\t\t\t\ttext.erase(text.begin()+(line+1));\n\t\t\t}\n\t\t}\n\t\telse if(c=='k')\n\t\t{\n\t\t\tif(cur<text[line].size())\n\t\t\t{\n\t\t\t\tbuf=text[line].substr(cur);\n\t\t\t\ttext[line].erase(text[line].begin()+cur,text[line].end());\n\t\t\t}\n\t\t\telse if(cur==text[line].size()&&line<text.size()-1)\n\t\t\t{\n\t\t\t\ttext[line]+=text[line+1];\n\t\t\t\ttext.erase(text.begin()+(line+1));\n\t\t\t\tbuf=\"\\n\";\n\t\t\t}\n\t\t}\n\t\telse if(c=='y')\n\t\t{\n\t\t\tif(buf.empty())continue;\n\t\t\tif(buf==\"\\n\")\n\t\t\t{\n\t\t\t\ttext.insert(text.begin()+line,text[line].substr(0,cur));\n\t\t\t\ttext[line].erase(text[line].begin()+cur,text[line].end());\n\t\t\t\tcur=0; line++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttext[line].insert(text[line].begin()+cur,all(buf));\n\t\t\t\tcur+=buf.size();\n\t\t\t}\n\t\t}\n\t\t\n\t\t//printtext(text,c,cur,line,buf);\n\t}\n\trep(i,text.size())cout<<text[i]<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[110][1100];\nchar buf[1100];\nchar in[10];\nint main(){\n\tint n=0;\n\twhile(1){\n\t\tgets(str[n]);\n\t\tif(str[n][3]=='_')break;\n\t\tn++;\n\t}\n\tint row=0;\n\tint col=0;\n\twhile(1){\n\t\tscanf(\"%s\",in);\n\t\tif(in[0]=='-')break;\n\t\tif(in[0]=='a')col=0;\n\t\tif(in[0]=='e'){\n\t\t\twhile(str[row][col]){\n\t\t\t\tcol++;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='p'){\n\t\t\tif(row)row--;\n\t\t\tcol=0;\n\t\t}\n\t\tif(in[0]=='n'){\n\t\t\tif(row<n-1)row++;\n\t\t\tcol=0;\n\t\t}\n\t\tif(in[0]=='f'){\n\t\t\tif(str[row][col])col++;\n\t\t\telse if(row<n-1){row++;col=0;}\n\t\t}\n\t\tif(in[0]=='b'){\n\t\t\tif(col)col--;\n\t\t\telse if(row){row--;col=0;\n\t\t\t\twhile(str[row][col])col++;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='d'){\n\t\t\tif(str[row][col]){\n\t\t\t\tfor(int i=col;str[row][i];i++)str[row][i]=str[row][i+1];\n\t\t\t}else if(row<n-1){\n\t\t\t\tfor(int i=0;str[row+1][i];i++){\n\t\t\t\t\tstr[row][col++]=str[row+1][i];\n\t\t\t\t\tstr[row+1][i]=0;\n\t\t\t\t}\n\t\t\t\tn--;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='k'){\n\t\t\tif(!str[row][col]){\n\t\t\t\tif(row<n-1){\n\t\t\t\t\tfor(int i=0;str[row+1][i];i++){\n\t\t\t\t\t\tstr[row][col++]=str[row+1][i];\n\t\t\t\t\t\tstr[row+1][i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tn--;\n\t\t\t\t\tbuf[0]='@';\n\t\t\t\t\tbuf[1]=0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint at=0;\n\t\t\t\tfor(int i=col;str[row][i];i++){\n\t\t\t\t\tbuf[at++]=str[row][i];\n\t\t\t\t\tstr[row][i]=0;\n\t\t\t\t}\n\t\t\t\tbuf[at]=0;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='y'){\n\t\t\tif(buf[0]){\n\t\t\t\tif(buf[0]=='@'){\n\t\t\t\t\tfor(int i=n-1;i>row;i--){\n\t\t\t\t\t\tfor(int j=0;j<1100;j++)str[i+1][j]=str[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tint at=0;\n\t\t\t\t\tfor(int i=col;str[row][i];i++){\n\t\t\t\t\t\tstr[row+1][at++]=str[row][i];\n\t\t\t\t\t\tstr[row][i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tstr[row+1][at]=0;\n\t\t\t\t\trow++;col=0;\n\t\t\t\t\tn++;\n\t\t\t\t}else{\n\t\t\t\t\tint sz=0;\n\t\t\t\t\tfor(int i=0;buf[i];i++)sz++;\n\t\t\t\t\tfor(int i=1109;i>=col;i--){\n\t\t\t\t\t\tif(i+sz>=1100)continue;\n\t\t\t\t\t\tstr[row][i+sz]=str[row][i];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0;i<sz;i++)str[row][col+i]=buf[i];\n\t\t\t\t\tcol+=sz;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)printf(\"%s\\n\",str[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\nvector<string> text;\nstring buf;\n\nint row, col;\n\nvoid func_a(){\n\tcol = 0;\n}\n\nvoid func_e(){\n\tcol = text[row].size() - 1;\n}\n\nvoid func_p(){\n\tif (row > 0) row--;\n\tfunc_a();\n}\n\nvoid func_n(){\n\tif (row < text.size() - 1) row++;\n\tfunc_a();\n}\n\nvoid func_f(){\n\tif (col < text[row].size() - 1) col++;\n\telse func_n();\n}\n\nvoid func_b(){\n\tif (col > 0) col--;\n\telse if (row > 0){\n\t\tfunc_p();\n\t\tfunc_e();\n\t}\n}\n\nvoid func_d(){\n\tif (col < text[row].size() - 1) text[row].erase(col, 1);\n\telse if (row < text.size() - 1){\n\t\ttext[row].erase(text[row].end() - 1);\n\t\ttext[row] += text[row + 1];\n\t\ttext.erase(text.begin() + row + 1);\n\t}\n}\n\nvoid func_k(){\n\tif (col < text[row].size() - 1){\n\t\tbuf = text[row].substr(col, text[row].size() - col - 1);\n\t\ttext[row].erase(col, text[row].size() - 1);\n\t\tcol = text[row].size() - 1;\n\t}\n\telse if (row < text.size() - 1){\n\t\tfunc_d();\n\t\tbuf = \"\\n\";\n\t}\n}\n\nvoid func_y(){\n\tif (!buf.empty()){\n\t\tif (buf == \"\\n\"){\n\t\t\ttext.insert(text.begin() + row + 1, text[row].substr(col, text[row].size() - 1));\n\t\t\ttext[row].erase(col, text[row].size() - 1);\n\t\t\ttext[row] += '$';\n\t\t}\n\t\telse {\n\t\t\ttext[row].insert(col, buf);\n\t\t\tcol += buf.size();\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstring in;\n\tchar cmd;\n\n\twhile (getline(cin, in), in != \"END_OF_TEXT\"){\n\t\ttext.push_back(in + '$');\n\t}\n\t\n\tcol = row = 0;\n\tbuf.clear();\n\n\twhile (cin >> cmd, cmd != '-'){\n\t\tswitch (cmd){\n\t\t  case 'a': func_a(); break;\n\t\t  case 'e':\tfunc_e(); break;\n\t\t  case 'p':\tfunc_p(); break;\n\t\t  case 'n': func_n(); break;\n\t\t  case 'f': func_f(); break;\n\t\t  case 'b':\tfunc_b(); break;\n\t\t  case 'd':\tfunc_d(); break;\n\t\t  case 'k': func_k(); break;\n\t\t  case 'y': func_y(); break;\n\t\t}\n#if 0\n\t\tprintf(\"col:%d row:%d\\n\", col, row);\n\t\tputs(\"status:\");\n\t\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\t\tcout << *it << endl;\n\t\t}\n\t\tputs(\"buffer:\");\n\t\tcout << buf << endl;\n#endif\n\t}\n\n\t\n\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\tcout << it->substr(0, it->size() - 1) << endl;\n\t}\n\n\treturn (0);"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[128];\nstring buf;\nint lines;\nvoid delete_line(int y)\n{\n    if (lines > 1)\n\t--lines;\n    for (int i = y; y < lines; ++y)\n\ts[i] = s[i + 1];\n    s[lines] = \"\";\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; --i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    while (true)\n    {\n\tstring t;\n\tgetline(cin, t);\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines++] = t;\n    }\n    if (lines == 0)\n\tlines = 1;\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    y = max(0, --y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    y = min(lines - 1, ++y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y + 1 < lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t    {\n\t\t--y;\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t\ts[y].erase(x, 1);\n\t    else if (y + 1 < lines)\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t    }\n\t    break;\n\t}\n\tcase 'k':\n\t{\n\t    if (x != s[y].size())\n\t    {\n\t\tbuf = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = s[y].size();\n\t    }\n\t    else if (y + 1 < lines)\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\ts[y + 1] = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = 0, ++y;\n\t    }\n\t    else\n\t\ts[y].insert(x, buf);\n\t    break;\n\t}\n\t}\n    }\n\n    for (int i = 0; i < lines; ++i)\n\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <list>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n\tlist<string> li;\n\tlist<string>::iterator ite;\n\tstring buffer;\n\tbool bu = false;\n\tint lc = 0;\n\n\twhile (1) {\n\t\tstring s;\n\t\tbool mo = false;\n\t\tgetline(cin, s);\n\t\tif (s == \"END_OF_TEXT\") break;\n\t\tli.push_back(s);\n\t\tite = --li.end();\n\t\tfor (int j = 0; j < (*ite).size(); ++j) {\n\t\t\tif ((*ite)[j] != ' ') {\n\t\t\t\tmo = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 0; j < (*ite).size(); ++j) {\n\t\t\tif ((*ite)[j] != ' ') {\n\t\t\t\tprintf(\"%c\\n\", (*ite)[j]);\n\t\t\t}\n\t\t}\n\t\tif (!mo) { s = \"\"; }\n\t}\n\tite = li.begin(); lc = 0;\n\twhile (1) {\n\t\tchar c;\n\t\tcin >> c;\n\t\tif (c == '-') break;\n\t\tswitch (c) {\n\t\tcase 'a': lc = 0; break;\n\t\tcase 'e': lc = (*ite).size(); break;\n\t\tcase 'p': \n\t\t\tlc = 0; \n\t\t\tif (ite != li.begin()) --ite; break;\n\t\tcase 'n': \n\t\t\tlc = 0;\n\t\t\tif (ite != --li.end()) ++ite; break;\n\t\tcase 'f': \n\t\t\tif ((*ite).size() != lc) ++lc; \n\t\t\telse if((*ite).size() == lc && ite != --li.end()){\n\t\t\t\t++ite; lc = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b': \n\t\t\tif (lc != 0) --lc;\n\t\t\telse if(lc == 0 && ite != --li.begin()){\n\t\t\t\t--ite; \n\t\t\t\tlc = (*ite).size();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd': \n\t\t\tif ((*ite)[lc] != ' ') {\n\t\t\t\t(*ite).erase((*ite).begin() + lc);\n\t\t\t}\n\t\t\telse if ((*ite).size() == lc && ite != --li.end()) {\n\t\t\t\t(*ite) += (*++ite);\n\t\t\t\tli.erase(ite);\n\t\t\t\t--ite;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'k': \n\t\t\tif ((*ite).size() == lc && ite != --li.end()) {\n\t\t\t\t(*ite) += (*++ite);\n\t\t\t\tli.erase(ite);\n\t\t\t\t--ite;\n\t\t\t\tbuffer = \"\"; bu = true;\n\t\t\t\tlc = (*ite).size();\n\t\t\t}\n\t\t\telse if ((*ite).size() != lc){\n\t\t\t\tbuffer = (*ite).substr(lc, (*ite).size());\n\t\t\t\t(*ite).erase(lc, (*ite).size());\n\t\t\t\tbu = true;\n\t\t\t\tlc = (*ite).size();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'y': \n\t\t\tif (bu) {\n\t\t\t\tif (buffer == \"\") {\n\t\t\t\t\tli.insert(ite,(*ite).substr(lc, (*ite).size()));\n\t\t\t\t\tlc = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t(*ite).insert(lc, buffer);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (list<string>::iterator i = li.begin(); i != li.end(); ++i) {\n\t\tcout << *i << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main(){\n\tstring str[1000];\n\tstring s;\n\tint size = 0;\n\twhile(getline(cin,s)){\n\t\tif(s == \"END_OF_TEXT\") break;\n\t\tstr[size++] = s;\n\t}\n\tchar ch;\n\tstring buf = \"\";\n\tint line = 0, pos = 0;\n\twhile(cin >> ch){\n\t\tif(ch == '-') break;\n\t\tif(ch == 'a') pos = 0;\n\t\tif(ch == 'e') pos = str[line].size();\n\t\tif(ch == 'p'){\n\t\t\tpos = 0;\n\t\t\tif(line!=0) line--;\n\t\t}\n\t\tif(ch == 'n'){\n\t\t\tpos = 0;\n\t\t\tif(line+1!=size) line++;\n\t\t}\n\t\tif(ch == 'f'){\n\t\t\tif(pos != str[line].size()) pos++;\n\t\t\telse if(line+1!=size) { pos = 0; line++; }\n\t\t}\n\t\tif(ch == 'b'){\n\t\t\tif(pos != 0) pos--;\n\t\t\telse if(line!=0) { line--; pos = str[line].size(); }\n\t\t}\n\t\tif(ch == 'd'){\n\t\t\tif(pos != str[line].size()){\n\t\t\t\tstr[line] = str[line].substr(0,pos) + str[line].substr(pos+1);\n\t\t\t} else if(line+1!=size){\n\t\t\t\tstr[line] = str[line] + str[line+1];\n\t\t\t\tfor(int i=line+1;i+1<size;i++){\n\t\t\t\t\tstr[i] = str[i+1];\n\t\t\t\t}\n\t\t\t\tstr[size-1] = \"\";\n\t\t\t\tsize--;\n\t\t\t}\n\t\t}\n\t\tif(ch == 'k'){\n\t\t\tif(pos == str[line].size() && line+1!=size){\n\t\t\t\tstr[line] = str[line] + str[line+1];\n\t\t\t\tfor(int i=line+1;i+1<size;i++){\n\t\t\t\t\tstr[i] = str[i+1];\n\t\t\t\t}\n\t\t\t\tstr[size-1] = \"\";\n\t\t\t\tsize--;\n\t\t\t\tbuf = \"IS_BREAK_LINE\";\n\t\t\t\tpos = str[line].size();\n\t\t\t}\n\t\t\telse if(pos < str[line].size()){\n\t\t\t\tbuf = str[line].substr(pos);\n\t\t\t\tstr[line] = str[line].substr(0,pos);\n\t\t\t}\n\t\t}\n\t\tif(ch == 'y'){\n\t\t\tif(buf == \"IS_BREAK_LINE\"){\n\t\t\t\tfor(int i=size-1;i>=line+1;i--){\n\t\t\t\t\tstr[i+1] = str[i];\n\t\t\t\t}\n\t\t\t\tsize++;\n\t\t\t\tstr[line+1] = str[line].substr(pos);\n\t\t\t\tstr[line] = str[line].substr(0,pos);\n\t\t\t\tline++;\n\t\t\t\tpos = 0;\n\t\t\t} else if(buf != \"\"){\n\t\t\t\tstr[line] = str[line].substr(0,pos) + buf + str[line].substr(pos);\n//\t\t\t\tpos += buf.size();\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tcout << line << \" \" << pos << endl;\n\t\tfor(int i=0;i<size;i++){\n\t\t\tcout << str[i] << endl;\t\n\t\t}\n\t\tputs(\"\");\n\t\t*/\n\t}\n\tfor(int i=0;i<size;i++){\n\t\tcout << str[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nint main(){\n  char str[128][1024],c,buf[1024];\n  string input;\n  int i,j,now_x,now_y,y_max;\n\n  memset(str,0,sizeof(str));\n  memset(buf,0,sizeof(buf));\n  for(i=0;getline(cin,input);i++){\n    if(input==\"END_OF_TEXT\")break;\n    strcpy(str[i],input.c_str());\n  }\n  y_max=i-1;\n  now_x=now_y=0;\n  for(;scanf(\" %c \",&c),c!='-';){\n    if(c=='a') //¶°¿Ùð»ÝÌsÌæª\n      {\n        now_x=0;\n      }\n    else if(c=='e') //¶°¿Ùð»ÝÌsÌs\n      {\n        now_x=strlen(str[now_y]);\n      }\n    else if(c=='p') //ãÉsª êÎ¶°¿ÙðãÌsÌæªAÈ­Äàæª\n      {\n        if(now_y>0)now_y--;\n        now_x=0;\n      }\n    else if(c=='n') //ºÉsª ``\n      {\n        if(now_y<y_max)now_y++;\n        now_x=0;\n      }\n    else if(c=='f') //¶°¿ÙªsÅÈ¢Æ«EÉÚ®AsºÉsª éÆ«ºÌsÌæªAÈ¢Æ«Í½àµÈ¢\n      {\n        if(now_x!=strlen(str[now_y]))now_x++;\n        else{\n          if(now_y<y_max)now_y++,now_x=0;\n        }\n      }\n    else if(c=='b') //¶°¿Ùªæª¶ÅÈ¢Èç¶°¿Ùð¶ÉÚ®AæªãÉsª``\n      {\n        if(now_x>0)now_x--;\n        else{\n          if(now_y>0)now_y--,now_x=strlen(str[now_y]);\n        }\n      }\n    else if(c=='d')//¶°¿Ùª¶ðw·êíAí³ê½¶ÌE¤Í¶É¼ÌÄ``\n      {\n        if(now_x!=strlen(str[now_y])){\n          for(i=now_x;i<strlen(str[now_y]);i++)str[now_y][i]=str[now_y][i+1];\n        }\n        else{//¶°¿ÙªsÌÆ«\n          if(now_y<y_max){\n            strcat(str[now_y],str[now_y+1]);\n            y_max=now_y;\n            for(i=now_y+1;i<127;i++){\n              strcpy(str[i],str[i+1]);\n              if(str[i]!=0)y_max=i;\n            }\n          }\n        }\n      }\n    else if(c=='k') //\n      {\n        if(now_x==strlen(str[now_y])){\n          if(now_y<y_max){\n            strcat(str[now_y],str[now_y+1]);\n            y_max=now_y;\n            for(i=now_y+1;i<127;i++){\n              strcpy(str[i],str[i+1]);\n              if(str[i][0]!=0)y_max=i;\n            }\n          }\n          buf[0]='\\n'; buf[1]=0;\n        }else{\n          strcpy(buf,str[now_y]+now_x);\n          str[now_y][now_x]=0;\n          now_x=strlen(str[now_y]);\n          \n        }\n      }\n    else if(c=='y') //\n      {\n        if(buf[0]!=0){\n          if(buf[0]=='\\n'){\n            for(i=126;i>now_y;i--)strcpy(str[i+1],str[i]);\n            strcpy(str[now_y+1],str[now_y]+now_x);\n            str[now_y][now_x]=0;\n            now_y++; now_x=0;\n            y_max++;\n          }else{\n            char tmp[1024];\n            strcpy(tmp,str[now_y]+now_x);\n            for(i=now_x,j=0;j<strlen(buf);)str[now_y][i++]=buf[j++];\n            str[now_y][i]=0;\n            now_x=i;\n            strcat(str[now_y],tmp);\n            \n          }\n        }\n        //memset(buf,0,sizeof(buf));\n      }\n    //printf(\"y_max:%d\\n\",y_max);\n    //for(i=0;i<=y_max;i++)printf(\"%d:%s\\n\",i,str[i]);\n    //printf(\"%c-----------------now_x:%d , now_y:%d , y_max:%d\\n\",c,now_x,now_y,y_max);\n  }\n  for(i=0;i<=y_max;i++)puts(str[i]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[128];\nstring buf;\nint lines;\nvoid delete_line(int y)\n{\n    for (int i = y; i < lines; ++i)\n\ts[i] = s[i + 1];\n\n    if (lines > 1)\n\t--lines;\n    s[lines] = \"\";\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; --i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    while (true)\n    {\n\tstring t;\n\tgetline(cin, t);\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines++] = t;\n    }\n    if (lines == 0)\n\tlines = 1;\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    y = max(0, --y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    y = min(lines - 1, ++y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y + 1 < lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t    {\n\t\t--y;\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t\ts[y].erase(x, 1);\n\t    else if (y + 1 < lines)\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t    }\n\t    break;\n\t}\n\tcase 'k':\n\t{\n\t    if (x != s[y].size())\n\t    {\n\t\tbuf = s[y].substr(x);\n\t\ts[y].erase(x);\n\t    }\n\t    else if (y + 1 < lines)\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\ts[y + 1] = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = 0, ++y;\n\t    }\n\t    else\n\t    {\n\t\ts[y].insert(x, buf);\n\t\tx += buf.size();\n\t    }\n\t    break;\n\t}\n\t}\n    }\n\n    for (int i = 0; i < lines; ++i)\n\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring buffer[500];\nstring killbuff;\nint lcnt,cury,curx;\n\nvoid exec_command(string com) {\n    if(com == \"a\") curx = 0;\n    else if(com == \"e\") curx = buffer[cury].length()-1;\n    else if(com == \"p\") {\n        curx = 0;\n        if(cury > 0) cury--;\n    }else if(com == \"n\") {\n        curx = 0;\n        if(cury < lcnt-1) cury++;\n    }else if(com == \"f\") {\n        if(buffer[cury][curx] != '$') curx++;\n        else if(cury < lcnt-1) { curx = 0, cury++; }\n    }else if(com == \"b\") {\n        if(curx > 0) curx--;\n        else if(cury > 0) curx = buffer[--cury].length()-1;\n    }else if(com == \"d\") {\n        if(buffer[cury][curx] == '$' && cury < lcnt-1) {\n            buffer[cury] = buffer[cury].substr(0,buffer[cury].length()-1)\n                + buffer[cury+1];\n            for(int i=cury+1; i<lcnt-1; ++i) buffer[i] = buffer[i+1];\n            lcnt--;\n        }else if(buffer[cury][curx] != '$') {\n            buffer[cury] = buffer[cury].substr(0,curx)\n                + buffer[cury].substr(curx+1);\n        }\n    }else if(com == \"k\") {\n        if(buffer[cury][curx] == '$' && cury < lcnt-1) {\n            buffer[cury] = buffer[cury].substr(0,buffer[cury].length()-1)\n                + buffer[cury+1];\n            for(int i=cury+1; i<lcnt-1; ++i) buffer[i] = buffer[i+1];\n            lcnt--;\n            killbuff = \"$\";\n        }else if(buffer[cury][curx] != '$') {\n            killbuff = buffer[cury].substr(curx);\n            killbuff = killbuff.substr(0, killbuff.length()-1);\n            buffer[cury] = buffer[cury].substr(0,curx) + \"$\";\n        }\n    }else if(com == \"y\") {\n        if(killbuff != \"\") {\n            if(killbuff == \"$\") {\n                string tmp = buffer[cury].substr(curx);\n                buffer[cury] = buffer[cury].substr(0,curx) + \"$\";\n                for(int i=cury+1; i<lcnt; ++i) {\n                    string tt = buffer[i];\n                    buffer[i] = tmp;\n                    tmp = tt;\n                }\n                buffer[lcnt++] = tmp;\n            }else{\n                buffer[cury] = buffer[cury].substr(0,curx) + killbuff\n                    + buffer[cury].substr(curx);\n                curx += killbuff.length();\n            }\n        }\n    }\n}\n\nint main() {\n    lcnt = cury = curx = 0;\n    killbuff = \"\";\n    string s;\n\n    while(getline(cin, s)) {\n        if(s == \"END_OF_TEXT\") {\n            buffer[lcnt++] = \"%\";\n            break;\n        }\n        s += \"$\";\n        buffer[lcnt++] = s;\n    }\n\n    while(cin>>s) {\n        if(s == \"-\") break;\n        exec_command(s);\n    }\n\n    for(int i=0; i<lcnt-1; ++i)\n        cout<<buffer[i].substr(0, buffer[i].length()-1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nint main(){\n  string s;\n  vector<string> v;\n  char command;\n\n  while( true ){\n    getline( cin,s );\n    if( s==\"END_OF_TEXT\" ) break;\n    v.push_back( s );\n  }\n\n  unsigned int line=0, c=0;\n  string buf=\"\";\n  while( cin>>command && c!='-' ){\n    switch( command ){\n    case 'a': c=0;      break;\n    case 'e': c=v[line].length();      break;\n    case 'p': if( line>0 ) line--;  c=0;      break;\n    case 'n': if( line+1<v.size() )line++; c=0;      break;\n    case 'f':\n      if( c<v[line].length() ) ++c;\n      else if( line+1<v.size() ){line++;c=0;  }      break;\n    case 'b':\n      if( c>0 ) --c;\n      else if( line>0 ){ c=v[--line].length(); }     break;\n    case 'd':\n      if( c<v[line].length() ) v[line].erase( c,1 );\n      else if( line+1<v.size() ){\n\tv[line] = v[line] + v[line+1];\n\tv.erase( v.begin()+line+1 );\n      }\n      break;\n    case 'k':\n      if( c==v[line].length() ){\n\tif( line+1<v.size() ){\n\t  v[line] = v[line] + v[line+1];\n\t  v.erase( v.begin()+line+1 );\n\t  buf=\"\\n\";\n\t}\n      }else{\n\tbuf = v[line].substr( c );\n\tv[line] = v[line].substr( 0,c );\n      }\n      break;\n    case 'y':\n      if( buf==\"\\n\" ){\n\tbuf = v[line].substr( c );\n\tv[line] = v[line].substr( 0,c );\n\tv.insert( v.begin()+line+1, buf );\n\tbuf=\"\\n\"; c=0;line++;\t\n      }else if( buf!=\"\" ){\n\tif( c<v[line].length() )\n\t  v[line] = v[line].substr( 0,c ) + buf + v[line].substr( c );\n\telse\n\t  v[line] = v[line] + buf;\n      }\n    }\n  }\n\n  for( unsigned int i=0;i<v.size();i++ )\n    cout << v[i] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 1021.cc: Emacs-like Editor\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\n/* typedef */\n\ntypedef vector<string> vs;\n\n/* global variables */\n\nvs txt;\nstring buf;\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    string s;\n    cin >> s;\n    if (s == \"END_OF_TEXT\") break;\n    txt.push_back(s);\n  }\n\n  int cx = 0, cy = 0;\n  \n  for (;;) {\n    char op;\n    cin >> op;\n    if (op == '-') break;\n\n    switch (op) {\n    case 'a':\n      cx = 0;\n      break;\n    case 'e':\n      cx = txt[cy].size();\n      break;\n    case 'p':\n      cx = 0;\n      if (cy > 0) cy--;\n      break;\n    case 'n':\n      cx = 0;\n      if (cy < txt.size() - 1) cy++;\n      break;\n    case 'f':\n      if (cx < txt[cy].size()) cx++;\n      else if (cy < txt.size() - 1) cy++, cx = 0;\n      break;\n    case 'b':\n      if (cx > 0) cx--;\n      else if (cy > 0) cy--, cx = txt[cy].size();\n      break;\n    case 'd':\n      if (cx < txt[cy].size()) txt[cy].erase(cx, 1);\n      else if (cy < txt.size() - 1) {\n\ttxt[cy] += txt[cy + 1];\n\ttxt.erase(txt.begin() + cy + 1);\n      }\n      break;\n    case 'k':\n      if (cx == txt[cy].size()) {\n\tif (cy < txt.size() - 1) {\n\t  txt[cy] += txt[cy + 1];\n\t  txt.erase(txt.begin() + cy + 1);\n\t  buf = \"\\n\";\n\t}\n      }\n      else {\n\tbuf = txt[cy].substr(cx);\n\ttxt[cy].erase(cx);\n\tcx = txt[cy].size();\n      }\n      break;\n    case 'y':\n      int bn = buf.size();\n      if (bn > 0) {\n\tif (buf == \"\\n\") {\n\t  string line = txt[cy].substr(cx);\n\t  txt[cy].erase(cx);\n\t  cy++, cx = 0;\n\t}\n\telse {\n\t  txt[cy].insert(cx, buf);\n\t  cx += bn;\n\t}\n      }\n    }\n  }\n\n  for (int i = 0; i < txt.size(); i++) cout << txt[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[111];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\tfor(int i=0 ; i<111 ; i++)\n\t\tt[i] = \"\";\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tif(i<110) t[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tif(row<110) col = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 && row < 110 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row < 110 && row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( row < 110 && col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else if( row < 110 ){\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( row < 110 && buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line+1 < 110 && line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\t//t[row+1] =\n\t\t\t\t\tif( col != t[row].size() ) t[row];//.substr( col );\n\t\t\t\t\t//t[row].erase( col );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else if( row < 110 ){\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvoid escape(string &s)\n{\n  if (s.find_first_of(\"\\n\") != string::npos)\n    s.erase(s.end()-1);\n  if (s.find_first_of(\"\\r\") != string::npos)\n    s.erase(s.end()-1);\n}\n\nint main()\n{\n  string s;\n  vector<string> line;\n  while (getline(cin, s)) {\n    escape(s);\n    if (s == \"END_OF_TEXT\")\n      break;\n    line.push_back(s);\n  }\n\n  int x = 0, y = 0;\n  string buffer = \"\";\n  while (cin >> s) {\n    if (s == \"-\")\n      break;\n\n    if (s == \"a\") {\n      x = 0;\n    } else if (s == \"e\") {\n      x = line[y].size();\n    } else if (s == \"p\") {\n      x = 0;\n      if (y > 0)\n\t--y;\n    } else if (s == \"n\") {\n      x = 0;\n      if (y != line.size()-1)\n\t++y;\n    } else if (s == \"f\") {\n      if (x < line[y].size()) {\n\t  ++x;\n      } else if (y != line.size()-1) {\n\tx = 0;\n\t++y;\n      }\n    } else if (s == \"b\") {\n      if (x > 0) {\n\t--x;\n      } else if (y > 0) {\n\t--y;\n\tx = line[y].size();\n      }\n    } else if (s == \"d\") {\n      if (x < line[y].size()) {\n\tline[y].erase(x, 1);\n      } else if (y != line.size()-1) {\n\tline[y] += line[y+1];\n\tline.erase(line.begin()+y+1);\n      }\n    } else if (s == \"k\") {\n      if (x >= line[y].size() && y != line.size()-1) {\n\tline[y] += line[y+1];\n\tline.erase(line.begin()+y+1);\n\tbuffer = \"\\n\";\n      } else if (x < line[y].size()) {\n\tbuffer = line[y].substr(x);\n\tline[y].erase(x);\n      }\n    } else if (s == \"y\" && buffer != \"\") {\n      if (buffer == \"\\n\") {\n\ts = line[y].substr(x);\n\tline[y].erase(x);\n\tline.insert(line.begin()+y+1, s);\n\tx = 0;\n\t++y;\n      } else {\n\tline[y].insert(x, buffer);\n\tx += buffer.size();\n      }\n    }\n  }\n  \n  for (unsigned int i = 0; i < line.size(); ++i)\n    cout << line[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main(){\n\tstring s[500];\n\tint line = 0;\n\tfor ( string in;cin >> in, in != \"END_OF_TEXT\"; ++line ){\n\t\ts[ line ] = in;\n\t}\n\tline--;\n\t\n\tint pX = 0;\n\tint pY = 0;\n\t\n\tstring buf;\n\tfor ( string in; cin >> in, in != \"-\"; ) {\n\t\tif ( in == \"a\" ) {\n\t\t\tpX = 0;\n\t\t} else if ( in == \"e\" ) {\n\t\t\tpX = s[ pY ].length();\n\t\t} else if ( in == \"p\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( 0 < pY ) {\n\t\t\t\t--pY;\n\t\t\t}\n\t\t} else if ( in == \"n\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( pY < line - 1 ) {\n\t\t\t\t++pY;\n\t\t\t}\n\t\t} else if ( in == \"f\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\t++pX;\n\t\t\t} else {\n\t\t\t\tif ( pY < line - 1 ) {\n\t\t\t\t\tpX = 0;\n\t\t\t\t\t++pY;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( in == \"b\" ) {\n\t\t\tif ( 0 < pX ) {\n\t\t\t\t--pX;\n\t\t\t} else {\n\t\t\t\tif ( 0 < pY ) {\n\t\t\t\t\t--pY;\n\t\t\t\t\tpX = s[ pY ].length();\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( in == \"d\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + s[ pY ].substr( pX + 1 );\n\t\t\t} else if ( pY < line - 1 ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\t--line;\n\t\t\t}\n\t\t} else if ( in == \"k\" ) {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\tbuf = s[ pY ].substr( pX );\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t\tpX = s[ pY ].length();\n\t\t\t} else if ( pY < line - 1 ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\tif ( 0 < line) {\n\t\t\t\t\t--line;\n\t\t\t\t}\n\t\t\t\tbuf = \"\\n\";\n\t\t\t}\n\t\t} else if ( in == \"y\" ) {\n\t\t\tif ( !buf.empty() ) {\n\t\t\t\tif ( buf == \"\\n\" ) {\n\t\t\t\t\tfor ( int i = line - 1; pY < i; --i ) {\n\t\t\t\t\t\ts[ i ] = s[ i - 1 ];\n\t\t\t\t\t}\n\t\t\t\t\ts[ pY + 1 ] = s[ pY ].substr( pX );\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t\t\t++line;\n\t\t\t\t} else {\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + buf + s[ pY ].substr( pX );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor ( int i = 0; i < line; ++i ) cout << s[ i ] << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint i=0,j=0;\nint line;\nstring buffer=\"\";\nvector<string> vec;\n\nvoid p(void){\n\tif(i > 0){\n\t\ti--;\n\t}\n\tj = 0;\n}\n\nvoid n(void){\n\tif(i < line - 1){\n\t\ti++;\n\t}\n\tj = 0;\n}\n\nvoid f(void){\n\tif(j < vec.at(i).length()){\n\t\tj++;\n\t}\n\telse if(j == vec.at(i).length() && i < line - 1){\n\t\ti++;\n\t\tj = 0;\n\t}\n}\n\nvoid b(void){\n\tif(j > 0){\n\t\tj--;\n\t}\n\telse if(j == 0 && i > 0){\n\t\ti--;\n\t\tj = vec.at(i).length();\n\t}\n}\n\nvoid d(void){\n\tstring s;\n\n\tif(j < vec.at(i).length()){\n\t\ts = vec.at(i);\n\t\ts.erase(s.begin() + j);\n\t}\n\telse if(j == vec.at(i).length() && i < line - 1){\n\t\ts = vec.at(i) + vec.at(i + 1);\n\t\tvec.erase(vec.begin() + i);\n\t}\n\tvec.erase(vec.begin() + i);\n\tvec.insert(vec.begin() + i, s);\n}\n\nvoid k(void){\n\tif(j == vec.at(i).length() && i < line - 1){\n\t\td();\n\t\tbuffer = \"\\n\";\n\t}\n\telse if(j < vec.at(i).length()){\n\t\tstring s = vec.at(i);\n\n\t\tbuffer = s.substr(j);\n\t\ts.erase(s.begin()+j,s.end());\n\t\tvec.erase(vec.begin() + i);\n\t\tvec.insert(vec.begin() + i, s);\n\t}\n}\n\nvoid y(void){\n\tstring s = vec.at(i);\n\n\tif(buffer == \"\\n\"){\n\t\tvec.insert(vec.begin()+i+1,s.substr(j));\n\t\ts.erase(s.begin()+j,s.end());\n\t\tvec.erase(vec.begin()+i);\n\t\tvec.insert(vec.begin()+i,s);\n\t\ti++;\n\t\tj = 0;\n\t}\n\telse if(buffer != \"\"){\n\t\ts.insert(j,buffer);\n\t\tj += buffer.length();\n\t\tvec.erase(vec.begin()+i);\n\t\tvec.insert(vec.begin()+i,s);\n\t}\n}\n\nint main(void){\n\tstring s;\n\n\tline = 0;\n\twhile(getline(cin,s) && s!=\"END_OF_TEXT\"){\n\t\tvec.push_back(s);\n\t\tline++;\n\t}\n\twhile(cin>>s && s!=\"-\"){\n\t\tswitch(s.at(0)){\n\t\tcase 'a': j=0; break;\n\t\tcase 'e': j=vec.at(i).length(); break;\n\t\tcase 'p': p(); break;\n\t\tcase 'n': n(); break;\n\t\tcase 'f': f(); break;\n\t\tcase 'b': b(); break;\n\t\tcase 'd': d(); break;\n\t\tcase 'k': k(); break;\n\t\tcase 'y': y(); break;\n\t\t}\n\t}\n\tfor(int i=0;i<vec.size();i++){\n\t\tcout<<vec.at(i)<<endl;\n\t}\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n)-1;i>=(m);--i)\n#define repc(i,n) for(int i=0;i<=(n);++i)\n#define repcn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repcd(i,n) for(int i=(n);i>=0;--i)\n#define repcnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define repc0(i,n) for(i=0;i<=(n);++i)\n#define repcn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repcd0(i,n) for(i=(n);i>=0;--i)\n#define repcnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE cout<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nstring str[100];\n\nint main() {\n\tint h = 0;\n\tIL {\n\t\tcin >> str[h];\n\t\tif (str[h] == \"END_OF_TEXT\") break;\n\t\t++h;\n\t}\n\tint x = 0, y = 0;\n\tstring com, buf = \"\";\n\tIL {\n\t\tcin >> com;\n\t\tif (com == \"a\") {\n\t\t\tx = 0;\n\t\t} else if (com == \"e\") {\n\t\t\tx = sz(str[y]);\n\t\t} else if (com == \"p\") {\n\t\t\tx = 0;\n\t\t\tif (y > 0) --y;\n\t\t} else if (com == \"n\") {\n\t\t\tx = 0;\n\t\t\tif (y < h - 1) ++y; \n\t\t} else if (com == \"f\") {\n\t\t\tif (x < sz(str[y])) ++x;\n\t\t\telse if (y < h - 1) {x = 0; ++y;}\n\t\t} else if (com == \"b\") {\n\t\t\tif (x > 0) --x;\n\t\t\telse if (y > 0) {--y; x = sz(str[y]);}\n\t\t} else if (com == \"d\") {\n\t\t\tif (x < sz(str[y])) str[y] = str[y].substr(0, x) + str[y].substr(x + 1);\n\t\t\telse if (y < h - 1) {\n\t\t\t\tstr[y] += str[y + 1];\n\t\t\t\t--h;\n\t\t\t\trepn (i, y + 1, h - 1) str[i] = str[i + 1];\n\t\t\t}\n\t\t} else if (com == \"k\") {\n\t\t\tif (x == sz(str[y])) {\n\t\t\t\tif (y < h - 1) {\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t\tstr[y] += str[y + 1];\n\t\t\t\t--h;\n\t\t\t\trepn (i, y + 1, h - 1) str[i] = str[i + 1];\n\t\t\t} else {\n\t\t\t\tbuf = str[y].substr(x);\n\t\t\t\tstr[y] = str[y].substr(0, x);\n\t\t\t\tx = sz(str[y]);\n\t\t\t}\n\t\t} else if (com == \"y\") {\n\t\t\tif (buf == \"\\n\") {\n\t\t\t\t++h;\n\t\t\t\trepn (i, y + 2, h) str[i] = str[i - 1];\n\t\t\t\tstr[y + 1] = str[y].substr(x);\n\t\t\t\tstr[y] = str[y].substr(0, x);\n\t\t\t\tx = 0;\n\t\t\t\t++y;\n\t\t\t} else if (sz(buf)  > 0) {\n\t\t\t\tstr[y] = str[y].substr(0, x) + buf + str[y].substr(x);\n\t\t\t\tx += sz(buf);\n\t\t\t}\n\t\t} else if (com == \"-\") {\n\t\t\tbreak;\n\t\t}\n\t}\n\trep (i, h) cout << str[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    list<list<char> > text;\n    for(;;){\n        string s;\n        getline(cin, s);\n        if(s == \"END_OF_TEXT\")\n            break;\n        text.push_back(list<char>(s.begin(), s.end()));\n    }\n\n    list<list<char> >::iterator it1 = text.begin();\n    list<char>::iterator it2 = it1->begin();\n    list<char> buffer;\n    bool newLine = false;\n    for(;;){\n        char c;\n        cin >> c;\n        if(c == 'a'){\n            it2 = it1->begin();\n        }else if(c == 'e'){\n            it2 = it1->end();\n        }else if(c == 'p'){\n            if(it1 != text.begin())\n                -- it1;\n            it2 = it1->begin();\n        }else if(c == 'n'){\n            ++ it1;\n            if(it1 == text.end())\n                -- it1;\n            it2 = it1->begin();\n        }else if(c == 'f'){\n            if(it2 != it1->end()){\n                ++ it2;\n            }else{\n                ++ it1;\n                if(it1 != text.end()){\n                    it2 = it1->begin();\n                }else{\n                    -- it1;\n                }\n            }\n        }else if(c == 'b'){\n            if(it2 != it1->begin()){\n                -- it2;\n            }else{\n                if(it1 != text.begin()){\n                    -- it1;\n                    it2 = it1->end();\n                }\n            }\n        }else if(c == 'd'){\n            if(it2 != it1->end()){\n                it2 = it1->erase(it2);\n            }else{\n                list<list<char> >::iterator tmp = it1;\n                ++ tmp;\n                if(tmp != text.end()){\n                    it2 = it1->insert(it2, '.');\n                    it1->splice(it1->end(), *tmp);\n                    text.erase(tmp);\n                    it2 = it1->erase(it2);\n                }\n            }\n        }else if(c == 'k'){\n            buffer.clear();\n            newLine = false;\n            if(it2 == it1->end()){\n                list<list<char> >::iterator tmp = it1;\n                ++ tmp;\n                if(tmp != text.end()){\n                    it2 = it1->insert(it2, '.');\n                    it1->splice(it1->end(), *tmp);\n                    text.erase(tmp);\n                    it2 = it1->erase(it2);\n                    newLine = true;\n                }\n            }else{\n                buffer.splice(buffer.end(), *it1, it2, it1->end());\n                it2 = it1->end();\n            }\n        }else if(c == 'y'){\n            if(newLine){\n                list<list<char> >::iterator tmp = it1;\n                ++ it1;\n                it1 = text.insert(it1, list<char>());\n                it1->splice(it1->end(), *tmp, it2, tmp->end());\n                it2 = it1->begin();\n            }else if(buffer.size() > 0){\n                list<char> tmp = buffer;\n                it1->splice(it2, tmp);\n            }\n        }else{\n            break;\n        }\n    }\n\n    it1 = text.begin();\n    do{\n        cout << string(it1->begin(), it1->end()) << endl;\n    }while(++it1 != text.end());\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<string> l;\nstring buffer;\nint X = 0 , Y = 0;\nvoid a(){ X = 0; }\nvoid e(){ X = l[Y].size()-1; }\nvoid p(){ Y = max<int>(0,Y-1) ; a(); }\nvoid n(){ Y = min<int>(l.size()-1,Y+1); a(); }\nvoid f(){ if(X != l[Y].size()-1){X++;}else if(Y != l.size()-1){n();} }\nvoid b(){ if(X != 0){X--;}else if(Y != 0){p(),e();} }\nvoid d(){\n\tif(l[Y][X] != '\\n'){\n\t\tl[Y] = l[Y].substr(0,X) + l[Y].substr(X+1);\n\t}else{\n\t\tl[Y] = Y==l.size()-1?l[Y]:l[Y].substr(0,l[Y].size()-1) + l[Y+1];\n\t\tvector<string> p;\n\t\tfor(int i = 0 ; i < l.size() ; i++){\n\t\t\tif(i != Y+1) p.push_back(l[i]);\n\t\t}\n\t\tl = p;\n\t}\n}\nvoid k(){\n\tif(l[Y][X] == '\\n'){\n\t\tif( Y != l.size()-1){\n\t\t\tbuffer = \"\\n\";\n\t\t\td();\n\t\t}\n\t\t//X = l[Y].size()-1;\n\t}else{\n\t\tbuffer = l[Y].substr(X);\n\t\tbuffer = l[Y].substr(0,buffer.size()-1);\n\t\tl[Y] = l[Y].substr(0,X) + \"\\n\";\n\t}\n}\nvoid y(){\n\tif(buffer != \"\"){\n\t\tif(buffer == \"\\n\"){\n\t\t\tvector<string> p;\n\t\t\tfor(int i = 0 ; i < l.size() ; i++){\n\t\t\t\tp.push_back(l[i]);\n\t\t\t\tif(i==Y)p.push_back(l[i].substr(X));\n\t\t\t}\n\t\t\tp[Y] = p[Y].substr(0,X) + \"\\n\";\n\t\t\tl = p;\n\t\t\tn();\n\t\t}else{\n\t\t\tl[Y].insert(X,buffer);\n\t\t\tX += buffer.size();\n\t\t}\n\t}\n}\nint main(){\n\tstring s;\n\twhile(getline(cin,s),s != \"END_OF_TEXT\"){\n\t\tl.push_back(s+\"\\n\");\n\t}\n\twhile(l.size() == 0);\n\twhile(cin >> s , s != \"-\"){\n\t\tif(s==\"a\")a();\n\t\tif(s==\"e\")e();\n\t\tif(s==\"p\")p();\n\t\tif(s==\"n\")n();\n\t\tif(s==\"f\")f();\n\t\tif(s==\"b\")b();\n\t\tif(s==\"d\")d();\n\t\tif(s==\"k\")k();\n\t\tif(s==\"y\")y();\n\t}\n\tfor(int i = 0 ; i < l.size() ; i++)\n\t\tcout << l[i];\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    list<list<char> > text;\n    for(;;){\n        string s;\n        getline(cin, s);\n        if(s == \"END_OF_TEXT\")\n            break;\n        text.push_back(list<char>(s.begin(), s.end()));\n    }\n\n    list<list<char> >::iterator it1 = text.begin();\n    list<char>::iterator it2 = it1->begin();\n    list<char> buffer;\n    bool newLine = false;\n    for(;;){\n        char c;\n        cin >> c;\n        if(c == 'a'){\n            it2 = it1->begin();\n        }else if(c == 'e'){\n            it2 = it1->end();\n        }else if(c == 'p'){\n            if(it1 != text.begin())\n                -- it1;\n            it2 = it1->begin();\n        }else if(c == 'n'){\n            ++ it1;\n            if(it1 == text.end())\n                -- it1;\n            it2 = it1->begin();\n        }else if(c == 'f'){\n            if(it2 != it1->end()){\n                ++ it2;\n            }else{\n                ++ it1;\n                if(it1 == text.end()){\n                    -- it1;\n                }else{\n                    it2 = it1->begin();\n                }\n            }\n        }else if(c == 'b'){\n            if(it2 != it1->begin()){\n                -- it2;\n            }else{\n                if(it1 != text.begin()){\n                    -- it1;\n                    it2 = it1->end();\n                }\n            }\n        }else if(c == 'd'){\n            if(it2 != it1->end()){\n                it2 = it1->erase(it2);\n            }else{\n                list<list<char> >::iterator tmp = it1;\n                ++ tmp;\n                if(tmp != text.end()){\n                    it2 = it1->insert(it2, '.');\n                    it1->splice(it1->end(), *tmp);\n                    text.erase(tmp);\n                    it2 = it1->erase(it2);\n                }\n            }\n        }else if(c == 'k'){\n            buffer.clear();\n            newLine = false;\n            if(it2 == it1->end()){\n                list<list<char> >::iterator tmp = it1;\n                ++ tmp;\n                if(tmp != text.end()){\n                    it2 = it1->insert(it2, '.');\n                    it1->splice(it1->end(), *tmp);\n                    text.erase(tmp);\n                    it2 = it1->erase(it2);\n                    newLine = true;\n                }\n            }else{\n                buffer.splice(buffer.end(), *it1, it2, it1->end());\n                it2 = it1->end();\n            }\n        }else if(c == 'y'){\n            if(newLine){\n                list<list<char> >::iterator tmp = it1;\n                ++ it1;\n                text.insert(it1, list<char>());\n                it1->splice(it1->end(), *tmp, it2, it1->end());\n                it2 = it1->begin();\n            }else if(buffer.size() > 0){\n                list<char> tmp = buffer;\n                it1->splice(it2, tmp);\n            }\n        }else{\n            break;\n        }\n    }\n\n    it1 = text.begin();\n    do{\n        cout << string(it1->begin(), it1->end()) << endl;\n    }while(++it1 != text.end());\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main()\n{\n\tstring str[300];\n\tstring b = \"???\";\n\tunsigned int y = 0, y2 = 0;\n\t\n\twhile (getline(std::cin, str[y]), str[y] != \"END_OF_TEXT\"){\n\t\ty++;\n\t}\n\ty2 = --y;\n\t\n\tchar cmd[2];\n\tunsigned int car = 0, car_y = 0;\n\t\n\twhile (scanf(\"%s\", cmd), cmd[0] != '-'){\n\t\tif (cmd[0] == 'a'){\n\t\t\tcar = 0;\n\t\t}\n\t\tif (cmd[0] == 'e'){\n\t\t\tcar = str[car_y].size();\n\t\t}\n\t\tif (cmd[0] == 'p'){\n\t\t\tif (car_y == 0){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y--;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'n'){\n\t\t\tif (car_y != y){\n\t\t\t\tcar_y++;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\t\n\t\t\telse {\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'f'){\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tcar++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tcar_y++;\n\t\t\t\t\tcar = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'b'){\n\t\t\tif (car != 0){\n\t\t\t\tcar--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != 0){\n\t\t\t\t\tcar_y--;\n\t\t\t\t\tcar = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'd'){\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tstr[car_y].erase(car, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = y - 1;\n\t\t\t\t\ty = car_y;\n\t\t\t\t\twhile (++y < y2){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y].erase();\n\t\t\t\t\t\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'k'){\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = y;\n\t\t\t\t\ty = car_y;\n\t\t\t\t\twhile (++y < y2){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y].erase();\n\t\t\t\t\t\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb = str[car_y].substr(car);\n\t\t\t\tstr[car_y].erase(car);\n\t\t\t\tcar = str[car_y].size();\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'y'){\n\t\t\tif(b != \"???\"){\n\t\t\t\tif (b[0] == '\\0'){\n\t\t\t\t\ty2 = y + 1;\n\t\t\t\t\twhile (y > car_y + 1){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y] = str[car_y].substr(car);\n\t\t\t\t\tstr[car_y].erase(car);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstr[car_y].insert(car, b);\n\t\t\t\t\tcar += b.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (unsigned int j = 0; j <= y; j++){\n\t\tcout << str[j] << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main()\n{\n\tstring str[300];\n\tstring b;\n\tb[0] = '???';\n\tint y = 0, y2 = 0;\n\t\n\twhile (getline(std::cin, str[y]), str[y] != \"END_OF_TEXT\"){\n\t\ty++;\n\t}\n\ty2 = --y;\n\t\n\tchar cmd[2];\n\tint car = 0, car_y = 0;\n\t\n\twhile (scanf(\"%s\", cmd), cmd[0] != '-'){\n\t\tif (cmd[0] == 'a'){\n\t\t\tcar = 0;\n\t\t}\n\t\tif (cmd[0] == 'e'){\n\t\t\tcar = str[car_y].size();\n\t\t}\n\t\tif (cmd[0] == 'p'){\n\t\t\tif (car_y == 0){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y--;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'n'){\n\t\t\tif (car_y != y){\n\t\t\t\tcar_y++;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\t\n\t\t\telse {\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'f'){\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tcar++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tcar_y++;\n\t\t\t\t\tcar = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'b'){\n\t\t\tif (car != 0){\n\t\t\t\tcar--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != 0){\n\t\t\t\t\tcar_y--;\n\t\t\t\t\tcar = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'd'){\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tstr[car_y].erase(car, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = y - 1;\n\t\t\t\t\ty = car_y;\n\t\t\t\t\twhile (++y < y2){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y].erase();\n\t\t\t\t\t\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'k'){\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = y;\n\t\t\t\t\ty = car_y;\n\t\t\t\t\twhile (++y < y2){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y].erase();\n\t\t\t\t\t\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb = str[car_y].substr(car);\n\t\t\t\tstr[car_y].erase(car);\n\t\t\t\tcar = str[car_y].size();\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'y'){\n\t\t\tif(b != \"???\"){\n\t\t\t\tif (b[0] == '\\0'){\n\t\t\t\t\ty2 = y + 1;\n\t\t\t\t\twhile (y > car_y + 1){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y] = str[car_y].substr(car);\n\t\t\t\t\tstr[car_y].erase(car);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstr[car_y].insert(car, b);\n\t\t\t\t\tcar += b.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int j = 0; j <= y; j++){\n\t\tcout << str[j] << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <list>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n\tlist<string> li;\n\tlist<string>::iterator ite;\n\tstring buffer;\n\tbool bu = false;\n\tint lc = 0;\n\n\twhile (1) {\n\t\tstring s;\n\t\tbool mo = false;\n\t\tgetline(cin, s);\n\t\tif (s == \"END_OF_TEXT\") break;\n\t\tli.push_back(s);\n\t\tite = --li.end();\n\t\tfor (int j = 0; j < (*ite).size(); ++j) {\n\t\t\tif ((*ite)[j] != ' ') {\n\t\t\t\tmo = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 0; j < (*ite).size(); ++j) {\n\t\t\tif ((*ite)[j] != ' ') {\n\t\t\t\tprintf(\"%c\\n\", (*ite)[j]);\n\t\t\t}\n\t\t}\n\t\tif (!mo) { s = \"\"; }\n\t}\n\tite = li.begin(); lc = 0;\n\twhile (1) {\n\t\tchar c;\n\t\tcin >> c;\n\t\tif (c == '-') break;\n\t\tswitch (c) {\n\t\tcase 'a': lc = 0; break;\n\t\tcase 'e': lc = (*ite).size(); break;\n\t\tcase 'p': \n\t\t\tlc = 0; \n\t\t\tif (ite != li.begin()) --ite; break;\n\t\tcase 'n': \n\t\t\tlc = 0;\n\t\t\tif (ite != --li.end()) ++ite; break;\n\t\tcase 'f': \n\t\t\tif ((*ite).size() != lc) ++lc; \n\t\t\telse if((*ite).size() == lc && ite != --li.end()){\n\t\t\t\t++ite; lc = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b': \n\t\t\tif (lc != 0) --lc;\n\t\t\telse if(lc == 0 && ite != --li.begin()){\n\t\t\t\t--ite; \n\t\t\t\tlc = (*ite).size();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd': \n\t\t\tif ((*ite)[lc] != ' ') {\n\t\t\t\t(*ite).erase((*ite).begin() + lc);\n\t\t\t}\n\t\t\telse if ((*ite).size() == lc && ite != --li.end()) {\n\t\t\t\t(*ite) += (*++ite);\n\t\t\t\tli.erase(ite);\n\t\t\t\t--ite;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'k': \n\t\t\tif ((*ite).size() == lc && ite != --li.end()) {\n\t\t\t\t(*ite) += (*++ite);\n\t\t\t\tli.erase(ite);\n\t\t\t\t--ite;\n\t\t\t\tbuffer = \"\"; bu = true;\n\t\t\t\tlc = (*ite).size();\n\t\t\t}\n\t\t\telse if ((*ite).size() != lc){\n\t\t\t\tbuffer = (*ite).substr(lc, (*ite).size());\n\t\t\t\t(*ite).erase(lc, (*ite).size());\n\t\t\t\tbu = true;\n\t\t\t\tlc = (*ite).size();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'y': \n\t\t\tif (bu) {\n\t\t\t\tif (buffer == \"\") {\n\t\t\t\t\tli.insert(ite,(*ite).substr(lc, (*ite).size()));\n\t\t\t\t\tlc = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t(*ite).insert(lc, buffer);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (list<string>::iterator i = li.begin(); i != li.end(); ++i) {\n\t\tcout << *i << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\tvector<string> edit;\n\twhile(true){\n\t\tstring s;\tcin>>s;\n\t\tif(s==\"END_OF_TEXT\")\tbreak;\n\t\tedit.push_back(s+'\\n');\n\t}\n\tint tr=0,tc=0;\n\tstring buff=\"\";\n\twhile(true){\n\t\tchar c;\tcin>>c;\n\t\tif(c=='-')\tbreak;\n\t\tif(c=='a')\ttr=0;\n\t\telse if(c=='e')\ttr=edit[tc].size()-1;\n\t\telse if(c=='p'){\n\t\t\ttr=0;\ttc=max(0,tc-1);\n\t\t}\n\t\telse if(c=='n'){\n\t\t\ttr=0;\ttc=min((int)edit.size()-1,tc+1);\n\t\t}\n\t\telse if(c=='f'){\n\t\t\tif((int)edit[tc].size()>tr+1)\ttr++;\n\t\t\telse if((int)edit.size()>tc+1){\n\t\t\t\ttc++;\ttr=0;\n\t\t\t}\n\t\t}\n\t\telse if(c=='b'){\n\t\t\tif(tr>0)\ttr--;\n\t\t\telse if(tc>0){\n\t\t\t\ttc--;\ttr=edit[tc].size()-1;\n\t\t\t}\n\t\t}\n\t\telse if(c=='d'){\n\t\t\tif(edit[tc][tr]!='\\n')\tedit[tc].erase(edit[tc].begin()+tr);\n\t\t\telse if(tc+1<(int)edit.size()){\n\t\t\t\tedit[tc].erase(edit[tc].end()-1);\n\t\t\t\tedit[tc].insert(edit[tc].end(),edit[tc+1].begin(),edit[tc+1].end());\n\t\t\t}\n\t\t}\n\t\telse if(c=='k'){\n\t\t\tif(edit[tc][tr]=='\\n'&&tc+1<(int)edit.size()){\n\t\t\t\tbuff='\\n';\n\t\t\t\tedit[tc].erase(edit[tc].end()-1);\n\t\t\t\tedit[tc].insert(edit[tc].end(),edit[tc+1].begin(),edit[tc+1].end());\n\t\t\t}\n\t\t\telse if(tr+1<(int)edit[tc].size()){\n\t\t\t\tbuff=string(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t\tbuff.erase(buff.end()-1);\n\t\t\t\tedit[tc].erase(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t\tedit[tc]+='\\n';\n\t\t\t}\n\t\t}\n\t\telse if(c=='y'){\n\t\t\tif(buff==\"\")\tcontinue;\n\t\t\tif(buff==\"\\n\"){\n\t\t\t\tstring s(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t\tedit[tc].erase(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t\tedit[tc]=edit[tc]+'\\n';\n\t\t\t\tedit.insert(edit.begin()+tc+1,s);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint s=buff.size();\n\t\t\t\tedit[tc].insert(edit[tc].begin()+tr,buff.begin(),buff.end());\n\t\t\t\ttr+=s;\n\t\t\t}\n\t\t}\n\t}\n\tfor(string s:edit)\tcout<<s;\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nchar t[100][1000];\nint h;\nint w[100];\n\nchar tmp[100];\nint tmp_size;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nint main(){\n\n  input();\n  x=y=tmp_size=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n  }\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w[i];j++){\n      cout<<t[i][j];\n    }\n    cout<<endl;\n    //    cout<<\" \"<<w[i]<<endl;\n  }\n  //cout<<y<<' '<<x<<endl;\n  return 0;\n}\n\nvoid funcA(){x=0;}\nvoid funcE(){x=w[y];}\nvoid funcP(){ if(y>0)y--; x=0; }\nvoid funcN(){ if(y+1<h)y++; x=0; }\nvoid funcF(){ \n  if(x<w[y])x++;\n  else if(y+1<h){y++;x=0;}\n}\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=w[y];}\n}\nvoid funcD(){\n  if(x<w[y]){\n    w[y]--;\n    for(int i=x;i<w[y];i++)t[y][i]=t[y][i+1];\n    return;\n  }\n  if(y+1==h)return;\n  for(int i=0;i<w[y+1];i++)t[y][w[y]+i]=t[y+1][i];\n  w[y]+=w[y+1];\n  h--;\n  for(int i=y+1;i<h;i++){\n    w[i]=w[i+1];\n    for(int j=0;j<w[i];j++){\n      t[i][j]=t[i+1][j];\n    }\n  }\n}\n\nvoid funcK(){\n  if(x==w[y]){\n    if(y+1<h){\n      funcD();\n      tmp[0]='\\n';\n      tmp_size=1;\n    }\n  }else{\n    tmp_size=0;\n    for(int i=x;i<w[y];i++)\n      tmp[tmp_size++]=t[y][i];\n    w[y]=x;\n  }\n}\n\nvoid funcY(){\n  \n  if(tmp_size==0)return;\n  if(tmp[0]!='\\n'){\n    char z[100];\n    int zs=0;\n    for(int i=x;i<w[y];i++){\n      z[zs++]=t[y][i];\n    }\n    for(int i=x;i<x+tmp_size;i++){\n      t[y][i]=tmp[i-x];\n    }\n    w[y]+=tmp_size;\n    for(int i=x+tmp_size;i<w[y];i++){\n      t[y][i]=z[i-x-tmp_size];\n    }\n    x+=tmp_size;\n    return;\n  }\n  \n  h++;\n  for(int i=h-1;i>y+1;i--){\n    w[i]=w[i-1];\n    for(int j=0;j<w[i];j++)\n      t[i][j]=t[i-1][j];\n  }\n\n  w[y+1]=w[y]-x;\n  for(int i=0;i<w[y+1];i++){\n    t[y+1][i]=t[y][i+x];\n  }\n  w[y]=x;\n  \n  y++;\n  x=0;\n  \n}\n\nvoid input(){\n  string str;\n  h=0;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    w[h]=str.size();\n    for(int i=0;i<(int)str.size();i++)\n      t[h][i]=str[i];\n    h++;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <string> VS;\nistream& myis = cin;\nostream& myos = cout;\n\nconst string END_OF_TEXT = \"END_OF_TEXT\";\nconst string END_OF_COMMAND = \"-\";\n\n// prototypes\nVS solve( const VS& lines );\nvoid output( const VS& lines );\nvoid split( const VS& lines, VS& T, VS& C );\n\n// editor\nclass Editor {\npublic:\n    // members\n    VS T;\n    int r;\n    int c;\n    string buffer;\n    // methods\n    Editor( VS T ): T(T) {\n        r = 0;\n        c = 0;\n        buffer.clear();\n    }\n    VS get_text() { return T; }\n    void parse_command( string com ) {\n        if ( com == \"a\" ) command_a();\n        if ( com == \"e\" ) command_e();\n        if ( com == \"p\" ) command_p();\n        if ( com == \"n\" ) command_n();\n        if ( com == \"f\" ) command_f();\n        if ( com == \"b\" ) command_b();\n        if ( com == \"d\" ) command_d();\n        if ( com == \"k\" ) command_k();\n        if ( com == \"y\" ) command_y();\n        // debug\n        /*\n        myos << \"::: debug start :::\" << endl;\n        myos << \"r: \" << r << endl;\n        myos << \"c: \" << c << endl;\n        myos << \"b: \" << buffer << endl;\n        myos << \"::: debug end   :::\" << endl;\n        */\n    }\nprivate:\n    bool is_cursor_leftmost() {\n        return c == 0;\n    }\n    bool is_cursor_rightmost() {\n        return c == (int)T[r].size();\n    }\n    bool exist_next_upperline() {\n        return r - 1 >= 0;\n    }\n    bool exist_next_lowerline() {\n        return r + 1 < (int)T.size();\n    }\n    void delete_line( int n ) {\n        T.erase( T.begin() + n );\n    }\n    void delete_letter( int n ) {\n        T[r].erase( T[r].begin() + n );\n    }\n    void move_cursor_leftmost() {\n        c = 0;\n    }\n    void move_cursor_rightmost() {\n        c = T[r].size();\n    }\n    void move_cursor_up() {\n        r -= 1;\n    }\n    void move_cursor_down() {\n        r += 1;\n    }\n    void move_cursor_left() {\n        c -= 1;\n    }\n    void move_cursor_right() {\n        c += 1;\n    }\n    void command_a() {\n        /*\n          J[\\ð»ÝÌsÌæª¶ÉÚ®·éB\n        */\n        move_cursor_leftmost();\n    }\n    void command_e() {\n        /*\n          J[\\ð»ÝÌsÌsÉÚ®·éB\n        */\n        move_cursor_rightmost();\n    }\n    void command_p() {\n        /*\n          ãÉsª êÎAJ[\\ðãÌsÌæª¶ÉÚ®·éB\n          ãÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n        */\n        if ( exist_next_upperline() ) {\n            move_cursor_up();\n            move_cursor_leftmost();\n        } else {\n            move_cursor_leftmost();\n        }\n    }\n    void command_n() {\n        /*\n          ºÉsª êÎAJ[\\ðºÌsÌæª¶ÉÚ®·éB\n          ºÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n        */\n        if ( exist_next_lowerline() ) {\n            move_cursor_down();\n            move_cursor_leftmost();\n        } else {\n            move_cursor_leftmost();\n        }\n    }\n    void command_f() {\n        /*\n          J[\\ªsÉÈ¢êAJ[\\ðPÂEÉÚ®·éB\n          J[\\ªsÉ è©ÂºÉsª éêÍAJ[\\ðºÌsÌæª¶ÖÚ®·éB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( ! is_cursor_rightmost() ) {\n            move_cursor_right();\n        } else if ( is_cursor_rightmost() && exist_next_lowerline() ) {\n            move_cursor_down();\n            move_cursor_leftmost();\n        }\n    }\n    void command_b() {\n        /*\n          J[\\ªæª¶ÅÈ¢ÈçÎAJ[\\ðPÂ¶ÉÚ®·éB\n          J[\\ªæª¶Å è©ÂãÉsª éêÍAJ[\\ðãÌsÌsÖÚ®·éB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( ! is_cursor_leftmost() ) {\n            move_cursor_left();\n        } else if ( is_cursor_leftmost() && exist_next_upperline() ) {\n            move_cursor_up();\n            move_cursor_rightmost();\n        }\n    }\n    void command_d() {\n        /*\n          J[\\ª¶ðw·êÍ»Ì¶ðí·éBí³ê½¶ÌE¤Ì¶ñÍ¶ÉVtg³êéB\n          J[\\ªsðwµºÉsª éêÍAºÌsð»ÌÜÜJ[\\ÌÊuÉq°éBÈºÌsÍãÉVtg³êéB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( ! is_cursor_rightmost() ) {\n            delete_letter( c );\n        } else if ( is_cursor_rightmost() && exist_next_lowerline() ) {\n            T[r] += T[r+1];\n            delete_line( r+1 );\n        }\n    }\n    void command_k() {\n        /*\n          J[\\ªsÉ éêAºÉsª êÎAd Æ¯¶ìðµobt@ÉPÂÌüsðL^·éB\n          J[\\ªsÉÈ¢êAJ[\\ªw·¶ðÜß½E¤·×ÄÌ¶ðØèæè»êðobt@ÉL^·éB\n          J[\\Í³ÌsÌsðw·æ¤ÉÈéBSÄÌL^É¨¢Äobt@Íã«³êéB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( is_cursor_rightmost() && exist_next_lowerline() ) {\n            T[r] += T[r+1];\n            delete_line( r+1 );\n            buffer = \"\\n\";\n        } else if ( ! is_cursor_rightmost() ) {\n            buffer = T[r].substr( c );\n            T[r] = T[r].substr( 0, c );\n            move_cursor_rightmost();\n        }\n    }\n    void command_y() {\n        /*\n          obt@ªóÌêÍÈÉàµÈ¢B\n          obt@ÌàeªüsÌêAJ[\\ªw·¶Ì¼OÅüsðs¤BJ[\\ÍVµ¢sÌæª¶ÖÚ®·éB\n          obt@Ìàeª¶ñÌêAJ[\\ÌÊuÉobt@Ìàeð}ü·éB\n          J[\\ÌÊuÍàÆàÆwµÄ¢½¶Ü½ÍsÌêÖÚ®·éB\n        */\n        if ( buffer == \"\\n\" ) {\n            string tmp = T[r].substr( c );\n            T[r] = T[r].substr( 0, c );\n            T.insert( T.begin() + r + 1, tmp );\n            move_cursor_down();\n            move_cursor_leftmost();\n        } else if ( buffer != \"\" ) {\n            string left = T[r].substr( 0, c );\n            string right = T[r].substr( c );\n            T[r] = left + buffer + right;\n        }\n    }\n};\n\n// functions\n\nVS solve( const VS& lines ) {\n    VS T; // text\n    VS C; // commands\n    split( lines, T, C );\n\n    if ( T.empty() ) return T;\n\n    // edit\n    Editor editor( T );\n    for ( VS ::iterator it_i = C.begin(); it_i != C.end(); ++ it_i ) {\n        string command = *it_i;\n        editor.parse_command( command );\n    }\n    return editor.get_text();\n}\n\nvoid output( const VS& lines ) {\n    for ( VS ::const_iterator it_i = lines.begin(); it_i != lines.end(); ++ it_i ) {\n        myos << *it_i << endl;\n    }\n}\n\nvoid split( const VS& lines, VS& T, VS& C ) {\n    T.clear();\n    C.clear();\n    VS ::const_iterator it_lines = lines.begin();\n    for ( ; it_lines != lines.end(); ++ it_lines ) {\n        const string& line = *it_lines;\n        if ( line == END_OF_TEXT ) {\n            ++ it_lines;\n            break;\n        }\n        T.push_back( line );\n    }\n    if ( T.empty() ) {\n        T.push_back( \"\" );\n    }\n    for ( ; it_lines != lines.end(); ++ it_lines ) {\n        const string& line = *it_lines;\n        if ( line == END_OF_COMMAND ) {\n            break;\n        }\n        C.push_back( line );\n    }\n}\n\nint main() {\n    VS lines;\n    string line;\n    while ( getline( myis, line ) ) lines.push_back( line );\n\n    VS answer = solve( lines );\n    output( answer );\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst ll INF = 1LL << 50;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nsize_t tpos;\nsize_t lpos;\n\nvoid do_a(const vector<string> &text){\n\tlpos = 0;\n}\n\nvoid do_e(const vector<string> &text){\n\tlpos = text[tpos].size();\n}\n\nvoid do_p(const vector<string> &text){\n\tlpos = 0;\n\ttpos = max(0, (int)tpos - 1);\n}\n\nvoid do_n(const vector<string> &text){\n\tlpos = 0;\n\ttpos = min((int)tpos + 1, (int)text.size() - 1);\n}\n\nvoid do_f(const vector<string> &text){\n\tif(lpos == text[tpos].size()){\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\tlpos = 0;\n\t\t\ttpos++;\n\t\t}\n\t}else{\n\t\tlpos++;\n\t}\n}\n\nvoid do_b(const vector<string> &text){\n\tif(lpos != 0){\n\t\tlpos--;\n\t}else{\n\t\tif(tpos > 0){\n\t\t\ttpos--;\n\t\t\tlpos = text[tpos].size();\n\t\t}\n\t}\n}\n\nvoid do_d(vector<string> &text){\n\tif(lpos != text[tpos].size()){\n\t\ttext[tpos].erase(lpos, 1);\n\t}else{\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\ttext[tpos]+=text[tpos+1];\n\t\t\ttext.erase(text.begin() + tpos+1);\n\t\t}\n\t}\n}\n\nvoid do_k(vector<string> &text, string &buffer){\n\tif(lpos == text[tpos].size()){\n\t\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\tbuffer = \"\\n\";\n\t\t\tdo_d(text);\n\t\t}\n\t}else{\n\t\tbuffer = string(text[tpos].begin() + lpos, text[tpos].end());\n\t\ttext[tpos].erase(text[tpos].begin() + lpos, text[tpos].end());\n\t}\n}\n\nvoid do_y(vector<string> &text, string &buffer){\n\tif(buffer != \"\"){\n\t\tif(buffer == \"\\n\"){\n\t\t\tstring a(text[tpos].begin() + lpos, text[tpos].end());\n\t\t\ttext[tpos].erase(lpos);\n\t\t\ttext.insert(text.begin() + tpos + 1, a);\n\t\t\ttpos++;\n\t\t\tlpos = 0;\n\t\t}else{\n\t\t\tif(lpos == text[tpos].size()){\n\t\t\t\ttext[tpos] += buffer;\n\t\t\t\tlpos = text[tpos].size();\n\t\t\t}else{\n\t\t\t\ttext[tpos].insert(text[tpos].begin() + lpos, buffer.begin(), buffer.end());\n\t\t\t\tlpos += buffer.size();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid output(const vector<string> &text){\n\trep(i, (int)text.size()) cout << text[i] << endl;\n}\n\nint main(){\n\tstring line;\n\tvector<string> text;\n\tstring buffer;\n\twhile(cin >> line && line != \"END_OF_TEXT\"){\n\t\ttext.push_back(line);\n\t}\n\ttpos = lpos = 0;\n\tchar command;\n\twhile(cin >> command && command != '-'){\n\t\tswitch(command){\n\t\tcase 'a':\n\t\t\tdo_a(text);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tdo_e(text);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tdo_p(text);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tdo_n(text);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tdo_f(text);\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tdo_b(text);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdo_d(text);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tdo_k(text, buffer);\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tdo_y(text, buffer);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t\t//output(text);\n\t\t//cout << tpos << \" \" << lpos << endl;\n\t}\n\toutput(text);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n\n#define rep(i,n)      for(int i=0;i<n;++i)\n\nusing namespace std;\n\nclass editor\n{\nprivate:\n\tvector<string> lines;\n\tint cur_line, cur_col;\n\n\tstring buffer;\n\tbool buf_is_available;\n\npublic:\n\teditor()\n\t\t: cur_line(0), cur_col(0), buf_is_available(false)\n\t{\n\t}\n\n\tvoid add_line(const string &l) { lines.push_back(l); }\n\n\tint tail() { return lines[cur_line].length(); }\n\n\tbool is_first_line() { return cur_line == 0; }\n\tbool is_last_line() { return cur_line + 1 == lines.size(); }\n\tbool is_head_of_line() { return cur_col == 0; }\n\tbool is_tail_of_line() { return cur_col == tail(); }\n\n\t// a\n\tvoid move_to_head() { cur_col = 0; }\n\n\t// e\n\tvoid move_to_tail() { cur_col = tail(); }\n\n\t// p\n\tvoid move_up()\n\t{\n\t\tmove_to_head();\n\t\tif (!is_first_line()) cur_line--;\n\t}\n\n\t// n\n\tvoid move_down()\n\t{\n\t\tmove_to_head();\n\t\tif (!is_last_line()) cur_line++;\n\t}\n\n\t// f\n\tvoid forward()\n\t{\n\t\tif (is_tail_of_line())\n\t\t\tmove_down();\n\t\telse\n\t\t\tcur_col++;\n\t}\n\n\t// b\n\tvoid backward()\n\t{\n\t\tif (is_head_of_line())\n\t\t\tmove_up();\n\t\telse\n\t\t\tcur_col--;\n\t}\n\n\t// d\n\tvoid delete_char()\n\t{\n\t\tif (!is_tail_of_line())\n\t\t{\n\t\t\tlines[cur_line].erase(cur_col, 1);\n\t\t}\n\t\telse if (!is_last_line())\n\t\t{\n\t\t\tlines[cur_line] += lines[cur_line + 1];\n\t\t\tlines.erase(lines.begin() + cur_line + 1);\n\t\t}\n\t}\n\n\t// k\n\tvoid cut_tails()\n\t{\n\t\tbuffer = lines[cur_line].substr(cur_col);\n\t\tbuf_is_available = true;\n\t\tif (is_tail_of_line())\n\t\t{\n\t\t\tif (!is_last_line())\n\t\t\t{\n\t\t\t\tlines[cur_line] += lines[cur_line + 1];\n\t\t\t\tlines.erase(lines.begin() + cur_line + 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlines[cur_line] = lines[cur_line].substr(0, cur_col);\n\t\t}\n\t}\n\n\t// y\n\tvoid paste()\n\t{\n\t\tif (!buf_is_available) return;\n\n\t\tif (buffer.empty())\n\t\t{\n\t\t\tlines.insert(lines.begin() + cur_line + 1, lines[cur_line].substr(cur_col));\n\t\t\tlines[cur_line] = lines[cur_line].substr(0, cur_col);\n\t\t\tcur_line++;\n\t\t\tcur_col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlines[cur_line].insert(cur_col, buffer);\n\t\t\tcur_col += buffer.length();\n\t\t}\n\t}\n\n\tvoid print_lines()\n\t{\n\t\trep(i,lines.size())\n\t\t{\n\t\t\tcout << lines[i] << endl;\n\t\t}\n\t}\n};\n\nint main()\n{\n\teditor edit;\n\tstring line;\n\twhile (getline(cin, line), line != \"END_OF_TEXT\") edit.add_line(line);\n\n\tchar c;\n\tfor(;cin>>c, c != '-';)\n\t{\n\t\tswitch (c)\n\t\t{\n\t\tcase 'a': edit.move_to_head(); break;\n\t\tcase 'e': edit.move_to_tail(); break;\n\t\tcase 'p': edit.move_up();      break;\n\t\tcase 'n': edit.move_down();    break;\n\t\tcase 'f': edit.forward();      break;\n\t\tcase 'b': edit.backward();     break;\n\t\tcase 'd': edit.delete_char();  break;\n\t\tcase 'k': edit.cut_tails();    break;\n\t\tcase 'y': edit.paste();        break;\n\t\t}\n\t}\n\tedit.print_lines();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\tvector<string> edit;\n\twhile(true){\n\t\tstring s;\tcin>>s;\n\t\tif(s==\"END_OF_TEXT\")\tbreak;\n\t\tedit.push_back(s+'\\n');\n\t}\n\tint tr=0,tc=0;\n\tstring buff=\"\";\n\twhile(true){\n\t\tchar c;\tcin>>c;\n\t\tif(c=='-')\tbreak;\n\t\tif(c=='a')\ttr=0;\n\t\telse if(c=='e')\ttr=edit[tc].size()-1;\n\t\telse if(c=='p'){\n\t\t\ttr=0;\ttc=max(0,tc-1);\n\t\t}\n\t\telse if(c=='n'){\n\t\t\ttr=0;\ttc=min((int)edit.size()-1,tc+1);\n\t\t}\n\t\telse if(c=='f'){\n\t\t\tif((int)edit[tc].size()>tr+1)\ttr++;\n\t\t\telse if((int)edit.size()>tc+1){\n\t\t\t\ttc++;\ttr=0;\n\t\t\t}\n\t\t}\n\t\telse if(c=='b'){\n\t\t\tif(tr>0)\ttr--;\n\t\t\telse if(tc>0){\n\t\t\t\ttc--;\ttr=edit[tc].size()-1;\n\t\t\t}\n\t\t}\n\t\telse if(c=='d'){\n\t\t\tif(tr+1<(int)edit[tc].size())\tedit[tc].erase(edit[tc].begin()+tr);\n\t\t\telse if(tc+1<(int)edit.size()){\n\t\t\t\tedit[tc].erase(edit[tc].end()-1);\n\t\t\t\tedit[tc].insert(edit[tc].end(),edit[tc+1].begin(),edit[tc+1].end());\n\t\t\t\tedit.erase(edit.begin()+tc+1);\n\t\t\t}\n\t\t}\n\t\telse if(c=='k'){\n\t\t\tif(edit[tc][tr]=='\\n'&&tc+1<(int)edit.size()){\n\t\t\t\tbuff=\"\\n\";\n\t\t\t\tedit[tc].erase(edit[tc].end()-1);\n\t\t\t\tedit[tc].insert(edit[tc].end(),edit[tc+1].begin(),edit[tc+1].end());\n\t\t\t\tedit.erase(edit.begin()+tc+1);\n\t\t\t}\n\t\t\telse if(tr+1<(int)edit[tc].size()){\n\t\t\t\tbuff=string(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t\tbuff.erase(buff.end()-1);\n\t\t\t\tedit[tc].erase(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t\tedit[tc]+=\"\\n\";\n\t\t\t}\n\t\t}\n\t\telse if(c=='y'){\n\t\t\tif(buff==\"\")\tcontinue;\n\t\t\tif(buff==\"\\n\"){\n\t\t\t\tstring s(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t\tedit[tc].erase(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t\tedit[tc]=edit[tc]+'\\n';\n\t\t\t\tedit.insert(edit.begin()+tc+1,s);\n\t\t\t\ttc++;\ttr=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint s=buff.size();\n\t\t\t\tedit[tc].insert(edit[tc].begin()+tr,buff.begin(),buff.end());\n\t\t\t\ttr+=s;\n\t\t\t}\n\t\t}\n\t}\n\tfor(string s:edit)\tcout<<s;\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t,u;\nvector<char> tmp;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nint main(){\n\n  t.clear();\n  tmp.clear();\n  input();\n  x=y=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n    //cout<<y<<' '<<x<<\" ty\"<<t.size()<<endl;\n  }\n\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    t[y].erase(t[y].begin()+x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  t[y].erase(t[y].begin()+x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  t.erase(t.begin()+y+1);\n}\n\nvoid funcK(){\n  tmp.clear();\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.push_back('\\n');\n    }\n\n    //x=t[y].size()-1;\n    return;\n  }\n  int c=0;\n  for(int i=x;i+1<(int)t[y].size();i++){\n    tmp.push_back(t[y][i]);\n    c++;\n  }\n  for(int i=0;i<=c;i++)t[y].pop_back();\n  t[y].push_back('\\n');\n  reverse(tmp.begin(),tmp.end());\n  x=t[y].size()-1;\n}\n\nvoid funcY(){\n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    vector<char> z;\n    int c=0;\n    for(int i=x;i<(int)t[y].size();i++){\n      z.push_back(t[y][i]);\n      c++;\n    }\n    for(int i=0;i<=c;i++)t[y].pop_back();\n    t[y].push_back('\\n');\n    t.insert(t.begin()+y+1,z);\n    y++;\n    x=0;\n    return;\n  }\n\n  for(int i=0;i<(int)tmp.size();i++){\n    t[y].insert(t[y].begin()+x,tmp[i]);\n  }\n  funcE();\n\n}\n\nvoid input(){\n  vector<char> a;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY = 0;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n\telse return;\n}\n\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\\n\";\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring front=\"\";\n\t\tstring rear=\"\";\n\t\tfront = lines[posY].substr(0,posX);\n\t\trear = lines[posY].substr(posX,lines[posY].size()-posX);\t\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX+1);\n\n\t\tlines[posY] = front;\n\t\tdeque<string>::iterator it = lines.begin();\n\t\tadvance(it,posY);\n\t\tlines.insert(it,rear);\n\t}\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(getline(cin,str)){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(cin >> str){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\tif(str == \"d\") ctrl_d(lines);\n\t\tif(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst ll INF = 1LL << 50;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nsize_t tpos;\nsize_t lpos;\n\nvoid do_a(const vector<string> &text){\n\tlpos = 0;\n}\n\nvoid do_e(const vector<string> &text){\n\tlpos = text[tpos].size();\n}\n\nvoid do_p(const vector<string> &text){\n\tlpos = 0;\n\ttpos = max(0, (int)tpos - 1);\n}\n\nvoid do_n(const vector<string> &text){\n\tlpos = 0;\n\ttpos = min((int)tpos + 1, (int)text.size() - 1);\n}\n\nvoid do_f(const vector<string> &text){\n\tif(lpos == text[tpos].size()){\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\tlpos = 0;\n\t\t\ttpos++;\n\t\t}\n\t}else{\n\t\tlpos++;\n\t}\n}\n\nvoid do_b(const vector<string> &text){\n\tif(lpos != 0){\n\t\tlpos--;\n\t}else{\n\t\tif(tpos > 0){\n\t\t\ttpos--;\n\t\t\tlpos = text[tpos].size();\n\t\t}\n\t}\n}\n\nvoid do_d(vector<string> &text){\n\tif(lpos != text[tpos].size()){\n\t\ttext[tpos].erase(lpos, 1);\n\t}else{\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\ttext[tpos]+=text[tpos+1];\n\t\t\ttext.erase(text.begin() + tpos+1);\n\t\t}\n\t}\n}\n\nvoid do_k(vector<string> &text, string &buffer){\n\tif(lpos == text[tpos].size()){\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\tbuffer = \"\\n\";\n\t\t\tdo_d(text);\n\t\t}\n\t}else{\n\t\tbuffer = string(text[tpos].begin() + lpos, text[tpos].end());\n\t\ttext[tpos].erase(text[tpos].begin() + lpos, text[tpos].end());\n\t}\n}\n\nvoid do_y(vector<string> &text, string &buffer){\n\tif(buffer != \"\"){\n\t\tif(buffer == \"\\n\"){\n\t\t\tstring a(text[tpos].begin() + lpos, text[tpos].end());\n\t\t\ttext[tpos].erase(lpos);\n\t\t\ttext.insert(text.begin() + tpos + 1, a);\n\t\t\ttpos++;\n\t\t\tlpos = 0;\n\t\t}else{\n\t\t\tif(lpos == text[tpos].size()){\n\t\t\t\ttext[tpos] += buffer;\n\t\t\t\tlpos = text[tpos].size();\n\t\t\t}else{\n\t\t\t\ttext[tpos].insert(text[tpos].begin() + lpos, buffer.begin(), buffer.end());\n\t\t\t\tlpos += buffer.size();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid output(const vector<string> &text){\n\trep(i, (int)text.size()) cout << text[i] << endl;\n}\n\nint main(){\n\tstring line;\n\tvector<string> text;\n\tstring buffer;\n\twhile(getline(cin, line) && line != \"END_OF_TEXT\"){\n\t\ttext.push_back(line);\n\t}\n\ttpos = lpos = 0;\n\tchar command;\n\twhile(cin >> command && command != '-'){\n\t\tswitch(command){\n\t\tcase 'a':\n\t\t\tdo_a(text);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tdo_e(text);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tdo_p(text);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tdo_n(text);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tdo_f(text);\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tdo_b(text);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdo_d(text);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tdo_k(text, buffer);\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tdo_y(text, buffer);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t\t\n\t}\n\toutput(text);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<string> vs;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nvoid printtext(vs &text,char c,int cur,int line,string buf)\n{\n\tcerr<<\"command: \"<<c<<endl;\n\tcerr<<\"cur: \"<<cur<<\", line: \"<<line<<\", buffer: \"<<buf<<endl;\n\trep(i,text.size())cerr<<text[i]<<endl;\n}\n\nint main()\n{\n\tvs text;\n\tstring tmp,buf;\n\twhile(getline(cin,tmp),tmp!=\"END_OF_TEXT\")text.pb(tmp);\n\t\n\tchar c;\n\tint cur=0,line=0;\n\twhile(cin>>c,c!='-')\n\t{\n\t\tif(c=='a')cur=0;\n\t\telse if(c=='e')cur=text[line].size();\n\t\telse if(c=='p')\n\t\t{\n\t\t\tcur=0;\n\t\t\tif(line>0)line--;\n\t\t}\n\t\telse if(c=='n')\n\t\t{\n\t\t\tcur=0;\n\t\t\tif(line<text.size()-1)line++;\n\t\t}\n\t\telse if(c=='f')\n\t\t{\n\t\t\tif(cur!=text[line].size())cur++;\n\t\t\telse if(line<text.size()-1)line++,cur=0;\n\t\t}\n\t\telse if(c=='b')\n\t\t{\n\t\t\tif(cur!=0)cur--;\n\t\t\telse if(line>0)line--,cur=text[line].size();\n\t\t}\n\t\telse if(c=='d')\n\t\t{\n\t\t\tif(cur<text[line].size())text[line].erase(text[line].begin()+cur);\n\t\t\tif(cur==text[line].size()&&line<text.size()-1)\n\t\t\t{\n\t\t\t\ttext[line]+=text[line+1];\n\t\t\t\ttext.erase(text.begin()+(line+1));\n\t\t\t}\n\t\t}\n\t\telse if(c=='k')\n\t\t{\n\t\t\tif(cur<text[line].size())\n\t\t\t{\n\t\t\t\tbuf=text[line].substr(cur);\n\t\t\t\ttext[line].erase(text[line].begin()+cur,text[line].end());\n\t\t\t}\n\t\t\telse if(cur==text[line].size()&&line<text.size()-1)\n\t\t\t{\n\t\t\t\ttext[line]+=text[line+1];\n\t\t\t\ttext.erase(text.begin()+(line+1));\n\t\t\t\tbuf=\"\\n\";\n\t\t\t}\n\t\t}\n\t\telse if(c=='y')\n\t\t{\n\t\t\tif(buf.empty())continue;\n\t\t\tif(buf==\"\\n\")\n\t\t\t{\n\t\t\t\ttext.insert(text.begin()+line,text[line].substr(0,cur));\n\t\t\t\ttext[line].erase(text[line].begin()+cur,text[line].end());\n\t\t\t\tcur=0; line++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttext[line].insert(text[line].begin()+cur,all(buf));\n\t\t\t\tcur+=buf.size();\n\t\t\t}\n\t\t}\n\t\t\n\t\t//printtext(text,c,cur,line,buf);\n\t}\n\trep(i,text.size())cout<<text[i]<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <string>\n#include <algorithm>\n\n#define DEBUG 0\n#define fprintf(...) (void)0\n\nint main() {\n  std::list<std::string> input;\n  while (true) {\n    char buf[24];\n    fgets(buf, sizeof buf, stdin);\n    std::string line=buf;\n    if (line == \"END_OF_TEXT\\n\")\n      break;\n\n    assert(line.back() == '\\n');\n    input.emplace_back(line);\n  }\n\n  std::string kbuf=\"\";\n  std::list<std::string>::iterator it=input.begin();\n  size_t cc=0;\n  while (true) {\n    char op;\n    scanf(\" %c\", &op);\n    if (op == '-')\n      break;\n\n    switch (op) {\n    case 'a':\n      cc = 0;\n      break;\n\n    case 'e':\n      cc = it->size()-1;\n      break;\n\n    case 'p':\n      cc = 0;\n      if (it != input.begin())\n        --it;\n      break;\n\n    case 'n':\n      cc = 0;\n      {\n        auto tmp=it;\n        ++tmp;\n        if (tmp != input.end())\n          it = tmp;\n      }\n      break;\n\n    case 'f':\n      if (cc+1 < it->size()) {\n        ++cc;\n      } else {\n        auto tmp=it;\n        ++tmp;\n        if (tmp != input.end()) {\n          cc = 0;\n          it = tmp;\n        }\n      }\n      break;\n\n    case 'b':\n      if (cc > 0) {\n        --cc;\n      } else if (it != input.begin()) {\n        --it;\n        cc = it->size()-1;\n      }\n      break;\n\n    case 'd':\n      if (cc+1 == it->size()) {\n        assert((*it)[cc] == '\\n');\n        {\n          auto tmp=it;\n          ++tmp;\n          if (tmp != input.end()) {\n            it->pop_back();\n            *it += *tmp;\n            input.erase(tmp);\n          }\n        }\n      } else {\n        // TLE?\n        std::string t=it->substr(0, cc);\n        t += it->substr(cc+1);\n        *it = t;\n      }\n      break;\n\n    case 'k':\n      if (cc+1 == it->size()) {\n        assert((*it)[cc] == '\\n');\n        {\n          auto tmp=it;\n          ++tmp;\n          if (tmp != input.end()) {\n            assert(it->back() == '\\n');\n            it->pop_back();\n            *it += *tmp;\n            input.erase(tmp);\n          }\n        }\n        kbuf = \"\\n\";\n      } else {\n        kbuf = it->substr(cc);\n        assert(kbuf.back() == '\\n');\n        kbuf.pop_back();  // '\\n'\n        fprintf(stderr, \"kill buffer: %s\\n\", kbuf.c_str());\n        if (cc > 0) {\n          *it = it->substr(0, cc);\n          *it += '\\n';\n        } else {\n          *it = \"\\n\";\n        }\n        //cc = it->size()-1;\n      }\n      break;\n\n    case 'y':\n      if (kbuf.empty()) break;\n\n      if (kbuf == \"\\n\") {\n        ++it;\n        input.emplace(it, \"\\n\");\n        --it;  // ??\n        cc = 0;\n      } else {\n        {\n          std::string t=\"\";\n          if (cc > 0) {\n            t += it->substr(0, cc);\n          }\n          t += kbuf;\n          //t.pop_back();\n          t += it->substr(cc);\n          *it = t;\n        }\n      }\n      break;\n    }\n\n    if (DEBUG) {\n      fprintf(stderr, \"%c: L%td C%zu\\n\", op, std::distance(input.begin(), it), cc);\n      for (const auto &s: input)\n        printf(\"%s\", s.c_str());  // s ~ \".*\\n\"\n    }\n  }\n\n  for (const auto &s: input)\n    printf(\"%s\", s.c_str());  // s ~ \".*\\n\"\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY = 0;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n\telse return;\n}\n\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\\n\";\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring front=\"\";\n\t\tstring rear=\"\";\n\t\t//front = lines[posY].substr(0,posX);\n\t\t//rear = lines[posY].substr(posX,lines[posY].size()-posX);\t\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX+1);\n\n\t\tlines[posY] = front;\n\t\tdeque<string>::iterator it = lines.begin();\n\t\tadvance(it,posY);\n\t\tlines.insert(it,rear);\n\t}\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(getline(cin,str)){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(cin >> str){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\tif(str == \"d\") ctrl_d(lines);\n\t\tif(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\n\nint main()\n{\t\t\n\tvector<string> snt;\n\tstring buffer;\n\tstring cm = \"aepnfbdky-\";\n\t\n\tfor(string line; getline(cin, line) && line != \"END_OF_TEXT\"; snt.push_back(line));\n\t\n\tpint cur = mp(0, 0); // := first = x, second = y\n\tfor(char com; cin >> com && com != '-';) switch(com)\n\t{\n\t\tMSG(com);\n\t\t\t/*\n\t\t\t a\n\t\t\t J[\\ð»ÝÌsÌæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'a':\n\t\t{\n\t\t\tcur.first = 0;\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t e\n\t\t\t J[\\ð»ÝÌsÌsÉÚ®·éB\n\t\t\t */\n\t\tcase 'e':\n\t\t{\n\t\t\tcur.first = snt[cur.second].size();\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t p\n\t\t\t ãÉsª êÎAJ[\\ðãÌsÌæª¶ÉÚ®·éB\n\t\t\t ãÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'p':\n\t\t{\n\t\t\tcur.second -= cur.second != 0;\n\t\t\tcur.first = 0;\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t n\n\t\t\t ºÉsª êÎAJ[\\ðºÌsÌæª¶ÉÚ®·éB\n\t\t\t ºÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'n':\n\t\t{\n\t\t\tcur.second += cur.second + 1 != snt.size();\n\t\t\tcur.first = 0;\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t f\n\t\t\t J[\\ªsÉÈ¢êAJ[\\ðPÂEÉÚ®·éB\n\t\t\t J[\\ªsÉ è©ÂºÉsª éêÍAJ[\\ðºÌsÌæª¶ÖÚ®·éB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'f':\n\t\t{\n\t\t\tif(cur.first != snt[cur.second].size())\n\t\t\t{\n\t\t\t\tcur.first++;\n\t\t\t}\n\t\t\telse if(cur.second + 1 != snt.size())\n\t\t\t{\n\t\t\t\tcur.first = 0;\n\t\t\t\tcur.second++;\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t b\n\t\t\t J[\\ªæª¶ÅÈ¢ÈçÎAJ[\\ðPÂ¶ÉÚ®·éB\n\t\t\t J[\\ªæª¶Å è©ÂãÉsª éêÍAJ[\\ðãÌsÌsÖÚ®·éB\n\t\t\t »êÈOÌêÍ½àµÈ¢\n\t\t\t */\n\t\tcase 'b':\n\t\t{\n\t\t\tif(cur.first != 0)\n\t\t\t{\n\t\t\t\tcur.first--;\n\t\t\t}\n\t\t\telse if(cur.second != 0)\n\t\t\t{\n\t\t\t\tcur.second--;\n\t\t\t\tcur.first = snt[cur.second].size();\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t d\n\t\t\t J[\\ª¶ðw·êÍ»Ì¶ðí·éBí³ê½¶ÌE¤Ì¶ñÍ¶ÉVtg³êéB\n\t\t\t J[\\ªsðwµºÉsª éêÍAºÌsð»ÌÜÜJ[\\ÌÊuÉq°éBÈºÌsÍãÉVtg³êéB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'd':\n\t\t{\n\t\t\tif(cur.first != snt[cur.second].size())\n\t\t\t{\n\t\t\t\tstring &line = snt[cur.second];\n\t\t\t\t\n\t\t\t\tline = line.substr(0, cur.first) + line.substr(cur.first + 1);\n\t\t\t}\n\t\t\telse if(cur.second + 1 != snt.size())\n\t\t\t{\n\t\t\t\tsnt[cur.second] += snt[cur.second + 1];\n\t\t\t\t\n\t\t\t\trotate(snt.begin() + cur.second + 1, snt.begin() + cur.second + 2, snt.end());\n\t\t\t\t\n\t\t\t\tsnt.erase(snt.begin() + snt.size() - 1);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t k\n\t\t\t J[\\ªsÉ éêAºÉsª êÎAd Æ¯¶ìðµobt@ÉPÂÌüsðL^·éB\n\t\t\t J[\\ªsÉÈ¢êAJ[\\ªw·¶ðÜß½E¤·×ÄÌ¶ðØèæè»êðobt@ÉL^·éBJ[\\Í³ÌsÌsðw·æ¤ÉÈéBSÄÌL^É¨¢Äobt@Íã«³êéB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'k':\n\t\t{\n\t\t\tif(cur.first == snt[cur.second].size() && cur.second + 1 != snt.size())\n\t\t\t{\n\n\t\t\t\tsnt[cur.second] += snt[cur.second + 1];\n\n\t\t\t\trotate(snt.begin() + cur.second + 1, snt.begin() + cur.second + 2, snt.end());\n\t\t\t\t\t\n\t\t\t\tsnt.erase(snt.begin() + snt.size() - 1);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tbuffer = \"\\n\";\n\t\t\t}\n\t\t\telse if(cur.first != snt[cur.second].size())\n\t\t\t{\n\t\t\t\tbuffer = snt[cur.second].substr(cur.first);\n\t\t\t\tsnt[cur.second] = snt[cur.second].substr(0, cur.first);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t y\n\t\t\t obt@ªóÌêÍÈÉàµÈ¢B\n\t\t\t obt@ÌàeªüsÌêAJ[\\ªw·¶Ì¼OÅüsðs¤BJ[\\ÍVµ¢sÌæª¶ÖÚ®·éB\n\t\t\t obt@Ìàeª¶ñÌêAJ[\\ÌÊuÉobt@Ìàeð}ü·éB J[\\ÌÊuÍàÆàÆwµÄ¢½¶Ü½ÍsÌêÖÚ®·é\n\t\t\t */\n\t\tcase 'y':\n\t\t{\n\t\t\tif(buffer != \"\")\n\t\t\t{\n\t\t\t\tif(buffer == \"\\n\")\n\t\t\t\t{\n\t\t\t\t\tstring &line = snt[cur.second];\n\t\t\t\t\tsnt.push_back(snt[snt.size() - 1]);\n\t\t\t\t\t\n\t\t\t\t\trotate(snt.begin() + cur.second + 1, snt.begin() + snt.size() - 2, snt.begin() + snt.size() - 1);\n\t\t\t\t\tsnt[cur.second + 1] = line.substr(cur.first);\n\t\t\t\t\tline = line.substr(0, cur.first);\n\t\t\t\t\t\n\t\t\t\t\tcur.second++;\n\t\t\t\t\tcur.first = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstring &line = snt[cur.second];\n\t\t\t\t\tline = line.substr(0, cur.first) + buffer + line.substr(cur.first);\n\t\t\t\t\t\n\t\t\t\t\tcur.first += buffer.size();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trep(i, snt.size()) cout << snt[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[111];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\tfor(int i=0 ; i<111 ; i++)\n\t\tt[i] = \"\";\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tif(i<110) t[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tif(row<110) col = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 && row < 110 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row < 110 && row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( row < 110 && col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else if( row < 110 ){\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( row < 110 && buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line+1 < 110 && line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\tt[row].substr( col );\n\t\t\t\t\t//t[row+1] = ;\n\t\t\t\t\t//t[row+1] =\n\t\t\t\t\t//if( col != t[row].size() ) t[row];//.substr( col );\n\t\t\t\t\t//if(col != t[row].size() ) t[row].erase( 0 );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else if( row < 110 ){\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t,u;\nvector<char> tmp;\n\nchar ch;\nint x,y;\n\nbool input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nint main(){\n  t.clear();\n  while(1){\n    for(int i=0;i<t.size();i++)t[i].clear();\n    t.clear();\n    tmp.clear();\n    if(input()==false)break;\n    x=y=0;\n    while(1){\n      \n      cin>>ch;\n      if(ch=='a')funcA();\n      else if(ch=='e')funcE();\n      else if(ch=='p')funcP();\n      else if(ch=='n')funcN();\n      else if(ch=='f')funcF();\n      else if(ch=='b')funcB();\n      else if(ch=='d')funcD();\n      else if(ch=='k')funcK();\n      else if(ch=='y')funcY();\n      else break;\n      \n      cout<<y<<' '<<x<<\" ty\"<<t.size()<<endl;\n    }\n    u=t;\n    t=u;\n    /*\n    for(int i=0;i<t.size();i++){\n      for(int j=0;j<t[i].size();j++){\n\tcout<<t[i][j];\n      }\n    }\n    */\n    cin.ignore();\n  }\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    t[y].erase(t[y].begin()+x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  t[y].erase(t[y].begin()+x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  t.erase(t.begin()+y+1);\n}\n\nvoid funcK(){\n  tmp.clear();\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.push_back('\\n');\n    }\n    funcE();\n    return;\n  }\n  int c=0;\n  for(int i=x;i+1<(int)t[y].size();i++){\n    tmp.push_back(t[y][i]);\n    c++;\n  }\n  for(int i=0;i<=c;i++)t[y].pop_back();\n  t[y].push_back('\\n');\n  reverse(tmp.begin(),tmp.end());\n  funcE();\n}\n\nvoid funcY(){\n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    vector<char> z;\n    int c=0;\n    for(int i=x;i<(int)t[y].size();i++){\n      z.push_back(t[y][i]);\n      c++;\n    }\n    for(int i=0;i<=c;i++)t[y].pop_back();\n    t[y].push_back('\\n');\n    t.insert(t.begin()+y+1,z);\n    y++;\n    x=0;\n    return;\n  }\n\n  for(int i=0;i<(int)tmp.size();i++){\n    t[y].insert(t[y].begin()+x,tmp[i]);\n  }\n  funcE();\n\n}\n\nbool input(){\n  vector<char> a;\n  string str;\n  while(1){\n    if(getline(cin,str)==false)return false;\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n  return true;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF 1145141919\n#define MOD 1000000007\n#define ALL(a) begin((a)),end((a))\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<edge> edges;\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nstring s[1005];\nint main()\n{\n\tREP(i, 1005) s[i].clear();\n\tint h = 0;\n\tstring tmp;\n\twhile (getline(cin, tmp))\n\t{\n\t\tif (tmp == \"END_OF_TEXT\") break;\n\t\telse s[h] = tmp;\n\t\th++;\n\t}\n\tchar t;\n\tP p = P(0, 0);\n\tstring buf;\n\twhile (cin >> t)\n\t{\n\t\tint x = p.first; int y = p.second;\n\t\tif (t == '-') break;\n\t\tif (t == 'a') p.second = 0;\n\t\tif (t == 'e') p.second = s[x].size();\n\t\tif (t == 'p')\n\t\t{\n\t\t\tif (x == 0) p.second = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tp.first--;\n\t\t\t\tp.second = 0;\n\t\t\t}\n\t\t}\n\t\tif (t == 'n')\n\t\t{\n\t\t\tif (x == h-1) p.second = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tp.first++;\n\t\t\t\tp.second = 0;\n\t\t\t}\n\t\t}\n\t\tif (t == 'f')\n\t\t{\n\t\t\tif (y != s[x].size()) p.second++;\n\t\t\telse if (x != h - 1)\n\t\t\t{\n\t\t\t\tp.first++;\n\t\t\t\tp.second = 0;\n\t\t\t}\n\t\t}\n\t\tif (t == 'b')\n\t\t{\n\t\t\tif (y != 0) p.second--;\n\t\t\telse if (x != 0)\n\t\t\t{\n\t\t\t\tp.first--;\n\t\t\t\tp.second = s[p.first].size();\n\t\t\t}\n\t\t}\n\t\tif (t == 'd')\n\t\t{\n\t\t\tif (y != s[x].size()) s[x].erase(y,1);\n\t\t\telse if (x != h - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\tfor (int i = x + 1; i < h-1; i++)\n\t\t\t\t{\n\t\t\t\t\ts[i] = s[i + 1];\n\t\t\t\t}\n\t\t\t\ts[h - 1].clear();\n\t\t\t\th--;\n\t\t\t}\n\t\t}\n\t\tif (t == 'k')\n\t\t{\n\t\t\tif (y == s[x].size() && x != h - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\tfor (int i = x + 1; i < h - 1; i++)\n\t\t\t\t{\n\t\t\t\t\ts[i] = s[i + 1];\n\t\t\t\t}\n\t\t\t\ts[h - 1].clear();\n\t\t\t\th--;\n\t\t\t\tbuf = \"#\";\n\t\t\t}\n\t\t\telse if (y != s[x].size())\n\t\t\t{\n\t\t\t\tbuf = s[x].substr(y);\n\t\t\t\ts[x].erase(y);\n\t\t\t\tp.second = s[x].size();\n\t\t\t}\n\t\t}\n\t\tif (t == 'y')\n\t\t{\n\t\t\tif (buf == \"\") goto end;\n\t\t\tif (buf == \"#\")\n\t\t\t{\n\t\t\t\tfor (int i = h - 1; i > x; i--)\n\t\t\t\t{\n\t\t\t\t\ts[i + 1] = s[i];\n\t\t\t\t}\n\t\t\t\ts[x + 1] = s[x].substr(y);\n\t\t\t\ts[x].erase(y);\n\t\t\t\tp.first++;\n\t\t\t\tp.second = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts[x].insert(y, buf);\n\t\t\t\tp.second = s[x].size();\n\t\t\t}\n\t\t}\n\tend:;\n\t}\n\tREP(i, h)\n\t{\n\t\tcout << s[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n \nusing namespace std;\n\n#define sz  size()\n#define er  erase\n#define ss  substr\n\nclass Emacs {\npublic:\n    Emacs(){\n        w = h = 0;\n        buf.clear();\n    }\n    void appendLine(string line){ txt.push_back(line); }\n    void execCommand(char code){\n        switch (code){\n          case 'a': A(); break;\n          case 'e': E(); break;\n          case 'p': P(); break;\n          case 'n': N(); break;\n          case 'f': F(); break;\n          case 'b': B(); break;\n          case 'd': D(); break;\n          case 'k': K(); break;\n          case 'y': Y(); break;\n        }\n    }\n    void showText(){\n        for (auto line : txt)\n            cerr << line << \"\\n\";\n    }\nprivate:\n    void A(){ w = 0; }\n    void E(){ w = txt[h].sz; }\n    void P(){ h = max(h - 1, 0); A(); }\n    void N(){ h = min(h + 1, (int)txt.sz - 1); A(); }\n    void F(){ if (w < txt[h].sz) w++; else if (h < txt.sz - 1) A(), h++; }\n    void B(){ if (w > 0) w--; else if (h > 0) h--, E(); }\n    void D(){ if (w < txt[h].sz) txt[h].er(w, 1); else if (h < txt.sz - 1) txt[h] += txt[h + 1], txt.er(txt.begin() + h + 1); }\n    void K(){ if (w < txt[h].sz) buf = txt[h].ss(w), txt[h] = txt[h].ss(0, w); else if (h < txt.sz - 1) D(), buf = \"\\n\"; }\n    void Y(){ if (!buf.empty()) { if (buf == \"\\n\") txt.insert(txt.begin() + h + 1, txt[h].ss(w)); else txt[h].insert(w, buf), w += buf.sz; }}\n    vector<string> txt;\n    string buf;\n    int h, w;\n};\n\nint main()\n{\n    Emacs emacs;\n\n    string in;\n    while (getline(cin, in), in != \"END_OF_TEXT\") emacs.appendLine(in);\n\n    char cmd;\n    while (cin >> cmd, cmd != '-') emacs.execCommand(cmd);\n\n    emacs.showText();\n\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY = 0;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n\telse return;\n}\n\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\\n\";\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring front=\"\";\n\t\tstring rear=\"\";\n\t\tfront = lines[posY].substr(0,posX);\n\t\trear = lines[posY].substr(posX,lines[posY].size()-posX);\t\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX);\n\n\t\tlines[posY] = front;\n\t\t//deque<string>::iterator it = lines.begin();\n\t\t//advance(it,posY);\n\t\tdeque<string> res;\n\n\t\tfor(int i=0;i<posY;i++){\n\t\t\tres.push_back(lines[i]);\n\t\t}\n\n\t\tres.push_back(lines[posY]);\n\t\tres.push_back(rear);\n\t\t\n\n\t\tfor(int i=posY+1;i<lines.size();i++){\n\t\t\tres.push_back(lines[i]);\n\t\t}\n\t\t\n\t\tlines = res;\n\t\tposY++;\n\t\tposX=0;\n\t\t//lines.insert(lines.begin()+posY,rear);\n\t\t//lines.insert(it,rear);\n\t}\n\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(getline(cin,str)){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(cin >> str){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\tif(str == \"d\") ctrl_d(lines);\n\t\tif(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\n// char s[102][1002];\nvector<string> s;\nint R;\n\nvoid input() {\n  string l;\n  int r = 0;\n  while (1) {\n    getline(cin, l);\n    // printf(\"INPUT:%s\\n\", l.c_str());\n    if (l == \"END_OF_TEXT\") {\n      R = r;\n      break;\n    }\n    l += '\\0';\n    s.push_back(l);\n    ++r;\n  }\n}\n\nvoid interpret() {\n  string buf;\n  char op;\n  int ci = 0, cj = 0;\n  // cin.ignore();\n  while (cin >> op, op != '-') {\n    // rep(i,R) {\n    //   printf(\"%s\\n\", s[i].c_str());\n    // }\n    // puts(\"--------------------------------------------------\");\n    // printf(\"[operation : %c | buf : %s]\\n\", op, buf.c_str());\n    switch (op) {\n      case 'a': {\n        // カーソルを現在の行の先頭文字に移動する\n        cj = 0;\n        break;\n      }\n      case 'e': {\n        // カーソルを現在の行の行末に移動する\n        while (s[ci][cj] != '\\0') ++cj;\n        break;\n      }\n      case 'p': {\n        // 上に行があれば、カーソルを上の行の先頭文字に移動する。\n        // 上に行がなければ、カーソルを先頭文字に移動する。\n        if (ci != 0) {\n          --ci; cj = 0;\n        } else {\n          cj = 0;\n        }\n        break;\n      }\n      case 'n': {\n        // 下に行があれば、カーソルを下の行の先頭文字に移動する。\n        // 下に行がなければ、カーソルを先頭文字に移動する。\n        if (ci + 1 < R) {\n          ++ci; cj = 0;\n        } else {\n          cj = 0;\n        }\n        break;\n      }\n      case 'f': {\n        // カーソルが行末にない場合、カーソルを１つ右に移動する \n        // カーソルが行末にありかつ下に行がある場合は、\n        // カーソルを下の行の先頭文字へ移動する \n        // それ以外の場合は何もしない\n        if (s[ci][cj] != '\\0') {\n          ++cj;\n        } else if (s[ci][cj] == '\\0' && ci + 1 < R) {\n          ++ci; cj = 0;\n        }\n        break;\n      }\n      case 'b': {\n        // カーソルが先頭文字でないならば、カーソルを１つ左に移動する。\n        // カーソルが先頭文字でありかつ上に行がある場合は、\n        // カーソルを上の行の行末へ移動する。\n        // それ以外の場合は何もしない。\n        if (cj != 0) {\n          cj = 0;\n        } else if (cj == 0 && ci != 0) {\n          --ci; cj = 0;\n        }\n        break;\n      }\n      case 'd': {\n        // カーソルが文字を指す場合はその文字を削除する。\n        // 削除された文字の右側の文字列は左にシフトされる。\n        // カーソルが行末を指し下に行がある場合は、\n        // 下の行をそのままカーソルの位置に繋げる。以下の行は上にシフトされる。\n        // それ以外の場合は何もしない。\n        if (s[ci][cj] == '\\0' && ci + 1 < R) {\n          s[ci].erase(cj, 1);\n          s[ci] += s[ci+1];\n          s.erase(s.begin() + ci + 1);\n        } else {\n          s[ci].erase(cj, 1);\n        }\n        break;\n      }\n      case 'k': {\n        // カーソルが行末にある場合、下に行があれば、\n        // d と同じ操作をしバッファに１つの改行を記録する。\n        // カーソルが行末にない場合、カーソルが指す文字を含めた\n        // 右側すべての文字を切り取りそれをバッファに記録する。\n        // カーソルは元の行の行末を指すようになる。全ての記録においてバッファは上書きされる。\n        // それ以外の場合は何もしない。(clarification at 14:20)\n        if (s[ci][cj] == '\\0' && ci + 1 < R) {\n          s[ci].erase(cj, 1);\n          s[ci] += s[ci+1];\n          s.erase(s.begin() + ci + 1);\n          buf = \"\\n\";\n        } else  {\n          buf = s[ci].substr(cj);\n          s[ci].erase(cj);\n          s[ci] += '\\0';\n        }\n        break;\n      }\n      case 'y': {\n        // バッファが空の場合はなにもしない。\n        // バッファの内容が改行の場合、カーソルが指す文字の直前で改行を行う。\n        // カーソルは新しい行の先頭文字へ移動する。\n        // バッファの内容が文字列の場合、カーソルの位置にバッファの内容を挿入する。\n        // カーソルの位置はもともと指していた文字または行末の場所へ移動する。 \n        if (buf == \"\") continue;\n        if (buf == \"\\n\") {\n          if (cj == 0) {\n            inserter(s, s.begin() + ci) = string(\"\\0\");\n          } else {\n            inserter(s, s.begin() + ci + 1) = s[ci].substr(cj - 1);\n            s[ci].erase(cj - 1);\n            s[ci] += '\\0';\n            ++ci; cj = 0;\n          }\n        } else {\n          // buf.erase(buf.size()-1);\n          string tBuf = buf;\n          tBuf.erase(tBuf.size() - 1);\n          s[ci].insert(cj, tBuf.c_str());\n        }\n        break;\n      }\n    }\n  }\n  // puts(\"----------------------------------------\");\n  rep(i,R) {\n    printf(\"%s\\n\", s[i].c_str());\n  }\n}\n\nint main() {\n  input();\n  interpret();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[111];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\tfor(int i=0 ; i<111 ; i++)\n\t\tt[i] = \"\";\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tif(i<110) t[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tif(row<110) col = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 && row < 110 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row < 110 && row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( row < 110 && col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else if( row < 110 ){\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( row < 110 && buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line+1 < 110 && line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\t//t[row+1] =\n\t\t\t\t\t//if( col != t[row].size() ) t[row];//.substr( col );\n\t\t\t\t\t//t[row].erase( col );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else if( row < 110 ){\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n  int p, q;\n  string str, buf;\n  vector<string> vec;\n\n  while(!cin.eof()){\n    p = q = 0;\n    buf = \"\";\n\n    while(getline(cin, str) && str != \"END_OF_TEXT\") vec.push_back(str);\n    while(getline(cin, str) && str != \"-\"){\n      if(str == \"a\") q = 0;\n\n      if(str == \"e\") q = vec[p].size();\n\n      if(str == \"p\"){\n\tif(p > 0) --p;\n\tq = 0;\n      }\n\n      if(str == \"n\"){\n\tif(p < vec.size()-1) ++p;\n\tq = 0;\n      }\n\n      if(str == \"f\"){\n\tif(q < vec[p].size()) ++q;\n\telse if(q == vec[p].size() && p < vec.size()-1){\n\t  ++p;\n\t  q = 0;\n\t}\n      }\n\n      if(str == \"b\"){\n\tif(q > 0) --q;\n\telse if(q == 0 && p > 0){\n\t  --p;\n\t  q = vec[p].size();\n\t}\n      }\n\n      if(str == \"d\"){\n\tif(q == vec[p].size()){\n\t  if(vec.size()-1 > p){\n\t    vec[p] += vec[p+1];\n\t    vec.erase(vec.begin()+(p+1));\n\t  }\n\t} else if(q < vec[p].size()){\n\t  vec[p].erase(vec[p].begin()+q);\n\t}\n      }\n\n      if(str == \"k\"){\n\tif(q == vec[p].size()){\n\t  if(vec.size()-1 > p){\n\t    vec[p] += vec[p+1];\n\t    vec.erase(vec.begin()+(p+1));\n\t    buf = \"\\n\";\n\t  }\n\t} else if(q < vec[p].size()){\n\t  buf = vec[p].substr(q);\n\t  vec[p] = vec[p].substr(0, q);\n\t}\n      }\n\n      if(str == \"y\" && buf.size()){\n\tif(buf == \"\\n\"){\n\t  string s1 = vec[p].substr(0, q), s2 = vec[p].substr(q);\n\t  vec[p++] = s1;\n\t  vec.insert(vec.begin()+(p), s2);\n\t  q = 0;\n\t} else {\n\t  // vec[p] = vec[p].substr(0, q)+buf+vec[p].substr(q);\n\t  vec[p].insert(q, buf);\n\t  q += buf.size();\n\t}\n      }\n    }\n\n    for(int i = 0; i < vec.size(); ++i)\n      cout << vec[i] << endl;\n    \n    buf.clear();\n    vec.clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nvector<string> s;\nstring buf = \"\";\nint ci = 0, cj = 0;\n\nvoid input() {\n  string l;\n  while (1) {\n    getline(cin, l);\n    if (l == \"END_OF_TEXT\") {\n      break;\n    }\n    s.push_back(l);\n  }\n}\n\n// カーソルを現在の行の先頭文字に移動する\nvoid op_a() { cj = 0; }\n\n// カーソルを現在の行の行末に移動する\nvoid op_e() { cj = s[ci].size(); }\n\n// 上に行があれば、カーソルを上の行の先頭文字に移動する。\n// 上に行がなければ、カーソルを先頭文字に移動する。\nvoid op_p() {\n  if (ci != 0) \n    --ci;\n  op_a();\n}\n\n// 下に行があれば、カーソルを下の行の先頭文字に移動する。\n// 下に行がなければ、カーソルを先頭文字に移動する。\nvoid op_n() {\n  if (ci != s.size() - 1) \n    ++ci;\n  op_a();\n}\n\n// カーソルが行末にない場合、カーソルを１つ右に移動する \n// カーソルが行末にありかつ下に行がある場合は、\n// カーソルを下の行の先頭文字へ移動する \n// それ以外の場合は何もしない\nvoid op_f() {\n  if (cj != s[ci].size()) {\n    ++cj;\n  } else if (cj == s[ci].size() && ci != s.size() - 1) {\n    op_n();\n  }\n}\n\n// カーソルが先頭文字でないならば、カーソルを１つ左に移動する。\n// カーソルが先頭文字でありかつ上に行がある場合は、\n// カーソルを上の行の行末へ移動する。\n// それ以外の場合は何もしない。\nvoid op_b() {\n  if (cj != 0) {\n    --cj;\n  } else if (cj == 0 && ci != 0) {\n    --ci;\n    op_e();\n  }\n}\n\n// カーソルが文字を指す場合はその文字を削除する。\n// 削除された文字の右側の文字列は左にシフトされる。\n// カーソルが行末を指し下に行がある場合は、\n// 下の行をそのままカーソルの位置に繋げる。以下の行は上にシフトされる。\n// それ以外の場合は何もしない。\nvoid op_d() {\n  if (cj != s[ci].size()) {\n    // prev\n    // s[ci].erase(cj, 1);\n    s[ci] = s[ci].substr(0, cj) + s[ci].substr(cj + 1);\n  } else if (cj == s[ci].size() && ci != s.size() - 1) {\n    // prev\n    // s[ci].erase(cj, 1);\n    // s[ci] += s[ci+1];\n    // s.erase(s.begin() + ci + 1);\n    s[ci] += s[ci+1];\n    s.erase(s.begin() + ci + 1);\n  }\n}\n\n// カーソルが行末にある場合、下に行があれば、\n// d と同じ操作をしバッファに１つの改行を記録する。\n// カーソルが行末にない場合、カーソルが指す文字を含めた\n// 右側すべての文字を切り取りそれをバッファに記録する。\n// カーソルは元の行の行末を指すようになる。全ての記録においてバッファは上書きされる。\n// それ以外の場合は何もしない。(clarification at 14:20)\nvoid op_k() {\n  if (cj == s[ci].size() && ci != s.size() - 1) {\n    // prev\n    // s[ci].erase(cj, 1);\n    // s[ci] += s[ci+1];\n    // s.erase(s.begin() + ci + 1);\n    s[ci] += s[ci+1];\n    s.erase(s.begin() + ci + 1);\n    buf = \"\\n\";\n  } else  {\n    // prev\n    // buf = s[ci].substr(cj);\n    // s[ci].erase(cj);\n    buf = s[ci].substr(cj);\n    s[ci] = s[ci].substr(0, cj);\n  }\n}\n\n// バッファが空の場合はなにもしない。\n// バッファの内容が改行の場合、カーソルが指す文字の直前で改行を行う。\n// カーソルは新しい行の先頭文字へ移動する。\n// バッファの内容が文字列の場合、カーソルの位置にバッファの内容を挿入する。\n// カーソルの位置はもともと指していた文字または行末の場所へ移動する。 \nvoid op_y() {\n  if (buf == \"\") return;\n  if (buf == \"\\n\") {\n    // prev\n    inserter(s, s.begin() + ci + 1) = s[ci].substr(cj);\n    s[ci].erase(cj);\n    ++ci; cj = 0;\n    // vector<string>::iterator itr = s.begin();\n    // rep(i,ci+1) ++itr;\n    // s.insert(itr, s[ci].substr(cj));\n    // s[ci] = s[ci].substr(0, cj);\n    // ++ci; cj = 0;\n  } else {\n    // prev\n    s[ci].insert(cj, buf.c_str());\n    cj += buf.size();\n    // s[ci] = s[ci].substr(0, cj) + buf + s[ci].substr(cj);\n    // cj += buf.size();\n  }\n}\n\nvoid interpret() {\n  string op;\n  while (1) {\n    getline(cin, op);\n    if (op == \"-\") break;\n    if (op == \"a\") {\n      op_a();\n    } else if (op == \"e\") {\n      op_e();\n    } else if (op == \"p\") {\n      op_p();\n    } else if (op == \"n\") {\n      op_n();\n    } else if (op == \"f\") {\n      op_f();\n    } else if (op == \"b\") {\n      op_b();\n    } else if (op == \"d\") {\n      op_d();\n    } else if (op == \"k\") {\n      op_k();\n    } else if (op == \"y\") {\n      op_y();\n    }\n  }\n  rep(i,s.size()) {\n    cout << s[i] << endl;\n  }\n}\n\nint main() {\n  input();\n  interpret();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[111];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\tfor(int i=0 ; i<111 ; i++)\n\t\tt[i] = \"\";\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tif(i<110) t[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tif(row<110) col = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 && row < 110 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row < 110 && row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( row < 110 && col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else if( row < 110 ){\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( row < 110 && buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line+1 < 110 && line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\t//t[row+1] =\n\t\t\t\t\t//if( col != t[row].size() ) t[row];//.substr( col );\n\t\t\t\t\tif(col != t[row].size() ) t[row].erase( col );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else if( row < 110 ){\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n//#include <cstdio>\n//#include <cstdlib>\n//#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n//#include <limits>\n//#include <sstream>\n//#include <functional>\nusing namespace std;\n\n#define len(array)  (sizeof (array) / sizeof *(array))\n#define rep(i, s, e) for(int i = s;i < e;i++)\n#define rrep(i, e, s) for(int i = e;s <= i;i--)\n#define vrange(v) v.begin(), v.end()\n#define vrrange(v) v.rbegin(), v.rend()\n#define vsort(v) sort(vrange(v))\n#define vrsort(v) sort(vrrange(v))\n#define arange(a) a, a + len(a)\n#define asort(a) sort(arange(a))\n#define arsort(a, t) sort(arange(a), greater<t>())\n#define afill(a, v) fill(arange(a), v)\n#define afill2(a, v, t) fill((t *)a, (t *)(a + len(a)), v)\n#define fmax(a, b) (a < b? b : a)\n#define fmin(a, b) (a > b? b : a)\n#define fabs(a) (a < 0? -a : a)\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\nconst int INF = (int)1e9;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-10;\n//const int dx[] = {1, -1, 0, 0, 1, -1, -1, 1};\n//const int dy[] = {0, 0, 1, -1, -1, -1, 1, 1};\n//const int weight[] = {0,1,10,100,1000,10000,100000,1000000,10000000};\n//priority_queue<int, vector<int>, greater<int>> q;\ntypedef struct _Node {\n  _Node(int arg1 = 0, int arg2 = 0 , int arg3 = 0) {\n\ti = arg1;\n\tj = arg2;\n\tk = arg3;\n  }\n  int i,j,k;\n  bool operator <(const struct _Node &e) const{\n    return i == e.i? j < e.j : i < e.i;\n  }\n  bool operator >(const struct _Node &e) const{\n    return i == e.i? j > e.j : i > e.i;\n  }\n}node;\n\n\nvoid doIt(){\n  string s = \"\", t, buffer = \"\";\n  char com;\n  int pos = 0;\n  bool bLine, bContinue = true;\n  while(1){\n\t//cin >> t;\n\tgetline(cin, t);\n\tif(t == \"END_OF_TEXT\") break;\n\ts += t + '\\n';\n  }\n  //cout << \"start..\" << endl;\n  while(bContinue){\n\tcin >> com;\n\n\tswitch(com){\n\tcase 'a':\n\t  while(pos != 0 && s[pos-1] != '\\n') pos--;\n\t  break;\n\tcase 'e':\n\t  while(s[pos] != '\\n') pos++;\n\t  break;\n\tcase 'p':\n\t  bLine = false;\n\t  //if(pos != 0 && s[pos] == '\\n') pos--;\n\t  while(pos != 0){\n\t\tif(s[pos-1] == '\\n'){\n\t\t  if(bLine) break;\n\t\t  else bLine = true;\n\t\t}\n\t\tpos--;\n\t  }\n\t  break;\n\tcase 'n':\n\t  while(s[pos] != '\\n') pos++;\n\t  if(pos == s.length() - 1){\n\t  \t//pos--;\n\t  \twhile(pos != 0 && s[pos-1] != '\\n') pos--;\n\t  }\n\t  else pos++;\n\t  // bLine = false;\n\t  // while(pos != s.length()){\n\t  // \tif(s[pos+1] == '\\n'){\n\t  // \t  if(bLine) break;\n\t  // \t  else bLine = true;\n\t  // \t}\n\t  // \tpos++;\n\t  // }\n\t  break;\n\tcase 'f':\n\t  if(pos != s.length() - 1) pos++;\n\t  break;\n\tcase 'b':\n\t  if(pos != 0) pos--;\n\t  break;\n\tcase 'd':\n\t  if(pos != s.length() - 1) s = s.substr(0, pos) + s.substr(pos+1, s.length()-(pos+1));\n\t  break;\n\tcase 'k':\n\t  if(s[pos] == '\\n'){\n\t\tif(pos != s.length()-1){\n\t\t  s = s.substr(0, pos) + s.substr(pos+1, s.length()-(pos+1));\n\t\t  buffer = \"\\n\";\n\t\t}\n\t  }\n\t  else{\n\t\tint end = pos;\n\t\twhile(s[end] != '\\n') end++;\n\t\tbuffer = s.substr(pos, end-pos);\n\t\ts = s.substr(0, pos) + s.substr(end, s.length()-end);\n\n\t  }\n\t  break;\n\tcase 'y':\n\t  if(buffer != \"\"){\n\t\ts = s.substr(0, pos) + buffer + s.substr(pos, s.length()-pos);\n\t\tpos += buffer.length();\n\t  }\n\t  break;\n\tcase '-':\n\t  bContinue = false;\n\t  break;\n\t}\n\n\t{\n\t  // cout << \"com = \" << com << endl;\n\t  // cout << \"s = [\\n\" << s << \"]\" << endl;\n\t  // cout << \"buffer = [\" << buffer << \"]\" << endl;\n\t  // cout << \"pos = \" << pos << endl;\n\t}\n  }\ncout << s.substr(0, s.length() - 1) << endl;\n}\n\nint main() {\n  doIt();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <string> VS;\nistream& myis = cin;\nostream& myos = cout;\n\nconst string END_OF_TEXT = \"END_OF_TEXT\";\nconst string END_OF_COMMAND = \"-\";\n\n// prototypes\nVS solve( const VS& lines );\nvoid output( const VS& lines );\nvoid split( const VS& lines, VS& T, VS& C );\n\n// editor\nclass Editor {\npublic:\n    // members\n    VS T;\n    int r;\n    int c;\n    string buffer;\n    // methods\n    Editor( VS T ): T(T) {\n        r = 0;\n        c = 0;\n        buffer.clear();\n    }\n    VS get_text() { return T; }\n    void parse_command( string com ) {\n        if ( com == \"a\" ) command_a();\n        if ( com == \"e\" ) command_e();\n        if ( com == \"p\" ) command_p();\n        if ( com == \"n\" ) command_n();\n        if ( com == \"f\" ) command_f();\n        if ( com == \"b\" ) command_b();\n        if ( com == \"d\" ) command_d();\n        if ( com == \"k\" ) command_k();\n        if ( com == \"y\" ) command_y();\n        // debug\n        /*\n        myos << \"::: debug start :::\" << endl;\n        myos << \"r: \" << r << endl;\n        myos << \"c: \" << c << endl;\n        myos << \"b: \" << buffer << endl;\n        myos << \"::: debug end   :::\" << endl;\n        */\n    }\nprivate:\n    bool is_cursor_leftmost() {\n        return c == 0;\n    }\n    bool is_cursor_rightmost() {\n        return c == (int)T[r].size();\n    }\n    bool exist_next_upperline() {\n        return r - 1 >= 0;\n    }\n    bool exist_next_lowerline() {\n        return r + 1 < (int)T.size();\n    }\n    void delete_line( int n ) {\n        T.erase( T.begin() + n );\n    }\n    void delete_letter( int n ) {\n        T[r].erase( T[r].begin() + n );\n    }\n    void move_cursor_leftmost() {\n        c = 0;\n    }\n    void move_cursor_rightmost() {\n        c = T[r].size();\n    }\n    void move_cursor_up() {\n        r -= 1;\n    }\n    void move_cursor_down() {\n        r += 1;\n    }\n    void move_cursor_left() {\n        c -= 1;\n    }\n    void move_cursor_right() {\n        c += 1;\n    }\n    void command_a() {\n        /*\n          J[\\ð»ÝÌsÌæª¶ÉÚ®·éB\n        */\n        move_cursor_leftmost();\n    }\n    void command_e() {\n        /*\n          J[\\ð»ÝÌsÌsÉÚ®·éB\n        */\n        move_cursor_rightmost();\n    }\n    void command_p() {\n        /*\n          ãÉsª êÎAJ[\\ðãÌsÌæª¶ÉÚ®·éB\n          ãÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n        */\n        if ( exist_next_upperline() ) {\n            move_cursor_up();\n            move_cursor_leftmost();\n        } else {\n            move_cursor_leftmost();\n        }\n    }\n    void command_n() {\n        /*\n          ºÉsª êÎAJ[\\ðºÌsÌæª¶ÉÚ®·éB\n          ºÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n        */\n        if ( exist_next_lowerline() ) {\n            move_cursor_down();\n            move_cursor_leftmost();\n        } else {\n            move_cursor_leftmost();\n        }\n    }\n    void command_f() {\n        /*\n          J[\\ªsÉÈ¢êAJ[\\ðPÂEÉÚ®·éB\n          J[\\ªsÉ è©ÂºÉsª éêÍAJ[\\ðºÌsÌæª¶ÖÚ®·éB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( ! is_cursor_rightmost() ) {\n            move_cursor_right();\n        } else if ( is_cursor_rightmost() && exist_next_lowerline() ) {\n            move_cursor_down();\n            move_cursor_leftmost();\n        }\n    }\n    void command_b() {\n        /*\n          J[\\ªæª¶ÅÈ¢ÈçÎAJ[\\ðPÂ¶ÉÚ®·éB\n          J[\\ªæª¶Å è©ÂãÉsª éêÍAJ[\\ðãÌsÌsÖÚ®·éB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( ! is_cursor_leftmost() ) {\n            move_cursor_left();\n        } else if ( is_cursor_leftmost() && exist_next_upperline() ) {\n            move_cursor_up();\n            move_cursor_rightmost();\n        }\n    }\n    void command_d() {\n        /*\n          J[\\ª¶ðw·êÍ»Ì¶ðí·éBí³ê½¶ÌE¤Ì¶ñÍ¶ÉVtg³êéB\n          J[\\ªsðwµºÉsª éêÍAºÌsð»ÌÜÜJ[\\ÌÊuÉq°éBÈºÌsÍãÉVtg³êéB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( ! is_cursor_rightmost() ) {\n            delete_letter( c );\n        } else if ( is_cursor_rightmost() && exist_next_lowerline() ) {\n            T[r] += T[r+1];\n            delete_line( r+1 );\n        }\n    }\n    void command_k() {\n        /*\n          J[\\ªsÉ éêAºÉsª êÎAd Æ¯¶ìðµobt@ÉPÂÌüsðL^·éB\n          J[\\ªsÉÈ¢êAJ[\\ªw·¶ðÜß½E¤·×ÄÌ¶ðØèæè»êðobt@ÉL^·éB\n          J[\\Í³ÌsÌsðw·æ¤ÉÈéBSÄÌL^É¨¢Äobt@Íã«³êéB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( is_cursor_rightmost() && exist_next_lowerline() ) {\n            T[r] += T[r+1];\n            delete_line( r+1 );\n            buffer = \"\\n\";\n        } else if ( ! is_cursor_rightmost() ) {\n            buffer = T[r].substr( c );\n            T[r] = T[r].substr( 0, c );\n            move_cursor_rightmost();\n        }\n    }\n    void command_y() {\n        /*\n          obt@ªóÌêÍÈÉàµÈ¢B\n          obt@ÌàeªüsÌêAJ[\\ªw·¶Ì¼OÅüsðs¤BJ[\\ÍVµ¢sÌæª¶ÖÚ®·éB\n          obt@Ìàeª¶ñÌêAJ[\\ÌÊuÉobt@Ìàeð}ü·éB\n          J[\\ÌÊuÍàÆàÆwµÄ¢½¶Ü½ÍsÌêÖÚ®·éB\n        */\n        if ( buffer == \"\\n\" ) {\n            string tmp = T[r].substr( c );\n            T[r] = T[r].substr( 0, c );\n            T.insert( T.begin() + r + 1, tmp );\n            move_cursor_down();\n            move_cursor_leftmost();\n        } else if ( buffer != \"\" ) {\n            string left = T[r].substr( 0, c );\n            string right = T[r].substr( c );\n            T[r] = left + buffer + right;\n        }\n    }\n};\n\n// functions\n\nVS solve( const VS& lines ) {\n    VS T; // text\n    VS C; // commands\n    split( lines, T, C );\n\n    if ( T.empty() ) return T;\n\n    // edit\n    Editor editor( T );\n    for ( VS ::iterator it_i = C.begin(); it_i != C.end(); ++ it_i ) {\n        string command = *it_i;\n        editor.parse_command( command );\n    }\n    return editor.get_text();\n}\n\nvoid output( const VS& lines ) {\n    for ( VS ::const_iterator it_i = lines.begin(); it_i != lines.end(); ++ it_i ) {\n        myos << *it_i << endl;\n    }\n}\n\nvoid split( const VS& lines, VS& T, VS& C ) {\n    T.clear();\n    C.clear();\n    VS ::const_iterator it_lines = lines.begin();\n    for ( ; it_lines != lines.end(); ++ it_lines ) {\n        const string& line = *it_lines;\n        if ( line == END_OF_TEXT ) {\n            ++ it_lines;\n            break;\n        }\n        T.push_back( line );\n    }\n    for ( ; it_lines != lines.end(); ++ it_lines ) {\n        const string& line = *it_lines;\n        if ( line == END_OF_COMMAND ) {\n            break;\n        }\n        C.push_back( line );\n    }\n}\n\nint main() {\n    VS lines;\n    string line;\n    while ( getline( myis, line ) ) lines.push_back( line );\n\n    VS answer = solve( lines );\n    output( answer );\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\n// char s[102][1002];\nvector<string> s;\nint R;\n\nvoid input() {\n  string l;\n  int r = 0;\n  while (1) {\n    getline(cin, l);\n    // printf(\"INPUT:%s\\n\", l.c_str());\n    if (l == \"END_OF_TEXT\") {\n      R = r;\n      break;\n    }\n    l += '\\0';\n    s.push_back(l);\n    ++r;\n  }\n}\n\nvoid interpret() {\n  string buf;\n  char op;\n  int ci = 0, cj = 0;\n  while (cin >> op, op != '-') {\n    // rep(i,R) {\n    //   printf(\"%s\\n\", s[i].c_str());\n    // }\n    // puts(\"--------------------------------------------------\");\n    // printf(\"[operation : %c | buf : %s]\\n\", op, buf.c_str());\n    switch (op) {\n      case 'a': {\n        // カーソルを現在の行の先頭文字に移動する\n        cj = 0;\n        break;\n      }\n      case 'e': {\n        // カーソルを現在の行の行末に移動する\n        cj = s[ci].size() - 1;\n        break;\n      }\n      case 'p': {\n        // 上に行があれば、カーソルを上の行の先頭文字に移動する。\n        // 上に行がなければ、カーソルを先頭文字に移動する。\n        if (ci) \n          --ci;\n        cj = 0;\n        break;\n      }\n      case 'n': {\n        // 下に行があれば、カーソルを下の行の先頭文字に移動する。\n        // 下に行がなければ、カーソルを先頭文字に移動する。\n        if (ci + 1 < R) \n          ++ci;\n        cj = 0;\n        break;\n      }\n      case 'f': {\n        // カーソルが行末にない場合、カーソルを１つ右に移動する \n        // カーソルが行末にありかつ下に行がある場合は、\n        // カーソルを下の行の先頭文字へ移動する \n        // それ以外の場合は何もしない\n        if (s[ci][cj] != '\\0') {\n          ++cj;\n        } else if (s[ci][cj] == '\\0' && ci + 1 < R) {\n          ++ci; cj = 0;\n        }\n        break;\n      }\n      case 'b': {\n        // カーソルが先頭文字でないならば、カーソルを１つ左に移動する。\n        // カーソルが先頭文字でありかつ上に行がある場合は、\n        // カーソルを上の行の行末へ移動する。\n        // それ以外の場合は何もしない。\n        if (cj != 0) {\n          // cj = 0;\n          --cj;\n        } else if (cj == 0 && ci != 0) {\n          --ci; cj = 0;\n        }\n        break;\n      }\n      case 'd': {\n        // カーソルが文字を指す場合はその文字を削除する。\n        // 削除された文字の右側の文字列は左にシフトされる。\n        // カーソルが行末を指し下に行がある場合は、\n        // 下の行をそのままカーソルの位置に繋げる。以下の行は上にシフトされる。\n        // それ以外の場合は何もしない。\n        if (s[ci][cj] == '\\0' && ci + 1 < R) {\n          s[ci].erase(cj, 1);\n          s[ci] += s[ci+1];\n          s.erase(s.begin() + ci + 1);\n        } else {\n          s[ci].erase(cj, 1);\n        }\n        break;\n      }\n      case 'k': {\n        // カーソルが行末にある場合、下に行があれば、\n        // d と同じ操作をしバッファに１つの改行を記録する。\n        // カーソルが行末にない場合、カーソルが指す文字を含めた\n        // 右側すべての文字を切り取りそれをバッファに記録する。\n        // カーソルは元の行の行末を指すようになる。全ての記録においてバッファは上書きされる。\n        // それ以外の場合は何もしない。(clarification at 14:20)\n        if (s[ci][cj] == '\\0' && ci + 1 < R) {\n          s[ci].erase(cj, 1);\n          s[ci] += s[ci+1];\n          s.erase(s.begin() + ci + 1);\n          buf = \"\\n\";\n        } else  {\n          buf = s[ci].substr(cj);\n          s[ci].erase(cj);\n          s[ci] += '\\0';\n        }\n        break;\n      }\n      case 'y': {\n        // バッファが空の場合はなにもしない。\n        // バッファの内容が改行の場合、カーソルが指す文字の直前で改行を行う。\n        // カーソルは新しい行の先頭文字へ移動する。\n        // バッファの内容が文字列の場合、カーソルの位置にバッファの内容を挿入する。\n        // カーソルの位置はもともと指していた文字または行末の場所へ移動する。 \n        if (buf == \"\") continue;\n        if (buf == \"\\n\") {\n          if (cj == 0) {\n            inserter(s, s.begin() + ci) = string(\"\\0\");\n          } else {\n            inserter(s, s.begin() + ci + 1) = s[ci].substr(cj - 1);\n            s[ci].erase(cj - 1);\n            s[ci] += '\\0';\n            ++ci; cj = 0;\n          }\n        } else {\n          // bool isEnd = s[ci][cj] == '\\0';\n          string tBuf = buf;\n          tBuf.erase(tBuf.size() - 1);\n          s[ci].insert(cj, tBuf.c_str());\n          cj += tBuf.size();\n          // if (isEnd) {\n          // }\n        }\n        break;\n      }\n    }\n  }\n  // puts(\"----------------------------------------\");\n  rep(i,R) {\n    printf(\"%s\\n\", s[i].c_str());\n  }\n}\n\nint main() {\n  input();\n  interpret();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY = 0;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n\telse return;\n}\n\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\\n\";\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring front=\"\";\n\t\tstring rear=\"\";\n\t\tfront = lines[posY].substr(0,posX);\n\t\trear = lines[posY].substr(posX,lines[posY].size()-posX);\t\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX);\n\n\t\tlines[posY] = front;\n\t\t//deque<string>::iterator it = lines.begin();\n\t\t//advance(it,posY);\n\t\tlines.insert(next(lines.begin()+posY),rear);\n\t\t//lines.insert(it,rear);\n\t}\n\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(getline(cin,str)){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(cin >> str){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\tif(str == \"d\") ctrl_d(lines);\n\t\tif(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define TOP_OF_BUFFER 0\n#define BEGIN_OF_LINE 0\n#define END_OF_LINE 10000\n\nstruct Cursor{\n  int x, y;\n  Cursor(){\n    x = 0, y = 0;\n  }\n};\n\nvector<string> buffer;\nstring buf;\nbool new_line;\nCursor cursor;\nint end;\n\nvoid output(){\n  for(int i = 0 ; i <= end ; i++){\n    cout << buffer[i] << endl;\n  }\n  //cout << endl;\n}\n\nvoid a_command(){\n  cursor.x = BEGIN_OF_LINE;\n}\n\nvoid e_command(){\n  cursor.x = END_OF_LINE;\n}\n\nvoid p_command(){\n  if(cursor.y == TOP_OF_BUFFER) cursor.x = BEGIN_OF_LINE;\n  else{\n    cursor.y--;\n    cursor.x = BEGIN_OF_LINE;\n  }\n}\n\nvoid n_command(){\n  if(cursor.y == end) cursor.x = BEGIN_OF_LINE;\n  else{\n    cursor.y++;\n    cursor.x = BEGIN_OF_LINE;\n  }\n}\n\nvoid f_command(){\n  if(cursor.x != END_OF_LINE) cursor.x++;\n  else if(cursor.x == END_OF_LINE && cursor.y != end){\n    cursor.x = BEGIN_OF_LINE;\n    cursor.y++;\n  }\n}\n\nvoid b_command(){\n  if(cursor.x != BEGIN_OF_LINE) cursor.x--;\n  else if(cursor.x == BEGIN_OF_LINE && cursor.y != TOP_OF_BUFFER){\n    cursor.x = END_OF_LINE;\n    cursor.y--;\n  }\n}\n\nvoid d_command(){\n  if(cursor.x == END_OF_LINE && cursor.y != end){\n    //シフト\n    //if(buffer[cursor.y].size() == 0) cursor.x = 0;\n    cursor.x = buffer[cursor.y].size();\n    buffer[cursor.y] += buffer[cursor.y+1];\n    buffer.erase(buffer.begin() + cursor.y+1);\n    end--;\n  }\n  else if(cursor.x != END_OF_LINE){\n    buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n  }\n}\n\nvoid k_command(){\n  if(cursor.x == END_OF_LINE && cursor.y != end){\n    d_command();\n    buf = \"\";\n    new_line = true;\n  }\n  else if(cursor.x != END_OF_LINE){\n    buf = \"\";\n    new_line = false;\n    for(int j = cursor.x ; j < buffer[cursor.y].size() ; j++){\n      buf += buffer[cursor.y][j];\n    }\n\n    int buffer_size = buffer[cursor.y].size();\n    for(int j = cursor.x ; j < buffer_size ; j++){\n      buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n      //cout << buffer[cursor.y] << endl;\n    }\n  }\n}\n\nvoid y_command(){\n  //if(buf == \"\") return;\n  string bf = \"\";\n  for(int j = cursor.x ; j < buffer[cursor.y].size() ; j++){\n    bf += buffer[cursor.y][j];\n  }\n   \n  if(new_line){\n    buffer.push_back(\"\");\n    \n    for(int i = buffer.size()-1 ; i > cursor.y ; i--){\n      buffer[i] = buffer[i-1];\n    }\n    end++;\n    buffer[cursor.y+1] = bf;\n    int buffer_size = buffer[cursor.y].size();\n    for(int j = cursor.x ; j < buffer_size ; j++){\n      buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n    }\n  }\n  else{\n    if(cursor.x == END_OF_LINE){\n      buffer[cursor.y] += buf;\n    }\n    else{\n      for(int cnt = 0 ; cnt < bf.size() ; cnt++){\n\tbuffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n      }\n      buffer[cursor.y] += buf;\n      buffer[cursor.y] += bf;\n      cursor.x += buf.size();\n    }\n  }\n} \n\nvoid init(){\n  end = buffer.size()-1;\n  new_line = false;  \n  buf = \"\";\n}\n  \nint main(){\n  string s;\n  while(getline(cin, s)){\n    if(s == \"END_OF_TEXT\") break;\n    buffer.push_back(s);\n  }\n  \n  init();\n  \n  char op;\n  while(cin >> op){\n    //cout << \"operand = \" << op << endl;\n    if(op == '-') break;\n    if(op == 'a') a_command();\n    if(op == 'e') e_command();\n    if(op == 'p') p_command();\n    if(op == 'n') n_command();\n    if(op == 'f') f_command();\n    if(op == 'b') b_command();\n    if(op == 'd') d_command();\n    if(op == 'k') k_command();\n    if(op == 'y') y_command();  \n    if(cursor.x == buffer[cursor.y].size() ) cursor.x = END_OF_LINE;\n    //output();\n    //cout << \"cursor.x = \" << cursor.x << \", cursor.y = \" << cursor.y << endl << endl;  \n    //cout << \"new_line = \" << new_line << endl;\n  }\n  \n  output();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\nvector<string> text;\nstring buf;\n\nint row, col;\n\nvoid func_a(){\n\tcol = 0;\n}\n\nvoid func_e(){\n\tcol = text[row].size() - 1;\n}\n\nvoid func_p(){\n\tif (row > 0) row--;\n\tfunc_a();\n}\n\nvoid func_n(){\n\tif (row < text.size() - 1) row++;\n\tfunc_a();\n}\n\nvoid func_f(){\n\tif (col < text[row].size() - 1) col++;\n\telse func_n();\n}\n\nvoid func_b(){\n\tif (col > 0) col--;\n\telse if (row > 0){\n\t\tfunc_p();\n\t\tfunc_e();\n\t}\n}\n\nvoid func_d(){\n\tif (col < text[row].size() - 1) text[row].erase(col, 1);\n\telse if (row < text.size() - 1){\n\t\ttext[row].erase(text[row].end() - 1);\n\t\ttext[row] += text[row + 1];\n\t\ttext.erase(text.begin() + row + 1);\n\t}\n}\n\nvoid func_k(){\n\tif (col < text[row].size() - 1){\n\t\tbuf = text[row].substr(col, text[row].size() - col - 1);\n\t\ttext[row].erase(col, text[row].size() - 1);\n\t\tcol = text[row].size() - 1;\n\t}\n\telse if (row < text.size() - 1){\n\t\tfunc_d();\n\t\tbuf = \"\\n\";\n\t}\n}\n\nvoid func_y(){\n\tif (!buf.empty()){\n\t\tif (buf == \"\\n\"){\n\t\t\ttext.insert(text.begin() + row + 1, text[row].substr(col, text[row].size() - 1));\n\t\t\ttext[row].erase(col, text[row].size() - 1);\n\t\t\ttext[row] += '$';\n\t\t}\n\t\telse {\n\t\t\ttext[row].insert(col, buf);\n\t\t\tcol += buf.size();\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstring in;\n\tchar cmd;\n\n\twhile (getline(cin, in), in != \"END_OF_TEXT\"){\n\t\ttext.push_back(in + '$');\n\t}\n\t\n\tcol = row = 0;\n\tbuf.clear();\n\n\twhile (cin >> cmd, cmd != '-'){\n\t\tswitch (cmd){\n\t\t  case 'a': func_a(); break;\n\t\t  case 'e':\tfunc_e(); break;\n\t\t  case 'p':\tfunc_p(); break;\n\t\t  case 'n': func_n(); break;\n\t\t  case 'f': func_f(); break;\n\t\t  case 'b':\tfunc_b(); break;\n\t\t  case 'd':\tfunc_d(); break;\n\t\t  case 'k': func_k(); break;\n\t\t  case 'y': func_y(); break;\n\t\t}\n#if 0\n\t\tprintf(\"col:%d row:%d\\n\", col, row);\n\t\tputs(\"status:\");\n\t\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\t\tcout << *it << endl;\n\t\t}\n\t\tputs(\"buffer:\");\n\t\tcout << buf << endl;\n#endif\n\t}\n\n\t\n\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\tcout << it->substr(0, it->size() - 1) << endl;\n\t}\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tstring str[10000];\n\tstring b;\n\tint i = 0;\n\t\n\twhile (getline(std::cin, str[i]), str[i] != \"END_OF_TEXT\") i++;\n\ti = 0;\n\t\n\tchar cmd[2];\n\tint car_y = 0;\n\tint car = 0;\n\tint y = 0, y2 = 0;\n\t\n\twhile (str[y] != \"END_OF_TEXT\") y++;\n\ty--;\n\ty2 = y;\n\t\n\tb.erase();\n\t\n\twhile (scanf(\"%s\", cmd), cmd[0] != '-'){\n\t\tif (cmd[0] == 'a'){\n\t\t\tcar = 0;\n\t\t//\tprintf(\" a\");\n\t\t}\n\t\tif (cmd[0] == 'e'){\n\t\t\tcar = str[car_y].size();\n\t\t\t\n\t\t//\tprintf(\" e\");\n\t\t}\n\t\tif (cmd[0] == 'p'){\n\t\t\t\n\t\t//\tprintf(\" p\");\n\t\t\tif (car_y == 0){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y--;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'n'){\n\t\t//\tprintf(\" n\");\n\t\t\tif (car_y == y2){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y++;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'f'){\n\t\t//\tprintf(\" f\");\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\tcar_y++;\n\t\t\t\t\tcar = 0;\n\t\t\t\t\t//printf(\" %d\",car_y);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar++;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'b'){\n\t\t//\tprintf(\" b\");\n\t\t\tif (car == 0){\n\t\t\t\tif (car_y != 0){\n\t\t\t\t\tcar_y--;\n\t\t\t\t\tcar = str[car_y].size();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar--;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'd'){\n\t\t//\tprintf(\" d\");\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tstr[car_y].erase(car, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\t//str[car_y] + str[car_y + 1];\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = --y;\n\t\t\t\t\ty = car_y + 1;\n\t\t\t\t\twhile (y <= y2){\n\t\t\t\t\t\tstr[y] = str[y + 1];\n\t\t\t\t\t\ty++;\n\t\t\t\t\t}\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'k'){\n\t\t//\tprintf(\" k\");\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\t//str[car_y] + str[car_y + 1];\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = --y;\n\t\t\t\t\ty = car_y + 1;\n\t\t\t\t\twhile (y <= y2){\n\t\t\t\t\t\tstr[y] = str[y + 1];\n\t\t\t\t\t\ty++;\n\t\t\t\t\t}\n\t\t\t\t\ty = y2;\n\t\t\t\t\tb[0] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb.erase();\n\t\t\t\tb = str[car_y].substr(car);\n\t\t\t\tstr[car_y].erase(car);\n\t\t\t\tcar = str[car_y].size();\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'y'){\n\t\t//\tprintf(\" y\");\n\t\t\t//if (b.empty());\n\t\t\t{\n\t\t\t\tif (b[0] == '\\0'){\n\t\t\t\t\ty2 = ++y;\n\t\t\t\t\twhile (y < car_y){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t\ty--;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tstr[y] = str[y - 1].substr(car);\n\t\t\t\t\tstr[y - 1].erase(car);\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstr[car_y].insert(car, b);\n\t\t\t\t\tcar += b.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\ti = 0;\n\twhile (i <= y2){\n\t\t//puts(str[i].c_str());\n\t\tcout << str[i] << endl;\n\t\ti++;\n\t}\n\t\n\ti = 0;\n\twhile (i <= y2){\n\t\tif (car_y == i){\n\t\t\tfor (int j = 0; j <= str[i].size(); j++){\n\t\t\t\tif (j == car){\n\t\t\t\t\tcout << 'I';\n\t\t\t\t}\n\t\t\t\tcout << str[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\telse{\n\t\t\tputs(str[i].c_str());\n\t\t}\n\t\ti++;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main() {\n    vector<string> e;\n    string s;\n    while (getline(cin, s), s != \"END_OF_TEXT\") {\n        e.push_back(s);\n    }\n    int y = 0, x = 0;\n    string buffer = \"\";\n    char c;\n    while (cin >> c, c != '-') {\n        if (c == 'a') {\n            x = 0;\n        } else if (c == 'e') {\n            x = e[y].size();\n        } else if (c == 'p') {\n            x = 0;\n            y = max(0, y-1);\n        } else if (c == 'n') {\n            x = 0;\n            y = min((int)e.size()-1, y+1);\n        } else if (c == 'f') {\n            if (x < (int)e[y].size()) {\n                x ++;\n            } else if (y+1 < (int)e.size()) {\n                x = 0;\n                y ++;\n            }\n        } else if (c == 'b') {\n            if (0 < x) {\n                x --;\n            } else if (0 <= y-1) {\n                x = e[y-1].size();\n                y --;\n            }\n        } else if (c == 'd') {\n            if (x < (int)e[y].size()) {\n                e[y] = e[y].substr(0,x) + e[y].substr(x+1);\n            } else if (y+1 < (int)e.size()) {\n                e[y] += e[y+1];\n                e.erase(e.begin() + y + 1);\n            }\n        } else if (c == 'k') {\n            if (x < (int)e[y].size()) {\n                buffer = e[y].substr(x);\n                e[y] = e[y].substr(0,x);\n                x = e[y].size();\n            } else if (y+1 < (int)e.size()) {\n                buffer = \"\\n\";\n                e[y] += e[y+1];\n                e.erase(e.begin() + y + 1);\n            }\n        } else if (c == 'y') {\n            if (buffer == \"\") {\n                // nothing\n            } else if (buffer == \"\\n\") {\n                e.insert(e.begin() + y + 1, e[y].substr(x));\n                e[y] = e[y].substr(0,x);\n                x = 0;\n                y ++;\n            } else {\n                e[y] = e[y].substr(0,x) + buffer + e[y].substr(x);\n                x += (int)buffer.size();\n            }\n        }\n    }\n    for (int i=0; i<(int)e.size(); ++i) {\n        cout << e[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nvector<string> s;\nstring buf = \"\";\nint R;\nint ci = 0, cj = 0;\n\nvoid input() {\n  string l;\n  while (1) {\n    getline(cin, l);\n    if (l == \"END_OF_TEXT\") {\n      break;\n    }\n    s.push_back(l);\n  }\n  R = s.size();\n}\n\n// カーソルを現在の行の先頭文字に移動する\nvoid op_a() { cj = 0; }\n\n// カーソルを現在の行の行末に移動する\nvoid op_e() { cj = s[ci].size(); }\n\n// 上に行があれば、カーソルを上の行の先頭文字に移動する。\n// 上に行がなければ、カーソルを先頭文字に移動する。\nvoid op_p() {\n  if (ci != 0) \n    --ci;\n  op_a();\n}\n\n// 下に行があれば、カーソルを下の行の先頭文字に移動する。\n// 下に行がなければ、カーソルを先頭文字に移動する。\nvoid op_n() {\n  if (ci != R - 1) \n    ++ci;\n  op_a();\n}\n\n// カーソルが行末にない場合、カーソルを１つ右に移動する \n// カーソルが行末にありかつ下に行がある場合は、\n// カーソルを下の行の先頭文字へ移動する \n// それ以外の場合は何もしない\nvoid op_f() {\n  if (cj != s[ci].size()) {\n    ++cj;\n  } else if (cj == s[ci].size() && ci != R - 1) {\n    op_n();\n  }\n}\n\n// カーソルが先頭文字でないならば、カーソルを１つ左に移動する。\n// カーソルが先頭文字でありかつ上に行がある場合は、\n// カーソルを上の行の行末へ移動する。\n// それ以外の場合は何もしない。\nvoid op_b() {\n  if (cj != 0) {\n    --cj;\n  } else if (cj == 0 && ci != 0) {\n    --ci;\n    op_e();\n  }\n}\n\n// カーソルが文字を指す場合はその文字を削除する。\n// 削除された文字の右側の文字列は左にシフトされる。\n// カーソルが行末を指し下に行がある場合は、\n// 下の行をそのままカーソルの位置に繋げる。以下の行は上にシフトされる。\n// それ以外の場合は何もしない。\nvoid op_d() {\n  if (cj == s[ci].size() && ci != R - 1) {\n    s[ci].erase(cj, 1);\n    s[ci] += s[ci+1];\n    s.erase(s.begin() + ci + 1);\n  } else {\n    s[ci].erase(cj, 1);\n  }\n}\n\n// カーソルが行末にある場合、下に行があれば、\n// d と同じ操作をしバッファに１つの改行を記録する。\n// カーソルが行末にない場合、カーソルが指す文字を含めた\n// 右側すべての文字を切り取りそれをバッファに記録する。\n// カーソルは元の行の行末を指すようになる。全ての記録においてバッファは上書きされる。\n// それ以外の場合は何もしない。(clarification at 14:20)\nvoid op_k() {\n  if (cj == s[ci].size() && ci != R - 1) {\n    s[ci].erase(cj, 1);\n    s[ci] += s[ci+1];\n    s.erase(s.begin() + ci + 1);\n    buf = \"\\n\";\n  } else  {\n    buf = s[ci].substr(cj);\n    s[ci].erase(cj);\n  }\n}\n\n// バッファが空の場合はなにもしない。\n// バッファの内容が改行の場合、カーソルが指す文字の直前で改行を行う。\n// カーソルは新しい行の先頭文字へ移動する。\n// バッファの内容が文字列の場合、カーソルの位置にバッファの内容を挿入する。\n// カーソルの位置はもともと指していた文字または行末の場所へ移動する。 \nvoid op_y() {\n  if (buf == \"\") return;\n  if (buf == \"\\n\") {\n    inserter(s, s.begin() + ci + 1) = s[ci].substr(cj);\n    s[ci].erase(cj);\n    ++ci; cj = 0;          \n  } else {\n    s[ci].insert(cj, buf.c_str());\n    cj += buf.size();\n  }\n}\n\nvoid interpret() {\n  char op;\n  while (cin >> op, op != '-') {\n    // rep(i,R) {\n    //   printf(\"%s\\n\", s[i].c_str());\n    // }\n    // puts(\"--------------------------------------------------\");\n    // printf(\"[operation : %c | buf : %s]\\n\", op, buf.c_str());\n    switch (op) {\n      case 'a': { op_a(); break; }\n      case 'e': { op_e(); break; }\n      case 'p': { op_p(); break; }\n      case 'n': { op_n(); break; }\n      case 'f': { op_f(); break; }\n      case 'b': { op_b(); break; }\n      case 'd': { op_d(); break; }\n      case 'k': { op_k(); break; }\n      case 'y': { op_y(); break; }\n    }\n  }\n  // puts(\"----------------------------------------\");\n  rep(i,R) {\n    printf(\"%s\\n\", s[i].c_str());\n  }\n}\n\nint main() {\n  input();\n  interpret();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tstring str[10000];\n\tstring b;\n\tint i = 0;\n\t\n\twhile (getline(std::cin, str[i]), str[i] != \"END_OF_TEXT\") i++;\n\ti = 0;\n\t\n\tchar cmd[2];\n\tint car_y = 0;\n\tint car = 0;\n\tint y = 0, y2 = 0;\n\t\n\twhile (str[y] != \"END_OF_TEXT\") y++;\n\ty2 = y;\n\t\n\tb.erase();\n\t\n\twhile (scanf(\"%s\", cmd), cmd[0] != '-'){\n\t\tif (cmd[0] == 'a'){\n\t\t\tcar = 0;\n\t\t//\tprintf(\" a\");\n\t\t}\n\t\tif (cmd[0] == 'e'){\n\t\t\tcar = str[car_y].size();\n\t\t\t\n\t\t//\tprintf(\" e\");\n\t\t}\n\t\tif (cmd[0] == 'p'){\n\t\t\t\n\t\t//\tprintf(\" p\");\n\t\t\tif (car_y == 0){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y--;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'n'){\n\t\t//\tprintf(\" n\");\n\t\t\tif (car_y == y2){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y++;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'f'){\n\t\t//\tprintf(\" f\");\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tcar_y++;\n\t\t\t\t\tcar = 0;\n\t\t\t\t\t//printf(\" %d\",car_y);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar++;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'b'){\n\t\t//\tprintf(\" b\");\n\t\t\tif (car == 0){\n\t\t\t\tif (car_y != 0){\n\t\t\t\t\tcar_y--;\n\t\t\t\t\tcar = str[car_y].size();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar--;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'd'){\n\t\t//\tprintf(\" d\");\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tstr[car_y].erase(car, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!str[car_y + 1].empty()){\n\t\t\t\t\t//str[car_y] + str[car_y + 1];\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'k'){\n\t\t//\tprintf(\" k\");\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (!str[car_y + 1].empty()){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\tb[0] = '\\0';\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb.erase();\n\t\t\t\tb = str[car_y].substr(car);\n\t\t\t\tstr[car_y].erase(car);\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'y'){\n\t\t//\tprintf(\" y\");\n\t\t\tif (b.empty());\n\t\t\telse {\n\t\t\t\tif (b[0] == '\\0'){\n\t\t\t\t\ty2 = y;\n\t\t\t\t\twhile (y < car_y){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t\ty--;\n\t\t\t\t\t}\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstr[car_y].insert(car, b);\n\t\t\t\t\tcar += b.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\ti = 0;\n\twhile (i < y){\n\t\t//puts(str[i].c_str());\n\t\tcout << str[i] << endl;\n\t\ti++;\n\t}\n\t/*\n\ti = 0;\n\twhile (!str[i].empty()){\n\t\tif (car_y == i){\n\t\t\tfor (int j = 0; j <= str[i].size(); j++){\n\t\t\t\tif (j == car){\n\t\t\t\t\tcout << 'I';\n\t\t\t\t}\n\t\t\t\tcout << str[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\telse{\n\t\t\tputs(str[i].c_str());\n\t\t}\n\t\ti++;\n\t}\n\t*/\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(5)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<short, short> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 100000007;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nvector<string> s;\nint x, y;\n\nvoid gotoend()\n{\n\ty = s[x].size();\n}\n\nvoid gotohome()\n{\n\ty = 0;\n}\n\nint check()\n{\n\tif (s[x].size() == 0 || y == s[x].size()) return 1;\n\telse return 0;\n}\n\n\nint main()\n{\n\tx = 0; y = 0;\n\tstring tmp;\n\tstring buf = \"\";\n\twhile (1)\n\t{\n\t\tgetline(cin, tmp);\n\t\tif (tmp == \"END_OF_TEXT\") break;\n\t\ts.push_back(tmp);\n\t}\n\tchar com;\n\twhile (cin >> com)\n\t{\n\t\tif (com == '-') break;\n\t\telse if (com == 'a') gotohome();\n\t\telse if (com == 'e') gotoend();\n\t\telse if (com == 'p')\n\t\t{\n\t\t\tif (x == 0) gotohome();\n\t\t\telse\n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'n')\n\t\t{\n\t\t\tif (x < s.size() - 1) x++;\n\t\t\tgotohome();\n\t\t}\n\t\telse if (com == 'f')\n\t\t{\n\t\t\tif (check() == 0) y++;\n\t\t\telse if (check() == 1 && x < s.size() - 1)\n\t\t\t{\n\t\t\t\tx++;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'b')\n\t\t{\n\t\t\tif (y > 0) y--;\n\t\t\telse if (y == 0 && x > 0)\n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tgotoend();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'd')\n\t\t{\n\t\t\tif (check() == 0) s[x].erase(y, 1);\n\t\t\telse if (check() == 1 && x < s.size() - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\ts.erase(begin(s) + x + 1);\n\t\t\t}\n\t\t}\n\t\telse if (com == 'k')\n\t\t{\n\t\t\tif (check() == 1 && x < s.size() - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\ts.erase(begin(s) + x + 1);\n\t\t\t\tbuf = \"\\n\";\n\t\t\t}\n\n\t\t\telse if (check() == 0)\n\t\t\t{\n\t\t\t\tbuf = s[x].substr(y);\n\t\t\t\ts[x].erase(y);\n\t\t\t}\n\t\t}\n\t\telse if (com == 'y')\n\t\t{\n\t\t\tif (buf == \"\\n\")\n\t\t\t{\n\t\t\t\tstring tmp = s[x].substr(y);\n\t\t\t\ts.insert(begin(s) + x + 1, tmp);\n\t\t\t\ts[x].erase(y);\n\t\t\t\tx++;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t\telse if (buf != \"\")\n\t\t\t{\n\t\t\t\ts[x].insert(y, buf);\n\t\t\t\ty += buf.size();\n\t\t\t}\n\t\t}\n\n\n\t}\n\tREP(i, s.size())\n\t{\n\t\tcout << s[i] << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <string> VS;\nistream& myis = cin;\nostream& myos = cout;\n\nconst string END_OF_TEXT = \"END_OF_TEXT\";\nconst string END_OF_COMMAND = \"-\";\n\n// prototypes\nVS solve( const VS& lines );\nvoid output( const VS& lines );\nvoid split( const VS& lines, VS& T, VS& C );\n\n// editor\nclass Editor {\npublic:\n    // members\n    VS T;\n    int r;\n    int c;\n    string buffer;\n    // methods\n    Editor( VS T ): T(T) {\n        r = 0;\n        c = 0;\n        buffer.clear();\n    }\n    VS get_text() { return T; }\n    void parse_command( string com ) {\n        if ( com == \"a\" ) command_a();\n        if ( com == \"e\" ) command_e();\n        if ( com == \"p\" ) command_p();\n        if ( com == \"n\" ) command_n();\n        if ( com == \"f\" ) command_f();\n        if ( com == \"b\" ) command_b();\n        if ( com == \"d\" ) command_d();\n        if ( com == \"k\" ) command_k();\n        if ( com == \"y\" ) command_y();\n    }\nprivate:\n    bool is_cursor_leftmost() {\n        return c == 0;\n    }\n    bool is_cursor_rightmost() {\n        return c == (int)T[r].size();\n    }\n    bool exist_next_upperline() {\n        return r - 1 >= 0;\n    }\n    bool exist_next_lowerline() {\n        return r + 1 < (int)T.size();\n    }\n    void delete_line( int n ) {\n        T.erase( T.begin() + n );\n    }\n    void delete_letter( int n ) {\n        T[r].erase( T[r].begin() + n );\n    }\n    void move_cursor_leftmost() {\n        c = 0;\n    }\n    void move_cursor_rightmost() {\n        c = T[r].size();\n    }\n    void move_cursor_up() {\n        r -= 1;\n    }\n    void move_cursor_down() {\n        r += 1;\n    }\n    void move_cursor_left() {\n        c -= 1;\n    }\n    void move_cursor_right() {\n        c += 1;\n    }\n    void move_cursor_right( int n ) {\n        c += n;\n    }\n    void command_a() {\n        /*\n          J[\\ð»ÝÌsÌæª¶ÉÚ®·éB\n        */\n        move_cursor_leftmost();\n    }\n    void command_e() {\n        /*\n          J[\\ð»ÝÌsÌsÉÚ®·éB\n        */\n        move_cursor_rightmost();\n    }\n    void command_p() {\n        /*\n          ãÉsª êÎAJ[\\ðãÌsÌæª¶ÉÚ®·éB\n          ãÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n        */\n        if ( exist_next_upperline() ) {\n            move_cursor_up();\n            move_cursor_leftmost();\n        } else {\n            move_cursor_leftmost();\n        }\n    }\n    void command_n() {\n        /*\n          ºÉsª êÎAJ[\\ðºÌsÌæª¶ÉÚ®·éB\n          ºÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n        */\n        if ( exist_next_lowerline() ) {\n            move_cursor_down();\n            move_cursor_leftmost();\n        } else {\n            move_cursor_leftmost();\n        }\n    }\n    void command_f() {\n        /*\n          J[\\ªsÉÈ¢êAJ[\\ðPÂEÉÚ®·éB\n          J[\\ªsÉ è©ÂºÉsª éêÍAJ[\\ðºÌsÌæª¶ÖÚ®·éB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( ! is_cursor_rightmost() ) {\n            move_cursor_right();\n        } else if ( is_cursor_rightmost() && exist_next_lowerline() ) {\n            move_cursor_down();\n            move_cursor_leftmost();\n        }\n    }\n    void command_b() {\n        /*\n          J[\\ªæª¶ÅÈ¢ÈçÎAJ[\\ðPÂ¶ÉÚ®·éB\n          J[\\ªæª¶Å è©ÂãÉsª éêÍAJ[\\ðãÌsÌsÖÚ®·éB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( ! is_cursor_leftmost() ) {\n            move_cursor_left();\n        } else if ( is_cursor_leftmost() && exist_next_upperline() ) {\n            move_cursor_up();\n            move_cursor_rightmost();\n        }\n    }\n    void command_d() {\n        /*\n          J[\\ª¶ðw·êÍ»Ì¶ðí·éBí³ê½¶ÌE¤Ì¶ñÍ¶ÉVtg³êéB\n          J[\\ªsðwµºÉsª éêÍAºÌsð»ÌÜÜJ[\\ÌÊuÉq°éBÈºÌsÍãÉVtg³êéB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( ! is_cursor_rightmost() ) {\n            delete_letter( c );\n        } else if ( is_cursor_rightmost() && exist_next_lowerline() ) {\n            T[r] += T[r+1];\n            delete_line( r+1 );\n        }\n    }\n    void command_k() {\n        /*\n          J[\\ªsÉ éêAºÉsª êÎAd Æ¯¶ìðµobt@ÉPÂÌüsðL^·éB\n          J[\\ªsÉÈ¢êAJ[\\ªw·¶ðÜß½E¤·×ÄÌ¶ðØèæè»êðobt@ÉL^·éB\n          J[\\Í³ÌsÌsðw·æ¤ÉÈéBSÄÌL^É¨¢Äobt@Íã«³êéB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( is_cursor_rightmost() && exist_next_lowerline() ) {\n            T[r] += T[r+1];\n            delete_line( r+1 );\n            buffer = \"\\n\";\n        } else if ( ! is_cursor_rightmost() ) {\n            buffer = T[r].substr( c );\n            T[r] = T[r].substr( 0, c );\n            move_cursor_rightmost();\n        }\n    }\n    void command_y() {\n        /*\n          obt@ªóÌêÍÈÉàµÈ¢B\n          obt@ÌàeªüsÌêAJ[\\ªw·¶Ì¼OÅüsðs¤BJ[\\ÍVµ¢sÌæª¶ÖÚ®·éB\n          obt@Ìàeª¶ñÌêAJ[\\ÌÊuÉobt@Ìàeð}ü·éB\n          J[\\ÌÊuÍàÆàÆwµÄ¢½¶Ü½ÍsÌêÖÚ®·éB\n        */\n        if ( buffer == \"\\n\" ) {\n            string tmp = T[r].substr( c );\n            T[r] = T[r].substr( 0, c );\n            T.insert( T.begin() + r + 1, tmp );\n            move_cursor_down();\n            move_cursor_leftmost();\n        } else if ( buffer != \"\" ) {\n            string left = T[r].substr( 0, c );\n            string right = T[r].substr( c );\n            T[r] = left + buffer + right;\n            move_cursor_right( buffer.size() );\n        }\n    }\n};\n\n// functions\n\nVS solve( const VS& lines ) {\n    VS T; // text\n    VS C; // commands\n    split( lines, T, C );\n\n    // edit\n    Editor editor( T );\n    for ( VS ::iterator it_i = C.begin(); it_i != C.end(); ++ it_i ) {\n        string command = *it_i;\n        editor.parse_command( command );\n    }\n    return editor.get_text();\n}\n\nvoid output( const VS& lines ) {\n    for ( VS ::const_iterator it_i = lines.begin(); it_i != lines.end(); ++ it_i ) {\n        myos << *it_i << endl;\n    }\n}\n\nvoid split( const VS& lines, VS& T, VS& C ) {\n    T.clear();\n    C.clear();\n    VS ::const_iterator it_lines = lines.begin();\n    for ( ; it_lines != lines.end(); ++ it_lines ) {\n        const string& line = *it_lines;\n        if ( line == END_OF_TEXT ) {\n            ++ it_lines;\n            break;\n        }\n        T.push_back( line );\n    }\n    for ( ; it_lines != lines.end(); ++ it_lines ) {\n        const string& line = *it_lines;\n        if ( line == END_OF_COMMAND ) {\n            break;\n        }\n        C.push_back( line );\n    }\n}\n\nint main() {\n    VS lines;\n    string line;\n    while ( getline( myis, line ) ) lines.push_back( line );\n\n    VS answer = solve( lines );\n    output( answer );\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nint main(){\n  vector<string> text(200);\n  int line = 0;\n  for(;line<11;line++){\n    getline(cin,text[line],'\\n');\n    if (text[line]==\"END_OF_TEXT\")\n      break;\n  }\n  string buf;\n  int cur[2];\n  cur[0] = 0;//0s\n  cur[1] = 0;//0¶Ú\n\n  while(true){\n    char com;\n    cin >> com;\n    if (com == '-')\n      break;\n    switch (com){\n    case 'a':\n      cur[1] = 0;\n      break;\n    case 'e':\n      cur[1] = (int)text[cur[0]].size();\n      break;\n    case 'p':\n      if (cur[0]>0)\n\tcur[0]--;\n      cur[1]=0;\n      break;\n    case 'n':\n      if (cur[0]<line-1)\n\tcur[0]++;\n      cur[1]=0;\n      break;\n    case 'f':\n      if (cur[1]<(int)text[cur[0]].size()){\n\tcur[1]++;\n      }\n      else{\n\tif (cur[0]<line-1){\n\t  cur[0]++;\n\t  cur[1]=0;\t\n\t}\n      }\n      break;\n    case 'b':\n      if (cur[1]>0)\n\tcur[1]--;\n      else{\n\tif (cur[0]>0){\n\t  cur[0]--;\n\t  cur[1]=(int)text[cur[0]].size();\t\n\t}\n      }\n      break;\n    case 'd':\n      if (cur[1]<(int)text[cur[0]].size()){\n\ttext[cur[0]] = text[cur[0]].substr(0,cur[1])+text[cur[0]].substr(cur[1]+1);\n      }\n      else{\n\tif (cur[0]<line-1){\n\t  text[cur[0]] = text[cur[0]]+text[cur[0]+1];\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i] = text[i+1];\n\t  line--;\n\t}\n      }\n      break;\n    case 'k':\n      if (cur[1]==(int)text[cur[0]].size()){\n\tif (cur[0]<line-1){\n\t  text[cur[0]] = text[cur[0]]+text[cur[0]+1];\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i] = text[i+1];\n\t  line--;\n\t  buf = \"\\n\";\n\t}\n      }\n      else{\n\tbuf = text[cur[0]].substr(cur[1]);\n\ttext[cur[0]] = text[cur[0]].substr(0,cur[1]);\n\tcur[1] = (int)text[cur[0]].size();\n      }\n      break;\n    case 'y':\n      if (buf.empty())\n\tbreak;\n      else{\n\tif (buf == \"\\n\"){\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i+1] = text[i];    \n\t  line++;\n\t  text[cur[0]] = text[cur[0]].substr(0,cur[1]);\n\t  text[cur[0]+1] = text[cur[0]].substr(cur[1]);\n\t  cur[0]++;\n\t  cur[1] = 0;\n\t}\n\telse{\n\t  text[cur[0]] = text[cur[0]].substr(0,cur[1])+buf+text[cur[0]].substr(cur[1]);\n\t  cur[1] += buf.size();\n\t}\n      }\n    default:\n      break;\n    }\n    /*      for(int i=0;i<line;i++)\n\tcout << text[i] << endl;\n\tcout << \"(\" << cur[0] << \",\" << cur[1] << \")\" << endl;\n\tcout << \"#\" << endl;*/\n  }\n  for(int i=0;i<line;i++)\n    cout << text[i] << endl;\n  return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main(){\n\tstring s[500];\n\tint line = 0;\n\tfor ( string in; getline( cin, in ), in != \"END_OF_TEXT\"; ++line ){\n\t\ts[ line ] = in;\n\t}\n\t\n\tint pX = 0;\n\tint pY = 0;\n\t\n\tstring buf;\n\tfor ( string in; cin >> in, in != \"-\"; ) {\n\t\tif ( in == \"a\" ) {\n\t\t\tpX = 0;\n\t\t} else if ( in == \"e\" ) {\n\t\t\tpX = s[ pY ].length();\n\t\t} else if ( in == \"p\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( 0 != pY ) {\n\t\t\t\t--pY;\n\t\t\t}\n\t\t} else if ( in == \"n\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( pY != line - 1 ) {\n\t\t\t\t++pY;\n\t\t\t}\n\t\t} else if ( in == \"f\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\t++pX;\n\t\t\t} else if ( pY != line - 1 ) {\n\t\t\t\tpX = 0;\n\t\t\t\t++pY;\n\t\t\t}\n\t\t} else if ( in == \"b\" ) {\n\t\t\tif ( 0 < pX ) {\n\t\t\t\t--pX;\n\t\t\t} else {\n\t\t\t\tif ( 0 < pY ) {\n\t\t\t\t\t--pY;\n\t\t\t\t\tpX = s[ pY ].length();\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( in == \"d\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + s[ pY ].substr( pX + 1 );\n\t\t\t} else if ( pY < line - 1 ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\ts[ line - 1 ] = \"\";\n\t\t\t\t--line;\n\t\t\t}\n\t\t} else if ( in == \"k\" ) {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\tbuf = s[ pY ].substr( pX );\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t} else if ( pY < line - 1 ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\ts[ line - 1 ] = \"\";\n\t\t\t\t--line;\n\t\t\t\tbuf = \"\\n\";\n\t\t\t}\n\t\t} else if ( in == \"y\" ) {\n\t\t\tif ( !buf.empty() ) {\n\t\t\t\tif ( buf == \"\\n\" ) {\n\t\t\t\t\tfor ( int i = line - 1; pY <= i; --i ) {\n\t\t\t\t\t\ts[ i + 1 ] = s[ i ];\n\t\t\t\t\t}\n\t\t\t\t\ts[ pY + 1 ] = s[ pY ].substr( pX );\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t\t\t++line;\n\t\t\t\t} else {\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + buf + s[ pY ].substr( pX );\n\t\t\t\t\tpX += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor ( int i = 0; i < line; ++i ) cout << s[ i ] << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main()\n{\n\tstring str[300];\n\tstring b = \"???\";\n\tint y = 0, y2 = 0;\n\t\n\twhile (getline(std::cin, str[y]), str[y] != \"END_OF_TEXT\"){\n\t\ty++;\n\t}\n\ty2 = --y;\n\t\n\tchar cmd[2];\n\tint car = 0, car_y = 0;\n\t\n\twhile (scanf(\"%s\", cmd), cmd[0] != '-'){\n\t\tif (cmd[0] == 'a'){\n\t\t\tcar = 0;\n\t\t}\n\t\tif (cmd[0] == 'e'){\n\t\t\tcar = str[car_y].size();\n\t\t}\n\t\tif (cmd[0] == 'p'){\n\t\t\tif (car_y == 0){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y--;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'n'){\n\t\t\tif (car_y != y){\n\t\t\t\tcar_y++;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\t\n\t\t\telse {\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'f'){\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tcar++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tcar_y++;\n\t\t\t\t\tcar = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'b'){\n\t\t\tif (car != 0){\n\t\t\t\tcar--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != 0){\n\t\t\t\t\tcar_y--;\n\t\t\t\t\tcar = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'd'){\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tstr[car_y].erase(car, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = y - 1;\n\t\t\t\t\ty = car_y;\n\t\t\t\t\twhile (++y < y2){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y].erase();\n\t\t\t\t\t\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'k'){\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = y;\n\t\t\t\t\ty = car_y;\n\t\t\t\t\twhile (++y < y2){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y].erase();\n\t\t\t\t\t\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb = str[car_y].substr(car);\n\t\t\t\tstr[car_y].erase(car);\n\t\t\t\tcar = str[car_y].size();\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'y'){\n\t\t\tif(b != \"???\"){\n\t\t\t\tif (b[0] == '\\0'){\n\t\t\t\t\ty2 = y + 1;\n\t\t\t\t\twhile (y > car_y + 1){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y] = str[car_y].substr(car);\n\t\t\t\t\tstr[car_y].erase(car);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstr[car_y].insert(car, b);\n\t\t\t\t\tcar += b.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int j = 0; j <= y; j++){\n\t\tcout << str[j] << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[110];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tif(i<110) t[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tif(row<110) col = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 && row < 110 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row < 110 && row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( row < 110 && col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else if( row < 110 ){\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( row < 110 && buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line+1 < 110 && line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\t/*t[row+1] = t[row].substr( col );\n\t\t\t\t\tt[row].erase( col );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;*/\n\t\t\t\t}else if( row < 110 ){\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef vector <string> VS;\n\nclass Cursor\n{\npublic:\n\tint top;\t// ã©ç½sÚ©\n\tint left;\t// ¶©ç½¶Ú©\n};\n\nVS\t\ttext;\nCursor\tc;\nstring\tbuf;\n\nvoid command( const string& cmd )\n{\n\tstring& line = text[c.top];\n\n\t/*\n\t// debug\n\tcout << \"command = \" << cmd << endl;\n\tcout << \"buffer  = \" << buf << endl;\n\tcout << \"before -> \" << c.left << \" \" << c.top << endl;\n\t*/\n\n\t// J[\\ð»ÝÌsÌæªÉÚ®·é\n\tif ( cmd == \"a\" )\n\t{\n\t\tc.left = 0;\n\t}\n\n\t// J[\\ð»ÝÌsÌsÉÚ®·é\n\telse if ( cmd == \"e\" )\n\t{\n\t\tc.left = line.length();\n\t}\n\n\t// J[\\ðãÉÚ®\n\telse if ( cmd == \"p\" )\n\t{\n\t\tif ( c.top > 0 )\n\t\t{\n\t\t\tc.top --;\n\t\t\tc.left = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc.left = 0;\n\t\t}\n\t}\n\n\t// J[\\ðºÉÚ®\n\telse if ( cmd == \"n\" )\n\t{\n\t\tif ( c.top + 1 < text.size() )\n\t\t\tc.top ++;\n\t\telse\n\t\t\tc.left = 0;\n\t}\n\n\t// J[\\ðEÉÚ®\n\telse if ( cmd == \"f\" )\n\t{\n\t\tif ( c.left < line.length() )\n\t\t{\n\t\t\tc.left ++;\n\t\t}\n\t\telse if ( c.left == line.length() )\n\t\t{\n\t\t\tif ( c.top + 1 < text.size() )\n\t\t\t{\n\t\t\t\tc.top ++;\n\t\t\t\tc.left = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// J[\\ð¶ÉÚ®\n\telse if ( cmd == \"b\" )\n\t{\n\t\tif ( c.left > 0 )\n\t\t{\n\t\t\tc.left --;\n\t\t}\n\t\telse if ( c.left == 0 )\n\t\t{\n\t\t\tif ( c.top > 0 )\n\t\t\t{\n\t\t\t\tc.top --;\n\t\t\t\tstring& new_line = text[ c.top ];\n\t\t\t\tc.left = new_line.length();\n\t\t\t}\n\t\t}\n\t}\n\n\t// ¶ðí\n\telse if ( cmd == \"d\" )\n\t{\n\t\tif ( c.left < line.length() )\n\t\t{\n\t\t\tstring new_line = \"\";\n\t\t\tfor ( int i = 0; i < c.left; i++ )\n\t\t\t{\n\t\t\t\tnew_line += line[i];\n\t\t\t}\n\t\t\tfor ( int i = c.left + 1; i < line.length(); i++ )\n\t\t\t{\n\t\t\t\tnew_line += line[i];\n\t\t\t}\n\t\t\ttext[c.top] = new_line;\n\t\t}\n\t\telse if ( c.left == line.length() )\n\t\t{\n\t\t\tif ( c.top + 1 < text.size() )\n\t\t\t{\n\t\t\t\t// ºÌsðJ[\\ÊuÉÂÈ°é\n\t\t\t\tstring new_line = \"\";\n\t\t\t\tfor ( int i = 0; i <= c.left; i++ )\n\t\t\t\t{\n\t\t\t\t\tnew_line += line[i];\n\t\t\t\t}\n\t\t\t\tstring& bottom = text[c.top+1];\n\t\t\t\tfor ( int i = 0; i < bottom.length(); i++ )\n\t\t\t\t{\n\t\t\t\t\tnew_line += bottom[i];\n\t\t\t\t}\n\t\t\t\ttext[c.top] = new_line;\n\t\t\t\tfor ( int i = c.top + 1; i < text.size() - 1; i++ )\n\t\t\t\t{\n\t\t\t\t\ttext[i] = text[i+1];\n\t\t\t\t}\n\t\t\t\ttext.erase( text.end() - 1 );\n\t\t\t}\n\t\t}\n\t}\n\n\t// J[\\ªw·¶ðÜß½E¤·×ÄðØèæè\n\t// sÉ éêÍüsðobt@ÉL^AºÌsÍãÖ\n\telse if ( cmd == \"k\" )\n\t{\n\t\tif ( c.left == line.length() )\n\t\t{\n\t\t\tif ( c.top + 1 < text.size() )\n\t\t\t{\n\t\t\t\t// ºÌsðJ[\\ÊuÉÂÈ°é\n\t\t\t\tstring new_line = \"\";\n\t\t\t\tfor ( int i = 0; i <= c.left; i++ )\n\t\t\t\t{\n\t\t\t\t\tnew_line += line[i];\n\t\t\t\t}\n\t\t\t\tstring& bottom = text[c.top+1];\n\t\t\t\tfor ( int i = 0; i < bottom.length(); i++ )\n\t\t\t\t{\n\t\t\t\t\tnew_line += bottom[i];\n\t\t\t\t}\n\t\t\t\ttext[c.top] = new_line;\n\t\t\t\tfor ( int i = c.top + 1; i < text.size() - 1; i++ )\n\t\t\t\t{\n\t\t\t\t\ttext[i] = text[i+1];\n\t\t\t\t}\n\t\t\t\ttext.erase( text.end() - 1 );\n\t\t\t}\n\t\t\tbuf = \"\\n\";\n\t\t}\n\t\telse if ( c.left < line.length() )\n\t\t{\n\t\t\tstring left  = \"\";\n\t\t\tstring right = \"\";\n\t\t\tfor ( int i = 0; i < c.left; i++ )\n\t\t\t\tleft  += line[i];\n\t\t\tfor ( int i = c.left; i < line.length(); i++ )\n\t\t\t\tright += line[i];\n\t\t\t\n\t\t\tstring& new_line = text[c.top];\n\t\t\tnew_line = left;\n\t\t\tbuf = right;\n\t\t\tc.left = new_line.length();\n\t\t}\n\t}\n\n\t// obt@ÌàeªüsÌêAüs·é\n\t// J[\\ÍVµ¢sÌæª\n\t// ¶ñÌêÍàeð}ü\n\t// J[\\ÊuÍ\n\telse if ( cmd == \"y\" )\n\t{\n\t\tif ( buf == \"\\n\" )\n\t\t{\n\t\t\tstring left;\n\t\t\tstring right;\n\t\t\tfor ( int i = 0; i < c.left; i++ )\n\t\t\t\tleft  += line[i];\n\t\t\tfor ( int i = c.left; i < line.length(); i++ )\n\t\t\t\tright += line[i];\n\n\t\t\tstring new_line = text[c.top];\n\t\t\tnew_line = left;\n\n\t\t\ttext.insert( text.begin() + c.top + 1, right );\n\n\t\t\tc.top++;\n\t\t\tc.left = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstring left  = \"\";\n\t\t\tstring right = \"\";\n\t\t\tfor ( int i = 0; i < c.left; i++ )\n\t\t\t\tleft += line[i];\n\t\t\tfor ( int i = c.left; i < line.length(); i++ )\n\t\t\t\tright += line[i];\n\t\t\tstring new_line = left + buf + right;\n\t\t\ttext[c.top] = new_line;\n\t\t}\n\t}\n\n\t// cout << \"after  -> \" << c.left << \" \" << c.top << endl << endl;\n}\n\nint main( void )\n{\n\t// eíîñÌú»\n\tc.top = c.left = 0;\n\tbuf = \"\";\n\n\t// ¶ñðüÍ\n\tstring in;\n\twhile ( cin >> in && in != \"END_OF_TEXT\" )\n\t{\n\t\ttext.push_back( in );\n\t}\n\n\t// R}hðÀs\n\tstring cmd;\n\twhile ( cin >> cmd && cmd != \"-\" )\n\t{\n\t\tcommand( cmd );\n\t}\n\n\t// R}hÀsãÌ¶ñðoÍ·é\n\tfor ( vector <string>::iterator it = text.begin(); it != text.end(); it++ )\n\t{\n\t\tcout << *it << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author: FreePascal\n * Created Time:  2011/8/31 14:37:10\n * File Name: 8331d.cpp\n */\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <deque>\n#include <list>\n#include <stack>\nusing namespace std;\n#define out(v) cerr << #v << \": \" << (v) << endl\n#define SZ(v) ((int)(v).size())\nconst int maxint = -1u>>1;\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\nvector<string> text;\nstring buf,cmd;\nint x = 0,y = 0;\nvoid a(){\n    y = 0;\n}\nvoid e(){\n    y = text[x].size();\n}\nvoid p(){\n    if(x>0) x--;\n    y = 0;\n}\nvoid n(){\n    if(x<text.size()-1) x++;\n    y = 0;\n}\nvoid f(){\n    if( y == text[x].size() && x == text.size()-1) return ;\n    y++;\n    if(y > text[x].size()){\n        x++;\n        y = 0;\n    }\n}\nvoid b(){\n    if(y == 0 && x == 0) return;\n    y--;\n    if(y<0){\n        x--; \n        y = text[x].size();\n    }\n}\nvoid d(){\n    if(y < text[x].size()) {\n        text[x].erase(y,1);\n    }\n    else if(x<text.size()-1)\n    {\n        text[x] += text[x+1];\n        //text.erase(x+1);\n        for(int i = x+1;i < text.size()-1;i++)\n            text[i] = text[i+1];\n        text.resize(text.size()-1);\n    }\n}\nvoid k(){\n    if(y == text[x].size()) {\n        d();\n        buf = \"\\n\";\n    }\n    else\n    {\n        buf = text[x].substr(y);\n        text[x].erase(y);\n        y = text[x].size();\n    }\n}\nvoid cy(){\n    if( buf == \"\") return;\n    else if(buf == \"\\n\"){\n        string tm;\n        tm = text[x].substr(y);\n        text[x].erase(y);\n        //text.insert(x);\n        text.push_back(\"\");\n        for(int i = x+2;i<text.size();i++)\n            text[i] = text[i-1];\n        text[x+1] = tm;\n        x++;\n        y = 0;\n    }\n    else\n    {\n        text[x].insert(y,buf);\n        y+=buf.size();\n    }\n}\nvoid init(){\n    string s;\n    while(getline(cin,s) && s!= \"END_OF_TEXT\")\n        text.push_back(s);\n    while(cin>>s && s!=\"-\")\n        cmd+=s;\n}\nvoid work(){\n    for(int i = 0;i < cmd.size();i++)\n    {\n        switch(cmd[i]){\n            case 'a': a();break;\n            case 'e': e();break;\n            case 'p': p();break;\n            case 'n': n();break;\n            case 'f': f();break;\n            case 'b': b();break;\n            case 'd': d();break;\n            case 'k': k();break;\n            case 'y': cy();break;\n        } \n}\n}\nvoid prnt(){\n    for(int i = 0;i < text.size();i ++)\n        cout<<text[i]<<endl;\n}\n\nint main() {\n    init();\n    work();\n    prnt();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[111];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\tfor(int i=0 ; i<111 ; i++)\n\t\tt[i] = \"\";\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tif(i<110) t[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tif(row<110) col = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 && row < 110 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row < 110 && row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( row < 110 && col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else if( row < 110 ){\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( row < 110 && buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line+1 < 110 && line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\t//t[row+1] =\n\t\t\t\t\tif( col != t[row].size() ) ;//t[row].substr( col );\n\t\t\t\t\t//t[row].erase( col );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else if( row < 110 ){\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[110];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tif(i<110) t[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tif(row<110) col = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 && row < 110 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row < 110 && row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( row < 110 && col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else if( row < 110 ){\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}/*else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( row < 110 && buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line+1 < 110 && line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\tt[row+1] = t[row].substr( col );\n\t\t\t\t\tt[row].erase( col );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else if( row < 110 ){\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[128];\nstring buf;\nint lines;\nvoid delete_line(int y)\n{\n    for (int i = y; y < lines; ++y)\n\ts[i] = s[i + 1];\n    s[--lines] = \"\";\n    if (lines == 0)\n\tlines = 1;\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; ++i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    for (lines = 0; ; ++lines)\n    {\n\tstring t;\n\tcin >> t;\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines] = t;\n    }\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    if (y != 0)\n\t\t--y;\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    if (y + 1 != lines)\n\t\t++y;\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y + 1 != lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t\tx = 0, --y;\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t\ts[y].erase(x, 1);\n\t    else\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t    }\n\t    break;\n\t}\n\tcase 'k':\n\t{\n\t    if (x == s[y].size())\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    else\n\t    {\n\t\tbuf = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\ts[y + 1] = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = 0, ++y;\n\t    }\n\t    else if (!buf.empty())\n\t\ts[y] += buf;\n\t    break;\n\t}\n\t}\n    }\n\n    for (int i = 0; i < lines; ++i)\n\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nstring s[102],buf;\nint l,r,N;\n\nvoid a(void){r=0;}\nvoid e(void){r=max(0,(int)s[l].size()-1);}\nvoid p(void){\n\tif(l>0)l--,r=0;\n\telse r=0;\n}\n\nvoid n(void){\n\tif(l<N-1)l++,r=0;\n\telse r=0;\n}\n\nvoid f(void){\n\tif(r<max(0,(int)s[l].size()-1))r++;\n\telse l++,r=0;\n}\n\nvoid b(void){\n\tif(r>0)r--;\n\telse if(l>0)r=s[--l].size();\n}\n\nvoid d(void){\n\tif(r==s[l].size()-1){\n\t\tif(l<N-1){\n\t\t\ts[l]+=s[l+1];\n\t\t\tfor(int i=l+1;i<N-1;i++)s[i]=s[i+1];\n\t\t\tN--;\n\t\t}\n\t}\n\telse s[l].erase(r,1);\n}\n\nvoid k(void){\n\tif(r==s[l].size()-1 && l<N-1)d(),buf=\"\\n\";\n\telse {\n\t\tbuf=s[l].substr(max(0,r-1));\n\t\ts[l].erase(max(0,r-1));\n\t}\n}\n\nvoid y(void){\n\tif(buf.empty())return ;\n\tif(buf==\"\\n\"){\n\t\tfor(int i=++N;i>l;i--)s[i]=s[i-1];\n\t\ts[l+1]=s[l].substr(max(0,r-1));\n\t\ts[l].erase(max(0,r-1));\n\t\tl++,r=0;\n\t}\n\telse {\n\t\ts[l].insert(min((int)s[l].size(),r+1),buf);\n\t\tr+=buf.size();\n\t}\n}\n\n\nint main(void){\n\tN=0;\n\twhile(getline(cin,s[N])){\n\t\tif(s[N]==\"END_OF_TEXT\")break;\n\t\tN++;\n\t}\n\tl=r=0;\n\tbuf.clear();\n\t\n\t\t\n\tstring C;\n\twhile(cin >> C,C!=\"-\"){\n\t\t\n\t\tif(C==\"a\")a();\n\t\telse if(C==\"e\")e();\n\t\telse if(C==\"p\")p();\n\t\telse if(C==\"n\")n();\n\t\telse if(C==\"f\")f();\n\t\telse if(C==\"b\")b();\n\t\telse if(C==\"d\")d();\n\t\telse if(C==\"k\")k();\n\t\telse if(C==\"y\")y();\n\t}\n\t\n\tfor(int i=0;i<N;i++){\n\t\tcout << s[i] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(5)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<short, short> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 100000007;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator > (const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nvector<string> s;\nint x, y;\n\nvoid gotoend()\n{\n\ty = s[x].size();\n}\n\nvoid gotohome()\n{\n\ty = 0;\n}\n\nint check()\n{\n\tif (s[x].size() == 0 || y == s[x].size()) return 1;\n\telse return 0;\n}\n\n\nint main()\n{\n\tx = 0; y = 0;\n\tstring tmp;\n\tstring buf = \"karappo!!!!!!!!!\";\n\twhile (1)\n\t{\n\t\tcin >> tmp;\n\t\tif (tmp == \"END_OF_TEXT\") break;\n\t\ts.push_back(tmp);\n\t}\n\tchar com;\n\twhile (cin >> com)\n\t{\n\t\tif (com == '-') break;\n\t\telse if (com == 'a') gotohome();\n\t\telse if (com == 'e') gotoend();\n\t\telse if (com == 'p')\n\t\t{\n\t\t\tif (x == 0) gotohome();\n\t\t\telse \n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'n')\n\t\t{\n\t\t\tif (x < s.size() - 1) x++;\n\t\t\tgotohome();\n\t\t}\n\t\telse if (com == 'f')\n\t\t{\n\t\t\tif (check() == 0) y++;\n\t\t\telse if (check()==1&&x < s.size() - 1)\n\t\t\t{\n\t\t\t\tx++;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'b')\n\t\t{\n\t\t\tif (y != 0) y--;\n\t\t\telse if (y == 0 && x > 0)\n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tgotoend();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'd')\n\t\t{\n\t\t\tif (check() == 0) s[x].erase(y, 1);\n\t\t\telse if (check() == 1 && x < s.size() - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\ts.erase(begin(s) + x + 1);\n\t\t\t}\n\t\t}\n\t\telse if (com == 'k')\n\t\t{\n\t\t\tif (check() == 1 && x < s.size() - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\ts.erase(begin(s) + x + 1);\n\t\t\t\tbuf = \"kaigyousuru!!!!!!!\";\n\t\t\t}\n\t\t\t\n\t\t\telse\n\t\t\t{\n\t\t\t\tbuf = s[x].substr(y);\n\t\t\t\ts[x].erase(y);\n\t\t\t}\n\t\t}\n\t\telse if (com == 'y')\n\t\t{\n\t\t\tif (buf == \"karappo!!!!!!!!!\") continue;\n\t\t\telse if (buf == \"kaigyousuru!!!!!!!\")\n\t\t\t{\n\t\t\t\tint t = s.size() - 1;\n\t\t\t\ts.push_back(\"\");\n\t\t\t\twhile (t > x)\n\t\t\t\t{\n\t\t\t\t\ts[t + 1] = s[t];\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t\ts[x + 1] = s[x].substr(y);\n\t\t\t\ts[x].erase(y);\n\t\t\t\tx++;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts[x].insert(y, buf);\n\t\t\t\ty += buf.size();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tREP(i, s.size())\n\t\t{\n\t\t\tcout << s[i] << endl;\n\t\t}\n\t\tcout << x << \" \" << y << endl;\n\t\tcout << buf;\n\t\tcout << endl << endl;\n\t\t*/\n\t}\n\tREP(i, s.size())\n\t{\n\t\tcout << s[i] << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n)-1;i>=(m);--i)\n#define repc(i,n) for(int i=0;i<=(n);++i)\n#define repcn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repcd(i,n) for(int i=(n);i>=0;--i)\n#define repcnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define repc0(i,n) for(i=0;i<=(n);++i)\n#define repcn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repcd0(i,n) for(i=(n);i>=0;--i)\n#define repcnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE cout<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nstring str[111];\n\nint main() {\n\tint h = 0;\n\tIL {\n\t\tgetline(cin, str[h]);\n\t\tif (str[h][sz(str[h]) - 1] < ' ') str[h] = str[h].substr(0, sz(str[h]) - 1);\n\t\tif (str[h] == \"END_OF_TEXT\") break;\n\t\t++h;\n\t}\n\tint x = 0, y = 0;\n\tstring com, buf = \"\";\n\tIL {\n\t\tcin >> com;\n\t\tif (com == \"a\") {\n\t\t\tx = 0;\n\t\t} else if (com == \"e\") {\n\t\t\tx = sz(str[y]);\n\t\t} else if (com == \"p\") {\n\t\t\tx = 0;\n\t\t\tif (y > 0) --y;\n\t\t} else if (com == \"n\") {\n\t\t\tx = 0;\n\t\t\tif (y < h - 1) ++y; \n\t\t} else if (com == \"f\") {\n\t\t\tif (x < sz(str[y])) ++x;\n\t\t\telse if (y < h - 1) {x = 0; ++y;}\n\t\t} else if (com == \"b\") {\n\t\t\tif (x > 0) --x;\n\t\t\telse if (y > 0) {--y; x = sz(str[y]);}\n\t\t} else if (com == \"d\") {\n\t\t\tif (x < sz(str[y])) str[y] = str[y].substr(0, x) + str[y].substr(x + 1);\n\t\t\telse if (y < h - 1) {\n\t\t\t\tstr[y] += str[y + 1];\n\t\t\t\t--h;\n\t\t\t\trepn (i, y + 1, h) str[i] = str[i + 1];\n\t\t\t}\n\t\t} else if (com == \"k\") {\n\t\t\tif (x == sz(str[y])) {\n\t\t\t\tif (y < h - 1) {\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t\tstr[y] += str[y + 1];\n\t\t\t\t\t--h;\n\t\t\t\t\trepn (i, y + 1, h) str[i] = str[i + 1];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbuf = str[y].substr(x);\n\t\t\t\tstr[y] = str[y].substr(0, x);\n\t\t\t\tx = sz(str[y]);\n\t\t\t}\n\t\t} else if (com == \"y\") {\n\t\t\tif (buf == \"\\n\") {\n\t\t\t\t++h;\n\t\t\t\trepn (i, y + 2, h) str[i] = str[i - 1];\n\t\t\t\tstr[y + 1] = str[y].substr(x);\n\t\t\t\tstr[y] = str[y].substr(0, x);\n\t\t\t\tx = 0;\n\t\t\t\t++y;\n\t\t\t} else if (sz(buf)  > 0) {\n\t\t\t\tstr[y] = str[y].substr(0, x) + buf + str[y].substr(x);\n\t\t\t\tx += sz(buf);\n\t\t\t}\n\t\t} else if (com == \"-\") {\n\t\t\tbreak;\n\t\t}\n\t}\n\trep (i, h) cout << str[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "import java.awt.Point;\nimport java.io.InputStreamReader;\nimport java.nio.Buffer;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.regex.Pattern;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) throws Exception {\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner sc = new Scanner(new InputStreamReader(System.in));\n\n\t\tArrayList<StringBuilder> lines = new ArrayList<StringBuilder>();\n\t\twhile (true) {\n\t\t\tString text = sc.next();\n\t\t\tif (text.equals(\"END_OF_TEXT\"))\n\t\t\t\tbreak;\n\t\t\tlines.add(new StringBuilder(text));\n\t\t}\n\t\tPoint cursor = new Point();\n\n\t\tString buffer = null;\n\n\t\tcommandLoop: while (true) {\n\t\t\tchar command = sc.next().charAt(0);\n\t\t\tStringBuilder currentLine = lines.get(cursor.y);\n\t\t\tswitch (command) {\n\t\t\tcase 'a':\n\t\t\t\tcursor.x = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tcursor.x = currentLine.length();\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tif (cursor.y > 0)\n\t\t\t\t\tcursor.y--;\n\t\t\t\telse\n\t\t\t\t\tcursor.x = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tif (cursor.y + 1 < lines.size())\n\t\t\t\t\tcursor.y++;\n\t\t\t\tcursor.x = 0; // ?\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (cursor.x < currentLine.length()) {\n\t\t\t\t\tcursor.x++;\n\t\t\t\t}\n\t\t\t\telse if (cursor.y + 1 < lines.size()) {\n\t\t\t\t\tcursor.y++;\n\t\t\t\t\tcursor.x = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tif (cursor.x > 0) {\n\t\t\t\t\tcursor.x--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (cursor.y > 0) {\n\t\t\t\t\tcursor.y--;\n\t\t\t\t\tcursor.x = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif (cursor.x < currentLine.length()) {\n\t\t\t\t\tcurrentLine.deleteCharAt(cursor.x);\n\t\t\t\t}\n\t\t\t\telse if (cursor.y + 1 < lines.size()) {\n\t\t\t\t\tcurrentLine.append(lines.remove(cursor.y + 1));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tif (cursor.x == currentLine.length()) {\n\t\t\t\t\tif (cursor.y + 1 < lines.size()) {\n\t\t\t\t\t\tcurrentLine.append(lines.remove(cursor.y + 1));\n\t\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = currentLine.substring(cursor.x);\n\t\t\t\t\tcurrentLine.delete(cursor.x, currentLine.length());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\tif (buffer != null) {\n\t\t\t\t\tif (buffer.equals(\"\\n\")) {\n\t\t\t\t\t\tStringBuilder newLine = new StringBuilder();\n\t\t\t\t\t\tif(cursor.x != currentLine.length()) {\n\t\t\t\t\t\t\tnewLine.append(currentLine.substring(cursor.x));\n\t\t\t\t\t\t\tcurrentLine.delete(cursor.x, currentLine.length());\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlines.add(cursor.y, newLine);\n\t\t\t\t\t\tcursor.y++;\n\t\t\t\t\t\tcursor.x = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(cursor.x == currentLine.length())\n\t\t\t\t\t\t\tcurrentLine.append(buffer);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcurrentLine.insert(cursor.x, buffer);\n\t\t\t\t\t\tcursor.x += buffer.length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak commandLoop;\n\t\t\t}\n//\t\t\tSystem.out.println(cursor);\n//\t\t\tSystem.out.println(currentLine);\n\t\t}\n\t\tfor (StringBuilder sb : lines) {\n\t\t\tSystem.out.println(sb);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Emacs{\n  int line,column;\n  string buffer;\n  vector<string> text;\n\n  void editText(){\n    for(int i = 0 ; i < (int)text.size() ; i++){\n      if(isEmptyLine(i)){ text[i] = \" \"; }\n    }\n  }\n\n  void order(char command){\n    editText();\n    switch(command){\n    case 'a': funcA(); break;\n    case 'e': funcE(); break;\n    case 'p': funcP(); break;\n    case 'n': funcN(); break;\n    case 'f': funcF(); break;\n    case 'b': funcB(); break;\n    case 'd': funcD(); break;\n    case 'k': funcK(); break;\n    case 'y': funcY(); break;\n    }\n  }\n\n  bool isEmptyLine(int l){\n    for(int i = 0 ; i < (int)text[l].size() ; i++){\n      if(text[l][i] != ' '){ return false; }\n    }\n    return true;\n  }\n\n  void funcA(){\n    column = 0;\n  }\n  \n  void funcE(){\n    column = text[line].size();\n  }\n\n  void funcP(){\n    if(line > 0){\n      line--;\n    }else{\n      column = 0;\n    }\n  }\n\n  void funcN(){\n    if(line+1 < (int)text.size()){\n      line++;\n    }else{\n      column = 0;\n    }\n  }\n\n  void funcF(){\n    if(column == (int)text[line].size()){\n      if(line+1 < (int)text.size()){\n        line++;\n        column = 0;\n      }\n    }else{\n      column++;\n    }\n  }\n  \n  void funcB(){\n    if(column == 0){\n      if(line != 0){\n        line--;\n        column = text[line].size();\n      }\n    }else{\n      column--;\n    }\n  }\n\n  void funcD(){\n    if(isEmptyLine(line)){\n      int len = text.size();\n      vector<string> ntext(len-1);\n      for(int i = 0 ; i < line ; i++){\n        ntext[i] = text[i];\n      }\n      for(int i = line ; i < len-1 ; i++){\n        ntext[i] = text[i+1];\n      }\n      text = ntext;\n      return;\n    }\n    if(0 <= column && column < (int)text[line].size()){\n      text[line] = text[line].substr(0,column) + text[line].substr(column+1);\n    }else{\n      int len = text.size();\n      if(line+1 < len){\n        vector<string> ntext(len-1);\n        for(int i = 0 ; i < line-1 ; i++){\n          ntext[i] = text[i];\n        }\n        ntext[line] = text[line] + text[line+1];\n        for(int i = line+2 ; i < len ; i++){\n          ntext[i] = text[i];\n        }\n        text = ntext;\n      }\n    }\n  }\n\n  void funcK(){\n    int len = text[line].size();\n    if(column == len){\n      int len2 = text.size();\n      if(line+1 < len2){\n        buffer = \"\\n\";\n        vector<string> ntext(len2-1);\n        for(int i = 0 ; i < line-1 ; i++){\n          ntext[i] = text[i];\n        }\n        ntext[line] = text[line] + text[line+1];\n        for(int i = line+2 ; i < len ; i++){\n          ntext[i] = text[i];\n        }\n        text = ntext;\n      }\n    }else{\n      buffer.clear();\n      for(int i = column ; i < len ; i++){\n        buffer += text[line][i];\n      }\n      text[line].resize(column);\n    }\n  }\n\n  void funcY(){\n    if(buffer.empty()){ return; }\n    if(buffer == \"\\n\"){\n      string str = text[line];\n      text[line] = str.substr(0,column);\n      if(line+1 < (int)text.size()){\n        text[line+1] = str.substr(column) + text[line+1];\n      }else{\n        text.push_back(str.substr(column));\n      }\n    }else{\n      string str = text[line];\n      str = str.substr(0,column) + buffer + str.substr(column);\n      text[line] = str;\n    }\n  }\n\n  void print(){\n    int len = text.size();\n    for(int i = 0 ; i < len ; i++){\n      cout << text[i] << endl;\n    }\n  }\n};\n\nint main(){\n  Emacs emacs;\n  string str;\n  while(getline(cin,str), str != \"END_OF_TEXT\"){\n    emacs.text.push_back(str);\n  }\n  emacs.line = emacs.column = 0;\n  char command;\n  while(cin >> command, command != '-'){\n    emacs.order(command);\n  }\n  emacs.print();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(5)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<short, short> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 100000007;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator > (const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nvector<string> s;\nint x, y;\n\nvoid gotoend()\n{\n\ty = s[x].size();\n}\n\nvoid gotohome()\n{\n\ty = 0;\n}\n\nint check()\n{\n\tif (s[x].size() == 0) return 1;\n\telse if (y == s[x].size()-1) return 2;\n\telse return 0;\n}\n\n\nint main()\n{\n\tx = 0; y = 0;\n\tstring tmp;\n\tstring buf = \"@\";\n\twhile (1)\n\t{\n\t\tcin >> tmp;\n\t\tif (tmp == \"END_OF_TEXT\") break;\n\t\ts.push_back(tmp);\n\t}\n\tchar com;\n\twhile (cin >> com)\n\t{\n\t\tif (com == '-') break;\n\t\telse if (com == 'a') gotohome();\n\t\telse if (com == 'e') gotoend();\n\t\telse if (com == 'p')\n\t\t{\n\t\t\tif (x == 0) gotohome();\n\t\t\telse \n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'n')\n\t\t{\n\t\t\tif (x < s.size() - 1) x++;\n\t\t\tgotohome();\n\t\t}\n\t\telse if (com == 'f')\n\t\t{\n\t\t\tif (check() == 0) y++;\n\t\t\telse if (x < s.size() - 1)\n\t\t\t{\n\t\t\t\tx++;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'b')\n\t\t{\n\t\t\tif (y != 0) y--;\n\t\t\telse if (y == 0 && x > 0)\n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tgotoend();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'd')\n\t\t{\n\t\t\tif (check() == 0) s[x].erase(y, 1);\n\t\t\telse if (check() == 2 && x < s.size() - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\tint t = x + 1;\n\t\t\t\twhile (t < s.size() - 1)\n\t\t\t\t{\n\t\t\t\t\ts[t] = s[t + 1];\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t\ts.pop_back();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'k')\n\t\t{\n\t\t\tif (check() != 0 && x < s.size() - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\tint t = x + 1;\n\t\t\t\twhile (t < s.size() - 1)\n\t\t\t\t{\n\t\t\t\t\ts[t] = s[t + 1];\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t\ts.pop_back();\n\t\t\t\tbuf = \"#\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbuf = s[x].substr(y);\n\t\t\t\ts[x].erase(y);\n\t\t\t}\n\t\t}\n\t\telse if (com == 'y')\n\t\t{\n\t\t\tif (buf == \"@\") continue;\n\t\t\telse if (buf == \"#\")\n\t\t\t{\n\t\t\t\tint t = s.size() - 1;\n\t\t\t\ts.push_back(\"\");\n\t\t\t\twhile (t > x)\n\t\t\t\t{\n\t\t\t\t\ts[t + 1] = s[t];\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t\ts[x + 1] = s[x].substr(y);\n\t\t\t\ts[x].erase(y);\n\t\t\t\tx++;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts[x].insert(y, buf);\n\t\t\t\ty += buf.size();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tREP(i, s.size())\n\t\t{\n\t\t\tcout << s[i] << endl;\n\t\t}\n\t\tcout << x << \" \" << y << endl;\n\t\tcout << buf;\n\t\tcout << endl << endl;\n\t\t*/\n\t}\n\tREP(i, s.size())\n\t{\n\t\tcout << s[i] << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint i, j;\nvector<string> data;\nstring buffer;\n\nvoid a(){\n  j = 0;\n}\n\nvoid e(){\n  j = data[i].size();\n}\n\nvoid p(){\n  if(i != 0) --i;\n  j = 0;\n}\n\nvoid n(){\n  if(i != data.size()-1) ++i;\n  j = 0;\n}\n\nvoid f(){\n  if(j != data[i].size()){\n    ++j;\n  }else if(j == data[i].size() && i != data.size()-1){\n    ++i;\n    j = 0;\n  }\n}\n\nvoid b(){\n  if(j != 0){\n    --j;\n  }else if(j == 0 && i != 0){\n    --i;\n    j = data[i].size();\n  }\n}\n\nvoid d(){\n  if(j != data[i].size()){\n    data[i].erase(data[i].begin()+j);\n  }else if(j == data[i].size() && i != data.size()-1){\n    data[i] += data[i+1];\n    data.erase(data.begin()+(i+1));\n  }\n}\n\nvoid k(){\n  if(j == data[i].size() && i != data.size()-1){\n    data[i] += data[i+1];\n    data.erase(data.begin()+(i+1));\n    buffer = \"\\n\";\n  }else if(j != data[i].size()){\n    buffer = string(data[i].begin()+j, data[i].end());\n    data[i].erase(data[i].begin()+j, data[i].end());\n  }\n}\n\nvoid y(){\n  if(buffer.empty()) return;\n  if(buffer == \"\\n\"){\n    data.insert(data.begin()+(i+1), string(data[i].begin()+j, data[i].end()));\n    data[i].erase(data[i].begin()+j, data[i].end());\n    ++i;\n  }else{\n    data[i].insert(data[i].begin()+j, buffer.begin(), buffer.end());\n    j += buffer.size();\n  }\n}\n\nint main(){\n  string s;\n  while(getline(cin, s)){\n    if(s == \"END_OF_TEXT\") break;\n    data.push_back(s);\n  }\n  i=0; j=0;\n  while(1){\n    cin >> s;\n    if(s == \"-\") break;\n    else if(s == \"a\") a();\n    else if(s == \"e\") e();\n    else if(s == \"p\") p();\n    else if(s == \"n\") n();\n    else if(s == \"f\") f();\n    else if(s == \"b\") b();\n    else if(s == \"d\") d();\n    else if(s == \"k\") k();\n    else if(s == \"y\") y();\n  }\n  for(vector<string>::iterator it=data.begin(); it!=data.end(); ++it)\n    cout << *it << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nvector<string> s;\nstring buf = \"\";\nint R;\nint ci = 0, cj = 0;\n\nvoid input() {\n  string l;\n  while (1) {\n    getline(cin, l);\n    if (l == \"END_OF_TEXT\") {\n      break;\n    }\n    s.push_back(l);\n  }\n  R = s.size();\n}\n\n// カーソルを現在の行の先頭文字に移動する\nvoid op_a() { cj = 0; }\n\n// カーソルを現在の行の行末に移動する\nvoid op_e() { cj = s[ci].size(); }\n\n// 上に行があれば、カーソルを上の行の先頭文字に移動する。\n// 上に行がなければ、カーソルを先頭文字に移動する。\nvoid op_p() {\n  if (ci != 0) \n    --ci;\n  op_a();\n}\n\n// 下に行があれば、カーソルを下の行の先頭文字に移動する。\n// 下に行がなければ、カーソルを先頭文字に移動する。\nvoid op_n() {\n  if (ci != R - 1) \n    ++ci;\n  op_a();\n}\n\n// カーソルが行末にない場合、カーソルを１つ右に移動する \n// カーソルが行末にありかつ下に行がある場合は、\n// カーソルを下の行の先頭文字へ移動する \n// それ以外の場合は何もしない\nvoid op_f() {\n  if (cj != s[ci].size()) {\n    ++cj;\n  } else if (cj == s[ci].size() && ci != R - 1) {\n    op_n();\n  }\n}\n\n// カーソルが先頭文字でないならば、カーソルを１つ左に移動する。\n// カーソルが先頭文字でありかつ上に行がある場合は、\n// カーソルを上の行の行末へ移動する。\n// それ以外の場合は何もしない。\nvoid op_b() {\n  if (cj != 0) {\n    --cj;\n  } else if (cj == 0 && ci != 0) {\n    --ci;\n    op_e();\n  }\n}\n\n// カーソルが文字を指す場合はその文字を削除する。\n// 削除された文字の右側の文字列は左にシフトされる。\n// カーソルが行末を指し下に行がある場合は、\n// 下の行をそのままカーソルの位置に繋げる。以下の行は上にシフトされる。\n// それ以外の場合は何もしない。\nvoid op_d() {\n  if (cj != s[ci].size()) {\n    // prev\n    // s[ci].erase(cj, 1);\n    s[ci] = s[ci].substr(0, cj) + s[ci].substr(cj + 1);\n  } else if (cj == s[ci].size() && ci != R - 1) {\n    // prev\n    // s[ci].erase(cj, 1);\n    // s[ci] += s[ci+1];\n    // s.erase(s.begin() + ci + 1);\n    s[ci] += s[ci+1];\n    s.erase(s.begin() + ci + 1);\n  }\n}\n\n// カーソルが行末にある場合、下に行があれば、\n// d と同じ操作をしバッファに１つの改行を記録する。\n// カーソルが行末にない場合、カーソルが指す文字を含めた\n// 右側すべての文字を切り取りそれをバッファに記録する。\n// カーソルは元の行の行末を指すようになる。全ての記録においてバッファは上書きされる。\n// それ以外の場合は何もしない。(clarification at 14:20)\nvoid op_k() {\n  if (cj == s[ci].size() && ci != R - 1) {\n    // prev\n    // s[ci].erase(cj, 1);\n    // s[ci] += s[ci+1];\n    // s.erase(s.begin() + ci + 1);\n    s[ci] += s[ci+1];\n    s.erase(s.begin() + ci + 1);\n    buf = \"\\n\";\n  } else  {\n    // prev\n    // buf = s[ci].substr(cj);\n    // s[ci].erase(cj);\n    buf = s[ci].substr(cj);\n    s[ci] = s[ci].substr(0, cj);\n  }\n}\n\n// バッファが空の場合はなにもしない。\n// バッファの内容が改行の場合、カーソルが指す文字の直前で改行を行う。\n// カーソルは新しい行の先頭文字へ移動する。\n// バッファの内容が文字列の場合、カーソルの位置にバッファの内容を挿入する。\n// カーソルの位置はもともと指していた文字または行末の場所へ移動する。 \nvoid op_y() {\n  if (buf == \"\") return;\n  if (buf == \"\\n\") {\n    // prev\n    // inserter(s, s.begin() + ci + 1) = s[ci].substr(cj);\n    // s[ci].erase(cj);\n    // ++ci; cj = 0;\n    vector<string>::iterator itr = s.begin();\n    rep(i,ci+1) ++itr;\n    s.insert(itr, s[ci].substr(cj));\n    s[ci] = s[ci].substr(0, cj);\n    ++ci; cj = 0;\n  } else {\n    // prev\n    // s[ci].insert(cj, buf.c_str());\n    // cj += buf.size();\n    s[ci] = s[ci].substr(0, cj) + buf + s[ci].substr(cj);\n    cj += buf.size();\n  }\n}\n\nvoid interpret() {\n  char op;\n  while (cin >> op, op != '-') {\n    switch (op) {\n      case 'a': { op_a(); break; }\n      case 'e': { op_e(); break; }\n      case 'p': { op_p(); break; }\n      case 'n': { op_n(); break; }\n      case 'f': { op_f(); break; }\n      case 'b': { op_b(); break; }\n      case 'd': { op_d(); break; }\n      case 'k': { op_k(); break; }\n      case 'y': { op_y(); break; }\n    }\n  }\n  rep(i,R) {\n    printf(\"%s\\n\", s[i].c_str());\n  }\n}\n\nint main() {\n  input();\n  interpret();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[110];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tt[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tcol = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\tt[row+1] = t[row].substr( col );\n\t\t\t\t\tt[row].erase( col );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else{\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<eps)\nvector<string> buf;\nstring tmp;\nint curline=0,curcol=0;\nvoid a(){curcol=0;}\nvoid e(){curcol=buf[curline].size();}\nvoid p()\n{\n\tif(curline==0)a();\n\telse curline--,curcol=0;\n}\nvoid n()\n{\n\tif(curline+1==buf.size())a();\n\telse curline++,curcol=0;\n}\nvoid f()\n{\n\tif(curcol==buf[curline].size()&&curline+1!=buf.size())curline++,curcol=0;\n\telse if(curcol!=buf[curline].size())curcol++;\n}\nvoid b()\n{\n\tif(curcol==0&&curline!=0)\n\t{\n\t\tcurline--;\n\t\tcurcol=buf[curline].size();\n\t}\n\telse if(curcol!=0)curcol--;\n}\nvoid d()\n{\n\tif(curcol==buf[curline].size()&&curline+1!=buf.size())\n\t{\n\t\tbuf[curline]+=buf[curline+1];\n\t\tfor(int i=curline+1;i<buf.size()-1;i++)buf[i]=buf[i+1];\n\t\tbuf.pop_back();\n\t}\n\telse if(curcol!=buf[curline].size())\n\t{\n\t\tbuf[curline]=buf[curline].substr(0,curcol)+buf[curline].substr(curcol+1);\n\t}\n}\nvoid k()\n{\n\tif(curcol==buf[curline].size()&&curline+1!=buf.size())\n\t{\n\t\td();\n\t\ttmp=\"\\n\";\n\t}\n\telse if(curcol!=buf[curline].size())\n\t{\n\t\ttmp=buf[curline].substr(curcol);\n\t\tbuf[curline]=buf[curline].substr(0,curcol);\n\t\tcurcol=buf[curline].size();\n\t}\n}\nvoid y()\n{\n\tif(tmp==\"\")return;\n\tif(tmp==\"\\n\")\n\t{\n\t\tbuf.pb(\"\");\n\t\tfor(int i=buf.size()-1;i>curline;i--)buf[i]=buf[i-1];\n\t\tbuf[curline+1]=buf[curline].substr(curcol);\n\t\tbuf[curline]=buf[curline].substr(0,curcol);\n\t\tcurline++;\n\t\tcurcol=0;\n\t}\n\telse\n\t{\n\t\tbuf[curline]=buf[curline].substr(0,curcol)+tmp+buf[curline].substr(curcol);\n\t\tcurcol+=tmp.size();\n\t}\n}\nvoid print()\n{\n\tcout << \"*****************************************\" << endl;\n\tfor(int i=0;i<buf.size();i++)cout<<buf[i]<<endl;\t\n\tcout << \"*****************************************\" << endl;\n}\nint main()\n{\n\tstring s;\n\tchar op;\n\twhile(getline(cin,s),s!=\"END_OF_TEXT\")buf.pb(s);\n\twhile(cin>>op,op!='-')\n\t{\n\t\tswitch(op)\n\t\t{\n\t\t\tcase 'a':a();break;\n\t\t\tcase 'e':e();break;\n\t\t\tcase 'p':p();break;\n\t\t\tcase 'n':n();break;\n\t\t\tcase 'f':f();break;\n\t\t\tcase 'b':b();break;\n\t\t\tcase 'd':d();break;\n\t\t\tcase 'k':k();break;\n\t\t\tcase 'y':y();break;\n\t\t}\n\t\t//print();\n\t}\n\tfor(int i=0;i<buf.size();i++)cout << buf[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring S;\nint p = 0;\n\nvoid a() {\n  for(; p >= 1 && S[p-1] != '\\n'; --p);\n}\n\nvoid e() {\n  for(; p < S.size() && S[p] != '\\n'; ++p);\n}\n\nint main() {\n  string line;\n  S = \"\\n\";\n  while(getline(cin,line) && line != \"END_OF_TEXT\") {\n    S += line;\n    S += '\\n';\n  }\n  char c;\n  p = 1;\n  string buffer = \"\";\n  while(cin >> c && c != '-') {\n    switch(c) {\n    case 'a':\n      a();\n      break;\n    case 'e':\n      e();\n      break;\n    case 'p':\n      a();\n      if(p != 1) {\n\t--p;\n\ta();\n      }\n      break;\n    case 'n':\n      e();\n      if(p+1 != S.size()) {\n\t++p;\n      }\n      a();\n      break;\n    case 'f':\n      p = min(p+1,(int)S.size()-1);\n      break;\n    case 'b':\n      p = max(p-1, 1);\n      break;\n    case 'd':\n      if(p+1 != S.size()) S.erase(p,1);\n      break;\n    case 'k':\n      if(S[p] == '\\n' && p+1 != S.size()) {\n\tS.erase(p,1);\n\tbuffer = \"\\n\";\n      } else {\n\tfor(int i = 1; ; ++i) {\n\t  if(S[p+i] == '\\n'){\n\t    buffer = S.substr(p,i);\n\t    S.erase(p,i);\n\t    break;\n\t  }\n\t}\n      }\n      break;\n    case 'y':\n      S.insert(p,buffer);\n      if(buffer == \"\\n\") ++p;\n      break;\n    }\n  }\n  cout << S.substr(1) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iterator>\nusing namespace std;\n\nstruct Emacs\n{\n  vector<string> buf;\n  int line, col;\n  string reg;\n  Emacs(const vector<string>& x) : buf(x), line(0), col(0), reg() {}\n  void execute(char cmd)\n  {\n    switch (cmd) {\n      case 'a': a(); break;\n      case 'e': e(); break;\n      case 'p': p(); break;\n      case 'n': n(); break;\n      case 'f': f(); break;\n      case 'b': b(); break;\n      case 'd': d(); break;\n      case 'k': k(); break;\n      case 'y': y(); break;\n    }\n  }\n\n  void a() { col = 0; }\n  void e() { col = buf[line].size(); }\n  void p() { if (line == 0) { a(); } else { --line; } }\n  void n() { if (line == buf.size()-1) { a(); } else { ++line; } }\n  void f() {\n    if (col != buf[line].size()) {\n      ++col;\n    } else if (line != buf.size()-1) {\n      ++line;\n      col = 0;\n    }\n  }\n  void b() {\n    if (col != 0) {\n      --col;\n    } else if (line != 0) {\n      --line;\n      col = buf[line].size();\n    }\n  }\n  void d() {\n    const string::iterator it = buf[line].begin() + col;\n    if (it != buf[line].end()) {\n      buf[line].erase(it);\n    } else if (line < buf.size()-1) {\n      buf[line] += buf[line+1];\n      buf.pop_back();\n    }\n  }\n  void k() {\n    if (buf[line].begin()+col == buf[line].end()) {\n      if (line < buf.size()-1) {\n        d();\n        reg = \"\\n\";\n      }\n    } else {\n      reg = string(buf[line].begin()+col, buf[line].end());\n      buf[line].erase(buf[line].begin()+col, buf[line].end());\n    }\n  }\n  void y() {\n    if (reg == \"\\n\") {\n      string rest(buf[line].begin()+col, buf[line].end());\n      buf[line].erase(col);\n      //buf.insert(buf.begin()+line+1, rest);\n      if (line == buf.size()-1) {\n        buf.push_back(rest);\n      } else {\n        buf.insert(buf.begin()+line, rest);\n      }\n      ++line;\n      col = 0;\n    } else if (!reg.empty()) {\n      buf[line].insert(col, reg);\n    }\n  }\n};\n\nint main()\n{\n  vector<string> buffer;\n  string line;\n  while (cin >> line && line != \"END_OF_TEXT\") {\n    buffer.push_back(line);\n  }\n  Emacs e(buffer);\n  char cmd;\n  while (cin >> cmd) {\n    e.execute(cmd);\n  }\n  copy(e.buf.begin(), e.buf.end(), ostream_iterator<string>(cout, \"\\n\"));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tvector<string> text;\n\twhile ( true )\n\t{\n\t\tstring t;\n\t\tgetline( cin, t );\n\t\tif ( t == \"END_OF_TEXT\" )\n\t\t\tbreak;\n\t\ttext.push_back( t );\n\t}\n\n\tint cx = 0;\n\tint cy = 0;\n\n\tstring buf;\n\n\twhile ( true )\n\t{\n\t\tchar c;\n\t\tcin >> c;\n\t\tif ( c == '-' )\n\t\t\tbreak;\n\t\tswitch ( c )\n\t\t{\n\t\tcase 'a':\n\t\t\tcx = 0;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tcx = (int)text[cy].length();\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif ( cy > 0 ) cy--;\n\t\t\tcx = 0;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tif ( cy < (int)text.size()-1 ) cy++;\n\t\t\tcx = 0;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tif ( cx != (int)text[cy].length() )\n\t\t\t\tcx++;\n\t\t\telse if ( cy < (int)text.size()-1 )\n\t\t\t\tcy++,\n\t\t\t\tcx = 0;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif ( cx > 0 )\n\t\t\t\tcx--;\n\t\t\telse if ( cy > 0 )\n\t\t\t\tcy--,\n\t\t\t\tcx = (int)text[cy].size();\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif ( cx < (int)text[cy].size() )\n\t\t\t\ttext[cy].erase( text[cy].begin()+cx );\n\t\t\telse if ( cy < (int)text.size()-1 )\n\t\t\t\ttext[cy] += text[cy+1],\n\t\t\t\ttext.erase( text.begin()+cy+1 );\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tif ( cx == (int)text[cy].size()  &&\n\t\t\t\t cy < (int)text.size() - 1 )\n\t\t\t{\n\t\t\t\tbuf = \"\\n\";\n\t\t\t\ttext[cy] += text[cy+1],\n\t\t\t\ttext.erase( text.begin()+cy+1 );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbuf = text[cy].substr( cx );\n\t\t\t\ttext[cy].erase( text[cy].begin()+cx, text[cy].end() );\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tif ( buf == \"\" )\n\t\t\t\tbreak;\n\t\t\telse if ( buf == \"\\n\" )\n\t\t\t{\n\t\t\t\ttext.insert( text.begin()+cy+1, text[cy].substr(cx) );\n\t\t\t\ttext[cy] = text[cy].substr(0,cx);\n\t\t\t\tcx = 0;\n\t\t\t\tcy++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttext[cy] = text[cy].substr(0,cx) + buf + text[cy].substr(cx);\n\t\t\t\tcx += (int)buf.length();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t//for ( int i=0; i<(int)text.size(); i++ )\n\t\t//\tcout << text[i] << endl;\n\t\t//cout << cx << \",\" << cy << endl;\n\t\t//cout << \"----\" << endl;\n\t}\n\n\tfor ( int i=0; i<(int)text.size(); i++ )\n\t\tcout << text[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvoid doA(int *l, int *c, string &s, string &b, vector<string> &v) {\n  *c = 0;\n}\n\nvoid doE(int *l, int *c, string &s, string &b, vector<string> &v) {\n  *c = s.size();\n}\n\nvoid doP(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*l > 0)\n    *l -= 1;\n  *c = 0;\n}\n\nvoid doN(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*l < v.size()-1)\n    *l += 1;\n  *c = 0;\n}\n\nvoid doF(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c < s.size()) {\n    *c += 1;\n  } else if (*l < v.size()-1){\n    *l += 1;\n    *c = 0;\n  }\n}\n\nvoid doB(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c > 0) {\n    *c -= 1;\n  } else if (*l > 0) {\n    *l -= 1;\n    *c = s.size();\n  }\n}\n\nvoid doD(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c < s.size()) {\n    s.erase(*c, 1);\n  } else if (*l < v.size()-1) {\n    s.append(v[*l+1]);\n    vector<string>::iterator itr = v.begin() + *l + 1;\n    v.erase(itr);\n  }\n}\n\nvoid doK(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c == s.size() && *l < v.size()-1) {\n    doD(l, c, s, b, v);\n    b = \"\\n\";\n  } else if (*c < s.size()) {\n    b = s.substr(*c, s.size() - *c);\n    s.erase(*c, s.size() - *c);\n    *c = s.size();\n  }\n}\n\nvoid doY(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (b.empty()) {\n    return;\n  } else if (b == \"\\n\") {\n    doK(l, c, s, b, v);\n    vector<string>::iterator itr = v.begin() + *l + 1;\n    v.insert(itr, b);\n  } else {\n    s.insert(*c, b);\n  }\n}\n\nint main(int argc, char *argv[]) {\n  string buf;\n  vector<string> strs;\n  while (true) {\n    string s;\n    getline(cin, s);\n    if (s == \"END_OF_TEXT\")\n      break;\n    strs.push_back(s);\n  }\n  int line = 0, chrc = 0;\n  while (true) {\n    char c;\n    cin >> c;\n    if (c == '-')\n      break;\n    else if (c == 'a')\n      doA(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'e')\n      doE(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'p')\n      doP(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'n')\n      doN(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'f')\n      doF(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'b')\n      doB(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'd')\n      doD(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'k')\n      doK(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'y')\n      doY(&line, &chrc, strs[line], buf, strs);\n  }\n\n  for (int i = 0; i < strs.size(); i++) {\n    if (i)\n      cout << endl;\n    cout << strs[i];\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <list>\n\nint main() {\n  std::list<std::string> lines;\n  while (true) {\n    char buf[32];\n    fgets(buf, sizeof buf, stdin);\n    std::string line=buf;\n    if (line == \"END_OF_TEXT\\n\")\n      break;\n\n    lines.emplace_back(line);\n  }\n\n  auto it=lines.begin();\n  size_t cc=0;\n  std::string kbuf=\"\";\n  while (true) {\n    char op;\n    scanf(\" %c\", &op);\n\n    switch (op) {\n    case '-': {\n      for (const auto &line: lines)\n        printf(\"%s\", line.c_str());\n      return 0;\n    }\n\n    case 'a':\n      cc = 0;\n      break;\n\n    case 'e':\n      cc = it->size()-1;\n      break;\n\n    case 'p':\n      cc = 0;\n      if (it != lines.begin())\n        --it;\n      break;\n\n    case 'n':\n      cc = 0;\n      if (std::next(it) != lines.end())\n        ++it;\n      break;\n\n    case 'f':\n      if ((*it)[cc] != '\\n') {\n        ++cc;\n      } else if (std::next(it) != lines.end()) {\n        ++it;\n        cc = 0;\n      }\n      break;\n\n    case 'b':\n      if (cc > 0) {\n        --cc;\n      } else if (it != lines.begin()) {\n        --it;\n        cc = it->size()-1;\n      }\n      break;\n\n    case 'd':\n      if ((*it)[cc] != '\\n') {\n        *it = it->substr(0, cc) + it->substr(cc+1);\n      } else if (std::next(it) != lines.end()) {\n        it->pop_back();\n        auto tmp=std::next(it);\n        *it += *tmp;\n        lines.erase(tmp);\n      }\n      break;\n\n    case 'k':\n      if ((*it)[cc] != '\\n') {\n        kbuf = it->substr(cc);\n        kbuf.pop_back();\n        *it = it->substr(0, cc) + \"\\n\";\n      } else if (std::next(it) != lines.end()) {\n        kbuf = \"\\n\";\n        it->pop_back();\n        auto tmp=std::next(it);\n        *it += *tmp;\n        lines.erase(tmp);\n      }\n      break;\n\n    case 'y':\n      if (kbuf.empty()) {\n        // no-op;\n      } else if (kbuf == \"\\n\") {\n        std::string s=it->substr(cc);\n        *it = it->substr(0, cc) + \"\\n\";\n        auto tmp=std::next(it);\n        lines.emplace(tmp, s);\n        ++it;\n        cc = 0;\n      } else {\n        *it = it->substr(0, cc) + kbuf + it->substr(cc);\n        cc += kbuf.length();\n      }\n      break;\n    }\n\n    // fprintf(stderr,\n    //         \"[%c] / L%td C%zu\\n\", op, std::distance(lines.begin(), it), cc);\n    // for (const auto &line: lines)\n    //   fprintf(stderr, \"%s\", line.c_str());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nvoid convert(string& text, int& cursor, string& buffer, char command);\n\nint main()\n{\n\tstring text, buffer;\n\tint cursor = 0;\n\t\n\tfor(string line; getline(cin, line) && line != \"END_OF_TEXT\"; text += line + '\\n');\n\tfor(char command; cin >> command && command != '-'; convert(text, cursor, buffer, command));\n\t\n\tcout << text;\n}\n\nvoid convert(string& text, int& cursor, string& buffer, char command)\n{\n\tswitch(command)\n\t{\n\t\t\t/*\n\t\t\t a\n\t\t\t J[\\ð»ÝÌsÌæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'a':\n\t\t{\n\t\t\tint pos = 0 < cursor ? text.rfind(\"\\n\", cursor - 1) : string::npos;\n\t\t\tcursor = (pos == string::npos ? 0 : pos + 1);\n\t\t\t\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t e\n\t\t\t J[\\ð»ÝÌsÌsÉÚ®·éB\n\t\t\t */\n\t\tcase 'e':\n\t\t{\n\t\t\tcursor = text.find(\"\\n\", cursor);\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t p\n\t\t\t ãÉsª êÎAJ[\\ðãÌsÌæª¶ÉÚ®·éB\n\t\t\t ãÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'p':\n\t\t{\n\t\t\t\n\t\t\tif(cursor != 0) while(--cursor) if(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(cursor != 0) while(--cursor) if(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tcursor++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t n\n\t\t\t ºÉsª êÎAJ[\\ðºÌsÌæª¶ÉÚ®·éB\n\t\t\t ºÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'n':\n\t\t{\n\t\t\tint cur = cursor;\n\t\t\twhile(text[cur] != '\\n') cur++;\n\t\t\t\n\t\t\tif(cur + 1 == text.size())\n\t\t\t{\n\t\t\t\tif(cursor != 0) while(--cursor) if(text[cursor] == '\\n')\n\t\t\t\t{\n\t\t\t\t\tcursor++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcursor = cur + 1;\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t f\n\t\t\t J[\\ªsÉÈ¢êAJ[\\ðPÂEÉÚ®·éB\n\t\t\t J[\\ªsÉ è©ÂºÉsª éêÍAJ[\\ðºÌsÌæª¶ÖÚ®·éB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'f':\n\t\t{\n\t\t\tcursor += cursor + 1 != text.size();\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t b\n\t\t\t J[\\ªæª¶ÅÈ¢ÈçÎAJ[\\ðPÂ¶ÉÚ®·éB\n\t\t\t J[\\ªæª¶Å è©ÂãÉsª éêÍAJ[\\ðãÌsÌsÖÚ®·éB\n\t\t\t »êÈOÌêÍ½àµÈ¢\n\t\t\t */\n\t\tcase 'b':\n\t\t{\n\t\t\tcursor -= 0 < cursor;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t d\n\t\t\t J[\\ª¶ðw·êÍ»Ì¶ðí·éBí³ê½¶ÌE¤Ì¶ñÍ¶ÉVtg³êéB\n\t\t\t J[\\ªsðwµºÉsª éêÍAºÌsð»ÌÜÜJ[\\ÌÊuÉq°éBÈºÌsÍãÉVtg³êéB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'd':\n\t\t{\n\t\t\tif(cursor + 1 != text.size()) text.erase(text.begin() + cursor);\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t k\n\t\t\t J[\\ªsÉ éêAºÉsª êÎAd Æ¯¶ìðµobt@ÉPÂÌüsðL^·éB\n\t\t\t J[\\ªsÉÈ¢êAJ[\\ªw·¶ðÜß½E¤·×ÄÌ¶ðØèæè»êðobt@ÉL^·éBJ[\\Í³ÌsÌsðw·æ¤ÉÈéBSÄÌL^É¨¢Äobt@Íã«³êéB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'k':\n\t\t{\n\t\t\tbuffer = \"\";\n\t\t\tif(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tif(cursor + 1 == text.size())\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tbuffer = \"\\n\";\n\t\t\t\ttext.erase(text.begin() + cursor);\n\t\t\t}\n\t\t\telse while(text[cursor] != '\\n')\n\t\t\t{\n\t\t\t\tbuffer += text[cursor];\n\t\t\t\ttext.erase(text.begin() + cursor);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t y\n\t\t\t obt@ªóÌêÍÈÉàµÈ¢B\n\t\t\t obt@ÌàeªüsÌêAJ[\\ªw·¶Ì¼OÅüsðs¤BJ[\\ÍVµ¢sÌæª¶ÖÚ®·éB\n\t\t\t obt@Ìàeª¶ñÌêAJ[\\ÌÊuÉobt@Ìàeð}ü·éB J[\\ÌÊuÍàÆàÆwµÄ¢½¶Ü½ÍsÌêÖÚ®·é\n\t\t\t */\n\t\tcase 'y':\n\t\t{\n\t\t\ttext = text.substr(0, cursor) + buffer + text.substr(cursor);\n\t\t\tcursor += buffer.size();\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n  int p, q;\n  string str, buf;\n  vector<string> vec;\n\n  while(!cin.eof()){\n    p = q = 0;\n    buf = \"\";\n\n    while(getline(cin, str) && str != \"END_OF_TEXT\") vec.push_back(str);\n    while(getline(cin, str) && str != \"-\"){\n      if(str == \"a\") q = 0;\n\n      if(str == \"e\") q = vec[p].size();\n\n      if(str == \"p\"){\n\tif(p > 0) --p;\n\tq = 0;\n      }\n\n      if(str == \"n\"){\n\tif(p < vec.size()-1) ++p;\n\tq = 0;\n      }\n\n      if(str == \"f\"){\n\tif(q < vec[p].size()) ++q;\n\telse if(q == vec[p].size() && p < vec.size()-1){\n\t  ++p;\n\t  q = 0;\n\t}\n      }\n\n      if(str == \"b\"){\n\tif(q > 0) --q;\n\telse if(q == 0 && p > 0){\n\t  --p;\n\t  q = vec[p].size();\n\t}\n      }\n\n      if(str == \"d\"){\n\tif(q == vec[p].size()){\n\t  if(vec.size()-1 > p){\n\t    vec[p] += vec[p+1];\n\t    vec.erase(vec.begin()+(p+1));\n\t  }\n\t} else if(q < vec[p].size()){\n\t  vec[p].erase(vec[p].begin()+q);\n\t}\n      }\n\n      if(str == \"k\"){\n\tif(q == vec[p].size()){\n\t  if(vec.size()-1 > p){\n\t    vec[p] += vec[p+1];\n\t    vec.erase(vec.begin()+(p+1));\n\t    buf = \"\\n\";\n\t  }\n\t} else if(q < vec[p].size()){\n\t  buf = vec[p].substr(q);\n\t  vec[p] = vec[p].substr(0, q);\n\t}\n      }\n\n      if(str == \"y\" && buf.size()){\n\tif(buf == \"\\n\"){\n\t  string s1 = vec[p].substr(0, q), s2 = vec[p].substr(q);\n\t  vec[p++] = s1;\n\t  vec.insert(vec.begin()+(p), s2);\n\t  q = 0;\n\t} else {\n\t  vec[p] = vec[p].substr(0, q)+buf+vec[p].substr(q);\n\t  q += buf.size();\n\t}\n      }\n    }\n\n    for(int i = 0; i < vec.size(); ++i)\n      cout << vec[i] << endl;\n    \n    buf.clear();\n    vec.clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nint main(){\n  char str[128][1024],c,buf[1024],input[1024];\n  int i,j,now_x,now_y,y_max;\n\n  memset(str,0,sizeof(str));\n  memset(buf,0,sizeof(buf));\n  for(i=0;gets(input);i++){\n    if(!strcmp(input,\"END_OF_TEXT\"))break;\n    strcpy(str[i],input);\n  }\n  y_max=i-1;\n  now_x=now_y=0;\n  for(;scanf(\" %c \",&c),c!='-';){\n    if(c=='a') //J[\\ð»ÝÌsÌæª\n      {\n        now_x=0;\n      }\n    else if(c=='e') //J[\\ð»ÝÌsÌs\n      {\n        now_x=strlen(str[now_y]);\n      }\n    else if(c=='p') //ãÉsª êÎJ[\\ðãÌsÌæªAÈ­Äàæª\n      {\n        if(now_y>0)now_y--;\n        now_x=0;\n      }\n    else if(c=='n') //ºÉsª ``\n      {\n        if(now_y<y_max)now_y++;\n        now_x=0;\n      }\n    else if(c=='f') //¶°¿ÙªsÅÈ¢Æ«EÉÚ®AsºÉsª éÆ«ºÌsÌæªAÈ¢Æ«Í½àµÈ¢\n      {\n        if(now_x!=strlen(str[now_y]))now_x++;\n        else{\n          if(now_y<y_max)now_y++,now_x=0;\n        }\n      }\n    else if(c=='b') //¶°¿Ùªæª¶ÅÈ¢Èç¶°¿Ùð¶ÉÚ®AæªãÉsª``\n      {\n        if(now_x>0)now_x--;\n        else{\n          if(now_y>0)now_y--,now_x=strlen(str[now_y]);\n        }\n      }\n    else if(c=='d')//¶°¿Ùª¶ðw·êíAí³ê½¶ÌE¤Í¶É¼ÌÄ``\n      {\n        if(now_x!=strlen(str[now_y])){\n          for(i=now_x;i<strlen(str[now_y]);i++)str[now_y][i]=str[now_y][i+1];\n        }\n        else{//¶°¿ÙªsÌÆ«\n          if(now_y<y_max){\n            strcat(str[now_y],str[now_y+1]);\n            y_max=now_y;\n            for(i=now_y+1;i<127;i++){\n              strcpy(str[i],str[i+1]);\n              if(str[i]!=0)y_max=i;\n            }\n          }\n        }\n      }\n    else if(c=='k') //\n      {\n        if(now_x==strlen(str[now_y])){\n          if(now_y<y_max){\n            strcat(str[now_y],str[now_y+1]);\n            y_max=now_y;\n            for(i=now_y+1;i<127;i++){\n              strcpy(str[i],str[i+1]);\n              if(str[i][0]!=0)y_max=i;\n            }\n          }\n          buf[0]='\\n'; buf[1]=0;\n        }else{\n          strcpy(buf,str[now_y]+now_x);\n          str[now_y][now_x]=0;\n          now_x=strlen(str[now_y]);\n          \n        }\n      }\n    else if(c=='y') //\n      {\n        if(buf[0]!=0){\n          if(buf[0]=='\\n'){\n            for(i=126;i>now_y;i--)strcpy(str[i+1],str[i]);\n            strcpy(str[now_y+1],str[now_y]+now_x);\n            str[now_y][now_x]=0;\n            now_y++; now_x=0;\n            y_max++;\n          }else{\n            char tmp[1024];\n            int t=now_x+1>strlen(str[now_y])?strlen(str[now_y]):now_x+1;\n            strcpy(tmp,str[now_y]+now_x);\n            for(i=now_x,j=0;j<strlen(buf);)str[now_y][i++]=buf[j++];\n            str[now_y][i]=0;\n            strcat(str[now_y],tmp);\n          }\n        }\n        //memset(buf,0,sizeof(buf));\n      }\n    //printf(\"y_max:%d\\n\",y_max);\n    //for(i=0;i<=y_max;i++)printf(\"%d:%s\\n\",i,str[i]);\n    //printf(\"%c-----------------now_x:%d , now_y:%d , y_max:%d\\n\",c,now_x,now_y,y_max);\n  }\n  for(i=0;i<=y_max;i++)puts(str[i]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\n\nint main() {\n\tvector<string>emacs;\n\twhile (1) {\n\t\tstring st; cin >> st;\n\t\t\n\t\tif (st == \"END_OF_TEXT\") {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\temacs.push_back(st);\n\t\t}\n\t}\n\tint x = 0, y = 0;\n\tvector<string>buf;\n\twhile (1) {\n\t\tchar c; cin >> c;\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\t\tx = 0;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tx = emacs[y].size();\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (y) {\n\t\t\t\ty--;\n\t\t\t}\n\t\t\tx = 0;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tif (y != emacs.size() - 1) {\n\t\t\t\ty++;\n\t\t\t}\n\t\t\tx = 0;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tif (x != emacs[y].size())x++;\n\t\t\telse {\n\t\t\t\tif (y != emacs.size() - 1) {\n\t\t\t\t\ty++;\n\t\t\t\t\tx = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif (x)x--;\n\t\t\telse {\n\t\t\t\tif (y) {\n\t\t\t\t\ty--;\n\t\t\t\t\tx = emacs[y].size();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (x != emacs[y].size()) {\n\t\t\t\temacs[y].erase(emacs[y].begin() + x);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (y != emacs.size() - 1) {\n\t\t\t\t\temacs[y].insert(emacs[y].end(), emacs[y + 1].begin(), emacs[y + 1].end());\n\t\t\t\t\temacs.erase(emacs.begin() + y + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tif (x == emacs[y].size()) {\n\t\t\t\tif (y != emacs.size() - 1) {\n\t\t\t\t\temacs[y].insert(emacs[y].end(), emacs[y + 1].begin(), emacs[y + 1].end());\n\t\t\t\t\temacs.erase(emacs.begin() + y + 1);\n\t\t\t\t\tbuf = vector<string>(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuf = vector<string>(1, emacs[y].substr(x));\n\t\t\t\temacs[y].erase(emacs[y].begin() + x, emacs[y].end());\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tif (buf.empty()) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (buf[0] == \"\") {\n\t\t\t\t\tstring rest = emacs[y].substr(x);\n\t\t\t\t\temacs[y].erase(emacs[y].begin() + x, emacs[y].end());\n\t\t\t\t\temacs.insert(emacs.begin() + y+1, rest);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\temacs[y].insert(emacs[y].begin() + x, buf[0].begin(), buf[0].end());\n\t\t\t\t\tx += buf[0].size();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (c=='-')break;\n\t\tfor (auto s : emacs) {\n\t\t\tcout << s << endl;\n\t\t}\n\t\tcout << \"x: \" << x << endl << \"y: \" << y << endl;\n\t}\n\tfor (auto s : emacs) {\n\t\tcout << s << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[110][1100];\nchar buf[1100];\nchar in[10];\nint main(){\n\tint n=0;\n\twhile(1){\n\t\tgets(str[n]);\n\t\tif(str[n][3]=='_')break;\n\t\tn++;\n\t}\n\tfor(int i=0;i<1100;i++)str[n][i]=0;\n\tint row=0;\n\tint col=0;\n\twhile(1){\n\t\tscanf(\"%s\",in);\n\t\tif(in[0]=='-')break;\n\t\tif(in[0]=='a')col=0;\n\t\tif(in[0]=='e'){\n\t\t\twhile(str[row][col]){\n\t\t\t\tcol++;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='p'){\n\t\t\tif(row)row--;\n\t\t\tcol=0;\n\t\t}\n\t\tif(in[0]=='n'){\n\t\t\tif(row<n-1)row++;\n\t\t\tcol=0;\n\t\t}\n\t\tif(in[0]=='f'){\n\t\t\tif(str[row][col])col++;\n\t\t\telse if(row<n-1){row++;col=0;}\n\t\t}\n\t\tif(in[0]=='b'){\n\t\t\tif(col)col--;\n\t\t\telse if(row){row--;col=0;\n\t\t\t\twhile(str[row][col])col++;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='d'){\n\t\t\tif(str[row][col]){\n\t\t\t\tfor(int i=col;str[row][i];i++)str[row][i]=str[row][i+1];\n\t\t\t}else if(row<n-1){\n\t\t\t\tfor(int i=0;str[row+1][i];i++){\n\t\t\t\t\tstr[row][col+i]=str[row+1][i];\n\t\t\t\t\tstr[row+1][i]=0;\n\t\t\t\t}\n\t\t\t\tn--;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='k'){\n\t\t\tif(!str[row][col]){\n\t\t\t\tif(row<n-1){\n\t\t\t\t\tfor(int i=0;str[row+1][i];i++){\n\t\t\t\t\t\tstr[row][col++]=str[row+1][i];\n\t\t\t\t\t\tstr[row+1][i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tn--;\n\t\t\t\t\tbuf[0]='@';\n\t\t\t\t\tbuf[1]=0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint at=0;\n\t\t\t\tfor(int i=col;str[row][i];i++){\n\t\t\t\t\tbuf[at++]=str[row][i];\n\t\t\t\t\tstr[row][i]=0;\n\t\t\t\t}\n\t\t\t\tbuf[at]=0;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='y'){\n\t\t\tif(buf[0]){\n\t\t\t\tif(buf[0]=='@'){\n\t\t\t\t\tfor(int i=n-1;i>row;i--){\n\t\t\t\t\t\tfor(int j=0;j<1100;j++)str[i+1][j]=str[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tint at=0;\n\t\t\t\t\tfor(int i=col;str[row][i];i++){\n\t\t\t\t\t\tstr[row+1][at++]=str[row][i];\n\t\t\t\t\t\tstr[row][i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tstr[row+1][at]=0;\n\t\t\t\t\trow++;col=0;\n\t\t\t\t\tn++;\n\t\t\t\t}else{\n\t\t\t\t\tint sz=0;\n\t\t\t\t\tfor(int i=0;buf[i];i++)sz++;\n\t\t\t\t\tfor(int i=1109;i>=col;i--){\n\t\t\t\t\t\tif(i+sz>=1100)continue;\n\t\t\t\t\t\tstr[row][i+sz]=str[row][i];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0;i<sz;i++)str[row][col+i]=buf[i];\n\t\t\t\t\tcol+=sz;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)printf(\"%s\\n\",str[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  vector<string> line;\n  string li;\n  while(getline(cin, li), li != \"END_OF_TEXT\")\n    line.push_back(li);\n//  cin.ignore();\n  char c;\n  int x = 0, y = 0;\n  string buf;\n  while(cin >> c, c!='-') {\n    switch(c) {\n    case 'a':\n      x=0;\n      break;\n    case 'e':\n      x=line[y].size();\n      break;\n    case 'p':\n      if (y)\n        y--;\n      x=0;\n      break;\n    case 'n':\n      if (y<line.size()-1)\n        y++;\n      x=0;\n      break;\n    case 'f':\n      if (x<line[y].size()) {\n        x++;\n      } else if (y<line.size()-1) {\n        y++;\n        x=0;\n      }\n      break;\n    case 'b':\n      if (x)\n        x--;\n      else if (y) {\n        y--;\n        x=line[y].size();\n      }\n      break;\n    case 'd':\n      if (x!=line[y].size()) {\n        line[y].erase(line[y].begin()+x);\n      } else if (y<line.size()-1) {\n        line[y] += line[y+1];\n        line.erase(line.begin()+y+1);\n      }\n      break;\n    case 'k':\n      if (x==line[y].size()) {\n        if (y<line.size()-1) {\n          line[y] += line[y+1];\n          line.erase(line.begin()+y+1);\n          buf = \"\\n\";\n        }\n      } else {\n        buf = line[y].substr(x);\n        line[y].resize(x);\n      }\n      break;\n    case 'y':\n      if (buf==\"\") break;\n      if (buf==\"\\n\") {\n        string tmp = line[y].substr(x);\n        line[y].resize(x);\n        line.insert(line.begin()+y+1,tmp);\n      } else {\n        line[y].insert(x, buf);\n        x+=buf.size();\n      }\n      break;\n      \n    }\n    // cout << c <<  \" \"  << x << \",\"<<y<< endl;\n    // REP(i, line.size())\n    //   cout << i<< \": \"<< line[i] << endl;\n  }\n  FOR(it, line)\n    cout << *it << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nint main(){\n  string s;\n  vector<string> v;\n  char command;\n\n  while( true ){\n    getline( cin,s );\n    if( s==\"END_OF_TEXT\" ) break;\n    v.push_back( s );\n  }\n\n  unsigned int line=0, c=0;\n  string buf=\"\";\n  while( cin>>command && c!='-' ){\n    switch( command ){\n    case 'a': c=0;      break;\n    case 'e': c=v[line].length();      break;\n    case 'p': if( line>0 ) line--;  c=0;      break;\n    case 'n': if( line+1<v.size() )line++; c=0;      break;\n    case 'f':\n      if( c<v[line].length() ) ++c;\n      else if( line+1<v.size() ){line++;c=0;  }      break;\n    case 'b':\n      if( c>0 ) --c;\n      else if( line>0 ){ c=v[--line].length(); }     break;\n    case 'd':\n      if( c<v[line].length() ) v[line].erase( c,1 );\n      else if( line+1<v.size() ){\n\tv[line] = v[line] + v[line+1];\n\tv.erase( v.begin()+line+1 );\n      }\n      break;\n    case 'k':\n      if( c==v[line].length() ){\n\tif( line+1<v.size() ){\n\t  v[line] = v[line] + v[line+1];\n\t  v.erase( v.begin()+line+1 );\n\t}\n\tbuf=\"\\n\";\n      }else{\n\tbuf = v[line].substr( c );\n\tv[line] = v[line].substr( 0,c );\n      }\n      break;\n    case 'y':\n      if( buf==\"\\n\" ){\n\tbuf = v[line].substr( c );\n\tv[line] = v[line].substr( 0,c );\n\tv.insert( v.begin()+line+1, buf );\n\tbuf=\"\\n\"; c=0;line++;\t\n      }else if( buf!=\"\" ){\n\tif( c<v[line].length() )\n\t  v[line] = v[line].substr( 0,c ) + buf + v[line].substr( c );\n\telse\n\t  v[line] = v[line] + buf;\n      }\n    }\n  }\n\n  for( unsigned int i=0;i<v.size();i++ )\n    cout << v[i] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define TOP_OF_BUFFER 0\n#define BEGIN_OF_LINE 0\n#define END_OF_LINE 10000\n\nstruct Cursor{\n  int x, y;\n  Cursor(){\n    x = 0, y = 0;\n  }\n};\n\nvector<string> buffer;\nstring buf;\nbool new_line;\nCursor cursor;\nint end;\n\nvoid output(){\n  for(int i = 0 ; i <= end ; i++){\n    cout << buffer[i] << endl;\n  }\n  //cout << endl;\n}\n\nvoid a_command(){\n  cursor.x = BEGIN_OF_LINE;\n}\n\nvoid e_command(){\n  cursor.x = END_OF_LINE;\n}\n\nvoid p_command(){\n  if(cursor.y == TOP_OF_BUFFER) cursor.x = BEGIN_OF_LINE;\n  else{\n    cursor.y--;\n    cursor.x = BEGIN_OF_LINE;\n  }\n}\n\nvoid n_command(){\n  if(cursor.y == end) cursor.x = BEGIN_OF_LINE;\n  else{\n    cursor.y++;\n    cursor.x = BEGIN_OF_LINE;\n  }\n}\n\nvoid f_command(){\n  if(cursor.x != END_OF_LINE) cursor.x++;\n  else if(cursor.x == END_OF_LINE && cursor.y != end){\n    cursor.x = BEGIN_OF_LINE;\n    cursor.y++;\n  }\n}\n\nvoid b_command(){\n  if(cursor.x != BEGIN_OF_LINE) cursor.x--;\n  else if(cursor.x == BEGIN_OF_LINE && cursor.y != TOP_OF_BUFFER){\n    cursor.x = END_OF_LINE;\n    cursor.y--;\n  }\n}\n\nvoid d_command(){\n  if(cursor.x == END_OF_LINE && cursor.y != end){\n    bool f = false;\n    if(buffer[cursor.y].size() == 0) cursor.x = 0;\n    buffer[cursor.y] += buffer[cursor.y+1];\n    buffer.erase(buffer.begin() + cursor.y+1);\n    end--;\n  }\n  else if(cursor.x != END_OF_LINE){\n    buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n  }\n}\n\nvoid k_command(){\n  if(cursor.x == END_OF_LINE && cursor.y != end){\n    d_command();\n    new_line = true;\n  }\n  else if(cursor.x != END_OF_LINE){\n    buf = \"\";\n    new_line = false;\n    for(int j = cursor.x ; j < buffer[cursor.y].size() ; j++){\n      buf += buffer[cursor.y][j];\n    }\n\n    int buffer_size = buffer[cursor.y].size();\n    for(int j = cursor.x ; j < buffer_size ; j++){\n      buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n      //cout << buffer[cursor.y] << endl;\n    }\n  }\n}\n\nvoid y_command(){\n  if(buf == \"\") return;\n  string bf = \"\";\n  for(int j = cursor.x ; j < buffer[cursor.y].size() ; j++){\n    bf += buffer[cursor.y][j];\n  }\n  \n  if(new_line){\n    buffer.push_back(\"\");\n    \n    for(int i = buffer.size()-1 ; i > cursor.y ; i--){\n      buffer[i] = buffer[i-1];\n    }\n    end++;\n    buffer[cursor.y+1] = bf;\n    int buffer_size = buffer[cursor.y].size();\n    for(int j = cursor.x ; j < buffer_size ; j++){\n      buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n    }\n  }\n  else{\n    if(cursor.x == END_OF_LINE){\n      buffer[cursor.y] += buf;\n    }\n    else{\n      for(int cnt = 0 ; cnt < bf.size() ; cnt++){\n\tbuffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n      }\n      buffer[cursor.y] += buf;\n      buffer[cursor.y] += bf;\n      cursor.x += buf.size();\n    }\n  }\n} \n\nvoid init(){\n  end = buffer.size()-1;\n  new_line = false;  \n  buf = \"\";\n}\n  \nint main(){\n  string s;\n  while(getline(cin, s)){\n    if(s == \"END_OF_TEXT\") break;\n    buffer.push_back(s);\n  }\n  \n  init();\n  \n  char op;\n  while(cin >> op){\n    //cout << \"operand = \" << op << endl;\n    if(op == '-') break;\n    if(op == 'a') a_command();\n    if(op == 'e') e_command();\n    if(op == 'p') p_command();\n    if(op == 'n') n_command();\n    if(op == 'f') f_command();\n    if(op == 'b') b_command();\n    if(op == 'd') d_command();\n    if(op == 'k') k_command();\n    if(op == 'y') y_command();  \n    if(cursor.x == buffer[cursor.y].size() ) cursor.x = END_OF_LINE;\n    //output();\n    //cout << \"cursor.x = \" << cursor.x << \", cursor.y = \" << cursor.y << endl << endl;  \n  }\n  \n  output();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<string> vs;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nvoid printtext(vs &text,char c,int cur,int line,string buf)\n{\n\tcerr<<\"command: \"<<c<<endl;\n\tcerr<<\"cur: \"<<cur<<\", line: \"<<line<<\", buffer: \"<<buf<<endl;\n\trep(i,text.size())cerr<<text[i]<<endl;\n}\n\nint main()\n{\n\tvs text;\n\tstring tmp,buf;\n\twhile(getline(cin,tmp),tmp!=\"END_OF_TEXT\")text.pb(tmp);\n\t\n\tchar c;\n\tint cur=0,line=0;\n\twhile(cin>>c,c!='-')\n\t{\n\t\tif(c=='a')cur=0;\n\t\telse if(c=='e')cur=text[line].size();\n\t\telse if(c=='p')\n\t\t{\n\t\t\tcur=0;\n\t\t\tif(line>0)line--;\n\t\t}\n\t\telse if(c=='n')\n\t\t{\n\t\t\tcur=0;\n\t\t\tif(line<text.size()-1)line++;\n\t\t}\n\t\telse if(c=='f')\n\t\t{\n\t\t\tif(cur!=text[line].size())cur++;\n\t\t\telse if(line<text.size()-1)line++,cur=0;\n\t\t}\n\t\telse if(c=='b')\n\t\t{\n\t\t\tif(cur!=0)cur--;\n\t\t\telse if(line>0)line--,cur=text[line].size();\n\t\t}\n\t\telse if(c=='d')\n\t\t{\n\t\t\tif(cur<text[line].size())text[line].erase(text[line].begin()+cur);\n\t\t\telse if(cur==text[line].size()&&line<text.size()-1)\n\t\t\t{\n\t\t\t\ttext[line]+=text[line+1];\n\t\t\t\ttext.erase(text.begin()+(line+1));\n\t\t\t}\n\t\t}\n\t\telse if(c=='k')\n\t\t{\n\t\t\tif(cur<text[line].size())\n\t\t\t{\n\t\t\t\tbuf=text[line].substr(cur);\n\t\t\t\ttext[line].erase(text[line].begin()+cur,text[line].end());\n\t\t\t}\n\t\t\telse if(cur==text[line].size()&&line<text.size()-1)\n\t\t\t{\n\t\t\t\ttext[line]+=text[line+1];\n\t\t\t\ttext.erase(text.begin()+(line+1));\n\t\t\t\tbuf=\"\\n\";\n\t\t\t}\n\t\t}\n\t\telse if(c=='y')\n\t\t{\n\t\t\tif(buf.empty())continue;\n\t\t\tif(buf==\"\\n\")\n\t\t\t{\n\t\t\t\ttext.insert(text.begin()+(line+1),text[line].substr(0,cur));\n\t\t\t\ttext[line].erase(text[line].begin()+cur,text[line].end());\n\t\t\t\tcur=0; line++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttext[line].insert(text[line].begin()+cur,all(buf));\n\t\t\t\tcur+=buf.size();\n\t\t\t}\n\t\t}\n\t\t\n\t\t//printtext(text,c,cur,line,buf);\n\t}\n\trep(i,text.size())cout<<text[i]<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define TOP_OF_BUFFER 0\n#define BEGIN_OF_LINE 0\n#define END_OF_LINE 10000\n\nstruct Cursor{\n  int x, y;\n  Cursor(){\n    x = 0, y = 0;\n  }\n};\n\nvector<string> buffer;\nstring buf;\nbool new_line;\nCursor cursor;\nint end;\n\nvoid output(){\n  for(int i = 0 ; i <= end ; i++){\n    cout << buffer[i] << endl;\n  }\n  //cout << endl;\n}\n\nvoid a_command(){\n  cursor.x = BEGIN_OF_LINE;\n}\n\nvoid e_command(){\n  cursor.x = END_OF_LINE;\n}\n\nvoid p_command(){\n  if(cursor.y == TOP_OF_BUFFER) cursor.x = BEGIN_OF_LINE;\n  else{\n    cursor.y--;\n    cursor.x = BEGIN_OF_LINE;\n  }\n}\n\nvoid n_command(){\n  if(cursor.y == end) cursor.x = BEGIN_OF_LINE;\n  else{\n    cursor.y++;\n    cursor.x = BEGIN_OF_LINE;\n  }\n}\n\nvoid f_command(){\n  if(cursor.x != END_OF_LINE) cursor.x++;\n  else if(cursor.x == END_OF_LINE && cursor.y != end){\n    cursor.x = BEGIN_OF_LINE;\n    cursor.y++;\n  }\n}\n\nvoid b_command(){\n  if(cursor.x != BEGIN_OF_LINE) cursor.x--;\n  else if(cursor.x == BEGIN_OF_LINE && cursor.y != TOP_OF_BUFFER){\n    cursor.x = END_OF_LINE;\n    cursor.y--;\n  }\n}\n\nvoid d_command(){\n  if(cursor.x == END_OF_LINE && cursor.y != end){\n    //シフト\n    //if(buffer[cursor.y].size() == 0) cursor.x = 0;\n    cursor.x = buffer[cursor.y].size();\n    buffer[cursor.y] += buffer[cursor.y+1];\n    buffer.erase(buffer.begin() + cursor.y+1);\n    end--;\n  }\n  else if(cursor.x != END_OF_LINE){\n    buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n  }\n}\n\nvoid k_command(){\n  if(cursor.x == END_OF_LINE && cursor.y != end){\n    d_command();\n    buf = \"\";\n    new_line = true;\n  }\n  else if(cursor.x != END_OF_LINE){\n    buf = \"\";\n    new_line = false;\n    for(int j = cursor.x ; j < buffer[cursor.y].size() ; j++){\n      buf += buffer[cursor.y][j];\n    }\n\n    int buffer_size = buffer[cursor.y].size();\n    for(int j = cursor.x ; j < buffer_size ; j++){\n      buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n      //cout << buffer[cursor.y] << endl;\n    }\n  }\n}\n\nvoid y_command(){\n  //if(buf == \"\") return;\n  string bf = \"\";\n  for(int j = cursor.x ; j < buffer[cursor.y].size() ; j++){\n    bf += buffer[cursor.y][j];\n  }\n   \n  if(new_line){\n    buffer.push_back(\"\");\n    //cout << \"size = \" << buffer.size() << endl;\n    for(int i = buffer.size()-1 ; i > cursor.y ; i--){\n      buffer[i] = buffer[i-1];\n    }\n    end++;\n    buffer[cursor.y+1] = bf;\n    int buffer_size = buffer[cursor.y].size();\n    for(int j = cursor.x ; j < buffer_size ; j++){\n      buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n    }\n    cursor.y++;\n    cursor.x = 0;\n  }\n  \n  if(buf == \"\") return;\n  \n  else{\n    if(cursor.x == END_OF_LINE){\n      buffer[cursor.y] += buf;\n    }\n    else{\n      for(int cnt = 0 ; cnt < bf.size() ; cnt++){\n\tbuffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n      }\n      buffer[cursor.y] += buf;\n      buffer[cursor.y] += bf;\n      cursor.x += buf.size();\n    }\n  }\n} \n\nvoid init(){\n  end = buffer.size()-1;\n  new_line = false;  \n  buf = \"\";\n}\n  \nint main(){\n  string s;\n  while(getline(cin, s)){\n    if(s == \"END_OF_TEXT\") break;\n    buffer.push_back(s);\n  }\n  \n  init();\n  \n  char op;\n  while(cin >> op){\n    //cout << \"operand = \" << op << endl;\n    if(op == '-') break;\n    if(op == 'a') a_command();\n    if(op == 'e') e_command();\n    if(op == 'p') p_command();\n    if(op == 'n') n_command();\n    if(op == 'f') f_command();\n    if(op == 'b') b_command();\n    if(op == 'd') d_command();\n    if(op == 'k') k_command();\n    if(op == 'y') y_command();  \n    if(cursor.x == buffer[cursor.y].size() ) cursor.x = END_OF_LINE;\n    //output();\n    //cout << \"cursor.x = \" << cursor.x << \", cursor.y = \" << cursor.y << endl << endl;  \n    //cout << \"new_line = \" << new_line << endl;\n  }\n  \n  output();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t,u;\nvector<char> tmp;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nint main(){\n\n  t.clear();\n  tmp.clear();\n  input();\n  x=y=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n    //cout<<y<<' '<<x<<\" ty\"<<t.size()<<endl;\n  }\n\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    t[y].erase(t[y].begin()+x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  t[y].erase(t[y].begin()+x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  t.erase(t.begin()+y+1);\n}\n\nvoid funcK(){\n  tmp.clear();\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.push_back('\\n');\n    }\n\n    x=t[y].size()-1;\n    return;\n  }\n  int c=0;\n  for(int i=x;i+1<(int)t[y].size();i++){\n    tmp.push_back(t[y][i]);\n    c++;\n  }\n  for(int i=0;i<=c;i++)t[y].pop_back();\n  t[y].push_back('\\n');\n  reverse(tmp.begin(),tmp.end());\n  x=t[y].size()-1;\n}\n\nvoid funcY(){\n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    vector<char> z;\n    int c=0;\n    for(int i=x;i<(int)t[y].size();i++){\n      z.push_back(t[y][i]);\n      c++;\n    }\n    for(int i=0;i<=c;i++)t[y].pop_back();\n    t[y].push_back('\\n');\n    t.insert(t.begin()+y+1,z);\n    y++;\n    x=0;\n    return;\n  }\n\n  for(int i=0;i<(int)tmp.size();i++){\n    t[y].insert(t[y].begin()+x,tmp[i]);\n  }\n  funcE();\n\n}\n\nvoid input(){\n  vector<char> a;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tvector<string> line;\n\tstring s, buff;\n\tint y=0, x=0;\n\t\n\twhile( getline(cin,s) ){\n\t\tif( s == \"END_OF_TEXT\" ) break;\n\t\tline.push_back( s );\n\t}\n\twhile( getline(cin,s) ){\n\t\tif( s == \"-\" ) break;\n\t\t\n\t\tif( s[0] == 'a' ){\n\t\t\tx = 0;\n\t\t}else if( s[0] == 'e' ){\n\t\t\tx = line[y].size();\n\t\t}else if( s[0] == 'p' ){\n\t\t\tif( y == 0 ){\n\t\t\t\tx = 0;\n\t\t\t}else{\n\t\t\t\ty--;\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t}else if( s[0] == 'n' ){\n\t\t\tif( y == line.size()-1 ){\n\t\t\t\tx = 0;\n\t\t\t}else{\n\t\t\t\ty++;\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t}else if( s[0] == 'f' ){\n\t\t\tif( x != line[y].size() ){\n\t\t\t\tx++;\n\t\t\t}else if( y != line.size()-1 ){\n\t\t\t\ty++;\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t}else if( s[0] == 'b' ){\n\t\t\tif( x != 0 ){\n\t\t\t\tx--;\n\t\t\t}else if( y != 0 ){\n\t\t\t\ty--;\n\t\t\t\tx = line[y].size();\n\t\t\t}\n\t\t}else if( s[0] == 'd' ){\n\t\t\tif( x != line[y].size() ){\n\t\t\t\tstring str;\n\t\t\t\tfor(int i=0 ; i < line[y].size() ; i++ ){\n\t\t\t\t\tif( i == x ) continue;\n\t\t\t\t\tstr.push_back( line[y][i] );\n\t\t\t\t}\n\t\t\t\tline[y] = str;\n\t\t\t}else if( y != line.size()-1 ){\n\t\t\t\tline[y] += line[y+1];\n\t\t\t\tfor(int i = y+2 ; i < line.size() ; i++ ){\n\t\t\t\t\tline[i-1] = line[i];\n\t\t\t\t}\n\t\t\t\tline.pop_back();\n\t\t\t}\n\t\t}else if( s[0] == 'k' ){\n\t\t\tif( x == line[y].size() ){\n\t\t\t\tif( y != line.size()-1 ){\n\t\t\t\t\tbuff = \";\";\n\t\t\t\t\tline[y] += line[y+1];\n\t\t\t\t\tfor(int i = y+2 ; i < line.size() ; i++ ){\n\t\t\t\t\t\tline[i-1] = line[i];\n\t\t\t\t\t}\n\t\t\t\t\tline.pop_back();\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tstring str;\n\t\t\t\tfor(int i=x ; i < line[y].size() ; i++ ){\n\t\t\t\t\tstr.push_back( line[y][i] );\n\t\t\t\t}\n\t\t\t\tbuff = str;\n\t\t\t\tstr.clear();\n\t\t\t\tfor(int i=0 ; i < x ; i++ ){\n\t\t\t\t\tstr.push_back( line[y][i] );\n\t\t\t\t}\n\t\t\t\tline[y] = str;\n\t\t\t}\n\t\t}else if( s[0] == 'y' ){\n\t\t\tif( !buff.empty() ){\n\t\t\t\tif( buff == \";\" ){\n\t\t\t\t\tstring str;\n\t\t\t\t\tfor(int i=x ; i < line[y].size() ; i++ ){\n\t\t\t\t\t\tstr.push_back( line[y][i] );\n\t\t\t\t\t}\n\t\t\t\t\tline.push_back( line[line.size()-1] );\n\t\t\t\t\tfor(int i = line.size()-2 ; i >= y+2 ; i-- ){\n\t\t\t\t\t\tline[i] = line[i-1];\n\t\t\t\t\t}\n\t\t\t\t\tline[y+1] = str;\n\t\t\t\t\tstr.clear();\n\t\t\t\t\tfor(int i=0 ; i < x ; i++ ){\n\t\t\t\t\t\tstr.push_back( line[y][i] );\n\t\t\t\t\t}\n\t\t\t\t\tline[y] = str;\n\t\t\t\t\ty++;\n\t\t\t\t\tx = 0;\n\t\t\t\t}else{\n\t\t\t\t\tstring str;\n\t\t\t\t\tfor(int i=0 ; i < x ; i++ ){\n\t\t\t\t\t\tstr.push_back( line[y][i] );\n\t\t\t\t\t}\n\t\t\t\t\tstr += buff;\n\t\t\t\t\tfor(int i=x ; i < line[y].size() ; i++ ){\n\t\t\t\t\t\tstr.push_back( line[y][i] );\n\t\t\t\t\t}\n\t\t\t\t\tline[y] = str;\n\t\t\t\t\tx += buff.size();\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t}\n\tfor(int y_=0 ; y_ < line.size() ; y_++ ){\n\t\tfor(int x_=0 ; x_ < line[y_].size() ; x_++ ){\n\t\t\tcout << line[y_][x_];\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[128];\nstring buf;\nint lines;\nvoid delete_line(int y)\n{\n    for (int i = y; y < lines; ++y)\n\ts[i] = s[i + 1];\n    s[--lines] = \"\";\n    if (lines <= 0)\n\tlines = 1;\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; ++i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    while (true)\n    {\n\tstring t;\n\tgetline(cin, t);\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines++] = t;\n    }\n    if (lines == 0)\n    {\n\tcout << \"\" << endl;\n\treturn 0;\n    }\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    y = max(0, --y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    y = min(lines - 1, ++y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y + 1 != lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t\tx = 0, --y;\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t\ts[y].erase(x, 1);\n\t    else\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t    }\n\t    break;\n\t}\n\tcase 'k':\n\t{\n\t    if (x == s[y].size())\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    else if (!s[y].empty())\n\t    {\n\t\tbuf = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\tif (!s[y].empty())\n\t\t{\n\t\t    s[y + 1] = s[y].substr(x);\n\t\t    s[y].erase(x);\n\t\t}\n\t\tx = 0, ++y;\n\t    }\n\t    else if (!buf.empty())\n\t\ts[y] += buf;\n\t    break;\n\t}\n\t}\n\n\ty = max(0, y);\n\tx = max(0, min(x, (int)s[y].size()));\n    }\n\n    for (int i = 0; i < lines; ++i)\n\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvoid doA(int *l, int *c, string &s, string &b, vector<string> &v) {\n  *c = 0;\n}\n\nvoid doE(int *l, int *c, string &s, string &b, vector<string> &v) {\n  *c = s.size();\n}\n\nvoid doP(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*l > 0)\n    *l -= 1;\n  *c = 0;\n}\n\nvoid doN(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*l < v.size()-1)\n    *l += 1;\n  *c = 0;\n}\n\nvoid doF(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c < s.size()) {\n    *c += 1;\n  } else if (*l < v.size()-1){\n    *l += 1;\n    *c = 0;\n  }\n}\n\nvoid doB(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c > 0) {\n    *c -= 1;\n  } else if (*l > 0) {\n    *l -= 1;\n    *c = s.size();\n  }\n}\n\nvoid doD(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c < s.size()) {\n    s.erase(*c, 1);\n  } else if (*l < v.size()-1) {\n    s.append(v[*l+1]);\n    vector<string>::iterator itr = v.begin() + *l + 1;\n    v.erase(itr);\n  }\n}\n\nvoid doK(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c == s.size() && *l < v.size()-1) {\n    doD(l, c, s, b, v);\n    b = \"\\n\";\n  } else if (*c < s.size()) {\n    b = s.substr(*c, s.size() - *c);\n    s.erase(*c, s.size() - *c);\n    *c = s.size();\n  }\n}\n\n\nvoid doY(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (b.empty()) {\n    return;\n  } else if (b == \"\\n\") {\n    doK(l, c, s, b, v);\n    vector<string>::iterator itr = v.begin() + *l + 1;\n    v.insert(itr, b);\n    b = \"\\n\";\n  } else {\n    s.insert(*c, b);\n    *c = s.size();\n  }\n}\n\nint main(int argc, char *argv[]) {\n  string buf;\n  vector<string> strs;\n  while (true) {\n    string s;\n    getline(cin, s);\n    if (s == \"END_OF_TEXT\")\n      break;\n    strs.push_back(s);\n  }\n  int line = 0, chrc = 0;\n  while (true) {\n    char c;\n    cin >> c;\n    if (c == '-')\n      break;\n    else if (c == 'a')\n      doA(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'e')\n      doE(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'p')\n      doP(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'n')\n      doN(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'f')\n      doF(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'b')\n      doB(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'd')\n      doD(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'k')\n      doK(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'y')\n      doY(&line, &chrc, strs[line], buf, strs);\n  }\n\n  for (int i = 0; i < strs.size(); i++)\n    cout << strs[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst ll INF = 1LL << 50;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nsize_t tpos;\nsize_t lpos;\n\nvoid do_a(const vector<string> &text){\n\tlpos = 0;\n}\n\nvoid do_e(const vector<string> &text){\n\tlpos = text[tpos].size();\n}\n\nvoid do_p(const vector<string> &text){\n\tlpos = 0;\n\ttpos = max(0, (int)tpos - 1);\n}\n\nvoid do_n(const vector<string> &text){\n\tlpos = 0;\n\ttpos = min((int)tpos + 1, (int)text.size() - 1);\n}\n\nvoid do_f(const vector<string> &text){\n\tif(lpos == text[tpos].size()){\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\tlpos = 0;\n\t\t\ttpos++;\n\t\t}\n\t}else{\n\t\tlpos++;\n\t}\n}\n\nvoid do_b(const vector<string> &text){\n\tif(lpos != 0){\n\t\tlpos--;\n\t}else{\n\t\tif(tpos > 0){\n\t\t\ttpos--;\n\t\t\tlpos = text[tpos].size();\n\t\t}\n\t}\n}\n\nvoid do_d(vector<string> &text){\n\tif(lpos != text[tpos].size()){\n\t\ttext[tpos].erase(lpos, 1);\n\t}else{\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\ttext[tpos]+=text[tpos+1];\n\t\t\ttext.erase(text.begin() + tpos+1);\n\t\t}\n\t}\n}\n\nvoid do_k(vector<string> &text, string &buffer){\n\tif(lpos == text[tpos].size()){\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\tbuffer = \"\\n\";\n\t\t\tdo_d(text);\n\t\t}\n\t}else{\n\t\tbuffer = string(text[tpos].begin() + lpos, text[tpos].end());\n\t\ttext[tpos].erase(text[tpos].begin() + lpos, text[tpos].end());\n\t}\n}\n\nvoid do_y(vector<string> &text, string &buffer){\n\tif(buffer != \"\"){\n\t\tif(buffer == \"\\n\"){\n\t\t\tstring a(text[tpos].begin() + lpos, text[tpos].end());\n\t\t\ttext[tpos].erase(lpos);\n\t\t\ttext.insert(text.begin() + tpos + 1, a);\n\t\t\ttpos++;\n\t\t\tlpos = 0;\n\t\t}else{\n\t\t\tif(lpos == text[tpos].size()){\n\t\t\t\ttext[tpos] += buffer;\n\t\t\t\tlpos = text[tpos].size();\n\t\t\t}else{\n\t\t\t\ttext[tpos].insert(text[tpos].begin() + lpos + 1, buffer.begin(), buffer.end());\n\t\t\t\tlpos += buffer.size();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid output(const vector<string> &text){\n\trep(i, (int)text.size()) cout << text[i] << endl;\n}\n\nint main(){\n\tstring line;\n\tvector<string> text;\n\tstring buffer;\n\twhile(cin >> line && line != \"END_OF_TEXT\"){\n\t\ttext.push_back(line);\n\t}\n\ttpos = lpos = 0;\n\tchar command;\n\twhile(cin >> command && command != '-'){\n\t\tswitch(command){\n\t\tcase 'a':\n\t\t\tdo_a(text);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tdo_e(text);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tdo_p(text);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tdo_n(text);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tdo_f(text);\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tdo_b(text);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdo_d(text);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tdo_k(text, buffer);\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tdo_y(text, buffer);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t\t//output(text);\n\t\t//cout << tpos << \" \" << lpos << endl;\n\t}\n\toutput(text);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int p=0;\n  char c[32]=\"\";\n  string s,t=\"\";\n  while(strcmp(c,\"END_OF_TEXT\\n\")){\n    s+=c;\n    fgets(c,32,stdin);\n  }\n  s.erase(s.length()-1,1);\n  while(cin>>c[0]&&c[0]!='-'){\n    switch(c[0]){\n    case 'a':\n      for(;p>0;p--){\n\tif(s[p-1]=='\\n')\n\t  break;\n      }\n      break;\n    case 'e':\n      p=s.find('\\n',p)<0?s.length():s.find('\\n',p);\n      break;\n    case 'p':\n      for(;p>0;p--){\n\tif(s[p-1]=='\\n')\n\t  break;\n      }\n      if(p){\n\tfor(p--;p>0;p--){\n\t  if(s[p-1]=='\\n')\n\t    break;\n\t}\n      }\n      break;\n    case 'n':\n      p=s.find('\\n',p)<0?s.length():s.find('\\n',p);\n      if(p==(int)s.length()){\n\tfor(;p>0;p--){\n\t  if(s[p-1]=='\\n')\n\t    break;\n\t}\n      }else\n\tp++;\n      break;\n    case 'f':\n      if(p!=(int)s.length())\n\tp++;\n      break;\n    case 'b':\n      if(p!=0)\n\tp--;\n      break;\n    case 'd':\n      if(p!=(int)s.length())\n\ts.erase(p,1);\n      break;\n    case 'k':\n      if(p!=(int)s.length()){\n\tif(s[p]=='\\n'){\n\t  t=s[p];\n\t  s.erase(p,1);\n\t}else{\n\t  if(s.find('\\n',p)==string::npos){\n\t    t=s.substr(p);\n\t    s.erase(p);\n\t  }else{\n\t    t=s.substr(p,s.find('\\n',p)-p);\n\t    s.erase(p,s.find('\\n',p)-p);\n\t  }\n\t}\n      }\n      break;\n    case 'y':\n      s.insert(p,t);\n      p+=t.length();\n      break;\n    }\n  }\n  cout<<s<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nvoid convert(string& text, int& cursor, string& buffer, char command);\n\nint main()\n{\n\tstring text, buffer;\n\tint cursor = 0;\n\t\n\tfor(string line; getline(cin, line) && line != \"END_OF_TEXT\"; text += line + '\\n');\n\tfor(char command; cin >> command && command != '-'; convert(text, cursor, buffer, command));\n\t\n\tcout << text;\n}\n\nvoid convert(string& text, int& cursor, string& buffer, char command)\n{\n\tswitch(command)\n\t{\n\t\t\t/*\n\t\t\t a\n\t\t\t J[\\ð»ÝÌsÌæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'a':\n\t\t{\n\t\t\tif(cursor != 0 && text[cursor - 1] != '\\n')\n\t\t\twhile(--cursor) if(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tcursor++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t e\n\t\t\t J[\\ð»ÝÌsÌsÉÚ®·éB\n\t\t\t */\n\t\tcase 'e':\n\t\t{\n\t\t\twhile(text[cursor] != '\\n') cursor++;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t p\n\t\t\t ãÉsª êÎAJ[\\ðãÌsÌæª¶ÉÚ®·éB\n\t\t\t ãÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'p':\n\t\t{\n\t\t\t\n\t\t\tif(cursor != 0) while(--cursor) if(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(cursor != 0) while(--cursor) if(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tcursor++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t n\n\t\t\t ºÉsª êÎAJ[\\ðºÌsÌæª¶ÉÚ®·éB\n\t\t\t ºÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'n':\n\t\t{\n\t\t\tint cur = cursor;\n\t\t\twhile(text[cur] != '\\n') cur++;\n\t\t\t\n\t\t\tif(cur + 1 == text.size())\n\t\t\t{\n\t\t\t\tif(cursor != 0) while(--cursor) if(text[cursor] == '\\n')\n\t\t\t\t{\n\t\t\t\t\tcursor++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcursor = cur + 1;\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t f\n\t\t\t J[\\ªsÉÈ¢êAJ[\\ðPÂEÉÚ®·éB\n\t\t\t J[\\ªsÉ è©ÂºÉsª éêÍAJ[\\ðºÌsÌæª¶ÖÚ®·éB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'f':\n\t\t{\n\t\t\tcursor += cursor + 1 != text.size();\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t b\n\t\t\t J[\\ªæª¶ÅÈ¢ÈçÎAJ[\\ðPÂ¶ÉÚ®·éB\n\t\t\t J[\\ªæª¶Å è©ÂãÉsª éêÍAJ[\\ðãÌsÌsÖÚ®·éB\n\t\t\t »êÈOÌêÍ½àµÈ¢\n\t\t\t */\n\t\tcase 'b':\n\t\t{\n\t\t\tcursor -= 0 < cursor;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t d\n\t\t\t J[\\ª¶ðw·êÍ»Ì¶ðí·éBí³ê½¶ÌE¤Ì¶ñÍ¶ÉVtg³êéB\n\t\t\t J[\\ªsðwµºÉsª éêÍAºÌsð»ÌÜÜJ[\\ÌÊuÉq°éBÈºÌsÍãÉVtg³êéB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'd':\n\t\t{\n\t\t\tif(cursor + 1 != text.size()) text.erase(text.begin() + cursor);\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t k\n\t\t\t J[\\ªsÉ éêAºÉsª êÎAd Æ¯¶ìðµobt@ÉPÂÌüsðL^·éB\n\t\t\t J[\\ªsÉÈ¢êAJ[\\ªw·¶ðÜß½E¤·×ÄÌ¶ðØèæè»êðobt@ÉL^·éBJ[\\Í³ÌsÌsðw·æ¤ÉÈéBSÄÌL^É¨¢Äobt@Íã«³êéB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'k':\n\t\t{\n\t\t\tbuffer = \"\";\n\t\t\tif(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tif(cursor + 1 == text.size())\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tbuffer = \"\\n\";\n\t\t\t\ttext.erase(text.begin() + cursor);\n\t\t\t}\n\t\t\telse while(text[cursor] != '\\n')\n\t\t\t{\n\t\t\t\tbuffer += text[cursor];\n\t\t\t\ttext.erase(text.begin() + cursor);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t y\n\t\t\t obt@ªóÌêÍÈÉàµÈ¢B\n\t\t\t obt@ÌàeªüsÌêAJ[\\ªw·¶Ì¼OÅüsðs¤BJ[\\ÍVµ¢sÌæª¶ÖÚ®·éB\n\t\t\t obt@Ìàeª¶ñÌêAJ[\\ÌÊuÉobt@Ìàeð}ü·éB J[\\ÌÊuÍàÆàÆwµÄ¢½¶Ü½ÍsÌêÖÚ®·é\n\t\t\t */\n\t\tcase 'y':\n\t\t{\n\t\t\ttext = text.substr(0, cursor) + buffer + text.substr(cursor);\n\t\t\tcursor += buffer.size();\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<assert.h>\nusing namespace std;\n\nvoid inputText(vector<string> &text){ //input text\n  string str; //1-line string\n  while(getline(cin,str)){\n    if(str==\"END_OF_TEXT\")break;\n    str += '\\n';\n    text.push_back(str);\n  }\n  \n  assert(text.size()>0);\n}\n\nvoid outputText(const vector<string> text){ //output text\n  for(int i=0;i<(int)text.size();i++){\n    cout<<text[i];\n  }\n}\n\nvoid cmdA(int &pr, int &pc, string &buffer, vector<string> &text){\n  pc = 0;\n}\n\nvoid cmdE(int &pr, int &pc, string &buffer, vector<string> &text){\n  pc = (int)text[pr].size() - 1;\n}\n\nvoid cmdP(int &pr, int &pc, string &buffer, vector<string> &text){\n  if(pr > 0) pr--, pc = 0;\n  else pc = 0;\n}\n\nvoid cmdN(int &pr, int &pc, string &buffer, vector<string> &text){\n  if(pr < (int)text.size() - 1) pr++, pc = 0;\n  else pc = 0;\n}\n\nvoid cmdF(int &pr, int &pc, string &buffer, vector<string> &text){\n  if(pc < (int)text[pr].size() - 1) pc++;\n  else if(pr < (int)text.size() - 1) pr++, pc=0;\n}\n\nvoid cmdB(int &pr, int &pc, string &buffer, vector<string> &text){\n  if(pc > 0) pc--;\n  else if(pr > 0) pr--, pc = (int)text[pr].size() - 1;\n}\n\nvoid cmdD(int &pr, int &pc, string &buffer, vector<string> &text){\n  if(text[pr][pc] != '\\n'){\n    string nstr; // next string\n    for(int i=0;i<(int)text[pr].size();i++)\n      if(i != pc)nstr += text[pr][i];\n\n    text[pr]=nstr;\n  }\n  else if(pr < (int)text.size() - 1){\n    text[pr].pop_back();\n    text[pr] += text[pr+1];\n    text.erase(text.begin() + pr + 1);\n  }\n}\n\nvoid cmdK(int &pr, int &pc, string &buffer, vector<string> &text){\n  if(pc == (int)text[pr].size() - 1){\n    if(pr < (int)text.size() - 1){\n      cmdD(pr, pc, buffer, text);\n      buffer = \"\\n\";\n    }\n  }\n  else {\n    buffer = \"\";\n    for(int i=pc;i<(int)text[pr].size()-1;i++)\n      buffer += text[pr][i];\n\n    string nstr; //next string\n    for(int i=0;i<pc;i++)nstr += text[pr][i];\n    nstr += '\\n';\n    text[pr]=nstr;\n  }\n}\n\nvoid cmdY(int &pr, int &pc, string &buffer, vector<string> &text){\n  if((int)buffer.size()==0)return;\n\n  if(buffer == \"\\n\"){\n    string nstr = text[pr].substr(pc); // next string\n    text[pr].erase(text[pr].begin() + pc, text[pr].end());\n    text[pr] += '\\n';\n    text.insert(text.begin()+ pr + 1 , nstr);\n    pr++; pc = 0;\n  }\n  else{\n    text[pr].insert(pc, buffer);\n    pc += buffer.size();\n  }\n}\n\n\n\nvoid doCmd(char cmd, int &pr, int &pc, string &buffer, vector<string> &text){\n  if(cmd=='a')cmdA(pr, pc, buffer, text);\n  if(cmd=='e')cmdE(pr, pc, buffer, text);\n  if(cmd=='p')cmdP(pr, pc, buffer, text);\n  if(cmd=='n')cmdN(pr, pc, buffer, text);\n  if(cmd=='f')cmdF(pr, pc, buffer, text);\n  if(cmd=='b')cmdB(pr, pc, buffer, text);\n  if(cmd=='d')cmdD(pr, pc, buffer, text);\n  if(cmd=='k')cmdK(pr, pc, buffer, text);\n  if(cmd=='y')cmdY(pr, pc, buffer, text);  \n}\n\nvoid emacsCmd(vector<string> &text){ //input and execute a command.\n  char cmd; // inputted emacs command\n  int pr=0, pc=0; //pr is the current row and pc is the current column\n  string buffer; // the curren buffer\n\n  while(cin>>cmd){\n    if(cmd=='-')break;\n    doCmd(cmd, pr, pc, buffer, text);\n  }\n}\n\n\nmain(){\n  vector<string> text;\n  inputText(text);\n  emacsCmd(text);\n  outputText(text);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nvoid rem(vector<string> &msg,int idx){\n\tvector<string> r;\n\tfor(int i = 0 ; i < msg.size() ; i++)\n\t\tif( i != idx ) r.push_back(msg[i]);\n\tmsg = r;\n}\n\nvoid rem(string &msg,int idx){\n\tstring r;\n\tfor(int i = 0 ; i < msg.size() ; i++)\n\t\tif( i != idx ) r += msg[i];\n\tmsg = r;\n}\n\nvector<string> msg;\nstring buf = \"\";\nint x,y;\n\n\nint main(){\n\tstring tmp;\n\twhile(getline(cin,tmp)){\n\t\tif( tmp[tmp.size()-1] == '\\r' ) tmp = tmp.substr(0,tmp.size()-1);\n\t\tif( tmp == \"END_OF_TEXT\" ) break;\n\t\tmsg.push_back(tmp);\n\t}\n\twhile( cin >> tmp && tmp != \"-\"){\n\t\tif( tmp == \"a\" ){\n\t\t\tx = 0;\n\t\t}\n\t\tif( tmp == \"e\" ){\n\t\t\tx = msg[y].size();\n\t\t}\n\t\tif( tmp == \"p\" ){\n\t\t\tx = 0;\n\t\t\tif(y)y--;\n\t\t}\n\t\tif( tmp == \"n\") {\n\t\t\tx = 0;\n\t\t\tif(y+1<msg.size())y++;\n\t\t}\n\t\tif( tmp == \"f\" ){\n\t\t\tif( x != msg[y].size() ){\n\t\t\t\tx++;\n\t\t\t}else if( x == msg[y].size() && y + 1 < msg.size() ){\n\t\t\t\ty++;\n\t\t\t\tx=0;\n\t\t\t}\n\t\t}\n\t\tif( tmp == \"b\" ){\n\t\t\tif( x != 0 ) x--;\n\t\t\telse if( x == 0 && y ){\n\t\t\t\ty--;\n\t\t\t\tx = msg[y].size();\n\t\t\t}\n\t\t}\n\t\tif( tmp == \"d\" ){\n\t\t\tif( x < msg[y].size() ){\n\t\t\t\trem(msg[y],x);\n\t\t\t}else if( x == msg[y].size() && y+1 < msg.size() ){\n\t\t\t\tmsg[y] += msg[y+1];\n\t\t\t\trem(msg,y+1);\n\t\t\t}\n\t\t}\n\n\t\tif( tmp == \"k\" ){\n\t\t\tif( x == msg[y].size() && y+1 < msg.size() ){ // ここ日本語怪しいからチェック\n\t\t\t\tmsg[y] += msg[y+1];\n\t\t\t\trem(msg,y+1);\n\t\t\t\tbuf = \"\\n\";\n\t\t\t}else if( x != msg[y].size() ){\n\t\t\t\tbuf = msg[y].substr(x);\n\t\t\t\tmsg[y] = msg[y].substr(0,x);\n\t\t\t}//else buf = \"\\n\";\n\t\t}\n\t\tif( tmp == \"y\" ){\n\t\t\tif( buf == \"\" ){\n\t\t\t}else if( buf == \"\\n\" ){\n\t\t\t\tvector<string> a;\n\t\t\t\tfor(int k = 0 ; k < y ; k++)\n\t\t\t\t\ta.push_back(msg[k]);\n\t\t\t\ta.push_back(msg[y].substr(0,x));\n\t\t\t\ta.push_back(msg[y].substr(x));\n\t\t\t\tfor(int k = y+1 ; k < msg.size() ; k++)\n\t\t\t\t\ta.push_back(msg[k]);\n\t\t\t\tmsg = a;\n\t\t\t\ty++;\n\t\t\t\tx = 0;\n\t\t\t}else{\n\t\t\t\tmsg[y] = msg[y].substr(0,x) + buf + msg[y].substr(x);\n\t\t\t\tx += buf.size();\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0 ; i < msg.size() ; i++)\n\t\tcout << msg[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define TOP_OF_BUFFER 0\n#define BEGIN_OF_LINE 0\n#define END_OF_LINE 10000\n\nstruct Cursor{\n  int x, y;\n  Cursor(){\n    x = 0, y = 0;\n  }\n};\n\nvector<string> buffer;\nstring buf;\nbool new_line;\nCursor cursor;\nint end;\n\nvoid output(){\n  for(int i = 0 ; i <= end ; i++){\n    cout << buffer[i] << endl;\n  }\n  //cout << endl;\n}\n\nvoid a_command(){\n  cursor.x = BEGIN_OF_LINE;\n}\n\nvoid e_command(){\n  cursor.x = END_OF_LINE;\n}\n\nvoid p_command(){\n  if(cursor.y == TOP_OF_BUFFER) cursor.x = BEGIN_OF_LINE;\n  else{\n    cursor.y--;\n    cursor.x = BEGIN_OF_LINE;\n  }\n}\n\nvoid n_command(){\n  if(cursor.y == end) cursor.x = BEGIN_OF_LINE;\n  else{\n    cursor.y++;\n    cursor.x = BEGIN_OF_LINE;\n  }\n}\n\nvoid f_command(){\n  if(cursor.x != END_OF_LINE) cursor.x++;\n  else if(cursor.x == END_OF_LINE && cursor.y != end){\n    cursor.x = BEGIN_OF_LINE;\n    cursor.y++;\n  }\n}\n\nvoid b_command(){\n  if(cursor.x != BEGIN_OF_LINE) cursor.x--;\n  else if(cursor.x == BEGIN_OF_LINE && cursor.y != TOP_OF_BUFFER){\n    cursor.x = END_OF_LINE;\n    cursor.y--;\n  }\n}\n\nvoid d_command(){\n  if(cursor.x == END_OF_LINE && cursor.y != end){\n    buffer[cursor.y] += buffer[cursor.y+1];\n    buffer.erase(buffer.begin() + cursor.y+1);\n    end--;\n  }\n  else if(cursor.x != END_OF_LINE){\n    buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n  }\n}\n\nvoid k_command(){\n  if(cursor.x == END_OF_LINE && cursor.y != end){\n    d_command();\n    new_line = true;\n  }\n  else if(cursor.x != END_OF_LINE){\n    buf = \"\";\n    new_line = false;\n    for(int j = cursor.x ; j < buffer[cursor.y].size() ; j++){\n      buf += buffer[cursor.y][j];\n    }\n\n    int buffer_size = buffer[cursor.y].size();\n    for(int j = cursor.x ; j < buffer_size ; j++){\n      buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n      //cout << buffer[cursor.y] << endl;\n    }\n  }\n}\n\nvoid y_command(){\n  if(buf == \"\") return;\n  string bf = \"\";\n  for(int j = cursor.x ; j < buffer[cursor.y].size() ; j++){\n    bf += buffer[cursor.y][j];\n  }\n  \n  if(new_line){\n    buffer.push_back(\"\");\n    \n    for(int i = buffer.size()-1 ; i > cursor.y ; i--){\n      buffer[i] = buffer[i-1];\n    }\n    end++;\n    buffer[cursor.y+1] = bf;\n    int buffer_size = buffer[cursor.y].size();\n    for(int j = cursor.x ; j < buffer_size ; j++){\n      buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n    }\n  }\n  else{\n    if(cursor.x == END_OF_LINE){\n      buffer[cursor.y] += buf;\n    }\n    else{\n      for(int cnt = 0 ; cnt < bf.size() ; cnt++){\n\tbuffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n      }\n      buffer[cursor.y] += buf;\n      buffer[cursor.y] += bf;\n      cursor.x += buf.size();\n    }\n  }\n} \n\nvoid init(){\n  end = buffer.size()-1;\n  new_line = false;  \n  buf = \"\";\n}\n  \nint main(){\n  string s;\n  while(getline(cin, s)){\n    if(s == \"END_OF_TEXT\") break;\n    buffer.push_back(s);\n  }\n  \n  init();\n  \n  char op;\n  while(cin >> op){\n    //cout << \"operand = \" << op << endl;\n    if(op == '-') break;\n    if(op == 'a') a_command();\n    if(op == 'e') e_command();\n    if(op == 'p') p_command();\n    if(op == 'n') n_command();\n    if(op == 'f') f_command();\n    if(op == 'b') b_command();\n    if(op == 'd') d_command();\n    if(op == 'k') k_command();\n    if(op == 'y') y_command();  \n    if(cursor.x == buffer[cursor.y].size()) cursor.x = END_OF_LINE;\n    //output();\n    //cout << \"cursor.x = \" << cursor.x << \", cursor.y = \" << cursor.y << endl << endl;  \n  }\n  \n  output();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t,u;\nvector<char> tmp;\nvector<char> z;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nvoid yinsert(int,vector<char>);\nvoid xinsert(int,int,char);\nvoid ydelete(int);\nvoid xdelete(int,int);\n\nint main(){\n\n  t.clear();\n  tmp.clear();\n  input();\n  x=y=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n    //cout<<y<<' '<<x<<\" ty\"<<t.size()<<endl;\n  }\n\n  for(int i=0;i<t.size();i++){\n    for(int j=0;j<t[i].size();j++){\n      cout<<t[i][j];\n    }\n  }\n\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    xdelete(y,x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  xdelete(y,x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  ydelete(y+1);\n}\n\nvoid funcK(){\n  tmp.clear();\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.push_back('\\n');\n    }\n    return;\n  }\n  while(t[y][x]!='\\n'){\n    tmp.push_back(t[y][x]);\n    xdelete(y,x);\n  }\n  reverse(tmp.begin(),tmp.end());\n  //funcE();\n}\n\nvoid funcY(){\n  z.clear();\n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    while(t[y][x]!='\\n'){\n      z.push_back(t[y][x]);\n      xdelete(y,x);\n    }\n    yinsert(y+1,z);\n    y++;\n    x=0;\n    return;\n  }\n  for(int i=0;i<(int)tmp.size();i++){\n    xinsert(y,x,tmp[i]);\n  }\n  //funcE();\n}\n\nvoid input(){\n  vector<char> a;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n}\n\n\n\n\n\n\n\n\nvoid xinsert(int y,int x,char ch){\n  if(x==(int)t[y].size()){\n    t[y].push_back(ch);\n  }else{\n    \n    z=t[y];\n    t[y].clear();\n    for(int i=0;i<(int)z.size();i++){\n      if(i==x)t[y].push_back(ch);\n      t[y].push_back(z[i]);\n    }\n  }\n}\n\nvoid xdelete(int y,int x){\n  if(x+1==(int)t[y].size()){\n    t[y].pop_back();\n  }else{\n    \n    z=t[y];\n    t[y].clear();\n    for(int i=0;i<(int)z.size();i++){\n      if(i==x)continue;\n      t[y].push_back(z[i]);\n    }\n  }\n}\n\nvoid yinsert(int y,vector<char> ch){\n  if(y==(int)t.size()){\n    t.push_back(ch);\n  }else{\n    u=t;\n    t.clear();\n    for(int i=0;i<(int)u.size();i++){\n      if(i==y)t.push_back(ch);\n      t.push_back(u[i]);\n    }\n  }\n}\n\nvoid ydelete(int y){\n  if(y+1==(int)t.size()){\n    t.pop_back();\n  }else{\n    u=t;\n    t.clear();\n    for(int i=0;i<(int)u.size();i++){\n      if(i==y)continue;\n      t.push_back(u[i]);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(5)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<short, short> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 100000007;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator > (const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nvector<string> s;\nint x, y;\n\nvoid gotoend()\n{\n\ty = s[x].size();\n}\n\nvoid gotohome()\n{\n\ty = 0;\n}\n\nint check()\n{\n\tif (s[x].size() == 0) return 1;\n\telse if (y == s[x].size()) return 2;\n\telse return 0;\n}\n\n\nint main()\n{\n\tx = 0; y = 0;\n\tstring tmp;\n\tstring buf = \"@\";\n\twhile (1)\n\t{\n\t\tcin >> tmp;\n\t\tif (tmp == \"END_OF_TEXT\") break;\n\t\ts.push_back(tmp);\n\t}\n\tchar com;\n\twhile (cin >> com)\n\t{\n\t\tif (com == '-') break;\n\t\telse if (com == 'a') gotohome();\n\t\telse if (com == 'e') gotoend();\n\t\telse if (com == 'p')\n\t\t{\n\t\t\tif (x == 0) gotohome();\n\t\t\telse \n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'n')\n\t\t{\n\t\t\tif (x != s.size() - 1) x++;\n\t\t\tgotohome();\n\t\t}\n\t\telse if (com == 'f')\n\t\t{\n\t\t\tif (check() == 0) y++;\n\t\t\telse if (x != s.size() - 1)\n\t\t\t{\n\t\t\t\tx++;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'b')\n\t\t{\n\t\t\tif (y != 0) y--;\n\t\t\telse if (y == 0 && x > 0)\n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tgotoend();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'd')\n\t\t{\n\t\t\tif (check() == 0) s[x].erase(y, 1);\n\t\t\telse if (check() == 2 && x < s.size() - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\tint t = x + 1;\n\t\t\t\twhile (t < s.size() - 1)\n\t\t\t\t{\n\t\t\t\t\ts[t] = s[t + 1];\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t\ts.pop_back();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'k')\n\t\t{\n\t\t\tif (check() == 2 && x < s.size() - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\tint t = x + 1;\n\t\t\t\twhile (t < s.size() - 1)\n\t\t\t\t{\n\t\t\t\t\ts[t] = s[t + 1];\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t\ts.pop_back();\n\t\t\t\tbuf = \"#\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbuf = s[x].substr(y);\n\t\t\t\ts[x].erase(y);\n\t\t\t}\n\t\t}\n\t\telse if (com == 'y')\n\t\t{\n\t\t\tif (buf == \"@\") continue;\n\t\t\telse if (buf == \"#\")\n\t\t\t{\n\t\t\t\tint t = s.size() - 1;\n\t\t\t\ts.push_back(\"\");\n\t\t\t\twhile (t > x)\n\t\t\t\t{\n\t\t\t\t\ts[t + 1] = s[t];\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t\ts[x + 1] = s[x].substr(y);\n\t\t\t\ts[x].erase(y);\n\t\t\t\tx++;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts[x].insert(y, buf);\n\t\t\t\ty += buf.size();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tREP(i, s.size())\n\t\t{\n\t\t\tcout << s[i] << endl;\n\t\t}\n\t\tcout << x << \" \" << y;\n\t\tcout << endl << endl;\n\t\t*/\n\t}\n\tREP(i, s.size())\n\t{\n\t\tcout << s[i] << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define TOP_OF_BUFFER 0\n#define BEGIN_OF_LINE 0\n#define END_OF_LINE 10000\n\nstruct Cursor{\n  int x, y;\n  Cursor(){\n    x = 0, y = 0;\n  }\n};\n\nvector<string> buffer;\nstring buf;\nbool new_line;\nCursor cursor;\nint end;\n\nvoid output(){\n  for(int i = 0 ; i <= end ; i++){\n    cout << buffer[i] << endl;\n  }\n  //cout << endl;\n}\n\nvoid a_command(){\n  cursor.x = BEGIN_OF_LINE;\n}\n\nvoid e_command(){\n  cursor.x = END_OF_LINE;\n}\n\nvoid p_command(){\n  if(cursor.y == TOP_OF_BUFFER) cursor.x = BEGIN_OF_LINE;\n  else{\n    cursor.y--;\n    cursor.x = BEGIN_OF_LINE;\n  }\n}\n\nvoid n_command(){\n  if(cursor.y == end) cursor.x = BEGIN_OF_LINE;\n  else{\n    cursor.y++;\n    cursor.x = BEGIN_OF_LINE;\n  }\n}\n\nvoid f_command(){\n  if(cursor.x != END_OF_LINE) cursor.x++;\n  else if(cursor.x == END_OF_LINE && cursor.y != end){\n    cursor.x = BEGIN_OF_LINE;\n    cursor.y++;\n  }\n}\n\nvoid b_command(){\n  if(cursor.x != BEGIN_OF_LINE) cursor.x--;\n  else if(cursor.x == BEGIN_OF_LINE && cursor.y != TOP_OF_BUFFER){\n    cursor.x = END_OF_LINE;\n    cursor.y--;\n  }\n}\n\nvoid d_command(){\n  if(cursor.x == END_OF_LINE && cursor.y != end){\n    //シフト\n    //if(buffer[cursor.y].size() == 0) cursor.x = 0;\n    cursor.x = buffer[cursor.y].size();\n    buffer[cursor.y] += buffer[cursor.y+1];\n    buffer.erase(buffer.begin() + cursor.y+1);\n    end--;\n  }\n  else if(cursor.x != END_OF_LINE){\n    buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n  }\n}\n\nvoid k_command(){\n  if(cursor.x == END_OF_LINE && cursor.y != end){\n    d_command();\n    new_line = true;\n  }\n  else if(cursor.x != END_OF_LINE){\n    buf = \"\";\n    new_line = false;\n    for(int j = cursor.x ; j < buffer[cursor.y].size() ; j++){\n      buf += buffer[cursor.y][j];\n    }\n\n    int buffer_size = buffer[cursor.y].size();\n    for(int j = cursor.x ; j < buffer_size ; j++){\n      buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n      //cout << buffer[cursor.y] << endl;\n    }\n  }\n}\n\nvoid y_command(){\n  //if(buf == \"\") return;\n  string bf = \"\";\n  for(int j = cursor.x ; j < buffer[cursor.y].size() ; j++){\n    bf += buffer[cursor.y][j];\n  }\n   \n  if(new_line){\n    buffer.push_back(\"\");\n    \n    for(int i = buffer.size()-1 ; i > cursor.y ; i--){\n      buffer[i] = buffer[i-1];\n    }\n    end++;\n    buffer[cursor.y+1] = bf;\n    int buffer_size = buffer[cursor.y].size();\n    for(int j = cursor.x ; j < buffer_size ; j++){\n      buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n    }\n  }\n  else{\n    if(cursor.x == END_OF_LINE){\n      buffer[cursor.y] += buf;\n    }\n    else{\n      for(int cnt = 0 ; cnt < bf.size() ; cnt++){\n\tbuffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n      }\n      buffer[cursor.y] += buf;\n      buffer[cursor.y] += bf;\n      cursor.x += buf.size();\n    }\n  }\n} \n\nvoid init(){\n  end = buffer.size()-1;\n  new_line = false;  \n  buf = \"\";\n}\n  \nint main(){\n  string s;\n  while(getline(cin, s)){\n    if(s == \"END_OF_TEXT\") break;\n    buffer.push_back(s);\n  }\n  \n  init();\n  \n  char op;\n  while(cin >> op){\n    //cout << \"operand = \" << op << endl;\n    if(op == '-') break;\n    if(op == 'a') a_command();\n    if(op == 'e') e_command();\n    if(op == 'p') p_command();\n    if(op == 'n') n_command();\n    if(op == 'f') f_command();\n    if(op == 'b') b_command();\n    if(op == 'd') d_command();\n    if(op == 'k') k_command();\n    if(op == 'y') y_command();  \n    if(cursor.x == buffer[cursor.y].size() ) cursor.x = END_OF_LINE;\n    //output();\n    //cout << \"cursor.x = \" << cursor.x << \", cursor.y = \" << cursor.y << endl << endl;  \n    //cout << \"new_line = \" << new_line << endl;\n  }\n  \n  output();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[128];\nstring buf;\nint lines;\nvoid delete_line(int y)\n{\n    for (int i = y; y < lines; ++y)\n\ts[i] = s[i + 1];\n    s[--lines] = \"\";\n    if (lines == 0)\n\tlines = 1;\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; ++i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    while (true)\n    {\n\tstring t;\n\tgetline(cin, t);\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines++] = t;\n    }\n    if (lines == 0)\n    {\n\tcout << \"\" << endl;\n\treturn 0;\n    }\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    y = max(0, --y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    y = min(lines - 1, ++y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y + 1 != lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t\tx = 0, --y;\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t\ts[y].erase(x, 1);\n\t    else\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t    }\n\t    break;\n\t}\n\tcase 'k':\n\t{\n\t    if (x == s[y].size())\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    else if (!s[y].empty())\n\t    {\n\t\tbuf = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\tif (!s[y].empty())\n\t\t{\n\t\t    s[y + 1] = s[y].substr(x);\n\t\t    s[y].erase(x);\n\t\t}\n\t\tx = 0, ++y;\n\t    }\n\t    else if (!buf.empty())\n\t\ts[y] += buf;\n\t    break;\n\t}\n\t}\n    }\n\n    for (int i = 0; i < lines; ++i)\n\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n)-1;i>=(m);--i)\n#define repc(i,n) for(int i=0;i<=(n);++i)\n#define repcn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repcd(i,n) for(int i=(n);i>=0;--i)\n#define repcnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define repc0(i,n) for(i=0;i<=(n);++i)\n#define repcn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repcd0(i,n) for(i=(n);i>=0;--i)\n#define repcnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE cout<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nstring str[111];\nchar s[100];\n\nint main() {\n\tint h = 0;\n\tIL {\n\t\tgets(s);\n\t\tstr[h] = s;\n\t\tstr[h] = str[h].substr(0, sz(str[h]) - 1);\n\t\tif (str[h] == \"END_OF_TEXT\") break;\n\t\t++h;\n\t}\n\tint x = 0, y = 0;\n\tstring com, buf = \"\";\n\tIL {\n\t\tcin >> com;\n\t\tif (com == \"a\") {\n\t\t\tx = 0;\n\t\t} else if (com == \"e\") {\n\t\t\tx = sz(str[y]);\n\t\t} else if (com == \"p\") {\n\t\t\tx = 0;\n\t\t\tif (y > 0) --y;\n\t\t} else if (com == \"n\") {\n\t\t\tx = 0;\n\t\t\tif (y < h - 1) ++y; \n\t\t} else if (com == \"f\") {\n\t\t\tif (x < sz(str[y])) ++x;\n\t\t\telse if (y < h - 1) {x = 0; ++y;}\n\t\t} else if (com == \"b\") {\n\t\t\tif (x > 0) --x;\n\t\t\telse if (y > 0) {--y; x = sz(str[y]);}\n\t\t} else if (com == \"d\") {\n\t\t\tif (x < sz(str[y])) str[y] = str[y].substr(0, x) + str[y].substr(x + 1);\n\t\t\telse if (y < h - 1) {\n\t\t\t\tstr[y] += str[y + 1];\n\t\t\t\t--h;\n\t\t\t\trepn (i, y + 1, h) str[i] = str[i + 1];\n\t\t\t}\n\t\t} else if (com == \"k\") {\n\t\t\tif (x == sz(str[y])) {\n\t\t\t\tif (y < h - 1) {\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t\tstr[y] += str[y + 1];\n\t\t\t\t\t--h;\n\t\t\t\t\trepn (i, y + 1, h) str[i] = str[i + 1];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbuf = str[y].substr(x);\n\t\t\t\tstr[y] = str[y].substr(0, x);\n\t\t\t\tx = sz(str[y]);\n\t\t\t}\n\t\t} else if (com == \"y\") {\n\t\t\tif (buf == \"\\n\") {\n\t\t\t\t++h;\n\t\t\t\trepn (i, y + 2, h) str[i] = str[i - 1];\n\t\t\t\tstr[y + 1] = str[y].substr(x);\n\t\t\t\tstr[y] = str[y].substr(0, x);\n\t\t\t\tx = 0;\n\t\t\t\t++y;\n\t\t\t} else if (sz(buf)  > 0) {\n\t\t\t\tstr[y] = str[y].substr(0, x) + buf + str[y].substr(x);\n\t\t\t\tx += sz(buf);\n\t\t\t}\n\t\t} else if (com == \"-\") {\n\t\t\tbreak;\n\t\t}\n\t}\n\trep (i, h) cout << str[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\nvector<string> text;\nstring buf;\n\nint row, col;\n\nvoid func_a(){\n\tcol = 0;\n}\n\nvoid func_e(){\n\tcol = text[row].size() - 1;\n}\n\nvoid func_p(){\n\tif (row > 0) row--;\n\tfunc_a();\n}\n\nvoid func_n(){\n\tif (row < text.size() - 1) row++;\n\tfunc_a();\n}\n\nvoid func_f(){\n\tif (col < text[row].size() - 1) col++;\n\telse func_n();\n}\n\nvoid func_b(){\n\tif (col > 0) col--;\n\telse if (row > 0){\n\t\tfunc_p();\n\t\tfunc_e();\n\t}\n}\n\nvoid func_d(){\n\tif (col < text[row].size() - 1) text[row].erase(col, col);\n\telse if (row < text.size() - 1){\n\t\ttext[row] += text[row + 1];\n\t\ttext.erase(text.begin() + row + 1);\n\t}\n}\n\nvoid func_k(){\n\tif (col < text[row].size() - 1){\n\t\tbuf = text[row].substr(col, text[row].size() - col - 1);\n\t\ttext[row].erase(col, text[row].size() - 1);\n\t\tcol = text[row].size() - 1;\n\t}\n\telse if (row < text.size() - 1){\n\t\tfunc_d();\n\t\tbuf = \"\\n\";\n\t}\n}\n\nvoid func_y(){\n\tif (!buf.empty()){\n\t\tif (buf == \"\\n\"){\n\t\t\ttext.insert(text.begin() + row + 1, text[row].substr(col, text[row].size() - 1));\n\t\t\ttext[row].erase(col, text[row].size() - 1);\t\t\t\n\t\t}\n\t\telse {\n\t\t\ttext[row].insert(col, buf);\n\t\t\tcol += buf.size();\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstring in;\n\tchar cmd;\n\n\twhile (getline(cin, in), in != \"END_OF_TEXT\"){\n\t\ttext.push_back(in + '$');\n\t}\n\t\n\tcol = row = 0;\n\tbuf.clear();\n\n\twhile (cin >> cmd, cmd != '-'){\n\t\tswitch (cmd){\n\t\t  case 'a': func_a(); break;\n\t\t  case 'e':\tfunc_e(); break;\n\t\t  case 'p':\tfunc_p(); break;\n\t\t  case 'n': func_n(); break;\n\t\t  case 'f': func_f(); break;\n\t\t  case 'b':\tfunc_b(); break;\n\t\t  case 'd':\tfunc_d(); break;\n\t\t  case 'k': func_k(); break;\n\t\t  case 'y': func_y(); break;\n\t\t}\n#if 0\n\t\tprintf(\"col:%d row:%d\\n\", col, row);\n\t\tputs(\"status:\");\n\t\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\t\tcout << *it << endl;\n\t\t}\n\t\tputs(\"buffer:\");\n\t\tcout << buf << endl;\n#endif\n\t}\n\n\t\n\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\tcout << it->substr(0, it->size() - 1) << endl;\n\t}\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t;\nvector<char> tmp;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nint main(){\n  t.clear();\n  tmp.clear();\n  input();\n  x=y=0;\n  while(1){\n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n\n  }\n\n  for(int i=0;i<t.size();i++){\n    for(int j=0;j<t[i].size();j++){\n      cout<<t[i][j];\n    }\n  }\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    t[y].erase(t[y].begin()+x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  t[y].erase(t[y].begin()+x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  t.erase(t.begin()+y+1);\n}\n\nvoid funcK(){\n  tmp.clear();\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.push_back('\\n');\n    }\n    return;\n  }\n  int c=0;\n  for(int i=x;i+1<(int)t[y].size();i++){\n    tmp.push_back(t[y][i]);\n    c++;\n  }\n  for(int i=0;i<=c;i++)t[y].pop_back();\n  t[y].push_back('\\n');\n  reverse(tmp.begin(),tmp.end());\n}\n\nvoid funcY(){\n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    vector<char> z;\n    int c=0;\n    for(int i=x;i<(int)t[y].size();i++){\n      z.push_back(t[y][i]);\n      c++;\n    }\n    for(int i=0;i<=c;i++)t[y].pop_back();\n    t[y].push_back('\\n');\n    t.insert(t.begin()+y+1,z);\n    y++;\n    x=0;\n    return;\n  }\n\n  for(int i=0;i<(int)tmp.size();i++){\n    t[y].insert(t[y].begin()+x,tmp[i]);\n  }\n  funcE();\n\n}\n\nvoid input(){\n  vector<char> a;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<string> text;\nstring buf;\n\nint row, col;\n\nvoid func_a(){\n\tcol = 0;\n}\n\nvoid func_e(){\n\tcol = text[row].size();\n}\n\nvoid func_p(){\n\tif (row > 0) row--;\n\tfunc_a();\n}\n\nvoid func_n(){\n\tif (row < text.size() - 1) row++;\n\tfunc_a();\n}\n\nvoid func_f(){\n\tif (col < text[row].size()) col++;\n\telse if (row < text.size() - 1){\n\t\tfunc_n();\n\t}\n}\n\nvoid func_b(){\n\tif (col > 0) col--;\n\telse if (row > 0){\n\t\tfunc_p();\n\t\tfunc_e();\n\t}\n}\n\nvoid func_d(){\n\tif (col < text[row].size()) text[row].erase(col, 1);\n\telse if (row < text.size() - 1){\n\t\ttext[row].erase(text[row].end() - 1);\n\t\ttext[row] += text[row + 1];\n\t\ttext.erase(text.begin() + row + 1);\n\t}\n}\n\nvoid func_k(){\n\tif (col < text[row].size()){\n\t\tbuf = text[row].substr(col, text[row].size() - col);\n\t\ttext[row].erase(col, text[row].size());\n\t}\n\telse if (row < text.size() - 1){\n\t\tfunc_d();\n\t\tbuf = \"\\n\";\n\t}\n}\n\nvoid func_y(){\n\tif (!buf.empty()){\n\t\tif (buf == \"\\n\"){\n\t\t\ttext.insert(text.begin() + row + 1, text[row]);\n\t\t\ttext[row].erase(col, text[row].size() - 1);\n\t\t\tfunc_n();\n\t\t}\n\t\telse {\n\t\t\ttext[row].insert(col, buf);\n\t\t\tcol += buf.size();\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstring in;\n\tchar cmd;\n\n\twhile (getline(cin, in), in != \"END_OF_TEXT\"){\n\t\ttext.push_back(in);\n\t}\n\t\n\tcol = row = 0;\n\tbuf.clear();\n\n\twhile (cin >> cmd, cmd != '-'){\n\t\tswitch (cmd){\n\t\t  case 'a': func_a(); break;\n\t\t  case 'e':\tfunc_e(); break;\n\t\t  case 'p':\tfunc_p(); break;\n\t\t  case 'n': func_n(); break;\n\t\t  case 'f': func_f(); break;\n\t\t  case 'b':\tfunc_b(); break;\n\t\t  case 'd':\tfunc_d(); break;\n\t\t  case 'k': func_k(); break;\n\t\t  case 'y': func_y(); break;\n\t\t}\n#if 0\n\t\tprintf(\"col:%d row:%d\\n\", col, row);\n\t\tputs(\"status:\");\n\t\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\t\tcout << *it << endl;\n\t\t}\n\t\tputs(\"buffer:\");\n\t\tcout << buf << endl;\n#endif\n\t}\n\n\t\n\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\tcout << *it << endl;\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t,u;\nvector<char> tmp;\nvector<char> z;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nvoid yinsert(int,vector<char>);\nvoid xinsert(int,int,char);\nvoid ydelete(int);\nvoid xdelete(int,int);\n\nint main(){\n\n  t.clear();\n  tmp.clear();\n  input();\n  x=y=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n    //cout<<y<<' '<<x<<\" ty\"<<t.size()<<endl;\n  }\n\n  for(int i=0;i<t.size();i++){\n    for(int j=0;j<t[i].size();j++){\n      cout<<t[i][j];\n    }\n  }\n\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    xdelete(y,x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  xdelete(y,x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  ydelete(y+1);\n}\n\nvoid funcK(){\n  tmp.clear();\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.push_back('\\n');\n    }\n    return;\n  }\n  while(t[y][x]!='\\n'){\n    tmp.push_back(t[y][x]);\n    xdelete(y,x);\n  }\n  reverse(tmp.begin(),tmp.end());\n  //funcE();\n}\n\nvoid funcY(){\n  z.clear();\n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    while(t[y][x]!='\\n'){\n      z.push_back(t[y][x]);\n      xdelete(y,x);\n    }\n    yinsert(y+1,z);\n    y++;\n    x=0;\n    return;\n  }\n  for(int i=0;i<(int)tmp.size();i++){\n    xinsert(y,x,tmp[i]);\n  }\n  funcE();\n}\n\nvoid input(){\n  vector<char> a;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n}\n\n\n\n\n\n\n\n\nvoid xinsert(int y,int x,char ch){\n  if(x==(int)t[y].size()){\n    t[y].push_back(ch);\n  }else{\n    \n    z=t[y];\n    t[y].clear();\n    for(int i=0;i<(int)z.size();i++){\n      if(i==x)t[y].push_back(ch);\n      t[y].push_back(z[i]);\n    }\n  }\n}\n\nvoid xdelete(int y,int x){\n  if(x+1==(int)t[y].size()){\n    t[y].pop_back();\n  }else{\n    \n    z=t[y];\n    t[y].clear();\n    for(int i=0;i<(int)z.size();i++){\n      if(i==x)continue;\n      t[y].push_back(z[i]);\n    }\n  }\n}\n\nvoid yinsert(int y,vector<char> ch){\n  if(y==(int)t.size()){\n    t.push_back(ch);\n  }else{\n    u=t;\n    t.clear();\n    for(int i=0;i<(int)u.size();i++){\n      if(i==y)t.push_back(ch);\n      t.push_back(u[i]);\n    }\n  }\n}\n\nvoid ydelete(int y){\n  if(y+1==(int)t.size()){\n    t.pop_back();\n  }else{\n    u=t;\n    t.clear();\n    for(int i=0;i<(int)u.size();i++){\n      if(i==y)continue;\n      t.push_back(u[i]);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Emacs {\nprivate:\n  string buffer;\n  // all elements has LF at the end.\n  vector<string> text; // text[row][column]\n  int row;\n  int column;\n\n  int findFirstColumn() { return 0; } int findLastColumn() { return text[row].size(); }\n\n  int findFirstRow(){return 0;}\n  int findLastRow(){return text.size()-1;}\n  void shiftRow(){\n    text[row] = text[row] + text[row+1];\n    text.erase(row+1 + text.begin());\n  }\n\n  bool isLastRow(){\n    auto end_row_idx = findLastRow();\n    return row == end_row_idx;\n  }\n  bool isFirstRow(){\n    return row == findFirstRow();\n  }\n  bool isLastColumn() {\n    auto end_column_idx = findLastColumn();\n    return column == end_column_idx;\n  }\n  bool isFirstColumn() {\n    return column == findFirstColumn();\n  }\n\npublic:\n#ifdef DEBUG\n  void print(){\n    cout << \"(\" << row << \", \" << column << \")\" << endl;\n    cout << \"===\" << buffer << endl;\n    for(int i = 0; i < (int)text.size(); i++){\n      for(int j = 0; j < (int)text[i].size(); j++){\n        if(i == row && j == column){\n          cout << \"\\x1b[7m\";\n        }\n        cout << text[i][j];\n        cout << \"\\x1b[0m\";\n      }\n      if(i == row && (int)text[i].size() == column){\n        cout << \"\\x1b[7m\";\n      }\n      cout << \" \";\n      cout << \"\\x1b[0m\";\n      cout << endl;\n    }\n    cout << \"---\" << endl << endl;\n  }\n#endif\n  Emacs(vector<string> text){\n    buffer = \"\";\n    this->text = text;\n    row = 0;\n    column = 0;\n  }\n  vector<string> getText(){return this->text;}\n  void distinguishCommand(char command) {\n    switch (command) {\n    case 'a': {\n      column = findFirstColumn();\n      break;\n    }\n    case 'e': {\n      column = findLastColumn();\n      break;\n    }\n    case 'p': {\n      column = findFirstColumn();\n      auto next_row = row - 1;\n      if (next_row >= findFirstRow()) {\n        row = next_row;\n      }\n      break;\n    }\n    case 'n': {\n      column = findFirstColumn();\n      auto next_row = row + 1;\n      if (next_row <= findLastRow()) {\n        row = next_row;\n      }\n      break;\n    }\n    case 'f': {\n      if (!isLastColumn()) {\n        column++;\n      } else if (!isLastRow()) {\n        column = findFirstColumn();\n        row++;\n      }\n      break;\n    }\n    case 'b': {\n      if (!isFirstColumn()) {\n        column--;\n      } else if (!isFirstRow()) {\n        row--;\n        column = findLastColumn();\n      }\n      break;\n    }\n    case 'd': {\n      if(!isLastColumn()){\n        text[row].erase(column + text[row].begin());\n      }else if(!isLastRow()){\n        shiftRow();\n      }\n      break;\n    }\n    case 'k': {\n      if(isLastColumn() && !isLastRow()){\n        shiftRow();\n        buffer = \"\\n\";\n      }else if(!isLastColumn()){\n        buffer = string(text[row].begin() + column, text[row].end());\n        text[row].erase(text[row].begin() + column, text[row].end());\n        column = findLastColumn();\n      }\n      break;\n    }\n    case 'y': {\n      if(buffer == \"\\n\"){\n        string left = string(text[row].begin(), text[row].begin()+column);\n        string right = string(text[row].begin() + column, text[row].end());\n\n        text[row] = left;\n        text.insert(text.begin() + row+1, right);\n        row++;\n        column = findFirstColumn();\n      }else if(!buffer.empty()){\n         // text[row].insert(column, buffer);\n         text[row].insert(column, buffer);\n         column += buffer.length();\n      }\n      break;\n    }\n    default: {\n      cerr << \"Invalid command: \" << command << endl;\n      exit(1);\n    }\n    }\n  }\n};\n\nint main(void) {\n  vector<string> text;\n  while(1){\n    string str;\n    getline(cin, str);\n    if(str == \"END_OF_TEXT\") break;\n    text.push_back(str);\n  }\n\n  Emacs emacs(text);\n\n  while(1){\n    char c; cin >> c;\n    if(c == '-') break;\n    emacs.distinguishCommand(c);\n#ifdef DEBUG\n    cout << \"==\" << c << \"==\" << endl;\n    emacs.print();\n#endif\n  }\n\n  vector<string> res = emacs.getText();\n  for(int i = 0; i < (int)res.size(); i++){\n    for(int j = 0; j < (int)res[i].size(); j++){\n      cout << res[i][j];\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <string>\n#include <cstdio>\n \nusing namespace std;\n \nint main()\n{\n    string str[300];\n    string b;\n    b[0] = '*';\n    int y = 0, y2 = 0;\n     \n    while (getline(std::cin, str[y]), str[y] != \"END_OF_TEXT\"){\n        y++;\n    }\n    y2 = --y;\n     \n    char cmd[2];\n    int car = 0, car_y = 0;\n\tint len;\n     \n    while (scanf(\"%s\", cmd), cmd[0] != '-'){\n\t\tlen = str[car_y].size();\n\t\t\n        if (cmd[0] == 'a'){\n            car = 0;\n        }\n        if (cmd[0] == 'e'){\n            car = len;\n        }\n        if (cmd[0] == 'p'){\n            if (car_y == 0){\n                car = 0;\n            }\n            else {\n                car_y--;\n                car = 0;\n            }\n        }\n        if (cmd[0] == 'n'){\n            if (car_y != y){\n                car_y++;\n                car = 0;\n            }\n             \n            else {\n                car = 0;\n            }\n        }\n        if (cmd[0] == 'f'){\n            if (car != len){\n                car++;\n            }\n            else {\n                if (car_y != y){\n                    car_y++;\n                    car = 0;\n                }\n            }\n        }\n        if (cmd[0] == 'b'){\n            if (car != 0){\n                car--;\n            }\n            else {\n                if (car_y != 0){\n                    car_y--;\n                    car = 0;\n                }\n            }\n        }\n        if (cmd[0] == 'd'){\n            if (car != len){\n                str[car_y].erase(car, 1);\n            }\n            else {\n                if (car_y != y){\n                    str[car_y].append(str[car_y + 1]);\n                    str[car_y + 1].erase();\n                     \n                    y2 = y - 1;\n                    y = car_y;\n                    while (++y < y2){\n                        str[y] = str[y - 1];\n                    }\n                    str[y].erase();\n                     \n                    y = y2;\n                }\n            }\n        }\n        if (cmd[0] == 'k'){\n            if (car == len){\n                if (car_y != y){\n                    str[car_y].append(str[car_y + 1]);\n                    str[car_y + 1].erase();\n                     \n                    y2 = y;\n                    y = car_y;\n                    while (++y < y2){\n                        str[y] = str[y - 1];\n                    }\n                    str[y].erase();\n                     \n                    y = y2;\n                    b[0] = '\\0';\n                }\n            }\n            else {\n                b = str[car_y].substr(car);\n                str[car_y].erase(car);\n                car = str[car_y].size();\n            }\n        }\n        if (cmd[0] == 'y'){\n            if(b[0] != '*'){\n                if (b[0] == '\\0'){\n                    y2 = y + 1;\n                    while (y > car_y + 1){\n                        str[y] = str[y - 1];\n                    }\n                    str[y] = str[car_y].substr(car);\n                    str[car_y].erase(car);\n                }\n                else {\n                    str[car_y].insert(car, b);\n                    car += b.size();\n                }\n            }\n        }\n    }\n     \n    for (int j = 0; j <= y; j++){\n        printf(\"%s\\n\", str[j].c_str());\n    }\n     \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[111];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\tfor(int i=0 ; i<111 ; i++)\n\t\tt[i] = \"\";\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tif(i<110) t[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tif(row<110) col = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 && row < 110 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row < 110 && row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( row < 110 && col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else if( row < 110 ){\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( row < 110 && buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line+1 < 110 && line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\tt[row+1] = \"\";\n\t\t\t\t\tfor(int i=col ; i<(int)t[row].size();i++)\n\t\t\t\t\t\tt[row+1].push_back( t[row][i] );\n\t\t\t\t\t//t[row].substr( col );\n\t\t\t\t\t//t[row+1] = ;\n\t\t\t\t\t//t[row+1] =\n\t\t\t\t\t//if( col != t[row].size() ) t[row];//.substr( col );\n\t\t\t\t\t//if(col != t[row].size() ) t[row].erase( 0 );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else if( row < 110 ){\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nstring s[102],buf;\nint l,r,N;\n\nvoid a(void){r=0;}\nvoid e(void){r=max(0,(int)s[l].size()-1);}\nvoid p(void){\n\tif(l>0)l--,r=0;\n\telse r=0;\n}\n\nvoid n(void){\n\tif(l<N-1)l++,r=0;\n\telse r=0;\n}\n\nvoid f(void){\n\tif(r<max(0,(int)s[l].size()-1))r++;\n\telse l++,r=0;\n}\n\nvoid b(void){\n\tif(r>0)r--;\n\telse if(l>0)r=s[--l].size();\n}\n\nvoid d(void){\n\tif(r==s[l].size()-1){\n\t\tif(l<N-1){\n\t\t\ts[l]+=s[l+1];\n\t\t\tfor(int i=l+1;i<N-1;i++)s[i]=s[i+1];\n\t\t\tN--;\n\t\t}\n\t}\n\telse s[l].erase(r,1);\n}\n\nvoid k(void){\n\tif(r==s[l].size() && l<N-1)d(),buf=\"\\n\";\n\telse {\n\t\tbuf=s[l].substr(max(0,r-1));\n\t\ts[l].erase(max(0,r-1));\n\t}\n}\n\nvoid y(void){\n\tif(buf.empty())return ;\n\tif(buf==\"\\n\"){\n\t\tfor(int i=N;i>l;i--)s[i]=s[i-1];\n\t\ts[l+1]=s[l].substr(max(0,r-1));\n\t\ts[l].erase(max(0,r-1));\n\t\tl++,r=0,N++;\n\t}\n\telse {\n\t\ts[l].insert(min((int)s[l].size(),r+1),buf);\n\t\tr+=buf.size();\n\t}\n}\n\n\nint main(void){\n\t\n\twhile(getline(cin,s[N])){\n\t\tif(s[N]==\"END_OF_TEXT\")break;\n\t\tN++;\n\t}\n\tl=r=0;\n\tbuf.clear();\n\t\n\t\t\n\tstring C;\n\twhile(cin >> C,C!=\"-\"){\n\t\t\n\t\tif(C==\"a\")a();\n\t\telse if(C==\"e\")e();\n\t\telse if(C==\"p\")p();\n\t\telse if(C==\"n\")n();\n\t\telse if(C==\"f\")f();\n\t\telse if(C==\"b\")b();\n\t\telse if(C==\"d\")d();\n\t\telse if(C==\"k\")k();\n\t\telse if(C==\"y\")y();\n\t}\n\t\n\tfor(int i=0;i<N;i++){\n\t\tcout << s[i] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t,u;\nvector<char> tmp;\nvector<char> z;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nvoid yinsert(int,vector<char>);\nvoid xinsert(int,int,char);\nvoid ydelete(int);\nvoid xdelete(int,int);\n\nint main(){\n\n  t.clear();\n  tmp.clear();\n  input();\n  x=y=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n    //cout<<y<<' '<<x<<\" ty\"<<t.size()<<endl;\n  }\n\n  for(int i=0;i<t.size();i++){\n    for(int j=0;j<t[i].size();j++){\n      cout<<t[i][j];\n    }\n  }\n\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    xdelete(y,x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  xdelete(y,x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  ydelete(y+1);\n}\n\nvoid funcK(){\n  tmp.clear();\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.push_back('\\n');\n    }\n    return;\n  }\n  while(t[y][x]!='\\n'){\n    tmp.push_back(t[y][x]);\n    xdelete(y,x);\n  }\n  reverse(tmp.begin(),tmp.end());\n  funcE();\n}\n\nvoid funcY(){\n  z.clear();\n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    while(t[y][x]!='\\n'){\n      z.push_back(t[y][x]);\n      xdelete(y,x);\n    }\n    yinsert(y+1,z);\n    return;\n  }\n  for(int i=0;i<(int)tmp.size();i++){\n    xinsert(y,x,tmp[i]);\n  }\n  funcE();\n}\n\nvoid input(){\n  vector<char> a;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n}\n\n\n\n\n\n\n\n\nvoid xinsert(int y,int x,char ch){\n  if(x==(int)t[y].size()){\n    t[y].push_back(ch);\n  }else{\n    \n    z=t[y];\n    t[y].clear();\n    for(int i=0;i<(int)z.size();i++){\n      if(i==x)t[y].push_back(ch);\n      t[y].push_back(z[i]);\n    }\n  }\n}\n\nvoid xdelete(int y,int x){\n  if(x+1==(int)t[y].size()){\n    t[y].pop_back();\n  }else{\n    \n    z=t[y];\n    t[y].clear();\n    for(int i=0;i<(int)z.size();i++){\n      if(i==x)continue;\n      t[y].push_back(z[i]);\n    }\n  }\n}\n\nvoid yinsert(int y,vector<char> ch){\n  if(y==(int)t.size()){\n    t.push_back(ch);\n  }else{\n    u=t;\n    t.clear();\n    for(int i=0;i<(int)u.size();i++){\n      if(i==y)t.push_back(ch);\n      t.push_back(u[i]);\n    }\n  }\n}\n\nvoid ydelete(int y){\n  if(y+1==(int)t.size()){\n    t.pop_back();\n  }else{\n    u=t;\n    t.clear();\n    for(int i=0;i<(int)u.size();i++){\n      if(i==y)continue;\n      t.push_back(u[i]);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\n// char s[102][1002];\nvector<string> s;\nint R;\n\nvoid input() {\n  string l;\n  int r = 0;\n  while (1) {\n    getline(cin, l);\n    // printf(\"INPUT:%s\\n\", l.c_str());\n    if (l == \"END_OF_TEXT\") {\n      R = r;\n      break;\n    }\n    l += '\\0';\n    s.push_back(l);\n    ++r;\n  }\n}\n\nvoid interpret() {\n  string buf;\n  char op;\n  int ci = 0, cj = 0;\n  while (cin >> op, op != '-') {\n    // rep(i,R) {\n    //   printf(\"%s\\n\", s[i].c_str());\n    // }\n    // puts(\"--------------------------------------------------\");\n    // printf(\"[operation : %c | buf : %s]\\n\", op, buf.c_str());\n    switch (op) {\n      case 'a': {\n        // カーソルを現在の行の先頭文字に移動する\n        cj = 0;\n        break;\n      }\n      case 'e': {\n        // カーソルを現在の行の行末に移動する\n        cj = s[ci].size() - 1;\n        break;\n      }\n      case 'p': {\n        // 上に行があれば、カーソルを上の行の先頭文字に移動する。\n        // 上に行がなければ、カーソルを先頭文字に移動する。\n        if (ci) \n          --ci;\n        cj = 0;\n        break;\n      }\n      case 'n': {\n        // 下に行があれば、カーソルを下の行の先頭文字に移動する。\n        // 下に行がなければ、カーソルを先頭文字に移動する。\n        if (ci + 1 < R) \n          ++ci;\n        cj = 0;\n        break;\n      }\n      case 'f': {\n        // カーソルが行末にない場合、カーソルを１つ右に移動する \n        // カーソルが行末にありかつ下に行がある場合は、\n        // カーソルを下の行の先頭文字へ移動する \n        // それ以外の場合は何もしない\n        if (s[ci][cj] != '\\0') {\n          ++cj;\n        } else if (s[ci][cj] == '\\0' && ci + 1 < R) {\n          ++ci; cj = 0;\n        }\n        break;\n      }\n      case 'b': {\n        // カーソルが先頭文字でないならば、カーソルを１つ左に移動する。\n        // カーソルが先頭文字でありかつ上に行がある場合は、\n        // カーソルを上の行の行末へ移動する。\n        // それ以外の場合は何もしない。\n        if (cj != 0) {\n          // cj = 0;\n          --cj;\n        } else if (cj == 0 && ci != 0) {\n          --ci; cj = 0;\n        }\n        break;\n      }\n      case 'd': {\n        // カーソルが文字を指す場合はその文字を削除する。\n        // 削除された文字の右側の文字列は左にシフトされる。\n        // カーソルが行末を指し下に行がある場合は、\n        // 下の行をそのままカーソルの位置に繋げる。以下の行は上にシフトされる。\n        // それ以外の場合は何もしない。\n        if (s[ci][cj] == '\\0' && ci + 1 < R) {\n          s[ci].erase(cj, 1);\n          s[ci] += s[ci+1];\n          s.erase(s.begin() + ci + 1);\n        } else {\n          s[ci].erase(cj, 1);\n        }\n        break;\n      }\n      case 'k': {\n        // カーソルが行末にある場合、下に行があれば、\n        // d と同じ操作をしバッファに１つの改行を記録する。\n        // カーソルが行末にない場合、カーソルが指す文字を含めた\n        // 右側すべての文字を切り取りそれをバッファに記録する。\n        // カーソルは元の行の行末を指すようになる。全ての記録においてバッファは上書きされる。\n        // それ以外の場合は何もしない。(clarification at 14:20)\n        if (s[ci][cj] == '\\0' && ci + 1 < R) {\n          s[ci].erase(cj, 1);\n          s[ci] += s[ci+1];\n          s.erase(s.begin() + ci + 1);\n          buf = \"\\n\";\n        } else  {\n          buf = s[ci].substr(cj);\n          s[ci].erase(cj);\n          s[ci] += '\\0';\n        }\n        break;\n      }\n      case 'y': {\n        // バッファが空の場合はなにもしない。\n        // バッファの内容が改行の場合、カーソルが指す文字の直前で改行を行う。\n        // カーソルは新しい行の先頭文字へ移動する。\n        // バッファの内容が文字列の場合、カーソルの位置にバッファの内容を挿入する。\n        // カーソルの位置はもともと指していた文字または行末の場所へ移動する。 \n        if (buf == \"\") continue;\n        if (buf == \"\\n\") {\n          inserter(s, s.begin() + ci + 1) = s[ci].substr(cj);\n          s[ci].erase(cj);\n          s[ci] += '\\0';\n          ++ci; cj = 0;          \n        } else {\n          string tBuf = buf;\n          tBuf.erase(tBuf.size() - 1);\n          s[ci].insert(cj, tBuf.c_str());\n          cj += tBuf.size();\n        }\n        break;\n      }\n    }\n  }\n  // puts(\"----------------------------------------\");\n  rep(i,R) {\n    printf(\"%s\\n\", s[i].c_str());\n  }\n}\n\nint main() {\n  input();\n  interpret();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[110];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tt[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tcol = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\tt[row+1] = \"\";\n\t\t\t\t\tfor(int i=col ; i<(int)t[row].size();i++)\n\t\t\t\t\t\tt[row+1].push_back( t[row][i] );\n\t\t\t\t\tif(col < t[row].size() ) t[row].erase( col );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else{\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Emacs{\n  int line,column;\n  string buffer;\n  vector<string> text;\n\n  void editText(){\n    for(int i = 0 ; i < (int)text.size() ; i++){\n      if(isEmptyLine(i)){ text[i].empty(); }\n    }\n  }\n\n  void order(char command){\n    editText();\n    switch(command){\n    case 'a': funcA(); break;\n    case 'e': funcE(); break;\n    case 'p': funcP(); break;\n    case 'n': funcN(); break;\n    case 'f': funcF(); break;\n    case 'b': funcB(); break;\n    case 'd': funcD(); break;\n    case 'k': funcK(); break;\n    case 'y': funcY(); break;\n    }\n  }\n\n  bool isEmptyLine(int l){\n    for(int i = 0 ; i < (int)text[l].size() ; i++){\n      if(text[l][i] != ' '){ return false; }\n    }\n    return true;\n  }\n\n  void funcA(){\n    column = 0;\n  }\n  \n  void funcE(){\n    column = text[line].size();\n  }\n\n  void funcP(){\n    if(line > 0){ line--; }\n    column = 0;\n  }\n\n  void funcN(){\n    if(line+1 < (int)text.size()){ line++; }\n    column = 0;\n  }\n\n  void funcF(){\n    if(column == (int)text[line].size()){\n      if(line+1 < (int)text.size()){\n        line++;\n        column = 0;\n      }\n    }else{\n      column++;\n    }\n  }\n  \n  void funcB(){\n    if(column == 0){\n      if(line != 0){\n        line--;\n        column = text[line].size();\n      }\n    }else{\n      column--;\n    }\n  }\n\n  void funcD(){\n    if(text[line].empty()){\n      int len = text.size();\n      vector<string> ntext(len-1);\n      for(int i = 0 ; i < line ; i++){\n        ntext[i] = text[i];\n      }\n      for(int i = line ; i < len-1 ; i++){\n        ntext[i] = text[i+1];\n      }\n      text = ntext;\n      return;\n    }\n    if(0 <= column && column < (int)text[line].size()){\n      text[line] = text[line].substr(0,column) + text[line].substr(column+1);\n    }else{\n      int len = text.size();\n      if(line+1 < len){\n        vector<string> ntext(len-1);\n        for(int i = 0 ; i < line-1 ; i++){\n          ntext[i] = text[i];\n        }\n        ntext[line] = text[line] + text[line+1];\n        for(int i = line+2 ; i < len ; i++){\n          ntext[i-1] = text[i];\n        }\n        text = ntext;\n      }\n    }\n  }\n\n  void funcK(){\n    int len = text[line].size();\n    if(text[line].empty()){\n      buffer = \"\\n\";\n      int len = text.size();\n      vector<string> ntext(len-1);\n      for(int i = 0 ; i < line ; i++){\n        ntext[i] = text[i];\n      }\n      for(int i = line ; i < len-1 ; i++){\n        ntext[i] = text[i+1];\n      }\n      text = ntext;\n      return;\n    }\n    if(column == len){\n      int len2 = text.size();\n      if(line+1 < len2){\n        buffer = \"\\n\";\n        vector<string> ntext(len-1);\n        for(int i = 0 ; i < line-1 ; i++){\n          ntext[i] = text[i];\n        }\n        ntext[line] = text[line] + text[line+1];\n        for(int i = line+2 ; i < len ; i++){\n          ntext[i-1] = text[i];\n        }\n        text = ntext;\n      }\n    }else{\n      buffer.clear();\n      for(int i = column ; i < len ; i++){\n        buffer += text[line][i];\n      }\n      text[line].resize(column);\n    }\n  }\n\n  void funcY(){\n    if(buffer.empty()){ return; }\n    if(buffer == \"\\n\"){\n      string str = text[line];\n      text[line] = str.substr(0,column);\n      if(line+1 < (int)text.size()){\n        text[line+1] = str.substr(column) + text[line+1];\n      }else{\n        text.push_back(str.substr(column));\n      }\n    }else{\n      string str = text[line];\n      str = str.substr(0,column) + buffer + str.substr(column);\n      text[line] = str;\n      column += buffer.size();\n    }\n  }\n\n  void print(){\n    int len = text.size();\n    for(int i = 0 ; i < len ; i++){\n      cout << text[i] << endl;\n    }\n  }\n};\n\nint main(){\n  Emacs emacs;\n  string str;\n  while(getline(cin,str), str != \"END_OF_TEXT\"){\n    emacs.text.push_back(str);\n  }\n  emacs.line = emacs.column = 0;\n  char command;\n  while(cin >> command, command != '-'){\n    emacs.order(command);\n  }\n  emacs.print();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[111];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tt[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tcol = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\tt[row+1] = \"\";\n\t\t\t\t\tfor(int i=col ; i<(int)t[row].size();i++)\n\t\t\t\t\t\tt[row+1].push_back( t[row][i] );\n\t\t\t\t\tif(col < t[row].size() ) t[row].erase( col );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else{\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <string>\n#include <cstdio>\n \nusing namespace std;\n \nint main()\n{\n    string str[300];\n    string b;\n    b[0] = '*';\n    int y = 0, y2 = 0;\n     \n    while (getline(std::cin, str[y]), str[y] != \"END_OF_TEXT\"){\n        y++;\n    }\n    y2 = --y;\n     \n    char cmd[2];\n    int car = 0, car_y = 0;\n\tint len;\n     \n    while (scanf(\"%s\", cmd), cmd[0] != '-'){\n\t\tlen = str[car_y].size();\n\t\t\n        if (cmd[0] == 'a'){\n            car = 0;\n        }\n        if (cmd[0] == 'e'){\n            car = len;\n        }\n        if (cmd[0] == 'p'){\n            if (car_y == 0){\n                car = 0;\n            }\n            else {\n                car_y--;\n                car = 0;\n            }\n        }\n        if (cmd[0] == 'n'){\n            if (car_y != y){\n                car_y++;\n                car = 0;\n            }\n             \n            else {\n                car = 0;\n            }\n        }\n        if (cmd[0] == 'f'){\n            if (car != len){\n                car++;\n            }\n            else {\n                if (car_y != y){\n                    car_y++;\n                    car = 0;\n                }\n            }\n        }\n        if (cmd[0] == 'b'){\n            if (car != 0){\n                car--;\n            }\n            else {\n                if (car_y != 0){\n                    car_y--;\n                    car = 0;\n                }\n            }\n        }\n        if (cmd[0] == 'd'){\n            if (car != len){\n                str[car_y].erase(car, 1);\n            }\n            else {\n                if (car_y != y){\n                    str[car_y].append(str[car_y + 1]);\n                    str[car_y + 1].erase();\n                     \n                    y2 = y - 1;\n                    y = car_y;\n                    while (++y < y2){\n                        str[y] = str[y - 1];\n                    }\n                    str[y].erase();\n                     \n                    y = y2;\n                }\n            }\n        }\n        if (cmd[0] == 'k'){\n            if (car == len){\n                if (car_y != y){\n                    str[car_y].append(str[car_y + 1]);\n                    str[car_y + 1].erase();\n                     \n                    y2 = y;\n                    y = car_y;\n                    while (++y < y2){\n                        str[y] = str[y - 1];\n                    }\n                    str[y].erase();\n                     \n                    y = y2;\n                    b[0] = '\\0';\n                }\n            }\n            else {\n                b = str[car_y].substr(car);\n                str[car_y].erase(car);\n                car = str[car_y].size();\n            }\n        }\n        if (cmd[0] == 'y'){\n            if(b[0] != '*'){\n                if (b[0] == '\\0'){\n                    y2 = y + 1;\n                    while (y > car_y + 1){\n                        str[y] = str[y - 1];\n\t\t\t\t\t\ty--;\n                    }\n                    str[y] = str[car_y].substr(car);\n                    str[car_y].erase(car);\n                }\n                else {\n                    str[car_y].insert(car, b);\n                    car += b.size();\n                }\n            }\n        }\n    }\n     \n    for (int j = 0; j <= y; j++){\n        printf(\"%s\\n\", str[j].c_str());\n    }\n     \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n \nusing namespace std;\n\n#define sz  size()\n#define er  erase\n#define ss  substr\n\nclass Emacs {\npublic:\n    Emacs(){\n        w = h = 0;\n        buf.clear();\n    }\n    void appendLine(string line){ txt.push_back(line); }\n    void execCommand(char code){\n        switch (code){\n          case 'a': A(); break;\n          case 'e': E(); break;\n          case 'p': P(); break;\n          case 'n': N(); break;\n          case 'f': F(); break;\n          case 'b': B(); break;\n          case 'd': D(); break;\n          case 'k': K(); break;\n          case 'y': Y(); break;\n        }\n    }\n    void showText(){\n        for (auto line : txt)\n            cout << line << \"\\n\";\n    }\nprivate:\n    void A(){ w = 0; }\n    void E(){ w = txt[h].sz; }\n    void P(){ h = max(h - 1, 0); A(); }\n    void N(){ h = min(h + 1, (int)txt.sz - 1); A(); }\n    void F(){ if (w < txt[h].sz) w++; else if (h < txt.sz - 1) A(), h++; }\n    void B(){ if (w > 0) w--; else if (h > 0) h--, E(); }\n    void D(){ if (w < txt[h].sz) txt[h].er(w, 1); else if (h < txt.sz - 1) txt[h] += txt[h + 1], txt.er(txt.begin() + h + 1); }\n    void K(){ if (w < txt[h].sz) buf = txt[h].ss(w), txt[h] = txt[h].ss(0, w); else if (h < txt.sz - 1) D(), buf = \"\\n\"; }\n    void Y(){ if (!buf.empty()) { if (buf == \"\\n\") txt.insert(txt.begin() + h + 1, txt[h].ss(w)), N(); else txt[h].insert(w, buf), w += buf.sz; }}\n    vector<string> txt;\n    string buf;\n    int h, w;\n};\n\nint main()\n{\n    Emacs emacs;\n\n    string in;\n    while (getline(cin, in), in != \"END_OF_TEXT\") emacs.appendLine(in);\n\n    char cmd;\n    while (cin >> cmd, cmd != '-') emacs.execCommand(cmd);\n\n    emacs.showText();\n\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[111];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\tfor(int i=0 ; i<111 ; i++)\n\t\tt[i] = \"\";\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tif(i<110) t[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tif(row<110) col = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 && row < 110 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row < 110 && row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( row < 110 && col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else if( row < 110 ){\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( row < 110 && buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line+1 < 110 && line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\t//t[row+1] =\n\t\t\t\t\t//if( col != t[row].size() ) t[row];//.substr( col );\n\t\t\t\t\tif(col != t[row].size() ) t[row].erase( 0 );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else if( row < 110 ){\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\n\nclass Emacs{\n  int row, col;\n  string buffer;\n  vector<string> text;\n\n  bool isFirstLine(){\n    return row == 0;\n  }\n\n  bool isLastLine(){\n    return row == text.size() - 1;\n  }\n\n  bool isFirstColumn(){\n    return col == 0;\n  }\n\n  bool isLastColumn(){\n    return col == text.at(row).size();\n  }\n\n  string::iterator firstColumn(){\n    return text.at(row).begin();\n  }\n\n  string::iterator lastColumn(){\n    return text.at(row).end();\n  }\n\n  void commandA(){\n    col = 0;\n  }\n\n  void commandE(){\n    col = text.at(row).size();\n  }\n\n  void commandP(){\n    if(!isFirstLine()){\n      row--;\n    }\n    col = 0;\n  }\n\n  void commandN(){\n    if(!isLastLine()){\n      row++;\n    }\n    col = 0;\n  }\n\n  void commandF(){\n    if(isLastColumn()){\n      commandN();\n    }\n    else{\n      col++;\n    }\n  }\n\n  void commandB(){\n    if(isFirstColumn() && !isFirstLine()){\n      row--;\n      col = text.at(row).size();\n    }\n    else{\n      col--;\n    }\n  }\n\n  void commandD(){\n    if(isLastColumn() && !isLastLine()){\n      text.at(row) += text.at(row + 1);\n      text.erase(text.begin() + row + 1);\n    }\n    else{\n      text.at(row).erase(firstColumn() + col);\n    }\n  }\n\n  void commandK(){\n    if(isLastColumn() && !isLastLine()){\n      commandD();\n      buffer = \"\\n\";\n    }\n    else{\n      buffer = text.at(row).substr(col);\n      text.at(row).erase(firstColumn() + col, lastColumn());\n      col = text.at(row).size();\n    }\n  }\n\n  void commandY(){\n    if(buffer.empty()){\n      return;\n    }\n    else if(buffer == \"\\n\"){\n      text.insert((text.begin() + row + 1), text.at(row).substr(col));\n      text.at(row).erase(firstColumn() + col, lastColumn());\n      commandN();\n    }\n    else{\n      text.at(row).insert(col, buffer);\n      col += buffer.size();\n    }\n  }\n\npublic:\n  Emacs(vector<string> str){\n    row = 0;\n    col = 0;\n    buffer = \"\";\n    text = str;\n  }\n\n  void applyCommand(char c){\n    switch(c){\n      case 'a': commandA(); break;\n      case 'e': commandE(); break;\n      case 'p': commandP(); break;\n      case 'n': commandN(); break;\n      case 'f': commandF(); break;\n      case 'b': commandB(); break;\n      case 'd': commandD(); break;\n      case 'k': commandK(); break;\n      case 'y': commandY(); break;\n    }\n  }\n\n  void output(){\n    for(auto line : text){\n      cout << line << endl;\n    }\n  }\n};\n\nint main(){\n  vector<string> text;\n  vector<char> commands;\n\n  string str;\n  while(getline(cin, str) && str != \"END_OF_TEXT\"){\n    text.push_back(str);\n  }\n\n  char c;\n  while(cin >> c && c != '-'){\n    commands.push_back(c);\n  }\n\n  Emacs emacs(text);\n\n  for(auto command : commands){\n    emacs.applyCommand(command);\n  }\n\n  emacs.output();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main(){\n\tstring str[1000];\n\tstring s;\n\tint size = 0;\n\twhile(getline(cin,s)){\n\t\tif(s == \"END_OF_TEXT\") break;\n\t\tstr[size++] = s;\n\t}\n\tchar ch;\n\tstring buf = \"\";\n\tint line = 0, pos = 0;\n\twhile(cin >> ch){\n\t\tif(ch == '-') break;\n\t\tif(ch == 'a') pos = 0;\n\t\tif(ch == 'e') pos = str[line].size();\n\t\tif(ch == 'p'){\n\t\t\tpos = 0;\n\t\t\tif(line!=0) line--;\n\t\t}\n\t\tif(ch == 'n'){\n\t\t\tpos = 0;\n\t\t\tif(line+1!=size) line++;\n\t\t}\n\t\tif(ch == 'f'){\n\t\t\tif(pos != str[line].size()) pos++;\n\t\t\telse if(line+1!=size) { pos = 0; line++; }\n\t\t}\n\t\tif(ch == 'b'){\n\t\t\tif(pos != 0) pos--;\n\t\t\telse if(line!=0) { line--; pos = str[line].size(); }\n\t\t}\n\t\tif(ch == 'd'){\n\t\t\tif(pos != str[line].size()){\n\t\t\t\tstr[line] = str[line].substr(0,pos) + str[line].substr(pos+1);\n\t\t\t} else if(line+1!=size){\n\t\t\t\tstr[line] = str[line] + str[line+1];\n\t\t\t\tfor(int i=line+1;i+1<size;i++){\n\t\t\t\t\tstr[i] = str[i+1];\n\t\t\t\t}\n\t\t\t\tstr[size-1] = \"\";\n\t\t\t\tsize--;\n\t\t\t}\n\t\t}\n\t\tif(ch == 'k'){\n\t\t\tif(pos == str[line].size() && line+1!=size){\n\t\t\t\tstr[line] = str[line] + str[line+1];\n\t\t\t\tfor(int i=line+1;i+1<size;i++){\n\t\t\t\t\tstr[i] = str[i+1];\n\t\t\t\t}\n\t\t\t\tstr[size-1] = \"\";\n\t\t\t\tsize--;\n\t\t\t\tbuf = \"IS_BREAK_LINE\";\n\t\t\t}\n\t\t\telse if(pos < str[line].size()){\n\t\t\t\tbuf = str[line].substr(pos);\n\t\t\t\tstr[line] = str[line].substr(0,pos);\n\t\t\t}\n\t\t}\n\t\tif(ch == 'y'){\n\t\t\tif(buf == \"IS_BREAK_LINE\"){\n\t\t\t\tfor(int i=size-1;i>=line+1;i--){\n\t\t\t\t\tstr[i+1] = str[i];\n\t\t\t\t}\n\t\t\t\tsize++;\n\t\t\t\tstr[line+1] = str[line].substr(pos);\n\t\t\t\tstr[line] = str[line].substr(0,pos);\n\t\t\t\tline++;\n\t\t\t\tpos = 0;\n\t\t\t} else if(buf != \"\"){\n\t\t\t\tstr[line] = str[line].substr(0,pos) + buf + str[line].substr(pos);\n\t\t\t\tpos += buf.size();\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tcout << line << \" \" << pos << endl;\n\t\tfor(int i=0;i<size;i++){\n\t\t\tcout << str[i] << endl;\t\n\t\t}\n\t\tputs(\"\");\n\t\t*/\n\t}\n\tfor(int i=0;i<size;i++){\n\t\tcout << str[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? n==1 ? x: b_pow(x,n>>1)*b_pow(x,(n>>1)+(n&1)) : 1;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\nstring buffer;\nvector<string> text;\nint x,y;\n\nvoid a(){\n\tx = 0;\n}\nvoid e(){\n\tx = text[y].length() - 1;\n}\nvoid p(){\n\tint ty = y - 1;\n\tx = 0;\n\tif(ty != -1 )y = ty;\n}\n\nvoid n(){\n\tint ty = y + 1;\n\tx = 0;\n\tif(ty != text.size() )y = ty;\n}\n\nvoid f(){\n\tint tx = x + 1;\n\tif(tx == text[y].length() ){\n\t\tint ty = y + 1;\n\t\tif(ty != text.size() ){\n\t\t\ty = ty;\n\t\t\tx = 0;\n\t\t}\n\t}else{\n\t\tx = tx;\n\t}\n}\n\nvoid b(){\n\tint tx = x - 1;\n\tif(tx == -1 ){\n\t\tint ty = y - 1;\n\t\tif(ty != -1 ){\n\t\t\ty = ty;\n\t\t\tx = text[y].length() - 1;\n\t\t}\n\t}else{\n\t\tx = tx;\n\t}\n}\n\nbool d(){\n\tif(text[y][x] == '\\n'){\n\t\tint ty = y + 1;\n\t\tif(ty != text.size() ){\n\t\t\ttext[y].erase(x,1);\n\t\t\ttext[y] += text[ty];\n\t\t\ttext[ty] = \"\";\n\t\t\treturn true;\n\t\t}\n\t}else{\n\t\ttext[y].erase(x,1);\n\t}\n\treturn false;\n}\nvoid k(){\n\tif(text[y][x] == '\\n'){\n\t\tif(d())buffer = \"\\n\";\n\t}else{\n\t\tbuffer = text[y].substr(x); buffer.erase(buffer.length()-1);\n\t\ttext[y] = text[y].substr(0,x) + \"\\n\";\n\t}\n}\n\nvoid Y(){\n\tif(buffer == \"\")return;\n\t\n\tif(buffer == \"\\n\"){\n\t\tvector<string> tmp;\n\t\tstring a,b;\n\t\ta = text[y].substr(0,x) + \"\\n\";\n\t\tb = text[y].substr(x);\n\t\trep(i,y)tmp.push_back(text[i]);\n\t\ttmp.push_back(a),tmp.push_back(b);\n\t\t\n\t\tfor(int i=y+1;i < text.size();i++)\n\t\t\ttmp.push_back(text[i]);\n\t\ty = y + 1;\n\t\t\n\t\ttext = tmp;\n\t}else{\n\t\ttext[y].insert(x,buffer);\n\t}\n}\n\n\nint main(){\n\tx = 0  , y = 0;\n\tstring s;\n\twhile(getline(cin,s)){\n\t\tif(s[s.length()-1] == '\\r')s.erase(s.length()-1,1);\n\t\tif(s == \"END_OF_TEXT\")break;\n\t\ttext.push_back(s + \"\\n\");\n\t}\n\tif(text.size() == 0)text.push_back(\"\\n\");\n\twhile(cin >> s , s != \"-\"){\n\t\tif(s == \"a\")a();\n\t\tif(s == \"e\")e();\n\t\tif(s == \"p\")p();\n\t\tif(s == \"n\")n();\n\t\tif(s == \"f\")f();\n\t\tif(s == \"b\")b();\n\t\tif(s == \"d\")d();\n\t\tif(s == \"k\")k();\n\t\tif(s == \"y\")Y();\n\t\ttext.erase(remove(all(text),\"\"),text.end());\n\t}\n\trep(i,text.size())cout << text[i];\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[128];\nstring buf;\nint lines;\nvoid delete_line(int y)\n{\n    if (lines > 1)\n\t--lines;\n    for (int i = y; y < lines; ++y)\n\ts[i] = s[i + 1];\n    s[lines] = \"\";\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; --i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    while (true)\n    {\n\tstring t;\n\tgetline(cin, t);\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines++] = t;\n    }\n    if (lines == 0)\n\tlines = 1;\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    y = max(0, --y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    y = max(0, min(lines - 1, ++y));\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y + 1 < lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t    {\n\t\t--y;\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t\ts[y].erase(x, 1);\n\t    else if (y + 1 < lines)\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t    }\n\t    break;\n\t}\n\tcase 'k':\n\t{\n\t    if (x != s[y].size())\n\t    {\n\t\tbuf = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = s[y].size();\n\t    }\n\t    else if (y + 1 < lines)\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\ts[y + 1] = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = 0, ++y;\n\t    }\n\t    else\n\t\ts[y] += buf;\n\t    break;\n\t}\n\t}\n    }\n\n    for (int i = 0; i < lines; ++i)\n\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\nvector<string> text;\nstring buf;\n\nint row, col;\n\nvoid func_a(){\n\tcol = 0;\n}\n\nvoid func_e(){\n\tcol = text[row].size() - 1;\n}\n\nvoid func_p(){\n\tif (row > 0) row--;\n\tfunc_a();\n}\n\nvoid func_n(){\n\tif (row < text.size() - 1) row++;\n\tfunc_a();\n}\n\nvoid func_f(){\n\tif (col < text[row].size() - 1) col++;\n\telse func_n();\n}\n\nvoid func_b(){\n\tif (col > 0) col--;\n\telse if (row > 0){\n\t\tfunc_p();\n\t\tfunc_e();\n\t}\n}\n\nvoid func_d(){\n\tif (col < text[row].size() - 1) text[row].erase(col, 1);\n\telse if (row < text.size() - 1){\n\t\ttext[row].erase(text[row].end() - 1);\n\t\ttext[row] += text[row + 1];\n\t\ttext.erase(text.begin() + row + 1);\n\t}\n}\n\nvoid func_k(){\n\tif (col < text[row].size() - 1){\n\t\tbuf = text[row].substr(col, text[row].size() - col - 1);\n\t\ttext[row].erase(col, text[row].size() - 1);\n\t\tcol = text[row].size() - 1;\n\t}\n\telse if (row < text.size() - 1){\n\t\tfunc_d();\n\t\tbuf = \"\\n\";\n\t}\n}\n\nvoid func_y(){\n\tif (!buf.empty()){\n\t\tif (buf == \"\\n\"){\n\t\t\ttext.insert(text.begin() + row + 1, text[row].substr(col, text[row].size() - 1));\n\t\t\ttext[row].erase(col, text[row].size() - 1);\t\t\t\n\t\t}\n\t\telse {\n\t\t\ttext[row].insert(col, buf);\n\t\t\tcol += buf.size();\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstring in;\n\tchar cmd;\n\n\twhile (getline(cin, in), in != \"END_OF_TEXT\"){\n\t\ttext.push_back(in + '$');\n\t}\n\t\n\tcol = row = 0;\n\tbuf.clear();\n\n\twhile (cin >> cmd, cmd != '-'){\n\t\tswitch (cmd){\n\t\t  case 'a': func_a(); break;\n\t\t  case 'e':\tfunc_e(); break;\n\t\t  case 'p':\tfunc_p(); break;\n\t\t  case 'n': func_n(); break;\n\t\t  case 'f': func_f(); break;\n\t\t  case 'b':\tfunc_b(); break;\n\t\t  case 'd':\tfunc_d(); break;\n\t\t  case 'k': func_k(); break;\n\t\t  case 'y': func_y(); break;\n\t\t}\n#if 0\n\t\tprintf(\"col:%d row:%d\\n\", col, row);\n\t\tputs(\"status:\");\n\t\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\t\tcout << *it << endl;\n\t\t}\n\t\tputs(\"buffer:\");\n\t\tcout << buf << endl;\n#endif\n\t}\n\n\t\n\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\tcout << it->substr(0, it->size() - 1) << endl;\n\t}\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1021\n#include<iostream>\n#include<vector>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\nconst int LMAX = 1000;\n\nvector<string> lines;\nint h, w;\nstring buffer;\n\nbool on_tail() { return w == lines[h].size(); }\nvoid goto_tail() { w = lines[h].size(); }\nbool on_eof() { return h >= lines.size() - 1; }\nvoid remove_line(int n) { lines.erase(lines.begin() + n); }\nvoid remove_char(int h, int w) {\n  lines[h].erase(lines[h].begin() + w);\n}\n\nvoid a() { w = 0; }\nvoid e() { goto_tail(); }\nvoid p() { h = max(h - 1, 0); w = 0; }\nvoid n() { h = min(h + 1, (int)lines.size() - 1); w = 0; }\nvoid f() {\n  if (not on_tail()) { w++; }\n  else if (not on_eof()) {\n    h++; w = 0;\n  }\n}\nvoid b() {\n  if (w > 0) { w--; }\n  else if (h > 0) { h--; goto_tail(); }\n}\nvoid d() {\n  if (on_tail() and !on_eof()) {\n    lines[h] += lines[h + 1];\n    remove_line(h + 1);\n  } else if (not on_tail()) {\n    remove_char(h, w);\n  }\n}\nvoid k() {\n  if (on_tail() and !on_eof()) {\n    d();\n    buffer = \"\\n\";\n  } else if (not on_tail()) {\n    buffer = lines[h].substr(w);\n    lines[h] = lines[h].substr(0, w);\n  }\n}\nvoid y() {\n  if (buffer == \"\\n\") {\n    lines.insert(lines.begin() + h, \"\\n\");\n    h++; w = 0;\n  } else if (not buffer.empty()) {\n    lines[h].insert(lines[h].begin()+w, buffer.begin(), buffer.end());\n    w += buffer.size();\n  }\n}\n\nint main() {\n  string l;\n  buffer = \"\";\n  while (cin >> l and l != \"END_OF_TEXT\") {\n    lines.push_back(l);\n  }\n\n  char com;\n  while (cin >> com and com != '-') {\n    switch (com) {\n    case 'a':\n      a(); break;\n    case 'e':\n      e(); break;\n    case 'p':\n      p(); break;\n    case 'n':\n      n(); break;\n    case 'f':\n      f(); break;\n    case 'b':\n      b(); break;\n    case 'd':\n      d(); break;\n    case 'k':\n      k(); break;\n    case 'y':\n      y(); break;\n    default:\n      break;\n    }\n/*    REP(i, lines.size()) {\n      cout << \">\" << lines[i] << endl;\n    }\n    cout << \"(\" << h << \",\" << w << \")\" << endl;\n*/  }\n\n  for (int i = 0; i < lines.size(); i++) {\n    cout << lines[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<string> buf;\nint row;\nint column;\nstring rem;\n\nvoid printbuf(){\n  cout << row << ' ' << column << \" \\\"\" << rem << \"\\\"\" << endl;\n  for(int i=0;i<buf.size();i++){\n    cout << buf[i];\n  }\n}\n\nmain(){\n  string in;\n  while(getline(cin, in)){\n    if(in == \"END_OF_TEXT\" /*|| in == \"1\"*/) break;\n    in += '\\n';\n    buf.push_back(in);\n  }\n  char c;\n  row = 0;\n  column = 0;\n  while(cin >> c){\n    if(c == '-') break;\n    switch(c){\n      case 'a':\n        column = 0;\n        break;\n      case 'e':\n        column = (int)buf[row].size()-1;\n        break;\n      case 'p':\n        column = 0;\n        if(row > 0) --row;\n        break;\n      case 'n':\n        column = 0;\n        if(row+1 < buf.size()) ++row;\n        break;\n      case 'f':\n        if(column+1 >= buf[row].size()){\n          if(row+1 < buf.size()){\n            column = 0;\n            ++row;\n          }\n        }else{\n          ++column;\n        }\n        break;\n      case 'b':\n        if(column == 0){\n          if(row > 0){\n            --row;\n            column = (int)buf[row].size()-1;\n          }\n        }else{\n          --column;\n        }\n        break;\n      case 'd':\n        if(column+1 == buf[row].size()){\n          if(row+1 != buf.size()){\n            vector<string>::iterator ite = buf.begin();\n            for(int i=0;i<row;i++) ++ite;\n            buf.erase(ite);\n          }\n        }else{\n          buf[row].erase(column, 1);\n        }\n        break;\n      case 'k':\n        rem = \"\";\n        if(column+1 == buf[row].size()){\n          if(row+1 != buf.size()){\n            vector<string>::iterator ite = buf.begin();\n            for(int i=0;i<row;i++) ++ite;\n            buf.erase(ite);\n            rem += '\\n';\n          }\n        }else{\n          for(int i=column;i+1<buf[row].size();++i){\n            rem += buf[row][i];\n          }\n          string::iterator ite = buf[row].begin();\n          for(int i=0;i<column;i++) ++ite;\n          buf[row].erase(ite, buf[row].end());\n          buf[row] += '\\n';\n        }\n        break;\n      case 'y':\n        if(rem.size() != 0){\n          int irem;\n          string back = buf[row].substr(column);\n          buf[row] = buf[row].substr(0, column);\n          for(irem = 0;irem<rem.size();irem++){\n            buf[row] += rem[irem];\n            ++column;\n            if(rem[irem] == '\\n'){\n              vector<string>::iterator ite = buf.begin();\n              for(int i=0;i<row+1;i++) ++ite;\n              buf.insert(ite, \"\");\n              column = 0;\n              ++row;\n            }\n          }\n          buf[row] += back;\n        }\n        break;\n    }\n    //printbuf();\n  }\n  for(int i=0;i<buf.size();i++){\n    cout << buf[i];\n  }\n  //cout << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tstring str[10000];\n\tstring b;\n\tint i = 0;\n\t\n\twhile (getline(std::cin, str[i]), str[i] != \"END_OF_TEXT\") i++;\n\ti = 0;\n\t\n\tchar cmd[2];\n\tint car_y = 0;\n\tint car = 0;\n\tint y = 0, y2 = 0;\n\t\n\twhile (str[y] != \"END_OF_TEXT\") y++;\n\ty--;\n\ty2 = y;\n\t\n\tcout << str[y] << endl;\n\t\n\tb.erase();\n\t\n\twhile (scanf(\"%s\", cmd), cmd[0] != '-'){\n\t\tif (cmd[0] == 'a'){\n\t\t\tcar = 0;\n\t\t//\tprintf(\" a\");\n\t\t}\n\t\tif (cmd[0] == 'e'){\n\t\t\tcar = str[car_y].size();\n\t\t\t\n\t\t//\tprintf(\" e\");\n\t\t}\n\t\tif (cmd[0] == 'p'){\n\t\t\t\n\t\t//\tprintf(\" p\");\n\t\t\tif (car_y == 0){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y--;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'n'){\n\t\t//\tprintf(\" n\");\n\t\t\tif (car_y == y2){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y++;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'f'){\n\t\t//\tprintf(\" f\");\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\tcar_y++;\n\t\t\t\t\tcar = 0;\n\t\t\t\t\t//printf(\" %d\",car_y);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar++;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'b'){\n\t\t//\tprintf(\" b\");\n\t\t\tif (car == 0){\n\t\t\t\tif (car_y != 0){\n\t\t\t\t\tcar_y--;\n\t\t\t\t\tcar = str[car_y].size();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar--;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'd'){\n\t\t//\tprintf(\" d\");\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tstr[car_y].erase(car, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\t//str[car_y] + str[car_y + 1];\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'k'){\n\t\t//\tprintf(\" k\");\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\tb[0] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb.erase();\n\t\t\t\tb = str[car_y].substr(car);\n\t\t\t\tstr[car_y].erase(car);\n\t\t\t\tcar = str[car_y].size();\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'y'){\n\t\t//\tprintf(\" y\");\n\t\t\tif (b.empty());\n\t\t\telse {\n\t\t\t\tif (b[0] == '\\0'){\n\t\t\t\t\ty2 = ++y;\n\t\t\t\t\twhile (y < car_y){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t\ty--;\n\t\t\t\t\t}\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstr[car_y].insert(car, b);\n\t\t\t\t\tcar += b.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\ti = 0;\n\twhile (i <= y2){\n\t\t//puts(str[i].c_str());\n\t\tcout << str[i] << endl;\n\t\ti++;\n\t}\n\t/*\n\ti = 0;\n\twhile (i <= y2){\n\t\tif (car_y == i){\n\t\t\tfor (int j = 0; j <= str[i].size(); j++){\n\t\t\t\tif (j == car){\n\t\t\t\t\tcout << 'I';\n\t\t\t\t}\n\t\t\t\tcout << str[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\telse{\n\t\t\tputs(str[i].c_str());\n\t\t}\n\t\ti++;\n\t}*/\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<string> vs;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nvoid printtext(vs &text,char c,int cur,int line,string buf)\n{\n\tcerr<<\"command: \"<<c<<endl;\n\tcerr<<\"cur: \"<<cur<<\", line: \"<<line<<\", buffer: \"<<buf<<endl;\n\trep(i,text.size())cerr<<text[i]<<endl;\n}\n\nint main()\n{\n\tvs text;\n\tstring tmp,buf;\n\twhile(cin>>tmp,tmp!=\"END_OF_TEXT\")text.pb(tmp);\n\t\n\tchar c;\n\tint cur=0,line=0;\n\twhile(cin>>c,c!='-')\n\t{\n\t\tif(c=='a')cur=0;\n\t\telse if(c=='e')cur=text[line].size();\n\t\telse if(c=='p')\n\t\t{\n\t\t\tcur=0;\n\t\t\tif(line>0)line--;\n\t\t}\n\t\telse if(c=='n')\n\t\t{\n\t\t\tcur=0;\n\t\t\tif(line<text.size()-1)line++;\n\t\t}\n\t\telse if(c=='f')\n\t\t{\n\t\t\tif(cur!=text[line].size())cur++;\n\t\t\telse if(line<text.size()-1)line++,cur=0;\n\t\t}\n\t\telse if(c=='b')\n\t\t{\n\t\t\tif(cur!=0)cur--;\n\t\t\telse if(line>0)line--,cur=text[line].size();\n\t\t}\n\t\telse if(c=='d')\n\t\t{\n\t\t\tif(cur<text[line].size())text[line].erase(text[line].begin()+cur);\n\t\t\tif(cur==text[line].size()&&line<text.size()-1)\n\t\t\t{\n\t\t\t\ttext[line]+=text[line+1];\n\t\t\t\ttext.erase(text.begin()+(line+1));\n\t\t\t}\n\t\t}\n\t\telse if(c=='k')\n\t\t{\n\t\t\tif(cur<text[line].size())\n\t\t\t{\n\t\t\t\tbuf=text[line].substr(cur);\n\t\t\t\ttext[line].erase(text[line].begin()+cur,text[line].end());\n\t\t\t}\n\t\t\telse if(cur==text[line].size()&&line<text.size()-1)\n\t\t\t{\n\t\t\t\ttext[line]+=text[line+1];\n\t\t\t\ttext.erase(text.begin()+(line+1));\n\t\t\t\tbuf=\"\\n\";\n\t\t\t}\n\t\t}\n\t\telse if(c=='y')\n\t\t{\n\t\t\tif(buf.empty())continue;\n\t\t\tif(buf==\"\\n\")\n\t\t\t{\n\t\t\t\ttext.insert(text.begin()+line,text[line].substr(0,cur));\n\t\t\t\ttext[line].erase(text[line].begin()+cur,text[line].end());\n\t\t\t\tcur=0; line++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttext[line].insert(text[line].begin()+cur,all(buf));\n\t\t\t\tcur+=buf.size();\n\t\t\t}\n\t\t}\n\t\t\n\t\t//printtext(text,c,cur,line,buf);\n\t}\n\trep(i,text.size())cout<<text[i]<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvoid doA(int *l, int *c, string &s, string &b, vector<string> &v) {\n  *c = 0;\n}\n\nvoid doE(int *l, int *c, string &s, string &b, vector<string> &v) {\n  *c = s.size();\n}\n\nvoid doP(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*l > 0)\n    *l -= 1;\n  *c = 0;\n}\n\nvoid doN(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*l < v.size()-1)\n    *l += 1;\n  *c = 0;\n}\n\nvoid doF(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c < s.size()) {\n    *c += 1;\n  } else if (*l < v.size()-1){\n    *l += 1;\n    *c = 0;\n  }\n}\n\nvoid doB(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c > 0) {\n    *c -= 1;\n  } else if (*l > 0) {\n    *l -= 1;\n    *c = v[*l].size();\n  }\n}\n\nvoid doD(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c < s.size()) {\n    s.erase(*c, 1);\n  } else if (*l < v.size()-1) {\n    s.append(v[*l+1]);\n    vector<string>::iterator itr = v.begin() + *l + 1;\n    v.erase(itr);\n  }\n}\n\nvoid doK(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c == s.size() && *l < v.size()-1) {\n    doD(l, c, s, b, v);\n    b = \"\\n\";\n  } else if (*c < s.size()) {\n    b = s.substr(*c, s.size() - *c);\n    s.erase(*c, s.size() - *c);\n    *c = s.size();\n  }\n}\n\n\nvoid doY(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (b.empty()) {\n    return;\n  } else if (b == \"\\n\" ) {\n    doK(l, c, s, b, v);\n    vector<string>::iterator itr = v.begin() + *l + 1;\n    v.insert(itr, b);\n    b = \"\\n\";\n    *l++;\n    *c = 0;\n  } else {\n    s.insert(*c, b);\n    *c = s.size();\n  }\n}\n\nint main(int argc, char *argv[]) {\n  string buf;\n  vector<string> strs;\n  while (true) {\n    string s;\n    getline(cin, s);\n    if (s == \"END_OF_TEXT\")\n      break;\n    strs.push_back(s);\n  }\n  int line = 0, chrc = 0;\n  while (true) {\n    char c;\n    cin >> c;\n    if (c == '-')\n      break;\n    else if (c == 'a')\n      doA(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'e')\n      doE(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'p')\n      doP(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'n')\n      doN(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'f')\n      doF(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'b')\n      doB(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'd')\n      doD(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'k')\n      doK(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'y')\n      doY(&line, &chrc, strs[line], buf, strs);\n  }\n\n  for (int i = 0; i < strs.size(); i++)\n    cout << strs[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nstruct Cursor{ int x, y; Cursor() : x(0), y(0) {} };\n\nvoid convert(vector<string>& snt, Cursor& cur, string& buffer, char com);\nvoid convert(string& text, int& cursor, string& buffer, char command);\n\nint main()\n{\t\n\t/*\n\tvector<string> snt;\n\tstring buffer;\n\tCursor cursor;\n\t\n\t\n\tfor(string line; getline(cin, line) && line != \"END_OF_TEXT\"; snt.push_back(line));\n\t\n\t\n\tfor(char com; cin >> com && com != '-'; convert(snt, cursor, buffer, com));\n\n\t\n\trep(i, snt.size()) cout << snt[i] << endl;\n\t */\n\t\n\tstring text, buffer;\n\tint cursor = 0;\n\t\n\tfor(string line; getline(cin, line) && line != \"END_OF_TEXT\"; text += line + '\\n');\n\tfor(char command; cin >> command && command != '-'; convert(text, cursor, buffer, command));\n\t\n\tcout << text;\n}\n\nvoid convert(string& text, int& cursor, string& buffer, char command)\n{\t\n\tswitch(command)\n\t{\n\t\t\t/*\n\t\t\t a\n\t\t\t J[\\ð»ÝÌsÌæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'a':\n\t\t{\n\t\t\tif(cursor != 0 && text[cursor - 1] != '\\n')\n\t\t\twhile(--cursor) if(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tcursor++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t e\n\t\t\t J[\\ð»ÝÌsÌsÉÚ®·éB\n\t\t\t */\n\t\tcase 'e':\n\t\t{\n\t\t\twhile(text[cursor] != '\\n') cursor++;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t p\n\t\t\t ãÉsª êÎAJ[\\ðãÌsÌæª¶ÉÚ®·éB\n\t\t\t ãÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'p':\n\t\t{\n\t\t\tif(cursor != 0) while(--cursor) if(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(cursor != 0) while(--cursor) if(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tcursor++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t n\n\t\t\t ºÉsª êÎAJ[\\ðºÌsÌæª¶ÉÚ®·éB\n\t\t\t ºÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'n':\n\t\t{\n\t\t\tint cur = cursor;\n\t\t\twhile(text[cur] != '\\n') cur++;\n\t\t\t\n\t\t\tif(cur + 1 == text.size())\n\t\t\t{\n\t\t\t\twhile(--cursor) if(text[cursor] == '\\n')\n\t\t\t\t{\n\t\t\t\t\tcursor++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcursor = cur + 1;\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t f\n\t\t\t J[\\ªsÉÈ¢êAJ[\\ðPÂEÉÚ®·éB\n\t\t\t J[\\ªsÉ è©ÂºÉsª éêÍAJ[\\ðºÌsÌæª¶ÖÚ®·éB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'f':\n\t\t{\n\t\t\tcursor += cursor + 1 != text.size();\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t b\n\t\t\t J[\\ªæª¶ÅÈ¢ÈçÎAJ[\\ðPÂ¶ÉÚ®·éB\n\t\t\t J[\\ªæª¶Å è©ÂãÉsª éêÍAJ[\\ðãÌsÌsÖÚ®·éB\n\t\t\t »êÈOÌêÍ½àµÈ¢\n\t\t\t */\n\t\tcase 'b':\n\t\t{\n\t\t\tcursor -= 0 < cursor;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t d\n\t\t\t J[\\ª¶ðw·êÍ»Ì¶ðí·éBí³ê½¶ÌE¤Ì¶ñÍ¶ÉVtg³êéB\n\t\t\t J[\\ªsðwµºÉsª éêÍAºÌsð»ÌÜÜJ[\\ÌÊuÉq°éBÈºÌsÍãÉVtg³êéB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'd':\n\t\t{\n\t\t\tif(cursor + 1 != text.size()) text.erase(text.begin() + cursor);\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t k\n\t\t\t J[\\ªsÉ éêAºÉsª êÎAd Æ¯¶ìðµobt@ÉPÂÌüsðL^·éB\n\t\t\t J[\\ªsÉÈ¢êAJ[\\ªw·¶ðÜß½E¤·×ÄÌ¶ðØèæè»êðobt@ÉL^·éBJ[\\Í³ÌsÌsðw·æ¤ÉÈéBSÄÌL^É¨¢Äobt@Íã«³êéB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'k':\n\t\t{\n\t\t\tbuffer = \"\";\n\t\t\tif(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tif(cursor + 1 != text.size())\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tbuffer = \"\\n\";\n\t\t\t\ttext.erase(text.begin() + cursor);\n\t\t\t}\n\t\t\telse while(text[cursor] != '\\n')\n\t\t\t{\n\t\t\t\tbuffer += text[cursor];\n\t\t\t\ttext.erase(text.begin() + cursor);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t y\n\t\t\t obt@ªóÌêÍÈÉàµÈ¢B\n\t\t\t obt@ÌàeªüsÌêAJ[\\ªw·¶Ì¼OÅüsðs¤BJ[\\ÍVµ¢sÌæª¶ÖÚ®·éB\n\t\t\t obt@Ìàeª¶ñÌêAJ[\\ÌÊuÉobt@Ìàeð}ü·éB J[\\ÌÊuÍàÆàÆwµÄ¢½¶Ü½ÍsÌêÖÚ®·é\n\t\t\t */\n\t\tcase 'y':\n\t\t{\n\t\t\ttext = text.substr(0, cursor) + buffer + text.substr(cursor);\n\t\t\tcursor += buffer.size();\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid convert(vector<string>& snt, Cursor& cur, string& buffer, char com)\n{\n\tswitch(com)\n\t{\n\t\t\t/*\n\t\t\t a\n\t\t\t J[\\ð»ÝÌsÌæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'a':\n\t\t{\n\t\t\tcur.x = 0;\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t e\n\t\t\t J[\\ð»ÝÌsÌsÉÚ®·éB\n\t\t\t */\n\t\tcase 'e':\n\t\t{\n\t\t\tcur.x = snt[cur.y].size();\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t p\n\t\t\t ãÉsª êÎAJ[\\ðãÌsÌæª¶ÉÚ®·éB\n\t\t\t ãÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'p':\n\t\t{\n\t\t\tcur.y -= cur.y != 0;\n\t\t\tcur.x = 0;\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t n\n\t\t\t ºÉsª êÎAJ[\\ðºÌsÌæª¶ÉÚ®·éB\n\t\t\t ºÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'n':\n\t\t{\n\t\t\tcur.y += cur.y + 1 != snt.size();\n\t\t\tcur.x = 0;\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t f\n\t\t\t J[\\ªsÉÈ¢êAJ[\\ðPÂEÉÚ®·éB\n\t\t\t J[\\ªsÉ è©ÂºÉsª éêÍAJ[\\ðºÌsÌæª¶ÖÚ®·éB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'f':\n\t\t{\n\t\t\tif(cur.x != snt[cur.y].size())\n\t\t\t{\n\t\t\t\tcur.x++;\n\t\t\t}\n\t\t\telse if(cur.y + 1 != snt.size())\n\t\t\t{\n\t\t\t\tcur.y++;\n\t\t\t\tcur.x = 0;\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t b\n\t\t\t J[\\ªæª¶ÅÈ¢ÈçÎAJ[\\ðPÂ¶ÉÚ®·éB\n\t\t\t J[\\ªæª¶Å è©ÂãÉsª éêÍAJ[\\ðãÌsÌsÖÚ®·éB\n\t\t\t »êÈOÌêÍ½àµÈ¢\n\t\t\t */\n\t\tcase 'b':\n\t\t{\n\t\t\tif(cur.x != 0)\n\t\t\t{\n\t\t\t\tcur.x--;\n\t\t\t}\n\t\t\telse if(cur.y != 0)\n\t\t\t{\n\t\t\t\tcur.y--;\n\t\t\t\tcur.x = snt[cur.y].size();\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t d\n\t\t\t J[\\ª¶ðw·êÍ»Ì¶ðí·éBí³ê½¶ÌE¤Ì¶ñÍ¶ÉVtg³êéB\n\t\t\t J[\\ªsðwµºÉsª éêÍAºÌsð»ÌÜÜJ[\\ÌÊuÉq°éBÈºÌsÍãÉVtg³êéB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'd':\n\t\t{\n\t\t\tif(cur.x != snt[cur.y].size())\n\t\t\t{\n\t\t\t\tstring &line = snt[cur.y];\n\t\t\t\t\n\t\t\t\tline = line.substr(0, cur.x) + line.substr(cur.x + 1);\n\t\t\t}\n\t\t\telse if(cur.y + 1 != snt.size())\n\t\t\t{\n\t\t\t\tsnt[cur.y] += snt[cur.y + 1];\n\t\t\t\t\n\t\t\t\tsnt.erase(snt.begin() + cur.y + 1);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t k\n\t\t\t J[\\ªsÉ éêAºÉsª êÎAd Æ¯¶ìðµobt@ÉPÂÌüsðL^·éB\n\t\t\t J[\\ªsÉÈ¢êAJ[\\ªw·¶ðÜß½E¤·×ÄÌ¶ðØèæè»êðobt@ÉL^·éBJ[\\Í³ÌsÌsðw·æ¤ÉÈéBSÄÌL^É¨¢Äobt@Íã«³êéB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'k':\n\t\t{\n\t\t\tif(cur.x == snt[cur.y].size() && cur.y + 1 != snt.size())\n\t\t\t{\t\t\t\t\n\t\t\t\tsnt[cur.y] += snt[cur.y + 1];\n\t\t\t\t\n\t\t\t\tsnt.erase(snt.begin() + cur.y + 1);\t\t\t\t\n\t\t\t\t\n\t\t\t\tbuffer = \"\\n\";\n\t\t\t}\n\t\t\telse if(cur.x != snt[cur.y].size())\n\t\t\t{\n\t\t\t\tbuffer = snt[cur.y].substr(cur.x);\n\t\t\t\tsnt[cur.y] = snt[cur.y].substr(0, cur.x);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t y\n\t\t\t obt@ªóÌêÍÈÉàµÈ¢B\n\t\t\t obt@ÌàeªüsÌêAJ[\\ªw·¶Ì¼OÅüsðs¤BJ[\\ÍVµ¢sÌæª¶ÖÚ®·éB\n\t\t\t obt@Ìàeª¶ñÌêAJ[\\ÌÊuÉobt@Ìàeð}ü·éB J[\\ÌÊuÍàÆàÆwµÄ¢½¶Ü½ÍsÌêÖÚ®·é\n\t\t\t */\n\t\tcase 'y':\n\t\t{\n\t\t\tif(buffer != \"\")\n\t\t\t{\n\t\t\t\tif(buffer == \"\\n\")\n\t\t\t\t{\n\t\t\t\t\tstring &line = snt[cur.y];\n\t\t\t\t\t\n\t\t\t\t\tsnt.insert(snt.begin() + cur.y + 1, snt[cur.y].substr(cur.x));\n\t\t\t\t\tline = line.substr(0, cur.x);\n\t\t\t\t\t\n\t\t\t\t\tcur.y++;\n\t\t\t\t\tcur.x = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstring &line = snt[cur.y];\n\t\t\t\t\tline = line.substr(0, cur.x) + buffer + line.substr(cur.x);\n\t\t\t\t\t\n\t\t\t\t\tcur.x += buffer.size();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tstring str[10000];\n\tstring b;\n\tint i = 0;\n\t\n\twhile (getline(std::cin, str[i]), str[i] != \"END_OF_TEXT\") i++;\n\ti = 0;\n\t\n\tchar cmd[2];\n\tint car_y = 0;\n\tint car = 0;\n\tint y = 0, y2 = 0;\n\t\n\twhile (str[y] != \"END_OF_TEXT\") y++;\n\ty--;\n\ty2 = y;\n\t\n\tb = \"???\";\n\t\n\twhile (scanf(\"%s\", cmd), cmd[0] != '-'){\n\t\tif (cmd[0] == 'a'){\n\t\t\tcar = 0;\n\t\t//\tprintf(\" a\");\n\t\t}\n\t\tif (cmd[0] == 'e'){\n\t\t\tcar = str[car_y].size();\n\t\t\t\n\t\t//\tprintf(\" e\");\n\t\t}\n\t\tif (cmd[0] == 'p'){\n\t\t\t\n\t\t//\tprintf(\" p\");\n\t\t\tif (car_y == 0){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y--;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'n'){\n\t\t//\tprintf(\" n\");\n\t\t\tif (car_y == y2){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y++;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'f'){\n\t\t//\tprintf(\" f\");\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\tcar_y++;\n\t\t\t\t\tcar = 0;\n\t\t\t\t\t//printf(\" %d\",car_y);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar++;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'b'){\n\t\t//\tprintf(\" b\");\n\t\t\tif (car == 0){\n\t\t\t\tif (car_y != 0){\n\t\t\t\t\tcar_y--;\n\t\t\t\t\tcar = str[car_y].size();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar--;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'd'){\n\t\t//\tprintf(\" d\");\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tstr[car_y].erase(car, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\t//str[car_y] + str[car_y + 1];\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = --y;\n\t\t\t\t\ty = car_y + 1;\n\t\t\t\t\twhile (y <= y2){\n\t\t\t\t\t\tif (y == y2){\n\t\t\t\t\t\t\tstr[y + 2].erase();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstr[y] = str[y + 1];\n\t\t\t\t\t\ty++;\n\t\t\t\t\t}\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'k'){\n\t\t//\tprintf(\" k\");\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\t//str[car_y] + str[car_y + 1];\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = --y;\n\t\t\t\t\ty = car_y + 1;\n\t\t\t\t\twhile (y <= y2){\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (y == y2){\n\t\t\t\t\t\t\tstr[y + 2].erase();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tstr[y] = str[y + 1];\n\t\t\t\t\t\ty++;\n\t\t\t\t\t}\n\t\t\t\t\ty = y2;\n\t\t\t\t\tb[0] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb.erase();\n\t\t\t\tb = str[car_y].substr(car);\n\t\t\t\tstr[car_y].erase(car);\n\t\t\t\tcar = str[car_y].size();\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'y'){\n\t\t//\tprintf(\" %d\\n\", y);\n\t\t\tif (b == \"???\");\n\t\t\telse if (b[0] == '\\0'){\n\t\t\t\t//\tprintf(\" y2\");\n\t\t\t\ty2 = ++y;\n\t\t\t\twhile (y - 1 > car_y){\n\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstr[y] = str[y - 1].substr(car);\n\t\t\t\tstr[y - 1].erase(car);\n\t\t\t\ty = y2;\n\t\t\t}\n\t\t\telse if (!b.empty()){\n\t\t\t\tstr[car_y].insert(car, b);\n\t\t\t\tcar += b.size();\n\t\t\t}\n\t\t}\n\t}\n\t\n\ti = 0;\n\twhile (i <= y2){\n\t\t//puts(str[i].c_str());\n\t\tcout << str[i] << endl;\n\t\ti++;\n\t}\n\t/*\n\ti = 0;\n\twhile (i <= y2){\n\t\tif (car_y == i){\n\t\t\tfor (int j = 0; j <= str[i].size(); j++){\n\t\t\t\tif (j == car){\n\t\t\t\t\tcout << 'I';\n\t\t\t\t}\n\t\t\t\tcout << str[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\telse{\n\t\t\tputs(str[i].c_str());\n\t\t}\n\t\ti++;\n\t}\n\t*/\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 1021.cc: Emacs-like Editor\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\n/* typedef */\n\ntypedef vector<string> vs;\n\n/* global variables */\n\nvs txt;\nstring buf;\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    string s;\n    cin >> s;\n    if (s == \"END_OF_TEXT\") break;\n    txt.push_back(s);\n  }\n  if (txt.size() == 0) txt.push_back(\"\");\n\n  int cx = 0, cy = 0;\n  \n  for (;;) {\n    char op;\n    cin >> op;\n    if (op == '-') break;\n\n    switch (op) {\n    case 'a':\n      cx = 0;\n      break;\n    case 'e':\n      cx = txt[cy].size();\n      break;\n    case 'p':\n      cx = 0;\n      if (cy > 0) cy--;\n      break;\n    case 'n':\n      cx = 0;\n      if (cy < txt.size() - 1) cy++;\n      break;\n    case 'f':\n      if (cx < txt[cy].size()) cx++;\n      else if (cy < txt.size() - 1) cy++, cx = 0;\n      break;\n    case 'b':\n      if (cx > 0) cx--;\n      else if (cy > 0) cy--, cx = txt[cy].size();\n      break;\n    case 'd':\n      if (cx < txt[cy].size()) txt[cy].erase(cx, 1);\n      else if (cy < txt.size() - 1) {\n\ttxt[cy] += txt[cy + 1];\n\ttxt.erase(txt.begin() + cy + 1);\n      }\n      break;\n    case 'k':\n      if (cx == txt[cy].size()) {\n\tif (cy < txt.size() - 1) {\n\t  txt[cy] += txt[cy + 1];\n\t  txt.erase(txt.begin() + cy + 1);\n\t  buf = \"\\n\";\n\t}\n      }\n      else {\n\tbuf = txt[cy].substr(cx);\n\ttxt[cy].erase(cx);\n\tcx = txt[cy].size();\n      }\n      break;\n    case 'y':\n      int bn = buf.size();\n      if (bn > 0) {\n\tif (buf == \"\\n\") {\n\t  string line = txt[cy].substr(cx);\n\t  txt[cy].erase(cx);\n\t  txt.insert(txt.begin() + cy + 1, line);\n\t  cy++, cx = 0;\n\t}\n\telse {\n\t  txt[cy].insert(cx, buf);\n\t  cx += bn;\n\t}\n      }\n      break;\n    }\n  }\n\n  for (int i = 0; i < txt.size(); i++) cout << txt[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY = 0;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n\telse return;\n}\n\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\\n\";\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring front=\"\";\n\t\tstring rear=\"\";\n\t\tfront = lines[posY].substr(0,posX);\n\t\trear = lines[posY].substr(posX,lines[posY].size()-posX);\t\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX);\n\n\t\tlines[posY] = front;\n\t\tdeque<string>::iterator it = lines.begin();\n\t\tadvance(it,posY);\n\t\t//lines.insert(it,rear);\n\t}\n\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(getline(cin,str)){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(cin >> str){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\tif(str == \"d\") ctrl_d(lines);\n\t\tif(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst ll INF = 1LL << 50;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nsize_t tpos;\nsize_t lpos;\n\nvoid do_a(const vector<string> &text){\n\tlpos = 0;\n}\n\nvoid do_e(const vector<string> &text){\n\tlpos = text[tpos].size();\n}\n\nvoid do_p(const vector<string> &text){\n\tlpos = 0;\n\ttpos = max(0, (int)tpos - 1);\n}\n\nvoid do_n(const vector<string> &text){\n\tlpos = 0;\n\ttpos = min((int)tpos + 1, (int)text.size() - 1);\n}\n\nvoid do_f(const vector<string> &text){\n\tif(lpos == text[tpos].size()){\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\tlpos = 0;\n\t\t\ttpos++;\n\t\t}\n\t}else{\n\t\tlpos++;\n\t}\n}\n\nvoid do_b(const vector<string> &text){\n\tif(lpos != 0){\n\t\tlpos--;\n\t}else{\n\t\tif(tpos > 0){\n\t\t\ttpos--;\n\t\t\tlpos = text[tpos].size();\n\t\t}\n\t}\n}\n\nvoid do_d(vector<string> &text){\n\tif(lpos != text[tpos].size()){\n\t\ttext[tpos].erase(lpos, 1);\n\t}else{\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\ttext[tpos]+=text[tpos+1];\n\t\t\ttext.erase(text.begin() + tpos+1);\n\t\t}\n\t}\n}\n\nvoid do_k(vector<string> &text, string &buffer){\n\tif(lpos == text[tpos].size()){\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\tbuffer = \"\\n\";\n\t\t\tdo_d(text);\n\t\t}\n\t}else{\n\t\tbuffer = string(text[tpos].begin() + lpos, text[tpos].end());\n\t\ttext[tpos].erase(text[tpos].begin() + lpos, text[tpos].end());\n\t}\n}\n\nvoid do_y(vector<string> &text, string &buffer){\n\tif(buffer != \"\"){\n\t\tif(buffer == \"\\n\"){\n\t\t\tstring a(text[tpos].begin() + lpos, text[tpos].end());\n\t\t\ttext[tpos].erase(lpos);\n\t\t\ttext.insert(text.begin() + tpos + 1, a);\n\t\t\ttpos++;\n\t\t\tlpos = 0;\n\t\t}else{\n\t\t\tif(lpos == text[tpos].size()){\n\t\t\t\ttext[tpos] += buffer;\n\t\t\t\tlpos = text[tpos].size();\n\t\t\t}else{\n\t\t\t\ttext[tpos].insert(text[tpos].begin() + lpos, buffer.begin(), buffer.end());\n\t\t\t\tlpos += buffer.size();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid output(const vector<string> &text){\n\trep(i, (int)text.size()) cout << text[i] << endl;\n}\n\nint main(){\n\tstring line;\n\tvector<string> text;\n\tstring buffer;\n\twhile(cin >> line && line != \"END_OF_TEXT\"){\n\t\ttext.push_back(line);\n\t}\n\ttpos = lpos = 0;\n\tchar command;\n\twhile(cin >> command && command != '-'){\n\t\tswitch(command){\n\t\tcase 'a':\n\t\t\tdo_a(text);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tdo_e(text);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tdo_p(text);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tdo_n(text);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tdo_f(text);\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tdo_b(text);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdo_d(text);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tdo_k(text, buffer);\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tdo_y(text, buffer);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t//\toutput(text);\n\t//\tcout << tpos << \" \" << lpos << endl;\n\t}\n\toutput(text);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nstring s[102],buf;\nint l,r,N;\n\nvoid a(void){r=0;}\nvoid e(void){r=max(0,(int)s[l].size()-1);}\n\nvoid p(void){\n\tif(l>0)l--;\n\telse r=0;\n}\n\nvoid n(void){\n\tif(l<N-1)l++,r=0;\n\telse r=0;\n}\n\nvoid f(void){\n\tif(r<max(0,(int)s[l].size()-1))r++;\n\telse l++,r=0;\n}\n\nvoid b(void){\n\tif(r>0)r--;\n\telse if(l>0)r=s[--l].size();\n}\n\nvoid d(void){\n\tif(r==s[l].size()-1){\n\t\tif(l<N-1){\n\t\t\ts[l]+=s[l+1];\n\t\t\tfor(int i=l+1;i<N-1;i++)s[i]=s[i+1];\n\t\t}\n\t}\n\telse s[l].erase(r,1);\n}\n\nvoid k(void){\n\tif(r==s[l].size() && l<N-1)d(),buf=\"\\n\";\n\telse {\n\t\tbuf=s[l].substr(max(0,r-1));\n\t\ts[l].erase(max(0,r-1));\n\t}\n}\n\nvoid y(void){\n\tif(buf.empty())return ;\n\tif(buf==\"\\n\"){\n\t\tfor(int i=N;i>l;i--)s[i]=s[i-1];\n\t\ts[l+1]=s[l].substr(max(0,r-1));\n\t\ts[l].erase(max(0,r-1));\n\t\tl++,r=0,N++;\n\t}\n\telse {\n\t\ts[l].insert(min((int)s[l].size(),r+1),buf);\n\t\tr+=buf.size();\n\t}\n}\n\n\nint main(void){\n\t\n\twhile(getline(cin,s[N])){\n\t\tif(s[N]==\"END_OF_TEXT\")break;\n\t\tN++;\n\t}\n\tl=r=0;\n\tbuf.clear();\n\t\n\t\t\n\tstring C;\n\twhile(cin >> C,C!=\"-\"){\n\t\t\n\t\tif(C==\"a\")a();\n\t\telse if(C==\"e\")e();\n\t\telse if(C==\"p\")p();\n\t\telse if(C==\"n\")n();\n\t\telse if(C==\"f\")f();\n\t\telse if(C==\"b\")b();\n\t\telse if(C==\"d\")d();\n\t\telse if(C==\"k\")k();\n\t\telse if(C==\"y\")y();\n\t}\n\t\n\tfor(int i=0;i<N;i++){\n\t\tcout << s[i] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring S;\nint p = 0;\n\nvoid a() {\n  for(; p >= 1 && S[p-1] != '\\n'; --p);\n}\n\nvoid e() {\n  for(; p < S.size() && S[p] != '\\n'; ++p);\n}\n\nint main() {\n  string line;\n  S = \"\\n\";\n  while(getline(cin,line) && line != \"END_OF_TEXT\") {\n    S += line;\n    S += '\\n';\n  }\n  if(S.size() == 1) S += '\\n';\n\n  char c;\n  string buffer = \"\";\n  p = 1;\n  while(cin >> c && c != '-') {\n    switch(c) {\n    case 'a':\n      a();\n      break;\n    case 'e':\n      e();\n      break;\n    case 'p':\n      a();\n      if(p != 1) {\n\t--p;\n\ta();\n      }\n      break;\n    case 'n':\n      e();\n      if(p+1 != S.size()) ++p;\n      a();\n      break;\n    case 'f':\n      p = min(p+1,(int)S.size()-1);\n      break;\n    case 'b':\n      p = max(p-1, 1);\n      break;\n    case 'd':\n      if(p+1 != S.size()) S.erase(p,1);\n      break;\n    case 'k':\n      if(S[p] == '\\n') {\n\tif(p+1 != S.size()) {\n\t  S.erase(p,1);\n\t  buffer = \"\\n\";\n\t}\n      } else {\n\tfor(int i = 1; ; ++i) {\n\t  if(S[p+i] == '\\n'){\n\t    buffer = S.substr(p,i);\n\t    S.erase(p,i);\n\t    break;\n\t  }\n\t}\n      }\n      break;\n    case 'y':\n      S.insert(p,buffer);\n      if(buffer == \"\\n\") ++p;\n      break;\n    }\n  }\n  cout << S.substr(1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring S;\nint p = 0;\n\nvoid a() {\n  for(; p >= 1 && S[p-1] != '\\n'; --p);\n}\n\nvoid e() {\n  for(; p < S.size() && S[p] != '\\n'; ++p);\n}\n\nint main() {\n  string line;\n  S = \"\\n\";\n  while(getline(cin,line) && line != \"END_OF_TEXT\") {\n    S += line;\n    S += '\\n';\n  }\n  char c;\n  p = 1;\n  string buffer = \"\";\n  while(cin >> c && c != '-') {\n    switch(c) {\n    case 'a':\n      a();\n      break;\n    case 'e':\n      e();\n      break;\n    case 'p':\n      a();\n      if(p != 1) {\n\t--p;\n\ta();\n      }\n      break;\n    case 'n':\n      e();\n      if(p+1 != S.size()) {\n\t++p;\n      }\n      a();\n      break;\n    case 'f':\n      p = min(p+1,(int)S.size()-1);\n      break;\n    case 'b':\n      p = max(p-1, 1);\n      break;\n    case 'd':\n      if(p+1 != S.size()) S.erase(p,1);\n      break;\n    case 'k':\n      if(S[p] == '\\n') {\n\tS.erase(p,1);\n\tbuffer = \"\\n\";\n      } else {\n\tfor(int i = 1; ; ++i) {\n\t  if(S[p+i] == '\\n'){\n\t    buffer = S.substr(p,i);\n\t    S.erase(p,i);\n\t    break;\n\t  }\n\t}\n      }\n      break;\n    case 'y':\n      S.insert(p,buffer);\n      if(buffer == \"\\n\") ++p;\n      break;\n    }\n  }\n  cout << S.substr(1) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nint main(){\n  vector<string> buff;\n  string str,kill;\n  int y = 0, x = 0;\n  while(getline(cin,str), str!=\"END_OF_TEXT\") buff.push_back(str);\n  while(getline(cin,str), str[0] != '-'){\n    //printf(\"command: %c (x=%d, y=%d)\\n\",str[0],x,y);\n    //REP(i,buff.size()) cout << buff[i] << endl;\n    switch(str[0]){\n    case 'a':\n      x = 0;\n      break;\n    case 'e':\n      x = buff[y].size();\n      break;\n    case 'p':\n      if(y==0) x = 0;\n      else{\n\tx = 0;\n\ty--;\n      }\n      break;\n    case 'n':\n      if(y==buff.size()-1) x=0;\n      else{\n\tx = 0;\n\ty++;\n      }\n      break;\n    case 'f':\n      if(x < buff[y].size()) x++;\n      else if(y != buff.size()-1){\n\tx = 0;\n\ty++;\n      }\n      break;\n    case 'b':\n      if(x > 0) x--;\n      else if(y != 0){\n\ty--;\n\tx = buff[y].size();\n      }\n      break;\n    case 'd':\n      if(x != buff[y].size()){\n\tbuff[y].erase(buff[y].begin()+x);\n      }else if(y != buff.size()-1){\n\tbuff[y] += buff[y+1];\n\tbuff.erase(buff.begin() + y + 1);\n      }\n      break;\n    case 'k':\n      if(x != buff[y].size()){\n\tkill = buff[y].substr(x);\n\tbuff[y] = buff[y].substr(0,x);\n      }else if(y != buff.size()-1){\n\tbuff[y] += buff[y+1];\n\tbuff.erase(buff.begin() + y + 1);\n\tkill = \"\\n\";\n      }\n      break;\n    case 'y':\n      if(kill != \"\"){\n\tif(kill == \"\\n\"){\n\t  string s = buff[y].substr(x);\n\t  buff[y] = buff[y].substr(0,x);\n\t  buff.insert(buff.begin() + y + 1, s);\n\t  y++; x=0;\n\t}else{\n\t  buff[y].insert(x, kill);\n\t  x += kill.size();\n\t}\n      }\n      break;\n    }\n  }\n  REP(i,buff.size()) cout << buff[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[110];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tif(i<110) t[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tif(row<110) col = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 && row < 110 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row < 110 && row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( row < 110 && col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else if( row < 110 ){\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( row < 110 && buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line+1 < 110 && line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\tt[row+1] = t[row].substr( col );\n\t\t\t\t\tt[row].erase( col );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else if( row < 110 ){\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<string> buf;\nint row;\nint column;\nstring rem;\n\nvoid printbuf(){\n  //cout << row << ' ' << column << \" \\\"\" << rem << \"\\\"\" << endl;\n  for(int i=0;i<buf.size();i++){\n    cout << buf[i];\n  }\n}\n\nmain(){\n  string in;\n  while(getline(cin, in)){\n    if(in == \"END_OF_TEXT\"/* || in == \"1\"*/) break;\n    in += '\\n';\n    buf.push_back(in);\n  }\n  char c;\n  row = 0;\n  column = 0;\n  while(cin >> c){\n    if(c == '-') break;\n    switch(c){\n      case 'a':\n        column = 0;\n        break;\n      case 'e':\n        column = (int)buf[row].size()-1;\n        break;\n      case 'p':\n        column = 0;\n        if(row > 0) --row;\n        break;\n      case 'n':\n        column = 0;\n        if(row+1 < buf.size()) ++row;\n        break;\n      case 'f':\n        if(column+1 >= buf[row].size()){\n          if(row+1 < buf.size()){\n            column = 0;\n            ++row;\n          }\n        }else{\n          ++column;\n        }\n        break;\n      case 'b':\n        if(column == 0){\n          if(row > 0){\n            column = 0;\n            --row;\n          }\n        }else{\n          --column;\n        }\n        break;\n      case 'd':\n        if(column+1 == buf[row].size()){\n          if(row+1 != buf.size()){\n            vector<string>::iterator ite = buf.begin();\n            for(int i=0;i<row;i++) ++ite;\n            buf.erase(ite);\n          }\n        }else{\n          buf[row].erase(column, 1);\n        }\n        break;\n      case 'k':\n        rem = \"\";\n        if(column+1 == buf[row].size()){\n          if(row+1 != buf.size()){\n            vector<string>::iterator ite = buf.begin();\n            for(int i=0;i<row;i++) ++ite;\n            buf.erase(ite);\n            rem += '\\n';\n          }\n        }else{\n          for(int i=column;i+1<buf[row].size();++i){\n            rem += buf[row][i];\n          }\n          string::iterator ite = buf[row].begin();\n          for(int i=0;i<column;i++) ++ite;\n          buf[row].erase(ite, buf[row].end());\n          buf[row] += '\\n';\n        }\n        break;\n      case 'y':\n        if(rem.size() != 0){\n          int irem;\n          string back = buf[row].substr(column);\n          buf[row] = buf[row].substr(0, column);\n          for(irem = 0;irem<rem.size();irem++){\n            buf[row] += rem[irem];\n            if(rem[irem] == '\\n'){\n              vector<string>::iterator ite = buf.begin();\n              for(int i=0;i<row+1;i++) ++ite;\n              buf.insert(ite, \"\");\n              column = 0;\n              ++row;\n            }\n          }\n          buf[row] += back;\n        }\n        break;\n    }\n    //printbuf();\n  }\n  printbuf();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tstring str[10000];\n\tstring b;\n\tint i = 0;\n\t\n\twhile (getline(std::cin, str[i]), str[i] != \"END_OF_TEXT\") i++;\n\ti = 0;\n\t\n\tchar cmd[2];\n\tint car_y = 0;\n\tint car = 0;\n\tint y = 0, y2 = 0;\n\t\n\twhile (str[y] != \"END_OF_TEXT\") y++;\n\ty--;\n\ty2 = y;\n\t\n\tb.erase();\n\t\n\twhile (scanf(\"%s\", cmd), cmd[0] != '-'){\n\t\tif (cmd[0] == 'a'){\n\t\t\tcar = 0;\n\t\t//\tprintf(\" a\");\n\t\t}\n\t\tif (cmd[0] == 'e'){\n\t\t\tcar = str[car_y].size();\n\t\t\t\n\t\t//\tprintf(\" e\");\n\t\t}\n\t\tif (cmd[0] == 'p'){\n\t\t\t\n\t\t//\tprintf(\" p\");\n\t\t\tif (car_y == 0){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y--;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'n'){\n\t\t//\tprintf(\" n\");\n\t\t\tif (car_y == y2){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y++;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'f'){\n\t\t//\tprintf(\" f\");\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\tcar_y++;\n\t\t\t\t\tcar = 0;\n\t\t\t\t\t//printf(\" %d\",car_y);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar++;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'b'){\n\t\t//\tprintf(\" b\");\n\t\t\tif (car == 0){\n\t\t\t\tif (car_y != 0){\n\t\t\t\t\tcar_y--;\n\t\t\t\t\tcar = str[car_y].size();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar--;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'd'){\n\t\t//\tprintf(\" d\");\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tstr[car_y].erase(car, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\t//str[car_y] + str[car_y + 1];\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = --y;\n\t\t\t\t\ty = car_y + 1;\n\t\t\t\t\twhile (y <= y2){\n\t\t\t\t\t\tif (y == y2){\n\t\t\t\t\t\t\tstr[y + 2].erase();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstr[y] = str[y + 1];\n\t\t\t\t\t\ty++;\n\t\t\t\t\t}\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'k'){\n\t\t//\tprintf(\" k\");\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\t//str[car_y] + str[car_y + 1];\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = --y;\n\t\t\t\t\ty = car_y + 1;\n\t\t\t\t\twhile (y <= y2){\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (y == y2){\n\t\t\t\t\t\t\tstr[y + 2].erase();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tstr[y] = str[y + 1];\n\t\t\t\t\t\ty++;\n\t\t\t\t\t}\n\t\t\t\t\ty = y2;\n\t\t\t\t\tb[0] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb.erase();\n\t\t\t\tb = str[car_y].substr(car);\n\t\t\t\tstr[car_y].erase(car);\n\t\t\t\tcar = str[car_y].size();\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'y'){\n\t\t//\tprintf(\" %d\\n\", y);\n\t\t\n\t\t\tif (b[0] == '\\0'){\n\t\t\t\t//\tprintf(\" y2\");\n\t\t\t\ty2 = ++y;\n\t\t\t\twhile (y - 1 > car_y){\n\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstr[y] = str[y - 1].substr(car);\n\t\t\t\tstr[y - 1].erase(car);\n\t\t\t\ty = y2;\n\t\t\t}\n\t\t\telse if (!b.empty()){\n\t\t\t\tstr[car_y].insert(car, b);\n\t\t\t\tcar += b.size();\n\t\t\t}\n\t\t}\n\t}\n\t\n\ti = 0;\n\twhile (i <= y2){\n\t\t//puts(str[i].c_str());\n\t\tcout << str[i] << endl;\n\t\ti++;\n\t}\n\t\n\ti = 0;\n\twhile (i <= y2){\n\t\tif (car_y == i){\n\t\t\tfor (int j = 0; j <= str[i].size(); j++){\n\t\t\t\tif (j == car){\n\t\t\t\t\tcout << 'I';\n\t\t\t\t}\n\t\t\t\tcout << str[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\telse{\n\t\t\tputs(str[i].c_str());\n\t\t}\n\t\ti++;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n)-1;i>=(m);--i)\n#define repc(i,n) for(int i=0;i<=(n);++i)\n#define repcn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repcd(i,n) for(int i=(n);i>=0;--i)\n#define repcnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define repc0(i,n) for(i=0;i<=(n);++i)\n#define repcn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repcd0(i,n) for(i=(n);i>=0;--i)\n#define repcnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE cout<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nstring str[111];\n\nint main() {\n\tint h = 0;\n\tIL {\n\t\tgetline(cin, str[h]);\n\t\tif (str[h][sz(str[h]) - 1] < ' ') str[h] = str[h].substr(0, sz(str[h]) - 1);\n\t\tif (str[h] == \"END_OF_TEXT\") break;\n\t\t++h;\n\t}\n\tint x = 0, y = 0;\n\tstring com, buf = \"\";\n\tIL {\n\t\tcin >> com;\n\t\tif (com == \"a\") {\n\t\t\tx = 0;\n\t\t} else if (com == \"e\") {\n\t\t\tx = sz(str[y]);\n\t\t} else if (com == \"p\") {\n\t\t\tx = 0;\n\t\t\tif (y > 0) --y;\n\t\t} else if (com == \"n\") {\n\t\t\tx = 0;\n\t\t\tif (y < h - 1) ++y; \n\t\t} else if (com == \"f\") {\n\t\t\tif (x < sz(str[y])) ++x;\n\t\t\telse if (y < h - 1) {x = 0; ++y;}\n\t\t} else if (com == \"b\") {\n\t\t\tif (x > 0) --x;\n\t\t\telse if (y > 0) {--y; x = sz(str[y]);}\n\t\t} else if (com == \"d\") {\n\t\t\tif (x < sz(str[y])) str[y] = str[y].substr(0, x) + str[y].substr(x + 1);\n\t\t\telse if (y < h - 1) {\n\t\t\t\tstr[y] += str[y + 1];\n\t\t\t\t--h;\n\t\t\t\trepn (i, y + 1, h) str[i] = str[i + 1];\n\t\t\t}\n\t\t} else if (com == \"k\") {\n\t\t\tif (x == sz(str[y])) {\n\t\t\t\tif (y < h - 1) {\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t\tstr[y] += str[y + 1];\n\t\t\t\t\t--h;\n\t\t\t\t\trepn (i, y + 1, h) str[i] = str[i + 1];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbuf = str[y].substr(x);\n\t\t\t\tstr[y] = str[y].substr(0, x);\n\t\t\t\tx = sz(str[y]);\n\t\t\t}\n\t\t} else if (com == \"y\") {\n\t\t\tif (buf == \"\\n\") {\n\t\t\t\t++h;\n\t\t\t\trepnd (i, y + 2, h) str[i] = str[i - 1];\n\t\t\t\tstr[y + 1] = str[y].substr(x);\n\t\t\t\tstr[y] = str[y].substr(0, x);\n\t\t\t\tx = 0;\n\t\t\t\t++y;\n\t\t\t} else if (sz(buf)  > 0) {\n\t\t\t\tstr[y] = str[y].substr(0, x) + buf + str[y].substr(x);\n\t\t\t\tx += sz(buf);\n\t\t\t}\n\t\t} else if (com == \"-\") {\n\t\t\tbreak;\n\t\t}\n\t}\n\trep (i, h) cout << str[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\n\nint main() {\n\tvector<string>emacs;\n\twhile (1) {\n\t\tstring st; cin >> st;\n\t\t\n\t\tif (st == \"END_OF_TEXT\") {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\temacs.push_back(st);\n\t\t}\n\t}\n\tint x = 0, y = 0;\n\tvector<string>buf;\n\twhile (1) {\n\t\tchar c; cin >> c;\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\t\tx = 0;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tx = emacs[y].size();\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (y) {\n\t\t\t\ty--;\n\t\t\t}\n\t\t\tx = 0;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tif (y != emacs.size() - 1) {\n\t\t\t\ty++;\n\t\t\t}\n\t\t\tx = 0;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tif (x != emacs[y].size())x++;\n\t\t\telse {\n\t\t\t\tif (y != emacs.size() - 1) {\n\t\t\t\t\ty++;\n\t\t\t\t\tx = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif (x)x--;\n\t\t\telse {\n\t\t\t\tif (y) {\n\t\t\t\t\ty--;\n\t\t\t\t\tx = emacs[y].size();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (x != emacs[y].size()) {\n\t\t\t\temacs[y].erase(emacs[y].begin() + x);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (y != emacs.size() - 1) {\n\t\t\t\t\temacs[y].insert(emacs[y].end(), emacs[y + 1].begin(), emacs[y + 1].end());\n\t\t\t\t\temacs.erase(emacs.begin() + y + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tif (x == emacs[y].size()) {\n\t\t\t\tif (y != emacs.size() - 1) {\n\t\t\t\t\temacs[y].insert(emacs[y].end(), emacs[y + 1].begin(), emacs[y + 1].end());\n\t\t\t\t\temacs.erase(emacs.begin() + y + 1);\n\t\t\t\t\tbuf = vector<string>(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuf = vector<string>(1, emacs[y].substr(x));\n\t\t\t\temacs[y].erase(emacs[y].begin() + x, emacs[y].end());\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tif (buf.empty()) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (buf[0] == \"\") {\n\t\t\t\t\tstring rest = emacs[y].substr(x);\n\t\t\t\t\temacs[y].erase(emacs[y].begin() + x, emacs[y].end());\n\t\t\t\t\temacs.insert(emacs.begin() + y+1, rest);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\temacs[y].insert(emacs[y].begin() + x, buf[0].begin(), buf[0].end());\n\t\t\t\t\tx += buf[0].size();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (c=='-')break;/*\n\t\tfor (auto s : emacs) {\n\t\t\tcout << s << endl;\n\t\t}\n\t\tcout << \"x: \" << x << endl << \"y: \" << y << endl;*/\n\t}\n\tfor (auto s : emacs) {\n\t\tcout << s << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  string txt[110],str,buf;\n  char c;\n  int x,y;\n\n  y = 0;\n  while(1){\n    getline(cin,str);\n    if(str == \"END_OF_TEXT\")break;\n    txt[y] = str + '\\n';\n    y++;\n  }\n\n  x = y = 0;\n  while(1){\n    c = getchar();\n    if(c == '-')break;\n    if(c == 'a'){\n      x = 0;\n    }\n    if(c == 'e'){\n      x = (int)txt[y].size() - 1;\n    }\n    if(c == 'p'){\n      if(y){\n\ty--;\n\tx = 0;\n      }else x = 0;\n    }\n    if(c == 'n'){\n      if(txt[y+1].size()){\n\ty++;\n\tx = 0;\n      }else x = 0;\n    }\n    if(c == 'f'){\n      if(x != (int)txt[y].size() - 1)x++;\n      else if(txt[y+1].size()){\n\ty++;\n\tx = 0;\n      }\n    }\n    if(c == 'b'){\n      if(x)x--;\n      else if(y){\n\ty--;\n\tx = (int)txt[y].size() - 1;\n      }\n    }\n    if(c == 'd'){\n      if(txt[y][x] != '\\n'){\n\ttxt[y].erase(txt[y].begin()+x);\n      }else if(txt[y+1].size()){\n\ttxt[y].erase(txt[y].begin()+x);\n\ttxt[y] += txt[y+1];\n\tint tmp = y+1;\n\twhile(txt[tmp+1].size()){\n\t  txt[tmp] = txt[tmp+1];\n\t  tmp++;\n\t}\n\ttxt[tmp].clear();\n      }\n    }\n    if(c == 'k'){\n      if(x == (int)txt[y].size() - 1){\n\tif(txt[y+1].size()){\n\t  txt[y].erase(txt[y].begin()+x);\n\t  txt[y] += txt[y+1];\n\t  int tmp = y+1;\n\t  while(txt[tmp+1].size()){\n\t    txt[tmp] = txt[tmp+1];\n\t    tmp++;\n\t  }\n\t  txt[tmp].clear();\n\t  buf = '\\n';\n\t}\n      }else{\n\tbuf.clear();\n\twhile(txt[y][x] != '\\n'){\n\t  buf.push_back(txt[y][x]);\n\t  txt[y].erase(txt[y].begin()+x);\n\t}\n      }\n    }\n    if(c == 'y'){\n      if(buf.size()){\n\tif(buf == \"\\n\"){\n\t  int tmp = y+1;\n\t  str = txt[y+1];\n\t  txt[y+1].clear();\n\t  while(txt[y][x] != '\\n'){\n\t    txt[y+1].push_back(txt[y][x]);\n\t    txt[y].erase(txt[y].begin()+x);\n\t  }\n\t  txt[y+1].push_back('\\n');\n\t  while(txt[++tmp].size())swap(txt[tmp],str);\n\t  txt[tmp] = str;\n\t  y++;\n\t  x = 0;\n\t}else{\n\t  str.clear();\n\t  for(int i=0;i<x;i++)str.push_back(txt[y][i]);\n\t  str += buf;\n\t  for(int i=x;i<(int)txt[y].size();i++)str.push_back(txt[y][i]);\n\t  txt[y] = str;\n\t  x += buf.size();\n\t}\n      }\n    }\n    //cout << c << \":\" << y << \" \" << x << endl;\n    getchar();\n  }\n  y = 0;\n  while(txt[y].size())cout << txt[y++];\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nint main(){\n  string s;\n  vector<string> v;\n  char command;\n\n  while( true ){\n    getline( cin,s );\n    if( s==\"END_OF_TEXT\" ) break;\n    v.push_back( s );\n  }\n\n  unsigned int line=0, c=0;\n  string buf=\"\";\n  while( cin>>command && c!='-' ){\n    switch( command ){\n    case 'a': c=0;\n      break;\n    case 'e': c=v[line].length();\n      break;\n    case 'p':\n      if( line>0 ) line--;\n      c=0;\n      break;\n    case 'n':\n      if( line<v.size()-1 ) line++;\n      c=v[line].length();\n      break;\n    case 'f':\n      if( c<v[line].length() ) ++c;\n      else if( line<v.size()-1 ){\n\tline++;c=0;\n      }\n      break;\n    case 'b':\n      if( c>0 ) --c;\n      else if( line>0 ){\n\tline--; c=v[line].length();\n      }\n      break;\n    case 'd':\n      if( c<v[line].length() ) v[line].erase( v[line].begin()+c );\n      else if( line<v.size()-1 ){\n\tv[line] = v[line] + v[line+1];\n\tv.erase( v.begin()+line+1 );\n      }\n      break;\n    case 'k':\n      if( c==v[line].length() ){\n\tif( line<v.size()-1 ){\n\t  v[line] = v[line] + v[line+1];\n\t  v.erase( v.begin()+line+1 );\n\t  buf=\"\\n\";\n\t}\n      }else{\n\tbuf = v[line].substr( c );\n\tv[line] = v[line].substr( 0,c );\n      }\n      break;\n    case 'y':\n      if( buf==\"\\n\" ){\n\tbuf = v[line].substr( c );\n\tv[line] = v[line].substr( 0,c );\n\tv.insert( v.begin()+line+1, buf );\n\tbuf=\"\\n\"; c=0;line++;\t\n      }else if( buf!=\"\" ){\n\tif( c<v[line].length() )\n\t  v[line] = v[line].substr( 0,c ) + buf + v[line].substr( c );\n\telse\n\t  v[line] = v[line].substr( 0,c ) + buf;\n      }\n    }\n  }\n\n  for( unsigned int i=0;i<v.size();i++ )\n    cout << v[i] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(5)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<short, short> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 100000007;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator > (const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nvector<string> s;\nint x, y;\n\nvoid gotoend()\n{\n\ty = s[x].size();\n}\n\nvoid gotohome()\n{\n\ty = 0;\n}\n\nint check()\n{\n\tif (s[x].size() == 0 || y == s[x].size()) return 1;\n\telse return 0;\n}\n\n\nint main()\n{\n\tx = 0; y = 0;\n\tstring tmp;\n\tstring buf = \"karappo!!!!!!!!!\";\n\twhile (1)\n\t{\n\t\tcin >> tmp;\n\t\tif (tmp == \"END_OF_TEXT\") break;\n\t\ts.push_back(tmp);\n\t}\n\tchar com;\n\twhile (cin >> com)\n\t{\n\t\tif (com == '-') break;\n\t\telse if (com == 'a') gotohome();\n\t\telse if (com == 'e') gotoend();\n\t\telse if (com == 'p')\n\t\t{\n\t\t\tif (x == 0) gotohome();\n\t\t\telse \n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'n')\n\t\t{\n\t\t\tif (x < s.size() - 1) x++;\n\t\t\tgotohome();\n\t\t}\n\t\telse if (com == 'f')\n\t\t{\n\t\t\tif (check() == 0) y++;\n\t\t\telse if (check()==1&&x < s.size() - 1)\n\t\t\t{\n\t\t\t\tx++;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'b')\n\t\t{\n\t\t\tif (y > 0) y--;\n\t\t\telse if (y == 0 && x > 0)\n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tgotoend();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'd')\n\t\t{\n\t\t\tif (check() == 0) s[x].erase(y, 1);\n\t\t\telse if (check() == 1 && x < s.size() - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\ts.erase(begin(s) + x + 1);\n\t\t\t}\n\t\t}\n\t\telse if (com == 'k')\n\t\t{\n\t\t\tif (check() == 1 && x < s.size() - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\ts.erase(begin(s) + x + 1);\n\t\t\t\tbuf = \"kaigyousuru!!!!!!!\";\n\t\t\t}\n\t\t\t\n\t\t\telse if (check()==0)\n\t\t\t{\n\t\t\t\tbuf = s[x].substr(y);\n\t\t\t\ts[x].erase(y);\n\t\t\t}\n\t\t}\n\t\telse if (com == 'y')\n\t\t{\n\t\t\tif (buf == \"karappo!!!!!!!!!\") continue;\n\t\t\telse if (buf == \"kaigyousuru!!!!!!!\")\n\t\t\t{\n\t\t\t\tstring tmp = s[x].substr(y);\n\t\t\t\ts.insert(begin(s) + x + 1, tmp);\n\t\t\t\ts[x].erase(y);\n\t\t\t\tx++;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts[x].insert(y, buf);\n\t\t\t\ty += buf.size();\n\t\t\t}\n\t\t}\n\n\t}\n\tREP(i, s.size())\n\t{\n\t\tcout << s[i] << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define TOP_OF_BUFFER 0\n#define BEGIN_OF_LINE 0\n\nstruct Cursor{\n  int x, y;\n  Cursor(){\n    x = 0, y = 0;\n  }\n};\n\nvector<string> buffer;\nstring buf;\nbool new_line;\nCursor cursor;\nint end;\n\nvoid output(){\n  for(int i = 0 ; i <= end ; i++){\n    cout << buffer[i] << endl;\n  }\n}\n\nvoid a_command(){\n  cursor.x = BEGIN_OF_LINE;\n}\n\nvoid e_command(){\n  cursor.x = buffer[cursor.y].size();\n}\n\nvoid p_command(){\n  if(cursor.y == TOP_OF_BUFFER) cursor.x = BEGIN_OF_LINE;\n  else{\n    cursor.y--;\n    cursor.x = BEGIN_OF_LINE;\n  }\n}\n\nvoid n_command(){\n  if(cursor.y == end) cursor.x = BEGIN_OF_LINE;\n  else{\n    cursor.y++;\n    cursor.x = BEGIN_OF_LINE;\n  }\n}\n\nvoid f_command(){\n  if(cursor.x != buffer[cursor.y].size()) cursor.x++;\n  else if(cursor.x == buffer[cursor.y].size() && cursor.y != end){\n    cursor.x = BEGIN_OF_LINE;\n    cursor.y++;\n  }\n}\n\nvoid b_command(){\n  if(cursor.x != BEGIN_OF_LINE) cursor.x--;\n  else if(cursor.x == BEGIN_OF_LINE && cursor.y != TOP_OF_BUFFER){\n    cursor.x = buffer[cursor.y-1].size();\n    cursor.y--;\n  }\n}\n\nvoid d_command(){\n  if(cursor.x == buffer[cursor.y].size() && cursor.y != end){\n    cursor.x = buffer[cursor.y].size();\n    buffer[cursor.y] += buffer[cursor.y+1];\n    buffer.erase(buffer.begin() + cursor.y+1);\n    end--;\n  }\n  else if(cursor.x != buffer[cursor.y].size()){\n    buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n  }\n}\n\nvoid k_command(){\n  if(cursor.x == buffer[cursor.y].size() && cursor.y != end){\n    d_command();\n    buf = \"\";\n    new_line = true;\n  }\n  else if(cursor.x != buffer[cursor.y].size()){\n    buf = \"\";\n    new_line = false;\n    for(int j = cursor.x ; j < buffer[cursor.y].size() ; j++){\n      buf += buffer[cursor.y][j];\n    }\n\n    int buffer_size = buffer[cursor.y].size();\n    for(int j = cursor.x ; j < buffer_size ; j++){\n      buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n    }\n  }\n}\n\nvoid y_command(){\n  string bf = \"\";\n  for(int j = cursor.x ; j < buffer[cursor.y].size() ; j++){\n    bf += buffer[cursor.y][j];\n  }\n  \n  \n  if(new_line){\n    buffer.push_back(\"\");\n    for(int i = buffer.size()-1 ; i > cursor.y ; i--){\n      buffer[i] = buffer[i-1];\n    }\n    end++;\n    buffer[cursor.y+1] = bf;\n    int buffer_size = buffer[cursor.y].size();\n    for(int j = cursor.x ; j < buffer_size ; j++){\n      buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n    }\n    cursor.y++;\n    cursor.x = 0;\n  }\n  \n  else{\n    if(cursor.x == buffer[cursor.y].size()){\n      buffer[cursor.y] += buf;\n      cursor.x += buf.size();\n    }\n    else{\n      for(int cnt = 0 ; cnt < bf.size() ; cnt++){\n\tbuffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n      }\n      buffer[cursor.y] += buf;\n      buffer[cursor.y] += bf;\n      cursor.x += buf.size();\n    }\n  }\n} \n\nvoid init(){\n  end = buffer.size()-1;\n  new_line = false;  \n  buf = \"\";\n}\n  \nint main(){\n  string s;\n  while(getline(cin, s)){\n    if(s == \"END_OF_TEXT\") break;\n    buffer.push_back(s);\n  }\n  \n  init();\n  \n  char op;\n  while(cin >> op){\n    if(op == '-') break;\n    if(op == 'a') a_command();\n    if(op == 'e') e_command();\n    if(op == 'p') p_command();\n    if(op == 'n') n_command();\n    if(op == 'f') f_command();\n    if(op == 'b') b_command();\n    if(op == 'd') d_command();\n    if(op == 'k') k_command();\n    if(op == 'y') y_command();  \n  }  \n  output();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring S;\nint p = 0;\n\nvoid a() {\n  for(; p >= 1 && S[p-1] != '\\n'; --p);\n}\n\nvoid e() {\n  for(; p < S.size() && S[p] != '\\n'; ++p);\n}\n\nint main() {\n  string line;\n  S = \"\\n\";\n  while(getline(cin,line) && line != \"END_OF_TEXT\") {\n    S += line;\n    S += '\\n';\n  }\n  char c;\n  string buffer = \"\";\n  p = 1;\n  while(cin >> c && c != '-') {\n    switch(c) {\n    case 'a':\n      a();\n      break;\n    case 'e':\n      e();\n      break;\n    case 'p':\n      a();\n      if(p != 1) {\n\t--p;\n\ta();\n      }\n      break;\n    case 'n':\n      e();\n      if(p+1 != S.size()) ++p;\n      a();\n      break;\n    case 'f':\n      p = min(p+1,(int)S.size()-1);\n      break;\n    case 'b':\n      p = max(p-1, 1);\n      break;\n    case 'd':\n      if(p+1 != S.size()) S.erase(p,1);\n      break;\n    case 'k':\n      if(S[p] == '\\n') {\n\tif(p+1 != S.size()) {\n\t  S.erase(p,1);\n\t  buffer = \"\\n\";\n\t}\n      } else {\n\tfor(int i = 1; ; ++i) {\n\t  if(S[p+i] == '\\n'){\n\t    buffer = S.substr(p,i);\n\t    S.erase(p,i);\n\t    break;\n\t  }\n\t}\n      }\n      break;\n    case 'y':\n      S.insert(p,buffer);\n      if(buffer == \"\\n\") ++p;\n      break;\n    }\n  }\n  cout << S.substr(1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY = 0;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n\telse return;\n}\n\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\";\n\t\tbuf.append(\"\\n\");\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring front=\"\";\n\t\tstring rear=\"\";\n\t\tfront = lines[posY].substr(0,posX);\n\t\trear = lines[posY].substr(posX,lines[posY].size()-posX);\t\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\t/*\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX+1);\n\n\t\tlines[posY] = front;\n\t\tdeque<string>::iterator it = lines.begin();\n\t\tadvance(it,posY);\n\t\tlines.insert(it,rear);\n\t}\n\t*/\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(getline(cin,str)){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(cin >> str){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\tif(str == \"d\") ctrl_d(lines);\n\t\tif(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nvoid convert(string& text, int& cursor, string& buffer, char command);\n\nint main()\n{\t\n\tstring text, buffer;\n\tint cursor = 0;\n\t\n\tfor(string line; getline(cin, line) && line != \"END_OF_TEXT\"; text += line + '\\n');\n\tfor(char command; cin >> command && command != '-'; convert(text, cursor, buffer, command));\n\t\n\tcout << text;\n}\n\nvoid convert(string& text, int& cursor, string& buffer, char command)\n{\t\n\tswitch(command)\n\t{\n\t\t\t/*\n\t\t\t a\n\t\t\t J[\\ð»ÝÌsÌæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'a':\n\t\t{\n\t\t\tif(cursor != 0 && text[cursor - 1] != '\\n')\n\t\t\twhile(--cursor) if(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tcursor++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t e\n\t\t\t J[\\ð»ÝÌsÌsÉÚ®·éB\n\t\t\t */\n\t\tcase 'e':\n\t\t{\n\t\t\twhile(text[cursor] != '\\n') cursor++;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t p\n\t\t\t ãÉsª êÎAJ[\\ðãÌsÌæª¶ÉÚ®·éB\n\t\t\t ãÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'p':\n\t\t{\n\t\t\tsize_t pos = text.rfind(\"\\n\", text.rfind(\"\\n\", cursor) - 1);\n\t\t\t\n\t\t\tcursor = (pos == string::npos ? 0 : pos);\n\t\t\t\n\t\t\t/*\n\t\t\tif(cursor != 0) while(--cursor) if(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(cursor != 0) while(--cursor) if(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tcursor++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t */\n\t\t\t\n\t\t\t\n\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t n\n\t\t\t ºÉsª êÎAJ[\\ðºÌsÌæª¶ÉÚ®·éB\n\t\t\t ºÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'n':\n\t\t{\n\t\t\tint cur = cursor;\n\t\t\twhile(text[cur] != '\\n') cur++;\n\t\t\t\n\t\t\tif(cur + 1 == text.size())\n\t\t\t{\n\t\t\t\tif(cursor != 0) while(--cursor) if(text[cursor] == '\\n')\n\t\t\t\t{\n\t\t\t\t\tcursor++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcursor = cur + 1;\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t f\n\t\t\t J[\\ªsÉÈ¢êAJ[\\ðPÂEÉÚ®·éB\n\t\t\t J[\\ªsÉ è©ÂºÉsª éêÍAJ[\\ðºÌsÌæª¶ÖÚ®·éB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'f':\n\t\t{\n\t\t\tcursor += cursor + 1 != text.size();\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t b\n\t\t\t J[\\ªæª¶ÅÈ¢ÈçÎAJ[\\ðPÂ¶ÉÚ®·éB\n\t\t\t J[\\ªæª¶Å è©ÂãÉsª éêÍAJ[\\ðãÌsÌsÖÚ®·éB\n\t\t\t »êÈOÌêÍ½àµÈ¢\n\t\t\t */\n\t\tcase 'b':\n\t\t{\n\t\t\tcursor -= 0 < cursor;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t d\n\t\t\t J[\\ª¶ðw·êÍ»Ì¶ðí·éBí³ê½¶ÌE¤Ì¶ñÍ¶ÉVtg³êéB\n\t\t\t J[\\ªsðwµºÉsª éêÍAºÌsð»ÌÜÜJ[\\ÌÊuÉq°éBÈºÌsÍãÉVtg³êéB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'd':\n\t\t{\n\t\t\tif(cursor + 1 != text.size()) text.erase(text.begin() + cursor);\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t k\n\t\t\t J[\\ªsÉ éêAºÉsª êÎAd Æ¯¶ìðµobt@ÉPÂÌüsðL^·éB\n\t\t\t J[\\ªsÉÈ¢êAJ[\\ªw·¶ðÜß½E¤·×ÄÌ¶ðØèæè»êðobt@ÉL^·éBJ[\\Í³ÌsÌsðw·æ¤ÉÈéBSÄÌL^É¨¢Äobt@Íã«³êéB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'k':\n\t\t{\n\t\t\tbuffer = \"\";\n\t\t\tif(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tif(cursor + 1 == text.size())\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tbuffer = \"\\n\";\n\t\t\t\ttext.erase(text.begin() + cursor);\n\t\t\t}\n\t\t\telse while(text[cursor] != '\\n')\n\t\t\t{\n\t\t\t\tbuffer += text[cursor];\n\t\t\t\ttext.erase(text.begin() + cursor);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t y\n\t\t\t obt@ªóÌêÍÈÉàµÈ¢B\n\t\t\t obt@ÌàeªüsÌêAJ[\\ªw·¶Ì¼OÅüsðs¤BJ[\\ÍVµ¢sÌæª¶ÖÚ®·éB\n\t\t\t obt@Ìàeª¶ñÌêAJ[\\ÌÊuÉobt@Ìàeð}ü·éB J[\\ÌÊuÍàÆàÆwµÄ¢½¶Ü½ÍsÌêÖÚ®·é\n\t\t\t */\n\t\tcase 'y':\n\t\t{\n\t\t\ttext = text.substr(0, cursor) + buffer + text.substr(cursor);\n\t\t\tcursor += buffer.size();\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    vector<string> buffer;\n    while(true) {\n        string str;\n        getline(cin, str);\n        if(str == \"END_OF_TEXT\") break;\n        buffer.push_back(str);\n    }\n\n    int row = 0, col = 0;\n    string clipboard;\n    while(true) {\n        char op;\n        cin >> op;\n        if(op == '-') break;\n        if(op == 'a') {\n            col = 0;\n        }\n        else if(op == 'e') {\n            col = buffer[row].size();\n        }\n        else if(op == 'p') {\n            col = 0;\n            if(row-1 >= 0) row--;\n        }\n        else if(op == 'n') {\n            col = 0;\n            if(row+1 < buffer.size()) row++;\n        }\n        else if(op == 'f') {\n            if(col == buffer[row].size()) {\n                if(row+1 < buffer.size()) {\n                    row++;\n                    col = 0;\n                }\n            }\n            else col++;\n        }\n        else if(op == 'b') {\n            if(col == 0) {\n                if(row-1 >= 0) {\n                    row--;\n                    col = buffer[row].size();\n                }\n            }\n            else col--;\n        }\n        else if(op == 'd') {\n            if(col == buffer[row].size()) {\n                if(row+1 < buffer.size()) {\n                    buffer[row] += buffer[row+1];\n                    for(int i = row+1; i < (int)buffer.size()-1; ++i) buffer[i] = buffer[i+1];\n                    buffer.resize((int)buffer.size()-1);\n                }\n            }\n            else buffer[row] = buffer[row].substr(0, col) + buffer[row].substr(col+1);\n        }\n        else if(op == 'k') {\n            if(col == buffer[row].size()) {\n                if(row+1 < buffer.size()) {\n                    buffer[row] += buffer[row+1];\n                    for(int i = row+1; i < (int)buffer.size()-1; ++i) buffer[i] = buffer[i+1];\n                    buffer.resize((int)buffer.size()-1);\n                    clipboard = \"\\n\";\n                }\n            }\n            else {\n                clipboard = buffer[row].substr(col);\n                buffer[row] = buffer[row].substr(0, col);\n                col = buffer[row].size();\n            }\n        }\n        else if(op == 'y') {\n            if(clipboard == \"\\n\") {\n                buffer.resize(buffer.size()+1);\n                for(int i = (int)buffer.size()-1; i > row+1; --i) \n                    buffer[i] = buffer[i-1];\n                buffer[row+1] = buffer[row].substr(col);\n                buffer[row] = buffer[row].substr(0, col);\n                ++row;\n                col = 0;\n            }\n            else if(clipboard != \"\") {\n                buffer[row] = buffer[row].substr(0, col) + clipboard + buffer[row].substr(col);\n                col += clipboard.size();\n            }\n        }\n    }\n    for(int i = 0; i < buffer.size(); ++i)\n        cout << buffer[i] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nvector<string> s;\nstring buf = \"\";\nint ci = 0, cj = 0;\n\nvoid input() {\n  string l;\n  while (1) {\n    getline(cin, l);\n    if (l == \"END_OF_TEXT\") {\n      break;\n    }\n    s.push_back(l);\n  }\n}\n\n// カーソルを現在の行の先頭文字に移動する\nvoid op_a() { cj = 0; }\n\n// カーソルを現在の行の行末に移動する\nvoid op_e() { cj = s[ci].size(); }\n\n// 上に行があれば、カーソルを上の行の先頭文字に移動する。\n// 上に行がなければ、カーソルを先頭文字に移動する。\nvoid op_p() {\n  if (ci != 0) \n    --ci;\n  op_a();\n}\n\n// 下に行があれば、カーソルを下の行の先頭文字に移動する。\n// 下に行がなければ、カーソルを先頭文字に移動する。\nvoid op_n() {\n  if (ci != s.size() - 1) \n    ++ci;\n  op_a();\n}\n\n// カーソルが行末にない場合、カーソルを１つ右に移動する \n// カーソルが行末にありかつ下に行がある場合は、\n// カーソルを下の行の先頭文字へ移動する \n// それ以外の場合は何もしない\nvoid op_f() {\n  if (cj != s[ci].size()) {\n    ++cj;\n  } else if (cj == s[ci].size() && ci != s.size() - 1) {\n    op_n();\n  }\n}\n\n// カーソルが先頭文字でないならば、カーソルを１つ左に移動する。\n// カーソルが先頭文字でありかつ上に行がある場合は、\n// カーソルを上の行の行末へ移動する。\n// それ以外の場合は何もしない。\nvoid op_b() {\n  if (cj != 0) {\n    --cj;\n  } else if (cj == 0 && ci != 0) {\n    --ci;\n    op_e();\n  }\n}\n\n// カーソルが文字を指す場合はその文字を削除する。\n// 削除された文字の右側の文字列は左にシフトされる。\n// カーソルが行末を指し下に行がある場合は、\n// 下の行をそのままカーソルの位置に繋げる。以下の行は上にシフトされる。\n// それ以外の場合は何もしない。\nvoid op_d() {\n  if (cj != s[ci].size()) {\n    s[ci].erase(cj, 1);\n  } else if (cj == s[ci].size() && ci != s.size() - 1) {\n    s[ci] += s[ci+1];\n    s.erase(s.begin() + ci + 1);\n  }\n}\n\n// カーソルが行末にある場合、下に行があれば、\n// d と同じ操作をしバッファに１つの改行を記録する。\n// カーソルが行末にない場合、カーソルが指す文字を含めた\n// 右側すべての文字を切り取りそれをバッファに記録する。\n// カーソルは元の行の行末を指すようになる。全ての記録においてバッファは上書きされる。\n// それ以外の場合は何もしない。(clarification at 14:20)\nvoid op_k() {\n  if (cj == s[ci].size() && ci != s.size() - 1) {\n    s[ci] += s[ci+1];\n    s.erase(s.begin() + ci + 1);\n    buf = \"\\n\";\n  } else  {\n    buf = s[ci].substr(cj);\n    s[ci].erase(cj);\n  }\n}\n\n// バッファが空の場合はなにもしない。\n// バッファの内容が改行の場合、カーソルが指す文字の直前で改行を行う。\n// カーソルは新しい行の先頭文字へ移動する。\n// バッファの内容が文字列の場合、カーソルの位置にバッファの内容を挿入する。\n// カーソルの位置はもともと指していた文字または行末の場所へ移動する。 \nvoid op_y() {\n  if (buf == \"\") return;\n  if (buf == \"\\n\") {\n    inserter(s, s.begin() + ci + 1) = s[ci].substr(cj);\n    s[ci].erase(cj);\n    ++ci; cj = 0;\n  } else {\n    s[ci].insert(cj, buf.c_str());\n    cj += buf.size();\n  }\n}\n\nvoid interpret() {\n  string op;\n  while (1) {\n    getline(cin, op);\n    if (op == \"-\") break;\n    if (op == \"a\") {\n      op_a();\n    } else if (op == \"e\") {\n      op_e();\n    } else if (op == \"p\") {\n      op_p();\n    } else if (op == \"n\") {\n      op_n();\n    } else if (op == \"f\") {\n      op_f();\n    } else if (op == \"b\") {\n      op_b();\n    } else if (op == \"d\") {\n      op_d();\n    } else if (op == \"k\") {\n      op_k();\n    } else if (op == \"y\") {\n      op_y();\n    }\n  }\n  rep(i,s.size()) {\n    cout << s[i] << endl;\n  }\n}\n\nint main() {\n  input();\n  interpret();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\tvector<string> edit;\n\twhile(true){\n\t\tstring s;\tcin>>s;\n\t\tif(s==\"END_OF_TEXT\")\tbreak;\n\t\tedit.push_back(s);\n\t}\n\tint tr=0,tc=0;\n\tstring buff=\"\";\n\twhile(true){\n\t\tchar c;\tcin>>c;\n\t\tif(c=='-')\tbreak;\n\t\tif(c=='a')\ttr=0;\n\t\telse if(c=='e')\ttr=edit[tc].size();\n\t\telse if(c=='p'){\n\t\t\ttr=0;\ttc=max(0,tc-1);\n\t\t}\n\t\telse if(c=='n'){\n\t\t\ttr=0;\ttc=min((int)edit.size()-1,tc+1);\n\t\t}\n\t\telse if(c=='f'){\n\t\t\tif((int)edit[tc].size()>=tr+1)\ttr++;\n\t\t\telse if((int)edit.size()>tc+1){\n\t\t\t\ttc++;\ttr=0;\n\t\t\t}\n\t\t}\n\t\telse if(c=='b'){\n\t\t\tif(tr>0)\ttr--;\n\t\t\telse if(tc>0){\n\t\t\t\ttc--;\ttr=edit[tc].size();\n\t\t\t}\n\t\t}\n\t\telse if(c=='d'){\n\t\t\tif(tr<(int)edit[tc].size())\tedit[tc].erase(edit[tc].begin()+tr);\n\t\t\telse if(tc+1<(int)edit.size()){\n\t\t\t\tedit[tc]=edit[tc]+edit[tc+1];\n\t\t\t\tedit.erase(edit.begin()+tc+1);\n\t\t\t}\n\t\t}\n\t\telse if(c=='k'){\n\t\t\tif(tr<(int)edit[tc].size()){\n\t\t\t\tbuff=edit[tc].substr(tr);\n\t\t\t\tedit[tc].erase(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t}\n\t\t\telse if(tc+1<(int)edit.size()){\n\t\t\t\tbuff=\"\\n\";\n\t\t\t\tedit[tc]=edit[tc]+edit[tc+1];\n\t\t\t\tedit.erase(edit.begin()+tc+1);\n\t\t\t}\n\t\t}\n\t\telse if(c=='y'){\n\t\t\tif(buff==\"\")\tcontinue;\n\t\t\tif(buff==\"\\n\"){\n\t\t\t\tstring s(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t\tedit[tc].erase(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t\tedit.insert(edit.begin()+tc+1,s);\n\t\t\t\ttc++;\ttr=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint s=buff.size();\n\t\t\t\tedit[tc].insert(edit[tc].begin()+tr,buff.begin(),buff.end());\n\t\t\t\ttr+=s;\n\t\t\t}\n\t\t}\n\t}\n\tfor(string s:edit)\tcout<<s<<endl;\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tstring str[10000];\n\tstring b;\n\tint i = 0;\n\t\n\twhile (getline(std::cin, str[i]), str[i] != \"END_OF_TEXT\") i++;\n\ti = 0;\n\t\n\tchar cmd[2];\n\tint car_y = 0;\n\tint car = 0;\n\tint y = 0, y2 = 0;\n\t\n\twhile (str[y] != \"END_OF_TEXT\") y++;\n\ty--;\n\ty2 = y;\n\t\n\tb.erase();\n\t\n\twhile (scanf(\"%s\", cmd), cmd[0] != '-'){\n\t\tif (cmd[0] == 'a'){\n\t\t\tcar = 0;\n\t\t//\tprintf(\" a\");\n\t\t}\n\t\tif (cmd[0] == 'e'){\n\t\t\tcar = str[car_y].size();\n\t\t\t\n\t\t//\tprintf(\" e\");\n\t\t}\n\t\tif (cmd[0] == 'p'){\n\t\t\t\n\t\t//\tprintf(\" p\");\n\t\t\tif (car_y == 0){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y--;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'n'){\n\t\t//\tprintf(\" n\");\n\t\t\tif (car_y == y2){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y++;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'f'){\n\t\t//\tprintf(\" f\");\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\tcar_y++;\n\t\t\t\t\tcar = 0;\n\t\t\t\t\t//printf(\" %d\",car_y);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar++;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'b'){\n\t\t//\tprintf(\" b\");\n\t\t\tif (car == 0){\n\t\t\t\tif (car_y != 0){\n\t\t\t\t\tcar_y--;\n\t\t\t\t\tcar = str[car_y].size();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar--;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'd'){\n\t\t//\tprintf(\" d\");\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tstr[car_y].erase(car, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\t//str[car_y] + str[car_y + 1];\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = --y;\n\t\t\t\t\ty = car_y + 1;\n\t\t\t\t\twhile (y <= y2){\n\t\t\t\t\t\tif (y == y2){\n\t\t\t\t\t\t\tstr[y + 2].erase();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstr[y] = str[y + 1];\n\t\t\t\t\t\ty++;\n\t\t\t\t\t}\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'k'){\n\t\t//\tprintf(\" k\");\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\t//str[car_y] + str[car_y + 1];\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = --y;\n\t\t\t\t\ty = car_y + 1;\n\t\t\t\t\twhile (y <= y2){\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (y == y2){\n\t\t\t\t\t\t\tstr[y + 2].erase();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tstr[y] = str[y + 1];\n\t\t\t\t\t\ty++;\n\t\t\t\t\t}\n\t\t\t\t\ty = y2;\n\t\t\t\t\tb[0] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb.erase();\n\t\t\t\tb = str[car_y].substr(car);\n\t\t\t\tstr[car_y].erase(car);\n\t\t\t\tcar = str[car_y].size();\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'y'){\n\t\t//\tprintf(\" %d\\n\", y);\n\t\t\n\t\t\tif (b[0] == '\\0'){\n\t\t\t\t//\tprintf(\" y2\");\n\t\t\t\ty2 = ++y;\n\t\t\t\twhile (y - 1 > car_y){\n\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstr[y] = str[y - 1].substr(car);\n\t\t\t\tstr[y - 1].erase(car);\n\t\t\t\ty = y2;\n\t\t\t}\n\t\t\telse if (!b.empty()){\n\t\t\t\tstr[car_y].insert(car, b);\n\t\t\t\tcar += b.size();\n\t\t\t}\n\t\t}\n\t}\n\t\n\ti = 0;\n\twhile (i <= y2){\n\t\t//puts(str[i].c_str());\n\t\tcout << str[i] << endl;\n\t\ti++;\n\t}\n\t/*\n\ti = 0;\n\twhile (i <= y2){\n\t\tif (car_y == i){\n\t\t\tfor (int j = 0; j <= str[i].size(); j++){\n\t\t\t\tif (j == car){\n\t\t\t\t\tcout << 'I';\n\t\t\t\t}\n\t\t\t\tcout << str[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\telse{\n\t\t\tputs(str[i].c_str());\n\t\t}\n\t\ti++;\n\t}\n\t*/\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1021\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n\nvector<string> text;\nint line, chara;\nstring buffer;\n\nbool on_tail() { return chara == text[line].size(); }\nvoid goto_tail() { chara = text[line].size(); }\nbool on_eof() { return line >= text.size() - 1; }\nvoid delete_line(int n) { text.erase(text.begin() + n); }\nvoid delete_chara(int line, int chara) {\n  text[line].erase(text[line].begin() + chara);\n}\n\nvoid a() { chara = 0; }\nvoid e() { goto_tail(); }\nvoid p() { line = max(line - 1, 0); chara = 0; }\nvoid n() { line = min(line + 1, (int)text.size() - 1); chara = 0; }\nvoid f() {\n  if (not on_tail()) { chara++; }\n  else if (not on_eof()) {\n    line++; chara = 0;\n  }\n}\nvoid b() {\n  if (chara > 0) { chara--; }\n  else if (line > 0) { line--; goto_tail(); }\n}\nvoid d() {\n  if (on_tail() and !on_eof()) {\n    text[line] += text[line + 1];\n    delete_line(line + 1);\n  } else if (not on_tail()) {\n    delete_chara(line, chara);\n  }\n}\nvoid k() {\n  if (on_tail() and !on_eof()) {\n    d();\n    buffer = \"\\n\";\n  } else if (not on_tail()) {\n    buffer = text[line].substr(chara);\n    text[line] = text[line].substr(0, chara);\n  }\n}\nvoid y() {\n  if (buffer == \"\\n\") {\n    string temp = text[line].substr(chara);\n    text[line] = text[line].substr(0, chara);\n    text.insert(text.begin() + line + 1, temp);\n    line++; chara = 0;\n  } else if (not buffer.empty()) {\n    text[line].insert(text[line].begin()+chara, buffer.begin(), buffer.end());\n    chara += buffer.size();\n  }\n}\n\nint main() {\n  string temp_line;\n  buffer = \"\";\n  while (getline(cin, temp_line) and temp_line != \"END_OF_TEXT\") {\n    text.push_back(temp_line);\n  }\n\n  char operat;\n  while (cin >> operat and operat != '-') {\n    switch (operat) {\n    case 'a':\n      a(); break;\n    case 'e':\n      e(); break;\n    case 'p':\n      p(); break;\n    case 'n':\n      n(); break;\n    case 'f':\n      f(); break;\n    case 'b':\n      b(); break;\n    case 'd':\n      d(); break;\n    case 'k':\n      k(); break;\n    case 'y':\n      y(); break;\n    default:\n      break;\n    }\n\n  }\n\n  for (int i = 0; i < text.size(); i++) {\n    cout << text[i] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * 1021.cc: Emacs-like Editor\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\n/* typedef */\n\ntypedef vector<string> vs;\n\n/* global variables */\n\nvs txt;\nstring buf;\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    string s;\n    cin >> s;\n    if (s == \"END_OF_TEXT\") break;\n    txt.push_back(s);\n  }\n  if (txt.size() == 0) txt.push_back(\"\");\n\n  int cx = 0, cy = 0;\n  \n  for (;;) {\n    char op;\n    cin >> op;\n    if (op == '-') break;\n\n    switch (op) {\n    case 'a':\n      cx = 0;\n      break;\n    case 'e':\n      cx = txt[cy].size();\n      break;\n    case 'p':\n      cx = 0;\n      if (cy > 0) cy--;\n      break;\n    case 'n':\n      cx = 0;\n      if (cy < txt.size() - 1) cy++;\n      break;\n    case 'f':\n      if (cx < txt[cy].size()) cx++;\n      else if (cy < txt.size() - 1) cy++, cx = 0;\n      break;\n    case 'b':\n      if (cx > 0) cx--;\n      else if (cy > 0) cy--, cx = txt[cy].size();\n      break;\n    case 'd':\n      if (cx < txt[cy].size()) txt[cy].erase(cx, 1);\n      else if (cy < txt.size() - 1) {\n\ttxt[cy] += txt[cy + 1];\n\ttxt.erase(txt.begin() + cy + 1);\n      }\n      break;\n    case 'k':\n      if (cx == txt[cy].size()) {\n\tif (cy < txt.size() - 1) {\n\t  txt[cy] += txt[cy + 1];\n\t  txt.erase(txt.begin() + cy + 1);\n\t  buf = \"\\n\";\n\t}\n      }\n      else {\n\tbuf = txt[cy].substr(cx);\n\ttxt[cy].erase(cx);\n\t//cx = txt[cy].size();\n      }\n      break;\n    case 'y':\n      int bn = buf.size();\n      if (bn > 0) {\n\tif (buf == \"\\n\") {\n\t  string line = txt[cy].substr(cx);\n\t  txt[cy].erase(cx);\n\t  txt.insert(txt.begin() + cy + 1, line);\n\t  cy++, cx = 0;\n\t}\n\telse {\n\t  txt[cy].insert(cx, buf);\n\t  cx += bn;\n\t}\n      }\n      break;\n    }\n  }\n\n  for (int i = 0; i < txt.size(); i++) cout << txt[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Emacs{\n  int line,column;\n  string buffer;\n  vector<string> text;\n\n  void editText(){\n    for(int i = 0 ; i < (int)text.size() ; i++){\n      if(isEmptyLine(i)){ text[i].empty(); }\n    }\n  }\n\n  void order(char command){\n    editText();\n    switch(command){\n    case 'a': funcA(); break;\n    case 'e': funcE(); break;\n    case 'p': funcP(); break;\n    case 'n': funcN(); break;\n    case 'f': funcF(); break;\n    case 'b': funcB(); break;\n    case 'd': funcD(); break;\n    case 'k': funcK(); break;\n    case 'y': funcY(); break;\n    }\n  }\n\n  bool isEmptyLine(int l){\n    for(int i = 0 ; i < (int)text[l].size() ; i++){\n      if(text[l][i] != ' '){ return false; }\n    }\n    return true;\n  }\n\n  void funcA(){\n    column = 0;\n  }\n  \n  void funcE(){\n    column = text[line].size();\n  }\n\n  void funcP(){\n    if(line > 0){ line--; }\n    column = 0;\n  }\n\n  void funcN(){\n    if(line+1 < (int)text.size()){ line++; }\n    column = 0;\n  }\n\n  void funcF(){\n    if(column == (int)text[line].size()){\n      funcN();\n    }else{\n      column++;\n    }\n  }\n  \n  void funcB(){\n    if(column == 0){\n      if(line != 0){\n        line--;\n        column = text[line].size();\n      }\n    }else{\n      column--;\n    }\n  }\n\n  void funcD(){\n    if(text[line].empty()){\n      int len = text.size();\n      vector<string> ntext(len-1);\n      for(int i = 0 ; i < line ; i++){\n        ntext[i] = text[i];\n      }\n      for(int i = line ; i < len-1 ; i++){\n        ntext[i] = text[i+1];\n      }\n      text = ntext;\n      return;\n    }\n    if(0 <= column && column < (int)text[line].size()){\n      text[line] = text[line].substr(0,column) + text[line].substr(column+1);\n    }else{\n      int len = text.size();\n      if(line+1 < len){\n        vector<string> ntext(len-1);\n        for(int i = 0 ; i < line-1 ; i++){\n          ntext[i] = text[i];\n        }\n        ntext[line] = text[line] + text[line+1];\n        for(int i = line+2 ; i < len ; i++){\n          ntext[i-1] = text[i];\n        }\n        text = ntext;\n      }\n    }\n  }\n\n  void funcK(){\n    int len = text[line].size();\n    if(text[line].empty()){\n      buffer = \"\\n\";\n      int len = text.size();\n      vector<string> ntext(len-1);\n      for(int i = 0 ; i < line ; i++){\n        ntext[i] = text[i];\n      }\n      for(int i = line ; i < len-1 ; i++){\n        ntext[i] = text[i+1];\n      }\n      text = ntext;\n      return;\n    }\n    if(column == len){\n      int len2 = text.size();\n      if(line+1 < len2){\n        buffer = \"\\n\";\n        vector<string> ntext(len2-1);\n        for(int i = 0 ; i < line ; i++){\n          ntext[i] = text[i];\n        }\n        ntext[line] = text[line] + text[line+1];\n        for(int i = line+1 ; i < len2-1 ; i++){\n          ntext[i] = text[i+1];\n        }\n        text = ntext;\n      }\n    }else{\n      buffer.clear();\n      for(int i = column ; i < len ; i++){\n        buffer += text[line][i];\n      }\n      text[line].resize(column);\n    }\n  }\n\n  void funcY(){\n    if(buffer.empty()){ return; }\n    if(buffer == \"\\n\"){\n      string str = text[line];\n      string str2 = str.substr(column);\n      text[line] = str.substr(0,column);\n      int size = text.size();\n      text.resize(size+1);\n      for(int i = size ; i >= line+2 ; i--){\n        text[i] = text[i-1];\n      }\n      text[line+1] = str2;\n      funcN();\n    }else{\n      string str = text[line];\n      str = str.substr(0,column) + buffer + str.substr(column);\n      text[line] = str;\n      column += buffer.size();\n    }\n  }\n\n  void print(){\n    int len = text.size();\n    for(int i = 0 ; i < len ; i++){\n      cout << text[i] << endl;\n    }\n  }\n};\n\nint main(){\n  Emacs emacs;\n  string str;\n  while(getline(cin,str), str != \"END_OF_TEXT\"){\n    emacs.text.push_back(str);\n  }\n  emacs.line = emacs.column = 0;\n  char command;\n  while(cin >> command, command != '-'){\n    emacs.order(command);\n  }\n  emacs.print();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[128];\nstring buf;\nint lines;\nvoid delete_line(int y)\n{\n    for (int i = y; y < lines; ++y)\n\ts[i] = s[i + 1];\n    s[--lines] = \"\";\n    if (lines == 0)\n\tlines = 1;\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; ++i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    while (true)\n    {\n\tstring t;\n\tgetline(cin, t);\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines++] = t;\n    }\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    y = max(0, --y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    y = min(lines - 1, ++y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y + 1 != lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t\tx = 0, --y;\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t\ts[y].erase(x, 1);\n\t    else\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t    }\n\t    break;\n\t}\n\tcase 'k':\n\t{\n\t    if (x == s[y].size())\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    else if (!s[y].empty())\n\t    {\n\t\tbuf = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\tif (!s[y].empty())\n\t\t{\n\t\t    s[y + 1] = s[y].substr(x);\n\t\t    s[y].erase(x);\n\t\t}\n\t\tx = 0, ++y;\n\t    }\n\t    else if (!buf.empty())\n\t\ts[y] += buf;\n\t    break;\n\t}\n\t}\n    }\n\n    for (int i = 0; i < lines; ++i)\n\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstruct Editor : public vector<string>{\n\tint CurX;int CurY;\n\tstring Buf;\n\tEditor(){CurX=0;CurY=0;Buf=\"\";}\n\tvector<string>::iterator Iterator(int l){\n\t\tvector<string>::iterator it=begin();\n\t\tfor(int i=0;i<l;i++)it++;\n\t\treturn it;\n\t}\n\tvoid Show(){\n\t\tfor(int i=0;i<size();i++){\n\t\t\tcout << at(i) << endl;\n\t\t}\n\t}\n\tvoid Cmd_a(){\n\t\tCurX=0;\n\t}\n\tvoid Cmd_e(){\n\t\tCurX=at(CurY).size();\n\t}\n\tvoid Cmd_p(){\n\t\tif(CurY!=0)CurY--;\n\t\tCmd_a();\n\t}\n\tvoid Cmd_n(){\n\t\tif(CurY!=size()-1)CurY++;\n\t\tCmd_a();\n\t}\n\tvoid Cmd_f(){\n\t\tif(CurX!=at(CurY).size()){\n\t\t\tCurX++;\n\t\t}else if(CurX==at(CurY).size()&&CurY!=size()-1){\n\t\t\tCmd_n();\n\t\t}\n\t}\n\tvoid Cmd_b(){\n\t\tif(CurX!=0){\n\t\t\tCurX--;\n\t\t}else if(CurX==0&&CurY!=0){\n\t\t\tCurY--;\n\t\t\tCmd_e();\n\t\t}\n\n\t}\n\tvoid Cmd_d(){\n\t\tif(CurX!=at(CurY).size()){\n\t\t\t(*this)[CurY]=at(CurY).substr(0,CurX)+at(CurY).substr(CurX+1);\n\t\t}else if(CurX==at(CurY).size()&&CurY!=size()-1){\n\t\t\t(*this)[CurY]+=at(CurY+1);\n\t\t\terase(Iterator(CurY+1));\n\t\t}\n\t}\n\tvoid Cmd_k(){\n\t\tif(CurX==at(CurY).size()&&CurY!=size()-1){\n\t\t\t(*this)[CurY]+=at(CurY+1);\n\t\t\terase(Iterator(CurY+1));\n\t\t\tBuf=\"\\n\";\n\t\t}else if(CurX!=at(CurY).size()){\n\t\t\tBuf=at(CurY).substr(CurX);\n\t\t\t(*this)[CurY]=at(CurY).substr(0,CurX);\n\t\t}\n\t}\n\tvoid Cmd_y(){\n\t\tif(Buf==\"\")return;\n\t\tif(Buf==\"\\n\"){\n\t\t\tinsert(Iterator(CurY+1),at(CurY).substr(CurX));\n\t\t\t(*this)[CurY]=at(CurY).substr(0,CurX);\n\t\t\tCurY++;CurX=0;\n\t\t}else{\n\t\t\t(*this)[CurY]=at(CurY).substr(0,CurX)+Buf+at(CurY).substr(CurX);\n\t\t\tCurX+=Buf.size();\n\t\t}\n\t}\n\tvoid Cmd(string cmd){\n\t\tif(cmd==\"a\"){\n\t\t\tCmd_a();\n\t\t}\n\t\tif(cmd==\"e\"){\n\t\t\tCmd_e();\n\t\t}\n\t\tif(cmd==\"p\"){\n\t\t\tCmd_p();\n\t\t}\n\t\tif(cmd==\"n\"){\n\t\t\tCmd_n();\n\t\t}\n\t\tif(cmd==\"f\"){\n\t\t\tCmd_f();\n\t\t}\n\t\tif(cmd==\"b\"){\n\t\t\tCmd_b();\n\t\t}\n\t\tif(cmd==\"d\"){\n\t\t\tCmd_d();\n\t\t}\n\t\tif(cmd==\"k\"){\n\t\t\tCmd_k();\n\t\t}\n\t\tif(cmd==\"y\"){\n\t\t\tCmd_y();\n\t\t}\n\t}\n};\nint main(){\n\tstring tmp;\n\tEditor ed;\n\twhile(1){\n\t\tgetline(cin,tmp);\n\t\tif(tmp==\"END_OF_TEXT\")break;\n\t\ted.push_back(tmp);\n\t}\n\twhile(1){\n\t\tgetline(cin,tmp);\n\t\tif(tmp==\"-\")break;\n\t\ted.Cmd(tmp);\n\t}\n\ted.Show();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n#define INPUT_LINE_MAX 10\n#define INPUT_CHAR_MAX 20\n#define COMMAND_MAX 300\n#define RUN_LINE_MAX 100\n#define RUN_CHAR_MAX 1000\n\nusing namespace std;\n\nint main() {\n  string input, buffer, result;\n  vector<string> editor;\n  char command = 0;\n  string::size_type cursor = 0;\n  vector<string>::size_type line = 0;\n\n  for (int in = 0; in < INPUT_LINE_MAX; in++) {\n    getline(cin, input);\n    if (input.size() > INPUT_CHAR_MAX)\n      return -1;\n    if (input == \"END_OF_TEXT\")\n      break;\n\n    editor.push_back(input);\n  }\n\n  cursor = 0;\n  line = 0;\n\n  for (int com = 0; com < COMMAND_MAX; com++) {\n    cin >> command;\n    if (command == '-')\n      break;\n\n    switch (command) {\n    case 'a':\n      cursor = 0;\n      break;\n\n    case 'e':\n      cursor = editor[line].size();\n      break;\n\n    case 'p':\n      cursor = 0;\n      if (line > 0)\n        line--;\n      break;\n    case 'n':\n      cursor = 0;\n      if (line < editor.size() - 1)\n        line++;\n      break;\n    case 'f':\n      if (cursor < editor[line].size())\n        cursor++;\n      else if (cursor == editor[line].size() && line < editor.size() - 1) {\n        cursor = 0;\n        line++;\n      }\n      break;\n    case 'b':\n      if (cursor > 0)\n        cursor--;\n      else if (cursor == 0 && line > 0) {\n        line--;\n        cursor = editor[line].size();\n      }\n      break;\n    case 'd':\n      if (cursor < editor[line].size())\n        editor[line].erase(editor[line].begin() + cursor);\n      else if (cursor == editor[line].size() && line < editor.size() - 1) {\n        editor[line] += editor[line + 1];\n        editor.erase(editor.begin() + line + 1);\n      }\n      break;\n\n    case 'k':\n      if (cursor < editor[line].size()) {\n        buffer = \"\";\n        copy(editor[line].begin() + cursor, editor[line].end(), back_inserter(buffer));\n        editor[line].erase(editor[line].begin() + cursor, editor[line].end());\n        cursor = editor[line].size();\n      }\n      else if (cursor == editor[line].size() && line < editor.size() - 1) {\n        editor[line] += editor[line + 1];\n        buffer = \"\\n\";\n        editor.erase(editor.begin() + line + 1);\n      }\n      break;\n\n    case 'y':\n      if (!buffer.empty()) {\n        if (buffer == \"\\n\") {\n          string tmp;\n          copy(editor[line].begin() + cursor, editor[line].end(), back_inserter(tmp));\n          editor[line].erase(editor[line].begin() + cursor, editor[line].end());\n          editor.insert(editor.begin() + line + 1, tmp);\n          cursor = 0;\n          line++;\n        }\n        else {\n          if (cursor == editor[line].size()) {\n            editor[line] += buffer;\n            cursor = editor[line].size();\n          }\n          else {\n            editor[line].insert(editor[line].begin() + cursor, buffer.begin(), buffer.end());\n            cursor += buffer.size();\n          }\n        }\n      }\n      break;\n    }\n  }\n\n  for (vector<string>::size_type i = 0; i < editor.size(); i++) {\n    result += editor[i];\n    result += \"\\n\";\n  }\n\n  cout << result;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[110][1100];\nchar buf[1100];\nchar in[10];\nint main(){\n\tint n=0;\n\twhile(1){\n\t\tgets(str[n]);\n\t\tif(str[n][3]=='_')break;\n\t\tn++;\n\t}\n\tfor(int i=0;i<1100;i++)str[n][i]=0;\n\tint row=0;\n\tint col=0;\n\twhile(1){\n\t\tscanf(\"%s\",in);\n\t\tif(in[0]=='-')break;\n\t\tif(in[0]=='a')col=0;\n\t\tif(in[0]=='e'){\n\t\t\twhile(str[row][col]){\n\t\t\t\tcol++;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='p'){\n\t\t\tif(row)row--;\n\t\t\tcol=0;\n\t\t}\n\t\tif(in[0]=='n'){\n\t\t\tif(row<n-1)row++;\n\t\t\tcol=0;\n\t\t}\n\t\tif(in[0]=='f'){\n\t\t\tif(str[row][col])col++;\n\t\t\telse if(row<n-1){row++;col=0;}\n\t\t}\n\t\tif(in[0]=='b'){\n\t\t\tif(col)col--;\n\t\t\telse if(row){row--;col=0;\n\t\t\t\twhile(str[row][col])col++;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='d'){\n\t\t\tif(str[row][col]){\n\t\t\t\tfor(int i=col;str[row][i];i++)str[row][i]=str[row][i+1];\n\t\t\t}else if(row<n-1){\n\t\t\t\tfor(int i=0;str[row+1][i];i++){\n\t\t\t\t\tstr[row][col+i]=str[row+1][i];\n\t\t\t\t\tstr[row+1][i]=0;\n\t\t\t\t}\n\t\t\t\tfor(int i=row+1;i<n;i++){\n\t\t\t\t\tfor(int j=0;j<1100;j++)str[i][j]=str[i+1][j];\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<1100;i++)str[n][i]=0;\n\t\t\t\tn--;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='k'){\n\t\t\tif(!str[row][col]){\n\t\t\t\tif(row<n-1){\n\t\t\t\t\tfor(int i=0;str[row+1][i];i++){\n\t\t\t\t\tstr[row][col+i]=str[row+1][i];\n\t\t\t\t\tstr[row+1][i]=0;\n\t\t\t\t}\n\t\t\t\tfor(int i=row+1;i<n;i++){\n\t\t\t\t\tfor(int j=0;j<1100;j++)str[i][j]=str[i+1][j];\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<1100;i++)str[n][i]=0;\n\t\t\t\tn--;\n\t\t\t\t\tbuf[0]='@';\n\t\t\t\t\tbuf[1]=0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint at=0;\n\t\t\t\tfor(int i=col;str[row][i];i++){\n\t\t\t\t\tbuf[at++]=str[row][i];\n\t\t\t\t\tstr[row][i]=0;\n\t\t\t\t}\n\t\t\t\tbuf[at]=0;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='y'){\n\t\t\tif(buf[0]){\n\t\t\t\tif(buf[0]=='@'){\n\t\t\t\t\tfor(int i=n-1;i>row;i--){\n\t\t\t\t\t\tfor(int j=0;j<1100;j++)str[i+1][j]=str[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tint at=0;\n\t\t\t\t\tfor(int i=col;str[row][i];i++){\n\t\t\t\t\t\tstr[row+1][at++]=str[row][i];\n\t\t\t\t\t\tstr[row][i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tstr[row+1][at]=0;\n\t\t\t\t\trow++;col=0;\n\t\t\t\t\tn++;\n\t\t\t\t}else{\n\t\t\t\t\tint sz=0;\n\t\t\t\t\tfor(int i=0;buf[i];i++)sz++;\n\t\t\t\t\tfor(int i=1109;i>=col;i--){\n\t\t\t\t\t\tif(i+sz>=1100)continue;\n\t\t\t\t\t\tstr[row][i+sz]=str[row][i];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0;i<sz;i++)str[row][col+i]=buf[i];\n\t\t\t\t\tcol+=sz;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)printf(\"%s\\n\",str[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <string> VS;\nistream& myis = cin;\nostream& myos = cout;\n\nconst string END_OF_TEXT = \"END_OF_TEXT\";\nconst string END_OF_COMMAND = \"-\";\n\n// prototypes\nVS solve( const VS& lines );\nvoid output( const VS& lines );\nvoid split( const VS& lines, VS& T, VS& C );\n\n// editor\nclass Editor {\npublic:\n    // members\n    VS T;\n    int r;\n    int c;\n    string buffer;\n    // methods\n    Editor( VS T ): T(T) {\n        r = 0;\n        c = 0;\n        buffer.clear();\n    }\n    VS get_text() { return T; }\n    void parse_command( string com ) {\n        if ( com == \"a\" ) command_a();\n        if ( com == \"e\" ) command_e();\n        if ( com == \"p\" ) command_p();\n        if ( com == \"n\" ) command_n();\n        if ( com == \"f\" ) command_f();\n        if ( com == \"b\" ) command_b();\n        if ( com == \"d\" ) command_d();\n        if ( com == \"k\" ) command_k();\n        if ( com == \"y\" ) command_y();\n        // debug\n        /*\n        myos << \"::: debug start :::\" << endl;\n        myos << \"r: \" << r << endl;\n        myos << \"c: \" << c << endl;\n        myos << \"b: \" << buffer << endl;\n        myos << \"::: debug end   :::\" << endl;\n        */\n    }\nprivate:\n    bool is_cursor_leftmost() {\n        return c == 0;\n    }\n    bool is_cursor_rightmost() {\n        return c == (int)T[r].size();\n    }\n    bool exist_next_upperline() {\n        return r - 1 >= 0;\n    }\n    bool exist_next_lowerline() {\n        return r + 1 < (int)T.size();\n    }\n    void delete_line( int n ) {\n        T.erase( T.begin() + n );\n    }\n    void delete_letter( int n ) {\n        T[r].erase( T[r].begin() + n );\n    }\n    void move_cursor_leftmost() {\n        c = 0;\n    }\n    void move_cursor_rightmost() {\n        c = T[r].size();\n    }\n    void move_cursor_up() {\n        r -= 1;\n    }\n    void move_cursor_down() {\n        r += 1;\n    }\n    void move_cursor_left() {\n        c -= 1;\n    }\n    void move_cursor_right() {\n        c += 1;\n    }\n    void move_cursor_right( int n ) {\n        c += n;\n    }\n    void command_a() {\n        /*\n          J[\\ð»ÝÌsÌæª¶ÉÚ®·éB\n        */\n        move_cursor_leftmost();\n    }\n    void command_e() {\n        /*\n          J[\\ð»ÝÌsÌsÉÚ®·éB\n        */\n        move_cursor_rightmost();\n    }\n    void command_p() {\n        /*\n          ãÉsª êÎAJ[\\ðãÌsÌæª¶ÉÚ®·éB\n          ãÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n        */\n        if ( exist_next_upperline() ) {\n            move_cursor_up();\n            move_cursor_leftmost();\n        } else {\n            move_cursor_leftmost();\n        }\n    }\n    void command_n() {\n        /*\n          ºÉsª êÎAJ[\\ðºÌsÌæª¶ÉÚ®·éB\n          ºÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n        */\n        if ( exist_next_lowerline() ) {\n            move_cursor_down();\n            move_cursor_leftmost();\n        } else {\n            move_cursor_leftmost();\n        }\n    }\n    void command_f() {\n        /*\n          J[\\ªsÉÈ¢êAJ[\\ðPÂEÉÚ®·éB\n          J[\\ªsÉ è©ÂºÉsª éêÍAJ[\\ðºÌsÌæª¶ÖÚ®·éB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( ! is_cursor_rightmost() ) {\n            move_cursor_right();\n        } else if ( is_cursor_rightmost() && exist_next_lowerline() ) {\n            move_cursor_down();\n            move_cursor_leftmost();\n        }\n    }\n    void command_b() {\n        /*\n          J[\\ªæª¶ÅÈ¢ÈçÎAJ[\\ðPÂ¶ÉÚ®·éB\n          J[\\ªæª¶Å è©ÂãÉsª éêÍAJ[\\ðãÌsÌsÖÚ®·éB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( ! is_cursor_leftmost() ) {\n            move_cursor_left();\n        } else if ( is_cursor_leftmost() && exist_next_upperline() ) {\n            move_cursor_up();\n            move_cursor_rightmost();\n        }\n    }\n    void command_d() {\n        /*\n          J[\\ª¶ðw·êÍ»Ì¶ðí·éBí³ê½¶ÌE¤Ì¶ñÍ¶ÉVtg³êéB\n          J[\\ªsðwµºÉsª éêÍAºÌsð»ÌÜÜJ[\\ÌÊuÉq°éBÈºÌsÍãÉVtg³êéB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( ! is_cursor_rightmost() ) {\n            delete_letter( c );\n        } else if ( is_cursor_rightmost() && exist_next_lowerline() ) {\n            T[r] += T[r+1];\n            delete_line( r+1 );\n        }\n    }\n    void command_k() {\n        /*\n          J[\\ªsÉ éêAºÉsª êÎAd Æ¯¶ìðµobt@ÉPÂÌüsðL^·éB\n          J[\\ªsÉÈ¢êAJ[\\ªw·¶ðÜß½E¤·×ÄÌ¶ðØèæè»êðobt@ÉL^·éB\n          J[\\Í³ÌsÌsðw·æ¤ÉÈéBSÄÌL^É¨¢Äobt@Íã«³êéB\n          »êÈOÌêÍ½àµÈ¢B\n        */\n        if ( is_cursor_rightmost() && exist_next_lowerline() ) {\n            T[r] += T[r+1];\n            delete_line( r+1 );\n            buffer = \"\\n\";\n        } else if ( ! is_cursor_rightmost() ) {\n            buffer = T[r].substr( c );\n            T[r] = T[r].substr( 0, c );\n            move_cursor_rightmost();\n        }\n    }\n    void command_y() {\n        /*\n          obt@ªóÌêÍÈÉàµÈ¢B\n          obt@ÌàeªüsÌêAJ[\\ªw·¶Ì¼OÅüsðs¤BJ[\\ÍVµ¢sÌæª¶ÖÚ®·éB\n          obt@Ìàeª¶ñÌêAJ[\\ÌÊuÉobt@Ìàeð}ü·éB\n          J[\\ÌÊuÍàÆàÆwµÄ¢½¶Ü½ÍsÌêÖÚ®·éB\n        */\n        if ( buffer == \"\\n\" ) {\n            string tmp = T[r].substr( c );\n            T[r] = T[r].substr( 0, c );\n            T.insert( T.begin() + r + 1, tmp );\n            move_cursor_down();\n            move_cursor_leftmost();\n        } else if ( buffer != \"\" ) {\n            string left = T[r].substr( 0, c );\n            string right = T[r].substr( c );\n            T[r] = left + buffer + right;\n            move_cursor_right( buffer.size() );\n        }\n    }\n};\n\n// functions\n\nVS solve( const VS& lines ) {\n    VS T; // text\n    VS C; // commands\n    split( lines, T, C );\n\n    if ( T.empty() ) return T;\n\n    // edit\n    Editor editor( T );\n    for ( VS ::iterator it_i = C.begin(); it_i != C.end(); ++ it_i ) {\n        string command = *it_i;\n        editor.parse_command( command );\n    }\n    return editor.get_text();\n}\n\nvoid output( const VS& lines ) {\n    for ( VS ::const_iterator it_i = lines.begin(); it_i != lines.end(); ++ it_i ) {\n        myos << *it_i << endl;\n    }\n}\n\nvoid split( const VS& lines, VS& T, VS& C ) {\n    T.clear();\n    C.clear();\n    VS ::const_iterator it_lines = lines.begin();\n    for ( ; it_lines != lines.end(); ++ it_lines ) {\n        const string& line = *it_lines;\n        if ( line == END_OF_TEXT ) {\n            ++ it_lines;\n            break;\n        }\n        T.push_back( line );\n    }\n    for ( ; it_lines != lines.end(); ++ it_lines ) {\n        const string& line = *it_lines;\n        if ( line == END_OF_COMMAND ) {\n            break;\n        }\n        C.push_back( line );\n    }\n}\n\nint main() {\n    VS lines;\n    string line;\n    while ( getline( myis, line ) ) lines.push_back( line );\n\n    VS answer = solve( lines );\n    output( answer );\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<sstream>\n#include<map>\n#include<vector>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nstring cash;\n\nvoid A(P& cursor)\n{\n  cursor.S = 0;\n}\n\nvoid E(P& cursor,vector<string>& buffer)\n{\n  cursor.S = buffer[cursor.F].size()-1;\n}\n\nvoid PP(P& cursor,vector<string>& buffer)\n{\n  if(cursor.F-1 >= 0)\n    cursor.F--,cursor.S = 0;\n  else \n    cursor.S = 0;\n}\n\nvoid N(P& cursor,vector<string>& buffer)\n{\n  if(cursor.F+1 < buffer.size())\n    cursor.F++,cursor.S = 0;\n  else\n    cursor.S = 0;\n}\n\nvoid F(P& cursor,vector<string>& buffer)\n{\n  if(cursor.S+1 < buffer[cursor.F].size())\n    cursor.S++;\n  else if(buffer[cursor.F].size()-1 == cursor.S && cursor.F+1 < buffer.size())\n    cursor.F++,cursor.S = 0;\n}\n\nvoid B(P& cursor,vector<string>& buffer)\n{\n  if(cursor.S != 0)\n    cursor.S--;\n  else if(cursor.S == 0 && cursor.F-1 >= 0)\n    cursor.F--,cursor.S = buffer[cursor.F].size()-1;\n}\n\nvoid D(P& cursor,vector<string>& buffer)\n{\n  if(cursor.S != buffer[cursor.F].size()-1)\n    {\n      string pre,bef;\n    for(int i=0;i<buffer[cursor.F].size();i++)\n      if(i == cursor.S)\n\tcontinue;\n      else if(i < cursor.S)      \n\tpre += buffer[cursor.F][i];\n      else \n\tbef += buffer[cursor.F][i];\n\n    buffer[cursor.F] = pre;\n    buffer[cursor.F] += bef;\n    }\n    else if(cursor.F+1 < buffer.size())\n    {\n      int Size = buffer[cursor.F].size();\n      for(int i=0;i<buffer[cursor.F+1].size();i++)\n\t{\n\t  if(cursor.S+i < Size)\n\t    buffer[cursor.F][cursor.S+i] = buffer[cursor.F+1][i];\n\t  else \n\t    buffer[cursor.F] += buffer[cursor.F+1][i];\n\t}\n\n      for(int i=cursor.F+1;i<buffer.size()-1;i++)\n\tbuffer[i] = buffer[i+1];\n      buffer.erase(buffer.end());\n    }\n}\n\nvoid K(P& cursor,vector<string>& buffer)\n{\n  if(cursor.S == buffer[cursor.F].size()-1)\n    {\n      D(cursor,buffer);\n      cash = \" \";   \n    }\n  else\n    {\n      cash.clear();\n      string pre;\n      for(int i=0;i<buffer[cursor.F].size();i++)\n\tif(cursor.S <= i)\n\t  cash += buffer[cursor.F][i];\n\telse \n\t  pre += buffer[cursor.F][i];\n      buffer[cursor.F] = pre + \" \";\n      cursor.S = buffer[cursor.F].size()-1;\n    }\n}\n\nvoid Y(P& cursor,vector<string>& buffer)\n{\n  if(cash.size() == 0)\n    return;\n\n  if(cash.size() == 1)\n    {   \n      buffer.push_back(\"\");\n      for(int i=buffer.size()-1;i>cursor.F;i--)\n\tbuffer[i] = buffer[i-1];\n     \n      string pre,bef;\n      for(int i=0;i<buffer[cursor.F].size();i++)\n\t{\n\t  if(i < cursor.S)\n\t    pre += buffer[cursor.F][i];\n\t  else \n\t    bef += buffer[cursor.F][i];\n\t}\t\n      buffer[cursor.F].clear();\n      buffer[cursor.F] = pre+\" \";\n      buffer[cursor.F+1] = bef;\n      cursor.F++,cursor.S = 0;\n      return;\n    }\n\n  string pre,bef;\n      for(int i=0;i<buffer[cursor.F].size();i++)\n\t{\n\t  if(i < cursor.S)\n\t    pre += buffer[cursor.F][i];\n\t  else \n\t    bef += buffer[cursor.F][i];\n\t}\t\n     \n      buffer[cursor.F] = pre;\n      buffer[cursor.F] += cash.substr(0,cash.size()-1);\n      cursor.S = buffer[cursor.F].size();\n      buffer[cursor.F] += bef;\n      \n}\n\nint main()\n{\n  \n \n      vector<string> buffer;\n      string line;\n      P cursor = P(0,0); //P(y、x)\n      cash.clear();\n\n      while(getline(cin,line),line != \"END_OF_TEXT\")\n\t{\n\t  buffer.push_back(line);  \n\t  buffer.back() += \" \";\n\t}\n\n      if(buffer.size() == 0)\n\tbuffer.push_back(\" \");\n\n      while(cin >> line,line != \"-\")\n\t{\n\t  if(buffer.size() == 0 || (buffer.size() == 1 && buffer[0].size() == 1))\n\t    continue;\n\t  if(line[0] == 'a')\n\t    A(cursor);\n\t  else if(line[0] == 'e')\n\t    E(cursor,buffer);\n\t  else if(line[0] == 'p')\n\t    PP(cursor,buffer);\n\t  else if(line[0] == 'n')\n\t    N(cursor,buffer);\n\t  else if(line[0] == 'f')\n\t    F(cursor,buffer);\n\t  else if(line[0] == 'b')\n\t    B(cursor,buffer);\n\t  else if(line[0] == 'd')\n\t    D(cursor,buffer);\n\t  else if(line[0] == 'k')\n\t    K(cursor,buffer);\n\t  else if(line[0] == 'y')\n\t    Y(cursor,buffer);\n\t  //cout <<line <<  \" ----------\" << endl;\n\t  //cout << \"cursor(\" << cursor.F << \" \"  << cursor.S << \")\" << endl;\n\t  //cout << \"cash = \" << cash << endl;\n\t  //for(int i=0;i<buffer.size();i++)\n\t  //cout << buffer[i].substr(0,buffer[i].size()-1) << \"||| \" << buffer[i].size() << endl;\t  \n\n\t}\n\n      for(int i=0;i<buffer.size();i++)\n\tcout << buffer[i].substr(0,buffer[i].size()-1) << endl;\n\t\n\n    \n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n\n#define rep(i,n)      for(int i=0;i<n;++i)\n\nusing namespace std;\n\nclass editor\n{\nprivate:\n\tvector<string> lines;\n\tint cur_line, cur_col;\n\n\tstring buffer;\n\tbool buf_is_available;\n\npublic:\n\teditor()\n\t\t: cur_line(0), cur_col(0), buf_is_available(false)\n\t{\n\t}\n\n\tvoid add_line(const string &l) { lines.push_back(l); }\n\n\tint tail() { return lines[cur_line].length(); }\n\n\tbool is_first_line() { return cur_line == 0; }\n\tbool is_last_line() { return cur_line + 1 == lines.size(); }\n\tbool is_head_of_line() { return cur_col == 0; }\n\tbool is_tail_of_line() { return cur_col == tail(); }\n\n\t// a\n\tvoid move_to_head() { cur_col = 0; }\n\n\t// e\n\tvoid move_to_tail() { cur_col = tail(); }\n\n\t// p\n\tvoid move_up()\n\t{\n\t\tmove_to_head();\n\t\tif (!is_first_line()) cur_line--;\n\t}\n\n\t// n\n\tvoid move_down()\n\t{\n\t\tmove_to_head();\n\t\tif (!is_last_line()) cur_line++;\n\t}\n\n\t// f\n\tvoid forward()\n\t{\n\t\tif (is_tail_of_line())\n\t\t\tmove_down();\n\t\telse\n\t\t\tcur_col++;\n\t}\n\n\t// b\n\tvoid backward()\n\t{\n\t\tif (is_head_of_line())\n\t\t{\n\t\t\tif (!is_first_line())\n\t\t\t{\n\t\t\t\tcur_line--;\n\t\t\t\tcur_col = 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcur_col--;\n\t\t}\n\t}\n\n\t// d\n\tvoid delete_char()\n\t{\n\t\tif (!is_tail_of_line())\n\t\t{\n\t\t\tlines[cur_line].erase(cur_col, 1);\n\t\t}\n\t\telse if (!is_last_line())\n\t\t{\n\t\t\tlines[cur_line] += lines[cur_line + 1];\n\t\t\tlines.erase(lines.begin() + cur_line + 1);\n\t\t}\n\t}\n\n\t// k\n\tvoid cut_tails()\n\t{\n\t\tbuffer = lines[cur_line].substr(cur_col);\n\t\tbuf_is_available = true;\n\t\tif (is_tail_of_line())\n\t\t{\n\t\t\tif (!is_last_line())\n\t\t\t{\n\t\t\t\tlines[cur_line] += lines[cur_line + 1];\n\t\t\t\tlines.erase(lines.begin() + cur_line + 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlines[cur_line] = lines[cur_line].substr(0, cur_col);\n\t\t}\n\t}\n\n\t// y\n\tvoid paste()\n\t{\n\t\tif (!buf_is_available) return;\n\n\t\tif (buffer.empty())\n\t\t{\n\t\t\tlines.insert(lines.begin() + cur_line + 1, lines[cur_line].substr(cur_col));\n\t\t\tlines[cur_line] = lines[cur_line].substr(0, cur_col);\n\t\t\tcur_line++;\n\t\t\tcur_col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlines[cur_line].insert(cur_col, buffer);\n\t\t\tcur_col += buffer.length();\n\t\t}\n\t}\n\n\tvoid print_lines()\n\t{\n\t\trep(i,lines.size())\n\t\t{\n\t\t\tcout << lines[i] << endl;\n\t\t}\n\t}\n};\n\nint main()\n{\n\teditor edit;\n\tstring line;\n\twhile (getline(cin, line), line != \"END_OF_TEXT\") edit.add_line(line);\n\n\tchar c;\n\tfor(;cin>>c, c != '-';)\n\t{\n\t\tswitch (c)\n\t\t{\n\t\tcase 'a': edit.move_to_head(); break;\n\t\tcase 'e': edit.move_to_tail(); break;\n\t\tcase 'p': edit.move_up();      break;\n\t\tcase 'n': edit.move_down();    break;\n\t\tcase 'f': edit.forward();      break;\n\t\tcase 'b': edit.backward();     break;\n\t\tcase 'd': edit.delete_char();  break;\n\t\tcase 'k': edit.cut_tails();    break;\n\t\tcase 'y': edit.paste();        break;\n\t\t}\n\t}\n\tedit.print_lines();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main(){ string str[1000]; string s; int size = 0; while(getline(cin,s)){ if(s == \"END_OF_TEXT\") break; str[size++] = s; } char ch; string buf = \"\"; int line = 0, pos = 0; while(cin >> ch){ if(ch == '-') break; if(ch == 'a') pos = 0; if(ch == 'e') pos = str[line].size(); if(ch == 'p'){ pos = 0; if(line!=0) line--; } if(ch == 'n'){ pos = 0; if(line+1!=size) line++; } if(ch == 'f'){ if(pos != str[line].size()) pos++; else if(line+1!=size) { pos = 0; line++; } } if(ch == 'b'){ if(pos != 0) pos--; else if(line!=0) { line--; pos = str[line].size(); } } if(ch == 'd'){ if(pos != str[line].size()){ str[line] = str[line].substr(0,pos) + str[line].substr(pos+1); } else if(line+1!=size){ str[line] = str[line] + str[line+1]; for(int i=line+1;i+1<size;i++){ str[i] = str[i+1]; } str[size-1] = \"\"; size--; } } if(ch == 'k'){ if(pos == str[line].size() && line+1!=size){ str[line] = str[line] + str[line+1]; for(int i=line+1;i+1<size;i++){ str[i] = str[i+1]; } str[size-1] = \"\"; size--; buf = \"IS_BREAK_LINE\"; } else if(pos < str[line].size()){ buf = str[line].substr(pos); str[line] = str[line].substr(0,pos); } } if(ch == 'y'){ if(buf == \"IS_BREAK_LINE\"){ for(int i=size-1;i>=line+1;i--){ str[i+1] = str[i]; } size++; str[line+1] = str[line].substr(pos); str[line] = str[line].substr(0,pos); line++; pos = 0; } else if(buf != \"\"){ str[line] = str[line].substr(0,pos) + buf + str[line].substr(pos); pos += buf.size(); } } /* cout << line << \" \" << pos << endl; for(int i=0;i<size;i++){ cout << str[i] << endl; } puts(\"\"); */ } for(int i=0;i<size;i++){ cout << str[i] << endl; } }"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[310];\nstring buf;\nint lines = 0;\nvoid delete_line(int y)\n{\n    for (int i = y; y < lines; ++y)\n\ts[i] = s[i + 1];\n    s[--lines] = \"\";\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; ++i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    for ( ; ; ++lines)\n    {\n\tstring t;\n\tcin >> t;\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines] = t;\n    }\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    if (y != 0)\n\t\t--y;\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    if (y != lines)\n\t\t++y;\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y != lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t\tx = 0, --y;\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t\ts[y].erase(x, 1);\n\t    else\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t    }\n\t    break;\n\t}\n\tcase 'k':\n\t{\n\t    if (x == s[y].size())\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    else\n\t    {\n\t\tbuf = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\ts[y + 1] = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = 0, ++y;\n\t    }\n\t    else if (!buf.empty())\n\t\ts[y] += buf;\n\t    break;\n\t}\n\t}\n    }\n\n\tfor (int i = 0; i < lines; ++i)\n\t    cout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\n\nint main() {\n\tvector<string>emacs;\n\twhile (1) {\n\t\tstring st; cin >> st;\n\t\t\n\t\tif (st == \"END_OF_TEXT\") {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\temacs.push_back(st);\n\t\t}\n\t}\n\tint x = 0, y = 0;\n\tvector<string>buf;\n\twhile (1) {\n\t\tchar c; cin >> c;\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\t\tx = 0;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tx = emacs[y].size();\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (y) {\n\t\t\t\ty--;\n\t\t\t}\n\t\t\tx = 0;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tif (y != emacs.size() - 1) {\n\t\t\t\ty++;\n\t\t\t}\n\t\t\tx = 0;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tif (x != emacs[y].size())x++;\n\t\t\telse {\n\t\t\t\tif (y != emacs.size() - 1) {\n\t\t\t\t\ty++;\n\t\t\t\t\tx = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif (x)x--;\n\t\t\telse {\n\t\t\t\tif (y) {\n\t\t\t\t\ty--;\n\t\t\t\t\tx = emacs[y].size();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (x != emacs[y].size()) {\n\t\t\t\temacs[y].erase(emacs[y].begin() + x);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (y != emacs.size() - 1) {\n\t\t\t\t\temacs[y].insert(emacs[y].end(), emacs[y + 1].begin(), emacs[y + 1].end());\n\t\t\t\t\temacs.erase(emacs.begin() + y + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tif (x == emacs[y].size()) {\n\t\t\t\tif (y != emacs.size() - 1) {\n\t\t\t\t\temacs[y].insert(emacs[y].end(), emacs[y + 1].begin(), emacs[y + 1].end());\n\t\t\t\t\temacs.erase(emacs.begin() + y + 1);\n\t\t\t\t\tbuf = vector<string>(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuf = vector<string>(1, emacs[y].substr(x));\n\t\t\t\temacs[y].erase(emacs[y].begin() + x, emacs[y].end());\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tif (buf.empty()) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (buf[0] == \"\") {\n\t\t\t\t\tstring rest = emacs[y].substr(x);\n\t\t\t\t\temacs.insert(emacs.begin() + y, rest);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\temacs[y].insert(emacs[y].begin() + x, buf[0].begin(), buf[0].end());\n\t\t\t\t\tx += buf[0].size();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (c=='-')break;\n\t}\n\tfor (auto s : emacs) {\n\t\tcout << s << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n  vector<string> text(200);\n  int line = 0;\n  for(;line<11;line++){\n    getline(cin,text[line],'\\n');\n    if (text[line]==\"END_OF_TEXT\")\n      break;\n  }\n  string buffer;\n  int cur[2];\n  cur[0] = 0;//0s\n  cur[1] = 0;//0¶Ú\n\n  while(true){\n    char com;\n    cin >> com;\n    if (com == '-')\n      break;\n    switch (com){\n    case 'a':\n      cur[1] = 0;\n      break;\n    case 'e':\n      cur[1] = (int)text[cur[0]].size();\n      break;\n    case 'p':\n      if (cur[0]>0)\n\tcur[0]--;\n      cur[1]=0;\n      break;\n    case 'n':\n      if (cur[0]<line-1)\n\tcur[0]++;\n      cur[1]=0;\n      break;\n    case 'f':\n      if (cur[1]<(int)text[cur[0]].size())\n\tcur[1]++;\n      else\n\tif (cur[0]<line-1){\n\t  cur[0]++;\n\t  cur[1]=0;\t\n\t}\n      break;\n    case 'b':\n      if (cur[1]>0)\n\tcur[1]--;\n    else\n      if (cur[0]>0){\n\tcur[0]--;\n\tcur[1]=(int)text[cur[0]].size();\t\n      }\n      break;\n    case 'd':\n      if (cur[1]<(int)text[cur[0]].size()){\n\ttext[cur[0]] = text[cur[0]].substr(0,cur[1])+text[cur[0]].substr(cur[1]+1);\n      }\n      else\n\tif (cur[0]<line-1){\n\t  text[cur[0]] = text[cur[0]]+text[cur[0]+1];\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i] = text[i+1];\n\t  line--;\n\t}\n      break;\n    case 'k':\n      if (cur[1]==(int)text[cur[0]].size()){\n\tif (cur[0]<line-1){\n\t  text[cur[0]] = text[cur[0]]+text[cur[0]+1];\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i] = text[i+1];\n\t  line--;\n\t  buffer = \"\\n\";\n\t}\n      }\n      else{\n\tbuffer = text[cur[0]].substr(cur[1]);\n\ttext[cur[0]] = text[cur[0]].substr(0,cur[1]);\n\tcur[1] = (int)text[cur[0]].size();\n      }\n      break;\n    case 'y':\n      if (buffer.empty())\n\tbreak;\n      else{\n\tif (buffer == \"\\n\"){\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i+1] = text[i];    \n\t  line++;\n\t  text[cur[0]] = text[cur[0]].substr(cur[1]);\n\t  text[cur[0]+1] = text[cur[0]].substr(0,cur[1]);\n\t}\n\telse{\n\t  text[cur[0]] = text[cur[0]].substr(0,cur[1])+buffer+text[cur[0]].substr(cur[1]);\n\t}\n      }\n    }\n    /*  for(int i=0;i<line;i++)\n\tcout << text[i] << endl;\n\tcout << \"(\" << cur[0] << \",\" << cur[1] << \")\" << endl;\n\tcout << \"#\" << endl;*/\n  }\n  for(int i=0;i<line;i++)\n    cout << text[i] << endl;\n  return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n\tvector<string> text;\n\twhile(true){\n\t\tstring line;\n\t\tgetline(cin, line);\n\t\tif(line == \"END_OF_TEXT\"){ break; }\n\t\ttext.push_back(line);\n\t}\n\tint x = 0, y = 0;\n\tstring buffer;\n\twhile(true){\n\t\tstring cmd;\n\t\tcin >> cmd;\n\t\tif(cmd == \"-\"){ break; }\n\t\tif(cmd == \"a\"){\n\t\t\tx = 0;\n\t\t}else if(cmd == \"e\"){\n\t\t\tx = text[y].size();\n\t\t}else if(cmd == \"p\"){\n\t\t\tx = 0;\n\t\t\tif(y > 0){ --y; }\n\t\t}else if(cmd == \"n\"){\n\t\t\tx = 0;\n\t\t\tif(y < text.size() - 1){ ++y; }\n\t\t}else if(cmd == \"f\"){\n\t\t\tif(x < text[y].size()){\n\t\t\t\t++x;\n\t\t\t}else if(y < text.size() - 1){\n\t\t\t\tx = 0;\n\t\t\t\t++y;\n\t\t\t}\n\t\t}else if(cmd == \"b\"){\n\t\t\tif(x > 0){\n\t\t\t\t--x;\n\t\t\t}else if(y > 0){\n\t\t\t\t--y;\n\t\t\t\tx = text[y].size();\n\t\t\t}\n\t\t}else if(cmd == \"d\"){\n\t\t\tif(x < text[y].size()){\n\t\t\t\ttext[y].erase(text[y].begin() + x);\n\t\t\t}else if(y < text.size() - 1){\n\t\t\t\ttext[y] += text[y + 1];\n\t\t\t\ttext.erase(text.begin() + y + 1);\n\t\t\t}\n\t\t}else if(cmd == \"k\"){\n\t\t\tif(x == text[y].size() && y < text.size() - 1){\n\t\t\t\tbuffer = \"\\n\";\n\t\t\t\ttext[y] += text[y + 1];\n\t\t\t\ttext.erase(text.begin() + y + 1);\n\t\t\t}else if(x != text[y].size()){\n\t\t\t\tbuffer = string(text[y].begin() + x, text[y].end());\n\t\t\t\ttext[y].erase(text[y].begin() + x, text[y].end());\n\t\t\t}\n\t\t}else if(cmd == \"y\"){\n\t\t\tif(buffer == \"\"){\n\t\t\t}else if(buffer == \"\\n\"){\n\t\t\t\ttext.insert(text.begin() + y + 1, string(text[y].begin() + x, text[y].end()));\n\t\t\t\ttext[y].erase(text[y].begin() + x, text[y].end());\n\t\t\t\t++y; x = 0;\n\t\t\t}else{\n\t\t\t\ttext[y].insert(x, buffer);\n\t\t\t\tx += buffer.size();\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < text.size(); ++i){ cout << text[i] << endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main()\n{\n\tstring str[300];\n\tstring b;\n\tb[0] = '*';\n\tint y = 0, y2 = 0;\n\t\n\twhile (getline(std::cin, str[y]), str[y] != \"END_OF_TEXT\"){\n\t\ty++;\n\t}\n\ty2 = --y;\n\t\n\tchar cmd[2];\n\tint car = 0, car_y = 0;\n\t\n\twhile (scanf(\"%s\", cmd), cmd[0] != '-'){\n\t\tif (cmd[0] == 'a'){\n\t\t\tcar = 0;\n\t\t}\n\t\tif (cmd[0] == 'e'){\n\t\t\tcar = str[car_y].size();\n\t\t}\n\t\tif (cmd[0] == 'p'){\n\t\t\tif (car_y == 0){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y--;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'n'){\n\t\t\tif (car_y != y){\n\t\t\t\tcar_y++;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\t\n\t\t\telse {\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'f'){\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tcar++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tcar_y++;\n\t\t\t\t\tcar = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'b'){\n\t\t\tif (car != 0){\n\t\t\t\tcar--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != 0){\n\t\t\t\t\tcar_y--;\n\t\t\t\t\tcar = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'd'){\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tstr[car_y].erase(car, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = y - 1;\n\t\t\t\t\ty = car_y;\n\t\t\t\t\twhile (++y < y2){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y].erase();\n\t\t\t\t\t\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'k'){\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = y;\n\t\t\t\t\ty = car_y;\n\t\t\t\t\twhile (++y < y2){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y].erase();\n\t\t\t\t\t\n\t\t\t\t\ty = y2;\n\t\t\t\t\tb[0] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb = str[car_y].substr(car);\n\t\t\t\tstr[car_y].erase(car);\n\t\t\t\tcar = str[car_y].size();\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'y'){\n\t\t\tif(b[0] != '*'){\n\t\t\t\tif (b[0] == '\\0'){\n\t\t\t\t\ty2 = y + 1;\n\t\t\t\t\twhile (y > car_y + 1){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y] = str[car_y].substr(car);\n\t\t\t\t\tstr[car_y].erase(car);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstr[car_y].insert(car, b);\n\t\t\t\t\tcar += b.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int j = 0; j <= y; j++){\n\t\tprintf(\"%s\\n\", str[j].c_str());\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <string>\n#include <algorithm>\n\n#define DEBUG 0\n#define fprintf(...) (void)0\n\nint main() {\n  std::list<std::string> input;\n  while (true) {\n    char buf[24];\n    fgets(buf, sizeof buf, stdin);\n    std::string line=buf;\n    if (line == \"END_OF_TEXT\\n\")\n      break;\n\n    assert(line.back() == '\\n');\n    input.emplace_back(line);\n  }\n\n  // fprintf(stderr, \"size: %zu\\n\", input.size());\n\n  std::string kbuf=\"\";\n  std::list<std::string>::iterator it=input.begin();\n  size_t cc=0;\n  while (true) {\n    char op;\n    scanf(\" %c\", &op);\n    if (op == '-')\n      break;\n\n    switch (op) {\n    case 'a':\n      cc = 0;\n      break;\n\n    case 'e':\n      assert(it->size() > 0);\n      cc = it->size()-1;\n      break;\n\n    case 'p':\n      cc = 0;\n      if (it != input.begin())\n        --it;\n      break;\n\n    case 'n':\n      cc = 0;\n      {\n        auto tmp=it;\n        ++tmp;\n        if (tmp != input.end())\n          it = tmp;\n      }\n      break;\n\n    case 'f':\n      if (cc+1 < it->size()) {\n        ++cc;\n      } else {\n        auto tmp=it;\n        ++tmp;\n        if (tmp != input.end()) {\n          cc = 0;\n          it = tmp;\n        }\n      }\n      break;\n\n    case 'b':\n      if (cc > 0) {\n        --cc;\n      } else if (it != input.begin()) {\n        --it;\n        cc = it->size()-1;\n      }\n      break;\n\n    case 'd':\n      if (cc+1 == it->size()) {\n        assert((*it)[cc] == '\\n');\n        {\n          auto tmp=it;\n          ++tmp;\n          if (tmp != input.end()) {\n            it->pop_back();  // '\\n'\n            *it += *tmp;\n            input.erase(tmp);\n          }\n        }\n      } else {\n        // TLE?\n        std::string t=it->substr(0, cc);\n        t += it->substr(cc+1);\n        *it = t;\n      }\n      break;\n\n    case 'k':\n      if (cc+1 == it->size()) {\n        assert((*it)[cc] == '\\n');\n        {\n          auto tmp=it;\n          ++tmp;\n          if (tmp != input.end()) {\n            assert(it->back() == '\\n');\n            it->pop_back();\n            *it += *tmp;\n            input.erase(tmp);\n            kbuf = \"\\n\";\n          }\n        }\n      } else {\n        kbuf = it->substr(cc);\n        assert(kbuf.back() == '\\n');\n        kbuf.pop_back();  // '\\n'\n        fprintf(stderr, \"kill buffer: %s\\n\", kbuf.c_str());\n        if (cc > 0) {\n          *it = it->substr(0, cc);\n          *it += '\\n';\n        } else {\n          *it = \"\\n\";\n        }\n        //cc = it->size()-1;\n      }\n      break;\n\n    case 'y':\n      if (kbuf.empty()) break;\n\n      if (kbuf == \"\\n\") {\n        // ++it;\n        // input.emplace(it, \"\\n\");\n        // --it;  // ??\n        {\n          std::string t=it->substr(cc);\n          *it = it->substr(0, cc);\n          *it += '\\n';\n          ++it;\n          input.emplace(it, t);\n          --it;\n        }\n        cc = 0;\n      } else {\n        {\n          std::string t=\"\";\n          if (cc > 0) {\n            t += it->substr(0, cc);\n          }\n          t += kbuf;\n          //t.pop_back();\n          t += it->substr(cc);\n          *it = t;\n        }\n      }\n      break;\n    }\n\n    if (DEBUG) {\n      fprintf(stderr, \"%c: L%td C%zu\\n\", op, std::distance(input.begin(), it), cc);\n      for (const auto &s: input)\n        fprintf(stderr, \"%s\", s.c_str());  // s ~ \".*\\n\"\n    }\n  }\n\n  for (const auto &s: input)\n    printf(\"%s\", s.c_str());  // s ~ \".*\\n\"\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvoid doA(int *l, int *c, string &s, string &b, vector<string> &v) {\n  *c = 0;\n}\n\nvoid doE(int *l, int *c, string &s, string &b, vector<string> &v) {\n  *c = s.size();\n}\n\nvoid doP(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*l > 0)\n    *l -= 1;\n  *c = 0;\n}\n\nvoid doN(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*l < v.size()-1)\n    *l += 1;\n  *c = 0;\n}\n\nvoid doF(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c < s.size()) {\n    *c += 1;\n  } else if (*l < v.size()-1){\n    *l += 1;\n    *c = 0;\n  }\n}\n\nvoid doB(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c > 0) {\n    *c -= 1;\n  } else if (*l > 0) {\n    *l -= 1;\n    *c = s.size();\n  }\n}\n\nvoid doD(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c < s.size()) {\n    s.erase(*c, 1);\n  } else if (*l < v.size()-1) {\n    s.append(v[*l+1]);\n    vector<string>::iterator itr = v.begin() + *l + 1;\n    v.erase(itr);\n  }\n}\n\nvoid doK(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (*c == s.size() && *l < v.size()-1) {\n    doD(l, c, s, b, v);\n    b = \"\\n\";\n  } else if (*c < s.size()) {\n    b = s.substr(*c, s.size() - *c);\n    s.erase(*c, s.size() - *c);\n  }\n}\n\n\nvoid doY(int *l, int *c, string &s, string &b, vector<string> &v) {\n  if (b.empty()) {\n    return;\n  } else if (b == \"\\n\" && *c < s.size()) {\n    doK(l, c, s, b, v);\n    vector<string>::iterator itr = v.begin() + *l + 1;\n    v.insert(itr, b);\n    b = \"\\n\";\n  } else if (b == \"\\n\") {\n    vector<string>::iterator itr = v.begin() + *l + 1;\n    v.insert(itr, \"\");\n  } else {\n    s.insert(*c, b);\n    *c = s.size();\n  }\n}\n\nint main(int argc, char *argv[]) {\n  string buf;\n  vector<string> strs;\n  while (true) {\n    string s;\n    getline(cin, s);\n    if (s == \"END_OF_TEXT\")\n      break;\n    strs.push_back(s);\n  }\n  int line = 0, chrc = 0;\n  while (true) {\n    char c;\n    cin >> c;\n    if (c == '-')\n      break;\n    else if (c == 'a')\n      doA(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'e')\n      doE(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'p')\n      doP(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'n')\n      doN(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'f')\n      doF(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'b')\n      doB(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'd')\n      doD(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'k')\n      doK(&line, &chrc, strs[line], buf, strs);\n    else if (c == 'y')\n      doY(&line, &chrc, strs[line], buf, strs);\n  }\n\n  for (int i = 0; i < strs.size(); i++)\n    cout << strs[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[111];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\tfor(int i=0 ; i<111 ; i++)\n\t\tt[i] = \"\";\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tif(i<110) t[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tif(row<110) col = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 && row < 110 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row < 110 && row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( row < 110 && col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else if( row < 110 ){\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( row < 110 && buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line+1 < 110 && line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\t//t[row+1] =\n\t\t\t\t\tt[row].substr( col );\n\t\t\t\t\t//t[row].erase( col );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else if( row < 110 ){\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\ntemplate <class T> void pv(T a, T b) {\n\tfor(typeof(a) it = a; it != b; ++it)\n\t\tcerr << *it << \" \";\n\tcerr << endl;\n}\n\n#define all(v) (v).begin(), (v).end()\n\nvector<string> text;\nvector<char> command;\n\nint cursol_row;\nint cursol_col;\n\nvoid com_a() {\n\tcursol_col = 0;\n}\n\nvoid com_e() {\n\tcursol_col = text.at(cursol_row).length() - 1;\n}\n\nvoid com_p() {\n\tif(cursol_row > 0) cursol_row--;\n\tcom_a();\n}\n\nvoid com_n() {\n\tif(cursol_row < (int)text.size() - 1) cursol_row++;\n\tcom_a();\n}\n\nvoid com_f() {\n\tif(text[cursol_row][cursol_col] != '^') cursol_col++;\n\telse if(text[cursol_row][cursol_col] == '^' && cursol_row < (int)text.size() - 1) {\n\t\tcom_n();\n\t}\n}\n\nvoid com_b() {\n\tif(cursol_col > 0) cursol_col--;\n\telse if(cursol_col == 0 && cursol_row > 0) {\n\t\tcursol_row--;\n\t\tcom_e();\n\t}\n}\n\nvoid show_cursol() {\n\tcerr << \"ROW: \" << cursol_row << \" COL: \" << cursol_col << endl;\n}\n\nvoid com_d() {\n\tif(text[cursol_row][cursol_col] != '^') {\n\t\tstring line = text[cursol_row];\n\t\tstring left = line.substr(0, cursol_col);\n\t\tstring right = line.substr(cursol_col + 1);\n\t\ttext[cursol_row] = left + right;\n\t} else if(text[cursol_row][cursol_col] == '^' && cursol_row < (int)text.size() - 1) {\n\t\tstring line = text[cursol_row];\n\t\tline = line.substr(0, line.length() - 1) + text[cursol_row + 1];\n\t\ttext[cursol_row] = line;\n\n\t\tvector<string>::iterator it = text.begin();\n\t\tadvance(it, cursol_row + 1);\n\t\ttext.erase(it);\n\t}\n}\n\nstring buffer;\n\nvoid com_k() {\n\tif(text[cursol_row][cursol_col] == '^' && cursol_row < (int)text.size() - 1) {\n\t\tcom_d(); buffer = \"^\";\n\t}\n\telse if(text[cursol_row][cursol_col] != '^') {\n\t\tstring line = text[cursol_row];\n\t\tbuffer = line.substr(cursol_col);\n\t\tbuffer = buffer.substr(0, buffer.length() - 1);\n\t\ttext[cursol_row] = line.substr(0, cursol_col) + \"^\";\n\t}\n}\n\nvoid com_y() {\n\tif(buffer == \"^\") {\n\t\tstring line = text[cursol_row];\n\t\tstring fs = line.substr(0, cursol_col) + \"^\";\n\t\tstring sc = line.substr(cursol_col);\n\t\ttext[cursol_row] = fs;\n\n\t\tvector<string>::iterator it = text.begin();\n\t\tadvance(it, cursol_row + 1);\n\t\ttext.insert(it, sc);\n\t\tcursol_row++;\n\t\tcursol_col = 0;\n\t}\n\telse if(buffer != \"\") {\n\t\tstring line = text[cursol_row];\n\t\tstring left = line.substr(0, cursol_col);\n\t\tstring right = line.substr(cursol_col);\n\t\ttext[cursol_row] = left + buffer + right;\n\t}\n}\n\nint main() {\n\tbuffer = \"\";\n\n\tcursol_row = 0;\n\tcursol_col = 0;\n\n#if 1\n\tfor(string line; getline(cin, line) && line != \"END_OF_TEXT\";) {\n\t\ttext.push_back(line + \"^\");\n\t}\n\tfor(char c; cin >> c && c != '-'; ) {\n\t\tcommand.push_back(c);\n\t}\n#else\n\tfor(string line; getline(cin, line) && line != \"-\";) {\n\t\ttext.push_back(line + \"^\");\n\t}\n\tfor(char c; cin >> c && c != '-'; ) {\n\t\tswitch(c) {\n\t\t\tcase 'a': com_a(); break;\n\t\t\tcase 'e': com_e(); break;\n\t\t\tcase 'p': com_p(); break;\n\t\t\tcase 'n': com_n(); break;\n\t\t\tcase 'f': com_f(); break;\n\t\t\tcase 'b': com_b(); break;\n\t\t\tcase 'd': com_d(); break;\n\t\t\tcase 'k': com_k(); break;\n\t\t\tcase 'y': com_y(); break;\n\t\t\tdefault: break;\n\t\t}\n\t\tpv(all(text));\n\t\tshow_cursol();\n\t}\n#endif\n\n\t\n#if 0\n\tpv(all(text));\n\tpv(all(command));\n#endif\n\n\n#if 1\n\tfor(int i = 0; i < (int)command.size(); i++) {\n\t\tchar c = command[i];\n\t\tswitch(c) {\n\t\t\tcase 'a': com_a(); break;\n\t\t\tcase 'e': com_e(); break;\n\t\t\tcase 'p': com_p(); break;\n\t\t\tcase 'n': com_n(); break;\n\t\t\tcase 'f': com_f(); break;\n\t\t\tcase 'b': com_b(); break;\n\t\t\tcase 'd': com_d(); break;\n\t\t\tcase 'k': com_k(); break;\n\t\t\tcase 'y': com_y(); break;\n\t\t\tdefault: break;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < (int)text.size(); i++) {\n\t\tcout << text[i].substr(0, text[i].length() - 1) << endl;\n\t\t// cout << text[i] << endl;\n\t}\n#endif\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n \nusing namespace std;\n\nclass Emacs {\npublic:\n    Emacs(){\n        col = row = 0;\n        buf.clear();\n    }\n    void appendLine(string line){ text.push_back(line); }\n    void execCommand(char code){\n        switch (code){\n          case 'a': A(); break;\n          case 'e': E(); break;\n          case 'p': P(); break;\n          case 'n': N(); break;\n          case 'f': F(); break;\n          case 'b': B(); break;\n          case 'd': D(); break;\n          case 'k': K(); break;\n          case 'y': Y(); break;\n        }\n    }\n    void showText(){\n        for (string line : text)\n            cout << line << \"\\n\";\n    }\nprivate:\n    void A(){ col = 0; }\n    void E(){ col = text[row].size(); }\n    void P(){ row = max(row - 1, 0); A(); }\n    void N(){ row = min(row + 1, (int)text[row].size() - 1); A(); }\n    void F(){ if (col < text[row].size()) col++; else if (row < text.size() - 1) A(), row++; }\n    void B(){ if (col > 0) col--; else if (row > 0) row--, E(); }\n    void D(){ if (col < text[row].size()) text[row].erase(col, 1); else if (row < text.size() - 1) text[row] += text[row + 1], text.erase(text.begin() + row + 1); }\n    void K(){ if (col < text[row].size()) buf = text[row].substr(col), text[row] = text[row].substr(0, col); else if (row < text.size() - 1) D(), buf = \"\\n\"; }\n    void Y(){ if (!buf.empty()) { if (buf == \"\\n\") text.insert(text.begin() + row + 1, text[row].substr(col)); else text[row].insert(col, buf), col += buf.size(); }}\n    vector<string> text;\n    string buf;\n    int row, col;\n};\n\nint main()\n{\n    Emacs emacs;\n\n    string in;\n    while (getline(cin, in), in != \"END_OF_TEXT\") emacs.appendLine(in);\n\n    char cmd;\n    while (cin >> cmd, cmd != '-') emacs.execCommand(cmd);\n\n    emacs.showText();\n\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<string> buf;\nint row;\nint column;\nstring rem;\n\nmain(){\n  string in;\n  while(getline(cin, in)){\n    if(in == \"END_OF_TEXT\") break;\n    in += '\\n';\n    buf.push_back(in);\n  }\n  char c;\n  row = 0;\n  column = 0;\n  while(cin >> c){\n    if(c == '-') break;\n    switch(c){\n      case 'a':\n        column = 0;\n        break;\n      case 'e':\n        column = (int)buf[row].size()-1;\n        break;\n      case 'p':\n        column = 0;\n        if(row > 0) --row;\n        break;\n      case 'n':\n        column = 0;\n        if(row+1 < buf.size()) ++row;\n        break;\n      case 'f':\n        if(column+1 >= buf[row].size()){\n          if(row+1 < buf.size()){\n            column = 0;\n            ++row;\n          }\n        }else{\n          ++column;\n        }\n        break;\n      case 'b':\n        if(column == 0){\n          if(row > 0){\n            --row;\n            column = (int)buf[row].size()-1;\n          }\n        }else{\n          --column;\n        }\n        break;\n      case 'd':\n        if(column+1 == buf[row].size()){\n          if(row+1 != buf.size()){\n            buf[row].erase((int)buf[row].size()-1);\n            buf[row] += buf[row+1];\n            vector<string>::iterator ite = buf.begin();\n            for(int i=0;i<row+1;i++) ++ite;\n            buf.erase(ite);\n          }\n        }else{\n          buf[row].erase(column, 1);\n        }\n        break;\n      case 'k':\n        rem = \"\";\n        if(column+1 == buf[row].size()){\n          if(row+1 != buf.size()){\n            buf[row].erase((int)buf[row].size()-1);\n            buf[row] += buf[row+1];\n            vector<string>::iterator ite = buf.begin();\n            for(int i=0;i<row+1;i++) ++ite;\n            buf.erase(ite);\n            rem += '\\n';\n          }\n        }else{\n          for(int i=column;i+1<buf[row].size();++i){\n            rem += buf[row][i];\n          }\n          string::iterator ite = buf[row].begin();\n          for(int i=0;i<column;i++) ++ite;\n          buf[row].erase(ite, buf[row].end());\n          buf[row] += '\\n';\n        }\n        break;\n      case 'y':\n        if(rem.size() != 0){\n          int irem;\n          string back = buf[row].substr(column);\n          buf[row] = buf[row].substr(0, column);\n          for(irem = 0;irem<rem.size();irem++){\n            buf[row] += rem[irem];\n            ++column;\n            if(rem[irem] == '\\n'){\n              vector<string>::iterator ite = buf.begin();\n              for(int i=0;i<row+1;i++) ++ite;\n              buf.insert(ite, \"\");\n              column = 0;\n              ++row;\n            }\n          }\n          buf[row] += back;\n        }\n        break;\n    }\n  }\n  for(int i=0;i<buf.size();i++){\n    cout << buf[i];\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[110][1100];\nchar buf[1100];\nchar in[10];\nint main(){\n\tint n=0;\n\twhile(1){\n\t\tgets(str[n]);\n\t\tif(str[n][3]=='_')break;\n\t\tn++;\n\t}\n\tfor(int i=0;i<1100;i++)str[n][i]=0;\n\tint row=0;\n\tint col=0;\n\twhile(1){\n\t\tscanf(\"%s\",in);\n\t\tif(in[0]=='-')break;\n\t\tif(in[0]=='a')col=0;\n\t\tif(in[0]=='e'){\n\t\t\twhile(str[row][col]){\n\t\t\t\tcol++;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='p'){\n\t\t\tif(row)row--;\n\t\t\tcol=0;\n\t\t}\n\t\tif(in[0]=='n'){\n\t\t\tif(row<n-1)row++;\n\t\t\tcol=0;\n\t\t}\n\t\tif(in[0]=='f'){\n\t\t\tif(str[row][col])col++;\n\t\t\telse if(row<n-1){row++;col=0;}\n\t\t}\n\t\tif(in[0]=='b'){\n\t\t\tif(col)col--;\n\t\t\telse if(row){row--;col=0;\n\t\t\t\twhile(str[row][col])col++;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='d'){\n\t\t\tif(str[row][col]){\n\t\t\t\tfor(int i=col;str[row][i];i++)str[row][i]=str[row][i+1];\n\t\t\t}else if(row<n-1){\n\t\t\t\tfor(int i=0;str[row+1][i];i++){\n\t\t\t\t\tstr[row][col++]=str[row+1][i];\n\t\t\t\t\tstr[row+1][i]=0;\n\t\t\t\t}\n\t\t\t\tn--;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='k'){\n\t\t\tif(!str[row][col]){\n\t\t\t\tif(row<n-1){\n\t\t\t\t\tfor(int i=0;str[row+1][i];i++){\n\t\t\t\t\t\tstr[row][col++]=str[row+1][i];\n\t\t\t\t\t\tstr[row+1][i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tn--;\n\t\t\t\t\tbuf[0]='@';\n\t\t\t\t\tbuf[1]=0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint at=0;\n\t\t\t\tfor(int i=col;str[row][i];i++){\n\t\t\t\t\tbuf[at++]=str[row][i];\n\t\t\t\t\tstr[row][i]=0;\n\t\t\t\t}\n\t\t\t\tbuf[at]=0;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='y'){\n\t\t\tif(buf[0]){\n\t\t\t\tif(buf[0]=='@'){\n\t\t\t\t\tfor(int i=n-1;i>row;i--){\n\t\t\t\t\t\tfor(int j=0;j<1100;j++)str[i+1][j]=str[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tint at=0;\n\t\t\t\t\tfor(int i=col;str[row][i];i++){\n\t\t\t\t\t\tstr[row+1][at++]=str[row][i];\n\t\t\t\t\t\tstr[row][i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tstr[row+1][at]=0;\n\t\t\t\t\trow++;col=0;\n\t\t\t\t\tn++;\n\t\t\t\t}else{\n\t\t\t\t\tint sz=0;\n\t\t\t\t\tfor(int i=0;buf[i];i++)sz++;\n\t\t\t\t\tfor(int i=1109;i>=col;i--){\n\t\t\t\t\t\tif(i+sz>=1100)continue;\n\t\t\t\t\t\tstr[row][i+sz]=str[row][i];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0;i<sz;i++)str[row][col+i]=buf[i];\n\t\t\t\t\tcol+=sz;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)printf(\"%s\\n\",str[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[1024];\nstring buf;\nint lines;\nvoid delete_line(int y)\n{\n    for (int i = y; y < lines; ++y)\n\ts[i] = s[i + 1];\n    s[--lines] = \"\";\n    if (lines <= 0)\n\tlines = 1;\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; --i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    while (true)\n    {\n\tstring t;\n\tgetline(cin, t);\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines++] = t;\n    }\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    y = max(0, --y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    y = min(lines - 1, ++y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y + 1 != lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t\tx = 0, --y;\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t\ts[y].erase(x, 1);\n\t    else\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t    }\n\t    break;\n\t}\n\tcase 'k':\n\t{\n\t    if (x == s[y].size())\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    else if (!s[y].empty())\n\t    {\n\t\tbuf = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\ts[y + 1] = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = 0, ++y;\n\t    }\n\t    else if (!buf.empty())\n\t\ts[y] += buf;\n\t    break;\n\t}\n\t}\n    }\n\n    for (int i = 0; i < lines; ++i)\n\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\nvector<string> text;\nstring buf;\n\nint row, col;\n\nvoid func_a(){\n\tcol = 0;\n}\n\nvoid func_e(){\n\tcol = text[row].size() - 1;\n}\n\nvoid func_p(){\n\tif (row > 0) row--;\n\tfunc_a();\n}\n\nvoid func_n(){\n\tif (row < text.size() - 1) row++;\n\tfunc_a();\n}\n\nvoid func_f(){\n\tif (col < text[row].size() - 1) col++;\n\telse if (row < text.size() - 1){\n\t\tfunc_n();\n\t}\n}\n\nvoid func_b(){\n\tif (col > 0) col--;\n\telse if (row > 0){\n\t\tfunc_p();\n\t\tfunc_e();\n\t}\n}\n\nvoid func_d(){\n\tif (col < text[row].size() - 1) text[row].erase(col, 1);\n\telse if (row < text.size() - 1){\n\t\ttext[row].erase(text[row].end() - 1);\n\t\ttext[row] += text[row + 1];\n\t\ttext.erase(text.begin() + row + 1);\n\t}\n}\n\nvoid func_k(){\n\tif (col < text[row].size() - 1){\n\t\tbuf = text[row].substr(col, text[row].size() - col - 1);\n\t\ttext[row].erase(col, text[row].size() - 1);\n\t\tcol = text[row].size() - 1;\n\t}\n\telse if (row < text.size() - 1){\n\t\tfunc_d();\n\t\tbuf = \"\\n\";\n\t}\n}\n\nvoid func_y(){\n\tif (!buf.empty()){\n\t\tif (buf == \"\\n\"){\n\t\t\ttext.insert(text.begin() + row + 1, text[row].substr(col, text[row].size() - 1));\n\t\t\ttext[row].erase(col, text[row].size() - 1);\n\t\t\ttext[row] += '$';\n\t\t}\n\t\telse {\n\t\t\ttext[row].insert(col, buf);\n\t\t\tcol += buf.size();\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstring in;\n\tchar cmd;\n\n\twhile (getline(cin, in), in != \"END_OF_TEXT\"){\n\t\ttext.push_back(in + '$');\n\t}\n\t\n\tcol = row = 0;\n\tbuf.clear();\n\n\twhile (cin >> cmd, cmd != '-'){\n\t\tswitch (cmd){\n\t\t  case 'a': func_a(); break;\n\t\t  case 'e':\tfunc_e(); break;\n\t\t  case 'p':\tfunc_p(); break;\n\t\t  case 'n': func_n(); break;\n\t\t  case 'f': func_f(); break;\n\t\t  case 'b':\tfunc_b(); break;\n\t\t  case 'd':\tfunc_d(); break;\n\t\t  case 'k': func_k(); break;\n\t\t  case 'y': func_y(); break;\n\t\t}\n#if 0\n\t\tprintf(\"col:%d row:%d\\n\", col, row);\n\t\tputs(\"status:\");\n\t\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\t\tcout << *it << endl;\n\t\t}\n\t\tputs(\"buffer:\");\n\t\tcout << buf << endl;\n#endif\n\t}\n\n\t\n\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\tcout << it->substr(0, it->size() - 1) << endl;\n\t}\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nchar t[100][1000];\nint h;\nint w[100];\n\nchar tmp[100];\nint tmp_size;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nint main(){\n\n  input();\n  x=y=tmp_size=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n    //cout<<y<<' '<<x<<\" ty\"<<t.size()<<endl;\n  }\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w[i];j++){\n      cout<<t[i][j];\n    }\n    cout<<endl;\n  }\n  \n  return 0;\n}\n\nvoid funcA(){x=0;}\nvoid funcE(){x=w[y];}\nvoid funcP(){ if(y>0)y--; x=0; }\nvoid funcN(){ if(y+1<h)y++; x=0; }\nvoid funcF(){ \n  if(x<w[y])x++;\n  else if(y+1<h){y++;x=0;}\n}\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=w[y];}\n}\nvoid funcD(){\n  if(x<w[y]){\n    w[y]--;\n    for(int i=x;i<w[y];i++)t[y][i]=t[y][i+1];\n    return;\n  }\n  if(y+1==h)return;\n  for(int i=0;i<w[y+1];i++)t[y][w[y]+i]=t[y+1][i];\n  w[y]+=w[y+1];\n  h--;\n  for(int i=y+1;i<h;i++){\n    w[i]=w[i+1];\n    for(int j=0;j<w[i];j++){\n      t[i][j]=t[i+1][j];\n    }\n  }\n}\n\nvoid funcK(){\n  if(x==w[y]){\n    if(y+1<h){\n      funcD();\n      tmp[0]='\\n';\n      tmp_size=1;\n    }\n  }else{\n    tmp_size=0;\n    for(int i=x;i<w[y];i++)\n      tmp[tmp_size++]=t[y][i];\n    w[y]=x;\n  }\n}\n\nvoid funcY(){\n  if(tmp_size==0)return;\n  if(tmp[0]!='\\n'){\n    w[y]+=tmp_size;\n    for(int i=w[y]-1;i>=x+tmp_size;i--)\n      t[y][i]= t[y][ i-tmp_size ];\n    for(int i=x;i<x+tmp_size;i++)\n      t[y][i]=tmp[i-x];\n    return;\n  }\n  \n  h++;\n  for(int i=h-1;i>y+1;i--){\n    w[i]=w[i-1];\n    for(int j=0;j<w[i];j++)\n      t[i][j]=t[i-1][j];\n  }\n\n  w[y+1]=w[y]-x;\n  for(int i=0;i<w[y+1];i++){\n    t[y+1][i]=t[y][i+x];\n  }\n  w[y]=x;\n  y++;\n  x=0;\n}\n\nvoid input(){\n  string str;\n  h=0;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    w[h]=str.size();\n    for(int i=0;i<(int)str.size();i++)\n      t[h][i]=str[i];\n    h++;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvoid escape(string &s)\n{\n  if (s.find_first_of(\"\\n\") != string::npos)\n    s.erase(s.end()-1);\n  if (s.find_first_of(\"\\r\") != string::npos)\n    s.erase(s.end()-1);\n}\n\nint main()\n{\n  string s;\n  vector<string> line;\n  while (getline(cin, s)) {\n    escape(s);\n    if (s == \"END_OF_TEXT\")\n      break;\n    line.push_back(s);\n  }\n\n  int x = 0, y = 0;\n  string buffer = \"\";\n  while (cin >> s) {\n    if (s == \"-\")\n      break;\n\n    if (s == \"a\") {\n      x = 0;\n    } else if (s == \"e\") {\n      x = line[y].size();\n    } else if (s == \"p\") {\n      x = 0;\n      if (y > 0)\n\t--y;\n    } else if (s == \"n\") {\n      x = 0;\n      if (y != line.size()-1)\n\t++y;\n    } else if (s == \"f\") {\n      if (x < line[y].size()) {\n\t  ++x;\n      } else if (y != line.size()-1) {\n\tx = 0;\n\t++y;\n      }\n    } else if (s == \"b\") {\n      if (x > 0) {\n\t--x;\n      } else if (y > 0) {\n\tx = 0;\n\t--y;\n      }\n    } else if (s == \"d\") {\n      if (x < line[y].size()) {\n\tline[y].erase(x, 1);\n      } else if (y != line.size()-1) {\n\tline[y] += line[y+1];\n\tline.erase(line.begin()+y+1);\n      }\n    } else if (s == \"k\") {\n      if (x >= line[y].size() && y != line.size()-1) {\n\tline[y] += line[y+1];\n\tline.erase(line.begin()+y+1);\n\tbuffer = \"\\n\";\n      } else if (x < line[y].size()) {\n\tbuffer = line[y].substr(x);\n\tline[y].erase(x);\n      }\n    } else if (s == \"y\" && buffer != \"\") {\n      if (buffer == \"\\n\") {\n\tbuffer = line[y].substr(x);\n\tline[y].erase(x);\n\tline.insert(line.begin()+y+1, buffer);\n\tx = 0;\n\t++y;\n      } else {\n\tline[y].insert(x, buffer);\n\tx += buffer.size();\n      }\n    }\n  }\n  \n  for (unsigned int i = 0; i < line.size(); ++i)\n    cout << line[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\nvector<string> text;\nstring buf;\n\nint row, col;\n\nvoid func_a(){\n\tcol = 0;\n}\n\nvoid func_e(){\n\tcol = text[row].size() - 1;\n}\n\nvoid func_p(){\n\tif (row > 0) row--;\n\tfunc_a();\n}\n\nvoid func_n(){\n\tif (row < text.size() - 1) row++;\n\tfunc_a();\n}\n\nvoid func_f(){\n\tif (col < text[row].size() - 1) col++;\n\telse func_n();\n}\n\nvoid func_b(){\n\tif (col > 0) col--;\n\telse if (row > 0){\n\t\tfunc_p();\n\t\tfunc_e();\n\t}\n}\n\nvoid func_d(){\n\tif (col < text[row].size() - 1) text[row].erase(col, 1);\n\telse if (row < text.size() - 1){\n\t\ttext[row].erase(text[row].end() - 1);\n\t\ttext[row] += text[row + 1];\n\t\ttext.erase(text.begin() + row + 1);\n\t}\n}\n\nvoid func_k(){\n\tif (col < text[row].size() - 1){\n\t\tbuf = text[row].substr(col, text[row].size() - col - 1);\n\t\ttext[row].erase(col, text[row].size() - 1);\n\t\tcol = text[row].size() - 1;\n\t}\n\telse if (row < text.size() - 1){\n\t\tfunc_d();\n\t\tbuf = \"\\n\";\n\t}\n}\n\nvoid func_y(){\n\tif (!buf.empty()){\n\t\tif (buf == \"\\n\"){\n\t\t\ttext.insert(text.begin() + row + 1, text[row].substr(col, text[row].size() - 1));\n\t\t\ttext[row].erase(col, text[row].size() - 1);\n\t\t\ttext[row] += '$';\n\t\t}\n\t\telse {\n\t\t\ttext[row].insert(col, buf);\n\t\t\tcol += buf.size();\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstring in;\n\tchar cmd;\n\n\twhile (getline(cin, in), in != \"END_OF_TEXT\"){\n\t\ttext.push_back(in + '$');\n\t}\n\t\n\tcol = row = 0;\n\tbuf.clear();\n\n\twhile (cin >> cmd, cmd != '-'){\n\t\tswitch (cmd){\n\t\t  case 'a': func_a(); break;\n\t\t  case 'e':\tfunc_e(); break;\n\t\t  case 'p':\tfunc_p(); break;\n\t\t  case 'n': func_n(); break;\n\t\t  case 'f': func_f(); break;\n\t\t  case 'b':\tfunc_b(); break;\n\t\t  case 'd':\tfunc_d(); break;\n\t\t  case 'k': func_k(); break;\n\t\t  case 'y': func_y(); break;\n\t\t}\n#if 0\n\t\tprintf(\"col:%d row:%d\\n\", col, row);\n\t\tputs(\"status:\");\n\t\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\t\tcout << *it << endl;\n\t\t}\n\t\tputs(\"buffer:\");\n\t\tcout << buf << endl;\n#endif\n\t}\n\n\t\n\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\tcout << it->substr(0, it->size() - 1) << endl;\n\t}\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[110];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tif(i<110) t[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tif(row<110) col = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 && row < 110 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row < 110 && row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( row < 110 && col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else if( row < 110 ){\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( row < 110 && buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line+1 < 110 && line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\tt[row+1] = t[row].substr( col );\n\t\t\t\t\tt[row].erase( col );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}/*else if( row < 110 ){\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}*/\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[1024];\nstring buf;\nint lines;\nvoid delete_line(int y)\n{\n    for (int i = y; y < lines; ++y)\n\ts[i] = s[i + 1];\n    s[--lines] = \"\";\n    if (lines <= 0)\n\tlines = 1;\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; ++i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    while (true)\n    {\n\tstring t;\n\tgetline(cin, t);\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines++] = t;\n    }\n    if (lines == 0)\n    {\n\tcout << \"\" << endl;\n\treturn 0;\n    }\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    y = max(0, --y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    y = min(lines - 1, ++y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y + 1 != lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t\tx = 0, --y;\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t    {\n\t\tif (x < s[y].size())\n\t\t{\n\t\t    s[y].erase(x, 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t    s[y] += s[y + 1];\n\t\t    delete_line(y + 1);\n\t\t}\n\t    }\n\t    break;\n\t \n\t}\n\tcase 'k':\n\t{\n\t    if (x == s[y].size())\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    else if (!s[y].empty())\n\t    {\n\t\tif (x < s[y].size())\n\t\t{\n\t\t    buf = s[y].substr(x);\n\t\t    s[y].erase(x);\n\t\t}\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\tif (!s[y].empty())\n\t\t{\n\t\t    if (x < s[y].size())\n\t\t    {\n\t\t\ts[y + 1] = s[y].substr(x);\n\t\t\ts[y].erase(x);\n\t\t    }\n\t\t}\n\t\tx = 0, ++y;\n\t    }\n\t    else if (!buf.empty())\n\t\ts[y] += buf;\n\t    break;\n\t}\n\t}\n\n\ty = max(0, y);\n\tx = max(0, min(x, (int)s[y].size()));\n    }\n\n    for (int i = 0; i < lines; ++i)\n\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY = 0;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\tposY++;\n\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n}\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\\n\";\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX);\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX+1);\n\n\t\tlines[posY] = front;\n\t\tdeque<string>::iterator it = lines.begin();\n\t\tadvance(it,posY);\n\t\tlines.insert(it,rear);\n\t}\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\n\tdeque<string> lines;\n\tstring str;\n\twhile(cin >> str){\n\t\tposX = 0;\n\t\tposY = 0;\n\t\tif(str == \"END_OF_TEXT\") {\n\t\t\twhile(cin >> str){\n\t\t\t\tif(str == \"-\") break;\n\t\t\t\tif(str == \"a\") ctrl_a(lines);\n\t\t\t\tif(str == \"e\") ctrl_e(lines);\n\t\t\t\tif(str == \"p\") ctrl_p(lines);\n\t\t\t\tif(str == \"n\") ctrl_n(lines);\n\t\t\t\tif(str == \"f\") ctrl_f(lines);\n\t\t\t\tif(str == \"b\") ctrl_b(lines);\n\t\t\t\tif(str == \"d\") ctrl_d(lines);\n\t\t\t\tif(str == \"k\") ctrl_k(lines);\n\t\t\t\tif(str == \"y\") ctrl_y(lines);\n\t\t\t\tprintf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t\t\t}\n\n\t\t\tfor(int i=0;i<lines.size();i++){\n\t\t\t\tcout << lines[i] << \"\\n\";\n\t\t\t}\n\n\t\t}\n\t\telse{\n\t\t\tlines.push_back(str);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n&#160;\nusing namespace std;\n&#160;\nint main(){\n&#160;&#160;&#160;&#160;string str[1000];\n&#160;&#160;&#160;&#160;string s;\n&#160;&#160;&#160;&#160;int size = 0;\n&#160;&#160;&#160;&#160;while(getline(cin,s)){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(s == \"END_OF_TEXT\") break;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;str[size++] = s;\n&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;char ch;\n&#160;&#160;&#160;&#160;string buf = \"\";\n&#160;&#160;&#160;&#160;int line = 0, pos = 0;\n&#160;&#160;&#160;&#160;while(cin >> ch){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(ch == '-') break;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(ch == 'a') pos = 0;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(ch == 'e') pos = str[line].size();\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(ch == 'p'){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pos = 0;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(line!=0) line--;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(ch == 'n'){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pos = 0;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(line+1!=size) line++;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(ch == 'f'){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(pos != str[line].size()) pos++;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if(line+1!=size) { pos = 0; line++; }\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(ch == 'b'){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(pos != 0) pos--;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if(line!=0) { line--; pos = str[line].size(); }\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(ch == 'd'){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(pos != str[line].size()){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;str[line] = str[line].substr(0,pos) + str[line].substr(pos+1);\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else if(line+1!=size){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;str[line] = str[line] + str[line+1];\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(int i=line+1;i+1<size;i++){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;str[i] = str[i+1];\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;str[size-1] = \"\";\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size--;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(ch == 'k'){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(pos == str[line].size() && line+1!=size){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;str[line] = str[line] + str[line+1];\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(int i=line+1;i+1<size;i++){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;str[i] = str[i+1];\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;str[size-1] = \"\";\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size--;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;buf = \"IS_BREAK_LINE\";\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if(pos < str[line].size()){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;buf = str[line].substr(pos);\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;str[line] = str[line].substr(0,pos);\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(ch == 'y'){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(buf == \"IS_BREAK_LINE\"){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(int i=size-1;i>=line+1;i--){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;str[i+1] = str[i];\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size++;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;str[line+1] = str[line].substr(pos);\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;str[line] = str[line].substr(0,pos);\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;line++;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pos = 0;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else if(buf != \"\"){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;str[line] = str[line].substr(0,pos) + buf + str[line].substr(pos);\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pos += buf.size();\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/*\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout << line << \" \" << pos << endl;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(int i=0;i<size;i++){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout << str[i] << endl; \n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;puts(\"\");\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*/\n&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;for(int i=0;i<size;i++){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout << str[i] << endl;\n&#160;&#160;&#160;&#160;}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <string>\n#include <algorithm>\n\n#define DEBUG 0\n#define fprintf(...) (void)0\n\nint main() {\n  std::list<std::string> input;\n  while (true) {\n    char buf[24];\n    fgets(buf, sizeof buf, stdin);\n    std::string line=buf;\n    if (line == \"END_OF_TEXT\\n\")\n      break;\n\n    assert(line.back() == '\\n');\n    input.emplace_back(line);\n  }\n\n  std::string kbuf=\"\";\n  std::list<std::string>::iterator it=input.begin();\n  size_t cc=0;\n  while (true) {\n    char op;\n    scanf(\" %c\", &op);\n    if (op == '-')\n      break;\n\n    switch (op) {\n    case 'a':\n      cc = 0;\n      break;\n\n    case 'e':\n      cc = it->size()-1;\n      break;\n\n    case 'p':\n      cc = 0;\n      if (it != input.begin())\n        --it;\n      break;\n\n    case 'n':\n      cc = 0;\n      {\n        auto tmp=it;\n        ++tmp;\n        if (tmp != input.end())\n          it = tmp;\n      }\n      break;\n\n    case 'f':\n      if (cc+1 < it->size()) {\n        ++cc;\n      } else {\n        auto tmp=it;\n        ++tmp;\n        if (tmp != input.end()) {\n          cc = 0;\n          it = tmp;\n        }\n      }\n      break;\n\n    case 'b':\n      if (cc > 0) {\n        --cc;\n      } else if (it != input.begin()) {\n        --it;\n        cc = it->size()-1;\n      }\n      break;\n\n    case 'd':\n      if (cc == it->size()) {\n        assert((*it)[cc] == '\\n');\n        {\n          auto tmp=it;\n          ++tmp;\n          if (tmp != input.end()) {\n            it->pop_back();\n            *it += *tmp;\n            input.erase(tmp);\n          }\n        }\n      } else {\n        // TLE?\n        std::string t=it->substr(0, cc);\n        t += it->substr(cc+1);\n        *it = t;\n      }\n      break;\n\n    case 'k':\n      if (cc == it->size()) {\n        assert((*it)[cc] == '\\n');\n        {\n          auto tmp=it;\n          ++tmp;\n          if (tmp != input.end()) {\n            it->pop_back();\n            *it += *tmp;\n            input.erase(tmp);\n          }\n        }\n        kbuf = \"\\n\";\n      } else {\n        kbuf = it->substr(cc);\n        assert(kbuf.back() == '\\n');\n        kbuf.pop_back();  // '\\n'\n        fprintf(stderr, \"kill buffer: %s\\n\", kbuf.c_str());\n        if (cc > 0) {\n          *it = it->substr(0, cc-1);\n          *it += '\\n';\n        } else {\n          *it = \"\\n\";\n        }\n        //cc = it->size()-1;\n      }\n      break;\n\n    case 'y':\n      if (kbuf.empty()) break;\n\n      if (kbuf == \"\\n\") {\n        ++it;\n        input.emplace(it, \"\\n\");\n        --it;  // ??\n        cc = 0;\n      } else {\n        {\n          std::string t=\"\";\n          if (cc > 0) {\n            t += it->substr(0, cc);\n          }\n          t += kbuf;\n          //t.pop_back();\n          t += it->substr(cc);\n          *it = t;\n        }\n      }\n      break;\n    }\n\n    if (DEBUG) {\n      fprintf(stderr, \"%c: L%td C%zu\\n\", op, std::distance(input.begin(), it), cc);\n      for (const auto &s: input)\n        printf(\"%s\", s.c_str());  // s ~ \".*\\n\"\n    }\n  }\n\n  for (const auto &s: input)\n    printf(\"%s\", s.c_str());  // s ~ \".*\\n\"\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nint main()\n{\n\tstring str[300];\n\tstring b;\n\tb[0] = '*';\n\tint y = 0, y2 = 0;\n\t\n\twhile (getline(std::cin, str[y]), str[y] != \"END_OF_TEXT\"){\n\t\ty++;\n\t}\n\ty2 = --y;\n\t\n\tchar cmd[2];\n\tint car = 0, car_y = 0;\n\t\n\twhile (scanf(\"%s\", cmd), cmd[0] != '-'){\n\t\tif (cmd[0] == 'a'){\n\t\t\tcar = 0;\n\t\t}\n\t\tif (cmd[0] == 'e'){\n\t\t\tcar = str[car_y].size();\n\t\t}\n\t\tif (cmd[0] == 'p'){\n\t\t\tif (car_y == 0){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y--;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'n'){\n\t\t\tif (car_y != y){\n\t\t\t\tcar_y++;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\t\n\t\t\telse {\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'f'){\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tcar++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tcar_y++;\n\t\t\t\t\tcar = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'b'){\n\t\t\tif (car != 0){\n\t\t\t\tcar--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != 0){\n\t\t\t\t\tcar_y--;\n\t\t\t\t\tcar = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'd'){\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tstr[car_y].erase(car, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = y - 1;\n\t\t\t\t\ty = car_y;\n\t\t\t\t\twhile (++y < y2){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y].erase();\n\t\t\t\t\t\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'k'){\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = y;\n\t\t\t\t\ty = car_y;\n\t\t\t\t\twhile (++y < y2){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y].erase();\n\t\t\t\t\t\n\t\t\t\t\ty = y2;\n\t\t\t\t\tb[0] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb = str[car_y].substr(car);\n\t\t\t\tstr[car_y].erase(car);\n\t\t\t\tcar = str[car_y].size();\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'y'){\n\t\t\tif(b[0] != '*'){\n\t\t\t\tif (b[0] == '\\0'){\n\t\t\t\t\ty2 = y + 1;\n\t\t\t\t\twhile (y > car_y + 1){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y] = str[car_y].substr(car);\n\t\t\t\t\tstr[car_y].erase(car);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstr[car_y].insert(car, b);\n\t\t\t\t\tcar += b.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int j = 0; j <= y; j++){\n\t\tcout << str[j] << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t,u;\nvector<char> tmp;\n\nchar ch;\nint x,y;\n\nbool input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nint main(){\n  while(1){\n    t.clear();\n    tmp.clear();\n    if(input()==false)break;\n    x=y=0;\n    while(1){\n      \n      cin>>ch;\n      if(ch=='a')funcA();\n      else if(ch=='e')funcE();\n      else if(ch=='p')funcP();\n      else if(ch=='n')funcN();\n      else if(ch=='f')funcF();\n      else if(ch=='b')funcB();\n      else if(ch=='d')funcD();\n      else if(ch=='k')funcK();\n      else if(ch=='y')funcY();\n      else break;\n      \n    }\n    u=t;\n    t=u;\n    for(int i=0;i<t.size();i++){\n      for(int j=0;j<t[i].size();j++){\n\tcout<<t[i][j];\n      }\n    }\n  }\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    t[y].erase(t[y].begin()+x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  t[y].erase(t[y].begin()+x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  t.erase(t.begin()+y+1);\n}\n\nvoid funcK(){\n  tmp.clear();\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.push_back('\\n');\n    }\n    return;\n  }\n  int c=0;\n  for(int i=x;i+1<(int)t[y].size();i++){\n    tmp.push_back(t[y][i]);\n    c++;\n  }\n  for(int i=0;i<=c;i++)t[y].pop_back();\n  t[y].push_back('\\n');\n  reverse(tmp.begin(),tmp.end());\n}\n\nvoid funcY(){\n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    vector<char> z;\n    int c=0;\n    for(int i=x;i<(int)t[y].size();i++){\n      z.push_back(t[y][i]);\n      c++;\n    }\n    for(int i=0;i<=c;i++)t[y].pop_back();\n    t[y].push_back('\\n');\n    t.insert(t.begin()+y+1,z);\n    y++;\n    x=0;\n    return;\n  }\n\n  for(int i=0;i<(int)tmp.size();i++){\n    t[y].insert(t[y].begin()+x,tmp[i]);\n  }\n  funcE();\n\n}\n\nbool input(){\n  vector<char> a;\n  string str;\n  while(1){\n    if(getline(cin,str)==false)return false;\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n  return true;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[111];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\tfor(int i=0 ; i<111 ; i++)\n\t\tt[i] = \"\";\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tif(i<110) t[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tif(row<110) col = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 && row < 110 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row < 110 && row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( row < 110 && col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else if( row < 110 ){\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( row < 110 && buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line+1 < 110 && line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\tt[row+1];\n\t\t\t\t\t//t[row+1] =\n\t\t\t\t\t//if( col != t[row].size() ) t[row];//.substr( col );\n\t\t\t\t\t//if(col != t[row].size() ) t[row].erase( 0 );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else if( row < 110 ){\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t,u;\nvector<char> tmp;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nint main(){\n\n  t.clear();\n  tmp.clear();\n  input();\n  x=y=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n    //cout<<y<<' '<<x<<\" ty\"<<t.size()<<endl;\n  }\n\n  for(int i=0;i<t.size();i++){\n    for(int j=0;j<t[i].size();j++){\n      cout<<t[i][j];\n    }\n  }\n\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    t[y].erase(t[y].begin()+x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  t[y].erase(t[y].begin()+x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  t.erase(t.begin()+y+1);\n}\n\nvoid funcK(){\n  tmp.clear();\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.push_back('\\n');\n    }\n  }\n}\n\nvoid funcY(){\n\n\n}\n\nvoid input(){\n  vector<char> a;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nint main(){\n  string s;\n  vector<string> v;\n  char command;\n\n  while( true ){\n    getline( cin,s );\n    if( s==\"END_OF_TEXT\" ) break;\n    v.push_back( s );\n  }\n\n  unsigned int line=0, c=0;\n  string buf=\"\";\n  bool RE = false;\n  while( cin>>command && c!='-' ){\n    switch( command ){\n    case 'a': c=0;      break;\n    case 'e': c=v[line].length();      break;\n    case 'p': if( line>0 ) line--;  c=0;      break;\n    case 'n': if( line+1<v.size() )line++; c=0;      break;\n    case 'f':\n      if( c<v[line].length() ) ++c;\n      else if( line+1<v.size() ){line++;c=0;  }      break;\n    case 'b':\n      if( c>0 ) --c;\n      else if( line>0 ){ --line; c=v[line].length(); }     break;\n    case 'd':\n      if( c<v[line].length() ) v[line].erase( c,1 );\n      else if( line+1<v.size() ){\n\tv[line] = v[line] + v[line+1];\n\tv.erase( v.begin()+line+1 );\n      }\n      break;\n    case 'k':\n      if( c==v[line].length() ){\n\tif( line+1<v.size() ){\n\t  v[line] = v[line] + v[line+1];\n\t  v.erase( v.begin()+line+1 );\n\t  buf=\"\"; RE=true;\n\t}\n      }else{\n\tbuf = v[line].substr( c ); RE=false;\n\tv[line] = v[line].substr( 0,c );\n      }\n      break;\n    case 'y':\n      if( RE ){\n\tbuf = v[line].substr( c );\n\tv[line] = v[line].substr( 0,c );\n\tv.insert( v.begin()+line+1, buf );\n\tbuf=\"\"; c=0;line++;\t\n      }else if( buf!=\"\" ){\n\tif( c<v[line].length() )\n\t  v[line] = v[line].substr( 0,c ) + buf + v[line].substr( c );\n\telse\n\t  v[line] = v[line] + buf;\n\tc += buf.length();\n      }\n    }\n  }\n\n  for( unsigned int i=0;i<v.size();i++ )\n    cout << v[i] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nstring s[102],buf;\nint l,r,N;\n\nvoid a(void){r=0;}\n\tvoid e(void){r=max(0,(int)s[l].size()-1);}\nvoid p(void){\n\tif(l>0)l--;\n\telse r=0;\n}\n\nvoid n(void){\n\tif(l<N-1)l++,r=0;\n\telse r=0;\n}\n\nvoid f(void){\n\tif(r<s[l].size()-1)r++;\n\telse l++,r=0;\n}\n\nvoid b(void){\n\tif(r>0)r--;\n\telse if(l>0)r=s[--l].size();\n}\n\nvoid d(void){\n\tif(r==s[l].size()-1){\n\t\tif(l<N-1){\n\t\t\ts[l]+=s[l+1];\n\t\t\tfor(int i=l+1;i<N-1;i++)s[i]=s[i+1];\n\t\t\tN--;\n\t\t}\n\t}\n\telse s[l].erase(r,1);\n}\n\nvoid k(void){\n\tif(r==s[l].size() && l<N-1)d(),buf=\"\\n\";\n\telse {\n\t\tbuf=s[l].substr(max(0,r-1));\n\t\ts[l].erase(max(0,r-1));\n\t}\n}\n\nvoid y(void){\n\tif(buf.empty())return ;\n\tif(buf==\"\\n\"){\n\t\tfor(int i=N;i>l;i--)s[i]=s[i-1];\n\t\ts[l+1]=s[l].substr(max(0,r-1));\n\t\ts[l].erase(max(0,r-1));\n\t\tl++,r=0,N++;\n\t}\n\telse {\n\t\ts[l].insert(min((int)s[l].size(),r+1),buf);\n\t\tr+=buf.size();\n\t}\n}\n\n\nint main(void){\n\t\n\twhile(getline(cin,s[N])){\n\t\tif(s[N]==\"END_OF_TEXT\")break;\n\t\tN++;\n\t}\n\tl=r=0;\n\tbuf.clear();\n\t\n\t\t\n\tstring C;\n\twhile(cin >> C,C!=\"-\"){\n\t\t\n\t\tif(C==\"a\")a();\n\t\telse if(C==\"e\")e();\n\t\telse if(C==\"p\")p();\n\t\telse if(C==\"n\")n();\n\t\telse if(C==\"f\")f();\n\t\telse if(C==\"b\")b();\n\t\telse if(C==\"d\")d();\n\t\telse if(C==\"k\")k();\n\t\telse if(C==\"y\")y();\n\t}\n\t\n\tfor(int i=0;i<N;i++){\n\t\tcout << s[i] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n\n\n\nint main(){\t\n\tvector<string> text;\n\tstring line;\n\tstring buf;\n\twhile(getline(cin,line)&&line!=\"END_OF_TEXT\"){\n\t\ttext.push_back(line);\n\t}\n\tchar com;\n\tint row=0,col=0;\n\twhile(cin>>com&&com!='-'){\n\t\tswitch(com){\n\t\tcase 'a':\n\t\t\tcol=0;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tcol=text[row].size();\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif(row)row--;\n\t\t\tcol=0;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tif(row+1<text.size())row++;\n\t\t\tcol=0;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tif(col<text[row].size())col++;\n\t\t\telse if(row+1<text.size())row++,col=0;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif(col)col--;\n\t\t\telse if(row){\n\t\t\t\trow--;\n\t\t\t\tcol=text[row].size();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif(col<text[row].size())text[row].erase(col,1);\n\t\t\telse if(row+1<text.size()){\n\t\t\t\ttext[row]+=text[row+1];\n\t\t\t\ttext.erase(text.begin()+row+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tif(col==text[row].size()){\n\t\t\t\tif(row+1<text.size()){\n\t\t\t\t\ttext[row]+=text[row+1];\n\t\t\t\t\ttext.erase(text.begin()+row+1);\n\t\t\t\t\tbuf=\"\\n\";\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tbuf=text[row].substr(col);\n\t\t\t\ttext[row].erase(col);\n\t\t\t\tcol=text[row].size();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tif(buf==\"\\n\"){\n\t\t\t\ttext.insert(text.begin()+row+1,text[row].substr(col));\n\t\t\t\ttext[row].erase(col);\n\t\t\t\trow++;\n\t\t\t\tcol=0;\n\t\t\t}else if(!buf.empty()){\n\t\t\t\ttext[row].insert(col,buf);\n\t\t\t\tcol+=buf.size();\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<text.size();i++)cout<<text[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1021\n#include<iostream>\n#include<vector>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\nconst int LMAX = 1000;\n\nvector<string> lines;\nint h, w;\nstring buffer;\n\nbool on_tail() { return w == lines[h].size(); }\nvoid goto_tail() { w = lines[h].size(); }\nbool on_eof() { return h >= lines.size() - 1; }\nvoid remove_line(int n) { lines.erase(lines.begin() + n); }\nvoid remove_char(int h, int w) {\n  lines[h].erase(lines[h].begin() + w);\n}\n\nvoid a() { w = 0; }\nvoid e() { goto_tail(); }\nvoid p() { h = (h > 0 ? h - 1 : 0); w = 0; }\nvoid n() { h = (on_eof() ? h : h + 1); w = 0; }\nvoid f() {\n  if (not on_tail()) { w++; }\n  else if (not on_eof()) {\n    h++; w = 0;\n  }\n}\nvoid b() {\n  if (w > 0) { w--; }\n  else if (h > 0) { h--; goto_tail(); }\n}\nvoid d() {\n  if (on_tail() and !on_eof()) {\n    lines[h] += lines[h + 1];\n    remove_line(h + 1);\n  } else if (not on_tail()) {\n    remove_char(h, w);\n  }\n}\nvoid k() {\n  if (on_tail() and !on_eof()) {\n    d();\n    buffer = \"\\n\";\n  } else if (not on_tail()) {\n    buffer = lines[h].substr(w);\n    lines[h] = lines[h].substr(0, w);\n  }\n}\nvoid y() {\n  if (buffer == \"\\n\") {\n    lines.insert(lines.begin() + h, \"\\n\");\n    h++; w = 0;\n  } else if (not buffer.empty()) {\n    lines[h].insert(lines[h].begin()+w, buffer.begin(), buffer.end());\n    w += buffer.size();\n  }\n}\n\nint main() {\n  string l;\n  buffer = \"\";\n  while (cin >> l and l != \"END_OF_TEXT\") {\n    lines.push_back(l);\n  }\n\n  char com;\n  while (cin >> com and com != '-') {\n    switch (com) {\n    case 'a':\n      a(); break;\n    case 'e':\n      e(); break;\n    case 'p':\n      p(); break;\n    case 'n':\n      n(); break;\n    case 'f':\n      f(); break;\n    case 'b':\n      b(); break;\n    case 'd':\n      d(); break;\n    case 'k':\n      k(); break;\n    case 'y':\n      y(); break;\n    default:\n      break;\n    }\n/*    REP(i, lines.size()) {\n      cout << \">\" << lines[i] << endl;\n    }\n    cout << \"(\" << h << \",\" << w << \")\" << endl;\n*/  }\n\n  for (int i = 0; i < lines.size(); i++) {\n    cout << lines[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n\tvector<string> lines;\n\tstring cmds;\n\tfor(string s;getline(cin,s),s!=\"END_OF_TEXT\";)\n\t\tlines.push_back(s);\n\tfor(char c;cin>>c,c!='-';)\n\t\tcmds+=c;\n\t\n\tint i=0,j=0;\n\tstring buf;\n\tfor(char c:cmds){\n\t\tif(c=='a')\n\t\t\tj=0;\n\t\telse if(c=='e')\n\t\t\tj=lines[i].size();\n\t\telse if(c=='p'){\n\t\t\tif(i>0)\n\t\t\t\ti--;\n\t\t\tj=0;\n\t\t}\n\t\telse if(c=='n'){\n\t\t\tif(i+1<lines.size())\n\t\t\t\ti++;\n\t\t\tj=0;\n\t\t}\n\t\telse if(c=='f'){\n\t\t\tif(j<lines[i].size())\n\t\t\t\tj++;\n\t\t\telse if(i+1<lines.size()){\n\t\t\t\ti++;\n\t\t\t\tj=0;\n\t\t\t}\n\t\t}\n\t\telse if(c=='b'){\n\t\t\tif(j>0)\n\t\t\t\tj--;\n\t\t\telse if(i>0){\n\t\t\t\ti--;\n\t\t\t\tj=lines[i].size();\n\t\t\t}\n\t\t}\n\t\telse if(c=='d'){\n\t\t\tif(j<lines[i].size())\n\t\t\t\tlines[i].erase(j,1);\n\t\t\telse if(i+1<lines.size()){\n\t\t\t\tlines[i]+=lines[i+1];\n\t\t\t\tlines.erase(lines.begin()+i+1);\n\t\t\t}\n\t\t}\n\t\telse if(c=='k'){\n\t\t\tif(j<lines[i].size()){\n\t\t\t\tbuf=lines[i].substr(j);\n\t\t\t\tlines[i].erase(j);\n\t\t\t}\n\t\t\telse if(i+1<lines.size()){\n\t\t\t\tbuf=\"\\n\";\n\t\t\t\tlines[i]+=lines[i+1];\n\t\t\t\tlines.erase(lines.begin()+i+1);\n\t\t\t}\n\t\t}\n\t\telse if(c=='y'){\n\t\t\tif(buf==\"\\n\"){\n\t\t\t\tlines.insert(lines.begin()+i+1,lines[i].substr(j));\n\t\t\t\tlines[i].erase(j);\n\t\t\t\ti++;\n\t\t\t\tj=0;\n\t\t\t}\n\t\t\telse if(buf.size()){\n\t\t\t\tlines[i].insert(j,buf);\n\t\t\t\tj+=buf.size();\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<lines.size();i++)\n\t\tcout<<lines[i]<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\nvector<string> text;\nstring buf;\n\nint row, col;\n\nvoid func_a(){\n\tcol = 0;\n}\n\nvoid func_e(){\n\tcol = text[row].size() - 1;\n}\n\nvoid func_p(){\n\tif (row > 0) row--;\n\tfunc_a();\n}\n\nvoid func_n(){\n\tif (row < text.size() - 1) row++;\n\tfunc_a();\n}\n\nvoid func_f(){\n\tif (col < text[row].size() - 1) col++;\n\telse if (row < text.size() - 1){\n\t\tfunc_n();\n\t}\n}\n\nvoid func_b(){\n\tif (col > 0) col--;\n\telse if (row > 0){\n\t\tfunc_p();\n\t\tfunc_e();\n\t}\n}\n\nvoid func_d(){\n\tif (col < text[row].size() - 1) text[row].erase(col, 1);\n\telse if (row < text.size() - 1){\n\t\ttext[row].erase(text[row].end() - 1);\n\t\ttext[row] += text[row + 1];\n\t\ttext.erase(text.begin() + row + 1);\n\t}\n}\n\nvoid func_k(){\n\tif (col < text[row].size() - 1){\n\t\tbuf = text[row].substr(col, text[row].size() - col - 1);\n\t\ttext[row].erase(col, text[row].size() - 1);\n\t}\n\telse if (row < text.size() - 1){\n\t\tfunc_d();\n\t\tbuf = \"\\n\";\n\t}\n}\n\nvoid func_y(){\n\tif (!buf.empty()){\n\t\tif (buf == \"\\n\"){\n\t\t\ttext.insert(text.begin() + row + 1, text[row].substr(col, text[row].size() - 1));\n\t\t\ttext[row].erase(col, text[row].size() - 1);\n\t\t\ttext[row] += '$';\n\t\t}\n\t\telse {\n\t\t\ttext[row].insert(col, buf);\n\t\t\tcol += buf.size();\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstring in;\n\tchar cmd;\n\n\twhile (getline(cin, in), in != \"END_OF_TEXT\"){\n\t\ttext.push_back(in + '$');\n\t}\n\t\n\tcol = row = 0;\n\tbuf.clear();\n\n\twhile (cin >> cmd, cmd != '-'){\n\t\tswitch (cmd){\n\t\t  case 'a': func_a(); break;\n\t\t  case 'e':\tfunc_e(); break;\n\t\t  case 'p':\tfunc_p(); break;\n\t\t  case 'n': func_n(); break;\n\t\t  case 'f': func_f(); break;\n\t\t  case 'b':\tfunc_b(); break;\n\t\t  case 'd':\tfunc_d(); break;\n\t\t  case 'k': func_k(); break;\n\t\t  case 'y': func_y(); break;\n\t\t}\n#if 0\n\t\tprintf(\"col:%d row:%d\\n\", col, row);\n\t\tputs(\"status:\");\n\t\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\t\tcout << *it << endl;\n\t\t}\n\t\tputs(\"buffer:\");\n\t\tcout << buf << endl;\n#endif\n\t}\n\n\t\n\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\tcout << it->substr(0, it->size() - 2) << endl;\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main()\n{\n\tstring str[300];\n\tstring b = \"???\";\n\tint y = 0, y2 = 0;\n\t\n\twhile (getline(std::cin, str[y]), str[y] != \"END_OF_TEXT\"){\n\t\ty++;\n\t}\n\ty2 = --y;\n\t\n\tchar cmd[2];\n\tint car = 0, car_y = 0;\n\t\n\twhile (scanf(\"%s\", cmd), cmd[0] != '-'){\n\t\tif (cmd[0] == 'a'){\n\t\t\tcar = 0;\n\t\t}\n\t\tif (cmd[0] == 'e'){\n\t\t\tcar = str[car_y].size();\n\t\t}\n\t\tif (cmd[0] == 'p'){\n\t\t\tif (car_y == 0){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y--;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'n'){\n\t\t\tif (car_y != y){\n\t\t\t\tcar_y++;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\t\n\t\t\telse {\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'f'){\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tcar++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tcar_y++;\n\t\t\t\t\tcar = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'b'){\n\t\t\tif (car != 0){\n\t\t\t\tcar--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != 0){\n\t\t\t\t\tcar_y--;\n\t\t\t\t\tcar = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'd'){\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tstr[car_y].erase(car, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = y - 1;\n\t\t\t\t\ty = car_y;\n\t\t\t\t\twhile (++y < y2){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y].erase();\n\t\t\t\t\t\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'k'){\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = y;\n\t\t\t\t\ty = car_y;\n\t\t\t\t\twhile (++y < y2){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y].erase();\n\t\t\t\t\t\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb = str[car_y].substr(car);\n\t\t\t\tstr[car_y].erase(car);\n\t\t\t\tcar = str[car_y].size();\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'y'){\n\t\t\tif(b != \"???\"){\n\t\t\t\tif (b[0] == '\\0'){\n\t\t\t\t\ty2 = y + 1;\n\t\t\t\t\twhile (y > car_y + 1){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y] = str[car_y].substr(car);\n\t\t\t\t\tstr[car_y].erase(car);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstr[car_y].insert(car, b);\n\t\t\t\t\tcar += b.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int j = 0; j <= y; j++){\n\t\tcout << str[j] << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst ll INF = 1LL << 50;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nsize_t tpos;\nsize_t lpos;\n\nvoid do_a(const vector<string> &text){\n\tlpos = 0;\n}\n\nvoid do_e(const vector<string> &text){\n\tlpos = text[tpos].size();\n}\n\nvoid do_p(const vector<string> &text){\n\tlpos = 0;\n\ttpos = max(0, (int)tpos - 1);\n}\n\nvoid do_n(const vector<string> &text){\n\tlpos = 0;\n\ttpos = min((int)tpos + 1, (int)text.size() - 1);\n}\n\nvoid do_f(const vector<string> &text){\n\tif(lpos == text[tpos].size()){\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\tlpos = 0;\n\t\t\ttpos++;\n\t\t}\n\t}else{\n\t\tlpos++;\n\t}\n}\n\nvoid do_b(const vector<string> &text){\n\tif(lpos != 0){\n\t\tlpos--;\n\t}else{\n\t\tif(tpos > 0) tpos--;\n\t}\n}\n\nvoid do_d(vector<string> &text){\n\tif(lpos != text[tpos].size()){\n\t\ttext[tpos].erase(lpos, 1);\n\t}else{\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\ttext[tpos]+=text[tpos+1];\n\t\t\ttext.erase(text.begin() + tpos+1);\n\t\t}\n\t}\n}\n\nvoid do_k(vector<string> &text, string &buffer){\n\tif(lpos == text[tpos].size()){\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\tbuffer = \"\\n\";\n\t\t\tdo_d(text);\n\t\t}\n\t}else{\n\t\tbuffer = string(text[tpos].begin() + lpos, text[tpos].end());\n\t\ttext[tpos].erase(text[tpos].begin() + lpos, text[tpos].end());\n\t}\n}\n\nvoid do_y(vector<string> &text, string &buffer){\n\tif(buffer != \"\"){\n\t\tif(buffer == \"\\n\"){\n\t\t\tstring a(text[tpos].begin() + lpos, text[tpos].end());\n\t\t\ttext[tpos].erase(lpos);\n\t\t\ttext.insert(text.begin() + tpos + 1, a);\n\t\t\ttpos++;\n\t\t\tlpos = 0;\n\t\t}else{\n\t\t\tif(lpos == text[tpos].size()){\n\t\t\t\ttext[tpos] += buffer;\n\t\t\t\tlpos = text[tpos].size();\n\t\t\t}else{\n\t\t\t\ttext[tpos].insert(text[tpos].begin() + lpos + 1, buffer.begin(), buffer.end());\n\t\t\t\tlpos += buffer.size();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid output(const vector<string> &text){\n\trep(i, (int)text.size()) cout << text[i] << endl;\n}\n\nint main(){\n\tstring line;\n\tvector<string> text;\n\tstring buffer;\n\twhile(cin >> line && line != \"END_OF_TEXT\"){\n\t\ttext.push_back(line);\n\t}\n\ttpos = lpos = 0;\n\tchar command;\n\twhile(cin >> command && command != '-'){\n\t\tswitch(command){\n\t\tcase 'a':\n\t\t\tdo_a(text);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tdo_e(text);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tdo_p(text);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tdo_n(text);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tdo_f(text);\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tdo_b(text);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdo_d(text);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tdo_k(text, buffer);\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tdo_y(text, buffer);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t\t//output(text);\n\t\t//cout << tpos << \" \" << lpos << endl;\n\t}\n\toutput(text);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n \nusing namespace std;\n\n#define sz  size()\n#define er  erase\n#define ss  substr\n\nclass Emacs {\npublic:\n    Emacs(){\n        w = h = 0;\n        buf.clear();\n    }\n    void appendLine(string line){ txt.push_back(line); }\n    void execCommand(char code){\n        switch (code){\n          case 'a': A(); break;\n          case 'e': E(); break;\n          case 'p': P(); break;\n          case 'n': N(); break;\n          case 'f': F(); break;\n          case 'b': B(); break;\n          case 'd': D(); break;\n          case 'k': K(); break;\n          case 'y': Y(); break;\n        }\n    }\n    void showText(){\n        for (auto line : txt)\n            cout << line << \"\\n\";\n    }\nprivate:\n    void A(){ w = 0; }\n    void E(){ w = txt[h].sz; }\n    void P(){ h = max(h - 1, 0); A(); }\n    void N(){ h = min(h + 1, (int)txt.sz - 1); A(); }\n    void F(){ if (w < txt[h].sz) w++; else if (h < txt.sz - 1) A(), h++; }\n    void B(){ if (w > 0) w--; else if (h > 0) h--, E(); }\n    void D(){ if (w < txt[h].sz) txt[h].er(w, 1); else if (h < txt.sz - 1) txt[h] += txt[h + 1], txt.er(txt.begin() + h + 1); }\n    void K(){ if (w < txt[h].sz) buf = txt[h].ss(w), txt[h] = txt[h].ss(0, w); else if (h < txt.sz - 1) D(), buf = \"\\n\"; }\n    void Y(){ if (!buf.empty()) { if (buf == \"\\n\") txt.insert(txt.begin() + h + 1, txt[h].ss(w)); else txt[h].insert(w, buf), w += buf.sz; }}\n    vector<string> txt;\n    string buf;\n    int h, w;\n};\n\nint main()\n{\n    Emacs emacs;\n\n    string in;\n    while (getline(cin, in), in != \"END_OF_TEXT\") emacs.appendLine(in);\n\n    char cmd;\n    while (cin >> cmd, cmd != '-') emacs.execCommand(cmd);\n\n    emacs.showText();\n\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring buffer[500];\nstring killbuff;\nint lcnt,cury,curx;\n\nvoid exec_command(string com) {\n    if(com == \"a\") curx = 0;\n    else if(com == \"e\") curx = buffer[cury].length()-1;\n    else if(com == \"p\") {\n        curx = 0;\n        if(cury > 0) cury--;\n    }else if(com == \"n\") {\n        curx = 0;\n        if(cury < lcnt-1) cury++;\n    }else if(com == \"f\") {\n        if(buffer[cury][curx] != '$') curx++;\n        else if(cury < lcnt-1) { curx = 0, cury++; }\n    }else if(com == \"b\") {\n        if(curx > 0) curx--;\n        else if(cury > 0) curx = buffer[--cury].length()-1;\n    }else if(com == \"d\") {\n        if(buffer[cury][curx] == '$' && cury < lcnt-1) {\n            buffer[cury] = buffer[cury].substr(0,buffer[cury].length()-1)\n                + buffer[cury+1];\n            for(int i=cury+1; i<lcnt-1; ++i) buffer[i] = buffer[i+1];\n            lcnt--;\n        }else if(buffer[cury][curx] != '$') {\n            buffer[cury] = buffer[cury].substr(0,curx)\n                + buffer[cury].substr(curx+1);\n        }\n    }else if(com == \"k\") {\n        if(buffer[cury][curx] == '$' && cury < lcnt-1) {\n            buffer[cury] = buffer[cury].substr(0,buffer[cury].length()-1)\n                + buffer[cury+1];\n            for(int i=cury+1; i<lcnt-1; ++i) buffer[i] = buffer[i+1];\n            lcnt--;\n            killbuff = \"$\";\n        }else if(buffer[cury][curx] != '$') {\n            killbuff = buffer[cury].substr(curx);\n            killbuff = killbuff.substr(0, killbuff.length()-1);\n            buffer[cury] = buffer[cury].substr(0,curx) + \"$\";\n        }\n    }else if(com == \"y\") {\n        if(killbuff != \"\") {\n            if(killbuff == \"$\") {\n                string tmp = buffer[cury].substr(curx);\n                buffer[cury] = buffer[cury].substr(0,curx) + \"$\";\n                for(int i=cury+1; i<lcnt; ++i) {\n                    string tt = buffer[i];\n                    buffer[i] = tmp;\n                    tmp = tt;\n                }\n                buffer[lcnt++] = tmp;\n            }else{\n                buffer[cury] = buffer[cury].substr(0,curx) + killbuff\n                    + buffer[cury].substr(curx);\n                curx += killbuff.length();\n            }\n        }\n    }\n}\n\nint main() {\n    lcnt = cury = curx = 0;\n    killbuff = \"\";\n    string s;\n\n    while(getline(cin, s)) {\n        if(s == \"END_OF_TEXT\") {\n            buffer[lcnt] = \"%\";\n            break;\n        }\n        s += \"$\";\n        buffer[lcnt++] = s;\n    }\n\n    while(cin>>s) {\n        if(s == \"-\") break;\n        exec_command(s);\n    }\n\n    for(int i=0; i<lcnt-1; ++i)\n        cout<<buffer[i].substr(0, buffer[i].length()-1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <list>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n\tlist<string> li;\n\tlist<string>::iterator ite;\n\tstring buffer;\n\tbool bu = false;\n\tint lc = 0;\n\n\twhile (1) {\n\t\tstring s;\n\t\tbool mo = false;\n\t\tgetline(cin, s);\n\t\tif (s == \"END_OF_TEXT\") break;\n\t\tli.push_back(s);\n\t\tite = --li.end();\n\t\tfor (int j = 0; j < (*ite).size(); ++j) {\n\t\t\tif ((*ite)[j] != ' ') {\n\t\t\t\tmo = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 0; j < (*ite).size(); ++j) {\n\t\t\tif ((*ite)[j] != ' ') {\n\t\t\t\tprintf(\"%c\\n\", (*ite)[j]);\n\t\t\t}\n\t\t}\n\t\tif (!mo) { s = \"\"; }\n\t}\n\tite = li.begin(); lc = 0;\n\twhile (1) {\n\t\tchar c;\n\t\tcin >> c;\n\t\tif (c == '-') break;\n\t\tswitch (c) {\n\t\tcase 'a': lc = 0; break;\n\t\tcase 'e': lc = (*ite).size(); break;\n\t\tcase 'p': \n\t\t\tlc = 0; \n\t\t\tif (ite != li.begin()) --ite; break;\n\t\tcase 'n': \n\t\t\tlc = 0;\n\t\t\tif (ite != --li.end()) ++ite; break;\n\t\tcase 'f': \n\t\t\tif ((*ite).size() != lc) ++lc; \n\t\t\telse if((*ite).size() == lc && ite != --li.end()){\n\t\t\t\t++ite; lc = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b': \n\t\t\tif (lc != 0) --lc;\n\t\t\telse if(lc == 0 && ite != --li.begin()){\n\t\t\t\t--ite; \n\t\t\t\tlc = (*ite).size();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd': \n\t\t\tif ((*ite)[lc] != ' ') {\n\t\t\t\t(*ite).erase((*ite).begin() + lc);\n\t\t\t}\n\t\t\telse if ((*ite).size() == lc && ite != --li.end()) {\n\t\t\t\t(*ite) += (*++ite);\n\t\t\t\tli.erase(ite);\n\t\t\t\t--ite;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'k': \n\t\t\tif ((*ite).size() == lc && ite != --li.end()) {\n\t\t\t\t(*ite) += (*++ite);\n\t\t\t\tli.erase(ite);\n\t\t\t\t--ite;\n\t\t\t\tbuffer = \"\"; bu = true;\n\t\t\t\tlc = (*ite).size();\n\t\t\t}\n\t\t\telse if ((*ite).size() != lc){\n\t\t\t\tbuffer = (*ite).substr(lc, (*ite).size());\n\t\t\t\t(*ite).erase(lc, (*ite).size());\n\t\t\t\tbu = true;\n\t\t\t\tlc = (*ite).size();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'y': \n\t\t\tif (bu) {\n\t\t\t\tif (buffer == \"\") {\n\t\t\t\t\tli.insert(ite,(*ite).substr(lc, (*ite).size()));\n\t\t\t\t\tlc = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t(*ite).insert(lc, buffer);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (auto i = li.begin(); i != li.end(); ++i) {\n\t\tcout << *i << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\tvector<string> edit;\n\twhile(true){\n\t\tstring s;\tcin>>s;\n\t\tif(s==\"END_OF_TEXT\")\tbreak;\n\t\tedit.push_back(s+'\\n');\n\t}\n\tint tr=0,tc=0;\n\tstring buff=\"\";\n\twhile(true){\n\t\tchar c;\tcin>>c;\n\t\tif(c=='-')\tbreak;\n\t\tif(c=='a')\ttr=0;\n\t\telse if(c=='e')\ttr=edit[tc].size()-1;\n\t\telse if(c=='p'){\n\t\t\ttr=0;\ttc=max(0,tc-1);\n\t\t}\n\t\telse if(c=='n'){\n\t\t\ttr=0;\ttc=min((int)edit.size()-1,tc+1);\n\t\t}\n\t\telse if(c=='f'){\n\t\t\tif((int)edit[tc].size()>tr+1)\ttr++;\n\t\t\telse if((int)edit.size()>tc+1){\n\t\t\t\ttc++;\ttr=0;\n\t\t\t}\n\t\t}\n\t\telse if(c=='b'){\n\t\t\tif(tr>0)\ttr--;\n\t\t\telse if(tc>0){\n\t\t\t\ttc--;\ttr=edit[tc].size()-1;\n\t\t\t}\n\t\t}\n\t\telse if(c=='d'){\n\t\t\tif(tr+1<(int)edit[tc].size())\tedit[tc].erase(edit[tc].begin()+tr);\n\t\t\telse if(tc+1<(int)edit.size()){\n\t\t\t\tedit[tc].erase(edit[tc].end()-1);\n\t\t\t\tedit[tc].insert(edit[tc].end(),edit[tc+1].begin(),edit[tc+1].end());\n\t\t\t\tedit.erase(edit.begin()+tc+1);\n\t\t\t}\n\t\t}\n\t\telse if(c=='k'){\n\t\t\tif(edit[tc][tr]=='\\n'&&tc+1<(int)edit.size()){\n\t\t\t\tbuff=\"\\n\";\n\t\t\t\tedit[tc].erase(edit[tc].end()-1);\n\t\t\t\tedit[tc].insert(edit[tc].end(),edit[tc+1].begin(),edit[tc+1].end());\n\t\t\t\tedit.erase(edit.begin()+tc+1);\n\t\t\t}\n\t\t\telse if(tr+1<(int)edit[tc].size()){\n\t\t\t\tbuff=string(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t\tbuff.erase(buff.end()-1);\n\t\t\t\tedit[tc].erase(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t\tedit[tc]+=\"\\n\";\n\t\t\t}\n\t\t}\n\t\telse if(c=='y'){\n\t\t\tif(buff==\"\")\tcontinue;\n\t\t\tif(buff==\"\\n\"){\n\t\t\t\tstring s(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t\tedit[tc].erase(edit[tc].begin()+tr,edit[tc].end());\n\t\t\t\tedit[tc]=edit[tc]+'\\n';\n\t\t\t\tedit.insert(edit.begin()+tc+1,s);\n\t\t\t\ttc++;\ttr=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint s=buff.size();\n\t\t\t\tedit[tc].insert(edit[tc].begin()+tr,buff.begin(),buff.end());\n\t\t\t\ttr+=s;\n\t\t\t}\n\t\t}\n\t}\n\tfor(string s:edit)\tcout<<s;\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <string>\nusing namespace std;\n\n//#define DEBUG\n\n#if defined(DEBUG)\n#define debug(code) {code}\n#else\n#define debug(code)\n#endif\n\n#define ASSERT(condition, message) {                               \\\n    if(!(condition)) {                                             \\\n        cout << \"Assertion Failed: \" << message << endl;           \\\n        exit(EXIT_FAILURE);                                        \\\n    }                                                              \\\n}\n\nclass EmacsLikeEditor {\n  private:\n    // Text as a vector with one element per line\n    vector<string> lines;\n    // Position of cursor\n    int row, col;\n    string buffer;\n    int getRowHead() { return 0; }\n    int getRowEnd() { return lines.size() - 1; }\n    int getColHead() { return 0; }\n    int getColEnd() { return lines[row].length() - 1; }\n  public:\n    EmacsLikeEditor(vector<string> lines) {\n      this->lines = lines;\n      this->row = 0;\n      this->col = 0;\n      this->buffer = \"\";\n    }\n    // Print text content\n    void printText() {\n      for(string line : lines) {\n        cout << line;\n      }\n    }\n    // Move cursor to first character of current line\n    void moveHeadOfLine() {\n      col = getColHead();\n      ASSERT(0 <= col && col < lines[row].length(), \"Column number out of range\");\n    }\n    // Move cursor to end-of-line of current line\n    void moveEndOfLine() {\n      col = getColEnd();\n      ASSERT(0 <= col && col < lines[row].length(), \"Column number out of range\");\n    }\n    // Move cursor to first character of next upper line\n    void movePrevLine() {\n      // Do not move line if there is no line above\n      if(row != getRowHead()) row -= 1;\n      col = getColHead();\n      ASSERT(0 <= row && row < lines.size(), \"Line number out of range\");\n      ASSERT(0 <= col && col < lines[row].length(), \"Column number out of range\");\n    }\n    // Move cursor to first character of next lower line\n    void moveNextLine() {\n      // Do not move line if there is no line below\n      if(row != getRowEnd()) row += 1;\n      col = getColHead();\n      ASSERT(0 <= row && row < lines.size(), \"Line number out of range\");\n      ASSERT(0 <= col && col < lines[row].length(), \"Column number out of range\");\n    }\n    // Move cursor by one character to front\n    void moveFront() {\n      // If cursor does not points out end-of-line\n      if(col != getColEnd()) {\n        // Move cursor by one character to right\n        col += 1;\n      }\n      // If cursor points out end-of-line and there is line below\n      else if(row != getRowEnd()) {\n        // Move cursor to first character of next lower line\n        row += 1;\n        col = getColHead();\n      }\n      ASSERT(0 <= row && row < lines.size(), \"Line number out of range\");\n      ASSERT(0 <= col && col < lines[row].length(), \"Column number out of range\");\n    }\n    // Move cursor by one character to back\n    void moveBack() {\n      // If cursor does not points out first character\n      if(col != getColHead()) {\n        // Move cursor by one character to left\n        col -= 1;\n      }\n      // If cursor points out first character and there is line above\n      else if(row != getRowHead()) {\n        // Move cursor to end-of-line of next upper line\n        row -= 1;\n        col = getColEnd();\n      }\n      ASSERT(0 <= row && row < lines.size(), \"Line number out of range\");\n      ASSERT(0 <= col && col < lines[row].length(), \"Column number out of range\");\n    }\n    // Delete character\n    void deleteChar() {\n      string line = lines[row];\n      // If cursor points out a character\n      if(col != getColEnd()) {\n        line.erase(line.begin() + col);\n        lines[row] = line;\n      }\n      // If cursor points out end-of-line and there is line below\n      else if(row != getRowEnd()) {\n        // Next lower line is appended to end-of-line of current line\n        int nextRow = row + 1;\n        line.pop_back();\n        line += lines[nextRow];\n        lines[row] = line;\n        lines.erase(lines.begin() + nextRow);\n      }\n      ASSERT(0 <= row && row < lines.size(), \"Line number out of range\");\n      ASSERT(0 <= col && col < lines[row].length(), \"Column number out of range\");\n    }\n    // Cut characters between cursor and end-of-line, and record them on buffer\n    void deleteRightAll() {\n      string line = lines[row];\n      // If cursor does not point out end-of-line\n      if(col != getColEnd()) {\n        // Record characters between cursor and end-of-line on buffer\n        buffer = line.substr(col, getColEnd() - col);\n        // Cut characters between cursor and end-of-line\n        line.erase(line.begin() + col, line.begin() + line.length() - 1);\n        lines[row] = line;\n        // Cursor indicates end-of-line of current line\n        col = getColEnd();\n      }\n      // If cursor points out end-of-line and there is line below\n      else if(row != getRowEnd()) {\n        // Record linefeed on buffer\n        buffer = \"\\n\";\n        // Perform the command d\n        deleteChar();\n      }\n      ASSERT(0 <= row && row < lines.size(), \"Line number out of range\");\n      ASSERT(0 <= col && col < lines[row].length(), \"Column number out of range\");\n    }\n    void paste() {\n      string line = lines[row];\n      string formerText, latterText;\n      formerText = line.substr(getColHead(), col);\n      latterText = line.substr(col, line.length() - col);\n      // If buffer is holding linefeed\n      if(buffer == \"\\n\") {\n        // Insert linefeed at cursor\n        lines[row] = formerText + buffer;\n        lines.insert(lines.begin() + row + 1, latterText);\n        // Cursor moves to first character of new line\n        row += 1;\n        col = getColHead();\n      }\n      // If buffer is holding characters\n      else if(buffer != \"\") {\n        // Insert the characters at cursor\n        lines[row] = formerText + buffer + latterText;\n        // Cursor moves to the character which is originally pointed by cursor\n        col += buffer.length();\n      }\n      ASSERT(0 <= row && row < lines.size(), \"Line number out of range\");\n      ASSERT(0 <= col && col < lines[row].length(), \"Column number out of range\");\n    }\n    // Trace text content for debugging\n    void traceText() {\n        debug(\n            cout << endl;\n            for(int i = 0; i < lines.size(); i++) {\n                for(int j = 0; j < lines[i].length(); j++) {\n                    // The character at cursor is enclosed in brackets\n                    if(i == row && j == col) {\n                        if(lines[i][j] == '\\n') cout << \"[]\" << lines[i][j];\n                        else cout << '[' << lines[i][j] << ']';\n                    }\n                    else {\n                        cout << lines[i][j];\n                    }\n                }\n            }\n            cout << endl;\n        );\n    }\n};\n\nint main() {\n    vector<string> inputLines;\n    string inputLine;\n    char command;\n\n    // Read a text consisting of several lines\n    while(1) {\n      getline(cin, inputLine);\n      if(inputLine == \"END_OF_TEXT\") break;\n      inputLines.push_back(inputLine + '\\n');\n    }\n\n    EmacsLikeEditor editor(inputLines);\n\n    // Read a series of commands\n    while(1) {\n      getline(cin, inputLine);\n      ASSERT(inputLine.length() == 1, \"Command must be one character per line\");\n      command = inputLine[0];\n      if(command == '-') break;\n      switch(command) {\n        case 'a':\n          editor.moveHeadOfLine();\n          break;\n        case 'e':\n          editor.moveEndOfLine();\n          break;\n        case 'p':\n          editor.movePrevLine();\n          break;\n        case 'n':\n          editor.moveNextLine();\n          break;\n        case 'f':\n          editor.moveFront();\n          break;\n        case 'b':\n          editor.moveBack();\n          break;\n        case 'd':\n          editor.deleteChar();\n          break;\n        case 'k':\n          editor.deleteRightAll();\n          break;\n        case 'y':\n          editor.paste();\n          break;\n        default:\n          break;\n      }\n      editor.traceText();\n    }\n\n    editor.printText();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[110];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tif(i<110) t[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tif(row<110) col = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 && row < 110 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row < 110 && row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( row < 110 && col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else if( row < 110 ){\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( row < 110 && buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line+1 < 110 && line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\t//t[row+1] = t[row].substr( col );\n\t\t\t\t\tt[row].erase( col );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else if( row < 110 ){\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY--;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n\telse return;\n}\n\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\\n\";\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring front=\"\";\n\t\tstring rear=\"\";\n\t\tfront = lines[posY].substr(0,posX);\n\t\trear = lines[posY].substr(posX,lines[posY].size()-posX);\t\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX);\n\n\t\tlines[posY] = front;\n\t\tdeque<string>::iterator it = lines.begin();\n\t\tadvance(it,posY);\n\t\tlines.insert(it,rear);\n\t}\n\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(getline(cin,str)){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(cin >> str){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\tif(str == \"d\") ctrl_d(lines);\n\t\tif(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nint main(){\n  vector<string> text(200);\n  int line = 0;\n  for(;line<11;line++){\n    getline(cin,text[line],'\\n');\n    if (text[line]==\"END_OF_TEXT\")\n      break;\n  }\n  string buf;\n  int cur[2];\n  cur[0] = 0;//0s\n  cur[1] = 0;//0¶Ú\n\n  while(true){\n    char com;\n    cin >> com;\n    if (com == '-')\n      break;\n    switch (com){\n    case 'a':\n      cur[1] = 0;\n      break;\n    case 'e':\n      cur[1] = (int)text[cur[0]].size();\n      break;\n    case 'p':\n      if (cur[0]>0)\n\tcur[0]--;\n      cur[1]=0;\n      break;\n    case 'n':\n      if (cur[0]<line-1)\n\tcur[0]++;\n      cur[1]=0;\n      break;\n    case 'f':\n      if (cur[1]<(int)text[cur[0]].size())\n\tcur[1]++;\n      else{\n\tif (cur[0]<line-1){\n\t  cur[0]++;\n\t  cur[1]=0;\t\n\t}\n      }\n      break;\n    case 'b':\n      if (cur[1]>0)\n\tcur[1]--;\n      else{\n\tif (cur[0]>0){\n\t  cur[0]--;\n\t  cur[1]=(int)text[cur[0]].size();\t\n\t}\n      }\n      break;\n    case 'd':\n      if (cur[1]<(int)text[cur[0]].size()){\n\ttext[cur[0]] = text[cur[0]].substr(0,cur[1])+text[cur[0]].substr(cur[1]+1);\n      }\n      else{\n\tif (cur[0]<line-1){\n\t  text[cur[0]] = text[cur[0]]+text[cur[0]+1];\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i] = text[i+1];\n\t  line--;\n\t}\n      }\n      break;\n    case 'k':\n      if (cur[1]==(int)text[cur[0]].size()){\n\tif (cur[0]<line-1){\n\t  text[cur[0]] = text[cur[0]]+text[cur[0]+1];\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i] = text[i+1];\n\t  line--;\n\t  buf = \"\\n\";\n\t}\n      }\n      else{\n\tbuf = text[cur[0]].substr(cur[1]);\n\ttext[cur[0]] = text[cur[0]].substr(0,cur[1]);\n\tcur[1] = (int)text[cur[0]].size();\n      }\n      break;\n    case 'y':\n      if (buf.empty())\n\tbreak;\n      else{\n\tif (buf == \"\\n\"){\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i+1] = text[i];    \n\t  line++;\n\t  text[cur[0]] = text[cur[0]].substr(0,cur[1]);\n\t  text[cur[0]+1] = text[cur[0]].substr(cur[1]);\n\t}\n\telse{\n\t  text[cur[0]] = text[cur[0]].substr(0,cur[1])+buf+text[cur[0]].substr(cur[1]);\n\t}\n      }\n    default:\n      break;\n    }\n    /*      for(int i=0;i<line;i++)\n\tcout << text[i] << endl;\n\tcout << \"(\" << cur[0] << \",\" << cur[1] << \")\" << endl;\n\tcout << \"#\" << endl;*/\n  }\n  for(int i=0;i<line;i++)\n    cout << text[i] << endl;\n  return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst ll INF = 1LL << 50;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nsize_t tpos;\nsize_t lpos;\n\nvoid do_a(const vector<string> &text){\n\tlpos = 0;\n}\n\nvoid do_e(const vector<string> &text){\n\tlpos = text[tpos].size();\n}\n\nvoid do_p(const vector<string> &text){\n\tlpos = 0;\n\ttpos = max(0, (int)tpos - 1);\n}\n\nvoid do_n(const vector<string> &text){\n\tlpos = 0;\n\ttpos = min((int)tpos + 1, (int)text.size() - 1);\n}\n\nvoid do_f(const vector<string> &text){\n\tif(lpos == text[tpos].size()){\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\tlpos = 0;\n\t\t\ttpos++;\n\t\t}\n\t}else{\n\t\tlpos++;\n\t}\n}\n\nvoid do_b(const vector<string> &text){\n\tif(lpos != 0){\n\t\tlpos--;\n\t}else{\n\t\tif(tpos > 0){\n\t\t\ttpos--;\n\t\t\tlpos = text[tpos].size();\n\t\t}\n\t}\n}\n\nvoid do_d(vector<string> &text){\n\tif(lpos != text[tpos].size()){\n\t\ttext[tpos].erase(lpos, 1);\n\t}else{\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\ttext[tpos]+=text[tpos+1];\n\t\t\ttext.erase(text.begin() + tpos+1);\n\t\t}\n\t}\n}\n\nvoid do_k(vector<string> &text, string &buffer){\n\tif(lpos == text[tpos].size()){\n\t\tbuffer = \"\\n\";\n\t\tif((int)tpos < (int)text.size() - 1){\n\t\t\tbuffer = \"\\n\";\n\t\t\tdo_d(text);\n\t\t}\n\t}else{\n\t\tbuffer = string(text[tpos].begin() + lpos, text[tpos].end());\n\t\ttext[tpos].erase(text[tpos].begin() + lpos, text[tpos].end());\n\t}\n}\n\nvoid do_y(vector<string> &text, string &buffer){\n\tif(buffer != \"\"){\n\t\tif(buffer == \"\\n\"){\n\t\t\tstring a(text[tpos].begin() + lpos, text[tpos].end());\n\t\t\ttext[tpos].erase(lpos);\n\t\t\ttext.insert(text.begin() + tpos + 1, a);\n\t\t\ttpos++;\n\t\t\tlpos = 0;\n\t\t}else{\n\t\t\tif(lpos == text[tpos].size()){\n\t\t\t\ttext[tpos] += buffer;\n\t\t\t\tlpos = text[tpos].size();\n\t\t\t}else{\n\t\t\t\ttext[tpos].insert(text[tpos].begin() + lpos, buffer.begin(), buffer.end());\n\t\t\t\tlpos += buffer.size();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid output(const vector<string> &text){\n\trep(i, (int)text.size()) cout << text[i] << endl;\n}\n\nint main(){\n\tstring line;\n\tvector<string> text;\n\tstring buffer;\n\twhile(cin >> line && line != \"END_OF_TEXT\"){\n\t\ttext.push_back(line);\n\t}\n\ttpos = lpos = 0;\n\tchar command;\n\twhile(cin >> command && command != '-'){\n\t\tswitch(command){\n\t\tcase 'a':\n\t\t\tdo_a(text);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tdo_e(text);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tdo_p(text);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tdo_n(text);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tdo_f(text);\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tdo_b(text);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdo_d(text);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tdo_k(text, buffer);\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tdo_y(text, buffer);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t\t//output(text);\n\t\t//cout << tpos << \" \" << lpos << endl;\n\t}\n\toutput(text);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring s[128];\nstring buf;\nint lines;\nvoid delete_line(int y)\n{\n    for (int i = y; y < lines; ++y)\n\ts[i] = s[i + 1];\n    s[--lines] = \"\";\n}\nvoid add_line(int y)\n{\n    for (int i = lines++; i > y; --i)\n\ts[i] = s[i - 1];\n    s[y] = \"\";\n}\nint main()\n{\n    while (true)\n    {\n\tstring t;\n\tgetline(cin, t);\n\tif (t == \"END_OF_TEXT\")\n\t    break;\n\ts[lines++] = t;\n    }\n\n    int x, y;\n    x = y = 0;\n    while (true)\n    {\n\tchar c;\n\tcin >> c;\n\tif (c == '-')\n\t    break;\n\n\tswitch (c)\n\t{\n\tcase 'a':\n\t{\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'e':\n\t{\n\t    x = s[y].size();\n\t    break;\n\t}\n\tcase 'p':\n\t{\n\t    y = max(0, --y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'n':\n\t{\n\t    y = min(lines - 1, ++y);\n\t    x = 0;\n\t    break;\n\t}\n\tcase 'f':\n\t{\n\t    if (x != s[y].size())\n\t\t++x;\n\t    else if (y + 1 != lines)\n\t\tx = 0, ++y;\n\t    break;\n\t}\n\tcase 'b':\n\t{\n\t    if (x != 0)\n\t\t--x;\n\t    else if (y != 0)\n\t    {\n\t\t--y;\n\t\tx = s[y].size();\n\t    }\n\t    break;\n\t}\n\tcase 'd':\n\t{\n\t    if (x != s[y].size())\n\t\ts[y].erase(x, 1);\n\t    else\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t    }\n\t    break;\n\t}\n\tcase 'k':\n\t{\n\t    if (x != s[y].size())\n\t    {\n\t\tbuf = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = s[y].size();\n\t    }\n\t    else if (y + 1 != lines)\n\t    {\n\t\ts[y] += s[y + 1];\n\t\tdelete_line(y + 1);\n\t\tbuf = \"\\n\";\n\t    }\n\t    break;\n\t}\n\tcase 'y':\n\t{\n\t    if (buf == \"\\n\")\n\t    {\n\t\tadd_line(y + 1);\n\t\ts[y + 1] = s[y].substr(x);\n\t\ts[y].erase(x);\n\t\tx = 0, ++y;\n\t    }\n\t    else\n\t\ts[y] += buf;\n\t    break;\n\t}\n\t}\n    }\n\n    for (int i = 0; i < lines; ++i)\n\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\n// char s[102][1002];\nvector<string> s;\nstring buf;\nint R;\nint ci = 0, cj = 0;\n\nvoid input() {\n  string l;\n  int r = 0;\n  while (1) {\n    getline(cin, l);\n    if (l == \"END_OF_TEXT\") {\n      R = r;\n      break;\n    }\n    s.push_back(l);\n    ++r;\n  }\n}\n\n// カーソルを現在の行の先頭文字に移動する\nvoid op_a() { cj = 0; }\n\n// カーソルを現在の行の行末に移動する\nvoid op_e() { cj = s[ci].size(); }\n\n// 上に行があれば、カーソルを上の行の先頭文字に移動する。\n// 上に行がなければ、カーソルを先頭文字に移動する。\nvoid op_p() {\n  if (ci != 0) \n    --ci;\n  op_a();\n}\n\n// 下に行があれば、カーソルを下の行の先頭文字に移動する。\n// 下に行がなければ、カーソルを先頭文字に移動する。\nvoid op_n() {\n  if (ci + 1 < R) \n    ++ci;\n  op_a();\n}\n\n// カーソルが行末にない場合、カーソルを１つ右に移動する \n// カーソルが行末にありかつ下に行がある場合は、\n// カーソルを下の行の先頭文字へ移動する \n// それ以外の場合は何もしない\nvoid op_f() {\n  if (cj != s[ci].size()) {\n    ++cj;\n  } else if (cj == s[ci].size() && ci + 1 < R) {\n    op_n();\n  }\n}\n\n// カーソルが先頭文字でないならば、カーソルを１つ左に移動する。\n// カーソルが先頭文字でありかつ上に行がある場合は、\n// カーソルを上の行の行末へ移動する。\n// それ以外の場合は何もしない。\nvoid op_b() {\n  if (cj != 0) {\n    --cj;\n  } else if (cj == 0 && ci != 0) {\n    --ci;\n    op_e();\n  }\n}\n\n// カーソルが文字を指す場合はその文字を削除する。\n// 削除された文字の右側の文字列は左にシフトされる。\n// カーソルが行末を指し下に行がある場合は、\n// 下の行をそのままカーソルの位置に繋げる。以下の行は上にシフトされる。\n// それ以外の場合は何もしない。\nvoid op_d() {\n  if (cj == s[ci].size() && ci + 1 < R) {\n    s[ci].erase(cj, 1);\n    s[ci] += s[ci+1];\n    s.erase(s.begin() + ci + 1);\n  } else {\n    s[ci].erase(cj, 1);\n  }\n}\n\n// カーソルが行末にある場合、下に行があれば、\n// d と同じ操作をしバッファに１つの改行を記録する。\n// カーソルが行末にない場合、カーソルが指す文字を含めた\n// 右側すべての文字を切り取りそれをバッファに記録する。\n// カーソルは元の行の行末を指すようになる。全ての記録においてバッファは上書きされる。\n// それ以外の場合は何もしない。(clarification at 14:20)\nvoid op_k() {\n  if (cj == s[ci].size() && ci + 1 < R) {\n    s[ci].erase(cj, 1);\n    s[ci] += s[ci+1];\n    s.erase(s.begin() + ci + 1);\n    buf = \"\\n\";\n  } else  {\n    buf = s[ci].substr(cj);\n    s[ci].erase(cj);\n  }\n}\n\n// バッファが空の場合はなにもしない。\n// バッファの内容が改行の場合、カーソルが指す文字の直前で改行を行う。\n// カーソルは新しい行の先頭文字へ移動する。\n// バッファの内容が文字列の場合、カーソルの位置にバッファの内容を挿入する。\n// カーソルの位置はもともと指していた文字または行末の場所へ移動する。 \nvoid op_y() {\n  if (buf == \"\") return;\n  if (buf == \"\\n\") {\n    inserter(s, s.begin() + ci + 1) = s[ci].substr(cj);\n    s[ci].erase(cj);\n    ++ci; cj = 0;          \n  } else {\n    s[ci].insert(cj, buf.c_str());\n    cj += buf.size();\n  }\n}\n\nvoid interpret() {\n  char op;\n  while (cin >> op, op != '-') {\n    // rep(i,R) {\n    //   printf(\"%s\\n\", s[i].c_str());\n    // }\n    // puts(\"--------------------------------------------------\");\n    // printf(\"[operation : %c | buf : %s]\\n\", op, buf.c_str());\n    switch (op) {\n      case 'a': { op_a(); break; }\n      case 'e': { op_e(); break; }\n      case 'p': { op_p(); break; }\n      case 'n': { op_n(); break; }\n      case 'f': { op_f(); break; }\n      case 'b': { op_b(); break; }\n      case 'd': { op_d(); break; }\n      case 'k': { op_k(); break; }\n      case 'y': { op_y(); break; }\n    }\n  }\n  // puts(\"----------------------------------------\");\n  rep(i,R) {\n    printf(\"%s\\n\", s[i].c_str());\n  }\n}\n\nint main() {\n  input();\n  interpret();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cstdio>\nusing namespace std;\n\nint crow = 0, ccol = 0;\nstring buf = \"\";\nvector<string> lines;\n\nvoid input() {\n    while(1) {\n        string s;\n        getline(cin, s);\n        if(s == \"END_OF_TEXT\") break;\n        lines.push_back(s + \"\\n\");\n    }\n}\n\nvoid assign_buf(string s, bool is_cl_only=false) {\n    buf = s;\n    if(!is_cl_only) {\n        assert(buf.back() == '\\n');\n        buf.pop_back();\n    }\n}\n\nbool is_col_begin() { return ccol == 0; }\nbool is_col_end() { return ccol + 1 == lines[crow].size(); }\nbool is_row_begin() { return crow == 0; }\nbool is_row_end() { return crow + 1 == lines.size(); }\n\nint get_col_begin() { return 0; }\nint get_col_end() { return (int)lines[crow].size() - 1; }\nint get_row_begin() { return 0; }\nint get_row_end() { return (int)lines.size() - 1; }\n\nvoid up()   { crow = max(get_row_begin(), crow - 1); ccol = 0; }\nvoid down() { crow = min(get_row_end()  , crow + 1); ccol = 0; }\nvoid right() {\n    if(is_col_end() && is_row_end()) return;\n\n    if(is_col_end()) down(), ccol = get_col_begin();\n    else             ccol++;\n}\nvoid left() {\n    if(is_col_begin() && is_row_begin()) return;\n\n    if(is_col_begin()) up(), ccol = get_col_end();\n    else               ccol--;\n}\n\nvoid delete_char() {\n    if(is_col_end()) {\n        if(is_row_end()) return;\n        string &target = lines[crow];\n        assert(target.back() == '\\n');\n        target.pop_back();\n        target += lines[crow + 1];\n        lines.erase(lines.begin() + crow + 1);\n    }\n    else {\n        lines[crow].erase(lines[crow].begin() + ccol);\n    }\n}\n\nvoid show_state(char op) {\n    printf(\"operate [%c]: row = %d, col = %d\\n\", op, crow, ccol);\n    for(auto x : lines) cout << x;\n}\n\nbool operate(char op) {\n    assert(crow >= 0 && ccol >= 0);\n    assert(crow + 1 <= lines.size());\n    assert(ccol + 1 <= lines[crow].size());\n\n    if(op == 'a') {\n        ccol = get_col_begin();\n    }\n    if(op == 'e') {\n        ccol = get_col_end();\n    }\n    if(op == 'p') {\n        up();\n    }\n    if(op == 'n') {\n        down();\n    }\n    if(op == 'f') {\n        right();\n    }\n    if(op == 'b') {\n        left();\n    }\n    if(op == 'd') {\n        delete_char();\n    }\n    if(op == 'k') {\n        if(is_col_end()) {\n            if(!is_row_end()) {\n                // printf(\"kill ring\\n\");\n                delete_char();\n                assign_buf(\"\\n\", true);\n            }\n        }\n        else {\n            string &target = lines[crow];\n            assign_buf(target.substr(ccol));\n            target = target.substr(0, ccol) + \"\\n\";\n        }\n    }\n    if(op == 'y') {\n        if(buf.size()) {\n            if(buf == \"\\n\") {\n                string &target = lines[crow];\n                string s1 = target.substr(0, ccol);\n                string s2 = target.substr(ccol);\n\n                if(s1.back() != '\\n') s1 += \"\\n\";\n                if(s2.back() != '\\n') s2 += \"\\n\";\n\n                target = s1;\n                lines.insert(lines.begin() + crow + 1, s2);\n\n                down();\n            }\n            else {\n                string &target = lines[crow];\n                target.insert(ccol, buf);\n                ccol += buf.size();\n            }\n        }\n    }\n\n    // show_state(op);\n    return op == '-';\n}\n\nint main() {\n    input();\n\n    while(1) {\n        char c; cin >> c;\n        if(operate(c)) break;\n    }\n    for(auto x : lines) {\n        cout << x;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tstring str[10000];\n\tstring b;\n\tint i = 0;\n\t\n\twhile (getline(std::cin, str[i]),i++ , str[i-1] != \"END_OF_TEXT\");\n\ti = 0;\n\twhile (!str[++i].empty());\n\tstr[i - 1].erase();\n\t\n\tchar cmd[1];\n\tint car_y = 0;\n\tint car = 0;\n\tint y = 0, y2 = 0;\n\t\n\twhile (!str[y++].empty());\n\ty2 = y;\n\t\n\tb.erase();\n\t\n\twhile (scanf(\"%s\", cmd), cmd[0] != '-'){\n\t\tif (cmd[0] == 'a'){\n\t\t\tcar = 0;\n\t\t//\tprintf(\" a\");\n\t\t}\n\t\tif (cmd[0] == 'e'){\n\t\t\tcar = str[car_y].size();\n\t\t\t\n\t\t//\tprintf(\" e\");\n\t\t}\n\t\tif (cmd[0] == 'p'){\n\t\t\t\n\t\t//\tprintf(\" p\");\n\t\t\tif (car_y == 0){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y--;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'n'){\n\t\t//\tprintf(\" n\");\n\t\t\tif (car_y == y2){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y++;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'f'){\n\t\t//\tprintf(\" f\");\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (!str[car_y + 1].size() == 0){\n\t\t\t\t\tcar_y++;\n\t\t\t\t\tcar = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar++;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'b'){\n\t\t//\tprintf(\" b\");\n\t\t\tif (car == 0){\n\t\t\t\tif (car_y != 0){\n\t\t\t\t\tcar_y--;\n\t\t\t\t\tcar = str[car_y].size();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar--;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'd'){\n\t\t//\tprintf(\" d\");\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tstr[car_y].erase(car, 1);\n\t\t\t\ty--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!str[car_y + 1].empty()){\n\t\t\t\t\t//str[car_y] + str[car_y + 1];\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'k'){\n\t\t//\tprintf(\" k\");\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (!str[car_y + 1].empty()){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\tb[0] = '\\0';\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb.erase();\n\t\t\t\tb = str[car_y].substr(car);\n\t\t\t\tstr[car_y].erase(car);\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'y'){\n\t\t//\tprintf(\" y\");\n\t\t\tif (b.empty());\n\t\t\telse {\n\t\t\t\tif (b[0] == '\\0'){\n\t\t\t\t\ty2 = y;\n\t\t\t\t\twhile (y < car_y){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t\ty--;\n\t\t\t\t\t}\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstr[car_y].insert(car, b);\n\t\t\t\t\tcar += b.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\ti = 0;\n\twhile (!str[i].empty()){\n\t\t//puts(str[i].c_str());\n\t\tcout << str[i] << endl;\n\t\ti++;\n\t}\n\t/*\n\ti = 0;\n\twhile (!str[i].empty()){\n\t\tif (car_y == i){\n\t\t\tfor (int j = 0; j <= str[i].size(); j++){\n\t\t\t\tif (j == car){\n\t\t\t\t\tcout << 'I';\n\t\t\t\t}\n\t\t\t\tcout << str[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\telse{\n\t\t\tputs(str[i].c_str());\n\t\t}\n\t\ti++;\n\t}\n\t*/\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<string> buf;\nint row;\nint column;\nstring rem;\n\nvoid printbuf(){\n  //cout << row << ' ' << column << \" \\\"\" << rem << \"\\\"\" << endl;\n  for(int i=0;i<buf.size();i++){\n    cout << buf[i];\n  }\n}\n\nmain(){\n  string in;\n  while(getline(cin, in)){\n    if(in == \"END_OF_TEXT\"/* || in == \"1\"*/) break;\n    in += '\\n';\n    buf.push_back(in);\n  }\n  char c;\n  row = 0;\n  column = 0;\n  while(cin >> c){\n    if(c == '-') break;\n    switch(c){\n      case 'a':\n        column = 0;\n        break;\n      case 'e':\n        column = (int)buf[row].size()-1;\n        break;\n      case 'p':\n        column = 0;\n        if(row > 0) --row;\n        break;\n      case 'n':\n        column = 0;\n        if(row+1 < buf.size()) ++row;\n        break;\n      case 'f':\n        if(column+1 >= buf[row].size()){\n          if(row+1 < buf.size()){\n            column = 0;\n            ++row;\n          }\n        }else{\n          ++column;\n        }\n        break;\n      case 'b':\n        if(column == 0){\n          if(row > 0){\n            column = 0;\n            --row;\n          }\n        }else{\n          --column;\n        }\n        break;\n      case 'd':\n        if(column+1 == buf[row].size()){\n          if(row+1 != buf.size()){\n            vector<string>::iterator ite = buf.begin();\n            for(int i=0;i<row;i++) ++ite;\n            buf.erase(ite);\n          }\n        }else{\n          buf[row].erase(column, 1);\n        }\n        break;\n      case 'k':\n        rem = \"\";\n        if(column+1 == buf[row].size()){\n          if(row+1 != buf.size()){\n            vector<string>::iterator ite = buf.begin();\n            for(int i=0;i<row;i++) ++ite;\n            buf.erase(ite);\n            rem += '\\n';\n          }\n        }else{\n          for(int i=column;i+1<buf[row].size();++i){\n            rem += buf[row][i];\n          }\n          string::iterator ite = buf[row].begin();\n          for(int i=0;i<column;i++) ++ite;\n          buf[row].erase(ite, buf[row].end());\n          buf[row] += '\\n';\n        }\n        break;\n      case 'y':\n        if(rem.size() != 0){\n          int irem;\n          string back = buf[row].substr(column);\n          buf[row] = buf[row].substr(0, column);\n          for(irem = 0;irem<rem.size();irem++){\n            buf[row] += rem[irem];\n            ++column;\n            if(rem[irem] == '\\n'){\n              vector<string>::iterator ite = buf.begin();\n              for(int i=0;i<row+1;i++) ++ite;\n              buf.insert(ite, \"\");\n              column = 0;\n              ++row;\n            }\n          }\n          buf[row] += back;\n        }\n        break;\n    }\n    //printbuf();\n  }\n  printbuf();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nchar t[100][1000];\nint h;\nint w[100];\n\nchar tmp[100];\nint tmp_size;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nint main(){\n\n  input();\n  x=y=tmp_size=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n  }\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w[i];j++){\n      cout<<t[i][j];\n    }\n    cout<<endl;\n  }\n  \n  return 0;\n}\n\nvoid funcA(){x=0;}\nvoid funcE(){x=w[y];}\nvoid funcP(){ if(y>0)y--; x=0; }\nvoid funcN(){ if(y+1<h)y++; x=0; }\nvoid funcF(){ \n  if(x<w[y])x++;\n  else if(y+1<h){y++;x=0;}\n}\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=w[y];}\n}\nvoid funcD(){\n  if(x<w[y]){\n    w[y]--;\n    for(int i=x;i<w[y];i++)t[y][i]=t[y][i+1];\n    return;\n  }\n  if(y+1==h)return;\n  for(int i=0;i<w[y+1];i++)t[y][w[y]+i]=t[y+1][i];\n  w[y]+=w[y+1];\n  h--;\n  for(int i=y+1;i<h;i++){\n    w[i]=w[i+1];\n    for(int j=0;j<w[i];j++){\n      t[i][j]=t[i+1][j];\n    }\n  }\n}\n\nvoid funcK(){\n  if(x==w[y]){\n    if(y+1<h){\n      funcD();\n      tmp[0]='\\n';\n      tmp_size=1;\n    }\n  }else{\n    tmp_size=0;\n    for(int i=x;i<w[y];i++)\n      tmp[tmp_size++]=t[y][i];\n    w[y]=x;\n  }\n}\n\nvoid funcY(){\n  \n  if(tmp_size==0)return;\n  if(tmp[0]!='\\n'){\n    char z[100];\n    int zs=0;\n    for(int i=x;i<w[y];i++){\n      z[zs++]=t[y][i];\n    }\n    for(int i=x;i<x+tmp_size;i++){\n      t[y][i]=tmp[i-x];\n    }\n    w[y]+=tmp_size;\n    for(int i=x+tmp_size;i<w[y];i++){\n      t[y][i]=z[i-x-tmp_size];\n    }\n    x+=tmp_size;\n    return;\n  }\n  \n  h++;\n  for(int i=h-1;i>y+1;i--){\n    w[i]=w[i-1];\n    for(int j=0;j<w[i];j++)\n      t[i][j]=t[i-1][j];\n  }\n\n  w[y+1]=w[y]-x;\n  for(int i=0;i<w[y+1];i++){\n    t[y+1][i]=t[y][i+x];\n  }\n  w[y]=x;\n  y++;\n  x=0;\n  \n}\n\nvoid input(){\n  string str;\n  h=0;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    w[h]=str.size();\n    for(int i=0;i<(int)str.size();i++)\n      t[h][i]=str[i];\n    h++;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tint h=0;\n\tchar s[100][1001];\n\tfor(int i=0;;i++){\n\t\tfgets(s[i],1001,stdin);\n\t\ts[i][strlen(s[i])-1]='\\0';\n\t\tif(strcmp(s[i],\"END_OF_TEXT\")==0){\n\t\t\ts[i][0]='\\0';\n\t\t\th=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tint cx=0,cy=0;\n\tchar buf[1001]=\"\";\n\twhile(1){\n\t\tchar cmd; scanf(\" %c\",&cmd);\n\t\tif(cmd=='-') break;\n\n\t\tif     (cmd=='a') cx=0;\n\t\telse if(cmd=='e') cx=strlen(s[cy]);\n\t\telse if(cmd=='p') cx=0, cy=max(cy-1,0);\n\t\telse if(cmd=='n') cx=0, cy=min(cy+1,h-1);\n\t\telse if(cmd=='f'){\n\t\t\tif(s[cy][cx]) cx++;\n\t\t\telse if(cy<h-1) cy++, cx=0;\n\t\t}\n\t\telse if(cmd=='b'){\n\t\t\tif(cx>0) cx--;\n\t\t\telse if(cy>0) cy--, cx=strlen(s[cy]);\n\t\t}\n\t\telse if(cmd=='d'){\n\t\t\tif(s[cy][cx]){\n\t\t\t\tfor(int j=cx+1;;j++){\n\t\t\t\t\ts[cy][j-1]=s[cy][j];\n\t\t\t\t\tif(!s[cy][j]) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cy<h-1){\n\t\t\t\tstrcpy(s[cy]+cx,s[cy+1]);\n\t\t\t\tfor(int i=cy+1;i<h-1;i++) strcpy(s[cy],s[cy+1]);\n\t\t\t\th--;\n\t\t\t}\n\t\t}\n\t\telse if(cmd=='k'){\n\t\t\tif(!s[cy][cx]){\n\t\t\t\tif(cy<h-1){\n\t\t\t\t\tstrcpy(s[cy]+cx,s[cy+1]);\n\t\t\t\t\tfor(int i=cy+1;i<h-1;i++) strcpy(s[cy],s[cy+1]);\n\t\t\t\t\th--;\n\t\t\t\t\tbuf[0]='\\n'; buf[1]='\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstrcpy(buf,s[cy]+cx);\n\t\t\t\ts[cy][cx]='\\0';\n\t\t\t}\n\t\t}\n\t\telse{ // cmd=='y'\n\t\t\tif(buf[0]){\n\t\t\t\tif(buf[0]=='\\n'){\n\t\t\t\t\tfor(int i=h-1;i>cy;i--) strcpy(s[i+1],s[i]);\n\t\t\t\t\tstrcpy(s[cy+1],s[cy]+cx);\n\t\t\t\t\ts[cy][cx]='\\0';\n\t\t\t\t\tcy++;\n\t\t\t\t\tcx=0;\n\t\t\t\t\th++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint m=strlen(buf);\n\t\t\t\t\tfor(int j=strlen(s[cy]);j>=cx;j--) s[cy][j+m]=s[cy][j];\n\t\t\t\t\trep(j,m) s[cy][j+cx]=buf[j];\n\t\t\t\t\tcx+=m;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i,h) puts(s[i]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(5)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<short, short> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 100000007;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator > (const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nvector<string> s;\nint x, y;\n\nvoid gotoend()\n{\n\ty = s[x].size();\n}\n\nvoid gotohome()\n{\n\ty = 0;\n}\n\nint check()\n{\n\tif (s[x].size() == 0 || y == s[x].size()) return 1;\n\telse return 0;\n}\n\n\nint main()\n{\n\tx = 0; y = 0;\n\tstring tmp;\n\tstring buf = \"karappo!!!!!!!!!\";\n\twhile (1)\n\t{\n\t\tcin >> tmp;\n\t\tif (tmp == \"END_OF_TEXT\") break;\n\t\ts.push_back(tmp);\n\t}\n\tchar com;\n\twhile (cin >> com)\n\t{\n\t\tif (com == '-') break;\n\t\telse if (com == 'a') gotohome();\n\t\telse if (com == 'e') gotoend();\n\t\telse if (com == 'p')\n\t\t{\n\t\t\tif (x == 0) gotohome();\n\t\t\telse \n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'n')\n\t\t{\n\t\t\tif (x < s.size() - 1) x++;\n\t\t\tgotohome();\n\t\t}\n\t\telse if (com == 'f')\n\t\t{\n\t\t\tif (check() == 0) y++;\n\t\t\telse if (check()==1&&x < s.size() - 1)\n\t\t\t{\n\t\t\t\tx++;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'b')\n\t\t{\n\t\t\tif (y > 0) y--;\n\t\t\telse if (y == 0 && x > 0)\n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tgotoend();\n\t\t\t}\n\t\t}\n\t\telse if (com == 'd')\n\t\t{\n\t\t\tif (check() == 0) s[x].erase(y, 1);\n\t\t\telse if (check() == 1 && x < s.size() - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\ts.erase(begin(s) + x + 1);\n\t\t\t}\n\t\t}\n\t\telse if (com == 'k')\n\t\t{\n\t\t\tif (check() == 1 && x < s.size() - 1)\n\t\t\t{\n\t\t\t\ts[x] += s[x + 1];\n\t\t\t\ts.erase(begin(s) + x + 1);\n\t\t\t\tbuf = \"kaigyousuru!!!!!!!\";\n\t\t\t}\n\t\t\t\n\t\t\telse if (check()==0)\n\t\t\t{\n\t\t\t\tbuf = s[x].substr(y);\n\t\t\t\ts[x].erase(y);\n\t\t\t}\n\t\t}\n\t\telse if (com == 'y')\n\t\t{\n\t\t\tif (buf == \"karappo!!!!!!!!!\") goto next;\n\t\t\telse if (buf == \"kaigyousuru!!!!!!!\")\n\t\t\t{\n\t\t\t\tstring tmp = s[x].substr(y);\n\t\t\t\ts.insert(begin(s) + x + 1, tmp);\n\t\t\t\ts[x].erase(y);\n\t\t\t\tx++;\n\t\t\t\tgotohome();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts[x].insert(y, buf);\n\t\t\t\ty += buf.size();\n\t\t\t}\n\t\t}\n\n\tnext:;\n\t}\n\tREP(i, s.size())\n\t{\n\t\tcout << s[i] << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n)-1;i>=(m);--i)\n#define repc(i,n) for(int i=0;i<=(n);++i)\n#define repcn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repcd(i,n) for(int i=(n);i>=0;--i)\n#define repcnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define repc0(i,n) for(i=0;i<=(n);++i)\n#define repcn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repcd0(i,n) for(i=(n);i>=0;--i)\n#define repcnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE cout<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nstring str[111];\n\nint main() {\n\tint h = 0;\n\tIL {\n\t\tcin >> str[h];\n\t\tif (str[h] == \"END_OF_TEXT\") break;\n\t\t++h;\n\t}\n\tint x = 0, y = 0;\n\tstring com, buf = \"\";\n\tIL {\n\t\tcin >> com;\n\t\tif (com == \"a\") {\n\t\t\tx = 0;\n\t\t} else if (com == \"e\") {\n\t\t\tx = sz(str[y]);\n\t\t} else if (com == \"p\") {\n\t\t\tx = 0;\n\t\t\tif (y > 0) --y;\n\t\t} else if (com == \"n\") {\n\t\t\tx = 0;\n\t\t\tif (y < h - 1) ++y; \n\t\t} else if (com == \"f\") {\n\t\t\tif (x < sz(str[y])) ++x;\n\t\t\telse if (y < h - 1) {x = 0; ++y;}\n\t\t} else if (com == \"b\") {\n\t\t\tif (x > 0) --x;\n\t\t\telse if (y > 0) {--y; x = sz(str[y]);}\n\t\t} else if (com == \"d\") {\n\t\t\tif (x < sz(str[y])) str[y] = str[y].substr(0, x) + str[y].substr(x + 1);\n\t\t\telse if (y < h - 1) {\n\t\t\t\tstr[y] += str[y + 1];\n\t\t\t\t--h;\n\t\t\t\trepn (i, y + 1, h) str[i] = str[i + 1];\n\t\t\t}\n\t\t} else if (com == \"k\") {\n\t\t\tif (x == sz(str[y])) {\n\t\t\t\tif (y < h - 1) {\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t\tstr[y] += str[y + 1];\n\t\t\t\t\t--h;\n\t\t\t\t\trepn (i, y + 1, h) str[i] = str[i + 1];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbuf = str[y].substr(x);\n\t\t\t\tstr[y] = str[y].substr(0, x);\n\t\t\t\tx = sz(str[y]);\n\t\t\t}\n\t\t} else if (com == \"y\") {\n\t\t\tif (buf == \"\\n\") {\n\t\t\t\t++h;\n\t\t\t\trepn (i, y + 2, h) str[i] = str[i - 1];\n\t\t\t\tstr[y + 1] = str[y].substr(x);\n\t\t\t\tstr[y] = str[y].substr(0, x);\n\t\t\t\tx = 0;\n\t\t\t\t++y;\n\t\t\t} else if (sz(buf)  > 0) {\n\t\t\t\tstr[y] = str[y].substr(0, x) + buf + str[y].substr(x);\n\t\t\t\tx += sz(buf);\n\t\t\t}\n\t\t} else if (com == \"-\") {\n\t\t\tbreak;\n\t\t}\n\t}\n\trep (i, h) cout << str[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nint main(){\n  char str[128][1024],c,buf[1024];\n  string input;\n  int i,j,now_x,now_y,y_max;\n\n  memset(str,0,sizeof(str));\n  memset(buf,0,sizeof(buf));\n  for(i=0;getline(cin,input);i++){\n    if(input==\"END_OF_TEXT\")break;\n    strcpy(str[i],input.c_str());\n  }\n  y_max=i-1;\n  now_x=now_y=0;\n  for(;scanf(\" %c \",&c),c!='-';){\n    if(c=='a') //¶°¿Ùð»ÝÌsÌæª\n      {\n        now_x=0;\n      }\n    else if(c=='e') //J[\\ð»ÝÌsÌs\n      {\n        now_x=strlen(str[now_y]);\n      }\n    else if(c=='p') //ãÉsª êÎJ[\\ðãÌsÌæªAÈ­Äàæª\n      {\n        if(now_y>0)now_y--;\n        now_x=0;\n      }\n    else if(c=='n') //ºÉsª ``\n      {\n        if(now_y<y_max)now_y++;\n        now_x=0;\n      }\n    else if(c=='f') //¶°¿ÙªsÅÈ¢Æ«EÉÚ®AsºÉsª éÆ«ºÌsÌæªAÈ¢Æ«Í½àµÈ¢\n      {\n        if(now_x!=strlen(str[now_y]))now_x++;\n        else{\n          if(now_y<y_max)now_y++,now_x=0;\n        }\n      }\n    else if(c=='b') //¶°¿Ùªæª¶ÅÈ¢Èç¶°¿Ùð¶ÉÚ®AæªãÉsª``\n      {\n        if(now_x>0)now_x--;\n        else{\n          if(now_y>0)now_y--,now_x=strlen(str[now_y]);\n        }\n      }\n    else if(c=='d')//¶°¿Ùª¶ðw·êíAí³ê½¶ÌE¤Í¶É¼ÌÄ``\n      {\n        if(now_x!=strlen(str[now_y])){\n          for(i=now_x;i<strlen(str[now_y]);i++)str[now_y][i]=str[now_y][i+1];\n        }\n        else{//¶°¿ÙªsÌÆ«\n          if(now_y<y_max){\n            strcat(str[now_y],str[now_y+1]);\n            y_max=now_y;\n            for(i=now_y+1;i<127;i++){\n              strcpy(str[i],str[i+1]);\n              if(str[i][0]!=0)y_max=i;\n            }\n          }\n        }\n      }\n    else if(c=='k') //\n      {\n        if(now_x==strlen(str[now_y])){\n          if(now_y<y_max){\n            strcat(str[now_y],str[now_y+1]);\n            y_max=now_y;\n            for(i=now_y+1;i<127;i++){\n              strcpy(str[i],str[i+1]);\n              if(str[i][0]!=0)y_max=i;\n            }\n            buf[0]='\\n'; buf[1]=0;\n          }\n        }else{\n          strcpy(buf,str[now_y]+now_x);\n          str[now_y][now_x]=0;\n          now_x=strlen(str[now_y]);\n          \n        }\n      }\n    else if(c=='y') //\n      {\n        if(buf[0]!=0){\n          if(buf[0]=='\\n'){\n            for(i=126;i>now_y;i--)strcpy(str[i+1],str[i]);\n            strcpy(str[now_y+1],str[now_y]+now_x);\n            str[now_y][now_x]=0;\n            now_y++; now_x=0;\n            y_max++;\n          }else{\n            char tmp[1024];\n            strcpy(tmp,str[now_y]+now_x);\n            for(i=now_x,j=0;j<strlen(buf);)str[now_y][i++]=buf[j++];\n            str[now_y][i]=0;\n            now_x=i;\n            strcat(str[now_y],tmp);\n          }\n        }\n      }\n    //printf(\"y_max:%d\\n\",y_max);\n    //for(i=0;i<=y_max;i++)printf(\"%d:%s\\n\",i,str[i]);\n    //printf(\"%c-----------------now_x:%d , now_y:%d , y_max:%d\\n\",c,now_x,now_y,y_max);\n  }\n  for(i=0;i<=y_max;i++)puts(str[i]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cassert>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for (int i = a; i < (int)(b); ++i)\n#define FORD(i,a,b) for (int i = a; i >= (int)(b); --i)\n#define FOREACH(it,c) for(typeof(c.begin()) it = c.begin(); it != c.end(); ++it)\n\nint x = 0, y = 0;\nvector<string> buf;\n\nint main() {\n  vector<string> lines;\n  string str;\n  while (getline(cin,str)) {\n    if (str == \"END_OF_TEXT\") break; \n    lines.push_back(str);\n  }\n  char c;\n  while (cin>>c, c != '-') {\n    switch (c) {\n    case 'a': {\n      x = 0;\n    } break;\n    case 'e': {\n      x = lines[y].size();\n    } break;\n    case 'p': {\n      if (y != 0) y--;\n      x = 0;\n    } break;\n    case 'n': {\n      if (y != lines.size()-1) y++;\n      x = 0;\n    } break;\n    case 'f': {\n      if (x != lines[y].size()) x++;\n      else if (y != lines.size()-1) {\n\ty++; x = 0;\n      }\n    } break;\n    case 'b': {\n      if (x != 0) x--;\n      else if (y != 0) {\n\ty--; x = lines[y].size();\n      }\n    } break;\n    case 'd': {\n      if (x != lines[y].size()) {\n\tFOR(i,x,lines[y].size()-1) {\n\t  lines[y][i] = lines[y][i+1];\n\t}\n\tlines[y].resize(lines[y].size()-1);\n      } else if (y != lines.size()-1) {\n\tlines[y]+=lines[y+1];\n\tFOR(i,y+1,lines.size()-1) {\n\t  lines[i] = lines[i+1];\n\t}\n\tlines.resize(lines.size()-1);\n      }\n    } break;\n    case 'k': {\n      if (x != lines[y].size()) {\n\tstring tmp;\n\tFOR(i,x,lines[y].size()) {\n\t  tmp += lines[y][i];\n\t}\n\tlines[y].resize(x);\n\tbuf = vector<string>(1,tmp);\n      } else if (y != lines.size()-1) {\n\tlines[y]+=lines[y+1];\n\tFOR(i,y+1,lines.size()-1) {\n\t  lines[i] = lines[i+1];\n\t}\n\tlines.resize(lines.size()-1);\n\tbuf = vector<string>(1, \"\");\n      }\n    } break;\n    case 'y': {\n      if (buf.size()) {\n\tif (buf[0] == \"\") {\n\t  string tmp = lines[y].substr(0,x);\n\t  lines.resize(lines.size()+1);\n\t  FORD(i,lines.size()-1,y+2) {\n\t    lines[i] = lines[i-1];\n\t  }\n\t  lines[y+1] = lines[y].substr(x);\n\t  lines[y] = tmp;\n\t  y++; x = 0;\n\t} else {\n\t  string tmp = lines[y].substr(x);\n\t  lines[y] = lines[y].substr(0,x);\n\t  lines[y] += buf[0];\n\t  lines[y] += tmp;\n\t  x += buf[0].size();\n\t}\n      } \n    } break;\n    default: assert(false);\n    }\n  }\n  REP(i,lines.size())\n    cout<<lines[i]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nchar t[2000000];\nint ts;\n\nchar u[1000000];\nint us;\n\nchar ch;\nint pos;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nint main(){\n\n  input();\n  pos=0;\n\n  while(1){\n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    /*\n    cout<<ch<<' '<<pos<<endl;\n    for(int i=0;i<ts;i++){\n      cout<<t[i];\n    }\n    cout<<endl;\n    */\n  }\n    for(int i=0;i<ts;i++){\n      cout<<t[i];\n    }\n\n  return 0;\n}\n\nvoid funcA(){\n  for(int i=pos-1;;i--){\n    if(i<=0){pos=0;return;}\n    if(t[i]=='\\n'){pos=i+1;return;}\n  }\n}\n\nvoid funcE(){\n  for(int i=pos;;i++){\n    if(i>=ts){pos=ts-1;return;}\n    if(t[i]=='\\n'){pos=i;return;}\n  }\n}\n\nvoid funcP(){\n  funcA();\n  if(pos==0)return;\n  pos--;\n  funcA();\n}\n\nvoid funcN(){ \n  funcE();\n  if(pos==ts-1)return;\n  pos++;\n}\n\nvoid funcF(){ \n  if(pos+1<ts)pos++;\n}\n\nvoid funcB(){\n  if(pos>0)pos--;\n}\n\nvoid funcD(){\n  ts--;\n  for(int i=pos;i<ts;i++){\n    t[i]=t[i+1];\n  }\n}\n\nvoid funcK(){\n  if(pos==ts-1)return;\n\n  if(t[pos]=='\\n'){\n    us=1;\n    u[0]='\\n';\n    funcD();\n    return;\n  }\n  us=0;\n  int c=0;\n  for(int i=pos;;i++){\n    if(t[i]=='\\n')break;\n    u[us++]=t[i];\n    c++;\n  }\n  ts-=c;\n  for(int i=pos;i<ts;i++){\n    t[i]=t[i+c];\n  }\n}\n\nvoid funcY(){\n  if(us==0)return;\n  if(u[0]=='\\n'&&us==1){\n    ts++;\n    for(int i=ts-1;i>pos;i--)t[i]=t[i-1];\n    t[pos]='\\n';\n    pos++;return;\n  }\n  \n  ts+=us;\n  for(int i=ts-1;i>=pos+us;i--){\n    t[i]=t[i-us];\n  }\n  for(int i=pos;i<pos+us;i++){\n    t[i]=u[i-pos];\n  }\n  pos+=us;\n}\n\nvoid input(){\n  ts=us=0;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    for(int i=0;i<(int)str.size();i++)\n      t[ts++]=str[i];\n    t[ts++]='\\n';\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t,u;\nvector<char> tmp;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nvoid yinsert(int,vector<char>);\nvoid xinsert(int,int,char);\nvoid ydelete(int);\nvoid xdelete(int,int);\n\nint main(){\n\n  t.clear();\n  tmp.clear();\n  input();\n  x=y=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n    //cout<<y<<' '<<x<<\" ty\"<<t.size()<<endl;\n  }\n\n  for(int i=0;i<t.size();i++){\n    for(int j=0;j<t[i].size();j++){\n      cout<<t[i][j];\n    }\n  }\n\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    xdelete(y,x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  xdelete(y,x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  ydelete(y+1);\n}\n\nvoid funcK(){\n  tmp.clear();\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.push_back('\\n');\n    }\n    return;\n  }\n  while(t[y][x]!='\\n'){\n    tmp.push_back(t[y][x]);\n    xdelete(y,x);\n  }\n  reverse(tmp.begin(),tmp.end());\n\n}\n\nvoid funcY(){\n  \n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    vector<char> z;\n    while(t[y][x]!='\\n'){\n      z.push_back(t[y][x]);\n      xdelete(y,x);\n    }\n    yinsert(y+1,z);\n    return;\n  }\n  for(int i=0;i<(int)tmp.size();i++){\n    xinsert(y,x,tmp[i]);\n  }\n  \n}\n\nvoid input(){\n  vector<char> a;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n}\n\n\n\n\n\n\n\n\nvoid xinsert(int y,int x,char ch){\n  if(x==(int)t[y].size()){\n    t[y].push_back(ch);\n  }else{\n    vector<char> z;\n    z=t[y];\n    t[y].clear();\n    for(int i=0;i<(int)z.size();i++){\n      if(i==x)t[y].push_back(ch);\n      t[y].push_back(z[i]);\n    }\n  }\n}\n\nvoid xdelete(int y,int x){\n  if(x+1==(int)t[y].size()){\n    t[y].pop_back();\n  }else{\n    vector<char> z;\n    z=t[y];\n    t[y].clear();\n    for(int i=0;i<(int)z.size();i++){\n      if(i==x)continue;\n      t[y].push_back(z[i]);\n    }\n  }\n}\n\nvoid yinsert(int y,vector<char> ch){\n  if(y==(int)t.size()){\n    t.push_back(ch);\n  }else{\n    u=t;\n    t.clear();\n    for(int i=0;i<(int)u.size();i++){\n      if(i==y)t.push_back(ch);\n      t.push_back(u[i]);\n    }\n  }\n}\n\nvoid ydelete(int y){\n  if(y+1==(int)t.size()){\n    t.pop_back();\n  }else{\n    u=t;\n    t.clear();\n    for(int i=0;i<(int)u.size();i++){\n      if(i==y)continue;\n      t.push_back(u[i]);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\n\nint main()\n{\t\t\n\tvector<string> snt;\n\tstring buffer;\n\t\n\t\n\tfor(string line; getline(cin, line) && line != \"END_OF_TEXT\";snt.push_back(line));\n\t\n\tpint cur = mp(0, 0); // := first = x, second = y\n\tfor(char com; cin >> com && com != '-';)\n\t{\n\t\tswitch(com)\n\t\t{\n\t\t\t\t/*\n\t\t\t\t a\n\t\t\t\t J[\\ð»ÝÌsÌæª¶ÉÚ®·éB\n\t\t\t\t */\n\t\t\tcase 'a':\n\t\t\t{\n\t\t\t\tcur.first = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t e\n\t\t\t\t J[\\ð»ÝÌsÌsÉÚ®·éB\n\t\t\t\t */\n\t\t\tcase 'e':\n\t\t\t{\n\t\t\t\tcur.first = snt[cur.second].size();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t p\n\t\t\t\t ãÉsª êÎAJ[\\ðãÌsÌæª¶ÉÚ®·éB\n\t\t\t\t ãÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t\t */\n\t\t\tcase 'p':\n\t\t\t{\n\t\t\t\tcur.second -= cur.second != 0;\n\t\t\t\tcur.first = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t n\n\t\t\t\t ºÉsª êÎAJ[\\ðºÌsÌæª¶ÉÚ®·éB\n\t\t\t\t ºÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t\t */\n\t\t\tcase 'n':\n\t\t\t{\n\t\t\t\tcur.second += cur.second + 1 != snt.size();\n\t\t\t\tcur.first = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t f\n\t\t\t\t J[\\ªsÉÈ¢êAJ[\\ðPÂEÉÚ®·éB\n\t\t\t\t J[\\ªsÉ è©ÂºÉsª éêÍAJ[\\ðºÌsÌæª¶ÖÚ®·éB\n\t\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t\t */\n\t\t\tcase 'f':\n\t\t\t{\n\t\t\t\tif(cur.first != snt[cur.second].size())\n\t\t\t\t{\n\t\t\t\t\tcur.first++;\n\t\t\t\t}\n\t\t\t\telse if(cur.second + 1 != snt.size())\n\t\t\t\t{\n\t\t\t\t\tcur.first = 0;\n\t\t\t\t\tcur.second++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t b\n\t\t\t\t J[\\ªæª¶ÅÈ¢ÈçÎAJ[\\ðPÂ¶ÉÚ®·éB\n\t\t\t\t J[\\ªæª¶Å è©ÂãÉsª éêÍAJ[\\ðãÌsÌsÖÚ®·éB\n\t\t\t\t »êÈOÌêÍ½àµÈ¢\n\t\t\t\t */\n\t\t\tcase 'b':\n\t\t\t{\n\t\t\t\tif(cur.first != 0)\n\t\t\t\t{\n\t\t\t\t\tcur.first--;\n\t\t\t\t}\n\t\t\t\telse if(cur.second != 0)\n\t\t\t\t{\n\t\t\t\t\tcur.second--;\n\t\t\t\t\tcur.first = snt[cur.second].size();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t d\n\t\t\t\t J[\\ª¶ðw·êÍ»Ì¶ðí·éBí³ê½¶ÌE¤Ì¶ñÍ¶ÉVtg³êéB\n\t\t\t\t J[\\ªsðwµºÉsª éêÍAºÌsð»ÌÜÜJ[\\ÌÊuÉq°éBÈºÌsÍãÉVtg³êéB\n\t\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t\t */\n\t\t\tcase 'd':\n\t\t\t{\n\t\t\t\tif(cur.first != snt[cur.second].size())\n\t\t\t\t{\n\t\t\t\t\tstring &line = snt[cur.second];\n\t\t\t\t\t\n\t\t\t\t\tline = line.substr(0, cur.first) + line.substr(cur.first + 1);\n\t\t\t\t}\n\t\t\t\telse if(cur.second + 1 != snt.size())\n\t\t\t\t{\n\t\t\t\t\tsnt[cur.second] += snt[cur.second + 1];\n\t\t\t\t\t\n\t\t\t\t\trotate(snt.begin() + cur.second + 1, snt.begin() + cur.second + 2, snt.end());\n\t\t\t\t\t\n\t\t\t\t\tsnt.erase(snt.begin() + snt.size() - 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t k\n\t\t\t\t J[\\ªsÉ éêAºÉsª êÎAd Æ¯¶ìðµobt@ÉPÂÌüsðL^·éB\n\t\t\t\t J[\\ªsÉÈ¢êAJ[\\ªw·¶ðÜß½E¤·×ÄÌ¶ðØèæè»êðobt@ÉL^·éBJ[\\Í³ÌsÌsðw·æ¤ÉÈéBSÄÌL^É¨¢Äobt@Íã«³êéB\n\t\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t\t */\n\t\t\tcase 'k':\n\t\t\t{\n\t\t\t\tif(cur.first == snt[cur.second].size())\n\t\t\t\t{\n\t\t\t\t\tif(cur.first != snt[cur.second].size())\n\t\t\t\t\t{\n\t\t\t\t\t\tstring &line = snt[cur.second];\n\t\t\t\t\t\t\n\t\t\t\t\t\tline = line.substr(0, cur.first) + line.substr(cur.first + 1);\n\t\t\t\t\t}\n\t\t\t\t\telse if(cur.second + 1 != snt.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tsnt[cur.second] += snt[cur.second + 1];\n\n\t\t\t\t\t\trotate(snt.begin() + cur.second + 1, snt.begin() + cur.second + 2, snt.end());\n\t\t\t\t\t\t\n\t\t\t\t\t\tsnt.erase(snt.begin() + snt.size() - 1);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbuffer = snt[cur.second].substr(cur.first);\n\t\t\t\t\tsnt[cur.second] = snt[cur.second].substr(0, cur.first);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/*\n\t\t\t\t y\n\t\t\t\t obt@ªóÌêÍÈÉàµÈ¢B\n\t\t\t\t obt@ÌàeªüsÌêAJ[\\ªw·¶Ì¼OÅüsðs¤BJ[\\ÍVµ¢sÌæª¶ÖÚ®·éB\n\t\t\t\t obt@Ìàeª¶ñÌêAJ[\\ÌÊuÉobt@Ìàeð}ü·éB J[\\ÌÊuÍàÆàÆwµÄ¢½¶Ü½ÍsÌêÖÚ®·é\n\t\t\t\t */\n\t\t\tcase 'y':\n\t\t\t{\n\t\t\t\tif(buffer != \"\")\n\t\t\t\t{\n\t\t\t\t\tif(buffer == \"\\n\")\n\t\t\t\t\t{\n\t\t\t\t\t\tstring &line = snt[cur.second];\n\t\t\t\t\t\tsnt.push_back(snt[snt.size() - 1]);\n\t\t\t\t\t\t\n\t\t\t\t\t\trotate(snt.begin() + cur.second + 1, snt.begin() + snt.size() - 2, snt.begin() + snt.size() - 1);\n\t\t\t\t\t\tsnt[cur.second + 1] = line.substr(cur.first);\n\t\t\t\t\t\tline = line.substr(0, cur.first);\n\t\t\t\t\t\t\n\t\t\t\t\t\tcur.second++;\n\t\t\t\t\t\tcur.first = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tstring &line = snt[cur.second];\n\t\t\t\t\t\tline = line.substr(0, cur.first) + buffer + line.substr(cur.first);\n\t\t\t\t\t\t\n\t\t\t\t\t\tcur.first += buffer.size();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\trep(i, snt.size()) cout << snt[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main()\n{\n\tstring str[300];\n\tstring b;\n\tb[0] = '*';\n\tint y = 0, y2;\n\t\n\twhile (getline(std::cin, str[y]), str[y] != \"END_OF_TEXT\"){\n\t\ty++;\n\t}\n\ty2 = --y;\n\t\n\tchar cmd[2];\n\tint car = 0, car_y = 0;\n\t\n\twhile (scanf(\"%s\", cmd), cmd[0] != '-'){\n\t\tif (cmd[0] == 'a'){\n\t\t\tcar = 0;\n\t\t}\n\t\tif (cmd[0] == 'e'){\n\t\t\tcar = str[car_y].size();\n\t\t}\n\t\tif (cmd[0] == 'p'){\n\t\t\tif (car_y == 0){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y--;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'n'){\n\t\t\tif (car_y != y){\n\t\t\t\tcar_y++;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\t\n\t\t\telse {\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'f'){\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tcar++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tcar_y++;\n\t\t\t\t\tcar = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'b'){\n\t\t\tif (car != 0){\n\t\t\t\tcar--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != 0){\n\t\t\t\t\tcar_y--;\n\t\t\t\t\tcar = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'd'){\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tstr[car_y].erase(car, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = y - 1;\n\t\t\t\t\ty = car_y;\n\t\t\t\t\twhile (++y < y2){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y].erase();\n\t\t\t\t\t\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'k'){\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y){\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = y;\n\t\t\t\t\ty = car_y;\n\t\t\t\t\twhile (++y < y2){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y].erase();\n\t\t\t\t\t\n\t\t\t\t\ty = y2;\n\t\t\t\t\tb[0] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb = str[car_y].substr(car);\n\t\t\t\tstr[car_y].erase(car);\n\t\t\t\tcar = str[car_y].size();\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'y'){\n\t\t\tif(b[0] != '*'){\n\t\t\t\tif (b[0] == '\\0'){\n\t\t\t\t\ty2 = y + 1;\n\t\t\t\t\twhile (y > car_y + 1){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstr[y] = str[car_y].substr(car);\n\t\t\t\t\tstr[car_y].erase(car);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstr[car_y].insert(car, b);\n\t\t\t\t\tcar += b.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int j = 0; j <= y; j++){\n\t\tcout << str[j] << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main(){\n\tstring str[100];\n\tstring s;\n\tint size = 0;\n\twhile(getline(cin,s)){\n\t\tif(s == \"END_OF_TEXT\") break;\n\t\tstr[size++] = s;\n\t}\n\tchar ch;\n\tstring buf = \"\";\n\tint line = 0, pos = 0;\n\twhile(cin >> ch){\n\t\tif(ch == '-') break;\n\t\tif(ch == 'a') pos = 0;\n\t\tif(ch == 'e') pos = str[line].size();\n\t\tif(ch == 'p'){\n\t\t\tpos = 0;\n\t\t\tif(line!=0) line--;\n\t\t}\n\t\tif(ch == 'n'){\n\t\t\tpos = 0;\n\t\t\tif(line+1!=size) line++;\n\t\t}\n\t\tif(ch == 'f'){\n\t\t\tif(pos != str[line].size()) pos++;\n\t\t\telse if(line+1!=size) { pos = 0; line++; }\n\t\t}\n\t\tif(ch == 'b'){\n\t\t\tif(pos != 0) pos--;\n\t\t\telse if(line!=0) { line--; pos = str[line].size(); }\n\t\t}\n\t\tif(ch == 'd'){\n\t\t\tif(pos != str[line].size()){\n\t\t\t\tstr[line] = str[line].substr(0,pos) + str[line].substr(pos+1);\n\t\t\t} else if(line+1!=size){\n\t\t\t\tstr[line] = str[line] + str[line+1];\n\t\t\t\tfor(int i=line+1;i+1<size;i++){\n\t\t\t\t\tstr[i] = str[i+1];\n\t\t\t\t}\n\t\t\t\tstr[size-1] = \"\";\n\t\t\t\tsize--;\n\t\t\t}\n\t\t}\n\t\tif(ch == 'k'){\n\t\t\tif(pos == str[line].size() && line+1!=size){\n\t\t\t\tstr[line] = str[line] + str[line+1];\n\t\t\t\tfor(int i=line+1;i+1<size;i++){\n\t\t\t\t\tstr[i] = str[i+1];\n\t\t\t\t}\n\t\t\t\tstr[size-1] = \"\";\n\t\t\t\tsize--;\n\t\t\t\tbuf = \"\\n\";\n\t\t\t}\n\t\t\telse if(pos < str[line].size()){\n\t\t\t\tbuf = str[line].substr(pos);\n\t\t\t\tstr[line] = str[line].substr(0,pos);\n\t\t\t}\n\t\t}\n\t\tif(ch == 'y'){\n\t\t\tif(buf == \"\\n\"){\n\t\t\t\tfor(int i=line+1;i<size;i++){\n\t\t\t\t\tstr[i+1] = str[i];\n\t\t\t\t}\n\t\t\t\tsize++;\n\t\t\t\tstr[line+1] = str[line].substr(pos);\n\t\t\t\tstr[line] = str[line].substr(0,pos);\n\t\t\t\tline++;\n\t\t\t\tpos = 0;\n\t\t\t} else if(buf != \"\"){\n\t\t\t\tstr[line] = str[line].substr(0,pos) + buf + str[line].substr(pos);\n//\t\t\t\tpos += buf.size();\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tcout << line << \" \" << pos << endl;\n\t\tfor(int i=0;i<size;i++){\n\t\t\tcout << str[i] << endl;\t\n\t\t}\n\t\tputs(\"\");\n\t\t*/\n\t}\n\tfor(int i=0;i<size;i++){\n\t\tcout << str[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint crow = 0, ccol = 0;\nstring buf = \"\";\nvector<string> lines;\n\nvoid input() {\n    while(1) {\n        string s;\n        getline(cin, s);\n        if(s == \"END_OF_TEXT\") break;\n        lines.push_back(s + \"\\n\");\n    }\n}\n\nvoid assign_buf(string s, bool is_cl_only=false) {\n    buf = s;\n    if(!is_cl_only) {\n        assert(buf.back() == '\\n');\n        buf.pop_back();\n    }\n}\n\nbool is_col_begin() { return ccol == 0; }\nbool is_col_end() { return ccol + 1 == lines[crow].size(); }\nbool is_row_begin() { return crow == 0; }\nbool is_row_end() { return crow + 1 == lines.size(); }\n\nint get_col_begin() { return 0; }\nint get_col_end() { return (int)lines[crow].size() - 1; }\nint get_row_begin() { return 0; }\nint get_row_end() { return (int)lines.size() - 1; }\n\nvoid up()   { crow = max(get_row_begin(), crow - 1); ccol = 0; }\nvoid down() { crow = max(get_row_end()  , crow + 1); ccol = 0; }\nvoid right() {\n    if(is_col_end() && is_row_end()) return;\n\n    if(is_col_end()) down(), ccol = get_col_begin();\n    else             ccol++;\n}\nvoid left() {\n    if(is_col_begin() && is_row_begin()) return;\n\n    if(is_col_begin()) up(), ccol = get_col_end();\n    else               ccol--;\n}\n\nvoid delete_char() {\n    if(is_col_end()) {\n        if(is_row_end()) return;\n        string &target = lines[crow];\n        target.pop_back();\n        target += lines[crow + 1];\n        lines.erase(lines.begin() + crow + 1);\n    }\n    else {\n        lines[crow].erase(lines[crow].begin() + ccol);\n    }\n}\n\nbool operate(char op) {\n    assert(crow >= 0 && ccol >= 0);\n    assert(crow + 1 <= lines.size());\n    assert(ccol + 1 <= lines[crow].size());\n\n    if(op == 'a') {\n        ccol = get_col_begin();\n    }\n    if(op == 'e') {\n        ccol = get_col_end();\n    }\n    if(op == 'p') {\n        up();\n    }\n    if(op == 'n') {\n        down();\n    }\n    if(op == 'f') {\n        right();\n    }\n    if(op == 'b') {\n        left();\n    }\n    if(op == 'd') {\n        delete_char();\n    }\n    if(op == 'k') {\n        if(is_col_end()) {\n            if(!is_row_end()) {\n                delete_char();\n                assign_buf(\"\\n\", true);\n            }\n        }\n        string &target = lines[crow];\n        assign_buf(target.substr(ccol));\n        target = target.substr(0, ccol) + \"\\n\";\n    }\n    if(op == 'y') {\n        if(buf.size()) {\n            if(buf == \"\\n\") {\n                string &target = lines[crow];\n                string s1 = target.substr(0, ccol);\n                string s2 = target.substr(ccol);\n\n                target = s1;\n                lines.insert(lines.begin() + crow + 1, s2);\n\n                down();\n            }\n            else {\n                string &target = lines[crow];\n                target.insert(ccol, buf);\n                ccol += buf.size();\n            }\n        }\n    }\n    return op == '-';\n}\n\nint main() {\n    input();\n\n    while(1) {\n        char c; cin >> c;\n        if(operate(c)) break;\n    }\n    for(auto x : lines) {\n        cout << x;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<sstream>\n#include<map>\n#include<vector>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nstring cash;\n\nvoid A(P& cursor)\n{\n  cursor.S = 0;\n}\n\nvoid E(P& cursor,vector<string>& buffer)\n{\n  cursor.S = buffer[cursor.F].size()-1;\n}\n\nvoid PP(P& cursor,vector<string>& buffer)\n{\n  if(cursor.F-1 >= 0)\n    cursor.F--,cursor.S = 0;\n  else \n    cursor.S = 0;\n}\n\nvoid N(P& cursor,vector<string>& buffer)\n{\n  if(cursor.F+1 < buffer.size())\n    cursor.F++,cursor.S = 0;\n  else\n    cursor.S = 0;\n}\n\nvoid F(P& cursor,vector<string>& buffer)\n{\n  if(cursor.S+1 < buffer[cursor.F].size())\n    cursor.S++;\n  else if(buffer[cursor.F].size()-1 == cursor.S && cursor.F+1 < buffer.size())\n    cursor.F++,cursor.S = 0;\n}\n\nvoid B(P& cursor,vector<string>& buffer)\n{\n  if(cursor.S != 0)\n    cursor.S--;\n  else if(cursor.S == 0 && cursor.F-1 >= 0)\n    cursor.F--,cursor.S = buffer[cursor.F].size()-1;\n}\n\nvoid D(P& cursor,vector<string>& buffer)\n{\n  if(cursor.S != buffer[cursor.F].size()-1)\n    {\n      string pre,bef;\n    for(int i=0;i<buffer[cursor.F].size();i++)\n      if(i == cursor.S)\n\tcontinue;\n      else if(i < cursor.S)      \n\tpre += buffer[cursor.F][i];\n      else \n\tbef += buffer[cursor.F][i];\n\n    buffer[cursor.F] = pre;\n    buffer[cursor.F] += bef;\n    }\n    else if(cursor.F+1 < buffer.size())\n    {\n      int Size = buffer[cursor.F].size();\n      for(int i=0;i<buffer[cursor.F+1].size();i++)\n\t{\n\t  if(cursor.S+i < Size)\n\t    buffer[cursor.F][cursor.S+i] = buffer[cursor.F+1][i];\n\t  else \n\t    buffer[cursor.F] += buffer[cursor.F+1][i];\n\t}\n\n      for(int i=cursor.F+1;i<buffer.size()-1;i++)\n\tbuffer[i] = buffer[i+1];\n      buffer.erase(buffer.end());\n    }\n}\n\nvoid K(P& cursor,vector<string>& buffer)\n{\n  if(cursor.S == buffer[cursor.F].size()-1)\n    {\n      D(cursor,buffer);\n      cash = \" \";   \n    }\n  else\n    {\n      cash.clear();\n      string pre;\n      for(int i=0;i<buffer[cursor.F].size();i++)\n\tif(cursor.S <= i)\n\t  cash += buffer[cursor.F][i];\n\telse \n\t  pre += buffer[cursor.F][i];\n      buffer[cursor.F] = pre + \" \";\n      cursor.S = buffer[cursor.F].size()-1;\n    }\n}\n\nvoid Y(P& cursor,vector<string>& buffer)\n{\n  if(cash.size() == 0)\n    return;\n\n  if(cash.size() == 1)\n    {\n      buffer.push_back(\"\");\n      for(int i=buffer.size()-1;i>cursor.F;i--)\n\tbuffer[i] = buffer[i-1];\n     \n      string pre,bef;\n      for(int i=cursor.S;i<buffer[cursor.F].size();i++)\n\t{\n\t  if(i < cursor.S)\n\t    pre += buffer[cursor.F][i];\n\t  else \n\t    bef += buffer[cursor.F][i];\n\t}\t\n      buffer[cursor.F].clear();\n      buffer[cursor.F] = pre+\" \";\n      buffer[cursor.F+1] = bef;\n      cursor.F++,cursor.S = 0;\n      return;\n    }\n\n  string pre,bef;\n      for(int i=0;i<buffer[cursor.F].size();i++)\n\t{\n\t  if(i < cursor.S)\n\t    pre += buffer[cursor.F][i];\n\t  else \n\t    bef += buffer[cursor.F][i];\n\t}\t\n     \n      buffer[cursor.F] = pre;\n      buffer[cursor.F] += cash.substr(0,cash.size()-1);\n      cursor.S = buffer[cursor.F].size();\n      buffer[cursor.F] += bef;\n      \n}\n\nint main()\n{\n  \n \n      vector<string> buffer;\n      string line;\n      P cursor = P(0,0); //P(y、x)\n      cash.clear();\n\n      while(getline(cin,line),line != \"END_OF_TEXT\")\n\t{\n\t  buffer.push_back(line);  \n\t  buffer.back() += \" \";\n\t}\n\n      if(buffer.size() == 0)\n\tbuffer.push_back(\" \");\n\n      while(cin >> line,line != \"-\")\n\t{\n\t  if(line[0] == 'a')\n\t    A(cursor);\n\t  else if(line[0] == 'e')\n\t    E(cursor,buffer);\n\t  else if(line[0] == 'p')\n\t    PP(cursor,buffer);\n\t  else if(line[0] == 'n')\n\t    N(cursor,buffer);\n\t  else if(line[0] == 'f')\n\t    F(cursor,buffer);\n\t  else if(line[0] == 'b')\n\t    B(cursor,buffer);\n\t  else if(line[0] == 'd')\n\t    D(cursor,buffer);\n\t  else if(line[0] == 'k')\n\t    K(cursor,buffer);\n\t  else if(line[0] == 'y')\n\t    Y(cursor,buffer);\n\t  //cout <<line <<  \" ----------\" << endl;\n\t  //cout << \"cursor(\" << cursor.F << \" \"  << cursor.S << \")\" << endl;\n\t  //cout << \"cash = \" << cash << endl;\n\t  //for(int i=0;i<buffer.size();i++)\n\t  //cout << buffer[i].substr(0,buffer[i].size()-1) << \"||| \" << buffer[i].size() << endl;\t  \n\n\t}\n\n      for(int i=0;i<buffer.size();i++)\n\tcout << buffer[i].substr(0,buffer[i].size()-1) << endl;\n\t\n\n    \n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nstring s[102],buf;\nint l,r,N;\n\nvoid a(void){r=0;}\n\tvoid e(void){r=max(0,(int)s[l].size()-1);}\nvoid p(void){\n\tif(l>0)l--;\n\telse r=0;\n}\n\nvoid n(void){\n\tif(l<N-1)l++,r=0;\n\telse r=0;\n}\n\nvoid f(void){\n\tif(r<max(0,(int)s[l].size()-1))r++;\n\telse l++,r=0;\n}\n\nvoid b(void){\n\tif(r>0)r--;\n\telse if(l>0)r=s[--l].size();\n}\n\nvoid d(void){\n\tif(r==s[l].size()-1){\n\t\tif(l<N-1){\n\t\t\ts[l]+=s[l+1];\n\t\t\tfor(int i=l+1;i<N-1;i++)s[i]=s[i+1];\n\t\t\tN--;\n\t\t}\n\t}\n\telse s[l].erase(r,1);\n}\n\nvoid k(void){\n\tif(r==s[l].size() && l<N-1)d(),buf=\"\\n\";\n\telse {\n\t\tbuf=s[l].substr(max(0,r-1));\n\t\ts[l].erase(max(0,r-1));\n\t}\n}\n\nvoid y(void){\n\tif(buf.empty())return ;\n\tif(buf==\"\\n\"){\n\t\tfor(int i=N;i>l;i--)s[i]=s[i-1];\n\t\ts[l+1]=s[l].substr(max(0,r-1));\n\t\ts[l].erase(max(0,r-1));\n\t\tl++,r=0,N++;\n\t}\n\telse {\n\t\ts[l].insert(min((int)s[l].size(),r+1),buf);\n\t\tr+=buf.size();\n\t}\n}\n\n\nint main(void){\n\t\n\twhile(getline(cin,s[N])){\n\t\tif(s[N]==\"END_OF_TEXT\")break;\n\t\tN++;\n\t}\n\tl=r=0;\n\tbuf.clear();\n\t\n\t\t\n\tstring C;\n\twhile(cin >> C,C!=\"-\"){\n\t\t\n\t\tif(C==\"a\")a();\n\t\telse if(C==\"e\")e();\n\t\telse if(C==\"p\")p();\n\t\telse if(C==\"n\")n();\n\t\telse if(C==\"f\")f();\n\t\telse if(C==\"b\")b();\n\t\telse if(C==\"d\")d();\n\t\telse if(C==\"k\")k();\n\t\telse if(C==\"y\")y();\n\t}\n\t\n\tfor(int i=0;i<N;i++){\n\t\tcout << s[i] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define TOP_OF_BUFFER 0\n#define BEGIN_OF_LINE 0\n#define END_OF_LINE 10000\n\nstruct Cursor{\n  int x, y;\n  Cursor(){\n    x = 0, y = 0;\n  }\n};\n\nvector<string> buffer;\nstring buf;\nbool new_line;\nCursor cursor;\nint end;\n\nvoid output(){\n  for(int i = 0 ; i < end+1 ; i++){\n    cout << buffer[i] << endl;\n  }\n  //cout << endl;\n}\n\nvoid a_command(){\n  cursor.x = BEGIN_OF_LINE;\n}\n\nvoid e_command(){\n  cursor.x = END_OF_LINE;\n}\n\nvoid p_command(){\n  if(cursor.y == TOP_OF_BUFFER) cursor.x = BEGIN_OF_LINE;\n  else{\n    cursor.y--;\n    cursor.x = BEGIN_OF_LINE;\n  }\n}\n\nvoid n_command(){\n  if(cursor.y == end) cursor.x = BEGIN_OF_LINE;\n  else{\n    cursor.y++;\n    cursor.x = BEGIN_OF_LINE;\n  }\n}\n\nvoid f_command(){\n  if(cursor.x != END_OF_LINE) cursor.x++;\n  else if(cursor.x == END_OF_LINE && cursor.y != end){\n    cursor.x = BEGIN_OF_LINE;\n    cursor.y++;\n  }\n}\n\nvoid b_command(){\n  if(cursor.x != BEGIN_OF_LINE) cursor.x--;\n  else if(cursor.x == BEGIN_OF_LINE && cursor.y != TOP_OF_BUFFER){\n    cursor.x = END_OF_LINE;\n    cursor.y--;\n  }\n}\n\nvoid d_command(){\n  if(cursor.x == END_OF_LINE && cursor.y != end){\n    buffer[cursor.y] += buffer[cursor.y+1];\n    buffer.erase(buffer.begin() + cursor.y+1);\n    end--;\n  }\n  else if(cursor.x != END_OF_LINE){\n    buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n  }\n}\n\nvoid k_command(){\n  if(cursor.x == END_OF_LINE && cursor.y != end){\n    d_command();\n    new_line = true;\n  }\n  else if(cursor.x != END_OF_LINE){\n    buf = \"\";\n    new_line = false;\n    for(int j = cursor.x ; j < buffer[cursor.y].size() ; j++){\n      buf += buffer[cursor.y][j];\n    }\n\n    int buffer_size = buffer[cursor.y].size();\n    for(int j = cursor.x ; j < buffer_size ; j++){\n      buffer[cursor.y].erase(buffer[cursor.y].begin() + cursor.x);\n      //cout << buffer[cursor.y] << endl;\n    }\n  }\n}\n\nvoid y_command(){\n  if(buf == \"\") return;\n  string bf = \"\";\n  for(int j = cursor.x ; j < buffer[cursor.y].size() ; j++){\n    bf += buffer[cursor.y][j];\n  }\n  \n  if(new_line){\n    buffer.push_back(\"\");\n    \n    for(int i = buffer.size()-1 ; i > cursor.y ; i--){\n      buffer[i] = buffer[i-1];\n    }\n    end++;\n    buffer[cursor.y+1] = bf;\n    int buffer_size = buffer[cursor.y].size();\n    for(int j = cursor.x ; j < buffer_size ; j++){\n      buffer[cursor.y].erase(buffer[cursor.y].begin() + j);\n    }\n  }\n  else{\n    if(cursor.x == END_OF_LINE){\n      buffer[cursor.y] += buf;\n    }\n    else{\n      for(int j = buffer[cursor.y].size()-1, cnt = 0 ; cnt < bf.size() ; cnt++){\n\tbuffer[cursor.y].erase(buffer[cursor.y].end()-1 - cnt);\n      }\n      buffer[cursor.y] += buf;\n      buffer[cursor.y] += bf;\n      cursor.x += buf.size();\n    }\n  }\n} \n\nvoid init(){\n  end = buffer.size()-1;\n  new_line = false;  \n  buf = \"\";\n}\n  \nint main(){\n  string s;\n  while(getline(cin, s)){\n    if(s == \"END_OF_TEXT\") break;\n    buffer.push_back(s);\n  }\n  \n  init();\n  \n  char op;\n  while(cin >> op){\n    //cout << \"operand = \" << op << endl;\n    if(op == '-') break;\n    if(op == 'a') a_command();\n    if(op == 'e') e_command();\n    if(op == 'p') p_command();\n    if(op == 'n') n_command();\n    if(op == 'f') f_command();\n    if(op == 'b') b_command();\n    if(op == 'd') d_command();\n    if(op == 'k') k_command();\n    if(op == 'y') y_command();  \n    if(cursor.x == buffer[cursor.y].size()) cursor.x = END_OF_LINE;\n    //output();\n    //cout << \"cursor.x = \" << cursor.x << \", cursor.y = \" << cursor.y << endl << endl;  \n  }\n  \n  output();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tstring str[10000];\n\tstring b;\n\tint i = 0;\n\t\n\twhile (getline(std::cin, str[i]), str[i] != \"END_OF_TEXT\") i++;\n\ti = 0;\n\t\n\tchar cmd[2];\n\tint car_y = 0;\n\tint car = 0;\n\tint y = 0, y2 = 0;\n\t\n\twhile (str[y] != \"END_OF_TEXT\") y++;\n\ty--;\n\ty2 = y;\n\t\n\tb.erase();\n\t\n\twhile (scanf(\"%s\", cmd), cmd[0] != '-'){\n\t\tif (cmd[0] == 'a'){\n\t\t\tcar = 0;\n\t\t//\tprintf(\" a\");\n\t\t}\n\t\tif (cmd[0] == 'e'){\n\t\t\tcar = str[car_y].size();\n\t\t\t\n\t\t//\tprintf(\" e\");\n\t\t}\n\t\tif (cmd[0] == 'p'){\n\t\t\t\n\t\t//\tprintf(\" p\");\n\t\t\tif (car_y == 0){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y--;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'n'){\n\t\t//\tprintf(\" n\");\n\t\t\tif (car_y == y2){\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar_y++;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'f'){\n\t\t//\tprintf(\" f\");\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\tcar_y++;\n\t\t\t\t\tcar = 0;\n\t\t\t\t\t//printf(\" %d\",car_y);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar++;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'b'){\n\t\t//\tprintf(\" b\");\n\t\t\tif (car == 0){\n\t\t\t\tif (car_y != 0){\n\t\t\t\t\tcar_y--;\n\t\t\t\t\tcar = str[car_y].size();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcar--;\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'd'){\n\t\t//\tprintf(\" d\");\n\t\t\tif (car != str[car_y].size()){\n\t\t\t\tstr[car_y].erase(car, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\t//str[car_y] + str[car_y + 1];\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = --y;\n\t\t\t\t\ty = car_y + 1;\n\t\t\t\t\twhile (y <= y2){\n\t\t\t\t\t\tif (y == y2){\n\t\t\t\t\t\t\tstr[y + 2].erase();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstr[y] = str[y + 1];\n\t\t\t\t\t\ty++;\n\t\t\t\t\t}\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'k'){\n\t\t//\tprintf(\" k\");\n\t\t\tif (car == str[car_y].size()){\n\t\t\t\tif (car_y != y2){\n\t\t\t\t\t//str[car_y] + str[car_y + 1];\n\t\t\t\t\tstr[car_y].append(str[car_y + 1]);\n\t\t\t\t\tstr[car_y + 1].erase();\n\t\t\t\t\t\n\t\t\t\t\ty2 = --y;\n\t\t\t\t\ty = car_y + 1;\n\t\t\t\t\twhile (y <= y2){\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (y == y2){\n\t\t\t\t\t\t\tstr[y + 2].erase();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tstr[y] = str[y + 1];\n\t\t\t\t\t\ty++;\n\t\t\t\t\t}\n\t\t\t\t\ty = y2;\n\t\t\t\t\tb[0] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb.erase();\n\t\t\t\tb = str[car_y].substr(car);\n\t\t\t\tstr[car_y].erase(car);\n\t\t\t\tcar = str[car_y].size();\n\t\t\t}\n\t\t}\n\t\tif (cmd[0] == 'y'){\n\t\t//\tprintf(\" y\");\n\t\t\t//if (b.empty());\n\t\t\t{\n\t\t\t\tif (b[0] == '\\0'){\n\t\t\t\t\ty2 = ++y;\n\t\t\t\t\twhile (y < car_y){\n\t\t\t\t\t\tstr[y] = str[y - 1];\n\t\t\t\t\t\ty--;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tstr[y] = str[y - 1].substr(car);\n\t\t\t\t\tstr[y - 1].erase(car);\n\t\t\t\t\ty = y2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstr[car_y].insert(car, b);\n\t\t\t\t\tcar += b.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\ti = 0;\n\twhile (i <= y2){\n\t\t//puts(str[i].c_str());\n\t\tcout << str[i] << endl;\n\t\ti++;\n\t}\n\t\n\ti = 0;\n\twhile (i <= y2){\n\t\tif (car_y == i){\n\t\t\tfor (int j = 0; j <= str[i].size(); j++){\n\t\t\t\tif (j == car){\n\t\t\t\t\tcout << 'I';\n\t\t\t\t}\n\t\t\t\tcout << str[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\telse{\n\t\t\tputs(str[i].c_str());\n\t\t}\n\t\ti++;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tstring t[110];\n\tstring buf = \"\";\n\tint row = 0;\n\tint col = 0;\n\tint line = 0;\n\t\n\tfor(int i=0 ; getline( cin , s ) ; i++ ){\n\t\tif( s == \"END_OF_TEXT\" ){\n\t\t\tbreak;\n\t\t}\n\t\tif(i<110) t[i] = s;\n\t\tline = i+1;\n\t}\n\tfor(; getline(cin,s) ; ){\n\t\tif( s == \"-\" ){\n\t\t\tbreak;\n\t\t}\n\n\t\tif( s == \"a\" ){\n\t\t\tcol = 0;\n\t\t}else if( s == \"e\" ){\n\t\t\tif(row<110) col = t[row].size() ;\n\t\t}else if( s == \"p\" ){\n\t\t\tcol = 0;\n\t\t\tif( row > 0 ){\n\t\t\t\trow--;\n\t\t\t}\n\t\t}else if( s == \"n\" ){\n\t\t\tcol = 0;\n\t\t\tif( row < line )\n\t\t\t\trow++;\n\t\t}else if( s == \"f\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"b\" ){\n\t\t\tif( col != 0 ){\n\t\t\t\tcol--;\n\t\t\t}else{\n\t\t\t\tif( row != 0 && row < 110 ){\n\t\t\t\t\tcol = t[--row].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"d\" ){\n\t\t\tif( row < 110 && col != (int)t[row].size() ){\n\t\t\t\tt[row].erase( col , 1 );\n\t\t\t}else{\n\t\t\t\tif( row < 110 && row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s == \"k\" ){\n\t\t\tif( row < 110 && col == (int)t[row].size() ){\n\t\t\t\tif( row+1 != line ){\n\t\t\t\t\tt[row] += t[row+1];\n\t\t\t\t\tt[row] = \"\";\n\t\t\t\t\tline--;\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t}\n\t\t\t}else if( row < 110 ){\n\t\t\t\tbuf = t[row].substr( col );\n\t\t\t\tt[row].erase( col );\n\t\t\t}\n\t\t}else if( s == \"y\" ){\n\t\t\tif( buf != \"\" ){\n\t\t\t\tif( row < 110 && buf == \"\\n\" ){\n\t\t\t\t\tfor(int i = line-1 ; i > row ; i-- ){\n\t\t\t\t\t\tif( line+1 < 110 && line >= 0 )\n\t\t\t\t\t\t\tt[line+1] = t[line];\n\t\t\t\t\t}\n\t\t\t\t\t//t[row+1] = t[row].substr( col );\n\t\t\t\t\t//t[row].erase( col );\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t\tline++;\n\t\t\t\t}else if( row < 110 ){\n\t\t\t\t\tt[row].insert( col , buf );\n\t\t\t\t\tcol += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i<line ; i++ ){\n\t\tcout << t[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nvoid convert(string& text, int& cursor, string& buffer, char command);\n\nint main()\n{\n\tstring text, buffer;\n\tint cursor = 0;\n\t\n\tfor(string line; getline(cin, line) && line != \"END_OF_TEXT\"; text += line + '\\n');\n\tfor(char command; cin >> command && command != '-'; convert(text, cursor, buffer, command));\n\t\n\tcout << text;\n}\n\nvoid convert(string& text, int& cursor, string& buffer, char command)\n{\n\tswitch(command)\n\t{\n\t\t\t/*\n\t\t\t a\n\t\t\t J[\\ð»ÝÌsÌæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'a':\n\t\t{\n\t\t\tint pos = 0 < cursor ? text.rfind(\"\\n\", cursor - 1) : string::npos;\n\t\t\tcursor = (pos == string::npos ? 0 : pos + 1);\n\t\t\t\n\t\t\t/*\n\t\t\tif(cursor != 0 && text[cursor - 1] != '\\n')\n\t\t\twhile(--cursor) if(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tcursor++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t */\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t e\n\t\t\t J[\\ð»ÝÌsÌsÉÚ®·éB\n\t\t\t */\n\t\tcase 'e':\n\t\t{\n\t\t\twhile(text[cursor] != '\\n') cursor++;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t p\n\t\t\t ãÉsª êÎAJ[\\ðãÌsÌæª¶ÉÚ®·éB\n\t\t\t ãÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'p':\n\t\t{\n\t\t\t\n\t\t\tif(cursor != 0) while(--cursor) if(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(cursor != 0) while(--cursor) if(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tcursor++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t n\n\t\t\t ºÉsª êÎAJ[\\ðºÌsÌæª¶ÉÚ®·éB\n\t\t\t ºÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'n':\n\t\t{\n\t\t\tint cur = cursor;\n\t\t\twhile(text[cur] != '\\n') cur++;\n\t\t\t\n\t\t\tif(cur + 1 == text.size())\n\t\t\t{\n\t\t\t\tif(cursor != 0) while(--cursor) if(text[cursor] == '\\n')\n\t\t\t\t{\n\t\t\t\t\tcursor++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcursor = cur + 1;\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t f\n\t\t\t J[\\ªsÉÈ¢êAJ[\\ðPÂEÉÚ®·éB\n\t\t\t J[\\ªsÉ è©ÂºÉsª éêÍAJ[\\ðºÌsÌæª¶ÖÚ®·éB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'f':\n\t\t{\n\t\t\tcursor += cursor + 1 != text.size();\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t b\n\t\t\t J[\\ªæª¶ÅÈ¢ÈçÎAJ[\\ðPÂ¶ÉÚ®·éB\n\t\t\t J[\\ªæª¶Å è©ÂãÉsª éêÍAJ[\\ðãÌsÌsÖÚ®·éB\n\t\t\t »êÈOÌêÍ½àµÈ¢\n\t\t\t */\n\t\tcase 'b':\n\t\t{\n\t\t\tcursor -= 0 < cursor;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t d\n\t\t\t J[\\ª¶ðw·êÍ»Ì¶ðí·éBí³ê½¶ÌE¤Ì¶ñÍ¶ÉVtg³êéB\n\t\t\t J[\\ªsðwµºÉsª éêÍAºÌsð»ÌÜÜJ[\\ÌÊuÉq°éBÈºÌsÍãÉVtg³êéB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'd':\n\t\t{\n\t\t\tif(cursor + 1 != text.size()) text.erase(text.begin() + cursor);\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t k\n\t\t\t J[\\ªsÉ éêAºÉsª êÎAd Æ¯¶ìðµobt@ÉPÂÌüsðL^·éB\n\t\t\t J[\\ªsÉÈ¢êAJ[\\ªw·¶ðÜß½E¤·×ÄÌ¶ðØèæè»êðobt@ÉL^·éBJ[\\Í³ÌsÌsðw·æ¤ÉÈéBSÄÌL^É¨¢Äobt@Íã«³êéB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'k':\n\t\t{\n\t\t\tbuffer = \"\";\n\t\t\tif(text[cursor] == '\\n')\n\t\t\t{\n\t\t\t\tif(cursor + 1 == text.size())\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tbuffer = \"\\n\";\n\t\t\t\ttext.erase(text.begin() + cursor);\n\t\t\t}\n\t\t\telse while(text[cursor] != '\\n')\n\t\t\t{\n\t\t\t\tbuffer += text[cursor];\n\t\t\t\ttext.erase(text.begin() + cursor);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t y\n\t\t\t obt@ªóÌêÍÈÉàµÈ¢B\n\t\t\t obt@ÌàeªüsÌêAJ[\\ªw·¶Ì¼OÅüsðs¤BJ[\\ÍVµ¢sÌæª¶ÖÚ®·éB\n\t\t\t obt@Ìàeª¶ñÌêAJ[\\ÌÊuÉobt@Ìàeð}ü·éB J[\\ÌÊuÍàÆàÆwµÄ¢½¶Ü½ÍsÌêÖÚ®·é\n\t\t\t */\n\t\tcase 'y':\n\t\t{\n\t\t\ttext = text.substr(0, cursor) + buffer + text.substr(cursor);\n\t\t\tcursor += buffer.size();\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <string>\n#include <cstdio>\n \nusing namespace std;\n \nint main()\n{\n    string str[300];\n    string b;\n    b[0];\n    int y = 0, y2 = 0;\n\tbool flag = false;\n     \n    while (getline(std::cin, str[y]), str[y] != \"END_OF_TEXT\"){\n        y++;\n    }\n    y2 = --y;\n     \n    char cmd[2];\n    int car = 0, car_y = 0;\n\tint len;\n     \n    while (scanf(\"%s\", cmd), cmd[0] != '-'){\n\t\tlen = str[car_y].size();\n\t\t\n        if (cmd[0] == 'a'){\n            car = 0;\n        }\n        if (cmd[0] == 'e'){\n            car = len;\n        }\n        if (cmd[0] == 'p'){\n            if (car_y == 0){\n                car = 0;\n            }\n            else {\n                car_y--;\n                car = 0;\n            }\n        }\n        if (cmd[0] == 'n'){\n            if (car_y != y){\n                car_y++;\n                car = 0;\n            }\n             \n            else {\n                car = 0;\n            }\n        }\n        if (cmd[0] == 'f'){\n            if (car != len){\n                car++;\n            }\n            else {\n                if (car_y != y){\n                    car_y++;\n                    car = 0;\n                }\n            }\n        }\n        if (cmd[0] == 'b'){\n            if (car != 0){\n                car--;\n            }\n            else {\n                if (car_y != 0){\n                    car_y--;\n                    car = 0;\n                }\n            }\n        }\n        if (cmd[0] == 'd'){\n            if (car != len){\n                str[car_y].erase(car, 1);\n            }\n            else {\n                if (car_y != y){\n                    str[car_y].append(str[car_y + 1]);\n                    str[car_y + 1].erase();\n                     \n                    y2 = y - 1;\n                    y = car_y;\n                    while (++y < y2){\n                        str[y] = str[y - 1];\n                    }\n                    str[y].erase();\n                     \n                    y = y2;\n                }\n            }\n        }\n        if (cmd[0] == 'k'){\n\t\t\tflag = true;\n            if (car == len){\n                if (car_y != y){\n                    str[car_y].append(str[car_y + 1]);\n                    str[car_y + 1].erase();\n                     \n                    y2 = y;\n                    y = car_y;\n                    while (++y < y2){\n                        str[y] = str[y - 1];\n                    }\n                    str[y].erase();\n                     \n                    y = y2;\n                    b[0] = '\\0';\n                }\n            }\n            else {\n                b = str[car_y].substr(car);\n                str[car_y].erase(car);\n                car = str[car_y].size();\n            }\n        }\n        if (cmd[0] == 'y'){\n            if(flag){\n                if (b[0] == '\\0'){\n                    y2 = y + 1;\n                    while (y > car_y + 1){\n                        str[y] = str[y - 1];\n\t\t\t\t\t\ty--;\n                    }\n                    str[y] = str[car_y].substr(car);\n                    str[car_y].erase(car);\n                }\n                else {\n                    str[car_y].insert(car, b);\n                    car += b.size();\n                }\n            }\n        }\n    }\n     \n    for (int j = 0; j <= y; j++){\n        printf(\"%s\\n\", str[j].c_str());\n    }\n     \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nchar t[100][1000];\nint h;\nint w[100];\n\nchar tmp[100];\nint tmp_size;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nint main(){\n\n  input();\n  x=y=tmp_size=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n  }\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w[i];j++){\n      cout<<t[i][j];\n    }\n    cout<<endl;\n  }\n  \n  return 0;\n}\n\nvoid funcA(){x=0;}\nvoid funcE(){x=w[y];}\nvoid funcP(){ if(y>0)y--; x=0; }\nvoid funcN(){ if(y+1<h)y++; x=0; }\nvoid funcF(){ \n  if(x<w[y])x++;\n  else if(y+1<h){y++;x=0;}\n}\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=w[y];}\n}\nvoid funcD(){\n  if(x<w[y]){\n    w[y]--;\n    for(int i=x;i<w[y];i++)t[y][i]=t[y][i+1];\n    return;\n  }\n  if(y+1==h)return;\n  for(int i=0;i<w[y+1];i++)t[y][w[y]+i]=t[y+1][i];\n  w[y]+=w[y+1];\n  h--;\n  for(int i=y+1;i<h;i++){\n    w[i]=w[i+1];\n    for(int j=0;j<w[i];j++){\n      t[i][j]=t[i+1][j];\n    }\n  }\n}\n\nvoid funcK(){\n  if(x==w[y]){\n    if(y+1<h){\n      funcD();\n      tmp[0]='\\n';\n      tmp_size=1;\n    }\n  }else{\n    tmp_size=0;\n    for(int i=x;i<w[y];i++)\n      tmp[tmp_size++]=t[y][i];\n    w[y]=x;\n  }\n}\n\nvoid funcY(){\n  /*\n  if(tmp_size==0)return;\n  if(tmp[0]!='\\n'){\n    w[y]+=tmp_size;\n    for(int i=w[y]-1;i>=x+tmp_size;i--)\n      t[y][i]= t[y][ i-tmp_size ];\n    for(int i=x;i<x+tmp_size;i++)\n      t[y][i]=tmp[i-x];\n    return;\n  }\n  \n  h++;\n  for(int i=h-1;i>y+1;i--){\n    w[i]=w[i-1];\n    for(int j=0;j<w[i];j++)\n      t[i][j]=t[i-1][j];\n  }\n\n  w[y+1]=w[y]-x;\n  for(int i=0;i<w[y+1];i++){\n    t[y+1][i]=t[y][i+x];\n  }\n  w[y]=x;\n  y++;\n  x=0;\n  */\n}\n\nvoid input(){\n  string str;\n  h=0;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    w[h]=str.size();\n    for(int i=0;i<(int)str.size();i++)\n      t[h][i]=str[i];\n    h++;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY = 0;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n/*\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n}\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\\n\";\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX);\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n*/\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX+1);\n\n\t\tlines[posY] = front;\n\t\tdeque<string>::iterator it = lines.begin();\n\t\tadvance(it,posY);\n\t\tlines.insert(it,rear);\n\t}\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(getline(cin,str)){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(cin >> str){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\t//if(str == \"d\") ctrl_d(lines);\n\t\t//if(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector< vector<char> > t,u;\nvector<char> tmp;\n\nchar ch;\nint x,y;\n\nvoid input();\nvoid funcA();\nvoid funcE();\nvoid funcP();\nvoid funcN();\nvoid funcF();\nvoid funcB();\nvoid funcD();\nvoid funcK();\nvoid funcY();\n\nint main(){\n\n  t.clear();\n  tmp.clear();\n  input();\n  x=y=0;\n  while(1){\n    \n    cin>>ch;\n    if(ch=='a')funcA();\n    else if(ch=='e')funcE();\n    else if(ch=='p')funcP();\n    else if(ch=='n')funcN();\n    else if(ch=='f')funcF();\n    else if(ch=='b')funcB();\n    else if(ch=='d')funcD();\n    else if(ch=='k')funcK();\n    else if(ch=='y')funcY();\n    else break;\n    \n    //cout<<y<<' '<<x<<\" ty\"<<t.size()<<endl;\n  }\n\n  for(int i=0;i<t.size();i++){\n    for(int j=0;j<t[i].size();j++){\n      cout<<t[i][j];\n    }\n  }\n\n  return 0;\n}\n\nvoid funcA(){\n  x=0;\n}\n\nvoid funcE(){\n  x=t[y].size()-1;\n}\n\nvoid funcP(){\n  if(y>0)y--;\n  x=0;\n}\n\nvoid funcN(){\n  if(y+1<(int)t.size())y++;\n  x=0;\n}\n\nvoid funcF(){\n  if(x+1<(int)t[y].size())x++;\n  else if(y+1<(int)t.size()){y++;x=0;}\n}\n\nvoid funcB(){\n  if(x>0)x--;\n  else if(y>0){y--;x=t[y].size()-1;}\n}\n\nvoid funcD(){\n  if(t[y][x]!='\\n'){\n    t[y].erase(t[y].begin()+x);\n    return;\n  }\n  if(y+1==(int)t.size())return;\n  t[y].erase(t[y].begin()+x);\n  for(int i=0;i<(int)t[y+1].size();i++)\n    t[y].push_back(t[y+1][i]);\n  t.erase(t.begin()+y+1);\n}\n\nvoid funcK(){\n  tmp.clear();\n  if(t[y][x]=='\\n'){\n    if(y+1<(int)t.size()){\n      funcD();\n      tmp.push_back('\\n');\n    }\n    return;\n  }\n  while(t[y][x]!='\\n'){\n    tmp.push_back(t[y][x]);\n    t[y].erase(t[y].begin()+x);\n  }\n  reverse(tmp.begin(),tmp.end());\n\n}\n\nvoid funcY(){\n  if(tmp.size()==0)return;\n  if(tmp[0]=='\\n'){\n    vector<char> z;\n    while(t[y][x]!='\\n'){\n      z.push_back(t[y][x]);\n      t[y].erase(t[y].begin()+x);\n    }\n    t.insert(t.begin()+y+1,z);\n    return;\n  }\n  \n}\n\nvoid input(){\n  vector<char> a;\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"END_OF_TEXT\")break;\n    a.clear();\n    for(int i=0;i<(int)str.size();i++)\n      a.push_back(str[i]);\n    a.push_back('\\n');\n    t.push_back(a);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main(){\n\tstring s[500];\n\tint line = 0;\n\tchar cs[100];\n\tfor ( string in; gets( cs ), in = string( cs ), in != \"END_OF_TEXT\"; ++line ){\n\t\ts[ line ] = in;\n\t}\n\t\n\tint pX = 0;\n\tint pY = 0;\n\t\n\tstring buf;\n\tfor ( string in; cin >> in, in != \"-\"; ) {\n\t\tif ( in == \"a\" ) {\n\t\t\tpX = 0;\n\t\t} else if ( in == \"e\" ) {\n\t\t\tpX = s[ pY ].length();\n\t\t} else if ( in == \"p\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( 0 != pY ) {\n\t\t\t\t--pY;\n\t\t\t}\n\t\t} else if ( in == \"n\" ) {\n\t\t\tpX = 0;\n\t\t\tif ( pY != line - 1 ) {\n\t\t\t\t++pY;\n\t\t\t}\n\t\t} else if ( in == \"f\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\t++pX;\n\t\t\t} else if ( pY != line - 1 ) {\n\t\t\t\tpX = 0;\n\t\t\t\t++pY;\n\t\t\t}\n\t\t} else if ( in == \"b\" ) {\n\t\t\tif ( 0 < pX ) {\n\t\t\t\t--pX;\n\t\t\t} else {\n\t\t\t\tif ( 0 < pY ) {\n\t\t\t\t\t--pY;\n\t\t\t\t\tpX = s[ pY ].length();\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( in == \"d\") {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + s[ pY ].substr( pX + 1 );\n\t\t\t} else if ( pY < line - 1 ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\ts[ line - 1 ] = \"\";\n\t\t\t\t--line;\n\t\t\t}\n\t\t} else if ( in == \"k\" ) {\n\t\t\tif ( pX != s[ pY ].length() ) {\n\t\t\t\tbuf = s[ pY ].substr( pX );\n\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t} else if ( pY < line - 1 ) {\n\t\t\t\ts[ pY ] = s[ pY ] + s[ pY + 1 ];\n\t\t\t\tfor ( int i = pY + 1; i < line - 1; ++i ) {\n\t\t\t\t\ts[ i ] = s[ i + 1 ];\n\t\t\t\t}\n\t\t\t\ts[ line - 1 ] = \"\";\n\t\t\t\t--line;\n\t\t\t\tbuf = \"\\n\";\n\t\t\t}\n\t\t} else if ( in == \"y\" ) {\n\t\t\tif ( !buf.empty() ) {\n\t\t\t\tif ( buf == \"\\n\" ) {\n\t\t\t\t\tfor ( int i = line - 1; pY < i; --i ) {\n\t\t\t\t\t\ts[ i ] = s[ i - 1 ];\n\t\t\t\t\t}\n\t\t\t\t\ts[ pY + 1 ] = s[ pY ].substr( pX );\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX );\n\t\t\t\t\t++line;\n\t\t\t\t} else {\n\t\t\t\t\ts[ pY ] = s[ pY ].substr( 0, pX ) + buf + s[ pY ].substr( pX );\n\t\t\t\t\tpX += buf.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor ( int i = 0; i < line; ++i ) cout << s[ i ] << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <list>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n\tlist<string> li;\n\tlist<string>::iterator ite;\n\tstring buffer;\n\tbool bu = false;\n\tint lc = 0;\n\n\twhile (1) {\n\t\tstring s;\n\t\tbool mo = false;\n\t\tgetline(cin, s);\n\t\tif (s == \"END_OF_TEXT\") break;\n\t\tli.push_back(s);\n\t\tite = --li.end();\n\t\tfor (int j = 0; j < (*ite).size(); ++j) {\n\t\t\tif ((*ite)[j] != ' ') {\n\t\t\t\tmo = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 0; j < (*ite).size(); ++j) {\n\t\t\tif ((*ite)[j] != ' ') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!mo) { s = \"\"; }\n\t}\n\tite = li.begin(); lc = 0;\n\twhile (1) {\n\t\tchar c;\n\t\tcin >> c;\n\t\tif (c == '-') break;\n\t\tswitch (c) {\n\t\tcase 'a': lc = 0; break;\n\t\tcase 'e': lc = (*ite).size(); break;\n\t\tcase 'p': \n\t\t\tlc = 0; \n\t\t\tif (ite != li.begin()) --ite; break;\n\t\tcase 'n': \n\t\t\tlc = 0;\n\t\t\tif (ite != --li.end()) ++ite; break;\n\t\tcase 'f': \n\t\t\tif ((*ite).size() > lc) ++lc; \n\t\t\telse if((*ite).size() == lc && ite != --li.end()){\n\t\t\t\t++ite; lc = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b': \n\t\t\tif (lc != 0) --lc;\n\t\t\telse if(lc == 0 && ite != --li.begin()){\n\t\t\t\t--ite; \n\t\t\t\tlc = (*ite).size();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd': \n\t\t\tif ((*ite)[lc] != ' ') {\n\t\t\t\t(*ite).erase((*ite).begin() + lc);\n\t\t\t}\n\t\t\telse if ((*ite).size() == lc && ite != --li.end()) {\n\t\t\t\t(*ite) += (*++ite);\n\t\t\t\tli.erase(ite);\n\t\t\t\t--ite;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'k': \n\t\t\tif ((*ite).size() == lc && ite != --li.end()) {\n\t\t\t\t(*ite) += (*++ite);\n\t\t\t\tli.erase(ite);\n\t\t\t\t--ite;\n\t\t\t\tbuffer = \"\"; bu = true;\n\t\t\t\tlc = (*ite).size();\n\t\t\t}\n\t\t\telse if ((*ite).size() > lc){\n\t\t\t\tbuffer = (*ite).substr(lc, (*ite).size());\n\t\t\t\t(*ite).erase(lc, (*ite).size());\n\t\t\t\tbu = true;\n\t\t\t\tlc = (*ite).size();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'y': \n\t\t\tif (bu) {\n\t\t\t\tif (buffer == \"\") {\n\t\t\t\t\tli.insert(ite,(*ite).substr(lc, (*ite).size()));\n\t\t\t\t\tlc = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t(*ite).insert(lc, buffer);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (list<string>::iterator i = li.begin(); i != li.end(); ++i) {\n\t\tcout << *i << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\nvector<string> text;\nstring buf;\n\nint row, col;\n\nvoid func_a(){\n\tcol = 0;\n}\n\nvoid func_e(){\n\tcol = text[row].size() - 1;\n}\n\nvoid func_p(){\n\tif (row > 0) row--;\n\tfunc_a();\n}\n\nvoid func_n(){\n\tif (row < text.size() - 1) row++;\n\tfunc_a();\n}\n\nvoid func_f(){\n\tif (col < text[row].size() - 1) col++;\n\telse func_n();\n}\n\nvoid func_b(){\n\tif (col > 0) col--;\n\telse if (row > 0){\n\t\tfunc_p();\n\t\tfunc_e();\n\t}\n}\n\nvoid func_d(){\n\tif (col < text[row].size() - 1) text[row].erase(col, 1);\n\telse if (row < text.size() - 1){\n\t\ttext[row].erase(text[row].end() - 1);\n\t\ttext[row] += text[row + 1];\n\t\ttext.erase(text.begin() + row + 1);\n\t}\n}\n\nvoid func_k(){\n\tif (col < text[row].size() - 1){\n\t\tbuf = text[row].substr(col, text[row].size() - col - 1);\n\t\ttext[row].erase(col, text[row].size() - 1);\n\t\tcol = text[row].size() - 1;\n\t}\n\telse if (row < text.size() - 1){\n\t\tfunc_d();\n\t\tbuf = \"\\n\";\n\t}\n}\n\nvoid func_y(){\n\tif (!buf.empty()){\n\t\tif (buf == \"\\n\"){\n\t\t\ttext.insert(text.begin() + row + 1, text[row].substr(col, text[row].size() - 1));\n\t\t\ttext[row].erase(col, text[row].size() - 1);\t\t\t\n\t\t}\n\t\telse {\n\t\t\ttext[row].insert(col, buf);\n\t\t\tcol += buf.size();\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstring in;\n\tchar cmd;\n\n\twhile (getline(cin, in), in != \"END_OF_TEXT\"){\n\t\ttext.push_back(in + '$');\n\t}\n\t\n\tcol = row = 0;\n\tbuf.clear();\n\n\twhile (cin >> cmd, cmd != '-'){\n\t\tswitch (cmd){\n\t\t  case 'a': func_a(); break;\n\t\t  case 'e':\tfunc_e(); break;\n\t\t  case 'p':\tfunc_p(); break;\n\t\t  case 'n': func_n(); break;\n\t\t  case 'f': func_f(); break;\n\t\t  case 'b':\tfunc_b(); break;\n\t\t  case 'd':\tfunc_d(); break;\n\t\t  case 'k': func_k(); break;\n\t\t  case 'y': func_y(); break;\n\t\t}\n#if 0\n\t\tprintf(\"col:%d row:%d\\n\", col, row);\n\t\tputs(\"status:\");\n\t\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\t\tcout << *it << endl;\n\t\t}\n\t\tputs(\"buffer:\");\n\t\tcout << buf << endl;\n#endif\n\t}\n\n\t\n\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\tcout << it->substr(0, it->size() - 1) << endl;\n\t}\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<string> text;\nstring buf;\n\nint row, col;\n\nvoid func_a(){\n\tcol = 0;\n}\n\nvoid func_e(){\n\tcol = text[row].size();\n}\n\nvoid func_p(){\n\tif (row > 0) row--;\n\tfunc_a();\n}\n\nvoid func_n(){\n\tif (row < text.size() - 1) row++;\n\tfunc_a();\n}\n\nvoid func_f(){\n\tif (col < text[row].size()) col++;\n\telse if (row < text.size() - 1){\n\t\tfunc_n();\n\t}\n}\n\nvoid func_b(){\n\tif (col > 0) col--;\n\telse if (row > 0){\n\t\tfunc_p();\n\t\tfunc_e();\n\t}\n}\n\nvoid func_d(){\n\tif (col < text[row].size() - 1) text[row].erase(col, 1);\n\telse if (row < text.size() - 1){\n\t\ttext[row].erase(text[row].end() - 1);\n\t\ttext[row] += text[row + 1];\n\t\ttext.erase(text.begin() + row + 1);\n\t}\n}\n\nvoid func_k(){\n\tif (col < text[row].size() - 1){\n\t\tbuf = text[row].substr(col, text[row].size() - col);\n\t\ttext[row].erase(col, text[row].size());\n\t}\n\telse if (row < text.size() - 1){\n\t\tfunc_d();\n\t\tbuf = \"\\n\";\n\t}\n}\n\nvoid func_y(){\n\tif (!buf.empty()){\n\t\tif (buf == \"\\n\"){\n\t\t\ttext.insert(text.begin() + row + 1, text[row]);\n\t\t\ttext[row].erase(col, text[row].size() - 1);\n\t\t}\n\t\telse {\n\t\t\ttext[row].insert(col, buf);\n\t\t\tcol += buf.size();\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstring in;\n\tchar cmd;\n\n\twhile (getline(cin, in), in != \"END_OF_TEXT\"){\n\t\ttext.push_back(in);\n\t}\n\t\n\tcol = row = 0;\n\tbuf.clear();\n\n\twhile (cin >> cmd, cmd != '-'){\n\t\tswitch (cmd){\n\t\t  case 'a': func_a(); break;\n\t\t  case 'e':\tfunc_e(); break;\n\t\t  case 'p':\tfunc_p(); break;\n\t\t  case 'n': func_n(); break;\n\t\t  case 'f': func_f(); break;\n\t\t  case 'b':\tfunc_b(); break;\n\t\t  case 'd':\tfunc_d(); break;\n\t\t  case 'k': func_k(); break;\n\t\t  case 'y': func_y(); break;\n\t\t}\n#if 0\n\t\tprintf(\"col:%d row:%d\\n\", col, row);\n\t\tputs(\"status:\");\n\t\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\t\tcout << *it << endl;\n\t\t}\n\t\tputs(\"buffer:\");\n\t\tcout << buf << endl;\n#endif\n\t}\n\n\t\n\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\tcout << *it << endl;\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nint posX=0;\nint posY=0;\nstring buf=\"\";\n\nvoid ctrl_a(deque<string>& lines){\n\tposX=0;\n}\n\nvoid ctrl_e(deque<string>& lines){\n\tposX=lines[posY].size();\n}\n\nvoid ctrl_p(deque<string>& lines){\n\tif(posY>0) {\n\t\tposY = 0;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_n(deque<string>& lines){\n\tif(posY+1 < lines.size()) {\n\t\tposY++;\n\t}\n\tposX = 0;\n}\n\nvoid ctrl_f(deque<string>& lines){\n\tif(posX < lines[posY].size()) {\n\t\tposX++;\n\t}\n\telse if(posX == lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tposY++;\n\t\t\tposX=0;\n\t}\n}\n\nvoid ctrl_b(deque<string>& lines){\n\tif(posX>0) {\n\t\tposX--;\n\t}\n\telse if(posX==0\n\t\t&& posY-1 >= 0){\n\t\t\tposY--;\n\t\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_d(deque<string>& lines){\n\tif(posX<lines[posY].size()) {\n\t\tstring tmp = \"\";\n\t\tfor(int i=0;i<lines[posY].size();i++){\n\t\t\tif(posX == i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.push_back(lines[posY][i]);\n\t\t}\n\t\tlines[posY] = tmp;\n\t}\n\telse if(posX==lines[posY].size()\n\t\t&& posY+1 < lines.size()){\n\t\t\tstring lower = lines[posY+1];\n\t\t\tlines[posY].append(lower);\n\t\t\tdeque<string>::iterator it = lines.begin();\n\t\t\tadvance(it,posY+1);\n\t\t\tlines.erase(it);\n\t}\n\telse return;\n}\n\n\nvoid ctrl_k(deque<string>& lines){\n\tif(posX==lines[posY].size()) {\n\t\tctrl_d(lines);\n\t\tbuf = \"\\n\";\n\t}\n\telse if(posX<lines[posY].size()){\n\t\tstring front=\"\";\n\t\tstring rear=\"\";\n\t\tfront = lines[posY].substr(0,posX);\n\t\trear = lines[posY].substr(posX,lines[posY].size()-posX);\t\n\t\tbuf = rear;\n\t\tlines[posY] = front;\n\t\tposX = lines[posY].size();\n\t}\n}\n\n\nvoid ctrl_y(deque<string>& lines){\n\tif(buf.size()==0) return;\n\n\telse if(buf==\"\\n\"){\n\t\tstring rear = lines[posY].substr(posX,lines[posY].size()-posX);\n\t\tstring front = lines[posY].substr(0,posX);\n\n\t\tlines[posY] = front;\n\t\t//deque<string>::iterator it = lines.begin();\n\t\t//advance(it,posY);\n\t\tdeque<string> res;\n\n\t\tfor(int i=0;i<posY;i++){\n\t\t\tres.push_back(lines[i]);\n\t\t}\n\n\t\tres.push_back(lines[posY]);\n\t\tres.push_back(rear);\n\t\t\n\n\t\tfor(int i=posY+1;i<lines.size();i++){\n\t\t\tres.push_back(lines[i]);\n\t\t}\n\t\t\n\t\tlines = res;\n\t\t//lines.insert(lines.begin()+posY,rear);\n\t\t//lines.insert(it,rear);\n\t}\n\n\telse{\n\t\tlines[posY].insert(posX,buf);\n\t\tposX += buf.size();\n\t}\n}\nint main(){\n\tdeque<string> lines;\n\tstring str;\n\tposX = 0;\n\tposY = 0;\n\twhile(getline(cin,str)){\t\t\n\t\tif(str == \"END_OF_TEXT\") break;\n\t\tlines.push_back(str);\n\t}\n\n\twhile(cin >> str){\n\t\tif(str == \"-\") break;\n\t\tif(str == \"a\") ctrl_a(lines);\n\t\tif(str == \"e\") ctrl_e(lines);\n\t\tif(str == \"p\") ctrl_p(lines);\n\t\tif(str == \"n\") ctrl_n(lines);\n\t\tif(str == \"f\") ctrl_f(lines);\n\t\tif(str == \"b\") ctrl_b(lines);\n\t\tif(str == \"d\") ctrl_d(lines);\n\t\tif(str == \"k\") ctrl_k(lines);\n\t\tif(str == \"y\") ctrl_y(lines);\n\t\t//printf(\"after:%s posX:%d posY:%d \\n\",str.c_str(),posX,posY);\n\t}\n\n\tfor(int i=0;i<lines.size();i++){\n\t\tcout << lines[i] << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\nclass Editor {\n\n    private:\n        //local variable declaration\n        string buffer;\n        int cursorX;\n        int cursorY;\n        vector<string> body;\n\n    public:\n        Editor(vector<string> arg) {\n            buffer = \"\";\n            cursorX = 1;\n            cursorY = 1;\n            body = arg;\n        }\n\n        //Set a motion for each case\n        void acceptCommand(char c) {\n            switch (c) {\n                case 'a':\n                    move_to_head();\n                    break;\n                case 'e':\n                    move_to_tail();\n                    break;\n                case 'p':\n                    move_up();\n                    move_to_head();\n                    break;\n                case 'n':\n                    move_down();\n                    move_to_head();\n                    break;\n                case 'f':\n                    move_forward();\n                    break;\n                case 'b':\n                    move_backward();\n                    break;\n                case 'd':\n                    delete_char();\n                    break;\n                case 'k':\n                    cut_tails();\n                    break;\n                case 'y':\n                    paste();\n                    break;\n            }\n        }\n\n        void paste() {\n            string cl = getCurrentLine();\n            if (buffer == \"\") {\n                return;\n            } else if (buffer == \"!\") {\n                body.push_back(body[body.size() - 1]);\n                for(int i = body.size() - 1; i >= cursorY + 1; i--) {\n                    body[i] = body[i - 1];\n                }\n                body[cursorY] =  cl.substr(cursorX - 1);\n                body[cursorY - 1] = cl.substr(0, cursorX - 1);\n                cursorY += 1;\n                move_to_head();\n            } else {\n                body[cursorY - 1]  = cl.substr(0, cursorX - 1) + buffer + cl.substr(cursorX - 1);\n                cursorX += buffer.length();\n            }\n        }\n\n        void delete_char() {\n\n            //local variable declaration\n            string cl = getCurrentLine();\n\n            if (cursorX <= cl.length()) {\n                string tmp1 = cl.substr(0, cursorX - 1);\n                string tmp2 = cl.substr(cursorX);\n                body[cursorY - 1] = tmp1 + tmp2;\n            }else if (cursorY < body.size()) {\n                body[cursorY - 1] = cl + body[cursorY];\n                for(int i = cursorY; i < body.size() - 1; i++) {\n                    body[i] = body[i+1];\n                }\n                body.pop_back();\n            }\n        }\n\n        void cut_tails() {\n            string cl = getCurrentLine();\n\n            if (cursorX <= cl.length()) {\n                buffer = cl.substr(cursorX - 1);\n                body[cursorY - 1] = cl.substr(0, cursorX - 1);\n            }else {\n                buffer = \"!\";\n                delete_char();\n            }\n        }\n\n        void move_forward() {\n            if (cursorX <= getCurrentLine().length()) {\n                cursorX += 1;\n            }else if (cursorY < body.size()) {\n                cursorY += 1;\n                move_to_head();\n            }\n        }\n\n        void move_backward() {\n            if (cursorX > 1) {\n                cursorX -= 1;\n            }else if (cursorY > 1) {\n                cursorY -= 1;\n                move_to_tail();\n            }\n        }\n\n        void move_to_head() {\n            cursorX = 1;\n        }\n\n        void move_to_tail() {\n            cursorX = body[cursorY - 1].length() + 1;\n        }\n\n        void move_up() {\n            if(cursorY > 1)    cursorY -= 1;\n        }\n\n        void move_down() {\n            if(cursorY < body.size())  cursorY += 1;\n        }\n\n        void printBody() {\n            for (int i = 0; i < body.size(); i++) {\n                cout << body[i] << endl;\n            }\n        }\n\n        string getCurrentLine() {\n            return body[cursorY - 1];\n        }\n\n};\n\nint main() {\n\n    vector<string> lines;\n\n    while (true) {\n        string line;\n        getline(cin, line);\n        if (line == \"END_OF_TEXT\") break;\n        lines.push_back(line);\n    }\n\n    Editor editor (lines);\n\n    while (true) {\n        char c;\n        cin >> c;\n        if(c == '-')    break;\n        editor.acceptCommand(c);\n    }\n    editor.printBody();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cstdio>\nusing namespace std;\n\nint crow = 0, ccol = 0;\nstring buf = \"\";\nvector<string> lines;\n\nvoid input() {\n    while(1) {\n        string s;\n        getline(cin, s);\n        if(s == \"END_OF_TEXT\") break;\n        lines.push_back(s + \"\\n\");\n    }\n}\n\nvoid assign_buf(string s, bool is_cl_only=false) {\n    buf = s;\n    if(!is_cl_only) {\n        assert(buf.back() == '\\n');\n        buf.pop_back();\n    }\n}\n\nbool is_col_begin() { return ccol == 0; }\nbool is_col_end() { return ccol + 1 == lines[crow].size(); }\nbool is_row_begin() { return crow == 0; }\nbool is_row_end() { return crow + 1 == lines.size(); }\n\nint get_col_begin() { return 0; }\nint get_col_end() { return (int)lines[crow].size() - 1; }\nint get_row_begin() { return 0; }\nint get_row_end() { return (int)lines.size() - 1; }\n\nvoid up()   { crow = max(get_row_begin(), crow - 1); ccol = 0; }\nvoid down() { crow = min(get_row_end()  , crow + 1); ccol = 0; }\nvoid right() {\n    if(is_col_end() && is_row_end()) return;\n\n    if(is_col_end()) down(), ccol = get_col_begin();\n    else             ccol++;\n}\nvoid left() {\n    if(is_col_begin() && is_row_begin()) return;\n\n    if(is_col_begin()) up(), ccol = get_col_end();\n    else               ccol--;\n}\n\nvoid delete_char() {\n    if(is_col_end()) {\n        if(is_row_end()) return;\n        string &target = lines[crow];\n        target.pop_back();\n        target += lines[crow + 1];\n        lines.erase(lines.begin() + crow + 1);\n    }\n    else {\n        lines[crow].erase(lines[crow].begin() + ccol);\n    }\n}\n\nvoid show_state(char op) {\n    printf(\"operate [%c]: row = %d, col = %d\\n\", op, crow, ccol);\n    for(auto x : lines) cout << x;\n}\n\nbool operate(char op) {\n    assert(crow >= 0 && ccol >= 0);\n    assert(crow + 1 <= lines.size());\n    assert(ccol + 1 <= lines[crow].size());\n\n    if(op == 'a') {\n        ccol = get_col_begin();\n    }\n    if(op == 'e') {\n        ccol = get_col_end();\n    }\n    if(op == 'p') {\n        up();\n    }\n    if(op == 'n') {\n        down();\n    }\n    if(op == 'f') {\n        right();\n    }\n    if(op == 'b') {\n        left();\n    }\n    if(op == 'd') {\n        delete_char();\n    }\n    if(op == 'k') {\n        if(is_col_end()) {\n            if(!is_row_end()) {\n                delete_char();\n                assign_buf(\"\\n\", true);\n            }\n        }\n        string &target = lines[crow];\n        assign_buf(target.substr(ccol));\n        target = target.substr(0, ccol) + \"\\n\";\n    }\n    if(op == 'y') {\n        if(buf.size()) {\n            if(buf == \"\\n\") {\n                string &target = lines[crow];\n                string s1 = target.substr(0, ccol);\n                string s2 = target.substr(ccol);\n\n                target = s1;\n                lines.insert(lines.begin() + crow + 1, s2);\n\n                down();\n            }\n            else {\n                string &target = lines[crow];\n                target.insert(ccol, buf);\n                ccol += buf.size();\n            }\n        }\n    }\n\n    show_state(op);\n    return op == '-';\n}\n\nint main() {\n    input();\n\n    while(1) {\n        char c; cin >> c;\n        if(operate(c)) break;\n    }\n    for(auto x : lines) {\n        cout << x;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main(){\n\tstring str[100];\n\tstring s;\n\tint size = 0;\n\twhile(getline(cin,s)){\n\t\tif(s == \"END_OF_TEXT\") break;\n\t\tstr[size++] = s;\n\t}\n\tchar ch;\n\tstring buf = \"\";\n\tint line = 0, pos = 0;\n\twhile(cin >> ch){\n\t\tif(ch == '-') break;\n\t\tif(ch == 'a') pos = 0;\n\t\tif(ch == 'e') pos = str[line].size();\n\t\tif(ch == 'p'){\n\t\t\tpos = 0;\n\t\t\tif(line!=0) line--;\n\t\t}\n\t\tif(ch == 'n'){\n\t\t\tpos = 0;\n\t\t\tif(line+1!=size) line++;\n\t\t}\n\t\tif(ch == 'f'){\n\t\t\tif(pos != str[line].size()) pos++;\n\t\t\telse if(line+1!=size) { pos = 0; line++; }\n\t\t}\n\t\tif(ch == 'b'){\n\t\t\tif(pos != 0) pos--;\n\t\t\telse if(line!=0) { line--; pos = str[line].size(); }\n\t\t}\n\t\tif(ch == 'd'){\n\t\t\tif(pos != str[line].size()){\n\t\t\t\tstr[line] = str[line].substr(0,pos) + str[line].substr(pos+1);\n\t\t\t} else if(line+1!=size){\n\t\t\t\tstr[line] = str[line] + str[line+1];\n\t\t\t\tfor(int i=line+1;i+1<size;i++){\n\t\t\t\t\tstr[i] = str[i+1];\n\t\t\t\t}\n\t\t\t\tstr[size-1] = \"\";\n\t\t\t\tsize--;\n\t\t\t}\n\t\t}\n\t\tif(ch == 'k'){\n\t\t\tif(pos == str[line].size() && line+1!=size){\n\t\t\t\tstr[line] = str[line] + str[line+1];\n\t\t\t\tfor(int i=line+1;i+1<size;i++){\n\t\t\t\t\tstr[i] = str[i+1];\n\t\t\t\t}\n\t\t\t\tstr[size-1] = \"\";\n\t\t\t\tsize--;\n\t\t\t\tbuf = \"\\n\";\n\t\t\t}\n\t\t\telse if(pos < str[line].size()){\n\t\t\t\tbuf = str[line].substr(pos);\n\t\t\t\tstr[line] = str[line].substr(0,pos);\n\t\t\t}\n\t\t}\n\t\tif(ch == 'y'){\n\t\t\tif(buf == \"\\n\"){\n\t\t\t\tfor(int i=line+1;i<size;i++){\n\t\t\t\t\tstr[i+1] = str[i];\n\t\t\t\t}\n\t\t\t\tsize++;\n\t\t\t\tstr[line+1] = str[line].substr(pos);\n\t\t\t\tstr[line] = str[line].substr(0,pos);\n\t\t\t} else if(buf != \"\"){\n\t\t\t\tstr[line] = str[line].substr(0,pos) + buf + str[line].substr(pos);\n\t\t\t\tpos += buf.size();\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tcout << line << \" \" << pos << endl;\n\t\tfor(int i=0;i<size;i++){\n\t\t\tcout << str[i] << endl;\t\n\t\t}\n\t\tputs(\"\");\n\t\t*/\n\t}\n\tfor(int i=0;i<size;i++){\n\t\tcout << str[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<string> l;\nstring buffer;\nint X = 0 , Y = 0;\nvoid a(){ X = 0; }\nvoid e(){ X = l[Y].size()-1; }\nvoid p(){ Y = max<int>(0,Y-1) ; a(); }\nvoid n(){ Y = min<int>(l.size()-1,Y+1); a(); }\nvoid f(){ if(X != l[Y].size()-1){X++;}else{n();} }\nvoid b(){ if(X != 0){X--;}else{p(),e();} }\nvoid d(){\n\tif(l[Y][X] != '\\n'){\n\t\tl[Y] = l[Y].substr(0,X) + l[Y].substr(X+1);\n\t}else{\n\t\tl[Y] = Y==l.size()-1?l[Y]:l[Y].substr(0,l[Y].size()-1) + l[Y+1];\n\t\tvector<string> p;\n\t\tfor(int i = 0 ; i < l.size() ; i++){\n\t\t\tif(i != Y+1) p.push_back(l[i]);\n\t\t}\n\t\tl = p;\n\t}\n}\nvoid k(){\n\tif(l[Y][X] == '\\n'){\n\t\tif( Y != l.size()-1){\n\t\t\tbuffer = \"\\n\";\n\t\t\td();\n\t\t\tX = l[Y].size()-1;\n\t\t}\n\t}else{\n\t\tbuffer = l[Y].substr(X);\n\t\tbuffer = l[Y].substr(0,buffer.size()-1);\n\t\tl[Y] = l[Y].substr(0,X) + \"\\n\";\n\t}\n}\nvoid y(){\n\tif(buffer != \"\"){\n\t\tif(buffer == \"\\n\"){\n\t\t\tvector<string> p;\n\t\t\tcout << \"{{\" << l[Y].substr(X) << \"}\" << endl;\n\t\t\tfor(int i = 0 ; i < l.size() ; i++){\n\t\t\t\tp.push_back(l[i]);\n\t\t\t\tif(i==Y)p.push_back(l[i].substr(X));\n\t\t\t}\n\t\t\tp[Y] = p[Y].substr(0,X) + \"\\n\";\n\t\t\tl = p;\n\t\t\tn();\n\t\t}else{\n\t\t\tl[Y].insert(X,buffer);\n\t\t\tX += buffer.size();\n\t\t}\n\t}\n}\nint main(){\n\tstring s;\n\twhile(getline(cin,s),s != \"END_OF_TEXT\"){\n\t\tl.push_back(s+\"\\n\");\n\t}\n\twhile(l.size() == 0);\n\twhile(cin >> s , s != \"-\"){\n\t\tif(s==\"a\")a();\n\t\tif(s==\"e\")e();\n\t\tif(s==\"p\")p();\n\t\tif(s==\"n\")n();\n\t\tif(s==\"f\")f();\n\t\tif(s==\"b\")b();\n\t\tif(s==\"d\")d();\n\t\tif(s==\"k\")k();\n\t\tif(s==\"y\")y();\n\t}\n\tfor(int i = 0 ; i < l.size() ; i++)\n\t\tcout << l[i];\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iterator>\nusing namespace std;\n\nstruct Emacs\n{\n  vector<string> buf;\n  int line, col;\n  string reg;\n  Emacs(const vector<string>& x) : buf(x), line(0), col(0), reg() {}\n  void execute(char cmd)\n  {\n    switch (cmd) {\n      case 'a': a(); break;\n      case 'e': e(); break;\n      case 'p': p(); break;\n      case 'n': n(); break;\n      case 'f': f(); break;\n      case 'b': b(); break;\n      case 'd': d(); break;\n      case 'k': k(); break;\n      case 'y': y(); break;\n    }\n  }\n\n  void a() { col = 0; }\n  void e() { col = buf[line].size(); }\n  void p() { if (line == 0) { a(); } else { --line; } }\n  void n() { if (line == buf.size()-1) { a(); } else { ++line; } }\n  void f() {\n    if (col != buf[line].size()) {\n      ++col;\n    } else if (line != buf.size()-1) {\n      ++line;\n      col = 0;\n    }\n  }\n  void b() {\n    if (col != 0) {\n      --col;\n    } else if (line != 0) {\n      --line;\n      col = buf[line].size();\n    }\n  }\n  void d() {\n    const string::iterator it = buf[line].begin() + col;\n    if (it != buf[line].end()) {\n      buf[line].erase(it);\n    } else if (line < buf.size()-1) {\n      buf[line] += buf[line+1];\n      buf.pop_back();\n    }\n  }\n  void k() {\n    if (buf[line].begin()+col == buf[line].end()) {\n      if (line < buf.size()-1) {\n        d();\n        reg = \"\\n\";\n      }\n    } else {\n      reg = string(buf[line].begin()+col, buf[line].end());\n      buf[line].erase(buf[line].begin()+col, buf[line].end());\n    }\n  }\n  void y() {\n    if (reg == \"\\n\") {\n      string rest(buf[line].begin()+col, buf[line].end());\n      buf[line].erase(col);\n      buf.insert(buf.begin()+line+1, rest);\n    } else if (!reg.empty()) {\n      buf[line].insert(col, reg);\n    }\n  }\n};\n\nint main()\n{\n  vector<string> buffer;\n  string line;\n  while (cin >> line && line != \"END_OF_TEXT\") {\n    buffer.push_back(line);\n  }\n  Emacs e(buffer);\n  char cmd;\n  while (cin >> cmd) {\n    e.execute(cmd);\n  }\n  copy(e.buf.begin(), e.buf.end(), ostream_iterator<string>(cout, \"\\n\"));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nstruct Cursor{ int x, y; Cursor() : x(0), y(0) {} };\n\nvoid convert(vector<string>& snt, Cursor& cur, string& buffer, char com);\n\nint main()\n{\t\t\n\tvector<string> snt;\n\tstring buffer;\n\tCursor cursor;\n\t\n\t\n\tfor(string line; getline(cin, line) && line != \"END_OF_TEXT\"; snt.push_back(line));\n\t\n\t\n\tfor(char com; cin >> com && com != '-'; convert(snt, cursor, buffer, com));\n\n\t\n\trep(i, snt.size()) cout << snt[i] << endl;\n}\n\n\nvoid convert(vector<string>& snt, Cursor& cur, string& buffer, char com)\n{\n\tswitch(com)\n\t{\n\t\t\t/*\n\t\t\t a\n\t\t\t J[\\ð»ÝÌsÌæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'a':\n\t\t{\n\t\t\tcur.x = 0;\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t e\n\t\t\t J[\\ð»ÝÌsÌsÉÚ®·éB\n\t\t\t */\n\t\tcase 'e':\n\t\t{\n\t\t\tcur.x = snt[cur.y].size();\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t p\n\t\t\t ãÉsª êÎAJ[\\ðãÌsÌæª¶ÉÚ®·éB\n\t\t\t ãÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'p':\n\t\t{\n\t\t\tcur.y -= cur.y != 0;\n\t\t\tcur.x = 0;\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t n\n\t\t\t ºÉsª êÎAJ[\\ðºÌsÌæª¶ÉÚ®·éB\n\t\t\t ºÉsªÈ¯êÎAJ[\\ðæª¶ÉÚ®·éB\n\t\t\t */\n\t\tcase 'n':\n\t\t{\n\t\t\tcur.y += cur.y + 1 != snt.size();\n\t\t\tcur.x = 0;\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t f\n\t\t\t J[\\ªsÉÈ¢êAJ[\\ðPÂEÉÚ®·éB\n\t\t\t J[\\ªsÉ è©ÂºÉsª éêÍAJ[\\ðºÌsÌæª¶ÖÚ®·éB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'f':\n\t\t{\n\t\t\tif(cur.x != snt[cur.y].size())\n\t\t\t{\n\t\t\t\tcur.x++;\n\t\t\t}\n\t\t\telse if(cur.y + 1 != snt.size())\n\t\t\t{\n\t\t\t\tcur.y++;\n\t\t\t\tcur.x = 0;\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t b\n\t\t\t J[\\ªæª¶ÅÈ¢ÈçÎAJ[\\ðPÂ¶ÉÚ®·éB\n\t\t\t J[\\ªæª¶Å è©ÂãÉsª éêÍAJ[\\ðãÌsÌsÖÚ®·éB\n\t\t\t »êÈOÌêÍ½àµÈ¢\n\t\t\t */\n\t\tcase 'b':\n\t\t{\n\t\t\tif(cur.x != 0)\n\t\t\t{\n\t\t\t\tcur.x--;\n\t\t\t}\n\t\t\telse if(cur.y != 0)\n\t\t\t{\n\t\t\t\tcur.y--;\n\t\t\t\tcur.x = snt[cur.y].size();\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t d\n\t\t\t J[\\ª¶ðw·êÍ»Ì¶ðí·éBí³ê½¶ÌE¤Ì¶ñÍ¶ÉVtg³êéB\n\t\t\t J[\\ªsðwµºÉsª éêÍAºÌsð»ÌÜÜJ[\\ÌÊuÉq°éBÈºÌsÍãÉVtg³êéB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'd':\n\t\t{\n\t\t\tif(cur.x != snt[cur.y].size())\n\t\t\t{\n\t\t\t\tstring &line = snt[cur.y];\n\t\t\t\t\n\t\t\t\tline = line.substr(0, cur.x) + line.substr(cur.x + 1);\n\t\t\t}\n\t\t\telse if(cur.y + 1 != snt.size())\n\t\t\t{\n\t\t\t\tsnt[cur.y] += snt[cur.y + 1];\n\t\t\t\t\n\t\t\t\tsnt.erase(snt.begin() + cur.y + 1);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t k\n\t\t\t J[\\ªsÉ éêAºÉsª êÎAd Æ¯¶ìðµobt@ÉPÂÌüsðL^·éB\n\t\t\t J[\\ªsÉÈ¢êAJ[\\ªw·¶ðÜß½E¤·×ÄÌ¶ðØèæè»êðobt@ÉL^·éBJ[\\Í³ÌsÌsðw·æ¤ÉÈéBSÄÌL^É¨¢Äobt@Íã«³êéB\n\t\t\t »êÈOÌêÍ½àµÈ¢B\n\t\t\t */\n\t\tcase 'k':\n\t\t{\n\t\t\tif(cur.x == snt[cur.y].size() && cur.y + 1 != snt.size())\n\t\t\t{\t\t\t\t\n\t\t\t\tsnt[cur.y] += snt[cur.y + 1];\n\t\t\t\t\n\t\t\t\tsnt.erase(snt.begin() + cur.y + 1);\t\t\t\t\n\t\t\t\t\n\t\t\t\tbuffer = \"\\n\";\n\t\t\t}\n\t\t\telse if(cur.x != snt[cur.y].size())\n\t\t\t{\n\t\t\t\tbuffer = snt[cur.y].substr(cur.x);\n\t\t\t\tsnt[cur.y] = snt[cur.y].substr(0, cur.x);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\t/*\n\t\t\t y\n\t\t\t obt@ªóÌêÍÈÉàµÈ¢B\n\t\t\t obt@ÌàeªüsÌêAJ[\\ªw·¶Ì¼OÅüsðs¤BJ[\\ÍVµ¢sÌæª¶ÖÚ®·éB\n\t\t\t obt@Ìàeª¶ñÌêAJ[\\ÌÊuÉobt@Ìàeð}ü·éB J[\\ÌÊuÍàÆàÆwµÄ¢½¶Ü½ÍsÌêÖÚ®·é\n\t\t\t */\n\t\tcase 'y':\n\t\t{\n\t\t\tif(buffer != \"\")\n\t\t\t{\n\t\t\t\tif(buffer == \"\\n\")\n\t\t\t\t{\n\t\t\t\t\tstring &line = snt[cur.y];\n\t\t\t\t\t\n\t\t\t\t\tsnt.insert(snt.begin() + cur.y + 1, snt[cur.y].substr(cur.x));\n\t\t\t\t\tline = line.substr(0, cur.x);\n\t\t\t\t\t\n\t\t\t\t\tcur.y++;\n\t\t\t\t\tcur.x = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstring &line = snt[cur.y];\n\t\t\t\t\tline = line.substr(0, cur.x) + buffer + line.substr(cur.x);\n\t\t\t\t\t\n\t\t\t\t\tcur.x += buffer.size();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nint main(){\n  vector<string> text(200);\n  int line = 0;\n  for(;line<11;line++){\n    getline(cin,text[line],'\\n');\n    if (text[line]==\"END_OF_TEXT\")\n      break;\n  }\n  string buf;\n  int cur[2];\n  cur[0] = 0;//0s\n  cur[1] = 0;//0¶Ú\n\n  while(true){\n    char com;\n    cin >> com;\n    if (com == '-')\n      break;\n    switch (com){\n    case 'a':\n      cur[1] = 0;\n      break;\n    case 'e':\n      cur[1] = (int)text[cur[0]].size();\n      break;\n    case 'p':\n      if (cur[0]>0)\n\tcur[0]--;\n      cur[1]=0;\n      break;\n    case 'n':\n      if (cur[0]<line-1)\n\tcur[0]++;\n      cur[1]=0;\n      break;\n    case 'f':\n      if (cur[1]<(int)text[cur[0]].size())\n\tcur[1]++;\n      else{\n\tif (cur[0]<line-1){\n\t  cur[0]++;\n\t  cur[1]=0;\t\n\t}\n      }\n      break;\n    case 'b':\n      if (cur[1]>0)\n\tcur[1]--;\n      else{\n\tif (cur[0]>0){\n\t  cur[0]--;\n\t  cur[1]=(int)text[cur[0]].size();\t\n\t}\n      }\n      break;\n    case 'd':\n      if (cur[1]<(int)text[cur[0]].size()){\n\ttext[cur[0]] = text[cur[0]].substr(0,cur[1])+text[cur[0]].substr(cur[1]+1);\n      }\n      else{\n\tif (cur[0]<line-1){\n\t  text[cur[0]] = text[cur[0]]+text[cur[0]+1];\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i] = text[i+1];\n\t  line--;\n\t}\n      }\n      break;\n    case 'k':\n      if (cur[1]==(int)text[cur[0]].size()){\n\tif (cur[0]<line-1){\n\t  text[cur[0]] = text[cur[0]]+text[cur[0]+1];\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i] = text[i+1];\n\t  line--;\n\t  buf = \"\\n\";\n\t}\n      }\n      else{\n\tbuf = text[cur[0]].substr(cur[1]);\n\ttext[cur[0]] = text[cur[0]].substr(0,cur[1]);\n\tcur[1] = (int)text[cur[0]].size();\n      }\n      break;\n    case 'y':\n      if (buf.empty())\n\tbreak;\n      else{\n\tif (buf == \"\\n\"){\n\t  for(int i=cur[0]+1;i<line+1;i++)\n\t    text[i+1] = text[i];    \n\t  line++;\n\t  text[cur[0]] = text[cur[0]].substr(0,cur[1]);\n\t  text[cur[0]+1] = text[cur[0]].substr(cur[1]);\n\t  cur[0]++;\n\t  cur[1] = 0;\n\t}\n\telse{\n\t  text[cur[0]] = text[cur[0]].substr(0,cur[1])+buf+text[cur[0]].substr(cur[1]);\n\t}\n      }\n    default:\n      break;\n    }\n    /*      for(int i=0;i<line;i++)\n\tcout << text[i] << endl;\n\tcout << \"(\" << cur[0] << \",\" << cur[1] << \")\" << endl;\n\tcout << \"#\" << endl;*/\n  }\n  for(int i=0;i<line;i++)\n    cout << text[i] << endl;\n  return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tvector<string> e;\n\tstring s;\n\twhile (getline(cin, s), s != \"END_OF_TEXT\") {\n\t\te.push_back(s);\n\t}\n\tint y = 0, x = 0;\n\tstring buffer = \"\";\n\tchar c;\n\twhile (cin >> c, c != '-') {\n\t\tswitch (c) {\n\t\t\tcase 'a':\n\t\t\t\tx = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tx = e[y].size();\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tx = 0;\n\t\t\t\ty = max(0, y-1);\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tx = 0;\n\t\t\t\ty = min((int)e.size()-1, y+1);\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (x < e[y].size()) {\n\t\t\t\t\t++x;\n\t\t\t\t} else if (y+1 < e.size()) {\n\t\t\t\t\tx = 0;\n\t\t\t\t\t++y;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tif (0 < x) {\n\t\t\t\t\t--x;\n\t\t\t\t} else if (0 <= y-1) {\n\t\t\t\t\tx = e[y-1].size();\n\t\t\t\t\t--y;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif (x < e[y].size()) {\n\t\t\t\t\te[y] = e[y].substr(0,x) + e[y].substr(x+1);\n\t\t\t\t} else if (y+1 < e.size()) {\n\t\t\t\t\te[y] += e[y+1];\n\t\t\t\t\te.erase(e.begin()+y+1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tif (x < e[y].size()) {\n\t\t\t\t\tbuffer = e[y].substr(x);\n\t\t\t\t\te[y] = e[y].substr(0,x);\n\t\t\t\t\tx = e[y].size();\n\t\t\t\t} else if (y+1 < e.size()) {\n\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t\te[y] += e[y+1];\n\t\t\t\t\te.erase(e.begin()+y+1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\tif (buffer != \"\") {\n\t\t\t\t\tif (buffer == \"\\n\") {\n\t\t\t\t\t\te.insert(e.begin()+y+1, e[y].substr(x));\n\t\t\t\t\t\te[y] = e[y].substr(0,x);\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\t++y;\n\t\t\t\t\t} else {\n\t\t\t\t\t\te[y] = e[y].substr(0,x) + buffer + e[y].substr(x);\n\t\t\t\t\t\tx += buffer.size();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=0; i<e.size(); ++i) {\n\t\tcout << e[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.State\nimport Data.List\n\nmain :: IO ()\nmain = solve <$> f [] <*> g [] >>= putStrLn\n  where\n    f xs = do\n      l <- getLine\n      if l == \"END_OF_TEXT\"\n        then return $ intercalate \"\\n\" $ reverse xs\n        else f (l:xs)\n    g xs = do\n      l <- getLine\n      if l == \"-\"\n        then return $ reverse xs\n        else g (l:xs)\n             \nsolve :: String -> [String] -> String\nsolve ts cs = evalState (f cs) ([], ts, [])\n  where\n    f :: [String] -> State (String, String, String) String\n    f [] = do\n      (as, bs, _) <- get\n      return $ revAppend as bs\n    f (\"a\":xs) = do\n      (as, bs, cs) <- get\n      let (a1s, a2s) = break (== '\\n') as\n      put (a2s, revAppend a1s bs, cs)\n      f xs\n    f (\"e\":xs) = do\n      (as, bs, cs) <- get\n      let (b1s, b2s) = break (== '\\n') bs\n      put (revAppend b1s as, b2s, cs)\n      f xs\n    f (\"p\":xs) = do\n      (as, bs, cs) <- get\n      let (a1s, a2s) = break (== '\\n') as\n      if null a2s\n        then put ([], revAppend a1s bs, cs)\n        else do\n          let (a3s, a4s) = break (== '\\n') (tail a2s)\n          put (a4s, revAppend a3s ('\\n' : (revAppend a1s bs)), cs)\n      f xs\n    f (\"n\":xs) = do\n      (as, bs, cs) <- get\n      let (b1s, b2s) = break (== '\\n') bs\n      if null b2s\n        then do\n          let (a1s, a2s) = break (== '\\n') as\n          put (a2s, revAppend a1s bs, cs)\n        else put ('\\n' : revAppend b1s as, tail b2s, cs)\n      f xs\n    f (\"f\":xs) = do\n      (as, bs, cs) <- get\n      if null bs\n        then put (as, bs, cs)\n        else put (head bs : as, tail bs, cs)\n      f xs\n    f (\"b\":xs) = do\n      (as, bs, cs) <- get\n      if null as\n        then put (as, bs, cs)\n        else put (tail as, head as : bs, cs)\n      f xs\n    f (\"d\":xs) = do\n      (as, bs, cs) <- get\n      if null bs\n        then put (as, bs, cs)\n        else put (as, tail bs, cs)\n      f xs\n    f (\"k\":xs) = do\n      (as, bs, cs) <- get\n      if null bs\n        then put (as, bs, cs)\n        else if head bs == '\\n'\n               then put (as, tail bs, \"\\n\")\n               else do\n                 let (b1s, b2s) = break (== '\\n') bs\n                 put (as, b2s, b1s)\n      f xs\n    f (\"y\":xs) = do\n      (as, bs, cs) <- get\n      if null cs\n        then put (as, bs, cs)\n        else if cs == \"\\n\"\n               then put ('\\n':as, bs, cs)\n               else put (revAppend cs as, bs, cs)\n      f xs\n\nrevAppend :: String -> String -> String\nrevAppend [] ys = ys\nrevAppend (x:xs) ys = revAppend xs (x:ys)\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    char message[128][1024];\n    int i, len, nowx, nowy;\n    int rowLength;\n    char buffer[2], stack[1024], temp[1024];\n    \n    i = 0;\n    memset(message, '\\0', sizeof(message));\n    memset(stack, '\\0', sizeof(stack));\n    while (1){\n        fgets(temp, 1024, stdin);\n        if (strcmp(temp, \"END_OF_TEXT\\n\") == 0){\n            break;\n        }\n        strcpy(message[i], temp);\n        i++;\n    }\n    len = i;\n    nowx = nowy = 0;\n    while (1){\n        scanf(\"%s\", buffer);\n        \n        if (buffer[0] == '-'){\n            break;\n        }\n        \n        switch (buffer[0]){\n          case 'a':\n            nowx = 0;\n            break;\n          \n          case 'e':\n            nowx = strlen(message[nowy]) - 1;\n            break;\n          \n          case 'p':\n            if (nowy > 0){\n                nowy--;\n            }\n            nowx = 0;\n            break;\n          \n          case 'n':\n            if (nowy < len - 1){\n                nowy++;\n            }\n            nowx = 0;\n            break;\n          \n          case 'f':\n            if (nowx < (int)strlen(message[nowy]) - 1){\n                nowx++;\n            }\n            else if (nowy < len - 1 && nowx == (int)strlen(message[nowy]) - 1){\n                nowy++;\n                nowx = 0;\n            }\n            break;\n          \n          case 'b':\n            if (nowx > 0){\n                nowx--;\n            }\n            else if (nowy > 0 && nowx == 0){\n                nowy--;\n                nowx = strlen(message[nowy]) - 1;\n            }\n            break;\n          \n          case 'd':\n            if (message[nowy][nowx] != '\\n'){\n                rowLength = strlen(message[nowy]) - 1;\n                for (i = nowx; i < rowLength; i++){\n                    message[nowy][i] = message[nowy][i + 1];\n                }\n                message[nowy][i] = '\\0';\n            }\n            else if (message[nowy][nowx] == '\\n' && nowy < len - 1){\n                rowLength = strlen(message[nowy + 1]);\n                for (i = 0; i < rowLength; i++){\n                    message[nowy][nowx + i] = message[nowy + 1][i];\n                }\n                len -= 1;\n                for (i = nowy + 1; i < len; i++){\n                    strcpy(message[i], message[i + 1]);\n                }\n                memset(message[i], '\\0', sizeof(message[i]));\n            }\n            break;\n          \n          case 'k':\n            if (message[nowy][nowx] == '\\n' && nowy < len - 1){\n                rowLength = strlen(message[nowy + 1]);\n                for (i = 0; i < rowLength; i++){\n                    message[nowy][nowx + i] = message[nowy + 1][i];\n                }\n                len -= 1;\n                for (i = nowy + 1; i < len; i++){\n                    strcpy(message[i], message[i + 1]);\n                }\n                memset(message[i], '\\0', sizeof(message[i]));\n                memset(stack, '\\0', sizeof(stack));\n                stack[0] = '\\n';\n            }\n            else if (message[nowy][nowx] != '\\n'){\n                memset(stack, '\\0', sizeof(stack));\n                strcpy(stack, &message[nowy][nowx]);\n                memset(&message[nowy][nowx], '\\0', sizeof(&message[nowy][nowx]));\n                stack[strlen(stack) - 1] = '\\0';\n                rowLength = strlen(message[nowy]);\n                nowx = rowLength;\n                message[nowy][nowx] = '\\n';\n            }\n            break;\n          \n          case 'y':\n            if (stack[0] == '\\n'){\n                for (i = len; i > nowy; i--){\n                    strcpy(message[i], message[i - 1]);\n                }\n                strcpy(message[nowy + 1], &message[nowy][nowx]);\n                memset(&message[nowy][nowx], '\\0', sizeof(&message[nowy][nowx]));\n                message[nowy][nowx] = '\\n';\n                nowy++;\n                nowx = 0;\n                len++;\n            }\n            else if (stack[0] != '\\0'){\n                strcpy(temp, message[nowy]);\n                strcpy(&message[nowy][nowx], stack);\n                strcat(message[nowy], &temp[nowx]);\n                nowx += strlen(stack);\n            }\n            break;\n        }\n    }\n    \n    for (i = 0; i < len; i++){\n        printf(\"%s\", message[i]);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1021 Emacs-like Editor\n// 2018.3.2 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\nchar text[11][1005]; int len[11];\nchar buf[1005]; int blen;\n\nint main()\n{\n\tint N, r, c, rr;\n\tchar cmd[5], *p, *q, *t;\n\n\tN = -1;\n\tdo {\n\t\tfgets(p=text[++N], 1005, stdin);\n\t\twhile (*p >= ' ') p++; *p = 0;\n\t\tlen[N] = p - text[N];\n\t} while (strcmp(text[N], \"END_OF_TEXT\"));\n\tr = 0, c = 0, blen = 0;\n\twhile (1) {\n\t\tfgets(cmd, 5, stdin); if (*cmd == '-') break;\n\t\tif      (*cmd == 'a') c = 0;\n\t\telse if (*cmd == 'e') c = len[r];\n\t\telse if (*cmd == 'p') { c = 0, r--; if (r < 0) r = 0; }\n\t\telse if (*cmd == 'n') { c = 0, r++; if (r >= N) r = N - 1; if (r < 0) r = 0; }\n\t\telse if (*cmd == 'f') { if (c < len[r]) c++; else if (r < N-1) r++, c = 0; }\n\t\telse if (*cmd == 'b') {\tif (c > 0) c--;\telse if (r > 0) r--, c = len[r]; }\n\t\telse if (*cmd == 'd') {\n\t\t\tif (c == len[r]) {\n\t\t\t\tif (r < N-1) {\n\t\t\t\t\tmemcpy(text[r]+len[r], text[r+1], len[r+1]+1);\n\t\t\t\t\tlen[r] += len[r+1];\n\t\t\t\t\tfor (rr = r+2; rr < N; rr++) {\n\t\t\t\t\t\tmemcpy(text[rr-1], text[rr], len[rr]+1);\n\t\t\t\t\t\tlen[rr-1] = len[rr];\n\t\t\t\t\t}\n\t\t\t\t\tN--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tp = text[r] + c;\n\t\t\t\twhile (*p) *p = *(p+1), p++;\n\t\t\t\tlen[r]--;\n\t\t\t}\n\t\t}\n\t\telse if (*cmd == 'k') {\n\t\t\tif (c == len[r]) {\n\t\t\t\tif (r < N-1) {\n\t\t\t\t\tblen = -1;\n\t\t\t\t\tmemcpy(text[r]+len[r], text[r+1], len[r+1]+1);\n\t\t\t\t\tlen[r] += len[r+1];\n\t\t\t\t\tfor (rr = r+2; rr < N; rr++) {\n\t\t\t\t\t\tmemcpy(text[rr-1], text[rr], len[rr]+1);\n\t\t\t\t\t\tlen[rr-1] = len[rr];\n\t\t\t\t\t}\n\t\t\t\t\tN--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tblen = len[r]-c, memcpy(buf, text[r]+c, blen+1);\n\t\t\t\tlen[r] -= blen; if (len[r] < 0) len[r] = 0; text[r][len[r]] = 0;\n\t\t\t\tc = len[r];\n\t\t\t}\n\t\t}\n\t\telse if (*cmd == 'y') {\n\t\t\tif (blen == -1) {\n\t\t\t\tfor (rr = N-1; rr > r; rr--) {\n\t\t\t\t\tmemcpy(text[rr+1], text[rr], len[rr]+1);\n\t\t\t\t\tlen[rr+1] = len[rr];\n\t\t\t\t}\n\t\t\t\tN++;\n\t\t\t\tlen[r+1] = len[r]-c, memcpy(text[r+1], text[r]+c, len[r+1]+1);\n\t\t\t\tlen[r] = c, text[r][len[r]] = 0;\n\t\t\t\tr++, c = 0;\n\t\t\t} else if (blen > 0) {\n\t\t\t\tt = text[r]+c, p = text[r]+len[r], q = p+blen;\n\t\t\t\twhile (p >= t) *q-- = *p--;\n\t\t\t\tmemcpy(t, buf, blen);\n\t\t\t\tc += blen, len[r] += blen;\n\t\t\t}\n\t\t}\n\t}\n\tfor (r = 0; r < N; r++) puts(text[r]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nchar inputString[1000][1000];\nchar listOfCommands[305];\nchar buffer[1000] = \"\";\n\nint numberOfLines = 0;\nint numberOfCommands = 0;\n\nint cursorXCordinate = 0;\nint cursorYCordinate = 0;\n\n\nvoid textInput() {\n\n    int indexOfString = 0;\n    int indexOfCommand = 0;\n    char dummyString[1000];\n    char dummyCommand;\n   // freopen(\"input.txt\", \"r\", stdin);\n    while ( scanf(\"%s\",dummyString)!=EOF) {\n        getchar();\n        if ( !strcmp(dummyString, \"END_OF_TEXT\") ) break;\n        for ( int i = 0; i<=strlen(dummyString); i++ ) {\n            inputString[indexOfString][i] = dummyString[i];\n\n        }\n        indexOfString++;\n    }\n\n    while( scanf(\"%c\", &dummyCommand)!=EOF ) {\n        getchar();\n        if( dummyCommand == '-' ) break;\n        listOfCommands[indexOfCommand] = dummyCommand;\n        indexOfCommand++;\n    }\n    numberOfLines = indexOfString - 1;\n    numberOfCommands = indexOfCommand;\n    return;\n}\n\n\nvoid goToFirstPosition() { // a\n    cursorYCordinate = 0;\n}\n\n\nvoid goToLastPosition() { // e\n    cursorYCordinate = strlen(inputString[cursorXCordinate]);\n}\n\n\nvoid moveToUpperLine() {\n\n    if (cursorXCordinate > 0) {\n        cursorXCordinate -= 1;\n    }\n    // cursorYCordinate = 0;\n}\n\nvoid moveTOLowerLine() {\n\n    if (cursorXCordinate < numberOfLines) {\n        cursorXCordinate += 1;\n    }\n    //cursorYCordinate = 0;\n\n}\n\n\nvoid moveByOnePlaceToTheRight() {\n\n    int currentStringLen = strlen(inputString[ cursorXCordinate ]);\n    if( cursorYCordinate == currentStringLen ) {\n        if ( numberOfLines - cursorXCordinate > 0 ) {\n            cursorXCordinate += 1;\n            cursorYCordinate  = 0;\n        }\n    } else {\n        if( cursorYCordinate < currentStringLen )\n            cursorYCordinate += 1;\n    }\n}\n\n\nvoid moveByOnePlaceToTheLeft() {\n\n    int upperStringLen;\n    int currentStringLen = strlen(inputString[ cursorXCordinate ]);\n    if ( cursorYCordinate == 0 ) {\n        if ( cursorXCordinate > 0 ) {\n            cursorXCordinate -= 1;\n            upperStringLen = strlen( inputString[cursorXCordinate] );\n            cursorYCordinate = upperStringLen;\n        }\n    } else {\n        if ( cursorYCordinate >  0 ) {\n            cursorYCordinate -= 1;\n        }\n    }\n}\n\n\nvoid deleteSingleCharacter() {\n\n    int currentStringLen = strlen(inputString[cursorXCordinate]);\n    char referenceString[1000] = \"\";\n    int temp = 0;\n    if ( cursorYCordinate < currentStringLen ) {\n        for( int i = 0; i < currentStringLen; i++) {\n            if ( i != cursorYCordinate) {\n                referenceString[temp] = inputString[cursorXCordinate][i];\n                temp++;\n            }\n\n        }\n        strcpy(inputString[cursorXCordinate], referenceString);\n    } else if( cursorYCordinate == currentStringLen ) {\n        if ( numberOfLines - cursorXCordinate > 0 ) {\n            strcat( inputString[cursorXCordinate], inputString[cursorXCordinate+1]);\n            for(int i = cursorXCordinate+1; i<numberOfLines; i++) strcpy(inputString[i], inputString[i+1]);\n            strcpy(inputString[numberOfLines], \"\");\n        }\n    }\n}\n\n\nvoid copyText() {\n\n    int currentStringLen = strlen(inputString[cursorXCordinate]);\n    if ( currentStringLen == cursorYCordinate ) {\n        if ( numberOfLines - cursorXCordinate > 0 ) {\n            strcat( inputString[cursorXCordinate], inputString[cursorXCordinate+1]);\n            for(int i = cursorXCordinate+1; i<numberOfLines; i++) strcpy(inputString[i], inputString[i+1]);\n            strcpy(inputString[numberOfLines], \"\");\n        }\n    } else if ( cursorYCordinate < currentStringLen ) {\n        strcpy(buffer, \"\");\n        for ( int i = cursorYCordinate; i<=currentStringLen; i++)\n            buffer[i-cursorYCordinate] = inputString[cursorXCordinate][i];\n        for ( int i = cursorYCordinate; i<=currentStringLen; i++)\n            inputString[cursorXCordinate][i] = NULL;\n\n    }\n}\n\n\nvoid yank() {\n\n    int currentStringLen = strlen( inputString[cursorXCordinate]);\n\n    if ( strlen(buffer) ) {\n        if( cursorYCordinate < currentStringLen) {\n            char firstPart[1000] = \"\";\n            char secondPart[1000] = \"\";\n            int j = 0;\n            for(int i = 0; i<cursorYCordinate; i++) firstPart[i] = inputString[cursorXCordinate][i];\n            strcat(firstPart, buffer);\n            for(int i = cursorYCordinate; i<currentStringLen; i++)\n                secondPart[j++] = inputString[cursorXCordinate][i];\n            strcat(firstPart, secondPart);\n            strcat(inputString[cursorXCordinate], firstPart);\n            cursorYCordinate += strlen(buffer);\n        }\n        else {\n        strcat(inputString[cursorXCordinate], buffer);\n        cursorYCordinate += strlen(buffer);\n        }\n    }\n}\n\n\nint main() {\n\n    textInput();\n    goToFirstPosition();\n    for(int i = 0; i<numberOfCommands; i++) {\n        if( listOfCommands[i]  == 'a') goToFirstPosition();\n        if ( listOfCommands[i] == 'e') goToLastPosition();\n        if ( listOfCommands[i] == 'p') moveToUpperLine();\n        if ( listOfCommands[i] == 'n') moveTOLowerLine();\n        if ( listOfCommands[i] == 'f') moveByOnePlaceToTheRight();\n        if ( listOfCommands[i] == 'b') moveByOnePlaceToTheLeft();\n        if ( listOfCommands[i] == 'd') deleteSingleCharacter();\n        if ( listOfCommands[i] == 'k') copyText();\n        if ( listOfCommands[i] == 'y') yank();\n       // printf(\"%c_____________________\\n\",listOfCommands[i]);\n        //printf(\"%s\\n\",inputString[0]);\n        //printf(\"%s\\n\",inputString[1]);\n        //printf(\"buffer-- %s\\n\",buffer);\n        //printf(\"(%d,%d)\\n\", cursorXCordinate, cursorYCordinate);\n\n    }\n    for(int i = 0; i<=numberOfLines; i++) if(strlen(inputString[i]))printf(\"%s\\n\",inputString[i]);\n    //printf(\"%c\", inputString[cursorXCordinate][cursorYCordinate]);\n    //goToLastPosition();\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nchar inputString[1000][1000];\nchar listOfCommands[305];\nchar buffer[1000] = \"\";\n\nint numberOfLines = 0;\nint numberOfCommands = 0;\n\nint cursorXCordinate = 0;\nint cursorYCordinate = 0;\n\n\nvoid textInput() {\n\n    int indexOfString = 0;\n    int indexOfCommand = 0;\n    char dummyString[1000];\n    char dummyCommand;\n    //freopen(\"input.txt\", \"r\", stdin);\n    while ( scanf(\"%s\",dummyString)!=EOF) {\n        getchar();\n        if ( !strcmp(dummyString, \"END_OF_TEXT\") ) break;\n        for ( int i = 0; i<=strlen(dummyString); i++ ) {\n            inputString[indexOfString][i] = dummyString[i];\n\n        }\n        indexOfString++;\n    }\n\n    while( scanf(\"%c\", &dummyCommand)!=EOF ) {\n        getchar();\n        if( dummyCommand == '-' ) break;\n        listOfCommands[indexOfCommand] = dummyCommand;\n        indexOfCommand++;\n    }\n    numberOfLines = indexOfString - 1;\n    numberOfCommands = indexOfCommand;\n    return;\n}\n\n\nvoid goToFirstPosition() { // a\n    cursorYCordinate = 0;\n}\n\n\nvoid goToLastPosition() { // e\n    cursorYCordinate = strlen(inputString[cursorXCordinate]);\n}\n\n\nvoid moveToUpperLine() {\n\n    if (cursorXCordinate > 0) {\n        cursorXCordinate -= 1;\n    }\n    // cursorYCordinate = 0;\n}\n\nvoid moveTOLowerLine() {\n\n    if (cursorXCordinate < numberOfLines) {\n        cursorXCordinate += 1;\n    }\n    //cursorYCordinate = 0;\n\n}\n\n\nvoid moveByOnePlaceToTheRight() {\n\n    int currentStringLen = strlen(inputString[ cursorXCordinate ]);\n    if( cursorYCordinate == currentStringLen ) {\n        if ( numberOfLines - cursorXCordinate > 0 ) {\n            cursorXCordinate += 1;\n            cursorYCordinate  = 0;\n        }\n    } else {\n        if( cursorYCordinate < currentStringLen )\n            cursorYCordinate += 1;\n    }\n}\n\n\nvoid moveByOnePlaceToTheLeft() {\n\n    int upperStringLen;\n    int currentStringLen = strlen(inputString[ cursorXCordinate ]);\n    if ( cursorYCordinate == 0 ) {\n        if ( cursorXCordinate > 0 ) {\n            cursorXCordinate -= 1;\n            upperStringLen = strlen( inputString[cursorXCordinate] );\n            cursorYCordinate = upperStringLen;\n        }\n    } else {\n        if ( cursorYCordinate >  0 ) {\n            cursorYCordinate -= 1;\n        }\n    }\n}\n\n\nvoid deleteSingleCharacter() {\n\n    int currentStringLen = strlen(inputString[cursorXCordinate]);\n    char referenceString[1000] = \"\";\n    int temp = 0;\n    if ( cursorYCordinate < currentStringLen ) {\n        for( int i = 0; i < currentStringLen; i++) {\n            if ( i != cursorYCordinate) {\n                referenceString[temp] = inputString[cursorXCordinate][i];\n                temp++;\n            }\n\n        }\n        strcpy(inputString[cursorXCordinate], referenceString);\n    } else if( cursorYCordinate == currentStringLen ) {\n        if ( numberOfLines - cursorXCordinate > 0 ) {\n            strcat( inputString[cursorXCordinate], inputString[cursorXCordinate+1]);\n            for(int i = cursorXCordinate+1; i<numberOfLines; i++) strcpy(inputString[i], inputString[i+1]);\n            strcpy(inputString[numberOfLines], \"\");\n        }\n    }\n}\n\n\nvoid copyText() {\n\n    int currentStringLen = strlen(inputString[cursorXCordinate]);\n    if ( currentStringLen == cursorYCordinate ) {\n        if ( numberOfLines - cursorXCordinate > 0 ) {\n            strcat( inputString[cursorXCordinate], inputString[cursorXCordinate+1]);\n            for(int i = cursorXCordinate+1; i<numberOfLines; i++) strcpy(inputString[i], inputString[i+1]);\n            strcpy(inputString[numberOfLines], \"\");\n        }\n    } else if ( cursorYCordinate < currentStringLen ) {\n        strcpy(buffer, \"\");\n        for ( int i = cursorYCordinate; i<=currentStringLen; i++)\n            buffer[i-cursorYCordinate] = inputString[cursorXCordinate][i];\n        for ( int i = cursorYCordinate; i<=currentStringLen; i++)\n            inputString[cursorXCordinate][i] = NULL;\n\n    }\n}\n\n\nvoid yank() {\n\n    int currentStringLen = strlen( inputString[cursorXCordinate]);\n\n    if ( strlen(buffer) ) {\n        if( cursorYCordinate < currentStringLen) {\n            char firstPart[1000] = \"\";\n            char secondPart[1000] = \"\";\n            int j = 0;\n            for(int i = 0; i<cursorYCordinate; i++) firstPart[i] = inputString[cursorXCordinate][i];\n            strcat(firstPart, buffer);\n            for(int i = cursorYCordinate; i<currentStringLen; i++)\n                secondPart[j++] = inputString[cursorXCordinate][i];\n            strcat(firstPart, secondPart);\n            strcat(inputString[cursorXCordinate], firstPart);\n            cursorYCordinate += strlen(buffer);\n        }\n        else {\n        strcat(inputString[cursorXCordinate], buffer);\n        cursorYCordinate += strlen(buffer);\n        }\n    }\n}\n\n\nint main() {\n\n    textInput();\n    goToFirstPosition();\n    for(int i = 0; i<numberOfCommands; i++) {\n        if( listOfCommands[i]  == 'a') goToFirstPosition();\n        if ( listOfCommands[i] == 'e') goToLastPosition();\n        if ( listOfCommands[i] == 'p') moveToUpperLine();\n        if ( listOfCommands[i] == 'n') moveTOLowerLine();\n        if ( listOfCommands[i] == 'f') moveByOnePlaceToTheRight();\n        if ( listOfCommands[i] == 'b') moveByOnePlaceToTheLeft();\n        if ( listOfCommands[i] == 'd') deleteSingleCharacter();\n        if ( listOfCommands[i] == 'k') copyText();\n        if ( listOfCommands[i] == 'y') yank();\n       // printf(\"%c_____________________\\n\",listOfCommands[i]);\n        //printf(\"%s\\n\",inputString[0]);\n        //printf(\"%s\\n\",inputString[1]);\n        //printf(\"buffer-- %s\\n\",buffer);\n        //printf(\"(%d,%d)\\n\", cursorXCordinate, cursorYCordinate);\n\n    }\n    for(int i = 0; i<=numberOfLines; i++) printf(\"%s\\n\",inputString[i]);\n    //printf(\"%c\", inputString[cursorXCordinate][cursorYCordinate]);\n    //goToLastPosition();\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nchar inputString[15][25];\nchar listOfCommands[35];\nchar buffer[35] = \"\";\n\nint numberOfLines = 0;\nint numberOfCommands = 0;\n\nint cursorXCordinate = 0;\nint cursorYCordinate = 0;\n\n\nvoid textInput() {\n\n    int indexOfString = 0;\n    int indexOfCommand = 0;\n    char dummyString[30];\n    char dummyCommand;\n   // freopen(\"input.txt\", \"r\", stdin);\n    while ( scanf(\"%s\",dummyString)!=EOF) {\n        getchar();\n        if ( !strcmp(dummyString, \"END_OF_TEXT\") ) break;\n        for ( int i = 0; i<=strlen(dummyString); i++ ) {\n            inputString[indexOfString][i] = dummyString[i];\n\n        }\n        indexOfString++;\n    }\n\n    while( scanf(\"%c\", &dummyCommand)!=EOF ) {\n        getchar();\n        if( dummyCommand == '-' ) break;\n        listOfCommands[indexOfCommand] = dummyCommand;\n        indexOfCommand++;\n    }\n    numberOfLines = indexOfString - 1;\n    numberOfCommands = indexOfCommand;\n}\n\n\nvoid goToFirstPosition() { // a\n    cursorYCordinate = 0;\n}\n\n\nvoid goToLastPosition() { // e\n    cursorYCordinate = strlen(inputString[cursorXCordinate]);\n}\n\n\nvoid moveToUpperLine() {\n\n    if (cursorXCordinate > 0) {\n        cursorXCordinate -= 1;\n    }\n    // cursorYCordinate = 0;\n}\n\nvoid moveTOLowerLine() {\n\n    if (cursorXCordinate < numberOfLines) {\n        cursorXCordinate += 1;\n    }\n    //cursorYCordinate = 0;\n\n}\n\n\nvoid moveByOnePlaceToTheRight() {\n\n    int currentStringLen = strlen(inputString[ cursorXCordinate ]);\n    if( cursorYCordinate == currentStringLen ) {\n        if ( numberOfLines - cursorXCordinate > 0 ) {\n            cursorXCordinate += 1;\n            cursorYCordinate  = 0;\n        }\n    } else {\n        if( cursorYCordinate < currentStringLen )\n            cursorYCordinate += 1;\n    }\n}\n\n\nvoid moveByOnePlaceToTheLeft() {\n\n    int upperStringLen;\n    int currentStringLen = strlen(inputString[ cursorXCordinate ]);\n    if ( cursorYCordinate == 0 ) {\n        if ( cursorXCordinate > 0 ) {\n            cursorXCordinate -= 1;\n            upperStringLen = strlen( inputString[cursorXCordinate] );\n            cursorYCordinate = upperStringLen;\n        }\n    } else {\n        if ( cursorYCordinate >  0 ) {\n            cursorYCordinate -= 1;\n        }\n    }\n}\n\n\nvoid deleteSingleCharacter() {\n\n    int currentStringLen = strlen(inputString[cursorXCordinate]);\n    char referenceString[30] = \"\";\n    int temp = 0;\n    if ( cursorYCordinate < currentStringLen ) {\n        for( int i = 0; i < currentStringLen; i++) {\n            if ( i != cursorYCordinate) {\n                referenceString[temp] = inputString[cursorXCordinate][i];\n                temp++;\n            }\n\n        }\n        strcpy(inputString[cursorXCordinate], referenceString);\n    } else if( cursorYCordinate == currentStringLen ) {\n        if ( numberOfLines - cursorXCordinate > 0 ) {\n            strcat( inputString[cursorXCordinate], inputString[cursorXCordinate+1]);\n            for(int i = cursorXCordinate+1; i<numberOfLines; i++) strcpy(inputString[i], inputString[i+1]);\n            strcpy(inputString[numberOfLines], \"\");\n        }\n    }\n}\n\n\nvoid copyText() {\n\n    int currentStringLen = strlen(inputString[cursorXCordinate]);\n    if ( currentStringLen == cursorYCordinate ) {\n        if ( numberOfLines - cursorXCordinate > 0 ) {\n            strcat( inputString[cursorXCordinate], inputString[cursorXCordinate+1]);\n            for(int i = cursorXCordinate+1; i<numberOfLines; i++) strcpy(inputString[i], inputString[i+1]);\n            strcpy(inputString[numberOfLines], \"\");\n        }\n    } else if ( cursorYCordinate < currentStringLen ) {\n        strcpy(buffer, \"\");\n        for ( int i = cursorYCordinate; i<=currentStringLen; i++)\n            buffer[i-cursorYCordinate] = inputString[cursorXCordinate][i];\n        for ( int i = cursorYCordinate; i<=currentStringLen; i++)\n            inputString[cursorXCordinate][i] = NULL;\n\n    }\n}\n\n\nvoid yank() {\n\n    int currentStringLen = strlen( inputString[cursorXCordinate]);\n\n    if ( strlen(buffer) ) {\n        if( cursorYCordinate < currentStringLen) {\n            char firstPart[30] = \"\";\n            char secondPart[30] = \"\";\n            int j = 0;\n            for(int i = 0; i<cursorYCordinate; i++) firstPart[i] = inputString[cursorXCordinate][i];\n            strcat(firstPart, buffer);\n            for(int i = cursorYCordinate; i<currentStringLen; i++)\n                secondPart[j++] = inputString[cursorXCordinate][i];\n            strcat(firstPart, secondPart);\n            strcat(inputString[cursorXCordinate], firstPart);\n            cursorYCordinate += strlen(buffer);\n        }\n        else {\n        strcat(inputString[cursorXCordinate], buffer);\n        cursorYCordinate += strlen(buffer);\n        }\n    }\n}\n\n\nint main() {\n\n    textInput();\n    goToFirstPosition();\n    for(int i = 0; i<numberOfCommands; i++) {\n        if( listOfCommands[i]  == 'a') goToFirstPosition();\n        if ( listOfCommands[i] == 'e') goToLastPosition();\n        if ( listOfCommands[i] == 'p') moveToUpperLine();\n        if ( listOfCommands[i] == 'n') moveTOLowerLine();\n        if ( listOfCommands[i] == 'f') moveByOnePlaceToTheRight();\n        if ( listOfCommands[i] == 'b') moveByOnePlaceToTheLeft();\n        if ( listOfCommands[i] == 'd') deleteSingleCharacter();\n        if ( listOfCommands[i] == 'k') copyText();\n        if ( listOfCommands[i] == 'y') yank();\n       // printf(\"%c_____________________\\n\",listOfCommands[i]);\n        //printf(\"%s\\n\",inputString[0]);\n        //printf(\"%s\\n\",inputString[1]);\n        //printf(\"buffer-- %s\\n\",buffer);\n        //printf(\"(%d,%d)\\n\", cursorXCordinate, cursorYCordinate);\n\n    }\n    for(int i = 0; i<=numberOfLines; i++) printf(\"%s\\n\",inputString[i]);\n    //printf(\"%c\", inputString[cursorXCordinate][cursorYCordinate]);\n    //goToLastPosition();\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    char message[128][1024];\n    int i, len, nowx, nowy;\n    int rowLength;\n    char buffer[2], stack[1024], temp[1024];\n    \n    i = 0;\n    memset(message, '\\0', sizeof(message));\n    memset(stack, '\\0', sizeof(stack));\n    while (1){\n        scanf(\"%[^\\n]\", temp);\n        getchar();\n        if (strcmp(temp, \"END_OF_TEXT\") == 0){\n            break;\n        }\n        strcpy(message[i], temp);\n        \n        message[i][strlen(message[i])] = '\\n';\n        i++;\n    }\n    len = i;\n    nowx = nowy = 0;\n    while (1){\n        scanf(\"%s\", buffer);\n        \n        if (buffer[0] == '-'){\n            break;\n        }\n        \n        switch (buffer[0]){\n          case 'a':\n            nowx = 0;\n            break;\n          \n          case 'e':\n            nowx = strlen(message[nowy]) - 1;\n            break;\n          \n          case 'p':\n            if (nowy > 0){\n                nowy--;\n            }\n            nowx = 0;\n            break;\n          \n          case 'n':\n            if (nowy < len - 1){\n                nowy++;\n            }\n            nowx = 0;\n            break;\n          \n          case 'f':\n            if (nowx < strlen(message[nowy]) - 1){\n                nowx++;\n            }\n            else if (nowy < len - 1 && nowx == strlen(message[nowy]) - 1){\n                nowy++;\n                nowx = 0;\n            }\n            break;\n          \n          case 'b':\n            if (nowx > 0){\n                nowx--;\n            }\n            else if (nowy > 0 && nowx == 0){\n                nowy--;\n                nowx = strlen(message[nowy]) - 1;\n            }\n            break;\n          \n          case 'd':\n            if (message[nowy][nowx] != '\\n'){\n                rowLength = strlen(message[nowy]) - 1;\n                for (i = nowx; i < rowLength; i++){\n                    message[nowy][i] = message[nowy][i + 1];\n                }\n                message[nowy][i] = '\\0';\n            }\n            else if (message[nowy][nowx] == '\\n' && nowy < len - 1){\n                rowLength = strlen(message[nowy + 1]);\n                for (i = 0; i < rowLength; i++){\n                    message[nowy][nowx + i] = message[nowy + 1][i];\n                }\n                len -= 1;\n                for (i = nowy + 1; i < len; i++){\n                    strcpy(message[i], message[i + 1]);\n                }\n                memset(message[i], '\\0', sizeof(message[i]));\n            }\n            break;\n          \n          case 'k':\n            if (message[nowy][nowx] == '\\n' && nowy < len - 1){\n                rowLength = strlen(message[nowy + 1]);\n                for (i = 0; i < rowLength; i++){\n                    message[nowy][nowx + i] = message[nowy + 1][i];\n                }\n                len -= 1;\n                for (i = nowy + 1; i < len; i++){\n                    strcpy(message[i], message[i + 1]);\n                }\n                memset(message[i], '\\0', sizeof(message[i]));\n                stack[0] = '\\n';\n            }\n            else if (message[nowy][nowx] != '\\n'){\n                strcpy(stack, &message[nowy][nowx]);\n                memset(&message[nowy][nowx], '\\0', sizeof(&message[nowy][nowx]));\n                stack[strlen(stack) - 1] = '\\0';\n                rowLength = strlen(message[nowy]);\n                nowx = rowLength;\n                message[nowy][nowx] = '\\n';\n            }\n            break;\n          \n          case 'y':\n            if (stack[0] == '\\n'){\n                for (i = len; i > nowy; i--){\n                    strcpy(message[i], message[i - 1]);\n                }\n                strcpy(message[nowy + 1], &message[nowy][nowx]);\n                message[nowy][nowx] = '\\n';\n                message[nowy][nowx + 1] = '\\0';\n                nowy++;\n                nowx = 0;\n                len++;\n            }\n            else if (stack[0] != '\\0'){\n                strcpy(temp, message[nowy]);\n                strcpy(&message[nowy][nowx], stack);\n                strcat(message[nowy], &temp[nowx]);\n                nowx += strlen(stack);\n            }\n            break;\n        }\n    }\n    \n    for (i = 0; i < len; i++){\n        printf(\"%s\", message[i]);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    char message[128][1024];\n    int i, len, nowx, nowy;\n    int rowLength;\n    char buffer[2], stack[1024], temp[1024];\n    \n    i = 0;\n    memset(message, '\\0', sizeof(message));\n    memset(stack, '\\0', sizeof(stack));\n    while (1){\n        scanf(\"%[^\\n]\", temp);\n        getchar();\n        if (strcmp(temp, \"END_OF_TEXT\") == 0){\n            break;\n        }\n        strcpy(message[i], temp);\n        \n        message[i][strlen(message[i])] = '\\n';\n        i++;\n    }\n    len = i;\n    nowx = nowy = 0;\n    while (1){\n        scanf(\"%s\", buffer);\n        \n        if (buffer[0] == '-'){\n            break;\n        }\n        \n        switch (buffer[0]){\n          case 'a':\n            nowx = 0;\n            break;\n          \n          case 'e':\n            nowx = strlen(message[nowy]) - 1;\n            break;\n          \n          case 'p':\n            if (nowy > 0){\n                nowy--;\n            }\n            nowx = 0;\n            break;\n          \n          case 'n':\n            if (nowy < len - 1){\n                nowy++;\n            }\n            nowx = 0;\n            break;\n          \n          case 'f':\n            if (nowx < (int)strlen(message[nowy]) - 1){\n                nowx++;\n            }\n            else if (nowy < len - 1 && nowx == (int)strlen(message[nowy]) - 1){\n                nowy++;\n                nowx = 0;\n            }\n            break;\n          \n          case 'b':\n            if (nowx > 0){\n                nowx--;\n            }\n            else if (nowy > 0 && nowx == 0){\n                nowy--;\n                nowx = strlen(message[nowy]) - 1;\n            }\n            break;\n          \n          case 'd':\n            if (message[nowy][nowx] != '\\n'){\n                rowLength = strlen(message[nowy]) - 1;\n                for (i = nowx; i < rowLength; i++){\n                    message[nowy][i] = message[nowy][i + 1];\n                }\n                message[nowy][i] = '\\0';\n            }\n            else if (message[nowy][nowx] == '\\n' && nowy < len - 1){\n                rowLength = strlen(message[nowy + 1]);\n                for (i = 0; i < rowLength; i++){\n                    message[nowy][nowx + i] = message[nowy + 1][i];\n                }\n                len -= 1;\n                for (i = nowy + 1; i < len; i++){\n                    strcpy(message[i], message[i + 1]);\n                }\n                memset(message[i], '\\0', sizeof(message[i]));\n            }\n            break;\n          \n          case 'k':\n            if (message[nowy][nowx] == '\\n' && nowy < len - 1){\n                rowLength = strlen(message[nowy + 1]);\n                for (i = 0; i < rowLength; i++){\n                    message[nowy][nowx + i] = message[nowy + 1][i];\n                }\n                len -= 1;\n                for (i = nowy + 1; i < len; i++){\n                    strcpy(message[i], message[i + 1]);\n                }\n                memset(message[i], '\\0', sizeof(message[i]));\n                stack[0] = '\\n';\n            }\n            else if (message[nowy][nowx] != '\\n'){\n                strcpy(stack, &message[nowy][nowx]);\n                memset(&message[nowy][nowx], '\\0', sizeof(&message[nowy][nowx]));\n                stack[strlen(stack) - 1] = '\\0';\n                rowLength = strlen(message[nowy]);\n                nowx = rowLength;\n                message[nowy][nowx] = '\\n';\n            }\n            break;\n          \n          case 'y':\n            if (stack[0] == '\\n'){\n                for (i = len; i > nowy; i--){\n                    strcpy(message[i], message[i - 1]);\n                }\n                strcpy(message[nowy + 1], &message[nowy][nowx]);\n                message[nowy][nowx] = '\\n';\n                message[nowy][nowx + 1] = '\\0';\n                nowy++;\n                nowx = 0;\n                len++;\n            }\n            else if (stack[0] != '\\0'){\n                strcpy(temp, message[nowy]);\n                strcpy(&message[nowy][nowx], stack);\n                strcat(message[nowy], &temp[nowx]);\n                nowx += strlen(stack);\n            }\n            break;\n        }\n    }\n    \n    for (i = 0; i < len; i++){\n        printf(\"%s\", message[i]);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint line_max;\nchar buffer[2000];\nchar bunsyou[200][2000];\nint cx,cy;\n\nvoid a(void) {\n\tcx=0;\n}\n\nvoid e(void) {\n\tcx=strlen(bunsyou[cy]);\n}\n\nvoid p(void) {\n\tif(cy>0)cy--;\n\tcx=0;\n}\n\nvoid n(void) {\n\tif(cy<line_max-1)cy++;\n\tcx=0;\n}\n\nvoid f(void) {\n\tif(cx<strlen(bunsyou[cy]))cx++;\n\telse if(cy<line_max-1) {\n\t\tcy++;\n\t\tcx=0;\n\t}\n}\n\nvoid b(void) {\n\tif(cx>0)cx--;\n\telse if(cy>0) {\n\t\tcy--;\n\t\tcx=strlen(bunsyou[cy]);\n\t}\n}\n\nvoid d(void) {\n\tint i,length;\n\tif(cx<strlen(bunsyou[cy])) {\n\t\tlength=strlen(&bunsyou[cy][cx])-1;\n\t\tmemmove(&bunsyou[cy][cx],&bunsyou[cy][cx+1],length);\n\t\tbunsyou[cy][cx+length]=0;\n\t} else if(cy<line_max-1) {\n\t\tstrcat(bunsyou[cy],bunsyou[cy+1]);\n\t\tfor(i=cy+2;i<line_max;i++) {\n\t\t\tstrcpy(bunsyou[i-1],bunsyou[i]);\n\t\t}\n\t\tline_max--;\n\t}\n}\n\nvoid k(void) {\n\tif(cx>=strlen(bunsyou[cy])) {\n\t\td();\n\t\tbuffer[0]='\\n';\n\t\tbuffer[1]=0;\n\t} else {\n\t\tstrcpy(buffer,&bunsyou[cy][cx]);\n\t\tbunsyou[cy][cx]=0;\n\t}\n}\n\nvoid y(void) {\n\tint i,length;\n\tif(buffer[0]==0)return;\n\tif(buffer[0]=='\\n') {\n\t\tfor(i=line_max;i>cy+1;i--) {\n\t\t\tstrcpy(bunsyou[i-1],bunsyou[i]);\n\t\t}\n\t\tline_max++;\n\t\tstrcpy(bunsyou[cy+1],&bunsyou[cy][cx]);\n\t\tbunsyou[cy][cx]=0;\n\t\tcy++;\n\t\tcx=0;\n\t} else {\n\t\tlength=strlen(buffer);\n\t\tmemmove(&bunsyou[cy][cx+length],&bunsyou[cy][cx],\n\t\t\tstrlen(&bunsyou[cy][cx])+1);\n\t\tmemmove(&bunsyou[cy][cx],buffer,length);\n\t\tcx+=length;\n\t}\n}\n\nint main(void) {\n\tchar* cp;\n\tchar cmd[10];\n\tint i;\n\tline_max=0;\n\twhile(1) {\n\t\tfgets(bunsyou[line_max],sizeof(bunsyou[line_max]),stdin);\n\t\tcp=strchr(bunsyou[line_max],'\\n');\n\t\tif(cp)*cp=0;\n\t\tif(strcmp(bunsyou[line_max],\"END_OF_TEXT\")==0) {\n\t\t\tbunsyou[line_max][0]=0;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tline_max++;\n\t\t}\n\t}\n\twhile(1) {\n\t\tscanf(\"%s\",cmd);\n\t\tif(cmd[0]=='-')break;\n\t\tswitch(cmd[0]) {\n\t\t\tcase 'a':a();break;\n\t\t\tcase 'e':e();break;\n\t\t\tcase 'p':p();break;\n\t\t\tcase 'n':n();break;\n\t\t\tcase 'f':f();break;\n\t\t\tcase 'b':b();break;\n\t\t\tcase 'd':d();break;\n\t\t\tcase 'k':k();break;\n\t\t\tcase 'y':y();break;\n\t\t}\n\t}\n\tfor(i=0;i<line_max;i++)puts(bunsyou[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint line_max;\nchar buffer[2000];\nchar bunsyou[200][2000];\nint cx,cy;\n\nvoid a(void) {\n\tcx=0;\n}\n\nvoid e(void) {\n\tcx=strlen(bunsyou[cy]);\n}\n\nvoid p(void) {\n\tif(cy>0)cy--;\n\tcx=0;\n}\n\nvoid n(void) {\n\tif(cy<line_max-1)cy++;\n\tcx=0;\n}\n\nvoid f(void) {\n\tif(cx<strlen(bunsyou[cy]))cx++;\n\telse if(cy<line_max-1) {\n\t\tcy++;\n\t\tcx=0;\n\t}\n}\n\nvoid b(void) {\n\tif(cx>0)cx--;\n\telse if(cy>0) {\n\t\tcy--;\n\t\tcx=strlen(bunsyou[cy]);\n\t}\n}\n\nvoid d(void) {\n\tint i,length;\n\tif(cx<strlen(bunsyou[cy])) {\n\t\tlength=strlen(&bunsyou[cy][cx])-1;\n\t\tmemmove(&bunsyou[cy][cx],&bunsyou[cy][cx+1],length);\n\t\tbunsyou[cy][cx+length]=0;\n\t} else if(cy<line_max-1) {\n\t\tstrcat(bunsyou[cy],bunsyou[cy+1]);\n\t\tfor(i=cy+2;i<line_max;i++) {\n\t\t\tstrcpy(bunsyou[i-1],bunsyou[i]);\n\t\t}\n\t\tline_max--;\n\t}\n}\n\nvoid k(void) {\n\tint i;\n\tif(cx>=strlen(bunsyou[cy])) {\n\t\tif(cy<line_max-1) {\n\t\t\tstrcat(bunsyou[cy],bunsyou[cy+1]);\n\t\t\tfor(i=cy+2;i<line_max;i++) {\n\t\t\t\tstrcpy(bunsyou[i-1],bunsyou[i]);\n\t\t\t}\n\t\t\tline_max--;\n\t\t\tbuffer[0]='\\n';\n\t\t\tbuffer[1]=0;\n\t\t}\n\t} else {\n\t\tstrcpy(buffer,&bunsyou[cy][cx]);\n\t\tbunsyou[cy][cx]=0;\n\t}\n}\n\nvoid y(void) {\n\tint i,length;\n\tif(buffer[0]==0)return;\n\tif(buffer[0]=='\\n') {\n\t\tfor(i=line_max;i>cy+1;i--) {\n\t\t\tstrcpy(bunsyou[i-1],bunsyou[i]);\n\t\t}\n\t\tline_max++;\n\t\tstrcpy(bunsyou[cy+1],&bunsyou[cy][cx]);\n\t\tbunsyou[cy][cx]=0;\n\t\tcy++;\n\t\tcx=0;\n\t} else {\n\t\tlength=strlen(buffer);\n\t\tmemmove(&bunsyou[cy][cx+length],&bunsyou[cy][cx],\n\t\t\tstrlen(&bunsyou[cy][cx])+1);\n\t\tmemmove(&bunsyou[cy][cx],buffer,length);\n\t\tcx+=length;\n\t}\n}\n\nint main(void) {\n\tchar* cp;\n\tchar cmd[10];\n\tint i;\n\tline_max=0;\n\twhile(1) {\n\t\tfgets(bunsyou[line_max],sizeof(bunsyou[line_max]),stdin);\n\t\tcp=strchr(bunsyou[line_max],'\\n');\n\t\tif(cp)*cp=0;\n\t\tif(strcmp(bunsyou[line_max],\"END_OF_TEXT\")==0) {\n\t\t\tbunsyou[line_max][0]=0;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tline_max++;\n\t\t}\n\t}\n\twhile(1) {\n\t\tscanf(\"%s\",cmd);\n\t\tif(cmd[0]=='-')break;\n\t\tswitch(cmd[0]) {\n\t\t\tcase 'a':a();break;\n\t\t\tcase 'e':e();break;\n\t\t\tcase 'p':p();break;\n\t\t\tcase 'n':n();break;\n\t\t\tcase 'f':f();break;\n\t\t\tcase 'b':b();break;\n\t\t\tcase 'd':d();break;\n\t\t\tcase 'k':k();break;\n\t\t\tcase 'y':y();break;\n\t\t}\n\t}\n\tfor(i=0;i<line_max;i++)puts(bunsyou[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "char*p,x[1001*100],b[1001],*q;\nA(){\n\twhile(p>x&&p[-1]!='\\n')\n\t\tp--;\n}\nE(){\n\twhile(*p&&*p!='\\n')\n\t\tp++;\n}\nF(){\n\tif(*p)\n\t\tp++;\n}\nB(){\n\tif(p>x)\n\t\tp--;\n}\nmain(c){\n\tfor(p=x;p<x+13||strcmp(p-13,\"\\nEND_OF_TEXT\\n\");p++)\n\t\t*p=getchar();\n\tp[-13]=0;\n\tp=x;\n\tfor(;~scanf(\"%s\",&c);){\n\t\tswitch(c){\n\t\tcase 'a':\n\t\t\tA();\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tE();\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tA(),B(),A();\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tE(),F(),E();\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tF();\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tB();\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif(*p)\n\t\t\t\tmemmove(p,p+1,strlen(p));\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tq=p;\n\t\t\tif(*p=='\\n')\n\t\t\t\tp++;\n\t\t\telse\n\t\t\t\tE();\n\t\t\tmemcpy(b,q,p-q);\n\t\t\tb[p-q]=0;\n\t\t\tp=memmove(q,p,strlen(p)+1);\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tmemmove(p+strlen(b),p,strlen(p)+1);\n\t\t\tmemcpy(p,b,strlen(b));\n\t\t\tp+=strlen(b);\n\t\t\tbreak;\n\t\t}\n\t}\n\tputs(x);\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    char message[101][1001];\n    int i, len, nowx, nowy;\n    int rowLength;\n    char buffer, stack[1001], temp[1001];\n    \n    i = 0;\n    memset(message, '\\0', sizeof(message));\n    memset(stack, '\\0', sizeof(stack));\n    while (1){\n        scanf(\"%s\", temp);\n        \n        if (strcmp(temp, \"END_OF_TEXT\") == 0){\n            break;\n        }\n        strcpy(message[i], temp);\n        \n        message[i][strlen(message[i])] = '\\n';\n        i++;\n    }\n    fflush(stdin);\n    len = i;\n    nowx = nowy = 0;\n    while (1){\n        scanf(\"%c\", &buffer);\n        getchar();\n        \n        if (buffer == '-'){\n            break;\n        }\n        \n        switch (buffer){\n          case 'a':\n            nowx = 0;\n            break;\n          \n          case 'e':\n            nowx = strlen(message[nowy]) - 1;\n            break;\n          \n          case 'p':\n            if (nowy > 0){\n                nowy--;\n            }\n            nowx = 0;\n            break;\n          \n          case 'n':\n            if (nowy < len - 1){\n                nowy++;\n            }\n            nowx = 0;\n            break;\n          \n          case 'f':\n            if (nowx < strlen(message[nowy]) - 1){\n                nowx++;\n            }\n            else if (nowy < len - 1 && nowx == strlen(message[nowy]) - 1){\n                nowy++;\n                nowx = 0;\n            }\n            break;\n          \n          case 'b':\n            if (nowx > 0){\n                nowx--;\n            }\n            else if (nowy > 0 && nowx == 0){\n                nowy--;\n                nowx = strlen(message[nowy]) - 1;\n            }\n            break;\n          \n          case 'd':\n            if (message[nowy][nowx] != '\\n'){\n                rowLength = strlen(message[nowy]) - 1;\n                for (i = nowx; i < rowLength; i++){\n                    message[nowy][i] = message[nowy][i + 1];\n                }\n                message[nowy][i] = '\\0';\n            }\n            else if (message[nowy][nowx] == '\\n' && nowy < len - 1){\n                rowLength = strlen(message[nowy + 1]);\n                for (i = 0; i < rowLength; i++){\n                    message[nowy][nowx + i] = message[nowy + 1][i];\n                }\n                len -= 1;\n                for (i = nowy + 1; i < len; i++){\n                    strcpy(message[i], message[i + 1]);\n                }\n                memset(message[i], '\\0', sizeof(message[i]));\n            }\n            break;\n          \n          case 'k':\n            if (message[nowy][nowx] == '\\n' && nowy < len - 1){\n                rowLength = strlen(message[nowy + 1]);\n                for (i = 0; i < rowLength; i++){\n                    message[nowy][nowx + i] = message[nowy + 1][i];\n                }\n                len -= 1;\n                for (i = nowy + 1; i < len; i++){\n                    strcpy(message[i], message[i + 1]);\n                }\n                memset(message[i], '\\0', sizeof(message[i]));\n                stack[0] = '\\n';\n            }\n            else if (message[nowy][nowx] != '\\n'){\n                strcpy(stack, &message[nowy][nowx]);\n                memset(&message[nowy][nowx], '\\0', sizeof(&message[nowy][nowx]));\n                stack[strlen(stack) - 1] = '\\0';\n                rowLength = strlen(message[nowy]);\n                nowx = rowLength;\n                message[nowy][nowx] = '\\n';\n            }\n            break;\n          \n          case 'y':\n            if (stack[0] == '\\n'){\n                for (i = len; i > nowy; i--){\n                    strcpy(message[i], message[i - 1]);\n                }\n                strcpy(message[nowy + 1], &message[nowy][nowx]);\n                message[nowy][nowx] = '\\n';\n                message[nowy][nowx + 1] = '\\0';\n                nowy++;\n                nowx = 0;\n                len++;\n            }\n            else if (stack[0] != '\\0'){\n                strcpy(temp, message[nowy]);\n                strcpy(&message[nowy][nowx], stack);\n                strcat(message[nowy], &temp[nowx]);\n                nowx += strlen(stack);\n            }\n            break;\n        }\n        i = 0;\n    }\n    \n    i = 0;\n    while (message[i][0] != '\\0'){\n        printf(\"%s\", message[i++]);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    char message[101][1001];\n    int i, len, nowx, nowy;\n    int rowLength;\n    char buffer[2], stack[1001], temp[1001];\n    \n    i = 0;\n    memset(message, '\\0', sizeof(message));\n    memset(stack, '\\0', sizeof(stack));\n    while (1){\n        scanf(\"%s\", temp);\n        \n        if (strcmp(temp, \"END_OF_TEXT\") == 0){\n            break;\n        }\n        strcpy(message[i], temp);\n        \n        message[i][strlen(message[i])] = '\\n';\n        i++;\n    }\n    len = i;\n    nowx = nowy = 0;\n    while (1){\n        scanf(\"%s\", buffer);\n        getchar();\n        \n        if (buffer[0] == '-'){\n            break;\n        }\n        \n        switch (buffer[0]){\n          case 'a':\n            nowx = 0;\n            break;\n          \n          case 'e':\n            nowx = strlen(message[nowy]) - 1;\n            break;\n          \n          case 'p':\n            if (nowy > 0){\n                nowy--;\n            }\n            nowx = 0;\n            break;\n          \n          case 'n':\n            if (nowy < len - 1){\n                nowy++;\n            }\n            nowx = 0;\n            break;\n          \n          case 'f':\n            if (nowx < strlen(message[nowy]) - 1){\n                nowx++;\n            }\n            else if (nowy < len - 1 && nowx == strlen(message[nowy]) - 1){\n                nowy++;\n                nowx = 0;\n            }\n            break;\n          \n          case 'b':\n            if (nowx > 0){\n                nowx--;\n            }\n            else if (nowy > 0 && nowx == 0){\n                nowy--;\n                nowx = strlen(message[nowy]) - 1;\n            }\n            break;\n          \n          case 'd':\n            if (message[nowy][nowx] != '\\n'){\n                rowLength = strlen(message[nowy]) - 1;\n                for (i = nowx; i < rowLength; i++){\n                    message[nowy][i] = message[nowy][i + 1];\n                }\n                message[nowy][i] = '\\0';\n            }\n            else if (message[nowy][nowx] == '\\n' && nowy < len - 1){\n                rowLength = strlen(message[nowy + 1]);\n                for (i = 0; i < rowLength; i++){\n                    message[nowy][nowx + i] = message[nowy + 1][i];\n                }\n                len -= 1;\n                for (i = nowy + 1; i < len; i++){\n                    strcpy(message[i], message[i + 1]);\n                }\n                memset(message[i], '\\0', sizeof(message[i]));\n            }\n            break;\n          \n          case 'k':\n            if (message[nowy][nowx] == '\\n' && nowy < len - 1){\n                rowLength = strlen(message[nowy + 1]);\n                for (i = 0; i < rowLength; i++){\n                    message[nowy][nowx + i] = message[nowy + 1][i];\n                }\n                len -= 1;\n                for (i = nowy + 1; i < len; i++){\n                    strcpy(message[i], message[i + 1]);\n                }\n                memset(message[i], '\\0', sizeof(message[i]));\n                stack[0] = '\\n';\n            }\n            else if (message[nowy][nowx] != '\\n'){\n                strcpy(stack, &message[nowy][nowx]);\n                memset(&message[nowy][nowx], '\\0', sizeof(&message[nowy][nowx]));\n                stack[strlen(stack) - 1] = '\\0';\n                rowLength = strlen(message[nowy]);\n                nowx = rowLength;\n                message[nowy][nowx] = '\\n';\n            }\n            break;\n          \n          case 'y':\n            if (stack[0] == '\\n'){\n                for (i = len; i > nowy; i--){\n                    strcpy(message[i], message[i - 1]);\n                }\n                strcpy(message[nowy + 1], &message[nowy][nowx]);\n                message[nowy][nowx] = '\\n';\n                message[nowy][nowx + 1] = '\\0';\n                nowy++;\n                nowx = 0;\n                len++;\n            }\n            else if (stack[0] != '\\0'){\n                strcpy(temp, message[nowy]);\n                strcpy(&message[nowy][nowx], stack);\n                strcat(message[nowy], &temp[nowx]);\n                nowx += strlen(stack);\n            }\n            break;\n        }\n    }\n    \n    for (i = 0; i < len; i++){\n        printf(\"%s\", message[i]);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    char message[256][1024];\n    int i, len, nowx, nowy;\n    int rowLength;\n    char buffer[2], stack[1024], temp[1024];\n    \n    i = 0;\n    memset(message, '\\0', sizeof(message));\n    memset(stack, '\\0', sizeof(stack));\n    while (1){\n        scanf(\"%[^\\n]\", temp);\n        getchar();\n        if (strcmp(temp, \"END_OF_TEXT\") == 0){\n            break;\n        }\n        strcpy(message[i], temp);\n        \n        message[i][strlen(message[i])] = '\\n';\n        i++;\n    }\n    len = i;\n    nowx = nowy = 0;\n    while (1){\n        scanf(\"%s\", buffer);\n        \n        if (buffer[0] == '-'){\n            break;\n        }\n        \n        switch (buffer[0]){\n          case 'a':\n            nowx = 0;\n            break;\n          \n          case 'e':\n            nowx = strlen(message[nowy]) - 1;\n            break;\n          \n          case 'p':\n            if (nowy > 0){\n                nowy--;\n            }\n            nowx = 0;\n            break;\n          \n          case 'n':\n            if (nowy < len - 1){\n                nowy++;\n            }\n            nowx = 0;\n            break;\n          \n          case 'f':\n            if (nowx < (int)strlen(message[nowy]) - 1){\n                nowx++;\n            }\n            else if (nowy < len - 1 && nowx == (int)strlen(message[nowy]) - 1){\n                nowy++;\n                nowx = 0;\n            }\n            break;\n          \n          case 'b':\n            if (nowx > 0){\n                nowx--;\n            }\n            else if (nowy > 0 && nowx == 0){\n                nowy--;\n                nowx = strlen(message[nowy]) - 1;\n            }\n            break;\n          \n          case 'd':\n            if (message[nowy][nowx] != '\\n'){\n                rowLength = strlen(message[nowy]) - 1;\n                for (i = nowx; i < rowLength; i++){\n                    message[nowy][i] = message[nowy][i + 1];\n                }\n                message[nowy][i] = '\\0';\n            }\n            else if (message[nowy][nowx] == '\\n' && nowy < len - 1){\n                rowLength = strlen(message[nowy + 1]);\n                for (i = 0; i < rowLength; i++){\n                    message[nowy][nowx + i] = message[nowy + 1][i];\n                }\n                len -= 1;\n                for (i = nowy + 1; i < len; i++){\n                    strcpy(message[i], message[i + 1]);\n                }\n                memset(message[i], '\\0', sizeof(message[i]));\n            }\n            break;\n          \n          case 'k':\n            if (message[nowy][nowx] == '\\n' && nowy < len - 1){\n                rowLength = strlen(message[nowy + 1]);\n                for (i = 0; i < rowLength; i++){\n                    message[nowy][nowx + i] = message[nowy + 1][i];\n                }\n                len -= 1;\n                for (i = nowy + 1; i < len; i++){\n                    strcpy(message[i], message[i + 1]);\n                }\n                memset(message[i], '\\0', sizeof(message[i]));\n                memset(stack, '\\0', sizeof(stack));\n                stack[0] = '\\n';\n            }\n            else if (message[nowy][nowx] != '\\n'){\n                memset(stack, '\\0', sizeof(stack));\n                strcpy(stack, &message[nowy][nowx]);\n                memset(&message[nowy][nowx], '\\0', sizeof(&message[nowy][nowx]));\n                stack[strlen(stack) - 1] = '\\0';\n                rowLength = strlen(message[nowy]);\n                nowx = rowLength;\n                message[nowy][nowx] = '\\n';\n            }\n            break;\n          \n          case 'y':\n            if (stack[0] == '\\n'){\n                for (i = len; i > nowy; i--){\n                    strcpy(message[i], message[i - 1]);\n                }\n                strcpy(message[nowy + 1], &message[nowy][nowx]);\n                memset(&message[nowy][nowx], '\\0', sizeof(&message[nowy][nowx]));\n                message[nowy][nowx] = '\\n';\n                nowy++;\n                nowx = 0;\n                len++;\n            }\n            else if (stack[0] != '\\0'){\n                strcpy(temp, message[nowy]);\n                strcpy(&message[nowy][nowx], stack);\n                strcat(message[nowy], &temp[nowx]);\n                nowx += strlen(stack);\n            }\n            break;\n        }\n    }\n    \n    for (i = 0; i < len; i++){\n        printf(\"%s\", message[i]);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint line_max;\nchar buffer[2000];\nchar bunsyou[200][2000];\nint cx,cy;\n\nvoid a(void) {\n\tcx=0;\n}\n\nvoid e(void) {\n\tcx=strlen(bunsyou[cy]);\n}\n\nvoid p(void) {\n\tif(cy>0)cy--;\n\tcx=0;\n}\n\nvoid n(void) {\n\tif(cy<line_max-1)cy++;\n\tcx=0;\n}\n\nvoid f(void) {\n\tif(cx<strlen(bunsyou[cy]))cx++;\n\telse if(cy<line_max-1) {\n\t\tcy++;\n\t\tcx=0;\n\t}\n}\n\nvoid b(void) {\n\tif(cx>0)cx--;\n\telse if(cy>0) {\n\t\tcy--;\n\t\tcx=strlen(bunsyou[cy]);\n\t}\n}\n\nvoid d(void) {\n\tint i,length;\n\tif(cx<strlen(bunsyou[cy])) {\n\t\tlength=strlen(&bunsyou[cy][cx])-1;\n\t\tmemmove(&bunsyou[cy][cx],&bunsyou[cy][cx+1],length);\n\t\tbunsyou[cy][cx+length]=0;\n\t} else if(cy<line_max-1) {\n\t\tstrcat(bunsyou[cy],bunsyou[cy+1]);\n\t\tfor(i=cy+2;i<line_max;i++) {\n\t\t\tstrcpy(bunsyou[i-1],bunsyou[i]);\n\t\t}\n\t\tline_max--;\n\t}\n}\n\nvoid k(void) {\n\tint i;\n\tif(cx>=strlen(bunsyou[cy])) {\n\t\tif(cy<line_max-1) {\n\t\t\tstrcat(bunsyou[cy],bunsyou[cy+1]);\n\t\t\tfor(i=cy+2;i<line_max;i++) {\n\t\t\t\tstrcpy(bunsyou[i-1],bunsyou[i]);\n\t\t\t}\n\t\t\tline_max--;\n\t\t\tbuffer[0]='\\n';\n\t\t\tbuffer[1]=0;\n\t\t}\n\t} else {\n\t\tstrcpy(buffer,&bunsyou[cy][cx]);\n\t\tbunsyou[cy][cx]=0;\n\t}\n}\n\nvoid y(void) {\n\tint i,length;\n\tif(buffer[0]==0)return;\n\tif(buffer[0]=='\\n') {\n\t\tfor(i=line_max;i>cy+1;i--) {\n\t\t\tstrcpy(bunsyou[i],bunsyou[i-1]);\n\t\t}\n\t\tline_max++;\n\t\tstrcpy(bunsyou[cy+1],&bunsyou[cy][cx]);\n\t\tbunsyou[cy][cx]=0;\n\t\tcy++;\n\t\tcx=0;\n\t} else {\n\t\tlength=strlen(buffer);\n\t\tmemmove(&bunsyou[cy][cx+length],&bunsyou[cy][cx],\n\t\t\tstrlen(&bunsyou[cy][cx])+1);\n\t\tmemmove(&bunsyou[cy][cx],buffer,length);\n\t\tcx+=length;\n\t}\n}\n\nint main(void) {\n\tchar* cp;\n\tchar cmd[10];\n\tint i;\n\tline_max=0;\n\twhile(1) {\n\t\tfgets(bunsyou[line_max],sizeof(bunsyou[line_max]),stdin);\n\t\tcp=strchr(bunsyou[line_max],'\\n');\n\t\tif(cp)*cp=0;\n\t\tif(strcmp(bunsyou[line_max],\"END_OF_TEXT\")==0) {\n\t\t\tbunsyou[line_max][0]=0;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tline_max++;\n\t\t}\n\t}\n\twhile(1) {\n\t\tscanf(\"%s\",cmd);\n\t\tif(cmd[0]=='-')break;\n\t\tswitch(cmd[0]) {\n\t\t\tcase 'a':a();break;\n\t\t\tcase 'e':e();break;\n\t\t\tcase 'p':p();break;\n\t\t\tcase 'n':n();break;\n\t\t\tcase 'f':f();break;\n\t\t\tcase 'b':b();break;\n\t\t\tcase 'd':d();break;\n\t\t\tcase 'k':k();break;\n\t\t\tcase 'y':y();break;\n\t\t}\n\t}\n\tfor(i=0;i<line_max;i++)puts(bunsyou[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    char message[128][1024];\n    int i, len, nowx, nowy;\n    int rowLength;\n    char buffer[2], stack[1024], temp[1024];\n    \n    i = 0;\n    memset(message, '\\0', sizeof(message));\n    memset(stack, '\\0', sizeof(stack));\n    while (1){\n        scanf(\"%[^\\n]\", temp);\n        getchar();\n        if (strcmp(temp, \"END_OF_TEXT\") == 0){\n            break;\n        }\n        strcpy(message[i], temp);\n        \n        message[i][strlen(message[i])] = '\\n';\n        i++;\n    }\n    len = i;\n    nowx = nowy = 0;\n    while (1){\n        scanf(\"%s\", buffer);\n        \n        if (buffer[0] == '-'){\n            break;\n        }\n        \n        switch (buffer[0]){\n          case 'a':\n            nowx = 0;\n            break;\n          \n          case 'e':\n            nowx = strlen(message[nowy]) - 1;\n            break;\n          \n          case 'p':\n            if (nowy > 0){\n                nowy--;\n            }\n            nowx = 0;\n            break;\n          \n          case 'n':\n            if (nowy < len - 1){\n                nowy++;\n            }\n            nowx = 0;\n            break;\n          \n          case 'f':\n            if (nowx < (int)strlen(message[nowy]) - 1){\n                nowx++;\n            }\n            else if (nowy < len - 1 && nowx == (int)strlen(message[nowy]) - 1){\n                nowy++;\n                nowx = 0;\n            }\n            break;\n          \n          case 'b':\n            if (nowx > 0){\n                nowx--;\n            }\n            else if (nowy > 0 && nowx == 0){\n                nowy--;\n                nowx = strlen(message[nowy]) - 1;\n            }\n            break;\n          \n          case 'd':\n            if (message[nowy][nowx] != '\\n'){\n                rowLength = strlen(message[nowy]) - 1;\n                for (i = nowx; i < rowLength; i++){\n                    message[nowy][i] = message[nowy][i + 1];\n                }\n                message[nowy][i] = '\\0';\n            }\n            else if (message[nowy][nowx] == '\\n' && nowy < len - 1){\n                rowLength = strlen(message[nowy + 1]);\n                for (i = 0; i < rowLength; i++){\n                    message[nowy][nowx + i] = message[nowy + 1][i];\n                }\n                len -= 1;\n                for (i = nowy + 1; i < len; i++){\n                    strcpy(message[i], message[i + 1]);\n                }\n                memset(message[i], '\\0', sizeof(message[i]));\n            }\n            break;\n          \n          case 'k':\n            if (message[nowy][nowx] == '\\n' && nowy < len - 1){\n                rowLength = strlen(message[nowy + 1]);\n                for (i = 0; i < rowLength; i++){\n                    message[nowy][nowx + i] = message[nowy + 1][i];\n                }\n                len -= 1;\n                for (i = nowy + 1; i < len; i++){\n                    strcpy(message[i], message[i + 1]);\n                }\n                memset(message[i], '\\0', sizeof(message[i]));\n                memset(stack, '\\0', sizeof(stack));\n                stack[0] = '\\n';\n            }\n            else if (message[nowy][nowx] != '\\n'){\n                strcpy(stack, &message[nowy][nowx]);\n                memset(&message[nowy][nowx], '\\0', sizeof(&message[nowy][nowx]));\n                stack[strlen(stack) - 1] = '\\0';\n                rowLength = strlen(message[nowy]);\n                nowx = rowLength;\n                message[nowy][nowx] = '\\n';\n            }\n            break;\n          \n          case 'y':\n            if (stack[0] == '\\n'){\n                for (i = len; i > nowy; i--){\n                    strcpy(message[i], message[i - 1]);\n                }\n                strcpy(message[nowy + 1], &message[nowy][nowx]);\n                memset(&message[nowy][nowx], '\\0', sizeof(&message[nowy][nowx]));\n                message[nowy][nowx] = '\\n';\n                nowy++;\n                nowx = 0;\n                len++;\n            }\n            else if (stack[0] != '\\0'){\n                strcpy(temp, message[nowy]);\n                strcpy(&message[nowy][nowx], stack);\n                strcat(message[nowy], &temp[nowx]);\n                nowx += strlen(stack);\n            }\n            break;\n        }\n    }\n    \n    for (i = 0; i < len; i++){\n        printf(\"%s\", message[i]);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "char*p,x[1001*100],b[1001],*q;\nA(){\n\twhile(p>x&&p[-1]!='\\n')\n\t\tp--;\n}\nE(){\n\twhile(*p&&*p!='\\n')\n\t\tp++;\n}\nF(){\n\tif(*p)\n\t\tp++;\n}\nB(){\n\tif(p>x)\n\t\tp--;\n}\nmain(c){\n\tfor(p=x;p<x+13||strcmp(p-13,\"\\nEND_OF_TEXT\\n\");p++)\n\t\t*p=getchar();\n\tp[-13]=0;\n\tp=x;\n\tfor(;~scanf(\"%s\",&c);){\n\t\tswitch(c){\n\t\tcase 'a':\n\t\t\tA();\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tE();\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tA(),B(),A();\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tE(),F(),A();\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tF();\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tB();\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif(*p)\n\t\t\t\tmemmove(p,p+1,strlen(p));\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tq=p;\n\t\t\tif(*p=='\\n')\n\t\t\t\tp++;\n\t\t\telse\n\t\t\t\tE();\n\t\t\tmemcpy(b,q,p-q);\n\t\t\tb[p-q]=0;\n\t\t\tp=memmove(q,p,strlen(p)+1);\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tmemmove(p+strlen(b),p,strlen(p)+1);\n\t\t\tmemcpy(p,b,strlen(b));\n\t\t\tp+=strlen(b);\n\t\t\tbreak;\n\t\t}\n\t}\n\tputs(x);\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1021 Emacs-like Editor\n// 2018.3.2 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\nchar text[101][1005]; int len[101];\nchar buf[1005]; int blen;\n\nint main()\n{\n\tint N, r, c, rr;\n\tchar cmd[5], *p, *q, *t;\n\n\tN = -1;\n\tdo {\n\t\tfgets(p=text[++N], 1005, stdin);\n\t\twhile (*p >= ' ') p++; *p = 0;\n\t\tlen[N] = p - text[N];\n\t} while (strcmp(text[N], \"END_OF_TEXT\"));\n\tr = 0, c = 0, blen = 0;\n\twhile (1) {\n\t\tfgets(cmd, 5, stdin); if (*cmd == '-') break;\n\t\tif      (*cmd == 'a') c = 0;\n\t\telse if (*cmd == 'e') c = len[r];\n\t\telse if (*cmd == 'p') { c = 0, r--; if (r < 0) r = 0; }\n\t\telse if (*cmd == 'n') { c = 0, r++; if (r >= N) r = N - 1; if (r < 0) r = 0; }\n\t\telse if (*cmd == 'f') { if (c < len[r]) c++; else if (r < N-1) r++, c = 0; }\n\t\telse if (*cmd == 'b') {\tif (c > 0) c--;\telse if (r > 0) r--, c = len[r]; }\n\t\telse if (*cmd == 'd') {\n\t\t\tif (c == len[r]) {\n\t\t\t\tif (r < N-1) {\n\t\t\t\t\tmemcpy(text[r]+len[r], text[r+1], len[r+1]+1);\n\t\t\t\t\tlen[r] += len[r+1];\n\t\t\t\t\tfor (rr = r+2; rr < N; rr++) {\n\t\t\t\t\t\tmemcpy(text[rr-1], text[rr], len[rr]+1);\n\t\t\t\t\t\tlen[rr-1] = len[rr];\n\t\t\t\t\t}\n\t\t\t\t\tN--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tp = text[r] + c;\n\t\t\t\twhile (*p) *p = *(p+1), p++;\n\t\t\t\tlen[r]--;\n\t\t\t}\n\t\t}\n\t\telse if (*cmd == 'k') {\n\t\t\tif (c == len[r]) {\n\t\t\t\tif (r < N-1) {\n\t\t\t\t\tblen = -1;\n\t\t\t\t\tmemcpy(text[r]+len[r], text[r+1], len[r+1]+1);\n\t\t\t\t\tlen[r] += len[r+1];\n\t\t\t\t\tfor (rr = r+2; rr < N; rr++) {\n\t\t\t\t\t\tmemcpy(text[rr-1], text[rr], len[rr]+1);\n\t\t\t\t\t\tlen[rr-1] = len[rr];\n\t\t\t\t\t}\n\t\t\t\t\tN--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tblen = len[r]-c, memcpy(buf, text[r]+c, blen+1);\n\t\t\t\tlen[r] -= blen; if (len[r] < 0) len[r] = 0; text[r][len[r]] = 0;\n\t\t\t\tc = len[r];\n\t\t\t}\n\t\t}\n\t\telse if (*cmd == 'y') {\n\t\t\tif (blen == -1) {\n\t\t\t\tfor (rr = N-1; rr > r; rr--) {\n\t\t\t\t\tmemcpy(text[rr+1], text[rr], len[rr]+1);\n\t\t\t\t\tlen[rr+1] = len[rr];\n\t\t\t\t}\n\t\t\t\tN++;\n\t\t\t\tlen[r+1] = len[r]-c, memcpy(text[r+1], text[r]+c, len[r+1]+1);\n\t\t\t\tlen[r] = c, text[r][len[r]] = 0;\n\t\t\t\tr++, c = 0;\n\t\t\t} else if (blen > 0) {\n\t\t\t\tt = text[r]+c, p = text[r]+len[r], q = p+blen;\n\t\t\t\twhile (p >= t) *q-- = *p--;\n\t\t\t\tmemcpy(t, buf, blen);\n\t\t\t\tc += blen, len[r] += blen;\n\t\t\t}\n\t\t}\n\t}\n\tfor (r = 0; r < N; r++) puts(text[r]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "char*p,x[1<<17],b[1001],*q;A(){for(;p>x&&p[-1]-10;)p--;}E(){for(;*p>10;)p++;}F(){if(*p)p++;}B(){if(p>x)p--;}main(c){for(p=x;p<x+13||strcmp(p-13,\"\\nEND_OF_TEXT\\n\");p++)*p=getchar();p[-13]=0;for(p=x;~scanf(\"%s\",&c);)c-'a'?c-'e'?c-'p'?c-'n'?c-'f'?c-'b'?c-'d'?c-'k'?c-'y'?puts(x):(memmove(p+strlen(b),p,strlen(p)+1),memcpy(p,b,strlen(b)),p+=strlen(b)):(q=p,*p-10?E():p++,b[p-q]=!memcpy(b,q,p-q),p=memmove(q,p,strlen(p)+1)):*p&&memmove(p,p+1,strlen(p)):B():F():A(F(E())):A(B(A())):E():A();}"
  },
  {
    "language": "C",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\nvector<string> text;\nstring buf;\n\nint row, col;\n\nvoid func_a(){\n\tcol = 0;\n}\n\nvoid func_e(){\n\tcol = text[row].size() - 1;\n}\n\nvoid func_p(){\n\tif (row > 0) row--;\n\tfunc_a();\n}\n\nvoid func_n(){\n\tif (row < text.size() - 1) row++;\n\tfunc_a();\n}\n\nvoid func_f(){\n\tif (col < text[row].size() - 1) col++;\n\telse func_n();\n}\n\nvoid func_b(){\n\tif (col > 0) col--;\n\telse if (row > 0){\n\t\tfunc_p();\n\t\tfunc_e();\n\t}\n}\n\nvoid func_d(){\n\tif (col < text[row].size() - 1) text[row].erase(col, col);\n\telse if (row < text.size() - 1){\n\t\ttext[row] += text[row + 1];\n\t\ttext.erase(text.begin() + row + 1);\n\t}\n}\n\nvoid func_k(){\n\tif (col < text[row].size() - 1){\n\t\tbuf = text[row].substr(col, text[row].size() - col - 1);\n\t\ttext[row].erase(col, text[row].size() - 1);\n\t\tcol = text[row].size() - 1;\n\t}\n\telse if (row < text.size() - 1){\n\t\tfunc_d();\n\t\tbuf = \"\\n\";\n\t}\n}\n\nvoid func_y(){\n\tif (!buf.empty()){\n\t\tif (buf == \"\\n\"){\n\t\t\ttext.insert(text.begin() + row + 1, text[row].substr(col, text[row].size() - 1));\n\t\t\ttext[row].erase(col, text[row].size() - 1);\t\t\t\n\t\t}\n\t\telse {\n\t\t\ttext[row].insert(col, buf);\n\t\t\tcol += buf.size();\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstring in;\n\tchar cmd;\n\n\twhile (getline(cin, in), in != \"END_OF_TEXT\"){\n\t\ttext.push_back(in + '$');\n\t}\n\t\n\tcol = row = 0;\n\tbuf.clear();\n\n\twhile (cin >> cmd, cmd != '-'){\n\t\tswitch (cmd){\n\t\t  case 'a': func_a(); break;\n\t\t  case 'e':\tfunc_e(); break;\n\t\t  case 'p':\tfunc_p(); break;\n\t\t  case 'n': func_n(); break;\n\t\t  case 'f': func_f(); break;\n\t\t  case 'b':\tfunc_b(); break;\n\t\t  case 'd':\tfunc_d(); break;\n\t\t  case 'k': func_k(); break;\n\t\t  case 'y': func_y(); break;\n\t\t}\n#if 0\n\t\tprintf(\"col:%d row:%d\\n\", col, row);\n\t\tputs(\"status:\");\n\t\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\t\tcout << *it << endl;\n\t\t}\n\t\tputs(\"buffer:\");\n\t\tcout << buf << endl;\n#endif\n\t}\n\n\t\n\tfor (vector<string>::iterator it = text.begin(); it != text.end(); it++){\n\t\tcout << it->substr(0, it->size() - 1) << endl;\n\t}\n\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "char*p,x[1<<17],b[1001],*q;\nA(){for(;p>x&&p[-1]-10;)p--;}\nE(){for(;*p>10;)p++;}\nF(){if(*p)p++;}\nB(){if(p>x)p--;}\nmain(c){\n\tfor(p=x;p<x+13||strcmp(p-13,\"\\nEND_OF_TEXT\\n\");p++)\n\t\t*p=getchar();\n\tp[-13]=0;\n\tfor(p=x;~scanf(\"%s\",&c);)\n\t\tc-'a'?\n\t\tc-'e'?\n\t\tc-'p'?\n\t\tc-'n'?\n\t\tc-'f'?\n\t\tc-'b'?\n\t\tc-'d'?\n\t\tc-'k'?\n\t\tc-'y'?\n\t\tputs(x)\n\t\t:(memmove(p+strlen(b),p,strlen(p)+1),memcpy(p,b,strlen(b)),p+=strlen(b))\n\t\t:(q=p,*p-10?E():p++,b[p-q]=!memcpy(b,q,p-q),p=memmove(q,p,strlen(p)+1))\n\t\t:*p&&memmove(p,p+1,strlen(p))\n\t\t:B()\n\t\t:F()\n\t\t:A(F(E()))\n\t\t:A(B(A()))\n\t\t:E()\n\t\t:A();\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    char message[256][1024];\n    int i, len, nowx, nowy;\n    int rowLength;\n    char buffer[2], stack[1024], temp[1024];\n    \n    i = 0;\n    memset(message, '\\0', sizeof(message));\n    memset(stack, '\\0', sizeof(stack));\n    while (1){\n        scanf(\"%[^\\n]\", temp);\n        getchar();\n        if (strcmp(temp, \"END_OF_TEXT\") == 0){\n            break;\n        }\n        strcpy(message[i], temp);\n        \n        message[i][strlen(message[i])] = '\\n';\n        i++;\n    }\n    len = i;\n    nowx = nowy = 0;\n    while (1){\n        scanf(\"%s\", buffer);\n        \n        if (buffer[0] == '-'){\n            break;\n        }\n        \n        switch (buffer[0]){\n          case 'a':\n            nowx = 0;\n            break;\n          \n          case 'e':\n            nowx = strlen(message[nowy]) - 1;\n            break;\n          \n          case 'p':\n            if (nowy > 0){\n                nowy--;\n            }\n            nowx = 0;\n            break;\n          \n          case 'n':\n            if (nowy < len - 1){\n                nowy++;\n            }\n            nowx = 0;\n            break;\n          \n          case 'f':\n            if (nowx < (int)strlen(message[nowy]) - 1){\n                nowx++;\n            }\n            else if (nowy < len - 1 && nowx == (int)strlen(message[nowy]) - 1){\n                nowy++;\n                nowx = 0;\n            }\n            break;\n          \n          case 'b':\n            if (nowx > 0){\n                nowx--;\n            }\n            else if (nowy > 0 && nowx == 0){\n                nowy--;\n                nowx = strlen(message[nowy]) - 1;\n            }\n            break;\n          \n          case 'd':\n            if (message[nowy][nowx] != '\\n'){\n                rowLength = strlen(message[nowy]) - 1;\n                for (i = nowx; i < rowLength; i++){\n                    message[nowy][i] = message[nowy][i + 1];\n                }\n                message[nowy][i] = '\\0';\n            }\n            else if (message[nowy][nowx] == '\\n' && nowy < len - 1){\n                rowLength = strlen(message[nowy + 1]);\n                for (i = 0; i < rowLength; i++){\n                    message[nowy][nowx + i] = message[nowy + 1][i];\n                }\n                len -= 1;\n                for (i = nowy + 1; i < len; i++){\n                    strcpy(message[i], message[i + 1]);\n                }\n                memset(message[i], '\\0', sizeof(message[i]));\n            }\n            break;\n          \n          case 'k':\n            if (message[nowy][nowx] == '\\n' && nowy < len - 1){\n                rowLength = strlen(message[nowy + 1]);\n                for (i = 0; i < rowLength; i++){\n                    message[nowy][nowx + i] = message[nowy + 1][i];\n                }\n                len -= 1;\n                for (i = nowy + 1; i < len; i++){\n                    strcpy(message[i], message[i + 1]);\n                }\n                memset(message[i], '\\0', sizeof(message[i]));\n                memset(stack, '\\0', sizeof(stack));\n                stack[0] = '\\n';\n            }\n            else if (message[nowy][nowx] != '\\n'){\n                memset(stack, '\\0', sizeof(stack));\n                strcpy(stack, &message[nowy][nowx]);\n                memset(&message[nowy][nowx], '\\0', sizeof(&message[nowy][nowx]));\n                stack[strlen(stack) - 1] = '\\0';\n                rowLength = strlen(message[nowy]);\n                nowx = rowLength;\n                message[nowy][nowx] = '\\n';\n            }\n            break;\n          \n          case 'y':\n            if (stack[0] == '\\n'){\n                for (i = len; i > nowy; i--){\n                    strcpy(message[i], message[i - 1]);\n                }\n                strcpy(message[nowy + 1], &message[nowy][nowx]);\n                memset(&message[nowy][nowx], '\\0', sizeof(&message[nowy][nowx]));\n                message[nowy][nowx] = '\\n';\n                nowy++;\n                nowx = 0;\n                len++;\n            }\n            else if (stack[0] != '\\0'){\n                strcpy(temp, message[nowy]);\n                strcpy(&message[nowy][nowx], stack);\n                strcat(message[nowy], &temp[nowx]);\n                nowx += strlen(stack);\n            }\n            break;\n        }\n    }\n    \n    for (i = 0; i < len; i++){\n        printf(\"%s\", message[i]);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint line_max;\nchar buffer[2000];\nchar bunsyou[200][2000];\nint cx,cy;\n\nvoid a(void) {\n\tcx=0;\n}\n\nvoid e(void) {\n\tcx=strlen(bunsyou[cy]);\n}\n\nvoid p(void) {\n\tif(cy>0)cy--;\n\tcx=0;\n}\n\nvoid n(void) {\n\tif(cy<line_max-1)cy++;\n\tcx=0;\n}\n\nvoid f(void) {\n\tif(cx<strlen(bunsyou[cy]))cx++;\n\telse if(cy<line_max-1) {\n\t\tcy++;\n\t\tcx=0;\n\t}\n}\n\nvoid b(void) {\n\tif(cx>0)cx--;\n\telse if(cy>0) {\n\t\tcy--;\n\t\tcx=strlen(bunsyou[cy]);\n\t}\n}\n\nvoid d(void) {\n\tint i,length;\n\tif(cx<strlen(bunsyou[cy])) {\n\t\tlength=strlen(&bunsyou[cy][cx])-1;\n\t\tmemmove(&bunsyou[cy][cx],&bunsyou[cy][cx+1],length);\n\t\tbunsyou[cy][cx+length]=0;\n\t} else if(cy<line_max-1) {\n\t\tstrcat(bunsyou[cy],bunsyou[cy+1]);\n\t\tfor(i=cy+2;i<line_max;i++) {\n\t\t\tstrcpy(bunsyou[i-1],bunsyou[i]);\n\t\t}\n\t\tline_max--;\n\t}\n}\n\nvoid k(void) {\n\tif(cx>=strlen(bunsyou[cy]) && cy<line_max-1) {\n\t\td();\n\t\tbuffer[0]='\\n';\n\t\tbuffer[1]=0;\n\t} else {\n\t\tstrcpy(buffer,&bunsyou[cy][cx]);\n\t\tbunsyou[cy][cx]=0;\n\t}\n}\n\nvoid y(void) {\n\tint i,length;\n\tif(buffer[0]==0)return;\n\tif(buffer[0]=='\\n') {\n\t\tfor(i=line_max;i>cy+1;i--) {\n\t\t\tstrcpy(bunsyou[i-1],bunsyou[i]);\n\t\t}\n\t\tline_max++;\n\t\tstrcpy(bunsyou[cy+1],&bunsyou[cy][cx]);\n\t\tbunsyou[cy][cx]=0;\n\t\tcy++;\n\t\tcx=0;\n\t} else {\n\t\tlength=strlen(buffer);\n\t\tmemmove(&bunsyou[cy][cx+length],&bunsyou[cy][cx],\n\t\t\tstrlen(&bunsyou[cy][cx])+1);\n\t\tmemmove(&bunsyou[cy][cx],buffer,length);\n\t\tcx+=length;\n\t}\n}\n\nint main(void) {\n\tchar* cp;\n\tchar cmd[10];\n\tint i;\n\tline_max=0;\n\twhile(1) {\n\t\tfgets(bunsyou[line_max],sizeof(bunsyou[line_max]),stdin);\n\t\tcp=strchr(bunsyou[line_max],'\\n');\n\t\tif(cp)*cp=0;\n\t\tif(strcmp(bunsyou[line_max],\"END_OF_TEXT\")==0) {\n\t\t\tbunsyou[line_max][0]=0;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tline_max++;\n\t\t}\n\t}\n\twhile(1) {\n\t\tscanf(\"%s\",cmd);\n\t\tif(cmd[0]=='-')break;\n\t\tswitch(cmd[0]) {\n\t\t\tcase 'a':a();break;\n\t\t\tcase 'e':e();break;\n\t\t\tcase 'p':p();break;\n\t\t\tcase 'n':n();break;\n\t\t\tcase 'f':f();break;\n\t\t\tcase 'b':b();break;\n\t\t\tcase 'd':d();break;\n\t\t\tcase 'k':k();break;\n\t\t\tcase 'y':y();break;\n\t\t}\n\t}\n\tfor(i=0;i<line_max;i++)puts(bunsyou[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    char message[128][1024];\n    int i, len, nowx, nowy;\n    int rowLength;\n    char buffer[2], stack[1024], temp[1024];\n    \n    i = 0;\n    memset(message, '\\0', sizeof(message));\n    memset(stack, '\\0', sizeof(stack));\n    while (1){\n        scanf(\"%[^\\n]\", temp);\n        getchar();\n        if (strcmp(temp, \"END_OF_TEXT\") == 0){\n            break;\n        }\n        strcpy(message[i], temp);\n        \n        message[i][strlen(message[i])] = '\\n';\n        i++;\n    }\n    len = i;\n    nowx = nowy = 0;\n    while (1){\n        scanf(\"%s\", buffer);\n        \n        if (buffer[0] == '-'){\n            break;\n        }\n        \n        switch (buffer[0]){\n          case 'a':\n            nowx = 0;\n            break;\n          \n          case 'e':\n            nowx = strlen(message[nowy]) - 1;\n            break;\n          \n          case 'p':\n            if (nowy > 0){\n                nowy--;\n            }\n            nowx = 0;\n            break;\n          \n          case 'n':\n            if (nowy < len - 1){\n                nowy++;\n            }\n            nowx = 0;\n            break;\n          \n          case 'f':\n            if (nowx < (int)strlen(message[nowy]) - 1){\n                nowx++;\n            }\n            else if (nowy < len - 1 && (int)nowx == strlen(message[nowy]) - 1){\n                nowy++;\n                nowx = 0;\n            }\n            break;\n          \n          case 'b':\n            if (nowx > 0){\n                nowx--;\n            }\n            else if (nowy > 0 && nowx == 0){\n                nowy--;\n                nowx = strlen(message[nowy]) - 1;\n            }\n            break;\n          \n          case 'd':\n            if (message[nowy][nowx] != '\\n'){\n                rowLength = strlen(message[nowy]) - 1;\n                for (i = nowx; i < rowLength; i++){\n                    message[nowy][i] = message[nowy][i + 1];\n                }\n                message[nowy][i] = '\\0';\n            }\n            else if (message[nowy][nowx] == '\\n' && nowy < len - 1){\n                rowLength = strlen(message[nowy + 1]);\n                for (i = 0; i < rowLength; i++){\n                    message[nowy][nowx + i] = message[nowy + 1][i];\n                }\n                len -= 1;\n                for (i = nowy + 1; i < len; i++){\n                    strcpy(message[i], message[i + 1]);\n                }\n                memset(message[i], '\\0', sizeof(message[i]));\n            }\n            break;\n          \n          case 'k':\n            if (message[nowy][nowx] == '\\n' && nowy < len - 1){\n                rowLength = strlen(message[nowy + 1]);\n                for (i = 0; i < rowLength; i++){\n                    message[nowy][nowx + i] = message[nowy + 1][i];\n                }\n                len -= 1;\n                for (i = nowy + 1; i < len; i++){\n                    strcpy(message[i], message[i + 1]);\n                }\n                memset(message[i], '\\0', sizeof(message[i]));\n                stack[0] = '\\n';\n            }\n            else if (message[nowy][nowx] != '\\n'){\n                strcpy(stack, &message[nowy][nowx]);\n                memset(&message[nowy][nowx], '\\0', sizeof(&message[nowy][nowx]));\n                stack[strlen(stack) - 1] = '\\0';\n                rowLength = strlen(message[nowy]);\n                nowx = rowLength;\n                message[nowy][nowx] = '\\n';\n            }\n            break;\n          \n          case 'y':\n            if (stack[0] == '\\n'){\n                for (i = len; i > nowy; i--){\n                    strcpy(message[i], message[i - 1]);\n                }\n                strcpy(message[nowy + 1], &message[nowy][nowx]);\n                message[nowy][nowx] = '\\n';\n                message[nowy][nowx + 1] = '\\0';\n                nowy++;\n                nowx = 0;\n                len++;\n            }\n            else if (stack[0] != '\\0'){\n                strcpy(temp, message[nowy]);\n                strcpy(&message[nowy][nowx], stack);\n                strcat(message[nowy], &temp[nowx]);\n                nowx += strlen(stack);\n            }\n            break;\n        }\n    }\n    \n    for (i = 0; i < len; i++){\n        printf(\"%s\", message[i]);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\npublic class Main {\n static int loc=0;\n static int line=0;\n static String str[];\n static String buffer=\"\";\n static String str2=\"\";\n static String str3=\"\";\n public static void main(String[] args){\n try{\n  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n  str=new String[1000];\n  int a;\n  int j=0;\n  while (true) {\n   String str1 = br.readLine();\n   if(str1.equals(\"END_OF_TEXT\")){a=j; break;}\n   str[j]=str1;\n   j++;\n  }\n  while(true){\n   char ch=br.readLine().charAt(0);\n   if(ch=='-') break;\n   else if(ch=='a')a();\n   else if(ch=='e')e();\n   else if(ch=='p')p();\n   else if(ch=='n')n(a);\n   else if(ch=='f')f(a);\n   else if(ch=='b')b(a);\n   else if(ch=='d')d(a);\n   else if(ch=='k')k(a);\n   else if(ch=='y')y(a);\n  }\n  for(int i=0;i<a;i++)System.out.println(str[i]);\n }\n catch(Exception e){System.out.println(\"err\");}\n }\n\n public static void a(){\n  loc=0;\n }\n public static void e(){\n  loc=str[line].length();\n }\n\n public static void p(){\n  loc=0;\n  if(line!=0)line--;\n }\n public static void n(int a){\n  loc=0;\n  if(line!=a-1)line++;\n }\n public static void f(int a){\n  if(loc != str[line].length())loc++;\n  else if(loc==str[line].length() && line!=a-1) {\n   loc=0;\n   line++;\n  }\n }\n public static void b(int a){\n  if(loc!=0)loc--;\n  else if(loc==0 && line!=0)loc=str[--line].length();\n }\n public static void d(int a){\n  if(loc!=str[line].length()){\n   str2=str[line].substring(0, loc)+str[line].substring(loc+1);\n   str[line]=\"\";\n   str[line]+=str2;\n  }\n  else if(loc==str[line].length() && line!=a-1){\n   str[line]+=str[line+1];\n   str[line+1]=\"\";\n   for(int i=line+2;i<a;i++){\n    str[i-1]+=str[i];\n    str[i]=\"\";\n   }\n   a--;\n  }\n }\n\n public static void k(int a){\n  if(loc!=str[line].length()){\n   buffer=str[line].substring(loc);\n   str2=str[line].substring(0, loc);\n   str[line]=\"\";\n   str[line]+=str2;\n  } \n  else if(loc==str[line].length() && line!=a-1){\n   buffer=\"\\n\";\n   for(int i=line+1;i<a-1;i++){\n    str[i-1]+=str[i];\n    str[i]=\"\";\n   }\n   a--;\n  }\n }\n\n public static void y(int a){\n  if(buffer.equals(\"\\n\")) {\n  str2=str[line].substring(0,loc);\n  str3=str[line].substring(loc);\n   for(int i=a-1;i>line;i--){\n    str[i+1]=\"\";\n    str[i+1]+=str[i];\n   }\n   str[line]=\"\";\n   str[line]+=str2;\n   str[line+1]=\"\";\n   str[line+1]+=str3;\n   a++;\n   loc=0;\n   line++;\n  }\n  else if(buffer!=\"\") {\n   str2=str[line].substring(0,loc);\n   str3=str[line].substring(loc);\n   str[line]=\"\";\n   str[line]=str2+buffer+str3;\n   loc+=buffer.length();\n  }\n }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class EditText {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static String[] modifyingText = new String[MAXMODIFIEDTEXTLINE];\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        String inputText[];\n        String inputCommand[];\n\n        inputText = giveTextLine();\n        inputCommand = giveCommand();\n        modifyText(inputText, inputCommand);\n\n        for(int i = 0; i < modifyingText.length; i++){\n            System.out.println(modifyingText[i]);\n        }\n    }\n\n    private static String[] giveTextLine() {\n        String input;\n        String[] inputText = new String[MAXINPUTLINE];\n        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = scan.next();\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText[i] = input;\n        }\n        return inputText;\n    }\n\n    private static String[] giveCommand() {\n        String input;\n        String[] inputCommand = new String[MAXINPUTCOMMAND];\n        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = scan.next();\n            if (input.equals(\"-\")) break;\n            inputCommand[i] = input;\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final String inputText[], final String inputCommand[]) {\n\n        for (int i = 0; i < inputText.length; i++) {\n            modifyingText[i] = inputText[i];\n        }\n\n        for (int i = 0; i < inputCommand.length; i++) {\n            if (inputCommand[i].equals(\"a\")) editA();\n            else if (inputCommand[i].equals(\"e\")) editE();\n            else if (inputCommand[i].equals(\"p\")) editP();\n            else if (inputCommand[i].equals(\"n\")) editN();\n            else if (inputCommand[i].equals(\"f\")) editF();\n            else if (inputCommand[i].equals(\"b\")) editB();\n            else if (inputCommand[i].equals(\"d\")) editD();\n            else if (inputCommand[i].equals(\"k\")) editK();\n            else if (inputCommand[i].equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        return str.substring(0, removeIndex) + str.substring(removeIndex + 1);\n    }\n\n    private static String insert(String str, int insertIndex) {\n        return str.substring(0, insertIndex) + buffer + str.substring(insertIndex);\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = modifyingText[cursorLocLine].length();\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (modifyingText[cursorLocLine + 1] != null) cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (modifyingText[cursorLocLine].length() == cursorLocRow + 1) {\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else {\n            cursorLocRow = modifyingText[cursorLocLine - 1].length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n        if (cursorLocRow != modifyingText[cursorLocLine].length() - 1) {\n            modifyingText[cursorLocLine] = remove(modifyingText[cursorLocLine], cursorLocRow);\n        } else if (modifyingText[cursorLocLine + 1] != null) {\n            for (int i = cursorLocLine; i < modifyingText.length; i++) {\n                if (modifyingText[i + 1] == null) break;\n                modifyingText[i] += modifyingText[i + 1];\n            }\n        }\n\n    }\n\n    private static void editK() {\n        if (cursorLocRow == modifyingText[cursorLocLine].length() - 1 && modifyingText[cursorLocLine + 1] != null) {\n            for (int i = cursorLocLine; i < modifyingText.length; i++) {\n                if (modifyingText[i + 1] == null) break;\n                modifyingText[i] += modifyingText[i + 1];\n            }\n            buffer = \"\\n\";\n        } else {\n            buffer = modifyingText[cursorLocLine].substring(cursorLocRow);\n            modifyingText[cursorLocLine] = modifyingText[cursorLocLine].substring(0, cursorLocRow - 1);\n        }\n    }\n\n    /**\n     * 　yank\n     */\n    private static void editY() {\n        if(buffer.equals(\"\\n\")) {\n            String movingText = modifyingText[cursorLocLine].substring(cursorLocRow);\n            modifyingText[cursorLocLine] = modifyingText[cursorLocLine].substring(0, cursorLocRow-1);\n            for( int i = modifyingText.length; i != cursorLocLine; i-- ){\n                if(modifyingText[cursorLocLine] != null)\n                    modifyingText[cursorLocLine+1] = modifyingText[cursorLocLine];\n            }\n            cursorLocLine++;\n            cursorLocRow = 0;\n        }else if (buffer != null){\n            modifyingText[cursorLocLine] = insert(modifyingText[cursorLocLine], cursorLocRow);\n        }\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\n//Emacs-like Editor\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tLinkedList<String> l = new LinkedList<String>();\n\t\twhile(true){\n\t\t\tString s = sc.nextLine();\n\t\t\tif(s.equals(\"END_OF_TEXT\"))break;\n\t\t\tl.add(s+\"$\");\n\t\t}\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tString buf = \"\";\n\t\twhile(true){\n\t\t\tchar ch = sc.next().charAt(0);\n\t\t\t\n\t\t\tif(ch=='-')break;\n\t\t\tif(ch=='a')j=0;\n\t\t\telse if(ch=='e')j=l.get(i).length()-1;\n\t\t\telse if(ch=='p'){\n\t\t\t\tif(i>0)i--;\n\t\t\t\tj=0;\n\t\t\t}\n\t\t\telse if(ch=='n'){\n\t\t\t\tif(i<l.size()-1)i++;\n\t\t\t\tj=0;\n\t\t\t}\n\t\t\telse if(ch=='f'){\n\t\t\t\tif(j!=l.get(i).length()-1)j++;\n\t\t\t\telse if(j==l.get(i).length()-1&&i<l.size()-1){\n\t\t\t\t\ti++;j=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ch=='b'){\n\t\t\t\tif(j>0)j--;\n\t\t\t\tif(j==0&&i>0){\n\t\t\t\t\ti--;j=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ch=='d'){\n\t\t\t\tif(l.get(i).charAt(j)!='$'){\n\t\t\t\t\tStringBuilder sb = new StringBuilder(l.remove(i));\n\t\t\t\t\tl.add(i, sb.substring(0, j)+sb.substring(j+1,sb.length()));\n\t\t\t\t}\n\t\t\t\telse if(i<l.size()-1){\n\t\t\t\t\tStringBuilder sb = new StringBuilder(l.remove(i));\n\t\t\t\t\tsb.append(l.remove(i));\n\t\t\t\t\tl.add(i, sb.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ch=='k'){\n\t\t\t\tif(j==l.get(i).length()-1&&i<l.size()-1){\n\t\t\t\t\tStringBuilder sb = new StringBuilder(l.remove(i));\n\t\t\t\t\tsb.append(l.remove(i));\n\t\t\t\t\tl.add(i, sb.toString());\n\t\t\t\t\tbuf = \"$\";\n\t\t\t\t}\n\t\t\t\telse if(j<l.get(i).length()-1){\n\t\t\t\t\tStringBuilder sb = new StringBuilder(l.remove(i));\n\t\t\t\t\tl.add(i, sb.substring(0,j)+\"$\");\n\t\t\t\t\tbuf = sb.substring(j,sb.length()-1);\n\t\t\t\t\tj = l.get(i).length()-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ch=='y'){\n\t\t\t\tif(buf.equals(\"\"))continue;\n\t\t\t\tif(buf.equals(\"$\")){\n\t\t\t\t\tStringBuilder sb = new StringBuilder(l.remove(i));\n\t\t\t\t\tl.add(i, sb.substring(0,j)+\"$\");\n\t\t\t\t\tl.add(i+1,sb.substring(j,sb.length()));\n\t\t\t\t\ti++;j=0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tStringBuilder sb = new StringBuilder(l.remove(i));\n\t\t\t\t\tchar r = sb.charAt(j);\n\t\t\t\t\tl.add(i, sb.substring(0, j)+buf+sb.substring(r=='$'?j+1:j,sb.length())+(r=='$'?\"$\":\"\"));\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(\"DUMP I:\" + i + \" J:\" +j + \" BUF:\" + buf + \" IM:\" + ch);\n//\t\t\tfor(String s:l)System.out.println(s);\n\t\t}\n\t\tfor(String s:l)System.out.println(s.substring(0,s.length()-1));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.xml.crypto.Data;\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tStringBuilder[] sb = new StringBuilder[1000];\n\t\tfor(int i = 0; i < sb.length; i++) {\n\t\t\tsb[i] = new StringBuilder();\n\t\t}\n\t\tint len = 0;\n\t\twhile(true) {\n\t\t\tString in = sc.nextLine();\n\t\t\tif(in.equals(\"END_OF_TEXT\")) break;\n\t\t\tsb[len++].append(in);\n\t\t}\n\t\tboolean LF = false;\n\t\tStringBuilder buffer = new StringBuilder();\n\t\tint ci = 0;\n\t\tint cj = 0;\n\t\twhile(true) {\n\t\t\tString in = sc.nextLine();\n\t\t\tif(in.equals(\"-\")) break;\n\t\t\tif(in.equals(\"a\")) {\n\t\t\t\tcj = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"e\")) {\n\t\t\t\tcj = sb[ci].length();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"p\")) {\n\t\t\t\tif(ci != 0) {\n\t\t\t\t\tci--;\n\t\t\t\t}\n\t\t\t\tcj = 0;\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"n\")) {\n\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\tci++;\n\t\t\t\t}\n\t\t\t\tcj = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"f\")) {\n\t\t\t\tif(cj != sb[ci].length()) {\n\t\t\t\t\tcj++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\tcj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"b\")) {\n\t\t\t\tif(cj != 0) {\n\t\t\t\t\tcj--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci != 0) {\n\t\t\t\t\t\tci--;\n\t\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"d\")) {\n\t\t\t\tif(cj != sb[ci].length()) {\n\t\t\t\t\tsb[ci].deleteCharAt(cj);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tsb[ci].append(sb[ci+1]);\n\t\t\t\t\t\twhile(ci+1 != len) {\n\t\t\t\t\t\t\tsb[ci] = sb[ci+1];\n\t\t\t\t\t\t\tci++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"k\")) {\n\t\t\t\tif(cj == sb[ci].length()) {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tsb[ci].append(sb[ci+1]);\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\twhile(ci+1 != len) {\n\t\t\t\t\t\t\tsb[ci] = sb[ci+1];\n\t\t\t\t\t\t\tci++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t\tbuffer = new StringBuilder();\n\t\t\t\t\tLF = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = new StringBuilder(sb[ci].substring(cj, sb[ci].length()));\n\t\t\t\t\tsb[ci].delete(cj, sb[ci].length());\n\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\tLF = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"y\")) {\n\t\t\t\tif(LF) {\n\t\t\t\t\tint now = len;\n\t\t\t\t\twhile(now != ci) {\n\t\t\t\t\t\tsb[now] = sb[now-1];\n\t\t\t\t\t\tnow--;\n\t\t\t\t\t}\n\t\t\t\t\tlen++;\n\t\t\t\t\tsb[ci+1] = new StringBuilder(sb[ci].substring(cj,sb[ci].length()));\n\t\t\t\t\tsb[ci].delete(cj, sb[ci].length());\n\t\t\t\t\tci++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(cj == sb[ci].length()) {\n\t\t\t\t\t\tsb[ci].insert(cj, buffer);\n\t\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsb[ci].insert(cj, buffer);\n\t\t\t\t\t\tcj += buffer.length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < len; i++) {\n\t\t\tSystem.out.println(sb[i].toString());\n\t\t}\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    BufferedReader br;\n    Main() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n    ArrayList<StringBuilder> buf;\n    ArrayList<String> cmds;\n    String clipboard;\n    boolean init() {\n        String s;\n        clipboard = new String();\n        buf = new ArrayList<StringBuilder>();\n        cmds = new ArrayList<String>();\n        try {\n            while (!(s = br.readLine()).equals(\"END_OF_TEXT\")) {\n                buf.add(new StringBuilder(s));\n            }\n            while (!(s = br.readLine()).equals(\"-\")) {\n                cmds.add(s);\n            }\n        } catch (IOException e) {}\n        return true;\n    }\n    void run() {\n        init();\n        //for (StringBuilder b : buf) {\n        //    System.out.println(b);\n        //}\n        int r = 0;\n        int c = 0;\n        for (String cmd : cmds) {\n            if (cmd.equals(\"a\")) {\n                c = 0;\n            } else if (cmd.equals(\"e\")) {\n                c = buf.get(r).length();\n            } else if (cmd.equals(\"p\")) {\n                if (r > 0) {\n                    r--;\n                    c = 0;\n                } else {\n                    c = 0;\n                }\n            } else if (cmd.equals(\"n\")) {\n                if (r < buf.size()-1) {\n                    r++;\n                    c = 0;\n                } else {\n                    c = 0;\n                }\n            } else if (cmd.equals(\"f\")) {\n                if (c != buf.get(r).length()) {\n                    c++;\n                } else if (r < buf.size()-1) {\n                    r++;\n                    c = 0;\n                }\n            } else if (cmd.equals(\"b\")) {\n                if (c != 0) {\n                    c--;\n                } else if (r > 0) {\n                    r--;\n                    c = buf.get(r).length();\n                }\n            } else if (cmd.equals(\"d\")) {\n                if (c != buf.get(r).length()) {\n                    buf.get(r).deleteCharAt(c);\n                } else if (r < buf.size()-1){\n                    buf.get(r).append(buf.get(r+1));\n                    buf.remove(r+1);\n                }\n            } else if (cmd.equals(\"k\")) {\n                if (c == buf.get(r).length()) {\n                    buf.get(r).append(buf.get(r+1));\n                    buf.remove(r+1);\n                    clipboard = \"\\n\";\n                    //System.out.println(\"copied newline\"); \n                } else {\n                    clipboard = buf.get(r).substring(c);\n                    buf.get(r).delete(c, buf.get(r).length());\n                    c = buf.get(r).length();\n                }\n            } else if (cmd.equals(\"y\")) {\n                //System.out.println(\"r: \" + r + \" c: \" + c);\n                //System.out.println(\"clipboard: \" + clipboard);\n                if (!clipboard.isEmpty()) {\n                    if (clipboard.equals(\"\\n\")) {\n                        StringBuilder tmp = new StringBuilder(buf.get(r).substring(c));\n                        buf.get(r).delete(c, buf.get(r).length());\n                        r++;\n                        buf.add(r, tmp);\n                        c = 0;\n                    } else {\n                        buf.get(r).insert(c, clipboard);\n                        c += clipboard.length();\n                    }\n                }\n            }\n\n            //System.out.println(\"------ cmd ------\");\n            //System.out.println(\"cmd: \" + cmd);\n            //System.out.println(\"------ current buffer ------\");\n            //System.out.println(\"r: \" + r + \" c: \" + c);\n            //for (StringBuilder b : buf) {\n            //    System.out.println(b);\n            //}\n            //System.out.println(\"\");\n        }\n        for (StringBuilder b : buf) {\n            System.out.println(b);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Emacs {\n    \n    String buffer;\n    int cursorX;\n    int cursorY;\n    ArrayList<String> body;\n\n    Emacs(ArrayList<String> body) {\n        this.buffer = \"\";\n        this.cursorX = 1;\n        this.cursorY = 1;\n        this.body = body;\n    }\n\n    void acceptCommand(char c) {\n        switch (c) {\n            case 'a':\n                this.moveCursorMostLeft();\n                break;\n            case 'e':\n                this.moveCursorMostRight();\n                break;\n            case 'p':\n                this.moveCursorUp();\n                this.moveCursorMostLeft();\n                break;\n            case 'n':\n                this.moveCursorDown();\n                this.moveCursorMostLeft();\n                break;\n            case 'f':\n                this.moveCursorForward();\n                break;\n            case 'b':\n                this.moveCursorBackward();\n                break;\n            case 'd':\n                this.deleteChar();\n                break;\n            case 'k':\n                this.killChar();\n                break;\n            case 'y':\n                this.yankBuffer();\n                break;\n        }\n    }\n\n    void yankBuffer() {\n        String cl = this.getCurrentLine();\n        if (this.buffer.equals(\"\")) {\n            return;\n        } else if (this.buffer.equals(\"!\")) {\n            this.body.add(this.body.get(this.body.size() - 1));\n            for(int i = this.body.size() - 1; i >= this.cursorY + 1; i--) {\n                this.body.set(i, this.body.get(i - 1));\n            }\n            this.body.set(this.cursorY, cl.substring(this.cursorX - 1, cl.length()));\n            this.body.set(this.cursorY - 1, cl.substring(0, this.cursorX - 1));\n        } else {\n            this.body.set(this.cursorY - 1, cl.substring(0, this.cursorX - 1) + this.buffer + cl.substring(this.cursorX - 1, cl.length()));\n        }\n    }\n\n    void deleteChar() {\n\n        String cl = this.getCurrentLine();\n\n        if (this.cursorX <= cl.length()) {\n            String tmp1 = cl.substring(0, this.cursorX - 1);\n            String tmp2 = cl.substring(this.cursorX,  cl.length());\n            this.body.set(this.cursorY - 1, tmp1 + tmp2);\n        } else if (this.cursorY < body.size()) {\n            this.body.set(this.cursorY - 1, cl + this.body.get(this.cursorY));\n            for(int i = this.cursorY; i < this.body.size() - 1; i++) {\n                this.body.set(i, this.body.get(i+1));\n            }\n            this.body.remove(this.body.size() - 1);\n        }\n    }\n\n    void killChar() {\n        String cl = this.getCurrentLine();\n\n        if (this.cursorX <= cl.length()) {\n            this.buffer = cl.substring(this.cursorX - 1, cl.length());\n            this.body.set(this.cursorY - 1, cl.substring(0, this.cursorX - 1));\n        } else {\n            this.buffer = \"!\";\n            this.deleteChar();\n        }\n    }\n\n    void moveCursorForward() {\n        if (this.cursorX <= this.getCurrentLine().length()) {\n            this.cursorX += 1;\n        } else if (this.cursorY < body.size()) {\n            this.cursorY += 1;\n            this.moveCursorMostLeft();\n        }\n    }\n\n    void moveCursorBackward() {\n        if (this.cursorX > 1) {\n            this.cursorX -= 1;\n        } else if (this.cursorY > 1) {\n            this.cursorY -= 1;\n            this.moveCursorMostRight();\n        }\n    }\n\n    void moveCursorMostLeft() {\n        this.cursorX = 1;\n    }\n\n    void moveCursorMostRight() {\n        this.cursorX = body.get(cursorY - 1).length() + 1;\n    }\n\n    void moveCursorUp() {\n        if(this.cursorY > 1)    this.cursorY -= 1;\n    }\n\n    void moveCursorDown() {\n        if(this.cursorY < body.size())  this.cursorY += 1;\n    }\n\n    void printBody() {\n        // System.out.printf(\"Cursor: (%d, %d)\\n\", this.cursorX, this.cursorY);\n        // System.out.printf(\"Buffer: %s\\n\",   this.buffer);\n        for (String line : this.body) {\n            System.out.println(line);\n        }\n    }\n\n    String getCurrentLine() {\n        return this.body.get(this.cursorY - 1);\n    }\n\n}\n\nclass Main {\n\n    public static void main (String [] args) {\n\n        Scanner sc = new Scanner(System.in);\n        ArrayList<String> lines = new ArrayList<String>();\n\n        while (true) {\n            String line = sc.nextLine();\n            if (line.equals(\"END_OF_TEXT\")) break;\n            lines.add(line);\n        }\n\n        Emacs emacs = new Emacs(lines);\n\n        while (true) {\n            char c = sc.nextLine().charAt(0);\n            if(c == '-')    break;\n            emacs.acceptCommand(c); \n        }\n\n        emacs.printBody();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tArrayList<String> lines = new ArrayList<String>();\n\t\twhile (true) {\n\t\t\tString line = sc.nextLine();\n\t\t\tif (line.equals(\"END_OF_TEXT\")) break;\n\t\t\tlines.add(line);\n\t\t}\n\t\tString buffer = \"\";\n\t\tint r = 0;\n\t\tint c = 0;\n\t\twhile (true) {\n\t\t\tchar q = sc.next().charAt(0);\n\t\t\tif (q == '-') break;\n\t\t\tswitch (q) {\n\t\t\tcase 'a':\n\t\t\t\tc = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tc = lines.get(r).length();\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tc = 0;\n\t\t\t\tif (r > 0) --r;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tc = 0;\n\t\t\t\tif (r < lines.size() - 1) ++r;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (c < lines.get(r).length()) {\n\t\t\t\t\t++c;\n\t\t\t\t} else if (c == lines.get(r).length() && r < lines.size() - 1) {\n\t\t\t\t\tc = 0;\n\t\t\t\t\t++r;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tif (c > 0) {\n\t\t\t\t\t--c;\n\t\t\t\t} else if (c == 0 && r > 0) {\n\t\t\t\t\tc = 0;\n\t\t\t\t\t--r;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif (c < lines.get(r).length()) {\n\t\t\t\t\tlines.set(r, lines.get(r).substring(0, c) + lines.get(r).substring(c + 1));\n\t\t\t\t} else if (c == lines.get(r).length() && r < lines.size() - 1) {\n\t\t\t\t\tlines.set(r, lines.get(r) + lines.get(r + 1));\n\t\t\t\t\tlines.remove(r + 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tif (c < lines.get(r).length()) {\n\t\t\t\t\tbuffer = lines.get(r).substring(c);\n\t\t\t\t\tlines.set(r, lines.get(r).substring(0, c));\n\t\t\t\t} else if (c == lines.get(r).length() && r < lines.size() - 1) {\n\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t\tlines.set(r, lines.get(r) + lines.get(r + 1));\n\t\t\t\t\tlines.remove(r + 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\tif (buffer.equals(\"\\n\")) {\n\t\t\t\t\tlines.add(lines.get(r).substring(c));\n\t\t\t\t\tlines.set(r, lines.get(r).substring(0, c));\n\t\t\t\t\tc = 0;\n\t\t\t\t\t++r;\n\t\t\t\t} else if (buffer.length() > 0) {\n\t\t\t\t\tlines.set(r, lines.get(r).substring(0, c) + buffer + lines.get(r).substring(c));\n\t\t\t\t\tc += buffer.length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (String l : lines) {\n\t\t\tSystem.out.println(l);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.xml.crypto.Data;\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tStringBuilder[] sb = new StringBuilder[1000];\n\t\tfor(int i = 0; i < sb.length; i++) {\n\t\t\tsb[i] = new StringBuilder();\n\t\t}\n\t\tint len = 0;\n\t\twhile(true) {\n\t\t\tString in = sc.nextLine();\n\t\t\tif(in.equals(\"END_OF_TEXT\")) break;\n\t\t\tsb[len++].append(in);\n\t\t}\n\t\tboolean LF = false;\n\t\tStringBuilder buffer = new StringBuilder();\n\t\tint ci = 0;\n\t\tint cj = 0;\n\t\twhile(true) {\n\t\t\tString in = sc.nextLine();\n\t\t\tif(in.equals(\"-\")) break;\n\t\t\tif(in.equals(\"a\")) {\n\t\t\t\tcj = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"e\")) {\n\t\t\t\tcj = sb[ci].length();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"p\")) {\n\t\t\t\tif(ci != 0) {\n\t\t\t\t\tci--;\n\t\t\t\t}\n\t\t\t\tcj = 0;\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"n\")) {\n\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\tci++;\n\t\t\t\t}\n\t\t\t\tcj = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"f\")) {\n\t\t\t\tif(cj != sb[ci].length()) {\n\t\t\t\t\tcj++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\tcj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"b\")) {\n\t\t\t\tif(cj != 0) {\n\t\t\t\t\tcj--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci != 0) {\n\t\t\t\t\t\tci--;\n\t\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"d\")) {\n\t\t\t\tif(cj != sb[ci].length()) {\n\t\t\t\t\tsb[ci].deleteCharAt(cj);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tsb[ci].append(sb[ci+1]);\n\t\t\t\t\t\tint now = ci;\n\t\t\t\t\t\twhile(now+1 != len) {\n\t\t\t\t\t\t\tsb[now] = sb[now+1];\n\t\t\t\t\t\t\tnow++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"k\")) {\n\t\t\t\tif(cj == sb[ci].length()) {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tsb[ci].append(sb[ci+1]);\n\t\t\t\t\t\tint now = ci;\n\t\t\t\t\t\twhile(now+1 != len) {\n\t\t\t\t\t\t\tsb[now] = sb[now+1];\n\t\t\t\t\t\t\tnow++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t\tbuffer = new StringBuilder();\n\t\t\t\t\tLF = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = new StringBuilder(sb[ci].substring(cj, sb[ci].length()));\n\t\t\t\t\tsb[ci].delete(cj, sb[ci].length());\n\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\tLF = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"y\")) {\n\t\t\t\tif(LF) {\n\t\t\t\t\tint now = len;\n\t\t\t\t\twhile(now != ci) {\n\t\t\t\t\t\tsb[now] = sb[now-1];\n\t\t\t\t\t\tnow--;\n\t\t\t\t\t}\n\t\t\t\t\tlen++;\n\t\t\t\t\tsb[ci+1] = new StringBuilder(sb[ci].substring(cj,sb[ci].length()));\n\t\t\t\t\tsb[ci].delete(cj, sb[ci].length());\n\t\t\t\t\tci++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(cj == sb[ci].length()) {\n\t\t\t\t\t\tsb[ci].insert(cj, buffer);\n\t\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsb[ci].insert(cj, buffer);\n\t\t\t\t\t\tcj += buffer.length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < len; i++) {\n\t\t\tSystem.out.println(sb[i].toString());\n\t\t}\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    BufferedReader br;\n    Main() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n    ArrayList<StringBuilder> buf;\n    ArrayList<String> cmds;\n    String clipboard;\n    boolean init() {\n        String s;\n        clipboard = new String();\n        buf = new ArrayList<StringBuilder>();\n        cmds = new ArrayList<String>();\n        try {\n            while (!(s = br.readLine()).equals(\"END_OF_TEXT\")) {\n                buf.add(new StringBuilder(s));\n            }\n            while (!(s = br.readLine()).equals(\"-\")) {\n                cmds.add(s);\n            }\n        } catch (IOException e) {}\n        return true;\n    }\n    void run() {\n        init();\n        //for (StringBuilder b : buf) {\n        //    System.out.println(b);\n        //}\n        int r = 0;\n        int c = 0;\n        for (String cmd : cmds) {\n            //System.out.println(\"cmd: \" + cmd);\n            if (cmd.equals(\"a\")) {\n                c = 0;\n            } else if (cmd.equals(\"e\")) {\n                c = buf.get(r).length();\n            } else if (cmd.equals(\"p\")) {\n                if (r > 0) {\n                    r--;\n                    c = 0;\n                } else {\n                    c = 0;\n                }\n            } else if (cmd.equals(\"n\")) {\n                if (r < buf.size()-1) {\n                    r++;\n                    c = 0;\n                } else {\n                    c = 0;\n                }\n            } else if (cmd.equals(\"f\")) {\n                if (c != buf.get(r).length()) {\n                    c++;\n                } else if (r < buf.size()) {\n                    r++;\n                    c = 0;\n                }\n            } else if (cmd.equals(\"b\")) {\n                if (c != 0) {\n                    c--;\n                } else if (r > 0) {\n                    r--;\n                    c = buf.get(r).length();\n                }\n            } else if (cmd.equals(\"d\")) {\n                if (c != buf.get(r).length()) {\n                    buf.get(r).deleteCharAt(c);\n                } else if (r < buf.size()-1){\n                    buf.get(r).append(buf.get(r+1));\n                    buf.remove(r+1);\n                }\n            } else if (cmd.equals(\"k\")) {\n                if (c == buf.get(r).length()) {\n                    buf.get(r).append(buf.get(r+1));\n                    buf.remove(r+1);\n                    clipboard = \"\\n\";\n                    //System.out.println(\"copied newline\"); \n                } else {\n                    clipboard = buf.get(r).substring(c);\n                    buf.get(r).delete(c, buf.get(r).length());\n                    c = buf.get(r).length();\n                }\n            } else if (cmd.equals(\"y\")) {\n                //System.out.println(\"r: \" + r + \" c: \" + c);\n                //System.out.println(\"clipboard: \" + clipboard);\n                if (!clipboard.isEmpty()) {\n                    if (clipboard.equals(\"\\n\")) {\n                        StringBuilder tmp = new StringBuilder(buf.get(r).substring(c));\n                        buf.get(r).delete(c, buf.get(r).length());\n                        buf.add(r, tmp);\n                        r++;\n                        c = 0;\n                    } else {\n                        buf.get(r).insert(c, clipboard);\n                    }\n                }\n            }\n\n            //System.out.println(\"------ current buffer ------\");\n            //System.out.println(\"r: \" + r + \" c: \" + c);\n            //for (StringBuilder b : buf) {\n            //    System.out.println(b);\n            //}\n            //System.out.println(\"\");\n        }\n        for (StringBuilder b : buf) {\n            System.out.println(b);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static ArrayList<String> modifyingText = new ArrayList<String>();\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        String inputText[];\n        String inputCommand[];\n\n        inputText = giveTextLine();\n        inputCommand = giveCommand();\n        modifyText(inputText, inputCommand);\n\n        for(int i = 0; i < modifyingText.size(); i++){\n            System.out.println(modifyingText.get(i));\n        }\n    }\n\n    private static String[] giveTextLine() {\n        String input;\n        String[] inputText = new String[MAXINPUTLINE];\n        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = String.valueOf(scan.next());\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText[i] = input;\n        }\n        return inputText;\n    }\n\n    private static String[] giveCommand() {\n        String input;\n        String[] inputCommand = new String[MAXINPUTCOMMAND];\n        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = String.valueOf(scan.next());\n            if (input.equals(\"-\")) break;\n            inputCommand[i] = input;\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final String inputText[], final String inputCommand[]) {\n\n        for (int i = 0; i < inputText.length; i++) {\n            modifyingText.add(i, inputText[i]);\n        }\n\n        for (int i = 0; i < inputCommand.length; i++) {\n            if (inputCommand[i].equals(\"a\")) editA();\n            else if (inputCommand[i].equals(\"e\")) editE();\n            else if (inputCommand[i].equals(\"p\")) editP();\n            else if (inputCommand[i].equals(\"n\")) editN();\n            else if (inputCommand[i].equals(\"f\")) editF();\n            else if (inputCommand[i].equals(\"b\")) editB();\n            else if (inputCommand[i].equals(\"d\")) editD();\n            else if (inputCommand[i].equals(\"k\")) editK();\n            else if (inputCommand[i].equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        return str.substring(0, removeIndex) + str.substring(removeIndex + 1);\n    }\n\n    private static String insert(String str, int insertIndex) {\n        return str.substring(0, insertIndex) + buffer + str.substring(insertIndex);\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = modifyingText.get(cursorLocLine).length();\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (modifyingText.get(cursorLocLine + 1) != null) cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (modifyingText.get(cursorLocLine).length() == cursorLocRow + 1) {\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else {\n            cursorLocRow = modifyingText.get(cursorLocLine - 1).length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n        if (cursorLocRow != modifyingText.get(cursorLocLine).length() - 1) {\n            modifyingText.add(cursorLocLine, remove(modifyingText.get(cursorLocLine), cursorLocRow));\n        } else if (modifyingText.get(cursorLocLine + 1) != null) {\n            for (int i = cursorLocLine; i < modifyingText.size(); i++) {\n                if (modifyingText.get(i + 1) == null) break;\n                modifyingText.add(i, modifyingText.get(i) + modifyingText.get(i + 1));\n            }\n        }\n\n    }\n\n    private static void editK() {\n        if (cursorLocRow == modifyingText.get(cursorLocLine).length() - 1 && modifyingText.get(cursorLocLine + 1) != null) {\n            for (int i = cursorLocLine; i < modifyingText.size(); i++) {\n                if (modifyingText.get(i + 1) == null) break;\n                modifyingText.add(i, modifyingText.get(i) + modifyingText.get(i + 1));\n            }\n            buffer = \"\\n\";\n        } else {\n            buffer = modifyingText.get(cursorLocLine).substring(cursorLocRow);\n            modifyingText.add(cursorLocLine, modifyingText.get(cursorLocLine).substring(0, cursorLocRow - 1));\n        }\n    }\n\n    private static void editY() {\n        if(buffer.equals(\"\\n\")) {\n            String movingText = modifyingText.get(cursorLocLine).substring(cursorLocRow);\n            modifyingText.add(cursorLocLine, modifyingText.get(cursorLocLine).substring(0, cursorLocRow-1));\n            for( int i = modifyingText.size(); i != cursorLocLine; i-- ){\n                if(modifyingText.get(cursorLocLine) != null)\n                    modifyingText.add(cursorLocLine + 1, modifyingText.get(cursorLocLine));\n            }\n            cursorLocLine++;\n            cursorLocRow = 0;\n        }else if (buffer != null){\n            modifyingText.add(cursorLocLine, insert(modifyingText.get(cursorLocLine), cursorLocRow));\n        }\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\n\nimport java.util.*;\nimport java.math.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.math.BigInteger.*;\nimport static java.lang.Character.*;\n\nclass AOJ1021 {\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (sc.hasNext()) {\n\t\t\tList<StringBuilder> lb = new ArrayList<StringBuilder>();\n\t\t\twhile (true) {\n\t\t\t\tString s = sc.nextLine();\n\t\t\t\tif (s.equals(\"END_OF_TEXT\"))\n\t\t\t\t\tbreak;\n\t\t\t\tlb.add(new StringBuilder(s));\n\t\t\t}\n\t\t\tint cur = 0, line = 0;\n\t\t\tStringBuilder buf = new StringBuilder();\n\t\t\tloop: while (true) {\n\t\t\t\tchar c = sc.nextLine().charAt(0);\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '-':\n\t\t\t\t\tbreak loop;\n\t\t\t\tcase 'a':\n\t\t\t\t\tcur = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e':\n\t\t\t\t\tcur = lb.get(line).length();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\n\t\t\t\t\tcur = 0;\n\t\t\t\t\tline = max(line - 1, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'n':\n\t\t\t\t\tcur = 0;\n\t\t\t\t\tline = min(line + 1, lb.size());\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tif (cur < lb.get(line).length())\n\t\t\t\t\t\tcur++;\n\t\t\t\t\telse if (line < lb.size() - 1) {\n\t\t\t\t\t\tcur = 0;\n\t\t\t\t\t\tline++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tif (cur > 0)\n\t\t\t\t\t\tcur--;\n\t\t\t\t\telse if (line > 0) {\n\t\t\t\t\t\tline--;\n\t\t\t\t\t\tcur = lb.get(line).length();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tif (cur < lb.get(line).length())\n\t\t\t\t\t\tlb.get(line).deleteCharAt(cur);\n\t\t\t\t\telse if (line < lb.size()) {\n\t\t\t\t\t\tlb.get(line).append(lb.get(line + 1));\n\t\t\t\t\t\tlb.remove(line);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'k':\n\t\t\t\t\tif (cur < lb.get(line).length()) {\n\t\t\t\t\t\tbuf = new StringBuilder(lb.get(line).substring(cur));\n\t\t\t\t\t\tlb.get(line).delete(cur, lb.get(line).length());\n\t\t\t\t\t} else if (line < lb.size()) {\n\t\t\t\t\t\tlb.get(line).append(lb.get(line + 1));\n\t\t\t\t\t\tlb.remove(line);\n\t\t\t\t\t\tbuf = null;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'y':\n\t\t\t\t\tif(buf == null) {\n\t\t\t\t\t\tlb.add(line + 1, new StringBuilder(lb.get(line).substring(cur)));\n\t\t\t\t\t\tlb.get(line).delete(cur, lb.get(line).length());\n\t\t\t\t\t\tline++;\n\t\t\t\t\t\tcur = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlb.get(line).insert(cur, buf);\n\t\t\t\t\t\tcur += buf.length();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (StringBuilder sb : lb)\n\t\t\t\tSystem.out.println(sb);\n\t\t}\n\t}\n}\n\npublic class Main {\n\tpublic static void main(String... args) {\n\t\tnew AOJ1021().run();\n\t}\n\n\tpublic static void debug(Object... os) {\n\t\tSystem.err.println(java.util.Arrays.deepToString(os));\n\t}\n}\n\nclass Scanner {\n\tfinal java.util.Scanner sc;\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(sc.next());\n\t}\n\n\tpublic Scanner(java.io.InputStream is) {\n\t\tthis.sc = new java.util.Scanner(is);\n\t}\n\n\tpublic boolean hasNext() {\n\t\treturn sc.hasNext();\n\t}\n\n\tpublic String next() {\n\t\treturn sc.next();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(sc.next());\n\t}\n\n\tpublic String nextLine() {\n\t\treturn sc.nextLine();\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(sc.next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.xml.crypto.Data;\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tStringBuilder[] sb = new StringBuilder[101];\n\t\tfor(int i = 0; i < sb.length; i++) {\n\t\t\tsb[i] = new StringBuilder();\n\t\t}\n\t\tint len = 0;\n\t\twhile(true) {\n\t\t\tString in = sc.nextLine();\n\t\t\tif(in.equals(\"END_OF_TEXT\")) break;\n\t\t\tsb[len++].append(in);\n\t\t}\n\t\tboolean LF = false;\n\t\tStringBuilder buffer = new StringBuilder();\n\t\tint ci = 0;\n\t\tint cj = 0;\n\t\twhile(true) {\n\t\t\tString in = sc.nextLine();\n\t\t\tif(in.equals(\"-\")) break;\n\t\t\tif(in.equals(\"a\")) {\n\t\t\t\tcj = 0;\n\t\t\t}\n\t\t\tif(in.equals(\"e\")) {\n\t\t\t\tcj = sb[ci].length();\n\t\t\t}\n\t\t\tif(in.equals(\"p\")) {\n\t\t\t\tif(ci != 0) {\n\t\t\t\t\tci--;\n\t\t\t\t}\n\t\t\t\tcj = 0;\t\n\t\t\t}\n\t\t\tif(in.equals(\"n\")) {\n\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\tci++;\n\t\t\t\t}\n\t\t\t\tcj = 0;\n\t\t\t}\n\t\t\tif(in.equals(\"f\")) {\n\t\t\t\tif(cj != sb[ci].length()) {\n\t\t\t\t\tcj++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\tcj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"b\")) {\n\t\t\t\tif(cj != 0) {\n\t\t\t\t\tcj--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci != 0) {\n\t\t\t\t\t\tci--;\n\t\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"d\")) {\n\t\t\t\tif(cj != sb[ci].length()) {\n\t\t\t\t\tsb[ci].deleteCharAt(cj);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tsb[ci].append(sb[ci+1]);\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\twhile(ci+1 != len) {\n\t\t\t\t\t\t\tsb[ci] = sb[ci+1];\n\t\t\t\t\t\t\tci++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"k\")) {\n\t\t\t\tif(cj == sb[ci].length()) {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tsb[ci].append(sb[ci+1]);\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\twhile(ci+1 != len) {\n\t\t\t\t\t\t\tsb[ci] = sb[ci+1];\n\t\t\t\t\t\t\tci++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t\tbuffer = new StringBuilder();\n\t\t\t\t\tLF = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = new StringBuilder(sb[ci].substring(cj, sb[ci].length()));\n\t\t\t\t\tsb[ci].delete(cj, sb[ci].length());\n\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\tLF = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"y\")) {\n\t\t\t\tif(LF) {\n\t\t\t\t\tint now = len;\n\t\t\t\t\twhile(now != ci) {\n\t\t\t\t\t\tsb[now] = sb[now-1];\n\t\t\t\t\t\tnow--;\n\t\t\t\t\t}\n\t\t\t\t\tlen++;\n\t\t\t\t\tsb[ci+1] = new StringBuilder(sb[ci].substring(cj,sb[ci].length()));\n\t\t\t\t\tsb[ci].delete(cj, sb[ci].length());\n\t\t\t\t\tci++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(cj == sb[ci].length()) {\n\t\t\t\t\t\tsb[ci].insert(cj, buffer);\n\t\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsb[ci].insert(cj, buffer);\n\t\t\t\t\t\tcj += buffer.length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < len; i++) {\n\t\t\tSystem.out.println(sb[i].toString());\n\t\t}\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static final String ENDOFLINE = \"$\";\n    static Scanner scan = new Scanner(System.in);\n    static ArrayList<String> modifyingText = new ArrayList<String>();\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        ArrayList<String> inputText;\n        ArrayList<String> inputCommand;\n\n        inputText = giveTextLine();\n//        System.out.println(\"==============================\");\n//        System.out.println(\"give Text Success\");\n\n        inputCommand = giveCommand();\n\n//        System.out.println(\"==============================\");\n//        System.out.println(\"give Command Success\");\n        modifyText(inputText, inputCommand);\n\n        for (int i = 0; i < modifyingText.size(); i++) {\n            int outLen = modifyingText.get(i).length();\n            if (outLen <= 1) {\n                System.out.print(\"\\n\");\n            } else System.out.println(modifyingText.get(i).substring(0, outLen - 1));\n        }\n    }\n\n    private static ArrayList<String> giveTextLine() {\n        String input;\n        ArrayList<String> inputText = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText.add(i, input);\n        }\n        return inputText;\n    }\n\n    private static ArrayList<String> giveCommand() {\n        String input;\n        ArrayList<String> inputCommand = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"-\")) break;\n            inputCommand.add(i, input);\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final ArrayList<String> inputText, final ArrayList<String> inputCommand) {\n\n        for (int i = 0; i < inputText.size(); i++) {\n            modifyingText.add(i, inputText.get(i) + ENDOFLINE);\n        }\n\n        for (int i = 0; i < inputCommand.size(); i++) {\n//            System.out.println(\"===============================\");\n//            System.out.println(inputCommand.get(i) + \" \" + cursorLocRow + \" \" + cursorLocLine + \" \" + modifyingText.get(cursorLocLine).length() + \" \" + buffer);\n//            System.out.println(\"===============================\");\n//            modifyingText.forEach(System.out::println);\n\n            if (inputCommand.get(i).equals(\"a\")) editA();\n            else if (inputCommand.get(i).equals(\"e\")) editE();\n            else if (inputCommand.get(i).equals(\"p\")) editP();\n            else if (inputCommand.get(i).equals(\"n\")) editN();\n            else if (inputCommand.get(i).equals(\"f\")) editF();\n            else if (inputCommand.get(i).equals(\"b\")) editB();\n            else if (inputCommand.get(i).equals(\"d\")) editD();\n            else if (inputCommand.get(i).equals(\"k\")) editK();\n            else if (inputCommand.get(i).equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        StringBuilder builder = new StringBuilder(str);\n        return builder.deleteCharAt(removeIndex).toString();\n    }\n\n    private static String insert(String str, int insertIndex) {\n        StringBuilder builder = new StringBuilder(str);\n\n        if (builder.length() <= insertIndex) {\n            return builder.append(buffer).toString();\n        } else {\n            return builder.insert(insertIndex, buffer).toString();\n        }\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = currentLineString().length() - 1;\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (isLastLine()) return;\n        cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (isLastRow()) {\n            if (isLastLine()) return;\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else if (cursorLocLine > 0) {\n            cursorLocRow = modifyingText.get(cursorLocLine - 1).length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n        if (!isEOL()) {\n            replaceCurrentLine(remove(modifyingText.get(cursorLocLine), cursorLocRow));\n        } else {\n            if (!isLastLine()) {\n                replaceCurrentLine(currentLineString() + modifyingText.get(cursorLocLine + 1));\n                replaceCurrentLine(remove(currentLineString(), cursorLocRow));\n                for (int i = cursorLocLine + 1; i < modifyingText.size(); i++) {\n                    if (isLastLine(i + 1)) break;\n                    replaceLine(i, modifyingText.get(i) + modifyingText.get(i + 1));\n                }\n            }\n        }\n    }\n\n    private static void editK() {\n        if (isLastRow()) {\n            if (!isLastLine()) {\n\n                replaceCurrentLine(currentLineString() + modifyingText.get(cursorLocLine + 1));\n                replaceCurrentLine(remove(currentLineString(), cursorLocRow));\n\n                for (int i = cursorLocLine + 1; i < modifyingText.size(); i++) {\n                    if (isLastLine(i + 1))\n                        replaceLine(i, modifyingText.get(i + 1));\n                }\n                modifyingText.remove(lastLine());\n                buffer = \"\\n\";\n            }\n        } else {\n            buffer = currentLineString().substring(cursorLocRow, currentLineString().length() - 1);\n            if (cursorLocRow == 0) replaceCurrentLine(ENDOFLINE);\n            else replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n        }\n    }\n\n    private static void editY() {\n        if (buffer != null) {\n            if (buffer.equals(\"\\n\")) {\n\n                if (isLastRow()) {\n                    String movingText = currentLineString().substring(cursorLocRow);\n                    replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n                    insertLine(cursorLocLine + 1, movingText);\n                } else {\n                    String movingText = currentLineString().substring(cursorLocRow);\n                    insertLine(cursorLocLine + 1, movingText);\n\n                    if (cursorLocRow != 0) {\n                        replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n                    } else {\n                        replaceCurrentLine(ENDOFLINE);\n                    }\n                }\n                cursorLocRow = 0;\n                cursorLocLine++;\n\n            } else {\n                replaceCurrentLine(insert(currentLineString(), cursorLocRow));\n                \n            }\n        }\n    }\n\n    private static String currentLineString() {\n        return modifyingText.get(cursorLocLine);\n    }\n\n    private static void replaceLine(int index, String str) {\n        modifyingText.set(index, str);\n    }\n\n    private static void replaceCurrentLine(String str) {\n        modifyingText.set(cursorLocLine, str);\n    }\n\n    private static void insertLine(int index, String str) {\n        modifyingText.add(index, str);\n    }\n\n    private static void insertInCurrentLine(String str) {\n        modifyingText.add(cursorLocLine, str);\n    }\n\n    private static boolean isLastLine() {\n        return modifyingText.size() <= cursorLocLine + 1;\n    }\n\n    private static boolean isLastLine(int i) {\n        return modifyingText.size() > i;\n    }\n\n    private static boolean isLastRow() {\n        return modifyingText.get(cursorLocLine).length() <= cursorLocRow + 1;\n    }\n\n    private static int lastLine() {\n        return modifyingText.size() - 1;\n    }\n\n    private static boolean isEOL() {\n        return String.valueOf(currentLineString().charAt(cursorLocRow)).equals(ENDOFLINE);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\nclass Main{\n\tstatic int l, c;\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry{\n\t\t\tArrayList<StringBuilder> str_array = new ArrayList<StringBuilder>();\n\t\t\twhile(true){\n\t\t\t\tString str = br.readLine();\n\t\t\t\tif(str.equals(\"END_OF_TEXT\")) break;\n\t\t\t\tstr_array.add(new StringBuilder(str));\n\t\t\t}\n\t\t\tl = 0;\n\t\t\tc = 0;\n\n\t\t\tString buffer = new String();\n\t\t\tboolean flag = true;\n\t\t\twhile(flag){\n\t\t\t\tchar command = br.readLine().charAt(0);\n\n\t\t\t\tswitch(command){\n\t\t\t\tcase 'a':\n\t\t\t\t\tc = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e':\n\t\t\t\t\tc = str_array.get(l).length();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\n\t\t\t\t\tif(l != 0) l--;\n\t\t\t\t\tc = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'n':\n\t\t\t\t\tif(l != str_array.size() - 1) l++;\n\t\t\t\t\tc = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':{\n\t\t\t\t\tStringBuilder str = str_array.get(l);\n\t\t\t\t\tif(c != str.length()){\n\t\t\t\t\t\t// 行末じゃないとき\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}else if(l != str_array.size() -1){\n\t\t\t\t\t\t// 行末だけど最終行じゃないとき\n\t\t\t\t\t\tl++;\n\t\t\t\t\t\tc = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'b':\n\t\t\t\t\tif(c != 0){\n\t\t\t\t\t\t// 行頭じゃないとき\n\t\t\t\t\t\tc--;\n\t\t\t\t\t}else if(l != 0){\n\t\t\t\t\t\t// 行頭だけど上に行があるとき\n\t\t\t\t\t\tl--;\n\t\t\t\t\t\tc = str_array.get(l).length();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':{\n\t\t\t\t\tStringBuilder str = str_array.get(l);\n\t\t\t\t\tif(c < str.length()){\n\t\t\t\t\t\t// 行末じゃないとき\n\t\t\t\t\t\tstr.deleteCharAt(c);\n\t\t\t\t\t}else if(l < str_array.size() - 1){\n\t\t\t\t\t\tStringBuilder str2 = str_array.get(l+1);\n\t\t\t\t\t\tstr.append(str2);\n\t\t\t\t\t\tstr_array.remove(str2);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'k':{\n\t\t\t\t\tStringBuilder str = str_array.get(l);\n\t\t\t\t\tif(c < str.length()){\n\t\t\t\t\t\t// 行末じゃないとき\n\t\t\t\t\t\tbuffer = str.substring(c);\n\t\t\t\t\t\tstr.delete(c, str.length());\n\t\t\t\t\t}else if(l < str_array.size() - 1){\n\t\t\t\t\t\tStringBuilder str2 = str_array.get(l+1);\n\t\t\t\t\t\tstr.append(str2);\n\t\t\t\t\t\tstr_array.remove(str2);\n\t\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'y':{\n\t\t\t\t\tStringBuilder str = str_array.get(l);\n\t\t\t\t\tif(buffer.equals(\"\\n\")){\n\t\t\t\t\t\tString temp = str.substring(c);\n\t\t\t\t\t\tstr.delete(c, str.length());\n\t\t\t\t\t\tStringBuilder str2 = new StringBuilder(temp);\n\t\t\t\t\t\tstr_array.add(l+1, str2);\n\t\t\t\t\t\tl++;\n\t\t\t\t\t\tc = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tstr.insert(c, buffer);\n\t\t\t\t\t\tc += buffer.length();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase '-':\n\t\t\t\t\tprint(str_array);\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// System.out.println(\"(\" + l + \", \" + c + \")\");\n\t\t\t\t// print(str_array);\n\t\t\t\t// System.out.println(\"Buffer:\" + buffer);\n\t\t\t}\n\t\t}catch(Exception e){\n\t\t\tSystem.err.println(e);\n\t\t}\n\t}\n\n\tstatic void print(int a[]){\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tSystem.out.print(a[i] + \"\\t\");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tstatic void print(int m[][]){\n\t\tfor(int i = 0; i < m.length; i++){\n\t\t\tfor(int j = 0; j < m[i].length; j++){\n\t\t\t\tSystem.out.print(m[i][j] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void print(ArrayList<StringBuilder> array){\n\t\tfor(int i = 0; i < array.size(); i++){\n\t\t\tSystem.out.println(array.get(i));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static String[] modifyingText = new String[MAXMODIFIEDTEXTLINE];\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        String inputText[];\n        String inputCommand[];\n\n        inputText = giveTextLine();\n        inputCommand = giveCommand();\n        modifyText(inputText, inputCommand);\n\n        for(int i = 0; i < modifyingText.length; i++){\n            System.out.println(modifyingText[i]);\n        }\n    }\n\n    private static String[] giveTextLine() {\n        String input;\n        String[] inputText = new String[MAXINPUTLINE];\n        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = scan.next();\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText[i] = input;\n        }\n        return inputText;\n    }\n\n    private static String[] giveCommand() {\n        String input;\n        String[] inputCommand = new String[MAXINPUTCOMMAND];\n        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = scan.next();\n            if (input.equals(\"-\")) break;\n            inputCommand[i] = input;\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final String inputText[], final String inputCommand[]) {\n\n        for (int i = 0; i < inputText.length; i++) {\n            modifyingText[i] = inputText[i];\n        }\n\n        for (int i = 0; i < inputCommand.length; i++) {\n            if (inputCommand[i].equals(\"a\")) editA();\n            else if (inputCommand[i].equals(\"e\")) editE();\n            else if (inputCommand[i].equals(\"p\")) editP();\n            else if (inputCommand[i].equals(\"n\")) editN();\n            else if (inputCommand[i].equals(\"f\")) editF();\n            else if (inputCommand[i].equals(\"b\")) editB();\n            else if (inputCommand[i].equals(\"d\")) editD();\n            else if (inputCommand[i].equals(\"k\")) editK();\n            else if (inputCommand[i].equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        return str.substring(0, removeIndex) + str.substring(removeIndex + 1);\n    }\n\n    private static String insert(String str, int insertIndex) {\n        return str.substring(0, insertIndex) + buffer + str.substring(insertIndex);\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = modifyingText[cursorLocLine].length();\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (modifyingText[cursorLocLine + 1] != null) cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (modifyingText[cursorLocLine].length() == cursorLocRow + 1) {\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else {\n            cursorLocRow = modifyingText[cursorLocLine - 1].length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n        if (cursorLocRow != modifyingText[cursorLocLine].length() - 1) {\n            modifyingText[cursorLocLine] = remove(modifyingText[cursorLocLine], cursorLocRow);\n        } else if (modifyingText[cursorLocLine + 1] != null) {\n            for (int i = cursorLocLine; i < modifyingText.length; i++) {\n                if (modifyingText[i + 1] == null) break;\n                modifyingText[i] += modifyingText[i + 1];\n            }\n        }\n\n    }\n\n    private static void editK() {\n        if (cursorLocRow == modifyingText[cursorLocLine].length() - 1 && modifyingText[cursorLocLine + 1] != null) {\n            for (int i = cursorLocLine; i < modifyingText.length; i++) {\n                if (modifyingText[i + 1] == null) break;\n                modifyingText[i] += modifyingText[i + 1];\n            }\n            buffer = \"\\n\";\n        } else {\n            buffer = modifyingText[cursorLocLine].substring(cursorLocRow);\n            modifyingText[cursorLocLine] = modifyingText[cursorLocLine].substring(0, cursorLocRow - 1);\n        }\n    }\n\n    /**\n     * 　yank\n     */\n    private static void editY() {\n        if(buffer.equals(\"\\n\")) {\n            String movingText = modifyingText[cursorLocLine].substring(cursorLocRow);\n            modifyingText[cursorLocLine] = modifyingText[cursorLocLine].substring(0, cursorLocRow-1);\n            for( int i = modifyingText.length; i != cursorLocLine; i-- ){\n                if(modifyingText[cursorLocLine] != null)\n                    modifyingText[cursorLocLine+1] = modifyingText[cursorLocLine];\n            }\n            cursorLocLine++;\n            cursorLocRow = 0;\n        }else if (buffer != null){\n            modifyingText[cursorLocLine] = insert(modifyingText[cursorLocLine], cursorLocRow);\n        }\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    BufferedReader br;\n    Main() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n    ArrayList<StringBuilder> buf;\n    ArrayList<String> cmds;\n    String clipboard;\n    boolean init() {\n        String s;\n        clipboard = new String();\n        buf = new ArrayList<StringBuilder>();\n        cmds = new ArrayList<String>();\n        try {\n            while (!(s = br.readLine()).equals(\"END_OF_TEXT\")) {\n                buf.add(new StringBuilder(s));\n            }\n            while (!(s = br.readLine()).equals(\"-\")) {\n                cmds.add(s);\n            }\n        } catch (IOException e) {}\n        return true;\n    }\n    void run() {\n        init();\n        //for (StringBuilder b : buf) {\n        //    System.out.println(b);\n        //}\n        int r = 0;\n        int c = 0;\n        for (String cmd : cmds) {\n            //System.out.println(\"cmd: \" + cmd);\n            if (cmd.equals(\"a\")) {\n                c = 0;\n            } else if (cmd.equals(\"e\")) {\n                c = buf.get(r).length();\n            } else if (cmd.equals(\"p\")) {\n                if (r > 0) {\n                    r--;\n                    c = 0;\n                } else {\n                    c = 0;\n                }\n            } else if (cmd.equals(\"n\")) {\n                if (r < buf.size()-1) {\n                    r++;\n                    c = 0;\n                } else {\n                    c = 0;\n                }\n            } else if (cmd.equals(\"f\")) {\n                if (c != buf.get(r).length()) {\n                    c++;\n                } else if (r < buf.size()-1) {\n                    r++;\n                    c = 0;\n                }\n            } else if (cmd.equals(\"b\")) {\n                if (c != 0) {\n                    c--;\n                } else if (r > 0) {\n                    r--;\n                    c = buf.get(r).length();\n                }\n            } else if (cmd.equals(\"d\")) {\n                if (c != buf.get(r).length()) {\n                    buf.get(r).deleteCharAt(c);\n                } else if (r < buf.size()-1){\n                    buf.get(r).append(buf.get(r+1));\n                    buf.remove(r+1);\n                }\n            } else if (cmd.equals(\"k\")) {\n                if (c == buf.get(r).length()) {\n                    buf.get(r).append(buf.get(r+1));\n                    buf.remove(r+1);\n                    clipboard = \"\\n\";\n                    //System.out.println(\"copied newline\"); \n                } else {\n                    clipboard = buf.get(r).substring(c);\n                    buf.get(r).delete(c, buf.get(r).length());\n                    c = buf.get(r).length();\n                }\n            } else if (cmd.equals(\"y\")) {\n                //System.out.println(\"r: \" + r + \" c: \" + c);\n                //System.out.println(\"clipboard: \" + clipboard);\n                if (!clipboard.isEmpty()) {\n                    if (clipboard.equals(\"\\n\")) {\n                        StringBuilder tmp = new StringBuilder(buf.get(r).substring(c));\n                        buf.get(r).delete(c, buf.get(r).length());\n                        buf.add(r, tmp);\n                        r++;\n                        c = 0;\n                    } else {\n                        buf.get(r).insert(c, clipboard);\n                        c += clipboard.length();\n                    }\n                }\n            }\n\n            //System.out.println(\"------ current buffer ------\");\n            //System.out.println(\"r: \" + r + \" c: \" + c);\n            //for (StringBuilder b : buf) {\n            //    System.out.println(b);\n            //}\n            //System.out.println(\"\");\n        }\n        for (StringBuilder b : buf) {\n            System.out.println(b);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\tArrayList<String> text = new ArrayList<String>();\n\t\t\tArrayList<Character> commands = new ArrayList<Character>();\n\t\t\tString buffer = null;\n\t\t\tint l=0, c=0;\n\t\t\t/* input */\n\t\t\twhile(true){\n\t\t\t\tline = br.readLine();\n\t\t\t\tif(line.equals(\"END_OF_TEXT\")) break;\n\t\t\t\ttext.add(line);\n\t\t\t}\n\t\t\twhile(true){\n\t\t\t\tline = br.readLine();\n\t\t\t\tif(line.equals(\"-\")) break;\n\t\t\t\tcommands.add(line.charAt(0));\n\t\t\t}\n\t\t\t/* processing */\n\t\t\tfor(char cm : commands){\n\t\t\t\tswitch(cm){\n\t\t\t\tcase 'a':\n\t\t\t\t\tc = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e':\n\t\t\t\t\tc = text.get(l).length();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\n\t\t\t\t\tif(l>0){\n\t\t\t\t\t\tl--;\n\t\t\t\t\t}\n\t\t\t\t\tc = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'n':\n\t\t\t\t\tif(l<text.size()-1){\n\t\t\t\t\t\tl++;\n\t\t\t\t\t}\n\t\t\t\t\tc = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tif(c==text.get(l).length()){\n\t\t\t\t\t\tif(l<text.size()-1){\n\t\t\t\t\t\t\tl++;\n\t\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tif(c==0){\n\t\t\t\t\t\tif(l>0){\n\t\t\t\t\t\t\tl--;\n\t\t\t\t\t\t\tc = text.get(l).length();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tif(c<text.get(l).length()){\n\t\t\t\t\t\ttext.set(l, text.get(l).substring(0,c) + text.get(l).substring(c+1,text.get(l).length()));\n\t\t\t\t\t} else if(l<text.size()-1){\n\t\t\t\t\t\ttext.set(l, text.get(l).substring(0,c) + text.get(l+1));\n\t\t\t\t\t\ttext.remove(l+1);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'k':\n\t\t\t\t\tif(c==text.get(l).length()){\n\t\t\t\t\t\tif(l<text.size()-1){\n\t\t\t\t\t\t\ttext.set(l, text.get(l).substring(0,c) + text.get(l+1));\n\t\t\t\t\t\t\ttext.remove(l+1);\n\t\t\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuffer = text.get(l).substring(c);\n\t\t\t\t\t\ttext.set(l, text.get(l).substring(0,c));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'y':\n\t\t\t\t\tif(buffer==null){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if(buffer.equals(\"\\n\")){\n\t\t\t\t\t\ttext.add(l+1,text.get(l).substring(c));\n\t\t\t\t\t\ttext.set(l, text.get(l).substring(0,c));\n\t\t\t\t\t\tl++;\n\t\t\t\t\t\tc = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttext.set(l, text.get(l).substring(0,c) + buffer + text.get(l).substring(c));\n\t\t\t\t\t\tc += buffer.length();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* output */\n\t\t\tfor(String s : text){\n\t\t\t\tSystem.out.println(s);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class EditText {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static final String ENDOFLINE = \"$\";\n    static Scanner scan = new Scanner(System.in);\n    static ArrayList<String> modifyingText = new ArrayList<String>();\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        ArrayList<String> inputText;\n        ArrayList<String> inputCommand;\n\n        inputText = giveTextLine();\n//        System.out.println(\"==============================\");\n//        System.out.println(\"give Text Success\");\n\n        inputCommand = giveCommand();\n\n//        System.out.println(\"==============================\");\n//        System.out.println(\"give Command Success\");\n        modifyText(inputText, inputCommand);\n\n        for (int i = 0; i < modifyingText.size(); i++) {\n            int outLen = modifyingText.get(i).length();\n            if (outLen <= 1) {\n                System.out.print(\"\\n\");\n            } else System.out.println(modifyingText.get(i).substring(0, outLen - 1));\n        }\n    }\n\n    private static ArrayList<String> giveTextLine() {\n        String input;\n        ArrayList<String> inputText = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText.add(i, input);\n        }\n        return inputText;\n    }\n\n    private static ArrayList<String> giveCommand() {\n        String input;\n        ArrayList<String> inputCommand = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"-\")) break;\n            inputCommand.add(i, input);\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final ArrayList<String> inputText, final ArrayList<String> inputCommand) {\n\n        for (int i = 0; i < inputText.size(); i++) {\n            modifyingText.add(i, inputText.get(i) + ENDOFLINE);\n        }\n\n        for (int i = 0; i < inputCommand.size(); i++) {\n//            System.out.println(\"===============================\");\n//            System.out.println(inputCommand.get(i) + \" \" + cursorLocRow + \" \" + cursorLocLine + \" \" + modifyingText.get(cursorLocLine).length() + \" \" + buffer);\n//            System.out.println(\"===============================\");\n//            modifyingText.forEach(System.out::println);\n\n            if (inputCommand.get(i).equals(\"a\")) editA();\n            else if (inputCommand.get(i).equals(\"e\")) editE();\n            else if (inputCommand.get(i).equals(\"p\")) editP();\n            else if (inputCommand.get(i).equals(\"n\")) editN();\n            else if (inputCommand.get(i).equals(\"f\")) editF();\n            else if (inputCommand.get(i).equals(\"b\")) editB();\n            else if (inputCommand.get(i).equals(\"d\")) editD();\n            else if (inputCommand.get(i).equals(\"k\")) editK();\n            else if (inputCommand.get(i).equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        StringBuilder builder = new StringBuilder(str);\n        return builder.deleteCharAt(removeIndex).toString();\n    }\n\n    private static String insert(String str, int insertIndex) {\n        StringBuilder builder = new StringBuilder(str);\n\n        if (builder.length() <= insertIndex) {\n            return builder.append(buffer).toString();\n        } else {\n            return builder.insert(insertIndex, buffer).toString();\n        }\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = currentLineString().length() - 1;\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (isLastLine()) return;\n        cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (isLastRow()) {\n            if (isLastLine()) return;\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else if (cursorLocLine > 0) {\n            cursorLocRow = modifyingText.get(cursorLocLine - 1).length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n        if (!isEOL()) {\n            replaceCurrentLine(remove(modifyingText.get(cursorLocLine), cursorLocRow));\n        } else {\n            if (!isLastLine()) {\n                replaceCurrentLine(currentLineString() + modifyingText.get(cursorLocLine + 1));\n                replaceCurrentLine(remove(currentLineString(), cursorLocRow));\n                for (int i = cursorLocLine + 1; i < modifyingText.size(); i++) {\n                    if (isLastLine(i + 1)) break;\n                    replaceLine(i, modifyingText.get(i) + modifyingText.get(i + 1));\n                }\n            }\n        }\n    }\n\n    private static void editK() {\n        if (isLastRow()) {\n            if (!isLastLine()) {\n\n                replaceCurrentLine(currentLineString() + modifyingText.get(cursorLocLine + 1));\n                replaceCurrentLine(remove(currentLineString(), cursorLocRow));\n\n                for (int i = cursorLocLine + 1; i < modifyingText.size(); i++) {\n                    if (isLastLine(i + 1))\n                        replaceLine(i, modifyingText.get(i + 1));\n                }\n                modifyingText.remove(lastLine());\n                buffer = \"\\n\";\n            }\n        } else {\n            buffer = currentLineString().substring(cursorLocRow, currentLineString().length() - 1);\n            if (cursorLocRow == 0) replaceCurrentLine(ENDOFLINE);\n            else replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n            cursorLocRow = currentLineString().length() - 1;\n        }\n    }\n\n    private static void editY() {\n        if (buffer != null) {\n            if (buffer.equals(\"\\n\")) {\n\n                if (isLastRow()) {\n                    String movingText = currentLineString().substring(cursorLocRow);\n                    replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n                    insertLine(cursorLocLine + 1, movingText);\n                } else {\n                    String movingText = currentLineString().substring(cursorLocRow);\n                    insertLine(cursorLocLine + 1, movingText);\n\n                    if (cursorLocRow != 0) {\n                        replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n                    } else {\n                        replaceCurrentLine(ENDOFLINE);\n                    }\n                }\n                cursorLocRow = 0;\n                cursorLocLine++;\n\n            } else {\n                replaceCurrentLine(insert(currentLineString(), cursorLocRow));\n\n            }\n        }\n    }\n\n    private static String currentLineString() {\n        return modifyingText.get(cursorLocLine);\n    }\n\n    private static void replaceLine(int index, String str) {\n        modifyingText.set(index, str);\n    }\n\n    private static void replaceCurrentLine(String str) {\n        modifyingText.set(cursorLocLine, str);\n    }\n\n    private static void insertLine(int index, String str) {\n        modifyingText.add(index, str);\n    }\n\n    private static void insertInCurrentLine(String str) {\n        modifyingText.add(cursorLocLine, str);\n    }\n\n    private static boolean isLastLine() {\n        return modifyingText.size() <= cursorLocLine + 1;\n    }\n\n    private static boolean isLastLine(int i) {\n        return modifyingText.size() > i;\n    }\n\n    private static boolean isLastRow() {\n        return modifyingText.get(cursorLocLine).length() <= cursorLocRow + 1;\n    }\n\n    private static int lastLine() {\n        return modifyingText.size() - 1;\n    }\n\n    private static boolean isEOL() {\n        return String.valueOf(currentLineString().charAt(cursorLocRow)).equals(ENDOFLINE);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static ArrayList<String> modifyingText = new ArrayList<String>();\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        String inputText[];\n        String inputCommand[];\n\n        inputText = giveTextLine();\n        inputCommand = giveCommand();\n        modifyText(inputText, inputCommand);\n\n        for(int i = 0; i < modifyingText.size(); i++){\n            System.out.println(modifyingText.get(i));\n        }\n    }\n\n    private static String[] giveTextLine() {\n        String input;\n        String[] inputText = new String[MAXINPUTLINE];\n        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = String.valueOf(scan.next());\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText[i] = input;\n        }\n        return inputText;\n    }\n\n    private static String[] giveCommand() {\n        String input;\n        String[] inputCommand = new String[MAXINPUTCOMMAND];\n        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = String.valueOf(scan.next());\n            if (input.equals(\"-\")) break;\n            inputCommand[i] = input;\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final String inputText[], final String inputCommand[]) {\n\n        for (int i = 0; i < inputText.length; i++) {\n            modifyingText.add(i, inputText[i]);\n        }\n\n        for (int i = 0; i < inputCommand.length; i++) {\n            if (inputCommand[i].equals(\"a\")) editA();\n            else if (inputCommand[i].equals(\"e\")) editE();\n            else if (inputCommand[i].equals(\"p\")) editP();\n            else if (inputCommand[i].equals(\"n\")) editN();\n            else if (inputCommand[i].equals(\"f\")) editF();\n            else if (inputCommand[i].equals(\"b\")) editB();\n            else if (inputCommand[i].equals(\"d\")) editD();\n            else if (inputCommand[i].equals(\"k\")) editK();\n            else if (inputCommand[i].equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        StringBuilder builder = new StringBuilder(str);\n        return builder.deleteCharAt(removeIndex).toString();\n//        return str.substring(0, removeIndex) + str.substring(removeIndex + 1);\n    }\n\n    private static String insert(String str, int insertIndex) {\n        StringBuilder builder = new StringBuilder(str);\n        return builder.insert(insertIndex, buffer).toString();\n//        return str.substring(0, insertIndex) + buffer + str.substring(insertIndex);\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = modifyingText.get(cursorLocLine).length();\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (modifyingText.get(cursorLocLine + 1) != null) cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (modifyingText.get(cursorLocLine).length() == cursorLocRow + 1) {\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else {\n            cursorLocRow = modifyingText.get(cursorLocLine - 1).length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n        if (cursorLocRow != modifyingText.get(cursorLocLine).length() - 1) {\n            modifyingText.add(cursorLocLine, remove(modifyingText.get(cursorLocLine), cursorLocRow));\n        } else if (modifyingText.get(cursorLocLine + 1) != null) {\n            for (int i = cursorLocLine; i < modifyingText.size(); i++) {\n                if (modifyingText.get(i + 1) == null) break;\n                modifyingText.add(i, modifyingText.get(i) + modifyingText.get(i + 1));\n            }\n        }\n\n    }\n\n    private static void editK() {\n        if (cursorLocRow == modifyingText.get(cursorLocLine).length() - 1 && modifyingText.get(cursorLocLine + 1) != null) {\n            for (int i = cursorLocLine; i < modifyingText.size(); i++) {\n                if (modifyingText.get(i + 1) == null) break;\n                modifyingText.add(i, modifyingText.get(i) + modifyingText.get(i + 1));\n            }\n            buffer = \"\\n\";\n        } else {\n            buffer = modifyingText.get(cursorLocLine).substring(cursorLocRow);\n            modifyingText.add(cursorLocLine, modifyingText.get(cursorLocLine).substring(0, cursorLocRow - 1));\n        }\n    }\n\n    private static void editY() {\n        if(buffer.equals(\"\\n\")) {\n            String movingText = modifyingText.get(cursorLocLine).substring(cursorLocRow);\n            modifyingText.add(cursorLocLine, modifyingText.get(cursorLocLine).substring(0, cursorLocRow-1));\n            for( int i = modifyingText.size(); i != cursorLocLine; i-- ){\n                if(modifyingText.get(cursorLocLine) != null)\n                    modifyingText.add(cursorLocLine + 1, modifyingText.get(cursorLocLine));\n            }\n            cursorLocLine++;\n            cursorLocRow = 0;\n        }else if (buffer != null){\n            modifyingText.add(cursorLocLine, insert(modifyingText.get(cursorLocLine), cursorLocRow));\n        }\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.xml.crypto.Data;\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tStringBuilder[] sb = new StringBuilder[101];\n\t\tfor(int i = 0; i < sb.length; i++) {\n\t\t\tsb[i] = new StringBuilder();\n\t\t}\n\t\tint len = 0;\n\t\twhile(true) {\n\t\t\tString in = sc.nextLine();\n\t\t\tif(in.equals(\"END_OF_TEXT\")) break;\n\t\t\tsb[len++].append(in);\n\t\t}\n\t\tboolean LF = false;\n\t\tStringBuilder buffer = new StringBuilder();\n\t\tint ci = 0;\n\t\tint cj = 0;\n\t\twhile(true) {\n\t\t\tString in = sc.nextLine();\n\t\t\tif(in.equals(\"-\")) break;\n\t\t\tif(in.equals(\"a\")) {\n\t\t\t\tcj = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(in.equals(\"e\")) {\n\t\t\t\tcj = sb[ci].length();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(in.equals(\"p\")) {\n\t\t\t\tif(ci != 0) {\n\t\t\t\t\tci--;\n\t\t\t\t}\n\t\t\t\tcj = 0;\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(in.equals(\"n\")) {\n\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\tci++;\n\t\t\t\t}\n\t\t\t\tcj = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(in.equals(\"f\")) {\n\t\t\t\tif(cj != sb[ci].length()) {\n\t\t\t\t\tcj++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\tcj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"b\")) {\n\t\t\t\tif(cj != 0) {\n\t\t\t\t\tcj--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci != 0) {\n\t\t\t\t\t\tci--;\n\t\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"d\")) {\n\t\t\t\tif(cj != sb[ci].length()) {\n\t\t\t\t\tsb[ci].deleteCharAt(cj);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tsb[ci].append(sb[ci+1]);\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\twhile(ci+1 != len) {\n\t\t\t\t\t\t\tsb[ci] = sb[ci+1];\n\t\t\t\t\t\t\tci++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"k\")) {\n\t\t\t\tif(cj == sb[ci].length()) {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tsb[ci].append(sb[ci+1]);\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\twhile(ci+1 != len) {\n\t\t\t\t\t\t\tsb[ci] = sb[ci+1];\n\t\t\t\t\t\t\tci++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t\tbuffer = new StringBuilder();\n\t\t\t\t\tLF = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = new StringBuilder(sb[ci].substring(cj, sb[ci].length()));\n\t\t\t\t\tsb[ci].delete(cj, sb[ci].length());\n\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\tLF = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"y\")) {\n\t\t\t\tif(LF) {\n\t\t\t\t\tint now = len;\n\t\t\t\t\twhile(now != ci) {\n\t\t\t\t\t\tsb[now] = sb[now-1];\n\t\t\t\t\t\tnow--;\n\t\t\t\t\t}\n\t\t\t\t\tlen++;\n\t\t\t\t\tsb[ci+1] = new StringBuilder(sb[ci].substring(cj,sb[ci].length()));\n\t\t\t\t\tsb[ci].delete(cj, sb[ci].length());\n\t\t\t\t\tci++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(cj == sb[ci].length()) {\n\t\t\t\t\t\tsb[ci].insert(cj, buffer);\n\t\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsb[ci].insert(cj, buffer);\n\t\t\t\t\t\tcj += buffer.length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < len; i++) {\n\t\t\tSystem.out.println(sb[i].toString());\n\t\t}\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.InputStreamReader;\nimport java.nio.Buffer;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.regex.Pattern;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) throws Exception {\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner sc = new Scanner(new InputStreamReader(System.in));\n\n\t\tArrayList<StringBuilder> lines = new ArrayList<StringBuilder>();\n\t\twhile (true) {\n\t\t\tString text = sc.next();\n\t\t\tif (text.equals(\"END_OF_TEXT\"))\n\t\t\t\tbreak;\n\t\t\tlines.add(new StringBuilder(text));\n\t\t}\n\t\tPoint cursor = new Point();\n\n\t\tString buffer = null;\n\n\t\tcommandLoop: while (true) {\n\t\t\tchar command = sc.next().charAt(0);\n\t\t\tStringBuilder currentLine = lines.get(cursor.y);\n\t\t\tswitch (command) {\n\t\t\tcase 'a':\n\t\t\t\tcursor.x = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tcursor.x = currentLine.length();\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tif (cursor.y > 0)\n\t\t\t\t\tcursor.y--;\n\t\t\t\telse\n\t\t\t\t\tcursor.x = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tif (cursor.y + 1 < lines.size())\n\t\t\t\t\tcursor.y++;\n\t\t\t\tcursor.x = 0; // ?\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (cursor.x < currentLine.length()) {\n\t\t\t\t\tcursor.x++;\n\t\t\t\t}\n\t\t\t\telse if (cursor.y + 1 < lines.size()) {\n\t\t\t\t\tcursor.y++;\n\t\t\t\t\tcursor.x = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tif (cursor.x > 0) {\n\t\t\t\t\tcursor.x--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (cursor.y > 0) {\n\t\t\t\t\tcursor.y--;\n\t\t\t\t\tcursor.x = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif (cursor.x < currentLine.length()) {\n\t\t\t\t\tcurrentLine.deleteCharAt(cursor.x);\n\t\t\t\t}\n\t\t\t\telse if (cursor.y + 1 < lines.size()) {\n\t\t\t\t\tcurrentLine.append(lines.remove(cursor.y + 1));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tif (cursor.x == currentLine.length()) {\n\t\t\t\t\tif (cursor.y + 1 < lines.size()) {\n\t\t\t\t\t\tcurrentLine.append(lines.remove(cursor.y + 1));\n\t\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = currentLine.substring(cursor.x);\n\t\t\t\t\tcurrentLine.delete(cursor.x, currentLine.length());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\tif (buffer != null) {\n\t\t\t\t\tif (buffer.equals(\"\\n\")) {\n\t\t\t\t\t\tStringBuilder newLine = new StringBuilder();\n\t\t\t\t\t\tif(cursor.x != currentLine.length()) {\n\t\t\t\t\t\t\tnewLine.append(currentLine.substring(cursor.x));\n\t\t\t\t\t\t\tcurrentLine.delete(cursor.x, currentLine.length());\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlines.add(cursor.y, newLine);\n\t\t\t\t\t\tcursor.y++;\n\t\t\t\t\t\tcursor.x = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(cursor.x == currentLine.length())\n\t\t\t\t\t\t\tcurrentLine.append(buffer);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcurrentLine.insert(cursor.x, buffer);\n\t\t\t\t\t\tcursor.x += buffer.length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak commandLoop;\n\t\t\t}\n//\t\t\tSystem.out.println(cursor);\n//\t\t\tSystem.out.println(currentLine);\n\t\t}\n\t\tfor (StringBuilder sb : lines) {\n\t\t\tSystem.out.println(sb);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static final String ENDOFLINE = \"$\";\n    static Scanner scan = new Scanner(System.in);\n    static ArrayList<String> modifyingText = new ArrayList<String>();\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        ArrayList<String> inputText;\n        ArrayList<String> inputCommand;\n\n        inputText = giveTextLine();\n//        System.out.println(\"==============================\");\n//        System.out.println(\"give Text Success\");\n\n        inputCommand = giveCommand();\n\n//        System.out.println(\"==============================\");\n//        System.out.println(\"give Command Success\");\n        modifyText(inputText, inputCommand);\n\n        for (int i = 0; i < modifyingText.size(); i++) {\n            int outLen = modifyingText.get(i).length();\n            if (outLen <= 1) {\n                System.out.print(\"\\n\");\n            } else System.out.println(modifyingText.get(i).substring(0, outLen - 1));\n        }\n    }\n\n    private static ArrayList<String> giveTextLine() {\n        String input;\n        ArrayList<String> inputText = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText.add(i, input);\n        }\n        return inputText;\n    }\n\n    private static ArrayList<String> giveCommand() {\n        String input;\n        ArrayList<String> inputCommand = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"-\")) break;\n            inputCommand.add(i, input);\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final ArrayList<String> inputText, final ArrayList<String> inputCommand) {\n\n        for (int i = 0; i < inputText.size(); i++) {\n            modifyingText.add(i, inputText.get(i) + ENDOFLINE);\n        }\n\n        for (int i = 0; i < inputCommand.size(); i++) {\n//            System.out.println(\"===============================\");\n//            System.out.println(inputCommand.get(i) + \" \" + cursorLocRow + \" \" + cursorLocLine + \" \" + modifyingText.get(cursorLocLine).length() + \" \" + buffer);\n//            System.out.println(\"===============================\");\n//            modifyingText.forEach(System.out::println);\n\n            if (inputCommand.get(i).equals(\"a\")) editA();\n            else if (inputCommand.get(i).equals(\"e\")) editE();\n            else if (inputCommand.get(i).equals(\"p\")) editP();\n            else if (inputCommand.get(i).equals(\"n\")) editN();\n            else if (inputCommand.get(i).equals(\"f\")) editF();\n            else if (inputCommand.get(i).equals(\"b\")) editB();\n            else if (inputCommand.get(i).equals(\"d\")) editD();\n            else if (inputCommand.get(i).equals(\"k\")) editK();\n            else if (inputCommand.get(i).equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        StringBuilder builder = new StringBuilder(str);\n        return builder.deleteCharAt(removeIndex).toString();\n    }\n\n    private static String insert(String str, int insertIndex) {\n        StringBuilder builder = new StringBuilder(str);\n\n        if (builder.length() <= insertIndex) {\n            return builder.append(buffer).toString();\n        } else {\n            return builder.insert(insertIndex, buffer).toString();\n        }\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = currentLineString().length() - 1;\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (isLastLine()) return;\n        cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (isLastRow()) {\n            if (isLastLine()) return;\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else if (cursorLocLine > 0) {\n            cursorLocRow = modifyingText.get(cursorLocLine - 1).length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n        if (!isEOL()) {\n            replaceCurrentLine(remove(modifyingText.get(cursorLocLine), cursorLocRow));\n        } else {\n            if (!isLastLine()) {\n                replaceCurrentLine(currentLineString() + modifyingText.get(cursorLocLine + 1));\n                replaceCurrentLine(remove(currentLineString(), cursorLocRow));\n                for (int i = cursorLocLine + 1; i < modifyingText.size(); i++) {\n                    if (isLastLine(i + 1)) break;\n                    replaceLine(i, modifyingText.get(i) + modifyingText.get(i + 1));\n                }\n            }\n        }\n    }\n\n    private static void editK() {\n        if (isLastRow()) {\n            if (!isLastLine()) {\n\n                replaceCurrentLine(currentLineString() + modifyingText.get(cursorLocLine + 1));\n                replaceCurrentLine(remove(currentLineString(), cursorLocRow));\n\n                for (int i = cursorLocLine + 1; i < modifyingText.size(); i++) {\n                    if (isLastLine(i + 1))\n                        replaceLine(i, modifyingText.get(i + 1));\n                }\n                modifyingText.remove(lastLine());\n                buffer = \"\\n\";\n            }\n        } else {\n            buffer = currentLineString().substring(cursorLocRow, currentLineString().length() - 1);\n            if (cursorLocRow == 0) replaceCurrentLine(ENDOFLINE);\n            else replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n            cursorLocRow = currentLineString().length() - 1;\n        }\n    }\n\n    private static void editY() {\n        if (buffer != null) {\n            if (buffer.equals(\"\\n\")) {\n\n                if (isLastRow()) {\n                    String movingText = currentLineString().substring(cursorLocRow);\n                    replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n                    insertLine(cursorLocLine + 1, movingText);\n                } else {\n                    String movingText = currentLineString().substring(cursorLocRow);\n                    insertLine(cursorLocLine + 1, movingText);\n\n                    if (cursorLocRow != 0) {\n                        replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n                    } else {\n                        replaceCurrentLine(ENDOFLINE);\n                    }\n                }\n                cursorLocRow = 0;\n                cursorLocLine++;\n\n            } else {\n                replaceCurrentLine(insert(currentLineString(), cursorLocRow));\n                cursorLocRow += buffer.length();\n\n            }\n        }\n    }\n\n    private static String currentLineString() {\n        return modifyingText.get(cursorLocLine);\n    }\n\n    private static void replaceLine(int index, String str) {\n        modifyingText.set(index, str);\n    }\n\n    private static void replaceCurrentLine(String str) {\n        modifyingText.set(cursorLocLine, str);\n    }\n\n    private static void insertLine(int index, String str) {\n        modifyingText.add(index, str);\n    }\n\n    private static void insertInCurrentLine(String str) {\n        modifyingText.add(cursorLocLine, str);\n    }\n\n    private static boolean isLastLine() {\n        return modifyingText.size() <= cursorLocLine + 1;\n    }\n\n    private static boolean isLastLine(int i) {\n        return modifyingText.size() > i;\n    }\n\n    private static boolean isLastRow() {\n        return modifyingText.get(cursorLocLine).length() <= cursorLocRow + 1;\n    }\n\n    private static int lastLine() {\n        return modifyingText.size() - 1;\n    }\n\n    private static boolean isEOL() {\n        return String.valueOf(currentLineString().charAt(cursorLocRow)).equals(ENDOFLINE);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\npublic class Main {\n static int loc=0;\n static int line=0;\n static String str[];\n static String buffer=\"\";\n static String str2=\"\";\n static String str3=\"\";\n public static void main(String[] args){\n try{\n  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n  str=new String[1000];\n  int a;\n  int j=0;\n  while (true) {\n   String str1 = br.readLine();\n   if(str1.equals(\"END_OF_TEXT\")){a=j; break;}\n   str[j]=str1;\n   j++;\n  }\n  while(true){\n   char ch=br.readLine().charAt(0);\n   if(ch=='-') break;\n   else if(ch=='a')a();\n   else if(ch=='e')e();\n   else if(ch=='p')p();\n   else if(ch=='n')n(a);\n   else if(ch=='f')f(a);\n   else if(ch=='b')b(a);\n   else if(ch=='d')d(a);\n   else if(ch=='k')k(a);\n   else if(ch=='y')y(a);\n  }\n  for(int i=0;i<a;i++)System.out.println(str[i]);\n }\n catch(Exception e){System.out.println(\"err\");}\n }\n\n public static void a(){\n  loc=0;\n }\n public static void e(){\n  loc=str[line].length();\n }\n\n public static void p(){\n  loc=0;\n  if(line!=0)line--;\n }\n public static void n(int a){\n  loc=0;\n  if(line!=a-1)line++;\n }\n public static void f(int a){\n  if(loc != str[line].length())loc++;\n  else if(loc==str[line].length() && line!=a-1) {\n   loc=0;\n   line++;\n  }\n }\n public static void b(int a){\n  if(loc!=0)loc--;\n  else if(loc==0 && line!=0)loc=str[--line].length();\n }\n public static void d(int a){\n  if(loc!=str[line].length()){\n   str2=str[line].substring(0, loc)+str[line].substring(loc+1);\n   str[line]=\"\";\n   str[line]+=str2;\n  }\n  else if(loc==str[line].length() && line!=a-1){\n   str[line]+=str[line+1];\n   str[line+1]=\"\";\n   for(int i=line+2;i<a;i++){\n    str[i-1]+=str[i];\n    str[i]=\"\";\n   }\n   a--;\n  }\n }\n\n public static void k(int a){\n  if(loc!=str[line].length()){\n   buffer=str[line].substring(loc);\n   str2=str[line].substring(0, loc);\n   str[line]=\"\";\n   str[line]+=str2;\n  } \n  else if(loc==str[line].length() && line!=a-1){\n   buffer=\"\\n\";\n   for(int i=line+1;i<a;i++){\n    str[i-1]+=str[i];\n    str[i]=\"\";\n   }\n   a--;\n  }\n }\n\n public static void y(int a){\n  if(buffer.equals(\"\\n\")) {\n  str2=str[line].substring(0,loc);\n  str3=str[line].substring(loc);\n   for(int i=a-1;i>line;i--){\n    str[i+1]=\"\";\n    str[i+1]+=str[i];\n   }\n   str[line]=\"\";\n   str[line]+=str2;\n   str[line+1]=\"\";\n   str[line+1]+=str3;\n   a++;\n   loc=0;\n   line++;\n  }\n  else if(buffer!=\"\") {\n   str2=str[line].substring(0,loc);\n   str3=str[line].substring(loc);\n   str[line]=\"\";\n   str[line]=str2+buffer+str3;\n   loc+=buffer.length();\n  }\n }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.xml.crypto.Data;\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tStringBuilder[] sb = new StringBuilder[1000];\n\t\tfor(int i = 0; i < sb.length; i++) {\n\t\t\tsb[i] = new StringBuilder();\n\t\t}\n\t\tint len = 0;\n\t\twhile(true) {\n\t\t\tString in = sc.nextLine();\n\t\t\tif(in.equals(\"END_OF_TEXT\")) break;\n\t\t\tsb[len++].append(in);\n\t\t}\n\t\tboolean LF = false;\n\t\tStringBuilder buffer = new StringBuilder();\n\t\tint ci = 0;\n\t\tint cj = 0;\n\t\twhile(true) {\n\t\t\tString in = sc.nextLine();\n\t\t\tif(in.equals(\"-\")) break;\n\t\t\tif(in.equals(\"a\")) {\n\t\t\t\tcj = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"e\")) {\n\t\t\t\tcj = sb[ci].length();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"p\")) {\n\t\t\t\tif(ci != 0) {\n\t\t\t\t\tci--;\n\t\t\t\t}\n\t\t\t\tcj = 0;\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"n\")) {\n\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\tci++;\n\t\t\t\t}\n\t\t\t\tcj = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"f\")) {\n\t\t\t\tif(cj != sb[ci].length()) {\n\t\t\t\t\tcj++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\tcj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"b\")) {\n\t\t\t\tif(cj != 0) {\n\t\t\t\t\tcj--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci != 0) {\n\t\t\t\t\t\tci--;\n\t\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"d\")) {\n\t\t\t\tif(cj != sb[ci].length()) {\n\t\t\t\t\tsb[ci].deleteCharAt(cj);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tsb[ci].append(sb[ci+1]);\n\t\t\t\t\t\tint now = ci+1;\n\t\t\t\t\t\twhile(now+1 != len) {\n\t\t\t\t\t\t\tsb[now] = sb[now+1];\n\t\t\t\t\t\t\tnow++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"k\")) {\n\t\t\t\tif(cj == sb[ci].length()) {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tsb[ci].append(sb[ci+1]);\n\t\t\t\t\t\tint now = ci+1;\n\t\t\t\t\t\twhile(now+1 != len) {\n\t\t\t\t\t\t\tsb[now] = sb[now+1];\n\t\t\t\t\t\t\tnow++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t\tbuffer = new StringBuilder();\n\t\t\t\t\tLF = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = new StringBuilder(sb[ci].substring(cj, sb[ci].length()));\n\t\t\t\t\tsb[ci].delete(cj, sb[ci].length());\n\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\tLF = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"y\")) {\n\t\t\t\tif(LF) {\n\t\t\t\t\tint now = len;\n\t\t\t\t\twhile(now != ci) {\n\t\t\t\t\t\tsb[now] = sb[now-1];\n\t\t\t\t\t\tnow--;\n\t\t\t\t\t}\n\t\t\t\t\tlen++;\n\t\t\t\t\tsb[ci+1] = new StringBuilder(sb[ci].substring(cj,sb[ci].length()));\n\t\t\t\t\tsb[ci].delete(cj, sb[ci].length());\n\t\t\t\t\tci++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(cj == sb[ci].length()) {\n\t\t\t\t\t\tsb[ci].insert(cj, buffer);\n\t\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsb[ci].insert(cj, buffer);\n\t\t\t\t\t\tcj += buffer.length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < len; i++) {\n\t\t\tSystem.out.println(sb[i].toString());\n\t\t}\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\n\nimport java.util.*;\nimport java.math.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.math.BigInteger.*;\nimport static java.lang.Character.*;\n\nclass AOJ1021 {\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t// while (sc.hasNext()) {\n\t\tList<StringBuilder> lb = new ArrayList<StringBuilder>();\n\t\twhile (true) {\n\t\t\tString s = sc.nextLine();\n\t\t\tif (s.equals(\"END_OF_TEXT\"))\n\t\t\t\tbreak;\n\t\t\tlb.add(new StringBuilder(s));\n\t\t}\n\t\tint cur = 0, line = 0;\n\t\tStringBuilder buf = new StringBuilder();\n\t\tloop: while (true) {\n\t\t\tchar c = sc.nextLine().charAt(0);\n\t\t\tswitch (c) {\n\t\t\tcase '-':\n\t\t\t\tbreak loop;\n\t\t\tcase 'a':\n\t\t\t\tcur = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tcur = lb.get(line).length();\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tcur = 0;\n\t\t\t\tline = max(line - 1, 0);\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tcur = 0;\n\t\t\t\tline = min(line + 1, lb.size() - 1);\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (cur < lb.get(line).length())\n\t\t\t\t\tcur++;\n\t\t\t\telse if (line < lb.size() - 1) {\n\t\t\t\t\tcur = 0;\n\t\t\t\t\tline++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tif (cur > 0)\n\t\t\t\t\tcur--;\n\t\t\t\telse if (line > 0) {\n\t\t\t\t\tline--;\n\t\t\t\t\tcur = lb.get(line).length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif (cur < lb.get(line).length())\n\t\t\t\t\tlb.get(line).deleteCharAt(cur);\n\t\t\t\telse if (line < lb.size() - 1) {\n\t\t\t\t\tlb.get(line).append(lb.get(line + 1));\n\t\t\t\t\tlb.remove(line + 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tif (cur < lb.get(line).length()) {\n\t\t\t\t\tbuf = new StringBuilder(lb.get(line).substring(cur));\n\t\t\t\t\tlb.get(line).delete(cur, lb.get(line).length());\n\t\t\t\t} else if (line < lb.size() - 1) {\n\t\t\t\t\tlb.get(line).append(lb.get(line + 1));\n\t\t\t\t\tlb.remove(line);\n\t\t\t\t\tbuf = null;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\tif (buf == null) {\n\t\t\t\t\tif (cur < lb.get(line).length()) {\n\t\t\t\t\t\tlb.add(line + 1, new StringBuilder(lb.get(line).substring(cur)));\n\t\t\t\t\t\tlb.get(line).delete(cur, lb.get(line).length());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlb.add(line + 1, new StringBuilder());\n\t\t\t\t\t}\n\t\t\t\t\tline++;\n\t\t\t\t\tcur = 0;\n\t\t\t\t} else {\n\t\t\t\t\tlb.get(line).insert(cur, buf);\n\t\t\t\t\tcur += buf.length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (StringBuilder sb : lb)\n\t\t\tSystem.out.println(sb);\n\t\t// }\n\t}\n}\n\npublic class Main {\n\tpublic static void main(String... args) {\n\t\tnew AOJ1021().run();\n\t}\n\n\tpublic static void debug(Object... os) {\n\t\tSystem.err.println(java.util.Arrays.deepToString(os));\n\t}\n}\n\nclass Scanner {\n\tfinal java.util.Scanner sc;\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(sc.next());\n\t}\n\n\tpublic Scanner(java.io.InputStream is) {\n\t\tthis.sc = new java.util.Scanner(is);\n\t}\n\n\tpublic boolean hasNext() {\n\t\treturn sc.hasNext();\n\t}\n\n\tpublic String next() {\n\t\treturn sc.next();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(sc.next());\n\t}\n\n\tpublic String nextLine() {\n\t\treturn sc.nextLine();\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(sc.next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) throws Exception {\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner sc = new Scanner(new InputStreamReader(System.in));\n\n\t\tArrayList<StringBuilder> lines = new ArrayList<StringBuilder>();\n\t\twhile (true) {\n\t\t\tString text = sc.next();\n\t\t\tif (text.equals(\"END_OF_TEXT\"))\n\t\t\t\tbreak;\n\t\t\tlines.add(new StringBuilder(text));\n\t\t}\n\t\tPoint cursor = new Point();\n\n\t\tString buffer = null;\n\n\t\tcommandLoop: while (true) {\n\t\t\tchar command = sc.next().charAt(0);\n\t\t\tStringBuilder currentLine = lines.get(cursor.y);\n\t\t\tswitch (command) {\n\t\t\tcase 'a':\n\t\t\t\tcursor.x = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tcursor.x = currentLine.length();\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tif (cursor.y > 0)\n\t\t\t\t\tcursor.y--;\n\t\t\t\tcursor.x = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tif (cursor.y + 1 < lines.size())\n\t\t\t\t\tcursor.y++;\n\t\t\t\tcursor.x = 0; // ?\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (cursor.x < currentLine.length()) {\n\t\t\t\t\tcursor.x++;\n\t\t\t\t}\n\t\t\t\telse if (cursor.y + 1 < lines.size()) {\n\t\t\t\t\tcursor.y++;\n\t\t\t\t\tcursor.x = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tif (cursor.x > 0) {\n\t\t\t\t\tcursor.x--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (cursor.y > 0) {\n\t\t\t\t\tcursor.y--;\n\t\t\t\t\tcursor.x = lines.get(cursor.y).length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif (cursor.x < currentLine.length()) {\n\t\t\t\t\tcurrentLine.deleteCharAt(cursor.x);\n\t\t\t\t}\n\t\t\t\telse if (cursor.y + 1 < lines.size()) {\n\t\t\t\t\tcurrentLine.append(lines.remove(cursor.y + 1));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tif (cursor.x == currentLine.length()) {\n\t\t\t\t\tif (cursor.y + 1 < lines.size()) {\n\t\t\t\t\t\tcurrentLine.append(lines.remove(cursor.y + 1));\n\t\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = currentLine.substring(cursor.x);\n\t\t\t\t\tcurrentLine.delete(cursor.x, currentLine.length());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\tif (buffer != null) {\n\t\t\t\t\tif (buffer.equals(\"\\n\")) {\n\t\t\t\t\t\tStringBuilder newLine = new StringBuilder();\n\t\t\t\t\t\tif(cursor.x != currentLine.length()) {\n\t\t\t\t\t\t\tnewLine.append(currentLine.substring(cursor.x));\n\t\t\t\t\t\t\tcurrentLine.delete(cursor.x, currentLine.length());\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlines.add(cursor.y, newLine);\n\t\t\t\t\t\tcursor.y++;\n\t\t\t\t\t\tcursor.x = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(cursor.x == currentLine.length())\n\t\t\t\t\t\t\tcurrentLine.append(buffer);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcurrentLine.insert(cursor.x, buffer);\n\t\t\t\t\t\tcursor.x += buffer.length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak commandLoop;\n\t\t\t}\n//\t\t\tSystem.out.println(cursor);\n//\t\t\tSystem.out.println(currentLine);\n\t\t}\n\t\tfor (StringBuilder sb : lines) {\n\t\t\tSystem.out.println(sb);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.xml.crypto.Data;\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tStringBuilder[] sb = new StringBuilder[1000];\n\t\tfor(int i = 0; i < sb.length; i++) {\n\t\t\tsb[i] = new StringBuilder();\n\t\t}\n\t\tint len = 0;\n\t\twhile(true) {\n\t\t\tString in = sc.nextLine();\n\t\t\tif(in.equals(\"END_OF_TEXT\")) break;\n\t\t\tsb[len++].append(in);\n\t\t}\n\t\tboolean LF = false;\n\t\tStringBuilder buffer = new StringBuilder();\n\t\tint ci = 0;\n\t\tint cj = 0;\n\t\twhile(true) {\n\t\t\tString in = sc.nextLine();\n\t\t\tif(in.equals(\"-\")) break;\n\t\t\tif(in.equals(\"a\")) {\n\t\t\t\tcj = 0;\n\t\t\t}\n\t\t\tif(in.equals(\"e\")) {\n\t\t\t\tcj = sb[ci].length();\n\t\t\t}\n\t\t\tif(in.equals(\"p\")) {\n\t\t\t\tif(ci != 0) {\n\t\t\t\t\tci--;\n\t\t\t\t}\n\t\t\t\tcj = 0;\t\n\t\t\t}\n\t\t\tif(in.equals(\"n\")) {\n\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\tci++;\n\t\t\t\t}\n\t\t\t\tcj = 0;\n\t\t\t}\n\t\t\tif(in.equals(\"f\")) {\n\t\t\t\tif(cj != sb[ci].length()) {\n\t\t\t\t\tcj++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\tcj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"b\")) {\n\t\t\t\tif(cj != 0) {\n\t\t\t\t\tcj--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci != 0) {\n\t\t\t\t\t\tci--;\n\t\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"d\")) {\n\t\t\t\tif(cj != sb[ci].length()) {\n\t\t\t\t\tsb[ci].deleteCharAt(cj);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tsb[ci].append(sb[ci+1]);\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\twhile(ci+1 != len) {\n\t\t\t\t\t\t\tsb[ci] = sb[ci+1];\n\t\t\t\t\t\t\tci++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"k\")) {\n\t\t\t\tif(cj == sb[ci].length()) {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tsb[ci].append(sb[ci+1]);\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\twhile(ci+1 != len) {\n\t\t\t\t\t\t\tsb[ci] = sb[ci+1];\n\t\t\t\t\t\t\tci++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t\tbuffer = new StringBuilder();\n\t\t\t\t\tLF = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = new StringBuilder(sb[ci].substring(cj, sb[ci].length()));\n\t\t\t\t\tsb[ci].delete(cj, sb[ci].length());\n\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\tLF = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"y\")) {\n\t\t\t\tif(LF) {\n\t\t\t\t\tint now = len;\n\t\t\t\t\twhile(now != ci) {\n\t\t\t\t\t\tsb[now] = sb[now-1];\n\t\t\t\t\t\tnow--;\n\t\t\t\t\t}\n\t\t\t\t\tlen++;\n\t\t\t\t\tsb[ci+1] = new StringBuilder(sb[ci].substring(cj,sb[ci].length()));\n\t\t\t\t\tsb[ci].delete(cj, sb[ci].length());\n\t\t\t\t\tci++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(cj == sb[ci].length()) {\n\t\t\t\t\t\tsb[ci].insert(cj, buffer);\n\t\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsb[ci].insert(cj, buffer);\n\t\t\t\t\t\tcj += buffer.length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < len; i++) {\n\t\t\tSystem.out.println(sb[i].toString());\n\t\t}\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\nclass Main{\n\tstatic int l, c;\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry{\n\t\t\tArrayList<StringBuilder> str_array = new ArrayList<StringBuilder>();\n\t\t\twhile(true){\n\t\t\twhile(true){\n\t\t\t\tString str = br.readLine();\n\t\t\t\tif(str.equals(\"END_OF_TEXT\")) break;\n\t\t\t\tstr_array.add(new StringBuilder(str));\n\t\t\t}\n\t\t\tl = 0;\n\t\t\tc = 0;\n\n\t\t\tString buffer = new String();\n\t\t\tboolean flag = true;\n\t\t\twhile(flag){\n\t\t\t\tchar command = br.readLine().charAt(0);\n\n\t\t\t\tswitch(command){\n\t\t\t\tcase 'a':\n\t\t\t\t\tc = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e':\n\t\t\t\t\tc = str_array.get(l).length();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\n\t\t\t\t\tif(l != 0) l--;\n\t\t\t\t\tc = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'n':\n\t\t\t\t\tif(l != str_array.size() - 1) l++;\n\t\t\t\t\tc = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':{\n\t\t\t\t\tStringBuilder str = str_array.get(l);\n\t\t\t\t\tif(c != str.length()){\n\t\t\t\t\t\t// 行末じゃないとき\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}else if(l != str_array.size() -1){\n\t\t\t\t\t\t// 行末だけど最終行じゃないとき\n\t\t\t\t\t\tl++;\n\t\t\t\t\t\tc = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'b':\n\t\t\t\t\tif(c != 0){\n\t\t\t\t\t\t// 行頭じゃないとき\n\t\t\t\t\t\tc--;\n\t\t\t\t\t}else if(l != 0){\n\t\t\t\t\t\t// 行頭だけど上に行があるとき\n\t\t\t\t\t\tl--;\n\t\t\t\t\t\tc = str_array.get(l).length();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':{\n\t\t\t\t\tStringBuilder str = str_array.get(l);\n\t\t\t\t\tif(c < str.length()){\n\t\t\t\t\t\t// 行末じゃないとき\n\t\t\t\t\t\tstr.deleteCharAt(c);\n\t\t\t\t\t}else if(l < str_array.size() - 1){\n\t\t\t\t\t\tStringBuilder str2 = str_array.get(l+1);\n\t\t\t\t\t\tstr.append(str2);\n\t\t\t\t\t\tstr_array.remove(str2);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'k':{\n\t\t\t\t\tStringBuilder str = str_array.get(l);\n\t\t\t\t\tif(c < str.length()){\n\t\t\t\t\t\t// 行末じゃないとき\n\t\t\t\t\t\tbuffer = str.substring(c);\n\t\t\t\t\t\tstr.delete(c, str.length());\n\t\t\t\t\t}else if(l < str_array.size() - 1){\n\t\t\t\t\t\tStringBuilder str2 = str_array.get(l+1);\n\t\t\t\t\t\tstr.append(str2);\n\t\t\t\t\t\tstr_array.remove(str2);\n\t\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'y':{\n\t\t\t\t\tStringBuilder str = str_array.get(l);\n\t\t\t\t\tif(buffer.equals(\"\\n\")){\n\t\t\t\t\t\tString temp = str.substring(c);\n\t\t\t\t\t\tstr.delete(c, str.length());\n\t\t\t\t\t\tStringBuilder str2 = new StringBuilder(temp);\n\t\t\t\t\t\tstr_array.add(l+1, str2);\n\t\t\t\t\t\tl++;\n\t\t\t\t\t\tc = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tstr.insert(c, buffer);\n\t\t\t\t\t\tc += buffer.length();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase '-':\n\t\t\t\t\tprint(str_array);\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// System.out.println(\"(\" + l + \", \" + c + \")\");\n\t\t\t\t// print(str_array);\n\t\t\t\t// System.out.println(\"Buffer:\" + buffer);\n\t\t\t}\n\t\t\t}\n\t\t}catch(Exception e){\n\t\t\tSystem.err.println(e);\n\t\t}\n\t}\n\n\tstatic void print(int a[]){\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tSystem.out.print(a[i] + \"\\t\");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tstatic void print(int m[][]){\n\t\tfor(int i = 0; i < m.length; i++){\n\t\t\tfor(int j = 0; j < m[i].length; j++){\n\t\t\t\tSystem.out.print(m[i][j] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void print(ArrayList<StringBuilder> array){\n\t\tfor(int i = 0; i < array.size(); i++){\n\t\t\tSystem.out.println(array.get(i));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO ツ篠ゥツ督ョツ青カツ青ャツつウツづェツつスツδソツッツドツ・ツスツタツブ\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tArrayList<String> str = new ArrayList<String>();\n\t\tArrayList<Character> command = new ArrayList<Character>();\n\t\tString buf;\n\t\tint x=0, y=0;\n\n\n\t\twhile(true){\n\t\t\tbuf = sc.nextLine();\n\t\t\tif(buf.equals(\"END_OF_TEXT\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstr.add(buf);\n\t\t}\n\t\twhile(true){\n\t\t\tbuf = sc.next();\n\t\t\tif(buf.charAt(0) == '-'){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcommand.add(buf.charAt(0));\n\t\t}\n\t\tbuf = \"\";\n\n\t\tfor(int i=0;i<command.size();i++){\n\t\t\tswitch(command.get(i)){\n\t\t\tcase 'a'://ok\n\t\t\t\tx=0;\n\t\t\t\tbreak;\n\n\t\t\tcase 'e'://ok\n\t\t\t\tx=str.get(y).length();\n\t\t\t\tbreak;\n\n\t\t\tcase 'p'://ok\n\t\t\t\tif(y!=0){\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t\tx=0;\n\t\t\t\tbreak;\n\n\t\t\tcase 'n'://ok\n\t\t\t\tif(str.size() != y+1){\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tx=0;\n\t\t\t\tbreak;\n\n\t\t\tcase 'f'://ok\n\t\t\t\tif(str.get(y).length() != x){\n\t\t\t\t\tx++;\n\t\t\t\t}else if(str.size() != y+1){\n\t\t\t\t\ty++;\n\t\t\t\t\tx=0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'b'://ok\n\t\t\t\tif(x!=0){\n\t\t\t\t\tx--;\n\t\t\t\t}else if(y!=0){\n\t\t\t\t\ty--;\n\t\t\t\t\tx=str.get(y).length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'd'://ok\n\t\t\t\tif(x!=str.get(y).length()){\n\t\t\t\t\tchar[] strbuf = str.get(y).toCharArray();\n\t\t\t\t\tString resultbuf = \"\";\n\t\t\t\t\tfor(int j=0;j<strbuf.length;j++){\n\t\t\t\t\t\tif(x!=j){\n\t\t\t\t\t\t\tresultbuf += strbuf[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstr.set(y,resultbuf);\n\t\t\t\t}else if(str.size() != y+1){\n\t\t\t\t\tstr.set(y, str.get(y)+str.get(y+1));\n\t\t\t\t\tstr.remove(y+1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'k'://ok\n\t\t\t\tif(x!=str.get(y).length()){\n\t\t\t\t\tchar[] strbuf = str.get(y).toCharArray();\n\t\t\t\t\tString resultbuf = \"\";\n\t\t\t\t\tbuf = \"\";\n\t\t\t\t\tfor(int j=0;j<strbuf.length;j++){\n\t\t\t\t\t\tif(x>j){\n\t\t\t\t\t\t\tresultbuf += strbuf[j];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf += strbuf[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstr.set(y,resultbuf);\n\t\t\t\t\tx = str.get(y).length();\n\t\t\t\t}else if(str.size() != y+1){\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t\tstr.set(y, str.get(y)+str.get(y+1));\n\t\t\t\t\tstr.remove(y+1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'y':\n\t\t\t\tif(buf.equals(\"\\n\")){\n\t\t\t\t\tchar[] strbuf = str.get(y).toCharArray();\n\t\t\t\t\tString resultbuf = \"\";\n\t\t\t\t\tbuf = \"\";\n\t\t\t\t\tfor(int j=0;j<strbuf.length;j++){\n\t\t\t\t\t\tif(x>j){\n\t\t\t\t\t\t\tresultbuf += strbuf[j];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf += strbuf[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstr.set(y,resultbuf);\n\t\t\t\t\tstr.add(y+1,buf);\n\n\t\t\t\t\ty++;\n\t\t\t\t\tx=0;\n\t\t\t\t\tbuf=\"\\n\";\n\t\t\t\t}else if(buf.length() != 0){\n\t\t\t\t\tchar[] strbuf = str.get(y).toCharArray();\n\t\t\t\t\tString resultbuf = \"\";\n\t\t\t\t\tfor(int j=0;j<=strbuf.length;j++){\n\t\t\t\t\t\tif(x==j){\n\t\t\t\t\t\t\tresultbuf += buf;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j!=strbuf.length){\n\t\t\t\t\t\t\tresultbuf += strbuf[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstr.set(y, resultbuf);\n\t\t\t\t\tx+=buf.length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<str.size();i++){\n\t\t\tSystem.out.println(str.get(i));\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static ArrayList<String> modifyingText = new ArrayList<String>();\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        String inputText[];\n        String inputCommand[];\n\n        inputText = giveTextLine();\n        inputCommand = giveCommand();\n        modifyText(inputText, inputCommand);\n\n        for(int i = 0; i < modifyingText.size(); i++){\n            System.out.println(modifyingText.get(i));\n        }\n    }\n\n    private static String[] giveTextLine() {\n        String input;\n        String[] inputText = new String[MAXINPUTLINE];\n        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = String.valueOf(scan.next());\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText[i] = input;\n        }\n        return inputText;\n    }\n\n    private static String[] giveCommand() {\n        String input;\n        String[] inputCommand = new String[MAXINPUTCOMMAND];\n        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = String.valueOf(scan.next());\n            if (input.equals(\"-\")) break;\n            inputCommand[i] = input;\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final String inputText[], final String inputCommand[]) {\n\n        for (int i = 0; i < inputText.length; i++) {\n            modifyingText.add(i, inputText[i]);\n        }\n\n        for (int i = 0; i < inputCommand.length; i++) {\n            if (inputCommand[i].equals(\"a\")) editA();\n            else if (inputCommand[i].equals(\"e\")) editE();\n            else if (inputCommand[i].equals(\"p\")) editP();\n            else if (inputCommand[i].equals(\"n\")) editN();\n            else if (inputCommand[i].equals(\"f\")) editF();\n            else if (inputCommand[i].equals(\"b\")) editB();\n            else if (inputCommand[i].equals(\"d\")) editD();\n            else if (inputCommand[i].equals(\"k\")) editK();\n            else if (inputCommand[i].equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        return str.substring(0, removeIndex) + str.substring(removeIndex + 1);\n    }\n\n    private static String insert(String str, int insertIndex) {\n        return str.substring(0, insertIndex) + buffer + str.substring(insertIndex);\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = modifyingText.get(cursorLocLine).length();\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (modifyingText.get(cursorLocLine + 1) != null) cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (modifyingText.get(cursorLocLine).length() == cursorLocRow + 1) {\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else {\n            cursorLocRow = modifyingText.get(cursorLocLine - 1).length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n        if (cursorLocRow != modifyingText.get(cursorLocLine).length() - 1) {\n            modifyingText.add(cursorLocLine, remove(modifyingText.get(cursorLocLine), cursorLocRow));\n        } else if (modifyingText.get(cursorLocLine + 1) != null) {\n            for (int i = cursorLocLine; i < modifyingText.size(); i++) {\n                if (modifyingText.get(i + 1) == null) break;\n                modifyingText.add(i, modifyingText.get(i) + modifyingText.get(i + 1));\n            }\n        }\n\n    }\n\n    private static void editK() {\n        if (cursorLocRow == modifyingText.get(cursorLocLine).length() - 1 && modifyingText.get(cursorLocLine + 1) != null) {\n            for (int i = cursorLocLine; i < modifyingText.size(); i++) {\n                if (modifyingText.get(i + 1) == null) break;\n                modifyingText.add(i, modifyingText.get(i) + modifyingText.get(i + 1));\n            }\n            buffer = \"\\n\";\n        } else {\n            buffer = modifyingText.get(cursorLocLine).substring(cursorLocRow);\n            modifyingText.add(cursorLocLine, modifyingText.get(cursorLocLine).substring(0, cursorLocRow - 1));\n        }\n    }\n\n    private static void editY() {\n        if(buffer.equals(\"\\n\")) {\n            String movingText = modifyingText.get(cursorLocLine).substring(cursorLocRow);\n            modifyingText.add(cursorLocLine, modifyingText.get(cursorLocLine).substring(0, cursorLocRow-1));\n            for( int i = modifyingText.size(); i != cursorLocLine; i-- ){\n                if(modifyingText.get(cursorLocLine) != null)\n                    modifyingText.add(cursorLocLine + 1, modifyingText.get(cursorLocLine));\n            }\n            cursorLocLine++;\n            cursorLocRow = 0;\n        }else if (buffer != null){\n            modifyingText.add(cursorLocLine, insert(modifyingText.get(cursorLocLine), cursorLocRow));\n        }\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\n\nimport java.util.*;\nimport java.math.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.math.BigInteger.*;\nimport static java.lang.Character.*;\n\nclass AOJ1021 {\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t// while (sc.hasNext()) {\n\t\tList<StringBuilder> lb = new ArrayList<StringBuilder>();\n\t\twhile (true) {\n\t\t\tString s = sc.nextLine();\n\t\t\tif (s.equals(\"END_OF_TEXT\"))\n\t\t\t\tbreak;\n\t\t\tlb.add(new StringBuilder(s));\n\t\t}\n\t\tint cur = 0, line = 0;\n\t\tStringBuilder buf = new StringBuilder();\n\t\tloop: while (true) {\n\t\t\tchar c = sc.nextLine().charAt(0);\n\t\t\tswitch (c) {\n\t\t\tcase '-':\n\t\t\t\tbreak loop;\n\t\t\tcase 'a':\n\t\t\t\tcur = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tcur = lb.get(line).length();\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tcur = 0;\n\t\t\t\tline = max(line - 1, 0);\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tcur = 0;\n\t\t\t\tline = min(line + 1, lb.size() - 1);\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (cur < lb.get(line).length())\n\t\t\t\t\tcur++;\n\t\t\t\telse if (line < lb.size() - 1) {\n\t\t\t\t\tcur = 0;\n\t\t\t\t\tline++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tif (cur > 0)\n\t\t\t\t\tcur--;\n\t\t\t\telse if (line > 0) {\n\t\t\t\t\tline--;\n\t\t\t\t\tcur = lb.get(line).length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif (cur < lb.get(line).length())\n\t\t\t\t\tlb.get(line).deleteCharAt(cur);\n\t\t\t\telse if (line < lb.size() - 1) {\n\t\t\t\t\tlb.get(line).append(lb.get(line + 1));\n\t\t\t\t\tlb.remove(line + 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tif (cur < lb.get(line).length()) {\n\t\t\t\t\tbuf = new StringBuilder(lb.get(line).substring(cur));\n\t\t\t\t\tlb.get(line).delete(cur, lb.get(line).length());\n\t\t\t\t} else if (line < lb.size() - 1) {\n\t\t\t\t\tlb.get(line).append(lb.get(line + 1));\n\t\t\t\t\tlb.remove(line + 1);\n\t\t\t\t\tbuf = null;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\tif (buf == null) {\n\t\t\t\t\tif (cur < lb.get(line).length()) {\n\t\t\t\t\t\tlb.add(line + 1, new StringBuilder(lb.get(line).substring(cur)));\n\t\t\t\t\t\tlb.get(line).delete(cur, lb.get(line).length());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlb.add(line + 1, new StringBuilder());\n\t\t\t\t\t}\n\t\t\t\t\tline++;\n\t\t\t\t\tcur = 0;\n\t\t\t\t} else {\n\t\t\t\t\tlb.get(line).insert(cur, buf);\n\t\t\t\t\tcur += buf.length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (StringBuilder sb : lb)\n\t\t\tSystem.out.println(sb);\n\t\t// }\n\t}\n}\n\npublic class Main {\n\tpublic static void main(String... args) {\n\t\tnew AOJ1021().run();\n\t}\n\n\tpublic static void debug(Object... os) {\n\t\tSystem.err.println(java.util.Arrays.deepToString(os));\n\t}\n}\n\nclass Scanner {\n\tfinal java.util.Scanner sc;\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(sc.next());\n\t}\n\n\tpublic Scanner(java.io.InputStream is) {\n\t\tthis.sc = new java.util.Scanner(is);\n\t}\n\n\tpublic boolean hasNext() {\n\t\treturn sc.hasNext();\n\t}\n\n\tpublic String next() {\n\t\treturn sc.next();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(sc.next());\n\t}\n\n\tpublic String nextLine() {\n\t\treturn sc.nextLine();\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(sc.next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO ツ篠ゥツ督ョツ青カツ青ャツつウツづェツつスツδソツッツドツ・ツスツタツブ\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tArrayList<String> str = new ArrayList<String>();\n\t\tArrayList<Character> command = new ArrayList<Character>();\n\t\tString buf;\n\t\tint x=0, y=0;\n\n\n\t\twhile(true){\n\t\t\tbuf = sc.nextLine();\n\t\t\tif(buf.equals(\"END_OF_TEXT\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstr.add(buf);\n\t\t}\n\t\twhile(true){\n\t\t\tbuf = sc.next();\n\t\t\tif(buf.charAt(0) == '-'){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcommand.add(buf.charAt(0));\n\t\t}\n\t\tbuf = \"\";\n\n\t\tfor(int i=0;i<command.size();i++){\n\t\t\tswitch(command.get(i)){\n\t\t\tcase 'a'://ok\n\t\t\t\tx=0;\n\t\t\t\tbreak;\n\n\t\t\tcase 'e'://ok\n\t\t\t\tx=str.get(y).length();\n\t\t\t\tbreak;\n\n\t\t\tcase 'p'://ok\n\t\t\t\tif(y!=0){\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t\tx=0;\n\t\t\t\tbreak;\n\n\t\t\tcase 'n'://ok\n\t\t\t\tif(str.size() != y+1){\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tx=0;\n\t\t\t\tbreak;\n\n\t\t\tcase 'f'://ok\n\t\t\t\tif(str.get(y).length() != x){\n\t\t\t\t\tx++;\n\t\t\t\t}else if(str.size() != y+1){\n\t\t\t\t\ty++;\n\t\t\t\t\tx=0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'b'://ok\n\t\t\t\tif(x!=0){\n\t\t\t\t\tx--;\n\t\t\t\t}else if(y!=0){\n\t\t\t\t\ty--;\n\t\t\t\t\tx=str.get(y).length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'd'://ok\n\t\t\t\tif(x!=str.get(y).length()){\n\t\t\t\t\tchar[] strbuf = str.get(y).toCharArray();\n\t\t\t\t\tString resultbuf = \"\";\n\t\t\t\t\tfor(int j=0;j<strbuf.length;j++){\n\t\t\t\t\t\tif(x!=j){\n\t\t\t\t\t\t\tresultbuf += strbuf[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstr.set(y,resultbuf);\n\t\t\t\t}else if(str.size() != y+1){\n\t\t\t\t\tstr.set(y, str.get(y)+str.get(y+1));\n\t\t\t\t\tstr.remove(y+1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'k'://ok\n\t\t\t\tif(x!=str.get(y).length()){\n\t\t\t\t\tchar[] strbuf = str.get(y).toCharArray();\n\t\t\t\t\tString resultbuf = \"\";\n\t\t\t\t\tbuf = \"\";\n\t\t\t\t\tfor(int j=0;j<strbuf.length;j++){\n\t\t\t\t\t\tif(x>j){\n\t\t\t\t\t\t\tresultbuf += strbuf[j];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf += strbuf[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstr.set(y,resultbuf);\n\t\t\t\t\tx = str.get(y).length();\n\t\t\t\t}else if(str.size() != y+1){\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t\tstr.set(y, str.get(y)+str.get(y+1));\n\t\t\t\t\tstr.remove(y+1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'y':\n\t\t\t\tif(buf.equals(\"\\n\")){\n\t\t\t\t\tchar[] strbuf = str.get(y).toCharArray();\n\t\t\t\t\tString resultbuf = \"\";\n\t\t\t\t\tbuf = \"\";\n\t\t\t\t\tfor(int j=0;j<strbuf.length;j++){\n\t\t\t\t\t\tif(x>j){\n\t\t\t\t\t\t\tresultbuf += strbuf[j];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf += strbuf[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstr.set(y,resultbuf);\n\t\t\t\t\tstr.add(y+1,buf);\n\n\t\t\t\t\tbuf=\"\\n\";\n\t\t\t\t}else if(buf.length() != 0){\n\t\t\t\t\tchar[] strbuf = str.get(y).toCharArray();\n\t\t\t\t\tString resultbuf = \"\";\n\t\t\t\t\tfor(int j=0;j<=strbuf.length;j++){\n\t\t\t\t\t\tif(x==j){\n\t\t\t\t\t\t\tresultbuf += buf;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j!=strbuf.length){\n\t\t\t\t\t\t\tresultbuf += strbuf[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstr.set(y, resultbuf);\n\t\t\t\t\tx+=buf.length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<str.size();i++){\n\t\t\tSystem.out.println(str.get(i));\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static ArrayList<String> modifyingText = new ArrayList<String>();\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        String inputText[];\n        String inputCommand[];\n\n        inputText = giveTextLine();\n        inputCommand = giveCommand();\n        modifyText(inputText, inputCommand);\n\n        for(int i = 0; i < modifyingText.size(); i++){\n            System.out.println(modifyingText.get(i));\n        }\n    }\n\n    private static String[] giveTextLine() {\n        String input;\n        String[] inputText = new String[MAXINPUTLINE];\n        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = String.valueOf(scan.next());\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText[i] = input;\n        }\n        return inputText;\n    }\n\n    private static String[] giveCommand() {\n        String input;\n        String[] inputCommand = new String[MAXINPUTCOMMAND];\n        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = String.valueOf(scan.next());\n            if (input.equals(\"-\")) break;\n            inputCommand[i] = input;\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final String inputText[], final String inputCommand[]) {\n\n        for (int i = 0; i < inputText.length; i++) {\n            modifyingText.add(i, inputText[i]);\n        }\n\n        for (int i = 0; i < inputCommand.length; i++) {\n            if (inputCommand[i].equals(\"a\")) editA();\n            else if (inputCommand[i].equals(\"e\")) editE();\n            else if (inputCommand[i].equals(\"p\")) editP();\n            else if (inputCommand[i].equals(\"n\")) editN();\n            else if (inputCommand[i].equals(\"f\")) editF();\n            else if (inputCommand[i].equals(\"b\")) editB();\n            else if (inputCommand[i].equals(\"d\")) editD();\n            else if (inputCommand[i].equals(\"k\")) editK();\n            else if (inputCommand[i].equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        return str.substring(0, removeIndex) + str.substring(removeIndex + 1);\n    }\n\n    private static String insert(String str, int insertIndex) {\n        return str.substring(0, insertIndex) + buffer + str.substring(insertIndex);\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = modifyingText.get(cursorLocLine).length();\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (modifyingText.get(cursorLocLine + 1) != null) cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (modifyingText.get(cursorLocLine).length() == cursorLocRow + 1) {\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else {\n            cursorLocRow = modifyingText.get(cursorLocLine - 1).length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n        if (cursorLocRow != modifyingText.get(cursorLocLine).length() - 1) {\n            modifyingText.add(cursorLocLine, remove(modifyingText.get(cursorLocLine), cursorLocRow));\n        } else if (modifyingText.get(cursorLocLine + 1) != null) {\n            for (int i = cursorLocLine; i < modifyingText.size(); i++) {\n                if (modifyingText.get(i + 1) == null) break;\n                modifyingText.add(i, modifyingText.get(i) + modifyingText.get(i + 1));\n            }\n        }\n\n    }\n\n    private static void editK() {\n        if (cursorLocRow == modifyingText.get(cursorLocLine).length() - 1 && modifyingText.get(cursorLocLine + 1) != null) {\n            for (int i = cursorLocLine; i < modifyingText.size(); i++) {\n                if (modifyingText.get(i + 1) == null) break;\n                modifyingText.add(i, modifyingText.get(i) + modifyingText.get(i + 1));\n            }\n            buffer = \"\\n\";\n        } else {\n            buffer = modifyingText.get(cursorLocLine).substring(cursorLocRow);\n            modifyingText.add(cursorLocLine, modifyingText.get(cursorLocLine).substring(0, cursorLocRow - 1));\n        }\n    }\n\n    private static void editY() {\n        if(buffer.equals(\"\\n\")) {\n            String movingText = modifyingText.get(cursorLocLine).substring(cursorLocRow);\n            modifyingText.add(cursorLocLine, modifyingText.get(cursorLocLine).substring(0, cursorLocRow-1));\n            for( int i = modifyingText.size(); i != cursorLocLine; i-- ){\n                if(modifyingText.get(cursorLocLine) != null)\n                    modifyingText.add(cursorLocLine + 1, modifyingText.get(cursorLocLine));\n            }\n            cursorLocLine++;\n            cursorLocRow = 0;\n        }else if (buffer != null){\n            modifyingText.add(cursorLocLine, insert(modifyingText.get(cursorLocLine), cursorLocRow));\n        }\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class EditText {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static Scanner scan = new Scanner(System.in);\n    static ArrayList<String> modifyingText = new ArrayList<String>();\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        ArrayList<String> inputText;\n        ArrayList<String> inputCommand;\n\n        inputText = giveTextLine();\n        System.out.println(\"==============================\");\n        System.out.println(\"give Text Success\");\n\n        inputCommand = giveCommand();\n\n        System.out.println(\"==============================\");\n        System.out.println(\"give Command Success\");\n        modifyText(inputText, inputCommand);\n\n        for (int i = 0; i < modifyingText.size(); i++) {\n            int outLen = modifyingText.get(i).length();\n            System.out.println(modifyingText.get(i).substring(0,outLen-1));\n        }\n    }\n\n    private static ArrayList<String> giveTextLine() {\n        String input;\n        ArrayList<String> inputText = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText.add(i, input);\n        }\n        return inputText;\n    }\n\n    private static ArrayList<String> giveCommand() {\n        String input;\n        ArrayList<String> inputCommand = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"-\")) break;\n            inputCommand.add(i, input);\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final ArrayList<String> inputText, final ArrayList<String> inputCommand) {\n\n        for (int i = 0; i < inputText.size(); i++) {\n            modifyingText.add(i, inputText.get(i) + \"$\");\n        }\n\n        for (int i = 0; i < inputCommand.size(); i++) {\n            System.out.println(\"===============================\");\n            System.out.println(inputCommand.get(i) + \" \" + cursorLocRow + \" \" + cursorLocLine + \" \" + modifyingText.get(cursorLocLine).length() + \" \" + buffer);\n            System.out.println(\"===============================\");\n            modifyingText.forEach(System.out::println);\n\n            if (inputCommand.get(i).equals(\"a\")) editA();\n            else if (inputCommand.get(i).equals(\"e\")) editE();\n            else if (inputCommand.get(i).equals(\"p\")) editP();\n            else if (inputCommand.get(i).equals(\"n\")) editN();\n            else if (inputCommand.get(i).equals(\"f\")) editF();\n            else if (inputCommand.get(i).equals(\"b\")) editB();\n            else if (inputCommand.get(i).equals(\"d\")) editD();\n            else if (inputCommand.get(i).equals(\"k\")) editK();\n            else if (inputCommand.get(i).equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        StringBuilder builder = new StringBuilder(str);\n        return builder.deleteCharAt(removeIndex).toString();\n//        return str.substring(0, removeIndex) + str.substring(removeIndex + 1);\n    }\n\n    private static String insert(String str, int insertIndex) {\n//        return str.substring(0, insertIndex) + buffer + str.substring(insertIndex);\n        StringBuilder builder = new StringBuilder(str);\n\n        if (builder.length() <= insertIndex) {\n            return builder.append(buffer).toString();\n        } else {\n            return builder.insert(insertIndex, buffer).toString();\n        }\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = modifyingText.get(cursorLocLine).length() - 1;\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (modifyingText.size() <= cursorLocLine + 1) return;\n\n        if (modifyingText.get(cursorLocLine + 1) != null) cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (modifyingText.get(cursorLocLine).length() == cursorLocRow + 1) {\n            if (modifyingText.size() <= cursorLocLine + 1) return;\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else if (cursorLocLine > 0) {\n            cursorLocRow = modifyingText.get(cursorLocLine - 1).length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n//        if (cursorLocRow != modifyingText.get(cursorLocLine).length() - 1) {\n        modifyingText.set(cursorLocLine, remove(modifyingText.get(cursorLocLine), cursorLocRow));\n\n//        } else if (modifyingText.get(cursorLocLine + 1) != null) {\n\n        if (modifyingText.get(cursorLocLine).length() == cursorLocRow) {\n            for (int i = cursorLocLine; i < modifyingText.size(); i++) {\n                if(modifyingText.size() >= i + 1) break;\n//                if (modifyingText.get(i + 1) == null) break;\n                modifyingText.add(i, modifyingText.get(i) + modifyingText.get(i + 1));\n            }\n        }\n    }\n\n    private static void editK() {\n        if (cursorLocRow == modifyingText.get(cursorLocLine).length() - 1 && modifyingText.size() <= cursorLocLine + 1) {\n            for (int i = cursorLocLine; i < modifyingText.size(); i++) {\n                if (modifyingText.size() <= cursorLocLine + 1) break;\n                modifyingText.add(i, modifyingText.get(i) + modifyingText.get(i + 1));\n            }\n            if(cursorLocLine != modifyingText.size() - 1) buffer = \"\\n\";\n        } else {\n            if (cursorLocRow < 0) return;\n\n            buffer = modifyingText.get(cursorLocLine).substring(cursorLocRow, modifyingText.get(cursorLocLine).length() - 1);\n            if(cursorLocRow == 0) modifyingText.set(cursorLocLine, \"$\");\n            else modifyingText.add(cursorLocLine, modifyingText.get(cursorLocLine).substring(0, cursorLocRow - 1));\n        }\n    }\n\n    private static void editY() {\n        if (buffer != null) {\n            if (buffer.equals(\"\\n\")) {\n\n                String movingText = modifyingText.get(cursorLocLine).substring(cursorLocRow);\n\n                if (cursorLocRow != 0) {\n                    modifyingText.add(cursorLocLine, modifyingText.get(cursorLocLine).substring(0, cursorLocRow - 1));\n                }\n\n                modifyingText.add(\"\");\n                for (int i = modifyingText.size() - 1; i != cursorLocLine; i--) {\n                    modifyingText.set(i, modifyingText.get(i - 1));\n                }\n                modifyingText.add(cursorLocLine + 1, movingText);\n                cursorLocLine++;\n                cursorLocRow = 0;\n            } else {\n                modifyingText.set(cursorLocLine, insert(modifyingText.get(cursorLocLine), cursorLocRow));\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.xml.crypto.Data;\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tStringBuilder[] sb = new StringBuilder[1000];\n\t\tfor(int i = 0; i < sb.length; i++) {\n\t\t\tsb[i] = new StringBuilder();\n\t\t}\n\t\tint len = 0;\n\t\twhile(true) {\n\t\t\tString in = sc.nextLine();\n\t\t\tif(in.equals(\"END_OF_TEXT\")) break;\n\t\t\tsb[len++].append(in);\n\t\t}\n\t\tboolean LF = false;\n\t\tStringBuilder buffer = new StringBuilder();\n\t\tint ci = 0;\n\t\tint cj = 0;\n\t\twhile(true) {\n\t\t\tString in = sc.nextLine();\n\t\t\tif(in.equals(\"-\")) break;\n\t\t\tif(in.equals(\"a\")) {\n\t\t\t\tcj = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"e\")) {\n\t\t\t\tcj = sb[ci].length();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"p\")) {\n\t\t\t\tif(ci != 0) {\n\t\t\t\t\tci--;\n\t\t\t\t}\n\t\t\t\tcj = 0;\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"n\")) {\n\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\tci++;\n\t\t\t\t}\n\t\t\t\tcj = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"f\")) {\n\t\t\t\tif(cj != sb[ci].length()) {\n\t\t\t\t\tcj++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\tcj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"b\")) {\n\t\t\t\tif(cj != 0) {\n\t\t\t\t\tcj--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci != 0) {\n\t\t\t\t\t\tci--;\n\t\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(in.equals(\"d\")) {\n\t\t\t\tif(cj != sb[ci].length()) {\n\t\t\t\t\tsb[ci].deleteCharAt(cj);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tsb[ci].append(sb[ci+1]);\n\t\t\t\t\t\tint now = ci+1;\n\t\t\t\t\t\twhile(now+1 != len) {\n\t\t\t\t\t\t\tsb[now] = sb[now+1];\n\t\t\t\t\t\t\tnow++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"k\")) {\n\t\t\t\tif(cj == sb[ci].length()) {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tsb[ci].append(sb[ci+1]);\n\t\t\t\t\t\tint now = ci+1;\n\t\t\t\t\t\twhile(now+1 != len) {\n\t\t\t\t\t\t\tsb[now] = sb[now+1];\n\t\t\t\t\t\t\tnow++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t\tbuffer = new StringBuilder();\n\t\t\t\t\tLF = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = new StringBuilder(sb[ci].substring(cj, sb[ci].length()));\n\t\t\t\t\tsb[ci].delete(cj, sb[ci].length());\n\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\tLF = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"y\")) {\n\t\t\t\tif(LF) {\n\t\t\t\t\tint now = len;\n\t\t\t\t\twhile(now != ci) {\n\t\t\t\t\t\tsb[now] = sb[now-1];\n\t\t\t\t\t\tnow--;\n\t\t\t\t\t}\n\t\t\t\t\tlen++;\n\t\t\t\t\tsb[ci+1] = new StringBuilder(sb[ci].substring(cj,sb[ci].length()));\n\t\t\t\t\tsb[ci].delete(cj, sb[ci].length());\n\t\t\t\t\tci++;\n\t\t\t\t\tcj = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(cj == sb[ci].length()) {\n\t\t\t\t\t\tsb[ci].insert(cj, buffer);\n\t\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsb[ci].insert(cj, buffer);\n\t\t\t\t\t\tcj += buffer.length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < len; i++) {\n\t\t\tSystem.out.println(sb[i].toString());\n\t\t}\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.xml.crypto.Data;\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tStringBuilder[] sb = new StringBuilder[101];\n\t\tfor(int i = 0; i < sb.length; i++) {\n\t\t\tsb[i] = new StringBuilder();\n\t\t}\n\t\tint len = 0;\n\t\twhile(true) {\n\t\t\tString in = sc.nextLine();\n\t\t\tif(in.equals(\"END_OF_TEXT\")) break;\n\t\t\tsb[len++].append(in);\n\t\t}\n\t\tboolean LF = false;\n\t\tStringBuilder buffer = new StringBuilder();\n\t\tint ci = 0;\n\t\tint cj = 0;\n\t\twhile(true) {\n\t\t\tString in = sc.nextLine();\n\t\t\tif(in.equals(\"-\")) break;\n\t\t\tif(in.equals(\"a\")) {\n\t\t\t\tcj = 0;\n\t\t\t}\n\t\t\tif(in.equals(\"e\")) {\n\t\t\t\tcj = sb[ci].length();\n\t\t\t}\n\t\t\tif(in.equals(\"p\")) {\n\t\t\t\tif(ci != 0) {\n\t\t\t\t\tci--;\n\t\t\t\t}\n\t\t\t\tcj = 0;\t\n\t\t\t}\n\t\t\tif(in.equals(\"n\")) {\n\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\tci++;\n\t\t\t\t}\n\t\t\t\tcj = 0;\n\t\t\t}\n\t\t\tif(in.equals(\"f\")) {\n\t\t\t\tif(cj != sb[ci].length()) {\n\t\t\t\t\tcj++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\tcj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"b\")) {\n\t\t\t\tif(cj != 0) {\n\t\t\t\t\tcj--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci != 0) {\n\t\t\t\t\t\tci--;\n\t\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"d\")) {\n\t\t\t\tif(cj != sb[ci].length()) {\n\t\t\t\t\tsb[ci].deleteCharAt(cj);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tsb[ci].append(sb[ci+1]);\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\twhile(ci+1 != len) {\n\t\t\t\t\t\t\tsb[ci] = sb[ci+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"k\")) {\n\t\t\t\tif(cj == sb[ci].length()) {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tsb[ci].append(sb[ci+1]);\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\twhile(ci+1 != len) {\n\t\t\t\t\t\t\tsb[ci] = sb[ci+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t\tbuffer = new StringBuilder();\n\t\t\t\t\tLF = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = new StringBuilder(sb[ci].substring(cj, sb[ci].length()));\n\t\t\t\t\tsb[ci].delete(cj, sb[ci].length());\n\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\tLF = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"y\")) {\n\t\t\t\tif(LF) {\n\t\t\t\t\tint now = len;\n\t\t\t\t\twhile(now != ci) {\n\t\t\t\t\t\tsb[now] = sb[now-1];\n\t\t\t\t\t}\n\t\t\t\t\tlen++;\n\t\t\t\t\tsb[ci+1] = new StringBuilder(sb[ci].substring(cj,sb[ci].length()));\n\t\t\t\t\tsb[ci].delete(cj, sb[ci].length());\n\t\t\t\t\tci++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(cj == sb[ci].length()) {\n\t\t\t\t\t\tsb[ci].insert(cj, buffer);\n\t\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsb[ci].insert(cj, buffer);\n\t\t\t\t\t\tcj += buffer.length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 1000; i++) {\n\t\t\tSystem.out.println(sb[i].toString());\n\t\t}\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Emacs {\n    \n    String buffer;\n    int cursorX;\n    int cursorY;\n    ArrayList<String> body;\n\n    Emacs(ArrayList<String> body) {\n        this.buffer = \"\";\n        this.cursorX = 1;\n        this.cursorY = 1;\n        this.body = body;\n    }\n\n    void acceptCommand(char c) {\n        switch (c) {\n            case 'a':\n                this.moveCursorMostLeft();\n                break;\n            case 'e':\n                this.moveCursorMostRight();\n                break;\n            case 'p':\n                this.moveCursorUp();\n                this.moveCursorMostLeft();\n                break;\n            case 'n':\n                this.moveCursorDown();\n                this.moveCursorMostLeft();\n                break;\n            case 'f':\n                this.moveCursorForward();\n                break;\n            case 'b':\n                this.moveCursorBackward();\n                break;\n            case 'd':\n                this.deleteChar();\n                break;\n            case 'k':\n                this.killChar();\n                break;\n            case 'y':\n                this.yankBuffer();\n                break;\n        }\n    }\n\n    void yankBuffer() {\n        String cl = this.getCurrentLine();\n        if (this.buffer.equals(\"\")) {\n            return;\n        } else if (this.buffer.equals(\"!\")) {\n            this.body.add(this.body.get(this.body.size() - 1));\n            for(int i = this.body.size() - 1; i >= this.cursorY + 1; i--) {\n                this.body.set(i, this.body.get(i - 1));\n            }\n            this.body.set(this.cursorY, cl.substring(this.cursorX - 1, cl.length()));\n            this.body.set(this.cursorY - 1, cl.substring(0, this.cursorX - 1));\n            this.cursorY += 1;\n            this.moveCursorMostLeft();\n        } else {\n            this.body.set(this.cursorY - 1, cl.substring(0, this.cursorX - 1) + this.buffer + cl.substring(this.cursorX - 1, cl.length()));\n            this.cursorX += this.buffer.length();\n        }\n    }\n\n    void deleteChar() {\n\n        String cl = this.getCurrentLine();\n\n        if (this.cursorX <= cl.length()) {\n            String tmp1 = cl.substring(0, this.cursorX - 1);\n            String tmp2 = cl.substring(this.cursorX,  cl.length());\n            this.body.set(this.cursorY - 1, tmp1 + tmp2);\n        } else if (this.cursorY < body.size()) {\n            this.body.set(this.cursorY - 1, cl + this.body.get(this.cursorY));\n            for(int i = this.cursorY; i < this.body.size() - 1; i++) {\n                this.body.set(i, this.body.get(i+1));\n            }\n            this.body.remove(this.body.size() - 1);\n        }\n    }\n\n    void killChar() {\n        String cl = this.getCurrentLine();\n\n        if (this.cursorX <= cl.length()) {\n            this.buffer = cl.substring(this.cursorX - 1, cl.length());\n            this.body.set(this.cursorY - 1, cl.substring(0, this.cursorX - 1));\n        } else {\n            this.buffer = \"!\";\n            this.deleteChar();\n        }\n    }\n\n    void moveCursorForward() {\n        if (this.cursorX <= this.getCurrentLine().length()) {\n            this.cursorX += 1;\n        } else if (this.cursorY < body.size()) {\n            this.cursorY += 1;\n            this.moveCursorMostLeft();\n        }\n    }\n\n    void moveCursorBackward() {\n        if (this.cursorX > 1) {\n            this.cursorX -= 1;\n        } else if (this.cursorY > 1) {\n            this.cursorY -= 1;\n            this.moveCursorMostRight();\n        }\n    }\n\n    void moveCursorMostLeft() {\n        this.cursorX = 1;\n    }\n\n    void moveCursorMostRight() {\n        this.cursorX = body.get(cursorY - 1).length() + 1;\n    }\n\n    void moveCursorUp() {\n        if(this.cursorY > 1)    this.cursorY -= 1;\n    }\n\n    void moveCursorDown() {\n        if(this.cursorY < body.size())  this.cursorY += 1;\n    }\n\n    void printBody() {\n        // System.out.printf(\"Cursor: (%d, %d)\\n\", this.cursorX, this.cursorY);\n        // System.out.printf(\"Buffer: %s\\n\",   this.buffer);\n        for (String line : this.body) {\n            System.out.println(line);\n        }\n    }\n\n    String getCurrentLine() {\n        return this.body.get(this.cursorY - 1);\n    }\n\n}\n\nclass Main {\n\n    public static void main (String [] args) {\n\n        Scanner sc = new Scanner(System.in);\n        ArrayList<String> lines = new ArrayList<String>();\n\n        while (true) {\n            String line = sc.nextLine();\n            if (line.equals(\"END_OF_TEXT\")) break;\n            lines.add(line);\n        }\n\n        Emacs emacs = new Emacs(lines);\n\n        while (true) {\n            char c = sc.nextLine().charAt(0);\n            if(c == '-')    break;\n            emacs.acceptCommand(c); \n        }\n\n        emacs.printBody();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\n\nimport java.util.*;\nimport java.math.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.math.BigInteger.*;\nimport static java.lang.Character.*;\n\nclass AOJ1021 {\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t// while (sc.hasNext()) {\n\t\tList<StringBuilder> lb = new ArrayList<StringBuilder>();\n\t\twhile (true) {\n\t\t\tString s = sc.nextLine();\n\t\t\tif (s.equals(\"END_OF_TEXT\"))\n\t\t\t\tbreak;\n\t\t\tlb.add(new StringBuilder(s));\n\t\t}\n\t\tint cur = 0, line = 0;\n\t\tStringBuilder buf = new StringBuilder();\n\t\tloop: while (true) {\n\t\t\tchar c = sc.nextLine().charAt(0);\n\t\t\tswitch (c) {\n\t\t\tcase '-':\n\t\t\t\tbreak loop;\n\t\t\tcase 'a':\n\t\t\t\tcur = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tcur = lb.get(line).length();\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tcur = 0;\n\t\t\t\tline = max(line - 1, 0);\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tcur = 0;\n\t\t\t\tline = min(line + 1, lb.size());\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (cur < lb.get(line).length())\n\t\t\t\t\tcur++;\n\t\t\t\telse if (line < lb.size() - 1) {\n\t\t\t\t\tcur = 0;\n\t\t\t\t\tline++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tif (cur > 0)\n\t\t\t\t\tcur--;\n\t\t\t\telse if (line > 0) {\n\t\t\t\t\tline--;\n\t\t\t\t\tcur = lb.get(line).length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif (cur < lb.get(line).length())\n\t\t\t\t\tlb.get(line).deleteCharAt(cur);\n\t\t\t\telse if (line < lb.size()) {\n\t\t\t\t\tlb.get(line).append(lb.get(line + 1));\n\t\t\t\t\tlb.remove(line);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tif (cur < lb.get(line).length()) {\n\t\t\t\t\tbuf = new StringBuilder(lb.get(line).substring(cur));\n\t\t\t\t\tlb.get(line).delete(cur, lb.get(line).length());\n\t\t\t\t} else if (line < lb.size()) {\n\t\t\t\t\tlb.get(line).append(lb.get(line + 1));\n\t\t\t\t\tlb.remove(line);\n\t\t\t\t\tbuf = null;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\tif (buf == null) {\n\t\t\t\t\tlb.add(line + 1, new StringBuilder(lb.get(line).substring(cur)));\n\t\t\t\t\tlb.get(line).delete(cur, lb.get(line).length());\n\t\t\t\t\tline++;\n\t\t\t\t\tcur = 0;\n\t\t\t\t} else {\n\t\t\t\t\tlb.get(line).insert(cur, buf);\n\t\t\t\t\tcur += buf.length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (StringBuilder sb : lb)\n\t\t\tSystem.out.println(sb);\n\t\t// }\n\t}\n}\n\npublic class Main {\n\tpublic static void main(String... args) {\n\t\tnew AOJ1021().run();\n\t}\n\n\tpublic static void debug(Object... os) {\n\t\tSystem.err.println(java.util.Arrays.deepToString(os));\n\t}\n}\n\nclass Scanner {\n\tfinal java.util.Scanner sc;\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(sc.next());\n\t}\n\n\tpublic Scanner(java.io.InputStream is) {\n\t\tthis.sc = new java.util.Scanner(is);\n\t}\n\n\tpublic boolean hasNext() {\n\t\treturn sc.hasNext();\n\t}\n\n\tpublic String next() {\n\t\treturn sc.next();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(sc.next());\n\t}\n\n\tpublic String nextLine() {\n\t\treturn sc.nextLine();\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(sc.next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static String[] modifyingText = new String[MAXMODIFIEDTEXTLINE];\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        String inputText[];\n        String inputCommand[];\n\n        inputText = giveTextLine();\n        inputCommand = giveCommand();\n        modifyText(inputText, inputCommand);\n\n        for(int i = 0; i < modifyingText.length; i++){\n            System.out.println(modifyingText[i]);\n        }\n    }\n\n    private static String[] giveTextLine() {\n        String input;\n        String[] inputText = new String[MAXINPUTLINE];\n        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText[i] = input;\n        }\n        return inputText;\n    }\n\n    private static String[] giveCommand() {\n        String input;\n        String[] inputCommand = new String[MAXINPUTCOMMAND];\n        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"-\")) break;\n            inputCommand[i] = input;\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final String inputText[], final String inputCommand[]) {\n\n        for (int i = 0; i < inputText.length; i++) {\n            modifyingText[i] = inputText[i];\n        }\n\n        for (int i = 0; i < inputCommand.length; i++) {\n            if (inputCommand[i].equals(\"a\")) editA();\n            else if (inputCommand[i].equals(\"e\")) editE();\n            else if (inputCommand[i].equals(\"p\")) editP();\n            else if (inputCommand[i].equals(\"n\")) editN();\n            else if (inputCommand[i].equals(\"f\")) editF();\n            else if (inputCommand[i].equals(\"b\")) editB();\n            else if (inputCommand[i].equals(\"d\")) editD();\n            else if (inputCommand[i].equals(\"k\")) editK();\n            else if (inputCommand[i].equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        return str.substring(0, removeIndex) + str.substring(removeIndex + 1);\n    }\n\n    private static String insert(String str, int insertIndex) {\n        return str.substring(0, insertIndex) + buffer + str.substring(insertIndex);\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = modifyingText[cursorLocLine].length();\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (modifyingText[cursorLocLine + 1] != null) cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (modifyingText[cursorLocLine].length() == cursorLocRow + 1) {\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else {\n            cursorLocRow = modifyingText[cursorLocLine - 1].length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n        if (cursorLocRow != modifyingText[cursorLocLine].length() - 1) {\n            modifyingText[cursorLocLine] = remove(modifyingText[cursorLocLine], cursorLocRow);\n        } else if (modifyingText[cursorLocLine + 1] != null) {\n            for (int i = cursorLocLine; i < modifyingText.length; i++) {\n                if (modifyingText[i + 1] == null) break;\n                modifyingText[i] += modifyingText[i + 1];\n            }\n        }\n\n    }\n\n    private static void editK() {\n        if (cursorLocRow == modifyingText[cursorLocLine].length() - 1 && modifyingText[cursorLocLine + 1] != null) {\n            for (int i = cursorLocLine; i < modifyingText.length; i++) {\n                if (modifyingText[i + 1] == null) break;\n                modifyingText[i] += modifyingText[i + 1];\n            }\n            buffer = \"\\n\";\n        } else {\n            buffer = modifyingText[cursorLocLine].substring(cursorLocRow);\n            modifyingText[cursorLocLine] = modifyingText[cursorLocLine].substring(0, cursorLocRow - 1);\n        }\n    }\n\n    private static void editY() {\n        if(buffer.equals(\"\\n\")) {\n            String movingText = modifyingText[cursorLocLine].substring(cursorLocRow);\n            modifyingText[cursorLocLine] = modifyingText[cursorLocLine].substring(0, cursorLocRow-1);\n            for( int i = modifyingText.length; i != cursorLocLine; i-- ){\n                if(modifyingText[cursorLocLine] != null)\n                    modifyingText[cursorLocLine+1] = modifyingText[cursorLocLine];\n            }\n            cursorLocLine++;\n            cursorLocRow = 0;\n        }else if (buffer != null){\n            modifyingText[cursorLocLine] = insert(modifyingText[cursorLocLine], cursorLocRow);\n        }\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tArrayList<String> lines = new ArrayList<String>();\n\t\twhile (true) {\n\t\t\tString line = sc.nextLine();\n\t\t\tif (line.equals(\"END_OF_TEXT\")) break;\n\t\t\tlines.add(line);\n\t\t}\n\t\tString buffer = \"\";\n\t\tint r = 0;\n\t\tint c = 0;\n\t\twhile (true) {\n\t\t\tchar q = sc.next().charAt(0);\n\t\t\tif (q == '-') break;\n\t\t\tswitch (q) {\n\t\t\tcase 'a':\n\t\t\t\tc = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tc = lines.get(r).length();\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tc = 0;\n\t\t\t\tif (r > 0) --r;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tc = 0;\n\t\t\t\tif (r < lines.size() - 1) ++r;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (c < lines.get(r).length()) {\n\t\t\t\t\t++c;\n\t\t\t\t} else if (c == lines.get(r).length() && r < lines.size() - 1) {\n\t\t\t\t\tc = 0;\n\t\t\t\t\t++r;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tif (c > 0) {\n\t\t\t\t\t--c;\n\t\t\t\t} else if (c == 0 && r > 0) {\n\t\t\t\t\tc = lines.get(r - 1).length();\n\t\t\t\t\t--r;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif (c < lines.get(r).length()) {\n\t\t\t\t\tlines.set(r, lines.get(r).substring(0, c) + lines.get(r).substring(c + 1));\n\t\t\t\t} else if (c == lines.get(r).length() && r < lines.size() - 1) {\n\t\t\t\t\tlines.set(r, lines.get(r) + lines.get(r + 1));\n\t\t\t\t\tlines.remove(r + 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tif (c < lines.get(r).length()) {\n\t\t\t\t\tbuffer = lines.get(r).substring(c);\n\t\t\t\t\tlines.set(r, lines.get(r).substring(0, c));\n\t\t\t\t} else if (c == lines.get(r).length() && r < lines.size() - 1) {\n\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t\tlines.set(r, lines.get(r) + lines.get(r + 1));\n\t\t\t\t\tlines.remove(r + 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\tif (buffer.equals(\"\\n\")) {\n\t\t\t\t\tlines.add(r + 1, lines.get(r).substring(c));\n\t\t\t\t\tlines.set(r, lines.get(r).substring(0, c));\n\t\t\t\t\tc = 0;\n\t\t\t\t\t++r;\n\t\t\t\t} else if (buffer.length() > 0) {\n\t\t\t\t\tlines.set(r, lines.get(r).substring(0, c) + buffer + lines.get(r).substring(c));\n\t\t\t\t\tc += buffer.length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (String l : lines) {\n\t\t\tSystem.out.println(l);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tArrayList<String> lines = new ArrayList<String>();\n\t\twhile (true) {\n\t\t\tString line = sc.nextLine();\n\t\t\tif (line.equals(\"END_OF_TEXT\")) break;\n\t\t\tlines.add(line);\n\t\t}\n\t\tString buffer = \"\";\n\t\tint r = 0;\n\t\tint c = 0;\n\t\twhile (true) {\n\t\t\tchar q = sc.next().charAt(0);\n\t\t\tif (q == '-') break;\n\t\t\tswitch (q) {\n\t\t\tcase 'a':\n\t\t\t\tc = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tc = lines.get(r).length();\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tc = 0;\n\t\t\t\tif (r > 0) --r;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tc = 0;\n\t\t\t\tif (r < lines.size() - 1) ++r;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (c < lines.get(r).length()) {\n\t\t\t\t\t++c;\n\t\t\t\t} else if (c == lines.get(r).length() && r < lines.size() - 1) {\n\t\t\t\t\tc = 0;\n\t\t\t\t\t++r;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tif (c > 0) {\n\t\t\t\t\t--c;\n\t\t\t\t} else if (c == 0 && r > 0) {\n\t\t\t\t\tc = lines.get(r - 1).length();\n\t\t\t\t\t--r;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif (c < lines.get(r).length()) {\n\t\t\t\t\tlines.set(r, lines.get(r).substring(0, c) + lines.get(r).substring(c + 1));\n\t\t\t\t} else if (c == lines.get(r).length() && r < lines.size() - 1) {\n\t\t\t\t\tlines.set(r, lines.get(r) + lines.get(r + 1));\n\t\t\t\t\tlines.remove(r + 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tif (c < lines.get(r).length()) {\n\t\t\t\t\tbuffer = lines.get(r).substring(c);\n\t\t\t\t\tlines.set(r, lines.get(r).substring(0, c));\n\t\t\t\t} else if (c == lines.get(r).length() && r < lines.size() - 1) {\n\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t\tlines.set(r, lines.get(r) + lines.get(r + 1));\n\t\t\t\t\tlines.remove(r + 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\tif (buffer.equals(\"\\n\")) {\n\t\t\t\t\tlines.add(lines.get(r).substring(c));\n\t\t\t\t\tlines.set(r, lines.get(r).substring(0, c));\n\t\t\t\t\tc = 0;\n\t\t\t\t\t++r;\n\t\t\t\t} else if (buffer.length() > 0) {\n\t\t\t\t\tlines.set(r, lines.get(r).substring(0, c) + buffer + lines.get(r).substring(c));\n\t\t\t\t\tc += buffer.length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (String l : lines) {\n\t\t\tSystem.out.println(l);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static Scanner scan = new Scanner(System.in);\n    static ArrayList<String> modifyingText = new ArrayList<String>();\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        ArrayList<String> inputText;\n        ArrayList<String> inputCommand;\n\n        inputText = giveTextLine();\n        System.out.println(\"==============================\");\n        System.out.println(\"give Text Success\");\n\n        inputCommand = giveCommand();\n\n        System.out.println(\"==============================\");\n        System.out.println(\"give Command Success\");\n        modifyText(inputText, inputCommand);\n\n        for (int i = 0; i < modifyingText.size(); i++) {\n            int outLen = modifyingText.get(i).length();\n            System.out.println(modifyingText.get(i).substring(0,outLen-1));\n        }\n    }\n\n    private static ArrayList<String> giveTextLine() {\n        String input;\n        ArrayList<String> inputText = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText.add(i, input);\n        }\n        return inputText;\n    }\n\n    private static ArrayList<String> giveCommand() {\n        String input;\n        ArrayList<String> inputCommand = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"-\")) break;\n            inputCommand.add(i, input);\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final ArrayList<String> inputText, final ArrayList<String> inputCommand) {\n\n        for (int i = 0; i < inputText.size(); i++) {\n            modifyingText.add(i, inputText.get(i) + \"$\");\n        }\n\n        for (int i = 0; i < inputCommand.size(); i++) {\n            System.out.println(\"===============================\");\n            System.out.println(inputCommand.get(i) + \" \" + cursorLocRow + \" \" + cursorLocLine + \" \" + modifyingText.get(cursorLocLine).length() + \" \" + buffer);\n            System.out.println(\"===============================\");\n            modifyingText.forEach(System.out::println);\n\n            if (inputCommand.get(i).equals(\"a\")) editA();\n            else if (inputCommand.get(i).equals(\"e\")) editE();\n            else if (inputCommand.get(i).equals(\"p\")) editP();\n            else if (inputCommand.get(i).equals(\"n\")) editN();\n            else if (inputCommand.get(i).equals(\"f\")) editF();\n            else if (inputCommand.get(i).equals(\"b\")) editB();\n            else if (inputCommand.get(i).equals(\"d\")) editD();\n            else if (inputCommand.get(i).equals(\"k\")) editK();\n            else if (inputCommand.get(i).equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        StringBuilder builder = new StringBuilder(str);\n        return builder.deleteCharAt(removeIndex).toString();\n//        return str.substring(0, removeIndex) + str.substring(removeIndex + 1);\n    }\n\n    private static String insert(String str, int insertIndex) {\n//        return str.substring(0, insertIndex) + buffer + str.substring(insertIndex);\n        StringBuilder builder = new StringBuilder(str);\n\n        if (builder.length() <= insertIndex) {\n            return builder.append(buffer).toString();\n        } else {\n            return builder.insert(insertIndex, buffer).toString();\n        }\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = modifyingText.get(cursorLocLine).length() - 1;\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (modifyingText.size() <= cursorLocLine + 1) return;\n\n        if (modifyingText.get(cursorLocLine + 1) != null) cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (modifyingText.get(cursorLocLine).length() == cursorLocRow + 1) {\n            if (modifyingText.size() <= cursorLocLine + 1) return;\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else if (cursorLocLine > 0) {\n            cursorLocRow = modifyingText.get(cursorLocLine - 1).length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n//        if (cursorLocRow != modifyingText.get(cursorLocLine).length() - 1) {\n        modifyingText.set(cursorLocLine, remove(modifyingText.get(cursorLocLine), cursorLocRow));\n\n//        } else if (modifyingText.get(cursorLocLine + 1) != null) {\n\n        if (modifyingText.get(cursorLocLine).length() == cursorLocRow) {\n            for (int i = cursorLocLine; i < modifyingText.size(); i++) {\n                if(modifyingText.size() >= i + 1) break;\n//                if (modifyingText.get(i + 1) == null) break;\n                modifyingText.add(i, modifyingText.get(i) + modifyingText.get(i + 1));\n            }\n        }\n    }\n\n    private static void editK() {\n        if (cursorLocRow == modifyingText.get(cursorLocLine).length() - 1 && modifyingText.size() <= cursorLocLine + 1) {\n            for (int i = cursorLocLine; i < modifyingText.size(); i++) {\n                if (modifyingText.size() <= cursorLocLine + 1) break;\n                modifyingText.add(i, modifyingText.get(i) + modifyingText.get(i + 1));\n            }\n            if(cursorLocLine != modifyingText.size() - 1) buffer = \"\\n\";\n        } else {\n            if (cursorLocRow < 0) return;\n\n            buffer = modifyingText.get(cursorLocLine).substring(cursorLocRow, modifyingText.get(cursorLocLine).length() - 1);\n            if(cursorLocRow == 0) modifyingText.set(cursorLocLine, \"$\");\n            else modifyingText.add(cursorLocLine, modifyingText.get(cursorLocLine).substring(0, cursorLocRow - 1));\n        }\n    }\n\n    private static void editY() {\n        if (buffer != null) {\n            if (buffer.equals(\"\\n\")) {\n\n                String movingText = modifyingText.get(cursorLocLine).substring(cursorLocRow);\n\n                if (cursorLocRow != 0) {\n                    modifyingText.add(cursorLocLine, modifyingText.get(cursorLocLine).substring(0, cursorLocRow - 1));\n                }\n\n                modifyingText.add(\"\");\n                for (int i = modifyingText.size() - 1; i != cursorLocLine; i--) {\n                    modifyingText.set(i, modifyingText.get(i - 1));\n                }\n                modifyingText.add(cursorLocLine + 1, movingText);\n                cursorLocLine++;\n                cursorLocRow = 0;\n            } else {\n                modifyingText.set(cursorLocLine, insert(modifyingText.get(cursorLocLine), cursorLocRow));\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.xml.crypto.Data;\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tStringBuilder[] sb = new StringBuilder[101];\n\t\tfor(int i = 0; i < sb.length; i++) {\n\t\t\tsb[i] = new StringBuilder();\n\t\t}\n\t\tint len = 0;\n\t\twhile(true) {\n\t\t\tString in = sc.next();\n\t\t\tif(in.equals(\"END_OF_TEXT\")) break;\n\t\t\tsb[len++].append(in);\n\t\t}\n\t\tboolean LF = false;\n\t\tStringBuilder buffer = new StringBuilder();\n\t\tint ci = 0;\n\t\tint cj = 0;\n\t\twhile(true) {\n\t\t\tString in = sc.next();\n\t\t\tif(in.equals(\"-\")) break;\n\t\t\tif(in.equals(\"a\")) {\n\t\t\t\tcj = 0;\n\t\t\t}\n\t\t\tif(in.equals(\"e\")) {\n\t\t\t\tcj = sb[ci].length();\n\t\t\t}\n\t\t\tif(in.equals(\"p\")) {\n\t\t\t\tif(ci != 0) {\n\t\t\t\t\tci--;\n\t\t\t\t}\n\t\t\t\tcj = 0;\t\n\t\t\t}\n\t\t\tif(in.equals(\"n\")) {\n\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\tci++;\n\t\t\t\t}\n\t\t\t\tcj = 0;\n\t\t\t}\n\t\t\tif(in.equals(\"f\")) {\n\t\t\t\tif(cj != sb[ci].length()) {\n\t\t\t\t\tcj++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\tcj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"b\")) {\n\t\t\t\tif(cj != 0) {\n\t\t\t\t\tcj--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci != 0) {\n\t\t\t\t\t\tci--;\n\t\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"d\")) {\n\t\t\t\tif(cj != sb[ci].length()) {\n\t\t\t\t\tsb[ci].deleteCharAt(cj);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tsb[ci].append(sb[ci+1]);\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\twhile(ci+1 != len) {\n\t\t\t\t\t\t\tsb[ci] = sb[ci+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"k\")) {\n\t\t\t\tif(cj == sb[ci].length()) {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tsb[ci].append(sb[ci+1]);\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\twhile(ci+1 != len) {\n\t\t\t\t\t\t\tsb[ci] = sb[ci+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t\tbuffer = new StringBuilder();\n\t\t\t\t\tLF = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = new StringBuilder(sb[ci].substring(cj, sb[ci].length()));\n\t\t\t\t\tsb[ci].delete(cj, sb[ci].length());\n\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\tLF = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"y\")) {\n\t\t\t\tif(LF) {\n\t\t\t\t\tint now = len;\n\t\t\t\t\twhile(now != ci) {\n\t\t\t\t\t\tsb[now] = sb[now-1];\n\t\t\t\t\t}\n\t\t\t\t\tlen++;\n\t\t\t\t\tsb[ci+1] = new StringBuilder(sb[ci].substring(cj,sb[ci].length()));\n\t\t\t\t\tsb[ci].delete(cj, sb[ci].length());\n\t\t\t\t\tci++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(cj == sb[ci].length()) {\n\t\t\t\t\t\tsb[ci].insert(cj, buffer);\n\t\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsb[ci].insert(cj, buffer);\n\t\t\t\t\t\tcj += buffer.length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < len; i++) {\n\t\t\tSystem.out.println(sb[i].toString());\n\t\t}\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) throws Exception {\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner sc = new Scanner(new InputStreamReader(System.in));\n\t\t\n\t\twhile (sc.hasNext()) {\n\t\t\tList<StringBuilder> lines = new ArrayList<StringBuilder>();\n\t\t\twhile (true) {\n\t\t\t\tString text = sc.nextLine();\n\t\t\t\tif (text.equals(\"END_OF_TEXT\"))\n\t\t\t\t\tbreak;\n\t\t\t\tlines.add(new StringBuilder(text));\n\t\t\t}\n\t\t\tPoint cursor = new Point();\n\t\t\tString buffer = null;\n\t\t\tcommandLoop: while (true) {\n\t\t\t\tchar command = sc.nextLine().charAt(0);\n\t\t\t\tStringBuilder currentLine = lines.get(cursor.y);\n\t\t\t\tswitch (command) {\n\t\t\t\tcase 'a':\n\t\t\t\t\tcursor.x = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e':\n\t\t\t\t\tcursor.x = currentLine.length();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\n\t\t\t\t\tif (cursor.y > 0)\n\t\t\t\t\t\tcursor.y--;\n\t\t\t\t\tcursor.x = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'n':\n\t\t\t\t\tif (cursor.y + 1 < lines.size())\n\t\t\t\t\t\tcursor.y++;\n\t\t\t\t\tcursor.x = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tif (cursor.x < currentLine.length()) {\n\t\t\t\t\t\tcursor.x++;\n\t\t\t\t\t}\n\t\t\t\t\telse if (cursor.y + 1 < lines.size()) {\n\t\t\t\t\t\tcursor.y++;\n\t\t\t\t\t\tcursor.x = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tif (cursor.x > 0) {\n\t\t\t\t\t\tcursor.x--;\n\t\t\t\t\t}\n\t\t\t\t\telse if (cursor.y > 0) {\n\t\t\t\t\t\tcursor.y--;\n\t\t\t\t\t\tcursor.x = lines.get(cursor.y).length();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tif (cursor.x < currentLine.length()) {\n\t\t\t\t\t\tcurrentLine.deleteCharAt(cursor.x);\n\t\t\t\t\t}\n\t\t\t\t\telse if (cursor.y + 1 < lines.size()) {\n\t\t\t\t\t\tcurrentLine.append(lines.remove(cursor.y + 1));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'k':\n\t\t\t\t\tif (cursor.x == currentLine.length()) {\n\t\t\t\t\t\tif (cursor.y + 1 < lines.size()) {\n\t\t\t\t\t\t\tcurrentLine.append(lines.remove(cursor.y + 1));\n\t\t\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuffer = currentLine.substring(cursor.x);\n\t\t\t\t\t\tcurrentLine.delete(cursor.x, currentLine.length());\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'y':\n\t\t\t\t\tif (buffer != null) {\n\t\t\t\t\t\tif (buffer.equals(\"\\n\")) {\n\t\t\t\t\t\t\tStringBuilder newLine = new StringBuilder();\n\t\t\t\t\t\t\tif (cursor.x != currentLine.length()) {\n\t\t\t\t\t\t\t\tnewLine.append(currentLine.substring(cursor.x));\n\t\t\t\t\t\t\t\tcurrentLine.delete(cursor.x,\n\t\t\t\t\t\t\t\t\t\tcurrentLine.length());\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlines.add(cursor.y + 1, newLine);\n\t\t\t\t\t\t\tcursor.y++;\n\t\t\t\t\t\t\tcursor.x = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (cursor.x == currentLine.length()) {\n\t\t\t\t\t\t\t\tcurrentLine.append(buffer);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tcurrentLine.insert(cursor.x, buffer);\n\t\t\t\t\t\t\tcursor.x += buffer.length();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '-':\n\t\t\t\t\tbreak commandLoop;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// System.out.println(cursor);\n\t\t\t\t// System.out.println(currentLine);\n\t\t\t\t//System.out.println(\"---\");\n\t\t\t}\n\t\t\tfor (StringBuilder sb : lines) {\n\t\t\t\tSystem.out.println(sb);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static ArrayList<String> modifyingText = new ArrayList<String>();\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        ArrayList<String> inputText;\n        ArrayList<String> inputCommand;\n\n        inputText = giveTextLine();\n        inputCommand = giveCommand();\n        modifyText(inputText, inputCommand);\n\n        for(int i = 0; i < modifyingText.size(); i++){\n            System.out.println(modifyingText.get(i));\n        }\n    }\n\n    private static ArrayList<String> giveTextLine() {\n        String input;\n        ArrayList<String>inputText = new ArrayList<>();\n        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = String.valueOf(scan.next());\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText.add(i, input);\n        }\n        return inputText;\n    }\n\n    private static ArrayList<String> giveCommand() {\n        String input;\n        ArrayList<String>inputCommand = new ArrayList<>();\n        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = String.valueOf(scan.next());\n            if (input.equals(\"-\")) break;\n            inputCommand.add(i, input);\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final ArrayList<String> inputText, final ArrayList<String> inputCommand) {\n\n        for (int i = 0; i < inputText.size(); i++) {\n            modifyingText.add(i, inputText.get(i));\n        }\n\n        for (int i = 0; i < inputCommand.size(); i++) {\n            if (inputCommand.get(i).equals(\"a\")) editA();\n            else if (inputCommand.get(i).equals(\"e\")) editE();\n            else if (inputCommand.get(i).equals(\"p\")) editP();\n            else if (inputCommand.get(i).equals(\"n\")) editN();\n            else if (inputCommand.get(i).equals(\"f\")) editF();\n            else if (inputCommand.get(i).equals(\"b\")) editB();\n            else if (inputCommand.get(i).equals(\"d\")) editD();\n            else if (inputCommand.get(i).equals(\"k\")) editK();\n            else if (inputCommand.get(i).equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        StringBuilder builder = new StringBuilder(str);\n        return builder.deleteCharAt(removeIndex).toString();\n//        return str.substring(0, removeIndex) + str.substring(removeIndex + 1);\n    }\n\n    private static String insert(String str, int insertIndex) {\n        StringBuilder builder = new StringBuilder(str);\n        return builder.insert(insertIndex, buffer).toString();\n//        return str.substring(0, insertIndex) + buffer + str.substring(insertIndex);\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = modifyingText.get(cursorLocLine).length();\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (modifyingText.get(cursorLocLine + 1) != null) cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (modifyingText.get(cursorLocLine).length() == cursorLocRow + 1) {\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else {\n            cursorLocRow = modifyingText.get(cursorLocLine - 1).length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n        if (cursorLocRow != modifyingText.get(cursorLocLine).length() - 1) {\n            modifyingText.add(cursorLocLine, remove(modifyingText.get(cursorLocLine), cursorLocRow));\n        } else if (modifyingText.get(cursorLocLine + 1) != null) {\n            for (int i = cursorLocLine; i < modifyingText.size(); i++) {\n                if (modifyingText.get(i + 1) == null) break;\n                modifyingText.add(i, modifyingText.get(i) + modifyingText.get(i + 1));\n            }\n        }\n\n    }\n\n    private static void editK() {\n        if (cursorLocRow == modifyingText.get(cursorLocLine).length() - 1 && modifyingText.get(cursorLocLine + 1) != null) {\n            for (int i = cursorLocLine; i < modifyingText.size(); i++) {\n                if (modifyingText.get(i + 1) == null) break;\n                modifyingText.add(i, modifyingText.get(i) + modifyingText.get(i + 1));\n            }\n            buffer = \"\\n\";\n        } else {\n            buffer = modifyingText.get(cursorLocLine).substring(cursorLocRow);\n            modifyingText.add(cursorLocLine, modifyingText.get(cursorLocLine).substring(0, cursorLocRow - 1));\n        }\n    }\n\n    private static void editY() {\n        if(buffer.equals(\"\\n\")) {\n            String movingText = modifyingText.get(cursorLocLine).substring(cursorLocRow);\n            modifyingText.add(cursorLocLine, modifyingText.get(cursorLocLine).substring(0, cursorLocRow-1));\n            for( int i = modifyingText.size(); i != cursorLocLine; i-- ){\n                if(modifyingText.get(cursorLocLine) != null)\n                    modifyingText.add(cursorLocLine + 1, modifyingText.get(cursorLocLine));\n            }\n            cursorLocLine++;\n            cursorLocRow = 0;\n        }else if (buffer != null){\n            modifyingText.add(cursorLocLine, insert(modifyingText.get(cursorLocLine), cursorLocRow));\n        }\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\n\nimport java.util.*;\nimport java.math.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.math.BigInteger.*;\nimport static java.lang.Character.*;\n\nclass AOJ1021 {\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t// while (sc.hasNext()) {\n\t\tList<StringBuilder> lb = new ArrayList<StringBuilder>();\n\t\twhile (true) {\n\t\t\tString s = sc.nextLine();\n\t\t\tif (s.equals(\"END_OF_TEXT\"))\n\t\t\t\tbreak;\n\t\t\tlb.add(new StringBuilder(s));\n\t\t}\n\t\tint cur = 0, line = 0;\n\t\tStringBuilder buf = new StringBuilder();\n\t\tloop: while (true) {\n\t\t\tchar c = sc.nextLine().charAt(0);\n\t\t\tswitch (c) {\n\t\t\tcase '-':\n\t\t\t\tbreak loop;\n\t\t\tcase 'a':\n\t\t\t\tcur = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tcur = lb.get(line).length();\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tcur = 0;\n\t\t\t\tline = max(line - 1, 0);\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tcur = 0;\n\t\t\t\tline = min(line + 1, lb.size() - 1);\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (cur < lb.get(line).length())\n\t\t\t\t\tcur++;\n\t\t\t\telse if (line < lb.size() - 1) {\n\t\t\t\t\tcur = 0;\n\t\t\t\t\tline++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tif (cur > 0)\n\t\t\t\t\tcur--;\n\t\t\t\telse if (line > 0) {\n\t\t\t\t\tline--;\n\t\t\t\t\tcur = lb.get(line).length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif (cur < lb.get(line).length())\n\t\t\t\t\tlb.get(line).deleteCharAt(cur);\n\t\t\t\telse if (line < lb.size() - 1) {\n\t\t\t\t\tlb.get(line).append(lb.get(line + 1));\n\t\t\t\t\tlb.remove(line);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tif (cur < lb.get(line).length()) {\n\t\t\t\t\tbuf = new StringBuilder(lb.get(line).substring(cur));\n\t\t\t\t\tlb.get(line).delete(cur, lb.get(line).length());\n\t\t\t\t} else if (line < lb.size() - 1) {\n\t\t\t\t\tlb.get(line).append(lb.get(line + 1));\n\t\t\t\t\tlb.remove(line);\n\t\t\t\t\tbuf = null;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\tif (buf == null) {\n\t\t\t\t\tlb.add(line + 1, new StringBuilder(lb.get(line).substring(cur)));\n\t\t\t\t\tlb.get(line).delete(cur, lb.get(line).length());\n\t\t\t\t\tline++;\n\t\t\t\t\tcur = 0;\n\t\t\t\t} else {\n\t\t\t\t\tlb.get(line).insert(cur, buf);\n\t\t\t\t\tcur += buf.length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (StringBuilder sb : lb)\n\t\t\tSystem.out.println(sb);\n\t\t// }\n\t}\n}\n\npublic class Main {\n\tpublic static void main(String... args) {\n\t\tnew AOJ1021().run();\n\t}\n\n\tpublic static void debug(Object... os) {\n\t\tSystem.err.println(java.util.Arrays.deepToString(os));\n\t}\n}\n\nclass Scanner {\n\tfinal java.util.Scanner sc;\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(sc.next());\n\t}\n\n\tpublic Scanner(java.io.InputStream is) {\n\t\tthis.sc = new java.util.Scanner(is);\n\t}\n\n\tpublic boolean hasNext() {\n\t\treturn sc.hasNext();\n\t}\n\n\tpublic String next() {\n\t\treturn sc.next();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(sc.next());\n\t}\n\n\tpublic String nextLine() {\n\t\treturn sc.nextLine();\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(sc.next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static final String ENDOFLINE = \"$\";\n    static Scanner scan = new Scanner(System.in);\n    static ArrayList<String> modifyingText = new ArrayList<String>();\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        ArrayList<String> inputText;\n        ArrayList<String> inputCommand;\n\n        inputText = giveTextLine();\n//        System.out.println(\"==============================\");\n//        System.out.println(\"give Text Success\");\n\n        inputCommand = giveCommand();\n\n//        System.out.println(\"==============================\");\n//        System.out.println(\"give Command Success\");\n        modifyText(inputText, inputCommand);\n\n        for (int i = 0; i < modifyingText.size(); i++) {\n            int outLen = modifyingText.get(i).length();\n            if (outLen <= 1) {\n                System.out.print(\"\\n\");\n            } else System.out.println(modifyingText.get(i).substring(0, outLen - 1));\n        }\n    }\n\n    private static ArrayList<String> giveTextLine() {\n        String input;\n        ArrayList<String> inputText = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText.add(i, input);\n        }\n        return inputText;\n    }\n\n    private static ArrayList<String> giveCommand() {\n        String input;\n        ArrayList<String> inputCommand = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"-\")) break;\n            inputCommand.add(i, input);\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final ArrayList<String> inputText, final ArrayList<String> inputCommand) {\n\n        for (int i = 0; i < inputText.size(); i++) {\n            modifyingText.add(i, inputText.get(i) + ENDOFLINE);\n        }\n\n        for (int i = 0; i < inputCommand.size(); i++) {\n//            System.out.println(\"===============================\");\n//            System.out.println(inputCommand.get(i) + \" \" + cursorLocRow + \" \" + cursorLocLine + \" \" + modifyingText.get(cursorLocLine).length() + \" \" + buffer);\n//            System.out.println(\"===============================\");\n//            modifyingText.forEach(System.out::println);\n\n            if (inputCommand.get(i).equals(\"a\")) editA();\n            else if (inputCommand.get(i).equals(\"e\")) editE();\n            else if (inputCommand.get(i).equals(\"p\")) editP();\n            else if (inputCommand.get(i).equals(\"n\")) editN();\n            else if (inputCommand.get(i).equals(\"f\")) editF();\n            else if (inputCommand.get(i).equals(\"b\")) editB();\n            else if (inputCommand.get(i).equals(\"d\")) editD();\n            else if (inputCommand.get(i).equals(\"k\")) editK();\n            else if (inputCommand.get(i).equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        StringBuilder builder = new StringBuilder(str);\n        return builder.deleteCharAt(removeIndex).toString();\n    }\n\n    private static String insert(String str, int insertIndex) {\n        StringBuilder builder = new StringBuilder(str);\n\n        if (builder.length() <= insertIndex) {\n            return builder.append(buffer).toString();\n        } else {\n            return builder.insert(insertIndex, buffer).toString();\n        }\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = currentLineString().length() - 1;\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (isLastLine()) return;\n        cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (isLastRow()) {\n            if (isLastLine()) return;\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else if (cursorLocLine > 0) {\n            cursorLocRow = modifyingText.get(cursorLocLine - 1).length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n        if (!isLastRow()) {\n            replaceCurrentLine(remove(modifyingText.get(cursorLocLine), cursorLocRow));\n        } else {\n            if (currentLineString().length() == 1) {\n                modifyingText.remove(cursorLocLine);\n            } else if (!isLastLine()) {\n                replaceCurrentLine(currentLineString() + modifyingText.get(cursorLocLine + 1));\n                replaceCurrentLine(remove(currentLineString(), cursorLocRow));\n                modifyingText.remove(cursorLocLine + 1);\n            }\n        }\n    }\n\n    private static void editK() {\n        if (isLastRow()) {\n            if (!isLastLine()) {\n\n                replaceCurrentLine(currentLineString() + modifyingText.get(cursorLocLine + 1));\n                replaceCurrentLine(remove(currentLineString(), cursorLocRow));\n\n                for (int i = cursorLocLine + 1; i < modifyingText.size(); i++) {\n                    if (isLastLine(i + 1))\n                        replaceLine(i, modifyingText.get(i + 1));\n                }\n                modifyingText.remove(lastLine());\n                buffer = \"\\n\";\n            }\n        } else {\n            buffer = currentLineString().substring(cursorLocRow, currentLineString().length() - 1);\n            if (cursorLocRow == 0) replaceCurrentLine(ENDOFLINE);\n            else replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n            cursorLocRow = currentLineString().length() - 1;\n        }\n    }\n\n    private static void editY() {\n        if (buffer != null) {\n            if (buffer.equals(\"\\n\")) {\n\n                if (isLastRow()) {\n                    String movingText = currentLineString().substring(cursorLocRow);\n                    replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n                    insertLine(cursorLocLine + 1, movingText);\n                } else {\n                    String movingText = currentLineString().substring(cursorLocRow);\n                    insertLine(cursorLocLine + 1, movingText);\n\n                    if (cursorLocRow != 0) {\n                        replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n                    } else {\n                        replaceCurrentLine(ENDOFLINE);\n                    }\n                }\n                cursorLocRow = 0;\n                cursorLocLine++;\n\n            } else {\n                replaceCurrentLine(insert(currentLineString(), cursorLocRow));\n                cursorLocRow += buffer.length();\n            }\n        }\n    }\n\n    private static String currentLineString() {\n        return modifyingText.get(cursorLocLine);\n    }\n\n    private static void replaceLine(int index, String str) {\n        modifyingText.set(index, str);\n    }\n\n    private static void replaceCurrentLine(String str) {\n        modifyingText.set(cursorLocLine, str);\n    }\n\n    private static void insertLine(int index, String str) {\n        modifyingText.add(index, str);\n    }\n\n    private static void insertInCurrentLine(String str) {\n        modifyingText.add(cursorLocLine, str);\n    }\n\n    private static boolean isLastLine() {\n        return modifyingText.size() <= cursorLocLine + 1;\n    }\n\n    private static boolean isLastLine(int i) {\n        return modifyingText.size() > i;\n    }\n\n    private static boolean isLastRow() {\n        return modifyingText.get(cursorLocLine).length() <= cursorLocRow + 1;\n    }\n\n    private static int lastLine() {\n        return modifyingText.size() - 1;\n    }\n\n    private static boolean isEOL() {\n        return String.valueOf(currentLineString().charAt(cursorLocRow)).equals(ENDOFLINE);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\n//Emacs-like Editor\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tLinkedList<String> l = new LinkedList<String>();\n\t\twhile(true){\n\t\t\tString s = sc.nextLine();\n\t\t\tif(s.equals(\"END_OF_TEXT\"))break;\n\t\t\tl.add(s+\"$\");\n\t\t}\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tString buf = \"\";\n\t\twhile(true){\n\t\t\tchar ch = sc.next().charAt(0);\n\t\t\t\n\t\t\tif(ch=='-')break;\n\t\t\tif(ch=='a')j=0;\n\t\t\telse if(ch=='e')j=l.get(i).length()-1;\n\t\t\telse if(ch=='p'){\n\t\t\t\tif(i>0)i--;\n\t\t\t\tj=0;\n\t\t\t}\n\t\t\telse if(ch=='n'){\n\t\t\t\tif(i<l.size()-1)i++;\n\t\t\t\tj=0;\n\t\t\t}\n\t\t\telse if(ch=='f'){\n\t\t\t\tif(j!=l.get(i).length()-1)j++;\n\t\t\t\telse if(j==l.get(i).length()-1&&i<l.size()-1){\n\t\t\t\t\ti++;j=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ch=='b'){\n\t\t\t\tif(j>0)j--;\n\t\t\t\tif(j==0&&i>0){\n\t\t\t\t\ti--;j=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ch=='d'){\n\t\t\t\tif(l.get(i).charAt(j)!='$'){\n\t\t\t\t\tStringBuilder sb = new StringBuilder(l.remove(i));\n\t\t\t\t\tl.add(i, sb.substring(0, j)+sb.substring(j+1,sb.length()));\n\t\t\t\t}\n\t\t\t\telse if(i<l.size()-1){\n\t\t\t\t\tString t = l.remove(i);\n\t\t\t\t\tStringBuilder sb = new StringBuilder(t.substring(0, t.length()-1));\n\t\t\t\t\tsb.append(l.remove(i));\n\t\t\t\t\tl.add(i, sb.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ch=='k'){\n\t\t\t\tif(j==l.get(i).length()-1&&i<l.size()-1){\n\t\t\t\t\tString t = l.remove(i);\n\t\t\t\t\tStringBuilder sb = new StringBuilder(t.substring(0, t.length()-1));\n\t\t\t\t\tsb.append(l.remove(i));\n\t\t\t\t\tl.add(i, sb.toString());\n\t\t\t\t\tbuf = \"$\";\n\t\t\t\t}\n\t\t\t\telse if(j<l.get(i).length()-1){\n\t\t\t\t\tStringBuilder sb = new StringBuilder(l.remove(i));\n\t\t\t\t\tl.add(i, sb.substring(0,j)+\"$\");\n\t\t\t\t\tbuf = sb.substring(j,sb.length()-1);\n\t\t\t\t\tj = l.get(i).length()-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ch=='y'){\n\t\t\t\tif(buf.equals(\"\"))continue;\n\t\t\t\tif(buf.equals(\"$\")){\n\t\t\t\t\tStringBuilder sb = new StringBuilder(l.remove(i));\n\t\t\t\t\tl.add(i, sb.substring(0,j)+\"$\");\n\t\t\t\t\tl.add(i+1,sb.substring(j,sb.length()));\n\t\t\t\t\ti++;j=0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tStringBuilder sb = new StringBuilder(l.remove(i));\n\t\t\t\t\tchar r = sb.charAt(j);\n\t\t\t\t\tl.add(i, sb.substring(0, j)+buf+sb.substring(r=='$'?j+1:j,sb.length())+(r=='$'?\"$\":\"\"));\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(\"DUMP I:\" + i + \" J:\" +j + \" BUF:\" + buf + \" IM:\" + ch);\n//\t\t\tfor(String s:l)System.out.println(s);\n\t\t}\n\t\tfor(String s:l)System.out.println(s.substring(0,s.length()-1));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) throws Exception {\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner sc = new Scanner(new InputStreamReader(System.in));\n\n\t\tList<StringBuilder> lines = new ArrayList<StringBuilder>();\n\t\twhile (true) {\n\t\t\tString text = sc.next();\n\t\t\tif (text.equals(\"END_OF_TEXT\"))\n\t\t\t\tbreak;\n\t\t\tlines.add(new StringBuilder(text));\n\t\t}\n\t\tPoint cursor = new Point();\n\n\t\tString buffer = null;\n\n\t\tcommandLoop: while (true) {\n\t\t\tchar command = sc.next().charAt(0);\n\t\t\tStringBuilder currentLine = lines.get(cursor.y);\n\t\t\tswitch (command) {\n\t\t\tcase 'a':\n\t\t\t\tcursor.x = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tcursor.x = currentLine.length();\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tif (cursor.y > 0)\n\t\t\t\t\tcursor.y--;\n\t\t\t\tcursor.x = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tif (cursor.y + 1 < lines.size())\n\t\t\t\t\tcursor.y++;\n\t\t\t\tcursor.x = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (cursor.x < currentLine.length()) {\n\t\t\t\t\tcursor.x++;\n\t\t\t\t}\n\t\t\t\telse if (cursor.y + 1 < lines.size()) {\n\t\t\t\t\tcursor.y++;\n\t\t\t\t\tcursor.x = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tif (cursor.x > 0) {\n\t\t\t\t\tcursor.x--;\n\t\t\t\t}\n\t\t\t\telse if (cursor.y > 0) {\n\t\t\t\t\tcursor.y--;\n\t\t\t\t\tcursor.x = lines.get(cursor.y).length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif (cursor.x < currentLine.length()) {\n\t\t\t\t\tcurrentLine.deleteCharAt(cursor.x);\n\t\t\t\t}\n\t\t\t\telse if (cursor.y + 1 < lines.size()) {\n\t\t\t\t\tcurrentLine.append(lines.remove(cursor.y + 1));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tif (cursor.x == currentLine.length()) {\n\t\t\t\t\tif (cursor.y + 1 < lines.size()) {\n\t\t\t\t\t\tcurrentLine.append(lines.remove(cursor.y + 1));\n\t\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = currentLine.substring(cursor.x);\n\t\t\t\t\tcurrentLine.delete(cursor.x, currentLine.length());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\tif (buffer != null) {\n\t\t\t\t\tif (buffer.equals(\"\\n\")) {\n\t\t\t\t\t\tStringBuilder newLine = new StringBuilder();\n\t\t\t\t\t\tif (cursor.x != currentLine.length()) {\n\t\t\t\t\t\t\tnewLine.append(currentLine.substring(cursor.x));\n\t\t\t\t\t\t\tcurrentLine.delete(cursor.x, currentLine.length());\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlines.add(cursor.y, newLine);\n\t\t\t\t\t\tcursor.y++;\n\t\t\t\t\t\tcursor.x = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (cursor.x == currentLine.length())\n\t\t\t\t\t\t\tcurrentLine.append(buffer);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcurrentLine.insert(cursor.x, buffer);\n\t\t\t\t\t\tcursor.x += buffer.length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak commandLoop;\n\t\t\t}\n\t\t\t// System.out.println(cursor);\n\t\t\t// System.out.println(currentLine);\n\t\t}\n\t\tfor (int i = 0; i < lines.size(); i++) {\n\t\t\tSystem.out.print(lines.get(i));\n\t\t\tif(i != lines.size() - 1)\n\t\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) throws Exception {\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner sc = new Scanner(new InputStreamReader(System.in));\n\n\t\tArrayList<StringBuilder> lines = new ArrayList<StringBuilder>();\n\t\twhile (true) {\n\t\t\tString text = sc.next();\n\t\t\tif (text.equals(\"END_OF_TEXT\"))\n\t\t\t\tbreak;\n\t\t\tlines.add(new StringBuilder(text));\n\t\t}\n\t\tPoint cursor = new Point();\n\n\t\tString buffer = null;\n\n\t\tcommandLoop: while (true) {\n\t\t\tchar command = sc.next().charAt(0);\n\t\t\tStringBuilder currentLine = lines.get(cursor.y);\n\t\t\tswitch (command) {\n\t\t\tcase 'a':\n\t\t\t\tcursor.x = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tcursor.x = currentLine.length();\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tif (cursor.y > 0)\n\t\t\t\t\tcursor.y--;\n\t\t\t\telse\n\t\t\t\t\tcursor.x = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tif (cursor.y + 1 < lines.size())\n\t\t\t\t\tcursor.y++;\n\t\t\t\tcursor.x = 0; // ?\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (cursor.x < currentLine.length()) {\n\t\t\t\t\tcursor.x++;\n\t\t\t\t}\n\t\t\t\telse if (cursor.y + 1 < lines.size()) {\n\t\t\t\t\tcursor.y++;\n\t\t\t\t\tcursor.x = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tif (cursor.x > 0) {\n\t\t\t\t\tcursor.x--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (cursor.y > 0) {\n\t\t\t\t\tcursor.y--;\n\t\t\t\t\tcursor.x = lines.get(cursor.y).length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif (cursor.x < currentLine.length()) {\n\t\t\t\t\tcurrentLine.deleteCharAt(cursor.x);\n\t\t\t\t}\n\t\t\t\telse if (cursor.y + 1 < lines.size()) {\n\t\t\t\t\tcurrentLine.append(lines.remove(cursor.y + 1));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tif (cursor.x == currentLine.length()) {\n\t\t\t\t\tif (cursor.y + 1 < lines.size()) {\n\t\t\t\t\t\tcurrentLine.append(lines.remove(cursor.y + 1));\n\t\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = currentLine.substring(cursor.x);\n\t\t\t\t\tcurrentLine.delete(cursor.x, currentLine.length());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\tif (buffer != null) {\n\t\t\t\t\tif (buffer.equals(\"\\n\")) {\n\t\t\t\t\t\tStringBuilder newLine = new StringBuilder();\n\t\t\t\t\t\tif(cursor.x != currentLine.length()) {\n\t\t\t\t\t\t\tnewLine.append(currentLine.substring(cursor.x));\n\t\t\t\t\t\t\tcurrentLine.delete(cursor.x, currentLine.length());\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlines.add(cursor.y, newLine);\n\t\t\t\t\t\tcursor.y++;\n\t\t\t\t\t\tcursor.x = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(cursor.x == currentLine.length())\n\t\t\t\t\t\t\tcurrentLine.append(buffer);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcurrentLine.insert(cursor.x, buffer);\n\t\t\t\t\t\tcursor.x += buffer.length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak commandLoop;\n\t\t\t}\n//\t\t\tSystem.out.println(cursor);\n//\t\t\tSystem.out.println(currentLine);\n\t\t}\n\t\tfor (StringBuilder sb : lines) {\n\t\t\tSystem.out.println(sb);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO ツ篠ゥツ督ョツ青カツ青ャツつウツづェツつスツδソツッツドツ・ツスツタツブ\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tArrayList<String> str = new ArrayList<String>();\n\t\tArrayList<Character> command = new ArrayList<Character>();\n\t\tString buf;\n\t\tint x=0, y=0;\n\n\n\t\twhile(true){\n\t\t\tbuf = sc.nextLine();\n\t\t\tif(buf.equals(\"END_OF_TEXT\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstr.add(buf);\n\t\t}\n\t\twhile(true){\n\t\t\tbuf = sc.next();\n\t\t\tif(buf.charAt(0) == '-'){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcommand.add(buf.charAt(0));\n\t\t}\n\t\tbuf = \"\";\n\n\t\tfor(int i=0;i<command.size();i++){\n\t\t\tswitch(command.get(i)){\n\t\t\tcase 'a'://ok\n\t\t\t\tx=0;\n\t\t\t\tbreak;\n\n\t\t\tcase 'e'://ok\n\t\t\t\tx=str.get(y).length();\n\t\t\t\tbreak;\n\n\t\t\tcase 'p'://ok\n\t\t\t\tif(y!=0){\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t\tx=0;\n\t\t\t\tbreak;\n\n\t\t\tcase 'n'://ok\n\t\t\t\tif(str.size() != y+1){\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tx=0;\n\t\t\t\tbreak;\n\n\t\t\tcase 'f'://ok\n\t\t\t\tif(str.get(y).length() != x){\n\t\t\t\t\tx++;\n\t\t\t\t}else if(str.size() != y+1){\n\t\t\t\t\ty++;\n\t\t\t\t\tx=0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'b'://ok\n\t\t\t\tif(x!=0){\n\t\t\t\t\tx--;\n\t\t\t\t}else if(y!=0){\n\t\t\t\t\ty--;\n\t\t\t\t\tx=str.get(y).length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'd'://ok\n\t\t\t\tif(x!=str.get(y).length()){\n\t\t\t\t\tchar[] strbuf = str.get(y).toCharArray();\n\t\t\t\t\tString resultbuf = \"\";\n\t\t\t\t\tfor(int j=0;j<strbuf.length;j++){\n\t\t\t\t\t\tif(x!=j){\n\t\t\t\t\t\t\tresultbuf += strbuf[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstr.set(y,resultbuf);\n\t\t\t\t}else if(str.size() != y+1){\n\t\t\t\t\tstr.set(y, str.get(y)+str.get(y+1));\n\t\t\t\t\tstr.remove(y+1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'k'://ok\n\t\t\t\tif(x!=str.get(y).length()){\n\t\t\t\t\tchar[] strbuf = str.get(y).toCharArray();\n\t\t\t\t\tString resultbuf = \"\";\n\t\t\t\t\tbuf = \"\";\n\t\t\t\t\tfor(int j=0;j<strbuf.length;j++){\n\t\t\t\t\t\tif(x>j){\n\t\t\t\t\t\t\tresultbuf += strbuf[j];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf += strbuf[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstr.set(y,resultbuf);\n\t\t\t\t\tx = str.get(y).length();\n\t\t\t\t}else if(str.size() != y+1){\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t\tstr.set(y, str.get(y)+str.get(y+1));\n\t\t\t\t\tstr.remove(y+1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'y':\n\t\t\t\tif(buf.equals(\"\\n\")){\n\t\t\t\t\tchar[] strbuf = str.get(y).toCharArray();\n\t\t\t\t\tString resultbuf = \"\";\n\t\t\t\t\tbuf = \"\";\n\t\t\t\t\tfor(int j=0;j<strbuf.length;j++){\n\t\t\t\t\t\tif(x>j){\n\t\t\t\t\t\t\tresultbuf += strbuf[j];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf += strbuf[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstr.set(y,resultbuf);\n\t\t\t\t\tstr.add(y+1,buf);\n\n\t\t\t\t\tbuf=\"\\n\";\n\t\t\t\t}else if(buf.length() != 0){\n\t\t\t\t\tchar[] strbuf = str.get(y).toCharArray();\n\t\t\t\t\tString resultbuf = \"\";\n\t\t\t\t\tfor(int j=0;j<=strbuf.length;j++){\n\t\t\t\t\t\tif(x==j){\n\t\t\t\t\t\t\tresultbuf += buf;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j!=strbuf.length){\n\t\t\t\t\t\t\tresultbuf += strbuf[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstr.set(y, resultbuf);\n\t\t\t\t\tx+=buf.length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<str.size();i++){\n\t\t\tSystem.out.print(str.get(i));\n\t\t\tif(i+1<str.size()){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) throws Exception {\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner sc = new Scanner(new InputStreamReader(System.in));\n\n\t\tList<StringBuilder> lines = new ArrayList<StringBuilder>();\n\t\twhile (true) {\n\t\t\tString text = sc.next();\n\t\t\tif (text.equals(\"END_OF_TEXT\"))\n\t\t\t\tbreak;\n\t\t\tlines.add(new StringBuilder(text));\n\t\t}\n\t\tPoint cursor = new Point();\n\n\t\tString buffer = null;\n\n\t\tcommandLoop: while (true) {\n\t\t\tchar command = sc.next().charAt(0);\n\t\t\tStringBuilder currentLine = lines.get(cursor.y);\n\t\t\tswitch (command) {\n\t\t\tcase 'a':\n\t\t\t\tcursor.x = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tcursor.x = currentLine.length();\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tif (cursor.y > 0)\n\t\t\t\t\tcursor.y--;\n\t\t\t\tcursor.x = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tif (cursor.y + 1 < lines.size())\n\t\t\t\t\tcursor.y++;\n\t\t\t\tcursor.x = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (cursor.x < currentLine.length()) {\n\t\t\t\t\tcursor.x++;\n\t\t\t\t}\n\t\t\t\telse if (cursor.y + 1 < lines.size()) {\n\t\t\t\t\tcursor.y++;\n\t\t\t\t\tcursor.x = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tif (cursor.x > 0) {\n\t\t\t\t\tcursor.x--;\n\t\t\t\t}\n\t\t\t\telse if (cursor.y > 0) {\n\t\t\t\t\tcursor.y--;\n\t\t\t\t\tcursor.x = lines.get(cursor.y).length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif (cursor.x < currentLine.length()) {\n\t\t\t\t\tcurrentLine.deleteCharAt(cursor.x);\n\t\t\t\t}\n\t\t\t\telse if (cursor.y + 1 < lines.size()) {\n\t\t\t\t\tcurrentLine.append(lines.remove(cursor.y + 1));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tif (cursor.x == currentLine.length()) {\n\t\t\t\t\tif (cursor.y + 1 < lines.size()) {\n\t\t\t\t\t\tcurrentLine.append(lines.remove(cursor.y + 1));\n\t\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = currentLine.substring(cursor.x);\n\t\t\t\t\tcurrentLine.delete(cursor.x, currentLine.length());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\tif (buffer != null) {\n\t\t\t\t\tif (buffer.equals(\"\\n\")) {\n\t\t\t\t\t\tStringBuilder newLine = new StringBuilder();\n\t\t\t\t\t\tif (cursor.x != currentLine.length()) {\n\t\t\t\t\t\t\tnewLine.append(currentLine.substring(cursor.x));\n\t\t\t\t\t\t\tcurrentLine.delete(cursor.x, currentLine.length());\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlines.add(cursor.y+1, newLine);\n\t\t\t\t\t\tcursor.y++;\n\t\t\t\t\t\tcursor.x = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (cursor.x == currentLine.length()) {\n\t\t\t\t\t\t\tcurrentLine.append(buffer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcurrentLine.insert(cursor.x, buffer);\n\t\t\t\t\t\tcursor.x += buffer.length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase '-':\n\t\t\t\tbreak commandLoop;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// System.out.println(cursor);\n\t\t\t// System.out.println(currentLine);\n\t\t\t//System.out.println(\"---\");\n\t\t}\n\t\tfor (StringBuilder sb : lines) {\n\t\t\tSystem.out.println(sb);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class EditText {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static final String ENDOFLINE = \"$\";\n    static Scanner scan = new Scanner(System.in);\n    static ArrayList<String> modifyingText = new ArrayList<String>();\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        ArrayList<String> inputText;\n        ArrayList<String> inputCommand;\n\n        inputText = giveTextLine();\n//        System.out.println(\"==============================\");\n//        System.out.println(\"give Text Success\");\n\n        inputCommand = giveCommand();\n\n//        System.out.println(\"==============================\");\n//        System.out.println(\"give Command Success\");\n        modifyText(inputText, inputCommand);\n\n        for (int i = 0; i < modifyingText.size(); i++) {\n            int outLen = modifyingText.get(i).length();\n            if (outLen <= 1) {\n                System.out.print(\"\\n\");\n            } else System.out.println(modifyingText.get(i).substring(0, outLen - 1));\n        }\n    }\n\n    private static ArrayList<String> giveTextLine() {\n        String input;\n        ArrayList<String> inputText = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText.add(i, input);\n        }\n        return inputText;\n    }\n\n    private static ArrayList<String> giveCommand() {\n        String input;\n        ArrayList<String> inputCommand = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"-\")) break;\n            inputCommand.add(i, input);\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final ArrayList<String> inputText, final ArrayList<String> inputCommand) {\n\n        for (int i = 0; i < inputText.size(); i++) {\n            modifyingText.add(i, inputText.get(i) + ENDOFLINE);\n        }\n\n        for (int i = 0; i < inputCommand.size(); i++) {\n//            System.out.println(\"===============================\");\n//            System.out.println(inputCommand.get(i) + \" \" + cursorLocRow + \" \" + cursorLocLine + \" \" + modifyingText.get(cursorLocLine).length() + \" \" + buffer);\n//            System.out.println(\"===============================\");\n//            modifyingText.forEach(System.out::println);\n\n            if (inputCommand.get(i).equals(\"a\")) editA();\n            else if (inputCommand.get(i).equals(\"e\")) editE();\n            else if (inputCommand.get(i).equals(\"p\")) editP();\n            else if (inputCommand.get(i).equals(\"n\")) editN();\n            else if (inputCommand.get(i).equals(\"f\")) editF();\n            else if (inputCommand.get(i).equals(\"b\")) editB();\n            else if (inputCommand.get(i).equals(\"d\")) editD();\n            else if (inputCommand.get(i).equals(\"k\")) editK();\n            else if (inputCommand.get(i).equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        StringBuilder builder = new StringBuilder(str);\n        return builder.deleteCharAt(removeIndex).toString();\n    }\n\n    private static String insert(String str, int insertIndex) {\n        StringBuilder builder = new StringBuilder(str);\n\n        if (builder.length() <= insertIndex) {\n            return builder.append(buffer).toString();\n        } else {\n            return builder.insert(insertIndex, buffer).toString();\n        }\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = currentLineString().length() - 1;\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (isLastLine()) return;\n        cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (isLastRow()) {\n            if (isLastLine()) return;\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else if (cursorLocLine > 0) {\n            cursorLocRow = modifyingText.get(cursorLocLine - 1).length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n        if (!isEOL()) {\n            replaceCurrentLine(remove(modifyingText.get(cursorLocLine), cursorLocRow));\n        } else {\n            if (!isLastLine()) {\n                replaceCurrentLine(currentLineString() + modifyingText.get(cursorLocLine + 1));\n                replaceCurrentLine(remove(currentLineString(), cursorLocRow));\n                for (int i = cursorLocLine + 1; i < modifyingText.size(); i++) {\n                    if (isLastLine(i + 1)) break;\n                    replaceLine(i, modifyingText.get(i) + modifyingText.get(i + 1));\n                }\n            }\n        }\n    }\n\n    private static void editK() {\n        if (isLastRow()) {\n            if (!isLastLine()) {\n\n                replaceCurrentLine(currentLineString() + modifyingText.get(cursorLocLine + 1));\n                replaceCurrentLine(remove(currentLineString(), cursorLocRow));\n\n                for (int i = cursorLocLine + 1; i < modifyingText.size(); i++) {\n                    if (isLastLine(i + 1))\n                        replaceLine(i, modifyingText.get(i + 1));\n                }\n                modifyingText.remove(lastLine());\n                buffer = \"\\n\";\n            }\n        } else {\n            buffer = currentLineString().substring(cursorLocRow, currentLineString().length() - 1);\n            if (cursorLocRow == 0) replaceCurrentLine(ENDOFLINE);\n            else replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n        }\n    }\n\n    private static void editY() {\n        if (buffer != null) {\n            if (buffer.equals(\"\\n\")) {\n\n                if (isLastRow()) {\n                    String movingText = currentLineString().substring(cursorLocRow);\n                    replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n                    insertLine(cursorLocLine + 1, movingText);\n                } else {\n                    String movingText = currentLineString().substring(cursorLocRow);\n                    insertLine(cursorLocLine + 1, movingText);\n\n                    if (cursorLocRow != 0) {\n                        replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n                    } else {\n                        replaceCurrentLine(ENDOFLINE);\n                    }\n                }\n                cursorLocRow = 0;\n                cursorLocLine++;\n\n            } else {\n                replaceCurrentLine(insert(currentLineString(), cursorLocRow));\n                \n            }\n        }\n    }\n\n    private static String currentLineString() {\n        return modifyingText.get(cursorLocLine);\n    }\n\n    private static void replaceLine(int index, String str) {\n        modifyingText.set(index, str);\n    }\n\n    private static void replaceCurrentLine(String str) {\n        modifyingText.set(cursorLocLine, str);\n    }\n\n    private static void insertLine(int index, String str) {\n        modifyingText.add(index, str);\n    }\n\n    private static void insertInCurrentLine(String str) {\n        modifyingText.add(cursorLocLine, str);\n    }\n\n    private static boolean isLastLine() {\n        return modifyingText.size() <= cursorLocLine + 1;\n    }\n\n    private static boolean isLastLine(int i) {\n        return modifyingText.size() > i;\n    }\n\n    private static boolean isLastRow() {\n        return modifyingText.get(cursorLocLine).length() <= cursorLocRow + 1;\n    }\n\n    private static int lastLine() {\n        return modifyingText.size() - 1;\n    }\n\n    private static boolean isEOL() {\n        return String.valueOf(currentLineString().charAt(cursorLocRow)).equals(ENDOFLINE);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static ArrayList<String> modifyingText = new ArrayList<String>();\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        String inputText[];\n        String inputCommand[];\n\n        inputText = giveTextLine();\n        inputCommand = giveCommand();\n        modifyText(inputText, inputCommand);\n\n        for(int i = 0; i < modifyingText.size(); i++){\n            System.out.println(modifyingText.get(i));\n        }\n    }\n\n    private static String[] giveTextLine() {\n        String input;\n        String[] inputText = new String[MAXINPUTLINE];\n        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = String.valueOf(scan.next());\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText[i] = input;\n        }\n        return inputText;\n    }\n\n    private static String[] giveCommand() {\n        String input;\n        String[] inputCommand = new String[MAXINPUTCOMMAND];\n        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = String.valueOf(scan.next());\n            if (input.equals(\"-\")) break;\n            inputCommand[i] = input;\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final String inputText[], final String inputCommand[]) {\n\n        for (int i = 0; i < inputText.length; i++) {\n            modifyingText.add(i, inputText[i]);\n        }\n\n        for (int i = 0; i < inputCommand.length; i++) {\n            if (inputCommand[i].equals(\"a\")) editA();\n            else if (inputCommand[i].equals(\"e\")) editE();\n            else if (inputCommand[i].equals(\"p\")) editP();\n            else if (inputCommand[i].equals(\"n\")) editN();\n            else if (inputCommand[i].equals(\"f\")) editF();\n            else if (inputCommand[i].equals(\"b\")) editB();\n            else if (inputCommand[i].equals(\"d\")) editD();\n            else if (inputCommand[i].equals(\"k\")) editK();\n            else if (inputCommand[i].equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        return str.substring(0, removeIndex) + str.substring(removeIndex + 1);\n    }\n\n    private static String insert(String str, int insertIndex) {\n        return str.substring(0, insertIndex) + buffer + str.substring(insertIndex);\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = modifyingText.get(cursorLocLine).length();\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (modifyingText.get(cursorLocLine + 1) != null) cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (modifyingText.get(cursorLocLine).length() == cursorLocRow + 1) {\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else {\n            cursorLocRow = modifyingText.get(cursorLocLine - 1).length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n        if (cursorLocRow != modifyingText.get(cursorLocLine).length() - 1) {\n            modifyingText.add(cursorLocLine, remove(modifyingText.get(cursorLocLine), cursorLocRow));\n        } else if (modifyingText.get(cursorLocLine + 1) != null) {\n            for (int i = cursorLocLine; i < modifyingText.size(); i++) {\n                if (modifyingText.get(i + 1) == null) break;\n                modifyingText.add(i, modifyingText.get(i) + modifyingText.get(i + 1));\n            }\n        }\n\n    }\n\n    private static void editK() {\n        if (cursorLocRow == modifyingText.get(cursorLocLine).length() - 1 && modifyingText.get(cursorLocLine + 1) != null) {\n            for (int i = cursorLocLine; i < modifyingText.size(); i++) {\n                if (modifyingText.get(i + 1) == null) break;\n                modifyingText.add(i, modifyingText.get(i) + modifyingText.get(i + 1));\n            }\n            buffer = \"\\n\";\n        } else {\n            buffer = modifyingText.get(cursorLocLine).substring(cursorLocRow);\n            modifyingText.add(cursorLocLine, modifyingText.get(cursorLocLine).substring(0, cursorLocRow - 1));\n        }\n    }\n\n    private static void editY() {\n        if(buffer.equals(\"\\n\")) {\n            String movingText = modifyingText.get(cursorLocLine).substring(cursorLocRow);\n            modifyingText.add(cursorLocLine, modifyingText.get(cursorLocLine).substring(0, cursorLocRow-1));\n            for( int i = modifyingText.size(); i != cursorLocLine; i-- ){\n                if(modifyingText.get(cursorLocLine) != null)\n                    modifyingText.add(cursorLocLine + 1, modifyingText.get(cursorLocLine));\n            }\n            cursorLocLine++;\n            cursorLocRow = 0;\n        }else if (buffer != null){\n            modifyingText.add(cursorLocLine, insert(modifyingText.get(cursorLocLine), cursorLocRow));\n        }\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static final String ENDOFLINE = \"$\";\n    static Scanner scan = new Scanner(System.in);\n    static ArrayList<String> modifyingText = new ArrayList<String>();\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        ArrayList<String> inputText;\n        ArrayList<String> inputCommand;\n\n        inputText = giveTextLine();\n//        System.out.println(\"==============================\");\n//        System.out.println(\"give Text Success\");\n\n        inputCommand = giveCommand();\n\n//        System.out.println(\"==============================\");\n//        System.out.println(\"give Command Success\");\n        modifyText(inputText, inputCommand);\n\n        for (int i = 0; i < modifyingText.size(); i++) {\n            int outLen = modifyingText.get(i).length();\n            if (outLen <= 1) {\n                System.out.print(\"\\n\");\n            } else System.out.println(modifyingText.get(i).substring(0, outLen - 1));\n        }\n    }\n\n    private static ArrayList<String> giveTextLine() {\n        String input;\n        ArrayList<String> inputText = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText.add(i, input);\n        }\n        return inputText;\n    }\n\n    private static ArrayList<String> giveCommand() {\n        String input;\n        ArrayList<String> inputCommand = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"-\")) break;\n            inputCommand.add(i, input);\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final ArrayList<String> inputText, final ArrayList<String> inputCommand) {\n\n        for (int i = 0; i < inputText.size(); i++) {\n            modifyingText.add(i, inputText.get(i) + ENDOFLINE);\n        }\n\n        for (int i = 0; i < inputCommand.size(); i++) {\n//            System.out.println(\"===============================\");\n//            System.out.println(inputCommand.get(i) + \" \" + cursorLocRow + \" \" + cursorLocLine + \" \" + modifyingText.get(cursorLocLine).length() + \" \" + buffer);\n//            System.out.println(\"===============================\");\n//            modifyingText.forEach(System.out::println);\n\n            if (inputCommand.get(i).equals(\"a\")) editA();\n            else if (inputCommand.get(i).equals(\"e\")) editE();\n            else if (inputCommand.get(i).equals(\"p\")) editP();\n            else if (inputCommand.get(i).equals(\"n\")) editN();\n            else if (inputCommand.get(i).equals(\"f\")) editF();\n            else if (inputCommand.get(i).equals(\"b\")) editB();\n            else if (inputCommand.get(i).equals(\"d\")) editD();\n            else if (inputCommand.get(i).equals(\"k\")) editK();\n            else if (inputCommand.get(i).equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        StringBuilder builder = new StringBuilder(str);\n        return builder.deleteCharAt(removeIndex).toString();\n    }\n\n    private static String insert(String str, int insertIndex) {\n        StringBuilder builder = new StringBuilder(str);\n\n        if (builder.length() <= insertIndex) {\n            return builder.append(buffer).toString();\n        } else {\n            return builder.insert(insertIndex, buffer).toString();\n        }\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = currentLineString().length() - 1;\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (isLastLine()) return;\n        cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (isLastRow()) {\n            if (isLastLine()) return;\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else if (cursorLocLine > 0) {\n            cursorLocRow = modifyingText.get(cursorLocLine - 1).length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n        if (!isEOL()) {\n            replaceCurrentLine(remove(modifyingText.get(cursorLocLine), cursorLocRow));\n        } else {\n            if (!isLastLine()) {\n                replaceCurrentLine(currentLineString() + modifyingText.get(cursorLocLine + 1));\n                replaceCurrentLine(remove(currentLineString(), cursorLocRow));\n                for (int i = cursorLocLine + 1; i < modifyingText.size(); i++) {\n                    if (isLastLine(i + 1)) break;\n                    replaceLine(i, modifyingText.get(i) + modifyingText.get(i + 1));\n                }\n            }\n        }\n    }\n\n    private static void editK() {\n        if (isLastRow()) {\n            if (!isLastLine()) {\n\n                replaceCurrentLine(currentLineString() + modifyingText.get(cursorLocLine + 1));\n                replaceCurrentLine(remove(currentLineString(), cursorLocRow));\n\n                for (int i = cursorLocLine + 1; i < modifyingText.size(); i++) {\n                    if (isLastLine(i + 1))\n                        replaceLine(i, modifyingText.get(i + 1));\n                }\n                modifyingText.remove(lastLine());\n                buffer = \"\\n\";\n            }\n        } else {\n            buffer = currentLineString().substring(cursorLocRow, currentLineString().length() - 1);\n            if (cursorLocRow == 0) replaceCurrentLine(ENDOFLINE);\n            else replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n            cursorLocRow = currentLineString().length() - 1;\n        }\n    }\n\n    private static void editY() {\n        if (buffer != null) {\n            if (buffer.equals(\"\\n\")) {\n\n                if (isLastRow()) {\n                    String movingText = currentLineString().substring(cursorLocRow);\n                    replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n                    insertLine(cursorLocLine + 1, movingText);\n                } else {\n                    String movingText = currentLineString().substring(cursorLocRow);\n                    insertLine(cursorLocLine + 1, movingText);\n\n                    if (cursorLocRow != 0) {\n                        replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n                    } else {\n                        replaceCurrentLine(ENDOFLINE);\n                    }\n                }\n                cursorLocRow = 0;\n                cursorLocLine++;\n\n            } else {\n                replaceCurrentLine(insert(currentLineString(), cursorLocRow));\n                cursorLocRow += (buffer.length()-1);\n\n            }\n        }\n    }\n\n    private static String currentLineString() {\n        return modifyingText.get(cursorLocLine);\n    }\n\n    private static void replaceLine(int index, String str) {\n        modifyingText.set(index, str);\n    }\n\n    private static void replaceCurrentLine(String str) {\n        modifyingText.set(cursorLocLine, str);\n    }\n\n    private static void insertLine(int index, String str) {\n        modifyingText.add(index, str);\n    }\n\n    private static void insertInCurrentLine(String str) {\n        modifyingText.add(cursorLocLine, str);\n    }\n\n    private static boolean isLastLine() {\n        return modifyingText.size() <= cursorLocLine + 1;\n    }\n\n    private static boolean isLastLine(int i) {\n        return modifyingText.size() > i;\n    }\n\n    private static boolean isLastRow() {\n        return modifyingText.get(cursorLocLine).length() <= cursorLocRow + 1;\n    }\n\n    private static int lastLine() {\n        return modifyingText.size() - 1;\n    }\n\n    private static boolean isEOL() {\n        return String.valueOf(currentLineString().charAt(cursorLocRow)).equals(ENDOFLINE);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\tArrayList<String> text = new ArrayList<String>();\n\t\t\tArrayList<String> commands = new ArrayList<String>();\n\t\t\tString buffer = null;\n\t\t\tint l=0, c=0;\n\t\t\t/* input */\n\t\t\twhile(true){\n\t\t\t\tline = br.readLine();\n\t\t\t\tif(line.equals(\"END_OF_TEXT\")) break;\n\t\t\t\ttext.add(line);\n\t\t\t}\n\t\t\twhile(true){\n\t\t\t\tline = br.readLine();\n\t\t\t\tif(line.equals(\"-\")) break;\n\t\t\t\tcommands.add(line);\n\t\t\t}\n\t\t\t/* processing */\n\t\t\tfor(String cm : commands){\n\t\t\t\tswitch(cm){\n\t\t\t\tcase \"a\":\n\t\t\t\t\tc = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"e\":\n\t\t\t\t\tc = text.get(l).length();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"p\":\n\t\t\t\t\tif(l>0){\n\t\t\t\t\t\tl--;\n\t\t\t\t\t}\n\t\t\t\t\tc = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"n\":\n\t\t\t\t\tif(l<text.size()-1){\n\t\t\t\t\t\tl++;\n\t\t\t\t\t}\n\t\t\t\t\tc = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"f\":\n\t\t\t\t\tif(c==text.get(l).length()){\n\t\t\t\t\t\tif(l<text.size()-1){\n\t\t\t\t\t\t\tl++;\n\t\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"b\":\n\t\t\t\t\tif(c==0){\n\t\t\t\t\t\tif(l>0){\n\t\t\t\t\t\t\tl--;\n\t\t\t\t\t\t\tc = text.get(l).length();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"d\":\n\t\t\t\t\tif(c<text.get(l).length()){\n\t\t\t\t\t\ttext.set(l, text.get(l).substring(0,c) + text.get(l).substring(c+1,text.get(l).length()));\n\t\t\t\t\t} else if(l<text.size()-1){\n\t\t\t\t\t\ttext.set(l, text.get(l).substring(0,c) + text.get(l+1));\n\t\t\t\t\t\ttext.remove(l+1);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"k\":\n\t\t\t\t\tif(c==text.get(l).length()){\n\t\t\t\t\t\tif(l<text.size()-1){\n\t\t\t\t\t\t\ttext.set(l, text.get(l).substring(0,c) + text.get(l+1));\n\t\t\t\t\t\t\ttext.remove(l+1);\n\t\t\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuffer = text.get(l).substring(c);\n\t\t\t\t\t\ttext.set(l, text.get(l).substring(0,c));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"y\":\n\t\t\t\t\tif(buffer==null){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if(buffer.equals(\"\\n\")){\n\t\t\t\t\t\ttext.add(l+1,text.get(l).substring(c));\n\t\t\t\t\t\ttext.set(l, text.get(l).substring(0,c));\n\t\t\t\t\t\tl++;\n\t\t\t\t\t\tc = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttext.set(l, text.get(l).substring(0,c) + buffer + text.get(l).substring(c));\n\t\t\t\t\t\tc += buffer.length();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* output */\n\t\t\tfor(String s : text){\n\t\t\t\tSystem.out.println(s);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.xml.crypto.Data;\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tStringBuilder[] sb = new StringBuilder[101];\n\t\tfor(int i = 0; i < sb.length; i++) {\n\t\t\tsb[i] = new StringBuilder();\n\t\t}\n\t\tint len = 0;\n\t\twhile(true) {\n\t\t\tString in = sc.nextLine();\n\t\t\tif(in.equals(\"END_OF_TEXT\")) break;\n\t\t\tsb[len++].append(in);\n\t\t}\n\t\tboolean LF = false;\n\t\tStringBuilder buffer = new StringBuilder();\n\t\tint ci = 0;\n\t\tint cj = 0;\n\t\twhile(true) {\n\t\t\tString in = sc.nextLine();\n\t\t\tif(in.equals(\"-\")) break;\n\t\t\tif(in.equals(\"a\")) {\n\t\t\t\tcj = 0;\n\t\t\t}\n\t\t\tif(in.equals(\"e\")) {\n\t\t\t\tcj = sb[ci].length();\n\t\t\t}\n\t\t\tif(in.equals(\"p\")) {\n\t\t\t\tif(ci != 0) {\n\t\t\t\t\tci--;\n\t\t\t\t}\n\t\t\t\tcj = 0;\t\n\t\t\t}\n\t\t\tif(in.equals(\"n\")) {\n\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\tci++;\n\t\t\t\t}\n\t\t\t\tcj = 0;\n\t\t\t}\n\t\t\tif(in.equals(\"f\")) {\n\t\t\t\tif(cj != sb[ci].length()) {\n\t\t\t\t\tcj++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\tcj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"b\")) {\n\t\t\t\tif(cj != 0) {\n\t\t\t\t\tcj--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci != 0) {\n\t\t\t\t\t\tci--;\n\t\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"d\")) {\n\t\t\t\tif(cj != sb[ci].length()) {\n\t\t\t\t\tsb[ci].deleteCharAt(cj);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tsb[ci].append(sb[ci+1]);\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\twhile(ci+1 != len) {\n\t\t\t\t\t\t\tsb[ci] = sb[ci+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"k\")) {\n\t\t\t\tif(cj == sb[ci].length()) {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tsb[ci].append(sb[ci+1]);\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\twhile(ci+1 != len) {\n\t\t\t\t\t\t\tsb[ci] = sb[ci+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t\tbuffer = new StringBuilder();\n\t\t\t\t\tLF = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = new StringBuilder(sb[ci].substring(cj, sb[ci].length()));\n\t\t\t\t\tsb[ci].delete(cj, sb[ci].length());\n\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\tLF = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"y\")) {\n\t\t\t\tif(LF) {\n\t\t\t\t\tint now = len;\n\t\t\t\t\twhile(now != ci) {\n\t\t\t\t\t\tsb[now] = sb[now-1];\n\t\t\t\t\t}\n\t\t\t\t\tlen++;\n\t\t\t\t\tsb[ci+1] = new StringBuilder(sb[ci].substring(cj,sb[ci].length()));\n\t\t\t\t\tsb[ci].delete(cj, sb[ci].length());\n\t\t\t\t\tci++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(cj == sb[ci].length()) {\n\t\t\t\t\t\tsb[ci].insert(cj, buffer);\n\t\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsb[ci].insert(cj, buffer);\n\t\t\t\t\t\tcj += buffer.length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < len; i++) {\n\t\t\tSystem.out.println(sb[i].toString());\n\t\t}\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\n\nimport java.util.*;\nimport java.math.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.math.BigInteger.*;\nimport static java.lang.Character.*;\n\nclass AOJ1021 {\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t// while (sc.hasNext()) {\n\t\tList<StringBuilder> lb = new ArrayList<StringBuilder>();\n\t\twhile (true) {\n\t\t\tString s = sc.nextLine();\n\t\t\tif (s.equals(\"END_OF_TEXT\"))\n\t\t\t\tbreak;\n\t\t\tlb.add(new StringBuilder(s));\n\t\t}\n\t\tint cur = 0, line = 0;\n\t\tStringBuilder buf = new StringBuilder();\n\t\tloop: while (true) {\n\t\t\tchar c = sc.nextLine().charAt(0);\n\t\t\tswitch (c) {\n\t\t\tcase '-':\n\t\t\t\tbreak loop;\n\t\t\tcase 'a':\n\t\t\t\tcur = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tcur = lb.get(line).length();\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tcur = 0;\n\t\t\t\tline = max(line - 1, 0);\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tcur = 0;\n\t\t\t\tline = min(line + 1, lb.size() - 1);\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (cur < lb.get(line).length())\n\t\t\t\t\tcur++;\n\t\t\t\telse if (line < lb.size() - 1) {\n\t\t\t\t\tcur = 0;\n\t\t\t\t\tline++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tif (cur > 0)\n\t\t\t\t\tcur--;\n\t\t\t\telse if (line > 0) {\n\t\t\t\t\tline--;\n\t\t\t\t\tcur = lb.get(line).length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif (cur < lb.get(line).length())\n\t\t\t\t\tlb.get(line).deleteCharAt(cur);\n\t\t\t\telse if (line < lb.size()) {\n\t\t\t\t\tlb.get(line).append(lb.get(line + 1));\n\t\t\t\t\tlb.remove(line);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tif (cur < lb.get(line).length()) {\n\t\t\t\t\tbuf = new StringBuilder(lb.get(line).substring(cur));\n\t\t\t\t\tlb.get(line).delete(cur, lb.get(line).length());\n\t\t\t\t} else if (line < lb.size()) {\n\t\t\t\t\tlb.get(line).append(lb.get(line + 1));\n\t\t\t\t\tlb.remove(line);\n\t\t\t\t\tbuf = null;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\tif (buf == null) {\n\t\t\t\t\tlb.add(line + 1, new StringBuilder(lb.get(line).substring(cur)));\n\t\t\t\t\tlb.get(line).delete(cur, lb.get(line).length());\n\t\t\t\t\tline++;\n\t\t\t\t\tcur = 0;\n\t\t\t\t} else {\n\t\t\t\t\tlb.get(line).insert(cur, buf);\n\t\t\t\t\tcur += buf.length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (StringBuilder sb : lb)\n\t\t\tSystem.out.println(sb);\n\t\t// }\n\t}\n}\n\npublic class Main {\n\tpublic static void main(String... args) {\n\t\tnew AOJ1021().run();\n\t}\n\n\tpublic static void debug(Object... os) {\n\t\tSystem.err.println(java.util.Arrays.deepToString(os));\n\t}\n}\n\nclass Scanner {\n\tfinal java.util.Scanner sc;\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(sc.next());\n\t}\n\n\tpublic Scanner(java.io.InputStream is) {\n\t\tthis.sc = new java.util.Scanner(is);\n\t}\n\n\tpublic boolean hasNext() {\n\t\treturn sc.hasNext();\n\t}\n\n\tpublic String next() {\n\t\treturn sc.next();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(sc.next());\n\t}\n\n\tpublic String nextLine() {\n\t\treturn sc.nextLine();\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(sc.next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\n//Emacs-like Editor\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tLinkedList<String> l = new LinkedList<String>();\n\t\twhile(true){\n\t\t\tString s = sc.nextLine();\n\t\t\tif(s.equals(\"END_OF_TEXT\"))break;\n\t\t\tl.add(s+\"$\");\n\t\t}\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tString buf = \"\";\n\t\twhile(true){\n\t\t\tchar ch = sc.next().charAt(0);\n\t\t\t\n\t\t\tif(ch=='-')break;\n\t\t\tif(ch=='a')j=0;\n\t\t\telse if(ch=='e')j=l.get(i).length()-1;\n\t\t\telse if(ch=='p'){\n\t\t\t\tif(i>0)i--;\n\t\t\t\tj=0;\n\t\t\t}\n\t\t\telse if(ch=='n'){\n\t\t\t\tif(i<l.size()-1)i++;\n\t\t\t\tj=0;\n\t\t\t}\n\t\t\telse if(ch=='f'){\n\t\t\t\tif(j!=l.get(i).length()-1)j++;\n\t\t\t\telse if(j==l.get(i).length()-1&&i<l.size()-1){\n\t\t\t\t\ti++;j=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ch=='b'){\n\t\t\t\tif(j>0)j--;\n\t\t\t\telse if(j==0&&i>0){\n\t\t\t\t\ti--;j=l.get(i).length()-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ch=='d'){\n\t\t\t\tif(l.get(i).charAt(j)!='$'){\n\t\t\t\t\tStringBuilder sb = new StringBuilder(l.remove(i));\n\t\t\t\t\tl.add(i, sb.substring(0, j)+sb.substring(j+1,sb.length()));\n\t\t\t\t}\n\t\t\t\telse if(i<l.size()-1){\n\t\t\t\t\tString t = l.remove(i);\n\t\t\t\t\tStringBuilder sb = new StringBuilder(t.substring(0, t.length()-1));\n\t\t\t\t\tsb.append(l.remove(i));\n\t\t\t\t\tl.add(i, sb.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ch=='k'){\n\t\t\t\tif(j==l.get(i).length()-1&&i<l.size()-1){\n\t\t\t\t\tString t = l.remove(i);\n\t\t\t\t\tStringBuilder sb = new StringBuilder(t.substring(0, t.length()-1));\n\t\t\t\t\tsb.append(l.remove(i));\n\t\t\t\t\tl.add(i, sb.toString());\n\t\t\t\t\tbuf = \"$\";\n\t\t\t\t}\n\t\t\t\telse if(j<l.get(i).length()-1){\n\t\t\t\t\tStringBuilder sb = new StringBuilder(l.remove(i));\n\t\t\t\t\tl.add(i, sb.substring(0,j)+\"$\");\n\t\t\t\t\tbuf = sb.substring(j,sb.length()-1);\n\t\t\t\t\tj = l.get(i).length()-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ch=='y'){\n\t\t\t\tif(buf.equals(\"\"))continue;\n\t\t\t\tif(buf.equals(\"$\")){\n\t\t\t\t\tStringBuilder sb = new StringBuilder(l.remove(i));\n\t\t\t\t\tl.add(i, sb.substring(0,j)+\"$\");\n\t\t\t\t\tl.add(i+1,sb.substring(j,sb.length()));\n\t\t\t\t\ti++;j=0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tStringBuilder sb = new StringBuilder(l.remove(i));\n\t\t\t\t\tchar r = sb.charAt(j);\n\t\t\t\t\tl.add(i, sb.substring(0, j)+buf+sb.substring(r=='$'?j+1:j,sb.length())+(r=='$'?\"$\":\"\"));\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(\"DUMP I:\" + i + \" J:\" +j + \" BUF:\" + buf + \" IM:\" + ch);\n//\t\t\tfor(String s:l)System.out.println(s);\n\t\t}\n\t\tfor(String s:l)System.out.println(s.substring(0,s.length()-1));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\n//Emacs-like Editor\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tLinkedList<String> l = new LinkedList<String>();\n\t\twhile(true){\n\t\t\tString s = sc.nextLine();\n\t\t\tif(s.equals(\"END_OF_TEXT\"))break;\n\t\t\tl.add(s+\"$\");\n\t\t}\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tString buf = \"\";\n\t\twhile(true){\n\t\t\tchar ch = sc.next().charAt(0);\n\t\t\t\n\t\t\tif(ch=='-')break;\n\t\t\tif(ch=='a')j=0;\n\t\t\telse if(ch=='e')j=l.get(i).length()-1;\n\t\t\telse if(ch=='p'){\n\t\t\t\tif(i>0)i--;\n\t\t\t\tj=0;\n\t\t\t}\n\t\t\telse if(ch=='n'){\n\t\t\t\tif(i<l.size()-1)i++;\n\t\t\t\tj=0;\n\t\t\t}\n\t\t\telse if(ch=='f'){\n\t\t\t\tif(j!=l.get(i).length()-1)j++;\n\t\t\t\telse if(j==l.get(i).length()-1&&i<l.size()-1){\n\t\t\t\t\ti++;j=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ch=='b'){\n\t\t\t\tif(j>0)j--;\n\t\t\t\telse if(j==0&&i>0){\n\t\t\t\t\ti--;j=l.get(i).length()-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ch=='d'){\n\t\t\t\tif(l.get(i).charAt(j)!='$'){\n\t\t\t\t\tStringBuilder sb = new StringBuilder(l.remove(i));\n\t\t\t\t\tl.add(i, sb.substring(0, j)+sb.substring(j+1,sb.length()));\n\t\t\t\t}\n\t\t\t\telse if(i<l.size()-1){\n\t\t\t\t\tString t = l.remove(i);\n\t\t\t\t\tStringBuilder sb = new StringBuilder(t.substring(0, t.length()-1));\n\t\t\t\t\tsb.append(l.remove(i));\n\t\t\t\t\tl.add(i, sb.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ch=='k'){\n\t\t\t\tif(j==l.get(i).length()-1&&i<l.size()-1){\n\t\t\t\t\tString t = l.remove(i);\n\t\t\t\t\tStringBuilder sb = new StringBuilder(t.substring(0, t.length()-1));\n\t\t\t\t\tsb.append(l.remove(i));\n\t\t\t\t\tl.add(i, sb.toString());\n\t\t\t\t\tbuf = \"$\";\n\t\t\t\t}\n\t\t\t\telse if(j<l.get(i).length()-1){\n\t\t\t\t\tStringBuilder sb = new StringBuilder(l.remove(i));\n\t\t\t\t\tl.add(i, sb.substring(0,j)+\"$\");\n\t\t\t\t\tbuf = sb.substring(j,sb.length()-1);\n\t\t\t\t\tj = l.get(i).length()-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ch=='y'){\n\t\t\t\tif(buf.equals(\"\"))continue;\n\t\t\t\tif(buf.equals(\"$\")){\n\t\t\t\t\tStringBuilder sb = new StringBuilder(l.remove(i));\n\t\t\t\t\tl.add(i, sb.substring(0,j)+\"$\");\n\t\t\t\t\tl.add(i+1,sb.substring(j,sb.length()));\n\t\t\t\t\ti++;j=0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tStringBuilder sb = new StringBuilder(l.remove(i));\n\t\t\t\t\tchar r = sb.charAt(j);\n\t\t\t\t\tl.add(i, sb.substring(0, j)+buf+sb.substring(r=='$'?j+1:j,sb.length())+(r=='$'?\"$\":\"\"));\n\t\t\t\t\tj += buf.length();\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(\"DUMP Line:\" + i + \" Column:\" +j + \" CHAR:\" + l.get(i).charAt(j) + \" BUF:\" + buf + \" IM:\" + ch);\n//\t\t\tfor(String s:l)System.out.println(s);\n\t\t}\n\t\tfor(String s:l)System.out.println(s.substring(0,s.length()-1));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static Scanner scan = new Scanner(System.in);\n    static ArrayList<String> modifyingText = new ArrayList<String>();\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        ArrayList<String> inputText;\n        ArrayList<String> inputCommand;\n\n        inputText = giveTextLine();\n//        System.out.println(\"==============================\");\n//        System.out.println(\"give Text Success\");\n\n        inputCommand = giveCommand();\n\n//        System.out.println(\"==============================\");\n//        System.out.println(\"give Command Success\");\n        modifyText(inputText, inputCommand);\n\n        for (int i = 0; i < modifyingText.size(); i++) {\n            int outLen = modifyingText.get(i).length();\n            System.out.println(modifyingText.get(i).substring(0,outLen-1));\n        }\n    }\n\n    private static ArrayList<String> giveTextLine() {\n        String input;\n        ArrayList<String> inputText = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText.add(i, input);\n        }\n        return inputText;\n    }\n\n    private static ArrayList<String> giveCommand() {\n        String input;\n        ArrayList<String> inputCommand = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"-\")) break;\n            inputCommand.add(i, input);\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final ArrayList<String> inputText, final ArrayList<String> inputCommand) {\n\n        for (int i = 0; i < inputText.size(); i++) {\n            modifyingText.add(i, inputText.get(i) + \"$\");\n        }\n\n        for (int i = 0; i < inputCommand.size(); i++) {\n//            System.out.println(\"===============================\");\n//            System.out.println(inputCommand.get(i) + \" \" + cursorLocRow + \" \" + cursorLocLine + \" \" + modifyingText.get(cursorLocLine).length() + \" \" + buffer);\n//            System.out.println(\"===============================\");\n//            modifyingText.forEach(System.out::println);\n\n            if (inputCommand.get(i).equals(\"a\")) editA();\n            else if (inputCommand.get(i).equals(\"e\")) editE();\n            else if (inputCommand.get(i).equals(\"p\")) editP();\n            else if (inputCommand.get(i).equals(\"n\")) editN();\n            else if (inputCommand.get(i).equals(\"f\")) editF();\n            else if (inputCommand.get(i).equals(\"b\")) editB();\n            else if (inputCommand.get(i).equals(\"d\")) editD();\n            else if (inputCommand.get(i).equals(\"k\")) editK();\n            else if (inputCommand.get(i).equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        StringBuilder builder = new StringBuilder(str);\n        return builder.deleteCharAt(removeIndex).toString();\n//        return str.substring(0, removeIndex) + str.substring(removeIndex + 1);\n    }\n\n    private static String insert(String str, int insertIndex) {\n//        return str.substring(0, insertIndex) + buffer + str.substring(insertIndex);\n        StringBuilder builder = new StringBuilder(str);\n\n        if (builder.length() <= insertIndex) {\n            return builder.append(buffer).toString();\n        } else {\n            return builder.insert(insertIndex, buffer).toString();\n        }\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = modifyingText.get(cursorLocLine).length() - 1;\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (modifyingText.size() <= cursorLocLine + 1) return;\n\n        if (modifyingText.get(cursorLocLine + 1) != null) cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (modifyingText.get(cursorLocLine).length() == cursorLocRow + 1) {\n            if (modifyingText.size() <= cursorLocLine + 1) return;\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else if (cursorLocLine > 0) {\n            cursorLocRow = modifyingText.get(cursorLocLine - 1).length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n//        if (cursorLocRow != modifyingText.get(cursorLocLine).length() - 1) {\n        modifyingText.set(cursorLocLine, remove(modifyingText.get(cursorLocLine), cursorLocRow));\n\n//        } else if (modifyingText.get(cursorLocLine + 1) != null) {\n\n        if (modifyingText.get(cursorLocLine).length() == cursorLocRow) {\n            for (int i = cursorLocLine; i < modifyingText.size(); i++) {\n                if(modifyingText.size() >= i + 1) break;\n//                if (modifyingText.get(i + 1) == null) break;\n                modifyingText.add(i, modifyingText.get(i) + modifyingText.get(i + 1));\n            }\n        }\n    }\n\n    private static void editK() {\n        if (cursorLocRow == modifyingText.get(cursorLocLine).length() - 1 && modifyingText.size() <= cursorLocLine + 1) {\n            for (int i = cursorLocLine; i < modifyingText.size(); i++) {\n                if (modifyingText.size() <= cursorLocLine + 1) break;\n                modifyingText.add(i, modifyingText.get(i) + modifyingText.get(i + 1));\n            }\n            if(cursorLocLine != modifyingText.size() - 1) buffer = \"\\n\";\n        } else {\n            if (cursorLocRow < 0) return;\n\n            buffer = modifyingText.get(cursorLocLine).substring(cursorLocRow, modifyingText.get(cursorLocLine).length() - 1);\n            if(cursorLocRow == 0) modifyingText.set(cursorLocLine, \"$\");\n            else modifyingText.add(cursorLocLine, modifyingText.get(cursorLocLine).substring(0, cursorLocRow - 1));\n        }\n    }\n\n    private static void editY() {\n        if (buffer != null) {\n            if (buffer.equals(\"\\n\")) {\n\n                String movingText = modifyingText.get(cursorLocLine).substring(cursorLocRow);\n\n                if (cursorLocRow != 0) {\n                    modifyingText.add(cursorLocLine, modifyingText.get(cursorLocLine).substring(0, cursorLocRow - 1));\n                }\n\n                modifyingText.add(\"\");\n                for (int i = modifyingText.size() - 1; i != cursorLocLine; i--) {\n                    modifyingText.set(i, modifyingText.get(i - 1));\n                }\n                modifyingText.add(cursorLocLine + 1, movingText);\n                cursorLocLine++;\n                cursorLocRow = 0;\n            } else {\n                modifyingText.set(cursorLocLine, insert(modifyingText.get(cursorLocLine), cursorLocRow));\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static String[] modifyingText = new String[MAXMODIFIEDTEXTLINE];\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        String inputText[];\n        String inputCommand[];\n\n        inputText = giveTextLine();\n        inputCommand = giveCommand();\n        modifyText(inputText, inputCommand);\n\n        for(int i = 0; i < modifyingText.length; i++){\n            System.out.println(modifyingText[i]);\n        }\n    }\n\n    private static String[] giveTextLine() {\n        String input;\n        String[] inputText = new String[MAXINPUTLINE];\n        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = String.valueOf(scan.next());\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText[i] = input;\n        }\n        return inputText;\n    }\n\n    private static String[] giveCommand() {\n        String input;\n        String[] inputCommand = new String[MAXINPUTCOMMAND];\n        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = String.valueOf(scan.next());\n            if (input.equals(\"-\")) break;\n            inputCommand[i] = input;\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final String inputText[], final String inputCommand[]) {\n\n        for (int i = 0; i < inputText.length; i++) {\n            modifyingText[i] = inputText[i];\n        }\n\n        for (int i = 0; i < inputCommand.length; i++) {\n            if (inputCommand[i].equals(\"a\")) editA();\n            else if (inputCommand[i].equals(\"e\")) editE();\n            else if (inputCommand[i].equals(\"p\")) editP();\n            else if (inputCommand[i].equals(\"n\")) editN();\n            else if (inputCommand[i].equals(\"f\")) editF();\n            else if (inputCommand[i].equals(\"b\")) editB();\n            else if (inputCommand[i].equals(\"d\")) editD();\n            else if (inputCommand[i].equals(\"k\")) editK();\n            else if (inputCommand[i].equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        return str.substring(0, removeIndex) + str.substring(removeIndex + 1);\n    }\n\n    private static String insert(String str, int insertIndex) {\n        return str.substring(0, insertIndex) + buffer + str.substring(insertIndex);\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = modifyingText[cursorLocLine].length();\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (modifyingText[cursorLocLine + 1] != null) cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (modifyingText[cursorLocLine].length() == cursorLocRow + 1) {\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else {\n            cursorLocRow = modifyingText[cursorLocLine - 1].length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n        if (cursorLocRow != modifyingText[cursorLocLine].length() - 1) {\n            modifyingText[cursorLocLine] = remove(modifyingText[cursorLocLine], cursorLocRow);\n        } else if (modifyingText[cursorLocLine + 1] != null) {\n            for (int i = cursorLocLine; i < modifyingText.length; i++) {\n                if (modifyingText[i + 1] == null) break;\n                modifyingText[i] += modifyingText[i + 1];\n            }\n        }\n\n    }\n\n    private static void editK() {\n        if (cursorLocRow == modifyingText[cursorLocLine].length() - 1 && modifyingText[cursorLocLine + 1] != null) {\n            for (int i = cursorLocLine; i < modifyingText.length; i++) {\n                if (modifyingText[i + 1] == null) break;\n                modifyingText[i] += modifyingText[i + 1];\n            }\n            buffer = \"\\n\";\n        } else {\n            buffer = modifyingText[cursorLocLine].substring(cursorLocRow);\n            modifyingText[cursorLocLine] = modifyingText[cursorLocLine].substring(0, cursorLocRow - 1);\n        }\n    }\n\n    private static void editY() {\n        if(buffer.equals(\"\\n\")) {\n            String movingText = modifyingText[cursorLocLine].substring(cursorLocRow);\n            modifyingText[cursorLocLine] = modifyingText[cursorLocLine].substring(0, cursorLocRow-1);\n            for( int i = modifyingText.length; i != cursorLocLine; i-- ){\n                if(modifyingText[cursorLocLine] != null)\n                    modifyingText[cursorLocLine+1] = modifyingText[cursorLocLine];\n            }\n            cursorLocLine++;\n            cursorLocRow = 0;\n        }else if (buffer != null){\n            modifyingText[cursorLocLine] = insert(modifyingText[cursorLocLine], cursorLocRow);\n        }\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.InputStreamReader;\nimport java.nio.Buffer;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.regex.Pattern;\n\npublic class AOJ1021 {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) throws Exception {\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner sc = new Scanner(new InputStreamReader(System.in));\n\n\t\tArrayList<StringBuilder> lines = new ArrayList<StringBuilder>();\n\t\twhile (true) {\n\t\t\tString text = sc.next();\n\t\t\tif (text.equals(\"END_OF_TEXT\"))\n\t\t\t\tbreak;\n\t\t\tlines.add(new StringBuilder(text));\n\t\t}\n\t\tPoint cursor = new Point();\n\n\t\tString buffer = null;\n\n\t\tcommandLoop: while (true) {\n\t\t\tchar command = sc.next().charAt(0);\n\t\t\tStringBuilder currentLine = lines.get(cursor.y);\n\t\t\tswitch (command) {\n\t\t\tcase 'a':\n\t\t\t\tcursor.x = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tcursor.x = currentLine.length();\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tif (cursor.y > 0)\n\t\t\t\t\tcursor.y--;\n\t\t\t\telse\n\t\t\t\t\tcursor.x = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tif (cursor.y + 1 < lines.size())\n\t\t\t\t\tcursor.y++;\n\t\t\t\tcursor.x = 0; // ?\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (cursor.x < currentLine.length()) {\n\t\t\t\t\tcursor.x++;\n\t\t\t\t}\n\t\t\t\telse if (cursor.y + 1 < lines.size()) {\n\t\t\t\t\tcursor.y++;\n\t\t\t\t\tcursor.x = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tif (cursor.x > 0) {\n\t\t\t\t\tcursor.x--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (cursor.y > 0) {\n\t\t\t\t\tcursor.y--;\n\t\t\t\t\tcursor.x = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif (cursor.x < currentLine.length()) {\n\t\t\t\t\tcurrentLine.deleteCharAt(cursor.x);\n\t\t\t\t}\n\t\t\t\telse if (cursor.y + 1 < lines.size()) {\n\t\t\t\t\tcurrentLine.append(lines.remove(cursor.y + 1));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tif (cursor.x == currentLine.length()) {\n\t\t\t\t\tif (cursor.y + 1 < lines.size()) {\n\t\t\t\t\t\tcurrentLine.append(lines.remove(cursor.y + 1));\n\t\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = currentLine.substring(cursor.x);\n\t\t\t\t\tcurrentLine.delete(cursor.x, currentLine.length());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\tif (buffer != null) {\n\t\t\t\t\tif (buffer.equals(\"\\n\")) {\n\t\t\t\t\t\tStringBuilder newLine = new StringBuilder();\n\t\t\t\t\t\tif(cursor.x != currentLine.length()) {\n\t\t\t\t\t\t\tnewLine.append(currentLine.substring(cursor.x));\n\t\t\t\t\t\t\tcurrentLine.delete(cursor.x, currentLine.length());\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlines.add(cursor.y, newLine);\n\t\t\t\t\t\tcursor.y++;\n\t\t\t\t\t\tcursor.x = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(cursor.x == currentLine.length())\n\t\t\t\t\t\t\tcurrentLine.append(buffer);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcurrentLine.insert(cursor.x, buffer);\n\t\t\t\t\t\tcursor.x += buffer.length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak commandLoop;\n\t\t\t}\n//\t\t\tSystem.out.println(cursor);\n//\t\t\tSystem.out.println(currentLine);\n\t\t}\n\t\tfor (StringBuilder sb : lines) {\n\t\t\tSystem.out.println(sb);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static final String ENDOFLINE = \"$\";\n    static Scanner scan = new Scanner(System.in);\n    static ArrayList<String> modifyingText = new ArrayList<String>();\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        ArrayList<String> inputText;\n        ArrayList<String> inputCommand;\n\n        inputText = giveTextLine();\n//        System.out.println(\"==============================\");\n//        System.out.println(\"give Text Success\");\n\n        inputCommand = giveCommand();\n\n//        System.out.println(\"==============================\");\n//        System.out.println(\"give Command Success\");\n        modifyText(inputText, inputCommand);\n\n        for (int i = 0; i < modifyingText.size(); i++) {\n            int outLen = modifyingText.get(i).length();\n            if (outLen <= 1) {\n                System.out.print(\"\\n\");\n            } else System.out.println(modifyingText.get(i).substring(0, outLen - 1));\n        }\n    }\n\n    private static ArrayList<String> giveTextLine() {\n        String input;\n        ArrayList<String> inputText = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText.add(i, input);\n        }\n        return inputText;\n    }\n\n    private static ArrayList<String> giveCommand() {\n        String input;\n        ArrayList<String> inputCommand = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"-\")) break;\n            inputCommand.add(i, input);\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final ArrayList<String> inputText, final ArrayList<String> inputCommand) {\n\n        for (int i = 0; i < inputText.size(); i++) {\n            modifyingText.add(i, inputText.get(i) + ENDOFLINE);\n        }\n\n        for (int i = 0; i < inputCommand.size(); i++) {\n//            System.out.println(\"===============================\");\n//            System.out.println(inputCommand.get(i) + \" \" + cursorLocRow + \" \" + cursorLocLine + \" \" + modifyingText.get(cursorLocLine).length() + \" \" + buffer);\n//            System.out.println(\"===============================\");\n//            modifyingText.forEach(System.out::println);\n\n            if (inputCommand.get(i).equals(\"a\")) editA();\n            else if (inputCommand.get(i).equals(\"e\")) editE();\n            else if (inputCommand.get(i).equals(\"p\")) editP();\n            else if (inputCommand.get(i).equals(\"n\")) editN();\n            else if (inputCommand.get(i).equals(\"f\")) editF();\n            else if (inputCommand.get(i).equals(\"b\")) editB();\n            else if (inputCommand.get(i).equals(\"d\")) editD();\n            else if (inputCommand.get(i).equals(\"k\")) editK();\n            else if (inputCommand.get(i).equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        StringBuilder builder = new StringBuilder(str);\n        return builder.deleteCharAt(removeIndex).toString();\n    }\n\n    private static String insert(String str, int insertIndex) {\n        StringBuilder builder = new StringBuilder(str);\n\n        if (builder.length() <= insertIndex) {\n            return builder.append(buffer).toString();\n        } else {\n            return builder.insert(insertIndex, buffer).toString();\n        }\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = currentLineString().length() - 1;\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (isLastLine()) return;\n        cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (isLastRow()) {\n            if (isLastLine()) return;\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else if (cursorLocLine > 0) {\n            cursorLocRow = modifyingText.get(cursorLocLine - 1).length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n        if (!isLastRow()) {\n            replaceCurrentLine(remove(modifyingText.get(cursorLocLine), cursorLocRow));\n        } else {\n            if (currentLineString().length() == 1) {\n                modifyingText.remove(cursorLocLine);\n            } else if (!isLastLine()) {\n                replaceCurrentLine(currentLineString() + modifyingText.get(cursorLocLine + 1));\n                replaceCurrentLine(remove(currentLineString(), cursorLocRow));\n                for (int i = cursorLocLine + 1; i < modifyingText.size(); i++) {\n                    if (isLastLine(i + 1)) break;\n                    replaceLine(i, modifyingText.get(i + 1));\n                }\n            }\n        }\n    }\n\n    private static void editK() {\n        if (isLastRow()) {\n            if (!isLastLine()) {\n\n                replaceCurrentLine(currentLineString() + modifyingText.get(cursorLocLine + 1));\n                replaceCurrentLine(remove(currentLineString(), cursorLocRow));\n\n                for (int i = cursorLocLine + 1; i < modifyingText.size(); i++) {\n                    if (isLastLine(i + 1))\n                        replaceLine(i, modifyingText.get(i + 1));\n                }\n                modifyingText.remove(lastLine());\n                buffer = \"\\n\";\n            }\n        } else {\n            buffer = currentLineString().substring(cursorLocRow, currentLineString().length() - 1);\n            if (cursorLocRow == 0) replaceCurrentLine(ENDOFLINE);\n            else replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n            cursorLocRow = currentLineString().length() - 1;\n        }\n    }\n\n    private static void editY() {\n        if (buffer != null) {\n            if (buffer.equals(\"\\n\")) {\n\n                if (isLastRow()) {\n                    String movingText = currentLineString().substring(cursorLocRow);\n                    replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n                    insertLine(cursorLocLine + 1, movingText);\n                } else {\n                    String movingText = currentLineString().substring(cursorLocRow);\n                    insertLine(cursorLocLine + 1, movingText);\n\n                    if (cursorLocRow != 0) {\n                        replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n                    } else {\n                        replaceCurrentLine(ENDOFLINE);\n                    }\n                }\n                cursorLocRow = 0;\n                cursorLocLine++;\n\n            } else {\n                replaceCurrentLine(insert(currentLineString(), cursorLocRow));\n                cursorLocRow += buffer.length();\n            }\n        }\n    }\n\n    private static String currentLineString() {\n        return modifyingText.get(cursorLocLine);\n    }\n\n    private static void replaceLine(int index, String str) {\n        modifyingText.set(index, str);\n    }\n\n    private static void replaceCurrentLine(String str) {\n        modifyingText.set(cursorLocLine, str);\n    }\n\n    private static void insertLine(int index, String str) {\n        modifyingText.add(index, str);\n    }\n\n    private static void insertInCurrentLine(String str) {\n        modifyingText.add(cursorLocLine, str);\n    }\n\n    private static boolean isLastLine() {\n        return modifyingText.size() <= cursorLocLine + 1;\n    }\n\n    private static boolean isLastLine(int i) {\n        return modifyingText.size() > i;\n    }\n\n    private static boolean isLastRow() {\n        return modifyingText.get(cursorLocLine).length() <= cursorLocRow + 1;\n    }\n\n    private static int lastLine() {\n        return modifyingText.size() - 1;\n    }\n\n    private static boolean isEOL() {\n        return String.valueOf(currentLineString().charAt(cursorLocRow)).equals(ENDOFLINE);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static ArrayList<String> modifyingText = new ArrayList<String>();\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        String inputText[];\n        String inputCommand[];\n\n        inputText = giveTextLine();\n        inputCommand = giveCommand();\n        modifyText(inputText, inputCommand);\n\n        for(int i = 0; i < modifyingText.size(); i++){\n            System.out.println(modifyingText.get(i));\n        }\n    }\n\n    private static String[] giveTextLine() {\n        String input;\n        String[] inputText = new String[MAXINPUTLINE];\n        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = String.valueOf(scan.next());\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText[i] = input;\n        }\n        return inputText;\n    }\n\n    private static String[] giveCommand() {\n        String input;\n        String[] inputCommand = new String[MAXINPUTCOMMAND];\n        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = String.valueOf(scan.next());\n            if (input.equals(\"-\")) break;\n            inputCommand[i] = input;\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final String inputText[], final String inputCommand[]) {\n\n        for (int i = 0; i < inputText.length; i++) {\n            modifyingText.add(i, inputText[i]);\n        }\n\n        for (int i = 0; i < inputCommand.length; i++) {\n            if (inputCommand[i].equals(\"a\")) editA();\n            else if (inputCommand[i].equals(\"e\")) editE();\n            else if (inputCommand[i].equals(\"p\")) editP();\n            else if (inputCommand[i].equals(\"n\")) editN();\n            else if (inputCommand[i].equals(\"f\")) editF();\n            else if (inputCommand[i].equals(\"b\")) editB();\n            else if (inputCommand[i].equals(\"d\")) editD();\n            else if (inputCommand[i].equals(\"k\")) editK();\n            else if (inputCommand[i].equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        StringBuilder builder = new StringBuilder(str);\n        return builder.deleteCharAt(removeIndex).toString();\n//        return str.substring(0, removeIndex) + str.substring(removeIndex + 1);\n    }\n\n    private static String insert(String str, int insertIndex) {\n        StringBuilder builder = new StringBuilder(str);\n        return builder.insert(insertIndex, buffer).toString();\n//        return str.substring(0, insertIndex) + buffer + str.substring(insertIndex);\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = modifyingText.get(cursorLocLine).length();\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (modifyingText.get(cursorLocLine + 1) != null) cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (modifyingText.get(cursorLocLine).length() == cursorLocRow + 1) {\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else {\n            cursorLocRow = modifyingText.get(cursorLocLine - 1).length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n        if (cursorLocRow != modifyingText.get(cursorLocLine).length() - 1) {\n            modifyingText.add(cursorLocLine, remove(modifyingText.get(cursorLocLine), cursorLocRow));\n        } else if (modifyingText.get(cursorLocLine + 1) != null) {\n            for (int i = cursorLocLine; i < modifyingText.size(); i++) {\n                if (modifyingText.get(i + 1) == null) break;\n                modifyingText.add(i, modifyingText.get(i) + modifyingText.get(i + 1));\n            }\n        }\n\n    }\n\n    private static void editK() {\n        if (cursorLocRow == modifyingText.get(cursorLocLine).length() - 1 && modifyingText.get(cursorLocLine + 1) != null) {\n            for (int i = cursorLocLine; i < modifyingText.size(); i++) {\n                if (modifyingText.get(i + 1) == null) break;\n                modifyingText.add(i, modifyingText.get(i) + modifyingText.get(i + 1));\n            }\n            buffer = \"\\n\";\n        } else {\n            buffer = modifyingText.get(cursorLocLine).substring(cursorLocRow);\n            modifyingText.add(cursorLocLine, modifyingText.get(cursorLocLine).substring(0, cursorLocRow - 1));\n        }\n    }\n\n    private static void editY() {\n        if(buffer.equals(\"\\n\")) {\n            String movingText = modifyingText.get(cursorLocLine).substring(cursorLocRow);\n            modifyingText.add(cursorLocLine, modifyingText.get(cursorLocLine).substring(0, cursorLocRow-1));\n            for( int i = modifyingText.size(); i != cursorLocLine; i-- ){\n                if(modifyingText.get(cursorLocLine) != null)\n                    modifyingText.add(cursorLocLine + 1, modifyingText.get(cursorLocLine));\n            }\n            cursorLocLine++;\n            cursorLocRow = 0;\n        }else if (buffer != null){\n            modifyingText.add(cursorLocLine, insert(modifyingText.get(cursorLocLine), cursorLocRow));\n        }\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) throws Exception {\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner sc = new Scanner(new InputStreamReader(System.in));\n\n\t\tList<StringBuilder> lines = new ArrayList<StringBuilder>();\n\t\twhile (true) {\n\t\t\tString text = sc.next();\n\t\t\tif (text.equals(\"END_OF_TEXT\"))\n\t\t\t\tbreak;\n\t\t\tlines.add(new StringBuilder(text));\n\t\t}\n\t\tPoint cursor = new Point();\n\n\t\tString buffer = null;\n\n\t\tcommandLoop: while (true) {\n\t\t\tchar command = sc.next().charAt(0);\n\t\t\tStringBuilder currentLine = lines.get(cursor.y);\n\t\t\tswitch (command) {\n\t\t\tcase 'a':\n\t\t\t\tcursor.x = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tcursor.x = currentLine.length();\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tif (cursor.y > 0)\n\t\t\t\t\tcursor.y--;\n\t\t\t\tcursor.x = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tif (cursor.y + 1 < lines.size())\n\t\t\t\t\tcursor.y++;\n\t\t\t\tcursor.x = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (cursor.x < currentLine.length()) {\n\t\t\t\t\tcursor.x++;\n\t\t\t\t}\n\t\t\t\telse if (cursor.y + 1 < lines.size()) {\n\t\t\t\t\tcursor.y++;\n\t\t\t\t\tcursor.x = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tif (cursor.x > 0) {\n\t\t\t\t\tcursor.x--;\n\t\t\t\t}\n\t\t\t\telse if (cursor.y > 0) {\n\t\t\t\t\tcursor.y--;\n\t\t\t\t\tcursor.x = lines.get(cursor.y).length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif (cursor.x < currentLine.length()) {\n\t\t\t\t\tcurrentLine.deleteCharAt(cursor.x);\n\t\t\t\t}\n\t\t\t\telse if (cursor.y + 1 < lines.size()) {\n\t\t\t\t\tcurrentLine.append(lines.remove(cursor.y + 1));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tif (cursor.x == currentLine.length()) {\n\t\t\t\t\tif (cursor.y + 1 < lines.size()) {\n\t\t\t\t\t\tcurrentLine.append(lines.remove(cursor.y + 1));\n\t\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = currentLine.substring(cursor.x);\n\t\t\t\t\tcurrentLine.delete(cursor.x, currentLine.length());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\tif (buffer != null) {\n\t\t\t\t\tif (buffer.equals(\"\\n\")) {\n\t\t\t\t\t\tStringBuilder newLine = new StringBuilder();\n\t\t\t\t\t\tif (cursor.x != currentLine.length()) {\n\t\t\t\t\t\t\tnewLine.append(currentLine.substring(cursor.x));\n\t\t\t\t\t\t\tcurrentLine.delete(cursor.x, currentLine.length());\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlines.add(cursor.y+1, newLine);\n\t\t\t\t\t\tcursor.y++;\n\t\t\t\t\t\tcursor.x = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (cursor.x == currentLine.length()) {\n\t\t\t\t\t\t\tcurrentLine.append(buffer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcurrentLine.insert(cursor.x, buffer);\n\t\t\t\t\t\tcursor.x += buffer.length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak commandLoop;\n\t\t\t}\n\t\t\t// System.out.println(cursor);\n\t\t\t// System.out.println(currentLine);\n\t\t}\n\t\tfor (StringBuilder sb : lines) {\n\t\t\tSystem.out.println(sb);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static final String ENDOFLINE = \"$\";\n    static Scanner scan = new Scanner(System.in);\n    static ArrayList<String> modifyingText = new ArrayList<String>();\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        ArrayList<String> inputText;\n        ArrayList<String> inputCommand;\n\n        inputText = giveTextLine();\n//        System.out.println(\"==============================\");\n//        System.out.println(\"give Text Success\");\n\n        inputCommand = giveCommand();\n\n//        System.out.println(\"==============================\");\n//        System.out.println(\"give Command Success\");\n        modifyText(inputText, inputCommand);\n\n        for (int i = 0; i < modifyingText.size(); i++) {\n            int outLen = modifyingText.get(i).length();\n            if (outLen <= 1) {\n                System.out.print(\"\\n\");\n            } else System.out.println(modifyingText.get(i).substring(0, outLen - 1));\n        }\n    }\n\n    private static ArrayList<String> giveTextLine() {\n        String input;\n        ArrayList<String> inputText = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText.add(i, input);\n        }\n        return inputText;\n    }\n\n    private static ArrayList<String> giveCommand() {\n        String input;\n        ArrayList<String> inputCommand = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"-\")) break;\n            inputCommand.add(i, input);\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final ArrayList<String> inputText, final ArrayList<String> inputCommand) {\n\n        for (int i = 0; i < inputText.size(); i++) {\n            modifyingText.add(i, inputText.get(i) + ENDOFLINE);\n        }\n\n        for (int i = 0; i < inputCommand.size(); i++) {\n//            System.out.println(\"===============================\");\n//            System.out.println(inputCommand.get(i) + \" \" + cursorLocRow + \" \" + cursorLocLine + \" \" + modifyingText.get(cursorLocLine).length() + \" \" + buffer);\n//            System.out.println(\"===============================\");\n//            modifyingText.forEach(System.out::println);\n\n            if (inputCommand.get(i).equals(\"a\")) editA();\n            else if (inputCommand.get(i).equals(\"e\")) editE();\n            else if (inputCommand.get(i).equals(\"p\")) editP();\n            else if (inputCommand.get(i).equals(\"n\")) editN();\n            else if (inputCommand.get(i).equals(\"f\")) editF();\n            else if (inputCommand.get(i).equals(\"b\")) editB();\n            else if (inputCommand.get(i).equals(\"d\")) editD();\n            else if (inputCommand.get(i).equals(\"k\")) editK();\n            else if (inputCommand.get(i).equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        StringBuilder builder = new StringBuilder(str);\n        return builder.deleteCharAt(removeIndex).toString();\n    }\n\n    private static String insert(String str, int insertIndex) {\n        StringBuilder builder = new StringBuilder(str);\n\n        if (builder.length() <= insertIndex) {\n            return builder.append(buffer).toString();\n        } else {\n            return builder.insert(insertIndex, buffer).toString();\n        }\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = currentLineString().length() - 1;\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (isLastLine()) return;\n        cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (isLastRow()) {\n            if (isLastLine()) return;\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else if (cursorLocLine > 0) {\n            cursorLocRow = modifyingText.get(cursorLocLine - 1).length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n        if (!isEOL()) {\n            replaceCurrentLine(remove(modifyingText.get(cursorLocLine), cursorLocRow));\n        } else {\n            if (!isLastLine()) {\n                replaceCurrentLine(currentLineString() + modifyingText.get(cursorLocLine + 1));\n                replaceCurrentLine(remove(currentLineString(), cursorLocRow));\n                for (int i = cursorLocLine + 1; i < modifyingText.size(); i++) {\n                    if (isLastLine(i + 1)) break;\n                    replaceLine(i, modifyingText.get(i) + modifyingText.get(i + 1));\n                }\n            }\n        }\n    }\n\n    private static void editK() {\n        if (isLastRow()) {\n            if (!isLastLine()) {\n\n                replaceCurrentLine(currentLineString() + modifyingText.get(cursorLocLine + 1));\n                replaceCurrentLine(remove(currentLineString(), cursorLocRow));\n\n                for (int i = cursorLocLine + 1; i < modifyingText.size(); i++) {\n                    if (isLastLine(i + 1))\n                        replaceLine(i, modifyingText.get(i + 1));\n                }\n                modifyingText.remove(lastLine());\n                buffer = \"\\n\";\n            }\n        } else {\n            buffer = currentLineString().substring(cursorLocRow, currentLineString().length() - 1);\n            if (cursorLocRow == 0) replaceCurrentLine(ENDOFLINE);\n            else replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n            cursorLocRow = currentLineString().length() - 1;\n        }\n    }\n\n    private static void editY() {\n        if (buffer != null) {\n            if (buffer.equals(\"\\n\")) {\n\n                if (isLastRow()) {\n                    String movingText = currentLineString().substring(cursorLocRow);\n                    replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n                    insertLine(cursorLocLine + 1, movingText);\n                } else {\n                    String movingText = currentLineString().substring(cursorLocRow);\n                    insertLine(cursorLocLine + 1, movingText);\n\n                    if (cursorLocRow != 0) {\n                        replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n                    } else {\n                        replaceCurrentLine(ENDOFLINE);\n                    }\n                }\n                cursorLocRow = 0;\n                cursorLocLine++;\n\n            } else {\n                replaceCurrentLine(insert(currentLineString(), cursorLocRow));\n\n            }\n        }\n    }\n\n    private static String currentLineString() {\n        return modifyingText.get(cursorLocLine);\n    }\n\n    private static void replaceLine(int index, String str) {\n        modifyingText.set(index, str);\n    }\n\n    private static void replaceCurrentLine(String str) {\n        modifyingText.set(cursorLocLine, str);\n    }\n\n    private static void insertLine(int index, String str) {\n        modifyingText.add(index, str);\n    }\n\n    private static void insertInCurrentLine(String str) {\n        modifyingText.add(cursorLocLine, str);\n    }\n\n    private static boolean isLastLine() {\n        return modifyingText.size() <= cursorLocLine + 1;\n    }\n\n    private static boolean isLastLine(int i) {\n        return modifyingText.size() > i;\n    }\n\n    private static boolean isLastRow() {\n        return modifyingText.get(cursorLocLine).length() <= cursorLocRow + 1;\n    }\n\n    private static int lastLine() {\n        return modifyingText.size() - 1;\n    }\n\n    private static boolean isEOL() {\n        return String.valueOf(currentLineString().charAt(cursorLocRow)).equals(ENDOFLINE);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\npublic class Main{\n        public static void main(String[] arg) throws IOException {\n                BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                String is;\n                String[] ia;\n\n                while((is = in.readLine()) != null){\n                        al = new ArrayList<StringBuffer>();\n                        while(!is.equals(\"END_OF_TEXT\")){\n                                al.add(new StringBuffer(is));\n                                is = in.readLine();\n                        }\n                        line = 0;\n                        chat = 0;\n                        buffer = null;\n                        loc = false;\n                        while((is = in.readLine()).charAt(0) != '-'){\n                                switch(is.charAt(0)){\n                                case 'a':\n                                        chat = 0;\n                                        break;\n                                case 'e':\n                                        chat = al.get(line).length();\n                                        break;\n                                case 'p':\n                                        chat = 0;\n                                        if(0 < line && line < al.size()){\n                                                --line;\n                                        }\n                                        break;\n                                case 'n':\n                                        chat = 0;\n                                        if(0 <= line && line < al.size()-1){\n                                                ++line;\n                                        }\n                                        break;\n                                case 'f':\n                                        if(chat < al.get(line).length()){\n                                                ++chat;\n                                        } else if(0 <= line && line < al.size()-1){\n                                                ++line;\n                                                chat = 0;\n                                        }\n                                        break;\n                                case 'b':\n                                        if(0 < chat){\n                                                --chat;\n                                        } else if(0 < line && line < al.size()){\n                                                --line;\n                                                chat = al.get(line).length();\n                                        }\n                                        break;\n                                case 'd':\n                                        if(0 <= chat && chat < al.get(line).length()){\n                                                al.get(line).deleteCharAt(chat);\n                                        } else if(chat == al.get(line).length() &&\n                                                  0 <= line && line < al.size()-1){\n                                                al.get(line).append(al.get(line+1));\n                                                al.remove(line+1);\n                                        }\n                                        break;\n                                case 'k':\n                                        if(0 <= chat && chat < al.get(line).length()){\n                                                loc = false;\n                                                buffer = new StringBuffer(al.get(line).substring(chat));\n                                                al.get(line).delete(chat, al.get(line).length());\n                                                chat = al.get(line).length();\n                                        } else {\n                                                if(chat == al.get(line).length() &&\n                                                  0 <= line && line < al.size()-1){\n                                                        loc = true;\n                                                        al.get(line).append(al.get(line+1));\n                                                        al.remove(line+1);\n                                                        buffer = new StringBuffer();\n                                                }\n                                        }\n                                        break;\n                                case 'y':\n                                        if(buffer == null){\n                                        } else if(loc){\n                                                al.add(line+1, new StringBuffer(al.get(line).substring(chat)));\n                                                al.get(line).delete(chat, al.get(line).length());\n                                                chat = 0;\n                                                ++line;\n                                        } else {\n                                                al.set(line, new StringBuffer(al.get(line).substring(0,chat)).append(buffer).append(al.get(line).substring(chat)));\n                                                chat+=buffer.length();\n                                        }\n                                        break;\n                                }\n                        }\n                        for(int i = 0;i < al.size(); ++i){\n                                System.out.println(al.get(i));\n                        }\n                }\n        }\n        static int line;\n        static int chat;\n        static StringBuffer buffer;\n        static boolean loc;\n        static ArrayList<StringBuffer> al;\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.xml.crypto.Data;\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tStringBuilder[] sb = new StringBuilder[101];\n\t\tfor(int i = 0; i < sb.length; i++) {\n\t\t\tsb[i] = new StringBuilder();\n\t\t}\n\t\tint len = 0;\n\t\twhile(true) {\n\t\t\tString in = sc.nextLine();\n\t\t\tif(in.equals(\"END_OF_TEXT\")) break;\n\t\t\tsb[len++].append(in);\n\t\t}\n\t\tboolean LF = false;\n\t\tStringBuilder buffer = new StringBuilder();\n\t\tint ci = 0;\n\t\tint cj = 0;\n\t\twhile(true) {\n\t\t\tString in = sc.nextLine();\n\t\t\tif(in.equals(\"-\")) break;\n\t\t\tif(in.equals(\"a\")) {\n\t\t\t\tcj = 0;\n\t\t\t}\n\t\t\tif(in.equals(\"e\")) {\n\t\t\t\tcj = sb[ci].length();\n\t\t\t}\n\t\t\tif(in.equals(\"p\")) {\n\t\t\t\tif(ci != 0) {\n\t\t\t\t\tci--;\n\t\t\t\t}\n\t\t\t\tcj = 0;\t\n\t\t\t}\n\t\t\tif(in.equals(\"n\")) {\n\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\tci++;\n\t\t\t\t}\n\t\t\t\tcj = 0;\n\t\t\t}\n\t\t\tif(in.equals(\"f\")) {\n\t\t\t\tif(cj != sb[ci].length()) {\n\t\t\t\t\tcj++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\tcj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"b\")) {\n\t\t\t\tif(cj != 0) {\n\t\t\t\t\tcj--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci != 0) {\n\t\t\t\t\t\tci--;\n\t\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"d\")) {\n\t\t\t\tif(cj != sb[ci].length()) {\n\t\t\t\t\tsb[ci].deleteCharAt(cj);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tsb[ci].append(sb[ci+1]);\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\twhile(ci+1 != len) {\n\t\t\t\t\t\t\tsb[ci] = sb[ci+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"k\")) {\n\t\t\t\tif(cj == sb[ci].length()) {\n\t\t\t\t\tif(ci+1 != len) {\n\t\t\t\t\t\tsb[ci].append(sb[ci+1]);\n\t\t\t\t\t\tci++;\n\t\t\t\t\t\twhile(ci+1 != len) {\n\t\t\t\t\t\t\tsb[ci] = sb[ci+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t\tbuffer = new StringBuilder();\n\t\t\t\t\tLF = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = new StringBuilder(sb[ci].substring(cj, sb[ci].length()));\n\t\t\t\t\tsb[ci].delete(cj, sb[ci].length());\n\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\tLF = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in.equals(\"y\")) {\n\t\t\t\tif(LF) {\n\t\t\t\t\tint now = len;\n\t\t\t\t\twhile(now != ci) {\n\t\t\t\t\t\tsb[now] = sb[now-1];\n\t\t\t\t\t}\n\t\t\t\t\tlen++;\n\t\t\t\t\tsb[ci+1] = new StringBuilder(sb[ci].substring(cj,sb[ci].length()));\n\t\t\t\t\tsb[ci].delete(cj, sb[ci].length());\n\t\t\t\t\tci++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(cj == sb[ci].length()) {\n\t\t\t\t\t\tsb[ci].insert(cj, buffer);\n\t\t\t\t\t\tcj = sb[ci].length();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsb[ci].insert(cj, buffer);\n\t\t\t\t\t\tcj += buffer.length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < len+1; i++) {\n\t\t\tSystem.out.println(sb[i].toString());\n\t\t}\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static final String ENDOFLINE = \"$\";\n    static Scanner scan = new Scanner(System.in);\n    static ArrayList<String> modifyingText = new ArrayList<String>();\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        ArrayList<String> inputText;\n        ArrayList<String> inputCommand;\n\n        inputText = giveTextLine();\n//        System.out.println(\"==============================\");\n//        System.out.println(\"give Text Success\");\n\n        inputCommand = giveCommand();\n\n//        System.out.println(\"==============================\");\n//        System.out.println(\"give Command Success\");\n        modifyText(inputText, inputCommand);\n\n        for (int i = 0; i < modifyingText.size(); i++) {\n            int outLen = modifyingText.get(i).length();\n            if (outLen <= 1) {\n                System.out.print(\"\\n\");\n            } else System.out.println(modifyingText.get(i).substring(0, outLen - 1));\n        }\n    }\n\n    private static ArrayList<String> giveTextLine() {\n        String input;\n        ArrayList<String> inputText = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText.add(i, input);\n        }\n        return inputText;\n    }\n\n    private static ArrayList<String> giveCommand() {\n        String input;\n        ArrayList<String> inputCommand = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"-\")) break;\n            inputCommand.add(i, input);\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final ArrayList<String> inputText, final ArrayList<String> inputCommand) {\n\n        for (int i = 0; i < inputText.size(); i++) {\n            modifyingText.add(i, inputText.get(i) + ENDOFLINE);\n        }\n\n        for (int i = 0; i < inputCommand.size(); i++) {\n//            System.out.println(\"===============================\");\n//            System.out.println(inputCommand.get(i) + \" \" + cursorLocRow + \" \" + cursorLocLine + \" \" + modifyingText.get(cursorLocLine).length() + \" \" + buffer);\n//            System.out.println(\"===============================\");\n//            modifyingText.forEach(System.out::println);\n\n            if (inputCommand.get(i).equals(\"a\")) editA();\n            else if (inputCommand.get(i).equals(\"e\")) editE();\n            else if (inputCommand.get(i).equals(\"p\")) editP();\n            else if (inputCommand.get(i).equals(\"n\")) editN();\n            else if (inputCommand.get(i).equals(\"f\")) editF();\n            else if (inputCommand.get(i).equals(\"b\")) editB();\n            else if (inputCommand.get(i).equals(\"d\")) editD();\n            else if (inputCommand.get(i).equals(\"k\")) editK();\n            else if (inputCommand.get(i).equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        StringBuilder builder = new StringBuilder(str);\n        return builder.deleteCharAt(removeIndex).toString();\n    }\n\n    private static String insert(String str, int insertIndex) {\n        StringBuilder builder = new StringBuilder(str);\n\n        if (builder.length() <= insertIndex) {\n            return builder.append(buffer).toString();\n        } else {\n            return builder.insert(insertIndex, buffer).toString();\n        }\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = currentLineString().length() - 1;\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (isLastLine()) return;\n        cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (isLastRow()) {\n            if (isLastLine()) return;\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else if (cursorLocLine > 0) {\n            cursorLocRow = modifyingText.get(cursorLocLine - 1).length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n        if (!isEOL()) {\n            replaceCurrentLine(remove(modifyingText.get(cursorLocLine), cursorLocRow));\n        } else {\n            if (!isLastLine()) {\n                replaceCurrentLine(currentLineString() + modifyingText.get(cursorLocLine + 1));\n                replaceCurrentLine(remove(currentLineString(), cursorLocRow));\n                for (int i = cursorLocLine + 1; i < modifyingText.size(); i++) {\n                    if (isLastLine(i + 1)) break;\n                    replaceLine(i, modifyingText.get(i) + modifyingText.get(i + 1));\n                }\n            }\n        }\n    }\n\n    private static void editK() {\n        if (isLastRow()) {\n            if (!isLastLine()) {\n\n                replaceCurrentLine(currentLineString() + modifyingText.get(cursorLocLine + 1));\n                replaceCurrentLine(remove(currentLineString(), cursorLocRow));\n\n                for (int i = cursorLocLine + 1; i < modifyingText.size(); i++) {\n                    if (isLastLine(i + 1))\n                        replaceLine(i, modifyingText.get(i + 1));\n                }\n                modifyingText.remove(lastLine());\n                buffer = \"\\n\";\n            }\n        } else {\n            buffer = currentLineString().substring(cursorLocRow, currentLineString().length() - 1);\n            if (cursorLocRow == 0) replaceCurrentLine(ENDOFLINE);\n            else replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n        }\n    }\n\n    private static void editY() {\n        if (buffer != null) {\n            if (buffer.equals(\"\\n\")) {\n\n                if (isLastRow()) {\n                    String movingText = currentLineString().substring(cursorLocRow);\n                    replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n                    insertLine(cursorLocLine + 1, movingText);\n                } else {\n                    String movingText = currentLineString().substring(cursorLocRow);\n                    insertLine(cursorLocLine + 1, movingText);\n\n                    if (cursorLocRow != 0) {\n                        replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n                    } else {\n                        replaceCurrentLine(ENDOFLINE);\n                    }\n                }\n\n            } else {\n                replaceCurrentLine(insert(currentLineString(), cursorLocRow));\n            }\n        }\n    }\n\n    private static String currentLineString() {\n        return modifyingText.get(cursorLocLine);\n    }\n\n    private static void replaceLine(int index, String str) {\n        modifyingText.set(index, str);\n    }\n\n    private static void replaceCurrentLine(String str) {\n        modifyingText.set(cursorLocLine, str);\n    }\n\n    private static void insertLine(int index, String str) {\n        modifyingText.add(index, str);\n    }\n\n    private static void insertInCurrentLine(String str) {\n        modifyingText.add(cursorLocLine, str);\n    }\n\n    private static boolean isLastLine() {\n        return modifyingText.size() <= cursorLocLine + 1;\n    }\n\n    private static boolean isLastLine(int i) {\n        return modifyingText.size() > i;\n    }\n\n    private static boolean isLastRow() {\n        return modifyingText.get(cursorLocLine).length() <= cursorLocRow + 1;\n    }\n\n    private static int lastLine() {\n        return modifyingText.size() - 1;\n    }\n\n    private static boolean isEOL() {\n        return String.valueOf(currentLineString().charAt(cursorLocRow)).equals(ENDOFLINE);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) throws Exception {\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner sc = new Scanner(new InputStreamReader(System.in));\n\n\t\twhile (sc.hasNext()) {\n\t\t\tList<StringBuilder> lines = new ArrayList<StringBuilder>();\n\t\t\twhile (true) {\n\t\t\t\tString text = sc.next();\n\t\t\t\tif (text.equals(\"END_OF_TEXT\"))\n\t\t\t\t\tbreak;\n\t\t\t\tlines.add(new StringBuilder(text));\n\t\t\t}\n\t\t\tPoint cursor = new Point();\n\t\t\tString buffer = null;\n\t\t\tcommandLoop: while (true) {\n\t\t\t\tchar command = sc.next().charAt(0);\n\t\t\t\tStringBuilder currentLine = lines.get(cursor.y);\n\t\t\t\tswitch (command) {\n\t\t\t\tcase 'a':\n\t\t\t\t\tcursor.x = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e':\n\t\t\t\t\tcursor.x = currentLine.length();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\n\t\t\t\t\tif (cursor.y > 0)\n\t\t\t\t\t\tcursor.y--;\n\t\t\t\t\tcursor.x = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'n':\n\t\t\t\t\tif (cursor.y + 1 < lines.size())\n\t\t\t\t\t\tcursor.y++;\n\t\t\t\t\tcursor.x = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tif (cursor.x < currentLine.length()) {\n\t\t\t\t\t\tcursor.x++;\n\t\t\t\t\t}\n\t\t\t\t\telse if (cursor.y + 1 < lines.size()) {\n\t\t\t\t\t\tcursor.y++;\n\t\t\t\t\t\tcursor.x = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tif (cursor.x > 0) {\n\t\t\t\t\t\tcursor.x--;\n\t\t\t\t\t}\n\t\t\t\t\telse if (cursor.y > 0) {\n\t\t\t\t\t\tcursor.y--;\n\t\t\t\t\t\tcursor.x = lines.get(cursor.y).length();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tif (cursor.x < currentLine.length()) {\n\t\t\t\t\t\tcurrentLine.deleteCharAt(cursor.x);\n\t\t\t\t\t}\n\t\t\t\t\telse if (cursor.y + 1 < lines.size()) {\n\t\t\t\t\t\tcurrentLine.append(lines.remove(cursor.y + 1));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'k':\n\t\t\t\t\tif (cursor.x == currentLine.length()) {\n\t\t\t\t\t\tif (cursor.y + 1 < lines.size()) {\n\t\t\t\t\t\t\tcurrentLine.append(lines.remove(cursor.y + 1));\n\t\t\t\t\t\t\tbuffer = \"\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuffer = currentLine.substring(cursor.x);\n\t\t\t\t\t\tcurrentLine.delete(cursor.x, currentLine.length());\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'y':\n\t\t\t\t\tif (buffer != null) {\n\t\t\t\t\t\tif (buffer.equals(\"\\n\")) {\n\t\t\t\t\t\t\tStringBuilder newLine = new StringBuilder();\n\t\t\t\t\t\t\tif (cursor.x != currentLine.length()) {\n\t\t\t\t\t\t\t\tnewLine.append(currentLine.substring(cursor.x));\n\t\t\t\t\t\t\t\tcurrentLine.delete(cursor.x,\n\t\t\t\t\t\t\t\t\t\tcurrentLine.length());\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlines.add(cursor.y + 1, newLine);\n\t\t\t\t\t\t\tcursor.y++;\n\t\t\t\t\t\t\tcursor.x = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (cursor.x == currentLine.length()) {\n\t\t\t\t\t\t\t\tcurrentLine.append(buffer);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tcurrentLine.insert(cursor.x, buffer);\n\t\t\t\t\t\t\tcursor.x += buffer.length();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '-':\n\t\t\t\t\tbreak commandLoop;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// System.out.println(cursor);\n\t\t\t\t// System.out.println(currentLine);\n\t\t\t\t//System.out.println(\"---\");\n\t\t\t}\n\t\t\tfor (StringBuilder sb : lines) {\n\t\t\t\tSystem.out.println(sb);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static final int MAXINPUTLINE = 10;\n    static final int MAXINPUTCOMMAND = 300;\n    static final int MAXMODIFIEDTEXTLINE = 100;\n    static final int MAXMODIFIERTEXTCHAR = 1000;\n    static final String ENDOFLINE = \"$\";\n    static Scanner scan = new Scanner(System.in);\n    static ArrayList<String> modifyingText = new ArrayList<String>();\n    static String buffer;\n    static int cursorLocLine = 0;\n    static int cursorLocRow = 0;\n\n    public static void main(String args[]) {\n        ArrayList<String> inputText;\n        ArrayList<String> inputCommand;\n\n        inputText = giveTextLine();\n//        System.out.println(\"==============================\");\n//        System.out.println(\"give Text Success\");\n\n        inputCommand = giveCommand();\n\n//        System.out.println(\"==============================\");\n//        System.out.println(\"give Command Success\");\n        modifyText(inputText, inputCommand);\n\n        for (int i = 0; i < modifyingText.size(); i++) {\n            int outLen = modifyingText.get(i).length();\n            if (outLen <= 1) {\n                System.out.print(\"\\n\");\n            } else System.out.println(modifyingText.get(i).substring(0, outLen - 1));\n        }\n    }\n\n    private static ArrayList<String> giveTextLine() {\n        String input;\n        ArrayList<String> inputText = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTLINE; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"END_OF_TEXT\")) break;\n            inputText.add(i, input);\n        }\n        return inputText;\n    }\n\n    private static ArrayList<String> giveCommand() {\n        String input;\n        ArrayList<String> inputCommand = new ArrayList<>();\n//        Scanner scan = new Scanner(System.in);\n        for (int i = 0; i < MAXINPUTCOMMAND; i++) {\n            input = scan.nextLine();\n            if (input.equals(\"-\")) break;\n            inputCommand.add(i, input);\n        }\n        return inputCommand;\n    }\n\n    private static void modifyText(final ArrayList<String> inputText, final ArrayList<String> inputCommand) {\n\n        for (int i = 0; i < inputText.size(); i++) {\n            modifyingText.add(i, inputText.get(i) + ENDOFLINE);\n        }\n\n        for (int i = 0; i < inputCommand.size(); i++) {\n//            System.out.println(\"===============================\");\n//            System.out.println(inputCommand.get(i) + \" \" + cursorLocRow + \" \" + cursorLocLine + \" \" + modifyingText.get(cursorLocLine).length() + \" \" + buffer);\n//            System.out.println(\"===============================\");\n//            modifyingText.forEach(System.out::println);\n\n            if (inputCommand.get(i).equals(\"a\")) editA();\n            else if (inputCommand.get(i).equals(\"e\")) editE();\n            else if (inputCommand.get(i).equals(\"p\")) editP();\n            else if (inputCommand.get(i).equals(\"n\")) editN();\n            else if (inputCommand.get(i).equals(\"f\")) editF();\n            else if (inputCommand.get(i).equals(\"b\")) editB();\n            else if (inputCommand.get(i).equals(\"d\")) editD();\n            else if (inputCommand.get(i).equals(\"k\")) editK();\n            else if (inputCommand.get(i).equals(\"y\")) editY();\n        }\n    }\n\n    private static String remove(String str, int removeIndex) {\n        StringBuilder builder = new StringBuilder(str);\n        return builder.deleteCharAt(removeIndex).toString();\n    }\n\n    private static String insert(String str, int insertIndex) {\n        StringBuilder builder = new StringBuilder(str);\n\n        if (builder.length() <= insertIndex) {\n            return builder.append(buffer).toString();\n        } else {\n            return builder.insert(insertIndex, buffer).toString();\n        }\n    }\n\n    private static void editA() {\n        cursorLocRow = 0;\n    }\n\n    private static void editE() {\n        cursorLocRow = currentLineString().length() - 1;\n    }\n\n    private static void editP() {\n        cursorLocRow = 0;\n        if (cursorLocLine > 0) cursorLocLine--;\n    }\n\n    private static void editN() {\n        cursorLocRow = 0;\n        if (isLastLine()) return;\n        cursorLocLine++;\n    }\n\n    private static void editF() {\n        if (isLastRow()) {\n            if (isLastLine()) return;\n            cursorLocLine++;\n            cursorLocRow = 0;\n        } else {\n            cursorLocRow++;\n        }\n    }\n\n    private static void editB() {\n        if (cursorLocRow > 0) cursorLocRow--;\n        else if (cursorLocLine > 0) {\n            cursorLocRow = modifyingText.get(cursorLocLine - 1).length() - 1;\n            cursorLocLine--;\n        }\n    }\n\n    private static void editD() {\n        if (!isEOL()) {\n            replaceCurrentLine(remove(modifyingText.get(cursorLocLine), cursorLocRow));\n        } else {\n            if (!isLastLine()) {\n                replaceCurrentLine(currentLineString() + modifyingText.get(cursorLocLine + 1));\n                replaceCurrentLine(remove(currentLineString(), cursorLocRow));\n                for (int i = cursorLocLine + 1; i < modifyingText.size(); i++) {\n                    if (isLastLine(i + 1)) break;\n                    replaceLine(i, modifyingText.get(i) + modifyingText.get(i + 1));\n                }\n            }\n        }\n    }\n\n    private static void editK() {\n        if (isLastRow()) {\n            if (!isLastLine()) {\n\n                replaceCurrentLine(currentLineString() + modifyingText.get(cursorLocLine + 1));\n                replaceCurrentLine(remove(currentLineString(), cursorLocRow));\n\n                for (int i = cursorLocLine + 1; i < modifyingText.size(); i++) {\n                    if (isLastLine(i + 1))\n                        replaceLine(i, modifyingText.get(i + 1));\n                }\n                modifyingText.remove(lastLine());\n                buffer = \"\\n\";\n            }\n        } else {\n            buffer = currentLineString().substring(cursorLocRow, currentLineString().length() - 1);\n            if (cursorLocRow == 0) replaceCurrentLine(ENDOFLINE);\n            else replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n            cursorLocRow = currentLineString().length() - 1;\n        }\n    }\n\n    private static void editY() {\n        if (buffer != null) {\n            if (buffer.equals(\"\\n\")) {\n\n                if (isLastRow()) {\n                    String movingText = currentLineString().substring(cursorLocRow);\n                    replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n                    insertLine(cursorLocLine + 1, movingText);\n                } else {\n                    String movingText = currentLineString().substring(cursorLocRow);\n                    insertLine(cursorLocLine + 1, movingText);\n\n                    if (cursorLocRow != 0) {\n                        replaceCurrentLine(currentLineString().substring(0, cursorLocRow) + ENDOFLINE);\n                    } else {\n                        replaceCurrentLine(ENDOFLINE);\n                    }\n                }\n                cursorLocRow = 0;\n                cursorLocLine++;\n\n            } else {\n                replaceCurrentLine(insert(currentLineString(), cursorLocRow));\n                cursorLocRow += (buffer.length());\n\n            }\n        }\n    }\n\n    private static String currentLineString() {\n        return modifyingText.get(cursorLocLine);\n    }\n\n    private static void replaceLine(int index, String str) {\n        modifyingText.set(index, str);\n    }\n\n    private static void replaceCurrentLine(String str) {\n        modifyingText.set(cursorLocLine, str);\n    }\n\n    private static void insertLine(int index, String str) {\n        modifyingText.add(index, str);\n    }\n\n    private static void insertInCurrentLine(String str) {\n        modifyingText.add(cursorLocLine, str);\n    }\n\n    private static boolean isLastLine() {\n        return modifyingText.size() <= cursorLocLine + 1;\n    }\n\n    private static boolean isLastLine(int i) {\n        return modifyingText.size() > i;\n    }\n\n    private static boolean isLastRow() {\n        return modifyingText.get(cursorLocLine).length() <= cursorLocRow + 1;\n    }\n\n    private static int lastLine() {\n        return modifyingText.size() - 1;\n    }\n\n    private static boolean isEOL() {\n        return String.valueOf(currentLineString().charAt(cursorLocRow)).equals(ENDOFLINE);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO ツ篠ゥツ督ョツ青カツ青ャツつウツづェツつスツδソツッツドツ・ツスツタツブ\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tArrayList<String> str = new ArrayList<String>();\n\t\tArrayList<Character> command = new ArrayList<Character>();\n\t\tString buf;\n\t\tint x=0, y=0;\n\n\n\t\twhile(true){\n\t\t\tbuf = sc.nextLine();\n\t\t\tif(buf.equals(\"END_OF_TEXT\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstr.add(buf);\n\t\t}\n\t\twhile(true){\n\t\t\tbuf = sc.next();\n\t\t\tif(buf.charAt(0) == '-'){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcommand.add(buf.charAt(0));\n\t\t}\n\t\tbuf = \"\";\n\n\t\tfor(int i=0;i<command.size();i++){\n\t\t\tswitch(command.get(i)){\n\t\t\tcase 'a'://ok\n\t\t\t\tx=0;\n\t\t\t\tbreak;\n\n\t\t\tcase 'e'://ok\n\t\t\t\tx=str.get(y).length();\n\t\t\t\tbreak;\n\n\t\t\tcase 'p'://ok\n\t\t\t\tif(y!=0){\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t\tx=0;\n\t\t\t\tbreak;\n\n\t\t\tcase 'n'://ok\n\t\t\t\tif(str.size() != y+1){\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tx=0;\n\t\t\t\tbreak;\n\n\t\t\tcase 'f'://ok\n\t\t\t\tif(str.get(y).length() != x){\n\t\t\t\t\tx++;\n\t\t\t\t}else if(str.size() != y+1){\n\t\t\t\t\ty++;\n\t\t\t\t\tx=0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'b'://ok\n\t\t\t\tif(x!=0){\n\t\t\t\t\tx--;\n\t\t\t\t}else if(y!=0){\n\t\t\t\t\ty--;\n\t\t\t\t\tx=str.get(y).length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'd'://ok\n\t\t\t\tif(x!=str.get(y).length()){\n\t\t\t\t\tchar[] strbuf = str.get(y).toCharArray();\n\t\t\t\t\tString resultbuf = \"\";\n\t\t\t\t\tfor(int j=0;j<strbuf.length;j++){\n\t\t\t\t\t\tif(x!=j){\n\t\t\t\t\t\t\tresultbuf += strbuf[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstr.set(y,resultbuf);\n\t\t\t\t}else if(str.size() != y+1){\n\t\t\t\t\tstr.set(y, str.get(y)+str.get(y+1));\n\t\t\t\t\tstr.remove(y+1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'k'://ok\n\t\t\t\tif(x!=str.get(y).length()){\n\t\t\t\t\tchar[] strbuf = str.get(y).toCharArray();\n\t\t\t\t\tString resultbuf = \"\";\n\t\t\t\t\tbuf = \"\";\n\t\t\t\t\tfor(int j=0;j<strbuf.length;j++){\n\t\t\t\t\t\tif(x>j){\n\t\t\t\t\t\t\tresultbuf += strbuf[j];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf += strbuf[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstr.set(y,resultbuf);\n\t\t\t\t\tx = str.get(y).length();\n\t\t\t\t}else if(str.size() != y+1){\n\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t\tstr.set(y, str.get(y)+str.get(y+1));\n\t\t\t\t\tstr.remove(y+1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'y':\n\t\t\t\tif(buf.equals(\"\\n\")){\n\t\t\t\t\tchar[] strbuf = str.get(y).toCharArray();\n\t\t\t\t\tString resultbuf = \"\";\n\t\t\t\t\tbuf = \"\";\n\t\t\t\t\tfor(int j=0;j<strbuf.length;j++){\n\t\t\t\t\t\tif(x>j){\n\t\t\t\t\t\t\tresultbuf += strbuf[j];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf += strbuf[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstr.set(y,resultbuf);\n\t\t\t\t\tstr.add(y+1,buf);\n\n\t\t\t\t\tbuf=\"\\n\";\n\t\t\t\t}else if(buf.length() != 0){\n\t\t\t\t\tchar[] strbuf = str.get(y).toCharArray();\n\t\t\t\t\tString resultbuf = \"\";\n\t\t\t\t\tfor(int j=0;j<=strbuf.length;j++){\n\t\t\t\t\t\tif(x==j){\n\t\t\t\t\t\t\tresultbuf += buf;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j!=strbuf.length){\n\t\t\t\t\t\t\tresultbuf += strbuf[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstr.set(y, resultbuf);\n\t\t\t\t\tx+=buf.length();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<str.size();i++){\n\t\t\tSystem.out.println(str.get(i));\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    BufferedReader br;\n    Main() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n    ArrayList<StringBuilder> buf;\n    ArrayList<String> cmds;\n    String clipboard;\n    boolean init() {\n        String s;\n        clipboard = new String();\n        buf = new ArrayList<StringBuilder>();\n        cmds = new ArrayList<String>();\n        try {\n            while (!(s = br.readLine()).equals(\"END_OF_TEXT\")) {\n                buf.add(new StringBuilder(s));\n            }\n            while (!(s = br.readLine()).equals(\"-\")) {\n                cmds.add(s);\n            }\n        } catch (IOException e) {}\n        return true;\n    }\n    void run() {\n        init();\n        //for (StringBuilder b : buf) {\n        //    System.out.println(b);\n        //}\n        int r = 0;\n        int c = 0;\n        for (String cmd : cmds) {\n            //System.out.println(\"cmd: \" + cmd);\n            if (cmd.equals(\"a\")) {\n                c = 0;\n            } else if (cmd.equals(\"e\")) {\n                c = buf.get(r).length();\n            } else if (cmd.equals(\"p\")) {\n                if (r > 0) {\n                    r--;\n                    c = 0;\n                } else {\n                    c = 0;\n                }\n            } else if (cmd.equals(\"n\")) {\n                if (r < buf.size()-1) {\n                    r++;\n                    c = 0;\n                } else {\n                    c = 0;\n                }\n            } else if (cmd.equals(\"f\")) {\n                if (c != buf.get(r).length()) {\n                    c++;\n                } else if (r < buf.size()-1) {\n                    r++;\n                    c = 0;\n                }\n            } else if (cmd.equals(\"b\")) {\n                if (c != 0) {\n                    c--;\n                } else if (r > 0) {\n                    r--;\n                    c = buf.get(r).length();\n                }\n            } else if (cmd.equals(\"d\")) {\n                if (c != buf.get(r).length()) {\n                    buf.get(r).deleteCharAt(c);\n                } else if (r < buf.size()-1){\n                    buf.get(r).append(buf.get(r+1));\n                    buf.remove(r+1);\n                }\n            } else if (cmd.equals(\"k\")) {\n                if (c == buf.get(r).length()) {\n                    buf.get(r).append(buf.get(r+1));\n                    buf.remove(r+1);\n                    clipboard = \"\\n\";\n                    //System.out.println(\"copied newline\"); \n                } else {\n                    clipboard = buf.get(r).substring(c);\n                    buf.get(r).delete(c, buf.get(r).length());\n                    c = buf.get(r).length();\n                }\n            } else if (cmd.equals(\"y\")) {\n                //System.out.println(\"r: \" + r + \" c: \" + c);\n                //System.out.println(\"clipboard: \" + clipboard);\n                if (!clipboard.isEmpty()) {\n                    if (clipboard.equals(\"\\n\")) {\n                        StringBuilder tmp = new StringBuilder(buf.get(r).substring(c));\n                        buf.get(r).delete(c, buf.get(r).length());\n                        buf.add(r, tmp);\n                        r++;\n                        c = 0;\n                    } else {\n                        buf.get(r).insert(c, clipboard);\n                    }\n                }\n            }\n\n            //System.out.println(\"------ current buffer ------\");\n            //System.out.println(\"r: \" + r + \" c: \" + c);\n            //for (StringBuilder b : buf) {\n            //    System.out.println(b);\n            //}\n            //System.out.println(\"\");\n        }\n        for (StringBuilder b : buf) {\n            System.out.println(b);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\npublic class Main {\n public static void main(String[] args){\n try{\n  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n  String str[];\n  str=new String[101];\n  String buffer=\"\";\n  String str2=\"\";\n  String str3=\"\";\n  int a;\n  int j=0;\n  while (true) {\n   String str1 = br.readLine();\n   if(str1.equals(\"END_OF_TEXT\")){a=j; break;}\n   str[j]=str1;\n   j++;\n  }\n  int loc=0;\n  int line=0;\n  while(true) {\n   System.out.print(loc);\n   System.out.print(' ');\n   System.out.println(line);\n   for(int i=0;i<a;i++)\n   System.out.println(str[i]);\n   char ch=br.readLine().charAt(0);\n   if(ch=='-') break;\n   else if(ch=='a')loc=0;\n   else if(ch=='e')loc=str[line].length()-1;\n   else if(ch=='p'){\n    loc=0;\n    if(line!=0)line--;\n   }\n   else if(ch=='n'){\n    loc=0;\n    if(line!=a-1)line++;\n   }\n   else if(ch=='f'){\n    if(loc!=str[line].length()-1)loc++;\n    else if (loc==str[line].length()-1 && line!=a-1) {\n     loc=0;\n     line++;\n    }\n   }\n   else if(ch=='b'){\n    if(loc!=0)loc--;\n    else if(loc==0 && line!=0)a=str[--line].length();\n   }\n   else if(ch=='d'){\n    if(loc!=str[line].length()-1){\n     str2=str[line].substring(0, loc)+str[line].substring(loc+1,str[line].length());\n     str[line]=\"\";\n     str[line]+=str2;\n    }\n    else if(loc==str[line].length()-1 && line<a-1){\n     str[line]+=str[line+1];\n     str[line+1]=\"\";\n     for(int i=line+2;i<a;i++){\n      str[i-1]+=str[i];\n      str[i]=\"\";\n     }\n     a--;\n    }\n   }\n   else if(ch=='k'){\n    if(loc!=str[line].length()-1) {\n     buffer=str[line].substring(loc);\n     str2=str[line].substring(0, loc);\n     str[line]=\"\";\n     str[line]+=str2;\n    } \n    else if(loc==str[line].length()-1 && line!=a-1){\n     buffer=\"\\n\";\n     for(int i=line+1;i<a;i++){\n      str[i-1]+=str[i];\n      str[i]=\"\";\n     }\n     a--;\n    }\n   }\n   else{\n    if(buffer.equals(\"\\n\")) {\n     str2=str[line].substring(loc,str[line].length());\n     for(int i=a-1;i>line;i--){\n      str[i+1]+=str[i];\n      str[i]=\"\";\n     }\n     str[line+1]+=str2;\n     a++;\n     loc=0;\n     line++;\n    }\n    else if(buffer!=\"\") {\n     str2=str[line].substring(loc);\n     str3=str[line].substring(0, loc);\n     str[line]=\"\";\n     str[line]=str3+buffer+str2;\n     loc=str[line].length()-1;\n    }\n   }\n  }\n  for(int i=0;i<a;i++)\n  System.out.println(str[i]);\n }\n catch(Exception e){System.out.println(\"err\");}\n }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\npublic class Main {\n static int loc=0;\n static int line=0;\n static String str[];\n static String buffer=\"\";\n static String str2=\"\";\n static String str3=\"\";\n static int a;\n public static void main(String[] args){\n try{\n  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n  str=new String[1000];\n  int j=0;\n  while (true) {\n   String str1 = br.readLine();\n   if(str1.equals(\"END_OF_TEXT\")){a=j; break;}\n   str[j]=str1;\n   j++;\n  }\n  while(true){\n   char ch=br.readLine().charAt(0);\n   if(ch=='-') break;\n   else if(ch=='a')a();\n   else if(ch=='e')e();\n   else if(ch=='p')p();\n   else if(ch=='n')n();\n   else if(ch=='f')f();\n   else if(ch=='b')b();\n   else if(ch=='d')d();\n   else if(ch=='k')k();\n   else if(ch=='y')y();\n  }\n  for(int i=0;i<a;i++)System.out.println(str[i]);\n }\n catch(Exception e){System.out.println(\"err\");}\n }\n\n public static void a(){\n  loc=0;\n }\n public static void e(){\n  loc=str[line].length();\n }\n\n public static void p(){\n  loc=0;\n  if(line!=0)line--;\n }\n public static void n(){\n  loc=0;\n  if(line!=a-1)line++;\n }\n public static void f()\n\n{\n  if(loc != str[line].length())loc++;\n  else if(loc==str[line].length() && line!=a-1) {\n   loc=0;\n   line++;\n  }\n }\n public static void b(){\n  if(loc!=0)loc--;\n  else if(loc==0 && line!=0)loc=str[--line].length();\n }\n public static void d(){\n  if(loc!=str[line].length()){\n   str2=str[line].substring(0, loc)+str[line].substring(loc+1);\n   str[line]=\"\";\n   str[line]+=str2;\n  }\n  else if(loc==str[line].length() && line!=a-1){\n   str[line]+=str[line+1];\n   str[line+1]=\"\";\n   for(int i=line+2;i<a;i++){\n    str[i-1]+=str[i];\n    str[i]=\"\";\n   }\n   a--;\n  }\n }\n\n public static void k(){\n  if(loc!=str[line].length()){\n   buffer=str[line].substring(loc);\n   str2=str[line].substring(0, loc);\n   str[line]=\"\";\n   str[line]+=str2;\n  } \n  else if(loc==str[line].length() && line!=a-1){\n   buffer=\"\\n\";\n   for(int i=line+1;i<a;i++){\n    str[i-1]+=str[i];\n    str[i]=\"\";\n   }\n   a--;\n  }\n }\n\n public static void y(){\n  if(buffer.equals(\"\\n\")) {\n  str2=str[line].substring(0,loc);\n  str3=str[line].substring(loc);\n   for(int i=a-1;i>line;i--){\n    str[i+1]=\"\";\n    str[i+1]+=str[i];\n   }\n   str[line]=\"\";\n   str[line]+=str2;\n   str[line+1]=\"\";\n   str[line+1]+=str3;\n   a++;\n   loc=0;\n   line++;\n  }\n  else if(buffer!=\"\") {\n   str2=str[line].substring(0,loc);\n   str3=str[line].substring(loc);\n   str[line]=\"\";\n   str[line]=str2+buffer+str3;\n   loc+=buffer.length();\n  }\n }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\n//Emacs-like Editor\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tLinkedList<String> l = new LinkedList<String>();\n\t\twhile(true){\n\t\t\tString s = sc.nextLine();\n\t\t\tif(s.equals(\"END_OF_TEXT\"))break;\n\t\t\tl.add(s+\"$\");\n\t\t}\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tString buf = \"\";\n\t\twhile(true){\n\t\t\tchar ch = sc.next().charAt(0);\n\t\t\t\n\t\t\tif(ch=='-')break;\n\t\t\tif(ch=='a')j=0;\n\t\t\telse if(ch=='e')j=l.get(i).length()-1;\n\t\t\telse if(ch=='p'){\n\t\t\t\tif(i>0)i--;\n\t\t\t\tj=0;\n\t\t\t}\n\t\t\telse if(ch=='n'){\n\t\t\t\tif(i<l.size()-1)i++;\n\t\t\t\tj=0;\n\t\t\t}\n\t\t\telse if(ch=='f'){\n\t\t\t\tif(j!=l.get(i).length()-1)j++;\n\t\t\t\telse if(j==l.get(i).length()-1&&i<l.size()-1){\n\t\t\t\t\ti++;j=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ch=='b'){\n\t\t\t\tif(j>0)j--;\n\t\t\t\tif(j==0&&i>0){\n\t\t\t\t\ti--;j=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ch=='d'){\n\t\t\t\tif(l.get(i).charAt(j)!='$'){\n\t\t\t\t\tStringBuilder sb = new StringBuilder(l.remove(i));\n\t\t\t\t\tl.add(i, sb.substring(0, j)+sb.substring(j+1,sb.length()));\n\t\t\t\t}\n\t\t\t\telse if(i<l.size()-1){\n\t\t\t\t\tString t = l.remove(i);\n\t\t\t\t\tStringBuilder sb = new StringBuilder(t.substring(0, t.length()-1));\n\t\t\t\t\tsb.append(l.remove(i));\n\t\t\t\t\tl.add(i, sb.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ch=='k'){\n\t\t\t\tif(j==l.get(i).length()-1&&i<l.size()-1){\n\t\t\t\t\tStringBuilder sb = new StringBuilder(l.remove(i));\n\t\t\t\t\tsb.append(l.remove(i));\n\t\t\t\t\tl.add(i, sb.toString());\n\t\t\t\t\tbuf = \"$\";\n\t\t\t\t}\n\t\t\t\telse if(j<l.get(i).length()-1){\n\t\t\t\t\tStringBuilder sb = new StringBuilder(l.remove(i));\n\t\t\t\t\tl.add(i, sb.substring(0,j)+\"$\");\n\t\t\t\t\tbuf = sb.substring(j,sb.length()-1);\n\t\t\t\t\tj = l.get(i).length()-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ch=='y'){\n\t\t\t\tif(buf.equals(\"\"))continue;\n\t\t\t\tif(buf.equals(\"$\")){\n\t\t\t\t\tStringBuilder sb = new StringBuilder(l.remove(i));\n\t\t\t\t\tl.add(i, sb.substring(0,j)+\"$\");\n\t\t\t\t\tl.add(i+1,sb.substring(j,sb.length()));\n\t\t\t\t\ti++;j=0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tStringBuilder sb = new StringBuilder(l.remove(i));\n\t\t\t\t\tchar r = sb.charAt(j);\n\t\t\t\t\tl.add(i, sb.substring(0, j)+buf+sb.substring(r=='$'?j+1:j,sb.length())+(r=='$'?\"$\":\"\"));\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(\"DUMP I:\" + i + \" J:\" +j + \" BUF:\" + buf + \" IM:\" + ch);\n//\t\t\tfor(String s:l)System.out.println(s);\n\t\t}\n\t\tfor(String s:l)System.out.println(s.substring(0,s.length()-1));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace AOJ\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tvar text = new List<string>();\n\n\t\t\tvar s = \"\";\n\t\t\twhile ((s = Console.ReadLine()) != \"END_OF_TEXT\")\n\t\t\t{\n\t\t\t\ttext.Add(s + \"\\n\");\n\t\t\t}\n\n\t\t\tint cx = 0, cy = 0;\n\t\t\tvar buf = \"\";\n\t\t\twhile ((s = Console.ReadLine()) != \"-\")\n\t\t\t{\n\t\t\t\tif (s == \"a\")\n\t\t\t\t{\n\t\t\t\t\tcx = 0;\n\t\t\t\t}\n\t\t\t\telse if (s == \"e\")\n\t\t\t\t{\n\t\t\t\t\tcx = text[cy].Length;\n\t\t\t\t}\n\t\t\t\telse if (s == \"p\")\n\t\t\t\t{\n\t\t\t\t\tif (cy > 0)\n\t\t\t\t\t\tcy--;\n\t\t\t\t\telse cx = 0;\n\t\t\t\t}\n\t\t\t\telse if (s == \"n\")\n\t\t\t\t{\n\t\t\t\t\tif (cy < text.Count - 1)\n\t\t\t\t\t\tcy++;\n\t\t\t\t\tcx = 0;\n\t\t\t\t}\n\t\t\t\telse if (s == \"f\")\n\t\t\t\t{\n\t\t\t\t\tif (cx < text[cy].Length - 1)\n\t\t\t\t\t\tcx++;\n\t\t\t\t\telse if (cx == text[cy].Length - 1 && cy < text.Count - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tcx = 0;\n\t\t\t\t\t\tcy++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (s == \"b\")\n\t\t\t\t{\n\t\t\t\t\tif (cx > 0)\n\t\t\t\t\t\tcx--;\n\t\t\t\t\telse if (cx == 0 && cy > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcy--;\n\t\t\t\t\t\tcx = text[cy].Length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (s == \"d\")\n\t\t\t\t{\n\t\t\t\t\tif (cx < text[cy].Length)\n\t\t\t\t\t{\n\t\t\t\t\t\ttext[cy] = text[cy].Remove(cx, 1);\n\t\t\t\t\t}\n\t\t\t\t\telse if (cx == text[cy].Length && cy < text.Count - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\ttext[cy] += text[cy + 1];\n\t\t\t\t\t\ttext.RemoveAt(cy + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (s == \"k\")\n\t\t\t\t{\n\t\t\t\t\tif (cx == text[cy].Length && cy < text.Count - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\ttext[cy] += text[cy + 1];\n\t\t\t\t\t\ttext.RemoveAt(cy + 1);\n\t\t\t\t\t\tbuf = \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t\telse if (cx < text[cy].Length)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuf = text[cy].Substring(cx);\n\t\t\t\t\t\ttext[cy] = text[cy].Substring(0, cx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (s == \"y\")\n\t\t\t\t{\n\t\t\t\t\tif (buf == \"\") return;\n\t\t\t\t\tif (buf == \"\\n\")\n\t\t\t\t\t{\n\t\t\t\t\t\ttext.Insert(cy + 1, text[cy].Substring(cx));\n\t\t\t\t\t\ttext[cy] = text[cy].Substring(0, cx);\n\t\t\t\t\t\tcy++;\n\t\t\t\t\t\tcx = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttext[cy] = text[cy].Substring(0, cx) + buf + text[cy].Substring(cx);\n\t\t\t\t\t\tcx += buf.Length;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < text.Count; i++)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(text[i].Replace(\"\\n\", \"\"));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ1021\n{\n    class Program\n    {\n        static void Main()\n        {\n            var emacs = new Emacs(ReadText());\n\n            foreach (var op in ReadOperation())\n            {\n                emacs.Operate(op);\n            }\n\n            foreach (var line in emacs.Text)\n            {\n                Console.WriteLine(line);\n            }\n        }\n\n        public static IEnumerable<string> ReadText()\n        {\n            string line;\n            while ((line = Console.ReadLine()) != null && line != \"END_OF_TEXT\")\n            {\n                yield return line;\n            }\n        }\n\n        public static IEnumerable<Emacs.Operation> ReadOperation()\n        {\n            string line;\n            while ((line = Console.ReadLine()) != null && line != \"-\")\n            {\n                switch (line)\n                {\n                    case \"a\":\n                        yield return Emacs.Operation.Home;\n                        break;\n                    case \"e\":\n                        yield return Emacs.Operation.End;\n                        break;\n                    case \"p\":\n                        yield return Emacs.Operation.Up;\n                        break;\n                    case \"n\":\n                        yield return Emacs.Operation.Down;\n                        break;\n                    case \"f\":\n                        yield return Emacs.Operation.Right;\n                        break;\n                    case \"b\":\n                        yield return Emacs.Operation.Left;\n                        break;\n                    case \"d\":\n                        yield return Emacs.Operation.Delete;\n                        break;\n                    case \"k\":\n                        yield return Emacs.Operation.Cut;\n                        break;\n                    case \"y\":\n                        yield return Emacs.Operation.Yank;\n                        break;\n                }\n            }\n        }\n    }\n\n    public class Emacs\n    {\n        public List<string> Text { get; private set; }\n        public string Buffer { get; private set; }\n        public int Line { get; private set; }\n        public int Column { get; private set; }\n\n        public Emacs(IEnumerable<string> text)\n        {\n            Text = new List<string>(text);\n            Buffer = null;\n            Line = 0;\n            Column = 0;\n        }\n\n        public void Operate(Operation op)\n        {\n            switch (op)\n            {\n                case Operation.Home:\n                    Column = 0;\n                    break;\n                case Operation.End:\n                    Column = Text[Line].Length;\n                    break;\n                case Operation.Up:\n                    Column = 0;\n                    if (Line != 0)\n                    {\n                        Line--;\n                    }\n                    break;\n                case Operation.Down:\n                    Column = 0;\n                    if (Line != Text.Count - 1)\n                    {\n                        Line++;\n                    }\n                    break;\n                case Operation.Right:\n                    if (Column == Text[Line].Length)\n                    {\n                        if (Line != Text.Count - 1)\n                        {\n                            Column = 0;\n                            Line++;\n                        }\n                    }\n                    else\n                    {\n                        Column++;\n                    }\n                    break;\n                case Operation.Left:\n                    if (Column == 0)\n                    {\n                        if (Line != 0)\n                        {\n                            Line--;\n                            Column = Text[Line].Length;\n                        }\n                    }\n                    else\n                    {\n                        Column--;\n                    }\n                    break;\n                case Operation.Delete:\n                    if (Column == Text[Line].Length)\n                    {\n                        if (Line != Text.Count - 1)\n                        {\n                            var line = Text[Line + 1];\n                            Text.RemoveAt(Line + 1);\n                            Text[Line] += line;\n                        }\n                    }\n                    else\n                    {\n                        Text[Line] = Text[Line].Remove(Column, 1);\n                    }\n                    break;\n                case Operation.Cut:\n                    if (Column == Text[Line].Length)\n                    {\n                        if (Line != Text.Count - 1)\n                        {\n                            var line = Text[Line + 1];\n                            Text.RemoveAt(Line + 1);\n                            Text[Line] += line;\n                            Buffer = \"\\n\";\n                        }\n                    }\n                    else\n                    {\n                        Buffer = Text[Line].Substring(Column);\n                        Text[Line] = Text[Line].Remove(Column);\n                    }\n                    break;\n                case Operation.Yank:\n                    if (Buffer == null) break;\n                    if (Buffer == \"\\n\")\n                    {\n                        if (Column == Text[Line].Length)\n                        {\n                            Text.Insert(Line + 1, \"\");\n                        }\n                        else\n                        {\n                            var temp = Text[Line].Substring(Column);\n                            Text[Line] = Text[Line].Remove(Column);\n                            Text.Insert(Line + 1, temp);\n                        }\n                        Line++;\n                        Column = 0;\n                    }\n                    else\n                    {\n                        Text[Line] = Text[Line].Insert(Column, Buffer);\n                        Column += Buffer.Length;\n                    }\n                    break;\n            }\n        }\n\n        public enum Operation\n        {\n            Home,\n            End,\n            Up,\n            Down,\n            Right,\n            Left,\n            Delete,\n            Cut,\n            Yank\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ1021\n{\n    class Program\n    {\n        static void Main()\n        {\n            var emacs = new Emacs(ReadText());\n\n            foreach (var op in ReadOperation())\n            {\n                emacs.Operate(op);\n            }\n\n            foreach (var line in emacs.Text)\n            {\n                Console.WriteLine(line);\n            }\n        }\n\n        public static IEnumerable<string> ReadText()\n        {\n            string line;\n            while ((line = Console.ReadLine()) != null && line != \"END_OF_TEXT\")\n            {\n                yield return line;\n            }\n        }\n\n        public static IEnumerable<Emacs.Operation> ReadOperation()\n        {\n            string line;\n            while ((line = Console.ReadLine()) != null && line != \"-\")\n            {\n                switch (line)\n                {\n                    case \"a\":\n                        yield return Emacs.Operation.Home;\n                        break;\n                    case \"e\":\n                        yield return Emacs.Operation.End;\n                        break;\n                    case \"p\":\n                        yield return Emacs.Operation.Up;\n                        break;\n                    case \"n\":\n                        yield return Emacs.Operation.Down;\n                        break;\n                    case \"f\":\n                        yield return Emacs.Operation.Right;\n                        break;\n                    case \"b\":\n                        yield return Emacs.Operation.Left;\n                        break;\n                    case \"d\":\n                        yield return Emacs.Operation.Delete;\n                        break;\n                    case \"k\":\n                        yield return Emacs.Operation.Cut;\n                        break;\n                    case \"y\":\n                        yield return Emacs.Operation.Yank;\n                        break;\n                }\n            }\n        }\n    }\n\n    public class Emacs\n    {\n        public List<string> Text { get; private set; }\n        public string Buffer { get; private set; }\n        public int Line { get; private set; }\n        public int Column { get; private set; }\n\n        public Emacs(IEnumerable<string> text)\n        {\n            Text = new List<string>(text);\n            Buffer = null;\n            Line = 0;\n            Column = 0;\n        }\n\n        public void Operate(Operation op)\n        {\n            switch (op)\n            {\n                case Operation.Home:\n                    Column = 0;\n                    break;\n                case Operation.End:\n                    Column = Text[Line].Length;\n                    break;\n                case Operation.Up:\n                    Column = 0;\n                    if (Line != 0)\n                    {\n                        Line--;\n                    }\n                    break;\n                case Operation.Down:\n                    Column = 0;\n                    if (Line != Text.Count - 1)\n                    {\n                        Line++;\n                    }\n                    break;\n                case Operation.Right:\n                    if (Column == Text[Line].Length)\n                    {\n                        if (Line != Text.Count - 1)\n                        {\n                            Column = 0;\n                            Line++;\n                        }\n                    }\n                    else\n                    {\n                        Column++;\n                    }\n                    break;\n                case Operation.Left:\n                    if (Column == 0)\n                    {\n                        if (Line != 0)\n                        {\n                            Line--;\n                            Column = Text[Line].Length;\n                        }\n                    }\n                    else\n                    {\n                        Column--;\n                    }\n                    break;\n                case Operation.Delete:\n                    if (Column == Text[Line].Length)\n                    {\n                        if (Line != Text.Count - 1)\n                        {\n                            var line = Text[Line + 1];\n                            Text.RemoveAt(Line + 1);\n                            Text[Line] += line;\n                        }\n                    }\n                    else\n                    {\n                        Text[Line] = Text[Line].Remove(Column, 1);\n                    }\n                    break;\n                case Operation.Cut:\n                    if (Column == Text[Line].Length)\n                    {\n                        if (Line != Text.Count - 1)\n                        {\n                            var line = Text[Line + 1];\n                            Text.RemoveAt(Line + 1);\n                            Text[Line] += line;\n                            Buffer = \"\\n\";\n                        }\n                    }\n                    else\n                    {\n                        Buffer = Text[Line].Substring(Column);\n                        Text[Line] = Text[Line].Remove(Column);\n                    }\n                    break;\n                case Operation.Yank:\n                    if (Buffer == null) break;\n                    if (Buffer == \"\\n\")\n                    {\n                        var temp = Text[Line].Substring(Column);\n                        Text[Line] = Text[Line].Remove(Column);\n                        Text.Insert(Line + 1, temp);\n                        Line++;\n                        Column = 0;\n                    }\n                    else\n                    {\n                        Text[Line] = Text[Line].Insert(Column, Buffer);\n                        Column += Buffer.Length;\n                    }\n                    break;\n            }\n        }\n\n        public enum Operation\n        {\n            Home,\n            End,\n            Up,\n            Down,\n            Right,\n            Left,\n            Delete,\n            Cut,\n            Yank\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\tSol mySol =new Sol();\n\t\tmySol.WriteAns();\n\t}\n}\n\nclass Sol{\n\n\tList<String> Content;\n\tint R;\n\tint C;\n\tString buf;\n\t\n\tpublic void WriteAns(){\n\t\tforeach(String s in Content){\n\t\t\tConsole.Write(s);\n\t\t}\n\t}\n\n\tpublic Sol(){\n\t\tContent=new List<String>();\n\t\twhile(true){\n\t\t\tvar s=Console.ReadLine()+\"\\n\";\n\t\t\tif(s==\"END_OF_TEXT\\n\")break;\n\t\t\tContent.Add(s);\n\t\t}\n//WriteAns();\n\t\tR=0;C=0;buf=\"\";\n\t\twhile(true){\n\t\t\tvar s=Console.ReadLine();\n\t\t\tif(s[0]=='-')break;\n\t\t\tOperation(s[0]);\n//Console.WriteLine(\"Ope={2},R={0},C={1},buf=\\\"{3}\\\"\",R,C,s[0],buf==\"\\n\"?\"\\\\n\":buf);WriteAns();\n\t\t}\n\t}\n\t\n\n\tvoid Operation(char c){\n\t\tswitch(c){\n\t\t\tcase 'a':\n\t\t\t\tC=0;\n\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tC=Content[R].Length-1;\n\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tif(R>0){C=0;R--;}\n\t\t\t\telse if(R==0){C=0;}\n\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tif(R<Content.Count-1){C=0;R++;}\n\t\t\t\telse if(R==Content.Count-1){C=0;}\n\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif(C<Content[R].Length-1){C++;}\n\t\t\t\telse if(C==Content[R].Length-1 && R<Content.Count-1){R++;C=0;}\n\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tif(C>0){C--;}\n\t\t\t\telse if(C==0 && R>0){R--;C=Content[R].Length-1;}\n\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif(Content[R].Length>1 && C<Content[R].Length-1){\n\t\t\t\t\tContent[R]=Content[R].Substring(0,C)+Content[R].Substring(C+1);\n\t\t\t\t}\n\t\t\t\telse if(C==Content[R].Length-1 && R<Content.Count-1){\n\t\t\t\t\tContent[R]=Content[R].Substring(0,C)+Content[R+1];\n\t\t\t\t\tContent.RemoveAt(R+1);\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tif(C==Content[R].Length-1 && R<Content.Count-1){\n\t\t\t\t\tContent[R]=Content[R].Substring(0,C)+Content[R+1];\n\t\t\t\t\tContent.RemoveAt(R+1);\n\t\t\t\t\tbuf=\"\\n\";\n\t\t\t\t}\n\t\t\t\telse if(C<Content[R].Length-1){\n\t\t\t\t\tbuf=Content[R].Substring(C);\n\t\t\t\t\tbuf=buf.Substring(0,buf.Length-1);\n\t\t\t\t\tContent[R]=Content[R].Substring(0,C)+\"\\n\";\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\tif(buf==\"\"){;}\n\t\t\t\telse if(buf==\"\\n\"){\n\t\t\t\t\tString sss=Content[R].Substring(C);\n\t\t\t\t\tContent[R]=Content[R].Substring(0,C)+\"\\n\";\n\t\t\t\t\tContent.Insert(R+1,sss);\n\t\t\t\t\tR++;C=0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tContent[R]=Content[R].Substring(0,C)+buf+Content[R].Substring(C);\n\t\t\t\t\tC+=buf.Length;\n\t\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace Aizu\n{\n    class OnlineJudge\n    {\n        public static void Main()\n        {\n            var buffer = new List<string>(10);\n            var cursor = new int[2];\n            var register = String.Empty;\n            for (string input; (input = Console.ReadLine()) != \"END_OF_TEXT\"; buffer.Add(input));\n            for (string command; (command = Console.ReadLine()) != \"-\";) {\n                switch(command) {\n                    case \"a\":\n                        cursor[1] = 0;\n                        break;\n                    case \"e\":\n                        cursor[1] = buffer[cursor[0]].Length + 1;\n                        break;\n                    case \"p\":\n                        cursor[1] = 0;\n                        cursor[0] = cursor[0] > 0 ? cursor[0] - 1 : cursor[0];\n                        break;\n                    case \"n\":\n                        cursor[1] = 0;\n                        cursor[0] = cursor[0] < buffer.Count ? cursor[0] + 1 : cursor[0];\n                        break;\n                    case \"f\":\n                        if (cursor[1] <= buffer[cursor[0]].Length) {\n                            ++cursor[1];\n                        }\n                        else {\n                            if (cursor[0] < buffer.Count) {\n                                cursor[1] = 0;\n                                ++cursor[0];\n                            }\n                        }\n                        break;\n                    case \"b\":\n                        if (cursor[1] > 0) {\n                            --cursor[1];\n                        }\n                        else {\n                            if (cursor[0] > 0) {\n                                cursor[1] = buffer[--cursor[0]].Length;\n                            }\n                        }\n                        break;\n                    case \"d\":\n                        if (cursor[1] == buffer[cursor[0]].Length + 1) {\n                            if (cursor[0] < buffer.Count) {\n                                buffer[cursor[0]] += buffer[cursor[0] + 1];\n                                buffer.RemoveAt(cursor[0] + 1);\n                            }\n                        }\n                        else {\n                            buffer[cursor[0]] = buffer[cursor[0]].Remove(cursor[1], 1);\n                        }\n                        break;\n                    case \"k\":\n                        if (cursor[1] == buffer[cursor[0]].Length + 1) {\n                            if (cursor[0] < buffer.Count) {\n                                buffer[cursor[0]] += buffer[cursor[0] + 1];\n                                buffer.RemoveAt(cursor[0] + 1);\n                                register = System.Environment.NewLine;\n                            }\n                        }\n                        else {\n                            register = buffer[cursor[0]].Substring(cursor[1]);\n                            buffer[cursor[0]] = buffer[cursor[0]].Remove(cursor[1]);\n                            cursor[1] = buffer[cursor[0]].Length;\n                        }\n                        break;\n                    case \"y\":\n                        if (!String.IsNullOrEmpty(register)) {\n                            if (register == System.Environment.NewLine) {\n                                if (cursor[1] == buffer[cursor[0]].Length + 1) {\n                                    buffer.Insert(cursor[0] + 1, \"\");\n                                }\n                                else {\n                                    var newline = buffer[cursor[0]].Substring(cursor[1]);\n                                    buffer.Insert(cursor[0], newline);\n                                    buffer[cursor[0]] = buffer[cursor[0]].Remove(cursor[1]);\n                                }\n                            }\n                            else {\n                                buffer[cursor[0]] = buffer[cursor[0]].Insert(cursor[1], register);\n                            }\n                        }\n                        break;\n                    case \"vim\":\n                        Console.WriteLine(\"vim!\");\n                        break;\n                }\n            }\n            foreach(var line in buffer) {\n                Console.WriteLine(line);\n            }\n        }\n    }\n}\n// vim: ft=cs"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\tSol mySol =new Sol();\n\t\tmySol.WriteAns();\n\t}\n}\n\nclass Sol{\n\n\tList<String> Content;\n\tint R;\n\tint C;\n\tString buf;\n\t\n\tpublic void WriteAns(){\n\t\tforeach(String s in Content){\n\t\t\tConsole.Write(s);\n\t\t}\n\t}\n\n\tpublic Sol(){\n\t\tContent=new List<String>();\n\t\twhile(true){\n\t\t\tvar s=Console.ReadLine()+\"\\n\";\n\t\t\tif(s==\"END_OF_TEXT\\n\")break;\n\t\t\tContent.Add(s);\n\t\t}\n//WriteAns();\n\t\tR=0;C=0;buf=\"\";\n\t\twhile(true){\n\t\t\tvar s=Console.ReadLine();\n\t\t\tif(s[0]=='-')break;\n\t\t\tOperation(s[0]);\n//Console.WriteLine(\"Ope={2},R={0},C={1},buf=\\\"{3}\\\"\",R,C,s[0],buf==\"\\n\"?\"\\\\n\":buf);WriteAns();\n\t\t}\n\t}\n\t\n\n\tvoid Operation(char c){\n\t\tswitch(c){\n\t\t\tcase 'a':\n\t\t\t\tC=0;\n\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tC=Content[R].Length-1;\n\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tif(R>0){C=0;R--;}\n\t\t\t\telse if(R==0){C=0;}\n\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tif(R<Content.Count-1){C=0;R++;}\n\t\t\t\telse if(R==Content.Count-1){C=0;}\n\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif(C<Content[R].Length-1){C++;}\n\t\t\t\telse if(C==Content[R].Length-1 && R<Content.Count-1){R++;C=0;}\n\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tif(C>0){C--;}\n\t\t\t\telse if(C==0 && R>0){R--;C=Content[R].Length-1;}\n\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif(Content[R].Length>1 && C<Content[R].Length-1){\n\t\t\t\t\tif(C>0){Content[R]=Content[R].Substring(0,C)+Content[R].Substring(C+1);}\n\t\t\t\t\tif(C==0){Content[R]=Content[R].Substring(C+1);}\n\t\t\t\t}\n\t\t\t\telse if(C==Content[R].Length-1 && R<Content.Count-1){\n\t\t\t\t\tif(C>0)Content[R]=Content[R].Substring(0,C)+Content[R+1];\n\t\t\t\t\tif(C==0)Content[R]=Content[R+1];\n\t\t\t\t\tContent.RemoveAt(R+1);\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tif(C==Content[R].Length-1 && R<Content.Count-1){\n\t\t\t\t\tif(C>0)Content[R]=Content[R].Substring(0,C)+Content[R+1];\n\t\t\t\t\tif(C==0)Content[R]=Content[R+1];\n\t\t\t\t\tContent.RemoveAt(R+1);\n\t\t\t\t\tbuf=\"\\n\";\n\t\t\t\t}\n\t\t\t\telse if(C<Content[R].Length-1){\n\t\t\t\t\tbuf=Content[R].Substring(C);\n\t\t\t\t\tbuf=buf.Substring(0,buf.Length-1);\n\t\t\t\t\tContent[R]=Content[R].Substring(0,C)+\"\\n\";\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\tif(buf==\"\"){;}\n\t\t\t\telse if(buf==\"\\n\"){\n\t\t\t\t\tString sss=Content[R].Substring(C);\n\t\t\t\t\tif(C>0){Content[R]=Content[R].Substring(0,C)+\"\\n\";}\n\t\t\t\t\tif(C==0){Content[R]=\"\\n\";}\n\t\t\t\t\tContent.Insert(R+1,sss);\n\t\t\t\t\tR++;C=0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(C>0){Content[R]=Content[R].Substring(0,C)+buf+Content[R].Substring(C);}\n\t\t\t\t\tif(C==0){Content[R]=buf+Content[R].Substring(C);}\n\t\t\t\t\tC+=buf.Length;\n\t\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "def last_word?(cur)\n  @lines[cur[0]].size == cur[1]\nend\n\ndef last_line?(cur)\n  cur[0] == @lines.size - 1\nend\n\nbuf = ''\ncur = [0, 0]\n@lines = []\nwhile l = gets.chomp\n  break if l == 'END_OF_TEXT'\n  @lines << l\nend\n\nwhile cmd = gets.chomp\n  break if cmd == '-'\n  case cmd\n  when 'a'\n    cur[1] = 0\n  when 'e'\n    cur[1] = @lines[cur[0]].size\n  when 'p'\n    cur[0] == 0 ? cur[1] = 0 : cur = [cur[0] - 1, 0]\n  when 'n'\n    last_line?(cur) ? cur[1] = 0 : cur = [cur[0] + 1, 0]\n  when 'f'\n    unless last_word?(cur)\n      cur[1] += 1\n    else\n      unless last_line?(cur)\n        cur = [cur[0] + 1, 0]\n      end\n    end\n  when 'b'\n    if cur[1] != 0\n      cur[1] -= 1\n    else\n      if cur[0] != 0\n        cur = [cur[0] - 1, @lines[cur[0] - 1].size]\n      end\n    end\n  when 'd'\n    if last_word?(cur) && !last_line?(cur)\n      l = @lines.delete_at(cur[0] + 1)\n      @lines[cur[0]] += l\n    elsif !last_word?(cur)\n      @lines[cur[0]].slice!(cur[1])\n    end\n  when 'k'\n    if last_word?(cur) && !last_line?(cur)\n      l = @lines.delete_at(cur[0] + 1)\n      @lines[cur[0]] += l\n      buf = \"\\\\n\"\n    elsif !last_word?(cur)\n      buf = @lines[cur[0]].slice!(cur[1]..-1)\n    end\n  when 'y'\n    if buf == \"\\\\n\"\n      @lines.insert(cur[0] + 1, @lines[cur[0]].slice!(cur[1]..-1))\n      cur = [cur[0] + 1, 0]\n    elsif buf != ''\n      @lines[cur[0]].insert(cur[1], buf)\n    end\n  end\nend\n\nputs @lines"
  },
  {
    "language": "Ruby",
    "code": "def end_of_words?(cur)\n  @txt[cur[0]].size == cur[1]\nend\n\ndef last_line?(cur)\n  cur[0] == @txt.size - 1\nend\n\nbuf = ''\ncur = [0, 0]\n@txt = []\nwhile l = gets.chomp\n  break if l == 'END_OF_TEXT'\n  @txt << l\nend\n\nloop do\n  case gets.chomp\n  when '-'\n    break\n  when 'a'\n    cur[1] = 0\n  when 'e'\n    cur[1] = @txt[cur[0]].size\n  when 'p'\n    cur[0] == 0 ? cur[1] = 0 : cur = [cur[0] - 1, 0]\n  when 'n'\n    last_line?(cur) ? cur[1] = 0 : cur = [cur[0] + 1, 0]\n  when 'f'\n    unless end_of_words?(cur)\n      cur[1] += 1\n    else\n      unless last_line?(cur)\n        cur = [cur[0] + 1, 0]\n      end\n    end\n  when 'b'\n    if cur[1] != 0\n      cur[1] -= 1\n    else\n      if cur[0] != 0\n        cur = [cur[0] - 1, @txt[cur[0] - 1].size]\n      end\n    end\n  when 'd'\n    unless end_of_words?(cur)\n      @txt[cur[0]].slice!(cur[1])\n    else\n      unless last_line?(cur)\n        l = @txt.delete_at(cur[0] + 1)\n        @txt[cur[0]] += l\n      end\n    end\n  when 'k'\n    unless end_of_words?(cur)\n      buf = @txt[cur[0]].slice!(cur[1]..-1)\n    else\n      unless last_line?(cur)\n        l = @txt.delete_at(cur[0] + 1)\n        @txt[cur[0]] += l\n        buf = '\\\\n'\n      end\n    end\n  when 'y'\n    if buf == '\\\\n'\n      @txt.insert(cur[0] + 1, @txt[cur[0]].slice!(cur[1]..-1))\n      cur = [cur[0] + 1, 0]\n    elsif buf != ''\n      @txt[cur[0]].insert(cur[1], buf)\n      cur[1] += buf.size\n    end\n  end\nend\n\nputs @txt"
  },
  {
    "language": "Ruby",
    "code": "def last_word?(cur)\n  @lines[cur[0]].size == cur[1]\nend\n\ndef last_line?(cur)\n  cur[0] == @lines.size - 1\nend\n\nbuf = ''\ncur = [0, 0]\n@lines = []\nwhile l = gets.chomp\n  break if l == 'END_OF_TEXT'\n  @lines << l\nend\n\nwhile cmd = gets.chomp\n  break if cmd == '-'\n  case cmd\n  when 'a'\n    cur[1] = 0\n  when 'e'\n    cur[1] = @lines[cur[0]].size\n  when 'p'\n    cur[0] == 0 ? cur[1] = 0 : cur = [cur[0] - 1, 0]\n  when 'n'\n    last_line?(cur) ? cur[1] = 0 : cur = [cur[0] + 1, 0]\n  when 'f'\n    unless last_word?(cur)\n      cur[1] += 1\n    else\n      unless last_line?(cur)\n        cur = [cur[0] + 1, 0]\n      end\n    end\n  when 'b'\n    if cur[1] != 0\n      cur[1] -= 1\n    else\n      if cur[0] != 0\n        cur = [cur[0] - 1, @lines[cur[0] - 1].size]\n      end\n    end\n  when 'd'\n    if last_word?(cur) && !last_line?(cur)\n      l = @lines.delete_at(cur[0] + 1)\n      @lines[cur[0]] += l\n    elsif !last_word?(cur)\n      @lines[cur[0]].slice!(cur[1])\n    end\n  when 'k'\n    if last_word?(cur) && !last_line?(cur)\n      l = @lines.delete_at(cur[0] + 1)\n      @lines[cur[0]] += l\n      buf = \"\\\\n\"\n    elsif !last_word?(cur)\n      buf = @lines[cur[0]].slice!(cur[1]..-1)\n    end\n  when 'y'\n    if buf == \"\\\\n\"\n      @lines.insert(cur[0] + 1, @lines[cur[0]].slice!(cur[1]..-1))\n      cur = [cur[0] + 1, 0]\n    elsif buf != ''\n      @lines[cur[0]].insert(cur[1], buf)\n      cur[1] = buf.size if cur[1] == 0\n    end\n  end\nend\n\nputs @lines"
  },
  {
    "language": "Ruby",
    "code": "## main\n\ntexts = []\nbuffer = \"\"\n\nloop do\n  line = gets.chop\n  break if line == 'END_OF_TEXT'\n\n  texts << line\nend\n\ncx = cy = 0\n\n#p [cx, cy]\n#p texts\n\nloop do\n  cmd = gets.strip\n  break if cmd == '-'\n\n  case cmd\n  when 'a'\n    cx = 0\n  when 'e'\n    cx = texts[cy].length\n  when 'p'\n    cx = 0\n    cy -= 1 if cy > 0\n  when 'n'\n    cx = 0\n    cy += 1 if cy < texts.length - 1\n  when 'f'\n    if cx < texts[cy].length\n      cx += 1\n    elsif cy < texts.length - 1\n      cy += 1\n      cx = 0\n    end\n  when 'b'\n    if cx > 0\n      cx -= 1\n    elsif cy > 0\n      cy -= 1\n      cx = texts[cy].length\n    end\n  when 'd'\n    if cx < texts[cy].length\n      texts[cy][cx] = ''\n    elsif cy < texts.length - 1\n      texts[cy] += texts[cy + 1]\n      texts.delete_at(cy + 1)\n    end\n  when 'k'\n    if cx == texts[cy].length\n      if cy < texts.length - 1\n        texts[cy] += texts[cy + 1]\n        texts.delete_at(cy + 1)\n        buffer = \"\\n\"\n      end\n    else\n      buffer = texts[cy][cx...texts[cy].length]\n      texts[cy][cx...texts[cy].length] = ''\n    end\n  when 'y'\n    if buffer == \"\\n\"\n      nline = texts[cy][cx...texts[cy].length]\n      texts[cy][cx...texts[cy].length] = ''\n      texts[cy, 0] = nline\n      cy += 1\n      cx = 0\n    elsif buffer != \"\"\n      texts[cy][cx, 0] = buffer\n      cx += buffer.length\n    end\n  end\n  #p [cmd, cx, cy, buffer]\n  #p texts\nend\n\nfor line in texts\n  puts line\nend"
  },
  {
    "language": "Ruby",
    "code": "class Cursor\n  attr_accessor :line, :index\n  def initialize\n    @line = 0\n    @index = 0\n  end\n  def move(n)\n    @index = n\n  end\n  def up\n    @line -= 1\n  end\n  def down\n    @line += 1\n  end\nend\n\ntext = Array.new\nwhile true do\n  text.push(gets.chomp)\n  break if text.last == \"END_OF_TEXT\"\nend\ntext.pop\n\ncursor = Cursor.new\nbuffer = \"\"\nwhile true do\n  case gets.chomp\n  when \"-\"\n    break\n  when \"a\"\n    cursor.move(0)\n  when \"e\"\n    cursor.move(text[cursor.line].size)\n  when \"p\"\n    cursor.up if cursor.line > 0\n    cursor.move(0)\n  when \"n\"\n    cursor.down if cursor.line < text.size - 1\n    cursor.move(0)\n  when \"f\"\n    if cursor.index < text[cursor.line].size\n      cursor.move(cursor.index + 1)\n    elsif cursor.line < text.size - 1\n      cursor.down\n      cursor.move(0)\n    end\n  when \"b\"\n    if cursor.index > 0\n      cursor.move(cursor.index - 1)\n    elsif cursor.line > 0\n      cursor.up\n      cursor.move(text[cursor.line].size - 1)\n    end\n  when \"d\"\n    if cursor.index != text[cursor.line].size\n      text[cursor.line].slice!(cursor.index)\n    elsif cursor.line < text.size - 1\n      text[cursor.line] += text[cursor.line + 1]\n      text.delete_at(cursor.line + 1)\n    end\n  when \"k\"\n    if cursor.index != text[cursor.line].size\n      buffer = text[cursor.line].slice!(cursor.index...text[cursor.line].size)\n    elsif cursor.line < text.size - 1\n      text[cursor.line] += text[cursor.line + 1]\n      text.delete_at(cursor.line + 1)\n      buffer = \"\\n\"\n    end\n  when \"y\"\n    case buffer\n    when \"\"\n    when \"\\n\"\n      text.insert(cursor.line + 1, text[cursor.line].slice!(cursor.index...text[cursor.line].size))\n      cursor.down\n      cursor.move(0)\n    else\n      text[cursor.line].insert(cursor.index, buffer)\n      cursor.move(cursor.index + buffer.size)\n    end\n  end\nend\n\nputs text"
  },
  {
    "language": "Ruby",
    "code": "END_OF_TEXT = 'END_OF_TEXT'\nEND_OF_COMMAND = '-'\n\n$text = []\n$commands = []\n\ndef input_line s_end\n    return false if ! ( s = gets )\n    s = s.strip\n    s == s_end ? false : s\nend\n\ndef input_until s\n    ->() {\n        res = []\n        while line = input_line(s) do\n            res.push(line)\n        end\n        res\n    }\nend\n\n$input_text = input_until END_OF_TEXT\n$input_commands = input_until END_OF_COMMAND\n\ndef input\n    $text = $input_text.call\n    if $text.empty?\n        $text = false\n    end\n    if $text \n        $commands = $input_commands.call\n        return true\n    end\n    return false\nend\n\nclass Editor\n    def initialize\n        @r = 0\n        @c = 0\n        @buffer = \"\"\n    end\n\n    def check_cursor_leftmost\n        @c == 0\n    end\n\n    def check_cursor_rightmost\n        @c == $text[@r].length\n    end\n\n    def has_prev_line\n        @r - 1 >= 0\n    end\n\n    def has_next_line\n        @r + 1 < $text.length\n    end\n\n    def delete_line k\n        $text[k, 1] = []\n    end\n\n    def delete_letter k\n        $text[@r][k, 1] = '' \n    end\n\n    def move_to_leftmost \n        @c = 0\n    end\n\n    def move_to_rightmost\n        @c = $text[@r].length\n    end\n\n    def move_to_up\n        @r -= 1\n    end\n\n    def move_to_down\n        @r += 1\n    end\n\n    def move_to_left k = 1\n        @c -= k\n    end\n\n    def move_to_right k = 1\n        @c += k\n    end\n\n    def command_a\n        move_to_leftmost\n    end\n\n    def command_e\n        move_to_rightmost\n    end\n\n    def command_p\n        move_to_up if has_prev_line\n        move_to_leftmost\n    end\n\n    def command_n\n        move_to_down if has_next_line\n        move_to_leftmost\n    end\n\n    def command_f\n        if check_cursor_rightmost\n            move_to_down if has_next_line\n            move_to_leftmost\n        else\n            move_to_right\n        end\n    end\n\n    def command_b\n        if check_cursor_leftmost\n            move_to_up if has_prev_line\n            move_to_rightmost\n        else\n            move_to_left\n        end\n    end\n\n    def command_d\n        if check_cursor_rightmost\n            if has_next_line\n                $text[@r] += $text[@r+1]\n                delete_line @r + 1\n            end\n        else\n            delete_letter @c\n        end\n    end\n\n    def command_k\n        if check_cursor_rightmost\n            if has_next_line\n                $text[@r] += $text[@r+1]\n                delete_line @r+1\n                @buffer = \"\\n\"\n            end\n        else\n            @buffer = $text[@r][@c..$text[@r].length-1]\n            $text[@r] = $text[@r][0, @c]\n        end\n    end\n\n    def command_y\n        if @buffer == \"\\n\"\n            tmp = $text[@r][@c..$text[@r].length-1]\n            $text[@r] = $text[@r][0, @c]\n            $text[@r+1, 0] = tmp\n            move_to_down\n            move_to_leftmost\n        elsif @buffer != ''\n            $text[@r][@c, 0] = @buffer\n            move_to_right @buffer.length\n        end\n    end\n\n    def command s\n        case s\n        when \"a\"\n            command_a\n        when \"e\"\n            command_e\n        when \"p\"\n            command_p\n        when \"n\"\n            command_n\n        when \"f\"\n            command_f\n        when \"b\"\n            command_b\n        when \"d\"\n            command_d\n        when \"k\"\n            command_k\n        when \"y\"\n            command_y\n        end\n    end\nend\n\ndef execute_command s\n    $e.command s\nend\n\ndef solve\n    $e = Editor.new\n    $commands.each {|cmd|\n        execute_command cmd\n    }\nend\n\ndef output\n    $text.map {|s| puts s}\nend\n\nwhile input\n    solve\n    output\nend"
  },
  {
    "language": "Ruby",
    "code": "def last_word?(cur)\n  @lines[cur[0]].size == cur[1]\nend\n\ndef last_line?(cur)\n  cur[0] == @lines.size - 1\nend\n\nbuf = ''\ncur = [0, 0]\n@lines = []\nwhile l = gets.chomp\n  break if l == 'END_OF_TEXT'\n  @lines << l\nend\n\nwhile cmd = gets.chomp\n  break if cmd == '-'\n  case cmd\n  when 'a'\n    cur[1] = 0\n  when 'e'\n    cur[1] = @lines[cur[0]].size\n  when 'p'\n    cur[0] == 0 ? cur[1] = 0 : cur = [cur[0] - 1, 0]\n  when 'n'\n    last_line?(cur) ? cur[1] = 0 : cur = [cur[0] + 1, 0]\n  when 'f'\n    unless last_word?(cur)\n      cur[1] += 1\n    else\n      unless last_line?(cur)\n        cur = [cur[0] + 1, 0]\n      end\n    end\n  when 'b'\n    if cur[1] != 0\n      cur[1] -= 1\n    else\n      if cur[0] != 0\n        cur = [cur[0] - 1, @lines[cur[0] - 1].size]\n      end\n    end\n  when 'd'\n    if last_word?(cur) && !last_line?(cur)\n      l = @lines.delete_at(cur[0] + 1)\n      @lines[cur[0]] += l\n    elsif !last_word?(cur)\n      @lines[cur[0]].slice!(cur[1])\n    end\n  when 'k'\n    if last_word?(cur) && !last_line?(cur)\n      l = @lines.delete_at(cur[0] + 1)\n      @lines[cur[0]] += l\n      buf = \"\\\\n\"\n    elsif !last_word?(cur)\n      buf = @lines[cur[0]].slice!(cur[1]..-1)\n    end\n  when 'y'\n    if buf == \"\\\\n\"\n      @lines.insert(cur[0] + 1, @lines[cur[0]].slice!(cur[1]..-1))\n      cur = [cur[0] + 1, 0]\n    elsif buf != ''\n      @lines[cur[0]].insert(cur[1], buf)\n      cur[1] += buf.size\n    end\n  end\nend\n\nputs @lines"
  },
  {
    "language": "Ruby",
    "code": "class Cursor\n  attr_accessor :line, :index\n  def initialize\n    @line = 0\n    @index = 0\n  end\n  def move(n)\n    @index = n\n  end\n  def up\n    @line -= 1\n  end\n  def down\n    @line += 1\n  end\nend\n\ntext = Array.new\nwhile true do\n  text.push(gets.chomp)\n  break if text.last == \"END_OF_TEXT\"\nend\ntext.pop\n\ncursor = Cursor.new\nbuffer = \"\"\nwhile true do\n  case gets.chomp\n  when \"-\"\n    break\n  when \"a\"\n    cursor.move(0)\n  when \"e\"\n    cursor.move(text[cursor.line].size)\n  when \"p\"\n    cursor.up if cursor.line > 0\n    cursor.move(0)\n  when \"n\"\n    cursor.down if cursor.line < text.size - 1\n    cursor.move(0)\n  when \"f\"\n    if cursor.index != text[cursor.line].size\n      cursor.move(cursor.index + 1)\n    elsif cursor.line < text.size - 1\n      cursor.down\n      cursor.move(0)\n    end\n  when \"b\"\n    if cursor.index != 0\n      cursor.move(cursor.index - 1)\n    elsif cursor.line > 0\n      cursor.up\n      cursor.move(text[cursor.line].size)\n    end\n  when \"d\"\n    if cursor.index != text[cursor.line].size\n      text[cursor.line].slice!(cursor.index)\n    elsif cursor.line < text.size - 1\n      text[cursor.line] += text[cursor.line + 1]\n      text.delete_at(cursor.line + 1)\n    end\n  when \"k\"\n    if cursor.index != text[cursor.line].size\n      buffer = text[cursor.line].slice!(cursor.index...text[cursor.line].size)\n    elsif cursor.line < text.size - 1\n      text[cursor.line] += text[cursor.line + 1]\n      text.delete_at(cursor.line + 1)\n      buffer = \"\\n\"\n    end\n  when \"y\"\n    case buffer\n    when \"\"\n    when \"\\n\"\n      text.insert(cursor.line + 1, text[cursor.line].slice!(cursor.index...text[cursor.line].size))\n      cursor.down\n      cursor.move(0)\n    else\n      text[cursor.line].insert(cursor.index, buffer)\n      cursor.move(cursor.index + buffer.size)\n    end\n  end\nend\n\nputs text"
  },
  {
    "language": "Ruby",
    "code": "## main\n\ntexts = []\nbuffer = \"\"\n\nloop do\n  line = gets.strip\n  break if line == 'END_OF_TEXT'\n\n  texts << line\nend\n\ncx = cy = 0\n\n#p [cx, cy]\n#p texts\n\nloop do\n  cmd = gets.strip\n  break if cmd == '-'\n\n  case cmd\n  when 'a'\n    cx = 0\n  when 'e'\n    cx = texts[cy].length\n  when 'p'\n    cx = 0\n    cy -= 1 if cy > 0\n  when 'n'\n    cx = 0\n    cy += 1 if cy < texts.length - 1\n  when 'f'\n    if cx < texts[cy].length\n      cx += 1\n    elsif cy < texts.length - 1\n      cy += 1\n      cx = 0\n    end\n  when 'b'\n    if cx > 0\n      cx -= 1\n    elsif cy > 0\n      cy -= 1\n      cx = texts[cy].length\n    end\n  when 'd'\n    if cx < texts[cy].length\n      texts[cy][cx] = ''\n    elsif cy < texts.length - 1\n      texts[cy] += texts.delete_at(cy + 1)\n    end\n  when 'k'\n    if cx == texts[cy].length\n      if cy < texts.length - 1\n        texts[cy] += texts.delete_at(cy + 1)\n        buffer = \"\\n\"\n      end\n    else\n      buffer = texts[cy][cx...texts[cy].length]\n      texts[cy][cx...texts[cy].length] = ''\n    end\n  when 'y'\n    if buffer == \"\\n\"\n      nline = texts[cy][cx...texts[cy].length]\n      texts[cy][cx...texts[cy].length] = ''\n      texts[cy, 0] = nline\n      cy += 1\n      cx = 0\n    elsif buffer != \"\"\n      texts[cy][cx, 0] = buffer\n      cx += buffer.length\n    end\n  end\n  #p [cmd, cx, cy, buffer]\n  #p texts\nend\n\nfor line in texts\n  puts line\nend"
  },
  {
    "language": "Ruby",
    "code": "class Cursor\n  attr_accessor :line, :index\n  def initialize\n    @line = 0\n    @index = 0\n  end\n  def move(n)\n    @index = n\n  end\n  def up\n    @line -= 1\n  end\n  def down\n    @line += 1\n  end\nend\n\ntext = Array.new\nwhile true do\n  text.push(gets.chomp)\n  break if text.last == \"END_OF_TEXT\"\nend\ntext.pop\n\ncursor = Cursor.new\nbuffer = \"\"\nwhile true do\n  case gets.chomp\n  when \"-\"\n    break\n  when \"a\"\n    cursor.move(0)\n  when \"e\"\n    cursor.move(text[cursor.line].size)\n  when \"p\"\n    cursor.up if cursor.line > 0\n    cursor.move(0)\n  when \"n\"\n    cursor.down if cursor.line < text.size - 1\n    cursor.move(0)\n  when \"f\"\n    if cursor.index < text[cursor.line].size\n      cursor.move(cursor.index + 1)\n    elsif cursor.line < text.size - 1\n      cursor.down\n      cursor.move(0)\n    end\n  when \"b\"\n    if cursor.index > 0\n      cursor.move(cursor.index - 1)\n    elsif cursor.line > 0\n      cursor.up\n      cursor.move(text[cursor.line].size - 1)\n    end\n  when \"d\"#あやしい\n    if cursor.index != text[cursor.line].size\n      text[cursor.line].slice!(cursor.index)\n    elsif cursor.line < text.size - 1\n      text[cursor.line] += text[cursor.line + 1]\n      text.delete_at(cursor.line + 1)\n    end\n  when \"k\"\n    if cursor.index != text[cursor.line].size\n      buffer = text[cursor.line].slice!(cursor.index...text[cursor.line].size)\n    elsif cursor.line < text.size - 1\n      text[cursor.line] += text[cursor.line + 1]\n      text.delete_at(cursor.line + 1)\n      buffer = \"\\n\"\n    end\n  when \"y\"\n    case buffer\n    when \"\"\n    when \"\\n\"\n      text.insert(cursor.line + 1, text[cursor.line].slice!(cursor.index...text[cursor.line].size))\n    else\n      text[cursor.line].insert(cursor.index, buffer)\n      cursor.move(cursor.index + buffer.size)\n    end\n  end\nend\n\nputs text"
  },
  {
    "language": "Ruby",
    "code": "lines = []\nwhile line = gets.chomp\n    break if line == \"END_OF_TEXT\"\n    lines << line\nend\n\ncursor_y, cursor_x = 0, 0\nbuffer = nil\nwhile true\n    line = gets.chomp\n    case line\n    when \"a\"\n        cursor_x = 0\n    when \"e\"\n        cursor_x = lines[cursor_y].length\n    when \"p\"\n        cursor_y -= 1 if cursor_y > 0\n        cursor_x = 0\n    when \"n\"\n        cursor_y += 1 if cursor_y < lines.length - 1\n        cursor_x = 0\n    when \"f\"\n        if cursor_x < lines[cursor_y].length\n            cursor_x += 1\n        else\n            if cursor_y < lines.length - 1\n                cursor_y += 1\n                cursor_x = 0\n            end\n        end\n    when \"b\"\n        if cursor_x > 0\n            cursor_x -= 1\n        else\n            if cursor_y > 0\n                cursor_y -= 1\n                cursor_x = lines[cursor_y].length\n            end\n        end\n    when \"d\"\n        if cursor_x < lines[cursor_y].length\n            lines[cursor_y][cursor_x, 1] = \"\"\n        else\n            if cursor_y < lines.length - 1\n                lines[cursor_y] += lines[cursor_y + 1]\n                lines.delete_at(cursor_y + 1)\n            end\n        end\n    when \"k\"\n        if cursor_x < lines[cursor_y].length\n            buffer = lines[cursor_y][cursor_x..-1]\n            lines[cursor_y] = lines[cursor_y][0...cursor_x]\n        else\n            if cursor_y < lines.length - 1\n                lines[cursor_y] += lines[cursor_y + 1]\n                lines.delete_at(cursor_y + 1)\n                buffer = \"\"\n            end\n        end\n    when \"y\"\n        if buffer == \"\"\n            temp = lines[cursor_y][cursor_x..-1]\n            lines[cursor_y] = lines[cursor_y][0...cursor_x]\n            cursor_y += 1\n            cursor_x = 0\n            lines[cursor_y, 0] = temp\n        elsif !buffer.nil?\n            lines[cursor_y][cursor_x, 0] = buffer\n            cursor_x += buffer.length\n        end\n    when \"-\"\n        break\n    end\nend\nlines.each{|line| puts line}\n\n"
  },
  {
    "language": "Ruby",
    "code": "END_OF_TEXT = 'END_OF_TEXT'\nEND_OF_COMMAND = '-'\n\n$text = []\n$commands = []\n\ndef input_line s_end\n    return false if ! ( s = gets )\n    s = s.strip\n    s == s_end ? false : s\nend\n\ndef input_until s\n    ->() {\n        res = []\n        while line = input_line(s) do\n            res.push(line)\n        end\n        res.empty? ? false : res\n    }\nend\n\n$input_text = input_until END_OF_TEXT\n$input_commands = input_until END_OF_COMMAND\n\ndef input\n    if $text = $input_text.call\n        if $commands = $input_commands.call\n            return true\n        end\n    end\n    return false\nend\n\nclass Editor\n    def initialize\n        @r = 0\n        @c = 0\n        @buffer = \"\"\n    end\n\n    def check_cursor_leftmost\n        @c == 0\n    end\n\n    def check_cursor_rightmost\n        @c == $text[@r].length\n    end\n\n    def has_prev_line\n        @r - 1 >= 0\n    end\n\n    def has_next_line\n        @r + 1 < $text.length\n    end\n\n    def delete_line k\n        $text[k, 1] = []\n    end\n\n    def delete_letter k\n        $text[@r][k, 1] = '' \n    end\n\n    def move_to_leftmost \n        @c = 0\n    end\n\n    def move_to_rightmost\n        @c = $text[@r].length\n    end\n\n    def move_to_up\n        @r -= 1\n    end\n\n    def move_to_down\n        @r += 1\n    end\n\n    def move_to_left k = 1\n        @c -= k\n    end\n\n    def move_to_right k = 1\n        @c += k\n    end\n\n    def command_a\n        move_to_leftmost\n    end\n\n    def command_e\n        move_to_rightmost\n    end\n\n    def command_p\n        move_to_up if has_prev_line\n        move_to_leftmost\n    end\n\n    def command_n\n        move_to_down if has_next_line\n        move_to_leftmost\n    end\n\n    def command_f\n        if check_cursor_rightmost\n            move_to_down if has_next_line\n            move_to_leftmost\n        else\n            move_to_right\n        end\n    end\n\n    def command_b\n        if check_cursor_leftmost\n            move_to_up if has_prev_line\n            move_to_rightmost\n        else\n            move_to_left\n        end\n    end\n\n    def command_d\n        if check_cursor_rightmost\n            if has_next_line\n                $text[@r] += $text[@r+1]\n                delete_line @r + 1\n            end\n        else\n            delete_letter @c\n        end\n    end\n\n    def command_k\n        if check_cursor_rightmost\n            if has_next_line\n                $text[@r] += $text[@r+1]\n                delete_line @r + 1\n                @buffer = '\\n'\n            end\n        else\n            @buffer = $text[@r][@c..$text[@r].length-1]\n            $text[@r] = $text[@r][0, @c]\n        end\n    end\n\n    def command_y\n        if @buffer == '\\n'\n            tmp = $text[@r][@c..$text[@r].length-1]\n            $text[@r] = $text[@r][0, @c]\n            $text[@r, 0] = tmp\n            move_to_down\n            move_to_leftmost\n        elsif @buffer != ''\n            $text[@r][@c, 0] = @buffer\n            move_to_right @buffer.length\n        end\n    end\n\n    def command s\n        case s\n        when \"a\"\n            command_a\n        when \"e\"\n            command_e\n        when \"p\"\n            command_p\n        when \"n\"\n            command_n\n        when \"f\"\n            command_f\n        when \"b\"\n            command_b\n        when \"d\"\n            command_d\n        when \"k\"\n            command_k\n        when \"y\"\n            command_y\n        end\n    end\nend\n\ndef execute_command s\n    $e.command s\nend\n\ndef solve\n    $e = Editor.new\n    $commands.each {|cmd|\n        execute_command cmd\n    }\nend\n\ndef output\n    $text.map {|s| puts s}\nend\n\nwhile input\n    solve\n    output\nend"
  },
  {
    "language": "Ruby",
    "code": "X = 1\nY = 0\n\nclass Editor\n  def initialize\n    @text = []\n    @buffer = ''\n    @cursor = [0, 0]\n  end\n\n  def line_start?\n    @cursor[Y] == 0\n  end\n\n  def line_end?\n    @cursor[Y] == @text.size - 1\n  end\n\n  def str_start?\n    @cursor[X] == 0\n  end\n\n  def str_end?\n    y = @cursor[Y]\n    @cursor[X] == @text[y].size\n  end\n\n  def character?\n    (not str_end?)\n  end\n\n  attr_accessor :text, :buffer, :cursor\nend\n\nclass CommandA\n  def self.execute editor\n    editor.cursor[X] = 0\n  end\nend\n\nclass CommandE\n  def self.execute editor\n    y = editor.cursor[Y]\n    editor.cursor[X] = editor.text[y].size\n  end\nend\n\nclass CommandP\n  def self.execute editor\n    editor.cursor[Y] -= 1 unless editor.line_start?\n    editor.cursor[X] = 0\n  end\nend\n\nclass CommandN\n  def self.execute editor\n    editor.cursor[Y] += 1 unless editor.line_end?\n    editor.cursor[X] = 0\n  end\nend\n\nclass CommandF\n  def self.execute editor\n    y = editor.cursor[Y]\n    if not editor.str_end?\n      editor.cursor[X] += 1\n    elsif not editor.line_end?\n      editor.cursor[Y] += 1\n      editor.cursor[X] = 0\n    end\n  end\nend\n\nclass CommandB\n  def self.execute editor\n    if not editor.str_start?\n      editor.cursor[X] -= 1\n    elsif not editor.line_start?\n      editor.cursor[Y] -= 1\n      y = editor.cursor[Y]\n      editor.cursor[X] = editor.text[y].size\n    end\n  end\nend\n\nclass CommandD\n  def self.execute editor\n    x = editor.cursor[X]\n    y = editor.cursor[Y]\n\n    if editor.character?\n      editor.text[y].slice!(x)\n    elsif editor.str_end? and not editor.line_end?\n      editor.text[y] << editor.text[y+1]\n      editor.text.slice!(y+1)\n    end\n  end\nend\n\nclass CommandK\n  def self.execute editor\n    x = editor.cursor[X]\n    y = editor.cursor[Y]\n\n    if editor.character?\n      editor.buffer = editor.text[y].slice!(x..-1)\n    elsif editor.str_end? and not editor.line_end?\n      editor.buffer = '\\n'\n      editor.text[y] << editor.text[y+1]\n      editor.text.slice!(y+1)\n    end\n  end\nend\n\nclass CommandY\n  def self.execute editor\n    unless editor.buffer.empty?\n      x = editor.cursor[X]\n      y = editor.cursor[Y]\n\n      if editor.buffer == '\\n'\n        str = editor.text[y].slice!(x..-1)\n        editor.text.insert(y+1, str)\n        editor.cursor[X] = 0\n        editor.cursor[Y] += 1\n      else\n        editor.text[y].insert(x, editor.buffer)\n        editor.cursor[X] += editor.buffer.size\n      end\n    end\n  end\nend\n\ndef main\n  editor = Editor.new\n  loop do\n    line = gets.chomp\n    break if line == 'END_OF_TEXT'\n    editor.text << line\n  end\n\n  command_list = []\n  loop do\n    command = gets.chomp\n    break if command == '-'\n    command_list << command\n  end\n\n  command_list.each do |command|\n    eval(\"Command#{command.upcase}\").execute(editor)\n  end\n\n  editor.text.each {|line| puts line}\nend\n\nmain"
  },
  {
    "language": "Ruby",
    "code": "## subroutines\n\ndef bol(text, pos)\n  while pos > 0 && text[pos - 1] != \"\\n\"\n    pos -= 1\n  end\n  pos\nend\n\ndef eol(text, pos)\n  while pos < text.length && text[pos] != \"\\n\"\n    pos += 1\n  end\n  pos\nend\n\n### main\n\ntext = \"\"\nbuffer = \"\"\n\nloop do\n  line = gets\n  break if line == \"END_OF_TEXT\\n\"\n\n  text += line\nend\n\npos = 0\n\nloop do\n  cmd = gets.strip\n  break if cmd == '-'\n\n  case cmd\n  when 'a'\n    pos = bol(text, pos)\n  when 'e'\n    pos = eol(text, pos)\n  when 'p'\n    pos = bol(text, pos)\n    if pos > 0\n      pos = bol(text, pos - 1)\n    end\n  when 'n'\n    pos0 = eol(text, pos)\n    if pos0 < text.length\n      pos0 += 1\n    end\n    pos = bol(text, pos0)\n  when 'f'\n    pos += 1 if pos < text.length\n  when 'b'\n    pos -= 1 if pos > 0\n  when 'd'\n    if pos < text.length\n      text[pos] = ''\n    end\n  when 'k'\n    if text[pos] == \"\\n\"\n      text[pos] = ''\n      buffer = \"\\n\"\n    else\n      pos0 = eol(text, pos)\n      buffer = text[pos...pos0]\n      text[pos...pos0] = ''\n    end\n  when 'y'\n    text[pos, 0] = buffer\n    pos += buffer.length\n  end\n  #p [cmd, cx, cy, buffer]\n  #p texts\nend\n\nputs text"
  },
  {
    "language": "Ruby",
    "code": "class Cursor\n  attr_accessor :line, :index\n  def initialize\n    @line = 0\n    @index = 0\n  end\n  def move(n)\n    @index = n\n  end\n  def up\n    @line -= 1\n  end\n  def down\n    @line += 1\n  end\nend\n\ntext = Array.new\nwhile true do\n  text.push(gets.chomp)\n  break if text.last == \"END_OF_TEXT\"\nend\ntext.pop\n\ncursor = Cursor.new\nbuffer = \"\"\nwhile true do\n  case gets.chomp\n  when \"-\"\n    break\n  when \"a\"\n    cursor.move(0)\n  when \"e\"\n    cursor.move(text[cursor.line].size)\n  when \"p\"\n    cursor.up if cursor.line > 0\n    cursor.move(0)\n  when \"n\"\n    cursor.down if cursor.line < text.size - 1\n    cursor.move(0)\n  when \"f\"\n    if cursor.index < text[cursor.line].size\n      cursor.move(cursor.index + 1)\n    elsif cursor.line < text.size - 1\n      cursor.down\n      cursor.move(0)\n    end\n  when \"b\"\n    if cursor.index > 0\n      cursor.move(cursor.index - 1)\n    elsif cursor.line > 0\n      cursor.up\n      cursor.move(text[cursor.line].size - 1)\n    end\n  when \"d\"#あやしい\n    if cursor.index != text[cursor.line].size\n      text[cursor.line].slice!(cursor.index)\n    elsif cursor.line < text.size - 1\n      text[cursor.line] += text[cursor.line + 1]\n      text.delete.at(cursor.line + 1)\n    end\n  when \"k\"\n    if cursor.index != text[cursor.line].size\n      buffer = text[cursor.line].slice!(cursor.index...text[cursor.line].size)\n    elsif cursor.line < text.size - 1\n      text[cursor.line] += text[cursor.line + 1]\n      text.delete.at(cursor.line + 1)\n      buffer = \"\\n\"\n    end\n  when \"y\"\n    case buffer\n    when \"\"\n    when \"\\n\"\n      text.insert(cursor.line + 1, text[cursor.line].slice!(cursor.index...text[cursor.line].size))\n    else\n      text[cursor.line].insert(cursor.index, buffer)\n      cursor.move(cursor.index + buffer.size)\n    end\n  end\nend\n\nputs text"
  },
  {
    "language": "Ruby",
    "code": "def end_of_words?(cur)\n  @lines[cur[0]].size == cur[1]\nend\n\ndef last_line?(cur)\n  cur[0] == @lines.size - 1\nend\n\nbuf = ''\ncur = [0, 0]\n@lines = []\nwhile l = gets.chomp\n  break if l == 'END_OF_TEXT'\n  @lines << l\nend\n\nloop do\n  case gets.chomp\n  when '-'\n    break\n  when 'a'\n    cur[1] = 0\n  when 'e'\n    cur[1] = @lines[cur[0]].size\n  when 'p'\n    cur[0] == 0 ? cur[1] = 0 : cur = [cur[0] - 1, 0]\n  when 'n'\n    last_line?(cur) ? cur[1] = 0 : cur = [cur[0] + 1, 0]\n  when 'f'\n    unless end_of_words?(cur)\n      cur[1] += 1\n    else\n      unless last_line?(cur)\n        cur = [cur[0] + 1, 0]\n      end\n    end\n  when 'b'\n    if cur[1] != 0\n      cur[1] -= 1\n    else\n      if cur[0] != 0\n        cur = [cur[0] - 1, @lines[cur[0] - 1].size]\n      end\n    end\n  when 'd'\n    unless end_of_words?(cur)\n      @lines[cur[0]].slice!(cur[1])\n    else\n      unless last_line?(cur)\n        l = @lines.delete_at(cur[0] + 1)\n        @lines[cur[0]] += l\n      end\n    end\n  when 'k'\n    unless end_of_words?(cur)\n      buf = @lines[cur[0]].slice!(cur[1]..-1)\n    else\n      unless last_line?(cur)\n        l = @lines.delete_at(cur[0] + 1)\n        @lines[cur[0]] += l\n        buf = '\\\\n'\n      end\n    end\n  when 'y'\n    if buf == '\\\\n'\n      @lines.insert(cur[0] + 1, @lines[cur[0]].slice!(cur[1]..-1))\n      cur = [cur[0] + 1, 0]\n    elsif buf != ''\n      @lines[cur[0]].insert(cur[1], buf)\n      cur[1] += buf.size\n    end\n  end\nend\n\nputs @lines"
  },
  {
    "language": "Ruby",
    "code": "## main\n\ntexts = []\nbuffer = \"\"\n\nloop do\n  line = gets.strip\n  break if line == 'END_OF_TEXT'\n\n  texts << line\nend\n\ncx = cy = 0\n\n#p [cx, cy]\n#p texts\n\nloop do\n  cmd = gets.strip\n  break if cmd == '-'\n\n  case cmd\n  when 'a'\n    cx = 0\n  when 'e'\n    cx = texts[cy].length\n  when 'p'\n    cx = 0\n    cy -= 1 if cy > 0\n  when 'n'\n    cx = 0\n    cy += 1 if cy < texts.length - 1\n  when 'f'\n    if cx < texts[cy].length\n      cx += 1\n    elsif cy < texts.length - 1\n      cy += 1\n      cx = 0\n    end\n  when 'b'\n    if cx > 0\n      cx -= 1\n    elsif cy > 0\n      cy -= 1\n      cx = texts[cy].length\n    end\n  when 'd'\n    if cx < texts[cy].length\n      texts[cy][cx] = ''\n    elsif cy < texts.length - 1\n      texts[cy] += texts[cy + 1]\n      texts.delete_at(cy + 1)\n    end\n  when 'k'\n    if cx == texts[cy].length\n      if cy < texts.length - 1\n        texts[cy] += texts[cy + 1]\n        texts.delete_at(cy + 1)\n        buffer = \"\\n\"\n      end\n    else\n      buffer = texts[cy][cx...texts[cy].length]\n      texts[cy][cx...texts[cy].length] = ''\n    end\n  when 'y'\n    if buffer == \"\\n\"\n      nline = texts[cy][cx...texts[cy].length]\n      texts[cy][cx...texts[cy].length] = ''\n      texts[cy, 0] = nline\n      cy += 1\n      cx = 0\n    elsif buffer != \"\"\n      texts[cy][cx, 0] = buffer\n      cx += buffer.length\n    end\n  end\n  #p [cmd, cx, cy, buffer]\n  #p texts\nend\n\nfor line in texts\n  puts line\nend"
  },
  {
    "language": "Ruby",
    "code": "## subroutines\n\ndef bol(text, pos)\n  while pos > 0 && text[pos - 1] != \"\\n\"\n    pos -= 1\n  end\n  pos\nend\n\ndef eol(text, pos)\n  while pos < text.length && text[pos] != \"\\n\"\n    pos += 1\n  end\n  pos\nend\n\n### main\n\ntext = \"\"\nbuffer = \"\"\n\nloop do\n  line = gets\n  break if line == \"END_OF_TEXT\\n\"\n\n  text += line\nend\n\npos = 0\n\nloop do\n  cmd = gets.strip\n  break if cmd == '-'\n\n  case cmd\n  when 'a'\n    pos = bol(text, pos)\n  when 'e'\n    pos = eol(text, pos)\n  when 'p'\n    pos = bol(text, pos)\n    if pos > 0\n      pos = bol(text, pos - 1)\n    end\n  when 'n'\n    pos0 = eol(text, pos)\n    if pos0 < text.length\n      pos0 += 1\n    end\n    pos = bol(text, pos0)\n  when 'f'\n    pos += 1 if pos < text.length\n  when 'b'\n    pos -= 1 if pos > 0\n  when 'd'\n    if pos < text.length\n      text[pos] = ''\n    end\n  when 'k'\n    if text[pos] == \"\\n\"\n      text[pos] = ''\n      buffer = \"\\n\"\n    else\n      pos0 = eol(text, pos)\n      buffer = text[pos...pos0]\n      text[pos...pos0] = ''\n    end\n  when 'y'\n    text[pos, 0] = buffer\n    pos += buffer.length\n  end\n  #p [cmd, cx, cy, buffer]\n  #p texts\nend\n\nputs text if text != \"\""
  },
  {
    "language": "Ruby",
    "code": "X = 1\nY = 0\n\nclass Editor\n  def initialize\n    @text = []\n    @buffer = ''\n    @cursor = [0, 0]\n  end\n\n  def line_start?\n    @cursor[Y] == 0\n  end\n\n  def line_end?\n    @cursor[Y] == @text.size - 1\n  end\n\n  def str_start?\n    @cursor[X] == 0\n  end\n\n  def str_end?\n    y = @cursor[Y]\n    @cursor[X] == @text[y].size\n  end\n\n  def character?\n    (not str_end?)\n  end\n\n  def command_a\n    @cursor[X] = 0\n  end\n\n  def command_e\n    y = @cursor[Y]\n    @cursor[X] = @text[y].size\n  end\n\n  def command_p\n    @cursor[Y] -= 1 unless line_start?\n    @cursor[X] = 0\n  end\n\n  def command_n\n    @cursor[Y] += 1 unless line_end?\n    @cursor[X] = 0\n  end\n\n  def command_f\n    if not str_end?\n      @cursor[X] += 1\n    elsif not line_end?\n      @cursor[Y] += 1\n      @cursor[X] = 0\n    end\n  end\n\n  def command_b\n    if not str_start?\n      @cursor[X] -= 1\n    elsif not line_start?\n      @cursor[Y] -= 1\n      y = @cursor[Y]\n      @cursor[X] = @text[y].size\n    end\n  end\n\n  def command_d\n    x = @cursor[X]\n    y = @cursor[Y]\n\n    if character?\n      @text[y].slice!(x)\n    elsif str_end? and not line_end?\n      @text[y] << @text[y+1]\n      @text.slice!(y+1)\n    end\n  end\n\n  def command_k\n    x = @cursor[X]\n    y = @cursor[Y]\n\n    if character?\n      @buffer = @text[y].slice!(x..-1)\n    elsif str_end? and not line_end?\n      @buffer = '\\n'\n      @text[y] << @text[y+1]\n      @text.slice!(y+1)\n    end\n  end\n\n  def command_y\n    unless @buffer.empty?\n      x = @cursor[X]\n      y = @cursor[Y]\n\n      if @buffer == '\\n'\n        str = @text[y].slice!(x..-1)\n        @text.insert(y+1, str)\n        @cursor[X] = 0\n        @cursor[Y] += 1\n      else\n        @text[y].insert(x, @buffer)\n        @cursor[X] += @buffer.size\n      end\n    end\n  end\n\n  def write line\n    @text << line\n  end\n\n  def print\n    @text.each {|line| puts line}\n  end\nend\n\ndef main\n  editor = Editor.new\n  loop do\n    line = gets.chomp\n    break if line == 'END_OF_TEXT'\n    editor.write(line)\n  end\n\n  loop do\n    command = gets.chomp\n    break if command == '-'\n    eval(\"editor.command_#{command}\")\n  end\n\n  editor.print\nend\n\nmain"
  },
  {
    "language": "Ruby",
    "code": "END_OF_TEXT = 'END_OF_TEXT'\nEND_OF_COMMAND = '-'\n\n$text = []\n$commands = []\n\ndef input_line s_end\n    return false if ! ( s = gets )\n    s = s.strip\n    s == s_end ? false : s\nend\n\ndef input_until s\n    ->() {\n        res = []\n        while line = input_line(s) do\n            res.push(line)\n        end\n        res\n    }\nend\n\n$input_text = input_until END_OF_TEXT\n$input_commands = input_until END_OF_COMMAND\n\ndef input\n    $text = $input_text.call\n    if $text.empty?\n        $text = false\n    end\n    if $text \n        $commands = $input_commands.call\n        return true\n    end\n    return false\nend\n\nclass Editor\n    def initialize\n        @r = 0\n        @c = 0\n        @buffer = \"\"\n    end\n\n    def check_cursor_leftmost\n        @c == 0\n    end\n\n    def check_cursor_rightmost\n        @c == $text[@r].length\n    end\n\n    def has_prev_line\n        @r - 1 >= 0\n    end\n\n    def has_next_line\n        @r + 1 < $text.length\n    end\n\n    def delete_line k\n        $text[k, 1] = []\n    end\n\n    def delete_letter k\n        $text[@r][k, 1] = '' \n    end\n\n    def move_to_leftmost \n        @c = 0\n    end\n\n    def move_to_rightmost\n        @c = $text[@r].length\n    end\n\n    def move_to_up\n        @r -= 1\n    end\n\n    def move_to_down\n        @r += 1\n    end\n\n    def move_to_left k = 1\n        @c -= k\n    end\n\n    def move_to_right k = 1\n        @c += k\n    end\n\n    def command_a\n        move_to_leftmost\n    end\n\n    def command_e\n        move_to_rightmost\n    end\n\n    def command_p\n        move_to_up if has_prev_line\n        move_to_leftmost\n    end\n\n    def command_n\n        move_to_down if has_next_line\n        move_to_leftmost\n    end\n\n    def command_f\n        if check_cursor_rightmost\n            move_to_down if has_next_line\n            move_to_leftmost\n        else\n            move_to_right\n        end\n    end\n\n    def command_b\n        if check_cursor_leftmost\n            move_to_up if has_prev_line\n            move_to_rightmost\n        else\n            move_to_left\n        end\n    end\n\n    def command_d\n        if check_cursor_rightmost\n            if has_next_line\n                $text[@r] += $text[@r+1]\n                delete_line @r + 1\n            end\n        else\n            delete_letter @c\n        end\n    end\n\n    def command_k\n        if check_cursor_rightmost\n            if has_next_line\n                $text[@r] += $text[@r+1]\n                delete_line @r + 1\n                @buffer = '\\n'\n            end\n        else\n            @buffer = $text[@r][@c..$text[@r].length-1]\n            $text[@r] = $text[@r][0, @c]\n        end\n    end\n\n    def command_y\n        if @buffer == '\\n'\n            tmp = $text[@r][@c..$text[@r].length-1]\n            $text[@r] = $text[@r][0, @c]\n            $text[@r, 0] = tmp\n            move_to_down\n            move_to_leftmost\n        elsif @buffer != ''\n            $text[@r][@c, 0] = @buffer\n            move_to_right @buffer.length\n        end\n    end\n\n    def command s\n        case s\n        when \"a\"\n            command_a\n        when \"e\"\n            command_e\n        when \"p\"\n            command_p\n        when \"n\"\n            command_n\n        when \"f\"\n            command_f\n        when \"b\"\n            command_b\n        when \"d\"\n            command_d\n        when \"k\"\n            command_k\n        when \"y\"\n            command_y\n        end\n    end\nend\n\ndef execute_command s\n    $e.command s\nend\n\ndef solve\n    $e = Editor.new\n    $commands.each {|cmd|\n        execute_command cmd\n    }\nend\n\ndef output\n    $text.map {|s| puts s}\nend\n\nwhile input\n    solve\n    output\nend"
  },
  {
    "language": "Ruby",
    "code": "def end_of_words?(cur)\n  @lines[cur[0]].size == cur[1]\nend\n\ndef last_line?(cur)\n  cur[0] == @lines.size - 1\nend\n\nbuf = ''\ncur = [0, 0]\n@lines = []\nwhile l = gets.chomp\n  break if l == 'END_OF_TEXT'\n  @lines << l\nend\n\nwhile cmd = gets.chomp\n  break if cmd == '-'\n  case cmd\n  when 'a'\n    cur[1] = 0\n  when 'e'\n    cur[1] = @lines[cur[0]].size\n  when 'p'\n    cur[0] == 0 ? cur[1] = 0 : cur = [cur[0] - 1, 0]\n  when 'n'\n    last_line?(cur) ? cur[1] = 0 : cur = [cur[0] + 1, 0]\n  when 'f'\n    unless end_of_words?(cur)\n      cur[1] += 1\n    else\n      unless last_line?(cur)\n        cur = [cur[0] + 1, 0]\n      end\n    end\n  when 'b'\n    if cur[1] != 0\n      cur[1] -= 1\n    else\n      if cur[0] != 0\n        cur = [cur[0] - 1, @lines[cur[0] - 1].size]\n      end\n    end\n  when 'd'\n    unless end_of_words?(cur)\n      @lines[cur[0]].slice!(cur[1])\n    else\n      unless last_line?(cur)\n        l = @lines.delete_at(cur[0] + 1)\n        @lines[cur[0]] += l\n      end\n    end\n  when 'k'\n    unless end_of_words?(cur)\n      buf = @lines[cur[0]].slice!(cur[1]..-1)\n    else\n      unless last_line?(cur)\n        l = @lines.delete_at(cur[0] + 1)\n        @lines[cur[0]] += l\n        buf = '\\\\n'\n      end\n    end\n  when 'y'\n    if buf == '\\\\n'\n      @lines.insert(cur[0] + 1, @lines[cur[0]].slice!(cur[1]..-1))\n      cur = [cur[0] + 1, 0]\n    elsif buf != ''\n      @lines[cur[0]].insert(cur[1], buf)\n      cur[1] += buf.size\n    end\n  end\nend\n\nputs @lines"
  },
  {
    "language": "Python",
    "code": "text = []\nwhile True:\n  s = input()\n  if s == \"END_OF_TEXT\":\n    break\n  text.append(s)\n\nx, y = 0, 0\nbuff = \"\"\nwhile True:\n  c = input()\n  if c == \"-\":\n    break\n\n  elif c == \"a\":\n    x = 0\n\n  elif c == \"e\":\n    x = len(text[y])\n\n  elif c == \"p\":\n    if y == 0:\n      x = 0\n    else:\n      x = 0\n      y -= 1\n\n  elif c == \"n\":\n    if y == len(text) - 1:\n      x = 0\n    else:\n      y += 1\n      x = 0\n\n  elif c == \"f\":\n    if x != len(text[y]):\n      x += 1\n    elif y != len(text) - 1:\n      y += 1\n      x = 0\n\n  elif c == \"b\":\n    if x != 0:\n      x -= 1\n    elif y != 0:\n      y -= 1\n      x = len(text[y])\n\n  elif c ==\"d\":\n    if x < len(text[y]):\n      text[y] = text[y][:x] + text[y][x + 1:] \n    elif y != len(text) - 1:\n      text[y] = text[y] + text[y + 1]\n      text = text[:y + 1] + text[y + 2:]\n\n  elif c == \"k\":\n    if x < len(text[y]):\n      buff = text[y][x:]\n      text[y] = text[y][:x]\n    elif y != len(text) - 1:\n      text[y] = text[y] + text[y + 1]\n      text = text[:y + 1] + text[y + 2:]\n      buff = \"\\n\"\n\n  elif c ==\"y\":\n    if buff == \"\\n\":\n      new_row = text[y][x:]\n      text[y] = text[y][:x]\n      text = text[:y + 1] + [new_row] + text[y + 1:]\n      x = 0\n      y += 1\n    else:\n      text[y] = text[y][:x] + buff + text[y][x:]\n      x += len(buff)\n\nprint(*text, sep=\"\\n\")\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\nclass Cursor:\n    BOL = (0,1)\n\n    def __init__(self, text):\n        assert isinstance(text, list)\n        self.text = text\n\n        for i in range(len(self.text)):\n            self.text[i] = list(self.text[i])\n\n        self.buffer = \"\"\n        self.line = 1\n        self.pos = self.BOL\n\n    def _check(self):\n        assert self.line > 0\n\n    def _get_pos_end_of_line(self):\n        last_char = len(self.text[self.line-1])\n        return (last_char, last_char+1)\n\n    def has_prev_line(self):\n        return self.line > 1\n\n    def has_next_line(self):\n        return self.line < len(self.text)\n\n    def beginning_of_line(self):\n        self.pos = self.BOL\n\n    def end_of_line(self):\n        self.pos = self._get_pos_end_of_line()\n\n    def prev_line(self):\n        if self.has_prev_line():\n            self.line -= 1\n\n    def next_line(self):\n        if self.has_next_line():\n            self.line += 1\n\n    def right_pos(self):\n        if self._get_pos_end_of_line() != self.pos:\n            self.pos = (self.pos[0] + 1, self.pos[1] + 1)\n        else:\n            if self.has_next_line():\n                self.line += 1\n                self.pos = self.BOL\n\n    def left_pos(self):\n        if self.BOL != self.pos:\n            self.pos = (self.pos[0] - 1, self.pos[1] - 1)\n        else:\n            if self.has_prev_line():\n                self.line -= 1\n                self.pos = self._get_pos_end_of_line()\n\n    def remove_current_pos(self):\n        if self._get_pos_end_of_line() != self.pos:\n            self.text[self.line-1] = self.text[self.line-1][:self.pos[0]] + self.text[self.line-1][self.pos[1]:]\n        else:\n            if self.has_next_line():\n                self.text[self.line-1][self.pos[0]:self.pos[0]] = self.text[self.line]\n                self.text.pop(self.line)\n\n    def remove_to_end_of_line(self):\n        if self._get_pos_end_of_line() == self.pos:\n            if self.has_next_line():\n                self.remove_current_pos()\n                self.buffer = '\\n'\n        else:\n            self.buffer = self.text[self.line - 1][self.pos[0]:]\n            self.text[self.line - 1] = self.text[self.line - 1][:self.pos[0]]\n            self.pos = self._get_pos_end_of_line()\n\n    def paste(self):\n        if self.buffer:\n            if self.buffer == '\\n':\n                prev = self.text[self.line - 1][:self.pos[0]]\n                next = self.text[self.line - 1][self.pos[0]:]\n\n                self.text[self.line - 1] = prev\n                self.text.insert(self.line, next)\n\n                self.line += 1\n                self.pos = self.BOL\n            else:\n                self.text[self.line - 1][self.pos[0]:self.pos[0]] = self.buffer\n                self.pos = (self.pos[0] + len(self.buffer), self.pos[1] + len(self.buffer))\n\n    def print(self):\n        for t in self.text:\n            print(\"\".join(t))\n\n\nclass Editor:\n    def __init__(self, text):\n        assert isinstance(text, list)\n        self.cursor = Cursor(text)\n\n    def process(self, commands):\n        if not isinstance(commands, list):\n            commands = [commands]\n\n        for command in commands:\n            self._process(command)\n\n        self.cursor.print()\n\n    def _process(self, command):\n        if command == 'a':\n            self.cursor.beginning_of_line()\n        elif command == 'e':\n            self.cursor.end_of_line()\n        elif command == 'p':\n            self.cursor.prev_line()\n            self.cursor.beginning_of_line()\n        elif command == 'n':\n            self.cursor.next_line()\n            self.cursor.beginning_of_line()\n        elif command == 'f':\n            self.cursor.right_pos()\n        elif command == 'b':\n            self.cursor.left_pos()\n        elif command == 'd':\n            self.cursor.remove_current_pos()\n        elif command == 'k':\n            self.cursor.remove_to_end_of_line()\n        elif command == 'y':\n            self.cursor.paste()\n\n\n\n\ndef load_input():\n    inputs = []\n    while True:\n        try:\n            inputs.append(input())\n        except EOFError:\n            return inputs\n\ndef split_end_of_text(inputs):\n    assert inputs\n    assert 'END_OF_TEXT' in inputs\n\n    for i in range(len(inputs)):\n        if inputs[i] == 'END_OF_TEXT':\n            return inputs[:i], inputs[i+1:]\n    else:\n        print(\"DO NOT DETECT END_OF_TEXT. got:\", inputs)\n        sys.exit(1)\n\n    \ndef main():\n    inputs = load_input()\n    text, commands = split_end_of_text(inputs)\n\n    # Attacking\n    assert 'END_OF_TEXT' not in text\n    assert 'END_OF_TEXT' not in commands\n\n    editor = Editor(text)\n    editor.process(commands)\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "class Editer:\n\n    def __init__(self, text):\n        # カーソルの位置\n        self.row = 0 #行\n        self.col = 0 #列\n        # 編集中のテキスト\n        self.text = [list(t) + ['\\n'] for t in text]\n        # バッファー\n        self.buffer = []\n\n    def row_head(self):\n        return 0\n\n    def row_tail(self):\n        return len(self.text) - 1\n\n    def col_head(self):\n        return 0\n\n    def col_tail(self):\n        return len(self.text[self.row]) - 1\n\n    def __repr__(self):\n        return ''.join(''.join(t) for t in self.text)\n\n    def command_a(self):\n        # カーソルを現在の行の先頭文字に移動\n        self.col = self.col_head()\n\n    def command_e(self):\n        # カーソルを現在の行の行末に移動\n        self.col = self.col_tail()\n\n    def command_p(self):\n        # 上に行があれば、カーソルを上の行に\n        if self.row != self.row_head() :\n            self.row -= 1\n        # カーソルを先頭に\n        self.col = self.col_head()\n\n    def command_n(self):\n        # 下に行があれば\n        if self.row != self.row_tail():\n            # カーソルを下の行に移動\n            self.row += 1\n        # カーソルを先頭文字に移動\n        self.col = self.col_head()\n\n    def command_b(self):\n        # カーソルが行末にない場合\n        if self.col != self.col_head():\n            # カーソルを１つ左に移動\n            self.col -= 1\n        # カーソルが行末にあり、上に行がある場合\n        elif self.row != self.row_head():\n            # カーソルを前の行の先頭に\n            self.row -= 1\n            self.col = self.col_tail()\n\n    def command_f(self):\n        # カーソルが行末にない場合\n        if self.col != self.col_tail():\n            # カーソルを１つ右に移動\n            self.col += 1\n        # カーソルが行末にあり、下に行がある場合\n        elif self.row != self.row_tail():\n            # カーソルを次の行の先頭に\n            self.row += 1\n            self.col = self.col_head()\n\n    def command_d(self):\n        # カーソルが行末にない場合\n        if self.col != self.col_tail():\n            # カーソルの文字を削除\n            self.text[self.row].pop(self.col)\n        # カーソルが行末を指し、下に行がある場合\n        elif self.row != self.row_tail():\n            # 下の行をそのままカーソルの位置に繋げ、以下の行は上にシフト\n            self.text[self.row].pop(self.col_tail())\n            self.text[self.row] += self.text.pop(self.row+1)\n\n    def command_k(self):\n        # カーソルが行末にない場合\n        if self.col != self.col_tail():\n            # カーソルが指す文字を含めた右側すべての文字を切り取りそれをバッファに記録する。\n            self.buffer = self.text[self.row][self.col:-1]\n            self.text[self.row] = self.text[self.row][:self.col] + ['\\n']\n            # カーソルは元の行の行末を指すようになる\n            self.col = self.col_tail()\n        # カーソルが行末にあり、下に行がある場合\n        elif self.row != self.row_tail():\n            # バッファに改行を記録する。\n            self.buffer = ['\\n']\n            # 下の行をそのままカーソルの位置に繋げる。以下の行は上にシフトされる。\n            self.text[self.row].pop(self.col_tail())\n            self.text[self.row] += self.text.pop(self.row+1)\n\n\n    def command_y(self):\n        '''\n        カーソルが指す文字の直前にバッファを挿入\n        カーソルの位置はもともと指していた文字へ移動\n        バッファの内容が改行なら\n        '''\n        if self.buffer != ['\\n']:\n            self.text[self.row][self.col:self.col] = self.buffer\n            self.col += len(self.buffer)\n\n        else:\n            self.text.insert(self.row+1, self.text[self.row][self.col:])\n            self.text[self.row] = self.text[self.row][:self.col] + ['\\n']\n            self.row += 1\n            self.col = self.col_head()\n\n\n\ndef main():\n    # input text\n    text = []\n    while True:\n        str = input()\n        if str == 'END_OF_TEXT': break\n        text.append(str)\n\n    editer = Editer(text)\n\n    # input command\n    while True:\n        command = input()\n        if   command == 'a' : editer.command_a()\n        elif command == 'e' : editer.command_e()\n        elif command == 'p' : editer.command_p()\n        elif command == 'n' : editer.command_n()\n        elif command == 'f' : editer.command_f()\n        elif command == 'b' : editer.command_b()\n        elif command == 'd' : editer.command_d()\n        elif command == 'y' : editer.command_y()\n        elif command == 'k' : editer.command_k()\n        elif command == '-' : break\n\n    print(editer, end='')\n\nif __name__ == '__main__': main()\n\n"
  }
]