[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LINES 100\n#define MAX_LINE_LENGTH 1000\n#define MAX_BUFFER_SIZE 10000\n\nchar text[MAX_LINES][MAX_LINE_LENGTH];\nchar buffer[MAX_BUFFER_SIZE];\nint buffer_size = 0;\nint num_lines = 0;\nint cursor_line = 0;\nint cursor_pos = 0;\n\nvoid insert_char(char c) {\n    if (cursor_pos < MAX_LINE_LENGTH - 1) {\n        memmove(&text[cursor_line][cursor_pos + 1], &text[cursor_line][cursor_pos], \n                strlen(&text[cursor_line][cursor_pos]) + 1);\n        text[cursor_line][cursor_pos] = c;\n        cursor_pos++;\n    }\n}\n\nvoid delete_char() {\n    if (cursor_pos < strlen(text[cursor_line])) {\n        memmove(&text[cursor_line][cursor_pos], &text[cursor_line][cursor_pos + 1], \n                strlen(&text[cursor_line][cursor_pos + 1]) + 1);\n    } else if (cursor_line < num_lines - 1) {\n        strcat(text[cursor_line], text[cursor_line + 1]);\n        memmove(&text[cursor_line + 1], &text[cursor_line + 2], \n                (num_lines - cursor_line - 2) * MAX_LINE_LENGTH);\n        num_lines--;\n    }\n}\n\nvoid cut() {\n    buffer_size = 0;\n    if (cursor_pos < strlen(text[cursor_line])) {\n        strcpy(buffer, &text[cursor_line][cursor_pos]);\n        buffer_size = strlen(buffer);\n        text[cursor_line][cursor_pos] = '\\0';\n    } else if (cursor_line < num_lines - 1) {\n        strcpy(buffer, text[cursor_line + 1]);\n        buffer_size = strlen(buffer);\n        memmove(&text[cursor_line + 1], &text[cursor_line + 2], \n                (num_lines - cursor_line - 2) * MAX_LINE_LENGTH);\n        num_lines--;\n    }\n}\n\nvoid paste() {\n    if (buffer_size > 0) {\n        if (cursor_pos == strlen(text[cursor_line])) {\n            strcat(text[cursor_line], buffer);\n            cursor_pos += buffer_size;\n        } else {\n            memmove(&text[cursor_line][cursor_pos + buffer_size], \n                    &text[cursor_line][cursor_pos], \n                    strlen(&text[cursor_line][cursor_pos]) + 1);\n            memcpy(&text[cursor_line][cursor_pos], buffer, buffer_size);\n            cursor_pos += buffer_size;\n        }\n    }\n}\n\nvoid move_cursor_up() {\n    if (cursor_line > 0) {\n        cursor_line--;\n        if (cursor_pos > strlen(text[cursor_line])) {\n            cursor_pos = strlen(text[cursor_line]);\n        }\n    }\n}\n\nvoid move_cursor_down() {\n    if (cursor_line < num_lines - 1) {\n        cursor_line++;\n        if (cursor_pos > strlen(text[cursor_line])) {\n            cursor_pos = strlen(text[cursor_line]);\n        }\n    }\n}\n\nvoid move_cursor_left() {\n    if (cursor_pos > 0) {\n        cursor_pos--;\n    } else if (cursor_line > 0) {\n        cursor_line--;\n        cursor_pos = strlen(text[cursor_line]);\n    }\n}\n\nvoid move_cursor_right() {\n    if (cursor_pos < strlen(text[cursor_line])) {\n        cursor_pos++;\n    } else if (cursor_line < num_lines - 1) {\n        cursor_line++;\n        cursor_pos = 0;\n    }\n}\n\nvoid print_text() {\n    for (int i = 0; i < num_lines; i++) {\n        printf(\"%s\\n\", text[i]);\n    }\n}\n\nint main() {\n    char line[MAX_LINE_LENGTH];\n    while (fgets(line, MAX_LINE_LENGTH, stdin)) {\n        if (line[0] == '\\n') break;\n        line[strcspn(line, \"\\n\")] = '\\0';\n        strcpy(text[num_lines++], line);\n    }\n\n    char command[10];\n    while (scanf(\"%s\", command) != EOF) {\n        if (strcmp(command, \"I\") == 0) {\n            char c;\n            scanf(\" %c\", &c);\n            insert_char(c);\n        } else if (strcmp(command, \"D\") == 0) {\n            delete_char();\n        } else if (strcmp(command, \"C\") == 0) {\n            cut();\n        } else if (strcmp(command, \"P\") == 0) {\n            paste();\n        } else if (strcmp(command, \"U\") == 0) {\n            move_cursor_up();\n        } else if (strcmp(command, \"Dn\") == 0) {\n            move_cursor_down();\n        } else if (strcmp(command, \"L\") == 0) {\n            move_cursor_left();\n        } else if (strcmp(command, \"R\") == 0) {\n            move_cursor_right();\n        } else if (strcmp(command, \"S\") == 0) {\n            print_text();\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:56:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class EmacsEditor {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // Read number of lines in initial text\n        int n = scanner.nextInt();\n        scanner.nextLine(); // consume newline\n        \n        // Read initial text\n        List<String> buffer = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            buffer.add(scanner.nextLine());\n        }\n        \n        // Read number of commands\n        int m = scanner.nextInt();\n        scanner.nextLine(); // consume newline\n        \n        // Cursor position\n        int line = 0;\n        int col = 0;\n        \n        // Clipboard for cut and paste\n        String clipboard = \"\";\n        \n        // Process commands\n        for (int i = 0; i < m; i++) {\n            String command = scanner.nextLine();\n            String[] parts = command.split(\" \");\n            \n            switch (parts[0]) {\n                case \"move\":\n                    line = Integer.parseInt(parts[1]) - 1;\n                    col = Integer.parseInt(parts[2]) - 1;\n                    break;\n                \n                case \"cut\":\n                    if (line < buffer.size()) {\n                        String currentLine = buffer.get(line);\n                        if (col <= currentLine.length()) {\n                            clipboard = currentLine.substring(col);\n                            buffer.set(line, currentLine.substring(0, col));\n                        }\n                    }\n                    break;\n                \n                case \"paste\":\n                    if (!clipboard.isEmpty() && line < buffer.size()) {\n                        String currentLine = buffer.get(line);\n                        buffer.set(line, currentLine.substring(0, col) + clipboard + currentLine.substring(col));\n                    }\n                    break;\n                \n                case \"delete\":\n                    if (line < buffer.size()) {\n                        String currentLine = buffer.get(line);\n                        if (col < currentLine.length()) {\n                            buffer.set(line, currentLine.substring(0, col) + currentLine.substring(col + 1));\n                        }\n                    }\n                    break;\n            }\n        }\n        \n        // Print final buffer\n        for (String line : buffer) {\n            System.out.println(line);\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 18:56:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> text;\nvector<string> clipboard;\nsize_t cursorX = 0, cursorY = 0;\n\nvoid moveCursor(int dx, int dy) {\n    cursorY = max(0, min((int)text.size() - 1, (int)cursorY + dy));\n    cursorX = max(0, min((int)text[cursorY].size(), (int)cursorX + dx));\n}\n\nvoid deleteChar() {\n    if (cursorX < text[cursorY].size()) {\n        text[cursorY].erase(cursorX, 1);\n    } else if (cursorY < text.size() - 1) {\n        text[cursorY] += text[cursorY + 1];\n        text.erase(text.begin() + cursorY + 1);\n    }\n}\n\nvoid cut() {\n    clipboard.clear();\n    if (cursorX < text[cursorY].size()) {\n        clipboard.push_back(text[cursorY].substr(cursorX));\n        text[cursorY].erase(cursorX);\n    } else if (cursorY < text.size() - 1) {\n        clipboard.push_back(text[cursorY + 1]);\n        text.erase(text.begin() + cursorY + 1);\n    }\n}\n\nvoid paste() {\n    if (clipboard.empty()) return;\n    text[cursorY].insert(cursorX, clipboard[0]);\n    cursorX += clipboard[0].size();\n}\n\nint main() {\n    string line;\n    while (getline(cin, line)) {\n        if (line == \"END\") break;\n        text.push_back(line);\n    }\n\n    string command;\n    while (cin >> command) {\n        if (command == \"M\") {\n            int dx, dy;\n            cin >> dx >> dy;\n            moveCursor(dx, dy);\n        } else if (command == \"D\") {\n            deleteChar();\n        } else if (command == \"C\") {\n            cut();\n        } else if (command == \"P\") {\n            paste();\n        }\n    }\n\n    for (const auto &line : text) {\n        cout << line << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:57:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LINES 1000\n#define MAX_LINE_LENGTH 100\n\ntypedef struct {\n    char lines[MAX_LINES][MAX_LINE_LENGTH];\n    int num_lines;\n    int cursor_line;\n    int cursor_pos;\n    char clipboard[MAX_LINE_LENGTH];\n} Buffer;\n\nvoid initialize_buffer(Buffer *buffer) {\n    buffer->num_lines = 0;\n    buffer->cursor_line = 0;\n    buffer->cursor_pos = 0;\n    buffer->clipboard[0] = '\\0';\n}\n\nvoid insert_line(Buffer *buffer, const char *line) {\n    if (buffer->num_lines < MAX_LINES) {\n        strcpy(buffer->lines[buffer->num_lines], line);\n        buffer->num_lines++;\n    }\n}\n\nvoid move_cursor(Buffer *buffer, int line, int pos) {\n    if (line >= 0 && line < buffer->num_lines) {\n        buffer->cursor_line = line;\n        buffer->cursor_pos = pos < strlen(buffer->lines[line]) ? pos : strlen(buffer->lines[line]);\n    }\n}\n\nvoid cut_line(Buffer *buffer) {\n    strcpy(buffer->clipboard, buffer->lines[buffer->cursor_line]);\n    \n    for (int i = buffer->cursor_line; i < buffer->num_lines - 1; i++) {\n        strcpy(buffer->lines[i], buffer->lines[i + 1]);\n    }\n    buffer->num_lines--;\n    \n    if (buffer->cursor_line >= buffer->num_lines) {\n        buffer->cursor_line = buffer->num_lines - 1;\n    }\n}\n\nvoid paste(Buffer *buffer) {\n    if (buffer->clipboard[0] != '\\0') {\n        if (buffer->num_lines < MAX_LINES) {\n            for (int i = buffer->num_lines; i > buffer->cursor_line + 1; i--) {\n                strcpy(buffer->lines[i], buffer->lines[i - 1]);\n            }\n            strcpy(buffer->lines[buffer->cursor_line + 1], buffer->clipboard);\n            buffer->num_lines++;\n            buffer->cursor_line++;\n            buffer->cursor_pos = 0;\n        }\n    }\n}\n\nvoid delete_char(Buffer *buffer) {\n    if (buffer->cursor_line < buffer->num_lines) {\n        int line_length = strlen(buffer->lines[buffer->cursor_line]);\n        if (buffer->cursor_pos < line_length) {\n            for (int i = buffer->cursor_pos; i < line_length - 1; i++) {\n                buffer->lines[buffer->cursor_line][i] = buffer->lines[buffer->cursor_line][i + 1];\n            }\n            buffer->lines[buffer->cursor_line][line_length - 1] = '\\0';\n        }\n    }\n}\n\nint main() {\n    Buffer buffer;\n    initialize_buffer(&buffer);\n\n    int n;\n    scanf(\"%d\", &n);\n    getchar();  // consume newline\n\n    for (int i = 0; i < n; i++) {\n        char line[MAX_LINE_LENGTH];\n        fgets(line, sizeof(line), stdin);\n        line[strcspn(line, \"\\n\")] = 0;\n        insert_line(&buffer, line);\n    }\n\n    int m;\n    scanf(\"%d\", &m);\n    getchar();  // consume newline\n\n    for (int i = 0; i < m; i++) {\n        char command[10];\n        scanf(\"%s\", command);\n\n        if (strcmp(command, \"move\") == 0) {\n            int line, pos;\n            scanf(\"%d %d\", &line, &pos);\n            move_cursor(&buffer, line, pos);\n        } else if (strcmp(command, \"cut\") == 0) {\n            cut_line(&buffer);\n        } else if (strcmp(command, \"paste\") == 0) {\n            paste(&buffer);\n        } else if (strcmp(command, \"delete\") == 0) {\n            delete_char(&buffer);\n        }\n    }\n\n    for (int i = 0; i < buffer.num_lines; i++) {\n        printf(\"%s\\n\", buffer.lines[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:57:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nclass TextEditor {\nprivate:\n    vector<string> buffer;\n    int cursor_line;\n    int cursor_pos;\n\npublic:\n    TextEditor() : cursor_line(0), cursor_pos(0) {}\n\n    void insert(const string& text) {\n        if (buffer.empty()) {\n            buffer.push_back(\"\");\n        }\n        buffer[cursor_line].insert(cursor_pos, text);\n        cursor_pos += text.length();\n    }\n\n    void move_cursor(int line, int pos) {\n        if (line >= 0 && line < buffer.size()) {\n            cursor_line = line;\n            cursor_pos = min(pos, static_cast<int>(buffer[line].length()));\n        }\n    }\n\n    void delete_char() {\n        if (!buffer.empty() && cursor_pos < buffer[cursor_line].length()) {\n            buffer[cursor_line].erase(cursor_pos, 1);\n        }\n    }\n\n    void delete_line() {\n        if (!buffer.empty()) {\n            buffer.erase(buffer.begin() + cursor_line);\n            if (buffer.empty()) {\n                buffer.push_back(\"\");\n            }\n            cursor_line = min(cursor_line, static_cast<int>(buffer.size()) - 1);\n            cursor_pos = 0;\n        }\n    }\n\n    void cut_line() {\n        if (!buffer.empty()) {\n            buffer[cursor_line].erase(cursor_pos);\n        }\n    }\n\n    void paste(const string& text) {\n        if (!buffer.empty()) {\n            buffer[cursor_line].insert(cursor_pos, text);\n            cursor_pos += text.length();\n        }\n    }\n\n    void print() {\n        for (const auto& line : buffer) {\n            cout << line << endl;\n        }\n    }\n};\n\nint main() {\n    TextEditor editor;\n    string command;\n\n    while (getline(cin, command)) {\n        istringstream iss(command);\n        string op;\n        iss >> op;\n\n        if (op == \"I\") {\n            string text;\n            getline(iss, text);\n            editor.insert(text.substr(1));\n        } else if (op == \"MC\") {\n            int line, pos;\n            iss >> line >> pos;\n            editor.move_cursor(line, pos);\n        } else if (op == \"DC\") {\n            editor.delete_char();\n        } else if (op == \"DL\") {\n            editor.delete_line();\n        } else if (op == \"CL\") {\n            editor.cut_line();\n        } else if (op == \"P\") {\n            string text;\n            getline(iss, text);\n            editor.paste(text.substr(1));\n        } else if (op == \"PRINT\") {\n            editor.print();\n        } else if (op == \"EXIT\") {\n            break;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:57:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class EmacsEditor {\n    private List<String> text;\n    private int cursorLine;\n    private int cursorPos;\n    private String clipboard;\n\n    public EmacsEditor() {\n        text = new ArrayList<>();\n        cursorLine = 0;\n        cursorPos = 0;\n        clipboard = \"\";\n    }\n\n    public void readText(Scanner scanner) {\n        while (scanner.hasNextLine()) {\n            String line = scanner.nextLine();\n            if (line.equals(\".\")) {\n                break;\n            }\n            text.add(line);\n        }\n    }\n\n    public void executeCommand(String command) {\n        String[] parts = command.split(\" \");\n        switch (parts[0]) {\n            case \"Ctrl-d\":\n                deleteChar();\n                break;\n            case \"Ctrl-k\":\n                cutToEnd();\n                break;\n            case \"Ctrl-y\":\n                paste();\n                break;\n            case \"Ctrl-f\":\n                moveCursorForward();\n                break;\n            case \"Ctrl-b\":\n                moveCursorBackward();\n                break;\n            case \"Ctrl-p\":\n                moveCursorUp();\n                break;\n            case \"Ctrl-n\":\n                moveCursorDown();\n                break;\n            case \"Ctrl-a\":\n                moveToLineStart();\n                break;\n            case \"Ctrl-e\":\n                moveToLineEnd();\n                break;\n            case \"Ctrl-x\":\n                saveAndExit();\n                break;\n        }\n    }\n\n    private void deleteChar() {\n        if (cursorLine < text.size()) {\n            String line = text.get(cursorLine);\n            if (cursorPos < line.length()) {\n                line = line.substring(0, cursorPos) + line.substring(cursorPos + 1);\n                text.set(cursorLine, line);\n            } else if (cursorLine < text.size() - 1) {\n                String nextLine = text.get(cursorLine + 1);\n                line = line + nextLine;\n                text.set(cursorLine, line);\n                text.remove(cursorLine + 1);\n            }\n        }\n    }\n\n    private void cutToEnd() {\n        if (cursorLine < text.size()) {\n            String line = text.get(cursorLine);\n            if (cursorPos < line.length()) {\n                clipboard = line.substring(cursorPos);\n                line = line.substring(0, cursorPos);\n                text.set(cursorLine, line);\n            } else {\n                clipboard = \"\\n\";\n                if (cursorLine < text.size() - 1) {\n                    text.remove(cursorLine + 1);\n                }\n            }\n        }\n    }\n\n    private void paste() {\n        if (cursorLine < text.size()) {\n            String line = text.get(cursorLine);\n            if (clipboard.equals(\"\\n\")) {\n                String newLine = line.substring(cursorPos);\n                line = line.substring(0, cursorPos);\n                text.set(cursorLine, line);\n                text.add(cursorLine + 1, newLine);\n            } else {\n                line = line.substring(0, cursorPos) + clipboard + line.substring(cursorPos);\n                text.set(cursorLine, line);\n                cursorPos += clipboard.length();\n            }\n        }\n    }\n\n    private void moveCursorForward() {\n        if (cursorLine < text.size()) {\n            String line = text.get(cursorLine);\n            if (cursorPos < line.length()) {\n                cursorPos++;\n            } else if (cursorLine < text.size() - 1) {\n                cursorLine++;\n                cursorPos = 0;\n            }\n        }\n    }\n\n    private void moveCursorBackward() {\n        if (cursorPos > 0) {\n            cursorPos--;\n        } else if (cursorLine > 0) {\n            cursorLine--;\n            cursorPos = text.get(cursorLine).length();\n        }\n    }\n\n    private void moveCursorUp() {\n        if (cursorLine > 0) {\n            cursorLine--;\n            String line = text.get(cursorLine);\n            if (cursorPos > line.length()) {\n                cursorPos = line.length();\n            }\n        }\n    }\n\n    private void moveCursorDown() {\n        if (cursorLine < text.size() - 1) {\n            cursorLine++;\n            String line = text.get(cursorLine);\n            if (cursorPos > line.length()) {\n                cursorPos = line.length();\n            }\n        }\n    }\n\n    private void moveToLineStart() {\n        cursorPos = 0;\n    }\n\n    private void moveToLineEnd() {\n        if (cursorLine < text.size()) {\n            cursorPos = text.get(cursorLine).length();\n        }\n    }\n\n    private void saveAndExit() {\n        for (String line : text) {\n            System.out.println(line);\n        }\n        System.exit(0);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        EmacsEditor editor = new EmacsEditor();\n        editor.readText(scanner);\n\n        while (scanner.hasNextLine()) {\n            String command = scanner.nextLine();\n            editor.executeCommand(command);\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:58:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class EmacsEditor:\n    def __init__(self, text):\n        self.lines = text.split('\\n')\n        self.cursor_line = 0\n        self.cursor_col = 0\n        self.buffer = ''\n\n    def move_cursor(self, line, col):\n        if 0 <= line < len(self.lines):\n            self.cursor_line = line\n            self.cursor_col = max(0, min(col, len(self.lines[line])))\n\n    def cut(self, length):\n        if length <= 0:\n            return\n        line = self.lines[self.cursor_line]\n        end_col = min(self.cursor_col + length, len(line))\n        self.buffer = line[self.cursor_col:end_col]\n        self.lines[self.cursor_line] = line[:self.cursor_col] + line[end_col:]\n\n    def paste(self):\n        line = self.lines[self.cursor_line]\n        self.lines[self.cursor_line] = line[:self.cursor_col] + self.buffer + line[self.cursor_col:]\n        self.cursor_col += len(self.buffer)\n\n    def delete(self, length):\n        if length <= 0:\n            return\n        line = self.lines[self.cursor_line]\n        end_col = min(self.cursor_col + length, len(line))\n        self.lines[self.cursor_line] = line[:self.cursor_col] + line[end_col:]\n\n    def get_text(self):\n        return '\\n'.join(self.lines)\n\ndef main():\n    text = \"\"\"this is a test\nof the emacs editor\nsimulation\"\"\"\n    \n    editor = EmacsEditor(text)\n    editor.move_cursor(0, 5)  # move cursor to the end of \"this \"\n    editor.cut(2)  # cut \"is\"\n    editor.move_cursor(1, 0)  # move to \"of the...\"\n    editor.paste()  # paste \"is\"\n    editor.delete(3)  # delete \"the\"\n    \n    print(editor.get_text())\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 01:33:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class EmacsLikeTextEditor {\n    private List<StringBuilder> text;\n    private StringBuilder clipboard;\n    private int cursorRow;\n    private int cursorCol;\n\n    public EmacsLikeTextEditor(List<String> lines) {\n        text = new ArrayList<>();\n        for (String line : lines) {\n            text.add(new StringBuilder(line));\n        }\n        clipboard = new StringBuilder();\n        cursorRow = 0;\n        cursorCol = 0;\n    }\n\n    public void moveCursor(int row, int col) {\n        cursorRow = Math.max(0, Math.min(row, text.size() - 1));\n        cursorCol = Math.max(0, Math.min(col, text.get(cursorRow).length()));\n    }\n\n    public void cut(int length) {\n        int endIdx = Math.min(cursorCol + length, text.get(cursorRow).length());\n        clipboard.setLength(0);\n        clipboard.append(text.get(cursorRow), cursorCol, endIdx);\n        text.get(cursorRow).delete(cursorCol, endIdx);\n    }\n\n    public void paste() {\n        text.get(cursorRow).insert(cursorCol, clipboard);\n        cursorCol += clipboard.length();\n    }\n\n    public void delete(int length) {\n        int endIdx = Math.min(cursorCol + length, text.get(cursorRow).length());\n        text.get(cursorRow).delete(cursorCol, endIdx);\n    }\n\n    public void processCommands(List<String> commands) {\n        for (String command : commands) {\n            String[] parts = command.split(\" \");\n            switch (parts[0]) {\n                case \"MOVE\":\n                    moveCursor(Integer.parseInt(parts[1]), Integer.parseInt(parts[2]));\n                    break;\n                case \"CUT\":\n                    cut(Integer.parseInt(parts[1]));\n                    break;\n                case \"PASTE\":\n                    paste();\n                    break;\n                case \"DELETE\":\n                    delete(Integer.parseInt(parts[1]));\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Unknown command: \" + parts[0]);\n            }\n        }\n    }\n\n    public List<String> getText() {\n        List<String> output = new ArrayList<>();\n        for (StringBuilder sb : text) {\n            output.add(sb.toString());\n        }\n        return output;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int lineCount = Integer.parseInt(scanner.nextLine());\n        List<String> lines = new ArrayList<>();\n        for (int i = 0; i < lineCount; i++) {\n            lines.add(scanner.nextLine());\n        }\n\n        EmacsLikeTextEditor editor = new EmacsLikeTextEditor(lines);\n\n        int commandCount = Integer.parseInt(scanner.nextLine());\n        List<String> commands = new ArrayList<>();\n        for (int i = 0; i < commandCount; i++) {\n            commands.add(scanner.nextLine());\n        }\n\n        editor.processCommands(commands);\n        List<String> resultText = editor.getText();\n\n        for (String line : resultText) {\n            System.out.println(line);\n        }\n\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 01:33:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_LINES 100\n#define MAX_LEN 1000\n\ntypedef struct {\n    int line;\n    int col;\n} Cursor;\n\nchar text[MAX_LINES][MAX_LEN];\nchar buffer[MAX_LEN];\nCursor cursor = {0, 0};\nint num_lines = 0;\n\nvoid move_cursor(int line, int col) {\n    if (line >= 0 && line < num_lines) {\n        cursor.line = line;\n        int len = strlen(text[line]);\n        cursor.col = col < len ? col : len;\n    }\n}\n\nvoid cut_text(int start, int end) {\n    if (end >= start && cursor.line >= 0 && cursor.line < num_lines) {\n        int len = strlen(text[cursor.line]);\n        if (start >= 0 && end < len) {\n            strncpy(buffer, &text[cursor.line][start], end - start + 1);\n            buffer[end-start+1] = '\\0';\n            memmove(&text[cursor.line][start], &text[cursor.line][end+1], len - end);\n        }\n    }\n}\n\nvoid paste_text() {\n    int len = strlen(text[cursor.line]);\n    int buf_len = strlen(buffer);\n    if (buf_len > 0 && cursor.line >= 0 && cursor.line < num_lines) {\n        memmove(&text[cursor.line][cursor.col + buf_len], &text[cursor.line][cursor.col], len - cursor.col + 1);\n        memcpy(&text[cursor.line][cursor.col], buffer, buf_len);\n    }\n}\n\nvoid delete_text(int count) {\n    int len = strlen(text[cursor.line]);\n    if (count > 0 && cursor.line >= 0 && cursor.line < num_lines && cursor.col < len) {\n        int end = cursor.col + count < len ? cursor.col + count : len;\n        memmove(&text[cursor.line][cursor.col], &text[cursor.line][end], len - end + 1);\n    }\n}\n\nint main() {\n    char command[10];\n    int param1, param2;\n\n    printf(\"Enter number of lines: \");\n    scanf(\"%d\", &num_lines);\n    getchar(); // eat newline\n\n    printf(\"Enter the lines of text:\\n\");\n    for (int i = 0; i < num_lines; i++) {\n        fgets(text[i], MAX_LEN, stdin);\n        text[i][strcspn(text[i], \"\\n\")] = '\\0';  // remove the newline character\n    }\n\n    printf(\"Enter commands (END to quit):\\n\");\n    while (1) {\n        scanf(\"%s\", command);\n        if (strcmp(command, \"END\") == 0) {\n            break;\n        }\n\n        if (strcmp(command, \"MOVE\") == 0) {\n            scanf(\"%d %d\", &param1, &param2);\n            move_cursor(param1, param2);\n        } else if (strcmp(command, \"CUT\") == 0) {\n            scanf(\"%d %d\", &param1, &param2);\n            cut_text(param1, param2);\n        } else if (strcmp(command, \"PASTE\") == 0) {\n            paste_text();\n        } else if (strcmp(command, \"DELETE\") == 0) {\n            scanf(\"%d\", &param1);\n            delete_text(param1);\n        }\n    }\n\n    printf(\"Edited text:\\n\");\n    for (int i = 0; i < num_lines; i++) {\n        printf(\"%s\\n\", text[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 01:33:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class EmacsEditor:\n    def __init__(self):\n        self.buffer = []\n        self.cursor_line = 0\n        self.cursor_col = 0\n        self.clipboard = \"\"\n\n    def insert(self, text):\n        if not self.buffer:\n            self.buffer.append(\"\")\n        current_line = self.buffer[self.cursor_line]\n        self.buffer[self.cursor_line] = (\n            current_line[:self.cursor_col] + text + current_line[self.cursor_col:]\n        )\n        self.cursor_col += len(text)\n\n    def move_cursor(self, line, col):\n        if 0 <= line < len(self.buffer):\n            self.cursor_line = line\n            self.cursor_col = min(col, len(self.buffer[line]))\n\n    def delete_char(self):\n        if not self.buffer:\n            return\n        current_line = self.buffer[self.cursor_line]\n        if self.cursor_col < len(current_line):\n            self.buffer[self.cursor_line] = (\n                current_line[:self.cursor_col] + current_line[self.cursor_col + 1:]\n            )\n\n    def kill_line(self):\n        if not self.buffer:\n            return\n        current_line = self.buffer[self.cursor_line]\n        self.clipboard = current_line[self.cursor_col:]\n        self.buffer[self.cursor_line] = current_line[:self.cursor_col]\n\n    def yank(self):\n        if self.clipboard:\n            self.insert(self.clipboard)\n\n    def process_commands(self, commands):\n        for cmd in commands:\n            parts = cmd.split()\n            op = parts[0]\n            \n            if op == 'I':\n                self.insert(parts[1])\n            elif op == 'C':\n                line = int(parts[1])\n                col = int(parts[2])\n                self.move_cursor(line, col)\n            elif op == 'D':\n                self.delete_char()\n            elif op == 'K':\n                self.kill_line()\n            elif op == 'Y':\n                self.yank()\n        \n        return '\\n'.join(self.buffer)\n\ndef main():\n    n = int(input())\n    editor = EmacsEditor()\n    commands = []\n    for _ in range(n):\n        commands.append(input().strip())\n    \n    result = editor.process_commands(commands)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 01:33:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef main():\n    text = []\n    buffer = []\n    cursor_line = 0\n    cursor_pos = 0\n\n    # Read initial text\n    while True:\n        line = sys.stdin.readline()\n        if line.strip() == \"END\":\n            break\n        text.append(line.rstrip('\\n'))\n\n    while True:\n        cmd = sys.stdin.readline().strip()\n        if cmd == \"END\":\n            break\n\n        if cmd == \"UP\":\n            if cursor_line > 0:\n                cursor_line -= 1\n                cursor_pos = min(cursor_pos, len(text[cursor_line]))\n        elif cmd == \"DOWN\":\n            if cursor_line < len(text) - 1:\n                cursor_line += 1\n                cursor_pos = min(cursor_pos, len(text[cursor_line]))\n        elif cmd == \"LEFT\":\n            if cursor_pos > 0:\n                cursor_pos -= 1\n        elif cmd == \"RIGHT\":\n            if cursor_pos < len(text[cursor_line]):\n                cursor_pos += 1\n        elif cmd == \"DELETE\":\n            if cursor_pos < len(text[cursor_line]):\n                text[cursor_line] = text[cursor_line][:cursor_pos] + text[cursor_line][cursor_pos+1:]\n            elif cursor_line < len(text) - 1:\n                next_line = text[cursor_line + 1]\n                text[cursor_line] += next_line\n                del text[cursor_line + 1]\n        elif cmd == \"BACKSPACE\":\n            if cursor_pos > 0:\n                text[cursor_line] = text[cursor_line][:cursor_pos-1] + text[cursor_line][cursor_pos:]\n                cursor_pos -= 1\n            elif cursor_line > 0:\n                cursor_pos = len(text[cursor_line - 1])\n                text[cursor_line - 1] += text[cursor_line]\n                del text[cursor_line]\n                cursor_line -= 1\n        elif cmd.startswith(\"CUT\"):\n            parts = cmd.split()\n            if len(parts) == 3 and parts[1].isdigit() and parts[2].isdigit():\n                start_line = int(parts[1])\n                end_line = int(parts[2])\n                if 0 <= start_line <= end_line < len(text):\n                    buffer = text[start_line:end_line+1]\n                    del text[start_line:end_line+1]\n                    if start_line < len(text):\n                        cursor_line = start_line\n                    else:\n                        cursor_line = max(0, len(text) - 1)\n                    cursor_pos = 0\n        elif cmd == \"PASTE\":\n            if buffer:\n                text[cursor_line:cursor_line] = buffer.copy()\n                cursor_line += len(buffer)\n                cursor_pos = 0\n        elif cmd.startswith(\"INSERT\"):\n            insert_text = cmd[7:]\n            if cursor_pos == 0:\n                text[cursor_line] = insert_text + text[cursor_line]\n            elif cursor_pos == len(text[cursor_line]):\n                text[cursor_line] += insert_text\n            else:\n                text[cursor_line] = text[cursor_line][:cursor_pos] + insert_text + text[cursor_line][cursor_pos:]\n            cursor_pos += len(insert_text)\n\n    for line in text:\n        print(line)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 01:34:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass EmacsEditor {\npublic:\n    EmacsEditor(const vector<string>& lines)\n        : text(lines), cursorLine(0), cursorPos(0) {}\n\n    void moveCursor(int line, int pos) {\n        cursorLine = min(max(line, 0), int(text.size()) - 1);\n        cursorPos = min(max(pos, 0), int(text[cursorLine].length()));\n    }\n\n    void cut(int line, int start, int length) {\n        line = min(max(line, 0), int(text.size()) - 1);\n        if (start < 0) start = 0;\n        if (start + length > text[line].length()) length = text[line].length() - start;\n        buffer = text[line].substr(start, length);\n        text[line].erase(start, length);\n    }\n\n    void paste(int line, int pos) {\n        line = min(max(line, 0), int(text.size()) - 1);\n        pos = min(max(pos, 0), int(text[line].length()));\n        text[line].insert(pos, buffer);\n    }\n\n    void deleteChars(int line, int pos, int length) {\n        line = min(max(line, 0), int(text.size()) - 1);\n        pos = min(max(pos, 0), int(text[line].length()));\n        if (pos + length > text[line].length()) length = text[line].length() - pos;\n        text[line].erase(pos, length);\n    }\n\n    void printText() const {\n        for (const string& line : text) {\n            cout << line << endl;\n        }\n    }\n\nprivate:\n    vector<string> text;\n    string buffer;\n    int cursorLine, cursorPos;\n};\n\nint main() {\n    vector<string> lines = {\n        \"This is the first line.\",\n        \"This is the second line.\",\n        \"This is the third line.\"\n    };\n\n    EmacsEditor editor(lines);\n\n    // Sample commands\n    editor.moveCursor(1, 5);\n    editor.cut(1, 5, 5);\n    editor.paste(0, 0);\n    editor.deleteChars(2, 0, 6);\n\n    editor.printText();\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:00:54"
  }
]