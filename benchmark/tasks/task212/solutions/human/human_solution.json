[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\n#define all(c) ((c).begin()),((c).end())\n#define debug(c) cerr<<\"> \"<<#c<<\" = \"<<(c)<<endl;\n#define iter(c) __typeof((c).begin())\n#define tr(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,a,b) for(int i=(int)(a);i<=(int)(b);i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\n#define EPS 1.0e-6\n\n//ツ点\ntypedef complex<double> P;\n\nstruct C{\n\tP p;\n\tdouble r;\n};\n\nvector<P> isCC(const C &c1, const C &c2) {\n\tdouble d = abs(c1.p - c2.p);\n\tif (c1.r + c2.r - d < -EPS || fabs(c1.r - c2.r) - d > EPS) return vector<P>();\n\tdouble x = (d*d + c1.r * c1.r - c2.r * c2.r) / 2 / d;\n\tdouble y = sqrt(c1.r * c1.r - x * x);\n\tP diff = (c2.p - c1.p) / d;\n\tvector<P> res;\n\tres.pb(c1.p + diff * P(x, y));\n\tif (y != 0) res.pb(c1.p + diff * P(x, -y));\n\treturn res;\n}\n\n\nint main() {\n\tfor (int N; cin >> N, N != 0; ) {\n\t\tvector<P> ps;\n\t\trep (i, N) {\n\t\t\tdouble x, y; cin >> x >> y;\n\t\t\tps.pb(P(x, y));\n\t\t}\n\t\tint res = 0;\n\t\trep (i, N) REP (j, i + 1, N-1) {\n\t\t\tvector<P> isp = isCC((C){ps[i],1},(C){ps[j],1});\n\t\t\trep (k, isp.size()) {\n\t\t\t\tint cnt = 0;\n\t\t\t\trep (l, N) if (abs(isp[k] - ps[l]) <= 1 + EPS) cnt++;\n\t\t\t\tres = max(res, cnt);\n\t\t\t}\n\t\t}\n\t\tif (res == 0) res++;\n\t\tcout << res <<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n// ??\\??? ????????¨???\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;}\ntemplate<class T> bool operator< (T a, T b){return a < b-eps;}\ntemplate<class T> bool operator<=(T a, T b){return a < b+eps;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n#define X real()\n#define Y imag()\n\ntypedef bool B;\ntypedef long double D;\ntypedef complex<D> P;\n\nP p[310];\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tD ix,iy;\n\t\trep(i,n){\n\t\t\tcin >> ix >> iy;\n\t\t\tp[i].real(ix),p[i].imag(iy);\n\t\t}\n\t\tint ans=1;\n\t\trep(i,n)rep(j,n){\n\t\t\tif(i==j) continue;\n\t\t\tD d=norm(p[j]-p[i]);\n\t\t\tif(d>4.0) continue;\n\t\t\tP v=(p[j]-p[i])/P(2.0,0.0);\n\t\t\tD s=sqrt((1.0-norm(v))/norm(v));\n\t\t\tP cnt1=p[i]+v+s*P(v.imag(),-v.real());\n\t\t\tint num=2;\n\t\t\trep(k,n){\n\t\t\t\tif(k==i||k==j) continue;\n\t\t\t\tif(norm(p[k]-cnt1)<1.0) num++;\n\t\t\t}\n\t\t\tans=max(ans,num);\n\t\t\tP cnt2=p[i]+v+s*P(-v.imag(),v.real());\n\t\t\tint num2=2;\n\t\t\trep(k,n){\n\t\t\t\tif(k==i||k==j) continue;\n\t\t\t\tif(norm(p[k]-cnt2)<1.0) num2++;\n\t\t\t}\n\t\t\tans=max(ans,num2);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n \n \nint main() {\n\tint point_num, ans;\n\tfloat point[300][2];   \n\tfor(;;){\n\t\tscanf(\"%d\\n\", &point_num);\n\t\tif(point_num == 0)\n\t\t\tbreak;\n\t\tint i;\n\t\tfloat x, y;\n\t\tfor (i = 0; i < point_num; i++)\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\tans = 0;\n\t\t\n\t\tfor (x = 1; x < 10; x += 0.001) {\n\t\t\tfor (y = 1; y < 10; y += 0.001) {\n\t\t\t\tint count = 0;\n\t\t\t\tfor (i = 0; i < point_num; i++) {\n\t\t\t\t\tif (1.0 >=  (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1]))\n\t\t\t\t\t\tcount++;\n\t\t\t\tif (count > ans)\n\t\t\t\t\tans = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define endl \"\\n\"\n#define rep(i, a, b) for (auto i = (a); i < (b); ++i)\n#define rrep(i, a, b) for (auto i = (a); i > (b); --i)\n#define UNIQUE(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\n\n#ifdef LOCAL_DEFINE\nstruct InitInput\n{\n  InitInput()\n  {\n    FILE *stream1;\n    stream1 = freopen(\"in.txt\", \"r\", stdin);\n    assert(stream1 != nullptr);\n    cerr << \"This problem is not interactive\" << endl;\n  }\n} LOCAL_INPUT;\nstruct LOCAL_OUTPUT\n{\n  LOCAL_OUTPUT()\n  {\n    FILE *stream2;\n    const char *outputfile = \"out.txt\";\n    stream2 = freopen(outputfile, \"w\", stdout);\n    assert(stream2 != nullptr);\n    cerr << \"output [ \" << outputfile << \" ]\" << endl;\n  }\n} /*LOCAL_OUTPUT*/;\n#define show(x) cerr << #x << \" = \" << (x) << \" (line \" << __LINE__ << \")\" << endl\n#define showA(a, n)                                            \\\n  do                                                           \\\n  {                                                            \\\n    for (int _i_t_e_ = 0; _i_t_e_ < (n); _i_t_e_++)            \\\n      cerr << \"(\" << _i_t_e_ << \" = \" << (a)[_i_t_e_] << \") \"; \\\n    cerr << endl;                                              \\\n  } while (0)\n#define showA2(a, n, m)                                                                        \\\n  do                                                                                           \\\n  {                                                                                            \\\n    for (int _i_t_e_ = 0; _i_t_e_ < (n); _i_t_e_++)                                            \\\n    {                                                                                          \\\n      for (int _i_t_e_2 = 0; _i_t_e_2 < (m); _i_t_e_2++)                                       \\\n      {                                                                                        \\\n        cerr << \"(\" << _i_t_e_ << \", \" << _i_t_e_2 << \" = \" << (a)[_i_t_e_][_i_t_e_2] << \") \"; \\\n      }                                                                                        \\\n      cerr << endl;                                                                            \\\n    }                                                                                          \\\n    cerr << endl;                                                                              \\\n  } while (0)\n#else\n#define show(x)\n#define showA(a, n)\n#define showA2(a, n, m)\n#endif\n\nstruct InitAim\n{\n  InitAim()\n  {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(12);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    cerr << \"This problem is not interactive\" << endl;\n#endif\n  }\n} aim_cpo;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconstexpr const int INT_INF = 0x3f3f3f3f;       //1061109567\nconstexpr const ll LL_INF = 0x3f3f3f3f3f3f3f3f; //4557430888798830399\n\ntemplate <typename T>\nbool chmin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate <typename T>\nbool chmax(T &a, T b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T>\nvoid ln(T i, T n) { cout << (i == n - 1 ? \"\\n\" : \" \"); }\ntemplate <typename T, typename S>\nostream &operator<<(ostream &out, const pair<T, S> &pair1)\n{\n  out << '(' << pair1.fi << \", \" << pair1.se << ')';\n  return out;\n}\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &vector1)\n{\n  out << '[';\n  for (unsigned int i = 0; i < vector1.size(); i++)\n  {\n    out << vector1[i];\n    if (i == vector1.size() - 1)\n      out << \"]\";\n    else\n      out << \", \";\n  }\n  return out;\n}\n\n// INT\n#define GCD(a, b) __gcd(a, b)\ntemplate <typename T>\nT LCM(T a, T b)\n{\n  return a / GCD(a, b) * b;\n}\ntemplate <typename T>\nT EXTGCD(T a, T b, T &x, T &y)\n{\n  T d = a;\n  if (b != 0)\n  {\n    d = EXTGCD(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n  else\n    x = 1, y = 0;\n  return d;\n}\ntemplate <typename T>\nbool is_prime(T a)\n{\n  for (int i = 2; i * i <= a; i++)\n    if (a % i == 0)\n      return true;\n  return false;\n}\ntemplate <typename T, typename S>\nT Pow(T a, S b)\n{\n  T res = 1, now = a;\n  while (b)\n  {\n    if (b & 1)\n      res *= now;\n    b >>= 1;\n    now *= now;\n  }\n  return res;\n}\n\n// MOD\nll MOD = 1000000000L + 7L;\n#define Madd(a, b) (((a) % MOD) + ((b) % MOD)) % MOD\n#define Mmul(a, b) (((a) % MOD) * ((b) % MOD)) % MOD\n#define Msub(a, b) (((a) % MOD) + MOD - ((b) % MOD)) % MOD\ntemplate <typename T, typename S>\nT ModPow(T a, S b)\n{\n  assert(b >= 0);\n  T res = 1, now = Msub(a, 0);\n  while (b)\n  {\n    if (b & 1)\n      res = Mmul(res, now);\n    b >>= 1;\n    now = Mmul(now, now);\n  }\n  return res;\n}\ntemplate <typename T>\nT ModInverse(T a, T mod, bool prime)\n{ // if mod is prime, \"prime\" is true.\n  if (prime)\n    return ModPow(a, mod - 2);\n  else\n  {\n    T x, y;\n    EXTGCD(a, mod, x, y);\n    return (mod + x % mod) % mod;\n  }\n}\ntemplate <typename T>\nT EulerTotient(T a)\n{\n  vector<pair<int, int>> v;\n  for (T i = 2; i * i <= a; i++)\n  {\n    int cnt = 0;\n    while (a % i == 0)\n    {\n      cnt++;\n      a /= i;\n    }\n    if (cnt != 0)\n      v.emplace_back(i, cnt);\n  }\n  if (a != 1)\n    v.emplace_back(a, 1);\n  //showV(v, (int) v.size());\n  T res = 1;\n  for (int i = 0; i < (int)v.size(); i++)\n  {\n    if (v[i].se == 1)\n    {\n      //res *= v[i].fi - 1;\n      res = Mmul(res, v[i].fi - 1);\n    }\n    else\n    {\n      //res *= Pow(v[i].fi, v[i].se) - Pow(v[i].fi, v[i].se - 1);\n      res = Mmul(res, Msub(ModPow(v[i].fi, v[i].se), ModPow(v[i].fi, v[i].se - 1)));\n    }\n  }\n  return res;\n}\n#define Mdivide(a, b) Mmul(((a) % MOD), (ModInverse((b), MOD, true))) % MOD\nll comb(ll a, ll b)\n{\n  chmin(b, a - b);\n  ll res = 1LL, now = a;\n  for (ll i = 1; i <= b; i++)\n  {\n    res = Mmul(res, now);  //res *= now;\n    res = Mdivide(res, i); // res /= i;\n    now--;\n  }\n  return res;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// TEMPLATE(data structure)\n///////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename T>\nclass BIT\n{\npublic:\n  BIT(int size)\n  {\n    BITTable.assign(++size, 0);\n  }\n  T sum(int k)\n  {\n    T res = 0;\n    for (++k; k > 0; k -= k & -k)\n    {\n      res += BITTable[k];\n    }\n    return res;\n  }\n  T sum(int l, int r)\n  {\n    if (l == 0)\n      return sum(r);\n    return sum(r) - sum(l - 1);\n  }\n  void update(int k, T x)\n  { // b[k] += x;\n    for (++k; k < (int)BITTable.size(); k += k & -k)\n      BITTable[k] += x;\n  }\n\nprivate:\n  vector<T> BITTable;\n};\n\ntemplate <typename T>\nclass IntervalTree\n{\n  using F = function<T(T, T)>;\n\npublic:\n  IntervalTree(int n, const F func, const T init) : func(func), init(init)\n  {\n    size = 1;\n    while ((int)size < n)\n      size <<= 1;\n    table.assign(2 * size, init);\n  }\n  void set(int k, T &x)\n  {\n    table[size + k] = x;\n  }\n  void build()\n  {\n    for (int i = size - 1; i >= 0; --i)\n    {\n      table[i] = func(table[i * 2], table[i * 2 + 1]);\n    }\n  }\n  void update(int k, const T &x)\n  {\n    k += size;\n    table[k] = x;\n    while (k >>= 1)\n    {\n      table[k] = func(table[k * 2], table[k * 2 + 1]);\n    }\n  }\n  T query(int a, int b)\n  {\n    T L = init, R = init;\n    for (a += size, b += size; a < b; a >>= 1, b >>= 1)\n    {\n      if (a & 1)\n        L = func(L, table[a++]);\n      if (b & 1)\n        R = func(table[--b], R);\n    }\n    return func(L, R);\n  }\n  T operator[](const int k) const\n  {\n    return table[k + size];\n  }\n\nprivate:\n  unsigned int size;\n  vector<T> table;\n  const F func;\n  const T init;\n};\n\nclass UnionFind\n{\npublic:\n  explicit UnionFind(int _n) : n(_n)\n  {\n    par.resize(static_cast<unsigned long>(_n));\n    rank.resize(static_cast<unsigned long>(_n));\n    sizes.resize(static_cast<unsigned long>(_n));\n    for (int i = 0; i < _n; i++)\n    {\n      par[i] = i;\n      rank[i] = 0;\n      sizes[i] = 1;\n    }\n  }\n  int find(int a)\n  {\n    if (par[a] == a)\n      return a;\n    return par[a] = find(par[a]);\n  }\n  bool same(int a, int b)\n  {\n    return find(a) == find(b);\n  }\n  void unite(int a, int b)\n  {\n    link(find(a), find(b));\n  }\n  int size(int a)\n  {\n    return sizes[find(a)];\n  }\n  void view()\n  {\n    for (int i = 0; i < n; i++)\n    {\n      cout << \" par\"\n           << \"[\" << i << \"]=\" << par[i] << ((i == n - 1) ? \"\\n\" : \",\");\n    }\n    for (int i = 0; i < n; i++)\n    {\n      cout << \"size\"\n           << \"[\" << i << \"]=\" << sizes[i] << ((i == n - 1) ? \"\\n\" : \",\");\n    }\n    cout << endl;\n  }\n\nprivate:\n  void link(int a, int b)\n  {\n    if (same(a, b))\n      return;\n    if (rank[a] > rank[b])\n    {\n      par[b] = a;\n      sizes[a] += sizes[b];\n      sizes[b] = 0;\n    }\n    else\n    {\n      par[a] = b;\n      if (rank[a] == rank[b])\n        rank[b]++;\n      sizes[b] += sizes[a];\n      sizes[a] = 0;\n    }\n  }\n  int n;\n  vector<int> par;\n  vector<int> rank;\n  vector<int> sizes;\n};\n\nnamespace geo\n{\n#define IL inline\ntypedef double D;\ntypedef bool B;\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\ntemplate <typename T, typename S>\nostream &operator<<(ostream &out, const P &point1)\n{\n  out << '(' << point1.X << \", \" << point1.Y << ')';\n  return out;\n}\nB comp(const P &l, const P &r)\n{\n  return (l.X == r.X) ? l.Y < r.Y : l.X < r.X;\n}\ntypedef pair<P, P> L;  //line\ntypedef pair<P, P> LS; //line segment\ntypedef pair<P, D> C;  //circle\ntypedef vector<P> Poly;\nconst D EPS = 1e-10;\n//Decompotision Macro\n#define DCl(a, b, l) \\\n  P a, b;            \\\n  tie(a, b) = l\n#define DCc(a, b, c) \\\n  P a;               \\\n  D b;               \\\n  tie(a, b) = c\n\n//A dot B\nIL D dot(P a, P b) { return a.X * b.X + a.Y * b.Y; }\n//A cross B\nIL D cross(P a, P b) { return a.X * b.Y - a.Y * b.X; }\nIL D ccw(P a, P b, P c)\n{\n  return cross(b - a, c - a);\n}\n\nIL int sgn(P a, P b, P c)\n{\n  if (cross(b - a, c - a) > EPS)\n    return 1;\n  if (cross(b - a, c - a) < -EPS)\n    return -1;\n  if (dot(b - a, c - a) < -EPS)\n    return 2; // b-a-c\n  if (dot(a - b, c - b) < -EPS)\n    return -2; // a-b-c\n  return 0;\n}\nIL D signed_distance_P_L(P p, L l)\n{\n  DCl(a, b, l);\n  return ccw(a, b, p) / abs(b - a);\n}\n\nIL D distance_P_L(P p, L l)\n{\n  return abs(signed_distance_P_L(p, l));\n}\n\nIL D distance_P_P(P p1, P p2)\n{\n  return abs(p1 - p2);\n}\n\nIL D distance_P_LS(P p, LS ls)\n{\n  DCl(a, b, ls);\n  if (dot(b - a, p - a) < EPS)\n    return abs(p - a);\n  if (dot(a - b, p - b) < EPS)\n    return abs(p - b);\n  return abs(cross(b - a, p - a)) / abs(b - a);\n}\n\nIL B is_L_L(L p, L q)\n{\n  DCl(a, b, p);\n  DCl(c, d, q);\n  return abs(cross(a - b, c - d)) > EPS ||\n         abs(cross(a - b, d - b)) < EPS;\n}\nIL B is_L_LS(L l, LS ls)\n{\n  DCl(a, b, l);\n  DCl(c, d, ls);\n  return ccw(a, b, c) * ccw(a, b, d) < EPS;\n}\nIL B is_LS_LS(LS p, LS q)\n{\n  DCl(a, b, p);\n  DCl(c, d, q);\n  return sgn(a, b, c) * sgn(a, b, d) <= 0 && sgn(c, d, a) * sgn(c, d, b) <= 0;\n}\n\nIL D distance_LS_LS(LS p, LS q)\n{\n  if (is_LS_LS(p, q))\n    return 0;\n  return min({distance_P_LS(p.fi, q),\n              distance_P_LS(p.se, q),\n              distance_P_LS(q.fi, p),\n              distance_P_LS(q.se, p)});\n}\n\n//caution: have to use isintersected_L_L before this function\nIL P cross_L_L(L p, L q)\n{\n  DCl(a, b, p);\n  D d1 = signed_distance_P_L(a, q);\n  D d2 = signed_distance_P_L(b, q);\n  return (a * d2 - b * d1) / (d2 - d1);\n}\n\nIL B is_C_C(C p, C q)\n{\n  DCc(cp, rp, p);\n  DCc(cq, rq, q);\n  D d = abs(cp - cq);\n  return abs(rp - rq) - d < EPS &&\n         rp + rq - d > -EPS;\n}\nIL LS cross_C_C(C p, C q)\n{\n  DCc(cp, rp, p);\n  DCc(cq, rq, q);\n  D d = abs(cp - cq);\n  D rc = (d * d + rp * rp - rq * rq) / (2 * d);\n  D rs = sqrt(rp * rp - rc * rc);\n  P diff = (cq - cp) / d;\n  return {cp + P(rc, rs) * diff, cp + P(rc, -rs) * diff};\n}\nIL Poly convex_hull(Poly p)\n{\n  int n = p.size();\n  Poly res(2 * n);\n  int k = 0, t;\n  sort(all(p), comp);\n  rep(i, 0, n)\n  {\n    while (k > 1 && ccw(res[k - 2], res[k - 1], p[i]) < EPS)\n      k--;\n    res[k++] = p[i];\n  }\n  t = k;\n  rep(j, 0, n - 1)\n  {\n    int i = n - 2 - j;\n    while (k > t && ccw(res[k - 2], res[k - 1], p[i]) < EPS)\n      k--;\n    res[k++] = p[i];\n  }\n  res.resize(k - 1);\n  return res;\n}\nIL B convex_in(Poly &l, P &p)\n{\n  int a = 0, b = l.size(), c;\n  D A, C;\n  P g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n  while (b - a > 1)\n  {\n    c = (a + b) / 2;\n    A = cross(l[a] - g, p - l[a]);\n    C = cross(l[c] - g, p - l[c]);\n    if (cross(l[a] - g, l[c] - g) >= 0)\n    {\n      if (A > -EPS && C < -EPS)\n        b = c;\n      else\n        a = c;\n    }\n    else\n    {\n      if (C < -EPS || A > -EPS)\n        b = c;\n      else\n        a = c;\n    }\n  }\n  return (cross(l[b % l.size()] - l[a], p - l[b % l.size()]) > -EPS);\n}\n\n//not necessary?\nIL D convex_area(Poly &l)\n{\n  double res = 0;\n  int n = l.size();\n  rep(i, 2, n)\n      res += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n  return res;\n}\nIL D area(Poly &l)\n{\n  double res = 0;\n  int n = l.size();\n  rep(i, 0, n)\n      res += cross(l[i], l[(i + 1) % n]);\n  return abs(res) / 2.0;\n}\ninline vector<L> tangent_line(C c, P p)\n{\n  vector<L> res;\n  DCc(cp, r, c);\n  P v = p - cp;\n  D dist = abs(v);\n  if (dist - r > -EPS)\n  {\n    double _cos = r / dist;\n    double _sin = sqrt(1.0 - _cos * _cos);\n    v = v * (r / dist);\n    {\n      P e = P(_cos * v.X - _sin * v.Y, _sin * v.X + _cos * v.Y);\n      res.push_back({p, cp + e});\n    }\n    if (dist - r > EPS)\n    {\n      P e = P(_cos * v.X + _sin * v.Y, -_sin * v.X + _cos * v.Y);\n      res.push_back({p, cp + e});\n    }\n  }\n  return res;\n}\nIL vector<L> inner_common_tangent_line(C p, C q)\n{\n  vector<L> res;\n  DCc(Mp, Rp, p);\n  DCc(Mq, Rq, q);\n  D dist = abs(Mp - Mq);\n  if (dist - (Rp + Rq) > -EPS)\n  {\n    P mid = (Mq * Rp + Mp * Rq) / (Rp + Rq);\n    res = tangent_line(p, mid);\n  }\n  return res;\n}\ninline vector<L> outer_common_tangent_line(C p, C q)\n{\n  vector<L> res;\n  DCc(Mp, Rp, p);\n  DCc(Mq, Rq, q);\n  P v = Mp - Mq;\n  D dist = abs(v);\n  if (dist - abs(Rp - Rq) > -EPS)\n  {\n    if (abs(Rp - Rq) < EPS)\n    {\n      P e = v * P(0, 1);\n      e = e / dist;\n      res.pb(L(Mp + e, Mq + e));\n      res.pb(L(Mp - e, Mq - e));\n    }\n    else\n    {\n      P mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n      res = tangent_line(p, mid);\n    }\n  }\n  return res;\n}\n\nvector<Poly> decomposition(Poly p)\n{\n  int n = p.size();\n  vector<Poly> res;\n  while (n >= 3)\n  {\n    [&]() {\n      rep(i, 0, n)\n      {\n        P a = p[i];\n        P b = p[(i + 1) % n];\n        P c = p[(i + 2) % n];\n        if (ccw(a, b, c) < 0)\n          continue;\n        if ([&]() {\n              rep(j, 3, n)\n              {\n                P d = p[(i + j) % n];\n                if (ccw(a, b, d) > -EPS && ccw(b, c, d) > -EPS && ccw(c, a, d) > -EPS)\n                  return true;\n              }\n              return false;\n            }())\n          continue;\n        Poly nxt;\n        rep(j, 0, n) if ((i + j) % n != (i + 1) % n)\n            nxt.push_back(p[(i + j) % n]);\n        swap(p, nxt);\n        res.push_back({a, b, c});\n        n--;\n        return;\n      }\n    }();\n  }\n  return res;\n}\nint in_triangle(P p, Poly q)\n{\n  rep(i, 0, 3) if (abs(p - q[i]) < EPS) return 3; //on point\n  rep(i, 0, 3)\n  {\n    int s = sgn(q[i], q[(i + 1) % 3], p);\n    if (s != 1)\n    {\n      if (s == 0)\n        return 2; //on line\n      else\n        return 0; // not in\n    }\n  }\n  return 1; // inside triangle\n}\nint in_C(P q, C c)\n{\n  DCc(p, r, c);\n  if (abs(r - abs(p - q)) < EPS)\n    return 2; //on\n  return r - abs(p - q) > -EPS ? 1 : 0;\n}\nint is_triangle_C(Poly t, C c)\n{\n  t = convex_hull(t);\n  DCc(p, r, c);\n  int cnt = 0;\n  rep(i, 0, 3)\n      cnt += (in_C(t[i], c) > 0);\n  if (cnt == 3)\n    return 3; // t in c\n  if (cnt == 0)\n  {\n    double d = distance_P_LS(p, LS(t[2], t[0]));\n    rep(i, 0, 2)\n        d = min(d, distance_P_LS(p, LS(t[i], t[i + 1])));\n    if (r - d > EPS)\n      return 1; //intersect\n    if (in_triangle(p, t))\n      return 2; //c in t\n    else if (r - d < -EPS)\n      return 0; //not intersect\n  }\n  return 1; //intersect\n}\n\n//p must be convex and ccw\nLS diameter(Poly &p)\n{\n  int n = p.size();\n  int is = 0, js = 0;\n  rep(i, 0, n) if (p[i].Y > p[is].Y)\n      is = i;\n  rep(i, 0, n) if (p[i].Y < p[js].Y)\n      js = i;\n  LS res = {p[is], p[js]};\n  {\n    int i = is;\n    int j = js;\n    do\n    {\n      int ni = (i + 1) % n;\n      int nj = (j + 1) % n;\n      if (cross(p[ni] - p[i], p[nj] - p[j]) < EPS)\n        i = ni;\n      else\n        j = nj;\n      if (abs(res.fi - res.se) < abs(p[i] - p[j]))\n        res = LS(p[i], p[j]);\n    } while (i != is || j != js);\n  }\n  return res;\n}\n\nPoly cross_C_L(C c, L v)\n{\n  DCc(p, r, c);\n  DCl(a, b, v);\n  a -= p;\n  b -= p;\n  P u = a - b;\n  u = P(-u.Y, u.X);\n  P x = cross_L_L({a, b}, {P(0, 0), u});\n  D d = abs(x);\n  Poly res;\n  if (d - r > EPS)\n    return res;\n  D y = sqrt(r * r - d * d);\n  res.pb(p + x + (b - a) * y / abs(b - a));\n  //if(d-r>-EPS)return res;\n  res.pb(p + x + (a - b) * y / abs(b - a));\n  return res;\n}\n\npair<C, C> GetC_p_p_r(P p1, P p2, double r) // 二点と半径から２つの円を求めるコード\n{\n  double d = distance_P_P(p1, p2);\n  assert(d <= 2. * r); // 二点間の距離は2 * r以内じゃないと同じ円周上に存在することはできない.\n  P mid = (p1 + p2) / 2.;\n  P NormalVector = (p1 - p2) / d * sqrt(r * r - d * d / 4.);\n  NormalVector = P(NormalVector.Y, -NormalVector.X);\n  P center1 = mid + NormalVector;\n  P center2 = mid - NormalVector;\n  return mp(C(center1, r), C(center2, r));\n}\n} // namespace geo\n\n///////////////////////////////////////////////////////////////////////////////////\n// MAIN\n///////////////////////////////////////////////////////////////////////////////////\n// 735134400 約数が1344個ある高度合成数(<= 1e9)\n// 897612484786617600 約数が103680個ある高度合成数(<= 1e18)\n// 苦手分野 重複順列\n// LLの数値をつかう時は最後にLLをつける癖をつけよう\n\nvoid solve(int &n)\n{\n  using namespace geo;\n  vector<P> v(n);\n  rep(i, 0, n)\n  {\n    double x, y;\n    cin >> x >> y;\n    v[i] = (P(x, y));\n  }\n  //show(v);\n  int ans = 1;\n  rep(i, 0, n)\n  {\n    rep(j, i + 1, n)\n    {\n      double d = distance_P_P(v[i], v[j]);\n      if (d > 2.0)\n        continue;\n      pair<C, C> Cs = GetC_p_p_r(v[i], v[j], 1);\n      int cnt = 0;\n      for (int k = 0; k < n; k++)\n      {\n        if (in_C(v[k], Cs.fi))\n          cnt++;\n      }\n      chmax(ans, cnt);\n      cnt = 0;\n      // center = mid - GetC;\n      // C c2(center, 1.);\n      for (int k = 0; k < n; k++)\n      {\n        if (in_C(v[k], Cs.se))\n          cnt++;\n      }\n      chmax(ans, cnt);\n    }\n  }\n  cout << ans << endl;\n}\n\nint n;\n\nint main()\n{\n  while (cin >> n, n)\n  {\n    solve(n);\n  }\n#ifdef LOCAL_DEFINE\n  cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \"s.\" << endl;\n  show(MOD);\n#endif\n  return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// NOTE\n///////////////////////////////////////////////////////////////////////////////////\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <cmath>\n#define EPS 1.0e-10\nusing namespace std;\n\n#define X real()\n#define Y imag()\ntypedef complex<double> P;\n \nvector<P> p;\nint check(P a){\n\tint ret=0;\n\tfor(int i=0;i<p.size();i++) if(abs(a-p[i]) < 1+EPS) ret ++;\n\treturn ret;\n}\n\nint adjcircle(P a, P b){\n\tP dir = a-b, pos=(a+b)*0.5;\n\tdir = P(dir.Y, -dir.X);\n\tdir = dir*(1/abs(dir))*sqrt(1-abs(pos-a)*abs(pos-a));\n\treturn max(check(pos+dir), check(pos-dir));\n}\n\nmain(){\n\tint i,j,N;\n\twhile(cin >> N, N){\n\t\tp = vector<P>(N);\n\t\tint ans = 0;\n\t\tfor(i=0;i<N;i++) cin >> p[i].X >> p[i].Y;\n\t\tfor(i=1;i<N;i++)\n\t\t\tfor(j=0;j<i;j++)\n\t\t\t\tif(abs(p[i]-p[j])<=2.0) ans = max(ans, adjcircle(p[i], p[j]));\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nusing Real = double;\nusing Point = complex< Real >;\n\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point &p, const Real &d) {\n  return Point(real(p) * d, imag(p) * d);\n}\n\nistream &operator>>(istream &is, Point &p) {\n  Real a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nPoint rotate(Real theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\nReal radian_to_degree(Real r) {\n  return (r * 180.0 / PI);\n}\n\nReal degree_to_radian(Real d) {\n  return (d * PI / 180.0);\n}\n\nReal get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  Real theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\n\n\nstruct Line {\n  Point a, b;\n\n  Line() = default;\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(Real A, Real B, Real C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line {\n  Segment() = default;\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  Real r;\n\n  Circle() = default;\n\n  Circle(Point p, Real r) : p(p), r(r) {}\n};\n\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\nReal cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\nReal dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool parallel(const Line &a, const Line &b) {\n  return eq(cross(a.b - a.a, b.b - b.a), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool orthogonal(const Line &a, const Line &b) {\n  return eq(dot(a.a - a.b, b.a - b.b), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\n\nbool intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nReal distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\nint intersect(Circle c1, Circle c2) {\n  if(c1.r < c2.r) swap(c1, c2);\n  Real d = abs(c1.p - c2.p);\n  if(c1.r + c2.r < d) return 4;\n  if(eq(c1.r + c2.r, d)) return 3;\n  if(c1.r - c2.r < d) return 2;\n  if(eq(c1.r - c2.r, d)) return 1;\n  return 0;\n}\n\nReal distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\nReal distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\nReal distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\nReal distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\nReal distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\nReal distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  Real A = cross(l.b - l.a, m.b - m.a);\n  Real B = cross(l.b - l.a, l.b - m.a);\n  if(eq(abs(A), 0.0) && eq(abs(B), 0.0)) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Segment &l, const Segment &m) {\n  return crosspoint(Line(l), Line(m));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point pr = projection(l, c.p);\n  Point e = (l.b - l.a) / abs(l.b - l.a);\n  if(eq(distance(l, c.p), c.r)) return {pr, pr};\n  double base = sqrt(c.r * c.r - norm(pr - c.p));\n  return {pr - e * base, pr + e * base};\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  Real d = abs(c1.p - c2.p);\n  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F\npair< Point, Point > tangent(const Circle &c1, const Point &p2) {\n  return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G\nLines tangent(Circle c1, Circle c2) {\n  Lines ret;\n  if(c1.r < c2.r) swap(c1, c2);\n  Real g = norm(c1.p - c2.p);\n  if(eq(g, 0)) return ret;\n  Point u = (c2.p - c1.p) / sqrt(g);\n  Point v = rotate(PI * 0.5, u);\n  for(int s : {-1, 1}) {\n    Real h = (c1.r + s * c2.r) / sqrt(g);\n    if(eq(1 - h * h, 0)) {\n      ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);\n    } else if(1 - h * h > 0) {\n      Point uu = u * h, vv = v * sqrt(1 - h * h);\n      ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);\n      ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);\n    }\n  }\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\nenum {\n  OUT, ON, IN\n};\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvoid merge_segments(vector< Segment > &segs) {\n\n  auto merge_if_able = [](Segment &s1, const Segment &s2) {\n    if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n    if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n    if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n    s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n    return true;\n  };\n\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C\nPolygon convex_cut(const Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A\nReal area2(const Polygon &p) {\n  Real A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_H\nReal area2(const Polygon &p, const Circle &c) {\n  if(p.size() < 3) return 0.0;\n  function< Real(Circle, Point, Point) > cross_area = [&](const Circle &c, const Point &a, const Point &b) {\n    Point va = c.p - a, vb = c.p - b;\n    Real f = cross(va, vb), ret = 0.0;\n    if(eq(f, 0.0)) return ret;\n    if(max(abs(va), abs(vb)) < c.r + EPS) return f;\n    if(distance(Segment(a, b), c.p) > c.r - EPS) return c.r * c.r * arg(vb * conj(va));\n    auto u = crosspoint(c, Segment(a, b));\n    vector< Point > tot{a, u.first, u.second, b};\n    for(int i = 0; i + 1 < tot.size(); i++) {\n      ret += cross_area(c, tot[i], tot[i + 1]);\n    }\n    return ret;\n  };\n  Real A = 0;\n  for(int i = 0; i < p.size(); i++) {\n    A += cross_area(c, p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B\nReal convex_diameter(const Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  Real maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\nReal closest_pair(Points ps) {\n  if(ps.size() <= 1) throw (0);\n  sort(begin(ps), end(ps));\n\n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n  vector< Point > beet(ps.size());\n\n  function< Real(int, int) > rec = [&](int left, int right) {\n    if(right - left <= 1) return INF;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    int ptr = 0;\n    for(int i = left; i < right; i++) {\n      if(abs(real(ps[i]) - x) >= ret) continue;\n      for(int j = 0; j < ptr; j++) {\n        auto luz = ps[i] - beet[ptr - j - 1];\n        if(imag(luz) >= ret) break;\n        ret = min(ret, abs(luz));\n      }\n      beet[ptr++] = ps[i];\n    }\n    return ret;\n  };\n  return rec(0, (int) ps.size());\n}\n\nint N;\ndouble x[305], y[305];\nPoint points[305];\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        cin >> N;\n        if(N == 0) break;\n        for(int i = 1; i <= N; i++) cin >> x[i] >> y[i];\n        for(int i = 1; i <= N; i++) points[i] = Point(x[i], y[i]);\n        int ans = 1;\n        for(int i = 1; i <= N; i++) {\n            for(int j = 1; j < i; j++) {\n                if(distance(points[i], points[j]) >= 2 - EPS) continue;\n                Circle C1(points[i], 1);\n                Circle C2(points[j], 1);\n                pair<Point, Point> p_p = crosspoint(C1, C2);\n                Point now = p_p.first;\n                int nowans = 0;\n                for(int k = 1; k <= N; k++) {\n                    if(distance(now, points[k]) <= 1.0 + EPS) nowans++;\n                }\n                ans = max(nowans, ans);\n                now = p_p.second;\n                nowans = 0;\n                for(int k = 1; k <= N; k++) {\n                    if(distance(now, points[k]) <= 1.0 + EPS) nowans++;\n                }\n                ans = max(nowans, ans);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\n#define MAX_N 300\nconst double PI=acos(-1.0);\n\nstruct Point{\n    double x,y;\n    Point(){\n        x=y=0;\n    }\n    bool operator<(const Point& p)const{\n        return this->x < p.x;\n    }\n};\n\nstruct comp{\n    bool operator()(const Point &P1, const Point &P2){\n        return P1.x < P2.x;\n    }\n    bool operator()(const Point &P, double d){\n        return P.x < d;\n    }\n    bool operator()(double d, const Point &P){\n        return d < P.x;\n    }\n};\n\nPoint points[MAX_N];\nint N;\n\ndouble distance(Point *a, Point *b){\n    return std::sqrt(pow(a->x-b->x,2)+pow(a->y-b->y,2));\n}\n\ndouble distance2(Point *a, Point *b){\n    return pow(a->x-b->x,2)+pow(a->y-b->y,2);\n}\n\nint solve(){\n    Point C, *P1, *P2, *P3;\n    int max=1;\n    for(int i=0;i<N;i++){\n        P1=&points[i];\n        Point *LB,*UB;\n        LB=std::lower_bound(points,points+N,P1->x-2.0001,comp());\n        UB=std::upper_bound(points,points+N,P1->x+2.0001,comp());\n        for(int j=(LB-points);j<(UB-points);j++){\n            if(i==j) continue;\n            P2=&points[j];\n            if(distance(P1,P2)>2.0) continue;\n\n            double alpha,beta;\n            alpha=acos(distance(P1,P2)/2.0);\n            if((P2->x-P1->x)>=0){\n                if((P2->y - P1->y)>=0){\n                    beta=atan((P2->y - P1->y) / (P2->x - P1->x));\n                }else{\n                    beta=atan((P2->y - P1->y) / (P2->x - P1->x))+2.0*PI;\n                }\n            }else{\n                beta=atan((P2->y - P1->y) / (P2->x - P1->x))+PI;\n            }\n            C.x=P1->x+cos(alpha+beta);\n            C.y=P1->y+sin(alpha+beta);\n\n            int enclosed=0;\n            Point *lb,*ub;\n            lb=std::lower_bound(points,points+N,C.x-1.0001,comp());\n            ub=std::upper_bound(points,points+N,C.x+1.0001,comp());\n            for(int k=(lb-points);k<(ub-points);k++){\n                if(k==i||k==j){\n                    enclosed++;\n                    continue;\n                }\n                P3=&points[k];\n                if(distance2(P3,&C)<1.0) enclosed++;\n            }\n            if(enclosed>max) max=enclosed;\n            if(max==N) return max;\n        }\n    }\n    return max;\n}\n\nint main(void){\n    while(scanf(\"%d\",&N), N){\n        for(int i=0;i<N;i++){\n            scanf(\"%lf %lf\", &points[i].x, &points[i].y);\n        }\n        std::sort(points,points+N);\n        printf(\"%d\\n\",solve());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<tuple>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define Per(i,sta,n) for(int i=n-1;i>=sta;i--)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef double ld;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n\n\n\nld torad(int deg) {return (ld)(deg) * pi / 180;}\nld todeg(ld ang) {return ang * 180 / pi;}\n\nstruct Point {\n    ld x, y;\n    Point(ld x = 0.0, ld y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\n\nPoint operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\nPoint operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\nPoint operator * (const Point &p, ld a) {return Point(p.x * a, p.y * a);}\nPoint operator * (ld a, const Point &p) {return Point(a * p.x, a * p.y);}\nPoint operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\nPoint operator / (const Point &p, ld a) {return Point(p.x / a, p.y / a);}\nPoint conj(const Point &p) {return Point(p.x, -p.y);}\nPoint rot(const Point &p, ld ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\nPoint rot90(const Point &p) {return Point(-p.y, p.x);}\nld cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\nld dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\nld norm(const Point &p) {return dot(p, p);}\nld abs(const Point &p) {return sqrt(dot(p, p));}\nld amp(const Point &p) {ld res = atan2(p.y, p.x); if (res < 0) res += pi*2; return res;}\nbool eq(const Point &p, const Point &q) {return abs(p - q) < eps;}\nbool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > eps ? p.x < q.x : p.y < q.y);}\nbool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > eps ? p.x > q.x : p.y > q.y);}\nPoint operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\nint ccw(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > eps) return 1;\n    if (cross(b-a, c-a) < -eps) return -1;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (norm(b-a) < norm(c-a)) return -2;\n    return 0;\n}\n\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n};\n\n\nPoint proj(Point p, Line l) {//射影\n    ld t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nPoint refl(Point p, Line l) {//対象な点\n    return p + (proj(p, l) - p) * 2;\n}\nbool isinterPL(Point p, Line l) {//点pが直線lに含まれるか\n    return (abs(p - proj(p, l)) < eps);\n}\nbool isinterPS(Point p, Line s) {//点pが線分sに含まれるか\n    return (ccw(s[0], s[1], p) == 0);\n}\nbool isinterLL(Line l, Line m) {//直線l,mが交わるか\n    return (abs(cross(l[1] - l[0], m[1] - m[0])) > eps ||\n            abs(cross(l[1] - l[0], m[0] - l[0])) < eps);\n}\nbool isinterSS(Line s, Line t) {//線分s,tが交わるか\n    return (ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 && \n            ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0);\n}\nld distancePL(Point p, Line l) {//点pと直線lの距離\n    return abs(p - proj(p, l));\n}\nld distancePS(Point p, Line s) {//点pと線分sの距離\n    Point h = proj(p, s);\n    if (isinterPS(h, s)) { return abs(p - h); }\n    return min(abs(p - s[0]), abs(p - s[1]));\n}\nld distanceLL(Line l, Line m) {//直線l,mの距離\n    if (isinterLL(l, m)) return 0;\n    else return distancePL(m[0], l);\n}\nld distanceSS(Line s, Line t) {//線分s,tの距離\n    if (isinterSS(s, t)) return 0;\n    else return min(min(distancePS(s[0], t), distancePS(s[1], t)), min(distancePS(t[0], s), distancePS(t[1], s)));\n}\nstruct Circle : Point{\n    ld r;\n    Circle(Point p = Point(0.0, 0.0), ld r = 0.0) : Point(p), r(r) {}\n};\n\n\nvector<Point> crosspoint(Line l, Line m) {\n    vector<Point> res;\n    ld d = cross(m[1] - m[0], l[1] - l[0]);\n    if (abs(d) < eps) return vector<Point>();\n    res.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n    return res;\n}\nvector<Point> crosspoint(Circle e, Circle f) {\n    vector<Point> res;\n    ld d = abs(e - f);\n    if (d < eps) return vector<Point>();\n    ld rcos = (d * d + e.r * e.r - f.r * f.r) / (2.0 * d);\n    ld rsin = sqrt(e.r * e.r - rcos * rcos);\n    Point dir = (f - e) / d;\n    Point p1 = e + dir * Point(rcos, rsin);\n    Point p2 = e + dir * Point(rcos, -rsin);\n    res.push_back(p1);\n    if (!eq(p1, p2)) res.push_back(p2);\n    return res;\n}\nvector<Point> crosspoint(Circle e, Line l) {\n    vector<Point> res;\n    Point p = proj(e, l);\n    ld rcos = abs(e - p), rsin;\n    if (rcos > e.r + eps) return vector<Point>();\n    else if (e.r - rcos < eps) rsin = 0;\n    else rsin = sqrt(e.r * e.r - rcos * rcos);\n    Point dir = (l[1] - l[0]) / abs(l[1] - l[0]);\n    Point p1 = p + dir * rsin;\n    Point p2 = p - dir * rsin;\n    res.push_back(p1);\n    if (!eq(p1, p2)) res.push_back(p2);\n    return res;\n}\n\nvoid solve(){\n  while(true){\n    int n;cin >> n;\n    if(n==0) return;\n    vector<Circle> cs;\n    rep(i,n){\n      ld x,y;\n      cin >> x >> y;\n      cs.push_back(Circle(Point(x,y),1));\n    }\n    int ans=0;\n    rep(i,n){\n      int res=0;\n      rep(k,n){\n        if(abs(cs[i]-cs[k])<1+eps){\n          res+=1;\n        }\n      }\n      ans=max(ans,res);\n      rep(j,n){\n        vector<Point> v=crosspoint(cs[i],cs[j]);\n        for(Point p:v){\n          res=0;\n          rep(k,n){\n            if(abs(p-cs[k])<1+eps){\n              res+=1;\n            }\n          }\n          ans=max(ans,res);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(50);\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// * XY座標\n#define X real()\n#define Y imag()\n\n// * 点の表現\ntypedef complex<double> P;\n\n// * 許容する誤差ε\nconst double EPS = 1e-10;\n// * Infinity\nconst double INF = 1e12;\n// * 円周率\nconst double PI = acos(-1.0);\n// * \nconst P INF_P(INF,INF);\n\n// * complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 点座標のデバッグ出力\nvoid print(P p) {\n\tcout << \"point\" << p << \";\" << endl;\n}\n\n// * 2乗する\ndouble sq(double x) {\n\treturn x * x;\n}\n\n// * 2点間の距離\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n// * 2つのベクトルが等しいかどうか\nbool eq_v(P a, P b) {\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// * 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// * 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// ベクトル a の単位法線ベクトルを求める\nvector<P> normal_unit(P a) {\n\tvector<P> vp;\n\tvp.push_back( (a * P(0,  1)) / abs(a) );\n\tvp.push_back( (a * P(0, -1)) / abs(a) ) ;\n\treturn vp;\n}\n\n// 原点を軸に点 p を角度 a (ラジアン)だけ回転させた点を返す\nP rot(P p, double a){\n\tdouble x = p.X * cos(a) - p.Y * sin(a);\n\tdouble y = p.X * sin(a) + p.Y * cos(a);\n\treturn P(x,y);\n}\n\nint main(){\n\tint n;\n\twhile( cin >> n , n ){\n\t\tvector<P> v;\n\t\tint ans=1;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf %lf\", &x, &y);\n\t\t\tv.push_back( P(x,y) );\n\t\t}\n\t\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\t\tfor(int j=i+1 ; j < v.size() ; j++ ){\n\t\t\t\tif( i == j ) continue;\n\t\t\t\tP p1 = v[i];\n\t\t\t\tP p2 = v[j];\n\t\t\t\tdouble d = dist(p1,p2);\n\t\t\t\tif( d >= 2.0 ) continue;\n\t\t\t\t\n\t\t\t\tdouble angle = atan2( p2.Y-p1.Y , p2.X-p1.X );\n\t\t\t\tP mid = rot( p2-p1 , -angle ) / 2.0;\n\t\t\t\tdouble h = sqrt(1.0 - sq(d/2.0));\n\t\t\t\tP p3 = P( mid.X , h );\n\t\t\t\tP p4 = P( mid.X , -h );\n\t\t\t\tint cnt1=0, cnt2=0;\n\t\t\t\tfor(int k=0 ; k < v.size() ; k++ ){\n\t\t\t\t\tP p = rot( v[k]-p1 , -angle );\n\t\t\t\t\tif( dist(p3,p) <= 1.0 ) cnt1++;\n\t\t\t\t\tif( dist(p4,p) <= 1.0 ) cnt2++;\n\t\t\t\t}\n\t\t\t\tans = max( ans , max(cnt1,cnt2) );\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\ntypedef pair<double, double> Point;\n\ndouble d2( Point p1, Point p2 ) {\n  double dx = p1.first - p2.first;\n  double dy = p1.second - p2.second;\n  return dx * dx + dy * dy;\n}\n\nPoint sub( Point p1, Point p2 ) {\n  return Point( p1.first - p2.first, p1.second - p2.second );\n}\n\nPoint add( Point p1, Point p2 ) {\n  return Point( p1.first + p2.first, p1.second + p2.second );\n}\n\nPoint div( Point p, double val ) {\n  return Point( p.first / val, p.second / val );\n}\n\nPoint middle( Point p1, Point p2 ) {\n  return div( add( p1, p2 ), 2.0 );\n}\n\ndouble norm( Point p ) {\n  return sqrt( p.first * p.first + p.second * p.second );\n}\n\nPoint normalize( Point p ) {\n  double n = norm( p );\n  return div( p, n );\n}\n\nPoint rotate( Point p, double th ) {\n  double x = cos( th ) * p.first - sin( th ) * p.second;\n  double y = sin( th ) * p.first + cos( th ) * p.second;\n  return Point( x, y );\n}\t\t\t\t\t\t\t\t\n\nvoid cross( Point p1, Point p2, Point &a1, Point &a2 ) {\n  Point v = normalize( sub( p1, p2 ) );\n  double th = acos( sqrt( d2( p1, p2 ) ) / 2.0 );\n  a1 = add( rotate( v, th ), p2 );\n  a2 = add( rotate( v, -th ), p2 );\n}\n\nvoid print( Point p ) {\n  cerr << p.first << \", \" << p.second << endl;\n}\n\nint main() {\n  while( true ) {\n\tint n;\n\tcin >> n;\n\tif ( n == 0 ) break;\n\t\n\tvector<Point> vs( n );\n\tfor ( int i = 0; i < n; i++ ) {\n\t  double x, y;\n\t  cin >> x >> y;\n\t  vs[ i ] = make_pair( x, y );\n\t}\n\tvector<Point> cands;\n\tfor ( int i = 0; i < n; i++ ) {\n\t  for ( int j = i + 1; j < n; j++ ) {\n\t\tdouble d = d2( vs[ i ], vs[ j ] );\n\t\tif ( d == 4 ) {\n\t\t  cands.push_back( middle( vs[ i ], vs[ j ] ) );\n\t\t} else if ( d < 4 ) {\n\t\t  Point p1, p2;\n\t\t  cross( vs[ i ], vs[ j ], p1, p2 );\n\t\t  cands.push_back( p1 );\n\t\t  cands.push_back( p2 );\n  \t\t}\n\t  }\n\t}\n\tint maxCount = 1;\n\tfor ( Point p : cands ) {\n\t  int c = 0;\n\t  for ( Point v : vs ) {\n\t\tif ( d2( p, v ) <= 1.0 ) {\n\t\t  c++;\n\t\t}\n\t  }\n\t  maxCount = max( maxCount, c );\n\t}\n\tcout << maxCount << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-4;\n\nstruct Circle{\n  P c;\n  double r;\n  Circle(P c=P(0,0),double r=0):c(c),r(r){}\n};\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1=c1.r,r2=c2.r,d;\n  P p1=c1.c,p2=c2.c;\n  d=abs(p1-p2);\n  if(d<EPS&&abs(r1-r2)<EPS) return res;\n  if(r1+r2<d-EPS||d+EPS<abs(r1-r2)) return res; \n  double a=(r1*r1-r2*r2+d*d)/(2*d);\n  double h=sqrt(max(r1*r1-a*a,0.0));\n  P tmp1=p1+a/d*(p2-p1);\n  P tmp2=h/d*(p2-p1);\n  if(abs(tmp2)<EPS)res.push_back(tmp1);\n  else{\n    res.push_back(P(real(tmp1)-imag(tmp2),imag(tmp1)+real(tmp2)));\n    res.push_back(P(real(tmp1)+imag(tmp2),imag(tmp1)-real(tmp2)));\n  }\n  return res;\n}\n\ndouble getdistancepp(P a,P b){\n  return sqrt((a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag()));\n}\n\nint main(){\n  int n,ans=0;\n  double a,b;\n  P p[N];\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>a>>b;\n      p[i]=P(a,b);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tCircle c1,c2;\n\tc1.c=p[i];\n\tc2.c=p[j];\n\tc1.r=c2.r=1;\n\tvector<P> r=getIntersectCC(c1,c2);\n\tif(!r.size())continue;\n\tfor(int k=0;k<r.size();k++){\n\t  int cnt=0;\n\t  for(int l=0;l<n;l++)\n\t    if(getdistancepp(r[k],p[l])<=1+EPS)cnt++;\t    \n\t  ans=max(ans,cnt);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n// ??????????????§?????????????????§???3????????????????????????????±?????????????????????¨?????????\n\nlong double pow2(long double d){\n\treturn d * d;\n}\n\nstruct Vector2{\n\tlong double x;\n\tlong double y;\n};\n\nVector2 P[500];\n\nint main(){\n\tint n;\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> P[i].x >> P[i].y;\n\t\t}\n\t\tlong double k, L_2, a, b;\n\t\t\n\t\tint max = 0;\n\t\t\n\t\tfor(int num1 = 0; num1 < n; num1++){\n\t\t\tfor(int num2 = num1 + 1; num2 < n; num2++){\n\t\t\t\tL_2 = pow2(P[num1].x - P[num2].x) + pow2(P[num1].y - P[num2].y);\n\t\t\t\tif(L_2 >= 4){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tk = sqrt((4 - L_2) / L_2);\n\t\t\t\t\n\t\t\t\ta = (k * (P[num1].y - P[num2].y) + P[num1].x + P[num2].x) / 2;\n\t\t\t\tb = (k * (P[num2].x - P[num1].x) + P[num1].y + P[num2].y) / 2;\n\t\t\t\t\n\t\t\t\tint count;\n\t\t\t\t\n\t\t\t\tcount = 0;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(i == num1 || i == num2){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(pow2(P[i].x - a) + pow2(P[i].y - b) <= 1){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(max < count){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ta = (k * (P[num2].y - P[num1].y) + P[num1].x + P[num2].x) / 2;\n\t\t\t\tb = (k * (P[num1].x - P[num2].x) + P[num1].y + P[num2].y) / 2;\n\t\t\t\t\n\t\t\t\tcount = 0;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(i == num1 || i == num2){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(pow2(P[i].x - a) + pow2(P[i].y - b) <= 1){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(max < count){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", max);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define mp            make_pair\n#define pb            push_back\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nconst int    INF = 1000000000;\nconst ll     MOD = 1000000007LL;\nconst double EPS = 1E-12;\n\ntemplate<typename T> T add(T x, T y){ if(abs(x+y) < EPS*(abs(x)+abs(y))) return 0; return x + y; }\ntemplate<typename T> inline bool semieq(T x, T y){ return abs(x - y) < EPS; }\ntemplate<typename T> inline bool semige(T x, T y){ return y - x < -EPS; }\ntemplate<typename T> inline bool semile(T x, T y){ return x - y < -EPS; }\n\n\nstruct Point : public complex<double>\n{\npublic:\n  Point() { this->real(0);  this->imag(0); }\n  Point(const double& x, const double& y) { this->real(x);  this->imag(y); }\n  Point(const complex<double> w)  { this->real(w.real());  this->imag(w.imag()); }\n  inline double dot(Point p){ return (conj(*this) * p).real(); }  // ??????\n  inline double det(Point p){ return (conj(*this) * p).imag(); }  // ??????\n};\n\nnamespace std\n{\n  inline bool operator < (const Point& a, const Point& b)\n  {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ntypedef vector<Point> Polygon;\ninline Point currPoint(vector<Point> P, int i){ return P[i]; }\ninline Point nextPoint(vector<Point> P, int i){ return P[(i+1)%P.size()]; }\ninline Point diffPoint(vector<Point> P, int i){ return nextPoint(P, i) - currPoint(P, i); }\n\n\nstruct Circle : Point\n{\nprivate:\n  Point p;\n  double r;\n\npublic:\n  Circle(Point p, double r) : p(p), r(r) {}\n  Circle(double x, double y, double r) : p(Point(x, y)), r(r) {}\n  inline Point center(){ return this->p; }\n  inline double radius(){ return this->r; }\n};\n\nint intersectionDeterminationOfCC(Circle A, Circle B)\n{\n  double d = abs(A.center() - B.center());\n  if(semile(d, A.radius() - B.radius())) return  1;  // B in A\n  if(semile(d, B.radius() - A.radius())) return -1;  // A in B\n  if(semieq(d, A.radius() - B.radius())) return  2;  // B in A????????\\???\n  if(semieq(d, B.radius() - A.radius())) return -2;  // A in B????????\\???\n  if(semige(d, A.radius() + B.radius())) return  3;  // ???????????????\n  if(semieq(d, A.radius() + B.radius())) return -3;  // ?????\\\n  return 4;  // ????????£?????????\n}\n\n\n// ???????????????????¨±??????????????????????????????????????¨????????????????¨???????????????????\nvector<Point> intersectionOfCC(Circle A, Circle B)\n{\n  vector<Point> ret;\n  double d = abs(A.center() - B.center());\n  double rc = (d * d + A.radius() * A.radius() - B.radius() * B.radius()) / (2.0 * d);\n  double rs = sqrt(A.radius() * A.radius() - rc * rc);\n  Point diff = (B.center() - A.center()) / d;\n  ret.pb(A.center() + diff * Point(rc,  rs));\n  ret.pb(A.center() + diff * Point(rc, -rs));\n  return ret;\n}\n\nconst double r = 1.0;\nint N;\ndouble x, y;\n\nint main()\n{\n  while((cin >> N) && N){\n    vector<Point> P;\n\n    rep(i, N){\n      cin >> x >> y;\n      P.pb(Point(x, y));\n    }\n\n    int res = 1;\n    rep(i, N) rep(j, i) if(!semige(abs(P[i] - P[j]), 2.0 * r)){\n      Circle A = Circle(P[i], r);\n      Circle B = Circle(P[j], r);\n      vector<Point> PP = intersectionOfCC(A, B);\n\n      vrep(v, PP){\n        int cnt = 0;\n        vrep(w, P) if(!semige(abs(*w - *v), r)) cnt += 1;\n        maxup(res, cnt);\n      }\n    }\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n\nusing namespace std;\ntypedef pair<double, double> P;\nconst double EPS = 1e-6;\n\ndouble dist(P a, P b)\n{\n    return hypot(a.first - b.first, a.second - b.second);\n}\n\nP center(P a, P b, P c)\n{\n    double ax = a.first, ay = a.second;\n    double bx = b.first, by = b.second;\n    double cx = c.first, cy = c.second;\n    double d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));\n    auto norm = [](P p) { return p.first * p.first + p.second * p.second; };\n    return P(\n        (norm(a) * (by - cy) + norm(b) * (cy - ay) + norm(c) * (ay - by)) / d,\n        (norm(a) * (cx - bx) + norm(b) * (ax - cx) + norm(c) * (bx - ax)) / d\n    );\n}\n\nint main()\n{\n    while (1) {\n        int n; cin >> n;\n        if (!n) break;\n        vector<P> pnt;\n        loop (n, i) {\n            double x, y; cin >> x >> y;\n            pnt.emplace_back(x, y);\n        }\n        int ans = 1;\n        loop (n, i) loop (n, j) {\n            if (dist(pnt[i], pnt[j]) < 2) ans = 2;\n        }\n        loop (n, i) loop (n, j) loop (n, k) {\n            int cnt = 0;\n            P o = center(pnt[i], pnt[j], pnt[k]);\n            loop (n, l) {\n                if (dist(o, pnt[l]) < 1 + EPS) cnt++;\n            }\n            ans = max(ans, cnt);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nconst double EPS = 1e-8;\ntypedef pair<double,double> P;\n\ninline double dist(P p,P q){\n  return ( (p.first-q.first)*(p.first-q.first) + (p.second-q.second)*(p.second-q.second));\n}\n\nint main(){\n  int N;\n  double sign[2] = {+1, -1};\n  while(cin>>N,N){\n    vector<P> p(N);\n    REP(i,N)cin>>p[i].first>>p[i].second;\n    int ans = 1;\n    REP(i,N){\n      FOR(j,i+1,N){\n        double dst = dist(p[i],p[j]);\n        if(dst > 4.0) continue;\n        P v((p[j].first-p[i].first)/dst, (p[j].second-p[i].second)/dst);\n        P m((p[j].first+p[i].first)/2.0, (p[j].second+p[i].second)/2.0);\n        double lth = sqrt(1.0-dst*dst/4.0);\n        REP(k,2){\n          double cx = m.first + sign[k] * v.first * lth;\n          double cy = m.second - sign[k] * v.second * lth;\n          P center(cx,cy);\n          int count = 0;\n          REP(l,N){\n            if(l == i || l == j || dist(center,p[l]) < 1){\n              count++;\n            }\n          }\n          ans = max(ans, count);\n        }\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n#include<cmath>\n#define EPS 1e-8\nusing namespace std;\n \ntypedef complex<double> P;\n \nP center(P a,P b){\n  P m = (a+b)/2.0;\n  P n = (a-b)*P(0,1);\n  n = n/abs(n);\n \n  double x = abs(a-b)/2.0;\n  return m + n*sqrt(1.0 - x*x);\n}\n \nint main(){\n  int n;\n  P p[300];\n \n  while(cin >> n && n){\n    for(int i=0;i<n;i++)cin >> p[i].real() >> p[i].imag();\n \n    int ans = 1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n    if(i!=j){\n      if(abs(p[i]-p[j])+EPS>2.0)continue;\n      P c = center(p[i],p[j]);\n      int num = 0;\n      for(int k=0;k<n;k++)\n        if(abs(c-p[k])<1.0+EPS)num++;\n      ans = max(ans,num);\n    }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\nconst double PI=3.1415926535897932;\n\nbool inC(P p, P c, double r){\n    return abs(p-c)<r;\n}\n\nint main(){\n    int n,i,j,k,ans,cnt;\n    double x, y;\n    while(scanf(\"%d\",&n)){\n        if(n==0) break;\n        ans=0;\n        vector<P> ps(n);\n        for(i=0; i<n; i++){\n            scanf(\"%lf%lf\",&x,&y);\n            ps[i] = P(x,y);\n        }\n        for(i=0;i<n;i++)\n            for(j=i+1;j<n;j++)if(abs(ps[i]-ps[j])<2){\n                cnt=0;\n                double d=sqrt(1-abs(ps[j]-ps[i])*abs(ps[j]-ps[i])/4)/abs(ps[j]-ps[i]);\n                P c1=(ps[i]+ps[j])/2.0+(ps[j]-ps[i])*polar(d/2,PI/2);\n                P c2=(ps[i]+ps[j])/2.0+(ps[j]-ps[i])*polar(d/2,-PI/2);\n                for(k=0;k<n;k++){\n                    cnt += inC(ps[k],c1,1.0);\n                }\n                if(cnt>ans)ans=cnt;\n                cnt=0;\n                for(k=0;k<n;k++){\n                    cnt += inC(ps[k],c2,1.0);\n                }\n                if(cnt>ans)ans=cnt;\n            }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\n#define Sq(x) ((x)*(x))\n\n#define Foreach(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n\nconst double PI = M_PI;\nconst double EPS = 0.0001;\n\nstruct Point{\n  double x,y;\n\n  Point(){}\n  Point(double x, double y) : x(x), y(y) {}\n};\n\nPoint operator+(const Point &a, const Point &b){\n  return Point(a.x + b.x, a.y + b.y);\n}\n\nPoint operator-(const Point &a, const Point &b){\n  return Point(a.x - b.x, a.y - b.y);\n}\n\nPoint operator*(const Point &a, const double k){\n  return Point(a.x * k, a.y * k);\n}\n\nPoint operator*(const Point &a,const Point &b){\n  return Point(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\n\nPoint operator/(const Point &p, const double k){\n  return Point(p.x / k, p.y / k);\n}\n\ndouble dot(const Point &a, const Point &b){\n  return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Point &a, const Point &b){\n  return a.x * b.y - a.y * b.x;\n}\n\ndouble norm(const Point &p){\n  return dot(p, p);\n}\n\ndouble abs(const Point &p){\n  return sqrt(norm(p));\n}\n\ntypedef Point Vector;\n\nstruct Circle : Point{\n  double r;\n  Circle(Point p = Point(0,0), double r = 0) : Point(p), r(r) {}\n};\n\ndouble distPP(const Point &a, const Point &b) {\n  return sqrt(Sq(a.x-b.x) + Sq(a.y-b.y));\n}\n\nbool isPointInCircle(const Point &p, const Circle &c) {\n  return abs(p - c) <= c.r + EPS;\n}\n \nvector<Point> crossPointCC(const Circle &c1, const Circle &c2) {\n  vector<Point> res;\n  \n  if(abs(c1-c2) < EPS) return vector<Point>();\n  \n  double d = abs( c1 - c2 );\n  double rc = ( d*d+c1.r * c1.r-c2.r * c2.r ) / ( 2*d );\n  double rs = sqrt(c1.r*c1.r-rc*rc);\n  Point diff = ( c2 - c1 ) / d;\n  res.push_back( Point(c1 + diff * Point(rc,rs)) );\n  res.push_back( Point(c1 + diff * Point(rc,-rs)) );\n  return res;\n}\n\nPoint rotate90(const Point &p) {\n  return Point(-p.y, p.x);\n}\n\n/*\nテ」ツ??」ツ?セテ」ツ?湘・ツ仰陛」ツ?凝」ツ?ェテ」ツ??\nPoint rotateVector(const Vector &p, double th) {\n  return Point(p.x * cos(th) - p.y*sin(th), p.x * sin(th) + p.y * cos(th));\n}\n*/\n\nint main() {\n  int n;\n  Point p[300];\n  \n  while(cin >> n && n) {\n    for(int i=0; i<n; i++) {\n      cin >> p[i].x >> p[i].y;\n    }\n    \n    int ans = 1;\n    for(int i=0; i<n-1; i++) {\n      for(int j=i+1; j<n; j++) {\n\tif(distPP(p[i], p[j]) + EPS > 2.0) continue;\n\t\n\tPoint cent((p[i]+p[j])/2);\n\tdouble a = distPP(p[i], cent);\n\tdouble b = sqrt(1.0 - a*a);\n\t\n\tVector v1 = p[i] - cent;\n\tVector v2 = rotate90(v1);\n\tPoint center = cent + ((v2/abs(v2)) * b);\n\tCircle c1(center, 1.0);\n\tint cnt = 0;\n\tfor(int k=0; k<n; k++) {\n\t  cnt += isPointInCircle(p[k], c1);\n\t}\n\tans = max(ans, cnt);\n\t\n\tcenter = cent + ((v2/abs(v2)) * -b);\n\tCircle c2(center, 1.0);\n\tcnt = 0;\n\tfor(int k=0; k<n; k++) {\n\t  cnt += isPointInCircle(p[k], c2);\n\t}\n\tans = max(ans, cnt);\n      }\n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint N;\ndouble x[300],y[300];\n\nint main(){\n\twhile(cin>>N&&N){\n\t\tint ans=1;\n\t\trep(i,N)cin>>x[i]>>y[i];\n\t\trep(i,N)for(int j=i+1;j<N;j++){\n\t\t\tdouble x1=x[i],y1=y[i],x2=x[j],y2=y[j];\n\t\t\tif((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)<4){\n\t\t\t\tdouble xm=(x1+x2)/2,ym=(y1+y2)/2,dx=x2-x1,dy=y2-y1,n=sqrt(dx*dx+dy*dy),d=sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)),dd=sqrt(1-d*d/4);\n\t\t\t\tdouble cx=xm-dy/n*dd,cy=ym+dx/n*dd;\n\t\t\t\tint res=0;\n\t\t\t\trep(k,N)if((x[k]-cx)*(x[k]-cx)+(y[k]-cy)*(y[k]-cy)<=1+EPS)res++;\n\t\t\t\tans=max(ans,res);\n\t\t\t\tcx=xm+dy/n*dd;cy=ym-dx/n*dd;\n\t\t\t\tres=0;\n\t\t\t\trep(k,N)if((x[k]-cx)*(x[k]-cx)+(y[k]-cy)*(y[k]-cy)<=1+EPS)res++;\n\t\t\t\tans=max(ans,res);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double R;//double long double の切り替え cmathの関数はオーバーロードに対応しているので問題ない\ntypedef complex<R> Point;\ntypedef pair<Point , Point> Line;\ntypedef pair<Point ,R > Circle;\ntypedef vector<Point> Poly;\n\n#define EPS (1e-10)//誤差\n#define EQ(a,b) (abs((a)-(b)) < EPS)//２つの実数が等しいか\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )//２つのベクトルが等しいか\n#define ft first\n#define sd second\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nR dot(Point a,Point b){//内積ok\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nR cross(Point a,Point b){//外積ok\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\n\n\nbool is_orthogonal(Line a,Line b){//2直線の直行判定ok\n    return EQ(dot(a.ft - a.sd,b.ft - b.sd),0.0);\n}\nbool is_parallel(Line a,Line b){//2直線の並行判定ok\n    return EQ(cross(a.ft - a.sd,b.ft - b.sd),0.0);\n}\n\n\n\n////////////////////交差判定\nint ccw(Point a,Point b,Point c){//ok\n    b -= a; c -= a;\n    if(cross(b,c) > EPS) return 1;//a→bで反時計周りに折れてb→c\n    if(cross(b,c) < -EPS) return -1;//a→bで時計周りに折れてb→c\n    if(dot(b,c) < -EPS) return 2;//c--a--b on same line\n    if(norm(c) - norm(b) > EPS) return -2;//a--b--c(absじゃなくて二乗するのは差が出やすいから?)\n    return 0;//a--c--bまたはb==c\n}\n\nbool is_intersection_ll(Line l,Line m){//２つの直線が交わるかok\n    return abs(cross(l.sd - l.ft,m.sd - m.ft)) > EPS || //平行でない\n        abs(cross(l.sd - l.ft,m.ft - l.ft)) < EPS; //平行だが同じ線\n}\n\nbool is_intersection_ls(Line l,Line s){//直線lと線分sが交わるか\n    return cross(l.sd - l.ft, s.ft-l.ft)*       // s[0] is left of l\n        cross(l.sd - l.ft, s.sd - l.ft) < EPS; // s[1] is right of l\n}\n\nbool is_intersection_lp(Line l,Point p){//直線lと点pが交わるか\n    return abs(cross(l.sd - p,l.ft - p));\n}\n\nbool is_intersection_ss(Line a,Line b){//２つの線分が交わるかok\n    return ccw(a.ft,a.sd,b.ft)*ccw(a.ft,a.sd,b.sd) <= 0 && ccw(b.ft,b.sd,a.ft)*ccw(b.ft,b.sd,a.sd) <= 0;\n}\n\nbool is_intersection_sp(Line s,Point p){//線分と点の交差判定 三角不等式の利用\n    return abs(s.ft - p) + abs(s.sd - p) - abs(s.ft - s.sd) < EPS;\n}\n\n\nbool intersection_cc(Circle c1,Circle c2){//２つの円の交差判定ok\n    return abs(c1.ft - c2.ft) - (c1.sd + c2.sd) < -EPS;\n}\n\n\n/////////////距離\nR dis_lp(Line l,Point p){//直線lと点pの距離ok\n    return abs(cross(l.sd - l.ft,p - l.ft)) / abs(l.sd - l.ft);\n}\n\nR dis_ll(Line l,Line m){//２つの直線の距離\n    return is_intersection_ll(l,m) ? 0.0 : dis_lp(l,m.ft);\n}\n\nR dis_ls(Line l,Line s){//直線lと線分sの距離\n    if(is_intersection_ls(l,s)) return 0.0;\n    return min(dis_lp(l,s.ft),dis_lp(l,s.sd));\n}\n\nR dis_sp(Line s,Point p){//線分sと点pの距離ok\n    if(dot(s.sd - s.ft,p - s.ft) < EPS) return abs(p - s.ft);\n    if(dot(s.ft - s.sd,p - s.sd) < EPS) return abs(p - s.sd);\n    return dis_lp(s,p);\n}\n\nR dis_ss(Line s,Line t){//２つの線分の距離ok\n    if(is_intersection_ss(s,t)) return 0.0;\n    return min(min(dis_sp(s,t.ft),dis_sp(s,t.sd)),\n            min(dis_sp(t,s.ft),dis_sp(t,s.sd)));\n}\n\n\n\n//////////////射影と反射\nPoint projection(Line l,Point p){//射影を求めるok\n    R t = dot(p - l.ft,l.ft - l.sd) / norm(l.ft - l.sd);\n    return l.ft + t * (l.ft - l.sd);\n}\n\nPoint reflection(Line l,Point p){//反射を求めるok\n    return p + (R)2.0 * (projection(l,p) - p);\n}\n\n//////////////垂直なベクトル\nPoint vertical_vec(Point v) {\n    return Point(-v.imag(),v.real());\n}\n\n//////////////ヴェクタを正規化\nPoint normalized(Point v) {\n    R a = abs(v);\n    return v / a;\n}\n\n//////////////交点(交差する保証してないときは交差判定してからつかってね)\n\nPoint intersection_ll(Line l,Line m){//交差判定してるなら線分にも使えるok\n    R A = cross(l.sd - l.ft,m.sd - m.ft);\n    R B = cross(l.sd - l.ft,l.sd - m.ft);\n    if(abs(A) < EPS && abs(B) < EPS) return m.ft;//同じ線\n    //if(abs(A) < EPS)assert(false);//並行で交点なし\n    return m.ft + B / A * (m.sd - m.ft);\n}\n\nLine intersection_of_two_circles(Circle c1,Circle c2){//ok ２つの円の交点をLineに入れて返す(r1 + r2 > sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2))を満たす必要があるok\n    R a =  abs(c2.ft - c1.ft);\n    R b = c1.sd;\n    R c = c2.sd;\n\n    R rc = (a  * a + b * b - c * c) / (2.0 * a);\n    R rs = sqrt(b * b - rc * rc);//C++ ではオーバーロードが可能であるため、sqrt または float 型を受け取る long double のオーバーロードを呼び出すことができます。 C プログラムでは、sqrt は常に double を受け取って返します。\n    Point diff = (c2.ft - c1.ft) / a;\n\n    Line p ;\n    p.ft = c1.ft + diff * rc + diff * Point(0,1) * rs;\n    p.sd = c1.ft + diff * rc + diff * Point(0,-1) * rs;\n\n    return p;\n}\n\n\n/////////////////////////polygon\n\n#define currP(P,i) P[(i) % P.size()]//今の頂点\n#define nextP(P,i) P[((i) + 1)%P.size()]//次の頂点\n\nint is_contains_p_in_Poly(Poly po,Point p){//点が多角形の内部(1)、境界(-1)、外部(0)のどこにあるかを判定ok\n    bool in = false;\n    REP(i,po.size()){\n        Point a = currP(po,i) - p,b = nextP(po,i) - p;\n        if(a.imag() > b.imag())swap(a,b);\n        if(a.imag() < EPS && EPS < b.imag())\n            if(cross(a,b) < -EPS) in = !in;\n        if(EQ(cross(a,b),0.0) && dot(a,b) < EPS)return  -1;\n    }\n    return in;\n}\n\nR area2(Poly po){//多角形の面積の二倍を求めるok\n    R A = 0.0;\n    REP(i,po.size())\n        A += cross(currP(po,i),nextP(po, i));\n    return A;\n}\n\n\n\n\n///////////////////////////凸\n\nbool comp_complex_real(Point a,Point b){//x→yの辞書順ok\n    if(EQ(a.real(),b.real()))\n        return b.imag() - a.imag() > EPS;\n    return b.real() - a.real() > EPS;\n}\n\nPoly convex_hull(Poly ps){//凸包ok\n    int n = ps.size(),k = 0;\n    sort(ps.begin(),ps.end(),comp_complex_real);\n    Poly ch(2*n);\n    for(int i = 0;i < n;ch[k++] = ps[i++])// lower-hull\n        while(k >= 2 && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0 && ccw(ch[k - 2],ch[k - 1],ps[i]) > -2) --k;//３つ目の条件は180度を含むときのみ必要\n    for(int i = n - 2,t = k + 1;i >= 0;ch[k++] = ps[i--])//upper-hull\n        while(k >= t && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0 && ccw(ch[k - 2],ch[k - 1],ps[i]) > -2) --k;//上に同じ\n    ch.resize(k - 1);\n    return ch;\n}\n#define prevP(P, i) P[(i+P.size()-1) % P.size()]\nbool isconvex(Poly P){//凸性判定時計回り反時計周りに対応\n    bool cl = false,ccl = false;\n    for(int i = 0;i < P.size();++i){\n        int c = ccw(prevP(P,i),currP(P,i),nextP(P,i));\n        if(c == -2)continue;//180度を含むときのみ　360度も含むときはc == -2 || c == 0\n        if(c == 1)ccl = true;\n        else if(c == 2)cl = true;\n        else return false;\n    }\n    return !(cl && ccl);\n}\nPoint p[1000];\nint n;\n\nint inner(Point c) {\n    int ret = 0;\n    REP(i,n) {\n        if(abs(c - p[i]) < 1.0 - EPS) {\n            ret++;\n        }\n    }\n    return ret;\n}\n\nint main(){\n    while(true) {\n        cin >> n;\n        if(n == 0)break;\n        REP(i,n) {\n            double x,y;\n\n            cin >> x >> y;\n\n            p[i] = Point(x,y);\n        }\n        if(n == 1) {\n            cout << 1 << endl;\n            continue;\n        }\n        int ans = 1;\n\n        REP(i,n) {\n            FOR(j,i+1,n) {\n                Point a = p[i];\n                Point b = p[j];\n\n                Point x = b - a;\n\n                Point y = vertical_vec(x);\n                y = normalized(y);\n\n                R c = abs(x) / 2;\n\n                if(c > 1.0 - EPS)continue;\n\n                R d = sqrt(1 - c * c);\n\n                y *= d;\n\n                Point m = (a  + b) / 2.0;\n                ans = max(ans,inner(m+y) + 2);\n                ans = max(ans,inner(m-y) + 2);\n\n\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double r = 1.0;\nconst double PI = acos(-1.0);\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y) : x(x), y(y) {}\n};\nPoint operator+(const Point &a, const Point &b) {\n    return Point(a.x + b.x, a.y + b.y);\n}\nPoint operator-(const Point &a, const Point &b) {\n    return Point(a.x - b.x, a.y - b.y);\n}\ninline double Distance2(const Point &a, const Point &b) {\n    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\nPoint Circle(const Point &p1, const Point &p2, double theta) {\n    Point p12 = p2 - p1;\n    Point rp(p12.x * cos(theta) - p12.y * sin(theta), p12.x * sin(theta) + p12.y * cos(theta));\n    double len = sqrt(p12.x * p12.x + p12.y * p12.y);\n\n    rp.x /= len;\n    rp.y /= len;\n\n    return rp + p1;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n\n    while (cin >> n, n) {\n        // Input\n        vector<Point> p(n);\n        for (int i = 0; i < n; ++i)\n            cin >> p[i].x >> p[i].y;\n\n        // Solve\n        int ans = 1;\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j) {\n                double d = Distance2(p[i], p[j]);\n\n                if (d <= 4.0 * r * r) {\n                    double theta = (PI - acos((2.0 - d) * 0.5)) * 0.5;\n\n                    for (int s = -1; s <= 1; s += 2) {\n                        Point c = Circle(p[i], p[j], s * theta);\n\n                        int num = 2;\n                        for (int k = 0; k < n; ++k) {\n                            if (k != i && k != j && Distance2(c, p[k]) <= 1.0)\n                                ++num;\n                        }\n\n                        ans = max(ans, num);\n                    }\n                }\n            }\n\n        // Output\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> P;\nconst LL MOD = 1000000007LL;\nconst double EPS = 1e-10;\nstruct Point {\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\tPoint operator+(const Point &p) const {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator-(const Point &p) const {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator*(const double a) const {\n\t\treturn Point(x*a, y*a);\n\t}\n\tPoint operator/(double a) const {\n\t\treturn Point(x / a, y / a);\n\t}\n\tdouble abs() const {\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm() const {\n\t\treturn x*x + y*y;\n\t}\n\tbool operator<(const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator==(const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\ntypedef Point Vector;\nstruct Segment {\n\tPoint p1, p2;\n};\ntypedef Segment Line;\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\ntypedef vector<Point> Polygon;\ndouble norm(Vector a);\ndouble abs(Vector a);\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\nbool equals(double a, double b);\nbool isOrthogonal(Vector a, Vector b);\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2);\nbool isOrthogonal(Segment s1, Segment s2);\nbool isParallel(Vector a, Vector b);\nbool isParallel(Point a1, Point a2, Point b1, Point b2);\nbool isParallel(Segment s1, Segment s2);\nPoint project(Segment s, Point p);\nPoint reflect(Segment s, Point p);\nint ccw(Point p0, Point p1, Point p2);\ndouble getDistance(Point a, Point b);\ndouble getDistanceLP(Line l, Point p);\ndouble getDistanceSP(Segment s, Point p);\ndouble getDistance(Segment s1, Segment s2);\nbool intersect(Point p1, Point p2, Point p3, Point p4);\nbool intersect(Segment s1, Segment s2);\nbool intersect(Circle c, Line l);\nbool intersect(Circle c1, Circle c2);\nPoint getCrossPoint(Segment s1, Segment s2);\npair<Point, Point> getCrossPoints(Circle c, Line l);\ndouble arg(Vector p);\nVector polar(double a, double r);\npair<Point, Point> getCrossPoints(Circle c1, Circle c2);\ndouble norm(Vector a) {\n\treturn a.x*a.x + a.y*a.y;\n}\ndouble abs(Vector a) {\n\treturn sqrt(norm(a));\n}\ndouble dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\ndouble cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\nbool equals(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base*r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\ndouble getDistance(Point a, Point b) {\n\treturn abs(a - b);\n}\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nbool intersect(Circle c, Line l) {\n\treturn getDistanceLP(l, c.c) <= c.r;\n}\nbool intersect(Circle c1, Circle c2) {\n\treturn getDistance(c1.c, c2.c) <= c1.r + c2.r;\n}\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r*c.r - norm(pr - c.c));\n\treturn make_pair(pr + e*base, pr - e*base);\n}\ndouble arg(Vector p) {\n\treturn atan2(p.y, p.x);\n}\nVector polar(double a, double r) {\n\treturn Vector(cos(r)*a, sin(r)*a);\n}\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\tassert(intersect(c1, c2));\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tPoint p[300];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = Point(x, y);\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tVector d = p[j] - p[i];\n\t\t\t\tif (d.abs() > 2.0) continue;\n\t\t\t\tPoint m = p[i] + d / 2.0;\n\t\t\t\tVector r = Vector(-d.y, d.x);\n\t\t\t\tr = r / r.abs()*sqrt(1 - pow(d.abs() / 2.0, 2));\n\t\t\t\tPoint p1 = m + r;\n\t\t\t\tPoint p2 = m - r;\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tint cnt2 = 0;\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif ((p[k] - p1).abs() <= 1) cnt1++;\n\t\t\t\t\tif ((p[k] - p2).abs() <= 1) cnt2++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, max(cnt1, cnt2));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <numeric>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<((x))<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n#define long long long\n#define EPS 1e-8\n\n// ???????°???°???????????????\ninline double add(double a, double b){\n  if(abs(a+b) < EPS*(abs(a) + abs(b))) return 0;\n  return a+b;\n}\n\nstruct Point{\n  double x,y;\n  Point() {}\n  Point(double nx, double ny) : x(nx), y(ny) {}\n  inline Point operator + (const Point & p){ return Point(add(x, p.x), add(y, p.y)); }\n  inline Point operator - (const Point & p){ return Point(add(x,-p.x), add(y,-p.y)); }\n  inline Point operator * (double d){ return Point(x*d, y*d); }\n  inline double dot(const Point & p){ return add(x * p.x, y*p.y); }  //??????\n  inline double det(const Point & p){ return add(x * p.y, -y*p.x); } //??????\n  inline double dist(const Point & p){ return sqrt((x-p.x)*(x-p.x) + (y-p.y)*(y-p.y)); }\n  inline bool operator < (const Point & p) const {\n    if(x != p.x) return x < p.x;\n    else return y < p.y;\n  }\n  inline bool operator == (const Point & p) const {\n    return (add(x, -p.x)==0) && (add(y, -p.y)==0);\n  }\n  friend ostream& operator<<(ostream& os, const Point& p) {\n    os << \"[\" << p.x << \",\" << p.y << \"]\";\n    return os;\n  }\n};\n\npair<Point, Point> calcCenter(Point &p1, Point &p2){\n  if(add(p1.x, -p2.x)==0){\n    double y = (p1.y + p2.y)/2;\n    double dx = sqrt(1 - (p1.y - y)*(p1.y - y));\n    return mp(Point(p1.x+dx, y), Point(p1.x-dx,y));\n  }\n  // 2???????????´???????????? Ax + By + C = 0 , A != 0\n  double A = 2*(p1.x - p2.x);\n  double B = 2*(p1.y - p2.y);\n  double C = - p1.x*p1.x + p2.x*p2.x - p1.y*p1.y + p2.y*p2.y;\n  // x = py+q\n  double p = -B/A; double q = -C/A;\n\n  // p1, p2 ??¨????????¢???1?????? ay^2 + 2by + c = 0\n  double a = 1 + p*p;\n  double b = p*q - p1.x*p - p1.y;\n  double c = q*q - 2*p1.x*q + p1.x*p1.x + p1.y*p1.y - 1;\n\n  double rt = sqrt(b*b-a*c);\n  double y1 = (-b+rt)/a;\n  double y2 = (-b-rt)/a;\n\n  return mp(Point(p*y1+q, y1), Point(p*y2+q, y2));\n}\n\nPoint vec[300];\n\nint main(){\n  int n;\n  while(scanf(\"%d\", &n), n){\n    rep(i,n){\n      scanf(\"%lf %lf\", &vec[i].x, &vec[i].y);\n    }\n\n    int res=1;\n    rep(i,n) repl(j,i+1,n) if(vec[i].dist(vec[j]) <= 2+EPS){\n      pair<Point, Point> pr = calcCenter(vec[i], vec[j]);\n      int cnt=0;\n      rep(k,n) if(pr.fi.dist(vec[k]) <= 1+EPS) cnt++;\n      res = max(res, cnt);\n      cnt=0;\n      rep(k,n) if(pr.se.dist(vec[k]) <= 1+EPS) cnt++;\n      res = max(res, cnt);\n    }\n\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>/*{{{*/\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\nstatic const double PI (3.14159265358979323846);\nstatic const double EPS (1e-10);\n\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n#define FOR(i, b, e) for (typeof(b) i = (b); assert((i) <= (e)), i != (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((ll)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define DEBUG_ON\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) fprintf(stderr, fmt, __VA_ARGS__)\n\t#define darr(a) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#else\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n#endif\n/*}}}*/\n\nint N;\nvector<P> points;\n\nP middle_point(P a, P b)\n{\n\treturn a + (b-a) / 2.0;\n}\n\n// 点pを中心としてr(radian)回転 p(0,0)で原点を中心として回転\nP rotate(P t, P p ,double r){\n\t// double r=radians(angle);\n\treturn (t - p) * P(cos(r), sin(r)) + p;\n}\n\n// 2円 |x-a|=raと|x-b|=rbの交点計算\nbool intersection_c_c(P a, double ra, P b, double rb, P ans[]){\n\tdouble di = abs(a-b);\n\tif(di > ra+rb || di < abs(ra-rb)) return false;\n\tdouble t=(ra*ra - rb*rb + di*di) / (di+di);\n\tdouble rd = acos(t/ra);\n\n\tP dv = (b-a) / abs(b-a);\n\tP g1 = rotate(dv, P(0,0), rd);\n\tP g2 = rotate(dv, P(0,0), -rd);\n\tans[0] = a + g1*ra;\n\tans[1] = a + g2*ra;\n\treturn true;\n}\n\nint main(int argc, char const* argv[])\n{\n\twhile (cin >> N, N) {\n\t\tint ans = 0;\n\t\tpoints.clear();\n\t\tREP(i, N) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoints.PB(P(x, y));\n\t\t}\n\t\tREP(i, N) {\n\t\t\tFOR(j, i+1, N) {\n\t\t\t\tP p1 = points[i], p2 = points[j];\n\t\t\t\tdprt(\"(%lf, %lf) and (%lf, %lf)\\n\", p1.real(), p1.imag(), p2.real(), p2.imag());\n\t\t\t\tP centers[2];\n\t\t\t\tif (intersection_c_c(p1, 1, p2, 1, centers)) {\n\t\t\t\t\tREP(k, 2) {\n\t\t\t\t\t\tdprt(\" center: (%lf, %lf)\\n\", centers[k].real(), centers[k].imag());\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\tREP(l, N) {\n\t\t\t\t\t\t\tif (abs(centers[k] - points[l]) < 1.0 + EPS) {\n\t\t\t\t\t\t\t\t++cnt;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans = max(ans, cnt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\n#include <assert.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-12;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(norm(p - at(0))) || !sig(norm(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t};\n\tstruct C : public P{\n\t\tR r;\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tP crosspoint(const L &l, const L &m);\n\tstruct G : public vector<P>{\n\t\tG(size_type size=0):vector(size){}\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tR area()const {\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false) {\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n\t\tG cut(const L &l)const {\n\t\t\tG g;\n\t\t\tREP(i, size()){\n\t\t\t\tconst S &s = edge(i);\n\t\t\t\tif(ccw(l[0], l[1], s[0], 0) >= 0) g.push_back(s[0]);\n\t\t\t\tif(ccw(l[0], l[1], s[0], 0) * ccw(l[0], l[1], s[1], 0) < 0)\n\t\t\t\t\tg.push_back(crosspoint(s, l));\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t\tG Voronoi(const vector<P> &p, const int t)const {\n\t\t\tG g = *this;\n\t\t\tREP(i, p.size())if(i!=t){\n\t\t\t\tconst P m = (p[t]+p[i])*0.5;\n\t\t\t\tg = g.cut(L(m, m+(p[i]-p[t])*P(0, 1)));\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t};\n\n\tinline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\tBOOL intersect(const S &s, const S &t){\n\t\tconst int p = ccw(t[0], t[1], s[0], 1) * ccw(t[0], t[1], s[1], 1);\n\t\tconst int q = ccw(s[0], s[1], t[0], 1) * ccw(s[0], s[1], t[1], 1);\n\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t}\n\tBOOL intersect(const S &s, const L &l){\n\t\tif(l.online(s[0]) || l.online(s[1])) return BORDER;\n\t\treturn (sig(outp(l.dir(), s[0]-l[0])) * sig(outp(l.dir(), s[1]-l[0])) <= 0);\n\t}\n\tR dist2(const L &l, const P &p){return norm(outp(l.dir(), p - l[0])) / norm(l.dir());}\n\tR dist2(const S &s, const P &p){\n\t\tif(inp(p-s[0],  s.dir()) < EPS) return norm(p - s[0]);\n\t\tif(inp(p-s[1], -s.dir()) < EPS) return norm(p - s[1]);\n\t\treturn dist2((const L &)s, p);\n\t}\n\tR dist2(const S &s, const L &l){\n\t\treturn intersect(s, l) ? .0 : min(dist2(l, s[0]), dist2(l, s[1]));\n\t}\n\tR dist2(const S &s, const S &t){\n\t\treturn intersect(s, t) ? .0 : min(min(dist2(s, t[0]), dist2(t, s[0])), \n\t\t\t\t\t\t\t\t\t   \t  min(dist2(s, t[1]), dist2(t, s[1])));\n\t}\n\ttemplate <class T> R dist2(const G &g, const T& t){ // todo: 内部に完全に含まれる場合\n\t\tR res = INF;\n\t\tREP(i, g.size()) res = min(res, dist2(g.edge(i), t));\n\t\treturn res;\n\t}\n\ttemplate<class S, class T> R dist(const S& s, const T& t){return sqrt(dist2(s, t));}\n\tinline BOOL intersect(const C &a, const C &b){\n\t\treturn less((a.r-b.r)*(a.r-b.r), norm(a-b)) + less(norm(a-b), (a.r+b.r)*(a.r+b.r)) - 1;\n\t}\n\tinline BOOL intersect(const C &c, const L &l){\n\t\treturn less(dist2(l, c), c.r*c.r);\n\t}\n\tinline BOOL intersect(const C &c, const S &s){\n\t\tint d = less(dist2(s, c), c.r*c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S crosspoint(const C &c1, const C &c2){\n\t\tif(!intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tinline P crosspoint(const L &l, const L &m){\n\t\tR A = outp(l.dir(), m.dir()), B = outp(l.dir(), l[1] - m[0]);\n\t\tif(!sig(abs(A)) && !sig(abs(B))) return m[0]; // same line\n\t\tif(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\t\treturn m[0] + B / A * (m[1] - m[0]);\n\t}\n\tinline R commonarea(const C &a, const C &b){\n\t\tif(less(norm(a-b), (a.r-b.r)*(a.r-b.r)) == TRUE) return min(a.r*a.r, b.r*b.r)*PI;\n\t\tif(less((a.r+b.r)*(a.r+b.r), norm(a-b)) == TRUE) return .0;\n\t\tdouble d = abs(a-b);\n\t\tdouble rc = (d*d + a.r*a.r - b.r*b.r) / (2*d);\n\t\tdouble theta = acos(rc / a.r);\n\t\tdouble phi = acos((d - rc) / b.r);\n\t\treturn a.r*a.r*theta + b.r*b.r*phi - d*a.r*sin(theta);\n\t}\n\tstruct Arrangement{\n\t\tstruct AEdge{\n\t\t\tint u, v, t;\n\t\t\tR cost;\n\t\t\tAEdge(int u=0, int v=0, int t=0, R cost=0)\n\t\t\t\t:u(u), v(v), t(t), cost(cost){}\n\t\t};\n\t\ttypedef vector<vector<AEdge>> AGraph;\n\t\tvector<P> p;\n\t\tAGraph g;\n\t\tArrangement(){}\n\t\tArrangement(vector<S> seg){\n\t\t\tint m = seg.size();\n\t\t\tREP(i, m){\n\t\t\t\tp.push_back(seg[i][0]);\n\t\t\t\tp.push_back(seg[i][1]);\n\t\t\t\tREP(j, i) if(sig(outp(seg[i].dir(), seg[j].dir())) && intersect(seg[i], seg[j]) == TRUE)\n\t\t\t\t\tp.push_back(crosspoint(seg[i], seg[j]));\n\t\t\t}\n\t\t\tsort(ALL(p)); UNIQUE(p);\n\t\t\tint n=p.size();\n\t\t\tg.resize(n);\n\t\t\tREP(i, m){\n\t\t\t\tS &s = seg[i];\n\t\t\t\tvector<pair<R, int>> ps;\n\t\t\t\tREP(j, n) if(s.online(p[j])) ps.emplace_back(norm(p[j] - s[0]), j);\n\t\t\t\tsort(ALL(ps));\n\t\t\t\tREP(j, (int)ps.size()-1){\n\t\t\t\t\tconst int u=ps[j].second;\n\t\t\t\t\tconst int v=ps[j+1].second;\n\t\t\t\t\tg[u].emplace_back(u, v, 0, abs(p[u] - p[v]));\n\t\t\t\t\tg[v].emplace_back(v, u, 0, abs(p[u] - p[v]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint getIdx(P q){\n\t\t\tauto it = lower_bound(ALL(p), q);\n\t\t\tif(it == p.end() || *it != q) return -1;\n\t\t\treturn it - p.begin();\n\t\t}\n\t};\n\n\tstruct min_ball {\n\t\tP center;\n\t\tR radius2;\n\t\tmin_ball(const vector<P>& p) {\n\t\t\tFOR(it, p) ps.push_back(*it);\n\t\t}\n\t\tmin_ball& compile() {\n\t\t\tm = 0;\n\t\t\tcenter = P(0, 0);\n\t\t\tradius2 = -1;\n\t\t\tmake_ball(ps.end());\n\t\t\treturn *this;\n\t\t}\n\tprivate:\n\t\tlist<P> ps;\n\t\tlist<P>::iterator supp_end;\n\t\tint m;\n\t\tP v[3], c[3];\n\t\tR z[3], r[3];\n\t\tvoid pop() { --m; }\n\t\tvoid push(const P& p) {\n\t\t\tif (m == 0) {\n\t\t\t\tc[0] = p; r[0] = 0;\n\t\t\t} else {\n\t\t\t\tR e = norm(p-c[m-1]) - r[m-1];\n\t\t\t\tP delta = p - c[0];\n\t\t\t\tv[m] = p - c[0];\n\t\t\t\tfor (int i = 1; i < m; ++i)\n\t\t\t\t\tv[m] -= v[i] * inp(v[i], delta) / z[i];\n\t\t\t\tz[m] = inp(v[m], v[m]);\n\t\t\t\tc[m] = c[m-1] + e*v[m]/z[m]*.5;\n\t\t\t\tr[m] = r[m-1] + e*e/z[m]*.25;\n\t\t\t}\n\t\t\tcenter\t= c[m];\n\t\t\tradius2 = r[m]; ++m;\n\t\t}\n\t\tvoid make_ball(list<P>::iterator i) {\n\t\t\tsupp_end = ps.begin();\n\t\t\tif (m == 3) return;\n\t\t\tfor (list<P>::iterator k = ps.begin(); k != i; ) {\n\t\t\t\tlist<P>::iterator j = k++;\n\t\t\t\tif (norm(*j-center) > radius2) {\n\t\t\t\t\tpush(*j); make_ball(j); pop();\n\t\t\t\t\tmove_to_front(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvoid move_to_front(list<P>::iterator j) {\n\t\t\tif (supp_end == j) ++supp_end;\n\t\t\tps.splice (ps.begin(), ps, j);\n\t\t}\n\t};\n\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const P &a, const P &b){return sig(a.X-b.X) ? a.X < b.X : a.Y < b.Y;}\n\tbool operator==(const P &a, const P &b){return !sig(norm(a-b));}\n\tistream& operator>>(istream &is, P &p){R x,y;is>>x>>y;p=P(x, y);return is;}\n\tistream& operator>>(istream &is, L &l){l.resize(2);return is >> l[0] >> l[1];}\n\tistream& operator>>(istream &is, C &c){return is >> (P &)c >> c.r;}\n}\n\n\nint n, m;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n, n){\n\t\tvector<P> p(n);\n\t\tREP(i, n) cin >> p[i];\n\t\tvector<P> cand;\n\t\tREP(i, n){\n\t\t\tREP(j, i)if(norm(p[j]-p[i])<4.+EPS){\n\t\t\t\tP m = (p[j]+p[i])*.5;\n\t\t\t\tR l = sqrt(4-norm(p[j]-p[i]))*.5;\n\t\t\t\tcand.push_back(m + unit(p[j]-p[i])*P(0,  1)*l);\n\t\t\t\tcand.push_back(m + unit(p[j]-p[i])*P(0, -1)*l);\n\t\t\t}\n\t\t}\n\t\tsort(ALL(cand));UNIQUE(cand);\n\t\tint ans = 1;\n\t\tFOR(q, cand) ans = max(ans, (int)count_if(ALL(p), [&](const P &p) { return norm(p-*q)<1.+EPS; }));\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nclass Point {\npublic:\n  double x, y;\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n  Point operator +(Point p) {\n    return Point(x+p.x, y+p.y);\n  }\n  Point operator -(Point p) {\n    return Point(x-p.x, y-p.y);\n  }\n  Point operator *(double a) {\n    return Point(x*a, y*a);\n  }\n  Point operator /(double a) {\n    return Point(x/a, y/a);\n  }\n  bool operator ==(const Point &p) const {\n    return x == p.x && y == p.y;\n  }\n  bool operator <(const Point &p) const {\n    double l1 = x+y;\n    double l2 = p.x+p.y;\n    if(l1 != l2) return l1 < l2;\n    if(y != p.y) return y < p.y;\n    return x < p.x;\n  }\n};\n\ntypedef Point Vector;\n\ndouble norm(Point p1, Point p2) {\n  return (p1.x-p2.x)*(p1.x-p2.x) + (p1.y-p2.y)*(p1.y-p2.y);\n}\n\nint n;\nPoint p[300];\n\nint calc(Point p1, Point p2) {\n  Point m = Point((p1.x+p2.x)/2.0, (p1.y+p2.y)/2.0);\n  Point o;\n  Vector moto = Vector(p2.y-p1.y, p1.x-p2.x);\n  int cnt = 0;\n  int newCnt;\n  double p1p2 = norm(p1,p2);\n  if(p1p2 > 4) return 1;\n  double l = sqrt(4.0/p1p2-1)/2.0;\n\n  for(int t = 0; t < 2; t++) {\n    newCnt = 0;\n    if(t == 1) {\n      moto = moto * (-1);\n    }\n    o = m + moto * l;\n\n    for(int i = 0; i < n; i++) {\n      if(newCnt + n-i <= cnt) break;\n      if(p[i] == p1 || p[i] == p2) continue;\n      if((p[i].x-o.x)*(p[i].x-o.x) + (p[i].y-o.y)*(p[i].y-o.y) <= 1.0) {\n\tnewCnt++;\n      }\n    }\n    if(newCnt > cnt) cnt = newCnt;\n  }\n  return cnt + 2;\n}\n\nmain() {\n  while(1) {\n    int ans;\n    cin >> n;\n    if(n == 0) break;\n    for(int i = 0; i < n; i++) {\n      cin >> p[i].x >> p[i].y;\n    }\n    sort(p, &p[n]);\n    ans = 1;\n    for(int i = 0; i < n; i++) {\n      for(int j = i+1; j < n; j++) {\n\tans = max(ans, calc(p[i],p[j]));\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nvoid calc(double x1,double y1,double x2,double y2,double *c_x1,double *c_y1,double *c_x2,double *c_y2){\n  double midx,midy,hox,hoy,dx,dy,dis;\n  midx = (x1+x2) / 2 , midy = (y1+y2) / 2;\n  dx = x1-x2 , dy = y1-y2;\n  dis = sqrt(1 - pow(x1-midx,2) - pow(y1-midy,2));\n  hox = sqrt(pow(dy,2) / (pow(dy,2) + pow(dx,2)));\n  hoy = hox * (-1) * (dx / dy);\n  *c_x1 = midx + hox*dis,*c_y1 = midy + hoy*dis;\n  *c_x2 = midx - hox*dis,*c_y2 = midy - hoy*dis;\n}\n\nint main(){\n  int N;\n\n  while(cin >> N){\n    double x[300],y[300],c_x1,c_y1,c_x2,c_y2;\n    int count,m;\n    m = 0;\n    if(!(N)) break;\n    for(int i=0;i<N;i++) cin >> x[i] >> y[i];\n\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n        if(i == j) continue;\n        if((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]) > 4.0 ) continue;\n        count = 2;\n        calc(x[i],y[i],x[j],y[j],&c_x1,&c_y1,&c_x2,&c_y2);\n        for(int k=0;k<N;k++){\n          if(k == i || k == j) continue;\n          if((x[k] - c_x1)*(x[k] - c_x1) + (y[k] - c_y1)*(y[k] - c_y1) <= 1.0  ) count++;\n        }\n        if(m < count) m = count;\n        count = 2;\n        for(int k=0;k<N;k++){\n          if(k == i || k == j) continue;\n          if((x[k] - c_x2)*(x[k] - c_x2) + (y[k] - c_y2)*(y[k] - c_y2) <= 1.0  ) count++;\n        }\n        if(m < count) m = count;\n      }\n    }\n\n    printf(\"%d\\n\",m);\n  }\n\n  return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 1000000000\n#define sz(x) ((int)(x).size())\n#define sq(x) ((x)*(x))\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ndouble add(double a,double b){\n\tif(abs(a+b)<eps*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{\n\tdouble x,y;\n\tP() {}\n\tP(double x,double y) : x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tdouble dot(P p){\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tdouble norm(){\n\t\treturn sqrt(x*x+y*y);\n\t}\n\tdouble dist2(P p){\n\t\treturn sq(x-p.x)+sq(y-p.y);\n\t}\n\tP vert(){\n\t\treturn P(y,-x);\n\t}\n\tvoid dump(){\n\t\tprintf(\"%.12f %.12f\\n\",x,y);\n\t\treturn;\n\t}\n};\nint N;\nP pts[305];\nint solve(){\n\tscanf(\"%d\",&N);\n\tif(N==0)return 1;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%lf %lf\",&pts[i].x,&pts[i].y);\n\t}\n\tint ans = 0;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tP m = (pts[i]+pts[j])*0.5;\n\t\t\tP a = (pts[i]-pts[j]);\n\t\t\tdouble na = a.norm();\n\t\t\tif(na>2.0)continue;\n\t\t\ta = (a.vert())*(1/na);\n\t\t\ta = a*(sqrt(1-sq(na/2.0)));\n\t\t\tP b = m+a;\n\t\t\tP c = m-a;\n\t\t\t/*cout << i << ' ' << j << endl;\n\t\t\tm.dump();\n\t\t\ta.dump();\n\t\t\tb.dump();\n\t\t\tc.dump();\n\t\t\tcout << endl;*/\n\t\t\tint cnt = 0;\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t//printf(\"%d:%.12f\\n\",k,pts[k].dist2(b));\n\t\t\t\tif(pts[k].dist2(b)<=1.0)cnt++;\n\t\t\t}\n\t\t\tans = max(ans,cnt);\n\t\t\tcnt = 0;\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t//printf(\"%d:%.12f\\n\",k,pts[k].dist2(c));\n\t\t\t\tif(pts[k].dist2(c)<=1.0)cnt++;\n\t\t\t}\n\t\t\tans = max(ans,cnt);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\nint main(){\n\twhile(!solve()){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nvoid calc(double x1,double y1,double x2,double y2,double *c_x1,double *c_y1,double *c_x2,double *c_y2){\n  double midx,midy,hox,hoy,dx,dy,dis;\n  midx = (x1+x2) / 2.0 , midy = (y1+y2) / 2.0;\n  dx = x1-x2 , dy = y1-y2;\n  dis = sqrt(1 - pow(x1-midx,2.0) - pow(y1-midy,2.0));\n  hox = sqrt(pow(dy,2.0) / (pow(dy,2.0) + pow(dx,2.0)));\n  hoy = hox * (-1.0) * (dx / dy);\n  *c_x1 = midx + hox*dis,*c_y1 = midy + hoy*dis;\n  *c_x2 = midx - hox*dis,*c_y2 = midy - hoy*dis;\n}\n\nint main(){\n  int N;\n\n  while(cin >> N){\n    double x[300],y[300],c_x1,c_y1,c_x2,c_y2;\n    int count,m;\n    m = 0;\n    if(!(N)) break;\n    for(int i=0;i<N;i++) cin >> x[i] >> y[i];\n\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n        if(i == j) continue;\n        if((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]) >= 4.0 ) continue;\n        count = 2;\n        calc(x[i],y[i],x[j],y[j],&c_x1,&c_y1,&c_x2,&c_y2);\n        for(int k=0;k<N;k++){\n          if(k == i || k == j) continue;\n          if((x[k] - c_x1)*(x[k] - c_x1) + (y[k] - c_y1)*(y[k] - c_y1) <= 1.0  ) count++;\n        }\n        if(m < count) m = count;\n        count = 2;\n        for(int k=0;k<N;k++){\n          if(k == i || k == j) continue;\n          if((x[k] - c_x2)*(x[k] - c_x2) + (y[k] - c_y2)*(y[k] - c_y2) <= 1.0  ) count++;\n        }\n        if(m < count) m = count;\n      }\n    }\n\n    printf(\"%d\\n\",m);\n  }\n\n  return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nconst double EPS = 1e-8;\n\nint n;\nPoint data[300];\n\nint calc(Point& a, Point& b){\n  int res = 0;\n  double d = abs(b - a) / 2.0;\n  Point ab = (b - a) / (2.0 * d);\n  if(d < 1){\n    Point o = ab * d;\n    d = sqrt(1.0 - d * d);\n    o += Point(d * ab.imag() + a.real(), -d * ab.real() + a.imag());\n    for(int i=0;i<n;i++) if(abs(o - data[i]) < 1.0 + EPS) res++;\n  }\n  return res;\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++) cin >> data[i].imag() >> data[i].real();\n    int ans = 1;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n        ans = max(ans, calc(data[i], data[j]));\n        ans = max(ans, calc(data[j], data[i]));\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\ntypedef complex<double> pt;\ntypedef pair<pt,pt> L;\ntypedef vector<P> poly;\nconst double EPS = 1e-15;\n#define x real()\n#define y imag()\n \ndouble dot(pt a,pt b){\n\treturn (conj(a)*b).x;\n}\ndouble cross(pt a,pt b){\n\treturn (conj(a)*b).y;\n}\nint ccw(pt a,pt b,pt c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > EPS) return 1; // counter clockwise\n\tif(cross(b,c) < -EPS) return -1; // clockwise\n\tif(dot(b,c) < -EPS) return 2; //c-a-b\n\tif(norm(b) < norm(c)) return -2; //a-b-c\n\treturn 0; //a-c-b\n}\nbool cmp(const pt& a,const pt& b){\n\tif(-EPS < a.x-b.x && a.x-b.x < EPS) return a.y < b.y;\n\telse return a.x < b.x;\n}\nvector<pt>convex_hull(vector<pt>ps)\n{\n\tsort(ps.begin(),ps.end(),cmp);\n\tint k=0,n = ps.size();\n\tvector<pt>qs(n*2);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\twhile(k>1 && ccw(qs[k-2],qs[k-1],ps[i]) == -1) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tfor(int i=n-2,t=k;i>=0;i--)\n\t{\n\t\twhile(k>t && ccw(qs[k-2],qs[k-1],ps[i]) == -1) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\npt intersect(pt a,pt b,pt c,pt d){\n\tdouble dev = (b.y-a.y)*(d.x-c.x)-(b.x-a.x)*(d.y-c.y);\n\t\n\tdouble d1, d2;\n \n\td1 = (c.y*d.x-c.x*d.y);\n\td2 = (a.y*b.x-a.x*b.y);\n \n\tpt ap1;\n\tap1.x = d1*(b.x-a.x) - d2*(d.x-c.x);\n\tap1.x /= dev;\n\tap1.y = d1*(b.y-a.y) - d2*(d.y-c.y);\n\tap1.y /= dev;\n \n\treturn ap1;\n}\nbool par(pt a,pt b,pt c,pt d){\n\tb.x -= a.x; b.y -= a.y;\n\td.x -= c.x; d.y -= c.y;\n\tif(abs(b.y*d.x - b.x*d.y) < EPS){\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ndouble PI = 3.1415926535897932;\nint main(){\n\twhile(1){\n\t\tint n; scanf(\"%d\",&n); if(!n) return 0; \n\t\tpt p[305];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tdouble a,b; scanf(\"%lf%lf\",&a,&b);\n\t\t\tp[i] = pt(a,b);\n\t\t}\n\t\tint ans = 1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=i+1;j<=n;j++){\n\t\t\t\tpt q = (p[i]+p[j])/2.0;\n\t\t\t\tpt r = (p[i]-p[j]); if(abs(r) >= 2.0) continue;\n\t\t\t\tpt p1 = q + r / abs(r) * polar(sqrt(1.0-abs(r)*abs(r)/4.0),PI/2);\n\t\t\t\tpt p2 = q - r / abs(r) * polar(sqrt(1.0-abs(r)*abs(r)/4.0),PI/2);\n\t\t\t\tint c=0,d=0;\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tif(k==i || k==j || abs(p1-p[k]) <= 1.0+EPS) c++;\n\t\t\t\t\tif(k==i || k==j || abs(p2-p[k]) <= 1.0+EPS) d++;\n\t\t\t\t}\n\t\t\t\tans = max(ans,max(c,d));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<unordered_map>\n#include<stack>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#include<complex>\nusing namespace std;\n\n/**** Type Define ****/\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> Q;\ntypedef complex<double> C;\n\n/**** Macro Define ****/\n\n#define cx real()\n#define cy imag()\n\n/**** Const List   ****/\n\nconst ll INF = 1LL << 60;\nconst ll mod = 1000000007;\nconst ll MAX_FLOW_MAX_V = 10000;\nconst ll MIN_COST_FLOW_MAX_V = 10000;\nconst ll BIPARTITE_MATCHING_MAX_V = 10000;\nconst ll dx[4] = {1, 0, -1, 0};\nconst ll dy[4] = {0, -1, 0, 1};\nconst C I = C(0, 1);\nconst double EPS = 1e-10;\n\n/**** General Functions ****/\n\ntemplate <typename T>\nT tmin(T a, T b) { return a > b ? b : a; };\n\ntemplate <typename T>\nT tmax(T a, T b) { return a > b ? a : b; };\n\ntemplate <typename T>\nT tadd(T a, T b) { return a + b; };\n\ntemplate <typename T>\nT tmul(T a, T b) { return a * b; };\n\ntemplate <typename T>\nT tpow(T a, T b) { return a * b; };\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y) {\n  if (b == 0) {\n    x = 1, y = 0; return a;\n  }\n  ll q = a/b, g = extgcd(b, a - q*b, x, y);\n  ll z = x - q * y;\n  x = y;\n  y = z;\n  return g;\n}\n\nll invmod (ll a, ll m) { // a^-1 mod m\n  ll x, y;\n  extgcd(a, m, x, y);\n  x %= m;\n  if (x < 0) x += m;\n  return x;\n}\n\nll nCk(ll n, ll k, ll mod) {\n  ll ans = 1;\n  for (ll i = n, j = 1; j <= k; i--, j++) ans = (((ans * i) % mod) * invmod(j, mod)) % mod;\n  return ans;\n}\n\nll lmin(ll a, ll b) { return a > b ? b : a; };\n\nll lmax(ll a, ll b) { return a > b ? a : b; };\n\nll lsum(ll a, ll b) { return a + b; };\n\n/**** Matrix ****/\n\ntemplate <typename T>\nstruct Matrix {\n  typedef vector<T> vec;\n  typedef vector<vec> mat;\n  ll x, y; // x: horizon  y: vertical\n  mat d;\n\n  Matrix(ll _y, ll _x = -1) {\n    if (_x == -1) _x = _y;\n    x = _x, y = _y;\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) d[i][j] = 0;\n  }\n  void unit() {\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) d[i][j] = i == j ? 1 : 0;\n  }\n  Matrix copy() {\n    Matrix m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j];\n    return m;\n  }\n  Matrix<T> operator + (Matrix<T>& t) { // No error check! Don't forget to check Matrix size!!\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j] + t.d[i][j];\n    return m;\n  }\n  Matrix<T> operator - (Matrix<T>& t) {\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j] - t.d[i][j];\n    return m;\n  }\n  Matrix<T> operator * (T t) {\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j] * t;\n    return m;\n  }\n  Matrix<T> det(Matrix<T>& t) { // x need to correspond to t.y\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++)\n      for (int j = 0; j < x; j++)\n        for (int k = 0; k < t.x; k++) m.d[i][j] += d[i][k] * t.d[k][j]; ////////////// mod???\n    return m;\n  }\n};\n\n/**** Zip ****/\n\ntemplate <typename T>\nclass Zip {\n  vector<T> d;\n  bool flag;\npublic:\n  Zip() {\n    flag = false;\n  }\n  void add(T x) {\n    d.push_back(x);\n    flag = true;\n  }\n  ll getNum(T x) { // T need to have operator < !!\n    if (flag) {\n      sort(d.begin(), d.end());\n      d.erase(unique(d.begin(), d.end()), d.end());\n      flag = false;\n    }\n    return lower_bound(d.begin(), d.end(), x) - d.begin();\n  }\n  ll size() {\n    if (flag) {\n      sort(d.begin(), d.end());\n      d.erase(unique(d.begin(), d.end()), d.end());\n      flag = false;\n    }\n    return (ll)d.size();\n  }\n};\n\n/**** Union Find ****/\n\nclass UnionFind {\n  vector<ll> par, rank; // par > 0: number, par < 0: -par\npublic:\n  void init(ll n) {\n    par.resize(n, 1); rank.resize(n, 0);\n  }\n  ll getSize(ll x) {\n    return par[find(x)];\n  }\n  ll find(ll x) {\n    if (par[x] > 0) return x;\n    return -(par[x] = -find(-par[x]));\n  }\n  void merge(ll x, ll y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) {\n      par[y] += par[x];\n      par[x] = -y;\n    } else {\n      par[x] += par[y];\n      par[y] = -x;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  bool isSame(ll x, ll y) {\n    return find(x) == find(y);\n  }\n};\n\ntemplate <typename T>\nstruct UnionFindT {\n  vector<ll> par;\n  vector<ll> rank;\n  vector<T> diff_weight;\n\n  UnionFindT(ll n = 1, T SUM_UNITY = 0) {\n    init(n, SUM_UNITY);\n  }\n\n  void init(ll n = 1, T SUM_UNITY = 0) {\n    par.resize(n); rank.resize(n); diff_weight.resize(n);\n    for (ll i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n  }\n\n  ll find(ll x) {\n    if (par[x] == x) {\n      return x;\n    }\n    else {\n      ll r = find(par[x]);\n        diff_weight[x] += diff_weight[par[x]];\n        return par[x] = r;\n    }\n  }\n\n  T weight(ll x) {\n    find(x);\n    return diff_weight[x];\n  }\n\n  bool isSame(ll x, ll y) {\n    return find(x) == find(y);\n  }\n\n  bool merge(ll x, ll y, T w) {\n    w += weight(x); w -= weight(y);\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (rank[x] < rank[y]) swap(x, y), w = -w;\n    if (rank[x] == rank[y]) ++rank[x];\n    par[y] = x;\n    diff_weight[y] = w;\n    return true;\n  }\n\n  T diff(ll x, ll y) {\n    return weight(y) - weight(x);\n  }\n};\n\nclass PersistentUnionFind {\n  vector<ll> rank, fin, par;\n  ll index;\npublic:\n  void init(ll n) {\n    index = 0;\n    par.resize(n); rank.resize(n, 1); fin.resize(n, 0);\n    for (ll i = 0; i < n; i++) par[i] = i;\n  }\n  ll find(ll x, ll t) {\n    if (t >= fin[x] && par[x] != x) return find(par[x], t);\n    return x;\n  }\n  void merge(ll x, ll y) {\n    x = find(x, index);\n    y = find(y, index);\n    index++;\n    if (x == y) return;\n    if (rank[x] < rank[y]) par[x] = y, fin[x] = index;\n    else {\n      par[y] = x, fin[y] = index;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  bool isSame(ll x, ll y, ll t) { return find(x, t) == find(y, t); }\n};\n\n/**** Segment Tree ****/\n\ntemplate <typename T>\nclass SegmentTree {\n  ll n;\n  vector<T> node;\n  function<T(T, T)> fun, fun2;\n  bool customChange;\n  T outValue, initValue;\npublic:\n  void init(ll num, function<T(T, T)> resultFunction, T init, T out, function<T(T, T)> changeFunction = NULL) {\n    // changeFunction: (input, beforevalue) => newvalue\n    fun = resultFunction;\n    fun2 = changeFunction;\n    customChange = changeFunction != NULL;\n    n = 1;\n    while (n < num) n *= 2;\n    node.resize(2 * n - 1, init);\n    outValue = out;\n    initValue = init;\n  }\n  void valueChange(ll num, T value) {\n    num += n-1;\n    if (customChange) node[num] = fun2(value, node[num]);\n    else node[num] = value;\n    while (num > 0) num = (num - 1) / 2, node[num] = fun(node[num * 2 + 1], node[num * 2 + 2]);\n  }\n  T rangeQuery(ll a, ll b, ll l = 0, ll r = -1, ll k = 0) { // [a, b)\n    if (r == -1) r = n;\n    if (a <= l && r <= b) return node[k];\n    if (b <= l || r <= a) return outValue;\n    ll mid = (l + r) / 2;\n    return fun(rangeQuery(a, b, l, mid, 2*k+1), rangeQuery(a, b, mid, r, 2*k+2));\n  }\n};\n\ntemplate <typename T>\nclass LazySegmentTree {\n  ll n;\n  vector<T> node;\n  vector<T> lazyNode;\n  function<T(T, T)> fun, fun2;\n  function<T(T, ll)> fun3;\n  T outValue, initValue;\n  T substitution(T a, T b) { return a; }\n  void eval(ll k, ll l, ll r) {\n    if (lazyNode[k] == 0) return;\n    node[k] = fun2(fun3(lazyNode[k], r - l), node[k]);\n    if (r - l > 1) {\n      lazyNode[2 * k + 1] = fun2(lazyNode[k], lazyNode[2 * k + 1]);\n      lazyNode[2 * k + 2] = fun2(lazyNode[k], lazyNode[2 * k + 2]);\n    }\n    lazyNode[k] = initValue;\n  }\npublic:\n  void init(ll num, function<T(T, T)> resultFunction, function<T(T, T)> changeFunction, function<T(T, ll)> lazyFunction, T init, T out) {\n    // changeFunction: (input, beforevalue) => newvalue\n    // lazyFunction: (lazyNode, diff) => newvalue\n    fun = resultFunction;\n    fun2 = changeFunction;\n    fun3 = lazyFunction;\n    n = 1;\n    while (n < num) n *= 2;\n    node.resize(2 * n - 1, init);\n    lazyNode.resize(2 * n - 1, init);\n    outValue = out;\n    initValue = init;\n  }\n  void rangeChange(ll a, ll b, T value, ll l = 0, ll r = -1, ll k = 0) {\n    if (r == -1) r = n;\n    eval(k, l, r);\n    if (b <= l || r <= a) return;\n    if (a <= l && r <= b) {\n      lazyNode[k] = fun2(value, lazyNode[k]);\n      eval(k, l, r);\n    } else {\n      ll mid = (l + r) / 2;\n      rangeChange(a, b, value, l, mid, 2*k+1);\n      rangeChange(a, b, value, mid, r, 2*k+2);\n      node[k] = fun(node[2*k+1], node[2*k+2]);\n    }\n  }\n  T rangeQuery(ll a, ll b, ll l = 0, ll r = -1, ll k = 0) { // [a, b)\n    if (r == -1) r = n;\n    if (b <= l || r <= a) return outValue;\n    eval(k, l, r);\n    if (a <= l && r <= b) return node[k];\n    ll mid = (l + r) / 2;\n    return fun(rangeQuery(a, b, l, mid, 2*k+1), rangeQuery(a, b, mid, r, 2*k+2));\n  }\n};\n\n/**** Network Flow ****/\n\nclass MaxFlow {\npublic:\n  struct edge { ll to, cap, rev; };\n\n  vector<edge> G[MAX_FLOW_MAX_V];\n  bool used[MAX_FLOW_MAX_V];\n  ll level[MAX_FLOW_MAX_V];\n  ll iter[MAX_FLOW_MAX_V];\n  \n  void init() {\n    for (ll i = 0; i < MAX_FLOW_MAX_V; i++) {\n      G[i].clear();\n    }\n  }\n  void add_edge(ll from, ll to, ll cap) {\n    G[from].push_back((edge){to, cap, (ll)G[to].size()});\n    G[to].push_back((edge){from, 0, (ll)G[from].size() - 1});\n  }\n  void add_undirected_edge(ll e1, ll e2, ll cap) {\n    G[e1].push_back((edge){e2, cap, (ll)G[e2].size()});\n    G[e2].push_back((edge){e1, cap, (ll)G[e1].size() - 1});\n  }\n  ll dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (ll i = 0; i < (ll)G[v].size(); i++) {\n      edge &e = G[v][i];\n      if (!used[e.to]&& e.cap > 0) {\n        ll d = dfs(e.to, t, min(f, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  ll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while (1) {\n      memset(used, 0, sizeof(used));\n      ll f = dfs(s, t, INF);\n      if (f == 0) return flow;\n      flow += f;\n    }\n  }\n  void bfs(ll s) {\n    memset(level, -1, sizeof(level));\n    queue<ll> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n      ll v = que.front(); que.pop();\n      for (ll i = 0; i < (ll)G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n  ll dinic_dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    for (ll &i= iter[v]; i < (ll)G[v].size(); i++) {\n      edge &e = G[v][i];\n      if (e.cap > 0 && level[v] < level[e.to]) {\n        ll d = dinic_dfs(e.to, t, min(f, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  ll dinic(ll s, ll t) {\n    ll flow = 0;\n    while (1) {\n      bfs(s);\n      if (level[t] < 0) return flow;\n      memset(iter, 0, sizeof(iter));\n      ll f;\n      while ((f = dinic_dfs(s, t, INF)) > 0) {\n        flow += f;\n      }\n    }\n  }\n};\n\n/**** bipartite matching ****/\n\nclass BipartiteMatching {\npublic:\n  ll V;\n  vector<ll> G[BIPARTITE_MATCHING_MAX_V];\n  ll match[BIPARTITE_MATCHING_MAX_V];\n  bool used[BIPARTITE_MATCHING_MAX_V];\n  \n  BipartiteMatching(ll v) {\n    V = v;\n  }\n  void init(ll v) {\n    V = v;\n    for (ll i = 0; i < BIPARTITE_MATCHING_MAX_V; i++) {\n      G[i].clear();\n    }\n  }\n  void add_edge(ll u, ll v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  bool dfs(ll v) {\n    used[v] = true;\n    for (ll i = 0; i < (ll)G[v].size(); i++) {\n      ll u = G[v][i], w = match[u];\n      if (w < 0 || !used[w] && dfs(w)) {\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n  ll max_matching() {\n    ll res = 0;\n    memset(match, -1, sizeof(match));\n    for (ll v = 0; v < V;v++) {\n      if (match[v] < 0) {\n        memset(used, 0, sizeof(used));\n        if (dfs(v)) {\n          res++;\n        }\n      }\n    }\n    return res;\n  }\n};\n\nclass MinCostFlow {\npublic:\n  struct edge { ll to, cap, cost, rev; };\n\n  ll V;\n  vector<edge> G[MIN_COST_FLOW_MAX_V];\n  ll dist[MIN_COST_FLOW_MAX_V];\n  ll prevv[MIN_COST_FLOW_MAX_V];\n  ll preve[MIN_COST_FLOW_MAX_V];\n  ll h[MIN_COST_FLOW_MAX_V];\n\n  MinCostFlow(ll v) {\n    V = v;\n  }\n  void init() {\n    for (ll i = 0; i < MAX_FLOW_MAX_V; i++) {\n      G[i].clear();\n    }\n  }\n  void add_edge(ll from, ll to, ll cap, ll cost) {\n    G[from].push_back((edge){to, cap, cost, (ll)G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, (ll)G[from].size() - 1});\n  }\n  void add_undirected_edge(ll e1, ll e2, ll cap, ll cost) {\n    add_edge(e1, e2, cap, cost);\n    add_edge(e2, e1, cap, cost);\n  }\n  ll min_cost_flow(ll s, ll t, ll f) { // minas\n    ll res = 0;\n    while (f > 0) {\n      fill(dist, dist + V, INF);\n      dist[s] = 0;\n      bool update = true;\n      while (update) {\n        update = false;\n        for (ll v = 0; v < V; v++) {\n          if (dist[v] == INF) continue;\n          for (ll i = 0; i < (ll)G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n              dist[e.to] = dist[v] + e.cost;\n              prevv[e.to] = v;\n              preve[e.to] = i;\n              update = true;\n            }\n          }\n        }\n      }\n      if (dist[t] == INF) {\n        return -1;\n      }\n      ll d = f;\n      for (ll v = t; v != s; v = prevv[v]) {\n        d = min(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * dist[t];\n      for (ll v = t; v != s; v = prevv[v]) {\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n  ll min_cost_flow_dijkstra(ll s, ll t, ll f) {\n    ll res = 0;\n    fill(h, h + V, 0);\n    while (f > 0) {\n      priority_queue<P, vector<P>, greater<P> > que;\n      fill(dist, dist + V, 0);\n      dist[s] = 0;\n      que.push(P(0, s));\n      while (!que.empty()) {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if (dist[v] < p.first) continue;\n        for (int i = 0; i < G[v].size(); i++) {\n          edge &e = G[v][i];\n          if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n            dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            que.push(P(dist[e.to], e.to));\n          }\n        }\n      }\n      if (dist[t] == INF) {\n        return -1;\n      }\n      for (int v = 0; v < V; v++) h[v] += dist[v];\n      int d = f;\n      for (int v = t; v != s; v = prevv[v]) {\n        d = tmin<ll>(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * h[t];\n      for (int v = t; v != s; v = prevv[v]) {\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n      return res;\n    }\n    return 0;\n  }\n};\n\n/**** LIS ****/\nll lis(ll* a, ll n, ll* dp) {\n  fill(dp, dp + n, INF);\n  for (ll i = 0; i < n; i++) *lower_bound(dp, dp + n, a[i]) = a[i];\n  return (ll)(lower_bound(dp, dp + n, INF) - dp);\n}\n\n/**** Geometry ****/\n\ndouble lengthC(C a) { return abs(a); }\ndouble lengthC2(C a) { return a.cx * a.cx + a.cy * a.cy; }\nbool isEqual(double a, double b) { return abs(a - b) < EPS; }\nbool isCEqual(C a, C b) { return isEqual(a.cx, a.cy) && isEqual(a.cy, a.cy); }\nbool isZero(double a) { return abs(a) < EPS; } // a == 0\nbool isUZero(double a) { return a > EPS; } // a > 0\nbool isUEZero(double a) { return a > -EPS; } // a >= 0\nbool isLZero(double a) { return a < -EPS; } // a < 0\nbool isLEZero(double a) { return a < EPS; } // a <= 0\nC getUnitVector(C a) { double len = abs(a); return isZero(len) ? C(0.0, 0.0) : a / len; }\ndouble dot(C a, C b) { return a.cx * b.cx + a.cy * b.cy; } // |a||b|cosθ\ndouble det(C a, C b) { return a.cx * b.cy - a.cy * b.cx; } // |a||b|sinθ\nbool isLineOrthogonal(C a1, C a2, C b1, C b2) { return isZero(dot(a1 - a2, b1 - b2)); } // a1-a2, b1-b2\nbool isLineParallel(C a1, C a2, C b1, C b2) { return isZero(det(a1 - a2, b1 - b2)); } // a1-a2, b1-b2\nbool isPointOnLine(C a, C b, C c) { return isZero(det(b - a, c - a)); } // a-b <- c\nbool isPointOnLineSegment(C a, C b, C c) { // a-b <- c\n  return isZero(det(b - a, c - a)) && isUEZero(dot(b - a, c - a)) && isUEZero(dot(a - b, c - b));\n}\n// bool isPointOnLineSegment(C a, C b, C c) { return isZero(abs(a-c) + abs(c-b) - abs(a-b)); }\ndouble distanceLineAndPoint(C a, C b, C c) { return abs(det(b-a, c-a)) / abs(b-a); } // a-b <- c\ndouble distanceLineSegmentAndPoint(C a, C b, C c) { // a-b <- c\n  if (isLEZero(dot(b-a, c-a))) return abs(c-a);\n  if (isLEZero(dot(a-b, c-b))) return abs(c-b);\n  return abs(det(b-a, c-a)) / abs(b-a);\n}\nbool isIntersectedLine(C a1, C a2, C b1, C b2) { // a1-a2, b1-b2\n  return !isLineParallel(a1, a2, b1, b2);\n}\nC intersectionLine(C a1, C a2, C b1, C b2) { // isIntersectedLine-> true\n  C a = a2 - a1, b = b2 - b1;\n  return a1 + a * det(b, b1 - a1) / det(b, a);\n}\n\n/**** NG Words ****/\n// cx cy P Q C\n\n/**** main function ****/\n\nll n;\ndouble x, y;\nC c[300];\n\nint main() {\n  while (scanf(\"%lld\", &n), n) {\n    for (ll i = 0; i < n; i++) scanf(\"%lf%lf\", &x, &y), c[i] = C(x, y);\n    ll ans = 1;\n    for (ll i = 0; i < n; i++) {\n      for (ll j = 0; j < i; j++) {\n        C mid = (c[i] + c[j]) / 2.0;\n        C dir = c[i] - mid;\n        double len = 1.0 - lengthC2(dir);\n        if (isLZero(len)) continue;\n        C dir2 = sqrt(len) * dir * I / abs(dir);\n        for (ll x = 0; x <= 1; x++) {\n          C circleO = mid;\n          if (x == 0) circleO += dir2;\n          else circleO -= dir2;\n          ll temp = 0;\n          for (ll k = 0; k < n; k++) {\n            if (isUEZero(1.0 - lengthC2(c[k] - circleO))) temp++;\n          }\n          ans = lmax(ans, temp);\n        }\n      }\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n#define OUT 0\n#define ON 1\n#define IN 2\n#define EPS 0.00009\n//#define EPS (1e-10)\nclass P{                    //テァツつケ\npublic:\n\tdouble x,y;\n\t\n\tP(double _x=0,double _y=0):x(_x),y(_y){};\n\tP operator + (const P &p     )const{ return P( x+p.x , y+p.y ); }  //テ・ツ環?ァツョツ?\n\tP operator - (const P &p     )const{ return P( x-p.x , y-p.y ); }  //テヲツクツ崚ァツョツ?\n\tP operator * (const double k )const{ return P( x*k   , y*k    ); } //テ、ツケツ療ァツョツ?\n\tP operator / (const double k )const{ return P( x/k   , y/k    ); } //テゥツ卍、テァツョツ?\n\t\n\tbool operator == (const P &p){ return ( fabs(x-p.x)<EPS && fabs(y-p.y)<EPS ); }\n\tbool operator < (const P &p) const{ return ( x!=p.x ? x<p.x:y<p.y ); }\n\t\n\tdouble norm(){ return x*x+y*y; }        //テ」ツδ偲」ツδォテ」ツδ?\n\tdouble abs() { return sqrt(norm()); }   //テ・ツ、ツァテ」ツ?催」ツ??\n};\nstruct C{P p;double r;};    //テ・ツ??\nstruct S{P p1,p2;};         //テァツキツ堙・ツ按?\ntypedef vector<P> Polygon;  //テ・ツ、ツ堙ィツァツ津・ツスツ「\ntypedef P Vector;           //テ」ツδ凖」ツつッテ」ツδ暗」ツδォ\ntypedef S L;                //テァツ崢エテァツキツ?\n\ndouble norm (P p)               { return p.norm(); }\ndouble abs  (P p)               { return p.abs(); }\ndouble dot  (Vector a,Vector b) { return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b) { return a.x*b.y-a.y*b.x; }\ndouble sqDist(P a, P b)         {return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}\ndouble dist (P a, P b)          {return sqrt(sqDist(a,b));}\nVector vec(S a)                 {return P(a.p2.x-a.p1.x,a.p2.y-a.p1.y);}\n\nint ccw(P p0,P p1,P p2){    //AOJ_BOOK_P386 verified\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\t\n\tif( cross(a,b) > EPS  ) return 1 ;      //COUNTER_CLOCKWISE\n\tif( cross(a,b) < -EPS ) return -1;      //CLOCKWISE\n\tif( dot(a,b)   < -EPS ) return 2;       //ONLINE_BACK\n\tif( a.norm()   < b.norm() ) return -2;  //ONLINE_FRONT\n\t\n\treturn 0;                               //ON_SEGMENT;\n}\n\n//テァツ崢エテァツキツ堙ァツ崢エティツ。ツ古・ツ按、テ・ツョツ?verified AOJ0058\nbool orthogonal(P p1,P p2,P p3,P p4){ return abs(dot(p1-p2,p3-p4))<EPS; }\n\n//テァツキツ堙・ツ按?、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?\nbool intersect(P p1,P p2,P p3,P p4){ return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); }\n\n//テァツキツ堙・ツ按?」ツ?ィテァツつケテ」ツ?ョティツキツ敕ゥツ崢「 verified ARC042-B\ndouble dLP(S l, P p) { return abs(cross(l.p2-l.p1, p-l.p1)) /(l.p2-l.p1).abs(); }\n\n//テァツキツ堙・ツ按?」ツ?ォテ・ツッツセテ」ツ?凖」ツつ凝ァツつケテ」ツ?ョテ・ツーツ?・ツスツア verified AOJ CGL_1_A\nP project(S s, P p){\n\tVector base = s.p2-s.p1;\n\tdouble r = dot(p-s.p1, base)/norm(base);\n\treturn (base*r)+s.p1;\n}\n\n//テァツキツ堙・ツ按?」ツ?ォテ・ツッツセテ」ツ?凖」ツつ凝ァツつケテ」ツ?ョテ・ツ渉催・ツーツ?verified AOJ CGL_1_B\nP reflect(S s,P p){ return p+(project(s,p)-p)*2.0; }\n\n//テァツ崢エテァツキツ堙」ツ?ィテァツ崢エテァツキツ堙」ツ?ョテゥツ鳴「テ、ツソツ?verified AOJ CGL_2\nint rLL(L a,L b){\n\tif( cross(vec(a),vec(b))==0 ) return 2; //テ、ツクツヲティツ。ツ?\n\tif( dot(vec(a),vec(b))==0 )   return 1; //テ・ツ楪づァツ崢エ\n\treturn 0;\n}\n\n// テ・ツ??」ツ?ィテァツつケテ」ツ?ョテ・ツ??・ツ、ツ姪・ツ按、テ・ツョツ?\nint contains(C c, P p){\n\tdouble d = (c.p-p).abs();\n\tif(d-c.r>EPS) return OUT;\n\tif(abs(d-c.r)<EPS) return ON;\n\treturn IN;\n}\n\n//テァツ崢エテァツキツ堙」ツ?ィテ・ツ??」ツ?ョテ、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?テゥツ?催」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝・ツ?エテ・ツ青暗」ツ?ッテ、ツコツ、テ・ツキツョテヲツ可アテ」ツ??\nbool intersect_circle_(P center, double r, L line){\n\tif( dLP(line,center) <= r+EPS ) return true;\n\treturn false;\n}\n\n//テァツキツ堙・ツ按?」ツ?ィテ・ツコツ療」ツ?ョティツキツ敕ゥツ崢「 verified QUPC-G\ndouble dSP(S s, P p){\n\tif(dot((s.p2-s.p1)   , p-s.p1) <= EPS) return (p - s.p1).abs();\n\tif(dot((s.p2-s.p1)*-1, p-s.p2) <= EPS) return (p - s.p2).abs();\n\treturn dLP(s, p);\n}\n\n//テァツキツ堙・ツ按?」ツ?ィテ・ツ??」ツ?ョテ、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?テゥツ?催」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝・ツ?エテ・ツ青暗」ツ?ッテ、ツコツ、テ・ツキツョテヲツ可アテ」ツ?? verified QUPC-G\nbool iCS(C c, S l){\n\tint c1 = contains(c, l.p1);\n\tint c2 = contains(c, l.p2);\n\tif(c1 > c2) swap(c1, c2);\n\t\n\t// (OUT, OUT) (OUT, ON) (OUT, IN) (ON, ON) (ON, IN) (IN, IN) テ」ツ?ョ6テゥツ?堙」ツつ?\n\tif(c1 == OUT && c2 == IN) return true;\n\tif(c1 == IN  && c2 == IN) return false;\n\tif(c1 == ON) return true; // (テヲツ篠・テ」ツ?凖」ツつ凝」ツ?ィテ」ツ??\n\tdouble d = dSP(l, c.p);\n\tif(d-c.r<-EPS) return true;\n\tif(d-c.r>EPS) return false;\n\treturn true; // (テヲツ篠・テ」ツ?凖」ツつ凝」ツ?ィテ」ツ??\n}\n\n//テ・ツ債佚ァツエツ氾・ツ、ツ堙ィツァツ津・ツスツ「テ・ツ按、テ・ツョツ?\nbool isSimple( Polygon pol ){\n\t//テ・ツ按敕」ツつ?」ツ?ョテァツつケテ」ツつ津ゥツ?催ィツ、ツ?」ツ?療」ツ?ヲpolテ」ツ?ォテ・ツ?・テ」ツつ古」ツ?ヲテ」ツ?甘」ツ??\n\tsize_t pol_size = pol.size()-1;\n\trep(i,pol_size){\n\t\tfor(int j=i+2;j<pol_size;j++){\n\t\t\tif( i==j || i==(j-1+pol_size)%pol_size || i==(j+1+pol_size)%pol_size )continue;\n\t\t\tif( intersect(pol[i], pol[i+1], pol[j], pol[j+1]) )return false;\n\t\t}\n\t}\n\treturn true;\n}\n\n//テァツつケテ」ツ?古・ツ?クテ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ョテ・ツ??・ツ?エテ」ツ?ォテ」ツ?づ」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ?凝」ツつ津ヲツアツづ」ツつ?」ツつ?trueテ」ツ?ェテ」ツつ嘉・ツ??・ツ?エ verified AOJ0012\nint isPointInsidePolygon(vector<P> pol,P p){\n\tint c=0;\n\trep(i,pol.size()){\n\t\tif( cross(pol[i]-pol[(i+1)%pol.size()] , p-pol[(i+1)%pol.size()])==0 ) return ON;\n\t\tif( cross(pol[i]-pol[(i+1)%pol.size()] , p-pol[(i+1)%pol.size()])>0 ) c++;\n\t}\n\tif( c%pol.size() )return OUT;\n\treturn IN;\n}\n\n//テ・ツ??」ツ?ィテ・ツ?クテ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ョテ、ツコツ、テ・ツキツョテァツ環カテヲツ?凝」ツつ津ィツェツソテ」ツ?ケテ」ツつ?\nint CPOLarea(C c ,Polygon pol){\n\tvector<L> lines;\n\tvector<int> res(pol.size());\n\tbool POLinC=true, isFar=true;\n\t\n\trep(i,pol.size()){\n\t\tif( contains(c,pol[i])==OUT )POLinC=false;\n\t\tres[i] = contains(c,pol[i]);\n\t\tlines.pb( L{ pol[i] , pol[(i+1)%pol.size()] });\n\t\tif( sqDist(c.p,pol[i])<c.r*c.r )isFar=false;\n\t}\n\t\n\tif( POLinC )                                        return 2;   //テ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ッテ・ツ??」ツ?ョテ・ツ??ゥツδィb\n\tif( isPointInsidePolygon(pol, c.p)==IN && isFar )   return 3;   //テ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ョテ・ツ??ゥツδィテ」ツ?ォテ・ツ??\n\trep(i,lines.size()) if( iCS(c,lines[i]) )           return 1;   //テ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ィテ・ツ??」ツ?ッテ、ツコツ、テ・ツキツョc\n\treturn 0;\n}\n\n//テ・ツ?クテ・ツ個?verified AOJ0068,QUPC-G\n//ティツセツ榲ヲツ崢クテゥツ??」ツ?ァテヲツッツ氾ィツシツ?\nbool cmp_x(const P& p, const P& q){\n\tif(p.x != q.x)return p.x<q.x;\n\treturn p.y<q.y;\n}\n\n//テ・ツ?クテ・ツ個?」ツつ津ヲツアツづ」ツつ?」ツつ?\nvector<P> convex_hull(vector<P> ps){\n\tint n = ps.size();\n\tsort(all(ps),cmp_x);\n\tint k=0;            //テ・ツ?クテ・ツ個?」ツ?ョテゥツ?づァツつケテヲツ閉ー\n\tvector<P> qs(n*2);  //テヲツァツ凝ヲツ按静、ツクツュテ」ツ?ョテ・ツ?クテ・ツ個?\n\t//テ、ツクツ凝・ツ?エテ・ツ?クテ・ツ個?」ツ?ョテ、ツスツ愿ヲツ按?\n\trep(i,n){\n\t\twhile( k>1 && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n\t\tqs[k++]=ps[i];\n\t}\n\t//テ、ツクツ甘・ツ?エテ・ツ?クテ・ツ個?」ツ?ョテ、ツスツ愿ヲツ按?\n\tfor(int i=n-2, t=k;i>=0;i--){\n\t\twhile( k>t && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n\t\tqs[k++]=ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n\n\n//2テァツつケテ」ツつ津ゥツ?堙」ツつ凝・ツ債甘・ツセツвテ」ツ?ョテ・ツ??」ツ?ョテ、ツクツュテ・ツソツε・ツコツァテヲツィツ凖」ツつ津ヲツアツづ」ツつ?」ツつ?\npair<P,P> geoGetCircleOf2pAndR(P p1,P p2,double r){\n\tP pc1=P(-INF,-INF), pc2(-INF,-INF), p3;\n\tdouble d, l, dx, dy ;\n\t\n\tp3 = (p1+p2)/2.0;\n\tl = sqDist(p2,p3);\n\t\n\tif  (r*r >= l) {\n\t\td  = sqrt(r*r / l - 1.0) ;\n\t\tdx = d * (p2.y - p3.y) ;\n\t\tdy = d * (p2.x - p3.x) ;\n\t\t\n\t\tpc1.x = p3.x + dx ;\n\t\tpc1.y = p3.y - dy ;\n\t\t\n\t\tpc2.x = p3.x - dx ;\n\t\tpc2.y = p3.y + dy ;\n\t}\n\treturn pair<P,P>(pc1,pc2);\n}\n\n\nint main(){\n\tint n;\n\twhile(cin>>n&&n){\n\t\tint ans=0;\n\t\tif(n==1)ans=1;\n\t\tvector<P> ps(n);\n\t\trep(i,n)cin>>ps[i].x>>ps[i].y;\n\t\t\n\t\trep(i,n){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(dist(ps[i],ps[j])>2+EPS)continue;\n\t\t\t\tpair<P,P> res = geoGetCircleOf2pAndR(ps[i],ps[j],1);\n\t\t\t\tint suma=0,sumb=0;\n\t\t\t\trep(k,n){\n\t\t\t\t\tif(sqDist(ps[k],res.first )<1+EPS)suma++;\n\t\t\t\t\tif(sqDist(ps[k],res.second)<1+EPS)sumb++;\n\t\t\t\t}\n\t\t\t\tans = max(ans,max(suma,sumb));\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nclass Point{\npublic:\n\tdouble x;\n\tdouble y;\n\tPoint() : x(0),y(0){}\n\tPoint(double _x,double _y){\n\t\tx = _x;\n\t\ty = _y;\n\t}\n};\n\nclass Region{\npublic:\n\tint larger_num;\n\tint smaller_num;\n\tdouble size;\n\tdouble x;\n\tdouble y;\n\tRegion(double _x,double _y,double _size,int _larger_num,int _smaller_num){\n\t\tx = _x;\n\t\ty = _y;\n\t\tsize = _size;\n\t\tlarger_num = _larger_num;\n\t\tsmaller_num = _smaller_num;\n\t}\n\n\tbool operator<(const Region& r) const{\n\t\treturn larger_num < r.larger_num;\n\t}\n};\n\nvoid save(double x,double y,double size,const vector<Point>& points,priority_queue<Region>& que,int maxv){\n\tint larger_num=0;\n\tint smaller_num=0;\n\tdouble cx = x + (size / 2.0);\n\tdouble cy = y + (size / 2.0);\n\n\tfor(int i=0;i<points.size();i++){\n\t\tdouble d = sqrt((points[i].x - cx) * (points[i].x - cx)\n\t\t\t+ (points[i].y - cy) * (points[i].y - cy));\n\t\tif(d <= 1.0) smaller_num++;\n\t\tif(d <= 1.0 + (size/2.0)*sqrt(2.0)) larger_num++;\n\t}\n\n\tif(maxv >= larger_num) return;\n\n\tque.push(Region(x,y,size,larger_num,smaller_num));\n}\n\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tvector<Point> points;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf %lf\",&x,&y);\n\t\t\tpoints.push_back(Point(x,y));\n\t\t}\n\n\t\tpriority_queue<Region> que;\n\n\t\tint maxv = 1;\n\t\tsave(0,0,10,points,que,maxv);\n\n\t\twhile(!que.empty()){\n\t\t\tRegion re = que.top();\n\t\t\tint larger = re.larger_num;\n\t\t\tint smaller = re.smaller_num;\n\t\t\tdouble size = re.size;\n\t\t\tdouble x = re.x;\n\t\t\tdouble y = re.y;\n\n\t\t\tque.pop();\n\n\t\t\tif(maxv > larger) continue;\n\t\t\tmaxv = max(smaller,maxv);\n\t\t\n\t\t\tsave(x,y,size/2.0,points,que,maxv);\n\t\t\tsave(x+size/2.0,y,size/2.0,points,que,maxv);\n\t\t\tsave(x,y+size/2.0,size/2.0,points,que,maxv);\n\t\t\tsave(x+size/2.0,y+size/2.0,size/2.0,points,que,maxv);\n\t\t}\n\n\t\tprintf(\"%d\\n\",maxv);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <string>\nusing namespace std;\n\ndouble distance(double x1,double y1,double x2,double y2)\n{\n\treturn sqrt(pow((x1-x2),2)+pow((y1-y2),2));\n}\n\nint countInside(double x,double y,double lx[],double ly[],int n)\n{\n\tint c=0;\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tif (distance(x,y,lx[i],ly[i]) <= 1)\n\t\t{\n\t\t\tc++;\n\t\t}\n\t}\n\treturn c;\n}\n\nint main(void) {\n\tvector<int> r;\n\twhile (true)\n\t{\n\t\tint n=0;\n\t\tscanf(\"%d\",&n);\n\t\tif (n==0){\n\t\t\tbreak;\n\t\t}\n\t\tdouble x[300]={0},y[300]={0};\n\t\tint map[12][12]={{0}};\n\t\tint maxpoint=0;\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tscanf(\"%lf %lf\", &x[i], &y[i]);\n\t\t\tint tx=0,ty=0;\n\t\t\ttx = int(round(x[i]+0.5));\n\t\t\tty = int(round(y[i]+0.5));\n\t\t\tmap[tx][ty]++;\n\t\t\tif (maxpoint < map[tx][ty]){\n\t\t\t\tmaxpoint = map[tx][ty];\n\t\t\t}\n\t\t}\n\t\tfor (int i=1; i<=10; i++)\n\t\t{\n\t\t\tfor (int j=1; j<=10; j++)\n\t\t\t{\n\t\t\t\tint aroundpoint=0;\n\t\t\t\tfor (int k=-1; k<=1; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (int l=-1; l<=1; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\taroundpoint+=map[i+k][j+l];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (maxpoint >= aroundpoint){\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tfor (double k=0; k<1; k+=0.01)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (double l=0; l<1; l+=0.01)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint tmp = countInside(i-1+k,j-1+l,x,y,n);\n\t\t\t\t\t\t\tif (tmp>maxpoint){\n\t\t\t\t\t\t\tmaxpoint = tmp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr.push_back(maxpoint);\n\t}\n\tfor(int i=0; i<r.size(); i++)\n\t{\n\t\tcout << r[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <complex>\n#include <vector>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P, double> C;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nP n_vector(P a){\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nvector<P> cpcc(C a, C b){\n  double d = abs(a.first-b.first), ra = a.second, rb = b.second;\n  double t = (ra*ra-rb*rb+d*d)/2/d, h = sqrt(ra*ra-t*t);\n  P m = t/abs(b.first-a.first)*(b.first-a.first)+a.first;\n  vector<P> cp(2,m);\n  P n = n_vector(a.first-b.first);\n  cp[0] -= h*n;\n  cp[1] += h*n;\n  return cp;\n}\n\n\nint main(){\n  int N;\n  double x, y;\n  while(cin >> N, N){\n    P ps[N];\n    for(int i = 0; i < N; ++i){\n      cin >> x >> y;\n      ps[i] = P(x,y);\n    }\n    if(N == 1){\n      cout << 1 << endl;\n      continue;\n    }\n    vector<P> cps;\n    for(int i = 0; i < N; ++i){\n      for(int j = i+1; j < N; ++j){\n\tif(abs(ps[i]-ps[j]) < 2 + EPS){\n\t  vector<P> cp = cpcc(C(ps[i],1),C(ps[j],1));\n\t  for(int k = 0; k < cp.size(); ++k)\n\t    cps.push_back(cp[k]);\n\t}\n      }\n    }\n    int n = cps.size(), ans = 0;;\n    for(int i = 0; i < n; ++i){\n      int cnt = 0;\n      for(int j = 0; j < N; ++j){\n\tif(norm(cps[i]-ps[j]) < 1 + EPS)\n\t  ++cnt;\n      }\n      ans = max(ans, cnt);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nstruct Point{\n\tdouble x,y;\n};\n\nvoid func(int N){\n\n\tPoint point[N];\n\tdouble x_min = 100,y_min = 100,x_max = -1,y_max = -1;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf\",&point[i].x,&point[i].y);\n\t\tx_min = min(point[i].x,x_min);\n\t\ty_min = min(point[i].y,y_min);\n\t\tx_max = max(point[i].x,x_max);\n\t\ty_max = max(point[i].y,y_max);\n\t}\n\n\tif(x_min > 1)x_min -= 1;\n\tif(y_min > 1)y_min -= 1;\n\tif(x_max < 9)x_max += 1;\n\tif(y_max < 9)y_max += 1;\n\n\tint count,max_count = 0;\n\n\tfor(double y = y_min; y <= y_max; y += 0.1){\n\t\tfor(double x = x_min; x <= x_max; x += 0.1){\n\t\t\tcount = 0;\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tif(sqrt((x-point[i].x)*(x-point[i].x)+(y-point[i].y)*(y-point[i].y)) <= 1.0)count++;\n\t\t\t}\n\t\t\tmax_count = max(max_count,count);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",max_count);\n}\n\n\nint main(){\n\n\tint N;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc(N);\n\t}\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <complex>\n\nusing namespace std;\ntypedef long long ll;\ntypedef complex<double> Point;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nint n;\nint ans;\ndouble R;\nPoint points[3000];\npair<double, int> radian[30000];\nbool used[3000];\n\nint calc(int s) {\n  int ret = 1;\n  int m = 0;\n  REP(i, n) {\n    double d = abs(points[s] - points[i]) / 2.0;\n    if (i == s || d * 2.0 > R * 2) { continue; }\n    Point center = (points[s] + points[i]) / 2.0;\n    Point vect = (points[i] - points[s]) * Point(0, -1);\n    vect /= abs(vect);\n    double l = sqrt(R * R - d * d);\n    Point c1 = center + vect * l;\n    Point c2 = center - vect * l;\n    double arg1 = arg(c1 - points[s]) - EPS;\n    double arg2 = arg(c2 - points[s]) + EPS;\n    radian[m++] = pair<double, int>(arg1 + 0 * PI, (i + 1));\n    radian[m++] = pair<double, int>(arg2 + 0 * PI, -(i + 1));\n  }\n  if (m / 2 < ans - 1) { return 0; }\n  sort(radian, radian + m);\n  MEMSET(used, false);\n  int lsum = 1;\n  REP(iter, 2) {\n    REP(i, m) {\n      int index = abs(radian[i].second) - 1;\n      bool start = radian[i].second > 0 ? true : false;\n      if (used[index] && !start) {\n        used[index] = false;\n        lsum--;\n      } else if (!used[index] && start) {\n        used[index] = true;\n        lsum++;\n      }\n      ret = max(ret, lsum);\n    }\n  }\n  return ret;\n}\n\nint main() {\n  R = 1.0;\n  while (scanf(\"%d\", &n), n) {\n    REP(i, n) {\n      double x, y;\n      scanf(\"%lf %lf\", &x, &y);\n      points[i] = Point(x, y);\n    }\n    ans = 0;\n    REP(i, n) {\n      ans = max(ans, calc(i));\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define M_PI 3.14159265359\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nclass P{\npublic:\n\tdouble x,y;\n\tP(){}\n\tP(double xx,double yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tP operator +(P p){\n\t\treturn P(x+p.x,y+p.y);\n\t}\n\tP operator -(P p){\n\t\treturn P(x-p.x,y-p.y);\n\t}\n\tP operator /(double d){\n\t\treturn P(x/d,y/d);\n\t}\n};\n\nint n;\nP p[301];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf%lf\",&p[i].x,&p[i].y);\n\t\t}\n\t\tint res=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tP np=p[j]-p[i];\n\t\t\t\t//printf(\"%lf %lf\\n\",np.x,np.y);\n\t\t\t\tdouble blen=np.x*np.x/4.0+np.y*np.y/4.0;\n\t\t\t\tif(blen>1.0)continue;\n\t\t\t\tdouble len=sqrt(1-blen);\n\t\t\t\tdouble dir=atan2(np.y,np.x);\n\t\t\t\tP cp=(p[i]+p[j])/2+P(len*cos(dir+M_PI/2),len*sin(dir+M_PI/2));\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tdouble len2=sqrt((cp.x-p[k].x)*(cp.x-p[k].x)+(cp.y-p[k].y)*(cp.y-p[k].y));\n\t\t\t\t\tif(len2<=1.0001)cnt++;\n\t\t\t\t}\n\t\t\t\tres=max(res,cnt);\n\t\t\t\tcp=(p[i]+p[j])/2+P(len*cos(dir-M_PI/2),len*sin(dir-M_PI/2));\n\t\t\t\tcnt=0;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tdouble len2=sqrt((cp.x-p[k].x)*(cp.x-p[k].x)+(cp.y-p[k].y)*(cp.y-p[k].y));\n\t\t\t\t\tif(len2<=1.0001)cnt++;\n\t\t\t\t}\n\t\t\t\tres=max(res,cnt);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// * XYツ催?標\n#define X real()\n#define Y imag()\n\n// * ツ点ツづ個表ツ個サ\ntypedef complex<double> P;\n\n// * ツ仰鳴容ツつキツづゥツ古ォツ債キツε?\nconst double EPS = 1e-10;\n// * Infinity\nconst double INF = 1e12;\n// * ツ円ツ偲シツ猟ヲ\nconst double PI = acos(-1.0);\n// * \nconst P INF_P(INF,INF);\n\n// * complex<double> ツづ個渉?渉伉づーツ津ィツ義ツつキツづゥ\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * ツ点ツ催?標ツづ個デツバツッツグツ出ツ療?\nvoid print(P p) {\n\tcout << \"point\" << p << \";\" << endl;\n}\n\n// * 2ツ湘ヲツつキツづゥ\ndouble sq(double x) {\n\treturn x * x;\n}\n\n// * 2ツ点ツ甘板づ個仰猟猟」\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 2ツづつづ個スツカツδ可ーツつェツ督卍つオツつ「ツつゥツづ?つ、ツつゥ\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n// * 2ツづつづ個ベツクツトツδ仰つェツ督卍つオツつ「ツつゥツづ?つ、ツつゥ\nbool eq_v(P a, P b) {\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// * ツ禿?静?(dot product) : aツ・b = |a||b|cosツδヲ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// * ツ外ツ静?(cross product) : aツ×b = |a||b|sinツδヲ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// ツベツクツトツδ?a ツづ個単ツ暗環法ツ静シツベツクツトツδ仰づーツ仰?づ淞づゥ\nvector<P> normal_unit(P a) {\n\tvector<P> vp;\n\tvp.push_back( (a * P(0,  1)) / abs(a) );\n\tvp.push_back( (a * P(0, -1)) / abs(a) ) ;\n\treturn vp;\n}\n\n// ツ個エツ点ツづーツ篠イツづ可点 p ツづーツ角ツ度 a (ツδ可ジツアツδ?ツつセツつッツ嘉アツ転ツつウツつケツつスツ点ツづーツ陛板つキ\nP rot(P p, double a){\n\tdouble x = p.X * cos(a) - p.Y * sin(a);\n\tdouble y = p.X * sin(a) + p.Y * cos(a);\n\treturn P(x,y);\n}\n\nint main(){\n\tint n;\n\twhile( cin >> n , n ){\n\t\tvector<P> v;\n\t\tint ans=1;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf %lf\", &x, &y);\n\t\t\tv.push_back( P(x,y) );\n\t\t}\n\t\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\t\tfor(int j=i+1 ; j < v.size() ; j++ ){\n\t\t\t\tif( i == j ) continue;\n\t\t\t\tP p1 = v[i];\n\t\t\t\tP p2 = v[j];\n\t\t\t\tdouble d = dist(p1,p2);\n\t\t\t\tif( d >= 2.0 ) continue;\n\t\t\t\t\n\t\t\t\tdouble angle = atan2( p2.Y-p1.Y , p2.X-p1.X );\n\t\t\t\tP mid = rot( p2-p1 , -angle ) / 2.0;\n\t\t\t\tdouble h = sqrt(1.0 - sq(d/2.0));\n\t\t\t\tP p3 = P( mid.X , h );\n\t\t\t\tP p4 = P( mid.X , -h );\n\t\t\t\tint cnt1=0, cnt2=0;\n\t\t\t\tfor(int k=0 ; k < v.size() ; k++ ){\n\t\t\t\t\tP p = rot( v[k]-p1 , -angle );\n\t\t\t\t\tif( dist(p3,p) <= 1.0 ) cnt1++;\n\t\t\t\t\tif( dist(p4,p) <= 1.0 ) cnt2++;\n\t\t\t\t}\n\t\t\t\tans = max( ans , max(cnt1,cnt2) );\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-8;\nconst int N = 300;\nconst double R = 1;\n\nstruct Circle{\n  P c;\n  double r;\n  Circle(P c=P(0,0), double r=0):c(c),r(r){}\n};\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1 = c1.r, r2 = c2.r, d;\n  P p1 = c1.c, p2 = c2.c;\n  d = abs(p1-p2);\n\n  if(d < EPS && abs(r1-r2) < EPS) return res; //????????¨?????????????????´???????????????????????????????????????\n  if(r1 + r2< d - EPS || d + EPS < abs(r1-r2)) return res; //???????????????\n\n  double a = (r1*r1 - r2*r2 + d*d) / (2*d);\n  double h = sqrt(max(r1*r1 - a*a, 0.0));\n  P tmp1 = p1 + a / d * (p2-p1);\n  P tmp2 = h / d * (p2-p1);\n\n  if(abs(tmp2) < EPS) res.push_back(tmp1);\n  else {\n    res.push_back(P(real(tmp1) - imag(tmp2), imag(tmp1) + real(tmp2)));\n    res.push_back(P(real(tmp1) + imag(tmp2), imag(tmp1) - real(tmp2)));\n  }\n  return res;\n}\n\n\nint n;\nvector<P> v;\n\nint solve(){\n  int ans = 0;\n\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      vector<P> cc = getIntersectCC(Circle(v[i], R), Circle(v[j], R)); // v[i]??¨v[j]??????????????¢?????¨??????R??¨????????? (?????´?????????????????????????????????????????????)\n      if(cc.size() == 0) continue;\n      for(int k=0;k<cc.size();k++){\n        int res = 0;\n        for(int l=0;l<n;l++) if(abs(v[l]-cc[k]) <= R + EPS) res++;\n        ans = max(ans, res);\n      }\n    }\n  }\n\n  return ans;\n}\n\nint main(){\n  while(cin >> n && n){\n    v.clear();\n    for(int i=0;i<n;i++){\n      double x, y;\n      cin >> x >> y;\n      v.push_back(P(x,y));\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf (1e8)\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\nvector<Point> vp;\nint n;\n\npair<Circle,Circle> makeCirclebySegment(Point a,Point b,int r){\n  Point m=a+(b-a)/2.0;\n  double d=sqrt(r*r-abs(m-b)*abs(m-b));\n  Vector v=(rotate(m,a,90)-m)*(d/abs(m-a));\n  Point A=m+v,B=m-v;\n  return mp(Circle(A,1),Circle(B,1));\n}\n\nint PointsInCircle(Circle C)\n{\n  int num=0;\n  for(int i=0;i<n;i++){\n    if(abs(vp[i]-C.c)-1<eps)num++;\n  }\n  return num;\n}\n\nint main()\n{\n  double x,y;\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    vp.clear();\n\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      vp.push_back(Point(x,y));\n    }\n    int ans=1;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(2-abs(vp[i]-vp[j])<eps)continue;\n\tpair<Circle,Circle> pc=makeCirclebySegment(vp[i],vp[j],1);\n\tans=max(ans,PointsInCircle(pc.f));\n\tans=max(ans,PointsInCircle(pc.s));\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <deque>\n#include <utility>\n\n#define REP(i, n) FOR(i, 0, n)\n#define FOR(i, a, b) for(int i = int(a); i < int(b); ++i)\n#define RREP(i, n) RFOR(i, 0, n)\n#define RFOR(i, a, b) for(int i = int(b) - 1; i >= int(a); --i)\n\nconstexpr double EPS = 1e-7;\n\nsigned main() {\n\n\twhile (true) {\n\t\tint n;\n\t\tstd::cin >> n;\n\t\tif (n == 0) break;\n\n\t\tstd::vector<double> x(n), y(n);\n\t\tREP(i, n) std::cin >> x[i] >> y[i];\n\n\t\tint ans = 0;\n\n\t\tREP(i, n) FOR(j, i + 1, n) {\n\t\t\tdouble dist = std::hypot(x[i] - x[j], y[i] - y[j]);\n\t\t\tif (dist > 2 + EPS) continue;\n\n\t\t\t// iとjの中点m\n\t\t\tdouble mx = (x[i] + x[j]) / 2;\n\t\t\tdouble my = (y[i] + y[j]) / 2;\n\n\t\t\t// 線分ijから中心への距離\n\t\t\tdouble r = std::sqrt(1 - dist / 2);\n\n\t\t\t// 中心c\n\t\t\tfor (int sign = -1; sign <= 1; sign += 2) {\n\t\t\t\t// 移動のベクトルv\n\t\t\t\tdouble vx = sign * r * (y[j] - y[i]) / dist;\n\t\t\t\tdouble vy = sign * r * -(x[j] - x[i]) / dist;\n\n\t\t\t\tdouble cx = mx + vx;\n\t\t\t\tdouble cy = my + vy;\n\n\t\t\t\tint cnt = 0;\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tif (std::hypot(cx - x[k], cy - y[k]) < 1 + EPS) ++cnt;\n\t\t\t\t}\n\t\t\t\tans = std::max(ans, cnt);\n\t\t\t}\n\t\t}\n\t\tstd::cout << ans << \"\\n\";\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\nconst double EPS = 1e-9;\n\ntypedef struct\n{\n  double x, y;\n}Point;\n\nint main()\n{\n  int N;\n  while (~scanf(\"%d\", &N)) {\n    if (N == 0)\n      break;\n\n    Point c;\n    vector<Point> p(N);\n    for (int i = 0; i < N; ++i)\n      scanf(\"%lf %lf\", &p[i].x, &p[i].y);\n\n    int ans = 1;\n    for (int i = 0; i < N; ++i) {\n      for (int j = i+1; j < N; ++j) {\n\tdouble H = hypot(p[i].x-p[j].x, p[i].y-p[j].y);\n\tif (H - 2.0 > EPS)\n\t  continue;\n\tdouble D = sqrt(1.0 - (H*H)/4.0);\n\tfor (int pm = 0; pm < 2; ++pm) {\n\t  c.x = (p[i].x+p[j].x)/2.0 + (p[j].y-p[i].y)*D/H;\n\t  c.y = (p[i].y+p[j].y)/2.0 - (p[j].x-p[i].x)*D/H;\n\t  int cnt = 2;\n\t  for (int k = 0; k < N; ++k) {\n\t    if (k == i || k == j)\n\t      continue;\n\t    if ((c.x-p[k].x)*(c.x-p[k].x)+(c.y-p[k].y)*(c.y-p[k].y)-1.0 <= EPS)\n\t      ++cnt;\n\t  }\n\t  ans = max(ans, cnt);\n\t  D *= -1.0;\n\t}\n     }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <complex>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef complex<double> Point;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nint n;\ndouble R;\nPoint points[3000];\n\nstruct Node {\n  Point p;\n  double w;\n  int bound;\n  Node(Point p, double w, int bound) : p(p), w(w), bound(bound) {;}\n  bool operator<(const Node &rhs) const {\n    return bound < rhs.bound;\n  }\n};\n\nint main() {\n  R = 1.0;\n  while (scanf(\"%d\", &n), n) {\n    priority_queue<Node> que;\n    REP(i, n) {\n      double x, y;\n      scanf(\"%lf %lf\", &x, &y);\n      points[i] = Point(x, y);\n      que.push(Node(points[i], R, 10000));\n    }\n    int ans = 1;\n    while (!que.empty()) {\n      Node node = que.top();\n      que.pop();\n      if (node.bound <= ans) { break; }\n      int lans = 0;\n      int nbound = 0;\n      REP(i, n) {\n        double dist = abs(points[i] - node.p);\n        if (dist < R) {\n          lans++;\n          nbound++;\n        } else if (dist < R + node.w * 1.41421356) {\n          nbound++;\n        }\n      }\n      ans = max(ans, lans);\n      if (nbound <= ans) { continue; }\n      const double dx[4] = { -1, -1, 1, 1 };\n      const double dy[4] = { -1, 1, -1, 1 };\n      double nw = node.w / 2.0;\n      REP(i, 4) {\n        double nx = node.p.real() + nw * dx[i];\n        double ny = node.p.imag() + nw * dy[i];\n        que.push(Node(Point(nx, ny), nw, nbound));\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\n#define x first\n#define y second\nconst int N = 300;\nconst int SCALE = 1e5;\nconst int radius = 1;\nconst double e = 1e-6;\ntypedef pair<double, double> point;\npoint points[N];\ndouble distances[N][N];\n\ndouble sq(double d) {\n  return d * d;\n}\n\ndouble dist(point a, point b) {\n  return sqrt(sq(a.x - b.x) + sq(a.y - b.y));\n}\n\nbool le(double a, double b){\n  return a < b or fabs(a - b) < e;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  while (n) {\n    for (int i = 0; i < n; ++i) {\n      double x, y;\n      cin >> x >> y;\n      points[i] = {x, y};\n    }\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        distances[i][j] = dist(points[i], points[j]);\n\n    // for each point,\n    //  for every other point\n    //    for every point currently selected\n    //      check if it goes past the bounds\n    //    add the point if its contained\n    //\n    int m = 0;\n    for (int i = 0; i < n; ++i) {\n      vector<int> selected = {i};\n      for (int j = 0; j < n; ++j) {\n        if (i == j) continue;\n        bool contained = true;\n        for (auto k : selected) {\n          if (distances[j][k] > 2.0) {\n            contained = false;\n            break;\n          }\n        }\n        if (contained) selected.push_back(j);\n        /*\n        cout << i << ' ' << j << \": \" << endl;\n        for (auto p : selected) cout << p << ' ';\n        cout << endl;\n        */\n      }\n\n      m = max(m, (int)selected.size());\n    }\n\n    cout << m << endl;\n\n    cin >> n;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <functional>\n#include <ctime>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n#define all(c) ((c).begin()), ((c).end())\n#define TEST(x,a) { auto y=(x); if (sign(y-a)) { cout << \"line \" << __LINE__  << #x << \" = \" << y << \" != \" << a << endl; exit(-1); } }\ndouble urand() { return rand() / (1.0 + RAND_MAX); }\n\nconst double PI = acos(-1.0);\n\n// implementation note: use EPS only this function\n// usage note: check sign(x) < 0, sign(x) > 0, or sign(x) == 0\n// notice: should be normalize to O(1)\nconst double EPS = 1e-8;\nint sign(double x) {\n  if (x < -EPS) return -1;\n  if (x > +EPS) return +1;\n  return 0;\n}\nstruct point {\n  typedef double T;\n  T x, y; \n  point &operator+=(point p) { x += p.x; y += p.y; return *this; }\n  point &operator-=(point p) { x -= p.x; y -= p.y; return *this; }\n  point &operator*=(T a)     { x *= a;   y *= a;   return *this; }\n  point &operator/=(T a)     { return *this *= (1.0/a); }\n  point operator-() const    { return {-x, -y}; }\n  bool operator==(point p) const { return !sign(x-p.x) && !sign(y-p.y); }\n  bool operator!=(point p) const { return !operator==(p); }\n  bool operator<(point p) const { return x!=p.x ? x<p.x : y<p.y; } // for sort\n};\npoint operator+(point p, point q) { return p += q; }\npoint operator-(point p, point q) { return p -= q; }\npoint operator*(point::T a, point p) { return p *= a; }\npoint operator*(point p, point::T a) { return p *= a; }\npoint operator/(point p, point::T a) { return p /= a; }\npoint::T dot(point p, point q) { return p.x*q.x+p.y*q.y; }\npoint::T cross(point p, point q) { return p.x*q.y-p.y*q.x; } // left turn > 0\npoint::T norm2(point p) { return dot(p,p); }\npoint::T norm(point p) { return sqrt(dot(p,p)); }\npoint::T dist(point p, point q) { return norm(p-q); }\npoint orth(point p) { return {-p.y, p.x}; }\n\nistream &operator>>(istream &is, point &p) { is>>p.x>>p.y;return is; }\nostream &operator<<(ostream &os, const point &p) { os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; return os; }\n\nint maximum_circle_cover(vector<point> ps, double r) {\n  struct range {\n    point p; // center\n    double w; // width\n    int hi;\n    bool operator<(range r) const {\n      return hi < r.hi;\n    }\n  };\n  double w = 0;\n  for (point p: ps) w = max({w, abs(p.x), abs(p.y)});\n  priority_queue<range> que;\n  que.push({{0,0}, w, (int)ps.size()});\n  point best_p;\n  int best = 0;\n  while (!que.empty()) {\n    range R = que.top(); que.pop();\n    if (R.hi <= best) continue;\n    //cout << \"processing \" << R.p << \" \" << R.w << \" \" << R.hi << \"/\" << best << endl;\n    double dx[] = {1,-1,-1,1}, dy[] = {1,1,-1,-1};\n    for (int i = 0; i < 4; ++i) {\n      range S = {R.p, R.w/2, 0};\n      S.p += S.w*point({dx[i], dy[i]});\n      int lo = 0;\n      for (point q: ps) {\n        auto d = dist(S.p, q);\n        if (sign(d - r) <= 0) ++lo;\n        if (sign(d - S.w*sqrt(2) - r) <= 0) ++S.hi;\n      }\n      if (lo > best) { best = lo; best_p = S.p; }\n      best = max(lo, best);\n      if (S.hi > best) que.push(S);\n    }\n  }\n  return best; //best_p;\n}\nint maximum_circle_cover3(vector<point> ps, double r) {\n\n  point best_p;\n  int best = 0;\n  function<void(point,double,vector<point>&)> rec = [&](point p, double w, vector<point> &ps) {\n    w /= 2;\n    const double dx[] = {1,-1,-1,1}, dy[] = {1,1,-1,-1};\n    point qs[4];\n    vector<point> pss[4];\n    for (int i = 0; i < 4; ++i) {\n      qs[i] = p + w * point({dx[i], dy[i]});\n      int lo = 0;\n      for (point q: ps) {\n        auto d = dist(qs[i], q);\n        if (sign(d - r) <= 0) ++lo;\n        if (sign(d - w*sqrt(2) - r) <= 0) pss[i].push_back(q);\n      }\n      if (lo > best) { best = lo; best_p = qs[i]; }\n    }\n    int a = 0, b = 1, c = 2, d = 3;\n    auto SW = [&](int &a, int &b) { if (pss[a].size() > pss[b].size()) swap(a, b); };\n    SW(a,b);SW(c,d);SW(b,d);SW(a,c);SW(b,c);\n    if (pss[d].size() > best) rec(qs[d], w, pss[d]);\n    if (pss[b].size() > best) rec(qs[b], w, pss[b]);\n    if (pss[c].size() > best) rec(qs[c], w, pss[c]);\n    if (pss[a].size() > best) rec(qs[a], w, pss[a]);\n  };\n  double w = 0;\n  for (point p: ps) w = max({w, abs(p.x), abs(p.y)});\n  rec({0,0}, w, ps);\n  return best; //best_p;\n}\n\nint maximum_circle_cover2(vector<point> ps, double r) {\n  int best = 0;\n  for (point p: ps) {\n    int count = 0;\n    vector<pair<double,int>> aux;\n    for (point q: ps) {\n      auto d = dist(p, q);\n      if (sign(d) == 0) ++count;\n      else if (sign(d - 2*r) <= 0) {\n        double theta = atan2(q.y-p.y, q.x-p.x);\n        double phi   = acos(min(1., d/(2*r)));\n        aux.push_back({theta-phi, -1});\n        aux.push_back({theta+phi, +1});\n      }\n    }\n    sort(all(aux));\n    /*\n    cout << \"for point \" << p << endl;\n    for (auto a: aux) \n      cout << \"(\" << a.fst << \",\" << a.snd << \") \";\n    cout << endl;\n    */\n\n    for (auto a: aux) \n      best = max(best, count -= a.snd);\n  }\n  return best;\n}\n\n\nvoid verify_maximum_circle_cover2() {\n  for (int n; scanf(\"%d\", &n) && n; ) {\n    vector<point> ps(n);\n    for (int i = 0; i < n; ++i) \n      scanf(\"%lf %lf\", &ps[i].x, &ps[i].y);\n    printf(\"%d\\n\", maximum_circle_cover2(ps, 1.0));\n  }\n}\n\n\nint main() {\n  //verify_maximum_circle_cover();\n  verify_maximum_circle_cover2();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\ntypedef long double ld;\n\nstruct Point {\n    ld x, y;\n    Point(ld x, ld y) : x(x), y(y) {}\n    string to_s() {\n        ostringstream os;\n        os << x << ',' << y;\n        return os.str();\n    }\n    Point operator+(const Point& o) const {\n        return Point(x+o.x, y+o.y);\n    }\n    Point operator/(const int d) const {\n        return Point(x/d, y/d);\n    }\n};\n\nstruct Circle {\n    ld x, y;\n    ld r;\n    Circle(ld x=0, ld y=0, ld r=1) : x(x), y(y), r(r) {}\n    const static ld eps = 1e-5;\n    bool isIntersect(const Circle& o) const {\n        ld dx = o.x - x;\n        ld dy = o.y - y;\n        return (r + o.r) * (r + o.r) > (dx*dx + dy*dy);\n    }\n    pair<Point, Point> intersectionPoint(const Circle& o) const {\n        //cout << x << ',' << y << \" and \" << o.x << ',' << o.y << endl;\n        ld dx = o.x - x;\n        ld dy = o.y - y;\n        //cout << \"dx: \" << dx << \" dy: \" << dy << endl;\n        ld d = sqrt(dx*dx + dy*dy);\n        //cout << \"d: \" << d << endl;\n\n        ld slope;\n        ld theta;\n        if (dx < eps) {\n            if (y < o.y) {\n                theta = M_PI / 2;\n            } else {\n                theta = - M_PI / 2;\n            }\n        } else {\n            slope = dy / dx;\n            theta = atan(slope);\n        }\n        //cout << \"theta: \" << theta << endl;\n        ld theta_p = acos((r*r - o.r*o.r + d*d) / (2*r*d));\n        //cout << \"theta_p: \" << theta_p << endl;\n\n        return make_pair(\n                Point(x + r*cos(theta - theta_p), y + r*sin(theta - theta_p)),\n                Point(x + r*cos(theta + theta_p), y + r*sin(theta + theta_p)));\n    }\n    bool contains(ld px, ld py) const {\n        return r + eps >= sqrt((px - x) * (px - x) + (py - y) * (py - y));\n    }\n    string to_s() {\n        ostringstream os;\n        os << x << ',' << y << ':' << r << endl;\n        return os.str();\n    }\n};\n\nint countContainingPoints(const Circle& c, const vector<Circle>& ps) {\n    int cnt = 0;\n    for (int i = 0; i < ps.size(); i++) \n        if (c.contains(ps[i].x, ps[i].y)) \n            cnt++;\n    return cnt;\n}\n\nPoint midPoint(pair<Point, Point>& pp) {\n    return (pp.first + pp.second) / 2;\n}\n\nint N;\nint main() {\n    vector<Circle> cs;\n    while (cin >> N, N) {\n        cs.clear(); cs.resize(N);\n        for (int i = 0; i < N; i++) cin >> cs[i].x >> cs[i].y;\n\n        vector<Point> ips; // Intersection PointS\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (i == j) continue;\n                if (!cs[i].isIntersect(cs[j])) continue;\n                pair<Point, Point> ip = cs[i].intersectionPoint(cs[j]);\n                ips.push_back(ip.first);\n                ips.push_back(ip.second);\n                //ips.push_back(midPoint(ip));\n            }\n        }\n\n        int maxPoint = 0;\n        for (int i = 0; i < ips.size(); i++) {\n            maxPoint = max(maxPoint, countContainingPoints(Circle(ips[i].x, ips[i].y, 1), cs));\n        }\n        cout << maxPoint << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1132>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\ntypedef complex<double> Point;\nint n;\nint solve(){\n    int res = 1;\n    vector<Point> ps(n);\n    for(int i = 0; i < n;i++){\n        double x,y; cin >> x >> y;\n        ps[i] = Point(x,y);\n    }\n    for(int i = 0; i < n;i++){\n        for(int j = i+1; j < n;j++){\n            double dist = abs(ps[i]-ps[j]);\n            if(dist > 2) continue;\n            Point mp = (ps[i]+ps[j])/2.;\n            Point dp = ps[i]-ps[j];\n            double x = sqrt(1-dist*dist/4);\n            Point cp = Point(-dp.imag()*x/dist+mp.real(),dp.real()*x/dist+mp.imag());\n            int cnt = 0;\n            for(int k = 0; k < n;k++){\n                if(abs(cp-ps[k]) < 1.0 + 1e-9) cnt++;\n            }\n            res = max(res,cnt);\n        }\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> n,n){\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <string> \n#include <vector> \n#include <cmath> \n#include <algorithm> \n#include <cstdlib> \n#include <ctime> \n#include <cstdio> \n#include <functional> \n#include <set> \n#include <sstream> \n\n\nusing namespace std; \n\nint main(){\n\n\tint n;\n\tconst double eps=1e-8;\n\twhile(true){\n\n\t\tcin>>n;\n\n\t\tif(n==0) return 0;\n\n\t\tint ans=1;\n\t\tvector< double > x(n),y(n);\n\n\t\tfor(int i=0;i<n;i++) cin>>x[i]>>y[i];\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tconst double d=hypot(x[i]-x[j],y[i]-y[j]);\n\t\t\t\tif(d>2.0+eps) continue;\n\n\t\t\t\tconst double mx=(x[i]+x[j])/2.0;\n\t\t\t\tconst double my=(y[i]+y[j])/2.0;\n\t\t\t\tconst double dvx=(x[i]-x[j])/d;\n\t\t\t\tconst double dvy=(y[i]-y[j])/d;\n\n\t\t\t\tconst double cx1=mx+dvy*sqrt(1.0-d*d/4.0);\n\t\t\t\tconst double cy1=my-dvx*sqrt(1.0-d*d/4.0);\n\n\t\t\t\tconst double cx2=mx-dvy*sqrt(1.0-d*d/4.0);\n\t\t\t\tconst double cy2=my+dvx*sqrt(1.0-d*d/4.0);\n\n\t\t\t\tint res=2;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i || k==j) continue;\n//\t\t\t\t\tif(hypot(x[k]-cx1,y[k]-cy1)<1.0+eps) res++;\n\t\t\t\t\tif((x[k]-cx1)*(x[k]-cx1)+(y[k]-cy1)*(y[k]-cy1)<1.0+eps) res++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tans=max(ans,res);\n\n\t\t\t\tres=2;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i || k==j) continue;\n//\t\t\t\t\tif(hypot(x[k]-cx2,y[k]-cy2)<1.0+eps) res++;\n\t\t\t\t\tif((x[k]-cx2)*(x[k]-cx2)+(y[k]-cy2)*(y[k]-cy2)<1.0+eps) res++;\n\t\t\t\t}\n\n\t\t\t\tans=max(ans,res);\n\n\t\t\t}\n\t\t}\n\n\t\tcout<<ans<<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#define COS45 0.707107\nusing namespace std;\n\nclass Point {\npublic:\n  double x, y;\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n  Point operator +(Point p) {\n    return Point(x+p.x, y+p.y);\n  }\n  Point operator -(Point p) {\n    return Point(x-p.x, y-p.y);\n  }\n  Point operator *(double a) {\n    return Point(x*a, y*a);\n  }\n  Point operator /(double a) {\n    return Point(x/a, y/a);\n  }\n  bool operator ==(const Point &p) const {\n    return x == p.x && y == p.y;\n  }\n  bool operator <(const Point &p) const {\n    double l1 = x+y;\n    double l2 = p.x+p.y;\n    if(l1 != l2) return l1 < l2;\n    if(y != p.y) return y < p.y;\n    return x < p.x;\n  }\n};\n\ntypedef Point Vector;\n\ndouble norm(Point p1, Point p2) {\n  return (p1.x-p2.x)*(p1.x-p2.x) + (p1.y-p2.y)*(p1.y-p2.y);\n}\n\nint n;\nPoint p[300];\n\nint calc(Point p1, Point p2) {\n  Point m = Point((p1.x+p2.x)/2.0, (p1.y+p2.y)/2.0);\n  Point o;\n  Vector moto = Vector(p2.y-p1.y, p1.x-p2.x);\n  int cnt = 0;\n  int newCnt;\n  double p1p2 = norm(p1,p2);\n  if(p1p2 > 4) return 1;\n  double l = sqrt(4.0/p1p2-1)/2.0;\n\n  for(int t = 0; t < 2; t++) {\n    newCnt = 0;\n    if(t == 1) {\n      moto = moto * (-1);\n    }\n    o = m + moto * l;\n\n    for(int i = 0; i < n; i++) {\n      //if(p[i].x > o.x + COS45 && p[i].y > o.y + COS45) break;\n      if(newCnt + n-i <= cnt) break;\n      if(p[i] == p1 || p[i] == p2) continue;\n      if((p[i].x-o.x)*(p[i].x-o.x) + (p[i].y-o.y)*(p[i].y-o.y) <= 1.0) {\n\tnewCnt++;\n      }\n    }\n    if(newCnt > cnt) cnt = newCnt;\n  }\n  return cnt + 2;\n}\n\nmain() {\n  while(1) {\n    int ans;\n    cin >> n;\n    if(n == 0) break;\n    for(int i = 0; i < n; i++) {\n      cin >> p[i].x >> p[i].y;\n    }\n    sort(p, &p[n]);\n    ans = -1;\n    for(int i = 0; i < n; i++) {\n      for(int j = i+1; j < n; j++) {\n\tans = max(ans, calc(p[i],p[j]));\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> C;\n\nconst double EPS = 1e-9;\n\nint solve(int N, vector<double>& x, vector<double>& y) {\n    vector<C> point(N);\n\n    for (int j = 0; j < N; ++j) {\n        point[j] = C(x[j], y[j]);\n    }\n\n    int ret = 1;\n\n    for (int j = 0; j < N; ++j) {\n        for (int k = j+1; k < N; ++k) {\n            C mid = (point[j] + point[k]) * 0.5;\n\n            C normal = (point[j] - point[k]) * C(0, 1);\n            normal /= abs(point[j] - point[k]);\n\n            double a = sqrt(1 - norm(mid - point[j]));\n\n            C centre1 = mid + a * normal;\n            int count = 0;\n            for (int l = 0; l < N; ++l) {\n                if (abs(centre1 - point[l]) < 1.0+EPS) {\n                    ++count;\n                }\n            }\n            ret = max(ret, count);\n\n            C centre2 = mid - a * normal;\n            count = 0;\n            for (int l = 0; l < N; ++l) {\n                if (abs(centre2 - point[l]) < 1.0+EPS) {\n                    ++count;\n                }\n            }\n            ret = max(ret, count);\n\n        }\n    }\n\n    return ret;\n}\n\nint main () {\n    int N;\n    vector<double> x, y;\n\n    while (true) {\n        cin >> N;\n        if (N == 0) break;\n\n        x.resize(N);\n        y.resize(N);\n\n        for (int j = 0; j < N; ++j) {\n            cin >> x[j] >> y[j];\n        }\n\n        cout << solve(N, x, y) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\nint count( vector<complex<double>> &vpos );\n\nint main(int argc, char const *argv[]) {\n    int n, result;\n    double x, y;\n    vector<complex<double>> vpos;\n    vector<int> results;\n\n    while(1){\n        cin>>n;\n        if( n == 0 ) break;\n        for(int i = 0; i < n; i++){\n            cin>>x>>y;\n            vpos.push_back( complex<double> (x,y) );\n        }\n        results.push_back( count( vpos ) );\n    }\n\n    for (auto it = results.begin(); it != results.end(); it++) {\n        cout<<*it<<endl;\n    }\n\n    return 0;\n}\n\nint count( vector<complex<double>> &vpos ){\n    int count = 0;\n    int tmp_count;\n    complex<double> m, n, center;\n\n    for(auto fi = vpos.begin(); fi != vpos.end(); fi++){\n        for(auto sc = vpos.begin(); sc != vpos.end(); sc++){\n            if( (*fi).real() == (*sc).real() ) continue;\n            tmp_count = 0;\n\n            m = ( (*fi) + (*sc) ) / 2.0;\n            n = ( (*fi) -  (*sc) ) * complex<double> ( 0.0, 1.0 );\n            n = n / abs(n);\n\n            double x = abs( (*fi) -  (*sc)  ) / 2.0;\n            center =  m + n * sqrt( 1.0 - x * x );\n\n            for(auto it = vpos.begin(); it != vpos.end(); it++){\n                double dist = abs( center - (*it ) );\n                if( dist <  2.0 ){\n                    tmp_count++;\n                }\n            }\n            if( count < tmp_count ){\n                count = tmp_count;\n            }\n        }\n    }\n    return count;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n\n#define rep2(i, b, n) for(int i=b; i < n; ++i)\n#define rep(i, n) rep2(i, 0, n)\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<double, double> pdd;\n\ndouble distance_sq( pdd a, pdd b )\n{\n\tdouble cx = a.X - b.X;\n\tdouble cy = a.Y - b.Y;\n\treturn ((cx*cx) + (cy*cy));\n}\n\ndouble norm( pdd &v )\n{\n\tdouble len = sqrt((v.X*v.X) + (v.Y*v.Y));\n\tv.X /= len;\n\tv.Y /= len;\n\treturn len;\n}\n\nvoid rotate( pdd &p )\n{\n\tswap(p.X, p.Y);\n\tp.Y = -p.Y;\n}\n\nint main( void )\n{\n\tint n;\n\tpdd p[300];\n\twhile(cin >> n, n)\n\t{\n\t\trep(i, n) cin >> p[i].X >> p[i].Y;\n\t\tint Max = 1;\n\t\trep(i, n) {\n\t\t\trep2(j, i+1, n) {\n\t\t\t\tif(distance_sq(p[i], p[j]) <= 4.0) {\n\t\t\t\t\tpdd v = make_pair(p[i].X-p[j].X, p[i].Y-p[j].Y);\n\t\t\t\t\tpdd c = make_pair(v.X / 2.0000, v.Y / 2.0000);\n\t\t\t\t\tpdd m = c;\n\t\t\t\t\tdouble len_c = norm(c);\n\t\t\t\t\tdouble sin_x = sqrt(1.0000 - (len_c*len_c));\n\t\t\t\t\trotate(c);\n\t\t\t\t\tc.X *= sin_x; c.Y *= sin_x;\n\t\t\t\t\tpdd p3 = make_pair(p[j].X+m.X+c.X, p[j].Y+m.Y+c.Y);\n\t\t\t\t\tpdd p4 = make_pair(p[j].X+m.X-c.X, p[j].Y+m.Y-c.Y);\n\t\t\t\t\tint count_p3, count_p4;\n\t\t\t\t\tcount_p3 = count_p4 = 2;\n\t\t\t\t\trep(k, n) {\n\t\t\t\t\t\tif(i==k || j==k) continue;\n\t\t\t\t\t\tif(distance_sq(p3, p[k]) < 1.000001) ++count_p3;\n\t\t\t\t\t\tif(distance_sq(p4, p[k]) < 1.000001) ++count_p4;\n\t\t\t\t\t}\n\t\t\t\t\tMax = max(Max, max(count_p3, count_p4));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << Max << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# 1 \"1132.cpp\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 175 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"1132.cpp\" 2\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n# 1 \"./../geometory.cpp\" 1\n# 1 \"geometry.h\"\n# 1 \"<command-line>\"\n# 1 \"geometry.h\"\nusing namespace std;\n\n\n# 1 \"point.cpp\" 1\ntypedef complex<double> Point;\nconst double EPS = 1e-8;\n\n\nint sign(double a){\n    if(a > EPS) return +1;\n    if(a < -EPS) return -1;\n    return 0;\n}\n\n\nnamespace std{\n    bool operator < (const Point& a, const Point& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\n\ndouble dot(Point a, Point b){\n    return real(conj(a) * b);\n}\ndouble cross(Point a, Point b){\n    return imag(conj(a) * b);\n}\n\n\n\ndouble angle(Point a, Point b){\n    return arg(conj(a) * b);\n}\n\n\n\nPoint rotate(Point a, double b, Point c = Point()){\n    return (a - c) * polar(1.0, b) + c;\n}\n\n\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > +EPS) return +1;\n    if (cross(b, c) < -EPS) return -1;\n    if (dot(b, c) < 0) return +2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\n# 4 \"geometry.h\" 2\n# 1 \"line.cpp\" 1\nstruct Line : public vector<Point> {\n    Line(const Point& a, const Point& b) {\n        push_back(a); push_back(b);\n    }\n    Point vector() const {\n        return back() - front();\n    }\n};\n\n\n\n\n\nbool paralell(Line l, Line m){\n    return sign(cross(l.vector(), m.vector())) == 0;\n}\n\n\nbool equalLL(Line l, Line m){\n    return sign(cross(l.vector(), m[0] - l[0])) == 0;\n}\n\n\nbool iLP(Line l, Point p) {\n\n    return sign(cross(l.vector(), p - l[0])) == 0;\n}\n\n\n\nbool iSP(Line s, Point p) {\n    return ccw(s[0], s[1], p) == 0;\n}\n\n\nbool iLS(Line l, Line s) {\n\n    return sign(cross(l.vector(), s[0] - l[0]) * cross(l.vector(), s[1] - l[0])) <= 0;\n}\n\n\nbool iSS(Line s, Line t) {\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n        ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\n\n\nPoint proj(Line l, Point p){\n    double t = dot(p - l[0], l.vector()) / norm(l.vector());\n    return l[0] + t * l.vector();\n}\n\n\nPoint refl(Line l, Point p){\n    return 2.0 * proj(l, p) - p;\n}\n\n\ndouble dLP(Line l, Point p){\n\n    return abs(cross(l.vector(), p - l[0])) / abs(l.vector());\n}\n\n\ndouble dSP(Line s, Point p){\n    if(sign(dot(s.vector(), p - s[0])) <= 0) return abs(p - s[0]);\n    if(sign(dot(-s.vector(), p - s[1])) <= 0) return abs(p - s[1]);\n    return dLP(s, p);\n}\n\n\ndouble dLL(Line l, Line m){\n\n    return paralell(l, m) ? dLP(l, m[0]) : 0;\n}\n\n\ndouble dLS(Line l, Line s){\n    if(iLS(l, s)) return 0;\n    return min(dLP(l, s[0]), dLP(l, s[1]));\n}\n\n\ndouble dSS(Line s, Line t){\n    if(iSS(s, t)) return 0;\n    return min({dSP(s, t[0]), dSP(s, t[1]), dSP(t, s[0]), dSP(t, s[1])});\n}\n\n\nPoint pLL(Line l, Line m){\n    double A = cross(l.vector(), m.vector());\n    double B = cross(l.vector(), l[1] - m[0]);\n    if(sign(A) == 0 && sign(B) == 0) return m[0];\n    if(sign(A) == 0) assert(false);\n    return m[0] + m.vector() * B / A;\n}\n# 5 \"geometry.h\" 2\n# 1 \"polygon.cpp\" 1\ntypedef vector<Point> Polygon;\n\n\nPoint curr(const Polygon& a, int x){ return a[x]; }\nPoint next(const Polygon& a, int x){ return a[(x + 1) % a.size()]; }\nPoint prev(const Polygon& a, int x){ return a[(x - 1 + a.size()) % a.size()]; }\n\n\n\nenum { OUT, ON, IN };\nint contains(const Polygon& P, const Point& p){\n\n    bool in = false;\n    for(int i = 0; i < P.size(); i++){\n        Point a = curr(P, i) - p;\n        Point b = next(P, i) - p;\n        if(a.imag() > b.imag()) swap(a, b);\n\n        if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0){\n            in = !in;\n        }\n        if(sign(cross(a, b)) == 0 && sign(dot(a, b)) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n\n\n\ndouble area(const Polygon& P) {\n    double A = 0;\n    for(int i = 0; i < P.size(); i++){\n        A += cross(curr(P, i), next(P, i));\n    }\n    return abs(A) / 2.0;\n}\n# 6 \"geometry.h\" 2\n# 1 \"convex.cpp\" 1\n\nPolygon convex_hull(vector<Point> ps) {\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<Point> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n\nbool is_convex(const Polygon& P){\n    for(int i = 0; i < P.size(); i++){\n        if(ccw(prev(P, i), curr(P, i), next(P, i)) > 0) return false;\n    }\n    return true;\n}\n\n\n\nPolygon convex_cut(const Polygon& P, Line l){\n    Polygon Q;\n    for(int i = 0; i < P.size(); i++){\n        Point A = curr(P, i), B = next(P, i);\n        if(ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if(ccw(l[0], l[1], A) * ccw(l[0], l[1], B) < 0)\n            Q.push_back(pLL(l, Line(A, B)));\n    }\n    return Q;\n}\n\n\nLine bisector(Point a, Point b){\n    Point mid = (a + b) / 2.0;\n    Point vec = (mid - a) * Point(0.0, 1.0);\n    return Line(mid, mid + vec);\n}\n\n\nPolygon voronoi_cell(Polygon P, const vector<Point>& ps, int s){\n    for(int i = 0; i < ps.size(); i++){\n        if(i != s) P = convex_cut(P, bisector(ps[s], ps[i]));\n    }\n    return P;\n}\n# 7 \"geometry.h\" 2\n# 1 \"circle.cpp\" 1\nstruct Circle {\n    Point p;\n    double r;\n    Circle() {}\n    Circle(Point p, double r) : p(p), r(r) { }\n};\n\n\nenum{ OUT, ON, IN };\nint contains(const Circle& C, const Point& p){\n    double d = abs(C.p - p);\n    if(sign(d - C.r) > 0) return OUT;\n    if(sign(d - C.r) == 0) return ON;\n    return IN;\n}\n\n\n\nbool iCS(const Circle& C, const Line& l){\n    int c1 = contains(C, l[0]);\n    int c2 = contains(C, l[1]);\n    if(c1 > c2) swap(c1, c2);\n\n\n    if(c1 == OUT && c2 == IN) return true;\n    if(c1 == IN && c2 == IN) return false;\n    if(c1 == ON) return true;\n    double d = dSP(l, C.p);\n    if(sign(d - C.r) < 0) return true;\n    if(sign(d - C.r) == 0) return true;\n    if(sign(d - C.r) > 0) return false;\n}\n\n\nbool iCC(const Circle& C, const Circle& D){\n\n    double e = abs(C.p - D.p);\n    return sign(e - (C.r + D.r)) <= 0 && sign(e - abs(C.r - D.r)) >= 0;\n}\n\n\n\nvector<Point> pLC(const Line &l, const Circle &c) {\n    vector<Point> res;\n    Point center = proj(l, c.p);\n    double d = abs(center - c.p);\n    double tt = c.r * c.r - d * d;\n    if(tt < 0 && tt > -EPS) tt = 0;\n    if(tt < 0) return res;\n    double t = sqrt(tt);\n    Point vect = l.vector();\n    vect /= abs(vect);\n    res.push_back(center - vect * t);\n    if (t > EPS) {\n        res.push_back(center + vect * t);\n    }\n    return res;\n}\n\n\nvector<Point> pSC(const Line &s, const Circle &c) {\n    vector<Point> ret;\n    vector<Point> nret = pLC(s, c);\n    for (int i = 0; i < nret.size(); i++) {\n        if (iSP(s, nret[i])) ret.push_back(nret[i]);\n    }\n    return ret;\n}\n\n\n\nvector<Point> pCC(Circle a, Circle b){\n    vector<Point> res;\n\n    double l = abs(b.p - a.p);\n\n    if(sign(l) == 0 && sign(a.r - b.r) == 0) assert(false);\n    if(sign(l - abs(a.r - b.r)) < 0 || sign(l - (a.r + b.r)) > 0) return res;\n\n    double th1 = arg(b.p - a.p);\n    if(sign(l - abs(a.r - b.r)) == 0 || sign(l - (a.r + b.r)) == 0){\n        res.push_back(a.p + polar(a.r, th1));\n    }else {\n        double th2 = acos( (a.r * a.r - b.r * b.r + l * l) / (2 * a.r * l) );\n        res.push_back(a.p + polar(a.r, th1 - th2));\n        res.push_back(a.p + polar(a.r, th1 + th2));\n    }\n    return res;\n}\n\n\n\nvector<Point> touching_circle2(Point a, Point b, double r){\n    vector<Point> res;\n\n    double d = abs(b - a);\n    if(d > 2 * r) return res;\n\n    Point mid = 0.5 * (a + b);\n    Point dir = polar(sqrt(r * r - d * d / 4), arg(b - a) + M_PI / 2);\n    res.push_back(mid + dir);\n    res.push_back(mid - dir);\n    return res;\n}\n\n\nCircle touching_circle3(Point a, Point b, Point c){\n\n    Point mid_ab = (a + b) / 2.0;\n    Line bis_ab(mid_ab, (mid_ab - a) * Point(0.0, 1.0));\n    Point mid_bc = (b + c) / 2.0;\n    Line bis_bc(mid_bc, (mid_bc - b) * Point(0.0, 1.0));\n\n    assert(!paralell(bis_ab, bis_bc));\n\n    Point center = pLL(bis_ab, bis_bc);\n    return Circle(center, abs(a - center));\n}\n\n\n\ndouble cc_area(const Circle& c1, const Circle& c2) {\n    double d = abs(c1.p - c2.p);\n    if (c1.r + c2.r < d + EPS) {\n        return 0.0;\n    } else if (d < abs(c1.r - c2.r) + EPS) {\n        double r = min(c1.r, c2.r);\n        return r * r * M_PI;\n    } else {\n        double rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n        double theta = acos(rc / c1.r);\n        double phi = acos((d - rc) / c2.r);\n        return c1.r*c1.r*theta + c2.r*c2.r*phi - d*c1.r*sin(theta);\n    }\n}\n# 8 \"geometry.h\" 2\n# 1 \"circle_tangent.cpp\" 1\n\n\nLine circle_tangent(const Circle& C, double th){\n    Point p0 = C.p + polar(C.r, th);\n    Point p1 = p0 + polar(1.0, th + M_PI / 2);\n    return Line(p0, p1);\n}\n\n\n\n\nvector<double> common_tangents(const Circle& C, const Circle& D){\n    vector<double> res;\n    Point v = D.p - C.p;\n    double l = abs(v);\n    double a = arg(v);\n    if(sign(l - abs(C.r - D.r)) > 0){\n\n\n        double a1 = acos((C.r - D.r) / l);\n        res.push_back(a + a1);\n        res.push_back(a - a1);\n        if(sign(l - (C.r + D.r)) > 0){\n\n\n            double a2 = acos((C.r + D.r) / l);\n            res.push_back(a + a2);\n            res.push_back(a - a2);\n        }\n    }\n    if((sign(l - abs(C.r - D.r)) == 0 || sign(l - (C.r + D.r)) == 0) && sign(l) != 0){\n\n\n        res.push_back(a);\n    }\n    return res;\n}\n\n\n\nvector<Line> tangents_through_point(const Circle& C, const Point& p){\n    vector<Line> tangents;\n    double d = abs(C.p - p);\n\n    double e = sqrt(d * d - C.r * C.r);\n\n    double th = asin(C.r / d);\n    Point q1 = p + (C.p - p) * polar(1.0, +th) * e / d;\n    Point q2 = p + (C.p - p) * polar(1.0, -th) * e / d;\n    tangents.push_back(Line(p, q1));\n    tangents.push_back(Line(p, q2));\n    return tangents;\n}\n# 8 \"geometry.h\" 2\n# 7 \"1132.cpp\" 2\n\nint main(){\n    int N;\n    while(cin >> N && N > 0) {\n        vector<Point> ps(N);\n        for(int i=0; i<(int)(N); ++i) {\n            double x, y;\n            cin >> x >> y;\n            ps[i] = Point(x, y);\n        }\n\n        int ans = 1;\n        for(int i=0; i<(int)(N); ++i) for(int j=0; j<(int)(N); ++j) if(i != j) {\n            vector<Point> cv = touching_circle2(ps[i], ps[j], 1.0);\n            for(auto c : cv) {\n                int sum = 0;\n                for(int k=0; k<(int)(N); ++k) {\n                    if(sign(abs(c - ps[k]) - 1.0) <= 0) {\n                        sum++;\n                    }\n                }\n                ans = max(ans, sum);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef double D;\ntypedef complex<D> P;\n\nconst D eps = 0.0001;\n\nint N;\nP ps[300];\n\nbool get_centre(P a, P b, P& r1, P& r2) {\n    if (norm(a - b) > 4) { return false; }\n    P m = (a + b) / 2.0 - a;\n    D l = sqrt(1 * 1 - norm(m));\n    P c = m * P(0, 1);\n    P cl = c / abs(c) * l;\n    r1 = a + m + cl;\n    r2 = a + m - cl;\n    return true;\n}\n\nint solve() {\n    int ans = 1;\n    for (int i = 0; i < N - 1; i++) {\n        for (int j = i + 1; j < N; j++) {\n            P r1, r2;\n            if (!get_centre(ps[i], ps[j], r1, r2)) { continue; }\n\n            int r1_cnt = 0;\n            int r2_cnt = 0;\n\n            for (int k = 0; k < N; k++) {\n                if (norm(ps[k] - r1) <= 1 + eps) { r1_cnt++; }\n                if (norm(ps[k] - r2) <= 1 + eps) { r2_cnt++; }\n            }\n\n            ans = max(ans, r1_cnt);\n            ans = max(ans, r2_cnt);\n        }\n    }\n    return ans;\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d\", &N);\n        if (!N) { break; }\n        for (int i = 0; i < N; i++) {\n            D x, y;\n            scanf(\"%lf%lf\", &x, &y);\n            ps[i] = P(x, y);\n        }\n        printf(\"%d\\n\", solve());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\ntypedef double Num;\ntypedef complex<Num> Pt2;\n\nstruct Circle2 {\n  Pt2 p; Num r;\n  Circle2(Pt2 p, Num r) : p(p), r(r) {}\n};\n\nconst double eps = 1e-10;\nconst double pi  = 3.14159265358979323846;\n\nPt2  ortho(Pt2 v)        { return v*Pt2(0,1); }\nPt2  unit (Pt2 v)        { return v/abs(v);   }\n\nvector<Circle2> make_circle(Pt2 a, Pt2 b, Num r) {\n\tNum d = abs(b-a)/2.0;\n\td = sqrt(r*r-d*d); // assert(r*r-d*d >= 0)\n\tPt2 p = (b+a)/2.0;\n\tPt2 v = unit(ortho(b-a)) * d;\n\n\tvector<Circle2> ret;\n\tret.push_back(Circle2(p+v,r));\n\tret.push_back(Circle2(p-v,r));\n\treturn ret;\n}\n\nbool into_circle(Circle2 p, Pt2 a) {\n\treturn abs(a-p.p)*abs(a-p.p) < p.r*p.r+eps;\n}\n\nint main()\n{\n\tint N;\n\twhile(cin>>N, N)\n\t{\n\t\tPt2 ps[300];\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tNum x,y;\n\t\t\tcin>>x>>y;\n\t\t\tps[i]=Pt2(x,y);\n\t\t}\n\n\t\tint ans=1;\n\t\tfor(int i=  0; i<N; i++)\n\t\tfor(int j=i+1; j<N; j++) {\n\t\t\tif(abs(ps[i]-ps[j]) > 2.0) continue;\n\n\t\t\tvector<Circle2> cs = make_circle(ps[i], ps[j], 1.0);\n\t\t\tfor(int k=0; k<2; k++){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int l=0; l<N; l++) {\n\t\t\t\t\tif(into_circle(cs[k], ps[l])) cnt++;\n\t\t\t\t}\n\t\t\t\tans=max(ans,cnt);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//???????????????????????????, ?????????????????????????????°????????????????????????????????????????????????2???????????¨???????????£?????\\????????¨?????§????????????\n//?????£???, 2??????????????????1?????????????????????????????????????????°??????????????????????£????, O(N^2)????????????????????????, ??¨?????§O(N^3)????????§?§£?????????\n#include <iostream>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> Point;\n\nint n;\ndouble x[300], y[300];\nvector<Point> points;\t//????£???????\n\nint main() {\n\twhile (cin >> n) {\n\t\tif (n == 0) break;\n\t\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tPoint p1 = Point(x[i], y[i]);\n\t\t\t\tPoint p2 = Point(x[j], y[j]);\n\t\t\t\tif (norm(p1 - p2) < 4) {\n\t\t\t\t\tdouble h = sqrt(1.0 - norm(p1 - p2) / 4.0);\n\t\t\t\t\tPoint t = p2 - p1; t /= abs(t);\n\t\t\t\t\tPoint u = t * Point(0, 1);\n\t\t\t\t\tpoints.push_back(p1 + t * abs(p1 - p2) / 2.0 + u * h);\n\t\t\t\t\tpoints.push_back(p1 + t * abs(p1 - p2) / 2.0 - u * h);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble eps = 1e-10;\n\t\tint ans = 1;\n\t\tfor (int i = 0; i < points.size(); i++) {\n\t\t\tdouble px = points[i].real();\n\t\t\tdouble py = points[i].imag();\n\t\t\tint cnt = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ((x[j] - px) * (x[j] - px) + (y[j] - py) * (y[j] - py) < 1 + eps) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ans < cnt) ans = cnt;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint N;\npair<double,double> dots[300];\n\nint main(){\n\n\twhile(cin >> N && N != 0){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tpair<double,double> p;\n\t\t\tcin >> dots[i].second >> dots[i].first;\n\t\t}\n\t\tint maxCnt = 1;\n\t\t// ~ðìé½ßÌQ_ðßé\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = i+1; j < N; j++){\n\t\t\t\tpair<double,double> dot1,dot2;\n\t\t\t\tdot1 = dots[i];\n\t\t\t\tdot2 = dots[j];\n\n\t\t\t\tdouble v = sqrt((dot1.first - dot2.first)*(dot1.first - dot2.first)\n\t\t\t\t\t+(dot1.second - dot2.second)*(dot1.second - dot2.second));\n\t\t\t\t// ñ_Ô£ª2æè¨¨«¯êÎÂ­êÈ¢\n\t\t\t\tif(v > 2){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdouble x = sqrt(1 - (v/2)*(v/2));\n\n\t\t\t\t// ñgÌPÊ@üxNg\n\t\t\t\tpair<double,double> hose[2];\n\t\t\t\those[0].first = -1.0/(dots[i].first - dots[j].first);\n\t\t\t\those[0].second = 1.0/(dots[i].second - dots[j].second);\n\t\t\t\those[1].first = 1.0/(dots[i].first - dots[j].first);\n\t\t\t\those[1].second = -1.0/(dots[i].second - dots[j].second);\n\n\t\t\t\tdouble dd1 = sqrt((hose[0].second)*(hose[0].second)+(hose[0].first)*(hose[0].first));\n\t\t\t\tdouble dd2 = sqrt((hose[1].second)*(hose[1].second)+(hose[1].first)*(hose[1].first));\n\t\t\t\those[0].first /= dd1; hose[0].second /= dd1;\n\t\t\t\those[1].first /= dd2; hose[1].second /= dd2;\n\n\t\t\t\t// x{·é\n\t\t\t\those[0].first *= x;hose[1].first *= x;\n\t\t\t\those[0].second *= x;hose[1].second *= x;\n\n\t\t\t\t// mð«·\n\t\t\t\those[0].first += (dot1.first + dot2.first)/2;\n\t\t\t\those[0].second += (dot1.second + dot2.second)/2;\n\t\t\t\those[1].first += (dot1.first + dot2.first)/2;\n\t\t\t\those[1].second += (dot1.second + dot2.second)/2;\n\n\t\t\t\t// hose[0]Æhose[1]Í~ÌSÀW\n\t\t\t\t// e_ÉÖµÄ~ÌÉ¶Ý·é©Ç¤©ðßé\n\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor(int l = 0; l < N; l++){\n\t\t\t\t\t\tdouble dist = sqrt((dots[l].first -hose[k].first)*(dots[l].first -hose[k].first)\n\t\t\t\t\t\t\t+ (dots[l].second -hose[k].second)*(dots[l].second -hose[k].second));\n\t\t\t\t\t\tif(dist <= 1){\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmaxCnt = max(maxCnt,cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << maxCnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (n); i++)\ntypedef complex<double> P;  // Point\nstatic const double EPS = 1e-6;\n\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<P> points;\n\t\tpriority_queue<tuple<int, double, double, double>, vector<tuple<int, double, double, double>>> pq;\n\t\trep(n, N) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoints.push_back(P(x, y));\n\t\t}\n\t\ttuple<int, double, double, double> s = make_tuple(N, -5.0, 5.0, 5.0);\n\t\tpq.push(s);\n\t\twhile(!pq.empty()) {\n\t\t\ts = pq.top();\n\t\t\t//cout << get<1>(s)<< \" \" <<get<0>(s) << endl;\n\t\t\tif (-get<1>(s) < EPS) break;\n\t\t\tpq.pop();\n\t\t\tdouble r = -get<1>(s) / 2;\n\t\t\trep(i, 2) {\n\t\t\t\trep(j, 2) {\n\t\t\t\t\tdouble x1 = get<2>(s) - get<1>(s) / 2 + i * get<1>(s);\n\t\t\t\t\tdouble y1 = get<3>(s) - get<1>(s) / 2 + j * get<1>(s);\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tP p1 = P(x1, y1);\n\t\t\t\t\tfor(auto p2 : points) {\n\t\t\t\t\t\tif (abs(p1 - p2) < r * sqrt(2) + 1 + EPS) cnt++;\n\t\t\t\t\t}\n\t\t\t\t\tpq.push(make_tuple(cnt, -r, x1, y1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << get<0>(s) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> coor;\n\n#define EPS 1e-5\n\ndouble in_cir(coor o, coor x)\n{\n  return abs(x - o);\n}\n\nint search(vector<coor> P)\n{\n  int mx = 1;\n  /*for (int i = 0; i < P.size(); i++) {\n    printf(\"%lf, %lf\\n\", P[i].real(), P[i].imag());\n    }*/\n  for (int i = 0; i < P.size(); i++) {\n    for (int j = i + 1; j < P.size(); j++) {\n      for (int k = 0; k < 2; k++) {\n\tif (abs(P[i] - P[j]) - 2.0 > -EPS) {continue;}\n\tcoor d = coor(P[i].imag() - P[j].imag(),\n\t\t      -(P[i].real() - P[j].real()));\n\tif (k == 1) {d = -d;}\n\td /= abs(d);\n\td *= sqrt(1 - norm(P[i] - P[j]) / 4);\n\t//printf(\"abs(d) = %lf\\n\", abs(d));\n\td += (P[i] + P[j]) / 2.0;\n\t//printf(\"%lf, %lf\\n\", d.real(), d.imag());\n\tint ctr = 2;\n\tfor (int l = 0; l < P.size(); l++) {\n\t  //printf(\"%lf\\n\", in_cir(d, P[l]));\n\t  if (l == i || l == j) {continue;}\n\t  if (in_cir(d, P[l]) - 1.0 < -EPS) {\n\t    ctr++;\n\t  }\n\t}\n\t//printf(\"_%d\\n\", ctr);\n\tmx = max(ctr, mx);\n\t\n      }\n    }\n  }\n  return mx;\n}\n\nint main()\n{\n  int N;\n  while (scanf(\"%d \", &N) == 1) {\n    if (N == 0) {\n      break;\n    }\n    vector<coor> P(N);\n    for (int i = 0; i < N; i++) {\n      double x, y;\n      scanf(\"%lf %lf \", &x, &y);\n      P[i] = coor(x, y);\n    }\n    printf(\"%d\\n\", search(P));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nconst double EPS = 1e-9;\nusing Point = pair<double, double>;\n\nvector<Point> getCenter(Point a, Point b) {\n  double xm = (a.first + b.first) / 2;\n  double ym = (a.second + b.second) / 2;\n  double dx = b.first - a.first;\n  double dy = b.second - a.second;\n  double l = hypot(dx, dy) / 2;\n  double t = sqrt((1 - l*l) / (dx*dx + dy*dy));\n  vector<Point> res;\n  res.emplace_back(xm - (-dy)*t, ym - dx*t);\n  res.emplace_back(xm + (-dy)*t, ym + dx*t);\n  return res;\n}\n\nint N;\ndouble X[310], Y[310];\nPoint p[310];\n\nbool contain(Point a, Point b) {\n  return hypot(a.first-b.first, a.second-b.second) - EPS < 1;\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  while (cin >> N, N) {\n    for (int i = 0; i < N; i++) {\n      cin >> X[i] >> Y[i];\n      p[i] = Point(X[i], Y[i]);\n    }\n    int ans = 1;\n    for (int i = 0; i < N; i++) {\n      for (int j = i+1; j < N; j++) {\n        auto c = getCenter(p[i], p[j]);\n        for (int ci = 0; ci < c.size(); ci++) {\n          int sum = 0;\n          for (int k = 0; k < N; k++) {\n            if (contain(c[ci], p[k])) sum++;\n          }\n          ans = max(ans, sum);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <algorithm>\n#include <iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define re real()\n#define im imag()\nusing namespace std;\nint main(){\n\twhile(true){\n\t\tint n,mx=1;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\tcomplex<double> p[300];\n\t\trep(i,n) scanf(\"%lf%lf\",&p[i].re,&p[i].im);\n\t\trep(i,n) rep(j,i){\n\t\t\tdouble d=abs(p[i]-p[j]);\n\t\t\tif(d>2) continue;\n\t\t\tcomplex<double> c=(p[i]+p[j])/2.0,dis=(p[i]-p[j])/d*sqrt(1-d*d/4);\n\t\t\tswap(dis.re,dis.im);\n\t\t\tdis.im=-dis.im;\n\t\t\tcomplex<double> cen=c+dis;\n\t\t\tint cnt=0;\n\t\t\trep(k,n) if(abs(cen-p[k])<=1.0000000001) cnt++;\n\t\t\tmx=max(mx,cnt);\n\t\t\tcen=c-dis;\n\t\t\tcnt=0;\n\t\t\trep(k,n) if(abs(cen-p[k])<=1.0000000001) cnt++;\n\t\t\tmx=max(mx,cnt);\n\t\t}\n\t\tprintf(\"%d\\n\",mx);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\nconst double EPS = 1e-10;\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>bool chmin(T &a, const T &b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// input\ntemplate<typename T>\nvoid input(T& a) { cin >> a; }\ntemplate<typename T,typename... Ts>\nvoid input(T& a,Ts&... ts) {\n    input<T>(a);\n    input<T>(ts...);\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a,make_vector<T>(b,ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) {\n        is >> e;\n    }\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\ntemplate<typename T>\nusing Edges = vector<edge<T>>;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate<typename T>\nusing MatrixGraph = vector<vector<T>>;\n\nint main()\n{\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) {\n            break;\n        }\n\n        vector<complex<double>> p(n);\n        for (int i = 0; i < n; ++i) {\n            double x, y; cin >> x >> y;\n            p[i] = {x, y};\n        }\n\n        int ans = 1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i+1; j < n; ++j) {\n                if (abs(p[i] - p[j]) > 2) {\n                    continue;\n                }\n                complex<double> m = (p[i] + p[j]) / 2.,\n                                d = (p[i] - p[j]) * polar(1.,M_PI/2.);\n                d /= abs(d);\n                d *= sqrt(1. - norm(p[i] - m));\n\n                for (auto t : {-1., 1.}) {\n                    complex<double> c = m + t * d;\n\n                    int cnt = 0;\n                    for (int k = 0; k < n; ++k) {\n                        if (abs(p[k] - c) <= 1 + EPS) {\n                            ++cnt;\n                        }\n                    }\n                    chmax(ans, cnt);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n// ??????????????§?????????????????§???3????????????????????????????±?????????????????????¨?????????\n\ndouble pow2(double d){\n\treturn d * d;\n}\n\nstruct Vector2{\n\tdouble x;\n\tdouble y;\n};\n\nVector2 P[500];\n\nint main(){\n\tint n;\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> P[i].x >> P[i].y;\n\t\t}\n\t\tdouble k, L_2, a, b;\n\t\t\n\t\tint max = 0;\n\t\t\n\t\tfor(int num1 = 0; num1 < n; num1++){\n\t\t\tfor(int num2 = num1 + 1; num2 < n; num2++){\n\t\t\t\tL_2 = pow2(P[num1].x - P[num2].x) + pow2(P[num1].y - P[num2].y);\n\t\t\t\tif(L_2 >= 4){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tk = sqrt((4 - L_2) / L_2);\n\t\t\t\t\n\t\t\t\ta = (k * (P[num1].y - P[num2].y) + P[num1].x + P[num2].x) / 2;\n\t\t\t\tb = (k * (P[num2].x - P[num1].x) + P[num1].y + P[num2].y) / 2;\n\t\t\t\t\n\t\t\t\tint count;\n\t\t\t\t\n\t\t\t\tcount = 0;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(i == num1 || i == num2){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(pow2(P[i].x - a) + pow2(P[i].y - b) <= 1){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(max < count){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ta = (k * (P[num2].y - P[num1].y) + P[num1].x + P[num2].x) / 2;\n\t\t\t\tb = (k * (P[num1].x - P[num2].x) + P[num1].y + P[num2].y) / 2;\n\t\t\t\t\n\t\t\t\tcount = 0;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(i == num1 || i == num2){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(pow2(P[i].x - a) + pow2(P[i].y - b) <= 1){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(max < count){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", max);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){\n    rep(i,v.size()) os << v[i] << (i+1==v.size()?\"\":\" \");\n    return os;\n}\n\ntypedef double R;\ntypedef complex<R> P;\nR const eps = 1e-8;\nR const pi = acos(-1);\n\nint main(){\n    int n;\n    while(cin>>n && n){\n        vector<P> ps(n);\n        rep(i,n){\n            R x,y; cin >> x >> y;\n            ps[i] = P(x,y);\n        }\n        int ans = 1;\n        rep(i,n)rep(j,i){\n            P & p = ps[i];\n            P & q = ps[j];\n            R d = abs(p-q)/2;\n            if(d+eps > 1.0) continue;\n            P m = (p+q)/R(2);\n            R l = sqrt(1-d*d);\n            P c = m + (p-m)/d*l*P(0,1);\n            int cnt = 0;\n            rep(k,n){\n                if(abs(c-ps[k]) < 1.0+eps) cnt++;\n                if(n-k+cnt+1 < ans) break;\n            }\n            ans = max(ans,cnt);\n            if(ans==n) goto END;\n        }\n    END:;\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<map>\nusing namespace std;\n#define INF 1e+10\n#define EPS 1e-10\n#define EQ(a,b) (abs(a-b)<EPS)\n\n//誤差を考慮して足し算\ninline double add(double a,double b){\n\tif(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{//2次元ベクトル\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tbool operator ==(P p){\n\t\treturn x==p.x && y==p.y;\n\t}\n\tbool equal(P p){\n\t\treturn (x-p.x)*(x-p.x)+(y-p.y)*(y-p.y) < EPS*EPS;\n\t}\t\n\tdouble dot(P p){//内積\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){//外積\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n};\n//線分p1-p2上に点qがあるか判定\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n//直線p1-p2と直線q1-q2の交点\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*( (q2-q1).det(q1-p1)/(q2-q1).det(p2-p1) );\n}\n//線分p1-p2と線分q1-q2が交差するか\nbool intersecting(P p1,P p2,P q1,P q2){\n\tif(on_seg(p1,p2,q1)||on_seg(p1,p2,q2)||on_seg(q1,q2,p1)||on_seg(q1,q2,p2))return true;\n\tif((p1-p2).det(q1-q2)==0 )return false;//平行\n\tP a=intersection(p1,p2,q1,q2);\n\treturn on_seg(p1,p2,a) && on_seg(q1,q2,a);\n}\nP rotate(P p,double rad){\n\tdouble s=sin(rad),c=cos(rad);\n\treturn P(c*p.x-s*p.y, s*p.x+c*p.y);\n}\ndouble dist(P p,P q){\n\tp = p-q;\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\n\n//円同士の交点を計算\npair<P,P> circle_intersection(double x1,double y1,double r1,double x2,double y2,double r2){\n\tx2 -= x1;\n\ty2 -= y1;\n\tdouble rad = atan2(y2,x2);\n\tP tmp = rotate(P(x2,y2),-rad);\n\tx2 = tmp.x;\n\ty2 = tmp.y;\n\tdouble x = (r1*r1-r2*r2+x2*x2)/(2*x2);\n\tif(abs(r1) < abs(x))return make_pair(P(0,0),P(0,0));//交点なし\n\tdouble y = sqrt(r1*r1-x*x);\n\treturn make_pair( P(x1,y1)+rotate(P(x,y),rad) ,  P(x1,y1)+rotate(P(x,-y),rad) );\n}\n//2点を通る円の中心座標\npair<P,P> circle_on_2P(P p,P q,double r){\n\tif(2*r < dist(p,q))return make_pair(P(0,0),P(0,0));//解なし\n\tif(q.x < p.x)swap(p,q);\n\tq = q - p;\n\tdouble rad = atan2(q.y,q.x);\n\tP tmp = rotate(q,-rad);\n\tdouble x = tmp.x/2;\n\tdouble y = sqrt(4*r*r-tmp.x*tmp.x)/2;\n\treturn make_pair( p+rotate(P(x,y),rad) ,  p+rotate(P(x,-y),rad) );\n}\n\nint n;\nP c[300];\nint calc(P p,P q){\n\tif (2 < dist(p,q))return 1;\n\tpair<P,P> pa = circle_on_2P(p,q,1.0);\n\tint res=0,t=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(dist(pa.first,c[i])<=1)t++;\n\t}\n\tres = t;\n\tt=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(dist(pa.second,c[i])<=1)t++;\n\t}\n\tres = max(res,t);\n\treturn res;\n}\nint main(){\n\twhile(cin>>n&&n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tc[i] = P(x,y);\n\t\t}\n\t\tint ans=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tans = max(ans,calc(c[i],c[j]));\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <complex>\n\n \nusing namespace std;\n \n#define INF 1000000000\n#define EPS 1e-9\n#define PI acos(-1)\n \ntypedef long long ll;\ntypedef complex<double> vec;\n\n#define MAX_N 300\nint N;\ndouble x[MAX_N], y[MAX_N];\nvector<int> ans_list;\n\nint par[MAX_N];\n\nint main(){\n\n  while(true){\n    cin >> N;\n    if(N == 0)\n      break;\n    for(int i = 0; i < N; i++){\n      cin >> x[i] >> y[i];\n    }\n\n    int ans = 0;\n\n    for(int i = 0; i < N; i++){\n      for(int j = i+1; j < N; j++){\n\tif(sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j])) > 2.0001)\n\t  continue;\n\tint tmp = 0;\n\tvec p1 = vec(x[i], y[i]), p2 = vec(x[j], y[j]);\n\tvec mid = (p2-p1);\n\tmid /= 2;\n\tvec r1 = (mid * vec(0, 1)) / abs(mid);\n\tvec r2 = (mid * vec(0, -1)) / abs(mid);\n\n\tvec R = p1 + mid + r1*sqrt((1-abs(mid)*abs(mid)));\n\tdouble rx = R.real();\n\tdouble ry = R.imag();\n\ttmp = 2;\n\tfor(int k = 0; k < N; k++){\n\t  if(k == i || k == j)\n\t    continue;\n\t  if((rx - x[k])*(rx-x[k]) + (ry - y[k])*(ry - y[k]) < 1)\n\t    tmp++;\n\t}\n\tans = max(ans, tmp);\n\tR = p1 + mid + r2*sqrt((1-abs(mid)*abs(mid)));\n\trx = R.real();\n\try = R.imag();\n\ttmp = 0;\n\tfor(int k = 0; k < N; k++){\n\t  if(k == i || k == j)\n\t    continue;\n\t  if((rx - x[k])*(rx-x[k]) + (ry - y[k])*(ry - y[k]) < 1)\n\t    tmp++;\n\t}\n\tans = max(ans, tmp);\n      }\n    }\n\n    if(ans == 0 && N >= 1)\n      ans_list.push_back(1);\n    else\n      ans_list.push_back(ans);\n    \n  }\n  \n  for(int i = 0; i < ans_list.size(); i++){\n    cout << ans_list[i] << endl;\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\n#define MAX_N 310\n\nlong double x[MAX_N], y[MAX_N];\nint n, maxn;\n\nint main() {\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tmaxn = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tint sum = 0;\n\n\t\t\t\tlong double X = (x[i] + x[j]) / 2.0;\n\t\t\t\tlong double Y = (y[i] + y[j]) / 2.0;\n\n\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t{\n\t\t\t\t\tif (((x[k] - X)*(x[k] - X) + (y[k] - Y)*(y[k] - Y)) <= 1) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\n\t\t\t\tlong double X1, Y1, X2, Y2, X3, Y3, VX2, VY2, Dist, Dist2;\n\n\t\t\t\t/*Dist = sqrtl((x[j] - x[i])*(x[j] - x[i]) + (y[j] - y[i])*(y[j] - y[i]));\n\t\t\t\tDist2 = sqrtl(4 - Dist*Dist);\n\t\t\t\tX2 = x[j] - x[i]; Y2 = y[j] - y[i];\n\t\t\t\tVX2 = (X2 / Dist)*Dist2 / 2; VY2 = (Y2 / Dist)*Dist2 / 2;\n\t\t\t\tX1 = X + VY2; Y1 = Y - VX2;\n\t\t\t\tX3 = X - VY2; Y3 = Y + VX2;\n\n\t\t\t\tsum = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (((x[k] - X1)*(x[k] - X1) + (y[k] - Y1)*(y[k] - Y1)) <= 1) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\t\t\t\tsum = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (((x[k] - X3)*(x[k] - X3) + (y[k] - Y3)*(y[k] - Y3)) <= 1) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);*/\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint sum = 0;\n\t\t\tlong double X = x[i];\n\t\t\tlong double Y = y[i];\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (((x[k] - X)*(x[k] - X) + (y[k] - Y)*(y[k] - Y)) <= 1) {\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxn = max(maxn, sum);\n\t\t}\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(N); i++)\n\nusing namespace std;\nnamespace geom{\n#define at(i) ((*this)[i])\n#define pb push_back\n#define X real()\n#define Y imag()\n#define SELF (*this)\ntypedef long double R;\ntypedef complex<R> P;\nconst R EPS = 1e-8;\nconst R PI=3.14159265358979323846264338327950288;\nenum { TURE = 1, FALSE = 0, BORDER= -1};\ninline int sig(const R&x){return (abs(x)<EPS?0:x>0?1:-1);}\ninline int less(const R &x,const R &y){return sig(x-y)?x<y:BORDER;}\ninline R inp(const P &a,const P &b){return (conj(a)*b).X;}\ninline R outp(const P &a,const P & b){return (conj(a)*b).Y;}\ninline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\ninline P unit(const P & p){return p/abs(p);}\ninline P proj(const P &s,const P &t){return t*inp(s,t)/norm(t);}\nstruct L :public vector<P>{\n  L(const P &p1,const P &p2){this->pb(p1);this->pb(p2);}\n  L(){}\n  P dir()const {return at(1)-at(0);}\n  int online(const P &p) const {return !sig(outp(p-at(0),dir()));}\n};\nstruct S: public L {\n    S(const P &p1, const P &p2): L(p1,p2){}\n    S(){}\n    int online(const P &p) const{\n        if(!sig(norm( p-at(0) )) || !sig(norm(p - at(1))) ) return BORDER;\n        return !sig(outp(p-at(0), dir())) && inp(p-at(0), dir()) > EPS && inp(p-at(1),-dir()) > -EPS;\n    }\n};\nstruct C :public P{\n  C(){}\n  C(const P &p,const R r):P(p),r(r){}\n  R r;\n  int inside(const P &p)const { return less(norm(p-SELF),r*r);}\n};\n//inline P proj(const P &s,const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\ninline int intersect (const C &a,const C &b){\n  return less((a.r-b.r)*(a.r-b.r),norm(a-b))+less(norm(a-b),(a.r+b.r)*(a.r+b.r))-1;\n}\n\ninline S crosspoint(const C &c1,const C &c2){\n  if(!intersect(c1,c2)) return S();\n  R d=abs(c1-c2);\n  R x=(c1.r*c1.r-c2.r*c2.r+d*d)/(2*d);\n  R h=sqrt(max<R>(0.,c1.r*c1.r-x*x));\n  P u=unit(c2-c1);\n  return S(c1+u*x+u*P(0,-1)*h,c1+u*x+u*P(0,1)*h);\n}\n\n// inline S crosspoint(const C &c,const L &l){\n//   R d2=dist2(l,c);\n//   if(c.r*c.r+EPS < d2) return S();\n//   P m= proj(c,l);\n//   P u = unit(l[1]-l[0]);\n//   R d=sqrt(max<R>(.0,c.r*c.r-d2));\n//   return S(m+u*d,m-u*d);\n// }\n\nS circlePPR(const P& a, const P& b, R r){\n    return crosspoint( C(a,r), C(b,r) );\n}\n}\nusing namespace geom;\n\nint main(){\n    int N;\n    while(cin>>N, N){\n        int ans = 1;\n        P po[305];\n        rep(i,N){\n            R x, y;\n            cin >> x >> y;\n            po[i] = P(x, y);\n        }\n        rep(i,N) rep(j,i){\n            //if( i==j ) continue;\n            S s = circlePPR( po[i], po[j], 1.0 );\n            //if( s.empty() ) continue;\n            //for(auto t: s) cout << t << \" \"; cout << endl;\n            for(auto k: s){\n                int count = 0;\n                rep(h,N){\n                    if( abs(k-po[h]) < 1.0 + EPS ){\n                        count++;\n                    }\n                }\n                ans = max(ans, count);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\n#define eps (1e-10)\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double x,double y):x(x),y(y){}\n    Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n    Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n    Point operator*(Point p) {return Point(x*p.x-y*p.y,x*p.y+y*p.x);}\n    Point operator*(double k){return Point(x*k,y*k);}\n    double norm(){return x*x+y*y;}\n    double abs(){return sqrt(norm());}\n    bool operator == (const Point &p) const{return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n    double arg(){return atan2(y,x);}\n    double dot(Point p){return x*p.x+y*p.y;}\n    double det(Point p){return x*p.y-y*p.x;}\n};\nbool cmp_x(const Point& p,const Point& q){\n  if(p.x!=q.x) return p.x<q.x;\n  return p.y<q.y;\n}\nstruct Circle{\n    double r;\n    Point p;\n    Circle(){}\n    Circle(Point p,double r):p(p),r(r){}\n};\nbool isIntersectCC(Circle c1,Circle c2){\n    return (c1.p-c2.p).abs()<=c1.r+c2.r+eps;\n}\npair<Point,Point> CrossPointsCC(Circle c1,Circle c2){\n    assert(isIntersectCC(c1,c2));\n    double d=(c1.p-c2.p).abs();\n    double k=acos((d*d+c1.r*c1.r-c2.r*c2.r)/(c1.r*d*2));\n    return make_pair(c1.p+(c2.p-c1.p)*Point(cos(k),sin(k))*(c1.r/d),c1.p+(c2.p-c1.p)*Point(cos(-k),sin(-k))*(c1.r/d));\n}\nPoint p[301];\nint main(){\n    int n;\n    double x,y;\n    while(cin>>n,n){\n        rep(i,n){\n            cin>>x>>y;\n            p[i]=Point(x,y);\n        }\n        int mx=1;\n        rep(i,n)FOR(j,i+1,n){\n            if((p[i]-p[j]).abs()>2) continue;\n            pair<Point,Point> pp=CrossPointsCC(Circle(p[i],1.0),Circle(p[j],1.0));\n            int cnt=0,cnt2=0;\n            rep(k,n){\n                if((pp.first-p[k]).abs()<=1.0) ++cnt;\n                if((pp.second-p[k]).abs()<=1.0) ++cnt2;\n            }\n            mx=max(mx,max(cnt,cnt2));\n        }\n        cout<<mx<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef pair<double, double> PDD;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\ntypedef vector<PDD> VPDD;\n\n#define fst first\n#define snd second\n#define Y first\n#define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nconst double EPS = 1e-6;\n\nVD xs;\nVD ys;\nint N;\n\ndouble distance(int i, int j) {\n    double x = xs[i] - xs[j];\n    double y = ys[i] - ys[j];\n    return sqrt(x * x + y * y);\n}\n\nbool is_over_circle(int i, int j) {\n    return distance(i, j) < 2.0;\n}\n\nVPDD calc_circle(int i, int j) {\n    double d = distance(i, j);\n    double a = acos(d / 2.0);\n    double b = acos(abs(xs[j] - xs[i]) / d);\n    double sita = a + b;\n    PDD p, q;\n    p.X = xs[i] + cos(sita);\n    p.Y = ys[i] + sin(sita);\n    q.X = (xs[i] + xs[j]) - p.X;\n    q.Y = (ys[i] + ys[j]) - p.Y;\n    return VPDD({p, q});\n}\n\nint count_inner_points(PDD circle) {\n    int cnt = 0;\n\n    for (int i = 0; i < N; i++) {\n        double x = circle.X - xs[i];\n        double y = circle.Y - ys[i];\n//        printf(\"--- %.3f %.3f %.3f %.3f\\n\", x, y, x * x + y * y, sqrt(x * x + y * y));\n        cnt += x * x + y * y < 1.0 + EPS;\n    }\n\n    return cnt;\n}\n\nint solve() {\n    int res = 1;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (is_over_circle(i, j)) {\n                VPDD ps = calc_circle(i, j);\n\n                for (auto p : ps) {\n//                    printf(\"%.3f %3f\\n\", p.X, p.Y);\n                    int cnt = count_inner_points(p);\n                    res = max(res, cnt);\n                }\n            }\n        }\n    }\n\n    return res;\n}\n\nint main(void) {\n    while (cin >> N, N) {\n        xs.clear();\n        ys.clear();\n        xs.resize(N);\n        ys.resize(N);\n        for (int i = 0; i < N; i++) {\n            cin >> xs[i] >> ys[i];\n        }\n        \n        cout << solve() << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#define EPS 10e-6\nusing namespace std;\ntypedef complex<double> xy_t;\nint n;\nxy_t points[301];\nint count_in(xy_t center)\n{\n  int ans=0;\n  for(int i=0;i<n;i++)\n  {\n    if (abs(center-points[i])<1.0+EPS)\n      ans++;\n  }\n  return ans;\n}\nxy_t ppdcl(xy_t a)\n{\n  return xy_t(a.imag(),-a.real());\n}\nxy_t delta_v(xy_t C1,xy_t C2)\n{\n  xy_t half=(C1-C2)*0.5;\n  double l=abs(half);\n  return ppdcl(half)*sqrt(1-l*l)*(1/l);\n}\nint main()\n{\n  while(1)\n  {\n    cin>>n;\n    if (n==0) break;\n    double x,y;\n    for(int i=0;i<n;i++)\n    {\n      cin>>x>>y;\n      points[i]=xy_t(x,y);\n    }\n    int maxn=-1;\n    for(int i=0;i<n;i++)\n    {\n      for(int j=i+1;j<n;j++)\n      {\n        if(abs(points[i]-points[j])<2.0+EPS)\n        {\n          xy_t mid_p=(points[i]+points[j])*0.5;\n          maxn=max(maxn,count_in(mid_p+delta_v(points[i],points[j])));\n          maxn=max(maxn,count_in(mid_p-delta_v(points[i],points[j])));\n        }\n      }\n    }\n    cout<<maxn<<endl;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <string> \n#include <vector> \n#include <cmath> \n#include <algorithm> \n#include <cstdlib> \n#include <ctime> \n#include <cstdio> \n#include <functional> \n#include <set> \n#include <sstream> \n\n\nusing namespace std; \n\nint main(){\n\n\tint n;\n\tconst double eps=1e-8;\n\twhile(true){\n\n\t\tcin>>n;\n\n\t\tif(n==0) return 0;\n\n\t\tint ans=0;\n\t\tvector< double > x(n),y(n);\n\n\t\tfor(int i=0;i<n;i++) cin>>x[i]>>y[i];\n\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tconst double d=hypot(x[i]-x[j],y[i]-y[j]);\n\t\t\t\tif(d>2.0-eps) continue;\n\n\t\t\t\tconst double mx=(x[i]+x[j])/2.0;\n\t\t\t\tconst double my=(y[i]+y[j])/2.0;\n\t\t\t\tconst double dvx=(x[i]-x[j])/d;\n\t\t\t\tconst double dvy=(y[i]-y[j])/d;\n\n\t\t\t\tconst double cx1=mx+dvy*sqrt(1.0-d*d/4.0);\n\t\t\t\tconst double cy1=my-dvx*sqrt(1.0-d*d/4.0);\n\n\t\t\t\tconst double cx2=mx-dvy*sqrt(1.0-d*d/4.0);\n\t\t\t\tconst double cy2=my+dvx*sqrt(1.0-d*d/4.0);\n\n\t\t\t\tint res=2;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i || k==j) continue;\n//\t\t\t\t\tif(hypot(x[k]-cx1,y[k]-cy1)<1.0+eps) res++;\n\t\t\t\t\tif((x[k]-cx1)*(x[k]-cx1)+(y[k]-cy1)*(y[k]-cy1)<1.0+eps) res++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tans=max(ans,res);\n\n\t\t\t\tres=2;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i || k==j) continue;\n//\t\t\t\t\tif(hypot(x[k]-cx2,y[k]-cy2)<1.0+eps) res++;\n\t\t\t\t\tif((x[k]-cx2)*(x[k]-cx2)+(y[k]-cy2)*(y[k]-cy2)<1.0+eps) res++;\n\t\t\t\t}\n\n\t\t\t\tans=max(ans,res);\n\n\t\t\t}\n\t\t}\n\n\t\tcout<<ans<<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <sstream>\n#include <complex>\nusing namespace std;\n\n#define REP(i,a,n) for(i=a; i<n; i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define foreach(it,x) for(typeof(x.begin()) it=x.begin(); it!=x.end(); it++)\n\ntypedef complex<double> Point;\nPoint p[300];\n\ndouble sqr(double x){ return x*x; }\n\nbool isok(Point& e, Point& q){\n    return (sqr(e.real() - q.real()) + sqr(e.imag() - q.imag()) < 1.0);\n}\n\n/*\n Point(0,1)@¶É90xñ]\n Point(0,-1)@EÉ90xñ]\n */\nint main(){\n    int n,i,j,k, res;\n\n    while( scanf(\"%d\",&n), n ){\n        res = 1;\n        rep(i,n) cin >> p[i].real() >> p[i].imag();\n\n        rep(i,n){\n            REP(j,i+1,n){\n                double dist = sqr(p[i].real() - p[j].real()) + sqr(p[i].imag() - p[j].imag());\n                if( dist < 4.0 ){\n                    dist /= 4.0; // (d/2)^2\n                    double x = sqrt(1.0 - dist); // x\n                    Point M((p[i].real() + p[j].real())/2.0, (p[i].imag() + p[j].imag())/2.0);\n\n                    Point d = (p[i] - p[j])/abs(p[i] - p[j]);\n                    Point e1 = M + d*Point(0,-1)*x;\n                    Point e2 = M + d*Point(0,1)*x;\n\n                    int cnt1 = 2, cnt2 = 2;\n\n                    rep(k,n) if( i != k && j != k ){ // e1\n                        if( isok(e1, p[k]) ) cnt1++;\n                        if( isok(e2, p[k]) ) cnt2++;\n                    }\n                    res = max(res, max(cnt1,cnt2));\n                }\n            }\n        }\n\n        printf(\"%d\\n\",res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#define rep(i,end) for(int i=0;i<end;i++)\nusing namespace std;\ntypedef complex<double> EN;\n\nint search(const EN a,vector<EN> dat){\n  int count=0;\n  rep(i,dat.size()){\n    if(abs(a-dat[i])<=1) count++;\n  }\n  //  cout <<count<<\" \"<<a<<endl;\n  return count;\n}\n\nEN tekitan(vector<EN> dat ){\n  \n  EN ans(0,0);\n  int maxn=0;\n  /*\n  vector<int> chart(10000,0);\n  for(int i=0;i<10000;i++)\n    chart[i]=search(EN(i/1000,((int)i%100)/10.0),dat);\n  for(double i=0;i<10000;i++)\n    if(maxn<chart[i]){\n      maxn=chart[i];\n      ret=i;\n    }\n  */\n  for(double i=0;i<=10.0;i+=0.1)\n    for(double j=0;j<=10.0;j+=0.1)\n      if (search(EN(i,j),dat)>maxn)\n\t{\n\t  ans=EN(i,j);\n\t  maxn=search(ans,dat);\n\t}\n  return ans;\n}\nint pretan(vector<EN> dataset,EN nearans){\n  int count=search(nearans,dataset);\n  double i=0.1;\n  int up,down,left,right;\n  for(i=0.1;i>0.00005;i/=2){\n    //    cout<<nearans<<endl;\n    up=search(nearans+EN(0,i),dataset);\n    down=search(nearans+EN(0,-i),dataset);\n    left=search(nearans+EN(-i,0),dataset);\n    right=search(nearans+EN(i,0),dataset);\n    if(up==max(up,max(down,max(left,max(right,count)))))\n      {count=up;nearans+=EN(0,i);continue;}\n    if(down==max(up,max(down,max(left,max(right,count)))))\n      {count=down;nearans+=EN(0,-i);continue;}\n    if(left==max(up,max(down,max(left,max(right,count)))))\n      {count=left;nearans+=EN(-i,0);continue;}\n    if(right==max(up,max(down,max(left,max(right,count)))))\n      {count=right;nearans+=EN(i,0);continue;}\n  \n  }\n  \n  \n  return count;\n}\nint main(){\n  int m;\n  double a,b,tmp;\n \n  vector<complex<double> > dataset;\n  EN nearans;\n  cin >>m;\n  while(m){\n\n    dataset.resize(m);\n    rep(i,m){\n      cin>>a>>b;\n      dataset[i]=EN(a,b);\n    }\n    \n    nearans=tekitan(dataset);\n\n    cout <<pretan(dataset,nearans)<<endl;\n    cin >>m;\n  }\n\n  return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<complex<double>> p(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tp[i]=complex<double>(x,y);\n\t\t}\n\n\t\tint res=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(abs(p[i]-p[j])>=2) continue;\n\t\t\t\tcomplex<double> mid=(p[i]+p[j])/complex<double>(2.0,0.0);\n\t\t\t\tauto a=(p[i]-p[j]);\n\t\t\t\tauto v=a*complex<double>(0,1);\n\t\t\t\tv=v/abs(v);\n\t\t\t\tdouble d=abs(mid-p[i]);\n\t\t\t\tdouble t=sqrt(1-d*d);\n\t\t\t\tcomplex<double> c[2]={mid+t*v,mid-t*v};\n\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\tint kai=0;\n\t\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\t\tif(abs(c[k]-p[i])<=1) kai++;\n\t\t\t\t\t}\n\t\t\t\t\tres=max(res,kai);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ndouble pow2(double d){\n\treturn d * d;\n}\n\nstruct Vector2{\n\tdouble x;\n\tdouble y;\n};\n\nVector2 P[500];\n\nint main(){\n\tint n;\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> P[i].x >> P[i].y;\n\t\t}\n\t\tdouble k, L_2, a, b;\n\t\t\n\t\tint max = 0;\n\t\t\n\t\tfor(int num1 = 0; num1 < n; num1++){\n\t\t\tfor(int num2 = num1 + 1; num2 < n; num2++){\n\t\t\t\tL_2 = pow2(P[num1].x - P[num2].x) + pow2(P[num1].y - P[num2].y);\n\t\t\t\tif(L_2 >= 4){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tk = sqrt((4 - L_2) / L_2);\n\t\t\t\t\n\t\t\t\ta = (k * (P[num1].y - P[num2].y) + P[num1].x + P[num2].x) / 2;\n\t\t\t\tb = (k * (P[num2].x - P[num1].x) + P[num1].y + P[num2].y) / 2;\n\t\t\t\t\n\t\t\t\tint count;\n\t\t\t\t\n\t\t\t\tcount = 0;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(i == num1 || i == num2){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(pow2(P[i].x - a) + pow2(P[i].y - b) <= 1){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(max < count){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ta = (k * (P[num2].y - P[num1].y) + P[num1].x + P[num2].x) / 2;\n\t\t\t\tb = (k * (P[num1].x - P[num2].x) + P[num1].y + P[num2].y) / 2;\n\t\t\t\t\n\t\t\t\tcount = 0;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(i == num1 || i == num2){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(pow2(P[i].x - a) + pow2(P[i].y - b) <= 1){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(max < count){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", max);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nconst double eps=1e-10;\ndouble add(double a,double b){\n    if(abs(a+b)<eps*(abs(a)+abs(b)))return 0;\n    return a+b;\n}\n\ntypedef pair<double,double> P;\nP operator+(const P& x,const P& y){\n    return {add(x.first,y.first),add(x.second,y.second)};\n}\n\nP operator-(const P& x,const P& y){\n    return {add(x.first,-y.first),add(x.second,-y.second)};\n\n}\n\nP operator*(const P& x,const double& y){\n    return {x.first*y,x.second*y};\n}\ndouble dot(P x,P y){\n    return add(x.first*y.first,x.second*y.second);\n\n\n}\n\ndouble det(P x,P y){\n    return add(x.first*y.second,-x.second*y.first);\n}\n\nbool onseg(P p1,P p2,P q){\n    return det(p1-q,p2-q)==0 &&dot(p1-q,p2-q)<=0; \n}\n\nP intersection(P p1,P p2,P q1,P q2){\n    return p1+(p2-p1)*(det(q2-q1,q1-p1)/det(q2-q1,p2-p1));\n}\n\nbool cross(P p1,P p2,P q1,P q2){\n    if(det(p1-p2,q1-q2)==0)return onseg(p1,p2,q1)||onseg(p1,p2,q2)||onseg(q1,q2,p1)||onseg(q1,q2,p2);\n    P ret=intersection(p1,p2,q1,q2);\n    return onseg(p1,p2,ret)&&onseg(q1,q2,ret);\n}\n\ndouble dist(P p1,P p2,P q){\n    if(dot(q-p1,p2-p1)<=0)return sqrt(dot(q-p1,q-p1));\n    if(dot(q-p2,p1-p2)<=0)return sqrt(dot(q-p2,q-p2));\n    P d=p1-p2;\n    P ret=q+P{d.second,-d.first};\n    P h=intersection(p1, p2, q, ret);\n    return sqrt(dot(q-h,q-h));\n}\ndouble d(P p,P q){\n    return sqrt(dot(p-q,p-q));\n}\n\nint main(){\n    int n;\n    while(cin>>n,n!=0){\n        P a[n];\n        rep(i,n)cin>>a[i].first>>a[i].second;\n        int ans=1;\n        rep(i,n)rep(j,n){\n            if(i==j)continue;\n            if(d(a[i],a[j])>2)continue;\n            P v=(a[i]-a[j])*(1.0/d(a[i],a[j]));\n            P h=P{v.second,-v.first};\n            P c=(a[i]+a[j])*(1.0/2)+h*sqrt(1.0-dot(a[i]-a[j],a[i]-a[j])/4);\n            int ret=2;\n            rep(k,n){\n                if(k==i||k==j)continue;\n                if(d(a[k],c)<=1)ret++;\n            }\n            ans=max(ans,ret);\n            c=(a[i]+a[j])*(1.0/2)-h*sqrt(1.0-dot(a[i]-a[j],a[i]-a[j])/4);\n            ret=2;\n            rep(k,n){\n                if(k==i||k==j)continue;\n                if(d(a[k],c)<=1)ret++;\n            }\n            ans=max(ans,ret);\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<complex>\n#include<numeric>\n#include<bitset>\n#define INF 1001001001\n#define EPS 0.000000001\nusing namespace std;\ntypedef vector<int> vint;\ntypedef vector<vint> vvint;\ntypedef pair<int,int> pint;\n\ntypedef complex<double> pt;\n\nint main(){\n\tpt p[310];\n\tint i,j,ii;\n\tint n;\n\t\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tfor(i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf %lf\",&x,&y);\n\t\t\tp[i] = pt(x,y);\n\t\t}\n\t\t\n\t\tint mx=1;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\tif(norm(p[i]-p[j]) > 4.0) continue;\n\t\t\t\tdouble l = abs(p[i]-p[j]);\n\t\t\t\tdouble k = sqrt(1.0-(l*l/4.0));\n\t\t\t\tpt m = (p[i]+p[j])/2.0;\n\t\t\t\tpt v(-imag(p[i]-p[j]),real(p[i]-p[j]));\n\t\t\t\tdouble r = abs(v);\n\t\t\t\tv= v*k/r;\n\t\t\t\tint cnt;\n\t\t\t\t\n\t\t\t\tp[n] = m+v;\n\t\t\t\tcnt=0;\n\t\t\t\tfor(ii=0;ii<n;ii++){\n\t\t\t\t\tif(norm(p[ii]-p[n])<1.00001) cnt++;\n\t\t\t\t}\n\t\t\t\tmx = max(mx,cnt);\n\t\t\t\t\n\t\t\t\tp[n]=m-v;\n\t\t\t\tcnt=0;\n\t\t\t\tfor(ii=0;ii<n;ii++){\n\t\t\t\t\tif(norm(p[ii]-p[n])<1.00001) cnt++;\n\t\t\t\t}\n\t\t\t\tmx = max(mx,cnt);\n\t\t\t}\n\t\t}\n\t\tcout << mx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n#define EPS (1e-6)\n\nP p[300];\nP tmp;\n\nint main() {\n  int n;\n  while (cin >> n, n) {\n    for (int i=0; i<n; i++) {\n      cin >> p[i].real() >> p[i].imag();\n    }\n\n    int ans = 1;\n    for (int i=0; i<n; i++) {\n      for (int j=i+1; j<n; j++) {\n        P v = p[i] - p[j];\n        double absv = abs(v);\n        if (absv > 2.0 + EPS) { continue; }\n\n        P m = p[j] + (v / 2.0);\n        P unv = (v * P(0, 1)) / absv; // unit normal vector\n        P nv = sqrt(1.0 - absv*absv/4.0) * unv;\n        for (int s=0; s<2; s++) {\n          nv *= -1;\n          P c = m + nv; // center point of the circle\n\n          int cnt = 0;\n          for (int k=0; k<n; k++) {\n            // if (abs(p[k] - c) < 1.0 + EPS) { cnt++; } // too slow\n            tmp = p[k] - c;\n            if ( tmp.real()*tmp.real() + tmp.imag()*tmp.imag() < 1.0 + EPS ) { cnt++; }\n          }\n          if (cnt > ans) { ans = cnt; }\n        }\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n\n#include <complex>\n#include <math.h>\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> VP;\n\nconst D EPS = 1e-9;\nconst D INF = 1e9;\n\n#define X real()\n#define Y imag()\n\n#define LE(n,m)\t((n) < (m) + EPS)\n#define GE(n,m)\t((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nVP cpr(P a, P b, D r) {\n\tVP cs;\n\tP h = (b - a) * 0.5;\n\tD d = abs(h);\n\tif (d == 0 || d > r) return cs;\n\tD N = sqrt(r*r - d*d);\n\tP n = h * P(0, 1) * (N / d);\n\tcs.push_back(a + h + n);\n\tif (N > 0)cs.push_back(a + h - n);\n\treturn cs;\n}\n\nint main() {\n\tint n;\n\twhile (cin >> n && n) {\n\t\tVP v(n);\n\t\trep(i, n) {\n\t\t\tD x, y;\n\t\t\tcin >> x >> y;\n\t\t\tv[i] = P(x, y);\n\t\t}\n\t\tint ans = 1;\n\t\trep(i, n)rep(j, n)if (i != j) {\n\t\t\tauto t = cpr(v[i], v[j], 1.0);\n\t\t\tfor (auto p : t) {\n\t\t\t\tint count = 0;\n\t\t\t\trep(k, n) {\n\t\t\t\t\tif (abs(p - v[k]) <= 1.0 + EPS) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = max(ans, count);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nusing R = long double;\nconstexpr R pi = acos((R)-1), eps = 1e-10;\n\nint sgn(R a) { return (a > eps) - (a < -eps); }\nint sgn(R a, R b) { return sgn(a - b); }\nusing P = complex<R>;\nistream& operator>>(istream& i, P& p) { R x, y; i >> x >> y; p = P(x, y); return i; }\nostream& operator<<(ostream& o, P p) { return o << fixed << setprecision(15) << real(p) << ' ' << imag(p); }\nbool cmp(P p, P q) { return 2 * sgn(real(p), real(q)) + sgn(imag(p), imag(q)) < 0; }\nbool eql(P p, P q) { return !cmp(p, q) and !cmp(q, p); }\nR dot(P p, P q) { return real(conj(p) * q); }\nR crs(P p, P q) { return imag(conj(p) * q); }\n// -2: back, -1: cw, 0: on, 1: ccw, 2: front\nint ccw(P p, P q) {\n  int s = sgn(crs(p, q));\n  if (s) return s;\n  if (dot(p, q) < 0) return -2;\n  if (dot(p, q - p) > 0) return 2;\n  return 0;\n}\nint ccw(P o, P p, P q) { return ccw(p - o, q - o); }\nstruct L {\n  P s, t;\n  P vec() const { return t - s; }\n  R abs() const { return std::abs(vec()); }\n  R arg() const { return std::arg(vec()); }\n};\nint ccw(L s, P p) { return ccw(s.s, s.t, p); }\n\nP proj(P p, L l) {\n  P e = l.vec() / l.abs();\n  return l.s + dot(p - l.s, e) * e;\n}\nP refl(P p, L l) { return (R)2 * proj(p, l) - p; }\nR distPP(P p, P q) { return abs(q - p); }\nR distPL(P p, L l) { return distPP(p, proj(p, l)); }\nR distPS(P p, L s) {\n  P q = proj(p, s);\n  if (!ccw(s, q)) return distPP(p, q);\n  return min(distPP(p, s.s), distPP(p, s.t));\n}\nR distLL(L l, L m) {\n  if (sgn(crs(l.vec(), m.vec()))) return 0;\n  return distPL(l.s, m);\n}\nR distLS(L l, L s) {\n  if (ccw(l, s.s) * ccw(l, s.t) != 1) return 0;\n  return min(distPL(s.s, l), distPL(s.t, l));\n}\nR distSS(L s, L t) {\n  if (ccw(s, t.s) * ccw(s, t.t) <= 0 and ccw(t, s.s) * ccw(t, s.t) <= 0) return 0;\n  return min({distPS(s.s, t), distPS(s.t, t), distPS(t.s, s), distPS(t.t, s)});\n}\nP intxn(L l, L m) {\n  assert(sgn(crs(l.vec(), m.vec())));\n  return l.s + crs(m.s - l.s, m.vec()) / crs(l.vec(), m.vec()) * l.vec();\n}\n\nusing G = V<P>;\nR area(const G& g) {\n  if (g.size() < 3) return 0;\n  R res = 0;\n  P a = g.back();\n  for (P b : g) {\n    res += crs(a, b) / 2;\n    a = b;\n  }\n  return res;\n}\n// -1: in, 0: on, 1: out\nint contains(const G& g, P p) {\n  assert(g.size() >= 3);\n  int c = 0;\n  P q = p + P(pi, 1), a = g.back();\n  for (P b : g) {\n    if (!ccw(a, b, p)) return 0;\n    if (!sgn(distLS({p, q}, {a, b}))) {\n      c += ccw(p, q, intxn({p, q}, {a, b})) >= 0;\n    }\n    a = b;\n  }\n  return c & 1 ? -1 : 1;\n}\nG half_convex_hull(const V<P>& ps, bool strict) {\n  G g;\n  for (P p : ps) {\n    while (g.size() >= 2) {\n      int c = ccw(g[g.size() - 2], g.back(), p);\n      if (c == 1 or !strict and c == 2) break;\n      g.pop_back();\n    }\n    g.push_back(p);\n  }\n  g.pop_back();\n  return g;\n}\nG convex_hull(V<P> ps, bool strict = true) {\n  sort(begin(ps), end(ps), cmp);\n  ps.erase(unique(begin(ps), end(ps), eql), end(ps));\n  if (ps.size() < 3) return ps;\n  G g = half_convex_hull(ps, strict);\n  reverse(begin(ps), end(ps));\n  G h = half_convex_hull(ps, strict);\n  g.insert(end(g), begin(h), end(h));\n  return g;\n}\nR diameter(const G& g) {\n  auto e = minmax_element(begin(g), end(g), cmp);\n  int n = g.size(), i = e.first - begin(g), j = e.second - begin(g);\n  R res = 0;\n  for (int _ = 0; _ < n; ++_) { // n: 半周, 2n: 一周\n    res = max(res, distPP(g[i], g[j]));\n    int ni = (i + 1) % n, nj = (j + 1) % n;\n    if (sgn(crs(g[ni] - g[i], g[nj] - g[j])) < 0) i = ni;\n    else j = nj;\n  }\n  return res;\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    int n; cin >> n;\n    if (!n) break;\n    V<P> ps(n); for (auto&& p : ps) cin >> p;\n    int res = 1;\n    for (P p : ps) for (P q : ps) if (cmp(p, q)) {\n      if (sgn(distPP(p, q), 2) > 0) continue;\n      P m = (p + q) / (R)2;\n      P r = sqrt(1 - norm(m - p)) * (q - p) * P(0, 1 / abs(q - p));\n      for (P o : {m + r, m - r}) {\n        int curr = 0;\n        for (P i : ps) {\n          curr += sgn(distPP(o, i), 1) <= 0;\n        }\n        res = max(res, curr);\n      }\n    }\n    cout << res << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <cfloat>\nusing namespace std;\n\nconst double EPS = 1.0e-9;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    const Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    const Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    const Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y-p.y, 2.0) + pow(x-p.x, 2.0));\n    }\n};\n\nint solve(vector<Point>& vp)\n{\n    int n = vp.size();\n    int ret = 1;\n\n    for(int i=0; i<n; ++i){\n        for(int j=i+1; j<n; ++j){\n            double dist = vp[i].dist(vp[j]);\n            if(dist > 2.0)\n                continue;\n\n            for(int k=0; k<2; ++k){\n                Point p = vp[j] - vp[i];\n                Point p1(p.x, p.y);\n                if(k == 0)\n                    p1.x *= -1;\n                else\n                    p1.y *= -1;\n                p = vp[i] + p * 0.5 + p1 * (sqrt(pow(dist, -2) - 0.25));\n                int num = 0;\n                for(int l=0; l<n; ++l){\n                    if(p.dist(vp[l]) < 1.0 + EPS)\n                        ++ num;\n                }\n                ret = max(ret, num);\n            }\n        }\n    }\n\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            break;\n\n        vector<Point> p(n);\n        for(int i=0; i<n; ++i)\n            cin >> p[i].x >> p[i].y;\n        cout << solve(p) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst long double eps=1e-3;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        vector<long double> xs(n),ys(n);\n        rep(i,0,n) cin >> xs[i] >> ys[i];\n\n        auto count=[&](const long double x,const long double y){\n            int res=0;\n            rep(i,0,n) if((xs[i]-x)*(xs[i]-x)+(ys[i]-y)*(ys[i]-y)<=1+eps) ++res;\n            return res;\n        };\n\n        int ans=0;\n        rep(i,0,1001){\n            const long double y=10.*i/1000;\n            rep(j,0,n){\n                const long double tmp=1-(ys[j]-y)*(ys[j]-y);\n                if(tmp<0) continue;\n                const long double x1=xs[j]-sqrtl(tmp),x2=xs[j]+sqrt(tmp);\n                ans=max({ans,count(x1,y),count(x2,y)});\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n\nusing namespace std;\ntypedef pair<double, double> P;\nconst double EPS = 1e-5;\n\n#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n\nusing namespace std;\n\ndouble dist(P a, P b)\n{\n    return hypot(a.first - b.first, a.second - b.second);\n}\n\nvector<P> center(P a, P b)\n{\n    auto t = atan2(b.first - a.first, b.second - a.second);\n    auto x = dist(a, b) / 2;\n    auto y = sqrt(1.0 - x * x);\n    auto cs = cos(t), sn = sin(t);\n    return { \n        { cs * x - sn * y + a.first, sn * x + cs * y + a.second },\n        { cs * x + sn * y + a.first, sn * x - cs * y + a.second }\n    };\n}\n\nint main()\n{\n    while (1) {\n        int n; cin >> n;\n        if (!n) break;\n        vector<P> pnt;\n        loop (n, i) {\n            double x, y; cin >> x >> y;\n            pnt.emplace_back(x, y);\n        }\n        int ans = 1;\n        loop (n, i) loop (n, j) {\n            auto ps = center(pnt[i], pnt[j]);\n            for (auto o : ps) {\n                int cnt = 0;\n                loop (n, l) {\n                    if (dist(o, pnt[l]) < 1 + EPS) cnt++;\n                }\n                ans = max(ans, cnt);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define REPP(i,j,n) for(int i=(j);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-5, pi = acos(-1.0);\nld dot(Point a, Point b){return real(conj(a)*b);}\nld cross(Point a, Point b){ return imag(conj(a)*b);}\n\nPoint p[310];\nint n;\n\nvoid solve(){\n  int result=1;\n  REP(i,n){\n    REPP(j,i+1,n){\n      Point ab=p[j]-p[i];\n      if(norm(ab)>4)continue;\n      Point q=(p[i]+p[j])/2.L;\n      Point aq=q-p[j];\n      Point normal=Point{imag(aq),-real(aq)}*sqrt(1-norm(aq))/abs(aq);\n      Point c=q+normal;\n      Point d=q-normal;\n      int cntc=0,cntd=0;\n      REP(k,n){\n\tif(norm(p[k]-c)<=1.001L)cntc++;\n\tif(norm(p[k]-d)<=1.001L)cntd++;\n      }\n      result=max({result,2,cntc,cntd});\n    }\n  }\n  cout<<result<<endl;\n}\n\nint main(){ _;\n  ld r,i;\n  while(cin>>n,n!=0){\n    REP(j,n){\n      cin>>r>>i;\n      p[j]=Point{r,i};\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,N) for(int i=0;i<(int)(N);i++)\n#define REP(i,k,N) for(int i=k;i<(int)(N);i++)\n\n#define vi vector<int>\n#define pb push_back\n\n#define pdd pair<double,double>\n#define fi first\n#define se second\nconst double  EPS = 1e-9;\n\ndouble dist(double x,double y){\n    return x*x+y*y;\n};\n\nint main(){\n    ifstream in(\"d_in.txt\");\n    cin.rdbuf(in.rdbuf());\n    int n;\n    while(cin >> n,n){\n        int ma = 0;\n        pdd p[330];\n        rep(i,n) cin >> p[i].fi >> p[i].se;\n        rep(i,n-1){\n            REP(j,i+1,n){\n\n                double x1,y1,x2,y2,x3,y3;\n                tie(x1,y1) = p[i];\n                tie(x2,y2) = p[j];\n                double cx1,cy1,cx2,cy2;\n                if(dist(x1-x2,y1-y2)  > 4+EPS  ) continue;\n\n                //はりまコーナー\n//                double ax,ay,bx1,by1,bx2,by2,mx,my,dx,dy;\n//                ax=x1-x2;ay=y1-y2;\n//                mx=(x1+x2)/2;my=(y1+y2)/2;\n//                by1 = (-0.5)*pow(ax,4)+pow(ax,2)+(-0.5)*pow(ax,2)*pow(ay,2)\n//                        /dist(ax,ay);\n//                by1 = sqrt(abs(by1));\n//                by2 = -1*by1;\n//                cy1= my+by1;\n//                cy2= my+by2;\n//                bx1= -1*(ay*by1)/ax;\n//                bx2= -1*(ay*by2)/ax;\n//                cx1=bx1+mx;\n//                cx2=bx2+mx;\n\n\n                //あじのりコーナー\n                double mx=(x1+x2)/2,my=(y1+y2)/2;\n\n                double ld = sqrt(1-dist((x1-x2),(y1-y2))/4);\n                double theta = atan((y2-y1)/(x2-x1));\n                cx1 = mx - sin(theta)*ld;\n                cy1 = my + cos(theta)*ld;\n                cx2 = mx + sin(theta)*ld;\n                cy2 = my - cos(theta)*ld;\n\n                int cnt1 = 0,cnt2=0;\n                for(int k = 0;k<n;k++) {\n                    tie(x3, y3) = p[k];\n                    if (EPS + 1> dist((cx1 - x3), (cy1 - y3))) cnt1++;\n                    if (EPS + 1> dist((cx2 - x3), (cy2 - y3))) cnt2++;\n                }\n                ma = max({cnt1,cnt2,ma});\n            }\n        }\n        cout<< ma << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double r = 1.0;\nconst double PI = acos(-1.0);\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y) : x(x), y(y) {}\n};\ninline double Distance2(const Point &a, const Point &b) {\n    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    std::random_device rnd;\n    std::mt19937 mt(rnd());\n    std::uniform_real_distribution<> rand100(0.0, 10.0);\n\n    while (cin >> n, n) {\n        // Input\n        vector<Point> p(n);\n        for (int i = 0; i < n; ++i)\n            cin >> p[i].x >> p[i].y;\n\n        // Solve\n        int ans = 1;\n        auto start = std::chrono::high_resolution_clock::now();\n        auto end = std::chrono::high_resolution_clock::now();\n        auto take_time = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n\n        while (true) {\n            end = std::chrono::high_resolution_clock::now();\n            take_time = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n            if (320 < take_time.count())\n                break;\n\n            for (int i = 0; i < 10; ++i) {\n                Point c(rand100(mt), rand100(mt));\n                int num = 0;\n                for (int j = 0; j < n; ++j) {\n                    double d = Distance2(p[j], c);\n                    if (d <= 1.0)\n                        ++num;\n                }\n                ans = max(ans, num);\n            }\n        }\n\n        // Output\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-3;\n\nstruct Circle{\n  P c;\n  double r;\n  Circle(P c=P(0,0),double r=0):c(c),r(r){}\n};\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1=c1.r,r2=c2.r,d;\n  P p1=c1.c,p2=c2.c;\n  d=abs(p1-p2);\n  if(d<EPS&&abs(r1-r2)<EPS) return res;\n  if(r1+r2<d-EPS||d+EPS<abs(r1-r2)) return res; \n  double a=(r1*r1-r2*r2+d*d)/(2*d);\n  double h=sqrt(max(r1*r1-a*a,0.0));\n  P tmp1=p1+a/d*(p2-p1);\n  P tmp2=h/d*(p2-p1);\n  if(abs(tmp2)<EPS)res.push_back(tmp1);\n  else{\n    res.push_back(P(real(tmp1)-imag(tmp2),imag(tmp1)+real(tmp2)));\n    res.push_back(P(real(tmp1)+imag(tmp2),imag(tmp1)-real(tmp2)));\n  }\n  return res;\n}\n\ndouble getdistancepp(P a,P b){\n  return sqrt((a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag()));\n}\n\nint main(){\n  int n,ans=0;\n  double a,b;\n  P p[N];\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>a>>b;\n      p[i]=P(a,b);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tCircle c1,c2;\n\tc1.c=p[i];\n\tc2.c=p[j];\n\tc1.r=c2.r=1;\n\tvector<P> r=getIntersectCC(c1,c2);\n\tif(!r.size())continue;\n\tfor(int k=0;k<r.size();k++){\n\t  int cnt=0;\n\t  for(int l=0;l<n;l++)\n\t    if(getdistancepp(r[k],p[l])<=1+EPS)cnt++;\t    \n\t  ans=max(ans,cnt);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <string> \n#include <vector> \n#include <cmath> \n#include <algorithm> \n#include <cstdlib> \n#include <ctime> \n#include <cstdio> \n#include <functional> \n#include <set> \n#include <sstream> \n\nusing namespace std; \n\ndouble d2(double x1,double x2,double y1,double y2){\n\treturn (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n}\n\nint main(){\n\n\tint n;\n\tconst double eps=1e-8;\n\twhile(true){\n\n\t\tcin>>n;\n\n\t\tif(n==0) return 0;\n\n\t\tint res=1;\n\t\tvector<double> x(n),y(n);\n\n\t\tfor(int i=0;i<n;i++) cin>>x[i]>>y[i];\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\n\t\t\t\tint res2=0;\n\t\t\t\tconst double X=(x[i]+x[j])/2.0;\n\t\t\t\tconst double Y=(y[i]+y[j])/2.0;\n\n\t\t\t\tfor(int k=0;k<n;k++){\n//\t\t\t\t\tprintf(\"P1(%f, %f) P2(%f, %f) -> d2=%f\\n\",x[k],y[k],X,Y,sqrt(d2(x[k],X,y[k],Y)));\n\t\t\t\t\tif(d2(x[k],X,y[k],Y)<1.0+eps) res2++;\n\t\t\t\t}\n//\t\t\t\tcout<<endl;\n\n\t\t\t\tres=max(res,res2);\n\n\t\t\t}\n\t\t}\n\n\t\tcout<<res<<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\nusing P = complex<ld>;\nconst ld eps = 1e-6;\n\nint main()\n{\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<ld> x(N), y(N);\n\t\tvector<P> p(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tp[i] = P(x[i], y[i]);\n\t\t}\n\t\tvector<P> ko;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tif (norm(p[i] - p[j]) < 4.0 + eps) {\n\t\t\t\t\tauto d = p[i] - p[j];\n\t\t\t\t\tko.push_back(p[j] + (d * (ld)0.5) + d * P(0, 1) / abs(d) * sqrtl(1 - norm(d * (ld)0.5)));\n\t\t\t\t\tko.push_back(p[j] + (d * (ld)0.5) - d * P(0, 1) / abs(d) * sqrtl(1 - norm(d * (ld)0.5)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor (auto c : ko) {\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (norm(c - p[i]) < 1.0001) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = max(res, cnt);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble Dis(double x1, double y1, double x2, double y2);\nint main(void){\n\twhile(1){\n\t\tint n;\n\t\tint ans = 1;\n\t\tvector< pair<double, double> > p;\n\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tpair<double, double> t;\n\t\t\tcin >> t.first >> t.second;\n\t\t\tp.push_back(t);\n\t\t}\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=i+1; j<n; j++){\n\t\t\t\t//中点\n\t\t\t\tdouble mpx = (p[i].first + p[j].first) / 2.0;\n\t\t\t\tdouble mpy = (p[i].second + p[j].second) / 2.0;\n\t\t\t\t//2点間の距離\n\t\t\t\tdouble d1 = Dis(p[i].first, p[i].second, p[j].first, p[j].second);\n\t\t\t\tif(d1 > 2.0) continue;\n\t\t\t\t//p[i]からp[j]へ向かうベクトル\n\t\t\t\tdouble v1x = (p[j].first - p[i].first) / d1;\n\t\t\t\tdouble v1y = (p[j].second - p[i].second) / d1;\n\t\t\t\t//中点から円の中心へ向かう単位ベクトル\n\t\t\t\tdouble v2x = -v1y;\n\t\t\t\tdouble v2y = v1x;\n\t\t\t\t//中心から円の中心へ向かうベクトルの長さ\n\t\t\t\tdouble d2 = sqrt(1.0 - (d1*d1/4.0));\n\n\t\t\t\t//円の中心の座標\n\t\t\t\tdouble cx = mpx + v2x * d2;\n\t\t\t\tdouble cy = mpy + v2y * d2;\n\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(k == i || k == j || (cx-p[k].first)*(cx-p[k].first) + (cy-p[k].second)*(cy-p[k].second) <= 1.0)\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt > ans){\n\t\t\t\t\tans = cnt;\n\t\t\t\t}\n\n\t\t\t\tcx = mpx - v2x * d2;\n\t\t\t\tcy = mpy - v2y * d2;\n\n\t\t\t\tcnt = 0;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(k == i || k == j || (cx-p[k].first)*(cx-p[k].first) + (cy-p[k].second)*(cy-p[k].second) <= 1.0)\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt > ans){\n\t\t\t\t\tans = cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\n\t}\n\t\n\treturn 0;\n}\n\ndouble Dis(double x1, double y1, double x2, double y2){\n\treturn sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nclass Point {\npublic:\n  double x, y;\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n  Point operator +(Point p) {\n    return Point(x+p.x, y+p.y);\n  }\n  Point operator -(Point p) {\n    return Point(x-p.x, y-p.y);\n  }\n  Point operator *(double a) {\n    return Point(x*a, y*a);\n  }\n  Point operator /(double a) {\n    return Point(x/a, y/a);\n  }\n  bool operator ==(const Point &p) const {\n    return x == p.x && y == p.y;\n  }\n};\n\ntypedef Point Vector;\n\ndouble dist(Point p1, Point p2) {\n  return sqrt(pow(p1.x-p2.x, 2.0) + pow(p1.y-p2.y, 2.0));\n}\n\ndouble norm(Point p1, Point p2) {\n  return pow(p1.x-p2.x, 2.0) + pow(p1.y-p2.y, 2.0);\n}\n\nint n;\nPoint p[300];\n\nint calc(Point p1, Point p2) {\n  Point m = Point((p1.x+p2.x)/2.0, (p1.y+p2.y)/2.0);\n  Point o;\n  Vector moto;\n  double l = sqrt(4.0/norm(p1,p2)-1)/2.0;\n  int cnt = 0;\n  int newCnt;\n  for(int t = 0; t < 2; t++) {\n    newCnt = 0;\n    moto = Vector(p2.y-p1.y, p1.x-p2.x);\n    if(t == 0) {\n      moto = moto * (-1);\n    }\n    o = m + moto * l;\n\n    for(int i = 0; i < n; i++) {\n      if(p[i] == p1 || p[i] == p2) continue;\n      if(pow(p[i].x-o.x, 2.0) + pow(p[i].y-o.y, 2.0) <= 1.0) {\n\tnewCnt++;\n      }\n    }\n    if(newCnt > cnt) cnt = newCnt;\n  }\n  return cnt + 2;\n}\n\nmain() {\n  while(1) {\n    int ans;\n    cin >> n;\n    if(n == 0) break;\n    for(int i = 0; i < n; i++) {\n      cin >> p[i].x >> p[i].y;\n    }\n    ans = -1;\n    for(int i = 0; i < n; i++) {\n      for(int j = i+1; j < n; j++) {\n\tans = max(ans, calc(p[i],p[j]));\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nconst double EPS = 1e-8;\ntypedef pair<double,double> P;\n\ninline double dist(P p,P q){\n  return ( (p.first-q.first)*(p.first-q.first) + (p.second-q.second)*(p.second-q.second));\n}\n\nint main(){\n  int N;\n  double sign[2] = {+1, -1};\n  P p[301];\n  while(cin>>N,N){\n    REP(i,N)cin>>p[i].first>>p[i].second;\n    int ans = 1;\n    REP(i,N){\n      FOR(j,i+1,N){\n        double dst = dist(p[i],p[j]);\n        if(dst > 4.0) continue;\n        P v((p[j].first-p[i].first)/dst, (p[j].second-p[i].second)/dst);\n        P m((p[j].first+p[i].first)/2.0, (p[j].second+p[i].second)/2.0);\n        double lth = sqrt(1.0-dst*dst/4.0);\n        REP(k,2){\n          double cx = m.first + sign[k] * v.first * lth;\n          double cy = m.second - sign[k] * v.second * lth;\n          P center(cx,cy);\n          int count = 0;\n          REP(l,N){\n            if(l == i || l == j || dist(center,p[l]) < 1){\n              count++;\n            }\n            if(N-l-1 + count < ans)break;\n          }\n          ans = max(ans, count);\n        }\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\n\nconst long double EPS = 10e-6;\n\nclass Point{\n    public: \n    long double x,y;\n    Point(long double x = 0.0, long double y = 0.0): x(x), y(y) {}\n    Point operator + (Point p) const {\n        return Point(x+p.x, y+p.y);\n    }\n    Point operator - (Point p) const {\n        return Point(x-p.x, y-p.y);\n    }\n    Point operator * (long double a) const {\n        return Point(x*a, y*a);\n    }\n    Point operator / (long double a) const {\n        return Point(x/a, y/a);\n    }\n    long double norm() const {\n        return x*x + y*y;\n    }\n    long double dot(Point p) const {\n        return x*p.x + y*p.y;\n    }\n};\n\nPoint calc_center(Point p, Point mid, Point midv){\n    long double norm = mid.norm(), vnorm = midv.norm();\n    midv = midv * sqrt((1.0 - norm)/vnorm);\n    return p+mid+midv;\n}\n\nint count(vector<Point> points, Point center){\n    int tmp = 0;\n    for(Point p: points){\n        Point v = p-center;\n        if(v.norm() <= 1.0 + EPS) tmp++;\n    }\n    return tmp;\n}\n\nint main() {\n    int n;\n    while(scanf(\"%d\", &n) && n){\n        vector<Point> points(n);\n        rep(n) scanf(\"%Lf %Lf\", &points[i].x, &points[i].y);\n\n        int ans = 1;\n        Point mid, midv, center;\n        rep(n){\n            repp(j, n){\n                if(j == i) continue;\n                mid = (points[j] - points[i]);\n                mid = mid * 0.5;\n                midv = Point(mid.y, -mid.x);\n                center = calc_center(points[i], mid, midv);\n                ans = max(count(points, center), ans);\n                /*\n                midv = midv * (-1);\n                center = calc_center(points[i], mid, midv);\n                ans = max(count(points, center), ans);\n                */\n            }\n        }\n        printf(\"%d\\n\", ans);\n        // debug(ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\ntypedef complex<double> Point;\n\nint calc(Point p, vector<Point>& ps){\n    int ans = 0;\n    for(int i = 0; i < ps.size(); i++){\n        if(abs(ps[i] - p) < 1.0 + EPS) {\n            ans++;\n        }\n    }\n    return ans;\n}\nvector<Point> touching_circle(Point a, Point b, double r){\n    vector<Point> res;\n\n    double d = abs(b - a);\n    if(d > 2 * r + EPS) return res;\n\n    Point mid = 0.5 * (a + b);\n    Point dir = polar(sqrt(r * r - d * d / 4), arg(b - a) + M_PI / 2);\n    res.push_back(mid + dir);\n    res.push_back(mid - dir);\n    return res;\n}\nint main(){\n    int N;\n    while(cin >> N && N){\n        vector<Point> ps(N);\n        REP(i, N){\n            double x, y;\n            cin >> x >> y;\n            ps[i] = Point(x, y);\n        }\n        int ans = 0;\n        REP(i, N) REP(j, N) if(abs(ps[i] - ps[j]) > EPS) {\n            vector<Point> tp = touching_circle(ps[i], ps[j], 1.0);\n            for(Point c : tp){\n            assert(abs(1.0 - abs(c - ps[i])) < EPS);\n            assert(abs(1.0 - abs(c - ps[j])) < EPS);\n                ans = max(ans, calc(c, ps));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\ntypedef complex<double> C;\n#define EPS (1e-6)\n\nint n;\nC c[301];\n\nvoid solve() {\n  for(int i=0;i<n;i++)\n  cin>>c[i].real()>>c[i].imag();\n  \n  int res = 1;\n  for (int i = 0; i < n; i += 1) {\n    for (int j = i+1; j < n; j += 1) {\n      C v = c[j] - c[i];\n      double absv = abs(v);\n      if (absv > 2.0 + EPS) continue;\n      // _\n      C m = c[i] + (v / 2.0);\n      // ~ÜÅÌ£\n      double dist = sqrt(1.0 - absv * absv / 4.0);\n      // PÊ@üxNg\n      C unv  = (v * C(0, 1)) / absv;\n      // S\n      C nv = unv * dist;\n      for (int k = 0; k < 2; k += 1) {          \n        int cnt = 0;\n        nv *= -1;\n        C tc = m + nv;\n        for (int l = 0; l < n; l += 1) {\n          if (abs(tc - c[l]) < 1.0 + EPS) cnt++;\n        }\n        res = max(res, cnt);\n      }\n    }\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>n, n) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\nR radNorP(R x) {\n    return fmod(fmod(x, 2*PI)+2*PI, 2*PI);\n}\n\nconst int MN = 330;\n\nP p[MN];\ntypedef pair<R, int> Pi;\n\nbool solve() {\n    int n;\n    cin >> n;\n    if (!n) return false;\n\n    for (int i = 0; i < n; i++) {\n        R x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n    }\n\n    int res = 0;\n    for (int i = 0; i < n; i++) {\n        vector<Pi> v;\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            if (2.0 < abs(p[j]-p[i])) continue;\n            R th = acos(abs(p[j]-p[i])/2.0);\n            R l = radNorP(arg(p[j]-p[i])-th);\n            R r = radNorP(arg(p[j]-p[i])+th);\n            if (r < l) {\n                v.push_back(Pi(l-EPS, 1));\n                v.push_back(Pi(2*PI+EPS, -1));\n                v.push_back(Pi(0-EPS, 1));\n                v.push_back(Pi(r+EPS, -1));\n            } else {\n                v.push_back(Pi(l-EPS, 1));\n                v.push_back(Pi(r+EPS, -1));\n            }\n\n        }\n\n        sort(v.begin(), v.end());\n        int sm = 1;\n        for (Pi p: v) {            \n            sm += p.second;\n            res = max(res, sm);\n        }\n    }\n    cout << res << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\n#define rep(i, n)       rep2(i, 0, n)\n#define rep2(i, m, n)   for(int i = m; i < (int)(n); ++i)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> Pt;\n\nconst double EPS = 1e-9;\n\nint main()\n{\n    int n;\n    while (cin >> n, n) {\n        double x, y;\n        vector<Pt> p;\n        rep (i, n) {\n            cin >> x >> y;\n            p.push_back(Pt(x, y));\n        }\n        \n        int ans = 1;\n        rep (i, n) rep2 (j, i + 1, n) {\n            double d = abs(p[i] - p[j]);\n            if (d > 2.0) continue;\n            \n            Pt m = (p[i] + p[j]) / 2.0;\n            Pt v = Pt(p[i].Y - p[j].Y, p[j].X - p[i].X);\n            v /= abs(v);\n            v *= sqrt(1.0 - d / 2.0);\n            \n            int t1 = 0, t2 = 0;\n            Pt c1 = m + v, c2 = m - v;\n            rep (k, n) {\n                if (abs(p[k] - c1) < 1.0 + EPS) ++t1;\n                if (abs(p[k] - c2) < 1.0 + EPS) ++t2;\n            }\n            ans = max(max(t1, t2), ans);\n        }\n        \n        cout << ans << endl;        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nstatic const double EPS = 1e-8;\ntypedef complex<double> P;\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { }};\n\nint xor128(){ \n    static unsigned long x=123456789,y=362436069,z=521288629,w=88675123; \n    unsigned long t; \n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) ); \n} \n\nvector<P> data;\n\nint check(double x,double y){\n\tint ret = 0;\n\trep(i,data.size()){\n\t\tif( (data[i].real()-x) * (data[i].real()-x) + (data[i].imag()-y)*(data[i].imag()-y) <= 1.0+EPS){\n\t\t\tret++;\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\tint n;\n\twhile(cin >> n , n){\n\t\tdata.resize(n);\n\t\trep(i,n){\n\t\t\tcin >> data[i].real() >> data[i].imag();\n\t\t}\n\t\tint ret = 0;\n\t\trep(i,n){\n\t\t\trep(x,300000/(n) ){\n\t\t\t\tdouble x = (xor128()%200000-100000)/100000.0;\n\t\t\t\tdouble y = (xor128()%200000-100000)/100000.0;\n\t\t\t\tret = max( check(data[i].real()+x,data[i].imag()+y) , ret);\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n)-1;i>=(m);--i)\n#define repc(i,n) for(int i=0;i<=(n);++i)\n#define repcn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repcd(i,n) for(int i=(n);i>=0;--i)\n#define repcnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define repc0(i,n) for(i=0;i<=(n);++i)\n#define repcn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repcd0(i,n) for(i=(n);i>=0;--i)\n#define repcnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE cout<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-7;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nint sig(double r) { return r < -EPS ? -1 : r > EPS ? 1 : 0; }\n\nstruct P {\n\tdouble x, y;\n\tP() {}\n\tP(double x, double y) : x(x), y(y) {}\n\tP operator+(const P &a) const { return P(x + a.x, y + a.y); }\n\tP operator-(const P &a) const { return P(x - a.x, y - a.y); }\n\tP operator*(const P &a) const { return P(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tP operator-() const { return P(-x, -y); }\n\tP operator*(const double &k) const { return P(x * k, y * k); }\n\tP operator/(const double &k) const { return P(x / k, y / k); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble abs() const { return sqrt(abs2()); }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const P &a) const { return x * a.x + y * a.y; }\n\tdouble det(const P &a) const { return x * a.y - y * a.x; }\n\tP proj(const P &a) const { double k = dot(a) / abs2(); return P(x * k, y * k); }\n\tbool operator<(const P &a) const { return x != a.x ? x < a.x : y < a.y; }\n\tbool operator==(const P &a) const { return sig(x - a.x) == 0 && sig(y - a.y) == 0; }\n};\n\nostream &operator<<(ostream&os, const P&a) { os << \"(\" << a.x << \", \" << a.y << \")\"; return os; }\ndouble tri(P a, P b, P c) { return (b - a).det(c - a); }\n\nstruct L {\n\tP a, b;\n\tL() {}\n\tL(P a, P b) : a(a), b(b) {}\n\tP vec() const { return b - a; }\n\tP proj(const P &p) const { return a + vec().proj(p - a); }\n\tP refl(const P &p) const { return proj(p) * 2 - p; }\n\tint iSP(const P &p) const {\n\t\tint s = sig(vec().det(p - a));\n\t\tif (s != 0) return s;\n\t\tif (sig(vec().dot(p - a)) < 0) return -2;\n\t\tif (sig(-vec().dot(p - b)) < 0) return 2;\n\t\treturn 0;\n\t}\n\tint iLL(const L &l) const {\n\t\tif (sig(vec().det(l.vec()))) return 1;\n\t\tif (sig(vec().det(l.a - a))) return 0;\n\t\treturn -1;\n\t}\n\tbool iLS(const L &l) const { return sig(tri(a, b, l.a)) * sig(tri(a, b, l.b)) <= 0; }\n\tbool iSS(const L &l) const { return this->iSP(l.a) * this->iSP(l.b) <= 0 && l.iSP(a) * l.iSP(b) <=0; }\n\tP pLL(const L &l) const { return a + vec() * (l.a - a).det(l.vec()) / b.det(l.vec()); }\n\tdouble dLP(const P &p) const { return abs(tri(a, b, p)) / vec().abs(); }\n\tdouble dSP(const P &p) const {\n\t\tif (sig(vec().dot(p - a)) <= 0) return (p - a).abs();\n\t\tif (sig(vec().dot(p - b)) >= 0) return (p - b).abs();\n\t\treturn dLP(p);\n\t}\n\tdouble dLL(const L &l) const { return iLL(l) ? 0 : dLP(l.a); }\n\tdouble dLS(const L &l) const { return iLS(l) ? 0 : min(dLP(l.a), dLP(l.b)); }\n\tdouble dSS(const L &l) const { return iSS(l) ? 0 : min(min(dSP(l.a), dSP(l.b)), min(l.dSP(a), l.dSP(b))); }\n};\n\nP p[310];\n\nint main() {\n\tint n, res;\n\tIL {\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tres = 1;\n\t\trep (i, n) cin >> p[i].x >> p[i].y;\n\t\trep (i, n) repn (j, i + 1, n) {\n\t\t\tif (sig((p[i] - p[j]).abs() - 2) > 0) continue;\n\t\t\tP v = p[j] - p[i];\n\t\t\tdouble th = acos(v.abs() / 2);\n\t\t\tP c = p[i] + P(cos(v.arg() + th), sin(v.arg() + th));\n\t\t\tint r = 0;\n\t\t\trep (k, n) {\n\t\t\t\tif (sig((p[k] - c).abs() - 1) <= 0) ++r;\n\t\t\t}\n\t\t\tres = max(res, r);\n\t\t\tc = p[i] + P(cos(v.arg() - th), sin(v.arg() - th));\n\t\t\tr = 0;\n\t\t\trep (k, n) {\n\t\t\t\tif (sig((p[k] - c).abs() - 1) <= 0) ++r;\n\t\t\t}\n\t\t\tres = max(res, r);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define LP(i,n) for(int i = 0; i < n; i++)\n\nusing namespace std;\ntypedef pair<double,double> P;\n\ndouble Dist(double x1[], double x2[]){\n\treturn pow((x1[0]-x2[0])*(x1[0]-x2[0])+(x1[1]-x2[1])*(x1[1]-x2[1]),0.5);\n\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\twhile(n){\n\t\tint mx = 0;\n\t\tP p[300];\n\t\tLP(i,n){\n\t\t\tcin >> p[i].first >> p[i].second;\n\t\t}\n\t\tsort(p,p+n);\n\t\tdouble x[300][2];\n\t\tLP(i,n){\n\t\t\tx[i][0] = p[i].first;\n\t\t\tx[i][1] = p[i].second;\n\t\t}\n\t\tdouble dist[300][300];\n\t\tLP(i,n){\n\t\t\tLP(j,n){\n\t\t\t\tdist[i][j] = Dist(x[i],x[j]);\n\t\t\t}\n\t\t}\n\t\tLP(i,n){\n\t\t\tfor(int j = i+1; j < n; j++){\n\t\t\t\tif(x[j][0]-x[i][0] > 2){\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tif(dist[i][j] <= 2){\n\t\t\t\t\t\tdouble m[] = {(x[j][0]+x[i][0])/2,(x[j][1]+x[i][1])/2};\n\t\t\t\t\t\tdouble d[] = {x[j][1]-x[i][1],-x[j][0]+x[i][0]};\n\t\t\t\t\t\tdouble O[] = {0,0};\n\t\t\t\t\t\tdouble _d = Dist(d,O);\n\t\t\t\t\t\tLP(k,2){\n\t\t\t\t\t\t\td[k] *= (pow(_d,-2)-0.25);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdouble o[2][2];\n\t\t\t\t\t\tLP(k,2){\n\t\t\t\t\t\t\tLP(l,2){\n\t\t\t\t\t\t\t\to[k][l] = m[l];\n\t\t\t\t\t\t\t\tif(k) o[k][l] += d[l];\n\t\t\t\t\t\t\t\telse o[k][l] -= d[l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLP(k,2){\n\t\t\t\t\t\t\tint s = 0;\n\t\t\t\t\t\t\tfor(int l = i; l < j; l++){\n\t\t\t\t\t\t\t\tif(Dist(x[l],o[k]) <= 1) s++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int l = i-1; 0<=l && x[i][0]-x[l][0] <= 1;l--){\n\t\t\t\t\t\t\t\tif(Dist(x[l],o[k]) <= 1) s++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int l = j; l < n && x[l][0]-x[j][0] <= 1; l++){\n\t\t\t\t\t\t\t\tif(Dist(x[l],o[k]) <= 1) s++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmx = max(mx,s);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mx == 0) mx = 1;\n\t\tcout << mx << endl;\n\t\tcin >> n;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n\n#define INF 1e10\n#define EPS (1e-10)    //誤差\n#define PI 3.1415926535897932384626433832795028841971\ntypedef complex<double> P;\n \nstruct star{\n    P point[5];    \n};\n \n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n \n//二つのベクトルが等しいかどうか\nbool EQV(P a, P b){\n    return (EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()));\n}\n \n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n \n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n \n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n// 点cが線分a,b上にあるかないか(3)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n \n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n//図を思い出す\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n \n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n \n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n\n// 点a1,a2を短点とする線分と、点b1,b2を端点とする線分との距離\ndouble distance_ls_ls(P a1, P a2, P b1, P b2){\n    if(is_intersected_ls(a1, a2, b1, b2)) return 0.0;\n    double ret = INF;\n    ret = min(ret, distance_ls_p(a1, a2, b1));\n    ret = min(ret, distance_ls_p(a1, a2, b2));\n    ret = min(ret, distance_ls_p(b1, b2, a1));\n    ret = min(ret, distance_ls_p(b1, b2, a2));\n    return ret;\n}\n \n\n\nsigned main(){\n    \n    while(1){\n\n        int n; cin >> n;\n        if(n == 0) break;\n        vector<P> points(n);\n        for(int i = 0; i < n; i++){\n            double x, y; cin >> x >> y;\n            points[i] = P(x, y);\n        }\n\n\n        int ans = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                P a = points[i];\n                P b = points[j];\n                if(abs(a - b) >= 2.0 + EPS) continue;\n                P m = (a + b) * 0.5;\n                P norm = (b - a) * P(0, 1);\n                norm = norm / abs(norm);\n                double l = abs(b - a) / 2;\n                double dist = sqrt(1.0 - l * l);\n                P O = m + norm * dist;\n                \n                int tmp = 0;\n                for(int k = 0; k < n; k++){\n                    if(abs(O - points[k]) <= 1.0 + EPS) tmp++;\n                }\n\n                ans = max(tmp, ans);\n            }\n        }\n\n        cout << max(ans, 1) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\nusing namespace std;\ntypedef complex<double> P;\nint n;\nvector<P> p;\nint ret(){\n\tint cnt=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(abs(p[i]-p[j])>2.0)\n\t\t\t\tcontinue;\n\t\t\tP c=(p[i]+p[j])*0.5;\n\t\t\tdouble d=sqrt(1.0-abs(p[i]-c)*abs(p[i]-c));\n\t\t\tP l1=(p[i]-p[j])*P(0,1);\n\t\t\tP l2=(p[i]-p[j])*P(0,-1);\n\t\t\tl1=l1*d/abs(l1)+c;l2=l2*d/abs(l2)+c;\n\t\t\tint x=2,y=2;\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(k==i||k==j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(abs(l1-p[k])<1.0+0.00001){\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif(abs(l2-p[k])<1.0+0.000001){\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tcnt=max(cnt,max(x,y));\n\t\t}\n\t}\n\treturn cnt;\n\t\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tp.resize(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tp[i]=P(x,y);\n\t\t}\n\t\tcout<<ret()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define double long double\ntypedef complex<double> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\nconst int R = 100000;\n\nint N;\nP X[300];\n\nint f(P x) {\n  int ctr = 0;\n  rep(i, N) {\n    P p = X[i];\n    if (abs(x-p) <= 1.0) ctr++;\n  }\n  return ctr;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  while (cin >> N && N != 0) {\n    rep(i, N) {\n      double x, y;\n      cin >> x >> y;\n      X[i] = P(x, y);\n    }\n    int ans = 1;\n    rep(i, N) {\n      rep(j, i) {\n        P a = X[i], b = X[j];\n        P base = (a+b)/(double)2.0;\n        P v = b-a;\n        double d = abs(v) / 2.0;\n        if (d > 1) continue;\n        P h1 = ((v*P(0, +1)) / abs(v)) * sqrt(1.0-d*d);\n        P h2 = ((v*P(0, -1)) / abs(v)) * sqrt(1.0-d*d);\n        ans = max(ans, f(base+h1));\n        ans = max(ans, f(base+h2));\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n\nusing namespace std;\n\nint n;\n\ndouble xi[300];\ndouble yi[300];\n\ndouble distant2(double x1,double y1,double x2,double y2)\n{\n\treturn (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n}\n\nint search(int i,int j)\n{\n\tdouble mx = (xi[i] + xi[j]) / 2,my = (yi[i] + yi[j]) / 2;\n\tdouble diff2 = distant2(mx,my,xi[i],yi[i]);\n\n\tif(diff2 > 1.0)\n\t\treturn 1; //1ツ古つつセツつッ\n\tdouble len = sqrt(1 - diff2);\n\tdouble diff = sqrt(diff2);\n\tdouble dx = len * (yi[i] - my) / diff,dy = len * (xi[i] - mx) / diff;\n\t\n\tint sign[] = {1,-1};\n\tint counter[2] = {0};\n\tfor(int s = 0; s < 2; s++)\n\t{\n\t\tdouble x = mx - sign[s] * dx,y = my + sign[s] * dy;\n\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tif(k == i || k == j){counter[s]++; continue;}\n\t\t\tif((x-xi[k])*(x-xi[k]) + (y-yi[k])*(y-yi[k])  <= 1.0)\n\t\t\t\tcounter[s]++;\n\t\t}\n\t}\n\n\treturn max(counter[0],counter[1]);\n}\n\n\n\nint solve()\n{\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> xi[i] >> yi[i];\n\t}\n\n\tint count = 0;\n\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = i+1; j < n; j++){\n\t\t\tcount = max(count,search(i,j));\n\t\t}\n\t}\n\n\treturn count;\n}\n\nint main() {\n  while (cin >>n,n) {\n    cout << solve() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 310\n\ndouble x[MAX_N], y[MAX_N];\nint n, maxn;\n\nint main() {\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tmaxn = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tint sum = 0;\n\t\t\t\tdouble X = (x[i] + x[j]) / 2.0;\n\t\t\t\tdouble Y = (y[i] + y[j]) / 2.0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (((x[k] - X)*(x[k] - X) + (y[k] - Y)*(y[k] - Y)) <= 1) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint sum = 0;\n\t\t\tdouble X = x[i];\n\t\t\tdouble Y = y[i];\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (((x[k] - X)*(x[k] - X) + (y[k] - Y)*(y[k] - Y)) <= 1) {\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxn = max(maxn, sum);\n\t\t}\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\nusing ll = long long ;\nusing P = pair<int,int> ;\nusing pll = pair<long long,long long>;\nconstexpr int INF = 1e9;\nconstexpr long long LINF = 1e17;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979323846;\n\nusing d = double;\nconstexpr double EPS = 1e-6;\nconstexpr bool eq(const d& x,const d& y){return abs(x-y)<EPS;}\nstruct point{\n    d x=0,y=0;\n    constexpr point(const d& x=0,const d& y=0):x(x),y(y){}\n    constexpr bool operator==(const point& r)const{return eq(x,r.x)&&eq(y,r.y);};\n    constexpr bool operator!=(const point& r)const{return !(*this==r);};\n    constexpr bool operator<(const point& r)const{return (eq(x,r.x))?(y<r.y):(x<r.x);};\n    constexpr bool operator>(const point& r)const{return (eq(x,r.x))?(y>r.y):(x>r.x);};\n    constexpr point operator+(const point& r)const{return point(*this)+=r;}\n    constexpr point operator+=(const point& r){\n        x+=r.x;y+=r.y;\n        return *this;\n    }\n    constexpr point operator-(const point& r)const{return point(*this)-=r;}\n    constexpr point operator-=(const point& r){\n        x-=r.x;y-=r.y;\n        return *this;\n    }\n    constexpr point operator*(const d& r)const{return point(*this)*=r;}\n    constexpr point operator*=(const d& r){\n        x*=r;y*=r;\n        return *this;\n    }\n    constexpr point operator*(const point& r)const{return point(*this)*=r;}\n    constexpr point operator*=(const point& r){\n        d tmp=x;\n        x=x*r.x-y*r.y;\n        y=tmp*r.y+y*r.x;\n        return *this;\n    }\n    constexpr point operator/(const double& r)const{return point(*this)/=r;}\n    constexpr point operator/=(const double& r){\n        x/=r;y/=r;\n        return *this;\n    }\n};\nd norm(const point& a){return a.x*a.x+a.y*a.y;}\ndouble abs(const point& a){return sqrt(a.x*a.x+a.y*a.y);}\nd dot(const point& a,const point& b){return a.x*b.x+a.y*b.y;}\nd cross(const point& a,const point& b){return a.x*b.y-a.y*b.x;}\npoint projection(const point& p,const point& b){return b*dot(p,b)/norm(b);}\npoint unit_vec(const point& p){return p/abs(p);}\npoint normal_vec(const point& p){return p*point(0,1);}\npoint rotation(const point& center,const point& p,const point& rot){return rot*(p-center)+center;}\ndouble area(const point& a,const point& b,const point& c){return cross(b-a,c-a)/2;}\n\nstruct Line{\n    point a,b;\n    constexpr Line(const point& a=point(0,0),const point& b=point(0,0)):a(a),b(b){}\n    constexpr Line(const double& A,const double& B,const double& C){ // Ax + By + C = 0\n        if(eq(A,0)&&eq(B,0)) assert(-1);\n        else if(eq(B,0)){\n            a = point(-C/A,0);\n            b = point(-C/A,1);\n        }else{\n            a = point(0,-C/B);\n            b = point(1,-(A+C)/B);\n        }\n    }\n};\nbool is_orthoonal(const Line& l,const Line& r){return eq(dot(l.b-l.a,r.b-r.a),0);}\nbool is_pararell(const Line& l,const Line& r){return eq(cross(l.b-l.a,r.b-r.a),0);}\nbool on_Line(const Line& l,const point& p){return eq(dot(p-l.a,l.b-l.a),0);}\ndouble dis_Lp(const Line& l,const point& p){return abs(cross(l.b-l.a,p-l.a))/abs(l.b-l.a);}\npoint Line_intersect(const Line& l,const Line& r){\n    point lv=l.b-l.a,rv=r.b-r.a;\n    return l.a + lv * abs(cross(r.b-l.a,rv) / cross(lv,rv)); \n}\nLine vertical_bisector(const point& p,const point& q){return Line((p+q)/2,rotation((p+q)/2,q,point(0,1)));}\nusing Segment = Line;\nbool on_Segment(const Segment& s,const point& p){\n    return ( abs(s.a-p)+abs(s.b-p)<abs(s.a-s.b)+EPS );\n}\nbool is_segment_intersect(const Segment& s,const Segment& t){\n    return  (cross(s.b-s.a,t.a-s.a) * cross(s.b-s.a,t.b-s.a) < EPS) &&\n            (cross(t.b-t.a,s.a-t.a) * cross(t.b-t.a,s.b-t.a) < EPS);\n}\npoint segment_intersect(const Segment& s,const Segment& t){\n    double d1 = dis_Lp(s,t.a);\n    double d2 = dis_Lp(s,t.b); \n    double p = d1/(d1+d2);\n    return t.a + (t.b-t.a)*p;\n}\n\nbool on_circle(point cen,point p){\n    return ( (cen.x-p.x)*(cen.x-p.x)+(cen.y-p.y)*(cen.y-p.y)<=1.0+EPS );\n}\n\nint main(){\n    int n;\n    while(cin >> n){\n        if(n==0) break;\n        vector<point> points(n);\n        rep(i,n) cin >> points[i].x >> points[i].y;\n        vector<point> centers;\n        vector<Line> lines;\n        rep(i,n)rep(j,i){\n            point p = (points[i]+points[j])/2;\n            centers.push_back(p);\n            if(1-norm(p-points[i])<=0) continue;\n            double dd = sqrt(1-norm(p-points[i])) / abs(p-points[i]);\n            point a = rotation(p,points[i],point(0,1)*dd);\n            point b = rotation(p,points[i],point(0,-1)*dd);\n            centers.push_back(a);\n            centers.push_back(b);\n        }\n\n        int mx = 1;\n        for(point c:centers){\n            int res = 0;\n            rep(i,n){\n                if(on_circle(c,points[i])) ++res;\n            }\n            mx = max(res,mx);\n            //cout << n << \" \" << res << endl;\n        }\n        cout << mx << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\n\ncomplex<double> Z[300];\n\nint main(void)\n{\n    int N, ans, count;\n    double X, Y;\n    while(true)\n    {\n        cin >> N;\n        if (!N) break;\n        for (int i = 0; i < N; i++)\n        {\n            cin >> X >> Y;\n            Z[i].real(X);\n            Z[i].imag(Y);\n        }\n        ans = 0;\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = i + 1; j < N; j++)\n            {\n                if (abs(Z[i] - Z[j]) >= 1.9999) continue;\n                auto a = (Z[i] - Z[j]) / 2.;\n                auto b = (Z[i] + Z[j]) / 2.;\n                auto r = sqrt(1. - norm(a));\n                a /= abs(a);\n                a *= r * 1.i;\n                complex<double> c[2] = {b + a, b - a};\n                for (int k = 0; k < 2; k++)\n                {\n                    count = 2;\n                    for (int l = 0; l < N; l++)\n                    {\n                        if (l == i || l == j) continue;\n                        if (abs(c[k] - Z[l]) <= 1.) count++;\n                    }\n                    if (count > ans) ans = count;\n                }\n            }\n        }\n        cout << (ans ? ans : 1) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define EPS 1.0e-4\nusing namespace std;\n\ntypedef struct {\n  double x,y;\n} P;\n\ndouble dis(P p ){\n  return sqrt( p.x*p.x + p.y*p.y );\n}\ndouble dis(P p1,P p2 ){\n  P p;\n  p.x = p1.x-p2.x;\n  p.y = p1.y-p2.y;\n  return dis( p );\n}\n\n\nint main(){\n  int n, mx;\n  // mv : @üxNg\n  P p[301], m, p1,p2, mv,dmv, c[2];\n  double x;\n\n  while( cin>>n && n ){\n    for( int i=0;i<n;i++ )\n      cin >> p[i].x >> p[i].y ;\n\n    mx=0;\n    for( int i=0;i<n;i++ ){\n      for( int j=i+1;j<n;j++ ){\n\tif( dis(p[i],p[j]) < 2.0+EPS ){\n\t  p1=p[i]; p2=p[j];\n\t  m.x = (p1.x+p2.x)/2.0;\n\t  m.y = (p1.y+p2.y)/2.0;\n\n\t  x=dis(p1,m);\n\t  x=sqrt( 1-x*x );\n\t  // S_ cðßé\n\t  if( fabs( p1.y-p2.y ) < EPS ){\n\t    mv.x=0.0;  mv.y=1.0;\n\t  }else if( fabs( p1.x-p2.x ) < EPS ){\n\t    mv.x=1.0;  mv.y=0.0;\n\t  }else{\n\t    double a1 = ( p2.y-p1.y )/( p2.x-p1.x );\n\t    mv.x=1.0; mv.y=-1.0/a1;\n\t  }\n\t  double scale = dis( mv );\n\t  dmv.x = x*mv.x / scale;\n\t  dmv.y = x*mv.y / scale;\n\n\t  c[0].x=m.x+dmv.x; c[0].y=m.y+dmv.y;\n\t  c[1].x=m.x-dmv.x; c[2].y=m.y-dmv.y;\n\t  /*\n\t  cout << \"m  \" << m.x    << \",\" << m.y    << endl;\n\t  cout << \"mv \" << mv.x   << \",\" << mv.y   << endl;\n\t  cout << \"dm \" << dmv.x  << \",\" << dmv.y  << endl;\n\t  cout << \"c0 \" << c[0].x << \",\" << c[0].y << endl;\n\t  cout << \"c1 \" << c[1].x << \",\" << c[1].y << endl;\n\t  */\n\n\t  for( int cn=0;cn<2;cn++ ){\n\t    int sum=0;\n\t    for( int k=0;k<n;k++ ){\n\t      if( dis( c[cn],p[k] ) < 1.0+EPS )\n\t\tsum++;\n\t    }\n\t    if( mx<sum ) mx=sum;\n\t  }\n\t}\n      }\n    }\n    cout << mx << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-8;\n\nstruct Circle{\n  P c;\n  double r;\n  Circle(P c=P(0,0),double r=0):c(c),r(r){}\n};\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1=c1.r,r2=c2.r,d;\n  P p1=c1.c,p2=c2.c;\n  d=abs(p1-p2);\n  if(d<EPS&&abs(r1-r2)<EPS) return res;\n  if(r1+r2<d-EPS||d+EPS<abs(r1-r2)) return res; \n  double a=(r1*r1-r2*r2+d*d)/(2*d);\n  double h=sqrt(max(r1*r1-a*a,0.0));\n  P tmp1=p1+a/d*(p2-p1);\n  P tmp2=h/d*(p2-p1);\n  if(abs(tmp2)<EPS)res.push_back(tmp1);\n  else{\n    res.push_back(P(real(tmp1)-imag(tmp2),imag(tmp1)+real(tmp2)));\n    res.push_back(P(real(tmp1)+imag(tmp2),imag(tmp1)-real(tmp2)));\n  }\n  return res;\n}\n\ndouble getdistancepp(P a,P b){\n  return sqrt((a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag()));\n}\n\nint main(){\n  int n,ans=0;\n  double a,b;\n  P p[N];\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>a>>b;\n      p[i]=P(a,b);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tCircle c1,c2;\n\tc1.c=p[i];\n\tc2.c=p[j];\n\tc1.r=c2.r=1;\n\tvector<P> r=getIntersectCC(c1,c2);\n\tif(!r.size())continue;\n\tfor(int k=0;k<r.size();k++){\n\t  int cnt=0;\n\t  for(int l=0;l<n;l++)\n\t    if(getdistancepp(r[k],p[l])<=1+EPS)cnt++;\t    \n\t  ans=max(ans,cnt);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n)-1;i>=(m);--i)\n#define repc(i,n) for(int i=0;i<=(n);++i)\n#define repcn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repcd(i,n) for(int i=(n);i>=0;--i)\n#define repcnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define repc0(i,n) for(i=0;i<=(n);++i)\n#define repcn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repcd0(i,n) for(i=(n);i>=0;--i)\n#define repcnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE cout<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nint sig(double r) { return r < -EPS ? -1 : r > EPS ? 1 : 0; }\n\nstruct P {\n\tdouble x, y;\n\tP() {}\n\tP(double x, double y) : x(x), y(y) {}\n\tP operator+(const P &a) const { return P(x + a.x, y + a.y); }\n\tP operator-(const P &a) const { return P(x - a.x, y - a.y); }\n\tP operator*(const P &a) const { return P(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tP operator-() const { return P(-x, -y); }\n\tP operator*(const double &k) const { return P(x * k, y * k); }\n\tP operator/(const double &k) const { return P(x / k, y / k); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble abs() const { return sqrt(abs2()); }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const P &a) const { return x * a.x + y * a.y; }\n\tdouble det(const P &a) const { return x * a.y - y * a.x; }\n\tP proj(const P &a) const { double k = dot(a) / abs2(); return P(x * k, y * k); }\n\tbool operator<(const P &a) const { return x != a.x ? x < a.x : y < a.y; }\n\tbool operator==(const P &a) const { return sig(x - a.x) == 0 && sig(y - a.y) == 0; }\n};\n\nostream &operator<<(ostream&os, const P&a) { os << \"(\" << a.x << \", \" << a.y << \")\"; return os; }\ndouble tri(P a, P b, P c) { return (b - a).det(c - a); }\n\nstruct L {\n\tP a, b;\n\tL() {}\n\tL(P a, P b) : a(a), b(b) {}\n\tP vec() const { return b - a; }\n\tP proj(const P &p) const { return a + vec().proj(p - a); }\n\tP refl(const P &p) const { return proj(p) * 2 - p; }\n\tint iSP(const P &p) const {\n\t\tint s = sig(vec().det(p - a));\n\t\tif (s != 0) return s;\n\t\tif (sig(vec().dot(p - a)) < 0) return -2;\n\t\tif (sig(-vec().dot(p - b)) < 0) return 2;\n\t\treturn 0;\n\t}\n\tint iLL(const L &l) const {\n\t\tif (sig(vec().det(l.vec()))) return 1;\n\t\tif (sig(vec().det(l.a - a))) return 0;\n\t\treturn -1;\n\t}\n\tbool iLS(const L &l) const { return sig(tri(a, b, l.a)) * sig(tri(a, b, l.b)) <= 0; }\n\tbool iSS(const L &l) const { return this->iSP(l.a) * this->iSP(l.b) <= 0 && l.iSP(a) * l.iSP(b) <=0; }\n\tP pLL(const L &l) const { return a + vec() * (l.a - a).det(l.vec()) / b.det(l.vec()); }\n\tdouble dLP(const P &p) const { return abs(tri(a, b, p)) / vec().abs(); }\n\tdouble dSP(const P &p) const {\n\t\tif (sig(vec().dot(p - a)) <= 0) return (p - a).abs();\n\t\tif (sig(vec().dot(p - b)) >= 0) return (p - b).abs();\n\t\treturn dLP(p);\n\t}\n\tdouble dLL(const L &l) const { return iLL(l) ? 0 : dLP(l.a); }\n\tdouble dLS(const L &l) const { return iLS(l) ? 0 : min(dLP(l.a), dLP(l.b)); }\n\tdouble dSS(const L &l) const { return iSS(l) ? 0 : min(min(dSP(l.a), dSP(l.b)), min(l.dSP(a), l.dSP(b))); }\n};\n\nP p[310];\n\nint main() {\n\tint n, res;\n\tIL {\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tres = 1;\n\t\trep (i, n) cin >> p[i].x >> p[i].y;\n\t\trep (i, n) rep (j, n) {\n\t\t\tif (sig((p[i] - p[j]).abs() - 2) > 0) continue;\n\t\t\tdouble th = acos(min((p[i] - p[j]).abs() / 2, 1.));\n\t\t\tP c = p[i] + P(cos(th), sin(th));\n\t\t\tint r = 0;\n\t\t\trep (k, n) {\n\t\t\t\tif (sig((p[k] - c).abs() - 1) <= 0) ++r;\n\t\t\t}\n\t\t\tres = max(res, r);\n\t\t\tc = p[i] + P(cos(-th), sin(-th));\n\t\t\tr = 0;\n\t\t\trep (k, n) {\n\t\t\t\tif (sig((p[k] - c).abs() - 1) <= 0) ++r;\n\t\t\t}\n\t\t\tres = max(res, r);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\n#define EPS 1.0e-8\ntypedef complex<double> P;\n\nint main(){\n  int n;\n  P p[301];\n\n  while( cin>>n && n ){\n    for( int i=0;i<n;i++ )\n      cin >> p[i].real() >> p[i].imag();\n\n    int ans=0;\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ ){\n\tif( i==j ) \t  continue;\n\tif( abs( p[i]-p[j] )+EPS > 2.0 ) continue;\n\n\tP m  = (p[i]+p[j]) / 2.0; // p[i]Æp[j]Ì_\n\tP nn = (p[i]-p[j]) * P(0,1);       // @üxNg\n\tnn = nn / abs(nn);\n\n\tdouble x = abs( p[i]-p[j] )/2.0;\n\tP c = m + nn*sqrt( 1.0-x*x );        // ~ÌS\n\n\tint num=0;\n\tfor( int k=0;k<n;k++ )\n\t  if( abs( c-p[k] ) < 1.0 + EPS  )\n\t    num++;\n\tans = max( ans,num );\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,N) for(int i=0;i<(int)(N);i++)\n#define REP(i,k,N) for(int i=k;i<(int)(N);i++)\n\n#define vi vector<int>\n#define pb push_back\n\n#define pdd pair<double,double>\n#define fi first\n#define se second\nconst double  EPS = 1e-6;\n\ndouble dist(double x,double y){\n    return x*x+y*y;\n};\n\nint main(){\n    ifstream in(\"d_in.txt\");\n    cin.rdbuf(in.rdbuf());\n    int n;\n    while(cin >> n,n){\n        int ma = 0;\n        pdd p[330];\n        rep(i,n) cin >> p[i].fi >> p[i].se;\n        rep(i,n-1){\n            REP(j,i+1,n){\n\n                double x1,y1,x2,y2,x3,y3;\n                tie(x1,y1) = p[i];\n                tie(x2,y2) = p[j];\n                double cx1,cy1,cx2,cy2;\n                if(dist(x1-x2,y1-y2)  > 4+EPS  ) continue;\n\n                //はりまコーナー\n//                double ax,ay,bx1,by1,bx2,by2,mx,my,dx,dy;\n//                ax=x1-x2;ay=y1-y2;\n//                mx=(x1+x2)/2;my=(y1+y2)/2;\n//                by1 = (-0.5)*pow(ax,4)+pow(ax,2)+(-0.5)*pow(ax,2)*pow(ay,2)\n//                        /dist(ax,ay);\n//                by1 = sqrt(abs(by1));\n//                by2 = -1*by1;\n//                cy1= my+by1;\n//                cy2= my+by2;\n//                bx1= -1*(ay*by1)/ax;\n//                bx2= -1*(ay*by2)/ax;\n//                cx1=bx1+mx;\n//                cx2=bx2+mx;\n\n\n                //あじのりコーナー\n                double mx=(x1+x2)/2,my=(y1+y2)/2;\n\n                double ld = sqrt(1-dist((x1-x2),(y1-y2))/4);\n                double theta = atan((y2-y1)/(x2-x1));\n                cx1 = mx - sin(theta)*ld;\n                cy1 = my + cos(theta)*ld;\n                cx2 = mx + sin(theta)*ld;\n                cy2 = my - cos(theta)*ld;\n\n                int cnt1 = 0,cnt2=0;\n                for(int k = 0;k<n;k++) {\n                    tie(x3, y3) = p[k];\n                    if (EPS + 1> dist((cx1 - x3), (cy1 - y3))) cnt1++;\n                    if (EPS + 1> dist((cx2 - x3), (cy2 - y3))) cnt2++;\n                }\n                ma = max({cnt1,cnt2,ma});\n            }\n        }\n        cout<< ma << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <numeric>\n#include <tuple>\n#include <assert.h>\n\n#define sqr(x) std::pow(x, 2.0)\n#define INF 1e10\n#define EPS 1e-10\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define POS_OR_INF(x) (x > 0 ? x : INF)\n\nusing namespace std;\n\nusing ld = long double;\n\nstruct Point {\n\tPoint() = default;\n\tPoint(ld x, ld y): x(x), y(y) {}\n\tPoint(const Point& s, const Point& e) : x(e.x-s.x), y(e.y-s.y) {}\n\n\tPoint normalized(void) const {\n\t\treturn Point(x / norm(), y / norm());\n\t}\n\n\tld norm(void) const {\n\t\treturn sqrt(x * x + y * y);\n\t}\n\n\tPoint flipped(void) const {\n\t\treturn Point(-x, -y);\n\t}\n\n\tPoint normal_vector(bool normalize = false) const {\n\t\tauto vec = Point(-y, x);\n\t\treturn normalize ? vec.normalized() : vec;\n\t}\n\n\tld x, y;\n};\n\nusing Vector = Point;\n\ninline Vector points2vec(const Point& s, const Point& e) {\n\treturn Vector(e.x - s.x, e.y - s.y);\n}\n\ninline ld distance(const Point& s, const Point& e) {\n\treturn points2vec(s, e).norm();\n}\n\ninline ld distance_square(const Point& s, const Point& e) {\n\treturn pow(points2vec(s, e).norm(), 2.0);\n}\n\ninline Vector operator * (const Vector& l, ld r) {\n\treturn Vector(l.x * r, l.y * r);\n}\n\ninline Vector operator * (ld l, const Vector& r) {\n\treturn r * l;\n}\n\ninline Vector operator / (const Vector& l, ld r) {\n\treturn Vector(l.x / r, l.y / r);\n}\n\ninline Point operator + (const Point& l, const Point& r) {\n\treturn Point(l.x + r.x, l.y + r.y);\n}\n\ninline Point operator - (const Point& l, const Point& r) {\n\treturn Point(l.x - r.x, l.y - r.y);\n}\n\ninline istream& operator >> (istream& is, Point& p) {\n\treturn is >> p.x >> p.y;\n}\n\nint main(int argc, char** argv) {\n\tint N;\n\n\twhile (cin >> N && N > 0) {\n\t\tvector<Point> p(N);\n\n\t\tREP(i, N)\n\t\t\tcin >> p[i];\n\n\t\tlong ans = 1;\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tif (distance(p[i], p[j]) > 2.0) continue;\n\n\t\t\t\tauto mid = (p[i] + p[j]) / 2;\n\t\t\t\tauto l = sqrt(4 - distance_square(p[i], p[j])) / 2;\n\t\t\t\tauto normal = Vector(p[i], p[j]).normal_vector(true);\n\n\t\t\t\tauto center1 = mid + normal * l;\n\t\t\t\tauto center2 = mid - normal * l;\n\n\t\t\t\tlong n1 = count_if(p.begin(), p.end(), [&](const Point& p) { return distance(center1, p) <= 1.0 + EPS; });\n\t\t\t\tlong n2 = count_if(p.begin(), p.end(), [&](const Point& p) { return distance(center2, p) <= 1.0 + EPS; });\n\n\t\t\t\tans = max(ans, max(n1, n2));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\ntypedef pair<double, double> PD;\n\nconst double EPS = 1e-11;\ndouble sq(double x) { return x * x; }\n\nvoid solve(double ax, double ay, double bx, double by, int &ma,\n\t\t vector<double> &x, vector<double> &y) {\n  double sqdist = sq(ax - bx) + sq(ay - by);\n  double dist = sqrt(sqdist);\n  double ndist = sqrt(1 - sqdist / 4);\n  double ex = (bx - ax) / dist, ey = (by - ay) / dist;\n  vector<PD> ans(2);\n  int n = x.size();\n  REP(i, 0, 2) {\n    double coef = i == 0 ? 1 : -1;\n    double cx = (ax + bx) / 2 + ey * coef * ndist;\n    double cy = (ay + by) / 2 - ex * coef * ndist;\n    int cnt = 0;\n    REP(i, 0, n) {\n      double sqdist = sq(x[i] - cx) + sq(y[i] - cy);\n      if (sqdist <= 1 + EPS) {\n\tcnt += 1;\n      }\n    }\n    ma = max(ma, cnt);\n  }\n}\n\nint main(void) {\n  int n;\n  while(scanf(\"%d\", &n) && n) {\n    vector<double> x(n), y(n);\n    REP(i, 0, n) scanf(\"%lf%lf\", &x[i], &y[i]);\n    int ma = 0;\n    REP(i, 0, n) {\n      REP(j, 0, i) {\n        solve(x[i], y[i], x[j], y[j], ma, x, y);\n      }\n    }\n    printf(\"%d\\n\", ma);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\ntypedef pair<double,double> P;\n\ninline double dist(P p,P q){\n  return ( (p.first-q.first)*(p.first-q.first) + (p.second-q.second)*(p.second-q.second));\n}\n\nint main(){\n  int N;\n  double sign[2] = {+1, -1};\n  P p[301];\n  while(scanf(\"%d\",&N) == EOF){\n    if(N == 0)break;\n    REP(i,N)scanf(\"%lf %lf\",&p[i].first,&p[i].second);\n    int ans = 1;\n    REP(i,N){\n      FOR(j,i+1,N){\n        double dst = dist(p[i],p[j]);\n        if(dst > 4.0) continue;\n        P v((p[j].first-p[i].first)/dst, (p[j].second-p[i].second)/dst);\n        P m((p[j].first+p[i].first)/2.0, (p[j].second+p[i].second)/2.0);\n        double lth = sqrt(1.0-dst*dst/4.0);\n        REP(k,2){\n          double cx = m.first + sign[k] * v.first * lth;\n          double cy = m.second - sign[k] * v.second * lth;\n          P center(cx,cy);\n          int count = 0;\n          REP(l,N){\n            if(l == i || l == j || dist(center,p[l]) < 1){\n              count++;\n            }\n            if(N-l-1 + count < ans)break;\n          }\n          if(ans < count) ans = count;\n        }\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){\n    rep(i,v.size()) os << v[i] << (i+1==v.size()?\"\":\" \");\n    return os;\n}\n\ntypedef double R;\ntypedef complex<R> P;\nR const eps = 1e-8;\nint main(){\n    int n;\n    while(cin>>n && n){\n        vector<P> ps(n);\n        rep(i,n){\n            R x,y; cin >> x >> y;\n            ps[i] = P(x,y);\n        }\n\n        int ans = 0;\n        rep(i,n)rep(j,n)if(i!=j){\n            P & p = ps[i];\n            P & q = ps[j];\n            R d = abs(p-q);\n            if(d > 2) continue;\n            P m = (p+q)/2.;\n            R l = sqrt(1-(d/2)*(d/2));\n            P c = m + (p-m)*(d/2)*l * P(0,1);\n            int cnt = 0;\n            rep(k,n){\n                if(abs(c-ps[k]) < 1+eps) cnt++;\n            }\n            ans = max(ans,cnt);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Point{\n\tbool operator<(const struct Point &arg) const{\n\t\t\treturn x < arg.x;\n\t};\n\tdouble x,y;\n};\n\ndouble a,b,c,d;\n\ndouble calc(double x){\n\treturn ((c-a)*x)/(b-d)+(b+d)/2-(c-a)*(a+c)/(2.0*(b-d));\n}\n\n\ndouble dist(double x,double y){\n\tdouble ans1 = sqrt((x-a)*(x-a)+(y-b)*(y-b));\n\tdouble ans2 = sqrt((x-c)*(x-c)+(y-d)*(y-d));\n\n\tif(fabs(1.0-ans1) < fabs(1.0-ans2)){\n\t\treturn ans1;\n\t}else{\n\t\treturn ans2;\n\t}\n}\n\nint main(){\n\n\tint N,maximum,count;\n\tPoint points[300];\n\tdouble left,right,m,tmp_x,tmp_y,tmp_dist;\n\n\tbool FLG;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tmaximum = 1;\n\n\t\tfor(int loop = 0; loop < N; loop++){\n\t\t\tscanf(\"%lf %lf\",&points[loop].x,&points[loop].y);\n\t\t}\n\n\t\tsort(points,points+N);\n\n\t\tfor(int i = 0; i <= N-2; i++){\n\t\t\tfor(int k = i+1; k <= N-1; k++){\n\n\t\t\t\ta = points[i].x;\n\t\t\t\tb = points[i].y;\n\t\t\t\tc = points[k].x;\n\t\t\t\td = points[k].y;\n\n\t\t\t\tleft = 0.0;\n\t\t\t\tright = (a+c)/2.0;\n\t\t\t\tm = (left+right)/2.0;\n\n\t\t\t\tFLG = false;\n\n\t\t\t\twhile(left <= right){\n\t\t\t\t\ttmp_y = calc(m);\n\t\t\t\t\ttmp_dist = dist(m,tmp_y);\n\n\t\t\t\t\tif(fabs(tmp_dist-1.0) < EPS){\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\ttmp_x = m;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(tmp_dist > 1.0){\n\t\t\t\t\t\tleft = m + EPS;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tright = m - EPS;\n\t\t\t\t\t}\n\t\t\t\t\tm = (left+right)/2.0;\n\t\t\t\t}\n\n\t\t\t\tif(FLG){\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\t\tif(sqrt((tmp_x-points[p].x)*(tmp_x-points[p].x)+(tmp_y-points[p].y)*(tmp_y-points[p].y)) < 1.0){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}else if(fabs(sqrt((tmp_x-points[p].x)*(tmp_x-points[p].x)+(tmp_y-points[p].y)*(tmp_y-points[p].y))-1.0) <= EPS){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmaximum = max(maximum,count);\n\t\t\t\t}\n\n\t\t\t\tleft = (a+c)/2.0;\n\t\t\t\tright = 10.0;\n\t\t\t\tm = (left+right)/2.0;\n\t\t\t\tFLG = false;\n\n\t\t\t\twhile(left <= right){\n\t\t\t\t\ttmp_y = calc(m);\n\t\t\t\t\ttmp_dist = dist(m,tmp_y);\n\n\t\t\t\t\tif(fabs(tmp_dist-1.0) < EPS){\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\ttmp_x = m;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(tmp_dist > 1.0){\n\t\t\t\t\t\tright = m - EPS;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tleft = m + EPS;\n\t\t\t\t\t}\n\t\t\t\t\tm = (left+right)/2.0;\n\t\t\t\t}\n\n\t\t\t\tif(FLG){\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\t\tif(sqrt((tmp_x-points[p].x)*(tmp_x-points[p].x)+(tmp_y-points[p].y)*(tmp_y-points[p].y)) < 1.0){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}else if(fabs(sqrt((tmp_x-points[p].x)*(tmp_x-points[p].x)+(tmp_y-points[p].y)*(tmp_y-points[p].y))-1.0) <= EPS){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmaximum = max(maximum,count);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",maximum);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i)\n\n#define X() real()\n#define Y() imag()\n#define x(p) (p).X()\n#define y(p) (p).Y()\n#define SZ(P) (int)(P.size())\n#define curr(P, i) P[(i)%SZ(P)]\n#define next(P, i) P[(i+1)%SZ(P)]\n#define prev(P, i) P[(i+SZ(P)-1)%SZ(P)]?´\n\nusing D = double;\nusing P = complex<D>;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return x(a) != x(b) ? x(a) < x(b) : y(a) < y(b);\n  }\n}\nD dot(const P& a, const P& b) {\n  return x(conj(a)*b);\n}\nD cross(const P& a, const P& b) {\n  return y(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a;\n  c -= a;\n  if(cross(b, c) > 0) return +1;\n  if(cross(b, c) < 0) return -1;\n  if(dot(b, c) < 0) return +2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\nstruct C {\n  P p;\n  D r;\n};\n\nP makeP(D arg, D r=1.0) {\n  return r * P{cos(arg), sin(arg)};\n}\nP rotP(const P& p, D arg) {\n  return p * makeP(arg);\n} \n\nvector<P> getNorm(const P& p) {\n  return {rotP(p, PI/2.0)/abs(p), rotP(p, -PI/2.0)/abs(p)};\n}\n\nvector<C> makeC(const P& a, const P& b, D r = 1.0) {\n  P m = (a+b)/2.0;\n  D d = sqrt(r*r-abs(m-a)*abs(m-a));\n  auto ps = getNorm(b-a);\n  rep(i, 2) ps[i] = d*ps[i]+m;\n  vector<C> ret;\n  rep(i, 2) ret.push_back(C{ps[i], r});\n  return ret;\n}\nbool include(const C& c, const P& p) {\n  return abs(c.p-p) < c.r+EPS;\n}\n\nint main() {\n  int n;\n  while(cin >> n && n) {\n    vector<P> ps(n);\n    rep(i, n) {\n      D x, y;\n      cin >> x >> y;\n      ps[i] = P{x, y};\n    }\n    int ans = 1;\n    rep(i, n) rep(j, i) {\n      auto cs = makeC(ps[i], ps[j]);\n      for(auto& c : cs) {\n\tint tmp = 0;\t\n\trep(k, n) if(include(c, ps[k])) tmp++;\n\tans = max(ans, tmp);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdint>\n#include <vector>\n#include <array>\n\nusing namespace std;\n\ntypedef array<double, 2> Point;\n\n\nuint32_t specialSolve(const vector<Point> v, double centerX, double centerY)\n{\n    uint32_t cnt = 0;\n    for(const auto& p: v)\n    {\n        const auto r = sqrt(pow(p[0] - centerX, 2) + pow(p[1] - centerY, 2));\n        if(r <= 1 + 1.0E-6)\n            ++cnt;\n    }\n\n    return cnt;\n}\n\n\nuint32_t solve(const vector<Point>& ps)\n{\n    const auto N = ps.size();\n\n    uint32_t maxCount = 0;\n    for(uint32_t i = 0; i < N; ++i)\n    {\n        auto const x1 = ps[i][0],\n                   y1 = ps[i][1];\n\n        for(uint32_t j = i + 1; j < N; ++j)\n        {\n            auto const x2 = ps[j][0],\n                       y2 = ps[j][1];\n\n            auto const a = -(x2 - x1)/(y2 - y1);\n            auto const a2 = pow(a, 2.0);\n            auto const ds2_4 = pow(x1 - x2, 2) + pow(y1 - y2, 2);\n            auto const dt2 = 1 - ds2_4/4;\n\n            // 2点は同じ半径1の円に入ることはない\n            if(dt2 < 0)\n                continue;\n\n            auto const dx = sqrt(dt2 / (1 + a2));\n            auto const dy = dx * a;\n            auto const avgPosX = (x2 + x1) / 2,\n                       avgPosY = (y2 + y1) / 2;\n            auto const m1 = specialSolve(ps, avgPosX + dx, avgPosY + dy),\n                       m2 = specialSolve(ps, avgPosX - dx, avgPosY - dy);\n\n            if(maxCount < m1)\n                maxCount = m1;\n            if(maxCount < m2)\n                maxCount = m2;\n        }\n    }\n\n\n    return maxCount;\n}\n\n\n\nint main()\n{\n    while(1)\n    {\n        uint32_t N;\n        cin >> N;\n\n        if(N == 0)\n            break;\n\n        vector<Point> ps;\n        for(uint32_t i = 0; i < N; ++i){\n            double a, b;\n            cin >> a >> b;\n            Point p = {a, b};\n            ps.push_back(p);\n        }\n\n\n        auto ans = solve(ps);\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ndouble pi = 3.14159265358979;\n\nsigned main(){\n    ios::sync_with_stdio(false);\n\tcin.tie(0);\n    cout << fixed << setprecision(20);\n\n    int n;\n    double eps = 1e-6;\n    double b = 2*pi/3000;\n    while(cin>>n){\n        if(n==0) break;\n        double x[n],y[n];\n        for(int i=0;i<n;i++){\n            cin>>x[i]>>y[i];\n        }\n        int ans = 0;\n        for(int i=0;i<n;i++){\n            int ret = 0;\n            for(int j=0;j<n;j++){\n                double d = (x[i] - x[j]) * (x[i] - x[j]);\n               d += (y[i] - y[j]) * (y[i]-y[j]);\n                if(d <= 1.0) ret++;\n            }\n            ans = max(ans,ret);\n        }\n        //cerr << \" a \" << ans << endl;\n        for(int i=0;i<n;i++){\n            for(int cnt=0;cnt<3000;cnt++){\n                double theta = b*cnt;\n                double ox = x[i] + cos(theta);\n                double oy = y[i] + sin(theta);\n                int ret = 0;\n                for(int j=0;j<n;j++){\n                    double d = (ox - x[j]) * (ox - x[j]);\n                    d += (oy - y[j]) * (oy - y[j]);\n                    if(d <= 1.0 + eps) ret++;\n                }\n                ans = max(ans,ret);\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nstruct Point{\n\tdouble x,y;\n};\n\nvoid func(int N){\n\n\tPoint point[N];\n\tdouble x_min = 100,y_min = 100,x_max = -1,y_max = -1;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf\",&point[i].x,&point[i].y);\n\t\tx_min = min(point[i].x,x_min);\n\t\ty_min = min(point[i].y,y_min);\n\t\tx_max = max(point[i].x,x_max);\n\t\ty_max = max(point[i].y,y_max);\n\t}\n\n\tif(x_min > 1)x_min -= 1;\n\tif(y_min > 1)y_min -= 1;\n\tif(x_max < 9)x_max += 1;\n\tif(y_max < 9)y_max += 1;\n\n\tint count,max_count = 0;\n\n\tfor(double y = y_min; y <= y_max; y += 0.01){\n\t\tfor(double x = x_min; x <= x_max; x += 0.01){\n\t\t\tcount = 0;\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tif(sqrt((x-point[i].x)*(x-point[i].x)+(y-point[i].y)*(y-point[i].y)) <= 1.0)count++;\n\t\t\t}\n\t\t\tmax_count = max(max_count,count);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",max_count);\n}\n\n\nint main(){\n\n\tint N;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc(N);\n\t}\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n\n#ifdef _DEBUG\n#define typeof(X) std::identity<decltype(X)>::type //C++0x (for vs2010)\n#else\n#define typeof(X) __typeof__(X) // for gcc\n#endif\n\n#define sz(a)  int((a).size())\n#define FOREACH(it, c) for (typeof((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define FOR(i,count) for (int i = 0; i < (count); i++)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nusing namespace std;\nstatic const double EPS = 1e-6;\ntypedef long long ll;\nconst int MODULO = 1000000007;\nconst int INF = 100000000; //1e8\n\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\ntypedef complex<double> Cd;\n\nint n;\nCd pt[300];\n\ndouble sqr(double x) { return x * x; }\n\nint C(Cd &o){\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tCd c = pt[i] - o;\n\t\tif(sqr(c.real()) + sqr(c.imag()) <= 1.0 + EPS)\n\t\t\tcnt++;\n\t}\n\treturn cnt;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tdouble x,y; cin>>x>>y;\n\t\tpt[i] = Cd(x,y);\n\t}\n\n\tint ans = 1;\n\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = i+1; j < n; j++){\n\t\t\tCd e = (pt[j] - pt[i]);\n\t\t\tdouble len = abs(e);\n\t\t\tif(len > 2.0 + EPS) continue;\n\t\t\tCd md = pt[i] + e / 2.0;\n\t\t\te /= len;\n\t\t\te *= Cd(0,1);\n\t\t\tdouble o_dis = sqrt(1.0 - sqr(len / 2));\n\t\t\te *= o_dis;\n\t\t\tstatic int dir[] = {1,-1};\n\t\t\tfor (int k = 0; k < 2; k++){\n\t\t\t\te *= -1;\n\t\t\t\tCd o = md + e; // 中心を出す\n\t\t\t\tans = max(ans,C(o));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n\n}\n\n\nint main(){\n\twhile(cin>>n,n){\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <cmath>\n\nusing namespace std;\n\ntypedef pair<double,double> pos;\nconst double r = 1;\nconst double eps = 0.0000000001;\nint count(vector<pos> ps,double x,double y,int ban1,int ban2){\n\tint c=0;//2;\n\tfor(int i=0;i<ps.size();i++){\n\t\tif(//i!=ban1&&i!=ban2&&\n\t\t\t\tpow(ps[i].first-x,2)+pow(ps[i].second-y,2)<=pow(1.0+eps,2)){\n\t\t\tc++;\n\t\t}\n\t}\n\treturn c;\n}\n\nbool range(pos p1,pos p2,double r){\n\treturn pow(p1.first-p2.first,2)+pow(p1.second-p2.second,2) <= r*r;\n}\n\ndouble len(pos p){\n\treturn sqrt(pow(p.first,2)+pow(p.second,2));\n}\n\ndouble len2(pos p){\n\treturn (pow(p.first,2)+pow(p.second,2));\n}\n\nvector<pos> point2(pos p1,pos p2){\n\tpos m = make_pair((p1.first+p2.first)/2,(p1.second+p2.second)/2);\n\tpos vec = make_pair(p1.first-p2.first,p1.second-p2.second);\n\tpos q = m;//make_pair(p2.first+vec.first/2,p2.second+vec.second/2);\n\tdouble l = sqrt(1-pow(len(vec)/2.0,2));\n\tdouble ll = len(vec);\n\tpos vec2 = make_pair(-vec.second,vec.first);\n\tvec2.first=vec2.first/ll*l;\n\tvec2.second = vec2.second/ll*l;\n\tvector<pos> ret;\n\tret.push_back(make_pair(q.first+vec2.first,q.second+vec2.second));\n\tret.push_back(make_pair(q.first-vec2.first,q.second-vec2.second));\n\treturn ret;\n}\n\nint solve(vector<pos> ps){\n\tint mx=0;\n\tfor(int i=0;i<ps.size()-1;i++)\n\t\tfor(int k=i+1;k<ps.size();k++){\n\t\t\tif(range(ps[i],ps[k],2)){\n\t\t\t\t//cerr << \"*****\" << i << \" \" << k << endl;\n\t\t\t\tvector<pos> vp = point2(ps[i],ps[k]);\n\t\t\t\tmx = max(mx,count(ps,vp[0].first,vp[0].second,i,k));\n\t\t\t\tmx = max(mx,count(ps,vp[1].first,vp[1].second,i,k));\n\t\t\t}\n\t\t}\n\treturn mx;\n}\n\nint main(){\n\t//cerr << point2(make_pair(0,0),make_pair(1,1))[1].first << endl;\n\twhile(true){\n\t\tint n;\n\t\tvector<pos> v;\n\t\tcin >> n;\n\t\tif(n==0)return 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tv.push_back(make_pair(x,y));\n\t\t}\n\t\tcout << solve(v) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <string> \n#include <vector> \n#include <cmath> \n#include <algorithm> \n#include <cstdlib> \n#include <ctime> \n#include <cstdio> \n#include <functional> \n#include <set> \n#include <sstream> \n\n\nusing namespace std; \n\nint main(){\n\n\tint n;\n\tconst double eps=1e-8;\n\twhile(true){\n\n\t\tcin>>n;\n\n\t\tif(n==0) return 0;\n\n\t\tint ans=0;\n\t\tvector< double > x(n),y(n);\n\n\t\tfor(int i=0;i<n;i++) cin>>x[i]>>y[i];\n\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tconst double d=hypot(x[i]-x[j],y[i]-y[j]);\n\t\t\t\tif(d>2-eps) continue;\n\n\t\t\t\tconst double mx=(x[i]+x[j])/2.0;\n\t\t\t\tconst double my=(y[i]+y[j])/2.0;\n\t\t\t\tconst double dvx=(x[i]-x[j])/d;\n\t\t\t\tconst double dvy=(y[i]-y[j])/d;\n\n\t\t\t\tconst double cx1=mx+dvy*sqrt(1.0-d*d/4.0);\n\t\t\t\tconst double cy1=my-dvx*sqrt(1.0-d*d/4.0);\n\n\t\t\t\tconst double cx2=mx-dvy*sqrt(1.0-d*d/4.0);\n\t\t\t\tconst double cy2=my+dvx*sqrt(1.0-d*d/4.0);\n\n\t\t\t\tint res=2;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i || k==j) continue;\n\t\t\t\t\tif(hypot(x[k]-cx1,y[k]-cy1)<1.0+eps) res++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tans=max(ans,res);\n\n\t\t\t\tres=2;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i || k==j) continue;\n\t\t\t\t\tif(hypot(x[k]-cx2,y[k]-cy2)<1.0+eps) res++;\n\t\t\t\t}\n\n\t\t\t\tans=max(ans,res);\n\n\t\t\t}\n\t\t}\n\n\t\tcout<<ans<<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n// ??\\??? ????????¨???\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;}\ntemplate<class T> bool operator< (T a, T b){return a < b-eps;}\ntemplate<class T> bool operator<=(T a, T b){return a < b+eps;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n#define X real()\n#define Y imag()\n\ntypedef bool B;\ntypedef long double D;\ntypedef complex<D> P;\n\nP p[310];\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tD ix,iy;\n\t\trep(i,n){\n\t\t\tcin >> ix >> iy;\n\t\t\tp[i].real(ix),p[i].imag(iy);\n\t\t}\n\t\tint ans=1;\n\t\trep(i,n)rep(j,n){\n\t\t\tif(i<=j) continue;\n\t\t\tD d=norm(p[j]-p[i]);\n\t\t\tif(d>4.0) continue;\n\t\t\tP v=(p[j]-p[i])/P(2.0,0.0);\n\t\t\tD s=sqrt((1.0-norm(v))/norm(v));\n\t\t\tP cnt1=p[i]+v+s*P(v.imag(),-v.real());\n\t\t\tint num=2;\n\t\t\trep(k,n){\n\t\t\t\tif(k==i||k==j) continue;\n\t\t\t\tif(norm(p[k]-cnt1)<1.0) num++;\n\t\t\t}\n\t\t\tans=max(ans,num);\n\t\t\tP cnt2=p[i]+v+s*P(-v.imag(),v.real());\n\t\t\tint num2=2;\n\t\t\trep(k,n){\n\t\t\t\tif(k==i||k==j) continue;\n\t\t\t\tif(norm(p[k]-cnt2)<1.0) num2++;\n\t\t\t}\n\t\t\tans=max(ans,num2);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\n#include<complex>\n\nconst double PI=acos(-1);\nconst double EPS=1e-9; //うまくいかなかったらゆるめる\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define diff(P,i) (P[(i+1)%P.size()] - P[i])\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(){;}\n};\nstruct C {\n  P c;double r;\n  C(const P &c,double r):c(c),r(r){}\n};\n\nnamespace std{//演算子の定義\n  bool operator < (const P& a,const P& b) {\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b) {\n    return a.real()==b.real() && a.imag()==b.imag();\n  }\n}\n\n\nvoid printP(const P &p){\n  cout << shosu(10) << p.real() << \" \" << p.imag() << endl;\n}\n\nvoid printL(const L &l) {\n  \tcout << shosu(10) << l[0].real() << \" \" << l[0].imag() << \" \" << l[1].real() << \" \" << l[1].imag() << endl;\n}\n\nvoid printG(const G &g) {\n  for(int i = 0; i < g.size(); i++){\n    cout << shosu(10) << g[i].real() << \" \" << g[i].imag() << endl;\n  }\n}\n\n\n\ndouble dot(P a,P b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(P a,P b) {\n  return imag(conj(a)*b);\n}\n\nP orth(const P &a, const P &b) { //点aを(点bを基準として)90度回転した点\n  P p = a-b;\n  P q(-p.imag(), p.real());\n  return q + b;\n}\n\nint ccw(P a, P b, P c) { //3点の関係性\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\n\nP projection(const L &l, const P &p) { //pの直線l上の射影の点\n  double t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n  return l[0]+t*(l[0]-l[1]);\n}\n\nP reflection(const L &l, const P &p) { //点pの直線lに関して対称な点\n  return p+2.0*(projection(l,p)-p);\n}\n\nbool isorthogonal(const L &l, const L &m) { //2直線の直交判定\n  return fabs(dot(l[1]-l[0], m[1]-m[0])) < EPS;\n}\n\nbool isparallel(const L &l, const L &m) { //2直線の平行判定\n  return fabs(cross(l[1]-l[0],m[1]-m[0])) < EPS;\n}\n\nbool intersectLL(const L &l, const L &m) { //2直線の交差判定\n  return !isparallel(l,m);\n}\n\nbool intersectSS(const L &s, const L &t) { //2線分の交差判定(完全に交差してないとだめ)\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectSP(const L &s, const P &p) { //直線と点の交差判定\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // 三角不等式\n}\n\n\nP crosspointSS(const L &a, const L &b) { //2線分の交点\ndouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\ndouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\nreturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\n\nP crosspointLL(const L &l, const L &m) { //2直線の交点\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nL crosspointCL(C c,L l){ //円と直線の交点\n\tP pr = projection(l,c.c);\n\tP e = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tdouble tmp = c.r * c.r - norm(pr - c.c);\n\tif(abs(tmp) < EPS) tmp = 0;\n\tdouble t = sqrt(tmp);\n\tP a = pr + t * e;\n\tP b = pr - t * e;\n\tif(b < a) swap(a,b);\n\treturn L(a,b);\n}\n\nL crosspointCC(C a,C b){ //2円の交点\n\tP tmp = b.c - a.c;\n\tdouble d = abs(tmp);\n\tdouble q = acos((a.r * a.r + d * d - b.r * b.r)/(2 * a.r * d));\n\tdouble t = arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1 = a.c + polar(a.r, t + q);\n\tP p2 = a.c + polar(a.r, t - q);\n\tif(p2 < p1) swap(p1,p2);\n\treturn L(p1, p2);\n}\n\n\ndouble distancePP(const P &p, const P &q){ //2点間の距離\n  return hypot(p.real()-q.real(), p.imag()-q.imag());\n}\n\ndouble distanceSP(const L &s, const P &p) {//直線と点との距離\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {//2線分の距離\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n\n\n\nP turn(P p,double t){ // 回転\n    return p*exp(P(.0,t*PI/180.0));\n}\n\n\nvector<L> tangentCC(C a,C b){ //2円の接線\n\tif(a.r < b.r) swap(a,b);\n\tdouble d = abs(a.c - b.c);\n\tvector<L> l;\n\tif(d < EPS) return l;\n\tif(a.r + b.r < d - EPS){ //離れている\n\t\tdouble t = acos((a.r + b.r)/d);\n\t\tt = t * 180 / PI;\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), t), b.c + turn(b.r / d * (a.c-b.c), t)));\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), -t), b.c + turn(b.r / d * (a.c-b.c), -t)));\n\t}else if(a.r + b.r < d + EPS){ //外接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\tif(abs(a.r - b.r) < d - EPS){ //交わっている\n\t\tdouble t1 = acos((a.r - b.r) / d);\n\t\tt1 = t1 * 180 / PI;\n\t\tdouble t2 = 180 - t1;\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c-a.c), t1), b.c + turn(b.r / d * (a.c - b.c), -t2)));\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c - a.c), -t1),b.c + turn(b.r / d * (a.c - b.c), t2)));\n\t}else if(abs(a.r - b.r) < d + EPS){ //内接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\treturn l;\n}\n\nL tangentCP(const C &c, const P &p) { //円cの外部にある点pを通るcの接線の接点\n  double d = distancePP(c.c,p);\n  double r = sqrt(d*d - c.r * c.r);\n  C cc(p,r);\n  return crosspointCC(c,cc);\n}\n\n\ndouble area(const G &g) { //多角形の面積\n    double S =0;\n    for(int i = 0; i < g.size(); i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\n\nbool isconvex(const G &g) { //凸かどうか(全ての内角の大きさが180度以下)\n\tint n = g.size();\n  for(int i = 0; i < n; i++)\n    if(ccw(g[(i+n-1)%n], g[i%n], g[(i+1)%n])==-1) return false;\n\treturn true;\n}\n\nint inconvex(const G& g, const P& p) { //多角形と点の関係\n\tbool in = false;\n\tint n = g.size();\n\tfor(int i = 0; i < n; i++){\n\t\tP a = g[i%n] - p;\n\t\tP b = g[(i+1)%n] - p;\n\t\tif(imag(a) > imag(b)) swap(a, b);\n\t\tif(imag(a) < EPS && 0 < imag(b))if(cross(a,b) < 0)in = !in;\n\t\tif(abs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;//ON\n\t}\n\treturn in ? 2 : 0;//IN : OUT;\n}\n\nG convex_hull(G &ps) { // 凸包(点集合 P の全ての点を含む最小の凸多角形)\n  int n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i = 0; i < n; ch[k++] = ps[i++])//lower-hull\n\t\twhile(k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//<=0  ->  ==-1\n\tfor(int i = n-2,t = k+1; i >= 0; ch[k++] = ps[i--])//upper-hull\n\t\twhile(k >= t && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//\n\tch.resize(k-1);\n\treturn ch;\n}\n\ndouble convex_diameter(const G &pt) { //凸多角形の直径(最遠頂点対間距離)\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is] - pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i] - pt[j]) > maxd) {\n      maxd = norm(pt[i] - pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\n\n\nG convex_cut(const G& g, const L& l) { //凸多角形の切断\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = g[i], b = g[(i+1)%g.size()];\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\n\n\nL PerpendicularBisector(const L &l) { //線分の垂直二等分線\n  P p = l[0];\n  P q((l[0].real() + l[1].real())/2.0, (l[0].imag() + l[1].imag())/2.0);\n  L t(q, orth(p,q));\n  return t;\n}\n\nP CircumscribedCircle(const G &g) { //三角形の外接円の半径\n  L l1(g[0],g[1]);\n  L l2(g[1],g[2]);\n  L m1 = PerpendicularBisector(l1);\n  L m2 = PerpendicularBisector(l2);\n  return crosspointLL(m1, m2);\n}\n\n\nP inP(){\n  double x,y;\n//  scanf(\"%lf,%lf\", &x, &y);\n  cin >> x >> y;\n  P p(x,y);\n  return p;\n}\n\n\nL inL(){\n  P p1 = inP();\n  P p2 = inP();\n  L l(p1,p2);\n  return l;\n}\n\nC inC(){\n  P p = inP();\n  double r;\n  cin >> r;\n  C c(p,r);\n  return c;\n}\n\n\nG inG(int n){\n  G g(n);\n  for(int i = 0; i < n; i++){\n    g[i] = inP();\n  }\n  return g;\n}\n\n\nint main(void) {\n    int n;\n    while(cin >> n, n){\n        G g = inG(n);\n        int ans = 1;\n        rep(i,n)loop(j,i+1,n){\n            P t1 = g[i]-g[j];\n            if(abs(t1) + EPS >= 2.0)continue;\n            t1 *= 0.5;\n            P t2 = t1 * P(0,1);\n            t2 /= abs(t2);\n            t2 *= sqrt(1 - abs(t1)*abs(t1));\n            P p = g[j] + t1 + t2;\n            P q = g[j] + t1 - t2;\n            int cnt1 = 0, cnt2 = 0;\n            rep(k,n) if(distancePP(p,g[k]) <= 1.0 + EPS) cnt1++;\n            rep(k,n) if(distancePP(q,g[k]) <= 1.0 + EPS) cnt2++;\n            ans = max(ans, max(cnt1,cnt2));\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nusing Float = double;\nusing Point = complex<Float>;\n\nvector<Point> ps;\n\nconst Float radius = 1.0;\nconst Float EPS = 1e-8;\n\nint calc(Point c){\n\tint ret = 0;\n\tfor(const Point &p : ps){\n\t\tif(abs(p - c) <= radius + EPS) ret++;\n\t}\n\treturn ret;\n}\n\nsigned main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tps.clear();\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tFloat x,y;\n\t\t\tcin >> x >> y;\n\t\t\tps.emplace_back(x,y);\n\t\t}\n\t\tint ans = 1;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = i + 1;j < n;j++){\n\t\t\t\tif(abs(ps[i] - ps[j]) >= radius * 2) continue;\n\t\t\t\tPoint mid = (ps[i] + ps[j]) / 2.0;\n\t\t\t\tPoint vect = Point(imag(ps[i] - ps[j]),-real(ps[i] - ps[j]));\n\t\t\t\tFloat dist = sqrt(1.0 - norm(mid - ps[i]));\n\t\t\t\tans = max(ans,max(calc(mid + vect / abs(vect) * dist),calc(mid - vect / abs(vect) * dist)));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-6;\nusing P = complex<double>;\nint n;\nP p[300];\n\nint main(){\n  while (cin >> n, n){\n    for (int i = 0; i < n; i++){\n      double x, y;\n      cin >> x >> y;\n      p[i] = P(x, y);\n    }\n    vector<P> ps;\n    for (int i = 0; i < n; i++){\n      for (int j = 0; j < i; j++){\n        if (abs(p[i] - p[j]) >= 2.0) continue;\n        P v = p[j] - p[i];\n        P u = v * P(0.0, 1.0);\n        u *= sqrt(1.0 - abs(v) / 2.0) / abs(u);\n        ps.push_back(p[i] + v / 2.0 + u);\n        ps.push_back(p[i] + v / 2.0 - u);\n      }\n    }\n    int res = 1;\n    for (P c : ps){\n      int s = 0;\n      for (int i = 0; i < n; i++){\n        s += abs(c - p[i]) <= 1.0 + EPS;\n      }\n      res = max(res, s);\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define EPS 1e-8\nusing namespace std;\ntypedef complex<double> P;\nint main(){\n\tint n; double x,y;\n\twhile(cin>>n,n){\n\t\tP p[n]; rep(i,n)cin>>x>>y,p[i]=P(x,y);\n\t\tint mx=1,m1,m2;\n\t\trep(i,n)rep(j,i)if(norm(p[i]-p[j])<4+EPS){\n\t\t\tP M=(p[i]+p[j])/P(2,0),C1,C2; double l=sqrt(1-norm(M-p[i]));\n\t\t\tC1=M+polar(l,arg(p[j]-p[i])+M_PI/2);\n\t\t\tC2=M+polar(l,arg(p[j]-p[i])-M_PI/2);\n\t\t\tm1=m2=0;\n\t\t\trep(k,n){\n\t\t\t\tif(norm(p[k]-C1)<1+EPS)m1++; if(norm(p[k]-C2)<1+EPS)m2++;\n\t\t\t}\n\t\t\tif(m1>mx)mx=m1; if(m2>mx)mx=m2;\n\t\t}\n\t\tcout<<mx<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<math.h>\n\nusing namespace std;\ntypedef pair<double, double> P;\n\nint N;\ndouble X[300], Y[300];\nP d[300];\n\nP add(P p1, P p2) {\n  return P(p1.first + p2.first, p1.second + p2.second);\n}\n\nP minas(P p1, P p2) {\n  return P(p1.first - p2.first, p1.second - p2.second);\n}\n\nP mul(P p, double c) {\n  return P(p.first * c, p.second * c);\n}\n\nP ave(P p1, P p2) {\n  return P((p1.first + p2.first) / 2, (p1.second + p2.second) / 2);\n}\n\nvoid printP(P p) {\n  printf(\"P:(%f, %f)\\n\", p.first, p.second);\n}\n\ndouble square(P p) {\n  return p.first * p.first + p.second * p.second;\n}\n\ndouble size(P p) {\n  return sqrt(square(p));\n}\n\nint count(P p) {\n  // printP(p);\n  int counter = 0;\n  for (int i = 0; i < N; i++) {\n    if (square(minas(p, d[i])) <= 1.0001) counter++;\n  }\n  // printf(\"%d\\n\",counter);\n  return counter;\n}\n\nint check(int i, int j) {\n  if (square(minas(d[i], d[j])) > 4.0) return 0;\n  int ans = 0;\n  P average = ave(d[i], d[j]);\n  P dir = mul(minas(d[i], d[j]), 0.5);\n  // printP(average);\n  double s = sqrt(1.0 - square(dir));\n  // printf(\"!!!!!!%f\\n\",s);\n  P dir1 = P((Y[i] - Y[j]), - (X[i] - X[j]));\n  //printf(\"!!!!!!%f\\n\",size(dir1));\n  double r = s / size(dir1);\n  P d1 = add(average, mul(dir1, r));\n  P d2 = add(average, mul(dir1, -r));\n  return max(count(d1), count(d2));\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &N);\n    if (N == 0) break;\n    for (int i = 0; i < N; i++) scanf(\"%lf%lf\", &X[i], &Y[i]), d[i] = P(X[i], Y[i]);\n    int ans = 1;\n    for (int i = 0; i < N; i++)\n      for (int j = 0; j < i; j++)\n        ans = max(ans, check(i, j));\n    printf(\"%d\\n\", ans);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\n\nconst long double EPS = 10e-6;\n\nclass Point{\n    public: \n    long double x,y;\n    \n    Point(long double x = 0.0, long double y = 0.0): x(x), y(y) {}\n    \n    Point operator + (Point p) const {\n        return Point(x+p.x, y+p.y);\n    }\n    Point operator - (Point p) const {\n        return Point(x-p.x, y-p.y);\n    }\n    Point operator * (long double a) const {\n        return Point(x*a, y*a);\n    }\n    Point operator / (long double a) const {\n        return Point(x/a, y/a);\n    }\n\n    long double norm() {\n        return x*x + y*y;\n    }\n    \n    long double dot(Point p) {\n        return x*p.x + y*p.y;\n    }\n};\n\nPoint calc_center(Point p, Point mid, Point midv){\n    long double norm = mid.norm();\n    midv = midv * sqrt((1.0 - norm) / norm);\n    return p+mid+midv;\n}\n\nint count(vector<Point> points, Point center){\n    int tmp = 0;\n    for(Point p: points){\n        if((p-center).norm() <= 1.0 + EPS) tmp++;\n    }\n    return tmp;\n}\n\nint main() {\n    int n;\n    while(scanf(\"%d\", &n) && n){\n        vector<Point> points(n);\n        rep(n) scanf(\"%Lf %Lf\", &points[i].x, &points[i].y);\n\n        int ans = 1;\n        rep(n){\n            repp(j, n){\n                if(j == i) continue;\n                Point mid = (points[j] - points[i]) * 0.5;\n                Point center = calc_center(points[i], mid, Point(mid.y, -mid.x));\n                ans = max(count(points, center), ans);\n\n                center = calc_center(points[i], mid, Point(-mid.y, mid.x));\n                ans = max(count(points, center), ans);\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\n// y???real(), x???imag()\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool cmp_y(const P &a, const P &b){\n\t\treturn a.imag() != b.imag() ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n// circle\nstruct C {\n\tP p; double r;\n\tC(const P& p, double r) : p(p), r(r) {}\n};\n\n// 2???p1, p2?????????????????????r?????????2?????????\nvector<C> calcCircle(P p1, P p2, double r) {\n\tif(abs(p1-p2) > 2*r) return {};\n\tP p3 = {(p1.real()+p2.real())/2, (p1.imag()+p2.imag())/2};\n\t// cout << p3.real() << \" \" << p3.imag() << endl;\n\tdouble l = abs(p1-p3);\n\t// cout << \"l:\" << l << endl;\n\t// ????????????p_1p_2\n\tP p1p2 = p2-p1;\n\tdouble a = p1p2.real(), b = p1p2.imag();\n\tdouble dx = b*sqrt((r*r-l*l)/(a*a+b*b)), dy = a*sqrt((r*r-l*l)/(a*a+b*b));\n\t// cout << \"dx:\" << dx << \" dy:\" << dy << endl;\n\treturn {{{p3.real()+dx, p3.imag()-dy}, r}, {{p3.real()-dx, p3.imag()+dy}, r}};\n}\n\n// ???p??????c????????¨????????¨??????????????????\nbool intersectCP(C c, P p) { return abs(p-c.p) <= c.r + EPS; }\n\nP po[105];\nsigned main(void)\n{\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n    REP(i, n) {\n      double x, y;\n      cin >> x >> y;\n      po[i] = {x, y};\n    }\n\n    int ans = 0;\n    REP(i, n) FOR(j, i+1, n) {\n      vector<C> ret = calcCircle(po[i], po[j], 1);\n      if(ret.size() == 0) continue;\n      // cout << \"i:\" << i << \" j:\" << j << endl;\n      // cout << ret[0].p.real() << \" \" << ret[0].p.imag() << \" \" << ret[0].r << endl;\n      // cout << ret[1].p.real() << \" \" << ret[1].p.imag() << \" \" << ret[1].r << endl;\n      int num = 0;\n      REP(k, n) {\n        num += intersectCP(ret[0], po[k])?1:0;\n        // if(intersectCP(ret[0], po[k])) cout << k << \" \";\n      }\n      chmax(ans, num);\n      // cout << \"num:\" << num << endl;\n      num = 0;\n      REP(k, n) {\n        num += intersectCP(ret[1], po[k])?1:0;\n        // if(intersectCP(ret[1], po[k])) cout << k << \" \";\n      }\n      // cout << \"num:\" << num << endl;\n      chmax(ans, num);\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n\n#define rep2(i, b, n) for(int i=b; i < n; ++i)\n#define rep(i, n) rep2(i, 0, n)\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<double, double> pdd;\n\ndouble distance_sq( pdd a, pdd b )\n{\n\tdouble cx = a.X - b.X;\n\tdouble cy = a.Y - b.Y;\n\treturn ((cx*cx) + (cy*cy));\n}\n\ndouble norm( pdd &v )\n{\n\tdouble len = sqrt((v.X*v.X) + (v.Y*v.Y));\n\tv.X /= len;\n\tv.Y /= len;\n\treturn len;\n}\n\nvoid rotate( pdd &p )\n{\n\tswap(p.X, p.Y);\n\tp.Y *= -1.0;\n}\n\nint main( void )\n{\n\tint n;\n\tpdd p[300];\n\twhile(cin >> n, n)\n\t{\n\t\trep(i, n) cin >> p[i].X >> p[i].Y;\n\t\tint Max = 0;\n\t\trep(i, n) {\n\t\t\trep2(j, i+1, n) {\n\t\t\t\tif(distance_sq(p[i], p[j]) <= 4.0) {\n\t\t\t\t\tpdd v = make_pair(p[i].X-p[j].X, p[i].Y-p[j].Y);\n\t\t\t\t\tpdd c = make_pair(v.X / 2.0, v.Y / 2.0);\n\t\t\t\t\tpdd m = c;\n\t\t\t\t\tdouble len_c = norm(c);\n\t\t\t\t\tdouble sin_x = sqrt(1.0 - (len_c * len_c));\n\t\t\t\t\trotate(c);\n\t\t\t\t\tc.X *= sin_x; c.Y *= sin_x;\n\t\t\t\t\tpdd p3 = make_pair(p[j].X+m.X+c.X, p[j].Y+m.Y+c.Y);\n\t\t\t\t\tpdd p4 = make_pair(p[j].X+m.X-c.X, p[j].Y+m.Y-c.Y);\n\t\t\t\t\tint count_p3, count_p4;\n\t\t\t\t\tcount_p3 = count_p4 = 0;\n\t\t\t\t\trep(k, n) {\n\t\t\t\t\t\tif(distance_sq(p3, p[k]) <= 1.0) ++count_p3;\n\t\t\t\t\t\tif(distance_sq(p4, p[k]) <= 1.0) ++count_p4;\n\t\t\t\t\t}\n\t\t\t\t\tMax = max(Max, max(count_p3, count_p4));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << Max << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-9\nusing namespace std;\ntypedef complex<double> point;\n\npair<point, point> norm(point p){\n  double unit = 1 / sqrt(p.real()*p.real() + p.imag()*p.imag());\n  return pair<point, point>(p*point(0, 1)/unit,\n                            p*point(0, -1)/unit);\n}\n\nvector<point> calcC(point a, point b){\n  point p = (b - a)/2.0;\n  pair<point, point> n = norm(p);\n  double unit = sqrt(1 - abs(p)*abs(p));\n  n.first  *= unit;\n  n.second *= unit;\n  vector<point> res(2);\n  res[0] = a + p + n.first;\n  res[1] = a + p + n.second;\n  return res;\n}\nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n, n){;\n    point p[n];\n    for (int i = 0; i < n; i++) {\n      double real, imag;\n      cin >> real >> imag;\n      p[i] = complex<double>(real, imag);\n    }\n    int ans = 0, cnt = 0;\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        point a = p[i], b = p[j];\n        if(abs(b - a) > 2 - eps)continue;\n        vector<point> center = calcC(a, b);\n        for (int c = 0; c < 2; c++) {\n          cnt = 0;\n          // std::cout << center[c].real() << \" \" <<\n          //   center[c].imag()<< std::endl;\n          for (int k = 0; k < n; k++) {\n            if(abs(center[c] - p[k]) <= 1 + eps)cnt++;\n          }\n          ans = max(ans, cnt);\n        }\n      }\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\n// 点\nclass Point {\n  public:\n    float x, y;\n    Point(double ix = 0.0, double iy = 0.0) {\n      set(ix, iy);\n    }\n    void set(double ix = 0.0, double iy = 0.0) {\n      x = ix;\n      y = iy;\n    }\n    void copy(Point p) {\n      x = p.x;\n      y = p.y;\n    }\n    double length() {\n      return sqrt(x * x + y * y);\n    }\n    double distanceTo(Point p) {\n      double dx = p.x - x, dy = p.y - y;\n      return sqrt(dx * dx + dy * dy);\n    }\n    void setCentroidOf(Point p1, Point p2) {\n      x = (p1.x + p2.x) / 2;\n      y = (p1.y + p2.y) / 2;\n    }\n};\n\nint main() {\n  vector<int> results;\n  while (true) {\n    // 入力\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    vector<Point> p(n);\n    for (int i=0; i<n; i++) {\n      double x, y;\n      cin >> x >> y;\n      p[i].set(x, y);\n    }\n    \n    const int nC2 = n * (n - 1) / 2 + n;\n    vector<Point> px(n); // 現時点で有力な点\n    for (int i=0; i<n; i++) px[i].copy(p[i]);\n    vector<Point> cp(nC2); // 中点たち\n    int previousMaxScore = 0; // 前回のループでの最高スコア\n    int maxScoreConst = 0; // 同じ最高スコアが連続して記録された回数\n    while (true) {\n      // 与えられた点の中点たち（+もとの点）を候補点とする\n      int cpi = 0;\n      for (int i=0; i<n-1; i++) {\n\tfor (int j=i+1; j<n; j++) {\n\t  cp[cpi++].setCentroidOf(px[i], px[j]);\n\t}\n      }\n      for (int i=0; i<n; i++) cp[cpi++].copy(px[i]);\n      // 各点のスコアを算出\n      vector<int> scores(nC2);\n      for (int i=0; i<nC2; i++) {\n\tscores[i] = 0;\n\tfor (int j=0; j<n; j++) {\n\t  if (cp[i].distanceTo(p[j]) <= 1) scores[i]++;\n\t}\n      }\n      // cpをスコア降順にバブルソート\n      for (int i=0; i<nC2; i++) {\n\tfor (int j=0; j<nC2-1; j++) {\n\t  if (scores[j] < scores[j + 1]) {\n\t    double jx = cp[j].x, jy = cp[j].y;\n\t    cp[j].copy(cp[j + 1]);\n\t    cp[j + 1].set(jx, jy);\n\t    int js = scores[j];\n\t    scores[j] = scores[j + 1];\n\t    scores[j + 1] = js;\n\t  }\n\t}\n      }\n      // このループの最大スコア\n      int maxScore = scores[0];\n      //cout << maxScore << \" -> \";\n      if (maxScore == previousMaxScore) {\n\t// 最大スコアが3回連続で更新されなかったら確定\n\tpreviousMaxScore = maxScore;\n\tif (++maxScoreConst >= 3) break;\n      } else {\n\tpreviousMaxScore = maxScore;\n\tmaxScoreConst = 0;\n      }\n      // スコアが上位nの点を次のループの中点の素として採用\n      for (int i=0; i<n; i++) px[i].copy(cp[i]);\n    }\n    \n    results.push_back(previousMaxScore);\n    //cout << endl;\n  }\n  \n  int size = results.size();\n  for (int i=0; i<size; i++) {\n    cout << results[i] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double eps = 1e-6;\n\ndouble  caclDistance2(double x1, double y1, double x2, double y2){\n    double ans;\n    ans = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n\n    return ans;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n\n        vector<pair<double, double> > point(n);\n\n        int ans = 1;\n\n        for(int i=0; i<n; i++){\n            cin >> point[i].first >> point[i].second;\n        }\n\n        for(int i=0; i<n; i++){\n            for(int j=i+1; j < n; j++){\n\n                int point_num = 0;\n\n                double distance_of_two_points = sqrt(caclDistance2(point[i].first, point[i].second, point[j].first, point[j].second));\n                //cout << \"distance = \"<< distance_of_two_points << endl;\n                if(distance_of_two_points > 2.0 + eps) continue;\n\n                pair<double, double> midpoint;\n                midpoint.first = (point[i].first + point[j].first) / 2;\n                midpoint.second = (point[i].second + point[j].second) / 2;\n\n                pair<double, double> vector;                \n                pair<double, double> centor;\n                \n                vector.first = (-1) * (point[i].second - point[j].second);\n                vector.second = (point[i].first - point[j].first);\n\n                //cout << vector.first << \" \" << vector.second << endl;\n\n                double vector_size = sqrt(vector.first * vector.first + vector.second * vector.second);\n\n                double distance_from_centor = sqrt(1.0 - (distance_of_two_points / 2.0) * (distance_of_two_points / 2.0));\n\n                centor.first = midpoint.first + (distance_from_centor/vector_size) * vector.first;\n                centor.second = midpoint.second + (distance_from_centor/vector_size) * vector.second;\n\n                //cout << centor.first << \" \" << centor.second << endl;\n\n                for(int k = 0; k<n; k++){\n                    if(caclDistance2(centor.first, centor.second, point[k].first, point[k].second) <= 1.00005){\n                        point_num++;\n                    }\n                }\n\n                ans = max(ans, point_num);\n\n                point_num = 0;\n\n                vector.first = (point[i].second - point[j].second);\n                vector.second = (-1) * (point[i].first - point[j].first);\n\n                centor.first = midpoint.first + (distance_from_centor/vector_size) * vector.first;\n                centor.second = midpoint.second + (distance_from_centor/vector_size) * vector.second;\n\n                //cout << centor.first << \" \" << centor.second << endl;\n\n                for(int k = 0; k<n; k++){\n                    if(caclDistance2(centor.first, centor.second, point[k].first, point[k].second) <= 1.00005){\n                        point_num++;\n                    }\n                }\n\n                ans = max(ans, point_num);                \n            }\n        }\n\n        cout << ans << endl;\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<complex>\n#include<vector>\n#include<map>\n\nusing namespace std;\n/*                         */\n/*                         */\n/* @@ Geometory Library @@ */\n/*               by ei1333 */\n/*                         */\nconst double EPS = 1e-8, PI = acos(-1);\n \ninline bool eq(double a,double b){ return abs(b - a) < EPS; }\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nstruct Geometory { // Geometory Library\n  struct Point {\n    double x, y;\n    Point(){};\n    Point(double x,double y):x(x),y(y){};\n    Point operator+(const Point& b) const { return Point(x + b.x,y + b.y); }\n    Point operator-(const Point& b) const { return Point(x - b.x,y - b.y); }\n    Point operator*(const double b) const { return Point(x * b,y * b); }\n    Point operator*(const Point& b) const { return Point(x * b.x - y * b.y,x * b.y + y * b.x); }\n    Point operator/(const double b) const { return Point(x / b,y / b); }\n    bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y;}\n    bool operator==(const Point& b) const { return eq(x,b.x) && eq(y,b.y); }\n    double norm(){ return x * x + y * y; }\n    double arg(){ return atan2(x,y); }\n    double abs(){ return sqrt(norm()); }\n    Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y,sin(theta) * x + cos(theta) * y); }\n    Point rotate90(){ return Point(-y,x); }\n    friend ostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\n    friend istream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\n  };\n    \n  struct Line {\n    Point a, b;\n    Line(){};\n    Line(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Line& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Line& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Segment {\n    Point a, b;\n    Segment(){};\n    Segment(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Segment& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Segment& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Circle {\n    Point p; double r;\n    Circle(){};\n    Circle(Point p, double r) : p(p),r(r){};\n  };\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n    \n  double cross(const Point& a,const Point& b){\n    return a.x * b.y - a.y * b.x;\n  }\n  double dot(const Point& a,const Point& b){\n    return a.x * b.x + a.y * b.y;\n  }\n    \n  int ccw(const Point& a,Point b,Point c){\n    b = b - a, c = c - a;\n    if(cross(b,c) > EPS)    return +1;  // a → b で 反時計方向におれて c\n    if(cross(b,c) < -EPS)    return -1; // a → b で 時計方向におれて c\n    if(dot(b,c) < 0)      return +2;  // c -- a -- bで一直線上\n    if(b.norm() < c.norm()) return -2; // a -- b -- cで一直線上\n    return 0;  // a -- c -- bで一直線上\n  }\n  Point Projection(const Line& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Projection(const Segment& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Reflection(const Line& l, const Point& p){\n    return p + (Projection( l, p) - p) * 2.0;\n  }\n    \n  double Distance( const Line& l,const Point& p) { //OK\n    return (p - Projection( l, p)).abs();\n  }\n    \n  bool Intersect(const Line& l, const Line& m){\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b-l.a, m.b-l.a)) < EPS;\n  }\n  bool Intersect(const Line& l, const Segment& s){\n    return cross( l.b - l.a, s.a - l.a) * cross( l.b - l.a, s.b - l.a) < EPS;\n  }\n  bool Intersect(const Line& l, const Point& p){\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n  bool Intersect(const Segment& s, const Segment& t){\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n  bool Intersect(const Segment& s, const Point& p){\n    return ccw(s.a, s.b, p) == 0;\n  }\n  bool Intersect(const Circle& c,const Line& l){\n    return Distance( l, c.p) <= c.r + EPS;\n  }\n  bool Intersect(const Circle& c,const Point& p){\n    return abs( ( p - c.p).abs() - c.r ) < EPS;\n  }\n  int Intersect(const Circle& c, const Segment& l){\n    if( (Projection( l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = ( c.p - l.a).abs(), d2 = ( c.p - l.b).abs();\n    if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if( d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n    const Point h = Projection( l, c.p);\n    if( dot( l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n  bool Intersect(const Circle& a,const Circle& b){\n    return ( ( a.p - b.p).norm() - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n      ( ( a.p - b.p).norm() - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n  }\n  double Distance(const Segment& s,const Point& p){\n    Point r = Projection(s, p);\n    if ( Intersect( s, r)) return ( r - p).abs();\n    return min( ( s.a - p).abs(), ( s.b - p).abs());\n  }\n  double Distance(const Segment& a,const Segment& b){\n    if(Intersect( a, b)) return 0;\n    return min( min( Distance( a, b.a), Distance( a, b.b)), min( Distance( b, a.a), Distance( b, a.b)));\n  }\n  double Distance(const Line& l,const Line& m) {\n    return Intersect( l, m) ? 0 : Distance( l, m.a);\n  }\n  double Distance(const Line& l,const Segment& s) { //OK\n    if (Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n  double Distance(const Point& a,const Point& b){ //OK\n    return ( a - b).abs();\n  }\n  Point Crosspoint(const Segment& l,const Segment& m) { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if (abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n  PointPoint Crosspoint(const Circle& c,const Line l){\n    Point hp = Projection( l, c.p), h =  hp - c.p;\n    const double d2 = h.norm();\n    Point v = ( l.b - l.a) * sqrt( c.r * c.r - d2) / ( l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n  PointPoint Crosspoint(const Circle& c,const Segment& l) {\n    Line aa = Line( l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n  PointPoint Crosspoint(const Circle& c1,const Circle& c2){ //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n    double h = 2 * S / d;\n    Point v = ( c2.p - c1.p) / ( c2.p - c1.p).abs();\n    double m = sqrt( c1.r * c1.r - h * h);\n    return PointPoint( c1.p + v * m + Point(0,1) * h * v, c1.p + v * m - Point(0,1) * h * v);\n  }\n  bool parallel(const Line& a,const Line& b){\n    return abs(cross( a.b - a.a, b.b - b.a)) < EPS;\n  }\n  bool orthogonal(const Line& a,const Line& b){\n    return abs(dot( a.a - a.b, b.a - b.b)) < EPS;\n  }\n  int Contains(const Polygon& Q,const Point& p){\n    bool in = false;\n    for(int i = 0 ; i < Q.size() ; i++ ){\n      Point a = curr(Q,i) - p, b = next(Q,i) - p;\n      if(a.y > b.y) swap(a,b);\n      if(a.y <= 0 && 0 < b.y && cross(a,b) < 0) in = !in;\n      if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n  bool Contains(const Circle& c,const Point& p){\n    return ( c.p - p).abs() < c.r + EPS;\n  }\n  double Area2(const Polygon& p){ //OK\n    double A = 0;\n    for (int i = 0; i < p.size(); ++i){\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n  bool IsConvex(const Polygon& p){\n    for(int i = 0; i < p.size(); i++){\n      if(ccw(prev(p,i),curr(p,i),next(p,i)) == -1) return false;\n    }\n    return true;\n  }\n  Polygon Convex_Hull(Polygon& p){\n    int n = p.size(), k = 0;\n    if(n >= 3){\n      sort( p.begin(), p.end());\n      vector< Point > ch(2 * n);\n      for(int i = 0; i < n; ch[k++] = p[i++]){\n        while(k >= 2 && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]){\n        while(k >= t && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      ch.resize( k - 1);\n      return ch;\n    } else {\n      return p;\n    }\n  }\n  double Convex_Diameter(Polygon& p){\n    int n = p.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++){\n      if(p[i].y > p[is].y) is = i;\n      if(p[i].y < p[js].y) js = i;\n    }\n    double maxdis = ( p[is] - p[js]).norm();\n  \n    int maxi, maxj, i, j;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n      if(cross( next( p, i) - curr( p, i), next( p, j) - curr( p, j)) >= 0){\n        j = (j + 1) % n;\n      } else {\n        i = (i + 1) % n;\n      }\n      if(( p[i] - p[j]).norm() > maxdis){\n        maxdis = ( p[i] - p[j]).norm();\n        maxi = i; maxj = j;\n      }\n    }  while (i != is || j != js);\n    return maxdis;\n  }\n};\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector< T >& p){\n  for(int i = 0; i < p.size(); i++) is >> p[i]; return is;\n}\ntemplate<typename T1, typename T2>\nistream& operator>>(istream& is, pair< T1, T2 >& p){\n  is >> p.first >> p.second; return is;\n}\n\n\nGeometory geo;\ntypedef Geometory::Point P;\ntypedef Geometory::Line L;\ntypedef Geometory::Segment S;\ntypedef Geometory::Circle C;\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    vector< P > vc(N);\n    cin >> vc;\n\n    int ret = 0;\n    for(int i = 0; i < vc.size(); i++){\n      for(int j = vc.size() - 1; j > i; j--){\n        \n        C c1 = C( vc[i], 1), c2 = C( vc[j], 1);\n        if(!geo.Intersect( c1, c2)) continue;\n        Geometory::PointPoint pp = geo.Crosspoint( c1, c2);\n\n        int res1 = 0, res2 = 0;\n        for(int k = 0; k < vc.size(); k++){\n          C c3 = C(pp.first, 1), c4 = C(pp.second, 1);\n          res1 += !!geo.Contains( c3, vc[k]);\n          res2 += !!geo.Contains( c4, vc[k]);\n        }\n        ret = max( ret, max( res1, res2)); \n      }\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n\nusing namespace std;\n\nint n;\n\ndouble xi[300];\ndouble yi[300];\n\ndouble distant2(double x1,double y1,double x2,double y2)\n{\n\treturn (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n}\n\nint search(int i,int j)\n{\n\tdouble mx = (xi[i] + xi[j]) / 2,my = (yi[i] + yi[j]) / 2;\n\tdouble diff2 = distant2(mx,my,xi[i],yi[i]);\n\n\tif(diff2 > 1.0)\n\t\treturn 1; //1ツ古つつセツつッ\n\n\tdouble len = sqrt(1 - diff2);\n\tdouble diff = sqrt(diff2);\n\tdouble dx = len * (xi[i] - mx) / diff,dy = len * (yi[i] - my) / diff;\n\n\tint sign[] = {1,-1};\n\tint counter[2] = {0};\n\tfor(int s = 0; s < 2; s++)\n\t{\n\t\tdouble x = mx + sign[s] * dx,y = my + sign[s] * dy;\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tif(k == i || k == j){counter[s]++; continue;}\n\t\t\tif(distant2(x,y,xi[k],yi[k]) < 1.0)\n\t\t\t\tcounter[s]++;\n\t\t}\n\t}\n\n\treturn max(counter[0],counter[1]);\n}\n\n\n\nint solve()\n{\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> xi[i] >> yi[i];\n\t}\n\n\tint count = 0;\n\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = i+1; j < n; j++){\n\t\t\tcount = max(count,search(i,j));\n\t\t}\n\t}\n\n\treturn count;\n}\n\nint main() {\n  while (cin >>n,n) {\n    cout << solve() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-9\nusing namespace std;\ntypedef complex<double> point;\n\npair<point, point> norm(point p){\n  double unit = 1 / sqrt(p.real()*p.real() + p.imag()*p.imag());\n  return pair<point, point>(p*point(0, 1)/unit,\n                            p*point(0, -1)/unit);\n}\n\nvector<point> calcC(point a, point b){\n  point p = (b - a)/2.0;\n  pair<point, point> n = norm(p);\n  double unit = sqrt(1 - abs(p)*abs(p));\n  n.first  =  n.first*unit;\n  n.second = n.second*unit;\n  vector<point> res(2);\n  res[0] = a + p + n.first;\n  res[1] = a + p + n.second;\n  return res;\n}\nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n, n){;\n    point p[n];\n    for (int i = 0; i < n; i++) {\n      double real, imag;\n      cin >> real >> imag;\n      p[i] = complex<double>(real, imag);\n    }\n    int ans = 1, cnt = 0;\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        point a = p[i], b = p[j];\n        if(abs(b - a) > 2 - eps)continue;\n        vector<point> center = calcC(a, b);\n        for (int c = 0; c < 2; c++) {\n          cnt = 0;\n          // std::cout << center[c].real() << \" \" <<\n          //   center[c].imag()<< std::endl;\n          for (int k = 0; k < n; k++) {\n            if(abs(center[c] - p[k]) <= 1 + eps)cnt++;\n          }\n          ans = max(ans, cnt);\n        }\n      }\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\nbool equals(double x, double y) {\n\treturn fabs(x-y) < EPS;\n}\n\n#define x first\n#define y second\ntypedef pair<double, double> pt;\n\n\npt operator-(pt u, pt v) { return pt(u.x - v.x, u.y - v.y); }\npt operator+(pt u, pt v) { return pt(u.x + v.x, u.y + v.y); }\npt operator*(pt u, double d) { return pt(u.x * d, u.y * d); }\n\n// dot product\ndouble operator*(pt u, pt v) { return u.x * v.x + u.y * v.y; }\n// norm\ndouble operator!(pt p) { return sqrt(p * p); }\n// \"cross product\"\ndouble operator^(pt u, pt v) { return u.x * v.y - u.y * v.x; }\n\ndouble operator==(pt a, pt b) { return equals(a.x, b.x) && equals(a.y, b.y);}\n\n// angle with positive x axis\ndouble operator~(pt v)\n{\n\treturn atan2(v.y, v.x);\n}\n\nint pointsInCircle(pt p, vector<pt>& points)\n{\n\tvector<pair<double, bool>> angles;\n\t\n\tfor(auto point : points)\n\t{\n\t\tpt x = point - p;\n\t\tdouble dSquared = x * x;\n\t\tif(p == point || dSquared > 4) continue;\n\t\tdouble a = acos(sqrt(dSquared) / 2.0); \n\t\tdouble b = ~x;\n\t\tangles.emplace_back(b - a, true);\n\t\tangles.emplace_back(a + b, false);\n\t}\n\t\n\tint count = 1;\n\tint result = 1;\n\tsort(angles.begin(), angles.end());\n\tfor(auto a : angles)\n\t{\n\t\tif(a.second) \n\t\t{\n\t\t\tcount++;\n\t\t\tresult = max(result, count);\n\t\t}\n\t\telse count--;\n\t}\n\treturn result;\n}\n\nint solve(vector<pt>& points)\n{\n\tint sln = 0;\n\tfor(auto p : points)\n\t\tsln = max(sln, pointsInCircle(p, points));\n\treturn sln;\n}\n\nint main(void) {\n\t\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\n\twhile(N)\n\t{\n\t\tvector<pt> points;\n\t\tfor(int i  = 0; i < N; ++i)\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoints.emplace_back(x, y);\n\t\t}\n\t\tcout << solve(points) << '\\n';\n\t\tcin >> N;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-5;\n\nstruct Circle{\n  P c;\n  double r;\n  Circle(P c=P(0,0),double r=0):c(c),r(r){}\n};\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1=c1.r,r2=c2.r,d;\n  P p1=c1.c,p2=c2.c;\n  d=abs(p1-p2);\n  if(d<EPS&&abs(r1-r2)<EPS) return res;\n  if(r1+r2<d-EPS||d+EPS<abs(r1-r2)) return res; \n  double a=(r1*r1-r2*r2+d*d)/(2*d);\n  double h=sqrt(max(r1*r1-a*a,0.0));\n  P tmp1=p1+a/d*(p2-p1);\n  P tmp2=h/d*(p2-p1);\n  if(abs(tmp2)<EPS)res.push_back(tmp1);\n  else{\n    res.push_back(P(real(tmp1)-imag(tmp2),imag(tmp1)+real(tmp2)));\n    res.push_back(P(real(tmp1)+imag(tmp2),imag(tmp1)-real(tmp2)));\n  }\n  return res;\n}\n\ndouble getdistancepp(P a,P b){\n  return sqrt((a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag()));\n}\n\nint main(){\n  int n,ans;\n  double a,b;\n  P p[N];\n  while(1){\n    ans=0;\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>a>>b;\n      p[i]=P(a,b);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tCircle c1,c2;\n\tc1.c=p[i];\n\tc2.c=p[j];\n\tc1.r=c2.r=1;\n\tvector<P> r=getIntersectCC(c1,c2);\n\tif(!r.size())continue;\n\tfor(int k=0;k<r.size();k++){\n\t  int cnt=0;\n\t  for(int l=0;l<n;l++)\n\t    if(getdistancepp(r[k],p[l])<=1+EPS)cnt++;\t    \n\t  ans=max(ans,cnt);\n\t}\n      }\n    }\n    if(!ans&&n>=1)ans=1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n#include <complex>\ntypedef complex<double> Point;\nint main(){\n  int N;\n  while(cin >> N && N){\n    vector<Point> ps(N);\n    REP(i, N) cin >> ps[i].real() >> ps[i].imag();\n    int ans = 0;\n    REP(i, N)REP(j, N) if(i != j){\n      double d = abs(ps[i] - ps[j]) / 2;\n      if(d > 1) continue;\n      double t = sqrt(1 - d * d);\n      Point start = ps[i] + (ps[j] - ps[i]) * 0.5;\n      Point vect = (ps[j] - ps[i]) * Point(0.0, 1.0);\n      vect /= abs(vect);\n      for(int sign = -1; sign <= 1; sign += 2){\n        Point center = start + vect * t * (double)sign;\n        int sub_ans = 0;\n        REP(k, N) if(abs(center - ps[k]) < 1.0 + EPS) sub_ans ++;\n        ans = max(ans, sub_ans);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-9\n#define PI 3.141592653589793238\n// sqrtは重い\nusing namespace std;\ntypedef pair<double,double> P;\n\nvoid display(complex<double> a,complex<double> b){\n cout << \"(\" << a.real() <<\",\" << a.imag() <<\")\"<< \" \" <<\"(\"<< b.real() <<\",\" <<b.imag() << \")\" << endl;\n}\n\nint main(){\n  int n,ans;\n  double xin,yin,X;\n  complex<double> m;\n  while(cin >> n && n){\n    ans = 0;\n    complex<double> point[n];\n    for(int i=0;i<n;i++){\n      cin >> xin >> yin;\n      point[i] = complex<double>(xin,yin);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i == j)continue;\n\tcomplex<double> Rr = point[i]-point[j];\n\tif(abs(Rr) < 2){\n\n\t  complex<double> UKPC,U,P1,P2;\n\t  UKPC = (point[i]+point[j])*0.5;\n       \n\t  double T = sqrt(1-norm(point[i]-point[j])*0.25);\n\n\t  UKPC = (point[i]+point[j])*0.5;\n\t               /* unit vector(単位べく利ゅ)             *//* T倍に拡大 ９０度回転 */ \n  \t  P1 = UKPC + (point[i]-point[j])/abs(point[i]-point[j])*polar(T,PI/2.0);\n\t  P2 = UKPC + (point[i]-point[j])/abs(point[i]-point[j])*polar(T,-PI/2.0);\n\t  //cout << \"P1 = \" << P1 << \", P2 = \" << P2 << endl;\n\t  int cnt=0;\n\t  complex<double> CalcP;\n\t  double Calc;\n\t  for(int k=0;k<n;k++){\n\t    Calc = abs(P1-point[k]);\n\t    if(Calc < 1.0+EPS){\n\t      cnt++;\n\t    }\n\t  }\t\n\n\t  ans = max(ans,cnt);\n\t  cnt = 0;\n\t  for(int k=0;k<n;k++){\n\t    Calc = abs(P2-point[k]);\n\t    if(fabs(Calc) < 1.0+EPS){\n\t      cnt++;\n\t    }\n\t  }\t\n  \n\t  ans = max(ans,cnt);\n\t  \n\n\t}\n\n      }\n    }\n\n    cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ???????????????????????¶?????????\n\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\n// double\nstruct P{\n    P(){}\n    P(double _r, double _i):r(_r), i(_i){}\n    void real(const double& v){r = v;}\n    void imag(const double& v){i = v;}\n    double r, i;\n};\n\ndouble real(const P& p){return p.r;}\ndouble imag(const P& p){return p.i;}\ndouble norm(const P& p){double r = real(p), i = imag(p); return r * r + i * i;}\ndouble dist(const P& p){return std::sqrt(norm(p));}\n\nP operator+(const P& lhs, const P& rhs){\n    return P(real(lhs)+real(rhs), imag(lhs)+imag(rhs));\n}\nP operator-(const P& lhs, const P& rhs){\n    return P(real(lhs)-real(rhs), imag(lhs)-imag(rhs));\n}\nP operator-(const P& p){\n    return P(-real(p), -imag(p));\n}\n\ndouble cross(const P& lhs, const P& rhs){\n    return real(lhs)*imag(rhs) - imag(lhs)*real(rhs);\n}\n\ndouble dot(const P& lhs, const P& rhs){\n    return real(lhs)*real(rhs) + imag(lhs)*imag(rhs);\n}\n\nconst double EPS = 1e-9, D_THETA = 0.06, D_R = 0.06;\n\nint N;\nP ps[300];\nstd::vector<P> is;\n\nvoid addIntersection(int i, int j){\n    if(dist(ps[i]-ps[j]) > 2.0){return;}\n    \n    P m{(real(ps[j])-real(ps[i])) / 2, (imag(ps[j])-imag(ps[i])) / 2}, n{-imag(m), real(m)};\n    {\n        double d = dist(n);\n        n.real(real(n) / d);\n        n.imag(imag(n) / d);\n    }\n\n    double t = std::sqrt(1 - norm(m));\n    for(int k=-1;k<=1;k+=2){\n        P p{t * k * real(n), t * k * imag(n)};\n        P q = ps[i] + m + p;\n        // printf(\"%.6f, %.6f\\n\", real(q), imag(q));\n        is.push_back(q);\n    }\n}\n\nint count(P p){\n    int res = 0;\n    for(int i=0;i<N;i++){\n        if(dist(ps[i]-p) < 1.0 + EPS){res++;}\n    }\n    return res;\n}\n\nint main(){\n    while(scanf(\"%d\", &N), N){\n        is.clear();\n        \n        for(int i=0;i<N;i++){\n            double x, y;\n            scanf(\"%lf %lf\", &x, &y);\n\n            ps[i].real(x);\n            ps[i].imag(y);\n        }\n\n        for(int i=0;i<N;i++){\n            for(int j=i+1;j<N;j++){\n                addIntersection(i, j);\n            }\n        }\n        \n        int res = 1;\n        for(auto i : is){\n            res = std::max(res, count(i));\n        }\n\n        printf(\"%d\\n\", res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\n\n/* 幾何の基本 */\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n// -1 => out\n//  0 => on\n//  1 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nPolygon convex_cut(const Polygon &ps, Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n\t\t\tQ.push_back(is_ll(l, m));\n\t}\n\treturn Q;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\nvector<Point>ps;\n\nint check(Point& center) {\n\tint num = 0;\n\tfor (int i = 0; i < ps.size(); ++i) {\n\t\tif (abs(ps[i] - center) <= 1) {\n\t\t\tnum++;\n\t\t}\n\t}\n\treturn num;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\n\t\tps.clear();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tlong double x, y; cin >> x >> y;\n\t\t\tps.push_back({ x,y });\n\t\t}\t\t\n\n\t\tint ans = 1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tif (abs(ps[i] - ps[j]) > 2)continue;\n\t\t\t\tLine l(ps[i], ps[j]);\n\t\t\t\tPoint center = (ps[i] + ps[j])*0.5l;\n\t\t\t\tPoint vec(imag(ps[i] - ps[j]), -real(ps[i] - ps[j]));\n\t\t\t\tlong double nl = sqrt(0.9999999 - norm(center - ps[i]));\n\t\t\t\tlong double oldl = abs(vec);\n\t\t\t\tvec *=nl / oldl;\n\t\t\t\tPoint checkcenter = center + vec;\n\t\t\t\tans = max(ans,check(checkcenter));\n\t\t\t\tcheckcenter = center - vec;\n\t\t\t\tans = max(ans, check(checkcenter));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-9\nusing namespace std;\ntypedef complex<double> point;\n\npair<point, point> norm(point p){\n  double unit = 1 / sqrt(p.real()*p.real() + p.imag()*p.imag());\n  return pair<point, point>(p*point(0, 1)/unit,\n                            p*point(0, -1)/unit);\n}\n\nvector<point> calcC(point a, point b){\n  point p = (b - a)/2.0;\n  pair<point, point> n = norm(p);\n  double unit = sqrt(1 - abs(p)*abs(p));\n  n.first  *= unit;\n  n.second *= unit;\n  vector<point> res(2);\n  res[0] = a + p + n.first;\n  res[1] = a + p + n.second;\n  return res;\n}\nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n, n){;\n    point p[n];\n    for (int i = 0; i < n; i++) {\n      double real, imag;\n      cin >> real >> imag;\n      p[i] = complex<double>(real, imag);\n    }\n    int ans = 0, cnt = 0;\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        point a = p[i], b = p[j];\n        if(abs(b - a) > 2 - eps)continue;\n        vector<point> center = calcC(a, b);\n        for (int c = 0; c < 2; c++) {\n          cnt = 0;\n          // std::cout << center[c].real() << \" \" <<\n          //   center[c].imag()<< std::endl;\n          for (int k = 0; k < n; k++) {\n            if(abs(center[c] - p[k]) <= 1 - eps)cnt++;\n          }\n          ans = max(ans, cnt);\n        }\n      }\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\nusing P = complex<ld>;\nconst ld eps = 1e-6;\n\nint main()\n{\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<ld> x(N), y(N);\n\t\tvector<P> p(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tp[i] = P(x[i], y[i]);\n\t\t}\n\t\tvector<P> ko;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tif (norm(p[i] - p[j]) < 4.0 + eps) {\n\t\t\t\t\tauto d = p[i] - p[j];\n\t\t\t\t\tko.push_back(p[j] + (d * (ld)0.5) + d * P(0, 1) / abs(d) * sqrtl(1 - norm(d * (ld)0.5)));\n\t\t\t\t\tko.push_back(p[j] + (d * (ld)0.5) - d * P(0, 1) / abs(d) * sqrtl(1 - norm(d * (ld)0.5)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 1;\n\t\tfor (auto c : ko) {\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (norm(c - p[i]) < 1.0001) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = max(res, cnt);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n#define EPS 1e-12\n\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tif (N == 1) {\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvector<P> v;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdouble x, y; cin >> x >> y;\n\t\t\tv.push_back( P(x, y) );\n\t\t}\n\n\t\tvector<P> c;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i+1; j < N; ++j) {\n\t\t\t\tP r = (v[j] - v[i])/2.0;\n\t\t\t\tdouble l = abs(r);\n\t\t\t\tif (l > 1 + EPS) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (l >= 1 - EPS) {\n\t\t\t\t\tc.push_back( v[i] + r );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tP t = r / l * sqrt(1 - l*l);\n\t\t\t\t\tc.push_back(v[i] + r + t * P(0, 1));\n\t\t\t\t\tc.push_back(v[i] + r + t * P(0, -1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < c.size(); ++i) {\n\t\t\tint cnt = 0;\n\t\t\tfor (int j = 0; j < v.size(); ++j) {\n\t\t\t\tif ( abs(c[i] - v[j]) <= 1 + EPS ) {\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ndouble pi = 3.14159265358979;\n\nsigned main(){\n    ios::sync_with_stdio(false);\n\tcin.tie(0);\n    cout << fixed << setprecision(20);\n\n    int n;\n    double eps = 1e-6;\n    double b = 2*pi/3000;\n    while(cin>>n){\n        if(n==0) break;\n        double x[n],y[n];\n        for(int i=0;i<n;i++){\n            cin>>x[i]>>y[i];\n        }\n        int ans = 0;\n        for(int i=0;i<n;i++){\n            int ret = 0;\n            for(int j=0;j<n;j++){\n                double d = (x[i] - x[j]) * (x[i] - x[j]);\n               d += (y[i] - y[j]) * (y[i]-y[j]);\n                if(d <= 1.0) ret++;\n            }\n            ans = max(ans,ret);\n        }\n        //cerr << \" a \" << ans << endl;\n        for(int i=0;i<n;i++){\n            for(int cnt=0;cnt<3000;cnt++){\n                double theta = b*cnt;\n                double ox = x[i] + cos(theta);\n                double oy = y[i] + sin(theta);\n                int ret = 0;\n                for(int j=0;j<n;j++){\n                    double d = (ox - x[j]) * (ox - x[j]);\n                    d += (oy - y[j]) * (oy - y[j]);\n                    if(d <= 1.0 + eps) ret++;\n                }\n                ans = max(ans,ret);\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\ntemplate<class T> bool operator<(const complex<T> &a, const complex<T> &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n}\n\ntypedef complex<float> P;\n#define X real()\n#define Y imag()\n\nfloat dot(P a, P b){\n    return (a * conj(b)).X;\n}\nfloat cross(P a, P b){\n    return (a * conj(b)).Y;\n}\n\nvector<P> points;\ndeque<P> selected;\nint max_count;\n\nvoid search(int index) {\n    if(index > points.size()) return;\n    int selected_size = selected.size();\n\n    bool is_all_in_circle = true;\n    if(selected_size >= 2 && selected_size > max_count) {\n        // calc is all overlaps\n        vector<P> copied_selected;\n        copy(selected.begin(), selected.end(), back_inserter(copied_selected));\n\n        for (int i = 0; i < selected_size ; ++i) {\n            for (int j = 0; j < selected_size; ++j) {\n                if(i == j) continue;\n                // two point check\n                float d12 = abs(copied_selected[i] - copied_selected[j]);\n                if(d12 > 2.0 + 1e-10) {\n                    is_all_in_circle = false;\n                    break;\n                }\n\n                for (int k = 0; k < selected_size; ++k) {\n                    if(i == k || j == k) continue;\n                    // three point check\n                    P p1 = copied_selected[i];\n                    P p2 = copied_selected[j];\n                    P p3 = copied_selected[k];\n\n                    P center12 = P((p1.X + p2.X) / 2, (p1.Y + p2.Y) / 2);\n                    float allow_distance = 1 + sqrt(1 - ((d12 * d12) / 4));\n                    if(abs(center12 - p3)  > allow_distance + 1e-4) {\n                        is_all_in_circle = false;\n                        break;\n                    }\n                }\n\n            }\n            if(!is_all_in_circle) {\n                break;\n            }\n        }\n\n        copied_selected.clear();\n        copied_selected.shrink_to_fit();\n    }\n\n    if (is_all_in_circle) {\n        // update max count\n        if(selected_size > max_count) {\n            max_count = selected_size;\n        }\n\n        P p = points[index];\n        // remove bad situation\n        if(selected.empty() || abs(p - selected.front()) <= 2.0 + 1e-4) {\n            // take\n            selected.push_front(p);\n            search(index + 1);\n            selected.pop_front();\n        }\n\n        // for next dispatch\n        // not take\n        search(index + 1);\n    }\n}\n\nint main() {\n    int n;\n    while (cin >> n) {\n        if(n == 0) break;\n        points.clear();\n        points.shrink_to_fit();\n        selected.clear();\n        selected.shrink_to_fit();\n        max_count = 0;\n\n        // load points\n        for (char i = 0; i < n; ++i) {\n            float x;\n            float y;\n            cin >> x >> y;\n            P p = P(x, y);\n            points.push_back(p);\n        }\n\n        search(0);\n        cout << max_count << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n#define EPS 1e-12\n\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<P> v;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdouble x, y; cin >> x >> y;\n\t\t\tv.push_back( P(x, y) );\n\t\t}\n\n\t\tvector<P> c;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i+1; j < N; ++j) {\n\t\t\t\tP r = (v[j] - v[i])/2.0;\n\t\t\t\tdouble l = abs(r);\n\t\t\t\tif (l > 1 + EPS) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (l >= 1 - EPS) {\n\t\t\t\t\tc.push_back( v[i] + r );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tP t = r / l * sqrt(1 - l*l);\n\t\t\t\t\tc.push_back(v[i] + r + t * P(0, 1));\n\t\t\t\t\tc.push_back(v[i] + r + t * P(0, -1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 1;\n\t\tfor (int i = 0; i < c.size(); ++i) {\n\t\t\tint cnt = 0;\n\t\t\tfor (int j = 0; j < v.size(); ++j) {\n\t\t\t\tP p = c[i] - v[j];\n\t\t\t\tif ( p.real()*p.real()+p.imag()*p.imag() <= 1 + EPS ) {\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int N;\n    while (cin >> N, N) {\n        static const complex<double> I = complex<double>(0, -1);\n        using Point = complex<double>;\n        vector<Point> points(N);\n        REP(i, N) {\n            double x, y; cin >> x >> y;\n            points[i] = Point(x, y);\n        }\n\n        int ans = 1;\n        REP(i, N) FOR(j, i+1, N) {\n            auto x = points[i];\n            auto y = points[j];\n            double l_sq = norm(x - y);\n            if (l_sq > 4) continue;\n            for(double d : {-1, 1}) {\n                Point middle = 0.5 * (x + y);\n                Point dir = (x - y) * I;\n                dir /= abs(dir);\n                Point center = middle + d*sqrt(1 - l_sq/4)*dir;\n\n                int count = 0;\n                REP(k, N) {\n                    if (norm(center - points[k]) <= 1 + 1e-10)\n                        ++count;\n                }\n                ans = max(ans, count);\n            }\n        }\n        cout << ans << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble distance(pair<double,double> p1,pair<double,double> p2){\n\treturn sqrt((p1.first-p2.first)*(p1.first-p2.first)+(p1.second-p2.second)*(p1.second-p2.second));\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<double> x(n);\n\t\tvector<double> y(n);\n\t\tint res=1;\n\t\tfor(int i=0;i<n;i++) cin>>x[i]>>y[i];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tpair<double,double> midp=make_pair((x[i]+x[j])/2,(y[i]+y[j])/2);\n\t\t\t\tdouble a=-(x[i]-x[j]),b=(y[i]-y[j]);\n\t\t\t\t//a(x-mid[i].first)+b(y-mid.second)=0\n\t\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\t\tpair<double,double> lef=midp;\n\t\t\t\t\t\tpair<double,double> rig;\n\t\t\t\t\t\tif(k==0) rig=make_pair(-b*1e6+midp.first,a*1e6+midp.second);\n\t\t\t\t\t\tif(k==1) rig=make_pair(b*1e6+midp.first,-a*1e6+midp.second);\n\t\t\t\t\t\twhile(distance(lef,rig)>=0.00000001){\n\t\t\t\t\t\t\t\tpair<double,double> mid=make_pair((lef.first+rig.first)/2,(lef.second+rig.second)/2);\n\t\t\t\t\t\t\t\tif(distance(mid,make_pair(x[i],y[i]))>1){\n\t\t\t\t\t\t\t\t\trig=mid;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tlef=mid;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint count=0;\n\t\t\t\t\t\tfor(int r=0;r<n;r++){\n\t\t\t\t\t\t\tif(distance(make_pair(x[r],y[r]),lef)<1+0.000001){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres=max(res,count);\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout<<res<<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\ntypedef complex<double> C;\n#define EPS (1e-8)\n\nint n;\nC c[301];\n\nvoid solve() {\n  for(int i=0;i<n;i++)\n  cin>>c[i].real()>>c[i].imag();\n  \n  int res = 0;\n  for (int i = 0; i < n; i += 1) {\n    for (int j = i+1; j < n; j += 1) {\n      C v = c[j] - c[i];\n      double absv = abs(v);\n      if (absv > 2.0 + EPS) continue;\n      // _\n      C m = c[i] + (v / 2.0);\n      // ~ÜÅÌ£\n      double dist = sqrt(1.0 - absv * absv / 4.0);\n      // PÊ@üxNg\n      C unv  = (v * C(0, 1)) / absv;\n      // S\n      C nv = unv * dist;\n      for (int k = 0; k < 2; k += 1) {          \n        int cnt = 0;\n        nv *= -1;\n        C tc = m + nv;\n        for (int l = 0; l < n; l += 1) {\n          if (abs(tc - c[l]) < 1.0 + EPS) {\n            cnt++;\n          }\n        }\n        res = max(res, cnt);\n      }\n    }\n  }\n  cout<<res<<endl;\n  //cout<<\"+++++\"<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>n, n) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-6;\n\nstruct Circle{\n  P c;\n  double r;\n  Circle(P c=P(0,0),double r=0):c(c),r(r){}\n};\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1=c1.r,r2=c2.r,d;\n  P p1=c1.c,p2=c2.c;\n  d=abs(p1-p2);\n  if(d<EPS&&abs(r1-r2)<EPS) return res;\n  if(r1+r2<d-EPS||d+EPS<abs(r1-r2)) return res; \n  double a=(r1*r1-r2*r2+d*d)/(2*d);\n  double h=sqrt(max(r1*r1-a*a,0.0));\n  P tmp1=p1+a/d*(p2-p1);\n  P tmp2=h/d*(p2-p1);\n  if(abs(tmp2)<EPS)res.push_back(tmp1);\n  else{\n    res.push_back(P(real(tmp1)-imag(tmp2),imag(tmp1)+real(tmp2)));\n    res.push_back(P(real(tmp1)+imag(tmp2),imag(tmp1)-real(tmp2)));\n  }\n  return res;\n}\n\ndouble getdistancepp(P a,P b){\n  return sqrt((a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag()));\n}\n\nint main(){\n  int n,ans=0;\n  double a,b;\n  P p[N];\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>a>>b;\n      p[i]=P(a,b);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tCircle c1,c2;\n\tc1.c=p[i];\n\tc2.c=p[j];\n\tc1.r=c2.r=1;\n\tvector<P> r=getIntersectCC(c1,c2);\n\tif(!r.size())continue;\n\tfor(int k=0;k<r.size();k++){\n\t  int cnt=0;\n\t  for(int l=0;l<n;l++)\n\t    if(getdistancepp(r[k],p[l])<=1+EPS)cnt++;\t    \n\t  ans=max(ans,cnt);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\nconst double PI=3.141592653589793238462643383279;\n\nbool inC(P p, P c, double r){return abs(p-c)<r+1e-9;}\n\nP getE(P p){return p/abs(p);}\n\ndouble sq(double x){ return  x*x;}\n\nint main(){\n    int n,i,j,k,ans,cnt;\n    double x, y;\n    while(scanf(\"%d\",&n)){\n        if(n==0) break;\n        ans=0;\n        vector<P> ps(n);\n        for(i=0; i<n; i++){\n            scanf(\"%lf%lf\",&x,&y);\n            ps[i] = P(x,y);\n        }\n        for(i=0;i<n;i++)\n            for(j=i+1;j<n;j++)if(abs(ps[i]-ps[j])<2){\n                double d=sqrt(1-sq(abs(ps[j]-ps[i])*0.5));\n                P c1=0.5*(ps[i]+ps[j])+getE(getE(ps[j]-ps[i]))*polar(d,PI/2);\n                P c2=0.5*(ps[i]+ps[j])+getE(getE(ps[j]-ps[i]))*polar(d,-PI/2);\n                cnt=0;\n                for(k=0;k<n;k++)if(inC(ps[k],c1,1.0))cnt++;\n                if(cnt>ans)ans=cnt;\n                cnt=0;\n                for(k=0;k<n;k++)if(inC(ps[k],c2,1.0))cnt++;\n                if(cnt>ans)ans=cnt;\n            }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define eps 1.0e-9\n\nusing namespace std;\n\nint N;\ndouble x[305], y[305];\n\nint count(double cx, double cy)\n{\n\tint ret = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tif( (cx - x[i])*(cx - x[i]) + (cy - y[i])*(cy - y[i]) <= 1 + eps) ret++;\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\tfor(int i = 0; i < N; i++) cin >> x[i] >> y[i];\n\t\t\n\t\tint ans = -1;\n\t\tdouble cx, cy;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\t\n\t\t\t\tdouble px = x[j] - x[i];\n\t\t\t\tdouble py = y[j] - y[i];\n\t\t\t\tdouble pnorm = sqrt(px*px + py*py);\n\t\t\t\tpx /= pnorm;\n\t\t\t\tpy /= pnorm;\n\t\t\t\t\n\t\t\t\tdouble mx = (x[i] + x[j]) / 2.0;\n\t\t\t\tdouble my = (y[i] + y[j]) / 2.0;\n\t\t\t\t\n\t\t\t\tdouble qnorm = 1 - pnorm*pnorm/4.0;\n\t\t\t\tif(qnorm < eps) continue;\n\t\t\t\tqnorm = sqrt(qnorm);\n\t\t\t\tdouble qx = qnorm * py;\n\t\t\t\tdouble qy = qnorm * -px;\n\t\t\t\t\n\t\t\t\tans = max(ans, count(mx + qx, my + qy));\n\t\t\t\tans = max(ans, count(mx - qx, my - qy));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define EPS 1.0e-4\nusing namespace std;\n\ntypedef struct {\n  double x,y;\n} P;\n\ndouble dis(P p ){\n  return sqrt( p.x*p.x + p.y*p.y );\n}\ndouble dis(P p1,P p2 ){\n  P p;\n  p.x = p1.x-p2.x;\n  p.y = p1.y-p2.y;\n  return dis( p );\n}\n\n\nint main(){\n  int n, mx;\n  // mv : @üxNg\n  P p[301], m, p1,p2, mv,dmv, c[2];\n  double x;\n\n  while( cin>>n && n ){\n    for( int i=0;i<n;i++ )\n      cin >> p[i].x >> p[i].y ;\n\n    mx=0;\n\n    for( int i=0;i<n;i++ ){\n      for( int j=i+1;j<n;j++ ){\n\tif( dis(p[i],p[j]) < 2.0 + EPS ){\n\t  p1=p[i]; p2=p[j];\n\t  m.x = (p1.x+p2.x)/2.0;\n\t  m.y = (p1.y+p2.y)/2.0;\n\n\t  x = sqrt( 1-dis(p1,m) );\n\t  // S_ cðßé\n\t  if( fabs( p1.y-p2.y ) < EPS ){\n\t    mv.x=0.0;  mv.y=1.0;\n\t  }else if( fabs( p1.x-p2.x ) < EPS ){\n\t    mv.x=1.0;  mv.y=0.0;\n\t  }else{\n\t    double a1 = ( p2.y-p1.y )/( p2.x-p1.x );\n\t    mv.x=1.0; mv.y=-1.0/a1;\n\t  }\n\t  double scale = dis( mv );\n\t  dmv.x = x*mv.x / scale;\n\t  dmv.y = x*mv.y / scale;\n\n\t  c[0].x=m.x+dmv.x; c[0].y=m.y+dmv.y;\n\t  c[1].x=m.x-dmv.x; c[2].y=m.y-dmv.y;\n\t  /*\n\t  cout << \"m  \" << m.x    << \",\" << m.y    << endl;\n\t  cout << \"mv \" << mv.x   << \",\" << mv.y   << endl;\n\t  cout << \"dm \" << dmv.x  << \",\" << dmv.y  << endl;\n\t  cout << \"c0 \" << c[0].x << \",\" << c[0].y << endl;\n\t  cout << \"c1 \" << c[1].x << \",\" << c[1].y << endl;\n\t  */\n\n\t  for( int cn=0;cn<2;cn++ ){\n\t    int sum=0;\n\t    for( int k=0;k<n;k++ ){\n\t      if( dis( c[cn],p[k] ) < 1.0 + EPS )\n\t\tsum++;\n\t    }\n\t    if( mx<sum ) mx=sum;\n\t  }\n\t}\n      }\n    }\n    cout << mx << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <complex>\n\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,n) loop(i,0,n)\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef complex<double> vec;\n\ndouble const pi = acos(-1);\ndouble const eps = 1e-6;\n\nint main(){\n    int n;\n    while (cin >> n && n){\n        vector<vec> v(n);\n        rep(i, n){\n            double x, y; cin >> x >> y;\n            vec p(x, y);\n            v[i] = p;\n        }\n\n        if (n == 1) {\n            puts(\"1\");\n            continue;\n        }\n        if (n == 2){\n            if (abs(v[0] - v[1]) < 2 - eps) {\n                puts(\"2\"); \n\n            }\n            else{\n                puts(\"1\"); \n            }\n            continue;\n        }\n\n        int ans = 0;\n        rep(i, n)rep(j, i){\n            double d = abs(v[i] - v[j]);\n            if (d - eps > 2) continue;\n            double h = 1 - d*d / 4;\n            vec c1 = polar(h, arg(v[i] - v[j]) + pi / 2) + (v[i] + v[j]) / 2.;\n            vec c2 = polar(h, arg(v[i] - v[j]) - pi / 2) + (v[i] + v[j]) / 2.;\n            int a1 = 0, a2 = 0;\n            rep(k, n){\n                if (abs(c1 - v[k]) <= 1 - eps) a1++;\n                if (abs(c2 - v[k]) <= 1 - eps) a2++;\n            }\n            ans = max(ans, a1);\n            ans = max(ans, a2);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <string> \n#include <vector> \n#include <cmath> \n#include <algorithm> \n#include <cstdlib> \n#include <ctime> \n#include <cstdio> \n#include <functional> \n#include <set> \n#include <sstream> \n\n\nusing namespace std; \n\nint main(){\n\n\tint n;\n\tconst double eps=1e-8;\n\twhile(true){\n\n\t\tcin>>n;\n\n\t\tif(n==0) return 0;\n\n\t\t//必ず1つは囲める\n\t\tint ans=1;\n\n\t\tvector< double > x(n),y(n);\n\n\t\tfor(int i=0;i<n;i++) cin>>x[i]>>y[i];\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tconst double d=hypot(x[i]-x[j],y[i]-y[j]);\n\t\t\t\tif(d>2.0-eps) continue;\n\n\t\t\t\t//中点\n\t\t\t\tconst double mx=(x[i]+x[j])/2.0;\n\t\t\t\tconst double my=(y[i]+y[j])/2.0;\n\n\t\t\t\t//方向ベクトル\n\t\t\t\tconst double dvx=(x[i]-x[j])/d;\n\t\t\t\tconst double dvy=(y[i]-y[j])/d;\n\n\t\t\t\t//(x[i],y[i]),(x[j],y[j])が円周上にある半径1の円の中心1\n\t\t\t\tconst double cx1=mx+dvy*sqrt(1.0-d*d/4.0);\n\t\t\t\tconst double cy1=my-dvx*sqrt(1.0-d*d/4.0);\n\n\t\t\t\t//(x[i],y[i]),(x[j],y[j])が円周上にある半径1の円の中心2\n\t\t\t\tconst double cx2=mx-dvy*sqrt(1.0-d*d/4.0);\n\t\t\t\tconst double cy2=my+dvx*sqrt(1.0-d*d/4.0);\n\n\t\t\t\t//2点は円周上にあるので確定(誤差死回避)\n\t\t\t\tint res=2;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i || k==j) continue;\n\t\t\t\t\tif((x[k]-cx1)*(x[k]-cx1)+(y[k]-cy1)*(y[k]-cy1)<1.0+eps) res++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tans=max(ans,res);\n\n\t\t\t\tres=2;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i || k==j) continue;\n\t\t\t\t\tif((x[k]-cx2)*(x[k]-cx2)+(y[k]-cy2)*(y[k]-cy2)<1.0+eps) res++;\n\t\t\t\t}\n\n\t\t\t\tans=max(ans,res);\n\n\t\t\t}\n\t\t}\n\n\t\tcout<<ans<<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define rrep(i,n) for (int i = (n)-1; i >= 0; i--)\n#define rep2(i,s,n) for (int i = (s); i < (n); ++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vvi vector<vector<int>>\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vd vector<double>\n#define vs vector<string>\n#define vc vector<char>\n#define vb vector<bool>\n#define vp vector<P>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\nusing LP = pair<ll,ll>;\ntemplate<class T> istream& operator>>(istream& is,vector<T>& v) { for(T& t:v){is>>t;} return is; }\ntemplate<class T> ostream& operator<<(ostream& os,const vector<T>& v) { for(T t:v){os<<t<<\" \";} os<<\"\\n\"; return os; }\nvoid Yes(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YES(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate<class T> inline bool chmin(T& a,T b) {if(a > b){a = b; return true;} return false;}\ntemplate<class T> inline bool chmax(T& a,T b) {if(a < b){a = b; return true;} return false;}\nconst int inf = 1001001001;\nconst ll linf = 1001001001001001001;\n\nconst double eps = 1e-9;\nconst double PI = acos(-1);\nint sgn(double a){ return a < -eps ? -1 : (a > eps ? 1 : 0); }\n\nstruct point {\n    double x,y;\n    point(double x=0,double y=0):x(x),y(y){}\n    point operator+(const point a) const{ return {x+a.x,y+a.y}; }\n    point operator-(const point a) const{ return {x-a.x,y-a.y}; }\n    point operator*(const double a) const{ return {x*a,y*a}; }\n    point operator/(const double a) const{ return {x/a,y/a}; }\n    point operator-() const{ return *this*(-1); }\n    double norm() { return x*x+y*y; }\n    double abs() { return sqrt(norm()); }\n    point rot90() { return point(-y,x); }\n    double arg() { return atan2(y,x);}\n};\nistream& operator>>(istream& is,point& p){ is >> p.x >> p.y; return is; }\nostream& operator<<(ostream& os,const point& p){ os << p.x << \" \" << p.y; return os; }\nbool operator==(point a,point b) { return !sgn(a.x-b.x) && !sgn(a.y-b.y); }\nbool operator!=(point a,point b) { return !(a == b); }\ndouble dist(point a,point b) { return (a-b).abs(); }\ndouble dot(point a,point b) { return a.x*b.x+a.y*b.y; }\ndouble cross(point a,point b) { return a.x*b.y-a.y*b.x; }\npoint mid(point a,point b) { return (a+b)/2; }\nint ccw(point a,point b,point c) {\n    // 1 -> c is upper than line(a,b)\n    // -1 -> c is lower than line(a,b)\n    // 2 -> in order [a,b,c]\n    // -2 -> in order [c,a,b]\n    // 0 -> in order [a,c,b]\n    b = b-a,c = c-a;\n    if(sgn(cross(b,c))) return sgn(cross(b,c));\n    if(sgn(dot(b,c)) < 0) return -2;\n    if(sgn(c.abs()-b.abs()) > 0) return 2;\n    return 0;\n}\nstruct line {\n    point a,b;\n    line(point a,point b):a(a),b(b) {}\n    bool online(point p) { return abs(ccw(a,b,p)) != 1; }\n};\nstruct segline {\n    point a,b;\n    segline(point a,point b):a(a),b(b) {}\n    bool online(point p) { return !ccw(a,b,p); }\n    line vertical_bisector() { return line(mid(a,b),mid(a,b)+(b-a).rot90()); }\n};\nbool vertical(line l,line m) { return !sgn(dot(l.a-l.b,m.a-m.b)); }\nbool vertical(segline l,segline m) { return !sgn(dot(l.a-l.b,m.a-m.b)); }\nbool parallel(line l,line m) { return !sgn(cross(l.a-l.b,m.a-m.b)); }\nbool parallel(segline l,segline m) { return !sgn(cross(l.a-l.b,m.a-m.b)); }\nbool operator==(line l,line m) { return parallel(l,m) && l.online(m.a); }\nbool operator!=(line l,line m) { return !(l == m); }\nbool operator==(segline l,segline m) { return l.a == m.a && l.b == m.b || l.a == m.b && l.b == m.a; }\nbool operator!=(segline l,segline m) { return !(l == m); }\n// intersect at one point\nbool intersect(line l,line m) { return !parallel(l,m); }\nbool intersect(line l,segline m) { return sgn(cross(l.b-l.a,m.a-l.a)*cross(l.b-l.a,m.b-l.a)) <= 0; }\nbool intersect(segline l,segline m) {\n    return ccw(l.a,l.b,m.a)*ccw(l.a,l.b,m.b) <= 0 &&\n        ccw(m.a,m.b,l.a)*ccw(m.a,m.b,l.b) <= 0;\n}\npoint intersection(line l,line m) {\n    assert(intersect(l,m));\n    return l.a+(l.b-l.a)*cross(m.b-m.a,m.a-l.a)/cross(m.b-m.a,l.b-l.a);\n}\npoint intersection(line l,segline m) {\n    assert(intersect(l,m));\n    return l.a+(l.b-l.a)*cross(m.b-m.a,m.a-l.a)/cross(m.b-m.a,l.b-l.a);\n}\npoint intersection(segline l,segline m) {\n    assert(intersect(l,m));\n    return l.a+(l.b-l.a)*cross(m.b-m.a,m.a-l.a)/cross(m.b-m.a,l.b-l.a);\n}\ndouble dist(line l,point p) { return abs(cross(l.b-l.a,p-l.a))/(l.b-l.a).abs(); }\ndouble dist(segline l,point p) {\n    if(sgn(dot(l.b-l.a,p-l.a)) < 0) return dist(p,l.a);\n    if(sgn(dot(l.a-l.b,p-l.b)) < 0) return dist(p,l.b);\n    return dist(line(l.a,l.b),p);\n}\ndouble dist(line l,line m) {\n    if(parallel(l,m)) return dist(l,m.a);\n    return 0;\n}\ndouble dist(line l,segline m) {\n    if(intersect(l,m)) return 0;\n    return min(dist(l,m.a),dist(l,m.b));\n}\ndouble dist(segline l,segline m) {\n    if(intersect(l,m)) return 0;\n    return min({dist(l,m.a),dist(l,m.b),dist(m,l.a),dist(m,l.b)});\n}\npoint projection(line l,point p) {\n    double d = dot(p-l.a,l.b-l.a)/(l.b-l.a).norm();\n    return l.a+(l.b-l.a)*d;\n}\npoint gaisin(point a,point b,point c) {\n    return intersection(segline(a,b).vertical_bisector(),segline(b,c).vertical_bisector());\n}\nstruct circle {\n    point o;\n    double r;\n    circle(point o,double r):o(o),r(r) {}\n    bool inside(point p){ return sgn(r-dist(o,p)) >= 0; }\n    double area() { return r*r*PI; }\n};\nbool intersect(circle c,line l) { return sgn(dist(l,c.o)-c.r) <= 0; }\nbool intersect(circle c,segline l) {\n    if(sgn(dist(l,c.o)-c.r) > 0) return false;\n    return sgn(max((c.o - l.a).abs(), (c.o - l.b).abs()) - c.r) >= 0;\n}\nvector<point> intersection(circle c,line l) {\n    point p = projection(l,c.o);\n    if(!intersect(c,l)) return {};\n    if(sgn(dist(l,c.o)-c.r) == 0) return {p};\n    point e = (l.b-l.a)/(l.b-l.a).abs();\n    double d = sqrt(c.r*c.r-(p-c.o).norm());\n    return {p-e*d,p+e*d};\n}\nvector<point> intersection(circle c,segline l) {\n    auto v = intersection(c,line(l.a,l.b));\n    vector<point> ret;\n    for(point p : v) if(l.online(p)) ret.pb(p);\n    return ret;\n}\nvector<point> intersection(circle a,circle b) {\n    double d = dist(a.o,b.o);\n    if(!sgn(a.r+b.r-d)) return {a.o+(b.o-a.o)*a.r/d};\n    if(!sgn(a.r-b.r-d)) return {a.o+(b.o-a.o)*a.r/d};\n    if(!sgn(b.r-a.r-d)) return {b.o+(a.o-b.o)*b.r/d};\n    if(sgn(abs(a.r-b.r)-d) > 0 || sgn(a.r+b.r-d) < 0) return {};\n    double x = (a.r*a.r+d*d-b.r*b.r)/(2*d);\n    double y = sqrt(a.r*a.r-x*x);\n    point p = (b.o-a.o).rot90()*y/d;\n    point tomid = a.o+(b.o-a.o)*x/d;\n    return {tomid+p,tomid-p};\n}\nvector<circle> circle_with_two_points_and_radius(point a,point b,double r) {\n    if(sgn(dist(a,b)-2*r) > 0) return {};\n    circle A(a,r),B(b,r);\n    auto v = intersection(A,B);\n    vector<circle> ret;\n    for(point p : v) ret.eb(p,r);\n    return ret;\n};\n\nint cnt(circle c,vector<point> &v) {\n    int ret = 0;\n    for(point &p : v) if(c.inside(p)) ret++;\n    return ret;\n}\n\nvoid solve(int n) {\n    vector<point> v(n);\n    cin >> v;\n    int ans = 1;\n    for(auto p : v) for(auto q : v) {\n        if(p == q) continue;\n        auto can = circle_with_two_points_and_radius(p,q,1);\n        for(auto &c : can) chmax(ans,cnt(c,v));\n    }\n    cout << ans << \"\\n\";\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); cout.tie(nullptr);\n    int n;\n    while(cin >> n,n) {\n        solve(n);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\nR radNorP(R x) {\n    return fmod(fmod(x, 2*PI)+2*PI, 2*PI);\n}\n\nconst int MN = 330;\n\nP p[MN];\ntypedef pair<R, int> Pi;\n\nbool solve() {\n    int n;\n    cin >> n;\n    if (!n) return false;\n\n    for (int i = 0; i < n; i++) {\n        R x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n    }\n\n    int res = 0;\n    for (int i = 0; i < n; i++) {\n        vector<Pi> v;\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            if (2.0 < abs(p[j]-p[i])) continue;\n            R th = acos(abs(p[j]-p[i])/2.0);\n            R l = radNorP(arg(p[j]-p[i])-th-EPS);\n            R r = radNorP(arg(p[j]-p[i])+th+EPS);\n            if (r < l) {\n                v.push_back(Pi(l-EPS, 1));\n                v.push_back(Pi(2*PI+EPS, -1));\n                v.push_back(Pi(0-EPS, 1));\n                v.push_back(Pi(r+EPS, -1));\n            } else {\n                v.push_back(Pi(l-EPS, 1));\n                v.push_back(Pi(r+EPS, -1));\n            }\n\n        }\n\n        sort(v.begin(), v.end());\n        int sm = 1;\n        for (Pi p: v) {            \n            sm += p.second;\n            res = max(res, sm);\n        }\n    }\n    cout << res << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst double PI=acos(-1);\nconst double EPS=1e-6;\ntypedef complex<double>Point;\nPoint in(){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    return Point(x,y);\n}\n\nint N;\nPoint P[333];\n\nsigned main(){\n\n    Point r=polar(1.0,PI/2);\n    while(scanf(\"%lld\",&N),N){\n        rep(i,N)P[i]=in();\n\n        int ma=1;\n        rep(i,N)rep(j,N){\n            Point b=(P[i]+P[j])*0.5;\n            Point v=(P[i]-P[j])*0.5*r;\n            for(double d:{-1.0,1.0}){\n                Point u=v*d*sqrt(1.0-abs(v)*abs(v));\n                Point p=b+u;\n                int cnt=0;\n                rep(k,N)if(abs(P[k]-p)<1.0+EPS)cnt++;\n                chmax(ma,cnt);\n            }\n        }\n        printf(\"%lld\\n\",ma);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\nstruct Point {\n\tlong double x;\n\tlong double y;\n\tPoint(long double _x = 0, long double _y = 0) :x(_x), y(_y) {}\n\tPoint operator+(Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator-(Point p)  {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tlong double abs() {\n\t\treturn sqrt(norm());\n\t}\n\tlong double norm() {\n\t\treturn x*x + y*y;\n\t}\n};\ntypedef Point Vector;\nstruct Circle {\n\tPoint c;\n\tlong double r;\n\tCircle(Point _c = Point(), long double _r = 0.0) :c(_c), r(_r) {}\n};\nlong double arg(Vector p) {\n\treturn atan2(p.y, p.x);\n}\nVector polar(long double a, long double r) {\n\treturn Point(cos(r)*a, sin(r)*a);\n}\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\tlong double d = (c1.c - c2.c).abs();\n\tlong double a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tlong double t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\nlong double X[300], Y[300];\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> X[i] >> Y[i];\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tCircle c1(Point(X[i], Y[i]), 1.0);\n\t\t\t\tCircle c2(Point(X[j], Y[j]), 1.0);\n\t\t\t\tif ((c1.c - c2.c).abs() > 2.0) continue;\n\t\t\t\tpair<Point, Point> c = getCrossPoints(c1, c2);\n\t\t\t\tint cnt1 = 0, cnt2 = 0;\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tPoint p(X[k], Y[k]);\n\t\t\t\t\tif ((p - c.first).abs() <= 1.0) cnt1++;\n\t\t\t\t\tif ((p - c.second).abs() <= 1.0) cnt2++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, cnt1);\n\t\t\t\tans = max(ans, cnt2);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int64_t i = 0; i < (n); i++)\n#define irep(i, n) for (int64_t i = 0; i <= (n); i++)\n#define rrep(i, n) for (int64_t i = (n)-1; i >= 0; i--)\n#define rirep(i, n) for (int64_t i = n; i >= 0; i--)\n\nclass Vec;\nVec operator/(const Vec& v, const double& divisor);\nVec operator*(const double& scale, const Vec& v);\n\nclass Circle;\nclass Line;\ntemplate <typename G, typename H>\nstd::pair<std::vector<Vec>, bool> intersection(const G& lh, const H& rh,\n                                               double eps);\ntemplate <>\nstd::pair<std::vector<Vec>, bool> intersection<Circle, Circle>(\n    const Circle& circle, const Circle& line, double eps);\ntemplate <>\nstd::pair<std::vector<Vec>, bool> intersection<Circle, Line>(\n    const Circle& circle, const Line& line, double eps);\n\nclass Vec {\n  using F = double;\n  vector<F> container;\n\n public:\n  explicit Vec(size_t size) : container(size) {}\n  explicit Vec(initializer_list<F> elements)\n      : container(elements.begin(), elements.end()) {}\n  size_t dim() const { return container.size(); }\n  F& operator[](const size_t size) { return container.at(size); }\n  const F& operator[](const size_t size) const { return container.at(size); }\n  Vec operator+(const Vec& other) const {\n    Vec ret(*this);\n    for (size_t i = 0; i < dim(); i++) ret[i] += other[i];\n    return ret;\n  }\n  Vec operator-(const Vec& other) const { return (*this) + (-other); }\n  Vec operator-() const { return -1.0 * (*this); }\n  F inner(const Vec& other) const {\n    F acc = 0;\n    for (size_t i = 0; i < dim(); i++) {\n      acc += (*this)[i] * other[i];\n    }\n    return acc;\n  }\n  Vec& operator+=(const Vec& other) {\n    for (size_t i = 0; i < dim(); i++) {\n      (*this)[i] += other[i];\n    }\n    return *this;\n  }\n  F norm() const { return sqrt(inner(*this)); }\n  Vec unit() const { return (*this) / this->norm(); }\n  F ccw(const Vec& other) const {\n    return (*this)[0] * other[1] - other[0] * (*this)[1];\n  }\n  Vec normal() const { return Vec({-(*this)[1], (*this)[0]}); }\n};\nVec operator/(const Vec& v, const double& divisor) { return 1.0 / divisor * v; }\nVec operator*(const double& scale, const Vec& v) {\n  Vec ret(v);\n  for (size_t i = 0; i < ret.dim(); i++) ret[i] *= scale;\n  return ret;\n}\n\nclass Circle {\n  Vec m_center;\n  double m_radius;\n\n public:\n  Circle(const Vec& center, double radius)\n      : m_center(center), m_radius(radius) {}\n  const Vec& center() const { return m_center; }\n  double radius() const { return m_radius; }\n};\n\nclass Line {\n  Vec m_grad;\n  double m_bias;\n\n public:\n  Line(const Vec& grad, double bias) : m_grad(grad), m_bias(bias) {}\n  static Line fromPoints(const Vec& p0, const Vec& p1) {\n    Vec d = p0 - p1;\n    Vec g({-d[1], d[0]});\n    return Line(g, g.inner(p0));\n  }\n  const Vec& grad() const { return m_grad; }\n  double bias() const { return m_bias; }\n  double dist(const Vec& p) const {\n    return abs(m_grad.inner(p) - m_bias) / m_grad.norm();\n  }\n  Vec projection(const Vec& p) const {\n    const Vec g = m_grad.unit();\n    const Vec h({-g[1], g[0]});\n    return m_bias / m_grad.norm() * g + h.inner(p) * h;\n  }\n};\n\ntemplate <>\npair<vector<Vec>, bool> intersection<Circle, Circle>(const Circle& c0,\n                                                     const Circle& c1,\n                                                     double eps) {\n  const Vec& p0 = c0.center();\n  const Vec& p1 = c1.center();\n  double r0 = c0.radius();\n  double r1 = c1.radius();\n\n  const Vec v = p0 - p1;\n\n  if (r0 + r1 < v.norm()) {\n    return make_pair(vector<Vec>(), false);\n  } else if (r0 > r1 + v.norm() || r1 > r0 + v.norm()) {\n    return make_pair(vector<Vec>(), false);\n  } else {\n    Vec grad = 2.0 * (p1 - p0);\n    const double bias = (r0 - r1) * (r0 + r1) -\n                        (p0[0] - p1[0]) * (p0[0] + p1[0]) -\n                        (p0[1] - p1[1]) * (p0[1] + p1[1]);\n    return move(intersection(c0, Line(grad, bias), eps));\n  }\n}\ntemplate <>\npair<vector<Vec>, bool> intersection<Circle, Line>(const Circle& circle,\n                                                   const Line& line,\n                                                   double eps) {\n  const double g = line.grad().norm();\n\n  if (g < eps) {\n    return make_pair(vector<Vec>(), abs(line.bias()) < eps);\n  } else {\n    vector<Vec> result;\n    const double dist = (line.bias() - line.grad().inner(circle.center())) / g;\n\n    const double det = pow(circle.radius(), 2) - pow(dist, 2);\n    if (det < 0) {\n    } else {\n      const double s = sqrt(det);\n      const Vec u = line.grad().unit();\n      const Vec p = circle.center() + dist * u;\n      Vec dir = u.normal();\n\n      result.push_back(p + s * dir);\n      result.push_back(p - s * dir);\n    }\n\n    return make_pair(move(result), false);\n  }\n}\n\nvoid solve(int N) {\n  vector<Vec> p;\n  rep(i, N) {\n    double x, y;\n    cin >> x >> y;\n    p.push_back(Vec({x, y}));\n  }\n\n  int result = 1;\n  rep(i, N) for (int j = i + 1; j < N; j++) {\n    const double EPS = 1e-9;\n\n    vector<Vec> s;\n    bool eq;\n    tie(s, eq) = intersection(Circle(p[i], 1), Circle(p[j], 1), EPS);\n    for (auto c : s) {\n      int cnt = 0;\n      rep(k, N) {\n        if (k == i || k == j) {\n          cnt++;\n        } else {\n          if ((p[k] - c).norm() < 1.0) {\n            cnt++;\n          }\n        }\n      }\n\n      result = max(result, cnt);\n    }\n  }\n  cout << result << \"\\n\";\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int N;\n  cin >> N;\n  while (N != 0) {\n    solve(N);\n    cin >> N;\n  }\n  cout << flush;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\nint main() {\n  const complex<double> I(0,1);\n  complex<double> d2(2,0);\n  for(int tci = 0; ; tci++) {\n    int n; scanf(\"%d\", &n);\n    if(!n) break;\n    complex<double> *pts = new complex<double>[n];\n    for(int i = 0; i < n; i++) {\n      scanf(\"%lf%lf\", &pts[i].real(), &pts[i].imag());\n    }\n    int maxcnt = 0;\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n        if(i==j) continue;\n        complex<double> d = (pts[i] - pts[j]) / d2;\n        double absd = abs(d);\n        complex<double> k = d*I/absd * sqrt(1-absd*absd);\n        complex<double> c = (pts[i] + pts[j]) / d2 + k;\n        int cnt = 0;\n        for(int k = 0; k < n; k++) {\n          cnt += (abs(pts[k]-c) <= 1 + 1e-9);\n        }\n        maxcnt = max(maxcnt, cnt);\n      }\n    }\n    delete[] pts;\n    printf(\"%d\\n\", maxcnt);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\nusing namespace std;\ntypedef long long LL;\n\n#include <complex>\n\ntypedef complex<double> P;\n\nint N=0;\nP p[302];\nint CountPointsInCircle(P c){\n    int cnt=0;\n    for(int i=0;i<N;i++){\n        if(abs(p[i]-c)<=1.0001){\n            cnt++;\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    while(1){\n        cin>>N;\n        if(N==0)break;        \n        for(int i=0;i<N;i++){\n            double x,y;\n            cin>>x>>y;\n            p[i]=P(x,y);\n        }\n        int ans=0;\n        for(int i=0;i<N;i++){\n            for(int j=i+1;j<N;j++){\n                P mid = P((p[i].real()+p[j].real())/2,(p[i].imag()+p[j].imag())/2);\n                double dist = abs(p[i]-p[j]);\n                if(dist>2.0001){\n                    continue;\n                }\n                P n1  = ((p[i]-p[j]) *P(0, 1))/dist;\n                P n2  = ((p[i]-p[j]) *P(0,-1))/dist;\n                P c1= mid + n1*sqrt(1.0-dist/2.0*dist/2.0);\n                P c2= mid + n2*sqrt(1.0-dist/2.0*dist/2.0);\n                int ans1=CountPointsInCircle(c1);\n                int ans2=CountPointsInCircle(c2);\n                ans=max(ans,max(ans1,ans2));\n            }\n        }\n        if(ans==0){\n            cout<<1<<endl;\n        }else{\n            cout<<ans<<endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <chrono>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <random>\n#include <memory>\n#include <utility>\n#include <limits>\n#include \"limits.h\"\n \n#define rep(i, a, b) for (long long (i) = (a); i < (b); i++)\n#define all(i) i.begin(), i.end()\n#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n\nvoid debug_out(){std::cerr<<std::endl;}\n\ntemplate<typename Head,typename... Tail>\nvoid debug_out(Head h,Tail... t){\n  std::cerr<<\" \"<<h;\n  debug_out(t...);\n}\n \ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, std::pair<T1, T2> pa) {\n  return os << pa.first << \" \" << pa.second;\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> vec) {\n  for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n  return os;\n}\n \ntemplate<typename T1,typename T2>\ninline bool chmax(T1& a,T2 b){return a<b && (a=b,true);}\n \ntemplate<typename T1,typename T2>\ninline bool chmin(T1& a,T2 b){return a>b && (a=b,true);}\n \nlong long pow_mod(long long a, long long b, long long mod=-1) {\n  if(b==0)return 1;\n  if ((a == 0)||(mod!=-1&&(a+mod)%mod==0)) {\n    return 0;\n  }\n  long long x = 1;\n  while (b > 0) {\n    if (b & 1) {\n      x = (mod!=-1)?(x * a) % mod:x*a;\n    }\n    a = (mod!=-1)?(a * a) % mod:a*a;\n    b >>= 1;\n  }\n  return x;\n}\n\n// const long long MOD = 998244353;\nconst long long MOD = 1e9 + 7;\n\nusing ll = long long;\nusing P=std::pair<long long,long long>;\n\nusing Point=std::complex<long double>;\n\nconst long double EPS=1e-10;\nconst long double PI=std::acos(-1.0l);\n\nbool EQ(long double a,long double b){return std::abs(a-b)<EPS;}\nbool EQP(Point a,Point b){return EQ(a.real(),b.real())&&EQ(a.imag(),b.imag());}\n\nPoint unitvec(Point a){return a/std::abs(a);}\n\nint main() {\n  std::cin.tie(nullptr);\n  std::ios::sync_with_stdio(false);\n\n  ll n;\n  while(std::cin>>n,n){\n    std::vector<Point> point;\n    rep(i,0,n){\n      long double a,b;\n      std::cin>>a>>b;\n      point.emplace_back(a,b);\n    }\n\n    std::vector<Point> candi;\n    rep(i,0,n){\n      rep(j,i+1,n){\n        if(std::abs(point[j]-point[i])<=2.0l+EPS){\n          Point mid=(point[i]+point[j])/2.0l;\n\n          Point unit=unitvec(point[i]-mid);\n          unit*=std::sqrt(1.0l-std::norm(point[i]-mid));\n          candi.push_back(unit*Point(0,1)+mid);\n          candi.push_back(unit*Point(0,-1)+mid);\n        }\n      }\n    }\n\n    ll ans=1;\n    for(auto e:candi){\n      ll cnt=0;\n      rep(i,0,n){\n        if(std::abs(e-point[i])<=1.0l+EPS)cnt++;\n      }\n      chmax(ans,cnt);\n    }\n    std::cout<<ans<<\"\\n\";\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nstruct Point{\n    double x,y;\n};\n\nvoid func(int N){\n\n    Point point[N];\n    double x_min = 100,y_min = 100,x_max = -1,y_max = -1;\n\n    for(int i = 0; i < N; i++){\n        scanf(\"%lf %lf\",&point[i].x,&point[i].y);\n        x_min = min(point[i].x,x_min);\n        y_min = min(point[i].y,y_min);\n        x_max = max(point[i].x,x_max);\n        y_max = max(point[i].y,y_max);\n    }\n\n    if(x_min > 1)x_min -= 0.04;\n    if(y_min > 1)y_min -= 0.04;\n    if(x_max < 9)x_max += 0.04;\n    if(y_max < 9)y_max += 0.04;\n\n    int count,max_count = 0;\n\n    for(double y = y_min; y <= y_max; y += 0.01){\n        for(double x = x_min; x <= x_max; x += 0.01){\n            count = 0;\n            for(int i = 0; i < N; i++){\n                if(sqrt((x-point[i].x)*(x-point[i].x)+(y-point[i].y)*(y-point[i].y)) <= 1.0)count++;\n            }\n            max_count = max(max_count,count);\n        }\n    }\n\n    printf(\"%d\\n\",max_count);\n}\n\n\nint main(){\n\n    int N;\n\n    while(true){\n        scanf(\"%d\",&N);\n        if(N == 0)break;\n\n        func(N);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#define EPS 10e-6\nusing namespace std;\ntypedef complex<double> xy_t;\nint n;\nxy_t points[301];\nint count_in(xy_t center)\n{\n  int ans=0;\n  for(int i=0;i<n;i++)\n  {\n    if (abs(center-points[i])<1+EPS)\n      ans++;\n  }\n  return ans;\n}\nxy_t ppdcl(xy_t a)\n{\n  return xy_t(a.imag(),-a.real());\n}\nxy_t delta_v(xy_t C1,xy_t C2)\n{\n  xy_t half=(C1-C2)*0.5;\n  double l=abs(half);\n  return ppdcl(half)*sqrt(1-l*l)*(1/l);\n}\nint main()\n{\n  while(1)\n  {\n    cin>>n;\n    if (n==0) break;\n    double x,y;\n    for(int i=0;i<n;i++)\n    {\n      cin>>x>>y;\n      points[i]=xy_t(x,y);\n    }\n    int maxn=-1;\n    for(int i=0;i<n;i++)\n    {\n      for(int j=i+1;j<n;j++)\n      {\n        if(abs(points[i]-points[j])<4+EPS)\n        {\n          xy_t mid_p=(points[i]+points[j])*0.5;\n          maxn=max(maxn,count_in(mid_p+delta_v(points[i],points[j])));\n          maxn=max(maxn,count_in(mid_p-delta_v(points[i],points[j])));\n        }\n      }\n    }\n    cout<<maxn<<endl;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble Dis(double x1, double y1, double x2, double y2);\nint main(void){\n\twhile(1){\n\t\tint n;\n\t\tint ans = 0;\n\t\tvector< pair<double, double> > p;\n\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tpair<double, double> t;\n\t\t\tcin >> t.first >> t.second;\n\t\t\tp.push_back(t);\n\t\t}\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t//中点\n\t\t\t\tdouble mpx = (p[i].first + p[j].first) / 2.0;\n\t\t\t\tdouble mpy = (p[i].second + p[j].second) / 2.0;\n\t\t\t\t//2点間の距離\n\t\t\t\tdouble d1 = Dis(p[i].first, p[i].second, p[j].first, p[j].second);\n\t\t\t\t//p[i]からp[j]へ向かうベクトル\n\t\t\t\tdouble v1x = (p[i].first - p[j].first) / d1;\n\t\t\t\tdouble v1y = (p[i].second - p[j].second) / d1;\n\t\t\t\t//中点から円の中心へ向かう単位ベクトル\n\t\t\t\tdouble v2x = -v1y;\n\t\t\t\tdouble v2y = v1x;\n\t\t\t\t//中心から円の中心へ向かうベクトルの長さ\n\t\t\t\tdouble d2 = sqrt(1.0 - (d1/2.0)*(d1/2.0));\n\n\t\t\t\t//円の中心の座標\n\t\t\t\tdouble cx = mpx + v2x * d2;\n\t\t\t\tdouble cy = mpy + v2y * d2;\n\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(Dis(cx, cy, p[k].first, p[k].second) <= 1.0)\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt > ans){\n\t\t\t\t\tans = cnt;\n\t\t\t\t}\n\n\t\t\t\tcx = mpx - v2x * d2;\n\t\t\t\tcy = mpy - v2y * d2;\n\n\t\t\t\tcnt = 0;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(Dis(cx, cy, p[k].first, p[k].second) <= 1.0)\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt > ans){\n\t\t\t\t\tans = cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\n\t}\n\t\n\treturn 0;\n}\n\ndouble Dis(double x1, double y1, double x2, double y2){\n\treturn sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define EPS (1e-4)\ntypedef complex<double> P;\n\nint main() {\n  int n;\n  while (cin >> n, n) {\n    vector<P> a(n);\n    for (auto &e : a) {\n      double x, y;\n      cin >> x >> y;\n      e.real(x);\n      e.imag(y);\n    }\n    int m = 1;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if (i != j && abs(a[j] - a[i]) < 2.0 + EPS) {\n          P u = (a[j] - a[i]) / 2.0;\n          P v = P(-u.imag(), u.real()) / abs(u) * sqrt(1.0 - pow(abs(u), 2));\n          vector<P> o = {a[i] + u + v, a[i] + u - v};\n          for (auto e : o) {\n            int t = 2;\n            for (int k = 0; k < n; k++) {\n              if (k != i && k != j) {\n                t += abs(a[k] - e) < 1.0 + EPS;\n              }\n            }\n            m = max(m, t);\n          }\n        }\n      }\n    }\n    cout << m << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\n\n/* 幾何の基本 */\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n// -1 => out\n//  0 => on\n//  1 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nPolygon convex_cut(const Polygon &ps, Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n\t\t\tQ.push_back(is_ll(l, m));\n\t}\n\treturn Q;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\nvector<Point>ps;\n\nint check(Point& center) {\n\tint num = 0;\n\tfor (int i = 0; i < ps.size(); ++i) {\n\t\tif (abs(ps[i] - center) <= 1) {\n\t\t\tnum++;\n\t\t}\n\t}\n\treturn num;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tif (N == 1) {\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tps.clear();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tlong double x, y; cin >> x >> y;\n\t\t\tps.push_back({ x,y });\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tif (abs(ps[i] - ps[j]) > 2)continue;\n\t\t\t\tLine l(ps[i], ps[j]);\n\t\t\t\tPoint center = (ps[i] + ps[j])*0.5l;\n\t\t\t\tPoint vec(imag(ps[i] - ps[j]), -real(ps[i] - ps[j]));\n\t\t\t\tlong double nl = sqrt(0.9999999 - norm(center - ps[i]));\n\t\t\t\tlong double oldl = abs(vec);\n\t\t\t\tvec *=nl / oldl;\n\t\t\t\tPoint checkcenter = center + vec;\n\t\t\t\tans = max(ans,check(checkcenter));\n\t\t\t\tcheckcenter = center - vec;\n\t\t\t\tans = max(ans, check(checkcenter));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(V) (V).begin(),(V).end()\nusing namespace std;\nusing ll = int64_t;\ntemplate <typename T> using V = vector<T>;\n\npair<long double, long double> lr_theta[300][300];\nll default_cnt[300];\npair<long double, long double> circle[300];\n\nlong double eps = 1e-5;\nconst long double inf = 5e15;\nauto error = make_pair(-inf, -inf);\n\nlong double length(long double x, long double y) { return sqrt(x * x + y * y); }\n\nll solve(ll N) {\n    for(ll i = 0; i < N; i++) {\n        long double x, y;\n        cin >> x >> y;\n        circle[i] = make_pair(x, y);\n    }\n\n    sort(circle, circle + N);\n\n    auto fix_theta = [](long double theta) { return theta < 0 ? theta + 2 * M_PI : theta; };\n\n    ll ans = 1;\n    for(ll i = 0; i < N; i++) {\n        V<pair<long double, bool>> lr_lis;\n        ll cur = 1;\n        long double xi, yi, xj, yj;\n        tie(xi, yi) = circle[i];\n        for(ll j = 0; j < N; j++) {\n            if(i == j) continue;\n            tie(xj, yj) = circle[j];\n            long double dx = xj - xi;\n            long double dy = yj - yi;\n            long double cen_len = length(dx, dy);\n            if(2.0 < cen_len) continue;\n            long double orx = -dy, ory = dx;\n            long double cur_orlen = length(orx, ory);\n            long double orlen = sqrt(1 - cen_len * cen_len / 4);\n            (orx *= orlen) /= cur_orlen;\n            (ory *= orlen) /= cur_orlen;\n            long double theta1 = fix_theta(atan2(dy / 2 + ory, dx / 2 + orx));\n            long double theta2 = fix_theta(atan2(dy / 2 - ory, dx / 2 - orx));\n            if(theta2 < theta1) swap(theta1, theta2);\n            if((theta1 + 2 * M_PI) - theta2 <= theta2 - theta1) {\n                cur++;\n                lr_lis.emplace_back(theta1, false);\n                lr_lis.emplace_back(theta2, true);\n            } else {\n                lr_lis.emplace_back(theta1, true);\n                lr_lis.emplace_back(theta2, false);\n            }\n        }\n        ans = max(ans, cur);\n        sort(ALL(lr_lis));\n        for(auto &&ele : lr_lis) {\n            cur += ele.second ? 1 : -1;\n            ans = max(ans, cur);\n        }\n    }\n    return ans;\n}\n\nint main() {\n    while(true) {\n        ll N;\n        cin >> N;\n        if(!N) break;\n        cout << solve(N) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> P;\nconst LL MOD = 1000000007LL;\nconst double EPS = 1e-10;\nstruct Point {\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\tPoint operator+(const Point &p) const {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator-(const Point &p) const {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator*(const double a) const {\n\t\treturn Point(x*a, y*a);\n\t}\n\tPoint operator/(double a) const {\n\t\treturn Point(x / a, y / a);\n\t}\n\tdouble abs() const {\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm() const {\n\t\treturn x*x + y*y;\n\t}\n\tbool operator<(const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator==(const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\ntypedef Point Vector;\nstruct Segment {\n\tPoint p1, p2;\n};\ntypedef Segment Line;\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\ntypedef vector<Point> Polygon;\ndouble norm(Vector a);\ndouble abs(Vector a);\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\nbool equals(double a, double b);\nbool isOrthogonal(Vector a, Vector b);\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2);\nbool isOrthogonal(Segment s1, Segment s2);\nbool isParallel(Vector a, Vector b);\nbool isParallel(Point a1, Point a2, Point b1, Point b2);\nbool isParallel(Segment s1, Segment s2);\nPoint project(Segment s, Point p);\nPoint reflect(Segment s, Point p);\nint ccw(Point p0, Point p1, Point p2);\ndouble getDistance(Point a, Point b);\ndouble getDistanceLP(Line l, Point p);\ndouble getDistanceSP(Segment s, Point p);\ndouble getDistance(Segment s1, Segment s2);\nbool intersect(Point p1, Point p2, Point p3, Point p4);\nbool intersect(Segment s1, Segment s2);\nbool intersect(Circle c, Line l);\nbool intersect(Circle c1, Circle c2);\nPoint getCrossPoint(Segment s1, Segment s2);\npair<Point, Point> getCrossPoints(Circle c, Line l);\ndouble arg(Vector p);\nVector polar(double a, double r);\npair<Point, Point> getCrossPoints(Circle c1, Circle c2);\ndouble norm(Vector a) {\n\treturn a.x*a.x + a.y*a.y;\n}\ndouble abs(Vector a) {\n\treturn sqrt(norm(a));\n}\ndouble dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\ndouble cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\nbool equals(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base*r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\ndouble getDistance(Point a, Point b) {\n\treturn abs(a - b);\n}\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nbool intersect(Circle c, Line l) {\n\treturn getDistanceLP(l, c.c) <= c.r;\n}\nbool intersect(Circle c1, Circle c2) {\n\treturn getDistance(c1.c, c2.c) <= c1.r + c2.r;\n}\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r*c.r - norm(pr - c.c));\n\treturn make_pair(pr + e*base, pr - e*base);\n}\ndouble arg(Vector p) {\n\treturn atan2(p.y, p.x);\n}\nVector polar(double a, double r) {\n\treturn Vector(cos(r)*a, sin(r)*a);\n}\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\tassert(intersect(c1, c2));\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tPoint p[300];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = Point(x, y);\n\t\t}\n\t\tint ans = 1;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tVector d = p[j] - p[i];\n\t\t\t\tif (d.abs() > 2.0) continue;\n\t\t\t\tPoint m = p[i] + d / 2.0;\n\t\t\t\tVector r = Vector(-d.y, d.x);\n\t\t\t\tr = r / r.abs()*sqrt(1 - pow(d.abs() / 2.0, 2));\n\t\t\t\tPoint p1 = m + r;\n\t\t\t\tPoint p2 = m - r;\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tint cnt2 = 0;\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif ((p[k] - p1).abs() <= 1) cnt1++;\n\t\t\t\t\tif ((p[k] - p2).abs() <= 1) cnt2++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, max(cnt1, cnt2));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        vector<long double> xs(n),ys(n);\n        rep(i,0,n) cin >> xs[i] >> ys[i];\n\n        auto count=[&](const long double x,const long double y){\n            int res=0;\n            rep(i,0,n) if((xs[i]-x)*(xs[i]-x)+(ys[i]-y)*(ys[i]-y)<=1+eps) ++res;\n            return res;\n        };\n\n        int ans=0;\n        rep(i,0,201){\n            const long double y=10.*i/200;\n            rep(j,0,n){\n                const long double tmp=1-(ys[j]-y)*(ys[j]-y);\n                if(tmp<0) continue;\n                const long double x1=xs[j]-sqrtl(tmp),x2=xs[j]+sqrt(tmp);\n                ans=max({ans,count(x1,y),count(x2,y)});\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Circle and Points\n\n// 平面走査ごり押し\n\n#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle().crosspoint()の戻り値\nusing namespace std;\n\nconst double EPS = 1e-12;\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\npublic:\n    double x, y;\n    Point(double a = 0.0, double b = 0.0) :x(a), y(b) {};\n    bool operator== (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    Point operator+(const Point&) const;\n    Point operator-(const Point&) const;\n    Point operator-() const;\n    Point times(double) const;\n    Point& operator=(const Point&);\n    Point& operator+=(const Point&);\n    Point& operator-=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    Point projection(const Line&) const;\n    Point reflection(const Line&) const;\n    int ccw(const Point&, const Point&) const;              // a.ccw(b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n};\nclass Segment {\npublic:\n    Point source, target;\n    Segment(Point a = Point(), Point b = Point()) :source(a), target(b) {};\n    Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n};\nclass Line {\npublic:\n    Point source, target;\n    Line(Point a = Point(), Point b = Point()) :source(a), target(b) {};\n    Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    Point projection(const Point&) const;\n    Point reflection(const Point&) const;\n    Point crosspoint(const Line&) const;\n};\nclass Circle {\npublic:\n    double x, y, r;\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :x(a), y(b), r(c) {};\n    Point point() const;\n    double distance(const Point&) const;                    // 円の中心と点の距離\n    double distance(const Circle&) const;                   // 円の中心同士の距離\n    bool include(const Point&) const;                       // 点を含むか\n    bool include(const Circle&) const;                      // 円を含むか\n    bool intersect(const Circle&) const;\n    vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x == p.x && y == p.y;}\nbool Point::operator<(const Point &p) const {return x != p.x ? x < p.x : y < p.y;}\nbool Point::operator>(const Point &p) const {return x != p.x ? x > p.x : y > p.y;}\nbool Point::operator<=(const Point &p) const {return x != p.x ? x < p.x : y <= p.y;}\nbool Point::operator>=(const Point &p) const {return x != p.x ? x > p.x : y >= p.y;}\nPoint Point::operator+(const Point& p) const {return Point(x + p.x, y + p.y);}\nPoint Point::operator-(const Point& p) const {return Point(x - p.x, y - p.y);}\nPoint Point::operator-() const {return Point(-x, -y);}\nPoint Point::times(double d) const {return Point(x * d, y * d);}\nPoint& Point::operator=(const Point& p) {x = p.x; y = p.y; return *this;}\nPoint& Point::operator+=(const Point& p) {x += p.x; y += p.y; return *this;}\nPoint& Point::operator-=(const Point& p) {x -= p.x; y -= p.y; return *this;}\ndouble Point::dot(const Point& p) const {return x * p.x + y * p.y;}\ndouble Point::cross(const Point& p) const {return x * p.y - y * p.x;}\ndouble Point::abs() const {return hypot(x, y);}\ndouble Point::norm() const {return x * x + y * y;}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nPoint Point::projection(const Line& l) const {return l.projection(*this);}\nPoint Point::reflection(const Line& l) const {return l.reflection(*this);}\nint Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > 0.0) return 1;\n    if(v1.cross(v2) < 0.0) return -1;\n    if(v1.dot(v2) < 0.0) return 2;\n    if(v1.norm() < v2.norm()) return -2;\n    return 0;\n}\n// Segment\nLine Segment::line() const {return Line(source, target);}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    double a = source.distance(p);\n    double b = target.distance(p);\n    return a < b ? a : b;\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source);\n    double b = distance(s.target);\n    double c = s.distance(source);\n    double d = s.distance(target);\n    a = a < b ? a : b;\n    a = a < c ? a : c;\n    return a < d ? a : d;\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {\n    return source.distance(p) + target.distance(p) - target.distance(source) <= EPS;\n}\nbool Segment::intersect(const Segment& s) const {\n    bool a = s.source.ccw(s.target, source) * s.source.ccw(s.target, target) <= EPS;\n    bool b = source.ccw(target, s.source) * source.ccw(target, s.target) <= EPS;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\n// Line\nSegment Line::segment() const {return Segment(source, target);}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source);\n    double b = distance(s.target);\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source);}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source - p;\n    Point v2 = target - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target - source;\n    Point v2 = s.source - source;\n    Point v3 = s.target - source;\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target - source;\n    Point v2 = l.target - l.source;\n    Point v3 = l.source - source;\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nPoint Line::projection(const Point& p) const {\n    Point v1 = p - source;\n    Point v2 = source - target;\n    return Point(source + v2.times(v1.dot(v2) / v2.norm()));\n}\nPoint Line::reflection(const Point& p) const {\n    return p + (projection(p) - p).times(2.0);\n}\nPoint Line::crosspoint(const Line& l) const {\n    Point v1 = target - source;\n    Point v2 = l.target - l.source;\n    Point v3 = target - l.source;\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source;\n    return l.source + v2.times(b / a);\n}\n// Circle\nPoint Circle::point() const {return Point(x, y);}\ndouble Circle::distance(const Point& p) const {return point().distance(p);}\ndouble Circle::distance(const Circle& c) const {return point().distance(c.point());}\nbool Circle::include(const Point& p) const {return distance(p) - r <= EPS;}\nbool Circle::include(const Circle& c) const {return distance(c) - (r - c.r) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return distance(c) - r - c.r <= EPS;}\nvector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y - y, c.x - x);\n    double d = distance(c);\n    double add = acos((d * d + r * r - c.r * c.r) / (2.0 * d * r));\n    vector<Point> result;\n    result.push_back(Point(x + r * cos(angle + add), y + r * sin(angle + add)));\n    result.push_back(Point(x + r * cos(angle - add), y + r * sin(angle - add)));\n    return result;\n}\n\nint main() {\n    int n;\n    while(cin>>n, n) {\n        vector<Circle> circle;\n        vector<Circle> crosspoint;\n        for(int i = 0; i < n; i++) {\n            double x, y;\n            cin>>x>>y;\n            circle.push_back(Circle(x, y, 1.0));\n        }\n        for(int i = 0; i < n - 1; i++) {\n            for(int j = i + 1; j < n; j++) {\n                if(!circle[i].intersect(circle[j])) continue;\n                vector<Point> p = circle[i].crosspoint(circle[j]);\n                crosspoint.push_back(Circle(p[0].x, p[0].y, 1.0));\n                crosspoint.push_back(Circle(p[1].x, p[1].y, 1.0));\n            }\n        }\n        int answer = 0;\n        for(int i = 0; i < crosspoint.size(); i++) {\n            int count = 0;\n            for(int j = 0; j < n; j++) {\n                if(crosspoint[i].include(circle[j].point())) count++;\n            }\n            if(answer < count) answer = count;\n        }\n        cout<<answer<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, const Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\ntypedef Line Seg;\nostream& operator<<(ostream& os, const Line& line)\n{\n    return os << \"(\" << line.first << \", \" << line.second << \")\";\n}\n\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, const Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\n\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021, AOJ0187\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool intersect_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool intersect_SP(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\n// AOJ1183\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\n// AOJ0187, AOJ1183\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n    const gtype feps = 1e-9;\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -feps\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -feps)\n\t\t|| intersect_SP(seg1, seg2.first)\n\t\t|| intersect_SP(seg1, seg2.second)\n\t\t|| intersect_SP(seg2, seg1.first)\n\t\t|| intersect_SP(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\n// AOJ1157\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"ip_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n    if (a < 1e-9 && b < 1e-9)\n    {\n        cerr << \"same line\" << endl;\n        exit(1);\n    }\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"ip_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n// 回転\nPoint rotate(const Point& p, gtype angle)\n{\n\tgtype c = cos(angle), s = sin(angle);\n\treturn Point(p.real() * c - p.imag() * s, p.real() * s + p.imag() * c);\n}\nPoint rotate(const Point& p, gtype angle, const Point& base)\n{\n\tPoint t = p - base;\n\treturn rotate(t, angle) + base;\n}\n\n// 点から直線に垂線を下ろした点\n// AOJ0081(by reflection), AOJ1183(by ip_CL)\nPoint projection(const Line& line, const Point& p)\n{\n\tPoint a = line.first - line.second;\n\tgtype t = dot(p - line.first, a) / norm(a);\n\treturn line.first + t * a;\n}\n\n// 線対称な点\n// AOJ0081\nPoint reflection(const Line& line, const Point& p)\n{\n\treturn p + ((gtype)2) * (projection(line, p) - p);\n}\n\n\n// 長方形\nstruct Rect\n{\n\tPoint low, high;\n\tRect(Point low, Point high)\n\t\t: low(low), high(high) { }\n\tRect() { }\n\n\tgtype x1() const { return low.real(); }\n\tgtype x2() const { return high.real(); }\n\tgtype y1() const { return low.imag(); }\n\tgtype y2() const { return high.imag(); }\n\n    Point top_left() const { return Point(x1(), y2()); }\n    Point bottom_left() const { return Point(x1(), y1()); }\n    Point bottom_right() const { return Point(x2(), y1()); }\n    Point top_right() const { return Point(x2(), y2()); }\n\n    G to_g() const\n    {\n        G res;\n        res.push_back(top_left());\n        res.push_back(bottom_left());\n        res.push_back(bottom_right());\n        res.push_back(top_right());\n        return res;\n    }\n};\n// 境界交差はfalse\nbool intersect_rect_area(const Rect& a, const Rect& b)\n{\n\tbool x = a.low.real() < b.high.real() && a.high.real() > b.low.real();\n\tbool y = a.low.imag() < b.high.imag() && a.high.imag() > b.low.imag();\n\treturn x && y;\n}\n// allow segment\nbool intersect_rect(const Rect& a, const Rect& b)\n{\n\tbool x = !(a.low.real() > b.high.real()) && !(a.high.real() < b.low.real());\n\tbool y = !(a.low.imag() > b.high.imag()) && !(a.high.imag() < b.low.imag());\n\treturn x && y;\n}\nvector<Point> corner(const Rect& r)\n{\n\tgtype x[] = { r.low.real(), r.high.real() };\n\tgtype y[] = { r.low.imag(), r.high.imag() };\n\tvector<Point> res;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tres.push_back(Point(x[i], y[j]));\n\treturn res;\n}\n\n\n// 凸包\n// AOJ0068\nbool allow_line(res_ccw r) { return r < 0; }\nbool strict(res_ccw r) { return r <= 0; }\nG convex_hull(vector<Point> ps, bool f(res_ccw) = strict)\n{\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int n = ps.size(), k = 0;\n    G res;\n    res.resize(2 * n);\n    for (int i = 0; i < n; ++i)\n    {\n        while (k >= 2 && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; --i)\n    {\n        while (k >= t && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    res.resize(k - 1);\n    return res;\n}\n\n// 凸包判定, 反時計回り\n// AOJ0035\nbool is_convex(const G& g)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n    {\n        if (ccw(g[(i - 1 + g.size()) % g.size()], g[i], g[(i + 1) % g.size()]) < 0)\n            return false;\n    }\n    return true;\n}\n\n// AOJ0079, AOJ0187\ngtype area(const G& g)\n{\n\tgtype s = 0;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t\ts += cross(g[i], g[(i + 1) % g.size()]);\n\treturn abs(s / 2);\n}\n\n// AOJ0012, AOJ0143\nenum res_contain { OUT, ON, IN };\nres_contain contain_GP(const G& g, const Point& p)\n{\n\tbool in = false;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t{\n\t\tPoint a = g[i] - p, b = g[(i + 1) % g.size()] - p;\n\t\tif (a.imag() > b.imag())\n\t\t\tswap(a, b);\n\t\tif ((a.imag() <= 0 && 0 < b.imag()) && cross(a, b) < 0)\n\t\t\tin = !in;\n\t\tif (intersect_SP(Line(g[i], g[(i + 1) % g.size()]), p))\n\t\t\treturn ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n// a contains b?\n// AOJ0214\nbool contain_GG(const G& a, const G& b)\n{\n    rep(i, b.size())\n        if (contain_GP(a, b[i]) == OUT)\n            return false;\n    return true;\n}\n// AOJ0214\nbool intersect_GG(const G& a, const G& b)\n{\n    rep(i, a.size()) rep(j, b.size())\n        if (intersect_SS(Line(a[i], a[(i + 1) % a.size()]), Line(b[j], b[(j + 1) % b.size()])))\n            return true;\n    return contain_GG(a, b) || contain_GG(b, a);\n}\n\n// AOJ1157(gは長方形)\nbool intersect_GS(const G& g, const Seg& s)\n{\n    if (contain_GP(g, s.first) || contain_GP(g, s.second))\n        return true;\n    rep(i, g.size())\n        if (intersect_SS(Seg(g[i], g[(i + 1) % g.size()]), s))\n            return true;\n    return false;\n}\nbool intersect_SG(const Seg& s, const G& g)\n{\n    return intersect_GS(g, s);\n}\n\n// 円\n\n// AOJ0023(feps = 0)\nenum res_pos_CC\n{\n    not_intersect,\n    intersect,\n\n    tangent,\n\n    a_in_b,\n    b_in_a,\n};\nres_pos_CC pos_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n    gtype d = abs(a.p - b.p);\n    if (d + feps > a.r + b.r)\n        return not_intersect;\n    else\n    {\n        if (d + feps < a.r - b.r)\n            return b_in_a;\n        else if (d + feps < b.r - a.r)\n            return a_in_b;\n        else\n            return intersect;\n    }\n}\n\nbool intersect_GC(const G& g, const Circle& c)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n        if (dist_SP(Line(g[i], g[(i + 1) % g.size()]), c.p) < c.r + 1e-9)\n            return true;\n    return contain_GP(g, c.p) != OUT;\n}\n\n// AOJ0129\nres_contain contain_CP(const Circle& c, const Point& p)\n{\n    const gtype feps = 1e-9;\n    gtype d = abs(c.p - p);\n    if (d > c.r + feps)\n        return OUT;\n    else if (d < c.r + feps)\n        return IN;\n    else\n        return ON;\n}\n\n// 円周と線分が交わるか\n// AOJ0129\nbool intersect_CS(const Circle& c, const Seg& seg)\n{\n    return dist_SP(seg, c.p) < c.r + 1e-9;\n}\nbool intersect_SC(const Seg& seg, const Circle& c)\n{\n    return intersect_CS(c, seg);\n}\n\n// AOJ2201\ngtype dist_CL(const Circle& c, const Line& line)\n{\n    return max<gtype>(0, dist_LP(line, c.p) - c.r);\n}\ngtype dist_LC(const Line& line, const Circle& c)\n{\n    return dist_CL(c, line);\n}\n\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n\n    if (pos_CC(a, b) != intersect)\n        return vector<Point>();\n    // if (abs(a.p - b.p) < a.r + b.r - feps)\n    //     return vector<Line>();\n\n    Point ab = b.p - a.p;\n    gtype t = (norm(ab) + a.r*a.r - b.r*b.r) / (2 * abs(ab));\n    Point u = ab / abs(ab);\n    Point q = a.p + t * u;\n\n    gtype h = sqrt(max<gtype>(0, a.r*a.r - t*t));\n    Point v = Point(0, h) * u;\n\n    vector<Point> res;\n    res.push_back(q + v);\n    if (h > feps)\n        res.push_back(q - v); // 2点\n    return res;\n}\n\n// AOJ1183\nvector<Point> ip_CL(const Circle& c, const Line& line)\n{\n    const gtype feps = 1e-9;\n\n    Point p = projection(line, c.p);\n    Point cp = p - c.p;\n    gtype d = abs(cp);\n    if (d > c.r + feps)\n        return vector<Point>();\n\n    gtype t = sqrt(max<gtype>(0, c.r*c.r - d*d));\n    Point u = line.second - line.first;\n    Point v = u / abs(u) * t;\n\n    vector<Point> res;\n    res.push_back(p + v);\n    if (t > feps)\n        res.push_back(p - v); // 2点\n    return res;\n}\n\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_CS(const Circle& c, const Seg& seg)\n{\n    vector<Point> ip = ip_CL(c, seg);\n    vector<Point> res;\n    rep(i, ip.size())\n        if (intersect_SP(seg, ip[i]))\n            res.push_back(ip[i]);\n    return res;\n}\n\n// 点pを通るcの接線\n// AOJ 2201(円が重ならないケースしかない)\nvector<Line> tangent_CP(const Circle& c, const Point& p)\n{\n    const gtype feps = 1e-8;\n\n    Point vec = c.p - p;\n    gtype d = abs(vec);\n    if (d < c.r)\n        return vector<Line>();\n\n    gtype t = sqrt(max<gtype>(0, d*d - c.r*c.r));\n    Point rota = Point(t / d, c.r / d);\n    rota *= 1; // 線分の長さが0にならないように\n\n    vector<Line> res;\n    res.push_back(Line(p, p + vec * rota));\n    if (d > feps)\n        res.push_back(Line(p, p + vec * conj(rota)));\n    return res;\n}\n\n// 共通外接線\n// AOJ 2201(円が重ならないケースしかない)\nvector<Line> tangent_ext_CC(const Circle& a, const Circle& b)\n{\n    if (abs(a.p - b.p) < abs(a.r - b.r))\n        return vector<Line>(); // 内包\n    \n    if (abs(a.r - b.r) > 1e-8)\n    {\n        Point ip = (-a.p * b.r + b.p * a.r) / (a.r - b.r);\n        return tangent_CP(a, ip);        \n    }\n    else\n    {\n        vector<Line> res;\n        Point v = b.p - a.p;\n        v /= abs(v);\n        v *= Point(0, a.r);\n        res.push_back(Line(a.p + v, b.p + v));\n        res.push_back(Line(a.p - v, b.p - v));\n        return res;\n    }\n}\n// 共通内接線\n// AOJ 2201(円が重ならないケースしかない)\nvector<Line> tangent_in_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-8;\n    if (abs(a.p - b.p) < a.r + b.r - feps)\n        return vector<Line>();\n    else\n    {\n        Point ip = (a.p * b.r + b.p * a.r) / (a.r + b.r);\n        return tangent_CP(a, ip);\n    }\n}\n// 共通接線\n// AOJ 2201(円が重ならないケースしかない)\nvector<Line> tangent_CC(const Circle& a, const Circle& b)\n{\n    vector<Line> res;\n    vector<Line> ext = tangent_ext_CC(a, b);\n    vector<Line> in = tangent_in_CC(a, b);\n    rep(i, ext.size())\n        res.push_back(ext[i]);\n    rep(i, in.size())\n        res.push_back(in[i]);\n    return res;\n}\n\n// 半径rで点a, bを通る円\nvector<Circle> circle_by_PP(const Point& a, const Point& b, gtype r)\n{\n    Point v = 0.5 * (b - a);\n    gtype t = sqrt(max<gtype>(0, r*r - norm(v))); \n    Point u = t / abs(v) * Point(0, 1) * v;\n\n   vector<Circle> res;\n   res.push_back(Circle(a + v + u, r));\n   res.push_back(Circle(a + v - u, r));\n   return res;\n}\n\n\n/////////////////// \n\nint main()\n{\n    int n;\n    while (cin >> n, n)\n    {\n        Point p[333];\n        rep(i, n)\n            cin >> p[i];\n        \n        int res = 1;\n        rep(i, n) rep(j, i)\n        {\n            vector<Circle> c = circle_by_PP(p[i], p[j], 1);\n            foreach (it, c)\n            {\n                int r = 0;\n                rep(k, n)\n                    if (contain_CP(*it, p[k]))\n                        ++r;\n                chmax(res, r);\n            }\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\nclass Line {\npublic:\n\tPoint a, b;\n};\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2 * d);\n\tld dfr = c1.r*c1.r - rc * rc;\n\tif (abs(dfr) < eps)dfr = 0.0;\n\tif (dfr < 0.0)return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0)res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\nld dis(Point x, Point y) {\n\treturn sqrt(dot(y - x, y - x));\n}\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tPoint a[300];\n\t\trep(i, n) {\n\t\t\tld x, y; cin >> x >> y; a[i] = { x,y };\n\t\t}\n\t\tint ma = 0;\n\t\trep(i, n) {\n\t\t\tRep(j, i + 1, n) {\n\t\t\t\tCircle s = { a[i],1.0 };\n\t\t\t\tCircle t = { a[j],1.0 };\n\t\t\t\tvector<Point> v = is_cc(s, t);\n\t\t\t\tif (v.size() < 2)continue;\n\t\t\t\tint cnt = 0;\n\t\t\t\trep(k, n) {\n\t\t\t\t\tif (dis(a[k], v[0]) <= 1.0+eps)cnt++;\n\t\t\t\t}\n\t\t\t\tma = max(ma, cnt); cnt = 0;\n\t\t\t\trep(k, n) {\n\t\t\t\t\tif (dis(a[k], v[1]) <= 1.0+eps)cnt++;\n\t\t\t\t}\n\t\t\t\tma = max(ma, cnt);\n\t\t\t}\n\t\t}\n\t\tcout << ma << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nconst ll mod = 1000000007;\n//const ll mod = 998244353;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nstruct Point {\n  ld x, y;\n\n  Point(ld x = 0, ld y = 0): x(x), y(y) {}\n\n  Point operator + (Point &p) {\n    return Point(x + p.x, y + p.y);\n  }\n\n  Point operator - (Point &p) {\n    return Point(x - p.x, y - p.y);\n  }\n\n  Point operator * (ld k) {\n    return Point(x * k, y * k);\n  }\n\n  Point operator / (ld k) {\n    return Point(x / k, y / k);\n  }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\n\nld norm(Point p) {\n  return p.x * p.x + p.y * p.y;\n}\n\nld dist(Point p) {\n  return sqrt(norm(p));\n}\n\nld dot(Point p1, Point p2) {\n  return p1.x * p2.x + p1.y * p2.y;\n}\n\nld cross(Point p1, Point p2) {\n  return p1.x * p2.y - p1.y * p2.x;\n}\n\nPoint rotate(Point p, ld theta) {\n  return Point(p.x * cos(theta) - p.y * sin(theta), p.x * sin(theta) + p.y * cos(theta));\n}\n\n//1:反時計回り\n//-1:時計回り\n//2:p2, p0, p1の順で同一直線上\n//-2:p0, p1, p2の順\n//0:p2が線分p0, p1上\nint ccw(Point p0, Point p1, Point p2) {\n  Point v1 = p1 - p0, v2 = p2 - p0;\n  if (cross(v1, v2) > 0) return 1;\n  else if (cross(v1, v2) < 0) return -1;\n  else if (dot(v1, v2) < 0) return 2;\n  else if (norm(v1) < norm(v2)) return -2;\n  else return 0;\n}\n\n//線分p1, p2がp3, p4と交差するか\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\n//直線p2-p1と点p3の距離\nld getDistanceLP(Point p1, Point p2, Point p3) {\n  return fabs(cross(p2-p1, p3-p1) / dist(p2-p1));\n}\n\n//線分s(p2-p1)と点p3の距離\nld getDistanceSP(Point p1, Point p2, Point p3) {\n  if (dot(p2-p1, p3-p1) < 0) return dist(p3-p1);\n  else if (dot(p1-p2, p3-p2) < 0) return dist(p3-p2);\n  else return getDistanceLP(p1, p2, p3);\n}\n\n//線分s1(p2-p1)と線分s2(p4-p3)の距離\nld getDistanceTS(Point p1, Point p2, Point p3, Point p4) {\n  if (intersect(p1, p2, p3, p4)) return 0;\n  ld ans = INF;\n  ans = min(ans, getDistanceSP(p1, p2, p3));\n  ans = min(ans, getDistanceSP(p1, p2, p4));\n  ans = min(ans, getDistanceSP(p3, p4, p1));\n  ans = min(ans, getDistanceSP(p3, p4, p2));\n  return ans;\n}\n\nvector<Point> convex_hull(vector<Point>& ps, int n) {\n  sort(ps.begin(), ps.end());\n  int k = 0;\n  vector<Point> qs(2 * n);\n  rep(i, n) {\n    while (k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  for (int i = n - 2, t = k; i >= 0; i--) {\n    while (k > t && (cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) <= 0)) k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k - 1);\n  return qs;\n}\n\n//円\nstruct Circle {\n  Point p;\n  ld r;\n\n  Circle() {}\n  Circle(Point p, ld r): p(p), r(r) {}\n};\n\n//２円の交点\nvector<Point> getIntersections(Circle c1, Circle c2) {\n  ld d = dist(c2.p - c1.p);\n  ld rc = (c1.r * c1.r + d * d - c2.r * c2.r) / (2 * d);\n  ld rs = sqrt(c1.r * c1.r - rc * rc);\n  Point e1 = (c2.p - c1.p) / d;\n  Point e2 = rotate(e1, M_PI / 2) * rs;\n  Point e3 = rotate(e1, -M_PI / 2) * rs;\n  e1 = e1 * rc;\n  Point a = c1.p + e1 + e2;\n  Point b = c1.p + e1 + e3;\n  return {a, b};\n}\n\nint n;\nPoint p[305];\nCircle c[305];\n\nvoid solve() {\n  rep(i, n) c[i] = {p[i], 1};\n  int ans = 1;\n  rep(i, n) {\n    int res = 0;\n    rep(j, n) {\n      if (dist(p[i] - p[j]) < 1 + EPS) res++;\n    }\n    chmax(ans, res);\n  }\n  rep(i, n) {\n    rep(j, i) {\n      if (dist(p[i] - p[j]) > 2 + EPS) continue;\n      vector<Point> vs = getIntersections(c[i], c[j]);\n      for (Point v: vs) {\n        int res = 0;\n        rep(k, n) {\n          if (dist(v - p[k]) < 1 + EPS) res++;\n        }\n        chmax(ans, res);\n      }\n    }\n  }\n  cout << ans << '\\n';\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(25);\n\n  while (cin >> n, n) {\n    rep(i, n) cin >> p[i].x >> p[i].y;\n\n    solve();\n  }\n\n  \n\n\n\n\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef double Real;\n\nReal eps = 1e-9;\n\nReal add(Real a, Real b) {\n    if (abs(a+b) < eps * (abs(a)+abs(b))) return 0;\n    return a+b;\n}\n\nbool equal(Real a, Real b) {\n    return add(a, -b) == 0;\n}\n\nstruct P {\n    Real x, y;\n    P() {}\n    P(Real x, Real y) : x(x), y(y) {}\n    P operator+(P p) const {return P(add(x, p.x), add(y, p.y));}\n    P operator-(P p) const {return P(add(x, -p.x), add(y, -p.y));}\n    P operator*(Real d) const {return P(x*d, y*d);}\n    Real dot(P p) const {return add(x*p.x, y*p.y);} // ??????\n    Real det(P p) const {return add(x*p.y, -y*p.x);} // ??????\n    Real dist(P p) const {return sqrt((x-p.x)*(x-p.x) + (y-p.y)*(y-p.y));} // ?????¢\n    void normalize() {Real d = sqrt(x*x+y*y); x /= d; y /= d;} // ??£??????\n    bool operator<(const P& rhs) const {\n        if (x != rhs.x) return x < rhs.x;\n        return y < rhs.y;\n    }\n    bool operator==(const P& rhs) const {\n        return equal(x, rhs.x) && equal(y, rhs.y);\n    }\n};\nconst int MAXN = 333;\nP pnt[MAXN];\nint N;\n\nint calc(P center) {\n\tint ret = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tP vec = pnt[i]-center;\n\t\tif (vec.dot(vec) < 1+eps) {\n\t\t\tret++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (cin >> N) {\n    \tif (N==0) break;\n    \tfor (int i = 0; i < N; i++) \n    \t\tcin >> pnt[i].x >> pnt[i].y;\n    \tint ans = min(2, N);\n    \tfor (int i = 0; i < N; i++) for (int j = i+1; j < N; j++) {\n    \t\tif (pnt[i].dist(pnt[j]) > 2) continue;\n    \t\t// diff ?????????\n    \t\tP vec = pnt[j]-pnt[i];\n    \t\t// vec ????????´????????????????????????\n    \t\tP n = P(vec.y, -vec.x);\n    \t\tn.normalize();\n    \t\tvec = vec*0.5;\n    \t\tdouble len = sqrt(1-vec.dot(vec));\n    \t\tP cand1 = pnt[i] + vec + n*len;\n    \t\tP cand2 = pnt[i] + vec - n*len;\n    \t\tans = max(ans, calc(cand1));\n    \t\tans = max(ans, calc(cand2));\n    \t}\n    \tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D[] points = new Point2D[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tpoints[i] = new Point2D(sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tint max = 0;\n\t\t\t\n\t\t\tfor(int fst = 0; fst < n; fst++){\n\t\t\t\tfor(int snd = 0; snd < n; snd++){\n\t\t\t\t\tPoint2D[] cross = Point2D.cross_ss(points[fst], 1, points[snd], 1);\n\t\t\t\t\t\n\t\t\t\t\tfor(Point2D cross_c : cross){\n\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\t\tif(cross_c.dist(points[i]) <= 1.0 + Point2D.EPS){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tmax = Math.max(max, count);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t\t\n\t}\n}\n\nclass Point2D {\n    public double x;\n    public double y;\n \n    public static final double EPS = 1e-4;\n \n    public Point2D(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n \n    public Point2D(Point2D point) {\n        this.x = point.x;\n        this.y = point.y;\n    }\n \n    public String toString() {\n        return x + \",\" + y;\n    }\n \n    @Override\n    public boolean equals(Object o) {\n        if (o instanceof Point2D) {\n            Point2D another = (Point2D) o;\n            if (this.x - EPS < another.x && this.x + EPS > another.x\n                    && this.y - EPS < another.y && this.y + EPS > another.y) {\n                return true;\n            }\n             \n            return false;\n \n            // return this.x == another.x && this.y == another.y;\n        }\n        return false;\n    }\n \n    public Point2D add(double x, double y) {\n        return new Point2D(this.x + x, this.y + y);\n    }\n \n    public Point2D sub(double x, double y) {\n        return add(-x, -y);\n    }\n \n    public Point2D add(Point2D another) {\n        return add(another.x, another.y);\n    }\n \n    public Point2D sub(Point2D another) {\n        return sub(another.x, another.y);\n    }\n \n    public Point2D mul(double d) {\n        return new Point2D(this.x * d, this.y * d);\n    }\n \n    public Point2D div(double d) {\n        return new Point2D(this.x / d, this.y / d);\n    }\n \n    public double dot(double x, double y) {\n        return this.x * x + this.y * y;\n    }\n \n    public double dot(Point2D another) {\n        return dot(another.x, another.y);\n    }\n \n    public double cross(double x, double y) {\n        return this.x * y - this.y * x;\n    }\n \n    public double cross(Point2D another) {\n        return cross(another.x, another.y);\n    }\n \n    public double dist(double x, double y) {\n        return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n                * (this.y - y));\n    }\n \n    public double dist(Point2D another) {\n        return dist(another.x, another.y);\n    }\n \n    public double dist_o() {\n        return dist(0, 0);\n    }\n \n    public Point2D unit() {\n        return div(dist_o());\n    }\n \n    public boolean pol(Point2D start, Point2D end) {\n        return end.sub(start).cross(this.sub(start)) < EPS;\n    }\n \n    public boolean pos(Point2D start, Point2D end) {\n        return (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n    }\n \n    public double pld(Point2D start, Point2D end) {\n        return Math.abs((end.sub(start).cross(this.sub(start)))\n                / end.sub(start).dist_o());\n    }\n \n    public double psd(Point2D start, Point2D end) {\n        if (end.sub(start).dot(this.sub(start)) < EPS) {\n            return this.dist(start);\n        } else if (start.sub(end).dot(this.sub(end)) < EPS) {\n            return this.dist(end);\n        } else {\n            return end.sub(start).cross(this.sub(start)) / end.dist(start);\n        }\n    }\n \n    public static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS)\n                && (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n    }\n \n    public static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return a1.sub(a2).cross(b1.sub(b2)) < EPS;\n    }\n \n    public static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D b = b2.sub(b1);\n        double d1 = Math.abs(b.cross(a1.sub(b1)));\n        double d2 = Math.abs(b.cross(a2.sub(b1)));\n        double t = d1 / (d1 + d2);\n        Point2D a = a2.sub(a1), v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D a = a2.sub(a1);\n        Point2D b = b2.sub(b1);\n        double t = b.cross(b1.sub(a1)) / b.cross(a);\n        Point2D v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n            double r2) {\n        double dis = p1.dist(p2);\n \n        if (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n            return new Point2D[0]; // same\n        }\n \n        if (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n            Point2D tmp = p2.sub(p1);\n            tmp = tmp.mul(r1 / tmp.dist_o());\n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis + EPS > r1 + r2) {\n            return new Point2D[0]; // out\n        }\n \n        double dis_m = Math.abs(r1 - r2);\n \n        if (dis_m + EPS > dis && dis_m - EPS < dis) {\n            Point2D tmp = null;\n            if (r1 > r2) {\n                tmp = p2.sub(p1);\n            } else {\n                tmp = p1.sub(p2);\n            }\n \n            double min = Math.min(r1, r2);\n \n            tmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n \n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis_m + EPS > dis) {\n            return new Point2D[0]; // inner\n        } else {\n            Point2D ret[] = new Point2D[2];\n \n            double theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n                    / (2 * dis * r1));\n            double a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n \n            ret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n                    * Math.sin(a + theta) + p1.y);\n            ret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n                    * Math.sin(a - theta) + p1.y);\n            return ret;\n        }\n    }\n \n    public void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n            Point2D ans[]) {\n        if (c.pld(start, end) > r + EPS)\n            return;\n        Point2D v = end.sub(start).unit();\n        double delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n                - start.dist(c) * start.dist(c) + r * r;\n        double t = -v.dot(start.sub(c));\n        double s = Math.sqrt(delta);\n        ans[0] = start.add(v.mul(t + s));\n        ans[1] = start.add(v.mul(t + s));\n    }\n \n    public Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n        Point2D v = b.sub(a).unit();\n        v = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n                (-1) * v.y, v.x);\n        return v.mul(p.pld(a, b));\n    }\n \n    public double area(Point2D a, Point2D b, Point2D c) {\n        return Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n    }\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\ntypedef double D;\nD EPS = 1e-8;\n\ntypedef complex<D> P;\nstruct L{\n    P a, b;\n    P vec(){ return b - a; }\n};\ntypedef vector<P> Pol;\n\nint sig(D a) { return a < -EPS ? -1 : a > EPS ? 1 : 0; }\nD dot(P a, P b){ return a.X * b.X + a.Y * b.Y; }\nD cross(P a, P b){ return a.X * b.Y - a.Y * b.X; }\n\nD area(Pol pol) {\n    int n = pol.size();\n    D res = 0;\n    REP(i, n) {\n        res += cross(pol[i], pol[ (i + 1) % n ]);\n    }\n    return abs(res) / 2.0;\n}\n\n// 2点a, bを通る半径rの円の中心\nvector<P> tc2(P a, P b, D r){\n    vector<P> res;\n\n    D d = abs(b - a);\n    if(sig(d - 2 * r) > 0) return res;\n\n    P mid = 0.5 * (a + b);\n    P dir = polar(sqrt(r * r - d * d / 4), arg(b - a) + M_PI / 2);\n    res.push_back(mid + dir);\n    res.push_back(mid - dir);\n    return res;\n}\n\nint main(){\n    int N;\n    while(cin >> N && N > 0) {\n        vector<P> ps(N);\n        REP(i, N) {\n            D x, y;\n            cin >> x >> y;\n            ps[i] = P(x, y);\n        }\n\n        int ans = 1;\n        REP(i, N) REP(j, N) if(i != j) {\n            vector<P> cv = tc2(ps[i], ps[j], 1.0);\n            for(auto c : cv) {\n                int sum = 0;\n                REP(k, N) {\n                    if(sig(abs(c - ps[k]) - 1.0) <= 0) {\n                        sum++;\n                    }\n                }\n                ans = max(ans, sum);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pd(a) printf(\"%.10f\\n\",a)\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define pi M_PI\n#define R cin>>\n#define F first\n#define S second\n#define C class\n#define ll long long\n#define ln cout<<'\\n'\ntemplate<C T>void pr(T a){cout<<a;ln;}\ntemplate<C T,C T2>void pr(T a,T2 b){cout<<a<<' '<<b;ln;}\ntemplate<C T,C T2,C T3>void pr(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c;ln;}\ntemplate<C T>void PR(T a,int n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\nconst double EPS = 1e-10;\ntypedef complex<double> P;\n\ndouble D(P a, P b) {\n  return sqrt((a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag()));\n}\ndouble toRad(double agl){return agl*M_PI/180.0;}\nP rotate(P a, double r){return P(a.real()*cos(r)-a.imag()*sin(r),a.real()*sin(r)+a.imag()*cos(r));}\n\nvoid Main() {\n  int n;\n  while(R n && n) {\n    P a[n];\n    rep(i,n) {\n      double x,y;\n      cin >> x >> y;\n      a[i]=P(x,y);\n    }\n    int ans=1;\n    rep(i,n) {\n      REP(j,i+1,n) {\n        if(D(a[i],a[j])>2) continue;\n        int cnt=0;\n        P q=P((a[i].real()+a[j].real())/2,(a[i].imag()+a[j].imag())/2);\n        P p=a[i]-q;\n        double r=sqrt(1.0-D(q,a[i])*D(q,a[i]));\n        if(r) p*=r/D(q,a[i]);\n        p=rotate(p,toRad(90));\n        p+=q;\n        rep(k,n) if(D(p,a[k])<=1+EPS) cnt++;\n        ans=max(ans,cnt);\n        cnt=0;\n        p-=q;\n        p=rotate(p,toRad(180));\n        p+=q;\n        rep(k,n) if(D(p,a[k])<=1+EPS) cnt++;\n        ans=max(ans,cnt);\n      }\n    }\n    pr(ans);\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);\n  Main();return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <complex>\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a); i < (b); i++)\n#define rep(i, n) REP(i, 0, n)\n\ntypedef complex<double> P;\n\n#define EPS (1e-10)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define EQV(a, b) (EQ((a).real(), (b).real) && EQ((a).imag(), (b).imag()))\n\nP unit_vector(P a) { return a/abs(a); }\nP normal_vector1(P a) { return a * P(0, 1); }\nP normal_vector2(P a) { return a * P(0, -1); }\ndouble distance_p_p(P a, P b) { return abs(a-b); }\n\nint N;\n\nint main()\n{\n\twhile (cin >> N) {\n\t\tvector<P> ps;\n\n\t\trep(i, N) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tps.push_back(P(x, y));\n\t\t}\n\n\t\tint ans = 0;\n\t\trep(i, N) {\n\t\t\tREP(j, i+1, N) {\n\t\t\t\tP p, q;\n\t\t\t\tp = ps[i]; q = ps[j];\n\n\t\t\t\tdouble d = distance_p_p(p, q);\n\t\t\t\tif (d > 2) continue;\n\n\t\t\t\tP pq_c = (q - p)/2.0;\n\t\t\t\tP a = unit_vector(normal_vector1(q-p));\n\t\t\t\tP b = unit_vector(normal_vector2(q-p));\n\n\t\t\t\tP c1 = (p + pq_c) + a*(sqrt(1.0-d*d/4.0));\n\t\t\t\tP c2 = (p + pq_c) + b*(sqrt(1.0-d*d/4.0));\n\n\t\t\t\tint buf1, buf2;\n\t\t\t\tbuf1 = buf2 = 2;\n\t\t\t\trep(k, N) {\n\t\t\t\t\tif (k == i || k == j) continue;\n\t\t\t\t\tif (distance_p_p(ps[k], c1) <= 1)\n\t\t\t\t\t\tbuf1++;\n\t\t\t\t\tif (distance_p_p(ps[k], c2) <= 1)\n\t\t\t\t\t\tbuf2++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, max(buf1, buf2));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1132&lang=jp\n\n#include <iostream>\n#include <complex>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\ntypedef complex<double> xy_t;\n\nconst xy_t rot[2] = { xy_t(0, 1), xy_t(0, -1) };\nconst double eps = 1e-6; // 最初から誤差の見積もりがあるのでそれに甘えた。\n\nint main() {\n  int N;\n  while (scanf(\"%d\", &N) != EOF && N) {\n    xy_t P[310];\n    for (int i=0; i<N; i++) {\n      double X, Y;\n      scanf(\"%lf%lf\", &X, &Y);\n      P[i] = xy_t(X, Y);\n    }\n    int ans = 1;\n    for (int i=0; i<N; i++) {\n      for (int j=i+1; j<N; j++) {\n\tif ( abs(P[i] - P[j]) > 2 - eps ) continue;\n\tfor (int k=0; k<2; k++) {\n\t  xy_t c = (P[i] + P[j])/2.0; // 中点\n\t  xy_t n = (P[i] - P[j]);\n\t  xy_t m = n/abs(n) * rot[k] * sqrt(1 - abs(n/2.0) * abs(n/2.0));\n\t  xy_t center = c + m;\n\t  int count = 0;\n\t  for (int k=0; k<N; k++) {\n\t    if (abs(center - P[k]) < 1 + eps) count++;\n\t    // cerr << fixed << setprecision(10) << abs(center - P[k]) << endl;\n\t  }\n\t  ans = max(ans, count);\n\t}\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> xy_t;\n\nconst xy_t INF_VECT = xy_t(100, 100);\nconst xy_t ZERO_VECT = xy_t(0, 0);\nconst double ERR = 0.00001;\n\nxy_t center(xy_t p, xy_t q);\n\nint main()\n{\n//    ifstream fin(\"1132_input.txt\");\n\n    int num;\n    while(1){\n        cin >> num;\n//        fin >> num;\n        if(num == 0) break;\n        \n        xy_t point[num];\n        for(int i = 0; i < num; i++){\n            double x, y;\n            cin >> x >> y;\n//            fin >> x >> y;\n            point[i] = xy_t(x, y);\n        }\n\n        if(num == 1){\n            cout << \"1\" << endl;\n        }\n\n        else if(num > 1){\n            int max = 1;\n            for(int i = 0; i < num-1; i++){\n                for(int j = i+1; j < num; j++){\n                    xy_t vec = center(point[i], point[j]);\n                    if(vec != INF_VECT){\n                        xy_t mid = (point[i] + point[j]) * xy_t(0.5, 0);\n                        xy_t cent = mid + vec;\n                        \n                        int cnt = 0;\n                        for(int k = 0; k < num; k++){\n                            xy_t r = point[k] - cent;\n                            if(abs(r) <= 1 + ERR) cnt++;\n                        }\n                        if(cnt > max) max = cnt;\n\n                        cent = mid - vec;\n                        cnt = 0;\n                        for(int k = 0; k < num; k++){\n                            xy_t r = point[k] - cent;\n                            if(abs(r) <= 1 + ERR) cnt++;\n                        }\n                        if(cnt > max) max = cnt;\n                    }\n                }\n            }\n            cout << max << endl;\n        }\n    }\n    return 0;\n}\n\n\nxy_t center(xy_t p, xy_t q)\n{    \n    xy_t r = q-p;\n    double d = abs(r);\n\n    if(d > 2){\n        return INF_VECT;\n    }\n    else if(d == 2){\n        return ZERO_VECT;\n    }\n    else{\n        double l = sqrt(4 - d*d) / 2;\n        xy_t r_ = r * xy_t(0, 1);\n        r_ *= xy_t(l/d, 0);\n        return r_;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nconst double EPS = 1e-8;\n\nint n;\nPoint data[300];\n\nint calc(Point a, Point b){\n  int res = 0;\n  double d = abs(b - a) / 2.0;\n  Point ab = (b - a) / (2.0 * d);\n  if(d < 1){\n    Point o = ab * d;\n    d = sqrt(1.0 - d * d);\n    o += Point(d * ab.imag() + a.real(), -d * ab.real() + a.imag());\n    for(int i=0;i<n;i++){\n      if(abs(o - data[i]) < 1.0 + EPS) res++;\n    }\n  }\n  return res;\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      cin >> data[i].imag() >> data[i].real();\n    }\n    int ans = 1;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n        ans = max(ans, calc(data[i], data[j]));\n        ans = max(ans, calc(data[j], data[i]));\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <complex>\n\nusing namespace std;\ntypedef long long ll;\ntypedef complex<double> Point;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nint n;\nint ans;\ndouble R;\nPoint points[3000];\npair<double, int> radian[30000];\nbool used[3000];\n\nint calc(int s) {\n  int ret = 1;\n  int m = 0;\n  REP(i, n) {\n    double d = abs(points[s] - points[i]) / 2.0;\n    if (i == s || d * 2.0 > R * 2) { continue; }\n    Point center = (points[s] + points[i]) / 2.0;\n    Point vect = (points[i] - points[s]) * Point(0, -1);\n    vect /= abs(vect);\n    double l = sqrt(R * R - d * d);\n    Point c1 = center + vect * l;\n    Point c2 = center - vect * l;\n    double arg1 = arg(c1 - points[s]) - EPS;\n    double arg2 = arg(c2 - points[s]) + EPS;\n    radian[m++] = pair<double, int>(arg1 + 0 * PI, (i + 1));\n    radian[m++] = pair<double, int>(arg2 + 0 * PI, -(i + 1));\n  }\n  if (m / 2 < ans - 1) { return 0; }\n  sort(radian, radian + m);\n  MEMSET(used, false);\n  int lsum = 1;\n  REP(iter, 2) {\n    REP(i, m) {\n      int index = abs(radian[i].second) - 1;\n      bool start = radian[i].second > 0 ? true : false;\n      if (used[index] && !start) {\n        used[index] = false;\n        lsum--;\n      } else if (!used[index] && start) {\n        used[index] = true;\n        lsum++;\n      }\n      ret = max(ret, lsum);\n    }\n  }\n  return ret;\n}\n\nint main() {\n  R = 1.0;\n  while (scanf(\"%d\", &n), n) {\n    REP(i, n) {\n      double x, y;\n      scanf(\"%lf %lf\", &x, &y);\n      points[i] = Point(x, y);\n    }\n    ans = 0;\n    REP(i, n) {\n      ans = max(ans, calc(i));\n    }\n    printf(\"It is possible to cover %d points.\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define EPS 1e-8\nusing namespace std;\ntypedef complex<double> P;\nint main(){\n\tint n; double x,y;\n\twhile(cin>>n,n){\n\t\tP p[n]; rep(i,n)cin>>x>>y,p[i]=P(x,y);\n\t\tint mx=0,m1,m2;\n\t\trep(i,n)rep(j,i)if(norm(p[i]-p[j])<4+EPS){\n\t\t\tP M=(p[i]+p[j])/P(2,0),C1,C2; double l=sqrt(1-norm(M-p[i]));\n\t\t\tC1=M+polar(l,arg(p[j]-p[i])+M_PI/2);\n\t\t\tC2=M+polar(l,arg(p[j]-p[i])-M_PI/2);\n\t\t\tm1=m2=0;\n\t\t\trep(k,n){\n\t\t\t\tif(norm(p[k]-C1)<1+EPS)m1++; if(norm(p[k]-C2)<1+EPS)m2++;\n\t\t\t}\n\t\t\tif(m1>mx)mx=m1; if(m2>mx)mx=m2;\n\t\t}\n\t\tcout<<mx<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\nusing namespace std;\ntypedef complex<double> P;\nint n;\nvector<P> p;\nint ret(){\n\tint cnt=1;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(abs(p[i]-p[j])>2.0)\n\t\t\t\tcontinue;\n\t\t\tP c=(p[i]+p[j])*0.5;\n\t\t\tdouble d=sqrt(1.0-abs(p[i]-c)*abs(p[i]-c));\n\t\t\tP l1=(p[i]-p[j])*P(0,1);\n\t\t\tP l2=(p[i]-p[j])*P(0,-1);\n\t\t\tl1=l1*d/abs(l1)+c;l2=l2*d/abs(l2)+c;\n\t\t\tint x=2,y=2;\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(k==i||k==j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(abs(l1-p[k])<=1.0){\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif(abs(l2-p[k])<=1.0){\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tcnt=max(cnt,max(x,y));\n\t\t}\n\t}\n\treturn cnt;\n\t\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tp.resize(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tp[i]=P(x,y);\n\t\t}\n\t\tcout<<ret()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n#include <complex>\ntypedef complex<double> Point;\nconst double EPS = 1e-8;\n\n// 入力ストリームから実数二つをとって Point へ\nistream& operator >> ( istream &s, Point &a )\n{\n\tdouble r, i;\n\ts >> r >> i;\n\ta = Point( r, i );\n\treturn s;\n}\n\n// 単位ベクトル\nPoint unitVector( const Point &a )\n{\n\treturn a / abs( a );\n}\n\n// 法線ベクトル\nPoint normalVector1( const Point &a )\n{\n\treturn a * Point( 0, 1 );\n}\nPoint normalVector2( const Point &a )\n{\n\treturn a * Point( 0, -1 );\n}\nPoint ( *normalVectors[] )( const Point& ) = { normalVector1, normalVector2 };\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int n; cin >> n, n; )\n\t{\n\t\tvector<Point> ps( n );\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tcin >> ps[i];\n\t\t}\n\n\t\tint res = 1;\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tREP( j, 0, i )\n\t\t\t{\n\t\t\t\tconst Point &a = ps[i], &b = ps[j];\n\t\t\t\tif ( 2 + EPS < abs( a - b ) )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tREP( k, 0, 2 )\n\t\t\t\t{\n\t\t\t\t\tconst Point c = ( a + b ) / Point( 2, 0 ) + unitVector( normalVectors[k]( a - b ) ) * sqrt( 1 - pow( abs( a - b ) / 2., 2. ) );\n\t\t\t\t\tint tmp = 2;\n\t\t\t\t\tREP( l, 0, n )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( l == i || l == j )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp += abs( c - ps[l] ) <= 1. + EPS;\n\t\t\t\t\t}\n\t\t\t\t\tres = max( res, tmp );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <numeric>\nusing namespace std;\n\nconst double ESP = 1E-9;\ndouble x[300];\ndouble y[300];\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x[i];\n\t\t\tcin >> y[i];\n\t\t}\n\t\tint count = 1;\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tfor(int j = 0; j < i; j++){\n\t\t\t\tdouble dx = x[j] - x[i];\n\t\t\t\tdouble dy = y[j] - y[i];\n\t\t\t\tdouble mx = (x[j]+x[i]) / 2;\n\t\t\t\tdouble my = (y[j]+y[i]) / 2;\n\t\t\t\tdouble dis = sqrt(dx*dx + dy*dy);\n\t\t\t\tif(dis > 2.0) continue;\n\t\t\t\tdouble mdis = dis / 2;\n\t\t\t\tdouble dis2 = sqrt(1-mdis*mdis);\n\t\t\t\tdx /= dis;\n\t\t\t\tdy /= dis;\n\t\t\t\tdouble px[2], py[2];\n\t\t\t\tpx[0] = mx + dis2 * dy;\n\t\t\t\tpx[1] = mx - dis2 * dy;\n\t\t\t\tpy[0] = my - dis2 * dx;\n\t\t\t\tpy[1] = my + dis2 * dx;\n\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\tint c = 0;\n\t\t\t\t\tfor(int l = 0; l < n; l++){\n\t\t\t\t\t\tdouble dx2 = px[k] - x[l];\n\t\t\t\t\t\tdouble dy2 = py[k] - y[l];\n\t\t\t\t\t\tdouble dis3 = dx2 * dx2 + dy2 * dy2;\n\t\t\t\t\t\tif(dis3 < 1 + ESP) c++;\n\t\t\t\t\t}\n\t\t\t\t\tcount = max(count, c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef double D;\nconst D EPS= (1e-10);\n\n#define X real()\n#define Y imag()\n#define SZ size()\n#define PB(x) push_back(b)\n#define PREV(x,i)  (x[(i+x.SZ-1)%x.SZ])\n#define NEXT(x,i) (x[(i+1)%x.SZ])\n\ntemplate<class T> using CR=const  T&;\nusing P=complex<D>;\nusing G=vector<P>;\n\nint sgn(D a,D b=0){\n    if(a>b+EPS)return 1;\n    if(a<b-EPS)return -1;\n    return 0;\n}\n\nD dist(P a,P b){\n    return abs(a-b);\n}\n\ntuple<P,P> normal_direction(P v){\n    D x=v.X,y=v.Y;\n    return tuple<P,P>(P(y,-x),P(-y,x));\n}\n\nP normalize(P v){\n    D x=v.X,y=v.Y;\n    D d=abs(v);\n    return P(x/d,y/d);\n}\n\ntuple<P,P> getC(P a,P b){\n    auto v=b-a;\n    auto pq=normal_direction(v);\n    P p,q;tie(p,q)=pq;\n    D d=sqrt(1-(dist(a,b)/2)*(dist(a,b)/2));\n    return tuple<P,P>(a+0.5*v+d*normalize(p),a+0.5*v+d*normalize(q));\n}\n\nint cnt(G& g,P c){\n    int n=g.size(),res=0;\n    for(int i=0;i<n;i++)\n\tif(sgn(dist(c,g[i]),1.0)<=0){\n\t    res++;\n\t}\n    return res;\n}\n\nint main(){\n    for(int n;cin>>n,n;){\n\tG g(n);\n\tfor(int i=0;i<n;i++){\\\n\t    D x,y;\n\t    cin>>x>>y;\n\t    g[i]=P(x,y);\n\t}\n\tint res=1;\n\tfor(int i=0;i<n;i++)\n\t    for(int j=i+1;j<n;j++)\n\t\tif(sgn(dist(g[i],g[j]),2.0)<=0){\n\t\t    auto pq=getC(g[i],g[j]);\n\t\t    P p,q;tie(p,q)=pq;\n\t\t    res=max({res,cnt(g,p),cnt(g,q)});\n\t\t}\n\tcout<<res<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\ntypedef complex<double> pt;\ntypedef pair<pt,pt> L;\ntypedef vector<P> poly;\nconst double EPS = 1e-11;\n#define x real()\n#define y imag()\n \ndouble dot(pt a,pt b){\n\treturn (conj(a)*b).x;\n}\ndouble cross(pt a,pt b){\n\treturn (conj(a)*b).y;\n}\nint ccw(pt a,pt b,pt c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > EPS) return 1; // counter clockwise\n\tif(cross(b,c) < -EPS) return -1; // clockwise\n\tif(dot(b,c) < -EPS) return 2; //c-a-b\n\tif(norm(b) < norm(c)) return -2; //a-b-c\n\treturn 0; //a-c-b\n}\nbool cmp(const pt& a,const pt& b){\n\tif(-EPS < a.x-b.x && a.x-b.x < EPS) return a.y < b.y;\n\telse return a.x < b.x;\n}\nvector<pt>convex_hull(vector<pt>ps)\n{\n\tsort(ps.begin(),ps.end(),cmp);\n\tint k=0,n = ps.size();\n\tvector<pt>qs(n*2);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\twhile(k>1 && ccw(qs[k-2],qs[k-1],ps[i]) == -1) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tfor(int i=n-2,t=k;i>=0;i--)\n\t{\n\t\twhile(k>t && ccw(qs[k-2],qs[k-1],ps[i]) == -1) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\npt intersect(pt a,pt b,pt c,pt d){\n\tdouble dev = (b.y-a.y)*(d.x-c.x)-(b.x-a.x)*(d.y-c.y);\n\t\n\tdouble d1, d2;\n \n\td1 = (c.y*d.x-c.x*d.y);\n\td2 = (a.y*b.x-a.x*b.y);\n \n\tpt ap1;\n\tap1.x = d1*(b.x-a.x) - d2*(d.x-c.x);\n\tap1.x /= dev;\n\tap1.y = d1*(b.y-a.y) - d2*(d.y-c.y);\n\tap1.y /= dev;\n \n\treturn ap1;\n}\nbool par(pt a,pt b,pt c,pt d){\n\tb.x -= a.x; b.y -= a.y;\n\td.x -= c.x; d.y -= c.y;\n\tif(abs(b.y*d.x - b.x*d.y) < EPS){\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ndouble PI = 3.1415926535897932;\nint main(){\n\twhile(1){\n\t\tint n; scanf(\"%d\",&n); if(!n) return 0; if(n==1){ puts(\"1\"); continue;}\n\t\tpt p[305];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tdouble a,b; scanf(\"%lf%lf\",&a,&b);\n\t\t\tp[i] = pt(a,b);\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=i+1;j<=n;j++){\n\t\t\t\tpt q = (p[i]+p[j])/2.0;\n\t\t\t\tpt r = (p[i]-p[j]); if(abs(r) > 2.0+EPS) continue;\n\t\t\t\tpt p1 = q + r / abs(r) * polar(sqrt(1.0-abs(r)*abs(r)/4.0),PI/2);\n\t\t\t\tpt p2 = q - r / abs(r) * polar(sqrt(1.0-abs(r)*abs(r)/4.0),PI/2);\n\t\t\t\tint c=0,d=0;\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tif(k==i || k==j || abs(p1-p[k]) <= 1.0+EPS) c++;\n\t\t\t\t\tif(k==i || k==j || abs(p2-p[k]) <= 1.0+EPS) d++;\n\t\t\t\t}\n\t\t\t\tans = max(ans,max(c,d));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\n#define x(p) real(p)\n#define y(p) imag(p)\n\nconst double eps=1e-10;\nconst double inf=1e12;\nconst double PI=acos(-1);\ntypedef complex<double> P;\n\nnamespace std{\n  bool operator<(const P& a,const P& b){\n    return x(a)==x(b)?y(a)<y(b):x(a)<x(b);\n  }\n}\ndouble cross(const P& a,const P& b){\n  return y(conj(a)*b);\n}\ndouble dot(const P& a,const P& b){\n  return x(conj(a)*b);\n}\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\n//// move point\nP projection(const L& l,const P& p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*x(c/b);\n}\nP reflection(const L& l,const P& p) {\n  return p+2.0*(projection(l,p)-p);\n}\nP rotation(const P& a,double r){\n  return P(x(a)*cos(r)-y(a)*sin(r),x(a)*sin(r)+y(a)*cos(r));\n}\n//// intersect\nbool intersectLL(const L& l,const L& m){\n  return abs(cross(l[1]-l[0],m[1]-m[0]))>eps||abs(cross(l[1]-l[0],m[0]-l[0]))<eps;\n}\nbool intersectLS(const L& l,const L& s){\n  return cross(l[1]-l[0],s[0]-l[0])*cross(l[1]-l[0],s[1]-l[0])<eps;\n}\nbool intersectLP(const L& l,const P& p){\n  return abs(cross(l[1]-p,l[0]-p))<eps;\n}\nbool intersectSP(const L& s,const P& p){\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0])<eps;\n}\n//// distance\ndouble distanceLP(const L& l,const P& p) {\n  return abs(p-projection(l,p));\n}\ndouble distanceLL(const L& l,const L& m) {\n  return intersectLL(l,m)?0:distanceLP(l,m[0]);\n}\ndouble distanceLS(const L& l,const L& s) {\n  return intersectLS(l,s)?0:min(distanceLP(l,s[0]),distanceLP(l,s[1]));\n}\ndouble distanceSP(const L& s,const P& p) {\n  const P r=projection(s,p);\n  return intersectSP(s,r)?abs(r-p):min(abs(s[0]-p),abs(s[1]-p));\n}\nstruct C{\n  P p;\n  double r;\n  C(const P& p,double r):p(p),r(r){}\n};\n\nint n;\nP ps[505];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    double x,y;\n    rep(i,n){\n      cin>>x>>y;\n      ps[i]=P(x,y);\n    }\n    int res=1;\n    rep(i,n)rep(j,i){\n      P mp=(ps[i]+ps[j])*0.5;\n      P nv=P(-y(ps[i]-ps[j]),x(ps[i]-ps[j]));\n      nv=nv*(1.0/abs(nv));\n      double h=pow(abs(mp-ps[i]),2);\n      if(1-h<eps)continue;\n      double len=sqrt(1-h);\n      {\n        C nc(P(mp+nv*len),1.0);\n        int cnt=0;\n        rep(k,n){\n          if(abs(nc.p-ps[k])*abs(nc.p-ps[k])<1.0+eps){\n            cnt++;\n          }\n        }\n        maxch(res,cnt);\n      }\n      {\n        C nc(P(mp-nv*len),1.0);\n        int cnt=0;\n        rep(k,n){\n          if(abs(nc.p-ps[k])*abs(nc.p-ps[k])<1.0+eps){\n            cnt++;\n          }\n        }\n        maxch(res,cnt);\n      }\n    }\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n\nusing namespace std;\n\nint n;\ndouble x[300];\ndouble y[300];\n\ndouble dist(double x1, double y1, double x2, double y2) {\n    double dx = abs(x1 - x2);\n    double dy = abs(y1 - y2);\n    return sqrt(dx * dx + dy * dy);\n}\n\nint count(double cx, double cy, int i, int j) {\n    int ans = 0;\n    for (int k = 0; k < n; ++k) {\n        if (k == i || k == j || dist(cx, cy, x[k], y[k]) < 1) ans++;\n    }\n    return ans;\n}\n\nvoid solve() {\n    for (int i = 0; i < n; ++i) {\n        cin >> x[i] >> y[i];\n    }\n\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (i == j) continue;\n            double d = dist(x[i], y[i], x[j], y[j]);\n            if (d > 2.) continue;\n            double dx = x[j] - x[i];\n            double dy = y[j] - y[i];\n            double r = sqrt(1 - (d * d / 4));\n            //cout << r << endl;\n            double cx = x[i] + dx / 2 - dy * r / d;\n            double cy = y[i] + dy / 2 + dx * r / d;\n            //cout << x[i] << \", \" << y[i] << \" - \" << x[j] << \", \" << y[j] << \" : \" << cx << \", \"<< cy << endl;\n            ans = max(ans, count(cx, cy, i, j));\n        }\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    while (1) {\n        cin >> n;\n        if (n == 0) break;\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, s, n) for (Int i = s; i < (Int)(n); i++)\n#define dump(x) cout << (x) << '\\n'\n#define Int int64_t\n#define fi first\n#define se second\n#define all(x) (x).begin(), (x).end()\n \ndouble EPS = 1e-10;\nInt INF = 1e18;\nint inf = 1e9;\nInt mod = 1e9+7;\n\nint main() {\n    vector<Int> res;\n    Int n;\n    while (cin >> n and n) {\n        vector<double> x(n), y(n);\n        rep(i, 0, n) cin >> x[i] >> y[i];\n        Int ma = 1;\n        rep(i, 0, n - 1) rep(j, i + 1, n) {\n            double d = sqrt(pow(x[i] - x[j], 2.0) + pow(y[i] - y[j], 2.0));\n            if (d > 2.0) continue;\n            complex<double> m((x[i] + x[j]) / 2.0, (y[i] + y[j]) / 2.0);\n            complex<double> mv(1.0, -1.0 / ((y[i] - y[j]) / (x[i] - x[j])));\n            mv /= abs(mv);\n            complex<double> ml(abs(x[i] - x[j]) / 2.0, abs(y[i] - y[j]) / 2.0);\n            mv *= sqrt(1.0 - pow(d / 2.0, 2.0));\n            complex<double> a = m + mv, b = m - mv;\n            // printf(\"a : %.12lf %.12lf\\n\", a.real(), a.imag());\n            // printf(\"b : %.12lf %.12lf\\n\", b.real(), b.imag());\n            Int cnt_a = 0;\n            rep(k, 0, n) {\n                double xx = pow(x[k] - a.real(), 2.0);\n                double yy = pow(y[k] - a.imag(), 2.0);\n                // printf(\"xx + yy = %.12lf\\n\", xx + yy);\n                if (xx + yy <= 1.0 + EPS) cnt_a++;\n            }\n            Int cnt_b = 0;\n            rep(k, 0, n) {\n                double xx = pow(x[k] - b.real(), 2.0);\n                double yy = pow(y[k] - b.imag(), 2.0);\n                // printf(\"xx + yy = %.12lf\\n\", xx + yy);\n                if (xx + yy <= 1.0 + EPS) cnt_b++;\n            }\n            ma = max(ma, max(cnt_a, cnt_b));\n        }\n        res.push_back(ma);\n    }\n    rep(i, 0, res.size()) dump(res[i]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\ntypedef complex<double> C;\n#define EPS (1e-6)\n\nint n;\nC c[301];\n\nvoid solve() {\n  for(int i=0;i<n;i++)\n  cin>>c[i].real()>>c[i].imag();\n  \n  int res = 0;\n  for (int i = 0; i < n; i += 1) {\n    for (int j = i+1; j < n; j += 1) {\n      C v = c[j] - c[i];\n      double absv = abs(v);\n      if (absv > 2.0 + EPS) continue;\n      // _\n      C m = c[i] + (v / 2.0);\n      // ~ÜÅÌ£\n      double dist = sqrt(1.0 - absv * absv / 4.0);\n      // PÊ@üxNg\n      C unv  = (v * C(0, 1)) / absv;\n      // S\n      C nv = unv * dist;\n      for (int k = 0; k < 2; k += 1) {          \n        int cnt = 0;\n        nv *= -1;\n        C tc = m + nv;\n        for (int l = 0; l < n; l += 1) {\n          if (abs(tc - c[l]) < 1.0 + EPS) {\n            cnt++;\n          }\n        }\n        res = max(res, cnt);\n      }\n    }\n  }\n  cout<<res<<endl;\n  //cout<<\"+++++\"<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>n, n) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n#include<set>\n#include<array>\n#include<cassert>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\ntypedef double Real;\n\nconst Real EPS = 1e-8;\n\nint sign(Real d){\n\treturn d > EPS ? 1 : d < -EPS ? -1 : 0;\n}\n\nstruct Point{\n\tReal x,y;\t\n\texplicit Point(Real x_ = 0,Real y_ = 0):x(x_),y(y_){}\n\tPoint operator+(const Point &p) const {return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point &p) const {return Point(x-p.x,y-p.y);}\n\tPoint operator*(Real s) const {return Point(x*s,y*s);}\n\tPoint operator/(Real s) const {return Point(x/s,y/s);}\n\tbool operator<(const Point &p) const{return sign(x-p.x) == -1 || (sign(x-p.x) == 0 && sign(y-p.y) == -1);}\n\tbool operator==(const Point &p) const{return sign(x-p.x) == 0 && sign(y-p.y) == 0;}\n\n};\n\nistream &operator>>(istream &is,Point &p){return is >> p.x >> p.y;}//??\\???????°???????\nostream &operator<<(ostream &os ,const Point &p){return os << '(' << p.x << \", \" << p.y << ')';}//??????????°???????\n\nstruct Segment : public array<Point,2>{\n\tSegment(const Point &a,const Point &b){\tat(0) = a; at(1) = b;}\n};\n\nstruct Line : public array<Point,2>{\n\tLine(const Point &a,const Point &b){at(0) = a; at(1) = b;}\n};\n\nstruct Circle{\n\tPoint c;\n\tReal r;\n\n\tCircle(const Point &c_, Real r_):c(c_),r(r_){}\n};\n\ntypedef vector<Point> Polygon;\n\nPoint rotate90(const Point &p){\n\treturn Point(-p.y,p.x);\n}\n\nPoint rotate(const Point &p,Real theta){\n\tconst Real s = sin(theta),c = cos(theta);\n\treturn Point(c*p.x-s*p.y,s*p.x+c*p.y);\n}\n\nReal angle(const Point &p){\n\treturn atan2(p.y,p.x);\n}\n\nReal dot(const Point &a,const Point &b){ //??????????????????\n\treturn a.x*b.x+a.y*b.y;\n}\n\nReal cross(const Point &a,const Point &b){ //??????????????????\n\treturn a.x*b.y-a.y*b.x;\n}\n\n\nReal norm(const Point &p){\n\treturn p.x*p.x+p.y*p.y;\n}\n\nReal abs(const Point &p){\n\treturn sqrt(norm(p));\n}\n\nenum { CCW=1,CW=-1,BACK=2,FRONT=-2,ON=0 };\nint ccw(const Point &a,const Point &b,const Point &c){\n\tconst Point p = b-a;\n\tconst Point q = c-a;\n\tconst int sgn = sign(cross(p,q));\n\t\n\tif(sgn == 1) return CCW;\n\tif(sgn == -1) return CW;\n\tif(sign(dot(p,q)) == -1) return BACK;\n\tif(sign(norm(p) - norm(q)) == -1) return FRONT;\n\treturn ON;\n}\n\nPoint project(const Line &l,const Point &p){ //?°???±\n\tReal t = dot(p-l[0], l[1]-l[0]) / norm(l[0] - l[1]);\n\treturn l[0] + (l[1] - l[0]) * t;\n}\n\nPoint refrect(const Line &l,const Point &p){ //????°?\n\tconst Point c = project(l,p);\n\treturn c+(c-p);\n}\n\nbool intersect(const Segment &a,const Segment &b){\n\treturn ccw(a[0],a[1],b[0])*ccw(a[0],a[1],b[1]) <= 0\n\t\t&& ccw(b[0],b[1],a[0])*ccw(b[0],b[1],a[1]) <= 0;\n}\n\nbool intersect(const Segment &s,const Point &p){\n\treturn ccw(s[0],s[1],p) == ON;\n}\n\nbool intersect(const Line &l,const Segment &s){\n\treturn sign(cross(l[1]-l[0],s[0]-l[0])) * cross(l[1]-l[0],s[1]-l[0]) <= 0;\n}\n\nbool intersect(const Line &l,const Point &p){\n\treturn abs(ccw(l[0],l[1],p)) != 1;\n}\n\nbool intersect(const Line &a,const Line &b){ //????????????\n\treturn sign(cross(a[1]-a[0],b[1]-b[0])) != 0\n\t\t||\tsign(cross(a[1]-a[0],b[1]-a[0]) == 0);\n}\n\nReal dist(const Point &a,const Point &b){\n\treturn abs(a-b);\t\n}\n\nReal dist(const Line &l,const Point &p){\n\tconst Point a = l[1]-l[0];\n\tconst Point b = p-l[0];\n\treturn abs(cross(a,b))/abs(a);\n}\n\nReal dist(const Line &l,const Segment &s){\n\tif(intersect(l,s)) return 0;\n\treturn min(dist(l,s[0]),dist(l,s[1]));\n}\n\nReal dist(const Line &a,const Line &b){\n\tif(intersect(a,b)) return 0;\n\treturn dist(a,b[0]);\n}\n\nReal dist(const Segment &s,const Point &p){\n\tif(sign(dot(s[1]-s[0],p-s[0]))==-1) return dist(s[0],p);\n\tif(sign(dot(s[0]-s[1],p-s[1]))==-1) return dist(s[1],p);\n\treturn dist(Line(s[0],s[1]),p);\n}\n\nReal dist(const Segment &a,const Segment &b){\n\tif(intersect(a,b)) return 0;\n\treturn min({dist(a,b[0]),dist(a,b[1]),dist(b,a[0]),dist(b,a[1])});\n}\n\nbool intersect(const Circle &a,const Circle &b){\n\treturn sign(dist(a.c,b.c)-(a.r+b.r)) <=0\n\t\t\t&& sign(dist(a.c,b.c)-abs(a.r-b.r)) >= 0;\n}\n\nbool intersect(const Circle &c,const Segment &s){\n\treturn sign(dist(s,c.c)-c.r)<=0;\n}\n\nbool intersect(const Circle &c,const Line &l){\n\treturn sign(dist(l,c.c)-c.r)<=0;\n}\n\nbool contain(const Circle &c,const Point &p){\n\treturn sign(dist(c.c,p)-c.r)<=0;\n}\n\nbool contain(const Polygon &P,const Point &p){\n\tbool res = false;\n\n\tfor(int i=0;i<P.size();++i){\n\t\tPoint v1=P[i]-p;\n\t\tPoint v2=P[(i+1)%P.size()]-p;\n\t\tif(v1.y>v2.y) swap(v1,v2);\n\n\t\tif(sign(cross(v1,v2))==0&&sign(dot(v1,v2))<=0){\n\t\t\treturn true;//on edge \n\t\t}\n\t\tif(sign(v1.y)<=0&&sign(v2.y)==1&&sign(cross(v1,v2))==1){\n\t\t\tres=!res;\n\t\t}\n\t}\n\treturn res;\n}\n\nPoint crosspoint(const Line &a,const Line &b){\n\tassert(intersect(a,b));\n\tconst Real crs = cross(a[1]-a[0],b[1]-b[0]);\n\tif(sign(crs) == 0) return a[0];\n\treturn b[0]+(b[1]-b[0])*(cross(a[1]-a[0],a[1]-b[0])/crs);\n}\n\n\n//??¬??¢?????????????????¨?????°?????????????????????Intersect?????????\nPoint crosspoint(const Segment &a,const Segment &b){\n\tassert(intersect(a,b));\n\tconst Real crs = cross(a[1]-a[0],b[1]-b[0]);\n\tif(sign(crs)==0){\n\t\tif(intersect(a,b[0])) return b[0];\n\t\tif(intersect(a,b[1])) return b[1];\n\t\tif(intersect(b,a[0])) return a[0];\n\t\treturn a[1];\n\t}\n\treturn b[0]+(b[1]-b[0])*(cross(a[1]-a[0],a[1]-b[0])/crs);\n}\n\nvector<Point> crosspoint(const Circle &c,const Line &l){\n\tconst Point p = project(l,c.c);\n\tconst Real h = dist(p,c.c);\n\n\tvector<Point> res;\n\tif(sign(h-c.r)==1){\n\t\t//nothing\n\t}else if(sign(h-c.r)==0){\n\t\tres.emplace_back(p);\t\n\t}else{\n\t\tconst Real b = sqrt(c.r*c.r-h*h);\n\t\tconst Point e = (l[1]-l[0])/abs(l[1]-l[0]);\n\t\tres.emplace_back(p+e*b);\n\t\tres.emplace_back(p-e*b);\n\t}\n\treturn res;\n}\n\nvector<Point> crosspoint(const Circle &a,const Circle &b){\n\tif(!intersect(a,b)) return vector<Point>();\n\n\tvector<Point> res;\n\tconst Real d = dist(a.c,b.c);\n\n\tif(sign(d-(a.r+b.r))==0){\n\t\tconst Point v = b.c - a.c;\n\t\tres.emplace_back(a.c + (v * (a.r /abs(v))));\n\t}else{\n\t\tconst Real theta = acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\t\tconst Real phi = angle(b.c-a.c);\n\t\tres.emplace_back(a.c+rotate(Point(a.r,0),phi+theta));\n\t\tres.emplace_back(a.c+rotate(Point(a.r,0),phi-theta));\n\t}\n\treturn res;\n}\n\nReal area(const Polygon &P){\n\tReal res = 0.0;\n\tfor(int i=0;i<P.size();++i){\n\t\tres+=cross(P[i],P[(i+1)%P.size()]);\n\t}\n\treturn abs(res) * 0.5;\n}\n\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tvector<Circle> circles;\n\t\tvector<Circle> ccircles;\n\t\trep(i,n){\n\t\t\tPoint p;\n\t\t\tcin >> p;\n\t\t\tcircles.push_back(Circle(p,1.0));\n\t\t}\n\n\t\trep(i,n) for(int j=i+1;j<n;j++){\n\t\t\tvector<Point> points = crosspoint(circles[i],circles[j]);\n\t\t\trep(k,points.size()){\n\t\t\t\tccircles.push_back(Circle(points[k],1.0));\n\t\t\t}\n\t\t}\n\n\t\tint ans=0;\n\t\tvector<Point> points;\n\n\t\trep(i,ccircles.size()){\n\t\t\tvector<Point> tmp;\n\t\t\tint cnt=0;\n\t\t\trep(j,n){\n\t\t\t\tif(contain(ccircles[i],circles[j].c)){\n\t\t\t\t\tcnt++;\t\n\t\t\t\t\ttmp.push_back(circles[j].c);\n\t\t\t\t}\n\t\t\t}\n\t\t\tans=max(cnt,ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={-1,0,1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-15;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef pair<int,Pii> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x = _x;\n        y = _y;\n    }\n    Point operator + (Point p){\n        return Point(x+p.x,y+p.y);\n    }\n  \n    Point operator - (Point p){\n        return Point(x-p.x,y-p.y);\n    }\n  \n    Point operator * (double k){\n        return Point(k*x,k*y);\n    }\n     \n    Point operator * (Point p){\n        return Point(p.x*x-p.y*y,p.x*y+p.y*x);\n    }\n\n    Point operator / (double k){\n        return Point(x/k,y/k);\n    }\n \t\n    Point operator = (Point p){\n    \tx = p.x;\n    \ty = p.y;\n    \treturn *this;\n    }\n\n    bool operator<(const Point &p)const{\n        return x!=p.x?x<p.x:y<p.y;\n    }\n\n};\ndouble dot(Point p, Point q){\n    return p.x*q.x+p.y*q.y;\n}\n  \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n  \ndouble norm(Point p){\n\t//ベクトルの大きさの2乗\n    return p.x*p.x+p.y*p.y;\n}\n  \ndouble pabs(Point p){\n\t//ベクトルの大きさ\n    return sqrt(norm(p));\n}\nPoint UnitVector(Point a){\n\t//単位ベクトル\n\treturn a/pabs(a);\n}\ntypedef vector<Point> Polygon;\nstruct Line : Polygon{\n    Line(){}\n    Line(Point p,Point q){\n        PB(p);\n        PB(q);  \n    }\n};\nstruct Circle{\n    Point p; //中心点\n    double r; //半径\n    Circle(){}\n    Circle(Point _p,double _r){\n        p = _p;\n        r = _r;\n    }\n};\nint ccw(Point a,Point b,Point c){\n    b = b-a;\n    c = c-a;\n    if(cross(b,c) > 0)return +1; //a→b で反時計に折れてc ccw\n    if(cross(b,c) < 0)return -1; //a→b で時計に折れてc ccw\n    if(dot(b,c) < 0)return +2; // c--a--b;\n    if(pabs(b)<pabs(c))return -2; //a--b--c\n    return 0; //a--c--b\n}\nbool intersectSS(Line l,Line m){\n    //lとmが交差してるかどうか\n    return (ccw(l[0],l[1],m[0])*ccw(l[0],l[1],m[1])<EPS)&&\n            (ccw(m[0],m[1],l[0])*ccw(m[0],m[1],l[1])<EPS);\n}\n\nbool intersectSP(Line l, Point p){\n\t//線分lと点pが交差してるか\n\treturn !ccw(l[0],l[1],p);\n}\n\nbool intersectLL(Line l,Line m){\n\treturn fabs(cross(l[1]-l[0],m[1]-m[0])) > EPS || //平行でない\n\t\t\tfabs(cross(l[1]-l[0],m[0]-l[0])) < EPS; //同一の線\n}\n\nint intercectCC(Circle a,Circle b,Point *p,Point *q){\n\tdouble dist = pabs(a.p-b.p);\n\tif(dist < fabs(a.r-b.r) || dist > a.r+b.r){\n\t\t//円の中心が一致しているとき\n\t\t//円の交点が存在しないとき\n\t\t*p = Point(1e15,1e15);\n\t\t*q = Point(1e15,1e15);\n\t\treturn 0;\n\t}\n\telse if(fabs(dist-a.r-b.r) < EPS){\n\t\t//円が1点で交わっているとき\n\t\tPoint way;\n\t\tway = b.p-a.p;\n\t\t*p = a.p+UnitVector(way)*a.r;\n\t\t*q = *p;\n\t\treturn 1;\n\t}\n\telse{\n\t\t//円が2点で交わっているとき\n        if(a.r < b.r){\n            swap(a.r,b.r);\n            swap(a.p,b.p);\n        }\n        double s = (a.r + b.r + dist) / 2.0 ;\n        double area = sqrt(s * (s - a.r) * (s - b.r) * (s - dist));\n        double h = 2.0 * area / dist;\n\n        Point  v = b.p-a.p;\n        v = UnitVector(v);\n        Point  m = a.p + (v*sqrt(a.r*a.r-h*h));\n        Point  n = v * Point(0.0,1.0);\n        \n        *p = m + (n * h);\n        *q = m - (n * h);\n        return 2;\n\t}\n}\n\ndouble TriangleArea(Point a,Point b,Point c){\n    b = b - a;\n    c = c - a;\n    return cross(b,c)*0.5; //負になることもあるので注意\n}\n \ndouble VertexArea(Polygon v){\n    double subArea = 0.0;\n    rep(i,v.size()-1){\n        subArea += TriangleArea(v[0],v[i],v[i+1]);\n    }\n    return subArea; //負になることもあるので注意\n}\n\nPoint crosspoint(Line l,Line m){\n\t//線分lと線分mの交点\n    if(intersectSS(l,m) == false)return Point(INF,INF);\n    return m[0]+(m[1]-m[0])*cross(l[1]-l[0],l[1]-m[0])/cross(l[1]-l[0],m[1]-m[0]);\n}\n \nPolygon ConvexHull(Polygon v){\n\tint n = v.size();\n\tint k = 0;\n\tsort(v.begin(),v.end());\n\tPolygon e(2*n);\n\tfor(int i=0;i<n;e[k++]=v[i++])\n\t\twhile(k>=2&&ccw(e[k-2],e[k-1],v[i])<=0)k--;\n\tfor(int i=n-2,t=k+1;i>=0;e[k++]=v[i--])\n\t\twhile(k>=t&&ccw(e[k-2],e[k-1],v[i])<=0)k--;\n\te.resize(k-1);\n\treturn e;\n}\n\nint main(){\n    int N;\n    while(scanf(\"%d\",&N),N){\n        Circle C[328];\n        vector< Point > points;\n        rep(i,N){\n            double x,y;\n            scanf(\"%lf %lf\",&x,&y);\n            C[i] = Circle(Point(x,y),1.);\n        }\n        int len = 0;\n        rep(i,N){\n            reps(j,i+1,N){\n                Point p,q;\n                int tmp = 0;\n                tmp = intercectCC(C[i],C[j],&p,&q);\n                if(tmp > 0){\n                    points.PB(p);\n                    points.PB(q);\n                    /*\n                    cout << i << \" \" << j << \"->\\n\";\n                    cout << \"1:\"<< p.x << \" \" << p.y << \"\\n\";\n                    cout << \"2:\"<< q.x << \" \" << q.y << \"\\n\";\n                    */\n                }\n            }\n        }\n        int ans = 1;\n        rep(i,points.size()){\n            Point tar = points[i];\n            int cnt = 0;\n            rep(j,N){\n                Point base = C[j].p;\n                //cout << pabs(base-tar) << \" \";\n                if(pabs(base-tar)-1.<EPS){\n                    cnt++;\n                }\n            }\n            ans = max(ans,cnt);\n        }\n\n        printf(\"%d\\n\",ans);\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> p;\n\nint n;\np ps[300];\n\nint main() {\n\twhile (cin >> n , n != 0) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tps[i] = p(x, y);\n\t\t}\n\n\t\tif (n == 1) {\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tp v = ps[i] - ps[j], ve = v / abs(v);\n\t\t\t\tdouble l = sqrt(1 - norm(v) * 0.25);\n\t\t\t\tp vn1 = ve * p(0, 1) * l, vn2 = ve * p(0, -1) * l;\n\t\t\t\tp c1 = ps[j] + v * 0.5 + vn1, c2 = ps[j] + v * 0.5 + vn2;\n\t\t\t\tint count1 = 2, count2 = 2;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (k == i || k == j) continue;\n\t\t\t\t\tif (norm(c1 - ps[k]) <= 1.0) count1++;\n\t\t\t\t\tif (norm(c2 - ps[k]) <= 1.0) count2++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, count1);\n\t\t\t\tans = max(ans, count2);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\ntypedef long double ld;\n\nstruct Point {\n    ld x, y;\n    Point(ld x, ld y) : x(x), y(y) {}\n    string to_s() {\n        ostringstream os;\n        os << x << ',' << y;\n        return os.str();\n    }\n    Point operator+(const Point& o) const {\n        return Point(x+o.x, y+o.y);\n    }\n    Point operator/(const int d) const {\n        return Point(x/d, y/d);\n    }\n};\n\nstruct Circle {\n    ld x, y;\n    ld r;\n    Circle(ld x=0, ld y=0, ld r=1) : x(x), y(y), r(r) {}\n    const static ld eps = 1e-10;\n    bool isIntersect(const Circle& o) const {\n        ld dx = o.x - x;\n        ld dy = o.y - y;\n        return (r + o.r) * (r + o.r) > (dx*dx + dy*dy);\n    }\n    pair<Point, Point> intersectionPoint(const Circle& o) const {\n        //cout << x << ',' << y << \" and \" << o.x << ',' << o.y << endl;\n        ld dx = o.x - x;\n        ld dy = o.y - y;\n        //cout << \"dx: \" << dx << \" dy: \" << dy << endl;\n        ld d = sqrt(dx*dx + dy*dy);\n        //cout << \"d: \" << d << endl;\n\n        ld slope;\n        ld theta;\n        if (dx == 0) {\n            if (y < o.y) {\n                theta = M_PI / 2;\n            } else {\n                theta = - M_PI / 2;\n            }\n        } else {\n            slope = dy / dx;\n            theta = atan(slope);\n        }\n        //cout << \"theta: \" << theta << endl;\n        ld theta_p = acos((r*r - o.r*o.r + d*d) / (2*r*d));\n        //cout << \"theta_p: \" << theta_p << endl;\n\n        return make_pair(\n                Point(x + r*cos(theta - theta_p), y + r*sin(theta - theta_p)),\n                Point(x + r*cos(theta + theta_p), y + r*sin(theta + theta_p)));\n    }\n    bool contains(ld px, ld py) const {\n        return r * r + eps > (px - x) * (px - x) + (py - y) * (py - y);\n    }\n    string to_s() {\n        ostringstream os;\n        os << x << ',' << y << ':' << r << endl;\n        return os.str();\n    }\n};\n\nint countContainingPoints(const Circle& c, const vector<Circle>& ps) {\n    int cnt = 0;\n    for (int i = 0; i < ps.size(); i++) \n        if (c.contains(ps[i].x, ps[i].y)) \n            cnt++;\n    return cnt;\n}\n\nPoint midPoint(pair<Point, Point>& pp) {\n    return (pp.first + pp.second) / 2;\n}\n\nint N;\nint main() {\n    vector<Circle> cs;\n    while (cin >> N, N) {\n        cs.clear(); cs.resize(N);\n        for (int i = 0; i < N; i++) cin >> cs[i].x >> cs[i].y;\n\n        vector<Point> ips; // Intersection PointS\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (i == j) continue;\n                if (!cs[i].isIntersect(cs[j])) continue;\n                pair<Point, Point> ip = cs[i].intersectionPoint(cs[j]);\n                ips.push_back(ip.first);\n                ips.push_back(ip.second);\n                //ips.push_back(midPoint(ip));\n            }\n        }\n\n        int maxPoint = 0;\n        for (int i = 0; i < ips.size(); i++) {\n            maxPoint = max(maxPoint, countContainingPoints(Circle(ips[i].x, ips[i].y, 1), cs));\n        }\n        cout << maxPoint << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#define EPS 0.0001\nusing namespace std;\ntypedef double elem;\ntypedef complex<elem> point,vec;\ninline elem dist(const point &a, const point &b){return abs(a-b);}\ninline vec normr(const vec &v){return v*vec(0,-1);}\ninline vec norml(const vec &v){return v*vec(0,1);}\ninline vec unormr(const vec &v){return normr(v) / abs(v);}\ninline vec unorml(const vec &v){return norml(v) / abs(v);}\nint main(){\n\twhile(true){\n\t\tint ans = 0;\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tvector< point > points;\n\t\tfor(int i=0;i<n;++i){\n\t\t\telem x, y;\n\t\t\tscanf(\"%Lf%Lf\", &x, &y);\n\t\t\tpoints.push_back( point(x,y) );\n\t\t}\n\t\tfor(unsigned int i = 0; i < points.size(); ++i){\n\t\t\tfor(unsigned int j = 0; j < points.size(); ++j){\n\t\t\t\tif( i != j && dist( points[i], points[j] ) < 2 ){\n\t\t\t\t\tint count_p = 0;\n\t\t\t\t\tint count_q = 0;\n\t\t\t\t\telem d = sqrt(1-pow(dist(points[i], points[j])/2,2 ) );\n\t\t\t\t\tpoint p,q;\n\t\t\t\t\tvec ab = points[j] - points[i];\n\t\t\t\t\tpoint t = 0.5 * ab + points[i];  \n\t\t\t\t\tp = d * unormr(ab) + t;\n\t\t\t\t\tq = d * unorml(ab) + t;\n\t\t\t\t\tfor(unsigned int k = 0; k < points.size(); ++k){\n\t\t\t\t\t\tif( dist(p, points[k]) <= 1.0+EPS ){ count_p++; }\n\t\t\t\t\t\tif( dist(q, points[k]) <= 1.0+EPS ){ count_q++; }\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans, max(count_q, count_p) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        vector<long double> xs(n),ys(n);\n        rep(i,0,n) cin >> xs[i] >> ys[i];\n\n        auto count=[&](const long double x,const long double y){\n            int res=0;\n            rep(i,0,n) if((xs[i]-x)*(xs[i]-x)+(ys[i]-y)*(ys[i]-y)<=1+eps) ++res;\n            return res;\n        };\n\n        int ans=0;\n        rep(i,0,801){\n            const long double y=10.*i/800;\n            rep(j,0,n){\n                const long double tmp=1-(ys[j]-y)*(ys[j]-y);\n                if(tmp<0) continue;\n                const long double x1=xs[j]-sqrtl(tmp),x2=xs[j]+sqrt(tmp);\n                ans=max({ans,count(x1,y),count(x2,y)});\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\n\nmain(){\n  int n;\n  while(cin>>n,n){\n    double x[n],y[n];\n\n    rep(i,n)cin>>x[i]>>y[i];\n\n    int ans=0;\n\n    rep(i,n){\n      rep(j,i){\n\tdouble sx,sy;\n\tdouble tx=x[i]-x[j],ty=y[i]-y[j];\n\tdouble len=sqrt(tx*tx+ty*ty);\n\tif(len>2+EPS)continue;\n\tlen=sqrt(1-len*len/4);\n\tdouble theta=atan2(ty,tx)+M_PI/2;\n\tint tans=0;\n\tsx=(x[i]+x[j])/2+cos(theta)*len;\n\tsy=(y[i]+y[j])/2+sin(theta)*len;\n\trep(k,n){\n\t  tx=sx-x[k];\n\t  ty=sy-y[k];\n\t  if(tx*tx+ty*ty<=1+EPS)++tans;\n\t}\n\tans=max(ans,tans);\n\ttans=0;\n\tsx=(x[i]+x[j])/2-cos(theta)*len;\n\tsy=(y[i]+y[j])/2-sin(theta)*len;\n\trep(k,n){\n\t  tx=sx-x[k];\n\t  ty=sy-y[k];\n\t  if(tx*tx+ty*ty<=1+EPS)++tans;\n\t}\n\tans=max(ans,tans);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <cmath>\n\nusing namespace std;\n\ntypedef pair<double,double> pos;\nconst double r = 1;\nconst double eps = 0.0001;\nint count(vector<pos> ps,double x,double y,int ban1,int ban2){\n\tint c=0;//2;\n\tfor(int i=0;i<ps.size();i++){\n\t\tif(//i!=ban1&&i!=ban2&&\n\t\t\t\tpow(ps[i].first-x,2)+pow(ps[i].second-y,2)<=pow(1.0+eps,2)){\n\t\t\tc++;\n\t\t}\n\t}\n\treturn c;\n}\n\nbool range(pos p1,pos p2,double r){\n\treturn pow(p1.first-p2.first,2)+pow(p1.second-p2.second,2) <= (r+eps)*(r+eps);\n}\n\ndouble len(pos p){\n\treturn sqrt(pow(p.first,2)+pow(p.second,2));\n}\n\ndouble len2(pos p){\n\treturn (pow(p.first,2)+pow(p.second,2));\n}\n\nvector<pos> point2(pos p1,pos p2){\n\tpos m = make_pair((p1.first+p2.first)/2,(p1.second+p2.second)/2);\n\tpos vec = make_pair(p1.first-p2.first,p1.second-p2.second);\n\tpos q = m;//make_pair(p2.first+vec.first/2,p2.second+vec.second/2);\n\tdouble l = sqrt(1-pow(len(vec)/2.0,2));\n\tdouble ll = len(vec);\n\tpos vec2 = make_pair(-vec.second,vec.first);\n\tvec2.first=vec2.first/ll*l;\n\tvec2.second = vec2.second/ll*l;\n\tvector<pos> ret;\n\tret.push_back(make_pair(q.first+vec2.first,q.second+vec2.second));\n\tret.push_back(make_pair(q.first-vec2.first,q.second-vec2.second));\n\treturn ret;\n}\n\nint solve(vector<pos> ps){\n\tint mx=0;\n\tfor(int i=0;i<ps.size()-1;i++)\n\t\tfor(int k=i+1;k<ps.size();k++){\n\t\t\tif(range(ps[i],ps[k],2)){\n\t\t\t\t//cerr << \"*****\" << i << \" \" << k << endl;\n\t\t\t\tvector<pos> vp = point2(ps[i],ps[k]);\n\t\t\t\tmx = max(mx,count(ps,vp[0].first,vp[0].second,i,k));\n\t\t\t\tmx = max(mx,count(ps,vp[1].first,vp[1].second,i,k));\n\t\t\t}\n\t\t}\n\treturn mx;\n}\n\nint main(){\n\t//cerr << point2(make_pair(0,0),make_pair(1,1))[1].first << endl;\n\twhile(true){\n\t\tint n;\n\t\tvector<pos> v;\n\t\tcin >> n;\n\t\tif(n==0)return 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tv.push_back(make_pair(x,y));\n\t\t}\n\t\tcout << solve(v) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst double PI=acos(-1);\nconst double EPS=1e-6;\ntypedef complex<double>Point;\nPoint in(){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    return Point(x,y);\n}\n\nint N;\nPoint P[333];\n\nsigned main(){\n\n    Point r=polar(1.0,PI/2);\n    while(scanf(\"%lld\",&N),N){\n        rep(i,N)P[i]=in();\n\n        int ma=1;\n        rep(i,N)rep(j,N){\n            Point b=(P[i]+P[j])*0.5;\n            Point v=(P[i]-P[j])*0.5*r;\n            for(double d:{-1.0,1.0}){\n                Point u=v*d*sqrt(1.0-abs(v)*abs(v));\n                Point p=b+u;\n                int cnt=0;\n                rep(k,N)if(abs(P[k]-p)<1.0+EPS)cnt++;\n                chmax(ma,cnt);\n            }\n        }\n        printf(\"%lld\\n\",ma);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pos     = complex<double>;\n\ntemplate <typename Itr>\nvoid printv(Itr begin, Itr end)\n{\n  for (Itr iter = begin; iter != end; iter++) {\n    cout << *iter << \", \";\n  }\n  cout << endl;\n}\n\ndouble dist(pos a, pos b)\n{\n  return sqrt(pow(a.imag() - b.imag(), 2) + pow(a.real() - b.real(), 2));\n}\n\npair<pos, pos> get_centers(pos a, pos b)\n{\n  pos c    = (a + b) / 2.0;\n  double l = sqrt(1 - pow(dist(a, c), 2));\n  pos vec  = (a - b) * pos(0, 1);\n  vec      = (vec / dist(vec, 0)) * l;\n  return {c + vec, c - vec};\n}\n\nint main()\n{\n  int n;\n  while (cin >> n) {\n    if (!n) break;\n\n    vector<pos> t(n);\n    for (int i = 0; i < n; ++i) {\n      double x, y;\n      cin >> x >> y;\n      t[i] = pos(x, y);\n    }\n\n    int ans = 0;\n    for (int pi = 0; pi < n; ++pi) {\n      for (int qi = 0; qi < n; ++qi) {\n        pos p = t[pi];\n        pos q = t[qi];\n        if (pi == qi || dist(p, q) > 2.0) {\n          ans = max(ans, 1);\n          continue;\n        }\n        pair<pos, pos> centers = get_centers(p, q);\n        for (pos center : {centers.first, centers.second}) {\n          int cnt_d = 2;\n          for (int ci = 0; ci < n; ++ci) {\n            if (ci != pi && ci != qi) {\n              if (dist(t[ci], center) <= 1) {\n                ++cnt_d;\n              }\n            }\n          }\n          ans = max(ans, cnt_d);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#define EPS 1e-9\nusing namespace std;\ntypedef complex<double> xy_t;\nint n;\nxy_t points[301];\nint count_in(xy_t center)\n{\n  int ans=0;\n  for(int i=0;i<n;i++)\n  {\n    if (abs(center-points[i])<1.0+EPS)\n      ans++;\n  }\n  return ans;\n}\n/*xy_t ppdcl(xy_t a)\n{\n  return xy_t(a.imag(),-a.real());\n}\nxy_t delta_v(xy_t C1,xy_t C2)\n{\n  xy_t half=(C1-C2)*0.5;\n  double l=abs(half);\n  return ppdcl(half)*sqrt(1-l*l)*(1.0/l);\n}*/\nint main()\n{\n  while(1)\n  {\n    cin>>n;\n    if (n==0) break;\n    double x,y;\n    for(int i=0;i<n;i++)\n    {\n      cin>>x>>y;\n      points[i]=xy_t(x,y);\n    }\n    int maxn=1;\n    for(int i=0;i<n;i++)\n    {\n      for(int j=i;j<n;j++)\n      {\n        /*if(abs(points[i]-points[j])<2.0)\n        {\n          xy_t mid_p=(points[i]+points[j])*0.5;\n          maxn=max(maxn,count_in(mid_p+delta_v(points[i],points[j])));\n          maxn=max(maxn,count_in(mid_p-delta_v(points[i],points[j])));\n        }*/\n        double d=abs(points[j]-points[i])/2;\n        xy_t v=(points[j]-points[i])/(2*d);\n        if(d<1)\n        {\n            maxn=max(maxn,count_in(points[i]+d*v+sqrt(1-d*d)*v*xy_t(0,+1)));\n            maxn=max(maxn,count_in(points[i]+d*v+sqrt(1-d*d)*v*xy_t(0,-1)));\n        }\n      }\n    }\n    cout<<maxn<<endl;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> P;\nconst LL MOD = 1000000007LL;\nconst double EPS = 1e-10;\nstruct Point {\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\tPoint operator+(Point &p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator-(Point &p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator*(double a) {\n\t\treturn Point(x*a, y*a);\n\t}\n\tPoint operator/(double a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm() {\n\t\treturn x*x + y*y;\n\t}\n\tbool operator<(const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator==(const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\ntypedef Point Vector;\nstruct Segment {\n\tPoint p1, p2;\n};\ntypedef Segment Line;\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\ntypedef vector<Point> Polygon;\ndouble norm(Vector a) {\n\treturn a.x*a.x + a.y*a.y;\n}\ndouble abs(Vector a) {\n\treturn sqrt(norm(a));\n}\ndouble dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\ndouble cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\nbool equals(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base*r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\ndouble getDistance(Point a, Point b) {\n\treturn abs(a - b);\n}\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\nbool intersect(Circle c, Line l) {\n\treturn getDistanceLP(l, c.c) <= c.r;\n}\nbool intersect(Circle c1, Circle c2) {\n\treturn getDistance(c1.c, c2.c) <= c1.r + c2.r;\n}\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r*c.r - norm(pr - c.c));\n\treturn make_pair(pr + e*base, pr - e*base);\n}\ndouble arg(Vector p) {\n\treturn atan2(p.y, p.x);\n}\nVector polar(double a, double r) {\n\treturn Vector(cos(r)*a, sin(r)*a);\n}\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\tassert(intersect(c1, c2));\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tPoint p[300];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = Point(x, y);\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tVector d = p[j] - p[i];\n\t\t\t\tif (d.abs() > 2.0) continue;\n\t\t\t\tPoint m = p[i] + d / 2.0;\n\t\t\t\tVector r = Vector(-d.y, d.x);\n\t\t\t\tr = r / r.abs()*sqrt(1 - pow(d.abs() / 2.0, 2));\n\t\t\t\tPoint p1 = m + r;\n\t\t\t\tPoint p2 = m - r;\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tint cnt2 = 0;\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif ((p[k] - p1).abs() <= 1) cnt1++;\n\t\t\t\t\tif ((p[k] - p2).abs() <= 1) cnt2++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, max(cnt1, cnt2));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<double, double> pt;\nconst double EPS = 1e-5;\n#define x first\n#define y second\n\ndouble sq(double a) { return a * a; }\n\ndouble dist(pt p, pt q) {\n  return sqrt(sq(p.x - q.x) + sq(p.y - q.y));\n}\n\nbool lessthan(double a, double b) {\n    if (a - b < EPS)\n        return true;\n    return false;\n}\n\npt midpoint(pt a, pt b) {\n    return pt((a.x + b.x)/2, (a.y + b.y)/2);\n}\n\npt operator+(pt a, pt b) {\n    return pt(a.x + b.x, a.y + b.y);\n}\n\npt operator-(pt a, pt b) {\n  return pt(a.x - b.x, a.y - b.y);\n}\n\npt operator*(pt a, double b) {\n    return pt(a.x * b, a.y * b);\n}\n\npt rotate(pt p, double a) {\n  pt res;\n  res.x = p.x * cos(a) - p.y * sin(a);\n  res.y = p.x * sin(a) + p.y * cos(a);\n  return res;\n}\n\n\n\nconst int maxn = 300;\npt pts[maxn + 1];\n\nint main() {\n    int N;\n    \n    cin >> N;\n    while (N != 0) {\n        for (int i = 0; i < N; ++i) {\n            double x, y;\n            cin >> x >> y;\n            pts[i] = pt(x, y);\n        }\n        int maxcount = 0;\n        for (int i = 0; i < N ; i++){\n            for (int j = 0; j < N; j++) {\n                if (j == i) continue;\n                // for every pair of points\n                if (dist(pts[i], pts[j]) > 2) continue;\n                pt A = pts[i];\n                pt B = pts[j];\n                //cout << \"for points \" << A.x << \" \" << A.y << \" b: \" << B.x << \" \"<< B.y << endl;\n                pt M = midpoint(A, B);\n                //cout << \" M is \" << M.x << \" \" << M.y << endl;\n                pt BM = M - B;\n                double distBM = dist(B,M);\n                //cout << \"dist BM \" << distBM << endl; \n                double alpha = acos(distBM);\n                pt BK = rotate(BM, alpha);\n                pt BC = BK * (1 / distBM);\n                pt C = B + BC;\n                //cout << \"C is  \"<< C.x << \" \" << C.y << endl;\n                int count = 2;\n                for (int k = 0; k < N; k++) {\n                    if (k == i || k == j) continue;\n                    if (lessthan(dist(C, pts[k]), 1)) count++; \n                }\n                maxcount = max(count, maxcount);\n            }\n        }\n        cout << maxcount << endl;\n        cin >> N;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nstruct Point{\n    double x,y;\n};\n\nvoid func(int N){\n\n    Point point[N];\n    double x_min = 100,y_min = 100,x_max = -1,y_max = -1;\n\n    for(int i = 0; i < N; i++){\n        scanf(\"%lf %lf\",&point[i].x,&point[i].y);\n        x_min = min(point[i].x,x_min);\n        y_min = min(point[i].y,y_min);\n        x_max = max(point[i].x,x_max);\n        y_max = max(point[i].y,y_max);\n    }\n\n    if(x_min > 1)x_min -= 0.047;\n    if(y_min > 1)y_min -= 0.047;\n    if(x_max < 9)x_max += 0.047;\n    if(y_max < 9)y_max += 0.047;\n\n    int count,max_count = 0;\n\n    for(double y = y_min; y <= y_max; y += 0.01){\n        for(double x = x_min; x <= x_max; x += 0.01){\n            count = 0;\n            for(int i = 0; i < N; i++){\n                if(sqrt((x-point[i].x)*(x-point[i].x)+(y-point[i].y)*(y-point[i].y)) <= 1.0)count++;\n            }\n            max_count = max(max_count,count);\n        }\n    }\n\n    printf(\"%d\\n\",max_count);\n}\n\n\nint main(){\n\n    int N;\n\n    while(true){\n        scanf(\"%d\",&N);\n        if(N == 0)break;\n\n        func(N);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P complex<double>\n#define X real()\n#define Y imag()\nconst double EPS = 1e-9;\n\nint n;\nvector<P> vv;\n\nint count_points(P a, P b, double mx, double my){\n    P v = (a - b);\n    double d_v = abs(v);\n    if(d_v >= 2.0 + EPS) return 0;\n    P m = v / 2.0 + b;\n    double half_d_v = d_v / 2;\n    double d = sqrt(1.0 - half_d_v * half_d_v);\n    P u = (v * P(mx, my)) / abs(v) * d;\n    int cnt = 0;\n    REP(i, n){\n        P c = m + u;\n        if(abs(c - vv[i]) <= 1.0 + EPS) cnt++;\n    }\n    return cnt;\n}\n\nint main(){\n    while(cin >>n && n){\n        vv = vector<P>(n);\n        REP(i, n){\n          double a, b; cin >>a >>b;\n          vv[i] = P(a, b);\n        }\n\n        int ans = 1;\n        REP(a, n){\n            FOR(b, a + 1, n){\n                ans = max(ans, count_points(vv[a], vv[b], 0, 1));\n                ans = max(ans, count_points(vv[a], vv[b], 0, -1));\n            }\n        }\n        cout <<ans <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble Dis(double x1, double y1, double x2, double y2);\nint main(void){\n\twhile(1){\n\t\tint n;\n\t\tint ans = 1;\n\t\tvector< pair<double, double> > p;\n\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tpair<double, double> t;\n\t\t\tcin >> t.first >> t.second;\n\t\t\tp.push_back(t);\n\t\t}\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=i+1; j<n; j++){\n\t\t\t\t//中点\n\t\t\t\tdouble mpx = (p[i].first + p[j].first) / 2.0;\n\t\t\t\tdouble mpy = (p[i].second + p[j].second) / 2.0;\n\t\t\t\t//2点間の距離\n\t\t\t\tdouble d1 = Dis(p[i].first, p[i].second, p[j].first, p[j].second);\n\t\t\t\t//p[i]からp[j]へ向かうベクトル\n\t\t\t\tdouble v1x = (p[j].first - p[i].first) / d1;\n\t\t\t\tdouble v1y = (p[j].second - p[i].second) / d1;\n\t\t\t\t//中点から円の中心へ向かう単位ベクトル\n\t\t\t\tdouble v2x = -v1y;\n\t\t\t\tdouble v2y = v1x;\n\t\t\t\t//中心から円の中心へ向かうベクトルの長さ\n\t\t\t\tdouble d2 = sqrt(1.0 - (d1*d1/4.0));\n\n\t\t\t\t//円の中心の座標\n\t\t\t\tdouble cx = mpx + v2x * d2;\n\t\t\t\tdouble cy = mpy + v2y * d2;\n\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(k == i || k == j || (cx-p[k].first)*(cx-p[k].first) + (cy-p[k].second)*(cy-p[k].second) <= 1.0)\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt > ans){\n\t\t\t\t\tans = cnt;\n\t\t\t\t}\n\n\t\t\t\tcx = mpx - v2x * d2;\n\t\t\t\tcy = mpy - v2y * d2;\n\n\t\t\t\tcnt = 0;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t}\n\t\t\t\tif(cnt > ans){\n\t\t\t\t\tif(k == i || k == j || (cx-p[k].first)*(cx-p[k].first) + (cy-p[k].second)*(cy-p[k].second) <= 1.0)\tcnt++;\n\t\t\t\t\tans = cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\n\t}\n\t\n\treturn 0;\n}\n\ndouble Dis(double x1, double y1, double x2, double y2){\n\treturn sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ndouble len(pair<double, double> p){\n    return sqrt(p.first * p.first + p.second * p.second);\n}\nconst double EPS=1e-6;\n\ndouble dist(pair<double, double> l, pair<double, double> r){\n    return sqrt((l.first - r.first) * (l.first - r.first) + (l.second - r.second) * (l.second - r.second));\n}\n\nint main(){\n    int n;\n    \n    while(cin >> n && n > 0){\n        vector<pair<double, double> > v;\n        for(int i = 0; i < n; i++){\n            double x, y;\n            cin >> x >> y;\n            v.push_back(make_pair(x, y));\n        }\n        int ans = 1;\n        for(int i = 0; i < v.size(); i++){\n            for(int j = i+1; j < v.size(); j++){\n                if(dist(v[i], v[j]) <= 2){\n                    pair<double, double> mid((v[i].first + v[j].first) / 2, (v[i].second + v[j].second) / 2);\n                    pair<double, double> vec(mid.first - v[i].first, mid.second - v[i].second);\n                    pair<double, double> center1, center2;\n                    double ratio = sqrt(1 - len(vec)*len(vec)) / len(vec);\n                    center1 = make_pair(mid.first - vec.second * ratio, mid.second + vec.first * ratio);\n                    center2 = make_pair(mid.first + vec.second * ratio, mid.second - vec.first * ratio);\n                    /*cout << mid.first << \" \" << mid.second << endl;\n                    cout << vec.first << \" \" << vec.second << endl;\n                    cout << dist(v[i], v[j]) << endl;\n                    cout << ratio << endl;\n                    cout << center1.first << \" \" << center1.second << endl; \n                    cout << center2.first << \" \" << center2.second << endl; */\n                    int s = 0;\n                    for(int k = 0; k < n; k++){\n                        if(dist(center1, v[k]) < 1+EPS){\n                            s++;\n                        }\n                    }  \n                    if(s > ans){\n                        ans = s;\n                    }\n                    s = 0;\n                    for(int k = 0; k < v.size(); k++){\n                        if(dist(center2, v[k]) < 1.0+EPS){\n                            s++;\n                        }\n                    }  \n                    if(s > ans){\n                        ans = s;\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double r = 1.0;\nconst double PI = acos(-1.0);\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y) : x(x), y(y) {}\n};\ninline double Distance2(const Point &a, const Point &b) {\n    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    std::random_device rnd;\n    std::mt19937 mt(rnd());\n    std::uniform_real_distribution<> rand100(0.0, 10.0);\n\n    while (cin >> n, n) {\n        // Input\n        vector<Point> p(n);\n        for (int i = 0; i < n; ++i)\n            cin >> p[i].x >> p[i].y;\n\n        // Solve\n        int ans = 1;\n        auto start = std::chrono::high_resolution_clock::now();\n        auto end = std::chrono::high_resolution_clock::now();\n        auto take_time = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n\n        while (true) {\n            end = std::chrono::high_resolution_clock::now();\n            take_time = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n            if (100 < take_time.count())\n                break;\n\n            for (int i = 0; i < 10; ++i) {\n                Point c(rand100(mt), rand100(mt));\n                int num = 0;\n                for (int j = 0; j < n; ++j) {\n                    double d = Distance2(p[j], c);\n                    if (d <= 1.0)\n                        ++num;\n                }\n                ans = max(ans, num);\n            }\n        }\n\n        // Output\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\ntypedef complex<double> point;\n\nint main(){\n\t\n\tA:;\n\tint n;\n\tcin>>n;\n\tif(n==0)return 0;\n\t\n\tpoint p[333];\n\t\n\trep(i,n){\n\t\tdouble a,b;\n\t\tcin>>a>>b;\n\t\tp[i] = point(a,b);\n\t}\n\tdouble eps = 1E-8;\n\tint ans = 0;\n\trep(i,n){\n\t\treps(j,i+1,n){\n\t\t\tpoint d = (p[j]-p[i])/point(2,0);\n\t\t\tdouble dlen = abs(d);\n\t\t\tif(dlen>1)continue;\n\t\t\t\n\t\t\t//cout<<p[j]<<\" \"<<p[i]<<\" \"<<d<<\" \"<<dlen<<endl;\n\t\t\t\n\t\t\tpoint center = p[i]+d;\n\t\t\tpoint e1 = d/point(dlen,0)*point(0,1)*point(sqrt(1-dlen*dlen),0);\n\t\t\tpoint e2 = d/point(dlen,0)*point(0,-1)*point(sqrt(1-dlen*dlen),0);\n\t\t\t\n\t\t\tpoint t1 = center+e1;\n\t\t\tpoint t2 = center+e2;\n\t\t\t\n\t\t\t//cout<<t1<<\" \"<<t2<<endl;\n\t\t\t\n\t\t\tint count1 = 0;\n\t\t\tint count2 = 0;\n\t\t\trep(k,n){\n\t\t\t\tif(abs(t1-p[k])<1+eps)count1++;\n\t\t\t\tif(abs(t2-p[k])<1+eps)count2++;\n\t\t\t}\n\t\t\t\n\t\t\tans = max(ans,count1);\n\t\t\tans = max(ans,count2);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n\t\n\tgoto A;\n}\n\n/*\n3\n0 1\n1 0\n1 1\n\n*/"
  },
  {
    "language": "C++",
    "code": "////////////////////\n///   template   ///\n////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\nusing namespace std;\n\n//// MACRO ////\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define allof(c) c.begin(), c.end()\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define EPS 1e-10\n#define INF 1000000000\n\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n#define PREDIACTE(t,a) [](const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) [](const t & a, const t & b) -> bool\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n//// iota iterator ////\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n//// geo ////\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\npair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n//// bit ////\n#ifdef _MSC_VER\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n//// graph ////\nstruct Path\n{\n\tint from;\n\tint to;\n\tdouble cost;\n\tPath(int from = 0, int to = 0, double cost = 0) : from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\npair<double, vector<int>> prim(const vector<vector<double>> &costTable)\n{\n\tint N = costTable.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(0, 0, 0));\n\n\tvector<int> parent(N, -1);\n\tdouble totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(Path(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\npair<vector<double>, vector<int>> dijkstra(const vector<vector<Path>> &routes, int start = 0, int goal = -1)\n{\n\tint N = routes.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<double> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tPath next = Path(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n//// i/o ////\ntemplate <class T>\nclass vevector : public vector<vector<T>>\n{\npublic:\n\tvevector(int n = 0, int m = 0) : vector<vector<T>>(n, vector<T>(m)) { };\n\tvevector(int n, int m, const T &initial) : vector<vector<T>>(n, vector<T>(m, initial)) { };\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(read<T>(read<int>())); return v; }\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T> void write(const T &t, const T &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\ntemplate<class T>\nistream & operator>>(istream & in, complex<T> & n) { T r, i; in >> r >> i; n = complex<T>(r, i); return in; }\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\t// freopen(\"A.in\", \"r\", stdin);\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tauto testcases = INF; // read<int>();\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\n\t\tauto ps = read<P2>(N);\n\n\t\tint result = min(N, 2);\n\t\tREP(i_, N) FOR(j_, i_ + 1, N)\n\t\t{\n\t\t\tconst P2 i = ps[i_], j = ps[j_];\n\t\t\tdouble r = 1;\n\t\t\tif (abs(i - j) - 2 * r > -EPS) { continue; } // 遠すぎて円が作れない\n\n\t\t\tauto c = get_same_distance_points(i, j, r); // i と j から ちょうど r 離れた点\n\n\t\t\tauto c1 = Circle(c.first, r), c2 = Circle(c.second, r);\n\t\t\tresult = max<int>(result, count_if(allof(ps), [c1, r](P2 p) { return c1.Contains(p); }));\n\t\t\tresult = max<int>(result, count_if(allof(ps), [c2, r](P2 p) { return c2.Contains(p); }));\n\t\t}\n\n\t\twrite(result);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define REPP(i,j,n) for(int i=(j);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-5, pi = acos(-1.0);\nld dot(Point a, Point b){return real(conj(a)*b);}\nld cross(Point a, Point b){ return imag(conj(a)*b);}\n\nPoint p[310];\nint n;\n\nvoid solve(){\n  int result=1;\n  REP(i,n){\n    REPP(j,i+1,n){\n      Point ab=p[j]-p[i];\n      if(norm(ab)>4)continue;\n      Point c=(p[i]+p[j])/2.L+Point{imag(ab),-real(ab)}*sqrt(1-norm(ab)/4.L)/abs(ab)/2.L;\n      Point d=(p[i]+p[j])/2.L+Point{-imag(ab),real(ab)}*sqrt(1-norm(ab)/4.L)/abs(ab)/2.L;\n      int cntc=0,cntd=0;\n      REP(k,n){\n\tif(abs(p[k]-c)<=1.0001L)cntc++;\n\tif(abs(p[k]-d)<=1.0001L)cntd++;\n      }\n      result=max({result,2,cntc,cntd});\n    }\n  }\n  cout<<result<<endl;\n}\n\nint main(){ _;\n  ld r,i;\n  while(cin>>n,n!=0){\n    REP(j,n){\n      cin>>r>>i;\n      p[j]=Point{r,i};\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <complex>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << \"\\n\"\nstatic const int INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[1010][1010];\ndouble w[1000],v[1000];\ndouble box[200010];\nchar field[200][200];\n\nnamespace Geometry{\n  #define equals(a,b) (fabs((a) - (b)) < EPS)\n  #define BOTTOM 0\n  #define LEFT 1\n  #define RIGHT 2\n  #define TOP 3\n  #define gprint(X) cout << fixed << setprecision(5) << (X) << endl\n  #define gprints(X,Y) cout << fixed << setprecision(5) << (X) << \" \" << (Y) << endl\n  const double EPS = 1e-10;\n  static const int COUNTER_CLOCKWISE = 1;\n  static const int CLOCKWISE = -1;\n  static const int ONLINE_BACK = 2;\n  static const int ONLINE_FRONT = -2;\n  static const int ON_SEGMENT = 0;\n  \n  class Point{\n  public:\n    double x,y;\n    Point(double x = 0,double y = 0): x(x),y(y){}\n    Point operator + (Point p){ return Point(x + p.x , y + p.y); }\n    Point operator - (Point p){ return Point(x - p.x , y - p.y); }\n    Point operator += (Point p){ return Point(x += p.x,y += p.y); }\n    Point operator -= (Point p){ return Point(x -= p.x,y -= p.y); }\n    Point operator * (double a){ return Point(a * x , a * y); }\n    Point operator / (double a){ return Point(x / a , y / a); }\n    bool operator < (const Point &p) const{ return x != p.x ? x < p.x : y < p.y; }\n    bool operator == (const Point &p) const{ return equals(x,p.x) && equals(y,p.y); }\n\n    double abs(){ return sqrt(norm()); }\n    double norm(){ return x * x + y * y; }\n    friend ostream& operator << (ostream &os,Point &p){ return os << p.x << \" \" << p.y; }\n    friend istream& operator >> (istream &is,Point &p){ return is >> p.x >> p.y; }\n  };\n\n  struct Segment{\n    Point p1,p2;\n    Segment(){};\n    Segment(Point p1,Point p2): p1(p1) , p2(p2){};\n    friend ostream& operator << (ostream &os,Segment &seg){ return os << seg.p1 << \" \" << seg.p2; }\n    friend istream& operator >> (istream &is,Segment &seg){ return is >> seg.p1 >> seg.p2; }\n  };\n\n  class Circle{\n  public:\n    Point c;\n    double r;\n    Circle(Point c = Point(),double r = 0.0): c(c),r(r){}\n    friend ostream& operator << (ostream &os,Circle &c){ return os << c.c << \" \" << c.r; }\n    friend istream& operator >> (istream &is,Circle &c){ return is >> c.c >> c.r; }\n  };\n\n  typedef Point Vector;\n  typedef Segment Line;\n  typedef vector<Point> Polygon;\n\n  double norm(Vector a){ return  a.x * a.x + a.y * a.y; }\n  double abs(Vector a){ return sqrt(norm(a)); }\n  double dot(Vector a,Vector b){ return a.x * b.x + a.y * b.y; }\n  double cross(Vector a,Vector b){ return a.x * b.y - a.y * b.x; }\n  bool Orthogonal(Vector a,Vector b){ return equals(dot(a,b),0.0); }\n  bool Orthogonal(Point a1,Point a2,Point b1,Point b2){ return Orthogonal(a1 - a2,b1 - b2); }\n  bool Orthogonal(Segment s1,Segment s2){ return equals(dot(s1.p2 - s1.p1,s2.p2 - s2.p1) , 0.0); }\n  bool Parallel(Vector a,Vector b){ return equals(cross(a,b),0.0); }\n  bool Parallel(Point a1,Point a2,Point b1,Point b2){ return Parallel(a1 - a2 , b1 - b2); }\n  bool Parallel(Segment s1,Segment s2){ return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0); }\n  bool less(const Point &a,const Point &b){ return (a.x != b.x) ? a.x < b.x : a.y < b.y; }\n  bool greater(const Point &a,const Point b){ return !less(a,b); }\n\n  Point project(Segment s,Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1 , base) / norm(base);\n    return s.p1 + base * r;\n  }\n\n  Point reflect(Segment s,Point p){\n    return p + (project(s,p) - p) * 2.0;\n  }\n\n  int ccw(Point &p0,Point p1,Point p2){\n    p1 -= p0;\n    p2 -= p0;\n    if(cross(p1,p2) > EPS)return COUNTER_CLOCKWISE;\n    if(cross(p1,p2) < -EPS)return CLOCKWISE;\n    if(dot(p1,p2) < -EPS)return ONLINE_BACK;\n    if(p1.norm() < p2.norm())return ONLINE_FRONT;\n    return ON_SEGMENT;\n  }\n\n  bool intersect(Point p1,Point p2,Point p3,Point p4){\n    return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && \n            ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0);\n  }\n  bool intersect(Segment s1,Segment s2){ return intersect(s1.p1 , s1.p2 , s2.p1 , s2.p2); }\n\n  double distance(Vector a,Vector b){ return abs(a - b); }\n  double distanceLP(Line l,Point p){ return abs(cross(l.p2 - l.p1 , p - l.p1) / abs(l.p2 - l.p1)); }\n  double distanceSP(Segment s,Point p){\n    if(dot(s.p2 - s.p1,p - s.p1) < 0.0) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2,p - s.p2) < 0.0) return abs(p - s.p2);\n    return distanceLP(s,p);\n  }\n  double distance(Segment s1,Segment s2){\n    if(intersect(s1,s2))return 0.0;\n    return min(min(distanceSP(s1,s2.p1),distanceSP(s1,s2.p2)),\n               min(distanceSP(s2,s1.p1),distanceSP(s2,s1.p2)));\n  }\n\n  Point getCrossPoint(Segment s1,Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base,s1.p1 - s2.p1));\n    double d2 = abs(cross(base,s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n  }\n\n  pair<Point,Point> getCrossPoints(Circle c,Line l){\n    Vector pr = project(l,c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base , pr - e * base);\n  }\n\n  double arg(Vector p){ return atan2(p.y,p.x); }\n  Vector polar(double a,double r){ return Point(cos(r) * a, sin(r) * a); }\n\n  pair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r,t + a),c1.c + polar(c1.r,t - a));\n  }\n  \n  int contains(Polygon g,Point p){\n    int n = g.size();\n    bool x = false;\n    for(int i = 0;i < n;i++){\n      Point a = g[i] - p, b = g[(i + 1) % n] - p;\n      if(abs(cross(a,b)) < EPS && dot(a,b) < EPS)return 1;\n      if(a.y > b.y)swap(a,b);\n      if(a.y < EPS && EPS < b.y && cross(a,b) > EPS)x = !x;\n    }\n    return (x ? 2 : 0);\n  }\n\n  //=====================================================//\n  //==================== Andrew Scan ====================//\n  //=====================================================//\n \n  int Accw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS)return 1;\n    return -1;\n  }\n \n  Polygon andrewScan(Polygon s){\n    Polygon ans;\n    Polygon u,l;\n    if(s.size() < 3)return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n    for(int i = 2;i < s.size();i++){\n      for(int n = u.size();n >= 2 && Accw(u[n-2],u[n-1],s[i]) != -1;n--){\n        u.pop_back();\n      }\n      u.push_back(s[i]);\n    }\n \n    for(int i = s.size() - 3;i >= 0;i--){\n      for(int n = l.size();n >= 2 && Accw(l[n-2],l[n-1],s[i]) != -1;n--){\n        l.pop_back();\n      }\n      l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i = u.size() - 2;i >= 1;i--){\n      l.push_back(u[i]);\n    }\n    int f = 0;\n    for(int i = 1;i < l.size();i++){\n      if(l[f].y > l[i].y || (l[f].y == l[i].y && l[f].x > l[i].x)){\n        f = i;\n      }\n    }\n    for(int i = 0;i < l.size();i++){\n      ans.push_back(Point((int)l[(i + f)%l.size()].x,(int)l[(i + f)%l.size()].y));\n    }\n    return ans;\n  }\n\n  //=====================================================//\n  //======================== END ========================//\n  //=====================================================//\n\n  class EndPoint{\n  public:\n    Point p;\n    int seg,st;\n    EndPoint(){}\n    EndPoint(Point p,int seg,int st): p(p),seg(seg),st(st){}\n\n    bool operator < (const EndPoint &ep) const{\n      if(p.y == ep.p.y){\n        return st < ep.st;\n      }else{\n        return p.y < ep.p.y;\n      }\n    }\n  };\n\n  EndPoint EP[2 * 100000];\n\n  int manhattanIntersection(vector<Segment> S){\n    int n = S.size();\n    for(int i = 0,k = 0;i < n;i++){\n      if(S[i].p1.y == S[i].p2.y){\n        if(S[i].p1.x > S[i].p2.x)swap(S[i].p1,S[i].p2);\n      }else if(S[i].p1.y > S[i].p2.y){\n        swap(S[i].p1,S[i].p2);\n      }\n\n      if(S[i].p1.y == S[i].p2.y){\n        EP[k++] = EndPoint(S[i].p1,i,LEFT);\n        EP[k++] = EndPoint(S[i].p2,i,RIGHT);\n      }else{\n        EP[k++] = EndPoint(S[i].p1,i,BOTTOM);\n        EP[k++] = EndPoint(S[i].p2,i,TOP);\n      }\n    }\n\n    sort(EP,EP + (2 * n));\n\n    set<int> BT;\n    BT.insert(1000000001);\n    int cnt = 0;\n    for(int i = 0;i < 2 * n;i++){\n      if(EP[i].st == TOP){\n        BT.erase(EP[i].p.x);\n      }else if(EP[i].st == BOTTOM){\n        BT.insert(EP[i].p.x);\n      }else if(EP[i].st == LEFT){\n        set<int>::iterator b = lower_bound(BT.begin(),BT.end(),S[EP[i].seg].p1.x);\n        set<int>::iterator e = upper_bound(BT.begin(),BT.end(),S[EP[i].seg].p2.x);\n        cnt += distance(b,e);\n      }\n    }\n    return cnt;\n  }\n};\n\nusing namespace Geometry;\n\nint main(){\n  while(cin >> n && n){\n    m = 0;\n    vector<Point> vec(n);\n    rep(i,0,n)cin >> vec[i];\n    clr(d,0);\n    rep(i,0,n){\n      rep(j,i+1,n){\n        if(i == j)continue;\n        // 2点に接する円を作り、その中に含まれる点の数を計算する (円の中心と点の距離が1＋誤差以下ならOK)\n        // 最大で2700万ループ\n        if((distance(vec[i],vec[j])) <= 2){\n          l = 0;\n          Point pnt = (vec[j] - vec[i]) / 2.0;\n          // gprint(pnt);\n          double dist = distance(Point(0,0),pnt);\n          double error = sqrt(1.0 - dist * dist) / dist;\n          // cout << dist << \" \" << error << endl;\n          Point center(vec[i].x + pnt.x - error * pnt.y , vec[i].y + pnt.y + error * pnt.x);\n          // cout << \"Center : \";\n          // gprint(center);\n          rep(k,0,n){\n            // printf(\"Distance (%f,%f) -> %f\\n\",vec[k].x,vec[k].y,distance(center,vec[k]));\n            if(distance(center,vec[k]) < 1.00001)l++;\n          }\n          m = max(m,l);\n        }\n      }\n    }\n    print(m);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\n#define all(c) ((c).begin()),((c).end())\n#define debug(c) cerr<<\"> \"<<#c<<\" = \"<<(c)<<endl;\n#define iter(c) __typeof((c).begin())\n#define tr(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,a,b) for(int i=(int)(a);i<=(int)(b);i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\n#define EPS 1.0e-6\n\n//ツ点\ntypedef complex<double> P;\n\nstruct C{\n\tP p;\n\tdouble r;\n};\n\nvector<P> isCC(const C &c1, const C &c2) {\n\tdouble d = abs(c1.p - c2.p);\n\tdouble x = (d*d + c1.r * c1.r - c2.r * c2.r) / 2 / d;\n\tdouble y = c1.r * c1.r - x * x;\n\tif(y < -EPS) return vector<P>();\n\tif(y < 0) y = 0;\n\tP diff = (c2.p - c1.p) / d;\n\tvector<P> res(2);\n\tres[0] = c1.p + diff * P(x, y);\n\tres[1] = c1.p + diff * P(x, -y);\n\treturn res;\n}\n\nint main() {\n\tfor (int N; cin >> N, N != 0; ) {\n\t\tvector<P> ps;\n\t\trep (i, N) {\n\t\t\tdouble x, y; cin >> x >> y;\n\t\t\tps.pb(P(x, y));\n\t\t}\n\t\tint res = 0;\n\t\trep (i, N) REP (j, i + 1, N-1) {\n\t\t\tvector<P> isp = isCC((C){ps[i],1},(C){ps[j],1});\n\t\t\trep (k, isp.size()) {\n\t\t\t\tint cnt = 0;\n\t\t\t\trep (l, N) if (abs(isp[k] - ps[l]) <= 1) cnt++;\n\t\t\t\tres = max(res, cnt);\n\t\t\t}\n\t\t}\n\t\tcout << res <<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <limits>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS = 1e-9;\n\nbool tolerant_eq(double a, double b){ return abs(a - b) < EPS; }\n\nstruct Point {\n\tdouble x, y;\n\texplicit Point(const double &x = 0.0, const double &y = 0.0) :\n\t\tx(x), y(y)\n\t{ }\n\n\tstatic Point invalid(){\n\t\tdouble qnan = numeric_limits<double>::quiet_NaN();\n\t\treturn Point(qnan, qnan);\n\t}\n\tbool is_valid() const { return !(isnan(x) || isnan(y)); }\n\n\tPoint operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n\tPoint &operator+=(const Point &p){ return *this = *this + p; }\n\tPoint operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n\tPoint &operator-=(const Point &p){ return *this = *this - p; }\n\tPoint operator*(double s) const { return Point(x * s, y * s); }\n\tPoint &operator*=(double s){ return *this = *this * s; }\n\tPoint operator/(double s) const { return Point(x / s, y / s); }\n\tPoint &operator/=(double s){ return *this = *this / s; }\n\n\tbool operator==(const Point &p) const { return x == p.x && y == p.y; }\n\tbool operator!=(const Point &p) const { return x != p.x || y != p.y; }\n\tbool operator<(const Point &p) const {\n\t\treturn (x == p.x) ? (y < p.y) : (x < p.x);\n\t}\n};\n\nPoint operator*(double s, const Point &p){ return p * s; }\n\nbool tolerant_eq(const Point &a, const Point &b){\n\treturn tolerant_eq(a.x, b.x) && tolerant_eq(a.y, b.y);\n}\ndouble abs(const Point &p){ return sqrt(p.x * p.x + p.y * p.y); }\nPoint unit(const Point &p){ return p / abs(p); }\nPoint ortho(const Point &p){ return Point(-p.y, p.x); }\ndouble cross(const Point &a, const Point &b){ return a.x * b.y - a.y * b.x; }\ndouble dot(const Point &a, const Point &b){ return a.x * b.x + a.y * b.y; }\nint ccw(const Point &a, const Point &b, const Point &c){\n\tPoint d = b - a, e = c - a;\n\tif(cross(d, e) > 0.0){ return 1; }\n\tif(cross(d, e) < 0.0){ return -1; }\n\tif(dot(d, e) < 0.0){ return 2; }\n\tif(abs(d) < abs(e)){ return -2; }\n\treturn 0;\n}\n\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\texplicit Circle(const Point &c = Point(), double r = 0.0) :\n\t\tc(c), r(r)\n\t{ }\n\n\tstatic Circle invalid(){\n\t\tdouble qnan = numeric_limits<double>::quiet_NaN();\n\t\treturn Circle(Point::invalid(), qnan);\n\t}\n\tbool is_valid() const { return c.is_valid() && !isnan(r); }\n\n\tbool operator<(const Circle &i) const {\n\t\treturn (r == i.r) ? (c < i.c) : (r < i.r);\n\t}\n};\n\nbool intersect(const Circle &a, const Circle &b){\n\treturn abs(a.c - b.c) <= a.r + b.r;\n}\n\nvector<Point> crosspoint(const Circle &a, const Circle &b){\n\tif(!intersect(a, b)){ return vector<Point>(); }\n\tdouble l = abs(b.c - a.c), s = (l + a.r + b.r) / 2.0;\n\tdouble S = sqrt(s * (s - l) * (s - a.r) * (s - b.r));\n\tdouble d = (S * 2) / l, t = sqrt(a.r * a.r - d * d);\n\tPoint v = t * unit(b.c - a.c);\n\tPoint w = d * unit(ortho(v));\n\tPoint x = a.c + v + w, y = a.c + v - w;\n\tif(tolerant_eq(x, y)){ return vector<Point>(1, x); }\n\tvector<Point> ans(2); ans[0] = x; ans[1] = y;\n\treturn ans;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcout << setiosflags(ios::fixed) << setprecision(10);\n\twhile(true){\n\t\tint N;\n\t\tcin >> N;\n\t\tif(N == 0){ break; }\n\t\tvector<Point> points(N);\n\t\tfor(int i = 0; i < N; ++i){ cin >> points[i].x >> points[i].y; }\n\t\tint answer = 1;\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tCircle ci(points[i], 1.0);\n\t\t\tfor(int j = i + 1; j < N; ++j){\n\t\t\t\tCircle cj(points[j], 1.0);\n\t\t\t\tif(!intersect(ci, cj)){ continue; }\n\t\t\t\tvector<Point> cp = crosspoint(ci, cj);\n\t\t\t\tfor(int k = 0; k < cp.size(); ++k){\n\t\t\t\t\tPoint c = cp[k];\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tfor(int l = 0; l < N; ++l){\n\t\t\t\t\t\tif(abs(c - points[l]) <= 1.0 + EPS){ ++count; }\n\t\t\t\t\t}\n\t\t\t\t\tanswer = max(answer, count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\n#include <ctime>\n#include <numeric>\n#include <fstream>\n#include <valarray>\nusing namespace std;\nstatic const double EPS = 1e-6;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> PI;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int(a.size()))\n#define F first\n#define S second\nconst long double pi=acos(-1.0);\nint dx[]={0,1,0,-1,1,1,-1,-1,0},dy[]={1,0,-1,0,1,-1,1,-1,0};\n\nint n;\npair<double,double> in[300];\nint ans;\n\nint getpointnum(double x,double y,double r){\n  int ret=0;\n  rep(i,n){\n    double tx=in[i].F-x;\n    double ty=in[i].S-y;\n    if(r*r+EPS>=tx*tx+ty*ty)++ret;\n  }\n  return ret;\n}\n\nvoid square(double x,double y,double wh){\n  int t=getpointnum(x+wh/2,y+wh/2,wh/sqrt(2)+1);\n  if(t<=ans)return;\n  ans=max(ans,getpointnum(x+wh/2,y+wh/2,1));\n\n  square(x,y,wh/2);\n  square(x+wh/2,y,wh/2);\n  square(x,y+wh/2,wh/2);\n  square(x+wh/2,y+wh/2,wh/2);    \n}\n\nvoid solve(){\n  rep(i,n)cin>>in[i].F>>in[i].S;\n  ans=0;\n\n  square(-1,-1,11);\n  cout<<ans<<endl;\n}\n\nmain(){\n  while(cin>>n,n)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\nusing namespace std;\n\n#define F(I,J,N) for(int I=J;I<N;I++)\ntypedef complex<double> P;\n#define EPS (1.0e-6)\n\n//内包問題\nclass Inclusion{\nprivate:\n\tP *p;\n\tint n;//n個の点\n\tdouble l;//半径l内に存在\npublic:\n\tInclusion(){}\n\tInclusion(int n){\n\t\tthis->n=n;\n\t\tp =new P[n];\n\t}\n\t~Inclusion(){\n\t\tdelete []p;\n\t}\n\tvoid set(int n,P a){\n\t\tp[n]=a;\n\t}\n\tvoid set(double l){\n\t\tthis->l=l;\n\t}\n\tint pnum(){\n\t\tint cnt;\n\t\tint ans=1;\n\t\tP c,ce,h;\n\t\tF(i,0,n-1){\n\t\t\tF(j,i+1,n){\n\t\t\t\tdouble len=abs(p[i]-p[j]);\n\t\t\t\tif(len<l*2+EPS){\n\t\t\t\t\tc=(p[i]+p[j])/2.0;\n\t\t\t\t\th=(p[i]-p[j])*P(0,1);\n\t\t\t\t\th=h*(sqrt(l*l-len*len/4)/abs(h));\n\t\t\t\t\tlen=l*l;\n\t\t\t\t\tce=c+h;\n\t\t\t\t\tcnt=0;\n\t\t\t\t\tF(k,0,n){\n\t\t\t\t\t\tif(k==i||k==j) cnt++;\n\t\t\t\t\t\telse if(abs2(p[k]-ce)<len+EPS) cnt++;\n\t\t\t\t\t}\n\t\t\t\t\tans=max(ans,cnt);\n\t\t\t\t\tce=c-h;\n\t\t\t\t\tcnt=0;\n\t\t\t\t\tF(k,0,n){\n\t\t\t\t\t\tif(k==i||k==j) cnt++;\n\t\t\t\t\t\telse if(abs2(p[k]-ce)<len+EPS) cnt++;\n\t\t\t\t\t}\n\t\t\t\t\tans=max(ans,cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tdouble abs2(P p){\n\t\treturn this->dot(p,p);\n\t}\n\t//内積\n\tdouble dot(P a,P b){\n\t\treturn (real(a)*real(b)+imag(a)*imag(b));\n\t}\n};\n\nint main(){\n\tint i,n;\n\tdouble x,y;\n\tdouble l;\n\tInclusion *inc;\n\twhile(cin>>n){\n\t\tif(n==0) break;\n\t\tinc=new Inclusion(n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>x>>y;\n\t\t\tinc->set(i,P(x,y));\n\t\t}\n\t\tinc->set(1);\n\t\tcout<<inc->pnum()<<endl;\n\t\tdelete inc;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\nstruct Point{double x,y;};\ndouble dist(Point a,Point b) {return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));}\n\nint main(void){\n    int N;\n    while(cin>>N,N){\n        vector<Point> p(N);\n        int maxcnt=1;\n        rep(i,N)cin>>p[i].x>>p[i].y;\n        rep(i,N){\n            for(int j=i+1;j<N;j++){\n                double d = dist(p[i],p[j]);\n                if(d>2.0)continue;\n                int sign[]={-1,1};\n                rep(s,2){\n                    Point C;\n                    C.x = p[i].x + cos(atan2(p[j].y-p[i].y,p[j].x-p[i].x) + sign[s]*acos(d/2.0));\n                    C.y = p[i].y + sin(atan2(p[j].y-p[i].y,p[j].x-p[i].x) + sign[s]*acos(d/2.0));\n                    int cnt=0;\n                    rep(k,N) cnt += (pow(C.x-p[k].x,2) + pow(C.y-p[k].y,2) <= 1.0001);\n                    if(maxcnt<cnt)maxcnt=cnt;\n                }\n            }\n        }\n        cout<<maxcnt<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-8;\n\nint main() {\n\tfor (;;) {\n\t\tint N; cin >> N;\n\t\tif (N == 0) break;\n\t\tvector<double> x(N), y(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> x[i] >> y[i];\n\t\tint maxi = 1;\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tdouble dx = x[j] - x[i], dy = y[j] - y[i];\n\t\t\t\tdouble d = sqrt(dx * dx + dy * dy);\n\t\t\t\tif (d > 2) continue;\n\t\t\t\tdouble h = sqrt(1 - d * d / 4);\n\t\t\t\tdouble ox = x[i] + dx / 2 - dy / d * h;\n\t\t\t\tdouble oy = y[i] + dy / 2 + dx / d * h;\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tdouble dx = x[k] - ox, dy = y[k] - oy;\n\t\t\t\t\tdouble d2 = dx * dx + dy * dy;\n\t\t\t\t\tif (d <= 1 + EPS) cnt++;\n\t\t\t\t}\n\t\t\t\tmaxi = max(maxi, cnt);\n\t\t\t}\n\t\tcout << maxi << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define MKP make_pair\n#define fi first\n#define se second\ntypedef pair<int, int> pii;\n\nconstexpr int MOD = 1e9 + 7;\nconstexpr int MAX_N = 205;\nconstexpr int MAX_W = 10005;\nconstexpr int INF = 1LL << 60;\n\n/* 基本要素 */\n\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n\n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n\nint n;\nvector<P> v;\n\nbool solve() {\n    v.clear();\n    cin >> n;\n    if (!n) return false;\n\n    for (int i = 0; i < n; ++i) {\n        double x, y;\n        cin >> x >> y;\n        v.emplace_back(P(x, y));\n    }\n\n    int res = 0;\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 0; j <= n; ++j) {\n            auto crs = crosspointCC(v[i], 1.0, v[j], 1.0);\n            for (int k = 0; k < crs.size(); ++k) {\n                int cnt = 0;\n                for (int l = 0; l <= n; ++l) {\n                    double dist = abs(crs[k] - v[l]);\n                    if (dist <= 1.0 + EPS) cnt++;\n                }\n\n                res = max(res, cnt);\n            }\n        }\n    }\n\n    cout << res << endl;\n\n    return true;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define EPS (1e-5)\n\ntypedef complex<double> P;\n\nvector<P> crossPoint(P a, P b)\n{\n\tvector<P> res;\n\tif (abs(abs(b - a) - 2.0) < EPS)\n\t{\n\t\tP c = a + b;\n\t\tres.push_back(P(c.real() / 2, c.imag() / 2));\n\t}\n\telse if (abs(b - a) < 2.0)\n\t{\n\t\tP ab = b - a;\n\t\tP center = a + P(ab.real() / 2, ab.imag() / 2);\n\t\tP un1 = (ab * P(0, +1)) / abs(ab);\n\t\tP un2 = (ab * P(0, -1)) / abs(ab);\n\t\tdouble dist = sqrt(1 - pow(abs(ab) / 2, 2));\n\t\tP c1 = center + un1 * dist;\n\t\tP c2 = center + un2 * dist;\n\t\tres.push_back(c1);\n\t\tres.push_back(c2);\n\t}\n\treturn res;\n}\n\nvoid solve()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<P> p(n);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = P(x, y);\n\t\t}\n\t\tint ans = 1;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\t{\n\t\t\t\tvector<P> v = crossPoint(p[i], p[j]);\n\t\t\t\tif (v.empty())\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint countA = 2;\n\t\t\t\tint countB = 2;\n\t\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t\t{\n\t\t\t\t\tif (i == k || j == k)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (abs(v[0] - p[k]) - 1.0 < EPS)\n\t\t\t\t\t{\n\t\t\t\t\t\tcountA++;\n\t\t\t\t\t}\n\t\t\t\t\tif (v.size() == 2 && abs(v[1] - p[k]) - 1.0 < EPS)\n\t\t\t\t\t{\n\t\t\t\t\t\tcountB++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = max(ans, max(countA, countB));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\nint main(void)\n{\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef complex<double> P;\nconst double EPS = 1e-8;\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    vector<P> v;\n    REP(i,n) {\n      double x,y;\n      cin >> x >> y;\n      v.push_back(P(x,y));\n    }\n    int ans = 0;\n    REP(i,n-1) {\n      for (int j=i+1;j<n;j++) {\n        P m = (v[i]+v[2])*P(0.5,0);\n        P a = v[i]-v[j];\n        double dis = abs(a);\n        double d = sqrt(1-dis*dis/4);\n        int hoge[]={1,-1};\n        REP(k,2) {\n          P un = (a * P(0, hoge[k])) / dis;\n          P o1 = m + un*d;\n          int sum = 0;\n          REP(l,n) {\n            if (norm(v[l]-o1)<1+EPS) sum++;\n          }\n          ans = max(ans,sum);\n        }\n      }\n    }\n    cout << ans << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconstexpr double EPS = 1e-6;\n\ninline double sq(double x) { return x*x; }\n\nstruct point {\n    double x, y;\n    point() {}\n    point(double x, double y): x(x), y(y) {}\n\n    point operator + (const point& o) const { return point(x+o.x, y+o.y); }\n    point operator - (const point& o) const { return point(x-o.x, y-o.y); }\n    point operator * (const double a) const { return point(x*a, y*a); }\n    point operator / (const double a) const { return point(x/a, y/a); }\n};\n\ndouble fabs(point a) { return sqrt(a.x*a.x + a.y*a.y); }\ndouble dist(point a, point b) { return fabs(a - b); }\n\nint N;\npoint P[300];\n\nint solve() {\n    int ans = 1;\n    for (int i = 0; i < N; ++i) {\n        for (int j = i+1; j < N; ++j) {\n            if (dist(P[i], P[j]) > 2) continue;\n\n            point d = (P[j] - P[i]) / dist(P[i], P[j]);\n            point t = (P[i] + P[j]) / 2;\n            double k = sqrt(1 - sq(dist(P[i], P[j]) / 2));\n            point cs[2] = {t + point(d.y, -d.x) * k, t + point(-d.y, d.x) * k};\n\n            for (point c : cs) {\n                int count = 0;\n                for (int i = 0; i < N; ++i) {\n                    if (dist(c, P[i]) <= 1 + EPS) ++count;\n                }\n                ans = max(ans, count);\n            }\n        }\n    }\n\n    return ans;\n}\n\nint main(void) {\n    while (true) {\n        cin >> N; if (N == 0) break;\n        for (int i = 0; i < N; ++i) cin >> P[i].x >> P[i].y;\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define re real()\n#define im imag()\nusing namespace std;\nint main(){\n\twhile(true){\n\t\tint n,mx=1;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\tcomplex<double> p[300];\n\t\trep(i,n) scanf(\"%lf%lf\",&p[i].re,&p[i].im);\n\t\trep(i,n) rep(j,i){\n\t\t\tdouble d=abs(p[i]-p[j]);\n\t\t\tif(d>2) continue;\n\t\t\tcomplex<double> c=(p[i]+p[j])/2.0,dis=(p[i]-p[j])/d*sqrt(1-d*d/4);\n\t\t\tswap(dis.re,dis.im);\n\t\t\tdis.im=-dis.im;\n\t\t\tcomplex<double> cen=c+dis;\n\t\t\tint cnt=0;\n\t\t\trep(k,n) if(abs(cen-p[k])<=1.0000000001) cnt++;\n\t\t\tmx=max(mx,cnt);\n\t\t\tcen=c-dis;\n\t\t\tcnt=0;\n\t\t\trep(k,n) if(abs(cen-p[k])<=1.0000000001) cnt++;\n\t\t\tmx=max(mx,cnt);\n\t\t}\n\t\tprintf(\"%d\\n\",mx);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\ntypedef complex<double> Point;\n\nconst double EPS = 0.000001;\n\nint main(){\n\t\n\tA:;\n\t\n\tint n;\n\tcin>>n;\n\t\n\tif(n==0)return 0;\n\t\n\tvector<Point> point;\n\trep(i,n){\n\t\tdouble a,b;\n\t\tcin>>a>>b;\n\t\tpoint.push_back(Point(a,b));\n\t}\n\t\n\tint ans = 1;\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(i==j)continue;\n\t\t\t\n\t\t\tPoint p1 = point[j];\n\t\t\tPoint p0 = point[i];\n\t\t\t\n\t\t\tPoint diff = p1-p0;\n\t\t\tPoint d2 = diff/Point(2,0);\n\t\t\t\n\t\t\tdouble dlen = abs(d2);\n\t\t\tif(dlen>1.0)continue;\n\t\t\t\n\t\t\tdouble clen = sqrt(1-dlen*dlen);\n\t\t\tPoint e = d2*Point(0,1);\n\t\t\te = e/Point(abs(e),0)*Point(clen,0);\n\t\t\t\n\t\t\tPoint t = p0 + d2 + e;\n\t\t\t\n\t\t\tint count = 0;\n\t\t\trep(k,n){\n\t\t\t\tif(abs(t-point[k])<=1.0+EPS)count++;\n\t\t\t}\n\t\t\tans = max(ans,count);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n\t\n\tgoto A;\n}\n/*\n3\n6.47634 7.69628\n5.16828 4.79915\n6.69533 6.20378\n\n2\n0 0\n0.8 0\n\n2\n0 0\n0.5 0.5\n\n2\n0 0\n0 2\n\n6\n7.15296 4.08328\n6.50827 2.69466\n5.91219 3.86661\n5.29853 4.16097\n6.10838 3.46039\n6.34060 2.41599\n\n*/"
  },
  {
    "language": "C++",
    "code": "// Circle and Points\n\n// 平面走査ごり押し\n\n#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle().crosspoint()の戻り値\nusing namespace std;\n\nconst double EPS = 1e-10;\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\npublic:\n    double x, y;\n    Point(double a = 0.0, double b = 0.0) :x(a), y(b) {};\n    bool operator== (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    Point operator+(const Point&) const;\n    Point operator-(const Point&) const;\n    Point operator-() const;\n    Point times(double) const;\n    Point& operator=(const Point&);\n    Point& operator+=(const Point&);\n    Point& operator-=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    Point projection(const Line&) const;\n    Point reflection(const Line&) const;\n    int ccw(const Point&, const Point&) const;              // a.ccw(b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n};\nclass Segment {\npublic:\n    Point source, target;\n    Segment(Point a = Point(), Point b = Point()) :source(a), target(b) {};\n    Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n};\nclass Line {\npublic:\n    Point source, target;\n    Line(Point a = Point(), Point b = Point()) :source(a), target(b) {};\n    Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    Point projection(const Point&) const;\n    Point reflection(const Point&) const;\n    Point crosspoint(const Line&) const;\n};\nclass Circle {\npublic:\n    double x, y, r;\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :x(a), y(b), r(c) {};\n    Point point() const;\n    double distance(const Point&) const;                    // 円の中心と点の距離\n    double distance(const Circle&) const;                   // 円の中心同士の距離\n    bool include(const Point&) const;                       // 点を含むか\n    bool include(const Circle&) const;                      // 円を含むか\n    bool intersect(const Circle&) const;\n    vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x == p.x && y == p.y;}\nbool Point::operator<(const Point &p) const {return x != p.x ? x < p.x : y < p.y;}\nbool Point::operator>(const Point &p) const {return x != p.x ? x > p.x : y > p.y;}\nbool Point::operator<=(const Point &p) const {return x != p.x ? x < p.x : y <= p.y;}\nbool Point::operator>=(const Point &p) const {return x != p.x ? x > p.x : y >= p.y;}\nPoint Point::operator+(const Point& p) const {return Point(x + p.x, y + p.y);}\nPoint Point::operator-(const Point& p) const {return Point(x - p.x, y - p.y);}\nPoint Point::operator-() const {return Point(-x, -y);}\nPoint Point::times(double d) const {return Point(x * d, y * d);}\nPoint& Point::operator=(const Point& p) {x = p.x; y = p.y; return *this;}\nPoint& Point::operator+=(const Point& p) {x += p.x; y += p.y; return *this;}\nPoint& Point::operator-=(const Point& p) {x -= p.x; y -= p.y; return *this;}\ndouble Point::dot(const Point& p) const {return x * p.x + y * p.y;}\ndouble Point::cross(const Point& p) const {return x * p.y - y * p.x;}\ndouble Point::abs() const {return hypot(x, y);}\ndouble Point::norm() const {return x * x + y * y;}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nPoint Point::projection(const Line& l) const {return l.projection(*this);}\nPoint Point::reflection(const Line& l) const {return l.reflection(*this);}\nint Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > 0.0) return 1;\n    if(v1.cross(v2) < 0.0) return -1;\n    if(v1.dot(v2) < 0.0) return 2;\n    if(v1.norm() < v2.norm()) return -2;\n    return 0;\n}\n// Segment\nLine Segment::line() const {return Line(source, target);}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    double a = source.distance(p);\n    double b = target.distance(p);\n    return a < b ? a : b;\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source);\n    double b = distance(s.target);\n    double c = s.distance(source);\n    double d = s.distance(target);\n    a = a < b ? a : b;\n    a = a < c ? a : c;\n    return a < d ? a : d;\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {\n    return source.distance(p) + target.distance(p) - target.distance(source) <= EPS;\n}\nbool Segment::intersect(const Segment& s) const {\n    bool a = s.source.ccw(s.target, source) * s.source.ccw(s.target, target) <= EPS;\n    bool b = source.ccw(target, s.source) * source.ccw(target, s.target) <= EPS;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\n// Line\nSegment Line::segment() const {return Segment(source, target);}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source);\n    double b = distance(s.target);\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source);}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source - p;\n    Point v2 = target - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target - source;\n    Point v2 = s.source - source;\n    Point v3 = s.target - source;\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target - source;\n    Point v2 = l.target - l.source;\n    Point v3 = l.source - source;\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nPoint Line::projection(const Point& p) const {\n    Point v1 = p - source;\n    Point v2 = source - target;\n    return Point(source + v2.times(v1.dot(v2) / v2.norm()));\n}\nPoint Line::reflection(const Point& p) const {\n    return p + (projection(p) - p).times(2.0);\n}\nPoint Line::crosspoint(const Line& l) const {\n    Point v1 = target - source;\n    Point v2 = l.target - l.source;\n    Point v3 = target - l.source;\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source;\n    return l.source + v2.times(b / a);\n}\n// Circle\nPoint Circle::point() const {return Point(x, y);}\ndouble Circle::distance(const Point& p) const {return point().distance(p);}\ndouble Circle::distance(const Circle& c) const {return point().distance(c.point());}\nbool Circle::include(const Point& p) const {return distance(p) - r <= EPS;}\nbool Circle::include(const Circle& c) const {return distance(c) - (r - c.r) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return distance(c) - r - c.r <= EPS;}\nvector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y - y, c.x - x);\n    double d = distance(c);\n    double add = acos((d * d + r * r - c.r * c.r) / (2.0 * d * r));\n    vector<Point> result;\n    result.push_back(Point(x + r * cos(angle + add), y + r * sin(angle + add)));\n    result.push_back(Point(x + r * cos(angle - add), y + r * sin(angle - add)));\n    return result;\n}\n\nint main() {\n    int n;\n    while(cin>>n, n) {\n        vector<Circle> circle;\n        vector<Circle> crosspoint;\n        for(int i = 0; i < n; i++) {\n            double x, y;\n            cin>>x>>y;\n            circle.push_back(Circle(x, y, 1.0));\n        }\n        for(int i = 0; i < n - 1; i++) {\n            for(int j = i + 1; j < n; j++) {\n                if(!circle[i].intersect(circle[j])) continue;\n                vector<Point> p = circle[i].crosspoint(circle[j]);\n                crosspoint.push_back(Circle(p[0].x, p[0].y, 1.0));\n                crosspoint.push_back(Circle(p[1].x, p[1].y, 1.0));\n            }\n        }\n        int answer = 0;\n        for(int i = 0; i < crosspoint.size(); i++) {\n            int count = 0;\n            for(int j = 0; j < n; j++) {\n                if(crosspoint[i].include(circle[j].point())) count++;\n            }\n            if(answer < count) answer = count;\n        }\n        cout<<answer<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint N;\npair<double,double> dots[300];\n#define EPS (1e-6)\n\n\nint main(){\n\n\twhile(cin >> N && N != 0){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tpair<double,double> p;\n\t\t\tcin >> dots[i].second >> dots[i].first;\n\t\t}\n\t\tint maxCnt = 1;\n\t\t// ~ðìé½ßÌQ_ðßé\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = i+1; j < N; j++){\n\t\t\t\tpair<double,double> dot1,dot2;\n\t\t\t\tdot1 = dots[i];\n\t\t\t\tdot2 = dots[j];\n\n\t\t\t\tdouble v = sqrt((dot1.first - dot2.first)*(dot1.first - dot2.first)\n\t\t\t\t\t+(dot1.second - dot2.second)*(dot1.second - dot2.second));\n\t\t\t\t// ñ_Ô£ª2æè¨¨«¯êÎÂ­êÈ¢\n\t\t\t\tif(v > 2.0 + EPS){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdouble x = sqrt(1 - (v/2)*(v/2));\n\n\t\t\t\t// ñgÌPÊ@üxNg\n\t\t\t\tpair<double,double> hose[2];\n\t\t\t\those[0].first = -1.0/(dots[i].first - dots[j].first);\n\t\t\t\those[0].second = 1.0/(dots[i].second - dots[j].second);\n\t\t\t\those[1].first = 1.0/(dots[i].first - dots[j].first);\n\t\t\t\those[1].second = -1.0/(dots[i].second - dots[j].second);\n\n\t\t\t\tdouble dd1 = sqrt((hose[0].second)*(hose[0].second)+(hose[0].first)*(hose[0].first));\n\t\t\t\tdouble dd2 = sqrt((hose[1].second)*(hose[1].second)+(hose[1].first)*(hose[1].first));\n\t\t\t\those[0].first /= dd1; hose[0].second /= dd1;\n\t\t\t\those[1].first /= dd2; hose[1].second /= dd2;\n\n\t\t\t\t// x{·é\n\t\t\t\those[0].first *= x;hose[1].first *= x;\n\t\t\t\those[0].second *= x;hose[1].second *= x;\n\n\t\t\t\t// mð«·\n\t\t\t\those[0].first += (dot1.first + dot2.first)/2;\n\t\t\t\those[0].second += (dot1.second + dot2.second)/2;\n\t\t\t\those[1].first += (dot1.first + dot2.first)/2;\n\t\t\t\those[1].second += (dot1.second + dot2.second)/2;\n\n\t\t\t\t// hose[0]Æhose[1]Í~ÌSÀW\n\t\t\t\t// e_ÉÖµÄ~ÌÉ¶Ý·é©Ç¤©ðßé\n\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor(int l = 0; l < N; l++){\n\t\t\t\t\t\tdouble dist = sqrt((dots[l].first -hose[k].first)*(dots[l].first -hose[k].first)\n\t\t\t\t\t\t\t+ (dots[l].second -hose[k].second)*(dots[l].second -hose[k].second));\n\t\t\t\t\t\tif(dist <= 1.0 + EPS){\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmaxCnt = max(maxCnt,cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << maxCnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <complex>\n\n \nusing namespace std;\n \n#define INF 1000000000\n#define EPS 1e-9\n#define PI acos(-1)\n \ntypedef long long ll;\ntypedef complex<double> vec;\n\n#define MAX_N 300\nint N;\ndouble x[MAX_N], y[MAX_N];\nvector<int> ans_list;\n\nint par[MAX_N];\n\nint main(){\n\n  while(true){\n    cin >> N;\n    if(N == 0)\n      break;\n    for(int i = 0; i < N; i++){\n      cin >> x[i] >> y[i];\n    }\n\n    int ans = 0;\n\n    for(int i = 0; i < N; i++){\n      for(int j = i+1; j < N; j++){\n\tif(sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j])) > 2.0001)\n\t  continue;\n\tint tmp = 0;\n\tvec p1 = vec(x[i], y[i]), p2 = vec(x[j], y[j]);\n\tvec mid = (p2-p1);\n\tmid /= 2;\n\tvec r1 = (mid * vec(0, 1)) / abs(mid);\n\tvec r2 = (mid * vec(0, -1)) / abs(mid);\n\n\tvec R = p1 + mid + r1*sqrt((1-abs(mid)*abs(mid)));\n\tdouble rx = R.real();\n\tdouble ry = R.imag();\n\ttmp = 2;\n\tfor(int k = 0; k < N; k++){\n\t  if(k == i || k == j)\n\t    continue;\n\t  if((rx - x[k])*(rx-x[k]) + (ry - y[k])*(ry - y[k]) < 1)\n\t    tmp++;\n\t}\n\tans = max(ans, tmp);\n\tR = p1 + mid + r2*sqrt((1-abs(mid)*abs(mid)));\n\trx = R.real();\n\try = R.imag();\n\ttmp = 0;\n\tfor(int k = 0; k < N; k++){\n\t  if(k == i || k == j)\n\t    continue;\n\t  if((rx - x[k])*(rx-x[k]) + (ry - y[k])*(ry - y[k]) < 1)\n\t    tmp++;\n\t}\n\tans = max(ans, tmp);\n      }\n    }\n\n    ans_list.push_back(ans);\n    \n  }\n  \n  for(int i = 0; i < ans_list.size(); i++){\n    cout << ans_list[i] << endl;\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D[] points = new Point2D[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tpoints[i] = new Point2D(sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tint max = 0;\n\t\t\t\n\t\t\tfor(int fst = 0; fst < n; fst++){\n\t\t\t\tfor(int snd = 0; snd < n; snd++){\n\t\t\t\t\tPoint2D[] cross = Point2D.cross_ss(points[fst], 1, points[snd], 1);\n\t\t\t\t\t\n\t\t\t\t\tfor(Point2D cross_c : cross){\n\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\t\tif(cross_c.dist(points[i]) <= 1.0 + Point2D.EPS){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tmax = Math.max(max, count);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t\t\n\t}\n}\n\nclass Point2D {\n    public double x;\n    public double y;\n \n    public static final double EPS = 1e-4;\n \n    public Point2D(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n \n    public Point2D(Point2D point) {\n        this.x = point.x;\n        this.y = point.y;\n    }\n \n    public String toString() {\n        return x + \",\" + y;\n    }\n \n    @Override\n    public boolean equals(Object o) {\n        if (o instanceof Point2D) {\n            Point2D another = (Point2D) o;\n            if (this.x - EPS < another.x && this.x + EPS > another.x\n                    && this.y - EPS < another.y && this.y + EPS > another.y) {\n                return true;\n            }\n             \n            return false;\n \n            // return this.x == another.x && this.y == another.y;\n        }\n        return false;\n    }\n \n    public Point2D add(double x, double y) {\n        return new Point2D(this.x + x, this.y + y);\n    }\n \n    public Point2D sub(double x, double y) {\n        return add(-x, -y);\n    }\n \n    public Point2D add(Point2D another) {\n        return add(another.x, another.y);\n    }\n \n    public Point2D sub(Point2D another) {\n        return sub(another.x, another.y);\n    }\n \n    public Point2D mul(double d) {\n        return new Point2D(this.x * d, this.y * d);\n    }\n \n    public Point2D div(double d) {\n        return new Point2D(this.x / d, this.y / d);\n    }\n \n    public double dot(double x, double y) {\n        return this.x * x + this.y * y;\n    }\n \n    public double dot(Point2D another) {\n        return dot(another.x, another.y);\n    }\n \n    public double cross(double x, double y) {\n        return this.x * y - this.y * x;\n    }\n \n    public double cross(Point2D another) {\n        return cross(another.x, another.y);\n    }\n \n    public double dist(double x, double y) {\n        return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n                * (this.y - y));\n    }\n \n    public double dist(Point2D another) {\n        return dist(another.x, another.y);\n    }\n \n    public double dist_o() {\n        return dist(0, 0);\n    }\n \n    public Point2D unit() {\n        return div(dist_o());\n    }\n \n    public boolean pol(Point2D start, Point2D end) {\n        return end.sub(start).cross(this.sub(start)) < EPS;\n    }\n \n    public boolean pos(Point2D start, Point2D end) {\n        return (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n    }\n \n    public double pld(Point2D start, Point2D end) {\n        return Math.abs((end.sub(start).cross(this.sub(start)))\n                / end.sub(start).dist_o());\n    }\n \n    public double psd(Point2D start, Point2D end) {\n        if (end.sub(start).dot(this.sub(start)) < EPS) {\n            return this.dist(start);\n        } else if (start.sub(end).dot(this.sub(end)) < EPS) {\n            return this.dist(end);\n        } else {\n            return end.sub(start).cross(this.sub(start)) / end.dist(start);\n        }\n    }\n \n    public static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS)\n                && (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n    }\n \n    public static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return a1.sub(a2).cross(b1.sub(b2)) < EPS;\n    }\n \n    public static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D b = b2.sub(b1);\n        double d1 = Math.abs(b.cross(a1.sub(b1)));\n        double d2 = Math.abs(b.cross(a2.sub(b1)));\n        double t = d1 / (d1 + d2);\n        Point2D a = a2.sub(a1), v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D a = a2.sub(a1);\n        Point2D b = b2.sub(b1);\n        double t = b.cross(b1.sub(a1)) / b.cross(a);\n        Point2D v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n            double r2) {\n        double dis = p1.dist(p2);\n \n        if (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n            return new Point2D[0]; // same\n        }\n \n        if (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n            Point2D tmp = p2.sub(p1);\n            tmp = tmp.mul(r1 / tmp.dist_o());\n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis + EPS > r1 + r2) {\n            return new Point2D[0]; // out\n        }\n \n        double dis_m = Math.abs(r1 - r2);\n \n        if (dis_m + EPS > dis && dis_m - EPS < dis) {\n            Point2D tmp = null;\n            if (r1 > r2) {\n                tmp = p2.sub(p1);\n            } else {\n                tmp = p1.sub(p2);\n            }\n \n            double min = Math.min(r1, r2);\n \n            tmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n \n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis_m + EPS > dis) {\n            return new Point2D[0]; // inner\n        } else {\n            Point2D ret[] = new Point2D[2];\n \n            double theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n                    / (2 * dis * r1));\n            double a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n \n            ret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n                    * Math.sin(a + theta) + p1.y);\n            ret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n                    * Math.sin(a - theta) + p1.y);\n            return ret;\n        }\n    }\n \n    public void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n            Point2D ans[]) {\n        if (c.pld(start, end) > r + EPS)\n            return;\n        Point2D v = end.sub(start).unit();\n        double delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n                - start.dist(c) * start.dist(c) + r * r;\n        double t = -v.dot(start.sub(c));\n        double s = Math.sqrt(delta);\n        ans[0] = start.add(v.mul(t + s));\n        ans[1] = start.add(v.mul(t + s));\n    }\n \n    public Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n        Point2D v = b.sub(a).unit();\n        v = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n                (-1) * v.y, v.x);\n        return v.mul(p.pld(a, b));\n    }\n \n    public double area(Point2D a, Point2D b, Point2D c) {\n        return Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n    }\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\nR radNorP(R x) {\n    return fmod(fmod(x, 2*PI)+2*PI, 2*PI);\n}\n\nconst int MN = 330;\n\nP p[MN];\ntypedef pair<R, int> Pi;\n\nbool solve() {\n    int n;\n    cin >> n;\n    if (!n) return false;\n\n    for (int i = 0; i < n; i++) {\n        R x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n    }\n\n    int res = 1;\n    for (int i = 0; i < n; i++) {\n        vector<Pi> v;\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            if (2.0 < abs(p[j]-p[i])) continue;\n            R th = acos(abs(p[j]-p[i])/2.0);\n            R l = radNorP(arg(p[j]-p[i])-th-EPS);\n            R r = radNorP(arg(p[j]-p[i])+th+EPS);\n            if (r < l) {\n                v.push_back(Pi(l-EPS, 1));\n                v.push_back(Pi(2*PI+EPS, -1));\n                v.push_back(Pi(0-EPS, 1));\n                v.push_back(Pi(r+EPS, -1));\n            } else {\n                v.push_back(Pi(l-EPS, 1));\n                v.push_back(Pi(r+EPS, -1));\n            }\n\n        }\n\n        sort(v.begin(), v.end());\n        int sm = 1;\n        for (Pi p: v) {            \n            sm += p.second;\n            res = max(res, sm);\n        }\n    }\n    cout << res << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\ntypedef complex<double> P;\nconst double r = 1.0;\n\n\nvector<P> GetCrossPoint(P a, P b)\n{\n\tvector<P> res;\n\t\n\t// ツ堕スツ閉ェツつャツづィツつャツづィツ静堋触ツつオツづつ「ツづゥ\n\tif(abs(abs(b - a) - r * 2) < EPS)\n\t{\n\t\tP c = a + b;\n\t\tres.push_back( P(c.real() / 2,c.imag() / 2) );\n\t}\n\t// ツ閉津環づ可古ーツづュツづづつ「ツづゥ\n\telse if(abs(b - a) < r * 2)\n\t{\n\t\tP ab = b - a;\n\t\tP center = a + P(ab.real() / 2, ab.imag() / 2);\n\t\t\n\t\tP u1 = (ab * P(0, +1)) / abs(ab);\n\t\tP u2 = (ab * P(0, -1)) / abs(ab);\n\t\t\n\t\tdouble dist = sqrt(1 - pow(abs(ab) / 2, 2));\n\t\tP c1 = center + u1 * dist;\n\t\tP c2 = center + u2 * dist;\n\t\t\n\t\tres.push_back(c1);\n\t\tres.push_back(c2);\n\t}\n\t\n\treturn res;\n}\n\n\nint main()\n{\n\tint n;\n\twhile(cin >> n && n)\n\t{\n\t\tvector<P> c(n);\n\t\t\n\t\tdouble x, y;\n\t\t\n\t\trep(i, n)\n\t\t{\n\t\t\tcin >> x >> y;\n\t\t\t\n\t\t\tc[i] = P(x, y);\n\t\t}\n\t\t\n\t\t\n\t\tint res = 1;\n\t\t\n\t\trep(i, n) REP(j, i + 1, n)\n\t\t{\n\t\t\tvector<P> crs(GetCrossPoint(c[i], c[j]));\n\t\t\t\n\t\t\trep(k, crs.size())\n\t\t\t{\n\t\t\t\tint cover = 2;\n\t\t\t\t\n\t\t\t\trep(l, n) if(l != i && l != j && abs(crs[k] - c[l]) - 1.0 < EPS)\n\t\t\t\t{\n\t\t\t\t\tcover++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tchmax(res, cover);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef complex<double> Point;\nconst double eps = 1e-9;\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint N; \n\twhile (cin >> N, N) {\n\t\tvector<Point> P(N);\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\tdouble x, y; cin >> x >> y;\n\t\t\tP[i] = Point(x, y);\n\t\t}\n\t\tif (N == 1) { cout << 1 << endl; continue; }\n\t\tint ans = 1;\n\t\tfor (int i = 0; i < N;i++) for (int j = i + 1; j < N;j++) {\n\t\t\tdouble dist = abs(P[i] - P[j]);\n\t\t\tif (dist > 2) continue;\n\t\t\tdouble r = sqrt(1 - dist*dist / 4);\n\t\t\tdouble difx = -(P[i] - P[j]).imag()*r / dist;\n\t\t\tdouble dify = (P[i] - P[j]).real()*r / dist;\n\t\t\tPoint new_P(difx, dify);\n\t\t\tPoint check_P(new_P + (P[i] + P[j]) / 2.0);\n\t\t\t\n\t\t\tint cnt = 0;\n\t\t\tfor (int k = 0; k < N;k++) {\n\t\t\t\tif (abs(check_P - P[k]) < 1.0 + eps)cnt++;\n\t\t\t}\n\t\t\tans = max(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> P;\nconst LL MOD = 1000000007LL;\nconst double EPS = 1e-10;\nstruct Point {\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\tPoint operator+(const Point &p) const {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator-(const Point &p) const {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator*(const double a) const {\n\t\treturn Point(x*a, y*a);\n\t}\n\tPoint operator/(double a) const {\n\t\treturn Point(x / a, y / a);\n\t}\n\tdouble abs() const {\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm() const {\n\t\treturn x*x + y*y;\n\t}\n\tbool operator<(const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator==(const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\ntypedef Point Vector;\nstruct Segment {\n\tPoint p1, p2;\n};\ntypedef Segment Line;\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\ntypedef vector<Point> Polygon;\ndouble norm(Vector a);\ndouble abs(Vector a);\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\nbool equals(double a, double b);\nbool isOrthogonal(Vector a, Vector b);\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2);\nbool isOrthogonal(Segment s1, Segment s2);\nbool isParallel(Vector a, Vector b);\nbool isParallel(Point a1, Point a2, Point b1, Point b2);\nbool isParallel(Segment s1, Segment s2);\nPoint project(Segment s, Point p);\nPoint reflect(Segment s, Point p);\nint ccw(Point p0, Point p1, Point p2);\ndouble getDistance(Point a, Point b);\ndouble getDistanceLP(Line l, Point p);\ndouble getDistanceSP(Segment s, Point p);\ndouble getDistance(Segment s1, Segment s2);\nbool intersect(Point p1, Point p2, Point p3, Point p4);\nbool intersect(Segment s1, Segment s2);\nbool intersect(Circle c, Line l);\nbool intersect(Circle c1, Circle c2);\nPoint getCrossPoint(Segment s1, Segment s2);\npair<Point, Point> getCrossPoints(Circle c, Line l);\ndouble arg(Vector p);\nVector polar(double a, double r);\npair<Point, Point> getCrossPoints(Circle c1, Circle c2);\ndouble norm(Vector a) {\n\treturn a.x*a.x + a.y*a.y;\n}\ndouble abs(Vector a) {\n\treturn sqrt(norm(a));\n}\ndouble dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\ndouble cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\nbool equals(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base*r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\ndouble getDistance(Point a, Point b) {\n\treturn abs(a - b);\n}\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nbool intersect(Circle c, Line l) {\n\treturn getDistanceLP(l, c.c) <= c.r;\n}\nbool intersect(Circle c1, Circle c2) {\n\treturn getDistance(c1.c, c2.c) <= c1.r + c2.r;\n}\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r*c.r - norm(pr - c.c));\n\treturn make_pair(pr + e*base, pr - e*base);\n}\ndouble arg(Vector p) {\n\treturn atan2(p.y, p.x);\n}\nVector polar(double a, double r) {\n\treturn Vector(cos(r)*a, sin(r)*a);\n}\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\tassert(intersect(c1, c2));\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tPoint p[300];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = Point(x, y);\n\t\t}\n\t\tint ans = 1;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tVector d = p[j] - p[i];\n\t\t\t\tif (d.abs() > 2.0) continue;\n\t\t\t\tPoint m = p[i] + d / 2.0;\n\t\t\t\tVector r = Vector(-d.y, d.x);\n\t\t\t\tr = r / r.abs()*sqrt(1 - pow(d.abs() / 2.0, 2));\n\t\t\t\tPoint p1 = m + r;\n\t\t\t\tPoint p2 = m - r;\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tint cnt2 = 0;\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif ((p[k] - p1).abs() <= 1+EPS) cnt1++;\n\t\t\t\t\tif ((p[k] - p2).abs() <= 1+EPS) cnt2++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, max(cnt1, cnt2));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\n\nconst long double EPS = 10e-6;\n\nclass Point{\n    public: \n    long double x,y;\n    \n    Point(long double x = 0.0, long double y = 0.0): x(x), y(y) {}\n    \n    Point operator + (Point p) {\n        return Point(x+p.x, y+p.y);\n    }\n    Point operator - (Point p) {\n        return Point(x-p.x, y-p.y);\n    }\n    Point operator * (long double a) {\n        return Point(x*a, y*a);\n    }\n    Point operator / (long double a) {\n        return Point(x/a, y/a);\n    }\n    \n    long double norm() {\n        return x*x + y*y;\n    }\n    \n    long double dot(Point p) {\n        return x*p.x + y*p.y;\n    }\n};\n\nPoint calc_center(Point p, Point mid, Point midv){\n    long double norm = mid.norm();\n    midv = midv * sqrt(1.0 - norm / norm);\n    return p+mid+midv;\n}\n\nint count(vector<Point> points, Point center){\n    int tmp = 0;\n    for(Point p: points){\n        if((p-center).norm() <= 1.0 + EPS) tmp++;\n    }\n    return tmp;\n}\n\nint main() {\n    int n;\n    while(scanf(\"%d\", &n) && n){\n        vector<Point> points(n);\n        rep(n) scanf(\"%Lf %Lf\", &points[i].x, &points[i].y);\n\n        int ans = 1;\n        rep(n){\n            repp(j, n){\n                if(j == i) continue;\n                Point mid = (points[j] - points[i]) * 0.5;\n                Point center = calc_center(points[i], mid, Point(mid.y, -mid.x));\n                ans = max(count(points, center), ans);\n\n                center = calc_center(points[i], mid, Point(-mid.y, mid.x));\n                ans = max(count(points, center), ans);\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\nvoid chmax(int &a,int b){\ta=max(a,b);\treturn;\t}\n\n#define EPS 1e-8\n#define EQ(x, y) (abs((x)-(y))<EPS)\n#define GE(x, y) ((x)>(y)||EQ(x, y))\n#define LE(x, y) ((x)<(y)||EQ(x, y))\n\ntypedef complex<double> point;//changed\ntypedef point vec;//changed\ntypedef array<point, 2> line;//changed\ntypedef vector<point> poly;//changed\n\nstruct circle {//changed\n\tpoint c;\n\tdouble r;\n};\n\nvector<point> CrosspointCC(circle c1, circle c2) {\n\tvector<point> ret;\n\tdouble d = abs(c1.c - c2.c);\n\tdouble rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n\tdouble dfr = c1.r*c1.r - rc*rc;\n\n\tif (EQ(dfr, 0.0)) dfr = 0.0;\n\telse if(dfr < 0.0) return ret;\n\n\tdouble rs = sqrt(dfr);\n\tvec sgn = (c2.c - c1.c) / d;\n\tret.emplace_back(c1.c + sgn*point(rc, rs));\n\tif (dfr > 0.0) ret.emplace_back(c1.c + sgn*point(rc, -rs));\n\treturn ret;\n}\n\n#define MAX_N 300\nint n;\npoint p[MAX_N];\n\nvoid solve(){\n\tint ans=1;\n\tfor(int i=0;i<n;++i) for(int j=i+1;j<n;++j){\n\t\tcircle c1=(circle){p[i],1.0},c2=(circle){p[j],1.0};\n\t\tvector<point> v=CrosspointCC(c1,c2);\n\t\tfor(int l=0;l<v.size();++l){\n\t\t\tpoint q=v[l];\n\t\t\tint b=2;\n\t\t\tfor(int k=0;k<n;++k) if(k!=i&&k!=j) if(abs(p[k]-q)<=1.0) ++b;\n\t\t\tchmax(ans,b);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\twhile(true){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tdouble a,b;\n\t\t\tscanf(\"%lf %lf\",&a,&b);\n\t\t\tp[i]=complex<double>(a,b);\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\ntemplate<class T> bool operator<(const complex<T> &a, const complex<T> &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n}\n\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\n\ndouble dot(P a, P b){\n    return (a * conj(b)).X;\n}\ndouble cross(P a, P b){\n    return (a * conj(b)).Y;\n}\n\nvector<P> points;\ndeque<P> selected;\nint max_count;\n\ninline bool is_out_of_circle_for_three(P p1, P p2, P p3) {\n    double d12 = abs(p1 - p2);\n    P center12 = P((p1.X + p2.X) / 2, (p1.Y + p2.Y) / 2);\n    double allow_distance = 1 + sqrt(1 - ((d12 * d12) / 4));\n    return abs(center12 - p3)  > allow_distance + 1e-10;\n}\n\nvoid search(int index) {\n    if(index > points.size()) return;\n    int selected_size = selected.size();\n\n    bool is_all_in_circle = true;\n    if(selected_size >= 2 && selected_size > max_count) {\n        // calc is all overlaps\n        vector<P> copied_selected;\n        copy(selected.begin(), selected.end(), back_inserter(copied_selected));\n\n        for (int i = 0; i < selected_size ; ++i) {\n            for (int j = 0; j < selected_size; ++j) {\n                if(i == j) continue;\n                // two point check\n                double d12 = abs(copied_selected[i] - copied_selected[j]);\n                if(d12 > 2.0 + 1e-10) {\n                    is_all_in_circle = false;\n                    break;\n                }\n\n                for (int k = 0; k < selected_size; ++k) {\n                    if(i == k || j == k) continue;\n                    // three point check\n                    P p1 = copied_selected[i];\n                    P p2 = copied_selected[j];\n                    P p3 = copied_selected[k];\n                    if(is_out_of_circle_for_three(p1, p2, p3)) {\n                        is_all_in_circle = false;\n                        break;\n                    }\n                }\n\n            }\n            if(!is_all_in_circle) {\n                break;\n            }\n        }\n\n        copied_selected.clear();\n        copied_selected.shrink_to_fit();\n    }\n\n    if (is_all_in_circle) {\n        // update max count\n        if(selected_size > max_count) {\n            max_count = selected_size;\n        }\n\n        P p = points[index];\n        // remove bad situation\n        if(selected.empty()) {\n            // take\n            selected.push_front(p);\n            search(index + 1);\n            selected.pop_front();\n        } else if (selected.size() == 1 && abs(p - selected.front()) <= 2.0 + 1e-10) {\n            // take\n            selected.push_front(p);\n            search(index + 1);\n            selected.pop_front();\n        } else if(selected.size() >= 2 && abs(p - selected.front()) <= 2.0 + 1e-10) {\n            P pm1 = selected.front();\n            selected.pop_front();\n            P pm2 = selected.front();\n            selected.push_front(pm1); // restore\n            if(!is_out_of_circle_for_three(pm2, pm1, p)) {\n                // take\n                selected.push_front(p);\n                search(index + 1);\n                selected.pop_front();\n            }\n        }\n\n        // for next dispatch\n        // not take\n        search(index + 1);\n    }\n}\n\nint main() {\n    int n;\n    while (cin >> n) {\n        if(n == 0) break;\n        points.clear();\n        points.shrink_to_fit();\n        selected.clear();\n        selected.shrink_to_fit();\n        max_count = 0;\n\n        // load points\n        for (char i = 0; i < n; ++i) {\n            double x;\n            double y;\n            cin >> x >> y;\n            P p = P(x, y);\n            points.push_back(p);\n        }\n\n        search(0);\n        cout << max_count << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <tuple>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nint N;\ndouble x[300];\ndouble y[300];\ninline double dist2(double a, double b)\n{\n\treturn a*a+b*b;\n}\nvoid exec()\n{\n\tcin >> N;\n\tif(N==0){\n\t\texit(0);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tint ret=0;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tdouble dx=(x[i]-x[j])/2;\n\t\t\tdouble dy=(y[i]-y[j])/2;\n\t\t\tdouble r2=dx*dx+dy*dy;\n\t\t\tdouble r=sqrt(r2);\n\t\t\tdouble R=sqrt(1-r2);\n\t\t\tdouble px=x[j]+dx-R*dy/r;\n\t\t\tdouble py=y[j]+dy+R*dx/r;\n\t\t\tdouble qx=x[j]+dx+R*dy/r;\n\t\t\tdouble qy=y[j]+dy-R*dx/r;\n\t\t\tint sp=0,sq=0;\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\tif(k==i||k==j){\n\t\t\t\t\tsp++;sq++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(dist2(x[k]-px,y[k]-py)<1){\n\t\t\t\t\tsp++;\n\t\t\t\t}\n\t\t\t\tif(dist2(x[k]-qx,y[k]-qy)<1){\n\t\t\t\t\tsq++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret=max(ret,sp);\n\t\t\tret=max(ret,sq);\n\t\t}\n\t}\n\tcout << ret << endl;\n}\nint main() {\n\twhile(1)\n\t\texec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nconst double eps=1e-8;\ntypedef pair<double,double> p;\n\ndouble dist(p a, p b)\n{\n    return sqrt((a.fi-b.fi)*(a.fi-b.fi)+(a.se-b.se)*(a.se-b.se));\n}\n\ndouble size(p a)\n{\n    return sqrt(a.fi*a.fi+a.se*a.se);\n}\n\nint main()\n{\n    int n;\n    while(cin >>n,n)\n    {\n        vector<p> v(n);\n        rep(i,n) scanf(\" %lf %lf\", &v[i].fi, &v[i].se);\n\n        if(n==1)\n        {\n            printf(\"1\\n\");\n            continue;\n        }\n\n        int ans=0;\n        //select 2 points\n        rep(i,n)rep(j,i)\n        {\n            double d=dist(v[i],v[j]);\n            if(d>2.0) continue;\n\n            double r=sqrt(1.0 - (d*d/4.0));\n\n            double X=v[j].fi-v[i].fi, Y=v[j].se-v[i].se;\n\n            p v1=p(X,Y);\n            double v1size=size(v1);\n            v1.fi/=v1size; v1.se/=v1size;\n            v1.fi*=d/2; v1.se*=d/2;\n\n            p v2;\n            double v2size;\n            p c;\n\n            //2 candidate for center of circle\n            //first\n            int ct=0;\n            v2=p(-Y,X);\n            v2size=size(v2);\n            v2.fi/=v2size; v2.se/=v2size;\n            v2.fi*=r; v2.se*=r;\n\n            c.fi=v[i].fi+v1.fi+v2.fi; c.se=v[i].se+v1.se+v2.se;\n            assert(dist(c,v[i]));\n            rep(k,n)\n            {\n                if(k==i || k==j) ++ct;\n                else\n                {\n                    if(dist(c,v[k])<1.0) ++ct;\n                }\n            }\n            ans=max(ans,ct);\n\n            //second\n            ct=0;\n            v2=p(Y,-X);\n            v2size=size(v2);\n            v2.fi/=v2size; v2.se/=v2size;\n            v2.fi*=r; v2.se*=r;\n\n            c.fi=v[i].fi+v1.fi+v2.fi; c.se=v[i].se+v1.se+v2.se;\n            assert(dist(c,v[i]));\n            rep(k,n)\n            {\n                if(k==i || k==j) ++ct;\n                else\n                {\n                    if(dist(c,v[k])<1.0) ++ct;\n                }\n            }\n            ans=max(ans,ct);\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\ntypedef double D;\nD EPS = 1e-8;\n\ntypedef complex<D> P;\nstruct L{\n    P a, b;\n    P vec(){ return b - a; }\n};\ntypedef vector<P> Pol;\n\nint sig(D a) { return a < -EPS ? -1 : a > EPS ? 1 : 0; }\nD dot(P a, P b){ return a.X * b.X + a.Y * b.Y; }\nD cross(P a, P b){ return a.X * b.Y - a.Y * b.X; }\n\nD area(Pol pol) {\n    int n = pol.size();\n    D res = 0;\n    REP(i, n) {\n        res += cross(pol[i], pol[ (i + 1) % n ]);\n    }\n    return abs(res) / 2.0;\n}\n\n// 2点a, bを通る半径rの円の中心\nvector<P> tc2(P a, P b, D r){\n    vector<P> res;\n\n    D d = abs(b - a);\n    if(sig(d - 2 * r) > 0) return res;\n\n    P mid = 0.5 * (a + b);\n    P dir = polar(sqrt(r * r - d * d / 4), arg(b - a) + M_PI / 2);\n    res.push_back(mid + dir);\n    res.push_back(mid - dir);\n    return res;\n}\n\nint main(){\n    int N;\n    while(cin >> N && N > 0) {\n        vector<P> ps(N);\n        REP(i, N) {\n            D x, y;\n            cin >> x >> y;\n            ps[i] = P(x, y);\n        }\n\n        int ans = 0;\n        REP(i, N) REP(j, N) if(i != j) {\n            vector<P> cv = tc2(ps[i], ps[j], 1.0);\n            for(auto c : cv) {\n                int sum = 0;\n                REP(k, N) {\n                    if(sig(abs(c - ps[k]) - 1.0) <= 0) {\n                        sum++;\n                    }\n                }\n                ans = max(ans, sum);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n\nusing namespace std;\n\ncomplex<double> points[300];\n\nconstexpr double epsilon = 1.0e-6;\n\nint count_points(const complex<double> &center,int N){\n  int num=0;\n  for(int i=0;i<N;++i){\n    double dist = abs(points[i]-center);\n    if(dist-1.0<=0) num++;\n  }\n  return num;\n}\n\nint main(){\n  int n;\n  while(cin >> n&&n>0){\n    for(int i=0;i<n;++i){\n      double x,y;\n      cin >> x >> y;\n      points[i] = complex<double>(x,y);\n    }\n    \n    int maxnum = 1;\n    for(int i=0;i<n-1;++i){\n      for(int j=i+1;j<n;++j){\n        complex<double> v = points[j]-points[i];\n        double dist = abs(v);\n        int circnum=0;\n        complex<double> center[2];\n        if(abs(dist-2.0)<=epsilon){\n          circnum = 1;\n          center[0] = (points[i]+points[j])/2.0;\n        }else if(dist-2.0<-epsilon){\n          circnum = 2;\n          complex<double> w = v/dist;\n          w *= complex<double>(0,1);\n          w *= sqrt(1.0-dist*dist/4.0);\n          center[0] = (points[i]+points[j])/2.0 + w;\n          // cout << w << endl;\n          center[1] = (points[i]+points[j])/2.0 - w;\n        }\n        for(int c=0;c<circnum;++c){\n          maxnum = max(maxnum,count_points(center[c],n));\n        }\n      }\n    }\n    cout << maxnum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <complex>\n\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,n) loop(i,0,n)\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef complex<double> vec;\n\ndouble const pi = acos(-1);\ndouble const eps = 1e-9;\n\nint main(){\n    int n;\n    while(cin >> n && n){\n        vector<vec> v(n);\n        rep(i, n){\n            double x, y; cin >> x >> y;\n            vec p(x, y);\n            v[i] = p;\n        }\n        int ans = 0;\n        rep(i, n)rep(j, i){\n            double d = abs(v[i] - v[j]);\n            if (d - eps > 2) continue;\n            double h = 1 - d*d/4;\n            vec c1 = polar(h, arg(v[i] - v[j]) + pi / 2) + (v[i] + v[j]) / 2.;\n            vec c2 = polar(h, arg(v[i] - v[j]) - pi / 2) + (v[i] + v[j]) / 2.;\n            int a1 = 0, a2 = 0;\n            rep(k, n){\n                if (abs(c1 - v[k]) <= 1 - eps) a1++;\n                if (abs(c2 - v[k]) <= 1 - eps) a2++;\n            }\n            ans = max(ans, a1);\n            ans = max(ans, a2);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nclass Point\n{\nprivate:\n\n\tdouble x_;\n\tdouble y_;\n\npublic:\n\n\tPoint() : x_(0), y_(0) { }\n\n\texplicit Point(double x, double y) : x_(x), y_(y) { }\n\n\texplicit Point(double x1, double y1, double x2, double y2) : x_(x2 - x1), y_(y2 - y1) { }\n\n\tdouble x() { return x_; }\n\tdouble y() { return y_; }\n\n\tdouble x() const { return x_; }\n\tdouble y() const { return y_; }\n\n\tPoint& operator+= (const Point& p) { x_ += p.x_; y_ += p.y_; return *this; }\n\tPoint& operator-= (const Point& p) { x_ -= p.x_; y_ -= p.y_; return *this; }\n\n\tPoint& operator*= (double s) { x_ *= s; y_ *= s; return *this; }\n\tPoint& operator/= (double s) { x_ /= s; y_ /= s; return *this; }\n\n\tfriend bool operator== (const Point& p1, const Point& p2) { return p1.x_ == p2.x_ && p1.y_ == p2.y_; }\n\tfriend bool operator!= (const Point& p1, const Point& p2) { return !(p1 == p2); }\n\n\tfriend Point operator+ (const Point& p1, const Point& p2) { return Point(p1.x_ + p2.x_, p1.y_ + p2.y_); }\n\tfriend Point operator- (const Point& p1, const Point& p2) { return Point(p1.x_ - p2.x_, p1.y_ - p2.y_); }\n\n\tfriend Point operator* (const Point& p, double s) { return Point(p.x_ * s, p.y_ * s); }\n\tfriend Point operator/ (const Point& p, double s) { return Point(p.x_ / s, p.y_ / s); }\n\n\tfriend Point operator* (double s, const Point& p) { return Point(p.x_ * s, p.y_ * s); }\n};\n\ndouble distance(const Point& p1, const Point& p2)\n{\n\treturn sqrt(pow(p2.x() - p1.x(), 2) + pow(p2.y() - p1.y(), 2));\n}\n\nint main()\n{\n\tint N; double X, Y;\n\n\tvector<Point> Plane;\n\n\twhile (true)\n\t{\n\t\tcin >> N;\n\n\t\tif (N == 0) { break; }\n\n\t\tPlane.clear();\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tcin >> X >> Y;\n\n\t\t\tPlane.push_back(Point(X, Y));\n\t\t}\n\n\t\tint max_ = 0;\n\n\t\tint count_;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t{\n\t\t\t\tcount_ = 1;\n\n\t\t\t\tif (distance(Plane[i], Plane[j]) < 2)\n\t\t\t\t{\n\t\t\t\t\tdouble vx = Plane[j].x() - Plane[i].x();\n\t\t\t\t\tdouble vy = Plane[j].y() - Plane[i].y();\n\n\t\t\t\t\tswap(vx, vy); vx = -vx;\n\n\t\t\t\t\tPoint R(vx, vy);\n\n\t\t\t\t\tcount_ = 2;\n\n\t\t\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (k != i && k != j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (distance(Plane[i], R) < 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcount_++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmax_ = max(count_, max_);\n\n\t\t\t\tcount_ = 0;\n\n\t\t\t\tif (distance(Plane[i], Plane[j]) < 2)\n\t\t\t\t{\n\t\t\t\t\tdouble vx = Plane[j].x() - Plane[i].x();\n\t\t\t\t\tdouble vy = Plane[j].y() - Plane[i].y();\n\n\t\t\t\t\tswap(vx, vy); vy = -vy;\n\n\t\t\t\t\tPoint R(vx, vy);\n\n\t\t\t\t\tcount_ = 2;\n\n\t\t\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (k != i && k != j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (distance(Plane[i], R) < 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcount_++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmax_ = max(count_, max_);\n\t\t\t}\n\t\t}\n\n\t\tcout << max_ << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\ntypedef complex<double> pt;\ntypedef pair<pt,pt> L;\ntypedef vector<P> poly;\nconst double EPS = 1e-9;\n#define x real()\n#define y imag()\n \ndouble dot(pt a,pt b){\n\treturn (conj(a)*b).x;\n}\ndouble cross(pt a,pt b){\n\treturn (conj(a)*b).y;\n}\nint ccw(pt a,pt b,pt c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > EPS) return 1; // counter clockwise\n\tif(cross(b,c) < -EPS) return -1; // clockwise\n\tif(dot(b,c) < -EPS) return 2; //c-a-b\n\tif(norm(b) < norm(c)) return -2; //a-b-c\n\treturn 0; //a-c-b\n}\nbool cmp(const pt& a,const pt& b){\n\tif(-EPS < a.x-b.x && a.x-b.x < EPS) return a.y < b.y;\n\telse return a.x < b.x;\n}\nvector<pt>convex_hull(vector<pt>ps)\n{\n\tsort(ps.begin(),ps.end(),cmp);\n\tint k=0,n = ps.size();\n\tvector<pt>qs(n*2);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\twhile(k>1 && ccw(qs[k-2],qs[k-1],ps[i]) == -1) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tfor(int i=n-2,t=k;i>=0;i--)\n\t{\n\t\twhile(k>t && ccw(qs[k-2],qs[k-1],ps[i]) == -1) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\npt intersect(pt a,pt b,pt c,pt d){\n\tdouble dev = (b.y-a.y)*(d.x-c.x)-(b.x-a.x)*(d.y-c.y);\n\t\n\tdouble d1, d2;\n \n\td1 = (c.y*d.x-c.x*d.y);\n\td2 = (a.y*b.x-a.x*b.y);\n \n\tpt ap1;\n\tap1.x = d1*(b.x-a.x) - d2*(d.x-c.x);\n\tap1.x /= dev;\n\tap1.y = d1*(b.y-a.y) - d2*(d.y-c.y);\n\tap1.y /= dev;\n \n\treturn ap1;\n}\nbool par(pt a,pt b,pt c,pt d){\n\tb.x -= a.x; b.y -= a.y;\n\td.x -= c.x; d.y -= c.y;\n\tif(abs(b.y*d.x - b.x*d.y) < EPS){\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(1){\n\t\tint n; scanf(\"%d\",&n); if(!n) return 0; if(n==1){ puts(\"1\"); continue;}\n\t\tpt p[305];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tdouble a,b; scanf(\"%lf%lf\",&a,&b);\n\t\t\tp[i] = pt(a,b);\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=i+1;j<=n;j++){\n\t\t\t\tpt q = (p[i]+p[j])/2.0;\n\t\t\t\tpt r = (p[i]-p[j]); if(abs(r) > 2.0+EPS) continue;\n\t\t\t\tpt p1 = q + r / abs(r) * pt(0,sqrt(1.0-abs(r)*abs(r)/4.0));\n\t\t\t\tpt p2 = q - r / abs(r) * pt(0,sqrt(1.0-abs(r)*abs(r)/4.0));\n\t\t\t\tint c=0,d=0;\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tif(abs(p1-p[k]) <= 1.0+EPS) c++;\n\t\t\t\t\tif(abs(p2-p[k]) <= 1.0+EPS) d++;\n\t\t\t\t}\n\t\t\t\tans = max(ans,max(c,d));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <set>\n\nusing namespace std;\n\n\nint main(){\n\tint n;\n\tdouble x1,y1,xc,yc,dis,vx,vy,ex,ey;\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\tvector<double> x(n);\n\t\tvector<double> y(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tint ans =1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\txc = (x[i]+x[j])/2;\n\t\t\t\tyc = (y[i]+y[j])/2;\n\t\t\t\tif((xc-x[i])*(xc-x[i])+(yc-y[i])*(yc-y[i])>1.0001)continue;\n\t\t\t\tdis = sqrt(1.0-(xc-x[i])*(xc-x[i])-(yc-y[i])*(yc-y[i]));\n\t\t\t\tvx = x[i]-x[j];\n\t\t\t\tvy = y[i]-y[j];\n\t\t\t\tex = dis * vy / sqrt(vx*vx+vy*vy);\n\t\t\t\tey = -dis* vx / sqrt(vx*vx+vy*vy);\n\t\t\t\tx1 = xc + ex;\n\t\t\t\ty1 = yc + ey;\n\t\t\t\tint count=0;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i||k==j)count +=1;\n\t\t\t\t\telse{\n\t\t\t\t\t\tif((x1-x[k])*(x1-x[k])+(y1-y[k])*(y1-y[k])<=1.0001){\n\t\t\t\t\t\t\tcount +=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = max(ans,count);\n\t\t\t\tx1 = xc - ex;\n\t\t\t\ty1 = yc - ey;\n\t\t\t\tcount = 0;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i||k==j)count +=1;\n\t\t\t\t\telse{\n\t\t\t\t\t\tif((x1-x[k])*(x1-x[k])+(y1-y[k])*(y1-y[k])<=1.0001){\n\t\t\t\t\t\t\tcount +=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = max(ans,count);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n\nusing namespace std;\n\nint n;\ndouble x[300];\ndouble y[300];\n\ndouble dist(double x1, double y1, double x2, double y2) {\n    double dx = abs(x1 - x2);\n    double dy = abs(y1 - y2);\n    return sqrt(dx * dx + dy * dy);\n}\n\nint count(double cx, double cy, int i, int j) {\n    int ans = 0;\n    for (int k = 0; k < n; ++k) {\n        if (k == i || k == j || dist(cx, cy, x[k], y[k]) < 1) ans++;\n    }\n    return ans;\n}\n\nvoid solve() {\n    for (int i = 0; i < n; ++i) {\n        cin >> x[i] >> y[i];\n    }\n\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (i == j) continue;\n            double d = dist(x[i], y[i], x[j], y[j]);\n            if (d > 2.) continue;\n            double dx = x[j] - x[i];\n            double dy = y[j] - y[i];\n            double r = sqrt(1 - (d * d / 4));\n            // cout << r << endl;\n            double cx = x[i] + dx / 2 - dy * r / d;\n            // cout << d << endl;\n            double cy = y[i] + dy / 2 + dx * r / d;\n            // cout << x[i] << \", \" << y[i] << \" - \" << x[j] << \", \" << y[j] << \" : \" << cx << \", \"<< cy << endl;\n            ans = max(ans, count(cx, cy, i, j));\n        }\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    while (1) {\n        cin >> n;\n        if (n == 0) break;\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\ninline point rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\ninline point rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ninline double angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ninline double abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ninline double norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ninline double dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ninline double cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\ninline int ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\ninline point projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\ninline bool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\ninline bool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\ninline bool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\ninline bool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ninline bool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\ninline bool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\ninline bool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ninline double dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ninline double dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ninline double dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ninline double dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ninline double dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\ninline double dist(const point& a, const point& b) {\n\treturn abs(a - b);\n}\n\ninline point crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn m.a + (m.b - m.a) * cross(l.b - l.a, l.a - m.a) * (1.0 / tmp);\n}\n\ninline point crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\ninline vector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ninline double areaTriangle(point a, point b, const point& c) {\n\ta = a - c;\n\tb = b - c;\n\treturn fabs(a.x * b.y - b.x * a.y) / 2.0;\n}\n\ninline double area(const polygon& p) {\n\tconst int num = p.size();\n\tif(num < 3)\n\t\treturn 0;\n\n\tif(num == 3)\n\t\treturn areaTriangle(p[0], p[1], p[2]);\n\n\tdouble res = cross(p[num - 1], p[0]);\n\tfor(int i = 1; i < num; ++i)\n\t\tres += cross(p[i - 1], p[i]);\n\n\treturn res * 0.5;\n}\n\n// L.aからL.bの方向を見た場合に，点aが左側に来る．\ninline line bisector(const point& a, const point& b) {\n\treturn line(point((a.x - a.y + b.x + b.y) / 2.0, (a.y + a.x + b.y - b.x) / 2.0),\n\t\t\t\tpoint((a.x + a.y + b.x - b.y) / 2.0, (a.y - a.x + b.y + b.x) / 2.0));\n}\n\n// L.aからL.bを向いた時の左側を残して切断する．\ninline polygon convex_cut(const polygon& p, const line& l) {\n\tconst int num = p.size();\n\tpolygon res;\n\tfor(int i = 0; i < num; ++i) {\n\t\tconst int next = (i + 1) % num;\n\t\tconst int tmp = ccw(l.a, l.b, p[i]);\n\t\tif(tmp != -1)\n\t\t\tres.push_back(p[i]);\n\n\t\tif(tmp * ccw(l.a, l.b, p[next]) < 0)\n\t\t\tres.push_back(crosspoint(l, line(p[i], p[next])));\n\t}\n\n\treturn res;\n}\n\nvector<point> tangent(const circle& c, const point& p) {\n\tconst double x = norm(p - c.c);\n\tdouble d = x - c.r * c.r;\n\tif(d < -EPS) return vector<point>();\n\td = max(d, 0.0);\n\tconst point q1 = (p - c.c) * (c.r * c.r / x);\n\tconst point q2 = rotate90((p - c.c) * (-c.r * sqrt(d) / x));\n\tvector<point> res;\n\tres.push_back(c.c + q1 - q2);\n\tres.push_back(c.c + q1 + q2);\n\treturn res;\n}\n\nvector<line> tangent(const circle &a, const circle& b) {\n\tvector<line> res;\n\tif(abs(a.r - b.r) < EPS) {\n\t\tpoint dir = b.c - a.c;\n\t\tdir = rotate90(dir * (a.r / abs(dir)));\n\t\tres.push_back(line(a.c + dir, b.c + dir));\n\t\tres.push_back(line(a.c - dir, b.c - dir));\n\t}\n\telse {\n\t\tpoint p = a.c * (-b.r) + b.c * a.r;\n\t\tp = p * (1.0 / (a.r - b.r));\n\t\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\t\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\t\tres.push_back(line(ps[i], qs[i]));\n\t}\n\n\tpoint p = a.c * b.r + b.c * a.r;\n\tp = p * (1.0 / (a.r + b.r));\n\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\tres.push_back(line(ps[i], qs[i]));\n\n\treturn res;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n, n;) {\n\t\tvector<point> points;\n\t\tpoints.reserve(n);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoints.push_back(point(x, y));\n\t\t}\n\n\t\tint ans = 1;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tconst circle c1 = circle(points[i], 1.0);\n\t\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\t\tconst circle c2 = circle(points[j], 1.0);\n\t\t\t\tvector<point> center = crosspoint(c1, c2);\n\t\t\t\tif(center.size() != 2)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor(int k = 0; k < 2; ++k) {\n\t\t\t\t\tint cnt = 2;\n\t\t\t\t\tfor(int l = 0; l < n; ++l) {\n\t\t\t\t\t\tif(l == i || l == j)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tif(dist(center[k], points[l]) < 1.0 + EPS)\n\t\t\t\t\t\t\t++cnt;\n\t\t\t\t\t}\n\n\t\t\t\t\tchmax(ans, cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\n\nconst double EPS = 1e-8;\n\nstruct Rect\n{\n\tdouble x, y, len;\n\tint c;\n\tRect(double x, double y, double len, int c)\n\t\t: x(x), y(y), len(len), c(c) { }\n};\nbool operator<(const Rect& a, const Rect& b)\n{\n\treturn a.c < b.c;\n};\n\n\nint n;\ndouble px[333], py[333];\n\nbool contain(double x, double y, double radius, double xa, double ya)\n{\n\tdouble dx = x - xa, dy = y - ya;\n\treturn dx*dx + dy*dy < radius*radius + EPS;\n}\nint count_p(double cx, double cy, double radius)\n{\n\tint res = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tif (contain(cx, cy, radius, px[i], py[i]))\n\t\t\t++res;\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\trep (i, n)\n\t\t\tscanf(\"%lf%lf\", px + i, py + i);\n\n\t\tint res = 0;\n\t\tpriority_queue<Rect> q;\n\t\tq.push(Rect(0, 0, 10, n));\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tRect t = q.top(); q.pop();\n\t\t\tif (t.c <= res)\n\t\t\t\tbreak;\n\n\t\t\tdouble len = t.len / 2;\n\t\t\tdouble rela_x[] = { 0, len, 0, len };\n\t\t\tdouble rela_y[] = { 0, 0, len, len };\n\t\t\trep (i, 4)\n\t\t\t{\n\t\t\t\tdouble tx = t.x + rela_x[i], ty = t.y + rela_y[i];\n\t\t\t\tdouble cx = tx + len / 2, cy = ty + len / 2;\n\n\t\t\t\tmax_swap(res, count_p(cx, cy, 1));\n\n\t\t\t\tint c = count_p(cx, cy, len * sqrt(2.0) + 1);\n\t\t\t\tif (c > res)\n\t\t\t\t\tq.push(Rect(tx, ty, len, c));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\ntypedef complex<double> pt;\ntypedef pair<pt,pt> L;\ntypedef vector<P> poly;\nconst double EPS = 1e-9;\n#define x real()\n#define y imag()\n \ndouble dot(pt a,pt b){\n\treturn (conj(a)*b).x;\n}\ndouble cross(pt a,pt b){\n\treturn (conj(a)*b).y;\n}\nint ccw(pt a,pt b,pt c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > EPS) return 1; // counter clockwise\n\tif(cross(b,c) < -EPS) return -1; // clockwise\n\tif(dot(b,c) < -EPS) return 2; //c-a-b\n\tif(norm(b) < norm(c)) return -2; //a-b-c\n\treturn 0; //a-c-b\n}\nbool cmp(const pt& a,const pt& b){\n\tif(-EPS < a.x-b.x && a.x-b.x < EPS) return a.y < b.y;\n\telse return a.x < b.x;\n}\nvector<pt>convex_hull(vector<pt>ps)\n{\n\tsort(ps.begin(),ps.end(),cmp);\n\tint k=0,n = ps.size();\n\tvector<pt>qs(n*2);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\twhile(k>1 && ccw(qs[k-2],qs[k-1],ps[i]) == -1) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tfor(int i=n-2,t=k;i>=0;i--)\n\t{\n\t\twhile(k>t && ccw(qs[k-2],qs[k-1],ps[i]) == -1) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\npt intersect(pt a,pt b,pt c,pt d){\n\tdouble dev = (b.y-a.y)*(d.x-c.x)-(b.x-a.x)*(d.y-c.y);\n\t\n\tdouble d1, d2;\n \n\td1 = (c.y*d.x-c.x*d.y);\n\td2 = (a.y*b.x-a.x*b.y);\n \n\tpt ap1;\n\tap1.x = d1*(b.x-a.x) - d2*(d.x-c.x);\n\tap1.x /= dev;\n\tap1.y = d1*(b.y-a.y) - d2*(d.y-c.y);\n\tap1.y /= dev;\n \n\treturn ap1;\n}\nbool par(pt a,pt b,pt c,pt d){\n\tb.x -= a.x; b.y -= a.y;\n\td.x -= c.x; d.y -= c.y;\n\tif(abs(b.y*d.x - b.x*d.y) < EPS){\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(1){\n\t\tint n; scanf(\"%d\",&n); if(!n) return 0;\n\t\tpt p[305];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tdouble a,b; scanf(\"%lf%lf\",&a,&b);\n\t\t\tp[i] = pt(a,b);\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=i+1;j<=n;j++){\n\t\t\t\tpt q = (p[i]+p[j])/2.0;\n\t\t\t\tpt r = (p[i]-p[j]);\n\t\t\t\tpt p1 = q + r / abs(r) * pt(0,sqrt(1.0-abs(r)*abs(r)/4.0));\n\t\t\t\tpt p2 = q - r / abs(r) * pt(0,sqrt(1.0-abs(r)*abs(r)/4.0));\n\t\t\t\tint c=0,d=0;\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tif(abs(p1-p[k]) <= 1.0+EPS) c++;\n\t\t\t\t\tif(abs(p2-p[k]) <= 1.0+EPS) d++;\n\t\t\t\t}\n\t\t\t\tans = max(ans,max(c,d));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<limits>\n#include<iomanip>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\n\n\n\ntypedef pair<double,double> Point;\n#define F first\n#define S second\n#define MK make_pair\n#define equal abs(a-b)<=1e-8\n\nPoint pls(Point a,Point b){\n    return MK(a.F+b.F,a.S+b.S);\n}\n\nPoint mns(Point a,Point b){\n    return MK(a.F-b.F,a.S-b.S);\n}\n\nPoint T(Point t){\n    return MK(t.S,-1.0*t.F);\n}\n\ndouble abs(Point a){\n    return sqrt(a.F*a.F+a.S*a.S);\n}\n\nPoint mid(Point a,Point b){\n    return MK(a.F/2+b.F/2,a.S/2+b.S/2);\n}\n\nbool in(Point c,Point t){\n    if(abs(mns(t,c))<=1){return true;}\n    return false;\n}\n\n\nint main(){\n    while(1){\n        int n;\n        cin>>n;\n        if(n==0){break;}\n        vector<Point> vp;\n        int mx=0;\n        for(int i=0;i<n;i++){\n            double a,b;\n            cin>>a>>b;\n            vp.push_back(MK(a,b));\n        }\n        sort(vp.begin(),vp.end());\n        for(int i=0;i<vp.size();i++){\n            for(int t=i+1;t<vp.size() && vp[t].F-vp[i].F<=2;t++){\n                if(abs(mns(vp[t],vp[i]))>2){continue;}\n                Point m=mid(vp[i],vp[t]);\n                Point l=mns(vp[t],vp[i]);\n                Point lt=T(l);\n                double h=sqrt(1-abs(l)*abs(l)/4.0);\n                lt.F=h*lt.F/abs(l);\n                lt.S=h*lt.S/abs(l);\n                Point c=pls(m,lt);\n                int count=2;\n                for(int k=0;k<vp.size();k++){\n                    if(k!=i && k!=t && in(c,vp[k])){count++;}\n                }\n                mx=max(mx,count);\n                c=mns(m,lt);\n                count=2;\n                for(int k=0;k<vp.size();k++){\n                    if(k!=i && k!=t && in(c,vp[k])){count++;}\n                }\n                mx=max(mx,count);\n            }\n        }\n        cout<<mx<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\n#define EQ(x,y) (abs((x)-(y))<EPS)\n#define LE(x,y) ((x)-(y) < +EPS)\n\n#include <complex>\ntypedef complex<double> P;\ntypedef vector<P> vp;\n\nP rotate(P t, P p, double r) {\n\tdouble ta = cos(r)*(t.real()-p.real())-sin(r)*(t.imag()-p.imag())+p.real();\n\tdouble tb = sin(r)*(t.real()-p.real())+cos(r)*(t.imag()-p.imag())+p.imag();\n\treturn P(ta, tb);\n}\n\ndouble to_radian(double degree) {\n\treturn degree*PI/180;\n}\n\nint main() {\n\tint N;\n\twhile(cin >> N, N) {\n\t\tvp points(N);\n\t\tdouble X, Y;\n\t\tREP(i, N) {\n\t\t\tcin >> X >> Y;\n\t\t\tpoints[i] = P(X, Y);\n\t\t}\n\n\t\tint ans = 0;\n\t\tREP(i, N) {\n\t\t\tFOR(j, i+1, N-1) {\n\t\t\t\tP a = points[i], b = points[j];\n\t\t\t\tif(LE(abs(a-b), 2.0)) {\n\t\t\t\t\tP m = P((a.real()+b.real())/2, (a.imag()+b.imag())/2);\n\t\t\t\t\tdouble l = abs(a-m);\n\t\t\t\t\tdouble d = sqrt(1-l*l);\n\t\t\t\t\tdouble c = l-d;\n\t\t\t\t\tP t = P((d*a.real()+c*m.real())/(c+d), (d*a.imag()+c*m.imag())/(c+d));\n\t\t\t\t\tP p1 = rotate(t, m, to_radian(90));\n\t\t\t\t\tint tmp1 = 0;\n\t\t\t\t\tREP(k, N) {\n\t\t\t\t\t\tif(LE(abs(p1-points[k]), 1.0)) {\n\t\t\t\t\t\t\ttmp1++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans, tmp1);\n\t\t\t\t\tP p2 = rotate(t, m, to_radian(-90));\n\t\t\t\t\tint tmp2 = 0;\n\t\t\t\t\tREP(k, N) {\n\t\t\t\t\t\tif(LE(abs(p2-points[k]), 1.0)) {\n\t\t\t\t\t\t\ttmp2++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans, tmp2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(N <= 2 && ans == 0) {\n\t\t\tcout << 1 << endl;\t\n\t\t} else {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef complex<double> P;\nconst double EPS = 1e-8;\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    vector<P> v;\n    REP(i,n) {\n      double x,y;\n      cin >> x >> y;\n      v.push_back(P(x,y));\n    }\n    int ans = 0;\n    REP(i,n-1) {\n      for (int j=i+1;j<n;j++) {\n        P m = (v[i]+v[j])*P(0.5,0);\n        //    cout << \"m \"<< m << endl;\n        P a = v[i]-v[j];\n        double dis = abs(a);\n        if (1-dis*dis/4<0) continue;\n        double d = sqrt(1-dis*dis/4);\n        int hoge[]={1,-1};\n        REP(k,2) {\n          P un = (a * P(0, hoge[k])) / dis;\n          P o1 = m + un*d;\n          //cout << o1 << endl;\n          int sum = 0;\n          REP(l,n) {\n            if (norm(v[l]-o1)<1+EPS) sum++;\n          }\n          ans = max(ans,sum);\n        }\n      }\n    }\n    cout << ans << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double EPS = 1e-9;   // 許容誤差。問題によって変える\nconst double pi=M_PI;\nconst double INFD=1e+9;\ntypedef complex<double> P; // Point\n#define rep(i,n) for(int i=0;i<n;i++)\n//点の座標は複素数で持つ\n#define X real()\n#define Y imag()\nnamespace std{\n    bool operator<(const P p1, const P p2){\n        return p1.X != p2.X ? p1.X < p2.X : p1.Y < p2.Y;\n    }\n    P operator+(const P p1, const P p2) { return P(p1.X + p2.X, p1.Y + p2.Y); }\n    P operator-(const P p1, const P p2) { return P(p1.X - p2.X, p1.Y - p2.Y); }\n    P operator*(const P p, double k) { return P(p.X * k, p.Y * k); }\n    P operator/(const P p, double k) { return P(p.X / k, p.Y / k); }\n} \n//Segment/L\nstruct Segment{\n    P p1, p2;\n    Segment() {}\n    Segment(P p1, P p2) : p1(p1), p2(p2) {}\n};\ntypedef Segment L;\n\ndouble norm(P &p1, P &p2){\n    return (p1.X - p2.X) * (p1.X - p2.X) + (p1.Y - p2.Y) * (p1.Y - p2.Y);\n}\n\ndouble cross(const P &a, const P &b){\n    return (conj(a) * b).Y;\n}\n\ndouble dot(const P &a, const P &b){\n    return (conj(a) * b).X;\n}\n\nP Projection(L l, P p){\n    P base = l.p2 - l.p1;                        //始点\n    double r = dot(p - l.p1, base) / norm(base); //線分に対する倍率の計算\n    return l.p1 + base * r;\n}\n\ndouble distanceLP(const L &l, const P &p){\n    return abs(p - Projection(l, p));\n}\n//Circle\nstruct Circle{\n    P p;\n    double r;\n    Circle(const P &p,double r) : p(p),r(r){}\n};\ntypedef Circle C;\n\nvector<P> crosspointCL(const C &c, const L &l) {\n    vector<P> res;\n    double d = distanceLP(l, c.p);      // 中心と直線の距離\n    if (abs(d - c.r) < EPS) {  // 触れている\n        res.push_back(Projection(l, c.p));\n        return res;\n    }\n    if (d > c.r) return res;  // 離れている\n    P h = Projection(l, c.p);\n    P u = sqrt(c.r * c.r - d * d) * (l.p2- l.p1) / abs(l.p2 - l.p1);\n    res.push_back(h + u);\n    res.push_back(h - u);\n    return res;\n}\n\nint intersectCC(const C &c1, const C &c2) {\n    double d = abs(c1.p - c2.p), r1 = c1.r, r2 = c2.r;\n    if (r1 + r2 < d) return 0;                   // 離れている\n    if (abs(r1 + r2 - d) < EPS) return -2;  // 外接\n    if (abs(d + r1 - r2) < EPS) return +1;  // c1 が c2 の中で内接\n    if (abs(d + r2 - r1) < EPS) return -1;  // c2 が c1 の中で内接\n    if (d + r1 < r2) return +3;                  // c1 が c2 の中\n    if (d + r2 < r1) return -3;                  // c2 が c1 の中\n    return 2;                                    // 2つの交点を持つ\n}\n\nvector<P> crosspointCC(const C &c1, const C &c2) {\n    vector<P> res;\n    double r1 = c1.r, r2 = c2.r, d = abs(c1.p - c2.p);\n    if (d<EPS) return res;  // 中心が同じ\n    int i = intersectCC(c1, c2);\n    if (i == +1 || i == -1) {  // 内接\n        if (r2 < r1)\n            res.push_back(c1.p + r1 / d * (c2.p - c1.p));\n        else\n            res.push_back(c2.p + r2 / d * (c1.p - c2.p));\n        return res;\n    }\n    if (i == -2) {  // 外接\n        res.push_back((c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r));\n        return res;\n    }\n    if (i == 0 || i == +3 || i == -3) {  // 共通部分なし || 内部\n        return res;\n    }\n    // 2つの交点を持つ\n    P p = c1.p - c2.p;\n    double A = -2 * p.real(), B = -2 * p.imag();\n    double C = norm(c1.p) - norm(c2.p) - r1 * r1 + r2 * r2;\n    L l;\n    if(abs(A)<EPS){\n        l = L(P(0, -C / B), P(1, -C / B));\n    }else if(abs(B)<EPS){\n        l = L(P(-C / A, 0), P(-C / A, 1));\n    }else if(abs(C)<EPS){\n        l = L(P(0, 0), P(1, -A / B));\n    }else{\n        l = L(P(0, -C / B), P(-C / A, 0));\n    }\n    return crosspointCL(c1, l);  // Ax + By + C = 0\n}\nvector<P> points;\nsigned main(){\n    int n;\n    while(cin>>n and n){\n        rep(i,n){\n            double x,y;cin>>x>>y;\n            P a=P(x,y);\n            points.push_back(a);\n        }\n        int ans=1;\n        vector<P> cent;\n        rep(i,n)for(int j=i+1;j<n;j++){\n            C c1=C(points[i],1),c2=C(points[j],1);\n            cent=crosspointCC(c1,c2);\n            rep(l,cent.size()){\n                int tmp=0;\n                rep(k,n){\n                    if(abs(points[k]-cent[l])<=1+EPS) tmp++;\n                }\n                ans=max(ans,tmp);\n            }\n        }\n        cout<<ans<<endl;\n        points.clear();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n#include<set>\n#include<array>\n#include<cassert>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\ntypedef double Real;\n\nconst Real EPS = 1e-8;\n\nint sign(Real d){\n\treturn d > EPS ? 1 : d < -EPS ? -1 : 0;\n}\n\nstruct Point{\n\tReal x,y;\t\n\texplicit Point(Real x_ = 0,Real y_ = 0):x(x_),y(y_){}\n\tPoint operator+(const Point &p) const {return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point &p) const {return Point(x-p.x,y-p.y);}\n\tPoint operator*(Real s) const {return Point(x*s,y*s);}\n\tPoint operator/(Real s) const {return Point(x/s,y/s);}\n\tbool operator<(const Point &p) const{return sign(x-p.x) == -1 || (sign(x-p.x) == 0 && sign(y-p.y) == -1);}\n\tbool operator==(const Point &p) const{return sign(x-p.x) == 0 && sign(y-p.y) == 0;}\n\n};\n\nistream &operator>>(istream &is,Point &p){return is >> p.x >> p.y;}//??\\???????°???????\nostream &operator<<(ostream &os ,const Point &p){return os << '(' << p.x << \", \" << p.y << ')';}//??????????°???????\n\nstruct Segment : public array<Point,2>{\n\tSegment(const Point &a,const Point &b){\tat(0) = a; at(1) = b;}\n};\n\nstruct Line : public array<Point,2>{\n\tLine(const Point &a,const Point &b){at(0) = a; at(1) = b;}\n};\n\nstruct Circle{\n\tPoint c;\n\tReal r;\n\n\tCircle(const Point &c_, Real r_):c(c_),r(r_){}\n};\n\ntypedef vector<Point> Polygon;\n\nPoint rotate90(const Point &p){\n\treturn Point(-p.y,p.x);\n}\n\nPoint rotate(const Point &p,Real theta){\n\tconst Real s = sin(theta),c = cos(theta);\n\treturn Point(c*p.x-s*p.y,s*p.x+c*p.y);\n}\n\nReal angle(const Point &p){\n\treturn atan2(p.y,p.x);\n}\n\nReal dot(const Point &a,const Point &b){ //??????????????????\n\treturn a.x*b.x+a.y*b.y;\n}\n\nReal cross(const Point &a,const Point &b){ //??????????????????\n\treturn a.x*b.y-a.y*b.x;\n}\n\n\nReal norm(const Point &p){\n\treturn p.x*p.x+p.y*p.y;\n}\n\nReal abs(const Point &p){\n\treturn sqrt(norm(p));\n}\n\nenum { CCW=1,CW=-1,BACK=2,FRONT=-2,ON=0 };\nint ccw(const Point &a,const Point &b,const Point &c){\n\tconst Point p = b-a;\n\tconst Point q = c-a;\n\tconst int sgn = sign(cross(p,q));\n\t\n\tif(sgn == 1) return CCW;\n\tif(sgn == -1) return CW;\n\tif(sign(dot(p,q)) == -1) return BACK;\n\tif(sign(norm(p) - norm(q)) == -1) return FRONT;\n\treturn ON;\n}\n\nPoint project(const Line &l,const Point &p){ //?°???±\n\tReal t = dot(p-l[0], l[1]-l[0]) / norm(l[0] - l[1]);\n\treturn l[0] + (l[1] - l[0]) * t;\n}\n\nPoint refrect(const Line &l,const Point &p){ //????°?\n\tconst Point c = project(l,p);\n\treturn c+(c-p);\n}\n\nbool intersect(const Segment &a,const Segment &b){\n\treturn ccw(a[0],a[1],b[0])*ccw(a[0],a[1],b[1]) <= 0\n\t\t&& ccw(b[0],b[1],a[0])*ccw(b[0],b[1],a[1]) <= 0;\n}\n\nbool intersect(const Segment &s,const Point &p){\n\treturn ccw(s[0],s[1],p) == ON;\n}\n\nbool intersect(const Line &l,const Segment &s){\n\treturn sign(cross(l[1]-l[0],s[0]-l[0])) * cross(l[1]-l[0],s[1]-l[0]) <= 0;\n}\n\nbool intersect(const Line &l,const Point &p){\n\treturn abs(ccw(l[0],l[1],p)) != 1;\n}\n\nbool intersect(const Line &a,const Line &b){ //????????????\n\treturn sign(cross(a[1]-a[0],b[1]-b[0])) != 0\n\t\t||\tsign(cross(a[1]-a[0],b[1]-a[0]) == 0);\n}\n\nReal dist(const Point &a,const Point &b){\n\treturn abs(a-b);\t\n}\n\nReal dist(const Line &l,const Point &p){\n\tconst Point a = l[1]-l[0];\n\tconst Point b = p-l[0];\n\treturn abs(cross(a,b))/abs(a);\n}\n\nReal dist(const Line &l,const Segment &s){\n\tif(intersect(l,s)) return 0;\n\treturn min(dist(l,s[0]),dist(l,s[1]));\n}\n\nReal dist(const Line &a,const Line &b){\n\tif(intersect(a,b)) return 0;\n\treturn dist(a,b[0]);\n}\n\nReal dist(const Segment &s,const Point &p){\n\tif(sign(dot(s[1]-s[0],p-s[0]))==-1) return dist(s[0],p);\n\tif(sign(dot(s[0]-s[1],p-s[1]))==-1) return dist(s[1],p);\n\treturn dist(Line(s[0],s[1]),p);\n}\n\nReal dist(const Segment &a,const Segment &b){\n\tif(intersect(a,b)) return 0;\n\treturn min({dist(a,b[0]),dist(a,b[1]),dist(b,a[0]),dist(b,a[1])});\n}\n\nbool intersect(const Circle &a,const Circle &b){\n\treturn sign(dist(a.c,b.c)-(a.r+b.r)) <=0\n\t\t\t&& sign(dist(a.c,b.c)-abs(a.r-b.r)) >= 0;\n}\n\nbool intersect(const Circle &c,const Segment &s){\n\treturn sign(dist(s,c.c)-c.r)<=0;\n}\n\nbool intersect(const Circle &c,const Line &l){\n\treturn sign(dist(l,c.c)-c.r)<=0;\n}\n\nbool contain(const Circle &c,const Point &p){\n\treturn sign(dist(c.c,p)-c.r)<=0;\n}\n\nbool contain(const Polygon &P,const Point &p){\n\tbool res = false;\n\n\tfor(int i=0;i<P.size();++i){\n\t\tPoint v1=P[i]-p;\n\t\tPoint v2=P[(i+1)%P.size()]-p;\n\t\tif(v1.y>v2.y) swap(v1,v2);\n\n\t\tif(sign(cross(v1,v2))==0&&sign(dot(v1,v2))<=0){\n\t\t\treturn true;//on edge \n\t\t}\n\t\tif(sign(v1.y)<=0&&sign(v2.y)==1&&sign(cross(v1,v2))==1){\n\t\t\tres=!res;\n\t\t}\n\t}\n\treturn res;\n}\n\nPoint crosspoint(const Line &a,const Line &b){\n\tassert(intersect(a,b));\n\tconst Real crs = cross(a[1]-a[0],b[1]-b[0]);\n\tif(sign(crs) == 0) return a[0];\n\treturn b[0]+(b[1]-b[0])*(cross(a[1]-a[0],a[1]-b[0])/crs);\n}\n\n\n//??¬??¢?????????????????¨?????°?????????????????????Intersect?????????\nPoint crosspoint(const Segment &a,const Segment &b){\n\tassert(intersect(a,b));\n\tconst Real crs = cross(a[1]-a[0],b[1]-b[0]);\n\tif(sign(crs)==0){\n\t\tif(intersect(a,b[0])) return b[0];\n\t\tif(intersect(a,b[1])) return b[1];\n\t\tif(intersect(b,a[0])) return a[0];\n\t\treturn a[1];\n\t}\n\treturn b[0]+(b[1]-b[0])*(cross(a[1]-a[0],a[1]-b[0])/crs);\n}\n\nvector<Point> crosspoint(const Circle &c,const Line &l){\n\tconst Point p = project(l,c.c);\n\tconst Real h = dist(p,c.c);\n\n\tvector<Point> res;\n\tif(sign(h-c.r)==1){\n\t\t//nothing\n\t}else if(sign(h-c.r)==0){\n\t\tres.emplace_back(p);\t\n\t}else{\n\t\tconst Real b = sqrt(c.r*c.r-h*h);\n\t\tconst Point e = (l[1]-l[0])/abs(l[1]-l[0]);\n\t\tres.emplace_back(p+e*b);\n\t\tres.emplace_back(p-e*b);\n\t}\n\treturn res;\n}\n\nvector<Point> crosspoint(const Circle &a,const Circle &b){\n\tif(!intersect(a,b)) return vector<Point>();\n\n\tvector<Point> res;\n\tconst Real d = dist(a.c,b.c);\n\n\tif(sign(d-(a.r+b.r))==0){\n\t\tconst Point v = b.c - a.c;\n\t\tres.emplace_back(a.c + (v * (a.r /abs(v))));\n\t}else{\n\t\tconst Real theta = acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\t\tconst Real phi = angle(b.c-a.c);\n\t\tres.emplace_back(a.c+rotate(Point(a.r,0),phi+theta));\n\t\tres.emplace_back(a.c+rotate(Point(a.r,0),phi-theta));\n\t}\n\treturn res;\n}\n\nReal area(const Polygon &P){\n\tReal res = 0.0;\n\tfor(int i=0;i<P.size();++i){\n\t\tres+=cross(P[i],P[(i+1)%P.size()]);\n\t}\n\treturn abs(res) * 0.5;\n}\n\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tvector<Circle> circles;\n\t\tvector<Circle> ccircles;\n\t\trep(i,n){\n\t\t\tPoint p;\n\t\t\tcin >> p;\n\t\t\tcircles.push_back(Circle(p,1.0));\n\t\t}\n\n\t\trep(i,n) for(int j=i+1;j<n;j++){\n\t\t\tvector<Point> points = crosspoint(circles[i],circles[j]);\n\t\t\tif(points.size()!=2) continue;\n\t\t\trep(k,points.size()){\n\t\t\t\tccircles.push_back(Circle(points[k],1.0));\n\t\t\t}\n\t\t}\n\n\t\tint ans=0;\n\t\tvector<Point> points;\n\n\t\trep(i,ccircles.size()){\n\t\t\tvector<Point> tmp;\n\t\t\tint cnt=0;\n\t\t\trep(j,n){\n\t\t\t\tif(contain(ccircles[i],circles[j].c)){\n\t\t\t\t\tcnt++;\t\n\t\t\t\t\ttmp.push_back(circles[j].c);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max(cnt,ans)!=ans){\n\t\t\t\tans=max(cnt,ans);\n\t\t\t\t//points=tmp;\t\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1000000000\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint median_Point(Point a,Point b){\n  Vector v=a-b;\n  return b+(v/2);\n}\n\nPoint PointRotation(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\nvector<Point> vp;\nint ans;\nint n;\n\npair<Circle,Circle> makeCircle(Point a,Point b){\n  Point m=median_Point(a,b);\n  double d=sqrt(1-abs(a-b)/2);\n  Point A=m+(PointRotation(m,a,90)-m)*d,B=m+(PointRotation(m,a,270)-m)*d;\n  return mp(Circle(A,1),Circle(B,1));\n}\n\nint PointsInCircle(Circle C)\n{\n  int num=0;\n  for(int i=0;i<n;i++){\n    if(abs(vp[i]-C.c)<=C.r)num++;\n  }\n  return num;\n}\n\nint main()\n{\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    vp.clear();\n    vp.resize(n);\n    for(int i=0;i<n;i++)cin>>vp[i].x>>vp[i].y;\n    ans=1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i==j)continue;\n\tif(2<abs(vp[i]-vp[j]))continue;\n\tpair<Circle,Circle> pc=makeCircle(vp[i],vp[j]);\n\tans=max(ans,PointsInCircle(pc.f));\n\tans=max(ans,PointsInCircle(pc.s));\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\ntypedef pair<double, double> PD;\n\nconst double EPS = 1e-11;\ndouble sq(double x) { return x * x; }\n\nvector<PD> solve(double ax, double ay, double bx, double by) {\n  double sqdist = sq(ax - bx) + sq(ay - by);\n  double dist = sqrt(sqdist);\n  double ndist = sqrt(1 - sqdist / 4);\n  double ex = (bx - ax) / dist, ey = (by - ay) / dist;\n  vector<PD> ans(2);\n  REP(i, 0, 2) {\n    double coef = i == 0 ? 1 : -1;\n    ans[i].first = (ax + bx) / 2 + ey * coef * ndist;\n    ans[i].second = (ay + by) / 2 - ex * coef * ndist;\n  }\n  return ans;\n}\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  while(cin >> n && n) {\n    vector<double> x(n), y(n);\n    REP(i, 0, n) cin >> x[i] >> y[i];\n    vector<PD> cand;\n    REP(i, 0, n) {\n      REP(j, 0, i) {\n\tfor (PD e: solve(x[i], y[i], x[j], y[j])) {\n\t  cand.push_back(e);\n\t}\n      }\n    }\n    int ma = 0;\n    for (PD c: cand) {\n      int cnt = 0;\n      REP(i, 0, n) {\n\tdouble sqdist = sq(x[i] - c.first) + sq(y[i] - c.second);\n\tif (sqdist <= 1 + EPS) {\n\t  cnt += 1;\n\t}\n      }\n      ma = max(ma, cnt);\n    }\n    cout << ma << \"\\n\";\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 1000000000\n#define sz(x) ((int)(x).size())\n#define sq(x) ((x)*(x))\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ndouble add(double a,double b){\n\tif(abs(a+b)<eps*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{\n\tdouble x,y;\n\tP() {}\n\tP(double x,double y) : x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tdouble dot(P p){\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tdouble norm(){\n\t\treturn sqrt(x*x+y*y);\n\t}\n\tdouble dist2(P p){\n\t\treturn sq(x-p.x)+sq(y-p.y);\n\t}\n\tP vert(){\n\t\treturn P(y,-x);\n\t}\n\tvoid dump(){\n\t\tprintf(\"%.12f %.12f\\n\",x,y);\n\t\treturn;\n\t}\n};\nint N;\nP pts[305];\nint solve(){\n\tscanf(\"%d\",&N);\n\tif(N==0)return 1;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%lf %lf\",&pts[i].x,&pts[i].y);\n\t}\n\tint ans = 0;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tP m = (pts[i]+pts[j])*0.5;\n\t\t\tP a = (pts[i]-pts[j]);\n\t\t\tdouble na = a.norm();\n\t\t\tif(na>2.0)continue;\n\t\t\ta = (a.vert())*(1/na);\n\t\t\ta = a*(sqrt(1-sq(na/2.0)));\n\t\t\tP b = m+a;\n\t\t\tP c = m-a;\n\t\t\t/*cout << i << ' ' << j << endl;\n\t\t\tm.dump();\n\t\t\ta.dump();\n\t\t\tb.dump();\n\t\t\tc.dump();\n\t\t\tcout << endl;*/\n\t\t\tint cnt = 0;\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t//printf(\"%d:%.12f\\n\",k,pts[k].dist2(b));\n\t\t\t\tif(pts[k].dist2(b)<=1.0+eps)cnt++;\n\t\t\t}\n\t\t\tans = max(ans,cnt);\n\t\t\tcnt = 0;\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t//printf(\"%d:%.12f\\n\",k,pts[k].dist2(c));\n\t\t\t\tif(pts[k].dist2(c)<=1.0+eps)cnt++;\n\t\t\t}\n\t\t\tans = max(ans,cnt);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\nint main(){\n\twhile(!solve()){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <tuple>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nint N;\ndouble x[300];\ndouble y[300];\ninline double dist2(double a, double b)\n{\n\treturn a*a+b*b;\n}\nvoid exec()\n{\n\tcin >> N;\n\tif(N==0){\n\t\texit(0);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tint ret=1;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tdouble dx=(x[i]-x[j])/2;\n\t\t\tdouble dy=(y[i]-y[j])/2;\n\t\t\tdouble r2=dx*dx+dy*dy;\n\t\t\tdouble R=sqrt(1/r2-1);\n\t\t\tdouble px=x[j]+dx-R*dy;\n\t\t\tdouble py=y[j]+dy+R*dx;\n\t\t\tdouble qx=x[j]+dx+R*dy;\n\t\t\tdouble qy=y[j]+dy-R*dx;\n\t\t\tint sp=0,sq=0;\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\tif(k==i||k==j){\n\t\t\t\t\tsp++;sq++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(dist2(x[k]-px,y[k]-py)<=1){\n\t\t\t\t\tsp++;\n\t\t\t\t}\n\t\t\t\tif(dist2(x[k]-qx,y[k]-qy)<=1){\n\t\t\t\t\tsq++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret=max(ret,sp);\n\t\t\tret=max(ret,sq);\n\t\t}\n\t}\n\tcout << ret << endl;\n}\nint main() {\n\twhile(1)\n\t\texec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nconst double EPS = 1e-6;\ntypedef pair<double,double> P;\n\ndouble dist(P p,P q){\n  return sqrt( (p.first-q.first)*(p.first-q.first) + (p.second-q.second)*(p.second-q.second));\n}\n\nint countP(double x,double y,vector<P>& p){\n  P t(x,y);\n  int ans = 0;\n  REP(i,p.size()){\n    if(dist(t,p[i]) < 1 + EPS){\n      ans ++;\n    }\n  }\n  return ans;\n}\n\nint main(){\n  int N;\n  while(cin>>N,N){\n    vector<P> p(N);\n    REP(i,N)cin>>p[i].first>>p[i].second;\n    int ans = 0;\n    REP(i,100000){\n      ans = max(ans, countP((double)rand()*10/RAND_MAX, (double)rand()*10/RAND_MAX, p));\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <complex>\n\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,n) loop(i,0,n)\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef complex<double> vec;\n\ndouble const pi = acos(-1);\ndouble const eps = 1e-6;\n\nint main(){\n    int n;\n    while (cin >> n && n){\n        vector<vec> v(n);\n        rep(i, n){\n            double x, y; cin >> x >> y;\n            vec p(x, y);\n            v[i] = p;\n        }\n\n        if (n == 1) {\n            puts(\"1\");\n            continue;\n        }\n        int ans = 1;\n        rep(i, n)rep(j, i){\n            double d = abs(v[i] - v[j]);\n            if (d > 2) continue;\n            ans = max(ans, 2);\n            double h = sqrt(1 - d*d / 4);\n            vec c1 = polar(h, arg(v[i] - v[j]) + pi / 2) + (v[i] + v[j]) / 2.;\n            vec c2 = polar(h, arg(v[i] - v[j]) - pi / 2) + (v[i] + v[j]) / 2.;\n            int a1 = 0, a2 = 0;\n            rep(k, n){\n                if (abs(c1 - v[k]) <= 1) a1++;\n                if (abs(c2 - v[k]) <= 1) a2++;\n            }\n            ans = max(ans, a1);\n            ans = max(ans, a2);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<cmath>\n#define dot complex<double>\nusing namespace std;\nint main(){\n  int n;\n  while(cin >>n,n){\n    vector<dot > num;\n    for(int i=0; i<n; i++){\n      double a,b;\n      cin >>a>>b;\n      num.push_back(dot(a,b));\n    }\n    int ans = 1;\n    for(int i=0; i<n; i++){\n      for(int j=i+1; j<n; j++){\n\tdot v = num[j]-num[i],o;\n\tif(abs(v) >= 2) continue;\n\tv/=2;\n\tint f = 0;\n\tdouble r = sqrt(1-abs(v)*abs(v))/abs(v);\n\to = num[i]+v+dot(v.imag(),-v.real())*r;\n\tfor(int k=0; k<n; k++){\n\t  dot vv = num[k]-o;\n\t  if(abs(vv)<1) f++;\n\t}\n\tans = max(ans,f);\n\tf = 0;\n\to = num[i]+v-dot(v.imag(),-v.real())*r;\n\tfor(int k=0; k<n; k++){\n\t  dot vv = num[k]-o;\n\t  if(abs(vv)<=1.00000001) f++;\n\t}\n\tans = max(ans,f);\n      }\n    }\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<double,double> P;\ntypedef pair<int,P> PP;\n\nint n;\nint ans;\nvector<double> x, y;\nvector<PP> v1, v2;\n\nvoid solve(){\n\tx.clear(); y.clear(); v1.clear(); v2.clear();\n\tx.resize(n); y.resize(n);\n\tans = 1;\n\trep(i,n) cin >> x[i] >> y[i];\n\tfor(int i = 0; i <= 100; i++) for(int j = 0; j <= 100; j++){\n\t\tdouble I = i/10.0, J = j/10.0;\n\t\tint cnt = 0;\n\t\trep(k,n){\n\t\t\tif((x[k]-I)*(x[k]-I)+(y[k]-J)*(y[k]-J) < 1) cnt++;\n\t\t}\n\t\tv1.push_back(PP(cnt,P(I,J)));\n\t}\n\tsort(v1.begin(),v1.end(), greater<PP>());\n\trep(u,10){\n\t\tP p = v1[u].second;\n\t\tfor(int i = 0; i <= 100; i++) for(int j = 0; j <= 100; j++){\n\t\t\tdouble I = p.first-0.05+i/1000.0, J = p.second-0.05+j/1000.0;\n\t\t\tint cnt = 0;\n\t\t\trep(k,n){\n\t\t\t\tif((x[k]-I)*(x[k]-I)+(y[k]-J)*(y[k]-J) < 1) cnt++;\n\t\t\t}\n\t\t\tv2.push_back(PP(cnt,P(I,J)));\n\t\t}\n\t}\n\tsort(v2.begin(),v2.end(), greater<PP>());\n\t\n\trep(u,10){\n\t\tP p = v2[u].second;\n\t\tfor(int i = 0; i <= 100; i++) for(int j = 0; j <= 100; j++){\n\t\t\tdouble I = p.first-0.005+i/10000.0, J = p.second-0.005+j/10000.0;\n\t\t\tint cnt = 0;\n\t\t\trep(k,n){\n\t\t\t\tif((x[k]-I)*(x[k]-I)+(y[k]-J)*(y[k]-J) < 1) cnt++;\n\t\t\t}\n\t\t\tans = max(ans,cnt);\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nint main(){\n\twhile(cin >> n){\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define sz(x) ((int)(x).size())\n#define sq(x) ((x)*(x))\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ndouble add(double a,double b){\n\tif(abs(a+b)<eps*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{\n\tdouble x,y;\n\tP() {}\n\tP(double x,double y) : x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tdouble dot(P p){\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tdouble norm(){\n\t\treturn sqrt(x*x+y*y);\n\t}\n\tdouble dist2(P p){\n\t\treturn sq(x-p.x)+sq(y-p.y);\n\t}\n\tP vert(){\n\t\treturn P(y,-x);\n\t}\n\tvoid dump(){\n\t\tprintf(\"%.12f %.12f\\n\",x,y);\n\t\treturn;\n\t}\n};\nint N;\nP pts[305];\nint solve(){\n\tscanf(\"%d\",&N);\n\tif(N==0)return 1;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%lf %lf\",&pts[i].x,&pts[i].y);\n\t}\n\tint ans = 1;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tP m = (pts[i]+pts[j])*0.5;\n\t\t\tP a = (pts[i]-pts[j]);\n\t\t\tdouble na = a.norm();\n\t\t\tif(na>2.0)continue;\n\t\t\ta = (a.vert())*(sqrt(1-sq(na/2.0))/na);\n\t\t\tP b = m+a;\n\t\t\tP c = m-a;\n\t\t\t/*cout << i << ' ' << j << endl;\n\t\t\tm.dump();\n\t\t\ta.dump();\n\t\t\tb.dump();\n\t\t\tc.dump();\n\t\t\tcout << endl;*/\n\t\t\tint cnt = 0;\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t//if(1.0<pts[k].dist2(b)&&pts[k].dist2(b)<=1.0+eps)printf(\"%d:%.12f\\n\",k,pts[k].dist2(b));\n\t\t\t\tif(pts[k].dist2(b)<=1.0+eps)cnt++;\n\t\t\t}\n\t\t\tans = max(ans,cnt);\n\t\t\tcnt = 0;\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t//if(1.0<pts[k].dist2(c)&&pts[k].dist2(c)<=1.0+eps)printf(\"%d:%.12f\\n\",k,pts[k].dist2(c));\n\t\t\t\tif(pts[k].dist2(c)<=1.0+eps)cnt++;\n\t\t\t}\n\t\t\tans = max(ans,cnt);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\nint main(){\n\twhile(!solve()){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\nconst double PI=3.141592653589793238462643383279;\n\nbool inC(P p, P c, double r){return abs(p-c)<r+1e-9;}\n\nP getE(P p){return p/abs(p);}\n\ndouble sq(double x){ return  x*x;}\n\nint main(){\n    int n,i,j,k,ans,cnt;\n    double x, y;\n    while(scanf(\"%d\",&n)){\n        if(n==0) break;\n        ans=0;\n        vector<P> ps(n);\n        for(i=0; i<n; i++){\n            scanf(\"%lf%lf\",&x,&y);\n            ps[i] = P(x,y);\n        }\n        for(i=0;i<n;i++)\n            for(j=i+1;j<n;j++)if(abs(ps[i]-ps[j])<2){\n                double d=sqrt(1-sq(abs(ps[j]-ps[i])*0.5));\n                P c1=0.5*(ps[i]+ps[j])+getE(getE(ps[j]-ps[i]))*polar(d,PI/2);\n                P c2=0.5*(ps[i]+ps[j])+getE(getE(ps[j]-ps[i]))*polar(d,-PI/2);\n                cnt=0;\n                for(k=0;k<n;k++)if(inC(ps[k],c1,1.0))cnt++;\n                if(cnt>ans)ans=cnt;\n                cnt=0;\n                for(k=0;k<n;k++)if(inC(ps[k],c2,1.0))cnt++;\n                if(cnt>ans)ans=cnt;\n            }\n        if(ans==0) ans++;\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<math.h>\n\nusing namespace std;\ntypedef pair<double, double> P;\n\nint N;\ndouble X[300], Y[300];\nP d[300];\n\nconst double ESP = 0.0001;\n\n\nbool near(double x, double y) {\n  return abs(x - y) < ESP;\n}\n\nP add(P p1, P p2) {\n  return P(p1.first + p2.first, p1.second + p2.second);\n}\n\nP minas(P p1, P p2) {\n  return P(p1.first - p2.first, p1.second - p2.second);\n}\n\nP mul(P p, double c) {\n  return P(p.first * c, p.second * c);\n}\n\nP ave(P p1, P p2) {\n  return P((p1.first + p2.first) / 2, (p1.second + p2.second) / 2);\n}\n\nvoid printP(P p) {\n  printf(\"P:(%f, %f)\\n\", p.first, p.second);\n}\n\ndouble square(P p) {\n  return p.first * p.first + p.second * p.second;\n}\n\ndouble size(P p) {\n  return sqrt(square(p));\n}\n\nint count(P p) {\n  // printP(p);\n  int counter = 0;\n  for (int i = 0; i < N; i++) {\n    if (square(minas(p, d[i])) <= 1.00001) counter++;\n  }\n  return counter;\n}\n\nint check(int i, int j) {\n  if (square(minas(d[i], d[j])) > 4.0) return 0;\n  int ans = 0;\n  P average = ave(d[i], d[j]);\n  P dir = mul(minas(d[i], d[j]), 0.5);\n  // printP(average);\n  double s = sqrt(1.0 - square(dir));\n  // printf(\"!!!!!!%f\\n\",s);\n  P dir1 = P((Y[i] - Y[j]), - (X[i] - X[j]));\n  //printf(\"!!!!!!%f\\n\",size(dir1));\n  double r = s / size(dir1);\n  P d1 = add(average, mul(dir1, r));\n  P d2 = add(average, mul(dir1, -r));\n  return max(count(d1), count(d2));\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &N);\n    if (N == 0) break;\n    for (int i = 0; i < N; i++) scanf(\"%lf%lf\", &X[i], &Y[i]), d[i] = P(X[i], Y[i]);\n    int ans = 0;\n    for (int i = 0; i < N; i++)\n      for (int j = 0; j < i; j++)\n        ans = max(ans, check(i, j));\n    printf(\"%d\\n\", ans);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> point;\n\npoint cal(point a,point b,double c){\n  double w=abs(b-a);\n  double h=sqrt(c*c-w*w/4);\n  point cen=point(w/2,h);\n  return cen*(b-a)/w+a;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    int ans=1;\n    double x,y;\n    point p[300];\n    for(int i=0;i<n;i++)cin>>x>>y,p[i]=point(x,y);\n\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++){\n\tif(abs(p[i]-p[j])>2)continue;\n\tpoint center=cal(p[i],p[j],1);\n\tint can=0;\n\tfor(int k=0;k<n;k++)\n\t  if(abs(p[k]-center)<=1+1e-8)can++;\n\tans=max(ans,can);\n      }\n    \n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1000000000\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint median_Point(Point a,Point b){\n  Vector v=a-b;\n  return b+(v/2);\n}\n\nPoint PointRotation(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\nvector<Point> vp;\nint ans;\nint n;\n\npair<Circle,Circle> makeCircle(Point a,Point b){\n  Point m=median_Point(a,b);\n  double d=sqrt(1-abs(a-b)/2);\n  Point A=m+(PointRotation(m,a,90)-m)*d,B=m+(PointRotation(m,a,270)-m)*d;\n  return mp(Circle(A,1),Circle(B,1));\n}\n\nint PointsInCircle(Circle C)\n{\n  int num=0;\n  for(int i=0;i<n;i++){\n    if((abs(vp[i]-C.c)-C.r)<+eps)num++;\n  }\n  return num;\n}\n\nint main()\n{\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    vp.clear();\n    vp.resize(n);\n    for(int i=0;i<n;i++)cin>>vp[i].x>>vp[i].y;\n    ans=1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i==j)continue;\n\tif(2<abs(vp[i]-vp[j]))continue;\n\tpair<Circle,Circle> pc=makeCircle(vp[i],vp[j]);\n\tans=max(ans,PointsInCircle(pc.f));\n\tans=max(ans,PointsInCircle(pc.s));\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <utility>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nbool eqv(double a, double b) {\n    return abs(a-b) < 1e-10;\n}\n\nbool inCircle(const Point &p, const Point &center, double radius) {\n    return abs(p-center) < radius+1e-10;\n}\n\nint check(const Point &center, const vector<Point> &points) {\n    const int N = points.size();\n    int cnt = 0;\n    for(int i = 0; i < N; ++i) {\n        if(inCircle(points[i], center, 1)) ++cnt;\n    }\n    return cnt;\n}\n\nint test(int a, int b, const vector<Point> &points) {\n    const Point v(points[a]-points[b]);\n    const double hlen = abs(v)/2;\n\n    if(hlen >= 1) return 0;\n    const Point unit = v / abs(v);\n    const double angle = acos(hlen);\n    return max(check(points[b] + unit*polar(1.0, angle), points), check(points[b] + unit*polar(1.0, -angle), points));\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        vector<Point> points(N);\n        for(int i = 0; i < N; ++i) {\n            cin >> points[i].real() >> points[i].imag();\n        }\n        int ans = 0;\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < i; ++j) {\n                ans = max(ans, test(i, j, points));\n            }\n        }\n        if(N == 1) ans = 1;\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\n#define MAX_N 310\n\ndouble x[MAX_N], y[MAX_N];\nint n, maxn;\n\nint main() {\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tmaxn = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tint sum = 0;\n\n\t\t\t\tdouble X = (x[i] + x[j]) / 2.0;\n\t\t\t\tdouble Y = (y[i] + y[j]) / 2.0;\n\n\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t{\n\t\t\t\t\tif (((x[k] - X)*(x[k] - X) + (y[k] - Y)*(y[k] - Y)) <= 1) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\n\t\t\t\tdouble X1, Y1, X2, Y2, X3, Y3, VX2, VY2, Dist, Dist2;\n\n\t\t\t\tDist = sqrt((x[j] - x[i])*(x[j] - x[i]) + (y[j] - y[i])*(y[j] - y[i]));\n\t\t\t\tDist2 = sqrt(4 - Dist*Dist);\n\n\t\t\t\tX2 = x[j] - x[i]; Y2 = y[j] - y[i];\n\t\t\t\tVX2 = (X2 / Dist)*Dist2 / 2; VY2 = (Y2 / Dist)*Dist2 / 2;\n\n\t\t\t\tX1 = X + VY2; Y1 = Y - VX2;\n\t\t\t\tX3 = X - VY2; Y3 = Y + VX2;\n\n\t\t\t\tsum = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (((x[k] - X1)*(x[k] - X1) + (y[k] - Y1)*(y[k] - Y1)) <= 1.0001) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\t\t\t\tsum = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (((x[k] - X3)*(x[k] - X3) + (y[k] - Y3)*(y[k] - Y3)) <= 1.0001) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint sum = 0;\n\t\t\tlong double X = x[i];\n\t\t\tlong double Y = y[i];\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (((x[k] - X)*(x[k] - X) + (y[k] - Y)*(y[k] - Y)) <= 1) {\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxn = max(maxn, sum);\n\t\t}\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(N); i++)\n\nusing namespace std;\nnamespace geom{\n#define at(i) ((*this)[i])\n#define pb push_back\n#define X real()\n#define Y imag()\n#define SELF (*this)\ntypedef long double R;\ntypedef complex<R> P;\nconst R EPS = 1e-8;\nconst R PI=3.14159265358979323846264338327950288;\nenum { TURE = 1, FALSE = 0, BORDER= -1};\ninline int sig(const R&x){return (abs(x)<EPS?0:x>0?1:-1);}\ninline int less(const R &x,const R &y){return sig(x-y)?x<y:BORDER;}\ninline R inp(const P &a,const P &b){return (conj(a)*b).X;}\ninline R outp(const P &a,const P & b){return (conj(a)*b).Y;}\ninline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\ninline P unit(const P & p){return p/abs(p);}\ninline P proj(const P &s,const P &t){return t*inp(s,t)/norm(t);}\nstruct L :public vector<P>{\n  L(const P &p1,const P &p2){this->pb(p1);this->pb(p2);}\n  L(){}\n  P dir()const {return at(1)-at(0);}\n  int online(const P &p) const {return !sig(outp(p-at(0),dir()));}\n};\nstruct S: public L {\n    S(const P &p1, const P &p2): L(p1,p2){}\n    S(){}\n    int online(const P &p) const{\n        if(!sig(norm( p-at(0) )) || !sig(norm(p - at(1))) ) return BORDER;\n        return !sig(outp(p-at(0), dir())) && inp(p-at(0), dir()) > EPS && inp(p-at(1),-dir()) > -EPS;\n    }\n};\nstruct C :public P{\n  C(){}\n  C(const P &p,const R r):P(p),r(r){}\n  R r;\n  int inside(const P &p)const { return less(norm(p-SELF),r*r);}\n};\n//inline P proj(const P &s,const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\ninline int intersect (const C &a,const C &b){\n  return less((a.r-b.r)*(a.r-b.r),norm(a-b))+less(norm(a-b),(a.r+b.r)*(a.r+b.r))-1;\n}\n\ninline S crosspoint(const C &c1,const C &c2){\n  if(!intersect(c1,c2)) return S();\n  R d=abs(c1-c2);\n  R x=(c1.r*c1.r-c2.r*c2.r+d*d)/(2*d);\n  R h=sqrt(max<R>(0.,c1.r*c1.r-x*x));\n  P u=unit(c2-c1);\n  return S(c1+u*x+u*P(0,-1)*h,c1+u*x+u*P(0,1)*h);\n}\n\n// inline S crosspoint(const C &c,const L &l){\n//   R d2=dist2(l,c);\n//   if(c.r*c.r+EPS < d2) return S();\n//   P m= proj(c,l);\n//   P u = unit(l[1]-l[0]);\n//   R d=sqrt(max<R>(.0,c.r*c.r-d2));\n//   return S(m+u*d,m-u*d);\n// }\n\nS circlePPR(const P& a, const P& b, R r){\n    return crosspoint( C(a,r), C(b,r) );\n}\n}\nusing namespace geom;\n\nint main(){\n    int N;\n    while(cin>>N, N){\n        int ans = 0;\n        P po[305];\n        rep(i,N){\n            R x, y;\n            cin >> x >> y;\n            po[i] = P(x, y);\n        }\n        rep(i,N) rep(j,i){\n            //if( i==j ) continue;\n            S s = circlePPR( po[i], po[j], 1.0 );\n            //if( s.empty() ) continue;\n            //for(auto t: s) cout << t << \" \"; cout << endl;\n            for(auto k: s){\n                int count = 0;\n                rep(h,N){\n                    if( abs(k-po[h]) < 1.0 + EPS ){\n                        count++;\n                    }\n                }\n                ans = max(ans, count);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n\nusing namespace std;\n\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\n\nconst int INF = INT_MAX / 4;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); i++ )\n#define UREP( i, m, n ) for ( ui i = (ui)( m ); i < (ui)( n ); i++ )\n#define EACH( v, c ) for ( __typeof( c.front() ) &v : c )\n\n#define ITER( c ) __typeof( (c).begin() )\n#define IREP( c, it ) for ( ITER(c) it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define RALL( c ) (c).rbegin(), (c).rend()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\ndouble powdist( double x1, double y1, double x2, double y2 )\n{\n\treturn pow( x1 - x2, 2 ) + pow( y1 - y2, 2 );\n}\n\ndouble dist( double x1, double y1, double x2, double y2 )\n{\n\treturn sqrt( pow( x1 - x2, 2 ) + pow( y1 - y2, 2 ) );\n}\n\nint main()\n{\n\twhile ( true )\n\t{\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif ( n == 0 )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<double> x( n ), y( n );\n\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\n\t\tint res = 1;\n\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tREP( j, i + 1, n )\n\t\t\t{\n\t\t\t\tif ( powdist( x[i], y[i], x[j], y[j] ) <= 4 )\n\t\t\t\t{\n\t\t\t\t\tdouble mx = ( x[i] + x[j] ) / 2, my = ( y[i] + y[j] ) / 2;\n\t\t\t\t\tdouble xl = sqrt( 1 - pow( dist( x[i], y[i], x[j], y[j] ) / 2, 2 ) );\n\t\t\t\t\t\n\t\t\t\t\tdouble ox1 = mx, oy1 = my, ox2 = mx, oy2 = my;\n\n\t\t\t\t\tif ( x[i] - x[j] == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\toy1 += xl;\n\t\t\t\t\t\toy2 -= xl;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( y[i] - y[j] == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tox1 += xl;\n\t\t\t\t\t\toy2 -= xl;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble s = -( ( x[j] - x[i] ) / ( y[j] - y[i] ) );\n\t\t\t\t\t\tdouble th = atan( s );\n\t\t\t\t\t\t\n\t\t\t\t\t\tox1 = mx + xl * cos( th );\n\t\t\t\t\t\toy1 = my + xl * sin( th );\n\n\t\t\t\t\t\tox2 = mx - xl * cos( th );\n\t\t\t\t\t\toy2 = my - xl * sin( th );\n\t\t\t\t\t}\n\n\t\t\t\t\tint tmp1 = 2, tmp2 = 2;\n\n\t\t\t\t\tREP( k, 0, n )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( i == k || j == k )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( powdist( x[k], y[k], ox1, oy1 ) <= 1 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmp1++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( powdist( x[k], y[k], ox2, oy2 ) <= 1 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmp2++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tres = max( res, max( tmp1, tmp2 ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = 1e9;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> P;\n\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n\n/** 幾何ライブラリ **/\n#include <complex>\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-11;\nconst double PI = acos(-1.0);\n\ntypedef double D;\ntypedef complex<D> P; // Point\n\nstruct L { // Line\n\tP a, b;\n\tL(){}\n\tL(P aa, P bb) : a(aa), b(bb){}\n};\n\nstruct C { // Circle\n\tP p; D r;\n\tC() {}\n\tC(P pp, D rr) : p(pp), r(rr) {}\n};\n\n// 共役複素数 conj(a);\n\n// 符号\nint sig(D a, D b=0) {\n\tif (a < b-EPS) return -1;\n\tif (a > b+EPS) return 1;\n\treturn 0;\n}\n\n// 内積\nD dot(P a, P b) { return (conj(a)*b).real(); }\n\n// 外積\nD cross(P a, P b) { return (conj(a)*b).imag(); }\n\n// 線分abに対する点cの位置\nenum STATE{LEFT=1, RIGHT=-1, BACK=2, FRONT=-2, ON=0, IN=3, OUT=-3};\nint ccw(P a, P b, P c)\n{\n\tb -= a, c -= a;\n\tD s = sig(cross(b, c));\n\tif (s) return s>0 ? LEFT : RIGHT;\n\tif (sig(dot(b, c))<0) return BACK;\n\tif (sig(abs(c), abs(b))>0) return FRONT;\n\treturn ON;\n}\n\n// 直線lに対する点pの写像\nP projection(L l, P p)\n{\n\treturn l.a + (l.b-l.a)/abs(l.b-l.a) * dot(l.b-l.a, p-l.a)/abs(l.b-l.a);\n}\n\n// 直線lに対する点pの反射\nP reflection(L l, P p)\n{\n\treturn p + (projection(l, p)-p)*P(2, 0);\n}\n\n// 直線abと点cの距離\nD dLP(L l, P c)\n{\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分abと点cの距離\nD dSP(L l, P c)\n{\n\tif (sig(dot(l.b-l.a, c-l.a))<0) return abs(c-l.a);\n\tif (sig(dot(l.a-l.b, c-l.b))<0) return abs(c-l.b);\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分と線分の交差判定\nbool iSS(L s, L t)\n{\n\treturn (ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0)\n\t\t\t&& (ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0);\n}\n\n// 線分と線分の距離\nD dSS(L s, L t)\n{\n\tif (iSS(s, t)) return 0;\n\treturn min(min(dSP(t, s.a), dSP(t, s.b)), min(dSP(s, t.a), dSP(s, t.b)));\n}\n\n// 線分と線分の交点 (公差していることが前提)\nP cSS(L s, L t)\n{\n\tD d1 = dLP(t, s.a);\n\tD d2 = dLP(t, s.b);\n\tD tmp = d1 / (d1 + d2);\n\treturn s.a + (s.b-s.a)*tmp;\n}\n\n// 直線と直線の交差判定\nbool iLL(L s, L t)\n{\n\treturn sig(cross(s.b-s.a, t.b-t.a))!=0;\n}\n\n// 直線と直線の交点 iLLを確認してから使用\nP cLL(L s, L t)\n{\n\tP ss = s.b - s.a, tt = t.b - t.a;\n\treturn s.a + ss*cross(tt, t.a-s.a)/cross(tt, ss);\n}\n\n// 円と直線の交差判定 (交点の数を返す)\nint iCL(C c, L l)\n{\n\tint t = sig(dLP(l, c.p), c.r);\n\tif (t < 0) return 2;\n\telse if (t == 0) return 1;\n\treturn 0;\n}\n\n// 円と直線の交点を求める\nvector<P> cCL(C c, L l)\n{\n\tvector<P> res;\n\tint n = iCL(c, l);\n\t\n\tP h = projection(l, c.p);\n\tD d = abs(h-c.p);\n\t\n\tif (n == 2) {\n\t\tP x = (l.b-l.a)/abs(l.b-l.a)*sqrt(c.r*c.r - d*d);\n\t\tres.push_back(h+x);\n\t\tres.push_back(h-x);\n\t} else if (n == 1) {\n\t\tres.push_back(h);\n\t}\n\t\n\treturn res;\n}\n\n// 円と円の交点を求める (交点があることが前提)\nvector<P> cCC(C a, C b)\n{\n\tD d = abs(b.p - a.p);\n\tD rc = (d*d + a.r*a.r - b.r*b.r)/(2*d);\n\tD rs = sqrt(a.r*a.r - rc*rc);\n\tP diff = (b.p-a.p)/d;\n\t\n\tvector<P> res;\n\tres.push_back(a.p + diff*P(rc, rs));\n\tres.push_back(a.p + diff*P(rc, -rs));\n\treturn res;\n}\n\n\n// 多角形\ntypedef vector<P> G;\n\n// 面積を求める\nD area(G g)\n{\n\tD res = 0.0;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tres += cross(g[i], g[(i+1)%g.size()]);\n\t}\n\treturn abs(res)/2;\n}\n\n// 多角形gと点pの包含関係を求める\nint containsGP(G g, P p)\n{\n\tbool in=false;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tP a = g[i], b = g[(i+1)%g.size()];\n\t\tif (ccw(a, b, p) == ON) return ON;\n\t\t\n\t\ta -= p, b -= p;\n\t\tif (a.Y > b.Y) swap(a, b);\n\t\tif (a.Y<0 && b.Y>=0 && sig(cross(a, b))>0) in = !in;\n\t}\n\treturn in?IN:OUT;\n}\n\nbool cmp_convex_full(const P &a, const P &b)\n{\n\tif (sig(a.X, b.X) != 0) return a.X < b.X;\n\treturn a.Y < b.Y;\n}\n\n// 凸包を得る\n// 辺上を含めない場合は <= 0 にする\nG convex_hull(vector<P> ps)\n{\n\tif (ps.size()==1) return ps;\n\t\n\tint N = (int)ps.size(), k=0;\n\tsort(ps.begin(), ps.end(), cmp_convex_full);\n\tG res(2*N);\n\t\n\tfor (int i=0; i<N; i++) {\n\t\twhile (k>=2 && ccw(res[k-2], res[k-1], ps[i]) == RIGHT) k--;\n\t\tres[k++] = ps[i];\n\t}\n\t\n\tint t = k+1;\n\tfor (int i=N-2; i>=0; i--) {\n\t\twhile (k>=t && ccw(res[k-2], res[k-1], ps[i]) == RIGHT) k--;\n\t\tres[k++] = ps[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// 凸多角形を直線で切断し、左側を残す\nG convex_cut(G g, L l)\n{\n\tG res;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tP a = g[i], b = g[(i+1)%g.size()];\n\t\tif (ccw(l.a, l.b, a) != RIGHT) res.push_back(a);\n\t\tif (ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0) res.push_back(cLL(L(a, b), l));\n\t}\n\treturn res;\n}\n\n\n/** Problem1132 : Circle and Points **/\nint main()\n{\n\tint N;\n\twhile (cin>>N, N) {\n\t\tvector<P> ps(N);\n\t\trep(i, N) {\n\t\t\tcin>>ps[i].X>>ps[i].Y;\n\t\t}\n\t\t\n\t\tint ans = 1;\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tfor (int j=i+1; j<N; j++) {\n\t\t\t\tif (sig(abs(ps[i]-ps[j]), 2) > 0) continue;\n\t\t\t\t\n\t\t\t\tP p = ps[j] - ps[i];\n\t\t\t\tD len = abs(p);\n\t\t\t\t\n\t\t\t\tP mid = ps[i] + p/2.0;\n\t\t\t\tD h = sqrt(1*1 - (len/2.0)*(len/2.0));\n\t\t\t\t\n\t\t\t\tP dir = p*P(0, 1)/len;\n\t\t\t\tC c1(mid+h*dir, 1), c2(mid-h*dir, 1);\n\t\t\t\t\n\t\t\t\tint tans=0;\n\t\t\t\tfor (int k=0; k<N; k++) {\n\t\t\t\t\tD x = ps[k].X - c1.p.X, y = ps[k].Y - c1.p.Y;\n\t\t\t\t\tif (sig(sqrt(x*x + y*y), 1) <= 0) tans++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, tans);\n\t\t\t\t\n\t\t\t\ttans = 0;\n\t\t\t\tfor (int k=0; k<N; k++) {\n\t\t\t\t\tD x = ps[k].X - c2.p.X, y = ps[k].Y - c2.p.Y;\n\t\t\t\t\tif (sig(sqrt(x*x + y*y), 1) <= 0) tans++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, tans);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<double, double> PD;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nvector<PD> cli(double a, double b, double c, PD c1) {\n  double l = a * a + b * b, k = a * c1.fi + b * c1.se + c, d = l - k * k;\n  vector<PD> v;\n  if (d > 0) {\n    double ds = sqrt(d), apl = a / l, bpl = b / l;\n    double xc = c1.fi - apl * k, xd = bpl * ds, yc = c1.se - bpl * k, yd = apl * ds;\n    v.pb(PD(xc - xd, yc + yd)), v.pb(PD(xc + xd, yc - yd));\n  } else if (d == 0) {\n    v.pb(PD(c1.fi - a * k / l, c1.se - b * k / l));\n  }\n  return v;\n}\n\nvector<PD> cci(PD c1, PD c2) {\n  double a = c1.fi - c2.fi, b = c1.se - c2.se;\n  return cli(2.0 * a, 2.0 * b, 0 - a * (c1.fi + c2.fi) - b * (c1.se + c2.se), c1);\n}\n\nbool dist(PD p1, PD p2) {\n  return (pow(p1.fi - p2.fi, 2.0) + pow(p1.se - p2.se, 2.0)) <= 1.0 + 1e-7;\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int n;\n  while(cin >> n, n) {\n    vector<PD> v(n);\n    rep(i, n) cin >> v[i].fi >> v[i].se;\n\n    int maxi = 0;\n    rep(i, n - 1)repl(j, i + 1, n) {\n      vector<PD> p = cci(v[i], v[j]);\n      rep(k, p.size()) {\n        int cnt = 0;\n        rep(l, n) {\n          if (dist(p[k], v[l])) cnt++;\n        }\n        maxch(maxi, cnt);\n      }\n    }\n\n    cout << maxi << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n \n#define rep(i,n) for(int i=0;i<(n);i++)\n \nusing namespace std;\n \ntypedef complex<double> Point;\n \nconst double EPS=1e-9;\n \nint n;\nPoint p[300];\n \nint f(const Point &c){\n    int res=0;\n    rep(i,n) if(abs(p[i]-c)<1+EPS) res++;\n    return res;\n}\n \nint main(){\n    for(;scanf(\"%d\",&n),n;){\n        rep(i,n){ double x,y; scanf(\"%lf%lf\",&x,&y); p[i]=Point(x,y); }\n \n        int ans=1;\n        rep(j,n) rep(i,j) {\n            double d=abs(p[j]-p[i])/2;\n            Point v=(p[j]-p[i])/(2*d);\n            if(d<1){\n                ans=max(ans,f(p[i]+d*v+sqrt(1-d*d)*v*Point(0,+1)));\n                ans=max(ans,f(p[i]+d*v+sqrt(1-d*d)*v*Point(0,-1)));\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\n// 点\nclass Point {\n  public:\n    float x, y;\n    Point(double ix = 0.0, double iy = 0.0) {\n      set(ix, iy);\n    }\n    void set(double ix = 0.0, double iy = 0.0) {\n      x = ix;\n      y = iy;\n    }\n    void copy(Point p) {\n      x = p.x;\n      y = p.y;\n    }\n    double length() {\n      return sqrt(x * x + y * y);\n    }\n    double distanceTo(Point p) {\n      double dx = p.x - x, dy = p.y - y;\n      return sqrt(dx * dx + dy * dy);\n    }\n    void setCentroidOf(Point p1, Point p2) {\n      x = (p1.x + p2.x) / 2;\n      y = (p1.y + p2.y) / 2;\n    }\n};\n\nint main() {\n  vector<int> results;\n  while (true) {\n    // 入力\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    vector<Point> p(n);\n    for (int i=0; i<n; i++) {\n      double x, y;\n      cin >> x >> y;\n      p[i].set(x, y);\n    }\n    \n    const int nC2 = n * (n - 1) / 2 + n;\n    vector<Point> px(n); // 現時点で有力な点\n    for (int i=0; i<n; i++) px[i].copy(p[i]);\n    vector<Point> cp(nC2); // 中点たち\n    int previousMaxScore = 0; // 前回のループでの最高スコア\n    int maxScoreConst = 0; // 同じ最高スコアが連続して記録された回数\n    while (true) {\n      // 与えられた点の中点たち（+もとの点）を候補点とする\n      int cpi = 0;\n      for (int i=0; i<n-1; i++) {\n\tfor (int j=i+1; j<n; j++) {\n\t  cp[cpi++].setCentroidOf(px[i], px[j]);\n\t}\n      }\n      for (int i=0; i<n; i++) cp[cpi++].copy(px[i]);\n      // 各点のスコアを算出\n      vector<int> scores(nC2);\n      for (int i=0; i<nC2; i++) {\n\tscores[i] = 0;\n\tfor (int j=0; j<n; j++) {\n\t  if (cp[i].distanceTo(p[j]) <= 1) scores[i]++;\n\t}\n      }\n      // cpをスコア降順にバブルソート\n      for (int i=0; i<nC2; i++) {\n\tfor (int j=0; j<nC2-1; j++) {\n\t  if (scores[j] < scores[j + 1]) {\n\t    double jx = cp[j].x, jy = cp[j].y;\n\t    cp[j].copy(cp[j + 1]);\n\t    cp[j + 1].set(jx, jy);\n\t    int js = scores[j];\n\t    scores[j] = scores[j + 1];\n\t    scores[j + 1] = js;\n\t  }\n\t}\n      }\n      // このループの最大スコア\n      int maxScore = scores[0];\n      //cout << maxScore << \" -> \";\n      if (maxScore == previousMaxScore) {\n\t// 最大スコアが5回連続で更新されなかったら確定\n\tpreviousMaxScore = maxScore;\n\tif (++maxScoreConst >= 5) break;\n      } else {\n\tpreviousMaxScore = maxScore;\n\tmaxScoreConst = 0;\n      }\n      // スコアが上位nの点を次のループの中点の素として採用\n      for (int i=0; i<n; i++) px[i].copy(cp[i]);\n    }\n    \n    results.push_back(previousMaxScore);\n    //cout << endl;\n  }\n  \n  int size = results.size();\n  for (int i=0; i<size; i++) {\n    cout << results[i] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nconst double EPS = 1e-4; // epsilon\nconst double R = 1;      // radius of circle\n\n/* Distance from (x1,y1) to (x2,y2) */\ndouble dist(std::pair<double, double> a, std::pair<double, double> b) {\n    \n    double ax, ay, bx, by;\n    ax = a.first;\n    ay = a.second;\n    bx = b.first;\n    by = b.second;\n    return std::sqrt(\n                        (by - ay) * (by - ay) +\n                        (bx - ax) * (bx - ax)\n                    );\n}\n\n/* Midpoint of two points */\nstd::pair<double, double>\nmidpoint(std::pair<double, double> a, std::pair<double, double> b) {\n    std::pair<double, double> mid;\n    mid.first = (a.first + b.first) / 2;\n    mid.second = (a.second + b.second) / 2;\n    return mid;\n}\n\n/*\nFind (By)\n((By) - Ay)^2 + (Bx - Ax)^2 = 1\n((By) - Ay)^2 = 1 - (Bx - Ax)^2\n(By) - Ay = sqrt(1 - (Bx - Ax)^2)\n(By) = sqrt(1 - (Bx - Ax)^2) + Ay\n*/\nint main() {\n    int n;\n    while (std::cin >> n) {\n        if (n <= 0) break;\n        int maxPts = 1;\n        if (n > 1) {\n            std::vector<std::pair<double, double>> pts;\n        \n            // insert points into vector\n            for(int i = 0; i < n; ++i) {\n                double x, y;\n                std::cin >> x >> y;\n                pts.emplace_back(x, y);\n            }\n            \n            for (unsigned int i = 0; i < pts.size() - 1; ++i) {\n                for (unsigned int j = i + 1; j < pts.size(); ++j) {\n                    // std::pair<double, double> a, b;\n                    auto a = pts.at(i);\n                    auto b = pts.at(j);\n                    if( dist(a, b) < (2*R-EPS)) {\n                        int numPts = 0;\n                        auto c = midpoint(a, b);\n                        auto cy1 = std::sqrt(1 - (c.first-a.first)*(c.first-a.first)) +\n                                   a.second;\n                        auto cy2 = -std::sqrt(1 - (c.first-a.first)*(c.first-a.first)) +\n                                   a.second;\n                        c.second = cy1;\n                        for (unsigned int k = 0; k < pts.size(); ++k) {\n                            // std::pair<double, double> p;\n                            auto p = pts.at(k);\n                            if (dist(c, p) < (R + EPS)) {\n                                numPts++;\n                            }\n                        }\n                        maxPts = std::max(numPts, maxPts);\n                        \n                        numPts = 0;\n                        c.second = cy2;\n                        for (unsigned int k = 0; k < pts.size(); ++k) {\n                            // std::pair<double, double> p;\n                            auto p = pts.at(k);\n                            if (dist(c, p) < (R + EPS)) {\n                                numPts++;\n                            }\n                        }\n                        maxPts = std::max(numPts, maxPts);\n                    }\n                }\n            }\n        \n        }\n        std::cout << maxPts << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble Dis(double x1, double y1, double x2, double y2);\nint main(void){\n\twhile(1){\n\t\tint n;\n\t\tint ans = 1;\n\t\tvector< pair<double, double> > p;\n\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tpair<double, double> t;\n\t\t\tcin >> t.first >> t.second;\n\t\t\tp.push_back(t);\n\t\t}\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t//中点\n\t\t\t\tdouble mpx = (p[i].first + p[j].first) / 2.0;\n\t\t\t\tdouble mpy = (p[i].second + p[j].second) / 2.0;\n\t\t\t\t//2点間の距離\n\t\t\t\tdouble d1 = Dis(p[i].first, p[i].second, p[j].first, p[j].second);\n\t\t\t\t//p[i]からp[j]へ向かうベクトル\n\t\t\t\tdouble v1x = (p[i].first - p[j].first) / d1;\n\t\t\t\tdouble v1y = (p[i].second - p[j].second) / d1;\n\t\t\t\t//中点から円の中心へ向かう単位ベクトル\n\t\t\t\tdouble v2x = -v1y;\n\t\t\t\tdouble v2y = v1x;\n\t\t\t\t//中心から円の中心へ向かうベクトルの長さ\n\t\t\t\tdouble d2 = sqrt(1.0 - (d1*d1/4.0));\n\n\t\t\t\t//円の中心の座標\n\t\t\t\tdouble cx = mpx + v2x * d2;\n\t\t\t\tdouble cy = mpy + v2y * d2;\n\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(k == i || k == j || Dis(cx, cy, p[k].first, p[k].second) <= 1.0)\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt > ans){\n\t\t\t\t\tans = cnt;\n\t\t\t\t}\n\n\t\t\t\tcx = mpx - v2x * d2;\n\t\t\t\tcy = mpy - v2y * d2;\n\n\t\t\t\tcnt = 0;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(Dis(cx, cy, p[k].first, p[k].second) <= 1.0)\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt > ans){\n\t\t\t\t\tans = cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\n\t}\n\t\n\treturn 0;\n}\n\ndouble Dis(double x1, double y1, double x2, double y2){\n\treturn sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\n#define FOR(i,b,n) for(int i=b;i<n;i++)\n#define RFOR(i,b,n) for(int i=n-1;i>=b;i--)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\n#define NCLR(mat) memset(mat, -1, sizeof(mat))\n\n#define EPS 0.0001\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define PI (acos(-1.0))\n#define POSARG(a) (arg((a)) > 0.0? arg((a)) : 2.0*PI + arg((a)))\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nint n;\n\nint solve(vector<P> vc)\n{\t\n\tint res = 1;\n\t\n\tFOR(j, 0, n)\n\t\tFOR(i, j+1, n)\n\t\t{\n\t\t\tint tmpp = 2;\n\t\t\tint tmpn = 2;\n\t\t\t\n\t\t\tif(abs(vc[j]-vc[i]) > 2.0+EPS)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tdouble cs = abs(vc[j]-vc[i])/2.0, sn = sqrt(1.0-cs*cs);\t\t//線分IJと円の中心の距離\n\t\t\t\n\t\t\tP mid = (vc[j]+vc[i])/2.0;//点IとJの中点\n\t\t\t\n\t\t\tP nml1 = (vc[j]-vc[i])*P(0.0, sn), nml2 = (vc[j]-vc[i])*P(0.0, -sn);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//線分IJの法線ベクトル(長さsn)\n\t\t\t\n\t\t\tP c1 = mid + nml1, c2 = mid + nml2;//円の中心2つ\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\tFOR(k, 0, n)\n\t\t\t{\t\n\t\t\t\tif( k != j && k != i )\n\t\t\t\t{\n\t\t\t\t\tif( abs(vc[k]-c1) < 1.0+EPS)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpp++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif( abs(vc[k]-c2) < 1.0+EPS)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpn++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tres = max(res, max(tmpp, tmpn));\n\t\t}\n\t\t\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tvector<P> vc = vector<P>();\n\t\t\n\t\tFOR(i, 0, n)\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tvc.push_back(P(x,y));\n\t\t}\n\n\t\tcout << solve(vc) << endl;\n\t}\n\t\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\n// 点\nclass Point {\n  public:\n    float x, y;\n    Point(double ix = 0.0, double iy = 0.0) {\n      set(ix, iy);\n    }\n    void set(double ix = 0.0, double iy = 0.0) {\n      x = ix;\n      y = iy;\n    }\n    double length() {\n      return sqrt(x * x + y * y);\n    }\n    double distanceTo(Point p) {\n      double dx = p.x - x, dy = p.y - y;\n      return sqrt(dx * dx + dy * dy);\n    }\n};\n\nint main() {\n  vector<int> results;\n  while (true) {\n    // 入力\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    vector<Point> p(n);\n    for (int i=0; i<n; i++) {\n      double x, y;\n      cin >> x >> y;\n      p[i].set(x, y);\n    }\n    \n    // とりあえず格子状に調べてみる（）\n    const float X = 1000;\n    Point pc;\n    int max = 0;\n    for (int xi=0; xi<=X; xi++) {\n      for (int yi=0; yi<=X; yi++) {\n\tfloat x = xi * 10 / X, y = yi * 10 / X; // 0 ~ 10に補正\n\t// 距離が1以下のものをカウント\n\tpc.set(x, y);\n\tint count = 0;\n\tfor (int i=0; i<n; i++) {\n\t  if (pc.distanceTo(p[i]) <= 1) count++;\n\t}\n\tif (count > max) max = count;\n      }\n    }\n    results.push_back(max);\n  }\n  \n  int size = results.size();\n  for (int i=0; i<size; i++) {\n    cout << results[i] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\npair<double,double> smul(pair<double,double> a,double k){\n  return make_pair(a.first*k,a.second*k);\n}\npair<double,double> sub2(pair<double,double> a,pair<double,double> b){\n  return make_pair(a.first-b.first,a.second-b.second);\n}\npair<double,double> mean2(pair<double,double> a,pair<double,double> b){\n  return make_pair((a.first+b.first)/2,(a.second+b.second)/2);\n}\ndouble dist(pair<double,double> a,pair<double,double> b){\n  return sqrt(pow(a.first-b.first,2)+pow(a.second-b.second,2));\n}\nint main(void)\n{\n  for(;;){\n    int n;\n    cin >> n;\n    if(!n) return 0;\n    vector<pair<double,double> > ps;\n    ps.resize(n);\n    REP(i,n) cin >> ps[i].first >> ps[i].second;\n    vector<pair<double,double> > co;\n    co.clear();\n    REP(j,n) REP(i,j){\n      if(dist(ps[i],ps[j])>2) continue;\n      pair<double,double> m=mean2(ps[i],ps[j]);\n      double k=sqrt(1-pow(dist(ps[i],ps[j])/2.0,2.0));\n      pair<double,double> tmp=sub2(ps[i],ps[j]);\n      tmp=smul(make_pair(tmp.second,-tmp.first),k/dist(ps[i],ps[j]));\n      co.push_back(sub2(m,tmp));\n      tmp=smul(tmp,-1.0);\n      co.push_back(sub2(m,tmp));\n    }\n    int answer=1;\n    for(auto x:co){\n      int tmpans=0;\n      REP(i,n) if(dist(x,ps[i])<1.000001) ++tmpans;\n      answer=max(answer,tmpans);\n    }\n    cout << answer << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\n\nconstexpr long double EPS = 10e-6;\nconstexpr long double radius = 1.0 + EPS;\nconstexpr long double diameter = 2.0 + EPS;\n\nclass Point{\n    public: \n    long double x,y;\n    Point(long double x = 0.0, long double y = 0.0): x(x), y(y) {}\n    Point operator + (Point p) const {\n        return Point(x+p.x, y+p.y);\n    }\n    Point operator - (Point p) const {\n        return Point(x-p.x, y-p.y);\n    }\n    Point operator * (long double a) const {\n        return Point(x*a, y*a);\n    }\n    Point operator / (long double a) const {\n        return Point(x/a, y/a);\n    }\n    long double norm() const {\n        return x*x + y*y;\n    }\n    long double dot(Point p) const {\n        return x*p.x + y*p.y;\n    }\n};\n\nint main() {\n    int n;\n    while(scanf(\"%d\", &n) && n){\n        vector<Point> points(n);\n        rep(n) scanf(\"%Lf %Lf\", &points[i].x, &points[i].y);\n\n        int ans = 1, tmp;\n        Point mid, midv, center;\n        long double c;\n        rep(n){\n            repp(j, n){\n                if(j == i) continue;\n                mid = points[j] - points[i];\n                if(mid.norm() > diameter*diameter) continue;\n                mid = mid * 0.5;\n                midv = Point(mid.y, -mid.x);\n                c = sqrt((1.0 - mid.norm())/midv.norm());\n                center = points[i] + mid + midv * c;\n                tmp = 0;\n                for(Point p: points){\n                    Point v = p-center;\n                    if(v.norm() <= radius) tmp++;\n                }\n                ans = max(tmp, ans);\n            }\n        }\n        printf(\"%d\\n\", ans);\n        debug(ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nstruct Point{\n    double x,y;\n};\n\nvoid func(int N){\n\n    Point point[N];\n    double x_min = 100,y_min = 100,x_max = -1,y_max = -1;\n\n    for(int i = 0; i < N; i++){\n        scanf(\"%lf %lf\",&point[i].x,&point[i].y);\n        x_min = min(point[i].x,x_min);\n        y_min = min(point[i].y,y_min);\n        x_max = max(point[i].x,x_max);\n        y_max = max(point[i].y,y_max);\n    }\n\n    if(x_min > 1)x_min -= 0.05;\n    if(y_min > 1)y_min -= 0.05;\n    if(x_max < 9)x_max += 0.05;\n    if(y_max < 9)y_max += 0.05;\n\n    int count,max_count = 0;\n\n    for(double y = y_min; y <= y_max; y += 0.011){\n        for(double x = x_min; x <= x_max; x += 0.011){\n            count = 0;\n            for(int i = 0; i < N; i++){\n                if(sqrt((x-point[i].x)*(x-point[i].x)+(y-point[i].y)*(y-point[i].y)) <= 1.0)count++;\n            }\n            max_count = max(max_count,count);\n        }\n    }\n\n    printf(\"%d\\n\",max_count);\n}\n\n\nint main(){\n\n    int N;\n\n    while(true){\n        scanf(\"%d\",&N);\n        if(N == 0)break;\n\n        func(N);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//edit\n\n\nnamespace Geometory {\n    const double EPS = 1e-5;\n\n    inline bool equals(double a, double b) {\n        return fabs(a - b) < EPS;\n    }\n\n    struct Point {\n        double x, y;\n\n        Point(double x = 0.0, double y = 0.0) : x(x), y(y) {}\n\n        Point operator+(const Point &p) {\n            return Point(x + p.x, y + p.y);\n        }\n\n        Point operator-(const Point &p) {\n            return Point(x - p.x, y - p.y);\n        }\n\n        Point operator*(const double k) {\n            return Point(x * k, y * k);\n        }\n\n        Point operator/(const double k) {\n            return Point(x / k, y / k);\n        }\n\n        double norm() const {\n            return x * x + y * y;\n        }\n\n        double abs() const {\n            return sqrt(norm());\n        }\n\n        double dot(Point p) {\n            return x * p.x + y * p.y;\n        }\n\n        double cross(Point p) {\n            return x * p.y - y * p.x;\n        }\n\n        bool operator<(const Point &p) const {\n            return x != p.x ? x < p.x : y < p.y;\n        }\n\n        bool operator==(const Point &p) const {\n            return equals(x, p.x) && equals(y, p.y);\n//            return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n        }\n\n\n    };\n\n    using Vector = Point;\n\n    struct Segment {\n        Point p1, p2;\n\n        Segment() {}\n\n        Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n\n        Segment(double x1, double y1, double x2, double y2) : p1(x1, y1), p2(x2, y2) {}\n    };\n\n    using Line = Segment;\n\n\n    double norm(Vector p) {\n        return p.x * p.x + p.y * p.y;\n    }\n\n    double abs(Vector a) {\n        return sqrt(norm(a));\n    }\n\n    double dot(Vector a, Vector b) {\n        return a.dot(b);\n    }\n\n    double cross(Vector a, Vector b) {\n        return a.cross(b);\n    }\n\n    //直行判定\n    bool is_orthogonal(Vector a, Vector b) {\n        return equals(dot(a, b), 0.0);\n    }\n\n    bool is_orthogonal(Point a1, Point a2, Point b1, Point b2) {\n        return is_orthogonal(a1 - a2, b1 - b2);\n    }\n\n    bool is_orthogonal(Segment s1, Segment s2) {\n        return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n    }\n\n    //平行判定\n    bool is_parallel(Vector a, Vector b) {\n        return equals(cross(a, b), 0.0);\n    }\n\n    bool is_parallel(Point a1, Point a2, Point b1, Point b2) {\n        return is_parallel(a1 - a2, b1 - b2);\n    }\n\n    bool is_parallel(Segment s1, Segment s2) {\n        return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n    }\n\n    //反時計回り\n    static const int CCW = 1; // Counter Clockwise\n    static const int CW = -1; // Clockwise\n    static const int OB = 2; // Online Back\n    static const int OF = -2; // Online Front\n    static const int OS = 0; // On Segment\n\n    // p0を中心としたとき、p2は{反時計回り、時計回り、p2->p0->p1で同一直線上、p0->p1->p2で直線上、p2がp0p1線分上} (後ろの3つの説明は雑)\n    int ccw(Point p0, Point p1, Point p2) {\n        Vector a = p1 - p0;\n        Vector b = p2 - p0;\n        if (cross(a, b) > EPS) return CCW;\n        if (cross(a, b) < -EPS) return CW;\n        if (dot(a, b) < -EPS) return OB;\n        if (a.norm() < b.norm()) return OF;\n\n        return OS;\n    }\n\n    //交差判定\n    bool is_intersect(Point p1, Point p2, Point p3, Point p4) {\n        return ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n               ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n    }\n\n    //交差判定\n    bool is_intersect(Segment s1, Segment s2) {\n        return is_intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n    }\n\n    //射影を求める\n    //pからsに垂直に線を引いたときの座標を返す\n    Point project(Segment s, Point p) {\n        Vector base = s.p2 - s.p1;\n        double r = dot(p - s.p1, base) / norm(base);\n        return s.p1 + base * r;\n    }\n\n    // 反射\n    // pを線分sを対称軸として線対称の位置にある点を求める。\n    Point reflect(Segment s, Point p) {\n//        return p + (project(s, p) - p) * 2;\n        return project(s, p) * 2 - p;\n    }\n\n\n    //距離シリーズ\n    //2点間の距離\n    double get_distance(Point a, Point b) {\n        return abs(a - b);\n    }\n\n    // 直線lと点pの距離\n    double get_distanceLP(Line l, Point p) {\n        return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n    }\n\n    // 線分sと点pの距離\n    double get_distanceSP(Segment s, Point p) {\n        if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n        if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n        return get_distanceLP(s, p);\n    }\n\n    //線分と線分の距離\n    double get_distance(Segment s1, Segment s2) {\n        if (is_intersect(s1, s2)) return 0.0;\n        return min({get_distanceSP(s1, s2.p1),\n                    get_distanceSP(s1, s2.p2),\n                    get_distanceSP(s2, s1.p1),\n                    get_distanceSP(s2, s1.p2),\n                   });\n    }\n\n    // 線分と線分の交点\n    Point get_cross_point(Segment s1, Segment s2) {\n//        Vector base = s2.p2 - s2.p1;\n//        double d1 = abs(cross(base, s1.p1 - s2.p1));\n//        double d2 = abs(cross(base, s1.p2 - s2.p1));\n//\n//        double t = d1 / (d1 + d2);\n//        return s1.p1 + (s1.p2 - s1.p1) * t;\n\n        double d1 = cross(s2.p2 - s2.p1, s2.p1 - s1.p1);\n        double d2 = cross(s2.p2 - s2.p1, s1.p2 - s1.p1);\n        if (equals(d1, 0) && equals(d2, 0)) return s1.p1;\n        if (equals(d2, 0)) throw \"no cross point\";\n\n        return s1.p1 + (s1.p2 - s1.p1) * d1 / d2;\n    }\n\n    struct Circle {\n        Point c;\n        double r;\n\n        Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n    };\n\n    //円と線分の交差判定\n    bool is_intersect(Circle c, Line l) {\n        double d = get_distanceLP(l, c.c);\n        return d - c.r < EPS;\n    }\n\n    bool is_intersect(Circle c1, Circle c2) {\n        double d = get_distance(c1.c, c2.c);\n        return d - (c1.r + c2.r) < EPS;\n    }\n\n    //円と線分の交点\n    pair<Point, Point> get_cross_points(Circle c, Line l) {\n//        assert(is_intersect(c, l));\n        if (!is_intersect(c, l)) exit(-1);\n        Vector pr = project(l, c.c);\n        Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n        double base = sqrt(c.r * c.r - norm(pr - c.c));\n        return make_pair(pr + e * base, pr - e * base);\n    }\n\n    double arg(Vector p) {\n        return atan2(p.y, p.x);\n    }\n\n    Vector polar(double a, double r) {\n        return Point(cos(r) * a, sin(r) * a);\n    }\n\n    pair<Point, Point> get_cross_points(Circle c1, Circle c2) {\n        assert(is_intersect(c1, c2));\n        double d = abs(c1.c - c2.c);\n        double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n        double t = arg(c2.c - c1.c);\n        return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n    }\n\n    using Polygon = vector<Point>;\n\n    static const int OUT = 0;\n    static const int ON = 1;\n    static const int IN = 2;\n\n    // 点pが多角形gにあるかを判定\n    // 計算量はO(|g|)\n    int contains(Polygon g, Point p) {\n        int n = g.size();\n        bool x = false;\n        for (int i = 0; i < n; ++i) {\n            Point a = g[i] - p, b = g[(i + 1) % n] - p;\n            if (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n            if (a.y > b.y) swap(a, b);\n            if (a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n        }\n        return x ? IN : OUT;\n    }\n\n    // 点集合sの凸集合を求める。\n    // Andrew's Algorithmを使用\n    // 計算量はO(|s|log(|s|))\n    Polygon get_convex_hull(Polygon s) {\n        if (s.size() < 3) return s;\n        Polygon u, l;\n        sort(s.begin(), s.end());\n\n        u.push_back(s[0]);\n        u.push_back(s[1]);\n        l.push_back(s[s.size() - 1]);\n        l.push_back(s[s.size() - 2]);\n\n        //凸包の上部\n        for (int i = 2; i < s.size(); ++i) {\n            for (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) == CCW; --n) {\n                u.pop_back();\n            }\n            u.push_back(s[i]);\n        }\n\n        //凸包の下部\n        for (int i = s.size() - 3; i >= 0; --i) {\n            for (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) == CCW; --n) {\n                l.pop_back();\n            }\n            l.push_back(s[i]);\n        }\n        reverse(l.begin(), l.end());\n        for (int i = u.size() - 2; i >= 1; --i) l.push_back(u[i]);\n\n        return l;\n    }\n\n    //多角形gの面積を求める\n    double get_area(Polygon g) {\n        int n = g.size();\n        double ret = 0.0;\n        for (int i = 0; i < n; ++i) {\n            Point a = g[i], b = g[(i + 1) % n];\n            double add = (b.y - a.y) * (a.x + b.x) / 2;\n            ret += add;\n        }\n\n        return fabs(ret);\n    }\n\n    std::ostream &operator<<(std::ostream &os, const Point &p) {\n//        os << \"(\" << p.x << \", \" << p.y << \")\";\n        os << \"\" << p.x << \" \" << p.y << \"\";\n        return os;\n    }\n\n};\n\nusing namespace Geometory;\n\n\nclass Solve {\npublic:\n    vector<Point> ps;\n\n    // 点i, jを通る円が何個の点を囲む？\n    Int cnt(Int i, Int j) {\n        double ab = abs(ps[j] - ps[i]) / 2;\n        if (ab > 1 + EPS) return 0;\n\n        double k = sqrt(1 - ab * ab);\n        Point m = (ps[i] + ps[j]) / 2;\n        Point ec = (ps[j] - ps[i]);\n        Point ee = Point(-ec.y, ec.x);\n        Point e = ee / abs(ee);\n\n        Circle c(m + e * k, 1);\n        Int ret1 = 0, ret2 = 0;\n\n        for (int idx = 0; idx < ps.size(); ++idx) {\n//            cerr << get_distance(ps[idx], c.c) << endl;\n            if (get_distance(ps[idx], c.c) <= 1. + EPS) {\n                ret1++;\n            }\n        }\n        c.c = m - e * k;\n\n        for (int idx = 0; idx < ps.size(); ++idx) {\n//            cerr << get_distance(ps[idx], c.c) << endl;\n            if (get_distance(ps[idx], c.c) <= 1. + EPS) {\n                ret2++;\n            }\n        }\n\n        return max(ret1, ret2);\n    }\n\n    bool solve() {\n        Int n;\n        cin >> n;\n        if (n == 0) return false;\n        ps.resize(n);\n\n        for (int i = 0; i < n; ++i) {\n            cin >> ps[i].x >> ps[i].y;\n        }\n\n        Int ans = 1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                Int tmp = cnt(i, j);\n                chmax(ans, tmp);\n            }\n        }\n        cout << ans << endl;\n\n\n        return true;\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    while (Solve().solve());\n//    Solve().solve();\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <set>\n\nusing namespace std;\n\n\nint main(){\n\tint n;\n\tdouble x1,y1,xc,yc,dis,vx,vy,ex,ey;\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\tvector<double> x(n);\n\t\tvector<double> y(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tint ans =0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(i==j)break;\n\t\t\t\txc = (x[i]+x[j])/2;\n\t\t\t\tyc = (y[i]+y[j])/2;\n\t\t\t\tdis = sqrt(1.0-(xc-x[i])*(xc-x[i])-(yc-y[i])*(yc-y[i]));\n\t\t\t\tvx = x[i]-x[j];\n\t\t\t\tvy = y[i]-y[j];\n\t\t\t\tex = dis * vy * sqrt(vx*vx+vy*vy);\n\t\t\t\tey = -dis* vx * sqrt(vx*vx+vy*vy);\n\t\t\t\tx1 = xc + ex;\n\t\t\t\ty1 = yc + ey;\n\t\t\t\tint count=0;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i||k==j)count +=1;\n\t\t\t\t\telse{\n\t\t\t\t\t\tif((x1-x[k])*(x1-x[k])+(y1-y[k])*(y1-y[k])<=1){\n\t\t\t\t\t\t\tcount +=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = max(ans,count);\n\t\t\t\tx1 = xc - ex;\n\t\t\t\ty1 = yc - ey;\n\t\t\t\tcount = 0;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i||k==j)count +=1;\n\t\t\t\t\telse{\n\t\t\t\t\t\tif((x1-x[k])*(x1-x[k])+(y1-y[k])*(y1-y[k])<=1){\n\t\t\t\t\t\t\tcount +=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = max(ans,count);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\nconst double PI=3.141592653589793238462643383279;\n\nbool inC(P p, P c, double r){return abs(p-c)<r+1e-9;}\n\nP getE(P p){return p/abs(p);}\n\ndouble sq(double x){ return  x*x;}\n\nint main(){\n    int n,i,j,k,ans,cnt;\n    double x, y;\n    while(scanf(\"%d\",&n)){\n        if(n==0) break;\n        ans=0;\n        vector<P> ps(n);\n        for(i=0; i<n; i++){\n            scanf(\"%lf%lf\",&x,&y);\n            ps[i] = P(x,y);\n        }\n        for(i=0;i<n;i++)\n            for(j=i+1;j<n;j++)if(abs(ps[i]-ps[j])<2){\n                    double d=sqrt(1-sq(abs(ps[j]-ps[i])*0.5));\n                    P c1=0.5*(ps[i]+ps[j])+getE(ps[j]-ps[i])*polar(d,PI/2);\n                    P c2=0.5*(ps[i]+ps[j])+getE(ps[j]-ps[i])*polar(d,-PI/2);\n                    cnt=0;\n                    for(k=0;k<n;k++)if(inC(ps[k],c1,1.0))cnt++;\n                    if(cnt>ans)ans=cnt;\n                    cnt=0;\n                    for(k=0;k<n;k++)if(inC(ps[k],c2,1.0))cnt++;\n                    if(cnt>ans)ans=cnt;\n                }\n        if(ans==0) ans++;\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n#include <complex>\nusing namespace std;\nusing ll = long long;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ninline bool equals(double a, double b) { return abs(b - a) < EPS; }\nusing Point = complex<double>;\n\ninline Point rotate(double theta, const Point &p) { return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag()); }\ninline double to_degree(double rad) { return (rad * 180.0 / PI); }\ninline double to_radian(double deg) { return (deg * PI / 180.0); }\nostream &operator<<(ostream &os, Point &p) { os << p.real() << \" \" << p.imag(); }\nnamespace std { bool operator < (const Point &a, const Point &b) { return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b); } }\ninline double dot(const Point &a, const Point &b) { return real(a) * real(b) + imag(a) * imag(b); }\ninline double cross(const Point &a, const Point &b) { return real(a) * imag(b) - imag(a) * real(b); }\n\nstruct Line\n{\n    Point a, b;\n    Line(Point a, Point b) : a(a), b(b) {}\n};\nstruct Segment : Line { Segment(Point a, Point b) : Line(a, b) {} };\nstruct Circle\n{\n    Point p; double r;\n    Circle(Point p, double r) : p(p), r(r) {}\n};\n\ninline bool isParallel(const Line &a, const Line &b) { return equals(cross(a.b - a.a, b.b - b.a), 0.0); }\ninline bool isOrthogonal(const Line &a, const Line &b) { return equals(dot(a.a - a.b, b.a - b.b), 0.0); }\ntemplate<typename T = Line>\ninline Point getProjection(const T &l, const Point &p)\n{\n    double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + (l.a - l.b) * t;\n}\ninline Point getReflection(const Line &l, const Point &p) { return p + (getProjection(l, p) - p) * 2.0; }\n//位置関係\ninline int ccw(const Point &a, Point b, Point c)\n{\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return 1;\n    if(cross(b, c) < -EPS) return -1;\n    if(dot(b, c) < 0) return 2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\n//点、直線、線分の交差\ninline bool isIntersect(const Line &l, const Point &p) { return abs(ccw(l.a, l.b, p)) != 1; }\ninline bool isIntersect(const Line &l, const Line &m) { return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS; }\ninline bool isIntersect(const Segment &s, const Point &p) { return ccw(s.a, s.b, p) == 0; }\ninline bool isIntersect(const Line &l, const Segment &s) { return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS; }\ninline bool isIntersect(const Segment &s, const Segment &t) { return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0; }\n//距離\ninline double getDistance(const Point &a, const Point &b) { return abs(a - b); }\ninline double getDistance(const Line &l, const Point &p) { return abs(p - getProjection(l, p)); }\ninline double getDistance(const Segment &s, const Point &p)\n{\n    Point r = getProjection(s, p);\n    if(isIntersect(s, r)) return abs(r - p);\n    return min(abs(s.a - p), abs(s.b - p));\n}\ninline double getDistance(const Line &l, const Line &m) { return isIntersect(l, m) ? 0 : getDistance(l, m.a); }\ninline double getDistance(const Segment &s1, const Segment &s2)\n{\n    if(isIntersect(s1, s2)) return 0;\n    return min({getDistance(s1, s2.a), getDistance(s1, s2.b), getDistance(s2, s1.a), getDistance(s2, s1.b)});\n}\ninline double getDistance(const Line &l, const Segment &s)\n{\n    if(isIntersect(l, s)) return 0;\n    return min(getDistance(l, s.a), getDistance(l, s.b));\n}\ninline bool isIntersect(const Circle &c, const Point &p) { return abs(abs(p - c.p) - c.r) < EPS; }\ninline bool isIntersect(const Circle &c, const Line &l) { return getDistance(l, c.p) <= c.r + EPS; }\ninline int isIntersect(const Circle &c, const Segment &l)\n{\n    if(norm(getProjection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n    auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n    if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n    const Point h = getProjection(l, c.p);\n    if(dot(l.a - h, l.b - h) < 0) return 2;\n    return 0;\n}\n//２つの円の共通接線の数\ninline int isIntersect(Circle c1, Circle c2)\n{\n    if(c1.r < c2.r) swap(c1, c2);\n    double d = abs(c1.p - c2.p);\n    if(c1.r + c2.r < d) return 4; //離れている\n    if(equals(c1.r + c2.r, d)) return 3; //外接する\n    if(c1.r - c2.r < d) return 2;//交わる\n    if(equals(c1.r - c2.r, d)) return 1;//内接する\n    return 0;//どちらかが内包する\n}\n//交差する点\ninline Point getCrossPoint(const Line &l, const Line &m)\n{\n    double a = cross(l.b - l.a, m.b - m.a), b = cross(l.b - l.a, l.b - m.a);\n    if(equals(abs(a), 0.0) and equals(abs(b), 0.0)) return m.a;\n    return m.a + (m.b - m.a) * b / a;\n}\ninline Point getCrossPoint(const Segment &l, const Segment &m) { return getCrossPoint(Line(l), Line(m)); }\n// 円と直線の交点\ninline pair<Point, Point> getCrossPoint(const Circle &c, const Line l)\n{\n    assert(isIntersect(c, l));\n    Point pr = getProjection(l, c.p);\n    Point e = (l.b - l.a) / abs(l.b - l.a);\n    if(equals(getDistance(l, c.p), c.r)) return make_pair(pr, pr);\n    double base = sqrt(c.r * c.r - norm(pr - c.p));\n    return make_pair(pr - e * base, pr + e * base);\n}\n//円と線分の交点\ninline pair<Point, Point> getCrossPoint(const Circle &c, const Segment &l)\n{\n    Line aa = Line(l.a, l.b);\n    if(isIntersect(c, l) == 2) return getCrossPoint(c, aa);\n    auto res = getCrossPoint(c, aa);\n    if(dot(l.a - res.first, l.b - res.first) < 0) res.second = res.first;\n    else res.first = res.second;\n    return res;\n}\ninline pair<Point, Point> getCrossPoint(const Circle &c1, const Circle &c2)\n{\n    double d = abs(c1.p - c2.p);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n    Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n    Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n    return make_pair(p1, p2); //isnan()\n}\nbool isContain(const Circle &c, const Point &p)\n{\n    return (p.real() - c.p.real()) * (p.real() - c.p.real()) + (p.imag() - c.p.imag()) * (p.imag() - c.p.imag()) < c.r + EPS ? true : false;\n}\nint N;\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> N, N)\n    {\n        vector<Point> p(N);\n        for(int i = 0; i < N; i++)\n        {\n            double x, y; cin >> x >> y;\n            p[i] = Point(x, y);\n        }\n        int ans = 1;\n        for(int i = 0; i < N; i++)\n        {\n            for(int j = i + 1; j < N; j++)\n            {\n                pair<Point, Point> cp = getCrossPoint(Circle(p[i], 1.0), Circle(p[j], 1.0));\n                //if(isnan(cp.first.real())) continue;\n                int a = 0, b = 0;\n                for(int k = 0; k < N; k++)\n                {\n                    if(isContain(Circle(cp.first, 1.0), p[k])) a++;\n                    if(isContain(Circle(cp.second, 1.0), p[k])) b++;\n                }\n                ans = max({ans, a, b});\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n//#define double long double\ntypedef complex<double> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\nconst int R = 100000;\n\nint N;\nP X[300];\n\nint f(P x, int a, int b) {\n  int ctr = 2;\n  rep(i, N) {\n    if (i == a || i == b) continue;\n    P p = X[i];\n    if (abs(x-p) <= 1.0) ctr++;\n  }\n  return ctr;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  while (cin >> N && N != 0) {\n    rep(i, N) {\n      double x, y;\n      cin >> x >> y;\n      X[i] = P(x, y);\n    }\n    int ans = 1;\n    rep(i, N) {\n      rep(j, i) {\n        P a = X[i], b = X[j];\n        P base = (a+b)/(double)2.0;\n        P v = b-a;\n        double d = abs(v) / 2.0;\n        if (d > 1) continue;\n        P h1 = ((v*P(0, +1)) / abs(v)) * sqrt(1.0-d*d);\n        P h2 = ((v*P(0, -1)) / abs(v)) * sqrt(1.0-d*d);\n        ans = max(ans, f(base+h1, i, j));\n        ans = max(ans, f(base+h2, i, j));\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\n\n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(Point a, Point b, double r) {\n  VP cs;\n  Point abH = (b-a)*0.5;\n  double d = abs(abH);\n  if (d == 0 || d > r) return cs;\n  double dN = sqrt(r*r - d*d);\n  Point n = abH * Point(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n\nint main(void){\n    int N;\n    while(cin>>N,N){\n        VP p(N);\n        int res=1;\n        rep(i,N){\n            double x,y;\n            cin>>x>>y;\n            p[i] = {x,y};\n        }\n        rep(i,N)rep(j,i){\n            VP cs = circlesPointsRadius(p[i],p[j],1.0);\n            for(Point c:cs){\n                int cnt=0;\n                rep(k,N) if(abs(c-p[k]) <= 1.0001)cnt++;\n                res=max(res,cnt);\n            }\n        }\n        cout<<res<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define cd complex<double>\n\ncomplex<double> ci = complex<double>(0.0,1.0);\ncomplex<double> mci = complex<double>(0.0,-1.0);\n\nint main(){\n\n  while(1){\n    int n;\n    cin >> n;\n    if (n==0)break;\n    vector<complex<double> > p(n);\n    rep(i,n){\n      double real,imag;\n      cin >> real >> imag;\n      p[i] = complex<double>(real,imag);\n    }\n    int summax = 0;\n    rep(i,n){\n      rep(j,n){\n        if (i==j)continue;\n        if (abs(p[i]-p[j])>2)continue;\n        complex<double> mid = (p[i]+p[j])/2.0;\n        double l = abs(p[i]-mid);\n        double h = sqrt(1-l*l);\n        complex<double> c1 = mid + (mid-p[i])*ci*h/l;\n        complex<double> c2 = mid + (mid-p[i])*mci*h/l;\n\n        int sum1 = 2,sum2 = 2;\n        rep(k,n){\n          if(k==i||k==j)continue;\n          if(abs(p[k]-c1)<1.0)sum1++;\n          if(abs(p[k]-c2)<1.0)sum2++;\n        }\n        if (max(sum1,sum2)>summax)summax=max(sum1,sum2);\n      }\n    }\n    cout << summax << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<double> x(n), y(n);\n\t\tint ans = -1;\n\t\tREP(i, n)cin >> x[i] >> y[i];\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tdouble ax = x[j] - x[i], ay = y[j] - y[i];\n\t\t\t\tif (ax*ax + ay*ay > 4)continue;\n\t\t\t\tdouble px = x[i] + ax / 2 + sqrt((4 - (ax*ax + ay*ay)) / (4 * (ax*ax + ay*ay)))*ay,\n\t\t\t\tpy = y[i] + ay / 2 - sqrt((4 - (ax*ax + ay*ay)) / (4 * (ax*ax + ay*ay)))*ax;\n\t\t\t\tint cnt = 0;\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tif ((x[k] - px)*(x[k] - px) + (y[k] - py)*(y[k] - py) < 1+EPS)cnt++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, cnt);\n\t\t\t}\n\t\t}\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tdouble ax = x[j] - x[i], ay = y[j] - y[i];\n\t\t\t\tif (ax*ax + ay*ay > 4)continue;\n\t\t\t\tdouble px = x[i] + ax / 2 - sqrt((4 - (ax*ax + ay*ay)) / (4 * (ax*ax + ay*ay)))*ay,\n\t\t\t\t\tpy = y[i] + ay / 2 + sqrt((4 - (ax*ax + ay*ay)) / (4 * (ax*ax + ay*ay)))*ax;\n\t\t\t\tint cnt = 0;\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tif ((x[k] - px)*(x[k] - px) + (y[k] - py)*(y[k] - py) < 1+EPS)cnt++;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tans = max(ans, cnt);\n\t\t\t}\n\t\t}\n\t\tcout <<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<pdd> p(n);\n\t\trep(i, n)cin >> p[i].first >> p[i].second;\n\t\tint m = 1;\n\t\trep(i, n)rep(j, i) {\n\t\t\tif (hypot(p[i].first - p[j].first, p[i].second - p[j].second) > 2.00005)continue;\n\t\t\tP s = { (p[i].first + p[j].first) / 2,(p[i].second + p[j].second) / 2 };\n\t\t\tP t = { (p[j].second - p[i].second) / 2,(p[i].first - p[j].first) / 2 };\n\t\t\tt = t / abs(t)*sqrt(1 - abs(t)*abs(t));\n\t\t\tP c = s + t;\n\t\t\tint cnt = 0;\n\t\t\trep(i, n)if (abs(P{ p[i].first,p[i].second }-c) < 1.00005)cnt++;\n\t\t\tcmax(m, cnt);\n\t\t\tc = s - t;\n\t\t\tcnt = 0;\n\t\t\trep(i, n)if (abs(P{ p[i].first,p[i].second }-c) < 1.00005)cnt++;\n\t\t\tcmax(m, cnt);\n\t\t}\n\t\tcout << m << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 301\nusing namespace std;\ntypedef complex <double> P;\nconst double EPS = 1e-8;\nP p[N];\nint n;\n\nint cnt(P c){\n  int res=0;\n  for(int i=0;i<n;i++)if(abs(c-p[i])<1+EPS) res++;\n  return res;\n}\n\nP get_C(P a,P b){\n  double x=abs(b-a);\n  if(x>2||a==b) return a;\n  return P(x/2,sqrt(1-x*x/4))*(b-a)/abs(b-a)+a;  \n}\n\n\nint main(){\n  while(1){\n  cin>>n;\n  if(!n)break;\n  double a,b;\n  for(int i=0;i<n;i++)cin>>a>>b,p[i]=P(a,b);\n  \n  int ans=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      ans=max(ans,cnt(get_C(p[i],p[j])));\n  cout <<ans<<endl;  \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint main(void) {\n  for(int N; cin >> N, N > 0;) {\n    double x[300], y[300];\n    REP(i, 0, N) cin >> x[i] >> y[i];\n\n    int answer = 1;\n    REP(i, 0, N) {\n      REP(j, i + 1, N) {\n        double d = sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]));\n        if(d > 2.) continue;\n        double vx = (x[i] - x[j]) / d;\n        double vy = (y[i] - y[j]) / d;\n        double l = sqrt(1. - d * d / 4.);\n        double sx = (x[i] + x[j]) / 2.;\n        double sy = (y[i] + y[j]) / 2.;\n\n        double cx1 = sx - vy * l;\n        double cy1 = sy + vx * l;\n        int cnt1 = 0;\n        REP(k, 0, N) if(k == i || k == j || (x[k] - cx1) * (x[k] - cx1) + (y[k] - cy1) * (y[k] - cy1) <= 1.0) cnt1++;\n        answer = max(answer, cnt1);\n\n        double cx2 = sx + vy * l;\n        double cy2 = sy - vx * l;\n        int cnt2 = 0;\n        REP(k, 0, N) if(k == i || k == j || (x[k] - cx2) * (x[k] - cx2) + (y[k] - cy2) * (y[k] - cy2) <= 1.0) cnt2++;\n        answer = max(answer, cnt2);\n      }\n    }\n\n    cout << answer << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>  \n#include <algorithm>\n#include <iostream>\n#include <utility>\n\nusing namespace std;\n\nconst double eps=1e-8; \nstruct point{\n\tdouble x,y;\t\n}P[310];\nint x,y,N;\nint ans=1;\n\ndouble cal_distance(point a, point b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\npoint cal_center(point a, point b){\n\tpoint mid,center;\n\tmid.x = (a.x+b.x)/2.0;\n\tmid.y = (a.y+b.y)/2.0;\n\tdouble angle = atan2(a.x-b.x,b.y-a.y);\n\tdouble line = sqrt(1-(cal_distance(a,mid)*cal_distance(a,mid)));\n\tcenter.x = mid.x+line*cos(angle);\n\tcenter.y = mid.y+line*sin(angle);\n\treturn center;\n}\n\nint main(){\n\twhile(cin >> N && N>0){\n\t\tans = 1;\n\t\tfor (int i=0; i<N; i++){\n\t\t\t\tcin >> P[i].x >> P[i].y;\n\t\t\t}\n\t\t\tfor (int i=0; i<N; i++){\n\t\t\t\tfor (int j=i+1; j<N; j++){\n\t\t\t\t\tif (cal_distance(P[i],P[j]) > 2.0) continue;\n\t\t\t\t\tpoint center = cal_center(P[i], P[j]);\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tfor (int k=0; k<N;k++){\n\t\t\t\t\t\tif (cal_distance(P[k],center) < (1.0+eps)) count++;\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans,count);\n\t\t\t\t}\n\t\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define dis(p,q) ((p)*(p)+(q)*(q))\nint main(){\n  int i,j,k;\n  int n;\n  while(cin>>n,n){\n    double x[300],y[300];\n    for(i=0;i<n;++i)\n      cin>>x[i]>>y[i];    \n    int mx=1;\n    for(i=0;i<n-1;++i){\n      for(j=i+1;j<n;++j){\n\tdouble d=dis(x[i]-x[j],y[i]-y[j]);\n\tif(d<=4){\n\t  double cx,cy,a=atan2(y[i]-y[j],x[i]-x[j]);\n\t  int sm;\n\t  cx=(x[i]+x[j])/2+cos(a+M_PI/2)*sqrt(1-d/4);\n\t  cy=(y[i]+y[j])/2+sin(a+M_PI/2)*sqrt(1-d/4);\n\t  sm=2;\n\t  for(k=0;k<n;++k){\n\t    if(k!=i&&k!=j&&dis(x[k]-cx,y[k]-cy)<=1)\n\t      ++sm;\n\t  }\n\t  mx=max(mx,sm);\n\t  cx=(x[i]+x[j])/2+cos(a-M_PI/2)*sqrt(1-d/4);\n\t  cy=(y[i]+y[j])/2+sin(a-M_PI/2)*sqrt(1-d/4);\n\t  sm=2;\n\t  for(k=0;k<n;++k){\n\t    if(k!=i&&k!=j&&dis(x[k]-cx,y[k]-cy)<=1)\n\t      ++sm;\n\t  }\n\t  mx=max(mx,sm);\n\t}\n      }\n    }\n    cout<<mx<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define MKP make_pair\n#define fi first\n#define se second\ntypedef pair<int, int> pii;\n\nconstexpr int MOD = 1e9 + 7;\nconstexpr int MAX_N = 205;\nconstexpr int MAX_W = 10005;\nconstexpr int INF = 1LL << 60;\n\n/* 基本要素 */\n\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n\n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n\nint n;\nvector<P> v;\n\nbool solve() {\n    v.clear();\n    cin >> n;\n    if (!n) return false;\n\n    for (int i = 0; i < n; ++i) {\n        double x, y;\n        cin >> x >> y;\n        v.emplace_back(P(x, y));\n    }\n\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            auto crs = crosspointCC(v[i], 1.0, v[j], 1.0);\n            for (int k = 0; k < crs.size(); ++k) {\n                int cnt = 0;\n                for (int l = 0; l < n; ++l) {\n                    double dist = abs(crs[k] - v[l]);\n                    if (dist <= 1.0 + EPS) cnt++;\n                }\n\n                res = max(res, cnt);\n            }\n        }\n    }\n\n    cout << res << endl;\n\n    return true;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 300\n\ntypedef double P_type;\ntypedef complex<P_type> P;\nconst P_type P_eps = 1e-8; //整数の時はゼロ\n\nnamespace std{\n  template<class T> bool operator<(const complex<T> &a, const complex<T> &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n  }\n};\n\n/* 円の点包含判定 */\ndouble isContainedCP(P c, double r, P p){\n  //return abs(c-p) < r - P_eps; //円周上を含まない\n  return abs(c-p) < r + P_eps; //円周上を含む\n}\n\nint solve(){\n  int n;\n  double x[SIZE], y[SIZE];\n\n  scanf(\"%d\", &n);\n  if(n == 0) return false;\n\n  if(n == 1){\n    puts(\"1\");\n    return true;\n  }\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%lf%lf\", x+i, y+i);\n  }\n\n  int ans = 0;\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i == j) continue;\n      P vec = P(x[i]-x[j], y[i]-y[j]);\n\n      if(abs(vec) > 2.0 + P_eps) continue;\n      \n      P p = P(-vec.imag(), vec.real());\n      p = p / abs(p) * sqrt(1 - norm(vec) / 4);\n      //debug(p);\n\n      p += vec / 2.0 + P(x[j], y[j]); \n\n      int counter = 0;\n      // debug(abs(p - P(x[i], y[i])));\n      \n      for(int k=0;k<n;k++){\n        counter += isContainedCP(p, 1, P(x[k], y[k]));\n      }\n\n      ans = max(ans, counter);\n    }\n  }\n\n  printf(\"%d\\n\", ans);\n  return true;\n}\n\n\nint main(){\n  while(solve());\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nstruct Point{\n    double x,y;\n};\n\nvoid func(int N){\n\n    Point point[N];\n    int x_table[1001],y_table[1001],x_start,x_end,y_start,y_end;\n\n    for(int i = 0; i <= 1000; i++){\n    \tx_table[i] = y_table[i] = 0;\n    }\n\n    for(int i = 0; i < N; i++){\n        scanf(\"%lf %lf\",&point[i].x,&point[i].y);\n        x_start = point[i].x*100-50;\n        x_start = max(49,x_start);\n        x_end = point[i].x*100+50;\n        x_end = min(x_end,901);\n        y_start = point[i].y*100-50;\n        y_start = max(49,y_start);\n        y_end = point[i].y*100+50;\n        y_end = min(y_end,901);\n\n        for(int k = x_start; k <= x_end; k++){\n        \tx_table[k]++;\n        }\n\n        for(int k = y_start; k <= y_end;k++){\n        \ty_table[k]++;\n        }\n    }\n\n\n    int count,max_count = 0;\n    double calc_x,calc_y;\n\n    for(int x = 49; x <= 951; x++){\n    \tfor(int y = 49; y <= 951; y++){\n    \t\tif(x_table[x] > 0 && y_table[y] > 0){\n    \t\t\tcalc_x = x,calc_y = y;\n    \t\t\tcalc_x /= 100,calc_y/=100;\n    \t\t\tcount = 0;\n    \t\t\tfor(int i = 0; i < N; i++){\n    \t\t\t\tif(sqrt((calc_x-point[i].x)*(calc_x-point[i].x)+(calc_y-point[i].y)*(calc_y-point[i].y)) <= 1){\n    \t\t\t\t\tcount++;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tmax_count = max(max_count,count);\n    \t\t}\n    \t}\n    }\n    printf(\"%d\\n\",max_count);\n}\n\n\nint main(){\n\n    int N;\n\n    while(true){\n        scanf(\"%d\",&N);\n        if(N == 0)break;\n\n        func(N);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst double EPS = 1e-6;\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tdouble x[n], y[n];\n\t\trep(i,n) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tint maxi = 0;\n\t\trep(i, n) {\n\t\t\tfor(int j=i+1; j<n; j++) {\n\t\t\t\tif( ((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])) > 4.0 ) continue;\n\t\t\t\tdouble mx = (x[i]+x[j]) / 2.0;\n\t\t\t\tdouble my = (y[i]+y[j]) / 2.0;\n\t\t\t\tdouble px0, py0, px1, py1;\n\t\t\t\tif( fabs(y[i]-y[j]) < EPS ) {\n\t\t\t\t\tpx0 = px1 = mx;\n\t\t\t\t\tpy0 = my + sqrt(1.0 - (x[i]-mx)*(x[i]-mx));\n\t\t\t\t\tpy1 = my - sqrt(1.0 - (x[i]-mx)*(x[i]-mx));\n\t\t\t\t} else if( fabs(x[i]-x[j]) < EPS ) {\n\t\t\t\t\tpy0 = py1 = my;\n\t\t\t\t\tpx0 = mx + sqrt(1.0 - (y[i]-my)*(y[i]-my));\n\t\t\t\t\tpx1 = mx - sqrt(1.0 - (y[i]-my)*(y[i]-my));\n\t\t\t\t} else {\n\t\t\t\t\tdouble m = - (x[i]-x[j]) / (y[i]-y[j]);\n\t\t\t\t\tdouble l = sqrt(1.0 - ((x[i]-mx)*(x[i]-mx)+(y[i]-my)*(y[i]-my)));\n\t\t\t\t\tpx0 = mx + sqrt(l*l/(1.0+m*m));\n\t\t\t\t\tpx1 = mx - sqrt(l*l/(1.0+m*m));\n\t\t\t\t\tpy0 = my + m * (px0-mx);\n\t\t\t\t\tpy1 = my + m * (px1-mx);\n\t\t\t\t}\n\t\t\t\tint cnt0 = 0, cnt1 = 0;\n\t\t\t\trep(k, n) {\n\t\t\t\t\tdouble d0 = (px0-x[k])*(px0-x[k]) + (py0-y[k])*(py0-y[k]);\n\t\t\t\t\tif( d0 <= 1.0+EPS ) {\n\t\t\t\t\t\tcnt0++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(k, n) {\n\t\t\t\t\tdouble d1 = (px1-x[k])*(px1-x[k]) + (py1-y[k])*(py1-y[k]);\n\t\t\t\t\tif( d1 <= 1.0+EPS ) {\n\t\t\t\t\t\tcnt1++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxi = max(maxi, cnt0);\n\t\t\t\tmaxi = max(maxi, cnt1);\n\t\t\t}\n\t\t}\n\t\tcout << maxi << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nconst double EPS = 1e-8;\n\nint n;\nPoint data[300];\n\nint calc(Point a, Point b){\n  int res = 0;\n  double d = abs(b - a) / 2.0;\n  Point ab = (b - a) / (2.0 * d);\n  if(d < 1){\n    Point o = ab * d;\n    d = sqrt(1.0 - d * d);\n    o += Point(d * ab.imag() + a.real(), -d * ab.real() + a.imag());\n    for(int i=0;i<n;i++) if(abs(o - data[i]) < 1.0 + EPS) res++;\n  }\n  return res;\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++) cin >> data[i].imag() >> data[i].real();\n    int ans = 1;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n        ans = max(ans, calc(data[i], data[j]));\n        ans = max(ans, calc(data[j], data[i]));\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <utility>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nbool eqv(double a, double b) {\n    return abs(a-b) < 1e-10;\n}\n\nbool inCircle(const Point &p, const Point &center, double radius) {\n    double dist2 = norm(p-center);\n    double rad2 = radius*radius;\n    return dist2 < radius*radius || eqv(dist2, rad2);\n}\n\nint check(const Point &center, const vector<Point> &points) {\n    const int N = points.size();\n    int cnt = 0;\n    for(int i = 0; i < N; ++i) {\n        if(inCircle(points[i], center, 1)) ++cnt;\n    }\n    return cnt;\n}\n\nint test(int a, int b, const vector<Point> &points) {\n    const Point v(points[a]-points[b]);\n    const double hlen = abs(v)/2;\n\n    if(hlen >= 1) return 0;\n    const Point unit = v / abs(v);\n    const double angle = acos(hlen);\n    return max(check(points[b] + unit*polar(1.0, angle), points), check(points[b] + unit*polar(1.0, -angle), points));\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        vector<Point> points(N);\n        for(int i = 0; i < N; ++i) {\n            cin >> points[i].real() >> points[i].imag();\n        }\n        int ans = 0;\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < i; ++j) {\n                ans = max(ans, test(i, j, points));\n            }\n        }\n        if(N == 1) ans = 1;\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint n;\ndouble arr[300][2];\n\nint main() {\n\twhile(true) {\n\t\tscanf(\"%d\",&n);\n\t\tif(n<=0) break;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscanf(\"%lf%lf\",&arr[i][0],&arr[i][1]);\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tdouble x1 = arr[i][0];\n\t\t\tdouble y1 = arr[i][1];\n\t\t\tfor(int j = i+1; j < n; j++) {\n\t\t\t\tdouble x2 = arr[j][0];\n\t\t\t\tdouble y2 = arr[j][1];\n\t\t\t\tdouble dx = x2-x1;\n\t\t\t\tdouble dy = y2-y1;\n\t\t\t\tdouble dlen = dx*dx+dy*dy;\n\t\t\t\tif(dlen>=4.0) continue;\n\t\t\t\tdouble len = sqrt(1-dlen/4.0);\n\t\t\t\tdouble cx1 = (x1+x2)/2.0+dy/sqrt(dlen)*len;\n\t\t\t\tdouble cy1 = (y1+y2)/2.0-dx/sqrt(dlen)*len;\n\t\t\t\tdouble cx2 = (x1+x2)/2.0-dy/sqrt(dlen)*len;\n\t\t\t\tdouble cy2 = (y1+y2)/2.0+dx/sqrt(dlen)*len;\n\t\t\t\tint _ans1 = 0;\n\t\t\t\tint _ans2 = 0;\n\t\t\t\tfor(int k = 0; k < n; k++) {\n\t\t\t\t\tdouble x3 = arr[k][0];\n\t\t\t\t\tdouble y3 = arr[k][1];\n\t\t\t\t\tif((cx1-x3)*(cx1-x3)+(cy1-y3)*(cy1-y3)<=1.0000001) _ans1++;\n\t\t\t\t\tif((cx2-x3)*(cx2-x3)+(cy2-y3)*(cy2-y3)<=1.0000001) _ans2++;\n\t\t\t\t}\n\t\t\t\tans = fmax(ans,_ans1);\n\t\t\t\tans = fmax(ans,_ans2);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",(ans==0)?1:ans);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\nusing namespace std;\ntypedef complex<double> P;\nint n;\nvector<P> p;\nint ret(){\n\tint cnt=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(abs(p[i]-p[j])>2.0)\n\t\t\t\tcontinue;\n\t\t\tP c=(p[i]+p[j])*0.5;\n\t\t\tdouble d=sqrt(1.0-abs(p[i]-c)*abs(p[i]-c));\n\t\t\tP l1=(p[i]-p[j])*P(0,1);\n\t\t\tP l2=(p[i]-p[j])*P(0,-1);\n\t\t\tl1=l1*d/abs(l1)+c;l2=l2*d/abs(l2)+c;\n\t\t\tint x=2,y=2;\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(k==i||k==j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(abs(l1-p[k])<1.0+0.00000001){\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif(abs(l2-p[k])<1.0+0.00000001){\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tcnt=max(cnt,max(x,y));\n\t\t}\n\t}\n\treturn cnt;\n\t\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tp.resize(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tp[i]=P(x,y);\n\t\t}\n\t\tcout<<ret()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nclass Point\n{\nprivate:\n\n\tdouble x_;\n\tdouble y_;\n\npublic:\n\n\tPoint() : x_(0), y_(0) { }\n\n\texplicit Point(double x, double y) : x_(x), y_(y) { }\n\n\texplicit Point(double x1, double y1, double x2, double y2) : x_(x2 - x1), y_(y2 - y1) { }\n\n\tdouble x() { return x_; }\n\tdouble y() { return y_; }\n\n\tdouble x() const { return x_; }\n\tdouble y() const { return y_; }\n\n\tPoint& operator+= (const Point& p) { x_ += p.x_; y_ += p.y_; return *this; }\n\tPoint& operator-= (const Point& p) { x_ -= p.x_; y_ -= p.y_; return *this; }\n\n\tPoint& operator*= (double s) { x_ *= s; y_ *= s; return *this; }\n\tPoint& operator/= (double s) { x_ /= s; y_ /= s; return *this; }\n\n\tfriend bool operator== (const Point& p1, const Point& p2) { return p1.x_ == p2.x_ && p1.y_ == p2.y_; }\n\tfriend bool operator!= (const Point& p1, const Point& p2) { return !(p1 == p2); }\n\n\tfriend Point operator+ (const Point& p1, const Point& p2) { return Point(p1.x_ + p2.x_, p1.y_ + p2.y_); }\n\tfriend Point operator- (const Point& p1, const Point& p2) { return Point(p1.x_ - p2.x_, p1.y_ - p2.y_); }\n\n\tfriend Point operator* (const Point& p, double s) { return Point(p.x_ * s, p.y_ * s); }\n\tfriend Point operator/ (const Point& p, double s) { return Point(p.x_ / s, p.y_ / s); }\n\n\tfriend Point operator* (double s, const Point& p) { return Point(p.x_ * s, p.y_ * s); }\n};\n\ndouble distance(const Point& p1, const Point& p2)\n{\n\treturn sqrt(pow(p2.x() - p1.x(), 2) + pow(p2.y() - p1.y(), 2));\n}\n\nint main()\n{\n\tint N; double X, Y;\n\n\tvector<Point> Plane;\n\n\twhile (true)\n\t{\n\t\tcin >> N;\n\n\t\tif (N == 0) { break; }\n\n\t\tPlane.clear();\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tcin >> X >> Y;\n\n\t\t\tPlane.push_back(Point(X, Y));\n\t\t}\n\n\t\tint max_ = 1;\n\n\t\tint count_;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t{\n\t\t\t\tcount_ = 1;\n\n\t\t\t\tif (distance(Plane[i], Plane[j]) < 2)\n\t\t\t\t{\n\t\t\t\t\tdouble vx = (Plane[j].x() - Plane[i].x()) / 2;\n\t\t\t\t\tdouble vy = (Plane[j].y() - Plane[i].y()) / 2;\n\n\t\t\t\t\tdouble vd = sqrt(vx * vx + vy * vy);\n\n\t\t\t\t\tdouble dist = sqrt(1 - vd * vd) / vd;\n\n\t\t\t\t\tdouble rx = Plane[i].x() + vx + -vy * dist;\n\t\t\t\t\tdouble ry = Plane[i].y() + vy + vx * dist;\n\n\t\t\t\t\tPoint R(rx, ry);\n\n\t\t\t\t\tcount_ = 2;\n\n\t\t\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (k != i && k != j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (distance(Plane[k], R) < 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcount_++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmax_ = max(count_, max_);\n\n\t\t\t\tcount_ = 0;\n\n\t\t\t\tif (distance(Plane[i], Plane[j]) < 2)\n\t\t\t\t{\n\t\t\t\t\tdouble vx = (Plane[j].x() - Plane[i].x()) / 2;\n\t\t\t\t\tdouble vy = (Plane[j].y() - Plane[i].y()) / 2;\n\n\t\t\t\t\tdouble vd = sqrt(vx * vx + vy * vy);\n\n\t\t\t\t\tdouble dist = sqrt(1 - vd * vd) / vd;\n\n\t\t\t\t\tdouble rx = Plane[i].x() + vx + vy * dist;\n\t\t\t\t\tdouble ry = Plane[i].y() + vy + -vx * dist;\n\n\t\t\t\t\tPoint R(rx, ry);\n\n\t\t\t\t\tcount_ = 2;\n\n\t\t\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (k != i && k != j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (distance(Plane[k], R) < 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcount_++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmax_ = max(count_, max_);\n\t\t\t}\n\t\t}\n\n\t\tcout << max_ << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\nusing namespace std;\n\ntypedef complex<double> P;\n#define EPS (1e-10)\n\nint main()\n{\n\tint n;\n\twhile(cin>>n && n!=0){\n\t\tint ans=1;\n\t\tvector<P> points;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y; cin>>x>>y;\n\t\t\tpoints.push_back(P(x,y));\n\t\t}\n\t\tfor(int a=0;a<n;a++){\n\t\t\tfor(int b=a+1;b<n;b++){\n\t\t\t\tif(abs(points[b]-points[a])+EPS>2.0) continue;\n\t\t\t\tP sa=P(points[b]-points[a])/2.0;\n\t\t\t\tP rev[2];\n\t\t\t\trev[0]=sa*P(0,1.0)/abs(sa);\n\t\t\t\trev[1]=sa*P(0,-1.0)/abs(sa);\n\t\t\t\tdouble l=sqrt(1-abs(sa)*abs(sa));\n\n\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\tP center=points[a]+sa+rev[k]*l;\n\t\t\t\t\tint t_ans=2;\n\t\t\t\t\tfor(int id=0;id<n;id++){\n\t\t\t\t\t\tif(id==a || id==b) continue;\n\t\t\t\t\t\tif(abs(center-points[id])+EPS<1.0){\n\t\t\t\t\t\t\tt_ans++;\n//\t\t\t\t\t\t\tcout<<abs(center-points[id])<<endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n//\t\t\t\t\tcout<<t_ans<<endl;\n\t\t\t\t\tans=max(ans,t_ans);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n??????????????????????????????3??\\??????3???????????¨?????????????????????????????????????????¨????????????\n*/\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<double> comd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define fst\tfirst\n#define scn second\n#define bucnt(x)\t__buildin__popcount(x)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl\n\nconst ll inf = (ll)1e9;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-9;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\ndouble Dist2(pdd a, pdd b) {\n\treturn (a.fst - b.fst)*(a.fst - b.fst) + (a.scn - b.scn)*(a.scn - b.scn);\n}\n\nvector<pdd> getCenter(pdd a, pdd b) {\n\tvector<pdd> ret;\n\tpdd c = mp((a.fst + b.fst) / 2.0, (a.scn + b.scn) / 2.0);\n\tpdd v = mp(a.scn - b.scn, b.fst - a.fst);\n\tdouble D = sqrt(v.fst*v.fst + v.scn*v.scn);\n\tv.fst /= D;\tv.scn /= D;\n\tD = sqrt(1 - Dist2(a, b)/4.0);\n\tv.fst *= D;\tv.scn *= D;\n\tret.push_back(mp(c.fst + v.fst, c.scn + v.scn));\n\tret.push_back(mp(c.fst - v.fst, c.scn - v.scn));\n\treturn ret;\n}\n\nint main() {\n\twhile (true) {\n\t\tint n;\tcin >> n;\n\t\tif (n == 0)\tbreak;\n\t\tvector<pdd> p(n,mp(0,0));\n\t\trep(i, n) cin >> p[i].fst >> p[i].scn;\n\t\tint ret = 0;\n\t\trep(i, n) {\n\t\t\trep(j, i) {\n\t\t\t\tif (Dist2(p[i], p[j]) <= 4.0) {\n\t\t\t\t\tvector<pdd> c = getCenter(p[i], p[j]);\n\t\t\t\t\tint tmp = 0;\n\t\t\t\t\trep(k, n) {\n\t\t\t\t\t\tif (Dist2(c[0], p[k]) <= 1.0 + eps)\ttmp++;\n\t\t\t\t\t}\n\t\t\t\t\tret = max(ret, tmp);\n\t\t\t\t\ttmp = 0;\n\t\t\t\t\trep(k, n) {\n\t\t\t\t\t\tif (Dist2(c[1], p[k]) <= 1.0 + eps)\ttmp++;\n\t\t\t\t\t}\n\t\t\t\t\tret = max(ret, tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////\n///   template   ///\n////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\nusing namespace std;\n\n//// MACRO ////\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define allof(c) c.begin(), c.end()\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define EPS 1e-10\n#define INF 1000000000\n\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n#define PREDIACTE(t,a) [](const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) [](const t & a, const t & b) -> bool\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n//// iota iterator ////\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n//// geo ////\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ntemplate<class P2>\npair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n//// bit ////\n#ifdef _MSC_VER\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n//// graph ////\nstruct Path\n{\n\tint from;\n\tint to;\n\tdouble cost;\n\tPath(int from = 0, int to = 0, double cost = 0) : from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n\n\n// prim //\npair<double, vector<int>> prim(const vector<vector<double>> &costTable)\n{\n\tint N = costTable.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(0, 0, 0));\n\n\tvector<int> parent(N, -1);\n\tdouble totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(Path(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\npair<vector<double>, vector<int>> dijkstra(const vector<vector<Path>> &routes, int start = 0, int goal = -1)\n{\n\tint N = routes.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<double> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tPath next = Path(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n//// i/o ////\ntemplate <class T>\nclass vevector : public vector<vector<T>>\n{\npublic:\n\tvevector(int n = 0, int m = 0) : vector<vector<T>>(n, vector<T>(m)) { };\n\tvevector(int n, int m, const T &initial) : vector<vector<T>>(n, vector<T>(m, initial)) { };\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(read<T>(read<int>())); return v; }\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T> void write(const T &t, const T &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\ntemplate<class T>\nistream & operator>>(istream & in, complex<T> & n) { T r, i; in >> r >> i; n = complex<T>(r, i); return in; }\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\t// freopen(\"A.in\", \"r\", stdin);\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tauto testcases = INF; // read<int>();\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\n\t\tauto ps = read<P2>(N);\n\t\t\n\t\tint result = 0;\n\t\tREP(i_, N) FOR(j_, i_ + 1, N)\n\t\t{\n\t\t\tconst P2 i = ps[i_], j = ps[j_];\n\t\t\tdouble r = 1;\n\t\t\tif (abs(i - j) >= 2 * r) { continue; } // 遠すぎて円が作れない\n\n\t\t\tauto c = get_same_distance_points(i, j, r); // i と j から ちょうど r 離れた点\n\n\t\t\tauto c1 = Circle(c.first, r), c2 = Circle(c.second, r);\n\t\t\tresult = max<int>(result, count_if(allof(ps), [c1, r](P2 p) { return c1.Contains(p); }));\n\t\t\tresult = max<int>(result, count_if(allof(ps), [c2, r](P2 p) { return c2.Contains(p); }));\n\t\t}\n\n\t\twrite(result);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble Dis(double x1, double y1, double x2, double y2);\nint main(void){\n\twhile(1){\n\t\tint n;\n\t\tint ans = 0;\n\t\tvector< pair<double, double> > p;\n\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tpair<double, double> t;\n\t\t\tcin >> t.first >> t.second;\n\t\t\tp.push_back(t);\n\t\t}\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t//中点\n\t\t\t\tdouble mpx = (p[i].first + p[j].first) / 2.0;\n\t\t\t\tdouble mpy = (p[i].second + p[j].second) / 2.0;\n\t\t\t\t//2点間の距離\n\t\t\t\tdouble d1 = Dis(p[i].first, p[i].second, p[j].first, p[j].second);\n\t\t\t\t//p[i]からp[j]へ向かうベクトル\n\t\t\t\tdouble v1x = (p[i].first - p[j].first) / d1;\n\t\t\t\tdouble v1y = (p[i].second - p[j].second) / d1;\n\t\t\t\t//中点から円の中心へ向かう単位ベクトル\n\t\t\t\tdouble v2x = -v1y;\n\t\t\t\tdouble v2y = v1x;\n\t\t\t\t//中心から円の中心へ向かうベクトルの長さ\n\t\t\t\tdouble d2 = sqrt(1.0 - (d1/2.0)*(d1/2.0));\n\n\t\t\t\t//円の中心の座標\n\t\t\t\tdouble cx = mpx + v2x * d2;\n\t\t\t\tdouble cy = mpy + v2y * d2;\n\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(k == i || k == j || Dis(cx, cy, p[k].first, p[k].second) <= 1.0)\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt > ans){\n\t\t\t\t\tans = cnt;\n\t\t\t\t}\n\n\t\t\t\tcx = mpx - v2x * d2;\n\t\t\t\tcy = mpy - v2y * d2;\n\n\t\t\t\tcnt = 0;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(Dis(cx, cy, p[k].first, p[k].second) <= 1.0)\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt > ans){\n\t\t\t\t\tans = cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\n\t}\n\t\n\treturn 0;\n}\n\ndouble Dis(double x1, double y1, double x2, double y2){\n\treturn sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\n#define EQ(x,y) (abs((x)-(y))<EPS)\n#define LE(x,y) ((x)-(y) < +EPS)\n\n#include <complex>\ntypedef complex<double> P;\ntypedef vector<P> vp;\n\nP rotate(P t, P p, double r) {\n\tdouble ta = cos(r)*(t.real()-p.real())-sin(r)*(t.imag()-p.imag())+p.real();\n\tdouble tb = sin(r)*(t.real()-p.real())+cos(r)*(t.imag()-p.imag())+p.imag();\n\treturn P(ta, tb);\n}\n\ndouble to_radian(double degree) {\n\treturn degree*PI/180;\n}\n\nint main() {\n\tint N;\n\twhile(cin >> N, N) {\n\t\tvp points(N);\n\t\tdouble X, Y;\n\t\tREP(i, N) {\n\t\t\tcin >> X >> Y;\n\t\t\tpoints[i] = P(X, Y);\n\t\t}\n\n\t\tint ans = 0;\n\t\tREP(i, N) {\n\t\t\tFOR(j, i+1, N-1) {\n\t\t\t\tP a = points[i], b = points[j];\n\t\t\t\tif(LE(abs(a-b), 2.0)) {\n\t\t\t\t\tP m = P((a.real()+b.real())/2, (a.imag()+b.imag())/2);\n\t\t\t\t\tdouble l = abs(a-m);\n\t\t\t\t\tdouble d = sqrt(1-l*l);\n\t\t\t\t\tdouble c = l-d;\n\t\t\t\t\tP t = P((d*a.real()+c*m.real())/(c+d), (d*a.imag()+c*m.imag())/(c+d));\n\t\t\t\t\tP p1 = rotate(t, m, to_radian(90));\n\t\t\t\t\tint tmp1 = 0;\n\t\t\t\t\tREP(k, N) {\n\t\t\t\t\t\tif(LE(abs(p1-points[k]), 1.0)) {\n\t\t\t\t\t\t\ttmp1++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans, tmp1);\n\t\t\t\t\tP p2 = rotate(t, m, to_radian(-90));\n\t\t\t\t\tint tmp2 = 0;\n\t\t\t\t\tREP(k, N) {\n\t\t\t\t\t\tif(LE(abs(p2-points[k]), 1.0)) {\n\t\t\t\t\t\t\ttmp2++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans, tmp2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 310\n\ndouble x[MAX_N], y[MAX_N];\nint n, maxn;\n\nint main() {\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tmaxn = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tint sum = 0;\n\t\t\t\tdouble X = (x[i] + x[j]) / 2.0;\n\t\t\t\tdouble Y = (y[i] + y[j]) / 2.0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (((x[k] - X)*(x[k] - X) + (y[k] - Y)*(y[k] - Y)) <= 1) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\t\t\t}\n\t\t}\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\ndouble x[300],y[300];\ndouble px[90000],py[90000];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tint now=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=i+1;j<a;j++){\n\t\t\t\tif((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])<4.0000001){\n\t\t\t\t\tdouble d=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n\t\t\t\t\tdouble mx=(x[i]+x[j])/2;\n\t\t\t\t\tdouble my=(y[i]+y[j])/2;\n\t\t\t\t\tdouble s=sqrt(1-d*d/4);\n\t\t\t\t\tdouble theta=atan((y[i]-y[j])/(x[i]-x[j]));\n\t\t\t\t\tpx[now]=mx-sin(theta)*s;\n\t\t\t\t\tpy[now++]=my+cos(theta)*s;\n\t\t\t\t\tpx[now]=mx+sin(theta)*s;\n\t\t\t\t\tpy[now++]=my-cos(theta)*s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=1;\n\t\tfor(int i=0;i<now;i++){\n\t\t\tint k=0;\n\t\t\tfor(int j=0;j<a;j++)if((px[i]-x[j])*(px[i]-x[j])+(py[i]-y[j])*(py[i]-y[j])<1.0000001)k++;\n\t\t\tret=max(ret,k);\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\n#define MAX_N 310\n\nlong double x[MAX_N], y[MAX_N];\nint n, maxn;\n\nint main() {\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tmaxn = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tint sum = 0;\n\n\t\t\t\tlong double X = (x[i] + x[j]) / 2.0;\n\t\t\t\tlong double Y = (y[i] + y[j]) / 2.0;\n\n\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t{\n\t\t\t\t\tif (((x[k] - X)*(x[k] - X) + (y[k] - Y)*(y[k] - Y)) <= 1) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\n\t\t\t\tlong double X1, Y1, X2, Y2, X3, Y3, VX2, VY2, Dist, Dist2;\n\n\t\t\t\tDist = sqrtl((x[j] - x[i])*(x[j] - x[i]) + (y[j] - y[i])*(y[j] - y[i]));\n\t\t\t\tDist2 = sqrtl(4 - Dist*Dist);\n\t\t\t\tX2 = x[j] - x[i]; Y2 = y[j] - y[i];\n\t\t\t\tVX2 = (X2 / Dist)*Dist2 / 2; VY2 = (Y2 / Dist)*Dist2 / 2;\n\t\t\t\tX1 = X + VY2; Y1 = Y - VX2;\n\t\t\t\tX3 = X - VY2; Y3 = Y + VX2;\n\n\t\t\t\tsum = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (((x[k] - X1)*(x[k] - X1) + (y[k] - Y1)*(y[k] - Y1)) <= 1) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\t\t\t\tsum = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (((x[k] - X3)*(x[k] - X3) + (y[k] - Y3)*(y[k] - Y3)) <= 1) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint sum = 0;\n\t\t\tlong double X = x[i];\n\t\t\tlong double Y = y[i];\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (((x[k] - X)*(x[k] - X) + (y[k] - Y)*(y[k] - Y)) <= 1) {\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxn = max(maxn, sum);\n\t\t}\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n \n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n \ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n \n// #define double long double\n \ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-6;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n \nP readP() {\n    double x, y;\n    cin >> x >> y;\n    return P(x, y);\n}\n \n// rot p around q by theta (counter-clockwise)\nP rotP(P p, P q, double theta) {\n    p -= q;\n    double x = p.real(), y = p.imag();\n    p = P(x * cos(theta) - y * sin(theta), x * sin(theta) + y * cos(theta));\n    p += q;\n    return p;\n}\n \nP center(P p, P q) {\n    // P v = q - p;\n    // double theta = asin(abs(v) / 2);\n    // v *= (1 / abs(v));\n    // P u = rotP(v, p, theta);\n    // return p + u;\n \n    // P v = q - p;\n    // P h = v * P(0., 1.) / abs(v);\n    // return p + (v / 2.) + h;\n \n    P v = q - p;\n    P h = P(v.imag(), -v.real());\n    h /= abs(h);\n    h *= sqrt(1 - norm(v / 2.));\n    P c = p + (v / 2.) + h;\n    return c;\n}\n \nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n \n    int n;\n    while (cin >> n, n) {\n        vector<P> p(n);\n        rep(i, n) p[i] = readP();\n \n        int ans = 1;\n        rep(i, n) {\n            rep2(j, i + 1, n) {\n                if (i == j) continue;\n                if (norm(p[i] - p[j]) > 4. + EPS) continue;\n                rep(s, 2) {\n                    P c = (s ? center(p[i], p[j]) : center(p[j], p[i]));\n                    int cnt = 2;\n                    rep(k, n) {\n                        if (k == i || k == j) continue;\n                        if (norm(p[k] - c) < 1. + EPS) {\n                            cnt++;\n                        }\n                    }\n                    ans = max(ans, cnt);\n                }\n            }\n        }\n \n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1000000000\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint median_Point(Point a,Point b){\n  Vector v=a-b;\n  return b+(v/2);\n}\n\nPoint PointRotation(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\nvector<Point> vp;\nint ans;\nint n;\n\npair<Circle,Circle> makeCircle(Point a,Point b){\n  Point m=median_Point(a,b);\n  double d=sqrt(1-(abs(a-b)/2)*(abs(a-b)/2));\n  Point A=m+(PointRotation(m,a,90)-m)*d,B=m+(PointRotation(m,b,90)-m)*d;\n  return mp(Circle(A,1),Circle(B,1));\n}\n\nint PointsInCircle(Circle C)\n{\n  int num=0;\n  for(int i=0;i<n;i++){\n    if(abs(vp[i]-C.c)<=C.r+eps)num++;\n  }\n  return num;\n}\n\nint main()\n{\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    vp.clear();\n    vp.resize(n);\n    for(int i=0;i<n;i++)cin>>vp[i].x>>vp[i].y;\n    ans=1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i==j)continue;\n\tif(2<abs(vp[i]-vp[j]))continue;\n\tpair<Circle,Circle> pc=makeCircle(vp[i],vp[j]);\n\tans=max(ans,PointsInCircle(pc.f));\n\tans=max(ans,PointsInCircle(pc.s));\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n#include<cmath>\n#define EPS 1e-8\nusing namespace std;\n\ntypedef complex<double> P;\n\nP center(P a,P b){\n  P m = (a+b)/2.0;\n  P n = (a-b)*P(0,1);\n  n = n/abs(n);\n\n  double x = abs(a-b)/2.0;\n  return m + n*sqrt(1.0 - x*x);\n}\n\nint main(){\n  int n;\n  P p[300];\n\n  while(cin >> n && n){\n    for(int i=0;i<n;i++)cin >> p[i].real() >> p[i].imag();\n\n    int ans = 1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i!=j){\n\t  if(abs(p[i]-p[j])+EPS>2.0)continue;\n\t  P c = center(p[i],p[j]);\n\t  int num = 0;\n\t  for(int k=0;k<n;k++)\n\t    if(abs(c-p[k])<1.0+EPS)num++;\n\t  ans = max(ans,num);\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-5;\n\nint main() {\n\tfor (;;) {\n\t\tint N; cin >> N;\n\t\tif (N == 0) break;\n\t\tvector<double> x(N), y(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> x[i] >> y[i];\n\t\tint maxi = 1;\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tdouble dx = x[j] - x[i], dy = y[j] - y[i];\n\t\t\t\tdouble d = sqrt(dx * dx + dy * dy);\n\t\t\t\tif (d > 2) continue;\n\t\t\t\tdouble h = sqrt(1 - d * d / 4);\n\t\t\t\tdouble ox = x[i] + dx / 2 - dy / d * h;\n\t\t\t\tdouble oy = y[i] + dy / 2 + dx / d * h;\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tdouble dx = x[k] - ox, dy = y[k] - oy;\n\t\t\t\t\tdouble d2 = dx * dx + dy * dy;\n\t\t\t\t\tif (d2 <= 1 + EPS) cnt++;\n\t\t\t\t}\n\t\t\t\tmaxi = max(maxi, cnt);\n\t\t\t}\n\t\tcout << maxi << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    while(cin>>n,n){\n        vector<Point> ps(n);\n        for(int i=0;i<n;i++){\n            ps[i] = input_point();\n        }\n        if(n==1){\n            cout<<n<<endl;\n            continue;\n        }\n        int res=1;\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++){\n                Circle c1=Circle(ps[i],1.0),c2=Circle(ps[j],1.0);\n                vector<Point> vs=is_cc(c1,c2);\n                int sz=vs.size();\n                if(sz==0) continue;\n                for(int k=0;k<sz;k++){\n                    Point p=vs[k];\n                    int tmp=0;\n                    for(int idx=0;idx<n;idx++){\n                        if(abs(ps[idx]-p)<=1+eps) tmp++;\n                    }\n                    res=max(res,tmp);\n                }\n            }\n        }\n        cout<<res<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 301\nusing namespace std;\ntypedef complex <double> P;\nP p[N];\nint n;\n\nint cnt(P c){\n  int res=0;\n  for(int i=0;i<n;i++)if(abs(c-p[i])<1) res++;\n  return res;\n}\n\nP get_C(P a,P b){\n  double x=abs(b-a);\n  if(x>2||a==b) return a;\n  return P(x/2,sqrt(1-x*x/4))*(b-a)/abs(b-a)+a;  \n}\n\n\nint main(){\n  while(1){\n  cin>>n;\n  if(!n)break;\n  double a,b;\n  for(int i=0;i<n;i++)cin>>a>>b,p[i]=P(a,b);\n  \n  int ans=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      ans=max(ans,cnt(get_C(p[i],p[j])));\n  cout <<ans<<endl;  \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\ntemplate<class T> bool operator<(const complex<T> &a, const complex<T> &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n}\n\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\n\ndouble dot(P a, P b){\n    return (a * conj(b)).X;\n}\ndouble cross(P a, P b){\n    return (a * conj(b)).Y;\n}\n\nvector<P> points;\ndeque<P> selected;\nint max_count;\n\nvoid search(int index) {\n    if(index > points.size()) return;\n    int selected_size = selected.size();\n\n    bool is_all_in_circle = true;\n    if(selected_size >= 2 && selected_size > max_count) {\n        // calc is all overlaps\n        vector<P> copied_selected;\n        copy(selected.begin(), selected.end(), back_inserter(copied_selected));\n\n        for (int i = 0; i < selected_size ; ++i) {\n            for (int j = 0; j < selected_size; ++j) {\n                if(i == j) continue;\n                // two point check\n                double d12 = abs(copied_selected[i] - copied_selected[j]);\n                if(d12 > 2.0 + 1e-10) {\n                    is_all_in_circle = false;\n                    break;\n                }\n\n                for (int k = 0; k < selected_size; ++k) {\n                    if(i == k || j == k) continue;\n                    // three point check\n                    P p1 = copied_selected[i];\n                    P p2 = copied_selected[j];\n                    P p3 = copied_selected[k];\n\n                    P center12 = P((p1.X + p2.X) / 2, (p1.Y + p2.Y) / 2);\n                    double allow_distance = 1 + sqrt(1 - ((d12 * d12) / 4));\n                    if(abs(center12 - p3)  > allow_distance + 1e-10) {\n                        is_all_in_circle = false;\n                        break;\n                    }\n                }\n\n            }\n            if(!is_all_in_circle) {\n                break;\n            }\n        }\n\n        copied_selected.clear();\n        copied_selected.shrink_to_fit();\n    }\n\n    if (is_all_in_circle) {\n        // update max count\n        if(selected_size > max_count) {\n            max_count = selected_size;\n        }\n\n        P p = points[index];\n        // remove bad situation\n        if(selected.empty() || abs(p - selected.front()) <= 2.0 + 1e-10) {\n            // take\n            selected.push_front(p);\n            search(index + 1);\n            selected.pop_front();\n        }\n\n        // for next dispatch\n        // not take\n        search(index + 1);\n    }\n}\n\nint main() {\n    int n;\n    while (cin >> n) {\n        if(n == 0) break;\n        points.clear();\n        points.shrink_to_fit();\n        selected.clear();\n        selected.shrink_to_fit();\n        max_count = 0;\n\n        // load points\n        for (char i = 0; i < n; ++i) {\n            double x;\n            double y;\n            cin >> x >> y;\n            P p = P(x, y);\n            points.push_back(p);\n        }\n\n        search(0);\n        cout << max_count << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <string> \n#include <vector> \n#include <cmath> \n#include <algorithm> \n#include <cstdlib> \n#include <ctime> \n#include <cstdio> \n#include <functional> \n#include <set> \n#include <sstream> \n\n\nusing namespace std; \n\nint main(){\n\n\tint n;\n\tconst double eps=1e-6;\n\twhile(true){\n\n\t\tcin>>n;\n\n\t\tif(n==0) return 0;\n\n\t\tint ans=0;\n\t\tvector< double > x(n),y(n);\n\n\t\tfor(int i=0;i<n;i++) cin>>x[i]>>y[i];\n\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tconst double d=hypot(x[i]-x[j],y[i]-y[j]);\n\t\t\t\tif(d>2.0-eps) continue;\n\n\t\t\t\tconst double mx=(x[i]+x[j])/2.0;\n\t\t\t\tconst double my=(y[i]+y[j])/2.0;\n\t\t\t\tconst double dvx=(x[i]-x[j])/d;\n\t\t\t\tconst double dvy=(y[i]-y[j])/d;\n\n\t\t\t\tconst double cx1=mx+dvy*sqrt(1.0-d*d/4.0);\n\t\t\t\tconst double cy1=my-dvx*sqrt(1.0-d*d/4.0);\n\n\t\t\t\tconst double cx2=mx-dvy*sqrt(1.0-d*d/4.0);\n\t\t\t\tconst double cy2=my+dvx*sqrt(1.0-d*d/4.0);\n\n\t\t\t\tint res=2;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i || k==j) continue;\n//\t\t\t\t\tif(hypot(x[k]-cx1,y[k]-cy1)<1.0+eps) res++;\n\t\t\t\t\tif((x[k]-cx1)*(x[k]-cx1)+(y[k]-cy1)*(y[k]-cy1)<1.0+eps) res++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tans=max(ans,res);\n\n\t\t\t\tres=2;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i || k==j) continue;\n//\t\t\t\t\tif(hypot(x[k]-cx2,y[k]-cy2)<1.0+eps) res++;\n\t\t\t\t\tif((x[k]-cx2)*(x[k]-cx2)+(y[k]-cy2)*(y[k]-cy2)<1.0+eps) res++;\n\t\t\t\t}\n\n\t\t\t\tans=max(ans,res);\n\n\t\t\t}\n\t\t}\n\n\t\tcout<<ans<<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst double r = 1.0;\nconst double PI = acos(-1.0);\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y) : x(x), y(y) {}\n};\nPoint operator+(const Point &a, const Point &b) {\n    return Point(a.x + b.x, a.y + b.y);\n}\nPoint operator-(const Point &a, const Point &b) {\n    return Point(a.x - b.x, a.y - b.y);\n}\nPoint operator*(const Point &a, double b) {\n    return Point(a.x * b, a.y * b);\n}\ninline double Distance2(const Point &a, const Point &b) {\n    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n// p1??¨??????p1p2???theta?????¢?????????????????£????????????????????????????????????????????????\nPoint Circle(const Point &p1, const Point &p2, double theta) {\n    Point p12 = p2 - p1;\n    Point rp(p12.x * cos(theta) - p12.y * sin(theta), p12.x * sin(theta) + p12.y * cos(theta));\n    double len = sqrt(p12.x * p12.x + p12.y * p12.y);\n\n    return (rp * (1.0 / len)) + p1;\n}\n\nint main()\n{\n    int n;\n\n    while (true) {\n        // Input\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        vector<Point> p(n);\n        for (int i = 0; i < n; ++i)\n            scanf(\"%lf %lf\", &p[i].x, &p[i].y);\n\n        // Solve\n        // 2???????????????????§£???????£???¨??????\n        int ans = 1;\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j) {\n                double d = Distance2(p[i], p[j]);\n\n                if (d <= 4.0 * r * r) {\n                    double theta = (PI - acos((2.0 - d) * 0.5)) * 0.5;\n\n                    for (int s = -1; s <= 1; s += 2) {\n                        Point c = Circle(p[i], p[j], s * theta);\n\n                        int num = 2;\n                        for (int k = 0; k < n; ++k) {\n                            if (k != i && k != j && Distance2(c, p[k]) <= 1.0)\n                                ++num;\n                        }\n\n                        ans = max(ans, num);\n                    }\n                }\n            }\n\n        // Output\n        printf(\"%d\\n\", ans);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=200005,INF=1<<29;\n\nconst double eps=1e-10;\nconst double pi=acos((long double)-1.0L);\n#define equals(a,b) (fabs((a)-(b))<eps)\n\ndouble torad(int deg) {return (double)(deg)*pi/180.0;}\ndouble todeg(double ang) {return ang*180.0/pi;}\n\nclass Point{\npublic:\n    double x,y;\n    \n    Point(double x=0,double y=0):x(x),y(y){}\n    \n    Point operator + (Point p){return Point(x+p.x,y+p.y);}\n    Point operator - (Point p){return Point(x-p.x,y-p.y);}\n    Point operator * (double a){return Point(a*x,a*y);}\n    Point operator / (double a){return Point(x/a,y/a);}\n    \n    double abs(){return sqrt(norm());}\n    double norm(){return x*x+y*y;}\n    \n    bool operator < (const Point &p)const{\n        return x!=p.x ? x<p.x : y<p.y;\n    }\n    \n    bool operator == (const Point &p)const{\n        return fabs(x-p.x)<eps&&fabs(y-p.y)<eps;\n    }\n};\n\ntypedef Point Vector;\n\ndouble norm(Vector a){\n    return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\nstruct Segment{\n    Point p1,p2;\n};\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nstatic const int counter_clockwise=1;\nstatic const int clockwise=-1;\nstatic const int online_back=2;\nstatic const int online_front=-2;\nstatic const int on_segment=0;\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    \n    if(cross(a,b)>eps) return counter_clockwise;\n    if(cross(a,b)<-eps) return clockwise;\n    if(dot(a,b)<-eps) return online_back;\n    if(a.norm()<b.norm()) return online_front;\n    \n    return on_segment;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return(ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ntypedef Segment Line;\n\ndouble getDistance(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0) return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0) return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2)) return 0.0;\n    return min({getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2),getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)});\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nclass Circle{\npublic:\n    Point c;\n    double r;\n    Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\nPoint CircleCenter(Point a,Point b,Point c){\n    Point u=a-b,v=a-c;\n    double m1=(norm(a)-norm(b))/2.0,m2=(norm(a)-norm(c))/2.0;\n    \n    Point res;\n    if(cross(u,v)==0.0){\n        res.x=1e9;\n        res.y=1e9;\n        \n        return res;\n    }\n    res.x=(m1*v.y-m2*u.y)/cross(u,v);\n    res.y=(m1*v.x-m2*u.x)/cross(v,u);\n    \n    return res;\n}\n\npair<Point,Point> segCrossPpoints(Circle c,Line l){\n    //assert(intersect(c,l));\n    Vector pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(c.r*c.r-norm(pr-c.c));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\ndouble arg(Vector p){return atan2(p.y,p.x);}\nVector polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    //assert(intersect(c1,c2));\n    double d=abs(c1.c-c2.c);\n    double a=acos((c1.r*c1.r+d*d-c2.r-c2.r)/(2*c1.r*d));\n    double t=arg(c2.c-c1.c);\n    return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\ntypedef vector<Point> Polygon;\n\n/*\n IN 2\n ON 1\n OUT 0\n */\n\nint contains(Polygon g,Point p){\n    int n=int(g.size());\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=g[(i+1)%n]-p;\n        if(a.y>b.y) swap(a,b);\n        if(a.y<eps&&eps<b.y&&cross(a,b)>eps) x=!x;\n    }\n    return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s,bool ok){\n    Polygon u,l;\n    sort(all(s));\n    \n    if(int(s.size())<3) return s;\n    int n=int(s.size());\n    \n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    \n    l.push_back(s[n-1]);\n    l.push_back(s[n-2]);\n    \n    if(ok){\n        for(int i=2;i<n;i++){\n            for(int j=int(u.size());j>=2&&ccw(u[j-2],u[j-1],s[i])==counter_clockwise;j--){\n                u.pop_back();\n            }\n            u.push_back(s[i]);\n        }\n        \n        for(int i=int(s.size())-3;i>=0;i--){\n            for(int j=int(l.size());j>=2&&ccw(l[j-2],l[j-1],s[i])==counter_clockwise;j--){\n                l.pop_back();\n            }\n            l.push_back(s[i]);\n        }\n    }\n    \n    if(!ok){\n        for(int i=2;i<n;i++){\n            for(int j=int(u.size());j>=2&&ccw(u[j-2],u[j-1],s[i])!=clockwise;j--){\n                u.pop_back();\n            }\n            u.push_back(s[i]);\n        }\n        \n        for(int i=int(s.size())-3;i>=0;i--){\n            for(int j=int(l.size());j>=2&&ccw(l[j-2],l[j-1],s[i])!=clockwise;j--){\n                l.pop_back();\n            }\n            l.push_back(s[i]);\n        }\n    }\n    \n    reverse(all(l));\n    \n    for(int i=int(u.size())-2;i>=1;i--) l.push_back(u[i]);\n    \n    return l;\n}//ok==1なら辺の上も含める\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N;cin>>N;\n        if(N==0) break;\n        \n        vector<Point> S(N);\n        for(int i=0;i<N;i++){\n            cin>>S[i].x>>S[i].y;\n        }\n        \n        int ans=1;\n        \n        for(int i=0;i<N;i++){\n            for(int j=i+1;j<N;j++){\n                Point c=(S[i]+S[j])/2.0;\n                \n                if(getDistance(S[i],c)>1.0) continue;\n                \n                int cnt=0;\n                \n                for(int k=0;k<N;k++){\n                    if(getDistance(S[k],c)<=1.0) cnt++;\n                }\n                \n                chmax(ans,cnt);\n            }\n        }\n        \n        for(int i=0;i<N;i++){\n            for(int j=i+1;j<N;j++){\n                for(int k=j+1;k<N;k++){\n                    Point c=CircleCenter(S[i],S[j],S[k]);\n                    \n                    if(getDistance(S[i],c)>1.0) continue;\n                    \n                    int cnt=0;\n                    \n                    for(int l=0;l<N;l++){\n                        if(getDistance(S[l],c)<=1.0) cnt++;\n                    }\n                    \n                    chmax(ans,cnt);\n                }\n            }\n        }\n        \n        cout<<ans<<endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\n\nmain(){\n  int n;\n  while(cin>>n,n){\n    double x[n],y[n];\n\n    rep(i,n)cin>>x[i]>>y[i];\n\n    int ans=0;\n\n    rep(i,n){\n      rep(j,i){\n\tdouble sx,sy;\n\tdouble tx=x[i]-x[j],ty=y[i]-y[j];\n\tdouble len=sqrt(tx*tx+ty*ty);\n\tif(len>2+EPS)continue;\n\tlen=sqrt(1-len*len/4);\n\tdouble theta=atan2(ty,tx)+M_PI/2;\n\tint tans=0;\n\tsx=(x[i]+x[j])/2+cos(theta)*len;\n\tsy=(y[i]+y[j])/2+sin(theta)*len;\n\trep(k,n){\n\t  tx=sx-x[k];\n\t  ty=sy-y[k];\n\t  if(tx*tx+ty*ty<=1+EPS)++tans;\n\t}\n\tans=max(ans,tans);\n\ttans=0;\n\tsx=(x[i]+x[j])/2-cos(theta)*len;\n\tsy=(y[i]+y[j])/2-sin(theta)*len;\n\trep(k,n){\n\t  tx=sx-x[k];\n\t  ty=sy-y[k];\n\t  if(tx*tx+ty*ty<=1+EPS)++tans;\n\t}\n\tans=max(ans,tans);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *  Circle and Points (PKU 1981)\n *  by Kenji Inoue, 2007-01-05\n **/\n\n#include <iostream>\n#include <math.h>\n\nusing namespace std;\n\n#define EPS (1e-6)\n\ndouble x[300], y[300];\n\nint sign[] = {+1, -1};\n\nint main(void) {\n  int n;\n  while (cin >> n, n) {\n    for (int i=0; i<n; i++) {\n      cin >> x[i] >> y[i];\n    }\n\n    int ans = 1;\n    for (int i=0; i<n; i++) {\n      for (int j=i+1; j<n; j++) {\n        double d = hypot(x[i]-x[j], y[i]-y[j]);\n        if ( d > 2.0 + EPS ) { continue; }\n\n        double mx = (x[i] + x[j]) / 2;\n        double my = (y[i] + y[j]) / 2;\n        double vx = (x[j] - x[i]) / d;\n        double vy = (y[j] - y[i]) / d;\n        double e = sqrt(1.0 - d*d/4.0);\n\n        for (int s=0; s<2; s++) {\n          double px = mx + sign[s]*e*vy;\n          double py = my - sign[s]*e*vx;\n\n\t\t  printf(\"%f,%f\\n\",px,py);\n\n          int cnt = 2;\n          for (int k=0; k<n; k++) {\n            if (k==i || k==j) { continue; }\n            if ( (px-x[k])*(px-x[k]) + (py-y[k])*(py-y[k]) < 1.0 + EPS ) { cnt++; }\n          }\n          if (cnt > ans) { ans = cnt; }\n        }\n      }\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <numeric>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<((x))<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n#define long long long\n#define EPS 1e-8\n\n// ???????°???°???????????????\ninline double add(double a, double b){\n  if(abs(a+b) < EPS*(abs(a) + abs(b))) return 0;\n  return a+b;\n}\n\nstruct Point{\n  double x,y;\n  Point() {}\n  Point(double nx, double ny) : x(nx), y(ny) {}\n  inline Point operator + (const Point & p){ return Point(add(x, p.x), add(y, p.y)); }\n  inline Point operator - (const Point & p){ return Point(add(x,-p.x), add(y,-p.y)); }\n  inline Point operator * (double d){ return Point(x*d, y*d); }\n  inline double dot(const Point & p){ return add(x * p.x, y*p.y); }  //??????\n  inline double det(const Point & p){ return add(x * p.y, -y*p.x); } //??????\n  inline double dist(const Point & p){ return sqrt((x-p.x)*(x-p.x) + (y-p.y)*(y-p.y)); }\n  inline bool operator < (const Point & p) const {\n    if(x != p.x) return x < p.x;\n    else return y < p.y;\n  }\n  inline bool operator == (const Point & p) const {\n    return (add(x, -p.x)==0) && (add(y, -p.y)==0);\n  }\n  friend ostream& operator<<(ostream& os, const Point& p) {\n    os << \"[\" << p.x << \",\" << p.y << \"]\";\n    return os;\n  }\n};\n\npair<Point, Point> calcCenter(Point &p1, Point &p2){\n  if(add(p1.x, -p2.x)==0){\n    double y = (p1.y + p2.y)/2;\n    double dx = sqrt(1 - (p1.y - y)*(p1.y - y));\n    return mp(Point(p1.x+dx, y), Point(p1.x-dx,y));\n  }\n  // 2???????????´???????????? Ax + By + C = 0 , A != 0\n  double A = 2*(p1.x - p2.x);\n  double B = 2*(p1.y - p2.y);\n  double C = - p1.x*p1.x + p2.x*p2.x - p1.y*p1.y + p2.y*p2.y;\n  // x = py+q\n  double p = -B/A; double q = -C/A;\n\n  // p1, p2 ??¨????????¢???1?????? ay^2 + 2by + c = 0\n  double a = 1 + p*p;\n  double b = p*q - p1.x*p - p1.y;\n  double c = q*q - 2*p1.x*q + p1.x*p1.x + p1.y*p1.y - 1;\n\n  double rt = sqrt(b*b-a*c);\n  double y1 = (-b+rt)/a;\n  double y2 = (-b-rt)/a;\n\n  return mp(Point(p*y1+q, y1), Point(p*y2+q, y2));\n}\n\nPoint vec[300];\n\nint main(){\n  int n;\n  while(scanf(\"%d\", &n), n){\n    rep(i,n){\n      scanf(\"%lf %lf\", &vec[i].x, &vec[i].y);\n    }\n\n    int res=1;\n    rep(i,n) repl(j,i+1,n) if(vec[i].dist(vec[j]) < 2){\n      pair<Point, Point> pr = calcCenter(vec[i], vec[j]);\n      int cnt=0;\n      rep(k,n) if(pr.fi.dist(vec[k]) < 1) cnt++;\n      res = max(res, cnt);\n      cnt=0;\n      rep(k,n) if(pr.se.dist(vec[k]) < 1) cnt++;\n      res = max(res, cnt);\n    }\n\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\n\nconst long double EPS = 10e-6;\n\nclass Point{\n    public: \n    long double x,y;\n    \n    Point(long double x = 0.0, long double y = 0.0): x(x), y(y) {}\n    \n    Point operator + (Point p) const {\n        return Point(x+p.x, y+p.y);\n    }\n    Point operator - (Point p) const {\n        return Point(x-p.x, y-p.y);\n    }\n    Point operator * (long double a) const {\n        return Point(x*a, y*a);\n    }\n    Point operator / (long double a) const {\n        return Point(x/a, y/a);\n    }\n\n    long double norm() {\n        return x*x + y*y;\n    }\n    \n    long double dot(Point p) {\n        return x*p.x + y*p.y;\n    }\n};\n\nPoint calc_center(Point p, Point mid, Point midv){\n    long double norm = mid.norm();\n    midv = midv * sqrt((1.0 - norm) / norm);\n    return p+mid+midv;\n}\n\nint count(vector<Point> points, Point center){\n    int tmp = 0;\n    for(Point p: points){\n        if((p-center).norm() <= 1.0 + EPS) tmp++;\n    }\n    return tmp;\n}\n\nint main() {\n    int n;\n    while(scanf(\"%d\", &n) && n){\n        vector<Point> points(n);\n        rep(n) scanf(\"%Lf %Lf\", &points[i].x, &points[i].y);\n\n        int ans = 1;\n        rep(n){\n            repp(j, n){\n                if(j == i) continue;\n                Point mid = (points[j] - points[i]) * 0.5;\n                Point center = calc_center(points[i], mid, Point(mid.y, -mid.x));\n                ans = max(count(points, center), ans);\n\n                center = calc_center(points[i], mid, Point(-mid.y, mid.x));\n                ans = max(count(points, center), ans);\n            }\n        }\n        printf(\"%d\\n\", ans);\n        debug(ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nint INF=1e9;\nint MOD=1000000007;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ndouble EPS = 1e-10;\ndouble add(double a,double b){\n\tif(abs(a+b)<EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,p.x),add(y,-p.y));\n\t}\n\tP operator * (P p){\n\t\treturn P(x*p.x,y*p.y);\n\t}\n};\ndouble dist(P a,P b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\nint cnt(P pos,vector<P> dat){\n\tint res=0;\n\tREP(i,dat.size()){\n\t\tif(dist(pos,dat[i])<=1.0+EPS)res++;\n\t}\n\treturn res;\n}\nint main(){\n\tint n;\n\tdouble x,y;\n\twhile(scanf(\"%d\",&n)&&n){\n\t\tvector<P> dat;\n\t\tREP(i,n){\n\t\t\tcin>>x>>y;\n\t\t\tdat.PB(P(x,y));\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tP a=dat[i],b=dat[j];\n\t\t\t\tP mid=P((a.x+b.x)/2.0,(a.y+b.y)/2.0);\n\t\t\t\tdouble dx=a.y-b.y,dy=b.x-a.x;\n\t\t\t\tdouble d=dist(a,b);\n\t\t\t\tif(d>2)continue;\n\t\t\t\tdouble dd=sqrt(dx*dx+dy*dy);\n\t\t\t\tdouble ddd=sqrt(1-d*d/4);\n\t\t\t\tdx=dx/dd*ddd;dy=dy/dd*ddd;\n\t\t\t\tans=max(ans,cnt(P(mid.x+dx,mid.y+dy),dat));\n\t\t\t\tans=max(ans,cnt(P(mid.x-dx,mid.y-dy),dat));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n#define EPS 1e-8\ntypedef complex<double> P;\n\nP center(P a, P b){\n  P m  = (a+b) / 2.0;         // p[i]Æp[j]Ì_\n  P n = (a-b) * P(0.0,1.0);  // @üxNg\n  n = n / abs(n);\n  \n  double x = abs( a-b )/2.0;\n  return m + n * sqrt( 1.0-x*x );     // ~ÌS\n}\n\nint main(){\n  int n;\n  P p[301];\n\n  while( cin>>n && n ){\n    for( int i=0;i<n;i++ )\n      cin >> p[i].real() >> p[i].imag();\n\n    int ans=0;\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ ){\n\tif( i==j ) \t  continue;\n\tif( abs( p[i]-p[j] )+EPS > 2.0 ) continue;\n\tP c = center( p[i],p[j] );\n\n\tint num=0;\n\tfor( int k=0;k<n;k++ )\n\t  if( abs( c-p[k] ) < 1.0 + EPS  )\n\t    num++;\n\tans = max( ans,num );\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> p;\n\nint n;\np ps[300];\n\nint main() {\n\twhile (cin >> n , n != 0) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tps[i] = p(x, y);\n\t\t}\n\n\t\tif (n == 1) {\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tp v = ps[i] - ps[j];\n\t\t\t\tp ve = v / abs(v);\n\t\t\t\tdouble l = sqrt(1 - norm(v) / 4);\n\t\t\t\tp vn1 = ve * p(0,1) * l, vn2 = ve * p(0,-1) * l;\n\t\t\t\tp c1 = ps[j] + v / 2.0 + vn1, c2 = ps[j] + v / 2.0 + vn2;\n\t\t\t\tint count1 = 2, count2 = 2;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (k == i || k == j) continue;\n\t\t\t\t\tif (norm(c1 - ps[k]) <= 1) count1++;\n\t\t\t\t\tif (norm(c2 - ps[k]) <= 1) count2++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, count1);\n\t\t\t\tans = max(ans, count2);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pint;\n\n#define DE 1\n#define FI first\n#define SE second\n#define PB push_back\n#define MP make_pair\n#define ALL(s) (s).begin(),(s).end()\n#define REP(i,n) for (int i = 0; i < (int)(n); ++i)\n#define EACH(i,s) for (typeof((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl\n\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, pair<T1,T2> P){return s<<'<'<<P.first<<\", \"<<P.second<<'>';}\ntemplate<class T> ostream& operator<<(ostream &s, vector<T> P) {s<<\"{ \";for(int i=0;i<P.size();++i){if(i>0)s<<\", \";s<<P[i];}return s<<\" }\"<<endl;}\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, map<T1,T2> P) {s<<\"{ \";for(typeof(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<'<'<<it->first<<\"->\"<<it->second<<'>';}return s<<\" }\"<<endl;}\n\n\n\nconst double INF = 1e10;\nconst double EPS = 1e-4;\nconst double PI = acos(-1.0);\ndouble torad(int deg) {return (double)(deg) * PI / 180;}\n\nstruct Point {\n    double x, y;\n    Point(double x = 0.0, double y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\n\nPoint operator + (Point p, Point q) {return Point(p.x + q.x, p.y + q.y);}\nPoint operator - (Point p, Point q) {return Point(p.x - q.x, p.y - q.y);}\nPoint operator * (Point p, double a) {return Point(p.x * a, p.y * a);}\nPoint operator * (double a, Point p) {return Point(a * p.x, a * p.y);}\nPoint operator * (Point p, Point q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\nPoint operator / (Point p, double a) {return Point(p.x / a, p.y / a);}\nPoint conj(Point p) {return Point(p.x, -p.y);}\nPoint rot(Point p, double ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\nPoint rot90(Point p) {return Point(-p.y, p.x);}\ndouble cross(Point p, Point q) {return p.x * q.y - p.y * q.x;}\ndouble dot(Point p, Point q) {return p.x * q.x + p.y * q.y;}\ndouble norm(Point p) {return dot(p, p);}\ndouble abs(Point p) {return sqrt(dot(p, p));}\nbool eq(Point p, Point q) {return abs(p - q) < EPS;}\ndouble amp(Point p) {double res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\nPoint operator / (Point p, Point q) {return p * conj(q) / norm(q);}\n\n\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n};\n\n\nstruct Circle : Point{\n    double r;\n    Circle(Point p = Point(0.0, 0.0), double r = 0.0) : Point(p), r(r) {}\n};\n\n\nPoint proj(Point p, Line l) {\n    double t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\n\ndouble distance(Point p, Line l) {\n    return abs(p - proj(p, l));\n}\n\nvector<Point> crosspoint(Line l, Line m) {\n    vector<Point> res;\n    double d = cross(m[1] - m[0], l[1] - l[0]);\n    if (abs(d) < EPS) return vector<Point>();\n    res.PB(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n    return res;\n}\n\nvector<Point> crosspoint(Circle e, Circle f) {\n    vector<Point> res;\n    double d = abs(e - f);\n    if (d < EPS || d > e.r + f.r + EPS) return vector<Point>();\n    double rcos = (d * d + e.r * e.r - f.r * f.r) / (2.0 * d);\n    double rsin = sqrt(e.r * e.r - rcos * rcos);\n    Point dir = (f - e) / d;\n    Point p1 = e + dir * Point(rcos, rsin);\n    Point p2 = e + dir * Point(rcos, -rsin);\n    res.push_back(p1);\n    if (!eq(p1, p2)) res.push_back(p2);\n    return res;\n}\n\nvector<Point> crosspoint(Circle e, Line l) {\n    vector<Point> res;\n    Point p = proj(e, l);\n    double rcos = abs(e - p);\n    if (rcos > e.r + EPS) return vector<Point>();\n    double rsin = sqrt(e.r * e.r - rcos * rcos);\n    Point dir = (l[1] - l[0]) / abs(l[1] - l[0]);\n    Point p1 = p + dir * rsin;\n    Point p2 = p - dir * rsin;\n    res.push_back(p1);\n    if (!eq(p1, p2)) res.push_back(p2);\n    return res;\n}\n\n\n\nint main() {\n    //freopen( \"/Users/macuser/Documents/Programming/Contest/input.in\", \"r\", stdin );\n    \n    int N;\n    while (cin >> N) {\n        if (N == 0) break;\n        \n        vector<Point> vp(N);\n        for (int i = 0; i < N; ++i) cin >> vp[i].x >> vp[i].y;\n        \n        int res = 1;\n        for (int i = 0; i < N; ++i) {\n            for (int j = i+1; j < N; ++j) {\n                double dis = abs(vp[i] - vp[j])/2;\n                \n                if (dis > 1.0 + EPS) continue;\n                \n                Circle c1(vp[i], 1.0), c2(vp[j], 1.0);\n                vector<Point> c = crosspoint(c1, c2);\n                \n                //cout << i << \", \" << j << \" : \" << dis << \", \" << c1 << \", \" << c2 << \", \" << c;\n                \n                for (int k = 0; k < c.size(); ++k) {\n                    Circle alt(c[k], 1.0);\n                    \n                    int con = 0;\n                    for (int l = 0; l < N; ++l) {\n                        double kyori = abs(vp[l]-c[k]);\n                        if (kyori < 1.0 + EPS) ++con;\n                    }\n                    \n                    //cout << alt << \", \" << con << endl;\n                    \n                    res = max(res, con);\n                }\n            }\n        }\n        \n        cout << res << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\n#define all(c) ((c).begin()),((c).end())\n#define debug(c) cerr<<\"> \"<<#c<<\" = \"<<(c)<<endl;\n#define iter(c) __typeof((c).begin())\n#define tr(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,a,b) for(int i=(int)(a);i<=(int)(b);i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\n#define EPS 1.0e-10\n\n//ツ点\ntypedef complex<double> P;\n\nstruct C{\n\tP p;\n\tdouble r;\n};\n\nvector<P> isCC(const C &c1, const C &c2) {\n\tdouble d = abs(c1.p - c2.p);\n\tdouble x = (d*d + c1.r * c1.r - c2.r * c2.r) / 2 / d;\n\tdouble y = c1.r * c1.r - x * x;\n\tif(y < -EPS) return vector<P>();\n\tif(y < 0) y = 0;\n\tP diff = (c2.p - c1.p) / d;\n\tvector<P> res(2);\n\tres[0] = c1.p + diff * P(x, y);\n\tres[1] = c1.p + diff * P(x, -y);\n\treturn res;\n}\n\nint main() {\n\tfor (int N; cin >> N, N != 0; ) {\n\t\tvector<P> ps;\n\t\trep (i, N) {\n\t\t\tdouble x, y; cin >> x >> y;\n\t\t\tps.pb(P(x, y));\n\t\t}\n\t\tint res = 0;\n\t\trep (i, N) REP (j, i + 1, N-1) {\n\t\t\tvector<P> isp = isCC((C){ps[i],1},(C){ps[j],1});\n\t\t\trep (k, isp.size()) {\n\t\t\t\tint cnt = 0;\n\t\t\t\trep (l, N) if (abs(isp[k] - ps[l]) <= 1 + EPS) cnt++;\n\t\t\t\tres = max(res, cnt);\n\t\t\t}\n\t\t}\n\t\tcout << res <<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-5;\n\nstruct Circle{\n  P c;\n  double r;\n  Circle(P c=P(0,0),double r=0):c(c),r(r){}\n};\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1=c1.r,r2=c2.r,d;\n  P p1=c1.c,p2=c2.c;\n  d=abs(p1-p2);\n  if(d<EPS&&abs(r1-r2)<EPS) return res;\n  if(r1+r2<d-EPS||d+EPS<abs(r1-r2)) return res; \n  double a=(r1*r1-r2*r2+d*d)/(2*d);\n  double h=sqrt(max(r1*r1-a*a,0.0));\n  P tmp1=p1+a/d*(p2-p1);\n  P tmp2=h/d*(p2-p1);\n  if(abs(tmp2)<EPS)res.push_back(tmp1);\n  else{\n    res.push_back(P(real(tmp1)-imag(tmp2),imag(tmp1)+real(tmp2)));\n    res.push_back(P(real(tmp1)+imag(tmp2),imag(tmp1)-real(tmp2)));\n  }\n  return res;\n}\n\ndouble getdistancepp(P a,P b){\n  return sqrt((a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag()));\n}\n\nint main(){\n  int n,ans;\n  double a,b;\n  P p[N];\n  while(1){\n    ans=0;\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>a>>b;\n      p[i]=P(a,b);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tCircle c1,c2;\n\tc1.c=p[i];\n\tc2.c=p[j];\n\tc1.r=c2.r=1;\n\tvector<P> r=getIntersectCC(c1,c2);\n\tif(!r.size())continue;\n\tfor(int k=0;k<r.size();k++){\n\t  int cnt=0;\n\t  for(int l=0;l<n;l++)\n\t    if(getdistancepp(r[k],p[l])<=1+EPS)cnt++;\t    \n\t  ans=max(ans,cnt);\n\t}\n      }\n    }\n    // if(!ans&&n>=1)ans=1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define REP(i,n) for(long long i = 0;i < n;++i)    \n#define seg_size 524288\nint main() {\n\tiostream::sync_with_stdio(false);\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0) return 0;\n\t\tvector<pair<long double, long double>> inputs;\n\t\tREP(i, n) {\n\t\t\tlong double a, b;\n\t\t\tcin >> a >> b;\n\t\t\tinputs.push_back(make_pair(a, b));\n\t\t}\n\t\tint ans = 1;\n\t\tREP(i, inputs.size()) {\n\t\t\tfor (int q = i + 1; q < inputs.size(); ++q) {\n\t\t\t\tlong double x = inputs[i].first + inputs[q].first;\n\t\t\t\tlong double y = inputs[i].second + inputs[q].second;\n\t\t\t\tx /= 2.0;\n\t\t\t\ty /= 2.0;\n\t\t\t\tlong double neko = (x - inputs[i].first) * (x - inputs[i].first) + (y - inputs[i].second) * (y - inputs[i].second);\n\t\t\t\tif (neko > 1.0+eps) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tneko = sqrt(1.0 - neko);\n\t\t\t\tlong double xe = inputs[i].second - inputs[q].second;\n\t\t\t\tlong double ye = inputs[i].first - inputs[q].first;\n\t\t\t\tye *= -1.0;\n\t\t\t\tlong double tani = xe * xe + ye * ye;\n\t\t\t\ttani = sqrt(tani);\n\t\t\t\txe /= tani;\n\t\t\t\tye /= tani;\n\t\t\t\tfor (long double j = -1; j <= 1; j += 2.0) {\n\t\t\t\t\tlong double next_x = x + xe * j * neko;\n\t\t\t\t\tlong double next_y = y + ye * j * neko;\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tREP(j, inputs.size()) {\n\t\t\t\t\t\tlong double dist = (inputs[j].first - next_x) * (inputs[j].first - next_x) + (inputs[j].second - next_y) * (inputs[j].second - next_y);\n\t\t\t\t\t\tif (dist <= 1.0 + eps) {\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans, cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n#include<set>\n#include<array>\n#include<cassert>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\ntypedef double Real;\n\nconst Real EPS = 1e-8;\n\nint sign(Real d){\n\treturn d > EPS ? 1 : d < -EPS ? -1 : 0;\n}\n\nstruct Point{\n\tReal x,y;\t\n\texplicit Point(Real x_ = 0,Real y_ = 0):x(x_),y(y_){}\n\tPoint operator+(const Point &p) const {return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point &p) const {return Point(x-p.x,y-p.y);}\n\tPoint operator*(Real s) const {return Point(x*s,y*s);}\n\tPoint operator/(Real s) const {return Point(x/s,y/s);}\n\tbool operator<(const Point &p) const{return sign(x-p.x) == -1 || (sign(x-p.x) == 0 && sign(y-p.y) == -1);}\n\tbool operator==(const Point &p) const{return sign(x-p.x) == 0 && sign(y-p.y) == 0;}\n\n};\n\nistream &operator>>(istream &is,Point &p){return is >> p.x >> p.y;}//??\\???????°???????\nostream &operator<<(ostream &os ,const Point &p){return os << '(' << p.x << \", \" << p.y << ')';}//??????????°???????\n\nstruct Segment : public array<Point,2>{\n\tSegment(const Point &a,const Point &b){\tat(0) = a; at(1) = b;}\n};\n\nstruct Line : public array<Point,2>{\n\tLine(const Point &a,const Point &b){at(0) = a; at(1) = b;}\n};\n\nstruct Circle{\n\tPoint c;\n\tReal r;\n\n\tCircle(const Point &c_, Real r_):c(c_),r(r_){}\n};\n\ntypedef vector<Point> Polygon;\n\nPoint rotate90(const Point &p){\n\treturn Point(-p.y,p.x);\n}\n\nPoint rotate(const Point &p,Real theta){\n\tconst Real s = sin(theta),c = cos(theta);\n\treturn Point(c*p.x-s*p.y,s*p.x+c*p.y);\n}\n\nReal angle(const Point &p){\n\treturn atan2(p.y,p.x);\n}\n\nReal dot(const Point &a,const Point &b){ //??????????????????\n\treturn a.x*b.x+a.y*b.y;\n}\n\nReal cross(const Point &a,const Point &b){ //??????????????????\n\treturn a.x*b.y-a.y*b.x;\n}\n\n\nReal norm(const Point &p){\n\treturn p.x*p.x+p.y*p.y;\n}\n\nReal abs(const Point &p){\n\treturn sqrt(norm(p));\n}\n\nenum { CCW=1,CW=-1,BACK=2,FRONT=-2,ON=0 };\nint ccw(const Point &a,const Point &b,const Point &c){\n\tconst Point p = b-a;\n\tconst Point q = c-a;\n\tconst int sgn = sign(cross(p,q));\n\t\n\tif(sgn == 1) return CCW;\n\tif(sgn == -1) return CW;\n\tif(sign(dot(p,q)) == -1) return BACK;\n\tif(sign(norm(p) - norm(q)) == -1) return FRONT;\n\treturn ON;\n}\n\nPoint project(const Line &l,const Point &p){ //?°???±\n\tReal t = dot(p-l[0], l[1]-l[0]) / norm(l[0] - l[1]);\n\treturn l[0] + (l[1] - l[0]) * t;\n}\n\nPoint refrect(const Line &l,const Point &p){ //????°?\n\tconst Point c = project(l,p);\n\treturn c+(c-p);\n}\n\nbool intersect(const Segment &a,const Segment &b){\n\treturn ccw(a[0],a[1],b[0])*ccw(a[0],a[1],b[1]) <= 0\n\t\t&& ccw(b[0],b[1],a[0])*ccw(b[0],b[1],a[1]) <= 0;\n}\n\nbool intersect(const Segment &s,const Point &p){\n\treturn ccw(s[0],s[1],p) == ON;\n}\n\nbool intersect(const Line &l,const Segment &s){\n\treturn sign(cross(l[1]-l[0],s[0]-l[0])) * cross(l[1]-l[0],s[1]-l[0]) <= 0;\n}\n\nbool intersect(const Line &l,const Point &p){\n\treturn abs(ccw(l[0],l[1],p)) != 1;\n}\n\nbool intersect(const Line &a,const Line &b){ //????????????\n\treturn sign(cross(a[1]-a[0],b[1]-b[0])) != 0\n\t\t||\tsign(cross(a[1]-a[0],b[1]-a[0]) == 0);\n}\n\nReal dist(const Point &a,const Point &b){\n\treturn abs(a-b);\t\n}\n\nReal dist(const Line &l,const Point &p){\n\tconst Point a = l[1]-l[0];\n\tconst Point b = p-l[0];\n\treturn abs(cross(a,b))/abs(a);\n}\n\nReal dist(const Line &l,const Segment &s){\n\tif(intersect(l,s)) return 0;\n\treturn min(dist(l,s[0]),dist(l,s[1]));\n}\n\nReal dist(const Line &a,const Line &b){\n\tif(intersect(a,b)) return 0;\n\treturn dist(a,b[0]);\n}\n\nReal dist(const Segment &s,const Point &p){\n\tif(sign(dot(s[1]-s[0],p-s[0]))==-1) return dist(s[0],p);\n\tif(sign(dot(s[0]-s[1],p-s[1]))==-1) return dist(s[1],p);\n\treturn dist(Line(s[0],s[1]),p);\n}\n\nReal dist(const Segment &a,const Segment &b){\n\tif(intersect(a,b)) return 0;\n\treturn min({dist(a,b[0]),dist(a,b[1]),dist(b,a[0]),dist(b,a[1])});\n}\n\nbool intersect(const Circle &a,const Circle &b){\n\treturn sign(dist(a.c,b.c)-(a.r+b.r)) <=0\n\t\t\t&& sign(dist(a.c,b.c)-abs(a.r-b.r)) >= 0;\n}\n\nbool intersect(const Circle &c,const Segment &s){\n\treturn sign(dist(s,c.c)-c.r)<=0;\n}\n\nbool intersect(const Circle &c,const Line &l){\n\treturn sign(dist(l,c.c)-c.r)<=0;\n}\n\nbool contain(const Circle &c,const Point &p){\n\treturn sign(dist(c.c,p)-c.r)<=0;\n}\n\nbool contain(const Polygon &P,const Point &p){\n\tbool res = false;\n\n\tfor(int i=0;i<P.size();++i){\n\t\tPoint v1=P[i]-p;\n\t\tPoint v2=P[(i+1)%P.size()]-p;\n\t\tif(v1.y>v2.y) swap(v1,v2);\n\n\t\tif(sign(cross(v1,v2))==0&&sign(dot(v1,v2))<=0){\n\t\t\treturn true;//on edge \n\t\t}\n\t\tif(sign(v1.y)<=0&&sign(v2.y)==1&&sign(cross(v1,v2))==1){\n\t\t\tres=!res;\n\t\t}\n\t}\n\treturn res;\n}\n\nPoint crosspoint(const Line &a,const Line &b){\n\tassert(intersect(a,b));\n\tconst Real crs = cross(a[1]-a[0],b[1]-b[0]);\n\tif(sign(crs) == 0) return a[0];\n\treturn b[0]+(b[1]-b[0])*(cross(a[1]-a[0],a[1]-b[0])/crs);\n}\n\n\n//??¬??¢?????????????????¨?????°?????????????????????Intersect?????????\nPoint crosspoint(const Segment &a,const Segment &b){\n\tassert(intersect(a,b));\n\tconst Real crs = cross(a[1]-a[0],b[1]-b[0]);\n\tif(sign(crs)==0){\n\t\tif(intersect(a,b[0])) return b[0];\n\t\tif(intersect(a,b[1])) return b[1];\n\t\tif(intersect(b,a[0])) return a[0];\n\t\treturn a[1];\n\t}\n\treturn b[0]+(b[1]-b[0])*(cross(a[1]-a[0],a[1]-b[0])/crs);\n}\n\nvector<Point> crosspoint(const Circle &c,const Line &l){\n\tconst Point p = project(l,c.c);\n\tconst Real h = dist(p,c.c);\n\n\tvector<Point> res;\n\tif(sign(h-c.r)==1){\n\t\t//nothing\n\t}else if(sign(h-c.r)==0){\n\t\tres.emplace_back(p);\t\n\t}else{\n\t\tconst Real b = sqrt(c.r*c.r-h*h);\n\t\tconst Point e = (l[1]-l[0])/abs(l[1]-l[0]);\n\t\tres.emplace_back(p+e*b);\n\t\tres.emplace_back(p-e*b);\n\t}\n\treturn res;\n}\n\nvector<Point> crosspoint(const Circle &a,const Circle &b){\n\tif(!intersect(a,b)) return vector<Point>();\n\n\tvector<Point> res;\n\tconst Real d = dist(a.c,b.c);\n\n\tif(sign(d-(a.r+b.r))==0){\n\t\tconst Point v = b.c - a.c;\n\t\tres.emplace_back(a.c + (v * (a.r /abs(v))));\n\t}else{\n\t\tconst Real theta = acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\t\tconst Real phi = angle(b.c-a.c);\n\t\tres.emplace_back(a.c+rotate(Point(a.r,0),phi+theta));\n\t\tres.emplace_back(a.c+rotate(Point(a.r,0),phi-theta));\n\t}\n\treturn res;\n}\n\nReal area(const Polygon &P){\n\tReal res = 0.0;\n\tfor(int i=0;i<P.size();++i){\n\t\tres+=cross(P[i],P[(i+1)%P.size()]);\n\t}\n\treturn abs(res) * 0.5;\n}\n\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tvector<Circle> circles;\n\t\tvector<Circle> ccircles;\n\t\trep(i,n){\n\t\t\tPoint p;\n\t\t\tcin >> p;\n\t\t\tcircles.push_back(Circle(p,1.0));\n\t\t}\n\n\t\trep(i,n) for(int j=i+1;j<n;j++){\n\t\t\tvector<Point> points = crosspoint(circles[i],circles[j]);\n\t\t\trep(k,points.size()){\n\t\t\t\tccircles.push_back(Circle(points[k],1.0));\n\t\t\t}\n\t\t}\n\n\t\tint ans=0;\n\t\tvector<Point> points;\n\n\t\trep(i,ccircles.size()){\n\t\t\tvector<Point> tmp;\n\t\t\tint cnt=0;\n\t\t\trep(j,n){\n\t\t\t\tif(contain(ccircles[i],circles[j].c)){\n\t\t\t\t\tcnt++;\t\n\t\t\t\t\ttmp.push_back(circles[j].c);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max(cnt,ans)!=ans){\n\t\t\t\tans=max(cnt,ans);\n\t\t\t\t//points=tmp;\t\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\n\n/* 幾何の基本 */\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n// -1 => out\n//  0 => on\n//  1 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nPolygon convex_cut(const Polygon &ps, Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n\t\t\tQ.push_back(is_ll(l, m));\n\t}\n\treturn Q;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\nvector<Point>ps;\n\nint check(Point& center) {\n\tint num = 0;\n\tfor (int i = 0; i < ps.size(); ++i) {\n\t\tif (abs(ps[i] - center) <= 1) {\n\t\t\tnum++;\n\t\t}\n\t}\n\treturn num;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tps.clear();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tlong double x, y; cin >> x >> y;\n\t\t\tps.push_back({ x,y });\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tif (abs(ps[i] - ps[j]) > 2)continue;\n\t\t\t\tLine l(ps[i], ps[j]);\n\t\t\t\tPoint center = (ps[i] + ps[j])*0.5l;\n\t\t\t\tPoint vec(imag(ps[i] - ps[j]), -real(ps[i] - ps[j]));\n\t\t\t\tlong double nl = sqrt(0.9999999 - norm(center - ps[i]));\n\t\t\t\tlong double oldl = abs(vec);\n\t\t\t\tvec *=nl / oldl;\n\t\t\t\tPoint checkcenter = center + vec;\n\t\t\t\tans = max(ans,check(checkcenter));\n\t\t\t\tcheckcenter = center - vec;\n\t\t\t\tans = max(ans, check(checkcenter));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\nusing P = complex<ld>;\nconst ld eps = 1e-8;\n\nint main()\n{\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<ld> x(N), y(N);\n\t\tvector<P> p(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tp[i] = P(x[i], y[i]);\n\t\t}\n\t\tvector<P> ko;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tif (norm(p[i] - p[j]) < 4.0 + eps) {\n\t\t\t\t\tauto d = p[i] - p[j];\n\t\t\t\t\tko.push_back(p[j] + (d * (ld)0.5) + d * P(0, 1) / abs(d) * sqrtl(1 - norm(d * (ld)0.5)));\n\t\t\t\t\tko.push_back(p[j] + (d * (ld)0.5) - d * P(0, 1) / abs(d) * sqrtl(1 - norm(d * (ld)0.5)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor (auto c : ko) {\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (norm(c - p[i]) < 1.0001 + eps) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = max(res, cnt);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\n#define FOR(i,b,n) for(int i=b;i<n;i++)\n#define RFOR(i,b,n) for(int i=n-1;i>=b;i--)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\n#define NCLR(mat) memset(mat, -1, sizeof(mat))\n\n#define EPS 0.00001\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define PI (acos(-1.0))\n#define POSARG(a) (arg((a)) > 0.0? arg((a)) : 2.0*PI + arg((a)))\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nint n;\n\nint solve(vector<P> vc)\n{\t\n\tint res = 1;\n\t\n\tFOR(j, 0, n)\n\t\tFOR(i, j+1, n)\n\t\t{\n\t\t\tint tmpp = 2;\n\t\t\tint tmpn = 2;\n\t\t\t\n\t\t\tif(abs(vc[j]-vc[i]) > 2.0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tdouble cs = abs(vc[j]-vc[i])/2.0, sn = sqrt(1.0-cs*cs);\t//線分IJと円の中心の距離\n\t\t\tP mid = (vc[j]+vc[i])/2.0;//線分IJの中点\n\t\t\tP nml = (vc[j]-vc[i])*P(0, 1);\n\t\t\tnml = nml/abs(nml);//線分IJの単位法線ベクトル\n\t\t\tP c1 = mid + nml*sn, c2 = mid - nml*sn;//円の中心2つ\n\t\t\t\t\t\t\n\t\t\tFOR(k, 0, n)\n\t\t\t{\t\n\t\t\t\tif( k != j && k != i )\n\t\t\t\t{\n\t\t\t\t\tif( abs(vc[k]-c1) < 1.0+EPS)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpp++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif( abs(vc[k]-c2) < 1.0+EPS)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpn++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tres = max(res, max(tmpp, tmpn));\n\t\t}\n\t\t\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tvector<P> vc = vector<P>();\n\t\t\n\t\tFOR(i, 0, n)\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tvc.push_back(P(x,y));\n\t\t}\n\n\t\tcout << solve(vc) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#define EPS 1e-10\n \nusing namespace std;\ntypedef long long int ll;\n \ndouble add(double a, double b){\n\tif(abs(a+b)<EPS*(abs(a)+abs(b))) return 0;\n\treturn a+b;\n}\n \nstruct P{\n\tdouble x, y;\n\tP() {}\n\tP(double x, double y): x(x), y(y){\n\t}\n\tP operator+ (P p){\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\tP operator- (P p){\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tP operator* (double d){\n\t\treturn P(x*d, y*d);\n\t}\n\tdouble dot(P p){\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\tdouble det(P p){\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n};\n\nint main()\n{\n\twhile(1){\n      int n;\n      scanf(\"%d\", &n);\n      if(n==0) return 0;\n      P p[300];\n      for(int i=0; i<n; i++){\n        double x, y;\n        scanf(\"%lf %lf\", &x, &y);\n        p[i]=P(x, y);\n      }\n      \n      int ans=1;\n      for(int i=0; i<n; i++){\n        for(int j=i+1; j<n; j++){\n          double d=sqrt((p[i]-p[j]).dot(p[i]-p[j]));\n          if(d>2.0) continue;\n          P q;\n          q.x=-(p[i]-p[j]).y;\n          q.y=(p[i]-p[j]).x;\n          double t=sqrt((1-((p[i]-p[j]).dot(p[i]-p[j]))/4.0)/(q.dot(q)));\n          P r1=(p[i]+p[j])*0.5+q*t;\n          P r2=(p[i]+p[j])*0.5-q*t;\n          int c=2;\n          for(int k=0; k<n; k++){\n            if(k==i || k==j) continue;\n            if(sqrt((p[k]-r1).dot(p[k]-r1))<1.0) c++;\n          }\n          if(ans<c) ans=c;\n          c=2;\n          for(int k=0; k<n; k++){\n            if(k==i || k==j) continue;\n            if(sqrt((p[k]-r2).dot(p[k]-r2))<1.0) c++;\n          }\n          if(ans<c) ans=c;\n        }\n      }\n      printf(\"%d\\n\", ans);\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define MKP make_pair\n#define fi first\n#define se second\ntypedef pair<int, int> pii;\n\nconstexpr int MOD = 1e9 + 7;\nconstexpr int MAX_N = 205;\nconstexpr int MAX_W = 10005;\nconstexpr int INF = 1LL << 60;\n\n/* 基本要素 */\n\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n\n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n\nint n;\nvector<P> v;\n\nbool solve() {\n    v.clear();\n    cin >> n;\n    if (!n) return false;\n\n    for (int i = 0; i < n; ++i) {\n        double x, y;\n        cin >> x >> y;\n        v.emplace_back(P(x, y));\n    }\n\n    int res = 1;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            auto crs = crosspointCC(v[i], 1.0, v[j], 1.0);\n            for (int k = 0; k < crs.size(); ++k) {\n                int cnt = 0;\n                for (int l = 0; l < n; ++l) {\n                    double dist = abs(crs[k] - v[l]);\n                    if (dist <= 1.0 + EPS) cnt++;\n                }\n\n                res = max(res, cnt);\n            }\n        }\n    }\n\n    cout << res << endl;\n\n    return true;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <complex>\n\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,n) loop(i,0,n)\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef complex<double> vec;\n\ndouble const pi = acos(-1);\ndouble const eps = 1e-5;\n\nint main(){\n    int n;\n    while (cin >> n && n){\n        vector<vec> v(n);\n        rep(i, n){\n            double x, y; cin >> x >> y;\n            vec p(x, y);\n            v[i] = p;\n        }\n\n        if (n == 1) {\n            puts(\"1\");\n            continue;\n        }\n        if (n == 2){\n            if (abs(v[0] - v[1]) < 2 - eps) {\n                puts(\"2\"); \n            }\n            else{\n                puts(\"1\"); \n            }\n            continue;\n        }\n\n        int ans = 0;\n        rep(i, n)rep(j, i){\n            double d = abs(v[i] - v[j]);\n            if (d - eps > 2) continue;\n            double h = 1 - d*d / 4;\n            vec c1 = polar(h, arg(v[i] - v[j]) + pi / 2) + (v[i] + v[j]) / 2.;\n            vec c2 = polar(h, arg(v[i] - v[j]) - pi / 2) + (v[i] + v[j]) / 2.;\n            int a1 = 0, a2 = 0;\n            rep(k, n){\n                if (abs(c1 - v[k]) <= 1 - eps) a1++;\n                if (abs(c2 - v[k]) <= 1 - eps) a2++;\n            }\n            ans = max(ans, a1);\n            ans = max(ans, a2);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <map>\n\nint n;\ndouble x[512];\ndouble y[512];\n\nvoid init() {\n  for(int i = 0; i < (int)512; ++i) {\n    x[i] = y[i] = 0.0;\n  }\n} \n\ninline double Heron(double a, double b, double c) {\n  double s = (a + b + c) / 2;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\nclass solve_ {\npublic:\n  int operator() (void) {\n    int res = 1;\n    for(int i = 0; i < (int)n; ++i) {\n      for(int j = 0; j < (int)i; ++j) {\n        res = std::max(res, CountPoints(i, j));\n      }\n    }\n    return res;\n  }\n  int CountPoints(int i, int j) {\n    double dx = x[i] - x[j];\n    double dy = y[i] - y[j];\n    double dist = sqrt(dx * dx + dy * dy);\n    if( dist > 2.0 ) return 0;\n    auto t1 = std::pair<double, double>((x[i] + x[j]) / 2, (y[i] + y[j]) / 2);\n    auto t2 = std::pair<double, double>(dx / dist, dy / dist);\n    double h = 2 * Heron(1, 1, dist) / dist;\n    auto t3 = std::pair<double, double>(t2.first * h, t2.second * h);\n    auto c1 = std::pair<double, double>(t1.first + t3.second, t1.second - t3.first);\n    auto c2 = std::pair<double, double>(t1.first - t3.second, t1.second + t3.first);\n    int count1 = 0;\n    int count2 = 0;\n    {\n      double cx = c1.first, cy = c1.second;\n      for(int k = 0; k < (int)n; ++k) {\n        if( k == i or k == j ) continue;\n        if( (cx - x[k]) * (cx - x[k]) + (cy - y[k]) * (cy - y[k]) <= 1 ) {\n          count1 += 1;\n        }\n      }\n    }\n    {\n      double cx = c2.first, cy = c2.second;\n      for(int k = 0; k < (int)n; ++k) {\n        if( k == i or k == j ) continue;\n        if( (cx - x[k]) * (cx - x[k]) + (cy - y[k]) * (cy - y[k]) <= 1 ) {\n          count2 += 1;\n        }\n      }\n    }\n    int res = std::max(count1, count2) + 2;\n    //printf(\"(%d, %d) -> %d\\n\", i, j, res);\n    return res;\n  }\n};\nsolve_ solve;\n\nint main() {\n  for(;;) {\n    init();\n    scanf(\"%d\", &n);\n    if( n == 0 ) break;\n    for(int i = 0; i < (int)n; ++i) {\n      scanf(\"%lf %lf\", &x[i], &y[i]);\n    }\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\nconst double EPS = 1e-8;\ntypedef pair<double, double> pt;\n#define x first\n#define y second\n\npt operator-(pt a, pt b) {\n  return pt(a.x - b.x, a.y - b.y);\n}\n\nbool zero(double x) {\n  return fabs(x) <= EPS;\n}\n\ndouble sq(double a) { return a * a; }\n\ndouble dist(pt p, pt q) {\n  return sqrt(sq(p.x - q.x) + sq(p.y - q.y));\n}\n\npt midpoint(pt p1, pt p2){\n    double midx = (p1.x+p2.x)/2;\n    double midy = (p1.y+p2.y)/2;\n    return make_pair(midx, midy);\n}\n\nint get_max_points(pt centre, vector<pt> points){\n\n    int count = 0;\n    for (int i = 0; i < points.size(); i++){\n        pt current = points[i];\n        double num = sq(current.x - centre.x) + sq(current.y - centre.y);\n        // cout << num << endl;\n        // cout << fabs(num - 1) << endl;\n        if (sqrt(num) < 1+EPS) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint find_max_points(vector<pt> points){\n    // for every pair of two points, create a cricle and check num points in circle\n\n    int max_points = 1;\n    for (int i = 0; i < points.size(); ++i){\n        pt p1 = points[i];\n        for (int j = i+1; j < points.size(); ++j){\n            pt p2 = points[j];\n\n            pt mid = midpoint(p1, p2);\n            double q = dist(p1, p2);\n\n            double x1 = mid.x + sqrt(1-sq(q/2))*(p1.y-p2.y)/q;\n            double y1 = mid.y + sqrt(1-sq(q/2))*(p2.x-p1.x)/q;\n            pt c1(x1, y1);\n            int m = get_max_points(c1, points);\n            max_points = max(m, max_points);\n            // cout << mid.x << \" \" << mid.y << endl;\n            // int m = get_max_points(mid, points);\n            double x2 = mid.x - sqrt(1-sq(q/2))*(p1.y-p2.y)/q;\n            double y2 = mid.y - sqrt(1-sq(q/2))*(p2.x-p1.x)/q;\n            pt c2(x1, x2);\n            m = get_max_points(c2, points);\n\n            max_points = max(max_points, m);\n        }\n    }\n    // cout << max_points \n    return max_points;\n}\n\nint main(){\n\n    int n;\n\n    while (1){\n        cin >> n;\n        if (n == 0) break;\n        vector<pt> points;\n        for (int i = 0; i < n; ++i){\n            double x, y;\n            cin >> x >> y;\n            points.push_back(make_pair(x, y));\n        }\n        cout << find_max_points(points) << endl;\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\nclass Line {\npublic:\n\tPoint a, b;\n};\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2 * d);\n\tld dfr = c1.r*c1.r - rc * rc;\n\tif (abs(dfr) < eps)dfr = 0.0;\n\tif (dfr < 0.0)return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0)res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\nld dis(Point x, Point y) {\n\treturn sqrt(dot(y - x, y - x));\n}\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tPoint a[300];\n\t\trep(i, n) {\n\t\t\tld x, y; cin >> x >> y; a[i] = { x,y };\n\t\t}\n\t\tint ma = 0;\n\t\trep(i, n) {\n\t\t\tRep(j, i + 1, n) {\n\t\t\t\tCircle s = { a[i],1.0 };\n\t\t\t\tCircle t = { a[j],1.0 };\n\t\t\t\tvector<Point> v = is_cc(s, t);\n\t\t\t\trep(l, (int)v.size()) {\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\trep(k, n) {\n\t\t\t\t\t\tif (dis(a[k], v[l]) <= 1.0 + eps)cnt++;\n\t\t\t\t\t}\n\t\t\t\t\tma = max(ma, cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ma << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#define MAX 10000\n#include<complex>\nusing namespace std;\ntypedef complex<double> P;\nint main(){\n\tint n;\n\tdouble p[MAX],q[MAX];\n\twhile(cin>>n,n){\n\t\tP tab[MAX];\n\t\tint ans=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>p[i]>>q[i];\n\t\t\ttab[i]=P(p[i],q[i]);\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(   norm(tab[i]-tab[j]) >4.0){\n\t\t\t\t//cout<<88<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tP temp=(tab[i]-tab[j])*sqrt(1-(((p[i]-p[j])*(p[i]-p[j])+(q[i]-q[j])*(q[i]-q[j]))*0.25))/abs(tab[i]-tab[j]);\n\t\t\tP pre=(tab[i]+tab[j])*0.5+temp*P(0,1);\n\t\t\tint r=2;\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(norm(tab[k]-pre)<=1.0&&(i!=k&&j!=k))\n\t\t\t\tr++;\n\t\t\t}\n\t\t\tans=max(ans,r);\n\t\t\ttemp=(tab[i]-tab[j])*sqrt(1-(   ( (p[i]-p[j])*(p[i]-p[j]) + (q[i]-q[j])*(q[i]-q[j]) )*0.25))/abs(tab[i]-tab[j]);\n\t\t\tpre=(tab[i]+tab[j])*0.5+temp*P(0,1)*P(0,1)*P(0,1);\n\t\t\tr=2;\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(norm(tab[k]-pre)<=1.0&&(i!=k&&j!=k))\n\t\t\t\tr++;\n\t\t\t}\n\t\t\tans=max(ans,r);\n\t\t\t\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 1e-10\n#define equals(a,b) (fabs( (a) - (b) )< EPS )\n// c++ 11,14\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\ntypedef struct point{\n\tdouble x,y;\n\tpoint(){};\n\tpoint(double x ,double y):x(x),y(y){};\n\tpoint operator + (point &p){ return point(x+p.x,y+p.y);\t}\n\tpoint operator - (point &p){ return point(x-p.x,y-p.y);\t}\n\tpoint operator * (point &p){ return point(x*p.x-y*p.y,x*p.y+y*p.x) ;}\n\tpoint operator * (double a){ return point(x*a,y*a);\t}\n\tpoint operator / (double a){ return point(x/a,y/a);\t}\n\t\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x+y*y; }\n\t\n\tbool operator < (const point &p) const { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (const point &p) const { return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS; }\n}point;\n\ndouble abs(point a){return a.abs();}\ndouble norm(point a){return a.norm();}\ntypedef struct circle{\n\tpoint p;\n\tdouble r;\n} circle;\ntypedef complex<double> C;\ntypedef struct { \n\tpoint s,e;\n} line;\n\nC convert(point a){ return C(a.x,a.y); }\npoint convert( C a){ return point(a.real(),a.imag() );}\ndouble dot(point a,point b){ return a.x*b.x+a.y*b.y ; } //内積　a・b\ndouble cross(point a,point b){ return a.x*b.y - a.y*b.x ; }//外積(z成分)　a×b\npoint vec(line l){return l.e-l.s;}\nline make(point s,point e){\n\tline res; res.s=s; res.e=e;\n\treturn res;\n}\ncircle make(point p,double r){ circle c;\n\tc.p = p ;\n\tc.r = r;\n\treturn c;\n}\npoint make(){ \n\tdouble x,y; cin>>x>>y;\n       \treturn point(x,y);\n}\nline lmake(){\n\tpoint p0=make();\n\tpoint p1=make();\n\treturn make(p0,p1);\n}\n//直交\nbool isorthogonal(point a,point b){ return equals(dot(a,b), 0.0); }\nbool isorthogonal(line l1,line l2){ return isorthogonal(vec(l1),vec(l2)); }\n//平行\nbool isparallel(point a,point b){ return equals(cross(a,b),0.0); }\nbool isparallel(line l1,line l2){ return isparallel(vec(l1),vec(l2)); }\n//射影\npoint project(line s,point p){\n\tpoint base = vec(s);\n\tdouble r=dot(p-s.s,base)/base.norm();\n\tbase = base*r;\n\treturn s.s+base;\n}\n//反射\npoint reflect(line l,point p){\n\tpoint tmp=project(l,p)-p;\n\ttmp= tmp*2.0;\n\treturn p+tmp;\n\n}\n//交差判定\n\nint ccw(point p0,point p1,point p2){\n\tpoint a = p1-p0;\n\tpoint b = p2-p0;\nif(cross(a,b)>EPS) return 1;//counter_clockwise\nif(cross(a,b)<-EPS) return -1;//clockwise\nif(dot(a,b)<-EPS)return 2;//online_back\nif(a.norm()<b.norm() ) return -2;//online_front\nreturn 0;//on_segment\n}\n// circle_versino\nint ccw(circle c0,circle c1){\n\tdouble  d = abs(c0.p-c1.p);\n\tdouble r0 = c0.r,r1 = c1.r;\n\t\n\t//c0in c1\n\tif(d<r1-r0)return -2;\n\t//c1 in c0\n\tif(d<r0-r1)return 2;\n\t//c0 cross c1\n\tif(abs(r0-r1)<=d&&d<=r0+r1)return 1;\n\t//c0 not cross c1\n\treturn 0;\n\n}\n\n// line p1-p2 line p3-p4\nbool intersect(point p1,point p2,point p3,point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); \n}\n// line l1,l2\nbool intersect(line l1,line l2){ return intersect(l1.s,l1.e,l2.s,l2.e); }\n\n\n//距離\n//point-point\ndouble distance(point a,point b){ return abs(a-b); }\n//point-line(直線）\ndouble distance2(line l,point p){\n\treturn abs(cross(vec(l),p-l.s)/abs(l.e-l.s));\n}\n//point-line(線分)\ndouble distance(line l,point p){\n\tif( dot(vec(l),p-l.s) <0.0 ) return abs(p-l.s);\n\tif( dot(l.s-l.e,p-l.e) <0.0 ) return abs(p-l.e);\n\treturn distance2(l,p);\n}\n//line-line\ndouble distance(line l1,line l2){\n\tif(intersect(l1,l2))\treturn 0.0;\n\treturn min(min(distance(l1,l2.s),distance(l1,l2.e) ), min(distance(l2,l1.s),distance(l2,l1.e) ) );\n}\n\n//交点\npoint crosspoint(line l1,line l2){\n\tpoint base = vec(l2);\n\tdouble d1 = abs(cross(base,l1.s-l2.s) );\n\tdouble d2 = abs(cross(base,l1.e-l2.s) );\n\tdouble t = d1/(d1+d2);\n\tpoint tmp = vec(l1)*t;\n\treturn l1.s+tmp;\n}\n//面積\ndouble area(vector<point> p,int n){\n\tdouble ans=0.0;\n\tfor(int i=0;i<n-2;i++){\n\tans+=cross(p[i+2]-p[0],p[i+1]-p[0]);\n\t}\n\treturn abs(ans)/2;\n}\ndouble area(vector<point> p){\n\treturn area(p,p.size());\n}\n//内包\nint contains(vector<point> g,point p){\nint n=g.size();\nbool flag=false;\n\tfor(int i=0;i<n;i++){\n\t\tpoint a=g[i]-p, b=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b) )<EPS && dot(a,b) <EPS)return 1;\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) flag=!flag;\n\t}\n\treturn (flag? 2:0);\n}\n//凸包\nvector<point> andrewscan(vector<point> s){\n\tvector<point> u,l;\n\tif(s.size() <3) return s;\n\tsort(s.begin(),s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\n\tfor(int i=2;i<s.size();i++){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor(int i=s.size()-3;i>=0;i--){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n}\n//直径\ndouble convex_diameter(vector<point> g){\n\tint n=g.size();\n\tint is=0,js=0;\n\tfor(int i=1;i<n;i++){\n\t\tif(g[is].y < g[i].y)is =i;\n\t\tif(g[i].y < g[js].y)js=i;\n\t}\n\tdouble maxd = abs((g[is]-g[js]));\n\tint i,mi,j,mj;\n\ti=mi=is;\n\tj=mj=js;\n\tdo{\n\t\tif(cross(g[(i+1)%n]-g[i],g[(j+1)%n]-g[j])>=0)j=(j+1)%n;\n\t\telse i=(i+1)%n;\n\t\tif(abs(g[i]-g[j])>maxd){\n\t\t\t//cerr<<i<<' '<<j<<' '<<norm(g[i]-g[j])<<endl;\n\t\t\tmaxd =abs(g[i]-g[j]);\n\t\t\tmi=i;mj=j;\n\t\t}\n\t}while(i!=is||j!=js);\n\treturn maxd;\n}\n// 90度　回転　反時計周り\npoint roll_l(point a){\n\treturn point(-a.y,a.x);\n}\t\n\n//2点を通る半径rの円を返す  hanten = 1 or -1\ncircle make(point a,point b,double r,int hanten){\n\tline l1  = make(a,b);\n\tpoint m = a+b;\n\tm = m/2.0;\n\tpoint  e = roll_l(vec(l1) );\n\te = e/e.abs();\n\tdouble d = abs(vec(l1) )/2.0;\n\tdouble lng = sqrt(r*r-d*d)*(double)hanten;\n\te = e*lng;\n\t\n\tpoint  o =m+e;\t//中心\n\treturn make(o,r);\t\n}\n// 円の中にあるか\nbool is_in(point p,circle c){\n\tpoint o = c.p;\n\tif(abs(p-o) <= c.r+EPS) return true;\n\telse return false;\n}\n//円に入る点の数\nint in_circle(vector<point> &g,circle c){\n\tint cnt = 0;\n\tfor(int i=0;i<g.size();i++){\n\t\tif(is_in(g[i],c) ){\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\nint solve(vector<point> &g){\n\tint n = g.size();\n\tint res = 0;\n\tdouble r = 1.0;\n\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tpoint a = g[i];\n\t\t\t\tpoint b = g[j];\n\t\t\t\tcircle c  = make(a,b,r,1);\n\t\t\t\tres  = max(res,in_circle(g,c) );\n\t\t\t\tc = make(a,b,r , -1);\n\t\t\t\tres  = max(res,in_circle(g,c) );\n\t\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tvector<point> g(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tg[i] = make();\n\t\t}\n\t\tcout<<solve(g)<<endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<math.h>\n\nusing namespace std;\ntypedef pair<double, double> P;\n\nint N;\ndouble X[300], Y[300];\nP d[300];\n\nP add(P p1, P p2) {\n  return P(p1.first + p2.first, p1.second + p2.second);\n}\n\nP minas(P p1, P p2) {\n  return P(p1.first - p2.first, p1.second - p2.second);\n}\n\nP mul(P p, double c) {\n  return P(p.first * c, p.second * c);\n}\n\nP ave(P p1, P p2) {\n  return P((p1.first + p2.first) / 2, (p1.second + p2.second) / 2);\n}\n\nvoid printP(P p) {\n  printf(\"P:(%f, %f)\\n\", p.first, p.second);\n}\n\ndouble square(P p) {\n  return p.first * p.first + p.second * p.second;\n}\n\ndouble size(P p) {\n  return sqrt(square(p));\n}\n\nint count(P p) {\n  // printP(p);\n  int counter = 0;\n  for (int i = 0; i < N; i++) {\n    if (square(minas(p, d[i])) <= 1.00001) counter++;\n  }\n  return counter;\n}\n\nint check(int i, int j) {\n  if (square(minas(d[i], d[j])) >= 4.0001) return 0;\n  int ans = 0;\n  P average = ave(d[i], d[j]);\n  P dir = mul(minas(d[i], d[j]), 0.5);\n  // printP(average);\n  double s = sqrt(1.0 - square(dir));\n  // printf(\"!!!!!!%f\\n\",s);\n  P dir1 = P((Y[i] - Y[j]), - (X[i] - X[j]));\n  //printf(\"!!!!!!%f\\n\",size(dir1));\n  double r = s / size(dir1);\n  P d1 = add(average, mul(dir1, r));\n  P d2 = add(average, mul(dir1, -r));\n  return max(count(d1), count(d2));\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &N);\n    if (N == 0) break;\n    for (int i = 0; i < N; i++) scanf(\"%lf%lf\", &X[i], &Y[i]), d[i] = P(X[i], Y[i]);\n    int ans = 0;\n    for (int i = 0; i < N; i++)\n      for (int j = 0; j < i; j++)\n        ans = max(ans, check(i, j));\n    printf(\"%d\\n\", ans);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n\n#define EPS 1e-8\n\ntypedef complex<double> P;\n\ndouble dot(P a,P b){\n\treturn real(a)*real(b)+imag(a)*imag(b);\n}\n\ndouble cross(P a,P b){\n\treturn real(a)*imag(b)-imag(a)*real(b);\n}\n\ndouble sq(double x){\n\treturn x*x;\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<P> v(n);\n\t\trep(i,n){\n\t\t\tdouble a,b;\n\t\t\tcin>>a>>b;\n\t\t\tv[i]=P(a,b);\n\t\t}\n\t\tint ans = 1;\n\t\trep(i,n){\n\t\t\trep(j,i){\n\t\t\t\t// cout<<i<<\" \"<<j<<\" \"<<abs(v[j]-v[i])<<endl;\n\t\t\t\tif(abs(v[j]-v[i])-2>EPS) continue;\n\t\t\t\tP c = v[j]-v[i];\n\t\t\t\tP n1 = (c*P(0,+1))/abs(c);\n\t\t\t\tP n2 = (c*P(0,-1))/abs(c);\n\t\t\t\tdouble d = sqrt(1-sq(abs(v[j]-v[i])/2));\n\t\t\t\t// cout<<\"d \"<<d<<endl;\n\t\t\t\tn1*=d;\n\t\t\t\tn2*=d;\n\t\t\t\tn1 += (v[j]-v[i])/2.0;\n\t\t\t\tn2 += (v[j]-v[i])/2.0;\n\t\t\t\t// cout<<\"n1 \"<<n1.real()<<\" \"<<n1.imag()<<endl;\n\t\t\t\tint tmp1=0;\n\t\t\t\tint tmp2=0;\n\t\t\t\trep(k,n){\n\t\t\t\t\tif(1-abs(n1-v[k]+v[i])>-EPS) tmp1++;\n\t\t\t\t\tif(1-abs(n2-v[k]+v[i])>-EPS) tmp2++;\n\t\t\t\t}\n\t\t\t\tans=max(ans,tmp1);\n\t\t\t\tans=max(ans,tmp2);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t\t// break;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x_ = 0.0, double y_ = 0.0) : x(x_), y(y_) {}\n    Point(const Point& p) : x(p.x), y(p.y) {}\n\n    Point& operator=(const Point& p) {\n        x = p.x;\n        y = p.y;\n        return *this;\n    }\n\n    double det(const Point& p) {\n        return x * p.y - y * p.x;\n    }\n\n    Point nrm() {\n        Point ret;\n        double n = length();\n        ret.x = x / n;\n        ret.y = y / n;\n        return ret;\n    }\n\n    double length() {\n        return sqrt(x * x + y * y);\n    }\n};\n\nPoint operator+(const Point& p1, const Point& p2) {\n    return Point(p1.x + p2.x, p1.y + p2.y);\n}\n\nPoint operator-(const Point& p1, const Point& p2) {\n    return Point(p1.x - p2.x, p1.y - p2.y);\n}\n\nPoint operator*(const Point& p1, double s) {\n    return Point(p1.x * s, p1.y * s);\n}\n\nPoint operator/(const Point& p1, double s) {\n    return Point(p1.x / s, p1.y / s);\n}\n\nPoint calcCenter(const Point& p1, const Point& p2, const Point& p3) {\n    double a = (p1 - p2).length();\n    double b = (p2 - p3).length();\n    double c = (p3 - p1).length();\n    double A = a * a;\n    double B = b * b;\n    double C = c * c;\n    double S = 0.5 * std::abs((p2 - p1).det(p3 - p1));\n    Point cent = (p1 * (A * (B + C - A)) + p2 * (B * (C + A - B)) + p3 * (C * (A + B - C))) / (16.0 * S * S);\n    return p1 + (cent - p1).nrm();\n}\n\nvoid solve(const std::vector<Point>& pts) {\n    int n = (int)pts.size();\n    int maxval = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int k = j + 1; k < n; k++) {\n                Point cnt = calcCenter(pts[i], pts[j], pts[k]);\n                int s = 0;\n                for (int l = 0; l < n; l++) {\n                    if ((cnt - pts[l]).length() <= 1.0) {\n                        s++;\n                    }\n                }\n\n                if (maxval < s) {\n                    maxval = s;\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\", maxval);\n}\n\nint main(int argc, char** argv) {\n    int n;\n    double x, y;\n    while (cin >> n) {\n        if (n == 0) break;\n\n        vector<Point> pts;\n        for (int i = 0; i < n; i++) {\n            cin >> x >> y;\n            pts.push_back(Point(x, y));\n        }\n        solve(pts);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nconst double eps=1e-8;\ntypedef pair<double,double> p;\n\ndouble dist(p a, p b)\n{\n    return sqrt((a.fi-b.fi)*(a.fi-b.fi)+(a.se-b.se)*(a.se-b.se));\n}\n\ndouble size(p a)\n{\n    return sqrt(a.fi*a.fi+a.se*a.se);\n}\n\nint main()\n{\n    int n;\n    while(cin >>n,n)\n    {\n        vector<p> v(n);\n        rep(i,n) scanf(\" %lf %lf\", &v[i].fi, &v[i].se);\n\n        int ans=0;\n        //select 2 points\n        rep(i,n)rep(j,i)\n        {\n            double d=dist(v[i],v[j]);\n            if(d>2.0) continue;\n\n            double r=sqrt(1.0 - (d*d/4.0));\n\n            double X=v[j].fi-v[i].fi, Y=v[j].se-v[i].se;\n\n            p v1=p(X,Y);\n            double v1size=size(v1);\n            v1.fi/=v1size; v1.se/=v1size;\n            v1.fi*=d/2; v1.se*=d/2;\n\n            p v2;\n            double v2size;\n            p c;\n\n            //2 candidate for center of circle\n            //first\n            int ct=0;\n            v2=p(-Y,X);\n            v2size=size(v2);\n            v2.fi/=v2size; v2.se/=v2size;\n            v2.fi*=r; v2.se*=r;\n\n            c.fi=v[i].fi+v1.fi+v2.fi; c.se=v[i].se+v1.se+v2.se;\n            assert(dist(c,v[i]));\n            rep(k,n)\n            {\n                if(k==i || k==j) ++ct;\n                else\n                {\n                    if(dist(c,v[k])<1.0) ++ct;\n                }\n            }\n            ans=max(ans,ct);\n\n            //second\n            ct=0;\n            v2=p(Y,-X);\n            v2size=size(v2);\n            v2.fi/=v2size; v2.se/=v2size;\n            v2.fi*=r; v2.se*=r;\n\n            c.fi=v[i].fi+v1.fi+v2.fi; c.se=v[i].se+v1.se+v2.se;\n            assert(dist(c,v[i]));\n            rep(k,n)\n            {\n                if(k==i || k==j) ++ct;\n                else\n                {\n                    if(dist(c,v[k])<1.0) ++ct;\n                }\n            }\n            ans=max(ans,ct);\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS (1e-6)\n\n\nvoid calc(double x1,double y1,double x2,double y2,double *c_x1,double *c_y1,double *c_x2,double *c_y2){\n  double midx,midy,hox,hoy,dx,dy,dis;\n  midx = (x1+x2) / 2.0 , midy = (y1+y2) / 2.0;\n  dx = x1-x2 , dy = y1-y2;\n  dis = sqrt(1 - pow(x1-midx,2.0) - pow(y1-midy,2.0));\n  hox = sqrt(pow(dy,2.0) / (pow(dy,2.0) + pow(dx,2.0)));\n  hoy = hox * (-1.0) * (dx / dy);\n  *c_x1 = midx + hox*dis,*c_y1 = midy + hoy*dis;\n  *c_x2 = midx - hox*dis,*c_y2 = midy - hoy*dis;\n}\n\nint main(){\n  int N;\n\n  while(cin >> N){\n    double x[300],y[300],c_x1,c_y1,c_x2,c_y2;\n    int count,m;\n    m = 0;\n    if(!(N)) break;\n    for(int i=0;i<N;i++) cin >> x[i] >> y[i];\n\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n        if(i == j) continue;\n        if(sqrt((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j])) > 2.0 + EPS  ) continue;\n        count = 2;\n        calc(x[i],y[i],x[j],y[j],&c_x1,&c_y1,&c_x2,&c_y2);\n        for(int k=0;k<N;k++){\n          if(k == i || k == j) continue;\n          if((x[k] - c_x1)*(x[k] - c_x1) + (y[k] - c_y1)*(y[k] - c_y1) < 1.0 + EPS  ) count++;\n        }\n        if(m < count) m = count;\n        count = 2;\n        for(int k=0;k<N;k++){\n          if(k == i || k == j) continue;\n          if((x[k] - c_x2)*(x[k] - c_x2) + (y[k] - c_y2)*(y[k] - c_y2) < 1.0 + EPS  ) count++;\n        }\n        if(m < count) m = count;\n      }\n    }\n\n    printf(\"%d\\n\",m);\n  }\n\n  return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst long double eps=1e-3;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        vector<long double> xs(n),ys(n);\n        rep(i,0,n) cin >> xs[i] >> ys[i];\n\n        auto count=[&](const long double x,const long double y){\n            int res=0;\n            rep(i,0,n) if((xs[i]-x)*(xs[i]-x)+(ys[i]-y)*(ys[i]-y)<=1+eps) ++res;\n            return res;\n        };\n\n        int ans=0;\n        rep(i,0,2001){\n            const long double y=10.*i/2000;\n            rep(j,0,n){\n                const long double tmp=1-(ys[j]-y)*(ys[j]-y);\n                if(tmp<0) continue;\n                const long double x1=xs[j]-sqrtl(tmp),x2=xs[j]+sqrt(tmp);\n                ans=max({ans,count(x1,y),count(x2,y)});\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n\n\n\n\nstruct Point;\nstruct Circle;\nstruct Angle;\nstruct Vector;\n\n\nPoint operator+(const Point& p, const Vector& v);\nPoint operator+(const Vector& v, const Point& p);\nVector operator-(const Point& to, const Point& from);\nVector operator*(const Vector& v, const double scala);\nVector operator*(const double scala, const Vector& v);\nAngle operator+(const Angle& a, const Angle& b);\nAngle operator-(const Angle& a, const Angle& b);\n\nstruct Point {\n\tdouble x, y;\n\tdouble distance_from(const Point& p) const;\n};\nstruct Circle {\n\tPoint center;\n\tdouble radius;\n\tbool contains(const Point& p) const;\n};\nstruct Angle {\n\tdouble sin, cos;\n\tstatic Angle from_cos(const double cos);\n\tAngle operator-() const;\n};\nstruct Vector {\n\tdouble dx, dy;\n\tVector rotate(const Angle& angle) const;\n\tdouble length() const;\n};\n\nint main() {\n\twhile (true) {\n\t\tint n; std::cin >> n; if (n == 0) break;\n\t\tstd::vector<Point> points(n); for (auto& p : points) std::cin >> p.x >> p.y;\n\t\tint max_covered_point = 1;\n\t\tfor (auto i = 1; i < n; ++i) {\n\t\t\tconst auto to = points[i];\n\t\t\tfor (auto j = 0; j < i; ++j) if (to.distance_from(points[j]) <= 2) {\n\t\t\t\tconst auto from = points[j];\n\t\t\t\tconst auto angle = Angle::from_cos(to.distance_from(from) / 2);\n\t\t\t\tconst auto vec = (to - from) * (1 / from.distance_from(to));\n\t\t\t\tconst auto circle_a = Circle{ from + vec.rotate(angle), 1 };\n\t\t\t\tconst auto circle_b = Circle{ from + vec.rotate(-angle), 1 };\n\t\t\t\tint count_a = 2, count_b = 2;\n\t\t\t\tfor (auto k = 0; k < n; ++k) if (k != i && k != j) {\n\t\t\t\t\tif (circle_a.contains(points[k])) ++count_a;\n\t\t\t\t\tif (circle_b.contains(points[k])) ++count_b;\n\t\t\t\t}\n\t\t\t\tmax_covered_point = std::max({ max_covered_point, count_a, count_b });\n\t\t\t}\n\t\t}\n\t\tstd::cout << max_covered_point << '\\n';\n\t}\n}\nVector Vector::rotate(const Angle& angle) const\n{\n\treturn Vector{ angle.cos * dx - angle.sin * dy, angle.sin * dx + angle.cos * dy };\n}\n\ndouble Vector::length() const\n{\n\treturn std::sqrt(dx * dx + dy * dy);\n}\n\nPoint operator+(const Point& p, const Vector& v)\n{\n\treturn Point{ p.x + v.dx, p.y + v.dy };\n}\n\nPoint operator+(const Vector& v, const Point& p)\n{\n\treturn Point{ p.x + v.dx, p.y + v.dy };\n}\n\nVector operator-(const Point& to, const Point& from)\n{\n\treturn Vector{ to.x - from.x, to.y - from.y };\n}\n\nVector operator*(const Vector& v, const double scala)\n{\n\treturn Vector{ v.dx * scala, v.dy * scala };\n}\n\nVector operator*(const double scala, const Vector& v)\n{\n\treturn Vector{ v.dx * scala, v.dy * scala };\n}\n\nAngle operator+(const Angle& a, const Angle& b)\n{\n\treturn Angle{ a.sin * b.cos + a.cos * b.sin, a.cos * b.cos - a.sin * b.sin };\n}\n\nAngle operator-(const Angle& a, const Angle& b)\n{\n\treturn Angle{ a.sin * b.cos - a.cos * b.sin, a.cos * b.cos + a.sin * b.sin };\n}\n\ndouble Point::distance_from(const Point& p) const\n{\n\treturn (*this - p).length();\n}\n\nbool Circle::contains(const Point& p) const\n{\n\treturn center.distance_from(p) <= radius;\n}\n\nAngle Angle::from_cos(const double cos)\n{\n\treturn Angle{ std::sqrt(1 - cos * cos), cos };\n}\n\nAngle Angle::operator-() const\n{\n\treturn Angle{ -sin, cos };\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-6\nusing namespace std;\nusing p = complex<double>;\n\nint n;\nvector<p> v;\np rot[2] = {p(0, 1), p(0, -1)};\n\nint solve();\nint count(p now);\n\nint main() {\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n    v.resize(n);\n    for(int i = 0; i < n; ++i) {\n      double x, y;\n      cin >> x >> y;\n      v[i] = p(x, y);\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nint solve() {\n  int ans = 1;\n  for(int i = 0; i < n; ++i)\n    for(int j = i + 1; j < n; ++j)\n      if(abs(v[i] - v[j]) <= 2.0 + EPS)\n        for(int t = 0; t < 2; ++t) {\n          p rotatep = (v[j] - v[i]) * rot[t];\n          double len = 0;\n          len = sqrt(4.0 - pow(abs(v[i] - v[j]), 2));\n          rotatep *= len / abs(rotatep);\n          rotatep += v[i];\n          p nowp = (rotatep - v[j]);\n          nowp /= 2;\n          ans = max(ans, count(v[j] + nowp));\n        }\n  return ans;\n}\n\nint count(p now) {\n  int ans = 0;\n  for(int i = 0; i < n; ++i)\n    if(abs(now - v[i]) <= 1.0 + EPS) ++ans;\n  return ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\n#define P complex<double>\n#define EPS 1.0e-8\n\nint main(){\n  int n;\n  P p[301];\n\n  while( cin>>n && n ){\n    for( int i=0;i<n;i++ )\n      cin >> p[i].real() >> p[i].imag();\n\n    int ans=0;\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ ){\n\tif( i==j ) \t  continue;\n\tif( abs( p[i]-p[j] )+EPS > 2.0 ) continue;\n\n\tP m  = (p[i]+p[j]) / 2.0; // p[i]Æp[j]Ì_\n\tP nn = (p[i]-p[j]) * P(0,1);       // @üxNg\n\tnn = nn / abs(nn);\n\n\tdouble x = abs( p[i]-p[j] )/2.0;\n\tP c = m + nn*sqrt( 1.0-x*x );        // ~ÌS\n\n\tint num=0;\n\tfor( int k=0;k<n;k++ )\n\t  if( abs( c-p[k] ) < 1.0 + EPS  )\n\t    num++;\n\tans = max( ans,num );\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<complex>\nusing namespace std;\n\ncomplex<double> p[300];\n\ncomplex<double> core(int a,int b){\n  complex<double> res,mid,norm;\n\n  mid = (p[a]+p[b]) / 2.0;\n\n  norm = (p[a] - p[b]) * complex<double>(0,1);\n  norm = norm / abs(norm);\n  norm = norm * sqrt(1.0 - abs(mid-p[a])*abs(mid-p[a]));\n\n  res = norm + mid;\n  return res;\n}\n  \n\nint main(){\n  int n;\n  complex<double> o;\n  int max,tmp;\n\n  while(1){\n    cin >> n;\n    if(!n)break;\n\n    for(int i=0;i<n;i++)cin >> p[i].real() >> p[i].imag();\n\n    max = 1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i!=j && abs(p[i]-p[j]) < 2.0){\n\t  o = core(i,j);\n\t  tmp = 2;\n\t  for(int k=0;k<n;k++){\n\t    if(k!=i && k!=j){\n\t      if(abs(o-p[k])<1.0)tmp++;\n\t    }\n\t  }\n\t  if(max < tmp)max = tmp;\n\t}\n      }\n    }\n    cout << max << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n#include <complex>\ntypedef complex<double> Point;\nint main(){\n  int N;\n  while(cin >> N && N){\n    vector<Point> ps(N);\n    REP(i, N) cin >> ps[i].real() >> ps[i].imag();\n    int ans = 1;\n    REP(i, N)REP(j, N) if(i != j){\n      double d = abs(ps[i] - ps[j]) / 2;\n      if(d > 1) continue;\n      double t = sqrt(1 - d * d);\n      Point start = ps[i] + (ps[j] - ps[i]) * 0.5;\n      Point vect = (ps[j] - ps[i]) * Point(0.0, 1.0);\n      vect /= abs(vect);\n      for(int sign = -1; sign <= 1; sign += 2){\n        Point center = start + vect * t * (double)sign;\n        int sub_ans = 0;\n        REP(k, N) if(abs(center - ps[k]) < 1.0 + EPS) sub_ans ++;\n        ans = max(ans, sub_ans);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-8;\n\nstruct Circle{\n  P c;\n  double r;\n  Circle(P c=P(0,0),double r=0):c(c),r(r){}\n};\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1=c1.r,r2=c2.r,d;\n  P p1=c1.c,p2=c2.c;\n  d=abs(p1-p2);\n  if(d<EPS&&abs(r1-r2)<EPS) return res;\n  if(r1+r2<d-EPS||d+EPS<abs(r1-r2)) return res; \n  double a=(r1*r1-r2*r2+d*d)/(2*d);\n  double h=sqrt(max(r1*r1-a*a,0.0));\n  P tmp1=p1+a/d*(p2-p1);\n  P tmp2=h/d*(p2-p1);\n  if(abs(tmp2)<EPS)res.push_back(tmp1);\n  else{\n    res.push_back(P(real(tmp1)-imag(tmp2),imag(tmp1)+real(tmp2)));\n    res.push_back(P(real(tmp1)+imag(tmp2),imag(tmp1)-real(tmp2)));\n  }\n  return res;\n}\n\ndouble getdistancepp(P a,P b){\n  return sqrt((a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag()));\n}\n\nint main(){\n  int n,ans=0;\n  double a,b;\n  P p[N];\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>a>>b;\n      p[i]=P(a,b);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tCircle c1,c2;\n\tc1.c=p[i];\n\tc2.c=p[j];\n\tc1.r=c2.r=1;\n\tvector<P> r=getIntersectCC(c1,c2);\n\tif(!r.size())continue;\n\tfor(int k=0;k<r.size();k++){\n\t  int cnt=0;\n\t  for(int l=0;l<n;l++)\n\t    if(getdistancepp(r[k],p[l])<=1+EPS)cnt++;\t    \n\t  ans=max(ans,cnt);\n\t}\n      }\n    }\n    if(!ans&&n==1)ans=1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\n/***** 基本的準備 *****/\n\n// xy平面上の点(ベクトル)を表現するには、complex型を利用するとよい\ntypedef complex<double> Point;\n\n// 辺の表現 (座標を2つ pair でもつ)\ntypedef pair<Point, Point> Line;\n\n// 円の表現 (座標 P と 半径 d で表現する)\ntypedef pair<Point, double> Circle;\n\n// 誤差(epsilon)の定義\nconst double EPS = 1e-10;\n\n// 2つの要素が等しいかどうか\ntemplate <typename float_type>\nbool EQ(float_type a, float_type b) { return abs(a - b) < EPS; }\n\n// 2つのベクトルが等しいかどうか\ntemplate <typename complex_type>\nbool EQV(complex_type a, complex_type b) { return EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()); }\n\n// m は n より大きい(以上)かどうか\ntemplate <typename float_type>\nbool LE(float_type n, float_type m) { return n < m + EPS; }\ntemplate <typename float_type>\nbool LEQ(float_type n, float_type m) { return n <= m + EPS; }\n\n// m は n より小さい(以下)かどうか\ntemplate <typename float_type>\nbool GE(float_type n, float_type m) { return n + EPS > m; }\ntemplate <typename float_type>\nbool GEQ(float_type n, float_type m) { return n + EPS >= m; }\n\n// 2つのベクトルの内積を求める\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 2つのベクトルの外積を求める\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// ccw (c が直線(線分) ab に対してどのような位置関係か？)\n// Verified: AOJ CGL_1_C: Counter-Clockwise\n// +1 ... a → b で半時計方向に折れて b → c (COUNTER_CLOCKWISE)\n// -1 ... a → b で時計方向に折れて b → c (CLOCKWISE)\n// +2 ... c, a, b がこの順で同一直線状にある場合 (ONLINE_BACK)\n// -2 ... a, b, c がこの順で同一直線状にある場合 ( or a == b ) (ONLINE_FRONT)\n//  0 ... c が線分 ab 上にある場合 (点 a, b 上を含む) (ON_SEGMENT)\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n\n/***** テクニック編 *****/\n\n/*\n// ベクトル a の絶対値を求める (complex型)\ndouble len = abs(a);\n\n// 2点 a,b 間の距離を求める (complex型)\ndouble dist = abs(a-b);\n\n// 2点が等しいかどうかの判定\nif(abs(a-b) < EPS)\n\n// ベクトル a の単位ベクトル b を求める\nPoint b = a / abs(a);\n\n// ベクトル a の法線ベクトル n1, n2 を求める\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n\n// ベクトル a の単位法線ベクトル un1, un2 を求める\nPoint un1 = (a * Point(0, 1)) / abs(a);\nPoint un2 = (a * Point(0, -1)) / abs(a);\n*/\n\n/***** 直交・平行判定 *****/\n// Verified: AOJ CGL_2_A: Parallel/Orthogonal\n\n// 2直線の直交判定 (内積が0であること)\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n\n// 2直線の平行判定 (外積が0であること)\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n\n/***** 各種交差判定 (intersection) *****/\n// 豆知識: 線分 ... line segment (英)\n\n// 直線 a1, a2 と点 b の交差判定 (直線上に点があるかの判定)\n// ccwで絶対値が1 (一直線で線分上にない) でなければ交差している\nbool isec_lp(Point a1, Point a2, Point b) {\n    return abs( ccw(a1, a2, b) ) != 1;\n}\n\n// 直線 a1, a2 と直線 b1, b2 の交差判定\nbool isec_ll(Point a1, Point a2, Point b1, Point b2) {\n    return !isec_lp(a2-a1, b2-b1, 0) || isec_lp(a1, b1, b2);\n}\n\n// 直線 a1, a2 と線分 b1, b2 の交差判定\nbool isec_ls(Point a1, Point a2, Point b1, Point b2) {\n    return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分 a1, a2 と線分 b1, b2 の交差判定\n// Verified: CGL_2_B: Intersection\nbool isec_ss(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n\n// 線分 a1, a2 と点 b の交差判定 (線分上に点があるかの判定)\nbool isec_sp(Point a1, Point a2, Point b) {\n    return !ccw(a1, a2, b);\n}\n\n/***** 各種距離 *****/\n\n// 点 p の直線 a1, a2 への射影点を返す\n// Verified: AOJ CGL_1_A: Projection\nPoint projection(Point a1, Point a2, Point p) {\n    return a1 + dot(a2-a1, p-a1) / norm(a2-a1) * (a2-a1);\n}\n\n// 点 p の直線 a への反射点を返す\n// Verified: AOJ CGL_1_B: Reflection\nPoint reflection(Point a1, Point a2, Point p) {\n    return 2.0 * projection(a1, a2, p) - p;\n}\n\n// 点 a1, a2 を通る直線と点 b との距離\ndouble dist_lp(Point a1, Point a2, Point b) {\n    return abs( cross(a2-a1, b-a1) ) / abs(a2-a1);\n}\n\n// 直線 a1, a2 と 直線 b1, b2 との距離\ndouble dist_ll(Point a1, Point a2, Point b1, Point b2) {\n    return isec_ll(a1, a2, b1, b2) ? 0 : dist_lp(a1, a2, b1);\n}\n\n// 直線 a1, a2 と 線分 b1, b2 との距離\ndouble dist_ls(Point a1, Point a2, Point b1, Point b2) {\n    return isec_ls(a1, a2, b1, b2) ? 0 : min( dist_lp(a1, a2, b1), dist_lp(a1, a2, b2) );\n}\n\n// 点 a1, a2 を端点とする線分と点 b との距離\ndouble dist_sp(Point a1, Point a2, Point b) {\n    if( dot(a2-a1, b-a1) < EPS ) return abs(b - a1);\n    if( dot(a1-a2, b-a2) < EPS ) return abs(b - a2);\n    return abs( cross(a2-a1, b-a1) ) / abs(a2 - a1);\n}\n\n// 線分 a1, a2 と 線分 b1, b2 との距離\n// Verified: CGL_2_D: Distance\ndouble dist_ss(Point a1, Point a2, Point b1, Point b2) {\n    if(isec_ss(a1, a2, b1, b2)) return 0;\n    return min( min(dist_sp(a1, a2, b1), dist_sp(a1, a2, b2)),\n                min(dist_sp(b1, b2, a1), dist_sp(b1, b2, a2)) );\n}\n\n// 直線 a1, a2 と直線b1, b2の交点を求める\n// Verified: AOJ CGL_2_C.cpp\nPoint crossp_ll(Point a1, Point a2, Point b1, Point b2) {\n    double d1 = cross(b2-b1, b1-a1);\n    double d2 = cross(b2-b1, a2-a1);\n    if( EQ(d1,0.0) && EQ(d2,0.0) ) return a1; // same line\n    if( EQ(d2,0.0) ) assert(false); // precondition not satisfied\n    return a1 + d1 / d2 * (a2 - a1);\n}\n\n/***** 円に関する問題 *****/\n\n// 直線 a1, a2 と 円 C との距離\ndouble dist_lc(Point a1, Point a2, Circle c) {\n    return max(dist_lp(a1, a2, c.first) - c.second, 0.0);\n}\n\n// 線分 a1, a2 と 円 C との距離\ndouble dist_sc(Point a1, Point a2, Circle c) {\n    double dSqr1 = norm(c.first - a1), dSqr2 = norm(c.first - a2);\n    double r = c.second;\n    if((dSqr1 < r*r) ^ (dSqr2 < r*r)) return 0; //円が線分を包含するとき距離0ならばここをORに変える\n    if((dSqr1 < r*r) & (dSqr2 < r*r)) return r - sqrt(max(dSqr1, dSqr2));\n    return max(dist_sp(a1, a2, c.first) - r, 0.0);\n}\n\n// 円 x と円 y との距離\ndouble dist_cc(Circle x, Circle y) {\n    Point a = x.first, b = y.first;\n    double ar = x.second, br = y.second;\n\n    double d = abs(a-b);\n    return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n\n// 直線 a1, a2 と円 C との交点\n// Verified: AOJ CGL_7_D: Cross Points of a Circle and a Line\nvector<Point> crossp_lc(Point a1, Point a2, Circle c) {\n    vector<Point> ps;\n    double r = c.second;\n    Point ft = projection(a1, a2, c.first);\n    if(!GEQ(r*r, norm(ft-c.first))) return ps;\n\n    Point dir = sqrt(max(r*r - norm(ft-c.first), 0.0)) / abs(a2-a1) * (a2-a1);\n    ps.push_back(ft + dir);\n    if(!EQ(r*r, norm(ft-c.first))) ps.push_back(ft - dir);\n    return ps;\n}\n\n// 円 x と円 y の交点\n// Verified: AOJ CGL_7_E: Cross Points of Circles\nvector<Point> crossp_cc(Circle x, Circle y) {\n    vector<Point> ps;\n    Point a = x.first, b = y.first;\n    double ar = x.second, br = y.second;\n\n    Point ab = b-a;\n    double d = abs(ab);\n    double crL = (norm(ab) + ar * ar - br * br) / (2 * d);\n    if(EQ(d,0.0) || ar < abs(crL)) return ps;\n\n    Point abN = ab * Point(0, sqrt(ar*ar - crL*crL) / d);\n    Point cp = a + crL/d * ab;\n    ps.push_back(cp + abN);\n    if(!EQ(norm(abN), 0.0)) ps.push_back(cp - abN);\n    return ps;\n}\n\n// 点 p から円 x への接線の接点\n// Verified: AOJ CGL_7_F: Tangent to a Circle\nvector<Point> tangentPoints(Point p, Circle x) {\n    vector<Point> ps;\n    Point a = x.first; double ar = x.second;\n    double sin = ar / abs(p-a);\n    if(!LE(sin, 1.0)) return ps; // ここで NaN もはじかれる\n\n    double t = M_PI_2 - asin(min(sin, 1.0));\n    ps.push_back(a + (p-a) * polar(sin, t));\n    if(!EQ(sin, 1.0)) ps.push_back(a + (p-a)*polar(sin, -t));\n    return ps;\n}\n\n// 円 x と円 y の共通接線。返される各直線に含まれる頂点は円との接点となる\n// Verified: AOJ CGL_7_G: Common Tangent\n// ※ やること: -0.0000000になる問題を直したい・・・\nvector<Line> tangentLines(Circle x, Circle y) {\n    Point a = x.first, b = y.first;\n    double ar = x.second, br = y.second;\n    vector<Line> ls;\n    double d = abs(b-a);\n\n    for(int i=0; i<2; i++) {\n        double sin = (ar - (1-i*2)*br) / d;\n        if(!LE(sin*sin, 1.0)) break;\n\n        double cos = sqrt(max(1 - sin*sin, 0.0));\n        for(int j=0; j<2; j++) {\n            Point n = (b-a) * Point(sin, (1-j*2)*cos) / d;\n            ls.push_back(Line(a + ar*n, b + (1-i+2)*br*n));\n            if(cos < EPS) break; // 重複する接線を無視 (重複してよいならこの行は不要)\n        }\n    }\n    return ls;\n}\n\n// 円 c1 と円 c2 の位置関係\n// Verified: AOJ CGL_7_A: Intersection\nint intersectCC(Circle c1, Circle c2){\n    Point c1p = c1.first, c2p = c2.first;\n    double c1r = c1.second, c2r = c2.second;\n    long double d = abs(c1p - c2p), r1 = c1r, r2 = c2r;\n    if(r1 + r2 < d)            return  0; // 離れている\n    if(abs(r1 + r2 - d) < EPS) return -2; // 外接\n    if(abs(d + r1 - r2) < EPS) return +1; // c1 が c2 の中で内接\n    if(abs(d + r2 - r1) < EPS) return -1; // c2 が c1 の中で内接\n    if(d + r1 < r2)            return +3; // c1 が c2 の中\n    if(d + r2 < r1)            return -3; // c2 が c1 の中\n    return 2; // 2つの交点を持つ\n}\n\n// 三角形の外心。点 a, b, c は同一線上にあってはならない\nPoint circumcenter(Point a, Point b, Point c) {\n    a = (a-c) * 0.5;\n    b = (b-c) * 0.5;\n    return c + crossp_ll(a, a*Point(1,1), b, b*Point(1,1));\n}\n\n// 三角形の内心\nPoint InnerCenter(Point a, Point b, Point c) {\n    double p = abs(b-c), q = abs(c-a), r = abs(a-b);\n    return (p*a + q*b + r*c) / (p + q + r);\n}\n\n// 三角形の重心\nPoint CenterOfGravity(Point a, Point b, Point c) {\n    return (a + b + c) / 3.0;\n}\n\n// 三角形の垂心\nPoint Orthocenter(Point a, Point b, Point c) {\n    Point x = circumcenter(a, b, c);\n    Point ret = (a-x) + (b-x) + (c-x);\n    return ret-x;\n}\n\n// 点 a と 点 b を通り、半径が r の円の中心を返す\nvector<Point> circlesPointsRadius(Point a, Point b, double r) {\n    vector<Point> cs;\n    Point abH = (b-a) * 0.5;\n    double d = abs(abH);\n\n    if(d == 0 || d > r) return cs; // 必要なら !LE(d,r) として円1つになる側へ丸める\n    double dN = sqrt(r*r - d*d);   // 必要なら max(r*r - d*d, 0) とする\n    Point n = abH * Point(0,1) * (dN / d);\n    cs.push_back(a + abH + n);\n    if(dN > 0) cs.push_back(a + abH - n);\n    return cs;\n}\n\n// 点 a と点 b を通り、直線 l に接する円の中心\nvector<Point> circlesPointsTangent(Point a, Point b, Point l1, Point l2) {\n    Point n = (l2-l1) * Point(0,1);\n    Point m = (b-a) * Point(0,0.5);\n    double rC = dot((a+b)*0.5-l1, n);\n    double qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n    double qb = -rC * dot(n,m);\n    double qc = norm(n)*norm(m) - rC*rC;\n    double qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n\n    vector<Point> cs;\n    if(qd < -EPS) return cs;\n    if(EQ(qa, 0.0)) {\n        if(!EQ(qb,0.0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n        return cs;\n    }\n    double t = -1*qb/qa;\n    cs.push_back( (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0)) / qa ));\n    if(qd > EPS) cs.push_back( (a+b)*0.5 + m * (t - sqrt(max(qd, 0.0)) / qa));\n    return cs;\n}\n\n// 点集合を含む最小の円の中心\nPoint minEnclosingCircle(const vector<Point> &ps) {\n    Point c;\n    double move = 0.5;\n    for(int i=0; i<39; i++) { // 2^(-39-1) \\approx 0.9e-12\n        for(int t=0; t<50; t++) {\n            double max = 0;\n            int k = 0;\n            for(size_t j=0; j<ps.size(); j++) if(max < norm(ps[j] - c)) {\n                max = norm(ps[j] - c);\n                k = j;\n            }\n            c += (ps[k] - c) * move;\n        }\n        move /= 2;\n    }\n    return c;\n}\n\n// (基本) 頂点の順序 (sortやmax_elementに必要)\nnamespace std {\n    bool operator<(const Point a, const Point b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n}\n\n// 凸包\n// Verified: AOJ CGL_4_A: Convex Hull\n// y座標優先でソート(必要があれば)\nbool cmp_y(const Point &a, const Point& b) {\n    return a.imag() != b.imag() ? a.imag() < b.imag() : a.real() < b.real();\n}\n\nvector<Point> convexHull(vector<Point> ps) {\n    int n = ps.size();\n    sort(ps.begin(), ps.end(), cmp_y);\n\n    int k = 0;\n    vector<Point> convex(n*2);\n    for(int i=0; i<n; i++) {\n        while (k >= 2 && ccw(convex[k-2], convex[k-1], ps[i]) == -1 ) k--;\n        convex[ k++ ] = ps[i];\n    }\n    for(int i=n-2, t=k; i>=0; i--) {\n        while (k > t && ccw(convex[k-2], convex[k-1], ps[i]) == -1 ) k--;\n        convex[ k++ ] = ps[i];\n    }\n    convex.resize(k-1);\n    return convex;\n}\n\n/* これはバグるので使用禁止。後で直したい\nvector<Point> convexHull(vector<Point> ps) { // 元の点集合がソートされていいなら vector<Point> & に\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<Point> ch(2 * n);\n    for(int i=0; i<n; ch[k++] = ps[i++]) // lower-hull\n        while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k; // 余計な点も含むなら-1とする\n    for(int i=n-2, t=k+1; i>=0; ch[k++] = ps[i--]) //upper-hull\n        while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    ch.resize(k-1);\n    return ch;\n}\n*/\n\n// 凸判定。縮退を認めないなら ccw の判定部分を != 1 とする\n// Verified: CGL_3_B: Is-Convex\nbool isCcwConvex(const vector<Point> &ps) {\n    int n = ps.size();\n    for(int i=0; i<n; i++) if(ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n    return true;\n}\n\n// 凸多角形の内部判定 O(n)\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inConvex(Point p, const vector<Point> &ps) {\n    int n = ps.size();\n    int dir = ccw(ps[0], ps[1], p);\n    for(int i=0; i<n; i++) {\n        int ccwc = ccw(ps[i], ps[(i+1) % n], p);\n        if(!ccwc) return 2;\n        if(ccwc != dir) return 0;\n    }\n    return 1;\n}\n\n// 凸多角形の内部判定 O(log n)\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inCcwConvex(Point p, const vector<Point> &ps) {\n    int n = ps.size();\n    Point g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n    if(g == p) return 1;\n    Point gp = p - g;\n\n    int l = 0, r = n;\n    while(l + 1 < r) {\n        int mid = (l + r) / 2;\n        Point gl = ps[l] - g;\n        Point gm = ps[mid] - g;\n        if(cross(gl,gm) > 0) {\n            if(cross(gl,gp) >= 0 && cross(gm,gp) <= 0) r = mid;\n            else l = mid;\n        }\n        else {\n            if(cross(gl,gp) <= 0 && cross(gm,gp) >= 0) l = mid;\n            else r = mid;\n        }\n    }\n    r %= n;\n    double cr = cross(ps[l] - p, ps[r] - p);\n    return EQ(cr, 0.0) ? 2 : cr < 0 ? 0 : 1;\n}\n\n// 多角形の内部判定\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\n// Verified: AOJ CGL_3_C: Polygon-Point Containment\nint inPolygon(Point p, const vector<Point> &ps) {\n    int n = ps.size();\n    bool in = false;\n    for(int i=0; i<n; i++) {\n        Point a = ps[i] - p;\n        Point b = ps[(i+1) % n] - p;\n        if(EQ(cross(a,b), 0.0) && LE(dot(a,b), 0.0)) return 2;\n        if(a.imag() > b.imag()) swap(a,b);\n        if((a.imag() * b.imag() < 0 || (a.imag() * b.imag() < EPS && b.imag() > EPS)) && LE(cross(a,b), 0.0)) in = !in;\n    }\n    return in;\n}\n\n// 凸多角形クリッピング\n// Verified: AOJ CGL_4_C: Convex Cut\nvector<Point> convexCut(Point a1, Point a2, const vector<Point> &ps) {\n    int n = ps.size();\n    vector<Point> ret;\n    for(int i=0; i<n; i++) {\n        int ccwc = ccw(a1, a2, ps[i]);\n        if(ccwc != -1) ret.push_back(ps[i]);\n        int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n        if(ccwc * ccwn == -1) ret.push_back(crossp_ll(a1, a2, ps[i], ps[(i + 1) % n]));\n    }\n    return ret;\n}\n\n// 凸多角形の直径 (最遠点対)\n// Verified: AOJ CGL_4_B: Diameter of a Convex Polygon\npair<int, int> convexDiameter(const vector<Point> &ps) {\n    int n = ps.size();\n    int i = min_element(ps.begin(), ps.end()) - ps.begin();\n    int j = max_element(ps.begin(), ps.end()) - ps.begin();\n    int maxI, maxJ;\n    double maxD = 0;\n    for(int _=0; _<2*n; _++) {\n        if(maxD < norm(ps[i] - ps[j])) {\n            maxD = norm(ps[i] - ps[j]);\n            maxI = i;\n            maxJ = j;\n        }\n        if(cross(ps[i] - ps[(i+1) % n], ps[(j+1) % n] - ps[j]) <= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n    }\n    return make_pair(maxI, maxJ);\n}\n\n// 多角形の符号付面積\n// Verified: AOJ CGL_3_A: Area\ndouble area(const vector<Point> &ps) {\n    double a = 0;\n    for(size_t i=0; i<ps.size(); i++) a += cross(ps[i], ps[(i+1) % ps.size()]);\n    return a / 2;\n}\n\n// 多角形の符号なし面積\ndouble area_n(const vector<Point> &v) {\n    double ans = 0;\n    double x, y, z;\n    Point init = v[0];\n    for(size_t i=2; i<v.size(); i++) {\n        x = sqrt(norm(v[i] - init));\n        y = sqrt(norm(v[i-1] - init));\n        z = sqrt(norm(v[i] - v[i-1]));\n\n        double s = (x + y + z) / 2;\n        ans += sqrt(s * (s-x) * (s-y) * (s-z));\n    }\n    return ans;\n}\n\n// 多角形の幾何学的重心\nPoint centroid(const vector<Point> &ps) {\n    int n = ps.size();\n    double aSum = 0;\n    Point c;\n    for(int i=0; i<n; i++) {\n        double a = cross(ps[i], ps[(i+1) % n]);\n        aSum += a;\n        c += (ps[i] + ps[(i+1) % n]) * a;\n    }\n    return 1 / aSum / 3 * c;\n}\n\n// ボロノイ領域\n/*\nvector<Point> voronoiCell(Point p, const vector<Point> &ps, const vector<Point> &outer) {\n    vector<Point> cl = outer;\n    for(size_t i=0; i<ps.size(); i++) {\n        if(EQ(norm(ps[i] - p), 0.0)) continue;\n        Point h = (p + ps[i]) * 0.5;\n        cl = convexCut(cl, h, h + (ps[i] - h) * Point(0,1));\n    }\n    return cl;\n}\n*/\n\n// 頂点を回転させる系\n\n// 度数法 → 弧度法\ndouble deg2rad(double x) {return x * M_PI / 180.0;}\n\n// 点 a を中心として、点 b を z 度回転させたときの位置\nPoint rotatePoint(Point a, Point b, double z) {\n    // 度数法の場合は変換\n    z = deg2rad(z);\n\n    b -= a;\n    double rx = b.real() * cos(z) - b.imag() * sin(z);\n    double ry = b.real() * sin(z) + b.imag() * cos(z);\n    Point ret(rx, ry); ret += a;\n    return ret;\n}\n\nint solve_testcase() {\n    int N; scanf(\"%d\", &N);\n    if(N == 0) return 1;\n    \n    vector<Point> points;\n    for(int i=0; i<N; i++) {\n        double x, y; scanf(\"%lf%lf\", &x, &y);\n        points.emplace_back(x, y);\n    }\n\n    const double EPS = 1e-7;\n    int ans = 1;\n    for(int i=0; i<N; i++) {\n        for(int j=i+1; j<N; j++) {\n            double d = abs(points[i] - points[j]);\n            if(d > 2.0 + EPS) continue;\n            double e = sqrt(1.0 - d*d/4);\n            Point vec = (points[j] - points[i]) / d;\n            for(int p=-1; p<=1; p+=2) {\n                Point c = points[i] + d/2*vec + e*(vec*Point(0, p));\n                int cand = 0;\n                for(int k=0; k<N; k++) {\n                    if(abs(points[k] - c) < 1.0 + EPS) cand++;\n                }\n                chmax(ans, cand);\n            }\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n\nint main() {\n    while(!solve_testcase());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <complex>\n\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,n) loop(i,0,n)\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef complex<double> vec;\n\ndouble const pi = acos(-1);\ndouble const eps = 1e-6;\n\nint main(){\n    int n;\n    while (cin >> n && n){\n        vector<vec> v(n);\n        rep(i, n){\n            double x, y; cin >> x >> y;\n            vec p(x, y);\n            v[i] = p;\n        }\n\n        if (n == 1) {\n            puts(\"1\");\n            continue;\n        }\n        int ans = 1;\n        rep(i, n)rep(j, i){\n            double d = abs(v[i] - v[j]);\n            if (d > 2) continue;\n            ans = max(ans, 2);\n            double h = 1 - d*d / 4;\n            vec c1 = polar(h, arg(v[i] - v[j]) + pi / 2) + (v[i] + v[j]) / 2.;\n            vec c2 = polar(h, arg(v[i] - v[j]) - pi / 2) + (v[i] + v[j]) / 2.;\n            int a1 = 0, a2 = 0;\n            rep(k, n){\n                if (abs(c1 - v[k]) <= 1 - eps) a1++;\n                if (abs(c2 - v[k]) <= 1 - eps) a2++;\n            }\n            ans = max(ans, a1);\n            ans = max(ans, a2);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1132&lang=jp\n\n#include <iostream>\n#include <complex>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\ntypedef complex<double> xy_t;\n\nconst xy_t rot[2] = { xy_t(0, 1), xy_t(0, -1) };\nconst double eps = 1e-6; // 最初から誤差の見積もりがあるのでそれに甘えた。\n\nint main() {\n  int N;\n  while (scanf(\"%d\", &N) != EOF && N) {\n    if (N == 1) {\n      printf(\"1\\n\");\n      continue;\n    }\n    xy_t P[310];\n    for (int i=0; i<N; i++) {\n      double X, Y;\n      scanf(\"%lf%lf\", &X, &Y);\n      P[i] = xy_t(X, Y);\n    }\n    int ans = 0;\n    for (int i=0; i<N; i++) {\n      for (int j=i+1; j<N; j++) {\n\tif ( abs(P[i] - P[j]) > 2 - eps ) continue;\n\tfor (int k=0; k<2; k++) {\n\t  xy_t c = (P[i] + P[j])/2.0; // 中点\n\t  xy_t n = (P[i] - P[j]);\n\t  xy_t m = n/abs(n) * rot[k] * sqrt(1 - abs(n/2.0) * abs(n/2.0));\n\t  xy_t center = c + m;\n\t  int count = 0;\n\t  for (int k=0; k<N; k++) {\n\t    if (abs(center - P[k]) < 1 + eps) count++;\n\t    // cerr << fixed << setprecision(10) << abs(center - P[k]) << endl;\n\t  }\n\t  ans = max(ans, count);\n\t}\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nstruct Point{\n\tdouble x,y;\n};\n\nvoid func(int N){\n\n\tPoint point[N];\n\tdouble x_min = 100,y_min = 100,x_max = -1,y_max = -1;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf\",&point[i].x,&point[i].y);\n\t\tx_min = min(point[i].x,x_min);\n\t\ty_min = min(point[i].y,y_min);\n\t\tx_max = max(point[i].x,x_max);\n\t\ty_max = max(point[i].y,y_max);\n\t}\n\n\tif(x_min > 1)x_min -= 1;\n\tif(y_min > 1)y_min -= 1;\n\tif(x_max < 9)x_max += 1;\n\tif(y_max < 9)y_max += 1;\n\n\tint count,max_count = 0;\n\n\tfor(double y = y_min; y <= y_max; y += 0.02){\n\t\tfor(double x = x_min; x <= x_max; x += 0.02){\n\t\t\tcount = 0;\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tif(sqrt((x-point[i].x)*(x-point[i].x)+(y-point[i].y)*(y-point[i].y)) <= 1.0)count++;\n\t\t\t}\n\t\t\tmax_count = max(max_count,count);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",max_count);\n}\n\n\nint main(){\n\n\tint N;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc(N);\n\t}\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-8;\nconst int N = 300;\nconst double R = 1;\n\nstruct Circle{\n  P c;\n  double r;\n  Circle(P c=P(0,0), double r=0):c(c),r(r){}\n};\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1 = c1.r, r2 = c2.r, d;\n  P p1 = c1.c, p2 = c2.c;\n  d = abs(p1-p2);\n\n  if(d < EPS && abs(r1-r2) < EPS) return res; //????????¨?????????????????´???????????????????????????????????????\n  if(r1 + r2< d - EPS || d + EPS < abs(r1-r2)) return res; //???????????????\n\n  double a = (r1*r1 - r2*r2 + d*d) / (2*d);\n  double h = sqrt(max(r1*r1 - a*a, 0.0));\n  P tmp1 = p1 + a / d * (p2-p1);\n  P tmp2 = h / d * (p2-p1);\n\n  if(abs(tmp2) < EPS) res.push_back(tmp1);\n  else {\n    res.push_back(P(real(tmp1) - imag(tmp2), imag(tmp1) + real(tmp2)));\n    res.push_back(P(real(tmp1) + imag(tmp2), imag(tmp1) - real(tmp2)));\n  }\n  return res;\n}\n\n\nint n;\nvector<P> v;\n\nint solve(){\n  int ans = 1;\n\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      vector<P> cc = getIntersectCC(Circle(v[i], R), Circle(v[j], R)); // v[i]??¨v[j]??????????????¢?????¨??????R??¨????????? (?????´?????????????????????????????????????????????)\n      if(cc.size() == 0) continue;\n      for(int k=0;k<cc.size();k++){\n        int res = 0;\n        for(int l=0;l<n;l++) if(abs(v[l]-cc[k]) <= R + EPS) res++;\n        ans = max(ans, res);\n      }\n    }\n  }\n\n  return ans;\n}\n\nint main(){\n  while(cin >> n && n){\n    v.clear();\n    for(int i=0;i<n;i++){\n      double x, y;\n      cin >> x >> y;\n      v.push_back(P(x,y));\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <complex>\n#include <vector>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P, double> C;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nP n_vector(P a){\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nvector<P> cpcc(C a, C b){\n  double d = abs(a.first-b.first), ra = a.second, rb = b.second;\n  double t = (ra*ra-rb*rb+d*d)/2/d, h = sqrt(ra*ra-t*t);\n  P m = t/abs(b.first-a.first)*(b.first-a.first)+a.first;\n  vector<P> cp(2,m);\n  P n = n_vector(a.first-b.first);\n  cp[0] -= h*n;\n  cp[1] += h*n;\n  return cp;\n}\n\n\nint main(){\n  int N;\n  double x, y;\n  while(cin >> N, N){\n    P ps[N];\n    for(int i = 0; i < N; ++i){\n      cin >> x >> y;\n      ps[i] = P(x,y);\n    }\n    vector<P> cps;\n    for(int i = 0; i < N; ++i){\n      for(int j = i+1; j < N; ++j){\n\tif(abs(ps[i]-ps[j]) <= 2 + EPS){\n\t  vector<P> cp = cpcc(C(ps[i],1),C(ps[j],1));\n\t  for(int k = 0; k < cp.size(); ++k)\n\t    cps.push_back(cp[k]);\n\t}\n      }\n    }\n    int n = cps.size(), ans = 1;\n    for(int i = 0; i < n; ++i){\n      int cnt = 0;\n      for(int j = 0; j < N; ++j){\n\tif(norm(cps[i]-ps[j]) <= 1 + EPS)\n\t  ++cnt;\n      }\n      ans = max(ans, cnt);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst double r = 1.0;\nconst double PI = acos(-1.0);\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y) : x(x), y(y) {}\n};\nPoint operator+(const Point &a, const Point &b) {\n    return Point(a.x + b.x, a.y + b.y);\n}\nPoint operator-(const Point &a, const Point &b) {\n    return Point(a.x - b.x, a.y - b.y);\n}\nPoint operator*(const Point &a, double b) {\n    return Point(a.x * b, a.y * b);\n}\ninline double Distance2(const Point &a, const Point &b) {\n    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n// p1??¨??????p1p2???theta?????¢?????????????????£????????????????????????????????????????????????\nPoint Circle(const Point &p1, const Point &p2, double theta) {\n    Point p12 = p2 - p1;\n    Point rp(p12.x * cos(theta) - p12.y * sin(theta), p12.x * sin(theta) + p12.y * cos(theta));\n    double len = sqrt(p12.x * p12.x + p12.y * p12.y);\n\n    return (rp * (1.0 / len)) + p1;\n}\n\nint main()\n{\n    int n;\n\n    while (true) {\n        // Input\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        vector<Point> p(n);\n        for (int i = 0; i < n; ++i)\n            scanf(\"%lf %lf\", &p[i].x, &p[i].y);\n\n        // Solve\n        // 2???????????????????§£???????£???¨??????\n        int ans = 1;\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j) {\n                double d = Distance2(p[i], p[j]);\n\n                if (d <= 4.0 * r * r) {\n                    double theta = (PI - acos((2.0 - d) * 0.5)) * 0.5;\n\n                    for (int s = -1; s <= 1; s += 2) {\n                        Point c = Circle(p[i], p[j], s * theta);\n\n                        int num = 2;\n                        for (int k = 0; k < n; ++k) {\n                            if (k != i && k != j && Distance2(c, p[k]) <= 1.0)\n                                ++num;\n                        }\n\n                        ans = max(ans, num);\n                    }\n                }\n            }\n\n        // Output\n        printf(\"%d\\n\", ans);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include \"stdlib.h\"\n\n#define MAXN 300\n#define eps 1e-8\n\ntypedef struct {\n    double x;\n    double y;\n} vec2;\n\nvec2 input[MAXN];\nuint num_of_input;\n\nuint init() {\n    uint N;\n    scanf(\"%u\", &N);\n    num_of_input = N;\n\n\n    if (!N)\n        return 0;\n\n    for (uint i = 0; i < N; i++) {\n        double x, y;\n        scanf(\"%lf%lf\", &x, &y);\n\n        input[i].x = x;\n        input[i].y = y;\n    }\n\n\n    return 1;\n\n\n}\n\ndouble dist(vec2 a, vec2 b) {\n    return sqrt(\n            (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)\n    );\n}\n\nvec2 get_center(vec2 a, vec2 b){\n    vec2 ret,mid={.x=(a.x+b.x)/2,.y=(a.y+b.y)/2};\n    double angle=atan2(a.y-b.y,a.x-b.x);\n    double distance_from_mid_to_center=sqrt(1.0-dist(a,b)*dist(a,b)/4.0);\n\n    ret.y=mid.y-distance_from_mid_to_center*cos(angle);\n    ret.x=mid.x+distance_from_mid_to_center*sin(angle);\n\n    return ret;\n}\n\nint main() {\n\n    while (init()) {\n        uint ans = 1;\n\n        for (uint i = 0; i < num_of_input;i++) {\n            for (uint j = i + 1; j < num_of_input; j++) {\n                vec2 center;\n                uint cur_count = 0;\n                if (dist(input[i], input[j]) > 2.0) continue;\n\n                center = get_center(input[i], input[j]);\n\n                for (uint k = 0; k < num_of_input; k++) {\n                    if (dist(center, input[k]) < 1.0 + eps)\n                        cur_count++;\n                }\n                ans = ans > cur_count ? ans : cur_count;\n            }\n        }\n\n        printf(\"%u\\n\", ans);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cassert>\n#include<string>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<tuple>\n#include<numeric>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\nconst int INF = 1 << 31;\nconst ll INF_ll = 1LL << 62;\nconst double EPS = 1e-7;\n\n// vector\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) {\n    for(const T &t : v) os << \"\\t\" << t; return os << endl;\n}\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) {\n    for(T &a : v) is >> a; return is;\n}\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) {\n    return os << \"<\" << v.first << \" \" << v.second << \">\";\n}\n\nusing Coordinate = double;\n\nbool eq(Coordinate a, Coordinate b) {\n    return abs(a - b) < EPS;\n}\n\n/*\n * Point\n */\nstruct Point {\n    Coordinate x,y;\n    Point():x(0),y(0){}\n    Point(Coordinate x,Coordinate y):x(x),y(y){}\n    pair<Coordinate,Coordinate> to_pair() const { return make_pair(x,y); }\n    bool operator == (const Point &a) const { return eq(x, a.x) && eq(y, a.y); }\n    bool operator != (const Point &a) const { return !(*this == a); }\n    \n    Point operator + (const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator - (const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator - () const { return Point(-x, -y); }\n    Point& operator += (const Point& p) { x += p.x; y += p.y; return *this; }\n    Point& operator -= (const Point& p) { x -= p.x; y -= p.y; return *this; }\n    // ???????????¨ x, y???\n    bool operator <  (const Point &a) const { return x < a.x && y < a.y; }\n    bool operator <= (const Point &a) const { return *this == a || *this < a;}\n    bool operator >  (const Point &a) const { return !(*this <= a); }\n    bool operator >= (const Point &a) const { return !(*this < a); }\n};\ntemplate<typename T> Point operator * (T k, const Point &p) { return Point(k * p.x, k * p.y); }\ntemplate<typename T> Point operator / (const Point &p, T k) { return Point(p.x / k, p.y / k); }\ndouble dot(const Point &a, const Point &b) { return a.x * b.x + a.y * b.y; }\ndouble cross(const Point &a, const Point &b) { return a.x * b.y - a.y * b.x; }\ndouble norm(const Point& a) { return sqrt( dot(a, a) ); }\n\nistream &operator >> (istream& is, Point& p){ return is >> p.x >> p.y;}\nostream &operator << (ostream& os, Point& p){ return os << \"(\" << p.x << \",\" << p.y << \")\";}\n\ndouble distance(const Point& a, const Point& b) { return norm(a - b); }\ndouble distance2(const Point& a, const Point& b) { return dot(a - b, a - b); }\n\nPoint rotate(Point &p, double degree) {\n    double rad = degree * M_PI / 180;\n    return Point(cos(rad) * p.x - sin(rad) * p.y,\n                 sin(rad) * p.x + cos(rad) * p.y);\n}\n// ??£?????´???????????????\nPoint orthonormal(Point &p) {\n    Point p2 = Point(-1 * p.y, p.x); //rotate(p, 90);\n    return p2 / norm(p2);\n}\n\n\nenum class ccw_t {\n    COUNTER_CLOCK_WISE = 1,\n    CLOCK_WISE = -1,\n    STRAIGHT_C_A_B = 2,\n    STRAIGHT_A_B_C = -2,\n    STRAIGHT_A_C_B = 0\n};\n\n\nccw_t ccw(Point a,Point b,Point c){\n    Point ab = b - a;\n    Point ac = c - a;\n    if( cross(ab,ac) > 0 ) return ccw_t::COUNTER_CLOCK_WISE;//a-b-c ???????¨???????\n    if( cross(ab,ac) < 0 ) return ccw_t::CLOCK_WISE;        //a-b-c ????¨???????\n    if( dot(ab,ac) < 0 ) return ccw_t::STRAIGHT_C_A_B;      //c-a-b\n    if( norm(ab) < norm(ac) )return ccw_t::STRAIGHT_A_B_C;  //a-b-c or a==b\n    return ccw_t::STRAIGHT_A_C_B;                           //a-c-b or b==c or a==c\n}\n\n/*\n * Segment\n */\n\nstruct Segment{\n    Point a, b;\n    Segment(){}\n    Segment(const Point& a, const Point& b):a(a), b(b){}\n    pair<Point,Point> to_pair() const { return make_pair(a,b); }\n    bool operator == (const Segment& s) const { return to_pair() == s.to_pair();}\n    bool operator != (const Segment& s) const { return to_pair() != s.to_pair();}\n};\n\ndouble length(const Segment &s){ return distance(s.a, s.b); }\nistream &operator >> (istream& is, Segment& s){ return is >> s.a >> s.b;}\nostream &operator << (ostream& os, Segment& s){ return os << s.a << \"->\" << s.b;}\n\nbool does_intersect(const Segment &a, const Segment &b){\n    return (int)ccw(a.a, a.b, b.a) * (int)ccw(a.a, a.b, b.b) <= 0 &&\n            (int)ccw(b.a, b.b, a.a) * (int)ccw(b.a, b.b, a.b) <= 0;\n}\n\ndouble distance( const Segment &s , const Point &p){\n    if( dot( s.b - s.a , p - s.a ) < EPS ) return norm( p - s.a );\n    if( dot( s.a - s.b , p - s.b ) < EPS ) return norm( p - s.b );\n    return abs(cross( s.b - s.a , p - s.a ) / norm( s.b - s.a ));\n}\n\nPoint midPoint(const Segment &s) {\n    return Point((s.a.x + s.b.x) / 2, (s.a.y + s.b.y) / 2);\n}\n\n\nbool solve() {\n    int n; cin >> n;\n    if(n == 0) return 0;\n    vector<Point> P(n); cin >> P;\n    int ans = 0;\n    rep(i, n) rep(j, i) if(distance(P[i], P[j]) <= 2.0 + EPS){\n        Point a = P[i] - P[j];\n        // double len = sqrt(1 - pow(distance(P[i], P[j]) / 2, 2));\n        double len = sqrt(1 - distance2(midPoint(Segment(P[i], P[j])), P[j]));\n        Point c = len * orthonormal(a) + midPoint(Segment(P[i], P[j]));\n        int cnt = 0;\n        rep(l, n) {\n            cnt += distance2(P[l], c) <= 1.0 + EPS;\n        }\n        ans = max(ans, cnt);\n    }\n    cout << ans << endl;\n    return 1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define EPS 1.0e-4\nusing namespace std;\n\ntypedef struct {\n  double x,y;\n} P;\n\ndouble dis(P p ){\n  return sqrt( p.x*p.x + p.y*p.y );\n}\ndouble dis(P p1,P p2 ){\n  P p;\n  p.x = p1.x-p2.x;\n  p.y = p1.y-p2.y;\n  return dis( p );\n}\n\n\nint main(){\n  int n, mx;\n  P p[301], m, p1,p2, mv,dmv, c[2];\n  double x;\n\n  while( cin>>n && n ){\n    for( int i=0;i<n;i++ )\n      cin >> p[i].x >> p[i].y ;\n\n    mx=0;\n\n    for( int i=0;i<n;i++ ){\n      for( int j=i+1;j<n;j++ ){\n\tif( dis(p[i],p[j]) < 2.0 + EPS ){\n\t  p1=p[i]; p2=p[j];\n\t  m.x = (p1.x+p2.x)/2.0;\n\t  m.y = (p1.y+p2.y)/2.0;\n\n\t  x = sqrt( 1-dis(p1,m) );\n\t  // ツ陳心ツ点 cツづーツ仰づ淞づゥ\n\t  if( fabs( p1.x-p2.x ) < EPS ){\n\t    mv.x=1.0;  mv.y=0.0;\n\t  }else{\n\t    double a1 = ( p2.y-p1.y )/( p2.x-p1.x );\n\t    mv.x=1.0; mv.y=-1.0/a1;\n\t  }\n\t  double scale = dis( mv );\n\t  dmv.x = x*mv.x / scale;\n\t  dmv.y = x*mv.y / scale;\n\n\t  c[0].x=m.x+dmv.x; c[0].y=m.y+dmv.y;\n\t  c[1].x=m.x-dmv.x; c[2].y=m.y-dmv.y;\n\n\t  for( int cn=0;cn<2;cn++ ){\n\t    int sum=0;\n\t    for( int k=0;k<n;k++ ){\n\t      if( dis( c[cn],p[k] ) < 1.0 + EPS )\n\t\tsum++;\n\t    }\n\t    if( mx<sum ) mx=sum;\n\t  }\n\t}\n      }\n    }\n    cout << mx << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint main(void) {\n  for(int N; cin >> N, N > 0;) {\n    double x[300], y[300];\n    REP(i, 0, N) cin >> x[i] >> y[i];\n\n    int answer = 1;\n    REP(i, 0, N) {\n      REP(j, i + 1, N) {\n        double tan = (y[i] - y[j]) / (x[i] - x[j]);\n        double cot = (x[i] - x[j]) / (y[i] - y[j]);\n        double dsq = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n        if(dsq > 4.0) continue;\n        double l = sqrt(1. - dsq / 4.);\n        double sx = (x[i] + x[j]) / 2.;\n        double sy = (y[i] + y[j]) / 2.;\n\n        double cx1 = sx - tan * l;\n        double cy1 = sy + cot * l;\n        int cnt1 = 0;\n        REP(k, 0, N) if(k == i || k == j || (x[k] - cx1) * (x[k] - cx1) + (y[k] - cy1) * (y[k] - cy1) <= 1.0) cnt1++;\n        answer = max(answer, cnt1);\n\n        double cx2 = sx + tan * l;\n        double cy2 = sy - cot * l;\n        int cnt2 = 0;\n        REP(k, 0, N) if(k == i || k == j || (x[k] - cx2) * (x[k] - cx2) + (y[k] - cy2) * (y[k] - cy2) <= 1.0) cnt2++;\n        answer = max(answer, cnt2);\n      }\n    }\n\n    cout << answer << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define INF 120000000\n#define EPS 1e-6\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef long long int LL;\nvector<P> in;\n\nvoid read(int &n) {\n    in.resize(n);\n    for (int i = 0; i < n; i++) {\n        double x, y;\n        cin >> x >> y;\n        in[i] = P(x, y);\n    }\n}\n\nint solve(int &n) {\n    int mx = 1;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            P c[2];\n            double v, w;\n            v = abs(in[i] - in[j]);\n            if (v > 2.0) continue;\n            w = sqrt(1.0 - v * v / 4.0);\n            // cout << w << endl;\n            P un1 = ((in[i] - in[j]) * P(0, 1)) / v;\n            P un2 = ((in[i] - in[j]) * P(0, -1)) / v;\n            // cout << real(un2) << \" \" << imag(un2) << endl;\n            c[0] = un1 * w + (in[i] + in[j]) / 2.0;\n            c[1] = un2 * w + (in[i] + in[j]) / 2.0;\n            // cout << real((in[i] + in[j]) / 2.0) << \" \" << imag((in[i] + in[j]) / 2.0) << endl;\n            // cout << real(c[0]) << \" \" << imag(c[0]) << endl;\n\n            for (int k = 0; k < 2; k++) {\n                // cout << real(c[k]) << \" \" << imag(c[k]) << endl;\n                int cnt = 0;\n                for (int l = 0; l < n; l++) {\n                    // cout << i << \" \" << j << \" \" << l << \" \" << abs(c[k] - in[l]) << endl;\n                    if (abs(c[k] - in[l]) <= 1.0 + EPS) {\n                        cnt++;\n                    }\n                }\n                mx = max(mx, cnt);\n            }\n        }\n    }\n\n    return mx;\n}\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        read(n);\n        cout << solve(n) << endl;\n        in.clear();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<double,double> P;\ntypedef pair<int,P> PP;\n\nint n;\nint ans;\nvector<double> x, y;\nvector<PP> v;\n\nvoid solve(){\n\tx.clear(); y.clear(); v.clear();\n\tx.resize(n); y.resize(n);\n\tans = 1;\n\trep(i,n) cin >> x[i] >> y[i];\n\tfor(int i = 0; i <= 1000; i++) for(int j = 0; j <= 1000; j++){\n\t\tdouble I = i/100.0, J = j/100.0;\n\t\tint cnt = 0;\n\t\trep(k,n){\n\t\t\tif((x[k]-I)*(x[k]-I)+(y[k]-J)*(y[k]-J) < 1) cnt++;\n\t\t}\n\t\tv.push_back(PP(cnt,P(I,J)));\n\t}\n\tsort(v.begin(),v.end(), greater<PP>());\n\trep(u,100){\n\t\tP p = v[u].second;\n\t\tfor(int i = 0; i <= 100; i++) for(int j = 0; j <= 100; j++){\n\t\t\tdouble I = p.first-0.005+i/10000.0, J = p.second-0.005+j/10000.0;\n\t\t\tint cnt = 0;\n\t\t\trep(k,n){\n\t\t\t\tif((x[k]-I)*(x[k]-I)+(y[k]-J)*(y[k]-J) < 1) cnt++;\n\t\t\t}\n\t\t\tans = max(ans,cnt);\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nint main(){\n\twhile(cin >> n){\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n};\n\nstruct Circle\n{\n\tPoint p; double r;\n\tCircle(Point a, double b) :p(a), r(b) {};\n};\n\ndouble dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;\t//counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;\t\t//c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;\t\t\t\t\t\t\t//a--c--b on line\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tdouble d = abs(c1.p - c2.p);\n\tdouble rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tdouble dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tdouble rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\n\n\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tint ans = 1;\n\t\tvector<Point> v;\n\t\tREP(i, n)\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tv.push_back(Point(x, y));\n\t\t}\n\t\tREP(i, n - 1)\n\t\t{\n\t\t\tFOR(j, 1 + 1, n)\n\t\t\t{\n\t\t\t\tCircle c1(v[i], 1), c2(v[j], 1);\n\t\t\t\tauto vp = is_cc(c1, c2);\n\t\t\t\tint a = vp.size();\n\t\t\t\tchmax(ans, a);\n\t\t\t\tREP(k, vp.size())\n\t\t\t\t{\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tPoint tmp = vp[k];\n\t\t\t\t\tREP(l, n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (abs(tmp - v[l])<= 1) cnt++;\n\t\t\t\t\t}\n\t\t\t\t\tchmax(ans, cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\ntypedef double D;\nD EPS = 1e-8;\n\ntypedef complex<D> P;\nstruct L{\n    P a, b;\n    P vec(){ return b - a; }\n};\ntypedef vector<P> Pol;\n\nint sig(D a) { return a < -EPS ? -1 : a > EPS ? 1 : 0; }\nD dot(P a, P b){ return a.X * b.X + a.Y * b.Y; }\nD cross(P a, P b){ return a.X * b.Y - a.Y * b.X; }\n\nD area(Pol pol) {\n    int n = pol.size();\n    D res = 0;\n    REP(i, n) {\n        res += cross(pol[i], pol[ (i + 1) % n ]);\n    }\n    return abs(res) / 2.0;\n}\n\n// 2点a, bを通る半径rの円の中心\nvector<P> tc2(P a, P b, D r){\n    vector<P> res;\n\n    D d = abs(b - a);\n    if(d > 2 * r) return res;\n\n    P mid = 0.5 * (a + b);\n    P dir = polar(sqrt(r * r - d * d / 4), arg(b - a) + M_PI / 2);\n    res.push_back(mid + dir);\n    res.push_back(mid - dir);\n    return res;\n}\n\nint main(){\n    int N;\n    while(cin >> N && N > 0) {\n        vector<P> ps(N);\n        REP(i, N) {\n            D x, y;\n            cin >> x >> y;\n            ps[i] = P(x, y);\n        }\n\n        int ans = 0;\n        REP(i, N) REP(j, N) if(i != j) {\n            vector<P> cv = tc2(ps[i], ps[j], 1.0);\n            for(auto c : cv) {\n                int sum = 0;\n                REP(k, N) {\n                    if(sig(abs(c - ps[k]) - 1.0) <= 0) {\n                        sum++;\n                    }\n                }\n                ans = max(ans, sum);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\nstruct Point{double x,y;};\ndouble dist(Point a,Point b) {return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));}\n#define eps 0.0001\n\nint main(void){\n    int N;\n    while(cin>>N,N){\n        vector<Point> p(N);\n        int maxcnt=1;\n        rep(i,N)cin>>p[i].x>>p[i].y;\n        rep(i,N){\n            for(int j=i+1;j<N;j++){\n                double d = dist(p[i],p[j]);\n                if(d>2.0)continue;\n                Point C1,C2;\n                C1.x = p[i].x + cos(atan2(p[j].y-p[i].y,p[j].x-p[i].x) + acos(d/2.0));\n                C1.y = p[i].y + sin(atan2(p[j].y-p[i].y,p[j].x-p[i].x) + acos(d/2.0));\n                C2.x = p[i].x + cos(atan2(p[j].y-p[i].y,p[j].x-p[i].x) - acos(d/2.0));\n                C2.y = p[i].y + sin(atan2(p[j].y-p[i].y,p[j].x-p[i].x) - acos(d/2.0));\n                int cnt=0;\n                rep(k,N){\n                    if(pow(C1.x-p[k].x,2) + pow(C1.y-p[k].y,2) <= 1.0+eps)cnt++;\n                }\n                if(maxcnt<cnt)maxcnt=cnt;\n                cnt=0;\n                rep(k,N){\n                    if(pow(C2.x-p[k].x,2) + pow(C2.y-p[k].y,2) <= 1.0+eps)cnt++;\n                }\n                if(maxcnt<cnt)maxcnt=cnt;\n            }\n        }\n        cout<<maxcnt<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# 1 \"1132.cpp\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 175 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"1132.cpp\" 2\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\n# 1 \"./../geometory.cpp\" 1\n# 1 \"geometry.h\"\n# 1 \"<command-line>\"\n# 1 \"geometry.h\"\nusing namespace std;\n\n\n# 1 \"point.cpp\" 1\ntypedef complex<double> Point;\nconst double EPS = 1e-8;\n\n\nint sign(double a){\n    if(a > EPS) return +1;\n    if(a < -EPS) return -1;\n    return 0;\n}\n\n\nnamespace std{\n    bool operator < (const Point& a, const Point& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\n\ndouble dot(Point a, Point b){\n    return real(conj(a) * b);\n}\ndouble cross(Point a, Point b){\n    return imag(conj(a) * b);\n}\n\n\n\ndouble angle(Point a, Point b){\n    return arg(conj(a) * b);\n}\n\n\n\nPoint rotate(Point a, double b, Point c = Point()){\n    return (a - c) * polar(1.0, b) + c;\n}\n\n\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > +EPS) return +1;\n    if (cross(b, c) < -EPS) return -1;\n    if (dot(b, c) < 0) return +2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nenum{ OUT, ON, IN };\n# 4 \"geometry.h\" 2\n# 1 \"line.cpp\" 1\nstruct Line : public vector<Point> {\n    Line(const Point& a, const Point& b) {\n        push_back(a); push_back(b);\n    }\n    Point vector() const {\n        return back() - front();\n    }\n};\n\n\n\n\n\nbool paralell(Line l, Line m){\n    return sign(cross(l.vector(), m.vector())) == 0;\n}\n\n\nbool equalLL(Line l, Line m){\n    return sign(cross(l.vector(), m[0] - l[0])) == 0;\n}\n\n\nbool iLP(Line l, Point p) {\n\n    return sign(cross(l.vector(), p - l[0])) == 0;\n}\n\n\n\nbool iSP(Line s, Point p) {\n    return ccw(s[0], s[1], p) == 0;\n}\n\n\nbool iLS(Line l, Line s) {\n\n    return sign(cross(l.vector(), s[0] - l[0]) * cross(l.vector(), s[1] - l[0])) <= 0;\n}\n\n\nbool iSS(Line s, Line t) {\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n        ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\n\n\nPoint proj(Line l, Point p){\n    double t = dot(p - l[0], l.vector()) / norm(l.vector());\n    return l[0] + t * l.vector();\n}\n\n\nPoint refl(Line l, Point p){\n    return 2.0 * proj(l, p) - p;\n}\n\n\ndouble dLP(Line l, Point p){\n\n    return abs(cross(l.vector(), p - l[0])) / abs(l.vector());\n}\n\n\ndouble dSP(Line s, Point p){\n    if(sign(dot(s.vector(), p - s[0])) <= 0) return abs(p - s[0]);\n    if(sign(dot(-s.vector(), p - s[1])) <= 0) return abs(p - s[1]);\n    return dLP(s, p);\n}\n\n\ndouble dLL(Line l, Line m){\n\n    return paralell(l, m) ? dLP(l, m[0]) : 0;\n}\n\n\ndouble dLS(Line l, Line s){\n    if(iLS(l, s)) return 0;\n    return min(dLP(l, s[0]), dLP(l, s[1]));\n}\n\n\ndouble dSS(Line s, Line t){\n    if(iSS(s, t)) return 0;\n    return min({dSP(s, t[0]), dSP(s, t[1]), dSP(t, s[0]), dSP(t, s[1])});\n}\n\n\nPoint pLL(Line l, Line m){\n    double A = cross(l.vector(), m.vector());\n    double B = cross(l.vector(), l[1] - m[0]);\n    if(sign(A) == 0 && sign(B) == 0) return m[0];\n    if(sign(A) == 0) assert(false);\n    return m[0] + m.vector() * B / A;\n}\n# 5 \"geometry.h\" 2\n# 1 \"polygon.cpp\" 1\ntypedef vector<Point> Polygon;\n\n\nPoint curr(const Polygon& a, int x){ return a[x]; }\nPoint next(const Polygon& a, int x){ return a[(x + 1) % a.size()]; }\nPoint prev(const Polygon& a, int x){ return a[(x - 1 + a.size()) % a.size()]; }\n\n\n\nint contains(const Polygon& P, const Point& p){\n\n    bool in = false;\n    for(int i = 0; i < P.size(); i++){\n        Point a = curr(P, i) - p;\n        Point b = next(P, i) - p;\n        if(a.imag() > b.imag()) swap(a, b);\n\n        if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0){\n            in = !in;\n        }\n        if(sign(cross(a, b)) == 0 && sign(dot(a, b)) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n\n\n\ndouble area(const Polygon& P) {\n    double A = 0;\n    for(int i = 0; i < P.size(); i++){\n        A += cross(curr(P, i), next(P, i));\n    }\n    return abs(A) / 2.0;\n}\n# 6 \"geometry.h\" 2\n# 1 \"convex.cpp\" 1\n\nPolygon convex_hull(vector<Point> ps) {\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<Point> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n\nbool is_convex(const Polygon& P){\n    for(int i = 0; i < P.size(); i++){\n        if(ccw(prev(P, i), curr(P, i), next(P, i)) > 0) return false;\n    }\n    return true;\n}\n\n\n\nPolygon convex_cut(const Polygon& P, Line l){\n    Polygon Q;\n    for(int i = 0; i < P.size(); i++){\n        Point A = curr(P, i), B = next(P, i);\n        if(ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if(ccw(l[0], l[1], A) * ccw(l[0], l[1], B) < 0)\n            Q.push_back(pLL(l, Line(A, B)));\n    }\n    return Q;\n}\n\n\nLine bisector(Point a, Point b){\n    Point mid = (a + b) / 2.0;\n    Point vec = (mid - a) * Point(0.0, 1.0);\n    return Line(mid, mid + vec);\n}\n\n\nPolygon voronoi_cell(Polygon P, const vector<Point>& ps, int s){\n    for(int i = 0; i < ps.size(); i++){\n        if(i != s) P = convex_cut(P, bisector(ps[s], ps[i]));\n    }\n    return P;\n}\n# 7 \"geometry.h\" 2\n# 1 \"circle.cpp\" 1\nstruct Circle {\n    Point p;\n    double r;\n    Circle() {}\n    Circle(Point p, double r) : p(p), r(r) { }\n};\n\n\nint contains(const Circle& C, const Point& p){\n    double d = abs(C.p - p);\n    if(sign(d - C.r) > 0) return OUT;\n    if(sign(d - C.r) == 0) return ON;\n    return IN;\n}\n\n\n\nbool iCS(const Circle& C, const Line& l){\n    int c1 = contains(C, l[0]);\n    int c2 = contains(C, l[1]);\n    if(c1 > c2) swap(c1, c2);\n\n\n    if(c1 == OUT && c2 == IN) return true;\n    if(c1 == IN && c2 == IN) return false;\n    if(c1 == ON) return true;\n    double d = dSP(l, C.p);\n    if(sign(d - C.r) < 0) return true;\n    if(sign(d - C.r) == 0) return true;\n    if(sign(d - C.r) > 0) return false;\n}\n\n\nbool iCC(const Circle& C, const Circle& D){\n\n    double e = abs(C.p - D.p);\n    return sign(e - (C.r + D.r)) <= 0 && sign(e - abs(C.r - D.r)) >= 0;\n}\n\n\n\nvector<Point> pLC(const Line &l, const Circle &c) {\n    vector<Point> res;\n    Point center = proj(l, c.p);\n    double d = abs(center - c.p);\n    double tt = c.r * c.r - d * d;\n    if(tt < 0 && tt > -EPS) tt = 0;\n    if(tt < 0) return res;\n    double t = sqrt(tt);\n    Point vect = l.vector();\n    vect /= abs(vect);\n    res.push_back(center - vect * t);\n    if (t > EPS) {\n        res.push_back(center + vect * t);\n    }\n    return res;\n}\n\n\nvector<Point> pSC(const Line &s, const Circle &c) {\n    vector<Point> ret;\n    vector<Point> nret = pLC(s, c);\n    for (int i = 0; i < nret.size(); i++) {\n        if (iSP(s, nret[i])) ret.push_back(nret[i]);\n    }\n    return ret;\n}\n\n\n\nvector<Point> pCC(Circle a, Circle b){\n    vector<Point> res;\n\n    double l = abs(b.p - a.p);\n\n    if(sign(l) == 0 && sign(a.r - b.r) == 0) assert(false);\n    if(sign(l - abs(a.r - b.r)) < 0 || sign(l - (a.r + b.r)) > 0) return res;\n\n    double th1 = arg(b.p - a.p);\n    if(sign(l - abs(a.r - b.r)) == 0 || sign(l - (a.r + b.r)) == 0){\n        res.push_back(a.p + polar(a.r, th1));\n    }else {\n        double th2 = acos( (a.r * a.r - b.r * b.r + l * l) / (2 * a.r * l) );\n        res.push_back(a.p + polar(a.r, th1 - th2));\n        res.push_back(a.p + polar(a.r, th1 + th2));\n    }\n    return res;\n}\n\n\n\nvector<Point> touching_circle2(Point a, Point b, double r){\n    vector<Point> res;\n\n    double d = abs(b - a);\n    if(d > 2 * r) return res;\n\n    Point mid = 0.5 * (a + b);\n    Point dir = polar(sqrt(r * r - d * d / 4), arg(b - a) + M_PI / 2);\n    res.push_back(mid + dir);\n    res.push_back(mid - dir);\n    return res;\n}\n\n\nCircle touching_circle3(Point a, Point b, Point c){\n\n    Point mid_ab = (a + b) / 2.0;\n    Line bis_ab(mid_ab, (mid_ab - a) * Point(0.0, 1.0));\n    Point mid_bc = (b + c) / 2.0;\n    Line bis_bc(mid_bc, (mid_bc - b) * Point(0.0, 1.0));\n\n    assert(!paralell(bis_ab, bis_bc));\n\n    Point center = pLL(bis_ab, bis_bc);\n    return Circle(center, abs(a - center));\n}\n\n\n\ndouble cc_area(const Circle& c1, const Circle& c2) {\n    double d = abs(c1.p - c2.p);\n    if (c1.r + c2.r < d + EPS) {\n        return 0.0;\n    } else if (d < abs(c1.r - c2.r) + EPS) {\n        double r = min(c1.r, c2.r);\n        return r * r * M_PI;\n    } else {\n        double rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n        double theta = acos(rc / c1.r);\n        double phi = acos((d - rc) / c2.r);\n        return c1.r*c1.r*theta + c2.r*c2.r*phi - d*c1.r*sin(theta);\n    }\n}\n# 8 \"geometry.h\" 2\n# 1 \"circle_tangent.cpp\" 1\n\n\nLine circle_tangent(const Circle& C, double th){\n    Point p0 = C.p + polar(C.r, th);\n    Point p1 = p0 + polar(1.0, th + M_PI / 2);\n    return Line(p0, p1);\n}\n\n\n\n\nvector<double> common_tangents(const Circle& C, const Circle& D){\n    vector<double> res;\n    Point v = D.p - C.p;\n    double l = abs(v);\n    double a = arg(v);\n    if(sign(l - abs(C.r - D.r)) > 0){\n\n\n        double a1 = acos((C.r - D.r) / l);\n        res.push_back(a + a1);\n        res.push_back(a - a1);\n        if(sign(l - (C.r + D.r)) > 0){\n\n\n            double a2 = acos((C.r + D.r) / l);\n            res.push_back(a + a2);\n            res.push_back(a - a2);\n        }\n    }\n    if((sign(l - abs(C.r - D.r)) == 0 || sign(l - (C.r + D.r)) == 0) && sign(l) != 0){\n\n\n        res.push_back(a);\n    }\n    return res;\n}\n\n\n\nvector<Line> tangents_through_point(const Circle& C, const Point& p){\n    vector<Line> tangents;\n    double d = abs(C.p - p);\n\n    double e = sqrt(d * d - C.r * C.r);\n\n    double th = asin(C.r / d);\n    Point q1 = p + (C.p - p) * polar(1.0, +th) * e / d;\n    Point q2 = p + (C.p - p) * polar(1.0, -th) * e / d;\n    tangents.push_back(Line(p, q1));\n    tangents.push_back(Line(p, q2));\n    return tangents;\n}\n# 8 \"geometry.h\" 2\n# 7 \"1132.cpp\" 2\n\nint main(){\n    int N;\n    while(cin >> N && N > 0) {\n        vector<Point> ps(N);\n        for(int i=0; i<(int)(N); ++i) {\n            double x, y;\n            cin >> x >> y;\n            ps[i] = Point(x, y);\n        }\n\n        int ans = 1;\n        for(int i=0; i<(int)(N); ++i) for(int j=0; j<(int)(N); ++j) if(i != j) {\n            vector<Point> cv = touching_circle2(ps[i], ps[j], 1.0);\n            for(auto c : cv) {\n                int sum = 0;\n                for(int k=0; k<(int)(N); ++k) {\n                    if(sign(abs(c - ps[k]) - 1.0) <= 0) {\n                        sum++;\n                    }\n                }\n                ans = max(ans, sum);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\n#include<complex>\n\nconst double PI=acos(-1);\nconst double EPS=1e-6; //うまくいかなかったらゆるめる\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define diff(P,i) (P[(i+1)%P.size()] - P[i])\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(){;}\n};\nstruct C {\n  P c;double r;\n  C(const P &c,double r):c(c),r(r){}\n};\n\nnamespace std{//演算子の定義\n  bool operator < (const P& a,const P& b) {\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b) {\n    return a.real()==b.real() && a.imag()==b.imag();\n  }\n}\n\n\nvoid printP(const P &p){\n  cout << shosu(10) << p.real() << \" \" << p.imag() << endl;\n}\n\nvoid printL(const L &l) {\n  \tcout << shosu(10) << l[0].real() << \" \" << l[0].imag() << \" \" << l[1].real() << \" \" << l[1].imag() << endl;\n}\n\nvoid printG(const G &g) {\n  for(int i = 0; i < g.size(); i++){\n    cout << shosu(10) << g[i].real() << \" \" << g[i].imag() << endl;\n  }\n}\n\n\n\ndouble dot(P a,P b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(P a,P b) {\n  return imag(conj(a)*b);\n}\n\nP orth(const P &a, const P &b) { //点aを(点bを基準として)90度回転した点\n  P p = a-b;\n  P q(-p.imag(), p.real());\n  return q + b;\n}\n\nint ccw(P a, P b, P c) { //3点の関係性\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\n\nP projection(const L &l, const P &p) { //pの直線l上の射影の点\n  double t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n  return l[0]+t*(l[0]-l[1]);\n}\n\nP reflection(const L &l, const P &p) { //点pの直線lに関して対称な点\n  return p+2.0*(projection(l,p)-p);\n}\n\nbool isorthogonal(const L &l, const L &m) { //2直線の直交判定\n  return fabs(dot(l[1]-l[0], m[1]-m[0])) < EPS;\n}\n\nbool isparallel(const L &l, const L &m) { //2直線の平行判定\n  return fabs(cross(l[1]-l[0],m[1]-m[0])) < EPS;\n}\n\nbool intersectLL(const L &l, const L &m) { //2直線の交差判定\n  return !isparallel(l,m);\n}\n\nbool intersectSS(const L &s, const L &t) { //2線分の交差判定(完全に交差してないとだめ)\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectSP(const L &s, const P &p) { //直線と点の交差判定\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // 三角不等式\n}\n\n\nP crosspointSS(const L &a, const L &b) { //2線分の交点\ndouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\ndouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\nreturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\n\nP crosspointLL(const L &l, const L &m) { //2直線の交点\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nL crosspointCL(C c,L l){ //円と直線の交点\n\tP pr = projection(l,c.c);\n\tP e = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tdouble tmp = c.r * c.r - norm(pr - c.c);\n\tif(abs(tmp) < EPS) tmp = 0;\n\tdouble t = sqrt(tmp);\n\tP a = pr + t * e;\n\tP b = pr - t * e;\n\tif(b < a) swap(a,b);\n\treturn L(a,b);\n}\n\nL crosspointCC(C a,C b){ //2円の交点\n\tP tmp = b.c - a.c;\n\tdouble d = abs(tmp);\n\tdouble q = acos((a.r * a.r + d * d - b.r * b.r)/(2 * a.r * d));\n\tdouble t = arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1 = a.c + polar(a.r, t + q);\n\tP p2 = a.c + polar(a.r, t - q);\n\tif(p2 < p1) swap(p1,p2);\n\treturn L(p1, p2);\n}\n\n\ndouble distancePP(const P &p, const P &q){ //2点間の距離\n  return hypot(p.real()-q.real(), p.imag()-q.imag());\n}\n\ndouble distanceSP(const L &s, const P &p) {//直線と点との距離\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {//2線分の距離\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n\n\n\nP turn(P p,double t){ // 回転\n    return p*exp(P(.0,t*PI/180.0));\n}\n\n\nvector<L> tangentCC(C a,C b){ //2円の接線\n\tif(a.r < b.r) swap(a,b);\n\tdouble d = abs(a.c - b.c);\n\tvector<L> l;\n\tif(d < EPS) return l;\n\tif(a.r + b.r < d - EPS){ //離れている\n\t\tdouble t = acos((a.r + b.r)/d);\n\t\tt = t * 180 / PI;\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), t), b.c + turn(b.r / d * (a.c-b.c), t)));\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), -t), b.c + turn(b.r / d * (a.c-b.c), -t)));\n\t}else if(a.r + b.r < d + EPS){ //外接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\tif(abs(a.r - b.r) < d - EPS){ //交わっている\n\t\tdouble t1 = acos((a.r - b.r) / d);\n\t\tt1 = t1 * 180 / PI;\n\t\tdouble t2 = 180 - t1;\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c-a.c), t1), b.c + turn(b.r / d * (a.c - b.c), -t2)));\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c - a.c), -t1),b.c + turn(b.r / d * (a.c - b.c), t2)));\n\t}else if(abs(a.r - b.r) < d + EPS){ //内接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\treturn l;\n}\n\nL tangentCP(const C &c, const P &p) { //円cの外部にある点pを通るcの接線の接点\n  double d = distancePP(c.c,p);\n  double r = sqrt(d*d - c.r * c.r);\n  C cc(p,r);\n  return crosspointCC(c,cc);\n}\n\n\ndouble area(const G &g) { //多角形の面積\n    double S =0;\n    for(int i = 0; i < g.size(); i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\n\nbool isconvex(const G &g) { //凸かどうか(全ての内角の大きさが180度以下)\n\tint n = g.size();\n  for(int i = 0; i < n; i++)\n    if(ccw(g[(i+n-1)%n], g[i%n], g[(i+1)%n])==-1) return false;\n\treturn true;\n}\n\nint inconvex(const G& g, const P& p) { //多角形と点の関係\n\tbool in = false;\n\tint n = g.size();\n\tfor(int i = 0; i < n; i++){\n\t\tP a = g[i%n] - p;\n\t\tP b = g[(i+1)%n] - p;\n\t\tif(imag(a) > imag(b)) swap(a, b);\n\t\tif(imag(a) < EPS && 0 < imag(b))if(cross(a,b) < 0)in = !in;\n\t\tif(abs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;//ON\n\t}\n\treturn in ? 2 : 0;//IN : OUT;\n}\n\nG convex_hull(G &ps) { // 凸包(点集合 P の全ての点を含む最小の凸多角形)\n  int n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i = 0; i < n; ch[k++] = ps[i++])//lower-hull\n\t\twhile(k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//<=0  ->  ==-1\n\tfor(int i = n-2,t = k+1; i >= 0; ch[k++] = ps[i--])//upper-hull\n\t\twhile(k >= t && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//\n\tch.resize(k-1);\n\treturn ch;\n}\n\ndouble convex_diameter(const G &pt) { //凸多角形の直径(最遠頂点対間距離)\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is] - pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i] - pt[j]) > maxd) {\n      maxd = norm(pt[i] - pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\n\n\nG convex_cut(const G& g, const L& l) { //凸多角形の切断\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = g[i], b = g[(i+1)%g.size()];\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\n\n\nL PerpendicularBisector(const L &l) { //線分の垂直二等分線\n  P p = l[0];\n  P q((l[0].real() + l[1].real())/2.0, (l[0].imag() + l[1].imag())/2.0);\n  L t(q, orth(p,q));\n  return t;\n}\n\nP CircumscribedCircle(const G &g) { //三角形の外接円の半径\n  L l1(g[0],g[1]);\n  L l2(g[1],g[2]);\n  L m1 = PerpendicularBisector(l1);\n  L m2 = PerpendicularBisector(l2);\n  return crosspointLL(m1, m2);\n}\n\n\nP inP(){\n  double x,y;\n//  scanf(\"%lf,%lf\", &x, &y);\n  cin >> x >> y;\n  P p(x,y);\n  return p;\n}\n\n\nL inL(){\n  P p1 = inP();\n  P p2 = inP();\n  L l(p1,p2);\n  return l;\n}\n\nC inC(){\n  P p = inP();\n  double r;\n  cin >> r;\n  C c(p,r);\n  return c;\n}\n\n\nG inG(int n){\n  G g(n);\n  for(int i = 0; i < n; i++){\n    g[i] = inP();\n  }\n  return g;\n}\n\n\nint main(void) {\n    int n;\n    while(cin >> n, n){\n        G g = inG(n);\n        int ans = 1;\n        rep(i,n)loop(j,i+1,n){\n            P t1 = g[i]-g[j];\n            if(abs(t1) + EPS >= 2.0)continue;\n            t1 *= 0.5;\n            P t2 = t1 * P(0,1);\n            t2 /= abs(t2);\n            t2 *= 1 - abs(t1)*abs(t1);\n            P p = g[j] + t1 + t2;\n            int cnt = 0;\n            rep(k,n) if(distancePP(p,g[k]) <= 1.0 + EPS) cnt++;\n            ans = max(ans, cnt);\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#define rep(i,x) for(int i = 0 ; i < x ; i ++)\n#define rep1(i,x) for(int i = 1 ; i <= x ; i ++)\n\ntypedef long double ld;\nconst ld PI = 3.141592653589793238462643383279;\n\nstruct po{\n\tld x;\n\tld y;\n\tpo(ld a){ x = a; y = 0; }\n\tpo(ld a,ld b){ x = a; y = b; }\n\tpo(){}\n\tinline ld operator()(const po& rhs) const {\n\t\treturn x*rhs.x+y*rhs.y;\n\t}\n\tinline ld norm() {\n\t\treturn sqrt((*this)(*this));\n\t}\n\tinline po& operator+=(const po& rhs){\n\t\tx += rhs.x;\n\t\ty += rhs.y;\n\t\treturn *this;\n\t}\n\tinline po& operator-=(const po& rhs){\n\t\tx -= rhs.x;\n\t\ty -= rhs.y;\n\t\treturn *this;\n\t}\n\tinline po& operator*=(const po& rhs){\n\t\tld x_ = x*rhs.x-y*rhs.y;\n\t\ty = x*rhs.y+y*rhs.x;\n\t\tx = x_;\n\t\treturn *this;\n\t}\n\tinline po& operator/=(const po& rhs){\n\t\tld x_ = x*rhs.x+y*rhs.y;\n\t\ty = -x*rhs.y+y*rhs.x;\n\t\tx = x_;\n\t\tld nor = rhs(rhs);\n\t\tx /= nor;\n\t\ty /= nor;\n\t\treturn *this;\n\t}\n\tinline void in(){\n\t\tscanf(\"%Lf%Lf\",&x,&y);\n\t}\n};\ninline po operator+(const po& a, const po& b){ return po(a) += b; }\ninline po operator-(const po& a, const po& b){ return po(a) -= b; }\ninline po operator*(const po& a, const po& b){ return po(a) *= b; }\ninline po operator/(const po& a, const po& b){ return po(a) /= b; }\n\ninline po similar(const po& a,const po& b,const po& c,const po& p,const po& q){\n\treturn p+(q-p)*(c-a)/(b-a);\n}\n\ntypedef pair<po,po> se;\n#define fr first\n#define sc second\n\nstruct li{\n\tld a;\n\tld b;\n\tld c;\n\tli(po p,po q){\n\t\ta = q.y-p.y;\n\t\tb = p.x-q.x;\n\t\tc = p.y*q.x-p.x*q.y;\n\t}\n\t/*explicit li(se s){\n\t\ta = s.sc.y-s.fr.y;\n\t\tb = s.fr.x-s.sc.x;\n\t\tc = s.fr.y*s.sc.x-s.fr.x*s.sc.y;\n\t\tli(s.fr,s.sc);\n\t}*/\n\tli(){}\n\tinline ld operator()(const po& p) const {\n\t\treturn a*p.x+b*p.y+c;\n\t}\n};\n\nvoid intersect(const li &l,const li &m,po* &ret){\n\tif(abs(l.a*m.b-m.a*l.b) <= 1e-18){\n\t\tret = nullptr;\n\t\treturn;\n\t}\n\tret = new po;\n\tret->x = -(l.c*m.b-m.c*l.b)/(l.a*m.b-m.a*l.b);\n\tret->y = -(l.a*m.c-m.a*l.c)/(l.a*m.b-m.a*l.b);\n}\ninline bool on(const po &p,const se &s){\n\treturn (s.fr-p)(s.sc-p) <= 1e-9;\n}\nvoid intersect(const se &s,const se &t,po* &ret){\n\tli l = li(s.fr,s.sc);\n\tli m = li(t.fr,t.sc);\n\tpo *p;\n\tintersect(l,m,p);\n\tif(p == nullptr || (on(*p,s)&&on(*p,t)))ret = p;\n\telse{\n\t\tdelete p;\n\t\tret = nullptr;\n\t}\n}\ninline ld dist(const po &p,const po &q){\n\treturn sqrt((p-q)(p-q));\n}\ninline li perpen(const po &p,const li &l){\n\tli ret;\n\tret.a = l.b;\n\tret.b = -l.a;\n\tret.c = l.a*p.y-l.b*p.x;\n\treturn ret;\n}\ninline po perpen_leg(const po &p,const li &l){\n\tpo ret;\n\tli m = perpen(p,l);\n\tret.x = -(l.c*m.b-m.c*l.b)/(l.a*m.b-m.a*l.b);\n\tret.y = -(l.a*m.c-m.a*l.c)/(l.a*m.b-m.a*l.b);\n\treturn ret;\n}\ninline ld dist(const po &p,const se &s){\n\tpo h = perpen_leg(p,li(s.fr,s.sc));\n\tif(on(h,s))return dist(p,h);\n\telse return min( dist(p,s.fr) , dist(p,s.sc) );\n}\ninline ld dist(const se &s,const se &t){\n\tpo *p;\n\tintersect(s,t,p);\n\tif(p != nullptr){\n\t\tdelete p;\n\t\treturn 0.0;\n\t}\n\tld ret = min( dist(s.fr,t) , dist(s.sc,t) );\n\tret = min( ret , min( dist(t.fr,s) , dist(t.sc,s) ) );\n\treturn ret;\n}\n\nstruct ci{\n\tpo c;\n\tld r;\n\tinline bool internal(const po &p){\n\t\treturn dist(p,c) <= r+1e-9;\n\t}\n};\n\nci circum(const po &p,const po &q,const po &r){\n\tci ret;\n\tli l = perpen((p+q)/2.0,li(p,q));\n\tli m = perpen((q+r)/2.0,li(q,r));\n\tpo* _c;\n\tintersect(l,m,_c);\n\tif(_c == nullptr){\n\t\tret.c = po(0.0,0.0);\n\t\tret.r = -1.0;\n\t\treturn ret;\n\t}\n\telse {\n\t\tret.c = *_c;\n\t\tret.r = dist(ret.c,p);\n\t\tdelete _c;\n\t\treturn ret;\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0)break;\n\t\tpo p[302];\n\t\trep1(i,n){\n\t\t\tp[i].in();\n\t\t}\n\t\tint ret = 1;\n\t\tfor(int i = 1 ; i <= n ; i ++){\n\t\t\tfor(int j = i+1 ; j <= n ; j ++){\n\t\t\t\tfor(int k = j+1 ; k <= n ; k ++){\n\t\t\t\t\tci c = circum(p[i],p[j],p[k]);\n\t\t\t\t\tif(c.r < -1e-9 || c.r >= 1.0+1e-9)continue;\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\trep1(l,n){\n\t\t\t\t\t\tif(c.internal(p[l]))cnt ++;\n\t\t\t\t\t}\n\t\t\t\t\tret = max( ret , cnt );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ret == 1){\n\t\t\tfor(int i = 1 ; i <= n ; i ++){\n\t\t\t\tfor(int j = i+1 ; j <= n ; j ++){\n\t\t\t\t\tif(dist(p[i],p[j]) >= 2.0+1e-9)continue;\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\trep1(k,n){\n\t\t\t\t\t\tif(on(p[k],se(p[i],p[j])))cnt ++;\n\t\t\t\t\t}\n\t\t\t\t\tret = max( ret , cnt );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) x.begin(),x.end()\nconst long double PI = acos(-1.0L);\nconst long long MOD = 1000000007LL;\n// const long long MOD = 998244353LL;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true;} return false; }\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nusing DD = double; // 精度が足りないときはlong double\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\n//点\nstruct Point {\n    DD x, y;\n    Point (DD x = 0, DD y = 0): x(x), y(y) {}\n\n    Point& operator+=(const Point &p) { x += p.x; y += p.y; return *this;}\n    Point operator+(const Point &p) const { return Point(*this) += p;}\n    Point& operator-=(const Point &p) { x -= p.x; y -= p.y; return *this;}\n    Point operator-(const Point &p) const { return Point(*this) -= p;}\n    Point& operator*=(DD a) { x *= a; y *= a; return *this;}\n    Point operator*(DD a) const { return Point(*this) *= a;}\n    Point& operator/=(DD a) { x /= a; y /= a; return *this;}\n    Point operator/(DD a) const { return Point(*this) /= a;}\n    bool operator== (const Point &p) const { return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;}\n    friend istream& operator >>(istream& is, Point& p) { is >> p.x >> p.y; return is;}\n    friend ostream& operator <<(ostream& os, const Point& p) { os<<p.x<<\" \"<<p.y; return os;}\n};\ntypedef Point Vector; //ベクトル\n\ninline DD norm(const Vector &a) { return a.x * a.x + a.y * a.y;}\ninline DD abs(const Vector &a) { return sqrt(norm(a));}\ninline DD dot(const Vector &a, const Vector &b) { return a.x * b.x + a.y * b.y;}\ninline DD cross(const Vector &a, const Vector &b) { return a.x * b.y - a.y * b.x;}\ninline Point rot(const Point &p, DD ang) { return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\ninline Point rot90(const Point &p) { return Point(-p.y, p.x);}\n\n//線分\nstruct Segment {\n    Point p1,p2;\n    Segment(Point p1 = Point(), Point p2 = Point()): p1(p1),p2(p2) {}\n};\ntypedef Segment Line; //直線\n\nstruct Circle {\n    Point c;\n    DD r;\n    Circle(Point c = Point(), DD r = 0): c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon; //多角形\n\n//射影\nPoint project(const Segment &s, const Point &p) {\n    Vector base = s.p2 - s.p1;\n    DD r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\ninline Point reflect(const Segment &s, const Point &p) {return p + (project(s,p) - p) * (DD)2;} //線対称\n\nint ccw(const Point &p0, const Point &p1, const Point &p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a,b) > EPS) return 1; //p0,p1から見てp2は左側(反時計回り)\n    if (cross(a,b) < -EPS) return -1; //p0,p1から見てp2は右側(時計回り)\n    if (dot(a,b) < -EPS) return 2; //p2-p0-p1の順に一直線上\n    if (norm(a) < norm(b)) return -2; //p0-p1-p2の順に一直線上\n    return 0; //p0-p2-p1の順に一直線上\n}\n//線分p1,p2とp3,p4の交差判定\ninline bool intersect(const Point &p1, const Point &p2, const Point &p3, const Point &p4) { return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);}\ninline bool intersect(const Segment &s1, const Segment &s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2);}\n\ninline DD getDistanceLP(const Line &l, const Point &p) { return abs(cross(l.p2 - l.p1,p - l.p1) / abs(l.p2 - l.p1));}\nDD getDistanceSP(const Segment &s, const Point &p) {\n    if (dot(s.p2 - s.p1,p - s.p1) < 0.0) return abs(p - s.p1);\n    if (dot(s.p1 - s.p2,p - s.p2) < 0.0) return abs(p - s.p2);\n    return getDistanceLP(s, p);\n}\nDD getDistance(const Segment &s1, const Segment &s2) {\n    if (intersect(s1, s2)) return (DD)0;\n    return min({getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2), getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)});\n}\n\n//線分と線分の交点\nPoint getCrossPoint(const Segment &s1, const Segment &s2) {\n    Vector base = s2.p2 - s2.p1;\n    DD d1 = abs(cross(base, s1.p1 - s2.p1));\n    DD d2 = abs(cross(base, s1.p2 - s2.p1));\n    DD t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n//円と直線の交差判定\ninline bool intersect(const Circle &c, const Line &l) { return getDistanceLP(l, c.c) - c.r < EPS;}\n//円と円の交差判定\ninline bool intersect(const Circle &c1, const Circle &c2) { return abs(c1.c - c2.c) - (c1.r + c2.r) < EPS && fabs(c1.r - c2.r) - abs(c1.c - c2.c) < EPS;}\n\n//円と線分の交点\npair<Point, Point> getCrossPoints(const Circle &c, const Line &l) {\n    assert(intersect(c,l));\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    DD base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\ninline DD arg(const Vector &p) { return atan2(p.y, p.x);}\ninline Vector polar(DD a, DD r) { return Point(cos(r) * a, sin(r) * a);}\n\n//円と円の交点\npair<Point, Point> getCrossPoints(const Circle &c1, const Circle &c2) {\n    assert(intersect(c1, c2));\n    DD d = abs(c1.c - c2.c);\n    DD a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (DD(2) * c1.r * d));\n    DD t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\nint ort(const Point &a) { //象限\n    if (norm(a) < EPS) return 0;\n    if (a.y > 0) return a.x > 0 ? 1 : 2;\n    return a.x > 0 ? 4 : 3;\n}\n\nbool xsort(const Point &a, const Point &b) {\n    if (equals(a.x, b.x)) return a.y < b.y;\n    return a.x < b.x;\n}\n\nbool ysort(const Point &a, const Point &b) {\n    if (equals(a.y, b.y)) return a.x < b.x;\n    return a.y < b.y;\n}\n\nbool argsortcross(const Point &a, const Point &b) {\n    int ao = ort(a), bo = ort(b);\n    if (ao != bo) return ao < bo;\n    return cross(a,b) > 0;\n}\n\nbool argsortatan2(const Point &a, const Point &b) {\n    return atan2(a.y, a.x) < atan2(b.y, b.x);\n}\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    while (1) {\n        int N; cin >> N;\n        if (N==0) break;\n        Polygon P(N);\n        rep(i,N) cin >> P[i];\n\n        vector<Circle> C(N);\n        rep(i,N) {\n            C[i].c = P[i];\n            C[i].r = 1;\n        }\n        vector<Point> A;\n        for (int i = 0; i < N-1; i++) {\n            for (int j = i+1; j < N; j++) {\n                if (intersect(C[i],C[j])) {\n                    Point p1,p2;\n                    tie(p1,p2) = getCrossPoints(C[i],C[j]);\n                    A.emplace_back(p1);\n                    A.emplace_back(p2);\n                }\n            }\n        }\n\n        int ans = 1;\n        for (auto p : A) {\n            int cnt = 0;\n            rep(i,N) {\n                if (abs(p-P[i]) - (DD)1 < EPS) cnt++;\n            }\n            chmax(ans,cnt);\n        }\n\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n\nusing namespace std;\ntypedef pair<double, double> P;\nconst double EPS = 1e-6;\n\n#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n\nusing namespace std;\n\ndouble dist(P a, P b)\n{\n    return hypot(a.first - b.first, a.second - b.second);\n}\n\nvector<P> center(P a, P b)\n{\n    auto t = atan2(b.first - a.first, b.second - a.second);\n    auto x = dist(a, b) / 2;\n    auto y = sqrt(1.0 - x * x);\n    return { \n        { cos(t) * x - sin(t) * y + a.first, sin(t) * x + cos(t) * y + a.second },\n        { cos(t) * x + sin(t) * y + a.first, sin(t) * x - cos(t) * y  + a.second },\n    };\n}\n\nint main()\n{\n    while (1) {\n        int n; cin >> n;\n        if (!n) break;\n        vector<P> pnt;\n        loop (n, i) {\n            double x, y; cin >> x >> y;\n            pnt.emplace_back(x, y);\n        }\n        int ans = 1;\n        loop (n, i) loop (n, j) {\n            if (dist(pnt[i], pnt[j]) < 2) ans = 2;\n        }\n        loop (n, i) loop (n, j) {\n            auto ps = center(pnt[i], pnt[j]);\n            for (auto o : ps) {\n                int cnt = 0;\n                loop (n, l) {\n                    if (dist(o, pnt[l]) < 1 + EPS) cnt++;\n                }\n                ans = max(ans, cnt);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<iostream>\nusing namespace std;\n#define EPS 1.0e-6\n#define F(I,J,N) for(int I=J;I<N;I++)\n\nclass point{\npublic:\n\tdouble x,y;\n\tpoint(){}\n\tpoint(double x,double y){\n\t\tthis->x=x;\n\t\tthis->y=y;\n\t}\n\tdouble len(point &p){\n\t\treturn sqrt((x-p.x)*(x-p.x)+(y-p.y)*(y-p.y));\n\t}\n\tdouble len(){\n\t\treturn sqrt(x*x+y*y);\n\t}\n\tpoint operator*(double d){\n\t\tpoint p(x*d,y*d);\n\t\treturn p;\n\t}\n\tpoint operator/(double d){\n\t\tpoint p(x/d,y/d);\n\t\treturn p;\n\t}\n\tpoint operator+(const point &o){\n\t\tpoint p(x+o.x,y+o.y);\n\t\treturn p;\n\t}\n\tpoint operator-(const point &o){\n\t\tpoint p(x-o.x,y-o.y);\n\t\treturn p;\n\t}\n\tpoint& operator=(const point &o){\n\t\tthis->x=o.x;\n\t\tthis->y=o.y;\n\t\treturn *this;\n\t}\n\tbool operator==(const point &o){\n\t\treturn (x==o.x && y==o.y);\n\t}\n\tbool operator!=(const point &o){\n\t\treturn !(x==o.x && y==o.y);\n\t}\n};\n\nint main(){\n\tint n;\n\tpoint *p;\n\tint ans;\n\tpoint c,ce,h;\n\twhile(cin>>n){\n\t\tc=ce;\n\t\tif(n==0) break;\n\t\tp=new point[n];\n\t\tans=0;\n\t\tF(i,0,n) cin>>p[i].x>>p[i].y;\n\t\tF(i,0,n-1){\n\t\t\tF(j,i+1,n){\n\t\t\t\tif(p[i].len(p[j])<2+EPS){\n\t\t\t\t\tc=(p[i]+p[j])/2;\n\t\t\t\t\th.x=-(p[i]-p[j]).y;\n\t\t\t\t\th.y=(p[i]-p[j]).x;\n\t\t\t\t\tdouble len=p[i].len(p[j]);\n\t\t\t\t\tlen=sqrt(1-len*len/4);\n\t\t\t\t\th=h*(len/h.len());\n\n\t\t\t\t\tce=c+h;\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tF(k,0,n) if(ce.len(p[k])<1+EPS) cnt++;\n\t\t\t\t\tans=max(ans,cnt);\n\n\t\t\t\t\tce=c-h;\n\t\t\t\t\tcnt=0;\n\t\t\t\t\tF(k,0,n) if(ce.len(p[k])<1+EPS) cnt++;\n\t\t\t\t\tans=max(ans,cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans==0) ans=1;\n\t\tcout<<ans<<endl;\n\t\tdelete []p;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define endl \"\\n\"\n#define rep(i, a, b) for (auto i = (a); i < (b); ++i)\n#define rrep(i, a, b) for (auto i = (a); i > (b); --i)\n#define UNIQUE(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\n\n#ifdef LOCAL_DEFINE\nstruct InitInput\n{\n  InitInput()\n  {\n    FILE *stream1;\n    stream1 = freopen(\"in.txt\", \"r\", stdin);\n    assert(stream1 != nullptr);\n    cerr << \"This problem is not interactive\" << endl;\n  }\n} LOCAL_INPUT;\nstruct LOCAL_OUTPUT\n{\n  LOCAL_OUTPUT()\n  {\n    FILE *stream2;\n    const char *outputfile = \"out.txt\";\n    stream2 = freopen(outputfile, \"w\", stdout);\n    assert(stream2 != nullptr);\n    cerr << \"output [ \" << outputfile << \" ]\" << endl;\n  }\n} /*LOCAL_OUTPUT*/;\n#define show(x) cerr << #x << \" = \" << (x) << \" (line \" << __LINE__ << \")\" << endl\n#define showA(a, n)                                            \\\n  do                                                           \\\n  {                                                            \\\n    for (int _i_t_e_ = 0; _i_t_e_ < (n); _i_t_e_++)            \\\n      cerr << \"(\" << _i_t_e_ << \" = \" << (a)[_i_t_e_] << \") \"; \\\n    cerr << endl;                                              \\\n  } while (0)\n#define showA2(a, n, m)                                                                        \\\n  do                                                                                           \\\n  {                                                                                            \\\n    for (int _i_t_e_ = 0; _i_t_e_ < (n); _i_t_e_++)                                            \\\n    {                                                                                          \\\n      for (int _i_t_e_2 = 0; _i_t_e_2 < (m); _i_t_e_2++)                                       \\\n      {                                                                                        \\\n        cerr << \"(\" << _i_t_e_ << \", \" << _i_t_e_2 << \" = \" << (a)[_i_t_e_][_i_t_e_2] << \") \"; \\\n      }                                                                                        \\\n      cerr << endl;                                                                            \\\n    }                                                                                          \\\n    cerr << endl;                                                                              \\\n  } while (0)\n#else\n#define show(x)\n#define showA(a, n)\n#define showA2(a, n, m)\n#endif\n\nstruct InitAim\n{\n  InitAim()\n  {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(12);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    cerr << \"This problem is not interactive\" << endl;\n#endif\n  }\n} aim_cpo;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconstexpr const int INT_INF = 0x3f3f3f3f;       //1061109567\nconstexpr const ll LL_INF = 0x3f3f3f3f3f3f3f3f; //4557430888798830399\n\ntemplate <typename T>\nbool chmin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate <typename T>\nbool chmax(T &a, T b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T>\nvoid ln(T i, T n) { cout << (i == n - 1 ? \"\\n\" : \" \"); }\ntemplate <typename T, typename S>\nostream &operator<<(ostream &out, const pair<T, S> &pair1)\n{\n  out << '(' << pair1.fi << \", \" << pair1.se << ')';\n  return out;\n}\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &vector1)\n{\n  out << '[';\n  for (unsigned int i = 0; i < vector1.size(); i++)\n  {\n    out << vector1[i];\n    if (i == vector1.size() - 1)\n      out << \"]\";\n    else\n      out << \", \";\n  }\n  return out;\n}\n\n// INT\n#define GCD(a, b) __gcd(a, b)\ntemplate <typename T>\nT LCM(T a, T b)\n{\n  return a / GCD(a, b) * b;\n}\ntemplate <typename T>\nT EXTGCD(T a, T b, T &x, T &y)\n{\n  T d = a;\n  if (b != 0)\n  {\n    d = EXTGCD(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n  else\n    x = 1, y = 0;\n  return d;\n}\ntemplate <typename T>\nbool is_prime(T a)\n{\n  for (int i = 2; i * i <= a; i++)\n    if (a % i == 0)\n      return true;\n  return false;\n}\ntemplate <typename T, typename S>\nT Pow(T a, S b)\n{\n  T res = 1, now = a;\n  while (b)\n  {\n    if (b & 1)\n      res *= now;\n    b >>= 1;\n    now *= now;\n  }\n  return res;\n}\n\n// MOD\nll MOD = 1000000000L + 7L;\n#define Madd(a, b) (((a) % MOD) + ((b) % MOD)) % MOD\n#define Mmul(a, b) (((a) % MOD) * ((b) % MOD)) % MOD\n#define Msub(a, b) (((a) % MOD) + MOD - ((b) % MOD)) % MOD\ntemplate <typename T, typename S>\nT ModPow(T a, S b)\n{\n  assert(b >= 0);\n  T res = 1, now = Msub(a, 0);\n  while (b)\n  {\n    if (b & 1)\n      res = Mmul(res, now);\n    b >>= 1;\n    now = Mmul(now, now);\n  }\n  return res;\n}\ntemplate <typename T>\nT ModInverse(T a, T mod, bool prime)\n{ // if mod is prime, \"prime\" is true.\n  if (prime)\n    return ModPow(a, mod - 2);\n  else\n  {\n    T x, y;\n    EXTGCD(a, mod, x, y);\n    return (mod + x % mod) % mod;\n  }\n}\ntemplate <typename T>\nT EulerTotient(T a)\n{\n  vector<pair<int, int>> v;\n  for (T i = 2; i * i <= a; i++)\n  {\n    int cnt = 0;\n    while (a % i == 0)\n    {\n      cnt++;\n      a /= i;\n    }\n    if (cnt != 0)\n      v.emplace_back(i, cnt);\n  }\n  if (a != 1)\n    v.emplace_back(a, 1);\n  //showV(v, (int) v.size());\n  T res = 1;\n  for (int i = 0; i < (int)v.size(); i++)\n  {\n    if (v[i].se == 1)\n    {\n      //res *= v[i].fi - 1;\n      res = Mmul(res, v[i].fi - 1);\n    }\n    else\n    {\n      //res *= Pow(v[i].fi, v[i].se) - Pow(v[i].fi, v[i].se - 1);\n      res = Mmul(res, Msub(ModPow(v[i].fi, v[i].se), ModPow(v[i].fi, v[i].se - 1)));\n    }\n  }\n  return res;\n}\n#define Mdivide(a, b) Mmul(((a) % MOD), (ModInverse((b), MOD, true))) % MOD\nll comb(ll a, ll b)\n{\n  chmin(b, a - b);\n  ll res = 1LL, now = a;\n  for (ll i = 1; i <= b; i++)\n  {\n    res = Mmul(res, now);  //res *= now;\n    res = Mdivide(res, i); // res /= i;\n    now--;\n  }\n  return res;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// TEMPLATE(data structure)\n///////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename T>\nclass BIT\n{\npublic:\n  BIT(int size)\n  {\n    BITTable.assign(++size, 0);\n  }\n  T sum(int k)\n  {\n    T res = 0;\n    for (++k; k > 0; k -= k & -k)\n    {\n      res += BITTable[k];\n    }\n    return res;\n  }\n  T sum(int l, int r)\n  {\n    if (l == 0)\n      return sum(r);\n    return sum(r) - sum(l - 1);\n  }\n  void update(int k, T x)\n  { // b[k] += x;\n    for (++k; k < (int)BITTable.size(); k += k & -k)\n      BITTable[k] += x;\n  }\n\nprivate:\n  vector<T> BITTable;\n};\n\ntemplate <typename T>\nclass IntervalTree\n{\n  using F = function<T(T, T)>;\n\npublic:\n  IntervalTree(int n, const F func, const T init) : func(func), init(init)\n  {\n    size = 1;\n    while ((int)size < n)\n      size <<= 1;\n    table.assign(2 * size, init);\n  }\n  void set(int k, T &x)\n  {\n    table[size + k] = x;\n  }\n  void build()\n  {\n    for (int i = size - 1; i >= 0; --i)\n    {\n      table[i] = func(table[i * 2], table[i * 2 + 1]);\n    }\n  }\n  void update(int k, const T &x)\n  {\n    k += size;\n    table[k] = x;\n    while (k >>= 1)\n    {\n      table[k] = func(table[k * 2], table[k * 2 + 1]);\n    }\n  }\n  T query(int a, int b)\n  {\n    T L = init, R = init;\n    for (a += size, b += size; a < b; a >>= 1, b >>= 1)\n    {\n      if (a & 1)\n        L = func(L, table[a++]);\n      if (b & 1)\n        R = func(table[--b], R);\n    }\n    return func(L, R);\n  }\n  T operator[](const int k) const\n  {\n    return table[k + size];\n  }\n\nprivate:\n  unsigned int size;\n  vector<T> table;\n  const F func;\n  const T init;\n};\n\nclass UnionFind\n{\npublic:\n  explicit UnionFind(int _n) : n(_n)\n  {\n    par.resize(static_cast<unsigned long>(_n));\n    rank.resize(static_cast<unsigned long>(_n));\n    sizes.resize(static_cast<unsigned long>(_n));\n    for (int i = 0; i < _n; i++)\n    {\n      par[i] = i;\n      rank[i] = 0;\n      sizes[i] = 1;\n    }\n  }\n  int find(int a)\n  {\n    if (par[a] == a)\n      return a;\n    return par[a] = find(par[a]);\n  }\n  bool same(int a, int b)\n  {\n    return find(a) == find(b);\n  }\n  void unite(int a, int b)\n  {\n    link(find(a), find(b));\n  }\n  int size(int a)\n  {\n    return sizes[find(a)];\n  }\n  void view()\n  {\n    for (int i = 0; i < n; i++)\n    {\n      cout << \" par\"\n           << \"[\" << i << \"]=\" << par[i] << ((i == n - 1) ? \"\\n\" : \",\");\n    }\n    for (int i = 0; i < n; i++)\n    {\n      cout << \"size\"\n           << \"[\" << i << \"]=\" << sizes[i] << ((i == n - 1) ? \"\\n\" : \",\");\n    }\n    cout << endl;\n  }\n\nprivate:\n  void link(int a, int b)\n  {\n    if (same(a, b))\n      return;\n    if (rank[a] > rank[b])\n    {\n      par[b] = a;\n      sizes[a] += sizes[b];\n      sizes[b] = 0;\n    }\n    else\n    {\n      par[a] = b;\n      if (rank[a] == rank[b])\n        rank[b]++;\n      sizes[b] += sizes[a];\n      sizes[a] = 0;\n    }\n  }\n  int n;\n  vector<int> par;\n  vector<int> rank;\n  vector<int> sizes;\n};\n\nnamespace geo\n{\n#define IL inline\ntypedef double D;\ntypedef bool B;\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\ntemplate <typename T, typename S>\nostream &operator<<(ostream &out, const P &point1)\n{\n  out << '(' << point1.X << \", \" << point1.Y << ')';\n  return out;\n}\nB comp(const P &l, const P &r)\n{\n  return (l.X == r.X) ? l.Y < r.Y : l.X < r.X;\n}\ntypedef pair<P, P> L;  //line\ntypedef pair<P, P> LS; //line segment\ntypedef pair<P, D> C;  //circle\ntypedef vector<P> Poly;\nconst D EPS = 1e-10;\n//Decompotision Macro\n#define DCl(a, b, l) \\\n  P a, b;            \\\n  tie(a, b) = l\n#define DCc(a, b, c) \\\n  P a;               \\\n  D b;               \\\n  tie(a, b) = c\n\n//A dot B\nIL D dot(P a, P b) { return a.X * b.X + a.Y * b.Y; }\n//A cross B\nIL D cross(P a, P b) { return a.X * b.Y - a.Y * b.X; }\nIL D ccw(P a, P b, P c)\n{\n  return cross(b - a, c - a);\n}\n\nIL int sgn(P a, P b, P c)\n{\n  if (cross(b - a, c - a) > EPS)\n    return 1;\n  if (cross(b - a, c - a) < -EPS)\n    return -1;\n  if (dot(b - a, c - a) < -EPS)\n    return 2; // b-a-c\n  if (dot(a - b, c - b) < -EPS)\n    return -2; // a-b-c\n  return 0;\n}\nIL D signed_distance_P_L(P p, L l)\n{\n  DCl(a, b, l);\n  return ccw(a, b, p) / abs(b - a);\n}\n\nIL D distance_P_L(P p, L l)\n{\n  return abs(signed_distance_P_L(p, l));\n}\n\nIL D distance_P_P(P p1, P p2)\n{\n  return abs(p1 - p2);\n}\n\nIL D distance_P_LS(P p, LS ls)\n{\n  DCl(a, b, ls);\n  if (dot(b - a, p - a) < EPS)\n    return abs(p - a);\n  if (dot(a - b, p - b) < EPS)\n    return abs(p - b);\n  return abs(cross(b - a, p - a)) / abs(b - a);\n}\n\nIL B is_L_L(L p, L q)\n{\n  DCl(a, b, p);\n  DCl(c, d, q);\n  return abs(cross(a - b, c - d)) > EPS ||\n         abs(cross(a - b, d - b)) < EPS;\n}\nIL B is_L_LS(L l, LS ls)\n{\n  DCl(a, b, l);\n  DCl(c, d, ls);\n  return ccw(a, b, c) * ccw(a, b, d) < EPS;\n}\nIL B is_LS_LS(LS p, LS q)\n{\n  DCl(a, b, p);\n  DCl(c, d, q);\n  return sgn(a, b, c) * sgn(a, b, d) <= 0 && sgn(c, d, a) * sgn(c, d, b) <= 0;\n}\n\nIL D distance_LS_LS(LS p, LS q)\n{\n  if (is_LS_LS(p, q))\n    return 0;\n  return min({distance_P_LS(p.fi, q),\n              distance_P_LS(p.se, q),\n              distance_P_LS(q.fi, p),\n              distance_P_LS(q.se, p)});\n}\n\n//caution: have to use isintersected_L_L before this function\nIL P cross_L_L(L p, L q)\n{\n  DCl(a, b, p);\n  D d1 = signed_distance_P_L(a, q);\n  D d2 = signed_distance_P_L(b, q);\n  return (a * d2 - b * d1) / (d2 - d1);\n}\n\nIL B is_C_C(C p, C q)\n{\n  DCc(cp, rp, p);\n  DCc(cq, rq, q);\n  D d = abs(cp - cq);\n  return abs(rp - rq) - d < EPS &&\n         rp + rq - d > -EPS;\n}\nIL LS cross_C_C(C p, C q)\n{\n  DCc(cp, rp, p);\n  DCc(cq, rq, q);\n  D d = abs(cp - cq);\n  D rc = (d * d + rp * rp - rq * rq) / (2 * d);\n  D rs = sqrt(rp * rp - rc * rc);\n  P diff = (cq - cp) / d;\n  return {cp + P(rc, rs) * diff, cp + P(rc, -rs) * diff};\n}\nIL Poly convex_hull(Poly p)\n{\n  int n = p.size();\n  Poly res(2 * n);\n  int k = 0, t;\n  sort(all(p), comp);\n  rep(i, 0, n)\n  {\n    while (k > 1 && ccw(res[k - 2], res[k - 1], p[i]) < EPS)\n      k--;\n    res[k++] = p[i];\n  }\n  t = k;\n  rep(j, 0, n - 1)\n  {\n    int i = n - 2 - j;\n    while (k > t && ccw(res[k - 2], res[k - 1], p[i]) < EPS)\n      k--;\n    res[k++] = p[i];\n  }\n  res.resize(k - 1);\n  return res;\n}\nIL B convex_in(Poly &l, P &p)\n{\n  int a = 0, b = l.size(), c;\n  D A, C;\n  P g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n  while (b - a > 1)\n  {\n    c = (a + b) / 2;\n    A = cross(l[a] - g, p - l[a]);\n    C = cross(l[c] - g, p - l[c]);\n    if (cross(l[a] - g, l[c] - g) >= 0)\n    {\n      if (A > -EPS && C < -EPS)\n        b = c;\n      else\n        a = c;\n    }\n    else\n    {\n      if (C < -EPS || A > -EPS)\n        b = c;\n      else\n        a = c;\n    }\n  }\n  return (cross(l[b % l.size()] - l[a], p - l[b % l.size()]) > -EPS);\n}\n\n//not necessary?\nIL D convex_area(Poly &l)\n{\n  double res = 0;\n  int n = l.size();\n  rep(i, 2, n)\n      res += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n  return res;\n}\nIL D area(Poly &l)\n{\n  double res = 0;\n  int n = l.size();\n  rep(i, 0, n)\n      res += cross(l[i], l[(i + 1) % n]);\n  return abs(res) / 2.0;\n}\ninline vector<L> tangent_line(C c, P p)\n{\n  vector<L> res;\n  DCc(cp, r, c);\n  P v = p - cp;\n  D dist = abs(v);\n  if (dist - r > -EPS)\n  {\n    double _cos = r / dist;\n    double _sin = sqrt(1.0 - _cos * _cos);\n    v = v * (r / dist);\n    {\n      P e = P(_cos * v.X - _sin * v.Y, _sin * v.X + _cos * v.Y);\n      res.push_back({p, cp + e});\n    }\n    if (dist - r > EPS)\n    {\n      P e = P(_cos * v.X + _sin * v.Y, -_sin * v.X + _cos * v.Y);\n      res.push_back({p, cp + e});\n    }\n  }\n  return res;\n}\nIL vector<L> inner_common_tangent_line(C p, C q)\n{\n  vector<L> res;\n  DCc(Mp, Rp, p);\n  DCc(Mq, Rq, q);\n  D dist = abs(Mp - Mq);\n  if (dist - (Rp + Rq) > -EPS)\n  {\n    P mid = (Mq * Rp + Mp * Rq) / (Rp + Rq);\n    res = tangent_line(p, mid);\n  }\n  return res;\n}\ninline vector<L> outer_common_tangent_line(C p, C q)\n{\n  vector<L> res;\n  DCc(Mp, Rp, p);\n  DCc(Mq, Rq, q);\n  P v = Mp - Mq;\n  D dist = abs(v);\n  if (dist - abs(Rp - Rq) > -EPS)\n  {\n    if (abs(Rp - Rq) < EPS)\n    {\n      P e = v * P(0, 1);\n      e = e / dist;\n      res.pb(L(Mp + e, Mq + e));\n      res.pb(L(Mp - e, Mq - e));\n    }\n    else\n    {\n      P mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n      res = tangent_line(p, mid);\n    }\n  }\n  return res;\n}\n\nvector<Poly> decomposition(Poly p)\n{\n  int n = p.size();\n  vector<Poly> res;\n  while (n >= 3)\n  {\n    [&]() {\n      rep(i, 0, n)\n      {\n        P a = p[i];\n        P b = p[(i + 1) % n];\n        P c = p[(i + 2) % n];\n        if (ccw(a, b, c) < 0)\n          continue;\n        if ([&]() {\n              rep(j, 3, n)\n              {\n                P d = p[(i + j) % n];\n                if (ccw(a, b, d) > -EPS && ccw(b, c, d) > -EPS && ccw(c, a, d) > -EPS)\n                  return true;\n              }\n              return false;\n            }())\n          continue;\n        Poly nxt;\n        rep(j, 0, n) if ((i + j) % n != (i + 1) % n)\n            nxt.push_back(p[(i + j) % n]);\n        swap(p, nxt);\n        res.push_back({a, b, c});\n        n--;\n        return;\n      }\n    }();\n  }\n  return res;\n}\nint in_triangle(P p, Poly q)\n{\n  rep(i, 0, 3) if (abs(p - q[i]) < EPS) return 3; //on point\n  rep(i, 0, 3)\n  {\n    int s = sgn(q[i], q[(i + 1) % 3], p);\n    if (s != 1)\n    {\n      if (s == 0)\n        return 2; //on line\n      else\n        return 0; // not in\n    }\n  }\n  return 1; // inside triangle\n}\nint in_C(P q, C c)\n{\n  DCc(p, r, c);\n  if (abs(r - abs(p - q)) < EPS)\n    return 2; //on\n  return r - abs(p - q) > -EPS ? 1 : 0;\n}\nint is_triangle_C(Poly t, C c)\n{\n  t = convex_hull(t);\n  DCc(p, r, c);\n  int cnt = 0;\n  rep(i, 0, 3)\n      cnt += (in_C(t[i], c) > 0);\n  if (cnt == 3)\n    return 3; // t in c\n  if (cnt == 0)\n  {\n    double d = distance_P_LS(p, LS(t[2], t[0]));\n    rep(i, 0, 2)\n        d = min(d, distance_P_LS(p, LS(t[i], t[i + 1])));\n    if (r - d > EPS)\n      return 1; //intersect\n    if (in_triangle(p, t))\n      return 2; //c in t\n    else if (r - d < -EPS)\n      return 0; //not intersect\n  }\n  return 1; //intersect\n}\n\n//p must be convex and ccw\nLS diameter(Poly &p)\n{\n  int n = p.size();\n  int is = 0, js = 0;\n  rep(i, 0, n) if (p[i].Y > p[is].Y)\n      is = i;\n  rep(i, 0, n) if (p[i].Y < p[js].Y)\n      js = i;\n  LS res = {p[is], p[js]};\n  {\n    int i = is;\n    int j = js;\n    do\n    {\n      int ni = (i + 1) % n;\n      int nj = (j + 1) % n;\n      if (cross(p[ni] - p[i], p[nj] - p[j]) < EPS)\n        i = ni;\n      else\n        j = nj;\n      if (abs(res.fi - res.se) < abs(p[i] - p[j]))\n        res = LS(p[i], p[j]);\n    } while (i != is || j != js);\n  }\n  return res;\n}\n\nPoly cross_C_L(C c, L v)\n{\n  DCc(p, r, c);\n  DCl(a, b, v);\n  a -= p;\n  b -= p;\n  P u = a - b;\n  u = P(-u.Y, u.X);\n  P x = cross_L_L({a, b}, {P(0, 0), u});\n  D d = abs(x);\n  Poly res;\n  if (d - r > EPS)\n    return res;\n  D y = sqrt(r * r - d * d);\n  res.pb(p + x + (b - a) * y / abs(b - a));\n  //if(d-r>-EPS)return res;\n  res.pb(p + x + (a - b) * y / abs(b - a));\n  return res;\n}\n} // namespace geo\n\n///////////////////////////////////////////////////////////////////////////////////\n// MAIN\n///////////////////////////////////////////////////////////////////////////////////\n// 735134400 約数が1344個ある高度合成数(<= 1e9)\n// 897612484786617600 約数が103680個ある高度合成数(<= 1e18)\n// 苦手分野 重複順列\n// LLの数値をつかう時は最後にLLをつける癖をつけよう\n\nvoid solve(int &n)\n{\n  using namespace geo;\n  vector<P> v(n);\n  rep(i, 0, n)\n  {\n    double x, y;\n    cin >> x >> y;\n    v[i] = (P(x, y));\n  }\n  //show(v);\n  int ans = 1;\n  rep(i, 0, n)\n  {\n    rep(j, i + 1, n)\n    {\n      double d = distance_P_P(v[i], v[j]);\n      if (d > 2.0)\n        continue;\n      //show(d);\n      P mid = (v[i] + v[j]) / 2.;\n      P GetC = (v[i] - v[j]) / d * sqrt(1 - d * d / 4);\n      GetC = P(GetC.Y, -GetC.X);\n      P center = mid + GetC;\n      C c1(center, 1.);\n      int cnt = 0;\n      for (int k = 0; k < n; k++)\n      {\n        if (in_C(v[k], c1))\n          cnt++;\n      }\n      chmax(ans, cnt);\n      cnt = 0;\n      center = mid - GetC;\n      C c2(center, 1.);\n      for (int k = 0; k < n; k++)\n      {\n        if (in_C(v[k], c2))\n          cnt++;\n      }\n      chmax(ans, cnt);\n    }\n  }\n  cout << ans << endl;\n}\n\nint n;\n\nint main()\n{\n  while (cin >> n, n)\n  {\n    solve(n);\n  }\n#ifdef LOCAL_DEFINE\n  cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \"s.\" << endl;\n  show(MOD);\n#endif\n  return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// NOTE\n///////////////////////////////////////////////////////////////////////////////////\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define EPS (1e-4)\ntypedef complex<double> P;\n\nint main() {\n  int n;\n  while (cin >> n, n) {\n    vector<P> a(n);\n    for (auto &e : a) {\n      double x, y;\n      cin >> x >> y;\n      e.real(x);\n      e.imag(y);\n    }\n    int m = 1;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if (abs(a[j] - a[i]) < 2.0 + EPS) {\n          P u = (a[j] - a[i]) / 2.0;\n          P v = P(-u.imag(), u.real()) / abs(u) * sqrt(1.0 - pow(abs(u), 2));\n          vector<P> o = {a[i] + u + v, a[i] + u - v};\n          for (auto e : o) {\n            int t = 2;\n            for (int k = 0; k < n; k++) {\n              if (k != i && k != j) {\n                t += abs(a[k] - e) < 1.0 + EPS;\n              }\n            }\n            m = max(m, t);\n          }\n        }\n      }\n    }\n    cout << m << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nclass Point {\npublic:\n  double x, y;\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n  Point operator +(Point p) {\n    return Point(x+p.x, y+p.y);\n  }\n  Point operator -(Point p) {\n    return Point(x-p.x, y-p.y);\n  }\n  Point operator *(double a) {\n    return Point(x*a, y*a);\n  }\n  Point operator /(double a) {\n    return Point(x/a, y/a);\n  }\n  bool operator ==(const Point &p) const {\n    return x == p.x && y == p.y;\n  }\n};\n\ntypedef Point Vector;\n\ndouble norm(Point p1, Point p2) {\n  return (p1.x-p2.x)*(p1.x-p2.x) + (p1.y-p2.y)*(p1.y-p2.y);\n}\n\nint n;\nPoint p[300];\n\nint calc(Point p1, Point p2) {\n  Point m = Point((p1.x+p2.x)/2.0, (p1.y+p2.y)/2.0);\n  Point o;\n  Vector moto = Vector(p2.y-p1.y, p1.x-p2.x);\n  double l = sqrt(4.0/norm(p1,p2)-1)/2.0;\n  int cnt = 0;\n  int newCnt;\n  for(int t = 0; t < 2; t++) {\n    newCnt = 0;\n    if(t == 1) {\n      moto = moto * (-1);\n    }\n    o = m + moto * l;\n\n    for(int i = 0; i < n; i++) {\n      if(p[i] == p1 || p[i] == p2) continue;\n      if(newCnt + n-i <= cnt) break;\n      if((p[i].x-o.x)*(p[i].x-o.x) + (p[i].y-o.y)*(p[i].y-o.y) <= 1.0) {\n\tnewCnt++;\n      }\n    }\n    if(newCnt > cnt) cnt = newCnt;\n  }\n  return cnt + 2;\n}\n\nmain() {\n  while(1) {\n    int ans;\n    cin >> n;\n    if(n == 0) break;\n    for(int i = 0; i < n; i++) {\n      cin >> p[i].x >> p[i].y;\n    }\n    ans = -1;\n    for(int i = 0; i < n; i++) {\n      for(int j = i+1; j < n; j++) {\n\tans = max(ans, calc(p[i],p[j]));\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\ntypedef long double ld;\n\nstruct Point {\n    ld x, y;\n    Point(ld x=0, ld y=0) : x(x), y(y) {}\n    string to_s() {\n        ostringstream os;\n        os << x << ',' << y;\n        return os.str();\n    }\n    Point operator+(const Point& o) const {\n        return Point(x+o.x, y+o.y);\n    }\n    Point operator/(const int d) const {\n        return Point(x/d, y/d);\n    }\n};\n\nstruct Circle {\n    ld x, y;\n    ld r;\n    Circle(ld x=0, ld y=0, ld r=1) : x(x), y(y), r(r) {}\n    const static ld eps = 1e-11;\n    bool isIntersect(const Circle& o) const {\n        ld dx = o.x - x;\n        ld dy = o.y - y;\n        return (r + o.r) * (r + o.r) > (dx*dx + dy*dy);\n    }\n    pair<Point, Point> intersectionPoint(const Circle& o) const {\n        ld dx = x - o.x;\n        ld dy = y - o.y;\n        ld a = (dx*dx + dy*dy + r*r - o.r*o.r) / 2.0;\n        ld d = sqrt((dx*dx+dy*dy)*r*r-a*a);\n        Point p, q;\n        p.x = (a*dx + dy * d) / (dx*dx+dy*dy) + o.x;\n        q.x = (a*dx - dy * d) / (dx*dx+dy*dy) + o.x;\n        p.y = (a*dy - dx * d) / (dx*dx+dy*dy) + o.y;\n        q.y = (a*dy + dx * d) / (dx*dx+dy*dy) + o.y;\n        //cout << p.x << ',' << p.y << endl;\n        //cout << q.x << ',' << q.y << endl;\n        return make_pair(p, q);\n    }\n    bool contains(ld px, ld py) const {\n        return r + eps >= sqrt((px - x) * (px - x) + (py - y) * (py - y));\n    }\n    string to_s() {\n        ostringstream os;\n        os << x << ',' << y << ':' << r << endl;\n        return os.str();\n    }\n};\n\nint countContainingPoints(const Circle& c, const vector<Circle>& ps) {\n    int cnt = 0;\n    for (int i = 0; i < ps.size(); i++) \n        if (c.contains(ps[i].x, ps[i].y)) \n            cnt++;\n    return cnt;\n}\n\nPoint midPoint(pair<Point, Point>& pp) {\n    return (pp.first + pp.second) / 2;\n}\n\nint N;\nint main() {\n    //cout << Circle(0, 0, 5).intersectionPoint(Circle(8, 0, 5)).first.to_s() << endl;\n    vector<Circle> cs;\n    while (cin >> N, N) {\n        cs.clear(); cs.resize(N);\n        for (int i = 0; i < N; i++) cin >> cs[i].x >> cs[i].y;\n\n        vector<Point> ips; // Intersection PointS\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (i == j) continue;\n                if (!cs[i].isIntersect(cs[j])) continue;\n                pair<Point, Point> ip = cs[i].intersectionPoint(cs[j]);\n                ips.push_back(ip.first);\n                ips.push_back(ip.second);\n                //ips.push_back(midPoint(ip));\n            }\n        }\n\n        int maxPoint = 0;\n        for (int i = 0; i < ips.size(); i++) {\n            maxPoint = max(maxPoint, countContainingPoints(Circle(ips[i].x, ips[i].y, 1), cs));\n        }\n        cout << maxPoint << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ndouble x[300], y[300];\nint n;\n\nint count(double x0, double y0, int p, int q){\n\tint ret = 2;\n\tREP(i,n){\n\t\tif(i==p||i==q)continue;\n\t\tdouble dx = x0-x[i];\n\t\tdouble dy = y0-y[i];\n\t\tif(pow(dx, 2.0)+pow(dy, 2.0)<1.0)ret++;\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(1){\n\t\tint ret = 1;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tREP(i,n)scanf(\"%f %f\", &x[i],&y[i]);\n\t\tREP(i,n){\n\t\t\tFOR(j, i+1,n){\n\t\t\t\tdouble dx = x[j]-x[i];\n\t\t\t\tdouble dy = y[j]-y[i];\n\t\t\t\tdouble d = sqrt(pow(dx, 2.0)+pow(dy, 2.0));\n\t\t\t\tif(d < 2.0){\n\t\t\t\t\tdouble mx = (x[j]+x[i])*0.5;\n\t\t\t\t\tdouble my = (y[j]+y[i])*0.5;\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble x = mx-dy/d*sqrt(1.0-d*d/4.0);\n\t\t\t\t\t\tdouble y = my+dx/d*sqrt(1.0-d*d/4.0);\n\t\t\t\t\t\tret = max(ret, count(x, y, i, j));\n\t\t\t\t\t}\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble x = mx+dy/d*sqrt(1.0-d*d/4.0);\n\t\t\t\t\t\tdouble y = my-dx/d*sqrt(1.0-d*d/4.0);\n\t\t\t\t\t\tret = max(ret, count(x, y, i, j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <cmath>\n#define EPS 1.0e-10\nusing namespace std;\n\n#define X real()\n#define Y imag()\ntypedef complex<double> P;\n \nvector<P> p;\nint check(P a){\n\tint ret=0;\n\tfor(int i=0;i<p.size();i++) if(abs(a-p[i]) < 1+EPS) ret ++;\n\treturn ret;\n}\n\nint adjcircle(P a, P b){\n\tP dir = a-b, pos=(a+b)*0.5;\n\tdir = P(dir.Y, -dir.X);\n\tdir = dir*(1/abs(dir))*sqrt(1-abs(pos-a)*abs(pos-a));\n\treturn max(check(pos+dir), check(pos-dir));\n}\n\nmain(){\n\tint i,j,N;\n\twhile(cin >> N, N){\n\t\tp = vector<P>(N);\n\t\tint ans = 1;\n\t\tfor(i=0;i<N;i++) cin >> p[i].X >> p[i].Y;\n\t\tfor(i=1;i<N;i++)\n\t\t\tfor(j=0;j<i;j++)\n\t\t\t\tif(abs(p[i]-p[j])<=2.0) ans = max(ans, adjcircle(p[i], p[j]));\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n#include <complex>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-6;\nconst double PI  = acos(-1.0);\n\n\ntypedef complex<double> CP;\nint N;\nCP point[310];\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(true){\n\tcin >> N; if(N == 0) break;\n\tREP(i,N){\n\t  double x,y; cin >> x >> y;\n\t  point[i] = CP(x, y);\n\t}\n\n\tint ans = 1;\n\tfor(int i1=0;i1<N;++i1){\n\t  for(int i2=i1+1;i2<N;++i2){\n\t\tdouble d = norm(point[i1] - point[i2]);\n\t\tif(sqrt(d) > 2.00){\n\t\t  continue;\n\t\t}\n\t\tCP m = (point[i1] + point[i2]) / 2.0;\n\t\tCP n = point[i2] - point[i1];\n\t\tn /= abs(n);\n\t\tn = CP(-imag(n), real(n));\n\n\t\tCP c = m + n * sqrt(1 - d / 4.0);\n\t\tint res = 2;\n\t\tfor(int i=0;i<N;++i){\n\t\t  if(i==i1 || i==i2) continue;\n\t\t  if(abs(c-point[i]) <= 1.0)\n\t\t\t++res;\n\t\t}\n\t\tans = max(ans, res);\n\n\t\tc = m - n * sqrt(1 - d / 4.0);\n\t\tres = 2;\n\t\tfor(int i=0;i<N;++i){\n\t\t  if(i==i1 || i==i2) continue;\n\t\t  if(abs(c-point[i]) <= 1.0)\n\t\t\t++res;\n\t\t}\n\t\tans = max(ans, res);\n\t\t\n\t  }\n\t}\n\t\n\tcout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<complex>\nusing namespace std;\n\ncomplex<double> p[300];\n\ncomplex<double> core(int a,int b){\n  complex<double> res,mid,norm;\n\n  mid = (p[a]+p[b]) / 2.0;\n\n  norm = (p[a] - p[b]) * complex<double>(0,1);\n  norm = norm / abs(norm);\n  norm = norm * sqrt(1.0 - abs(mid-p[a])*abs(mid-p[a]));\n\n  res = norm + mid;\n  return res;\n}\n  \n\nint main(){\n  int n;\n  complex<double> o,r;\n  int max,tmp;\n\n  while(1){\n    cin >> n;\n    if(!n)break;\n\n    for(int i=0;i<n;i++)cin >> p[i].real() >> p[i].imag();\n\n    max = 1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i!=j && abs(p[i]-p[j]) < 2.0){\n\t  o = core(i,j);\n\t  tmp = 2;\n\t  for(int k=0;k<n;k++){\n\t    if(k!=i && k!=j){\n\t      r = o-p[k];\n\t      if( r.real()*r.real() + r.imag()*r.imag() <1.0)tmp++;\n\t    }\n\t  }\n\t  if(max < tmp)max = tmp;\n\t}\n      }\n    }\n    cout << max << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n#include<set>\n#include<array>\n#include<cassert>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\ntypedef double Real;\n\nconst Real EPS = 1e-8;\n\nint sign(Real d){\n\treturn d > EPS ? 1 : d < -EPS ? -1 : 0;\n}\n\nstruct Point{\n\tReal x,y;\t\n\texplicit Point(Real x_ = 0,Real y_ = 0):x(x_),y(y_){}\n\tPoint operator+(const Point &p) const {return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point &p) const {return Point(x-p.x,y-p.y);}\n\tPoint operator*(Real s) const {return Point(x*s,y*s);}\n\tPoint operator/(Real s) const {return Point(x/s,y/s);}\n\tbool operator<(const Point &p) const{return sign(x-p.x) == -1 || (sign(x-p.x) == 0 && sign(y-p.y) == -1);}\n\tbool operator==(const Point &p) const{return sign(x-p.x) == 0 && sign(y-p.y) == 0;}\n\n};\n\nistream &operator>>(istream &is,Point &p){return is >> p.x >> p.y;}//??\\???????°???????\nostream &operator<<(ostream &os ,const Point &p){return os << '(' << p.x << \", \" << p.y << ')';}//??????????°???????\n\nstruct Segment : public array<Point,2>{\n\tSegment(const Point &a,const Point &b){\tat(0) = a; at(1) = b;}\n};\n\nstruct Line : public array<Point,2>{\n\tLine(const Point &a,const Point &b){at(0) = a; at(1) = b;}\n};\n\nstruct Circle{\n\tPoint c;\n\tReal r;\n\n\tCircle(const Point &c_, Real r_):c(c_),r(r_){}\n};\n\ntypedef vector<Point> Polygon;\n\nPoint rotate90(const Point &p){\n\treturn Point(-p.y,p.x);\n}\n\nPoint rotate(const Point &p,Real theta){\n\tconst Real s = sin(theta),c = cos(theta);\n\treturn Point(c*p.x-s*p.y,s*p.x+c*p.y);\n}\n\nReal angle(const Point &p){\n\treturn atan2(p.y,p.x);\n}\n\nReal dot(const Point &a,const Point &b){ //??????????????????\n\treturn a.x*b.x+a.y*b.y;\n}\n\nReal cross(const Point &a,const Point &b){ //??????????????????\n\treturn a.x*b.y-a.y*b.x;\n}\n\n\nReal norm(const Point &p){\n\treturn p.x*p.x+p.y*p.y;\n}\n\nReal abs(const Point &p){\n\treturn sqrt(norm(p));\n}\n\nenum { CCW=1,CW=-1,BACK=2,FRONT=-2,ON=0 };\nint ccw(const Point &a,const Point &b,const Point &c){\n\tconst Point p = b-a;\n\tconst Point q = c-a;\n\tconst int sgn = sign(cross(p,q));\n\t\n\tif(sgn == 1) return CCW;\n\tif(sgn == -1) return CW;\n\tif(sign(dot(p,q)) == -1) return BACK;\n\tif(sign(norm(p) - norm(q)) == -1) return FRONT;\n\treturn ON;\n}\n\nPoint project(const Line &l,const Point &p){ //?°???±\n\tReal t = dot(p-l[0], l[1]-l[0]) / norm(l[0] - l[1]);\n\treturn l[0] + (l[1] - l[0]) * t;\n}\n\nPoint refrect(const Line &l,const Point &p){ //????°?\n\tconst Point c = project(l,p);\n\treturn c+(c-p);\n}\n\nbool intersect(const Segment &a,const Segment &b){\n\treturn ccw(a[0],a[1],b[0])*ccw(a[0],a[1],b[1]) <= 0\n\t\t&& ccw(b[0],b[1],a[0])*ccw(b[0],b[1],a[1]) <= 0;\n}\n\nbool intersect(const Segment &s,const Point &p){\n\treturn ccw(s[0],s[1],p) == ON;\n}\n\nbool intersect(const Line &l,const Segment &s){\n\treturn sign(cross(l[1]-l[0],s[0]-l[0])) * cross(l[1]-l[0],s[1]-l[0]) <= 0;\n}\n\nbool intersect(const Line &l,const Point &p){\n\treturn abs(ccw(l[0],l[1],p)) != 1;\n}\n\nbool intersect(const Line &a,const Line &b){ //????????????\n\treturn sign(cross(a[1]-a[0],b[1]-b[0])) != 0\n\t\t||\tsign(cross(a[1]-a[0],b[1]-a[0]) == 0);\n}\n\nReal dist(const Point &a,const Point &b){\n\treturn abs(a-b);\t\n}\n\nReal dist(const Line &l,const Point &p){\n\tconst Point a = l[1]-l[0];\n\tconst Point b = p-l[0];\n\treturn abs(cross(a,b))/abs(a);\n}\n\nReal dist(const Line &l,const Segment &s){\n\tif(intersect(l,s)) return 0;\n\treturn min(dist(l,s[0]),dist(l,s[1]));\n}\n\nReal dist(const Line &a,const Line &b){\n\tif(intersect(a,b)) return 0;\n\treturn dist(a,b[0]);\n}\n\nReal dist(const Segment &s,const Point &p){\n\tif(sign(dot(s[1]-s[0],p-s[0]))==-1) return dist(s[0],p);\n\tif(sign(dot(s[0]-s[1],p-s[1]))==-1) return dist(s[1],p);\n\treturn dist(Line(s[0],s[1]),p);\n}\n\nReal dist(const Segment &a,const Segment &b){\n\tif(intersect(a,b)) return 0;\n\treturn min({dist(a,b[0]),dist(a,b[1]),dist(b,a[0]),dist(b,a[1])});\n}\n\nbool intersect(const Circle &a,const Circle &b){\n\treturn sign(dist(a.c,b.c)-(a.r+b.r)) <=0\n\t\t\t&& sign(dist(a.c,b.c)-abs(a.r-b.r)) >= 0;\n}\n\nbool intersect(const Circle &c,const Segment &s){\n\treturn sign(dist(s,c.c)-c.r)<=0;\n}\n\nbool intersect(const Circle &c,const Line &l){\n\treturn sign(dist(l,c.c)-c.r)<=0;\n}\n\nbool contain(const Circle &c,const Point &p){\n\treturn sign(dist(c.c,p)-c.r)<=0;\n}\n\nbool contain(const Polygon &P,const Point &p){\n\tbool res = false;\n\n\tfor(int i=0;i<P.size();++i){\n\t\tPoint v1=P[i]-p;\n\t\tPoint v2=P[(i+1)%P.size()]-p;\n\t\tif(v1.y>v2.y) swap(v1,v2);\n\n\t\tif(sign(cross(v1,v2))==0&&sign(dot(v1,v2))<=0){\n\t\t\treturn true;//on edge \n\t\t}\n\t\tif(sign(v1.y)<=0&&sign(v2.y)==1&&sign(cross(v1,v2))==1){\n\t\t\tres=!res;\n\t\t}\n\t}\n\treturn res;\n}\n\nPoint crosspoint(const Line &a,const Line &b){\n\tassert(intersect(a,b));\n\tconst Real crs = cross(a[1]-a[0],b[1]-b[0]);\n\tif(sign(crs) == 0) return a[0];\n\treturn b[0]+(b[1]-b[0])*(cross(a[1]-a[0],a[1]-b[0])/crs);\n}\n\n\n//??¬??¢?????????????????¨?????°?????????????????????Intersect?????????\nPoint crosspoint(const Segment &a,const Segment &b){\n\tassert(intersect(a,b));\n\tconst Real crs = cross(a[1]-a[0],b[1]-b[0]);\n\tif(sign(crs)==0){\n\t\tif(intersect(a,b[0])) return b[0];\n\t\tif(intersect(a,b[1])) return b[1];\n\t\tif(intersect(b,a[0])) return a[0];\n\t\treturn a[1];\n\t}\n\treturn b[0]+(b[1]-b[0])*(cross(a[1]-a[0],a[1]-b[0])/crs);\n}\n\nvector<Point> crosspoint(const Circle &c,const Line &l){\n\tconst Point p = project(l,c.c);\n\tconst Real h = dist(p,c.c);\n\n\tvector<Point> res;\n\tif(sign(h-c.r)==1){\n\t\t//nothing\n\t}else if(sign(h-c.r)==0){\n\t\tres.emplace_back(p);\t\n\t}else{\n\t\tconst Real b = sqrt(c.r*c.r-h*h);\n\t\tconst Point e = (l[1]-l[0])/abs(l[1]-l[0]);\n\t\tres.emplace_back(p+e*b);\n\t\tres.emplace_back(p-e*b);\n\t}\n\treturn res;\n}\n\nvector<Point> crosspoint(const Circle &a,const Circle &b){\n\tif(!intersect(a,b)) return vector<Point>();\n\n\tvector<Point> res;\n\tconst Real d = dist(a.c,b.c);\n\n\tif(sign(d-(a.r+b.r))==0){\n\t\tconst Point v = b.c - a.c;\n\t\tres.emplace_back(a.c + (v * (a.r /abs(v))));\n\t}else{\n\t\tconst Real theta = acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\t\tconst Real phi = angle(b.c-a.c);\n\t\tres.emplace_back(a.c+rotate(Point(a.r,0),phi+theta));\n\t\tres.emplace_back(a.c+rotate(Point(a.r,0),phi-theta));\n\t}\n\treturn res;\n}\n\nReal area(const Polygon &P){\n\tReal res = 0.0;\n\tfor(int i=0;i<P.size();++i){\n\t\tres+=cross(P[i],P[(i+1)%P.size()]);\n\t}\n\treturn abs(res) * 0.5;\n}\n\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tvector<Circle> circles;\n\t\tvector<Circle> ccircles;\n\t\trep(i,n){\n\t\t\tPoint p;\n\t\t\tcin >> p;\n\t\t\tcircles.push_back(Circle(p,1.0));\n\t\t}\n\t\t\n\t\t//??????????±???????\n\t\trep(i,n) for(int j=i+1;j<n;j++){\n\t\t\tvector<Point> points = crosspoint(circles[i],circles[j]);\n\t\t\trep(k,points.size()){\n\t\t\t\tccircles.push_back(Circle(points[k],1.0));\n\t\t\t}\n\t\t}\n\n\t\tint ans=0;\n\t\tvector<Point> points;\n\t\t\n\t\t//??????????????§??°???????????§????????????\n\t\trep(i,ccircles.size()){\n\t\t\tint cnt=0;\n\t\t\trep(j,n){\n\t\t\t\tif(contain(ccircles[i],circles[j].c)){\n\t\t\t\t\tcnt++;\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tans=max(cnt,ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\n\n\nnamespace Geometry{\n#define F first\n#define S second\n    typedef long double D;\n    typedef complex<long double> P;\n    typedef pair<P,D> C;\n    \n    const D EPS=1e-9;\n    const D PI=asin(1)*2;\n    const D INF=1e18;\n    \n    static bool comp(const P &p1,const P &p2){\n        if(p1.real()==p2.real()){return p1.imag()<p2.imag();}\n        return p1.real()<p2.real();\n    }\n    \n    static bool comp_y(const P &p1,const P &p2){\n        if(p1.imag()==p2.imag()){return p1.real()<p2.real();}\n        return p1.imag()<p2.imag();\n    }\n    \n    static bool eqls(const P &p1,const P &p2){return abs(p1-p2)<EPS;}\n    \n    D dot(P p1,P p2){return p1.real()*p2.real()+p1.imag()*p2.imag();}\n    \n    D cross(P p1,P p2){return p1.real()*p2.imag()-p1.imag()*p2.real();}\n    \n    P project(P vec,P x){return vec*(x/vec).real();}\n    \n    P project(P p1,P p2,P x){return p1+project(p2-p1,x-p1);}\n    \n    P reflect(P vec,P x){return vec*conj(x/vec);}\n    \n    P reflect(P p1,P p2,P x){return p1+reflect(p2-p1,x-p1);}\n    \n    bool intersectSL(P p1,P p2,P vec){\n        vec/=abs(vec); p1/=vec; p2/=vec;\n        return (p1.imag()<EPS && p2.imag()>-EPS) || (p1.imag()>-EPS && p2.imag()<EPS);\n    }\n    \n    bool intersectSL(P p1,P p2,P p3,P p4){return intersectSL(p1-p4,p2-p4,p3-p4);}\n    \n    bool intersectSS(P p1,P p2,P p3,P p4){\n        if(dot(p2-p1,p3-p1)<-EPS && dot(p2-p1,p4-p1)<-EPS){return false;}\n        if(dot(p1-p2,p3-p2)<-EPS && dot(p1-p2,p4-p2)<-EPS){return false;}\n        return intersectSL(p1,p2,p3,p4) && intersectSL(p3,p4,p1,p2);\n    }\n    \n    D distLP(P vec,P x){return abs((x/vec).imag())*abs(vec);}\n    \n    D distLP(P p1,P p2,P x){return distLP(p2-p1,x-p1);}\n    \n    D distSP(P p1,P p2,P x){\n        if(dot(p2-p1,x-p1)<-EPS){return abs(x-p1);}\n        if(dot(p1-p2,x-p2)<-EPS){return abs(x-p2);}\n        return distLP(p1,p2,x);\n    }\n    \n    D distSS(P p1,P p2,P p3,P p4){\n        if(intersectSS(p1,p2,p3,p4)){return 0.0;}\n        return min({distSP(p1,p2,p3),distSP(p1,p2,p4),\n            distSP(p3,p4,p1),distSP(p3,p4,p2)});\n    }\n    \n    P crosspointLL(P p1,P p2,P vec){\n        if(abs(cross(p2-p1,vec))<EPS){return vec;}\n        return vec*cross(p2-p1,p2)/cross(p2-p1,vec);\n    }\n    \n    P crosspointLL(P p1,P p2,P p3,P p4){\n        return p4+crosspointLL(p1-p4,p2-p4,p3-p4);\n    }\n    \n    P crosspointSS(P p1,P p2,P p3,P p4){\n        if(distSP(p1,p2,p3)<EPS){return p3;}\n        if(distSP(p1,p2,p4)<EPS){return p4;}\n        return crosspointLL(p1,p2,p3,p4);\n    }\n    \n    bool intersectShL(P p1,P p2,P vec){\n        vec/=abs(vec);\n        return intersectSL(p1,p2,vec) &&\n        crosspointLL(p1/vec,p2/vec,vec/vec).real()>-EPS;\n    }\n    \n    bool intersectShL(P p1,P p2,P p3,P p4){\n        return intersectShL(p1-p3,p2-p3,p4-p3);\n    }\n    \n    //1::in,0::on edge,-1::out\n    int contain(const vector<P> &poly,const P &p){\n        vector<P> A={{65537,96847},{-24061,6701},{56369,-86509},{-93763,-78049},{56957,10007}};\n        int s=A.size();\n        vector<bool> cnt(s,false);\n        for(int i=0;i<(int)poly.size();i++){\n            int k=(i+1)%poly.size();\n            if(distSP(poly[i],poly[k],p)<EPS){return 0;}\n            for(int j=0;j<s;j++){\n                if(intersectShL(poly[i],poly[k],p,p+A[j])){cnt[j]=!cnt[j];}\n            }\n        }\n        int in=0;\n        for(int j=0;j<s;j++){if(cnt[j]){in++;}}\n        return in>s/2?1:-1;\n    }\n    \n    vector<P> convexcut(const vector<P> &poly,P p1,P p2){\n        vector<P> ret;\n        for(int i=0;i<(int)poly.size();i++){\n            int j=(i+1)%poly.size();\n            if(cross(p2-p1,poly[i]-p1)>-EPS){ret.push_back(poly[i]);}\n            if(intersectSL(poly[i],poly[j],p1,p2) &&\n               distLP(p1,p2,poly[i])>EPS && distLP(p1,p2,poly[j])>EPS){\n                ret.push_back(crosspointLL(poly[i],poly[j],p1,p2));\n            }\n        }\n        return ret;\n    }\n    \n    D area(const vector<P> &poly){\n        D ans=0;\n        for(int i=2;i<(int)poly.size();i++){\n            ans+=cross(poly[i-1]-poly[0],poly[i]-poly[0]);\n        }\n        return abs(ans)/2;\n    }\n    \n    vector<P> convexhull(vector<P> pts){\n        vector<P> ret;\n        sort(pts.begin(),pts.end(),comp);\n        auto fnc=[&](){\n            for(auto &I:pts){\n                if(!ret.empty() && abs(I-ret.back())<EPS){continue;}\n                while(ret.size()>1){\n                    P A=ret.back()-ret[ret.size()-2];\n                    P B=I-ret.back();\n                    if(cross(A,B)<-EPS){ret.pop_back();}\n                    else if(abs(cross(A,B))<EPS && dot(A,B)>EPS){ret.pop_back();}\n                    else{break;}\n                }\n                ret.push_back(I);\n            }\n        };\n        fnc();\n        reverse(pts.begin(),pts.end());\n        fnc();\n        if(ret.size()>1 && ret[0]==ret.back()){ret.pop_back();}\n        return ret;\n    }\n    \n    //4::seperate,3::circumscribe,2::intersect,1::inscribe,0::contain,-1::same\n    int intersectCC(C c1,C c2){\n        D d=abs(c1.F-c2.F),r=c1.S+c2.S,dif=abs(c2.S-c1.S);\n        if(d<EPS && dif<EPS){return -1;}\n        if(d-r>EPS){return 4;}\n        if(d-r>-EPS){return 3;}\n        if(d-dif>EPS){return 2;}\n        if(d-dif>-EPS){return 1;}\n        return 0;\n    }\n    \n    vector<P> crosspointLC(P p1,P p2,C c){\n        vector<P> ret;\n        P pr=project(p1,p2,c.F);\n        D d=distLP(p1,p2,c.F);\n        if(d-c.S>EPS){return ret;}\n        if(d-c.S>-EPS){ret.push_back(pr); return ret;}\n        P vec=p2-p1; vec*=sqrt(c.S*c.S-d*d)/abs(vec);\n        ret.push_back(pr-vec);\n        ret.push_back(pr+vec);\n        return ret;\n    }\n    \n    vector<P> crosspointSC(P p1,P p2,C c){\n        vector<P> ret;\n        for(auto &I:crosspointLC(p1,p2,c)){\n            if(distSP(p1,p2,I)<EPS){ret.push_back(I);}\n        }\n        return ret;\n    }\n    \n    vector<P> crosspointCC(C c1,C c2){\n        vector<P> ret;\n        P vec=c2.F-c1.F;\n        D base=(c1.S*c1.S+norm(vec)-c2.S*c2.S)/(2*abs(vec));\n        D h=sqrt(c1.S*c1.S-base*base);\n        vec/=abs(vec);\n        ret.push_back(c1.F+vec*P(base,-h));\n        ret.push_back(c1.F+vec*P(base,h));\n        return ret;\n    }\n    \n    vector<P> tangentCP(C c,P p){\n        return crosspointCC(c,C(p,sqrt(norm(c.F-p)-c.S*c.S)));\n    }\n    \n    vector<pair<P,P>> tangentCC(C c1,C c2){\n        vector<pair<P,P>> ret;\n        P d=c2.F-c1.F;\n        for(D i:{-1,1}){\n            D r=c1.S+c2.S*i;\n            if(intersectCC(c1,c2)>i+1){\n                for(P s:{-1i,1i}){\n                    P p=r+s*sqrt(norm(d)-norm(r));\n                    ret.push_back({c1.F+d*c1.S/norm(d)*p,c2.F-d*i*c2.S/norm(d)*p});\n                }\n            }\n        }\n        return ret;\n    }\n    \n    D area(const vector<P> &poly,C c){\n        D ret=0;\n        for(int i=0;i<(int)poly.size();i++){\n            P a=poly[i]-c.F,b=poly[(i+1)%poly.size()]-c.F;\n            if(abs(a)<c.S+EPS && abs(b)<c.S+EPS){ret+=cross(a,b);}\n            else{\n                vector<P> A=crosspointSC(a,b,{0,c.S});\n                if(A.empty()){ret+=c.S*c.S*arg(b/a);}\n                else{\n                    ret+=(abs(a)<c.S?cross(a,A[0]):c.S*c.S*arg(A[0]/a));\n                    ret+=(abs(b)<c.S?cross(A.back(),b):c.S*c.S*arg(b/A.back()));\n                    ret+=cross(A[0],A.back());\n                }\n            }\n        }\n        return abs(ret)/2;\n    }\n    \n    //反時計回り\n    D diameter(const vector<P> &poly){\n        D ret=0;\n        ll l=0,r=0,n=poly.size();\n        if(n==2){return abs(poly[0]-poly[1]);}\n        for(int i=0;i<n;i++){\n            if(comp(poly[l],poly[i])){l=i;}\n            if(comp(poly[i],poly[r])){r=i;}\n        }\n        ll sl=r,sr=l;\n        while(sl!=l || sr!=r){\n            ret=max(ret,abs(poly[r]-poly[l]));\n            if(cross(poly[(l+1)%n]-poly[l],poly[(r+1)%n]-poly[r])<0){(++l)%=n;}\n            else{(++r)%=n;}\n        }\n        return ret;\n    }\n    \n    D closestpair(vector<P> pt){\n        sort(pt.begin(),pt.end(),comp);\n        D ret=INF;\n        int N=pt.size();\n        for(int i=1;i<N;i<<=1){\n            for(int j=0;i+j<N;j+=i*2){\n                int m=i+j;\n                vector<P> R;\n                D l=-INF,r=INF;\n                for(int k=j;k<m;k++){l=max(l,pt[k].real());}\n                for(int k=0;m+k<N && k<i;k++){r=min(r,pt[m+k].real());}\n                for(int k=0;m+k<N && k<i;k++){\n                    if(pt[m+k].real()-l<ret){R.push_back(pt[m+k]);}\n                }\n                int idx=0;\n                for(int k=j;k<m;k++){\n                    if(r-pt[k].real()>ret){continue;}\n                    int M=R.size();\n                    while(idx<M && pt[k].imag()-R[idx].imag()>ret){idx++;}\n                    for(int s=idx;s<M && R[s].imag()-pt[k].imag()<ret;s++){\n                        ret=min(ret,abs(R[s]-pt[k]));\n                    }\n                }\n                auto ed=(j+i*2<N?pt.begin()+j+2*i:pt.end());\n                inplace_merge(pt.begin()+j,pt.begin()+m,ed,comp_y);\n            }\n        }\n        return ret;\n    }\n    \n    P centerofgravity(const vector<P> &pt){\n        P ret(0,0);\n        D wt=0;\n        for(int i=2;i<(int)pt.size();i++){\n            D w2=cross(pt[i-1]-pt[0],pt[i]-pt[0]);\n            P p=(pt[0]+pt[i-1]+pt[i])/(D)3;\n            wt+=w2;\n            ret+=p*w2;\n        }\n        return ret/wt;\n    }\n    \n    void segment_arrangement(const vector<pair<P,P>> &L,vector<pair<int,int>> &seg,vector<P> &pt){\n        int N=L.size();\n        for(int i=0;i<N;i++){\n            pt.push_back(L[i].F);\n            pt.push_back(L[i].S);\n            for(int j=i+1;j<N;j++){\n                if(intersectSS(L[i].F,L[i].S,L[j].F,L[j].S)){\n                    pt.push_back(crosspointSS(L[i].F,L[i].S,L[j].F,L[j].S));\n                }\n            }\n        }\n        auto le=[](P a,P b){return eqls(a,b)?false:comp(a,b);};\n        sort(pt.begin(),pt.end(),le);\n        pt.erase(unique(pt.begin(),pt.end(),eqls),pt.end());\n        for(auto &I:L){\n            vector<pair<D,int>> on;\n            for(int j=0;j<(int)pt.size();j++){\n                if(distSP(I.F,I.S,pt[j])<EPS){\n                    on.emplace_back(abs(pt[j]-I.F),j);\n                }\n            }\n            sort(on.begin(),on.end());\n            for(int j=1;j<(int)on.size();j++){\n                seg.emplace_back(on[j-1].S,on[j].S);\n            }\n        }\n        sort(seg.begin(),seg.end());\n        seg.erase(unique(seg.begin(),seg.end()),seg.end());\n    }\n    \n    vector<P> convex_of_segments(const vector<pair<P,P>> &L){\n        vector<pair<int,int>> seg;\n        vector<P> pt;\n        segment_arrangement(L,seg,pt);\n        vector<vector<int>> edge(pt.size());\n        for(auto &I:seg){\n            edge[I.F].push_back(I.S);\n            edge[I.S].push_back(I.F);\n        }\n        vector<P> ret;\n        function<void(int,int)> dfs=[&](int v,int pre){\n            if(pre!=-1 && v==0){return;}\n            ret.push_back(pt[v]);\n            vector<pair<D,int>> nx;\n            for(auto &u:edge[v]){\n                D a=arg((pt[u]-pt[v])/(pre==-1 || eqls(pt[v],pt[pre])?P(1):pt[v]-pt[pre]));\n                if(abs(a+PI)<EPS){a=PI;}\n                nx.emplace_back(a,u);\n            }\n            sort(nx.begin(),nx.end());\n            dfs(nx[0].S,v);\n        };\n        dfs(0,-1);\n        return ret;\n    }\n    \n  istream & operator >> (istream &i,P &p){D x,y; i>>x>>y; p={x,y}; return i;}\n  istream & operator >> (istream &i,C &p){D x,y; i>>x>>y>>p.S; p.F={x,y}; return i;}\n  void Input(P &p){D x,y;cin>>x>>y;p={x,y};}\n};\n\nusing namespace Geometry;\n\nconst D R=1.0;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll N;\n  while(cin>>N,N){\n    vector<P> A(N);\n    for(auto &I:A){Input(I);}\n    ll ans=1;\n    for(auto &I:A){\n      for(auto &J:A){\n        P vec=I-J;\n        if(abs(vec)>2*R+EPS){continue;}\n        vec/=abs(vec);\n        D dis=abs(I-J)/2;\n        P ctr=(I+J)/(D)2;\n        ctr+=vec*P(0,1)*sqrt(1.0-dis*dis);\n        ll cnt=0;\n        for(auto &K:A){\n          if(abs(ctr-K)<R+EPS){cnt++;}\n        }\n        ans=max(ans,cnt);\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.00001\nusing namespace std;\n\nstruct Point{\n\tbool operator<(const struct Point &arg) const{\n\t\t\treturn x < arg.x;\n\t};\n\tdouble x,y;\n};\n\ndouble a,b,c,d;\n\ndouble calc(double x){\n\treturn ((c-a)*x)/(b-d)+(b+d)/2-(c-a)*(a+c)/(2*(b-d));\n}\n\n\ndouble dist(double x,double y){\n\treturn sqrt((x-a)*(x-a)+(y-b)*(y-b));\n}\n\nint main(){\n\n\tint N,maximum,count;\n\tPoint points[300];\n\tdouble left,right,m,tmp_x,tmp_y,tmp_dist;\n\n\tbool FLG;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tmaximum = 1;\n\n\t\tfor(int loop = 0; loop < N; loop++){\n\t\t\tscanf(\"%lf %lf\",&points[loop].x,&points[loop].y);\n\t\t}\n\n\t\tsort(points,points+N);\n\n\t\tfor(int i = 0; i <= N-2; i++){\n\t\t\tfor(int k = i+1; k <= N-1; k++){\n\n\t\t\t\ta = points[i].x;\n\t\t\t\tb = points[i].y;\n\t\t\t\tc = points[k].x;\n\t\t\t\td = points[k].y;\n\n\t\t\t\tleft = 0.0;\n\t\t\t\tright = (a+c)/2;\n\t\t\t\tm = (left+right)/2;\n\n\t\t\t\tFLG = false;\n\n\t\t\t\twhile(left <= right){\n\t\t\t\t\ttmp_y = calc(m);\n\t\t\t\t\ttmp_dist = dist(m,tmp_y);\n\n\t\t\t\t\tif(fabs(tmp_dist-1.0) < EPS){\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\ttmp_x = m;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(tmp_dist > 1.0){\n\t\t\t\t\t\tleft = m + EPS;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tright = m - EPS;\n\t\t\t\t\t}\n\t\t\t\t\tm = (left+right)/2.0;\n\t\t\t\t}\n\n\t\t\t\tif(FLG){\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\t\tif(sqrt((tmp_x-points[p].x)*(tmp_x-points[p].x)+(tmp_y-points[p].y)*(tmp_y-points[p].y)) < 1.0){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}else if(fabs(sqrt((tmp_x-points[p].x)*(tmp_x-points[p].x)+(tmp_y-points[p].y)*(tmp_y-points[p].y))-1.0) <= EPS){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmaximum = max(maximum,count);\n\t\t\t\t}\n\n\t\t\t\tleft = (a+c)/2;\n\t\t\t\tright = 10.0;\n\t\t\t\tm = (left+right)/2;\n\t\t\t\tFLG = false;\n\n\t\t\t\twhile(left <= right){\n\t\t\t\t\ttmp_y = calc(m);\n\t\t\t\t\ttmp_dist = dist(m,tmp_y);\n\n\t\t\t\t\tif(fabs(tmp_dist-1.0) < EPS){\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\ttmp_x = m;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(tmp_dist > 1.0){\n\t\t\t\t\t\tright = m - EPS;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tleft = m + EPS;\n\t\t\t\t\t}\n\t\t\t\t\tm = (left+right)/2.0;\n\t\t\t\t}\n\n\t\t\t\tif(FLG){\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\t\tif(sqrt((tmp_x-points[p].x)*(tmp_x-points[p].x)+(tmp_y-points[p].y)*(tmp_y-points[p].y)) < 1.0){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}else if(fabs(sqrt((tmp_x-points[p].x)*(tmp_x-points[p].x)+(tmp_y-points[p].y)*(tmp_y-points[p].y))-1.0) <= EPS){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmaximum = max(maximum,count);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",maximum);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<list>\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\ntypedef pair<P,double> C;\n\nconst double PI = acos(-1);\n\n//for vector\nP unit(P p){return p / abs(p);}\n\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\ndouble dot(P x,P y){return real(conj(x)*y);}\n\ndouble cross(P x,P y){return imag(conj(x)*y);}\n\n//rotate a point counter-clockwise on the origin\nP rotate(P v,double s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\n\n\n//return seta A\ndouble arg(double a,double b,double c){return acos( (b*b+c*c-a*a)/(2*b*c) );}\n\n\n//for circle\ndouble area_cir(C c){return PI * c.sc * c.sc;}\n\nbool in_cir(C c,P x){return (abs(x-c.fs) +EPS < c.sc);}\nbool on_cir(C c,P x){return EQ(abs(x-c.fs),c.sc);}\n\n//circle position relation\nint cpr(C a,C b){\n  double d = abs(a.fs-b.fs);\n  if(a.sc+b.sc + EPS < d)return -1;      //no cross point (outside)\n  if(b.sc+d + EPS < a.sc)return 1;       //no cross point (inside,B in A)\n  if(a.sc+d + EPS < b.sc)return 2;       //no cross point (inside,A in B)\n  //------------above verified----------------// \n  if(abs(a.sc+b.sc - d) < EPS)return -3; //one cross point (outside)\n  if(abs(b.sc+d - a.sc) < EPS)return 3;  //one cross point (inside,B in A)\n  if(abs(a.sc+d - b.sc) < EPS)return 4;  //one cross point (inside,A in B)\n  return 0;                              //two cross point\n}\n  \n//not verified\nvector<P> cp_cir_to_cir(C a, C b){\n  vector<P> v;\n  int pos = cpr(a,b);\n  if(pos==0){\n    double s = arg(b.sc,abs(b.fs-a.fs),a.sc);\n    P x = a.sc * unit(b.fs - a.fs);\n    v.pb(a.fs + rotate(x,s));\n    v.pb(a.fs + rotate(x,-s));\n  }else if(abs(pos) == 3){\n    v.pb(a.fs + a.sc * unit(b.fs-a.fs));\n  }else if(pos == 4){\n    v.pb(a.fs + a.sc * unit(b.fs-a.fs));\n  }\n  return v;\n}\n\nint n;\nC c[500];\n\nint main(){\n  while(scanf(\"%d\",&n),n){\n    for(int i=0;i<n;i++){\n      scanf(\"%lf%lf\",&c[i].fs.real(),&c[i].fs.imag());\n      c[i].sc = 1.0;\n    }\n\n    int pos;\n    vector<P> s,cp;\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tpos = cpr(c[i],c[j]);\n\tif(pos==1)s.pb(c[i].fs);\n\telse if(pos==2)s.pb(c[j].fs);\n\telse{\n\t  cp = cp_cir_to_cir(c[i],c[j]);\n\t  for(int x=0;x<cp.sz;x++)s.pb(cp[x]);\n\t}\n      }\n    }\n\n    int ans = 1;\n    for(int i=0;i<s.sz;i++){\n      int num = 0;\n      for(int j=0;j<n;j++){\n\tif(abs(s[i]-c[j].fs) < 1.0 + EPS)num++;\n      }\n      if(ans<num)ans = num;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (1e9+7)\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n\nusing P=complex<double>;\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        int ans=1;\n        vector<P> c(n);\n        rep(i,n) { double p,q; cin>>p>>q; c[i]=P(p,q); }\n        rep(i,n)range(j,i+1,n){\n            P v=c[i]-c[j];\n            double d=abs(v);\n            if(d>2.0) continue;\n            P med=(c[i]+c[j])/2.0;\n            P nml=v/d*P(0,1)*sqrt(1-d*d/4);\n            P r1=med+nml;\n            P r2=med-nml;\n            int s1=0,s2=0;\n            rep(k,n){\n                s1+=(abs(r1-c[k])<=1.0+1e-6);\n                s2+=(abs(r2-c[k])<=1.0+1e-6);\n            }\n            ans=max(ans,max(s1,s2));\n        }\n        cout<<ans<<endl;\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> P;\nconst LL MOD = 1000000007LL;\nconst double EPS = 1e-10;\nstruct Point {\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\tPoint operator+(Point &p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator-(Point &p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator*(double a) {\n\t\treturn Point(x*a, y*a);\n\t}\n\tPoint operator/(double a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm() {\n\t\treturn x*x + y*y;\n\t}\n\tbool operator<(const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator==(const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\ntypedef Point Vector;\nstruct Segment {\n\tPoint p1, p2;\n};\ntypedef Segment Line;\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\ntypedef vector<Point> Polygon;\ndouble norm(Vector a);\ndouble abs(Vector a);\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\nbool equals(double a, double b);\nbool isOrthogonal(Vector a, Vector b);\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2);\nbool isOrthogonal(Segment s1, Segment s2);\nbool isParallel(Vector a, Vector b);\nbool isParallel(Point a1, Point a2, Point b1, Point b2);\nbool isParallel(Segment s1, Segment s2);\nPoint project(Segment s, Point p);\nPoint reflect(Segment s, Point p);\nint ccw(Point p0, Point p1, Point p2);\ndouble getDistance(Point a, Point b);\ndouble getDistanceLP(Line l, Point p);\ndouble getDistanceSP(Segment s, Point p);\ndouble getDistance(Segment s1, Segment s2);\nbool intersect(Point p1, Point p2, Point p3, Point p4);\nbool intersect(Segment s1, Segment s2);\nbool intersect(Circle c, Line l);\nbool intersect(Circle c1, Circle c2);\nPoint getCrossPoint(Segment s1, Segment s2);\npair<Point, Point> getCrossPoints(Circle c, Line l);\ndouble arg(Vector p);\nVector polar(double a, double r);\npair<Point, Point> getCrossPoints(Circle c1, Circle c2);\ndouble norm(Vector a) {\n\treturn a.x*a.x + a.y*a.y;\n}\ndouble abs(Vector a) {\n\treturn sqrt(norm(a));\n}\ndouble dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\ndouble cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\nbool equals(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base*r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\ndouble getDistance(Point a, Point b) {\n\treturn abs(a - b);\n}\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nbool intersect(Circle c, Line l) {\n\treturn getDistanceLP(l, c.c) <= c.r;\n}\nbool intersect(Circle c1, Circle c2) {\n\treturn getDistance(c1.c, c2.c) <= c1.r + c2.r;\n}\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r*c.r - norm(pr - c.c));\n\treturn make_pair(pr + e*base, pr - e*base);\n}\ndouble arg(Vector p) {\n\treturn atan2(p.y, p.x);\n}\nVector polar(double a, double r) {\n\treturn Vector(cos(r)*a, sin(r)*a);\n}\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\tassert(intersect(c1, c2));\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tPoint p[300];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = Point(x, y);\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tVector d = p[j] - p[i];\n\t\t\t\tif (d.abs() > 2.0) continue;\n\t\t\t\tPoint m = p[i] + d / 2.0;\n\t\t\t\tVector r = Vector(-d.y, d.x);\n\t\t\t\tr = r / r.abs()*sqrt(1 - pow(d.abs() / 2.0, 2));\n\t\t\t\tPoint p1 = m + r;\n\t\t\t\tPoint p2 = m - r;\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tint cnt2 = 0;\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif ((p[k] - p1).abs() <= 1) cnt1++;\n\t\t\t\t\tif ((p[k] - p2).abs() <= 1) cnt2++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, max(cnt1, cnt2));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nP center1(P a ,P b ,double r){\n  return (a+b)/(P)2+(b-a)*P(0,1)*(P)(sqrt(r*r-norm((b-a)/(P)2))/abs(b-a));\n}\n\nP center2(P a ,P b ,double r){\n  return (a+b)/(P)2+(b-a)*P(0,-1)*(P)(sqrt(r*r-norm((b-a)/(P)2))/abs(b-a));\n}\n\nint main(){\n  int n;\n  double x,y;\n  while(true){\n    cin >>n;\n    if (!n)\n      break;\n    P dot[n];\n    for(int i=0;i<n;i++){\n      cin >>x >>y;\n      dot[i] = P(x,y);\n    }\n    set<int> near_dot[n];\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif (norm(dot[i]-dot[j])<4)\n\t  near_dot[i].insert(j);\n      }\n    }\n    \n    set<int>::iterator it;\n    int cnt,max=1;\n    P c;\n    for(int i=0;i<n;i++){\n      it = near_dot[i].begin();\n      while(it != near_dot[i].end()){\n\tc = center1(dot[i],dot[*it],1);\n\tcnt=0;\n\tfor(int j=0;j<n;j++)\n\t  if (norm(dot[j]-c)<=1.0001)\n\t    cnt++;\n\tif (max<cnt){\n\t  max=cnt;\n\t}\n\n\tc = center2(dot[i],dot[*it],1);\n\tcnt=0;\n\tfor(int j=0;j<n;j++)\n\t  if (norm(dot[j]-c)<=1.0001)\n\t    cnt++;\n\tif (max<cnt){\n\t  max=cnt;\n\t}\n\tit++;\n      }\n    }\n    cout << max << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){\n    rep(i,v.size()) os << v[i] << (i+1==v.size()?\"\":\" \");\n    return os;\n}\n\ntypedef double R;\ntypedef complex<R> P;\nR const eps = 1e-8;\nR const pi = acos(-1);\n\nint main(){\n    int n;\n    while(cin>>n && n){\n        vector<P> ps(n);\n        rep(i,n){\n            R x,y; cin >> x >> y;\n            ps[i] = P(x,y);\n        }\n        int ans = 1;\n        rep(i,n)rep(j,n)if(i!=j){\n            P & p = ps[i];\n            P & q = ps[j];\n            R d = abs(p-q)/2;\n            if(d+eps > 1.0) continue;\n            P m = (p+q)/R(2);\n            R l = sqrt(1-d*d);\n            P u = (p-m)/d*l*P(0,1);\n            P c = m + u;\n            int cnt = 0;\n            dump(abs(c-p));\n            rep(k,n) if(abs(c-ps[k]) < 1.0+eps) cnt++;\n            ans = max(ans,cnt);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\ntypedef long double ld;\n\nstruct Point {\n    ld x, y;\n    Point(ld x, ld y) : x(x), y(y) {}\n    string to_s() {\n        ostringstream os;\n        os << x << ',' << y;\n        return os.str();\n    }\n    Point operator+(const Point& o) const {\n        return Point(x+o.x, y+o.y);\n    }\n    Point operator/(const int d) const {\n        return Point(x/d, y/d);\n    }\n};\n\nstruct Circle {\n    ld x, y;\n    ld r;\n    Circle(ld x=0, ld y=0, ld r=1) : x(x), y(y), r(r) {}\n    const static ld eps = 1e-10;\n    bool isIntersect(const Circle& o) const {\n        ld dx = o.x - x;\n        ld dy = o.y - y;\n        return (r + o.r) * (r + o.r) > (dx*dx + dy*dy);\n    }\n    pair<Point, Point> intersectionPoint(const Circle& o) const {\n        ld dx = o.x - x;\n        ld dy = o.y - y;\n        ld d = sqrt(dx*dx + dy*dy);\n\n        ld slope = dy / dx;\n        ld theta = atan(slope);\n        ld theta_p = acos((r*r - o.r*o.r + d*d) / (2*r*d));\n\n        return make_pair(\n                Point(x + r*cos(theta - theta_p), y + r*sin(theta - theta_p)),\n                Point(x + r*cos(theta + theta_p), y + r*sin(theta + theta_p)));\n    }\n    bool contains(ld px, ld py) const {\n        return r * r + eps > (px - x) * (px - x) + (py - y) * (py - y);\n    }\n    string to_s() {\n        ostringstream os;\n        os << x << ',' << y << ':' << r << endl;\n        return os.str();\n    }\n};\n\nint countContainingPoints(const Circle& c, const vector<Circle>& ps) {\n    int cnt = 0;\n    for (int i = 0; i < ps.size(); i++) \n        if (c.contains(ps[i].x, ps[i].y)) \n            cnt++;\n    return cnt;\n}\n\nPoint midPoint(pair<Point, Point>& pp) {\n    return (pp.first + pp.second) / 2;\n}\n\nint N;\nint main() {\n    vector<Circle> cs;\n    while (cin >> N, N) {\n        cs.clear(); cs.resize(N);\n        for (int i = 0; i < N; i++) cin >> cs[i].x >> cs[i].y;\n\n        vector<Point> ips; // Intersection PointS\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (i == j) continue;\n                if (!cs[i].isIntersect(cs[j])) continue;\n                pair<Point, Point> ip = cs[i].intersectionPoint(cs[j]);\n                ips.push_back(ip.first);\n                ips.push_back(ip.second);\n                //ips.push_back(midPoint(ip));\n            }\n        }\n\n        int maxPoint = 0;\n        for (int i = 0; i < ips.size(); i++) {\n            maxPoint = max(maxPoint, countContainingPoints(Circle(ips[i].x, ips[i].y, 1), cs));\n        }\n        cout << maxPoint << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint sgn(int x) { return (x > 0) - (x < 0); }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nsigned main() {\n    while (true) {\n        int N;\n        cin >> N;\n        if (N == 0) { break; }\n        vector<complex<double>> points;\n        rep(i, N) {\n            double X, Y;\n            cin >> X >> Y;\n            points.push_back({X, Y});\n        }\n        int ans = 1;\n        rep(i, N) {\n            rep(j, i) {\n                if (abs(points[i] - points[j]) > 2) { continue; }\n                complex<double> d = (points[i] - points[j]) / 2.0;\n                complex<double> v = d * sqrt(1 - norm(d)) / abs(d) * polar(1.0, PI / 2);\n                auto count = [&](complex<double> center) {\n                    double eps = 1e-8;\n                    int ret = 0;\n                    rep(k, N) { if (abs(points[k] - center) < 1 + eps) { ret++; }}\n                    return ret;\n                };\n                chmax(ans, count(points[j] + d + v));\n                chmax(ans, count(points[j] + d - v));\n            }\n        }\n        cout << ans << endl;\n\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define PI 3.141592653589793238\n// sqrtは重い\nusing namespace std;\ntypedef pair<double,double> P;\n\nvoid display(complex<double> a,complex<double> b){\n cout << \"(\" << a.real() <<\",\" << a.imag() <<\")\"<< \" \" <<\"(\"<< b.real() <<\",\" <<b.imag() << \")\" << endl;\n}\n\nint main(){\n  int n,ans;\n  double xin,yin,X;\n  complex<double> m;\n  while(cin >> n && n){\n    ans = 0;\n    complex<double> point[n];\n    for(int i=0;i<n;i++){\n      cin >> xin >> yin;\n      point[i] = complex<double>(xin,yin);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i == j)continue;\n\tcomplex<double> Rr = point[i]-point[j];\n\tif(abs(Rr) <= 2.0+EPS){\n\n\t  complex<double> UKPC,U,P1,P2;\n\t  UKPC = (point[i]+point[j])*0.5;\n       \n\t  double T = sqrt(1-norm(point[i]-point[j])*0.25);\n\n\t  UKPC = (point[i]+point[j])*0.5;\n\t               /* unit vector(単位べく利ゅ)             *//* T倍に拡大 ９０度回転 */ \n  \t  P1 = UKPC + (point[i]-point[j])/abs(point[i]-point[j])*polar(T,PI/2.0);\n\t  P2 = UKPC + (point[i]-point[j])/abs(point[i]-point[j])*polar(T,-PI/2.0);\n\t  //cout << \"P1 = \" << P1 << \", P2 = \" << P2 << endl;\n\t  int cnt=0;\n\t  complex<double> CalcP;\n\t  double Calc;\n\t  for(int k=0;k<n;k++){\n\t    Calc = abs(P1-point[k]);\n\t    if(Calc < 1.0+EPS){\n\t      cnt++;\n\t    }\n\t  }\t\n\n\t  ans = max(ans,cnt);\n\t  cnt = 0;\n\t  for(int k=0;k<n;k++){\n\t    Calc = abs(P2-point[k]);\n\t    if(fabs(Calc) < 1.0+EPS){\n\t      cnt++;\n\t    }\n\t  }\t\n  \n\t  ans = max(ans,cnt);\n\t  \n\n\t}\n\n      }\n    }\n\n    cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <complex>\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a); i < (b); i++)\n#define rep(i, n) REP(i, 0, n)\n\ntypedef complex<double> P;\n\n#define EPS (1e-10)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define EQV(a, b) (EQ((a).real(), (b).real) && EQ((a).imag(), (b).imag()))\n\nP unit_vector(P a) { return a/abs(a); }\nP normal_vector1(P a) { return a * P(0, 1); }\nP normal_vector2(P a) { return a * P(0, -1); }\ndouble distance_p_p(P a, P b) { return abs(a-b); }\n\nint N;\n\nint main()\n{\n\twhile (cin >> N, N) {\n\t\tvector<P> ps;\n\n\t\trep(i, N) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tps.push_back(P(x, y));\n\t\t}\n\n\t\tint ans = 1;\n\t\trep(i, N) {\n\t\t\tREP(j, i+1, N) {\n\t\t\t\tP p, q;\n\t\t\t\tp = ps[i]; q = ps[j];\n\n\t\t\t\tdouble d = distance_p_p(p, q);\n\t\t\t\tif (d > 2) continue;\n\n\t\t\t\tP pq_c = (q - p)/2.0;\n\t\t\t\tP a = unit_vector(normal_vector1(q-p));\n\t\t\t\tP b = unit_vector(normal_vector2(q-p));\n\n\t\t\t\tP c1 = (p + pq_c) + a*(sqrt(1.0-d*d/4.0));\n\t\t\t\tP c2 = (p + pq_c) + b*(sqrt(1.0-d*d/4.0));\n\n\t\t\t\tint buf1, buf2;\n\t\t\t\tbuf1 = buf2 = 2;\n\t\t\t\trep(k, N) {\n\t\t\t\t\tif (k == i || k == j) continue;\n\t\t\t\t\tif (distance_p_p(ps[k], c1) <= 1)\n\t\t\t\t\t\tbuf1++;\n\t\t\t\t\tif (distance_p_p(ps[k], c2) <= 1)\n\t\t\t\t\t\tbuf2++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, max(buf1, buf2));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\ninline point rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\ninline point rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ninline double angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ninline double abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ninline double norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ninline double dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ninline double cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\ninline int ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\ninline point projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\ninline bool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\ninline bool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\ninline bool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\ninline bool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ninline bool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\ninline bool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\ninline bool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ninline double dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ninline double dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ninline double dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ninline double dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ninline double dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\ninline double dist(const point& a, const point& b) {\n\treturn abs(a - b);\n}\n\ninline point crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn m.a + (m.b - m.a) * cross(l.b - l.a, l.a - m.a) * (1.0 / tmp);\n}\n\ninline point crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\ninline vector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS || !intersect(c, d)) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ninline double areaTriangle(point a, point b, const point& c) {\n\ta = a - c;\n\tb = b - c;\n\treturn fabs(a.x * b.y - b.x * a.y) / 2.0;\n}\n\ninline double area(const polygon& p) {\n\tconst int num = p.size();\n\tif(num < 3)\n\t\treturn 0;\n\n\tif(num == 3)\n\t\treturn areaTriangle(p[0], p[1], p[2]);\n\n\tdouble res = cross(p[num - 1], p[0]);\n\tfor(int i = 1; i < num; ++i)\n\t\tres += cross(p[i - 1], p[i]);\n\n\treturn res * 0.5;\n}\n\n// L.aからL.bの方向を見た場合に，点aが左側に来る．\ninline line bisector(const point& a, const point& b) {\n\treturn line(point((a.x - a.y + b.x + b.y) / 2.0, (a.y + a.x + b.y - b.x) / 2.0),\n\t\t\t\tpoint((a.x + a.y + b.x - b.y) / 2.0, (a.y - a.x + b.y + b.x) / 2.0));\n}\n\n// L.aからL.bを向いた時の左側を残して切断する．\ninline polygon convex_cut(const polygon& p, const line& l) {\n\tconst int num = p.size();\n\tpolygon res;\n\tfor(int i = 0; i < num; ++i) {\n\t\tconst int next = (i + 1) % num;\n\t\tconst int tmp = ccw(l.a, l.b, p[i]);\n\t\tif(tmp != -1)\n\t\t\tres.push_back(p[i]);\n\n\t\tif(tmp * ccw(l.a, l.b, p[next]) < 0)\n\t\t\tres.push_back(crosspoint(l, line(p[i], p[next])));\n\t}\n\n\treturn res;\n}\n\nvector<point> tangent(const circle& c, const point& p) {\n\tconst double x = norm(p - c.c);\n\tdouble d = x - c.r * c.r;\n\tif(d < -EPS) return vector<point>();\n\td = max(d, 0.0);\n\tconst point q1 = (p - c.c) * (c.r * c.r / x);\n\tconst point q2 = rotate90((p - c.c) * (-c.r * sqrt(d) / x));\n\tvector<point> res;\n\tres.push_back(c.c + q1 - q2);\n\tres.push_back(c.c + q1 + q2);\n\treturn res;\n}\n\nvector<line> tangent(const circle &a, const circle& b) {\n\tvector<line> res;\n\tif(abs(a.r - b.r) < EPS) {\n\t\tpoint dir = b.c - a.c;\n\t\tdir = rotate90(dir * (a.r / abs(dir)));\n\t\tres.push_back(line(a.c + dir, b.c + dir));\n\t\tres.push_back(line(a.c - dir, b.c - dir));\n\t}\n\telse {\n\t\tpoint p = a.c * (-b.r) + b.c * a.r;\n\t\tp = p * (1.0 / (a.r - b.r));\n\t\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\t\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\t\tres.push_back(line(ps[i], qs[i]));\n\t}\n\n\tpoint p = a.c * b.r + b.c * a.r;\n\tp = p * (1.0 / (a.r + b.r));\n\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\tres.push_back(line(ps[i], qs[i]));\n\n\treturn res;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n, n;) {\n\t\tvector<point> points;\n\t\tpoints.reserve(n);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoints.push_back(point(x, y));\n\t\t}\n\n\t\tint ans = 1;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tconst circle c1 = circle(points[i], 1.0);\n\t\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\t\tconst circle c2 = circle(points[j], 1.0);\n\t\t\t\tvector<point> center = crosspoint(c1, c2);\n\t\t\t\tif(center.size() != 2)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor(int k = 0; k < 2; ++k) {\n\t\t\t\t\tint cnt = 2;\n\t\t\t\t\tfor(int l = 0; l < n; ++l) {\n\t\t\t\t\t\tif(l == i || l == j)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tif(dist(center[k], points[l]) < 1.0 + EPS)\n\t\t\t\t\t\t\t++cnt;\n\t\t\t\t\t}\n\n\t\t\t\t\tchmax(ans, cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <complex>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << \"\\n\"\nstatic const int INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[1010][1010];\ndouble w[1000],v[1000];\ndouble box[200010];\nchar field[200][200];\n\nnamespace Geometry{\n  #define equals(a,b) (fabs((a) - (b)) < EPS)\n  #define BOTTOM 0\n  #define LEFT 1\n  #define RIGHT 2\n  #define TOP 3\n  #define gprint(X) cout << fixed << setprecision(5) << (X) << endl\n  #define gprints(X,Y) cout << fixed << setprecision(5) << (X) << \" \" << (Y) << endl\n  const double EPS = 1e-10;\n  static const int COUNTER_CLOCKWISE = 1;\n  static const int CLOCKWISE = -1;\n  static const int ONLINE_BACK = 2;\n  static const int ONLINE_FRONT = -2;\n  static const int ON_SEGMENT = 0;\n  \n  class Point{\n  public:\n    double x,y;\n    Point(double x = 0,double y = 0): x(x),y(y){}\n    Point operator + (Point p){ return Point(x + p.x , y + p.y); }\n    Point operator - (Point p){ return Point(x - p.x , y - p.y); }\n    Point operator += (Point p){ return Point(x += p.x,y += p.y); }\n    Point operator -= (Point p){ return Point(x -= p.x,y -= p.y); }\n    Point operator * (double a){ return Point(a * x , a * y); }\n    Point operator / (double a){ return Point(x / a , y / a); }\n    bool operator < (const Point &p) const{ return x != p.x ? x < p.x : y < p.y; }\n    bool operator == (const Point &p) const{ return equals(x,p.x) && equals(y,p.y); }\n\n    double abs(){ return sqrt(norm()); }\n    double norm(){ return x * x + y * y; }\n    friend ostream& operator << (ostream &os,Point &p){ return os << p.x << \" \" << p.y; }\n    friend istream& operator >> (istream &is,Point &p){ return is >> p.x >> p.y; }\n  };\n\n  struct Segment{\n    Point p1,p2;\n    Segment(){};\n    Segment(Point p1,Point p2): p1(p1) , p2(p2){};\n    friend ostream& operator << (ostream &os,Segment &seg){ return os << seg.p1 << \" \" << seg.p2; }\n    friend istream& operator >> (istream &is,Segment &seg){ return is >> seg.p1 >> seg.p2; }\n  };\n\n  class Circle{\n  public:\n    Point c;\n    double r;\n    Circle(Point c = Point(),double r = 0.0): c(c),r(r){}\n    friend ostream& operator << (ostream &os,Circle &c){ return os << c.c << \" \" << c.r; }\n    friend istream& operator >> (istream &is,Circle &c){ return is >> c.c >> c.r; }\n  };\n\n  typedef Point Vector;\n  typedef Segment Line;\n  typedef vector<Point> Polygon;\n\n  double norm(Vector a){ return  a.x * a.x + a.y * a.y; }\n  double abs(Vector a){ return sqrt(norm(a)); }\n  double dot(Vector a,Vector b){ return a.x * b.x + a.y * b.y; }\n  double cross(Vector a,Vector b){ return a.x * b.y - a.y * b.x; }\n  bool Orthogonal(Vector a,Vector b){ return equals(dot(a,b),0.0); }\n  bool Orthogonal(Point a1,Point a2,Point b1,Point b2){ return Orthogonal(a1 - a2,b1 - b2); }\n  bool Orthogonal(Segment s1,Segment s2){ return equals(dot(s1.p2 - s1.p1,s2.p2 - s2.p1) , 0.0); }\n  bool Parallel(Vector a,Vector b){ return equals(cross(a,b),0.0); }\n  bool Parallel(Point a1,Point a2,Point b1,Point b2){ return Parallel(a1 - a2 , b1 - b2); }\n  bool Parallel(Segment s1,Segment s2){ return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0); }\n  bool less(const Point &a,const Point &b){ return (a.x != b.x) ? a.x < b.x : a.y < b.y; }\n  bool greater(const Point &a,const Point b){ return !less(a,b); }\n\n  Point project(Segment s,Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1 , base) / norm(base);\n    return s.p1 + base * r;\n  }\n\n  Point reflect(Segment s,Point p){\n    return p + (project(s,p) - p) * 2.0;\n  }\n\n  int ccw(Point &p0,Point p1,Point p2){\n    p1 -= p0;\n    p2 -= p0;\n    if(cross(p1,p2) > EPS)return COUNTER_CLOCKWISE;\n    if(cross(p1,p2) < -EPS)return CLOCKWISE;\n    if(dot(p1,p2) < -EPS)return ONLINE_BACK;\n    if(p1.norm() < p2.norm())return ONLINE_FRONT;\n    return ON_SEGMENT;\n  }\n\n  bool intersect(Point p1,Point p2,Point p3,Point p4){\n    return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && \n            ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0);\n  }\n  bool intersect(Segment s1,Segment s2){ return intersect(s1.p1 , s1.p2 , s2.p1 , s2.p2); }\n\n  double distance(Vector a,Vector b){ return abs(a - b); }\n  double distanceLP(Line l,Point p){ return abs(cross(l.p2 - l.p1 , p - l.p1) / abs(l.p2 - l.p1)); }\n  double distanceSP(Segment s,Point p){\n    if(dot(s.p2 - s.p1,p - s.p1) < 0.0) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2,p - s.p2) < 0.0) return abs(p - s.p2);\n    return distanceLP(s,p);\n  }\n  double distance(Segment s1,Segment s2){\n    if(intersect(s1,s2))return 0.0;\n    return min(min(distanceSP(s1,s2.p1),distanceSP(s1,s2.p2)),\n               min(distanceSP(s2,s1.p1),distanceSP(s2,s1.p2)));\n  }\n\n  Point getCrossPoint(Segment s1,Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base,s1.p1 - s2.p1));\n    double d2 = abs(cross(base,s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n  }\n\n  pair<Point,Point> getCrossPoints(Circle c,Line l){\n    Vector pr = project(l,c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base , pr - e * base);\n  }\n\n  double arg(Vector p){ return atan2(p.y,p.x); }\n  Vector polar(double a,double r){ return Point(cos(r) * a, sin(r) * a); }\n\n  pair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r,t + a),c1.c + polar(c1.r,t - a));\n  }\n  \n  int contains(Polygon g,Point p){\n    int n = g.size();\n    bool x = false;\n    for(int i = 0;i < n;i++){\n      Point a = g[i] - p, b = g[(i + 1) % n] - p;\n      if(abs(cross(a,b)) < EPS && dot(a,b) < EPS)return 1;\n      if(a.y > b.y)swap(a,b);\n      if(a.y < EPS && EPS < b.y && cross(a,b) > EPS)x = !x;\n    }\n    return (x ? 2 : 0);\n  }\n\n  //=====================================================//\n  //==================== Andrew Scan ====================//\n  //=====================================================//\n \n  int Accw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS)return 1;\n    return -1;\n  }\n \n  Polygon andrewScan(Polygon s){\n    Polygon ans;\n    Polygon u,l;\n    if(s.size() < 3)return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n    for(int i = 2;i < s.size();i++){\n      for(int n = u.size();n >= 2 && Accw(u[n-2],u[n-1],s[i]) != -1;n--){\n        u.pop_back();\n      }\n      u.push_back(s[i]);\n    }\n \n    for(int i = s.size() - 3;i >= 0;i--){\n      for(int n = l.size();n >= 2 && Accw(l[n-2],l[n-1],s[i]) != -1;n--){\n        l.pop_back();\n      }\n      l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i = u.size() - 2;i >= 1;i--){\n      l.push_back(u[i]);\n    }\n    int f = 0;\n    for(int i = 1;i < l.size();i++){\n      if(l[f].y > l[i].y || (l[f].y == l[i].y && l[f].x > l[i].x)){\n        f = i;\n      }\n    }\n    for(int i = 0;i < l.size();i++){\n      ans.push_back(Point((int)l[(i + f)%l.size()].x,(int)l[(i + f)%l.size()].y));\n    }\n    return ans;\n  }\n\n  //=====================================================//\n  //======================== END ========================//\n  //=====================================================//\n\n  class EndPoint{\n  public:\n    Point p;\n    int seg,st;\n    EndPoint(){}\n    EndPoint(Point p,int seg,int st): p(p),seg(seg),st(st){}\n\n    bool operator < (const EndPoint &ep) const{\n      if(p.y == ep.p.y){\n        return st < ep.st;\n      }else{\n        return p.y < ep.p.y;\n      }\n    }\n  };\n\n  EndPoint EP[2 * 100000];\n\n  int manhattanIntersection(vector<Segment> S){\n    int n = S.size();\n    for(int i = 0,k = 0;i < n;i++){\n      if(S[i].p1.y == S[i].p2.y){\n        if(S[i].p1.x > S[i].p2.x)swap(S[i].p1,S[i].p2);\n      }else if(S[i].p1.y > S[i].p2.y){\n        swap(S[i].p1,S[i].p2);\n      }\n\n      if(S[i].p1.y == S[i].p2.y){\n        EP[k++] = EndPoint(S[i].p1,i,LEFT);\n        EP[k++] = EndPoint(S[i].p2,i,RIGHT);\n      }else{\n        EP[k++] = EndPoint(S[i].p1,i,BOTTOM);\n        EP[k++] = EndPoint(S[i].p2,i,TOP);\n      }\n    }\n\n    sort(EP,EP + (2 * n));\n\n    set<int> BT;\n    BT.insert(1000000001);\n    int cnt = 0;\n    for(int i = 0;i < 2 * n;i++){\n      if(EP[i].st == TOP){\n        BT.erase(EP[i].p.x);\n      }else if(EP[i].st == BOTTOM){\n        BT.insert(EP[i].p.x);\n      }else if(EP[i].st == LEFT){\n        set<int>::iterator b = lower_bound(BT.begin(),BT.end(),S[EP[i].seg].p1.x);\n        set<int>::iterator e = upper_bound(BT.begin(),BT.end(),S[EP[i].seg].p2.x);\n        cnt += distance(b,e);\n      }\n    }\n    return cnt;\n  }\n};\n\nusing namespace Geometry;\n\nint main(){\n  while(cin >> n && n){\n    m = 0;\n    vector<Point> vec(n);\n    rep(i,0,n)cin >> vec[i];\n    clr(d,0);\n    rep(i,0,n){\n      rep(j,i+1,n){\n        if(i == j)continue;\n        // 2点に接する円を作り、その中に含まれる点の数を計算する (円の中心と点の距離が1＋誤差以下ならOK)\n        // 最大で2700万ループ\n        if((distance(vec[i],vec[j])) <= 2){\n          l = 0;\n          Point pnt = (vec[j] - vec[i]) / 2.0;\n          // gprint(pnt);\n          double dist = distance(Point(0,0),pnt);\n          double error = sqrt(1.0 - dist * dist) / dist;\n          // cout << dist << \" \" << error << endl;\n          Point center(vec[i].x + pnt.x - error * pnt.y , vec[i].y + pnt.y + error * pnt.x);\n          // cout << \"Center : \";\n          // gprint(center);\n          rep(k,0,n){\n            // printf(\"Distance (%f,%f) -> %f\\n\",vec[k].x,vec[k].y,distance(center,vec[k]));\n            if(distance(center,vec[k]) < 1.00001)l++;\n          }\n          m = max(m,l);\n        }\n      }\n    }\n    if(m == 0)puts(\"1\");\n    else print(m);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(void){\n\tint n;\n\twhile(cin >> n, n){\n\t\tvector<double> x(n), y(n);\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tfor(int j = i+1; j < n; ++j){\n\t\t\t\tdouble rx[2], ry[2], a, ax, ay, bx, by;\n\t\t\t\tax = (x[j] - x[i]) / 2.0;\n\t\t\t\tay = (y[j] - y[i]) / 2.0;\n\t\t\t\ta = sqrtl(ax*ax + ay*ay);\n\t\t\t\tby = ax * sqrtl(1.0-a*a) / a;\n\t\t\t\tbx = ay * sqrtl(1.0-a*a) / a;\n\t\t\t\trx[0] = x[i] + ax + bx; rx[1] = x[i] + ax - bx;\n\t\t\t\try[0] = y[i] + ay - by; ry[1] = y[i] + ay + by;\n\t\t\t\tfor(int k = 0; k < 2; ++k){\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\t//cout << \"[\" << rx[k] << \" \" << ry[k] << \"]\" << endl;\n\t\t\t\t\tfor(int l = 0; l < n; ++l){\n\t\t\t\t\t\t//cout << (x[l]-rx[k])*(x[l]-rx[k])+(y[l]-ry[k])*(y[l]-ry[k]) << endl;\n\t\t\t\t\t\tif((x[l]-rx[k])*(x[l]-rx[k])+(y[l]-ry[k])*(y[l]-ry[k]) <= 1.0001){\n\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t\t\t//cout << x[l] << \" \" << y[l] << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans, sum);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (ans?ans:1) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <assert.h>\n#include <iomanip>\n#include <bitset>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define IS_BIT_ON(bit, i) (bit & (1 << i))\n#define BIT_ON(bit, i) (bit |= (1 << i))\n#define BIT_OFF(bit, i) (bit &= ~(1 << i))\n#define BIT_COUNT(bit) (__builtin_popcount(bit))\n\ntypedef long long LL;\ntemplate<typename T> std::vector<T> make_v(size_t a){return std::vector<T>(a);}\ntemplate<typename T,typename... Ts> auto make_v(size_t a, Ts... ts){ return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}    // C++14\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value==0>::type fill_v(T &t,const V &v){t=v;}\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value!=0>::type fill_v(T &t,const V &v){for(auto &e:t) fill_v(e,v);}\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\nvoid print() { std::cout << std::endl; }\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) { std::cout << head; if (sizeof...(tail) != 0) {std::cout << \" \";} print(std::forward<Tail>(tail)...); }\ntemplate <class T> void print(std::vector<T> &v) {for (auto& a : v) { std::cout << a; if (&a != &v.back()) {std::cout << \" \";} }std::cout << std::endl;}\ntemplate <class T> void print(std::vector<std::vector<T>> &vv) { for (auto& v : vv) { print(v); }}\ninline bool inside(long long y, long long x, long long H, long long W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\n\ntemplate<class T> inline std::vector<T> unique(std::vector<T> v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v;\n}\n// 初項s, 交差dのn個の数列の和\nlong long sum_of_arithmetic_progression(long long s, long long d, long long n) {\n    return n * (2 * s + (n - 1) * d) / 2;\n}\n\n// 2のべき乗数かどうか\nbool is_power_of_two(long long x) {\n    return !(x & (x - 1));\n}\n\n// aとbの最大公約数 O(log min(a, b))\nlong long gcd(long long a, long long b) {\n    if (b == 0) { return a; }\n    return gcd(b, a % b);\n}\n\n// 数列vの最大公約数 O(N log d)\nlong long gcd(std::vector<long long> &v) {\n    long long ans = v[0];\n    for (int i = 1; i < (int)v.size(); ++i) {\n        ans = gcd(ans, v[i]);\n    }\n    return ans;\n}\n\n// aとbの最小公倍数 O(log min(a, b))\nlong long lcm(long long a, long long b) {\n    long long g = gcd(a, b);\n    return a / g * b;\n}\n\nconst int INF = 1u << 30u;\nconst long long LINF = 1ull << 58u;\nconst double EPS = 1e-9;\nconst long double PI = acos(-1.0);\nconst std::vector<int> dy2 = {0, 1}, dx2 = {1, 0};  // 右，下\nconst std::vector<int> dy4 = {0, 1, 0, -1}, dx4 = {1, 0, -1, 0};    // 右，下，左，上\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\ntemplate<class T> class Inside {\npublic:\n    // 半径r，中心(y1, x1)の円に点(y2, x2)が含まれるか\n    static bool inside_circle(T y1, T x1, T r, T y2, T x2) {\n        return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= r * r + EPS;  // 線も含む\n//        return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) < r * r; // 線を含まない\n    }\n};\n\n\n// (y1, x1)と(y2, x2)を円周上にもつ半径rの円の中心座標\nvector<pair<double, double>> point_on_circle(double y1, double x1, double y2, double x2, double r) {\n\n    const auto x3 = (x1 + x2) / 2.0;\n    const auto y3 = (y1 + y2) / 2.0;\n\n    r *= r;\n    const auto l1 = (x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3);\n\n    if  (r >= l1) {\n        const auto d = sqrt(r / l1 - 1.0);\n        const auto dx = d * (y2 - y3);\n        const auto dy = d * (x2 - x3);\n        return {make_pair(y3 - dy, x3 + dx), make_pair(y3 + dy, x3 - dx)};\n    }\n    else {\n        return {};\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        LL N;\n        cin >> N;\n\n        if (N == 0) {\n\n            return 0;\n        }\n\n        auto points = make_v<pair<double, double>>(N);\n        FOR(i, 0, N) {\n            cin >> points[i].second >> points[i].first;\n        }\n\n        LL ans = 1;\n        FOR(i, 0, N) {\n            FOR(j, 0, N) {\n                if (i == j) {\n                    continue;\n                }\n                if (euclidean_distance(points[i].first, points[i].second, points[j].first, points[j].second) > 2 + EPS) {\n                    continue;\n                }\n\n                auto p = point_on_circle(points[i].first, points[i].second, points[j].first, points[j].second, 1);\n\n                if (p.empty()) {\n                    continue;\n                }\n\n                LL num1 = 0, num2 = 0;\n                FOR(k, 0, N) {\n                    num1 += Inside<double>::inside_circle(p[0].first, p[0].second, 1, points[k].first, points[k].second);\n                    num2 += Inside<double>::inside_circle(p[1].first, p[1].second, 1, points[k].first, points[k].second);\n                }\n                chmax(ans, num1);\n                chmax(ans, num2);\n            }\n        }\n        print(ans);\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <string> \n#include <vector> \n#include <cmath> \n#include <algorithm> \n#include <cstdlib> \n#include <ctime> \n#include <cstdio> \n#include <functional> \n#include <set> \n#include <sstream> \n\nusing namespace std; \n\ndouble d2(double x1,double x2,double y1,double y2){\n\treturn (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n}\n\nint main(){\n\n\tint n;\n\tconst double eps=1e-8;\n\twhile(true){\n\n\t\tcin>>n;\n\n\t\tif(n==0) return 0;\n\n\t\tint res=1;\n\t\tvector<double> x(n),y(n);\n\n\t\tfor(int i=0;i<n;i++) cin>>x[i]>>y[i];\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\n\t\t\t\tint res2=0;\n\t\t\t\tconst double X=(x[i]+x[j])/2.0;\n\t\t\t\tconst double Y=(y[i]+y[j])/2.0;\n\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tprintf(\"P1(%f, %f) P2(%f, %f) -> d2=%f\\n\",x[k],y[k],X,Y,sqrt(d2(x[k],X,y[k],Y)));\n\t\t\t\t\tif(d2(x[k],X,y[k],Y)<1.0+eps) res2++;\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\n\t\t\t\tres=max(res,res2);\n\n\t\t\t}\n\t\t}\n\n\t\tcout<<res<<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n#include<set>\n#include<array>\n#include<cassert>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\ntypedef double Real;\n\nconst Real EPS = 1e-8;\n\nint sign(Real d){\n\treturn d > EPS ? 1 : d < -EPS ? -1 : 0;\n}\n\nstruct Point{\n\tReal x,y;\t\n\texplicit Point(Real x_ = 0,Real y_ = 0):x(x_),y(y_){}\n\tPoint operator+(const Point &p) const {return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point &p) const {return Point(x-p.x,y-p.y);}\n\tPoint operator*(Real s) const {return Point(x*s,y*s);}\n\tPoint operator/(Real s) const {return Point(x/s,y/s);}\n\tbool operator<(const Point &p) const{return sign(x-p.x) == -1 || (sign(x-p.x) == 0 && sign(y-p.y) == -1);}\n\tbool operator==(const Point &p) const{return sign(x-p.x) == 0 && sign(y-p.y) == 0;}\n\n};\n\nistream &operator>>(istream &is,Point &p){return is >> p.x >> p.y;}//??\\???????°???????\nostream &operator<<(ostream &os ,const Point &p){return os << '(' << p.x << \", \" << p.y << ')';}//??????????°???????\n\nstruct Segment : public array<Point,2>{\n\tSegment(const Point &a,const Point &b){\tat(0) = a; at(1) = b;}\n};\n\nstruct Line : public array<Point,2>{\n\tLine(const Point &a,const Point &b){at(0) = a; at(1) = b;}\n};\n\nstruct Circle{\n\tPoint c;\n\tReal r;\n\n\tCircle(const Point &c_, Real r_):c(c_),r(r_){}\n};\n\ntypedef vector<Point> Polygon;\n\nPoint rotate90(const Point &p){\n\treturn Point(-p.y,p.x);\n}\n\nPoint rotate(const Point &p,Real theta){\n\tconst Real s = sin(theta),c = cos(theta);\n\treturn Point(c*p.x-s*p.y,s*p.x+c*p.y);\n}\n\nReal angle(const Point &p){\n\treturn atan2(p.y,p.x);\n}\n\nReal dot(const Point &a,const Point &b){ //??????????????????\n\treturn a.x*b.x+a.y*b.y;\n}\n\nReal cross(const Point &a,const Point &b){ //??????????????????\n\treturn a.x*b.y-a.y*b.x;\n}\n\n\nReal norm(const Point &p){\n\treturn p.x*p.x+p.y*p.y;\n}\n\nReal abs(const Point &p){\n\treturn sqrt(norm(p));\n}\n\nenum { CCW=1,CW=-1,BACK=2,FRONT=-2,ON=0 };\nint ccw(const Point &a,const Point &b,const Point &c){\n\tconst Point p = b-a;\n\tconst Point q = c-a;\n\tconst int sgn = sign(cross(p,q));\n\t\n\tif(sgn == 1) return CCW;\n\tif(sgn == -1) return CW;\n\tif(sign(dot(p,q)) == -1) return BACK;\n\tif(sign(norm(p) - norm(q)) == -1) return FRONT;\n\treturn ON;\n}\n\nPoint project(const Line &l,const Point &p){ //?°???±\n\tReal t = dot(p-l[0], l[1]-l[0]) / norm(l[0] - l[1]);\n\treturn l[0] + (l[1] - l[0]) * t;\n}\n\nPoint refrect(const Line &l,const Point &p){ //????°?\n\tconst Point c = project(l,p);\n\treturn c+(c-p);\n}\n\nbool intersect(const Segment &a,const Segment &b){\n\treturn ccw(a[0],a[1],b[0])*ccw(a[0],a[1],b[1]) <= 0\n\t\t&& ccw(b[0],b[1],a[0])*ccw(b[0],b[1],a[1]) <= 0;\n}\n\nbool intersect(const Segment &s,const Point &p){\n\treturn ccw(s[0],s[1],p) == ON;\n}\n\nbool intersect(const Line &l,const Segment &s){\n\treturn sign(cross(l[1]-l[0],s[0]-l[0])) * cross(l[1]-l[0],s[1]-l[0]) <= 0;\n}\n\nbool intersect(const Line &l,const Point &p){\n\treturn abs(ccw(l[0],l[1],p)) != 1;\n}\n\nbool intersect(const Line &a,const Line &b){ //????????????\n\treturn sign(cross(a[1]-a[0],b[1]-b[0])) != 0\n\t\t||\tsign(cross(a[1]-a[0],b[1]-a[0]) == 0);\n}\n\nReal dist(const Point &a,const Point &b){\n\treturn abs(a-b);\t\n}\n\nReal dist(const Line &l,const Point &p){\n\tconst Point a = l[1]-l[0];\n\tconst Point b = p-l[0];\n\treturn abs(cross(a,b))/abs(a);\n}\n\nReal dist(const Line &l,const Segment &s){\n\tif(intersect(l,s)) return 0;\n\treturn min(dist(l,s[0]),dist(l,s[1]));\n}\n\nReal dist(const Line &a,const Line &b){\n\tif(intersect(a,b)) return 0;\n\treturn dist(a,b[0]);\n}\n\nReal dist(const Segment &s,const Point &p){\n\tif(sign(dot(s[1]-s[0],p-s[0]))==-1) return dist(s[0],p);\n\tif(sign(dot(s[0]-s[1],p-s[1]))==-1) return dist(s[1],p);\n\treturn dist(Line(s[0],s[1]),p);\n}\n\nReal dist(const Segment &a,const Segment &b){\n\tif(intersect(a,b)) return 0;\n\treturn min({dist(a,b[0]),dist(a,b[1]),dist(b,a[0]),dist(b,a[1])});\n}\n\nbool intersect(const Circle &a,const Circle &b){\n\treturn sign(dist(a.c,b.c)-(a.r+b.r)) <=0\n\t\t\t&& sign(dist(a.c,b.c)-abs(a.r-b.r)) >= 0;\n}\n\nbool intersect(const Circle &c,const Segment &s){\n\treturn sign(dist(s,c.c)-c.r)<=0;\n}\n\nbool intersect(const Circle &c,const Line &l){\n\treturn sign(dist(l,c.c)-c.r)<=0;\n}\n\nbool contain(const Circle &c,const Point &p){\n\treturn sign(dist(c.c,p)-c.r)<=0;\n}\n\nbool contain(const Polygon &P,const Point &p){\n\tbool res = false;\n\n\tfor(int i=0;i<P.size();++i){\n\t\tPoint v1=P[i]-p;\n\t\tPoint v2=P[(i+1)%P.size()]-p;\n\t\tif(v1.y>v2.y) swap(v1,v2);\n\n\t\tif(sign(cross(v1,v2))==0&&sign(dot(v1,v2))<=0){\n\t\t\treturn true;//on edge \n\t\t}\n\t\tif(sign(v1.y)<=0&&sign(v2.y)==1&&sign(cross(v1,v2))==1){\n\t\t\tres=!res;\n\t\t}\n\t}\n\treturn res;\n}\n\nPoint crosspoint(const Line &a,const Line &b){\n\tassert(intersect(a,b));\n\tconst Real crs = cross(a[1]-a[0],b[1]-b[0]);\n\tif(sign(crs) == 0) return a[0];\n\treturn b[0]+(b[1]-b[0])*(cross(a[1]-a[0],a[1]-b[0])/crs);\n}\n\n\n//??¬??¢?????????????????¨?????°?????????????????????Intersect?????????\nPoint crosspoint(const Segment &a,const Segment &b){\n\tassert(intersect(a,b));\n\tconst Real crs = cross(a[1]-a[0],b[1]-b[0]);\n\tif(sign(crs)==0){\n\t\tif(intersect(a,b[0])) return b[0];\n\t\tif(intersect(a,b[1])) return b[1];\n\t\tif(intersect(b,a[0])) return a[0];\n\t\treturn a[1];\n\t}\n\treturn b[0]+(b[1]-b[0])*(cross(a[1]-a[0],a[1]-b[0])/crs);\n}\n\nvector<Point> crosspoint(const Circle &c,const Line &l){\n\tconst Point p = project(l,c.c);\n\tconst Real h = dist(p,c.c);\n\n\tvector<Point> res;\n\tif(sign(h-c.r)==1){\n\t\t//nothing\n\t}else if(sign(h-c.r)==0){\n\t\tres.emplace_back(p);\t\n\t}else{\n\t\tconst Real b = sqrt(c.r*c.r-h*h);\n\t\tconst Point e = (l[1]-l[0])/abs(l[1]-l[0]);\n\t\tres.emplace_back(p+e*b);\n\t\tres.emplace_back(p-e*b);\n\t}\n\treturn res;\n}\n\nvector<Point> crosspoint(const Circle &a,const Circle &b){\n\tif(!intersect(a,b)) return vector<Point>();\n\n\tvector<Point> res;\n\tconst Real d = dist(a.c,b.c);\n\n\tif(sign(d-(a.r+b.r))==0){\n\t\tconst Point v = b.c - a.c;\n\t\tres.emplace_back(a.c + (v * (a.r /abs(v))));\n\t}else{\n\t\tconst Real theta = acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\t\tconst Real phi = angle(b.c-a.c);\n\t\tres.emplace_back(a.c+rotate(Point(a.r,0),phi+theta));\n\t\tres.emplace_back(a.c+rotate(Point(a.r,0),phi-theta));\n\t}\n\treturn res;\n}\n\nReal area(const Polygon &P){\n\tReal res = 0.0;\n\tfor(int i=0;i<P.size();++i){\n\t\tres+=cross(P[i],P[(i+1)%P.size()]);\n\t}\n\treturn abs(res) * 0.5;\n}\n\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tvector<Circle> circles;\n\t\tvector<Circle> ccircles;\n\t\trep(i,n){\n\t\t\tPoint p;\n\t\t\tcin >> p;\n\t\t\tcircles.push_back(Circle(p,1.0));\n\t\t}\n\t\t\n\t\t//??????????±???????\n\t\trep(i,n) for(int j=i+1;j<n;j++){\n\t\t\tvector<Point> points = crosspoint(circles[i],circles[j]);\n\t\t\trep(k,points.size()){\n\t\t\t\tccircles.push_back(Circle(points[k],1.0));\n\t\t\t}\n\t\t}\n\n\n\t\tint ans=1;\n\t\tvector<Point> points;\n\t\t\n\t\t//??????????????§??°???????????§????????????\n\t\trep(i,ccircles.size()){\n\t\t\tint cnt=0;\n\t\t\trep(j,n){\n\t\t\t\tif(contain(ccircles[i],circles[j].c)){\n\t\t\t\t\tcnt++;\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tans=max(cnt,ans);\n\t\t}\t\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <cmath>\n\nusing namespace std;\n\ntypedef pair<double,double> pos;\nconst double r = 1;\nint count(vector<pos> ps,double x,double y,int ban1,int ban2){\n\tint c=2;\n\tfor(int i=0;i<ps.size();i++){\n\t\tif(i!=ban1&&i!=ban2&&\n\t\t\t\tpow(ps[i].first-x,2)+pow(ps[i].second-y,2)<=1.0){\n\t\t\tc++;\n\t\t}\n\t}\n\treturn c;\n}\n\nbool range(pos p1,pos p2,double r){\n\treturn pow(p1.first-p2.first,2)+pow(p1.second-p2.second,2) <= r*r;\n}\n\ndouble len(pos p){\n\treturn sqrt(pow(p.first,2)+pow(p.second,2));\n}\n\ndouble len2(pos p){\n\treturn (pow(p.first,2)+pow(p.second,2));\n}\n\nvector<pos> point2(pos p1,pos p2){\n\tpos m = make_pair((p1.first+p2.first)/2,(p1.second+p2.second)/2);\n\tpos vec = make_pair(p1.first-p2.first,p1.second-p2.second);\n\tpos q = m;//make_pair(p2.first+vec.first/2,p2.second+vec.second/2);\n\tdouble l = sqrt(1-pow(len(vec)/2.0,2));\n\tdouble ll = len(vec);\n\tpos vec2 = make_pair(-vec.second,vec.first);\n\tvec2.first=vec2.first/ll*l;\n\tvec2.second = vec2.second/ll*l;\n\tvector<pos> ret;\n\tret.push_back(make_pair(q.first+vec2.first,q.second+vec2.second));\n\tret.push_back(make_pair(q.first-vec2.first,q.second-vec2.second));\n\treturn ret;\n}\n\nint solve(vector<pos> ps){\n\tint mx=0;\n\tfor(int i=0;i<ps.size()-1;i++)\n\t\tfor(int k=i+1;k<ps.size();k++){\n\t\t\tif(range(ps[i],ps[k],2)){\n\t\t\t\t//cerr << \"*****\" << i << \" \" << k << endl;\n\t\t\t\tvector<pos> vp = point2(ps[i],ps[k]);\n\t\t\t\tmx = max(mx,count(ps,vp[0].first,vp[0].second,i,k));\n\t\t\t\tmx = max(mx,count(ps,vp[1].first,vp[1].second,i,k));\n\t\t\t}\n\t\t}\n\treturn mx;\n}\n\nint main(){\n\t//cerr << point2(make_pair(0,0),make_pair(1,1))[1].first << endl;\n\twhile(true){\n\t\tint n;\n\t\tvector<pos> v;\n\t\tcin >> n;\n\t\tif(n==0)return 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tv.push_back(make_pair(x,y));\n\t\t}\n\t\tcout << solve(v) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <complex>\n\n#define EPS (1e-10)\n\nusing namespace std;\n\nint count( vector<complex<double>> &vpos );\n\nint main(int argc, char const *argv[]) {\n    int n, result;\n    double x, y;\n    vector<complex<double>> vpos;\n    vector<int> results;\n\n    while(1){\n        cin>>n;\n        if( n == 0 ) break;\n        for(int i = 0; i < n; i++){\n            cin>>x>>y;\n            vpos.push_back( complex<double> (x,y) );\n        }\n        results.push_back( count( vpos ) );\n        vpos.clear();\n    }\n\n    for (auto it = results.begin(); it != results.end(); it++) {\n        cout<<*it<<endl;\n    }\n\n    return 0;\n}\n\nint count( vector<complex<double>> &vpos ){\n    int count = 0;\n    int tmp_count1, tmp_count2;\n    int size = vpos.size();\n    bool flag = false;\n    complex<double> m, n1, n2, center1, center2;\n\n    if( size == 1 ) return 1;\n\n    for(int i = 0; i < size; i++){\n        for(int j = i + 1; j < size ; j++){\n            if( vpos[i].real() == vpos[j].real() ) continue;\n            tmp_count1 = 0;\n            tmp_count2 = 0;\n\n            m = ( vpos[i] + vpos[j] ) / 2.0;\n            n1 = ( vpos[i] -  vpos[j] ) * complex<double> ( 0.0, 1.0 );\n            n1 = n1 / abs(n1);\n            n2 = ( vpos[i] -  vpos[j] ) * complex<double> ( 0.0, -1.0 );\n            n2 = n2 / abs(n2);\n\n            double x = abs( vpos[i] -  vpos[j] ) / 2.0;\n            center1 =  m + n1 * sqrt( 1.0 - x * x );\n            center2 =  m + n2 * sqrt( 1.0 - x * x );\n\n            if( center1.real() > 0.0 ) flag = true;\n            if( center2.real() > 0.0 ) flag = true;\n\n            for(int k = 0; k < size; k++){\n                double dist1 = abs( center1 - vpos[k] );\n                double dist2 = abs( center2 - vpos[k] );\n                if( dist1 <= 1.0 + EPS ){\n                    tmp_count1++;\n                }\n                if( dist2 <= 1.0 + EPS ){\n                    tmp_count2++;\n                }\n            }\n            if( count < max(tmp_count1, tmp_count2) ){\n                count = max(tmp_count1, tmp_count2);\n            }\n        }\n    }\n\n    if(!flag) return 1;\n    return count;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\n// y???real(), x???imag()\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool cmp_y(const P &a, const P &b){\n\t\treturn a.imag() != b.imag() ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n// circle\nstruct C {\n\tP p; double r;\n\tC(const P& p, double r) : p(p), r(r) {}\n};\n\n// 2???p1, p2?????????????????????r?????????2?????????\nvector<C> calcCircle(P p1, P p2, double r) {\n\tif(abs(p1-p2) > 2*r) return {};\n\tP p3 = {(p1.real()+p2.real())/2, (p1.imag()+p2.imag())/2};\n\t// cout << p3.real() << \" \" << p3.imag() << endl;\n\tdouble l = abs(p1-p3);\n\t// cout << \"l:\" << l << endl;\n\t// ????????????p_1p_2\n\tP p1p2 = p2-p1;\n\tdouble a = p1p2.real(), b = p1p2.imag();\n\tdouble dx = b*sqrt((r*r-l*l)/(a*a+b*b)), dy = a*sqrt((r*r-l*l)/(a*a+b*b));\n\t// cout << \"dx:\" << dx << \" dy:\" << dy << endl;\n\treturn {{{p3.real()+dx, p3.imag()-dy}, r}, {{p3.real()-dx, p3.imag()+dy}, r}};\n}\n\n// ???p??????c????????¨????????¨??????????????????\nbool intersectCP(C c, P p) { return abs(p-c.p) <= c.r + EPS; }\n\nP po[305];\nsigned main(void)\n{\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n    REP(i, n) {\n      double x, y;\n      cin >> x >> y;\n      po[i] = {x, y};\n    }\n\n    int ans = 1;\n    REP(i, n) FOR(j, i+1, n) {\n      vector<C> ret = calcCircle(po[i], po[j], 1);\n      if(ret.size() == 0) continue;\n      // cout << \"i:\" << i << \" j:\" << j << endl;\n      // cout << ret[0].p.real() << \" \" << ret[0].p.imag() << \" \" << ret[0].r << endl;\n      // cout << ret[1].p.real() << \" \" << ret[1].p.imag() << \" \" << ret[1].r << endl;\n      int num = 0;\n      REP(k, n) {\n        num += intersectCP(ret[0], po[k])?1:0;\n        // if(intersectCP(ret[0], po[k])) cout << k << \" \";\n      }\n      chmax(ans, num);\n      // cout << \"num:\" << num << endl;\n      num = 0;\n      REP(k, n) {\n        num += intersectCP(ret[1], po[k])?1:0;\n        // if(intersectCP(ret[1], po[k])) cout << k << \" \";\n      }\n      // cout << \"num:\" << num << endl;\n      chmax(ans, num);\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cassert>\n#include<string>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<tuple>\n#include<numeric>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\nconst int INF = 1 << 31;\nconst ll INF_ll = 1LL << 62;\nconst double EPS = 1e-8;\n\n// vector\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) {\n    for(const T &t : v) os << \"\\t\" << t; return os << endl;\n}\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) {\n    for(T &a : v) is >> a; return is;\n}\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) {\n    return os << \"<\" << v.first << \" \" << v.second << \">\";\n}\n\nusing Coordinate = double;\n\nbool eq(Coordinate a, Coordinate b) {\n    return abs(a - b) < EPS;\n}\n\n/*\n * Point\n */\nstruct Point {\n    Coordinate x,y;\n    Point():x(0),y(0){}\n    Point(Coordinate x,Coordinate y):x(x),y(y){}\n    pair<Coordinate,Coordinate> to_pair() const { return make_pair(x,y); }\n    bool operator == (const Point &a) const { return eq(x, a.x) && eq(y, a.y); }\n    bool operator != (const Point &a) const { return !(*this == a); }\n    \n    Point operator + (const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator - (const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator - () const { return Point(-x, -y); }\n    Point& operator += (const Point& p) { x += p.x; y += p.y; return *this; }\n    Point& operator -= (const Point& p) { x -= p.x; y -= p.y; return *this; }\n    // ???????????¨ x, y???\n    bool operator <  (const Point &a) const { return x < a.x && y < a.y; }\n    bool operator <= (const Point &a) const { return *this == a || *this < a;}\n    bool operator >  (const Point &a) const { return !(*this <= a); }\n    bool operator >= (const Point &a) const { return !(*this < a); }\n};\ntemplate<typename T> Point operator * (T k, const Point &p) { return Point(k * p.x, k * p.y); }\ntemplate<typename T> Point operator / (const Point &p, T k) { return Point(p.x / k, p.y / k); }\ndouble dot(const Point &a, const Point &b) { return a.x * b.x + a.y * b.y; }\ndouble cross(const Point &a, const Point &b) { return a.x * b.y - a.y * b.x; }\ndouble norm(const Point& a) { return sqrt( dot(a, a) ); }\n\nistream &operator >> (istream& is, Point& p){ return is >> p.x >> p.y;}\nostream &operator << (ostream& os, Point& p){ return os << \"(\" << p.x << \",\" << p.y << \")\";}\n\ndouble distance(const Point& a, const Point& b) { return norm(a - b); }\ndouble distance2(const Point& a, const Point& b) { return dot(a - b, a - b); }\n\nPoint rotate(Point &p, double degree) {\n    double rad = degree * M_PI / 180;\n    return Point(cos(rad) * p.x - sin(rad) * p.y,\n                 sin(rad) * p.x + cos(rad) * p.y);\n}\n// ??£?????´???????????????\nPoint orthonormal(Point &p) {\n    Point p2 = Point(-1 * p.y, p.x); //rotate(p, 90);\n    return p2 / norm(p2);\n}\n\n\nenum class ccw_t {\n    COUNTER_CLOCK_WISE = 1,\n    CLOCK_WISE = -1,\n    STRAIGHT_C_A_B = 2,\n    STRAIGHT_A_B_C = -2,\n    STRAIGHT_A_C_B = 0\n};\n\n\nccw_t ccw(Point a,Point b,Point c){\n    Point ab = b - a;\n    Point ac = c - a;\n    if( cross(ab,ac) > 0 ) return ccw_t::COUNTER_CLOCK_WISE;//a-b-c ???????¨???????\n    if( cross(ab,ac) < 0 ) return ccw_t::CLOCK_WISE;        //a-b-c ????¨???????\n    if( dot(ab,ac) < 0 ) return ccw_t::STRAIGHT_C_A_B;      //c-a-b\n    if( norm(ab) < norm(ac) )return ccw_t::STRAIGHT_A_B_C;  //a-b-c or a==b\n    return ccw_t::STRAIGHT_A_C_B;                           //a-c-b or b==c or a==c\n}\n\n/*\n * Segment\n */\n\nstruct Segment{\n    Point a, b;\n    Segment(){}\n    Segment(const Point& a, const Point& b):a(a), b(b){}\n    pair<Point,Point> to_pair() const { return make_pair(a,b); }\n    bool operator == (const Segment& s) const { return to_pair() == s.to_pair();}\n    bool operator != (const Segment& s) const { return to_pair() != s.to_pair();}\n};\n\ndouble length(const Segment &s){ return distance(s.a, s.b); }\nistream &operator >> (istream& is, Segment& s){ return is >> s.a >> s.b;}\nostream &operator << (ostream& os, Segment& s){ return os << s.a << \"->\" << s.b;}\n\nbool does_intersect(const Segment &a, const Segment &b){\n    return (int)ccw(a.a, a.b, b.a) * (int)ccw(a.a, a.b, b.b) <= 0 &&\n            (int)ccw(b.a, b.b, a.a) * (int)ccw(b.a, b.b, a.b) <= 0;\n}\n\ndouble distance( const Segment &s , const Point &p){\n    if( dot( s.b - s.a , p - s.a ) < EPS ) return norm( p - s.a );\n    if( dot( s.a - s.b , p - s.b ) < EPS ) return norm( p - s.b );\n    return abs(cross( s.b - s.a , p - s.a ) / norm( s.b - s.a ));\n}\n\nPoint midPoint(const Segment &s) {\n    return Point((s.a.x + s.b.x) / 2, (s.a.y + s.b.y) / 2);\n}\n\n\nbool solve() {\n    int n; cin >> n;\n    if(n == 0) return 0;\n    vector<Point> P(n); cin >> P;\n    int ans = 0;\n    rep(i, n) rep(j, i) if(distance(P[i], P[j]) <= 2.0){\n        Point a = P[i] - P[j];\n        double len = sqrt(1 - pow(distance(P[i], P[j]) / 2, 2));\n        Point c = len * orthonormal(a) + midPoint(Segment(P[i], P[j]));\n        int cnt = 0;\n        rep(l, n) {\n            cnt += distance2(P[l], c) <= 1.0 + EPS;\n        }\n        ans = max(ans, cnt);\n    }\n    cout << ans << endl;\n    return 1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\nint n;\nP pts[353];\n\nint check(P c){\n  int ret = 0;\n  REP(i,n){\n    if(abs(c-pts[i])<=1.00001)ret++;\n  }\n  return ret;\n}\n\nint main(){\n  while(true){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    REP(i,n){\n      double x,y;\n      scanf(\"%lf%lf\",&x,&y);\n      pts[i] = P(x,y);\n    }\n    int ans = 1;\n    REP(i,n)REP(j,i){\n      P a,b;\n      a = pts[i];\n      b = pts[j];\n      double l = abs(b-a);\n      if(l>2.0)continue;\n      double h = sqrt(1.0-l*l/4.0);\n      P c;\n      c = a + (b-a)/2.0 + (b-a)*P(0,1)*h/l;\n      ans = max(ans,check(c));\n      c = a + (b-a)/2.0 + (b-a)*P(0,-1)*h/l;\n      ans = max(ans,check(c));\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst double pi = 3.141592653589793238462643383279;\nusing namespace std;\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n \n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n\n//ここから編集\n\nusing Point = complex< long double >;\n\nnamespace std {\n  bool operator<(const Point a, const Point b) {\n    if(a.real() == b.real()) return a.imag() < b.imag();\n    return a.real() < b.real();\n  }\n}\n\nconst long double EPS = 1e-10, PI = acos(-1);\n\nbool eq(long double a, long double b){ return fabs(a-b) < EPS; }\n\nistream &operator>> (istream &is, Point &p) {\n  long double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<< (ostream &os, Point &p) {\n  return os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nbool operator<(const Point &a, const Point &b) {\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\nstruct Line{\n  Point a, b;\n\n  Line() = default;\n\n  Line(Point a, Point b) : a(a), b(b){}\n\n  Line(long double A, long double B, long double C){\n    //ax + by = c\n    if(eq(A, 0)){\n      a = Point(0, C/B), b = Point(1, C/B);\n    }else if(eq(B, 0)){\n      a = Point(C/A, 0), b = Point(C/A, 1);\n    }else{\n      a = Point(0, C/B), b = Point(C/A, 0);\n    }\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n  friend ostream &operator<<(ostream &os, Line &a) {\n    return os << a.a << \" to \" << a.b;\n  }\n};\n\nstruct Segment: Line {\n  Segment() = default;\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  long double r;\n\n  Circle() = default;\n\n  Circle(Point p, long double r): p(p), r(r){}\n};\n\nusing Points = vector<Point>;\nusing Polygon = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\n\nlong double cross(const Point &a, const Point &b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nlong double dot(const Point& a, const Point &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\n//https://mathtrain.jp/projection\nPoint projection(const Line &l, const Point &p){\n  long double t = dot(p - l.a, l.a-l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p){\n  long double t = dot(p - l.a, l.b-l.a) / norm(l.a - l.b);\n  return l.a + (l.b - l.a) * t;\n}\n\nPoint reflection(const Line &l, const Point &p){\n  return p + (projection(l, p) - p) * (long double)2.0;\n}\n\nint ccw(const Point &a, const Point &b, const Point &c) {\n  if(cross(b-a, c-a) > EPS) return 1;   // \"COUNTER_CLOCKWISE\"\n  if(cross(b-a, c-a) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b-a, c-a) < -EPS) return 2;    // \"ONLINE_BACK\" c-a-b\n  if(norm(b-a) < norm(c-a) - EPS) return -2;  // \"ONLINE_FRONT\" a-b-c\n  return 0;                         // \"ON_SEGMENT\" a-c-b\n}\n\nbool parallel(const Line &a, const Line &b){\n  return eq(cross(a.a-a.b, b.a-b.b), 0.0);\n}\nbool orthogonal(const Line &a, const Line &b){\n  return eq(dot(a.a-a.b, b.a-b.b), 0.0);\n}\n\nbool intersect(const Segment &s, const Point &p){\n  return ccw(s.a, s.b, p) == 0;\n}\n\n//直線の交差判定\nbool intersect(const Line &a, const Line &b) {\n  if(parallel(a, b)) return 0;\n  return 1;\n}\n\n//線分が重なる/端点で交わるときtrue\nbool intersect(const Segment &a, const Segment &b) {\n  return ccw(a.a, a.b, b.a) * ccw(a.a, a.b, b.b) <= 0 && ccw(b.a, b.b, a.a) * ccw(b.a, b.b, a.b) <= 0;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n  \n}\n\nPoint crosspoint(const Line &a, const Line &b){\n  long  double d = cross(b.b-b.a, a.b-a.a);\n  if(eq(d, 0.0)) return Point(1e9, 1e9); \n  \n  return a.a + (a.b - a.a) * cross(b.b-b.a, b.b-a.a) / d;\n}\n\nPoint crosspoint(const Segment &a, const Segment &b){\n  return crosspoint(Line(a.a, a.b), Line(b.a, b.b));\n}\n\n\n/* 2円の交点 */\nvector<Point> crosspointCC(Circle C1, Circle C2){\n  vector<Point> ps;\n  Point ab = C2.p - C1.p;\n  long double d = abs(ab);\n  long double rc = (C1.r * C1.r + d * d - C2.r * C2.r) / (2 * d);\n  if(eq(d, 0) || C1.r < abs(rc)) return ps;\n\n  long double rs = sqrt(C1.r * C1.r - rc*rc);\n\n  Point abN = ab * Point(0, rs/d);\n  Point cp = C1.p + rc /d * ab;\n  ps.push_back(cp + abN);\n  if(!eq(norm(abN), 0))ps.push_back(cp-abN);\n  return ps;\n}\n\nint N;\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(5);\n  vector<int> res;\n  while(cin >> N, N){\n    Circles cs;\n\n    vector<Point> pts(N);\n    set<Point> st;\n    for(int i=0; i<N; i++){\n      Circle c; \n      cin >> pts[i];\n      st.insert(pts[i]);\n\n      \n      c.p = pts[i];\n      c.r = 1.0;\n      cs.push_back(c);\n    }\n\n    \n    for(int i=0; i<N; i++){\n      \n      for(int j=0; j<N; j++){\n        auto v = crosspointCC(cs[i], cs[j]);\n\n        for(auto p: v){\n          st.insert(p);\n        }\n      }\n    }\n\n    int ans = 0;\n    for(auto p: st){\n      int cnt = 0;\n      for(int i=0; i<N; i++){\n        if(abs(p - pts[i]) - EPS <= 1.0) cnt++;\n      }\n      ans = max(ans, cnt);\n    }\n    res.push_back(ans);\n  }\n  for(auto e: res) cout << e << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\ntypedef long double ld;\n\nstruct Point {\n    ld x, y;\n    Point(ld x=0, ld y=0) : x(x), y(y) {}\n    string to_s() {\n        ostringstream os;\n        os << x << ',' << y;\n        return os.str();\n    }\n    Point operator+(const Point& o) const {\n        return Point(x+o.x, y+o.y);\n    }\n    Point operator/(const int d) const {\n        return Point(x/d, y/d);\n    }\n};\n\nstruct Circle {\n    ld x, y;\n    ld r;\n    Circle(ld x=0, ld y=0, ld r=1) : x(x), y(y), r(r) {}\n    const static ld eps = 1e-5;\n    bool isIntersect(const Circle& o) const {\n        ld dx = o.x - x;\n        ld dy = o.y - y;\n        return (r + o.r) * (r + o.r) > (dx*dx + dy*dy);\n    }\n    pair<Point, Point> intersectionPoint(const Circle& o) const {\n        ld dx = x - o.x;\n        ld dy = y - o.y;\n        ld a = (dx*dx + dy*dy + r*r - o.r*o.r) / 2.0;\n        ld d = sqrt((dx*dx+dy*dy)*r*r-a*a);\n        Point p, q;\n        p.x = (a*dx + dy * d) / (dx*dx+dy*dy) + o.x;\n        q.x = (a*dx - dy * d) / (dx*dx+dy*dy) + o.x;\n        p.y = (a*dy - dx * d) / (dx*dx+dy*dy) + o.y;\n        q.y = (a*dy + dx * d) / (dx*dx+dy*dy) + o.y;\n        //cout << p.x << ',' << p.y << endl;\n        //cout << q.x << ',' << q.y << endl;\n        return make_pair(p, q);\n    }\n    bool contains(ld px, ld py) const {\n        return r + eps >= sqrt((px - x) * (px - x) + (py - y) * (py - y));\n    }\n    string to_s() {\n        ostringstream os;\n        os << x << ',' << y << ':' << r << endl;\n        return os.str();\n    }\n};\n\nint countContainingPoints(const Circle& c, const vector<Circle>& ps) {\n    int cnt = 0;\n    for (int i = 0; i < ps.size(); i++) \n        if (c.contains(ps[i].x, ps[i].y)) \n            cnt++;\n    return cnt;\n}\n\nPoint midPoint(pair<Point, Point>& pp) {\n    return (pp.first + pp.second) / 2;\n}\n\nint N;\nint main() {\n    //cout << Circle(0, 0, 5).intersectionPoint(Circle(8, 0, 5)).first.to_s() << endl;\n    vector<Circle> cs;\n    while (cin >> N, N) {\n        cs.clear(); cs.resize(N);\n        for (int i = 0; i < N; i++) cin >> cs[i].x >> cs[i].y;\n\n        vector<Point> ips; // Intersection PointS\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (i == j) continue;\n                if (!cs[i].isIntersect(cs[j])) continue;\n                pair<Point, Point> ip = cs[i].intersectionPoint(cs[j]);\n                ips.push_back(ip.first);\n                ips.push_back(ip.second);\n                //ips.push_back(midPoint(ip));\n            }\n        }\n\n        int maxPoint = 0;\n        for (int i = 0; i < ips.size(); i++) {\n            maxPoint = max(maxPoint, countContainingPoints(Circle(ips[i].x, ips[i].y, 1), cs));\n        }\n        cout << maxPoint << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\nstruct makehtml{\n\tvector<string> ss;\n\t\n\tmakehtml(){}\n\t/*\n\tctx.beginPath()\n\tctx.moveTo(50.000000,100.000000);\n\tctx.lineTo(150.000000,100.000000);\n\tctx.stroke();\n\t\n\tctx.fillStyle = \"rgb(0,0,0)\";\n\t\n\tctx.beginPath();\n\tctx.arc(168,59,3,0,360);\n\tctx.fill();\n\n\t*/\n\t\n\tvoid out(const char* name,double mag){\n\t\tchar fname[100];\n\t\tsprintf(fname,\"%s.html\",name);\n\t\tFILE* fp = fopen(fname,\"w\");\n\t\tif(fp==NULL){\n\t\t\teprintf(\"can't open %s\\b\",fname);\n\t\t\texit(-1);\n\t\t}\n\t\tfprintf(fp,\"<html>\\n<head>\\n<title>\");\n\t\tfprintf(fp,\"%s\",name);\n\t\tfprintf(fp,\"</title>\\n</head>\\n<body>\\n\");\n\t\tfprintf(fp,\"<p>name: %s</p>\",name);\n\t\tfprintf(fp,\"<canvas id=\\\"vis\\\" width=\\\"%d\\\" height=\\\"%d\\\"></canvas>\",2000,2000);\n\t\tfprintf(fp,\"<script>\\n\");\n\t\tfprintf(fp,\"var vis = document.getElementById('vis');\\nvar ctx = vis.getContext('2d');\\n\");\n\t\t\n\t\trep(i,ss.size()){\n\t\t\tfprintf(fp,\"%s\\n\",ss[i].c_str());\n\t\t}\n\t\t\n\t\tfprintf(fp,\"</script>\\n\");\n\t\tfprintf(fp,\"</body>\\n</html>\\n\");\n\t\tfclose(fp);\n\t}\n\n} makehtml_instance;\n\n\nvoid addhtml(string s){\n\tmakehtml_instance.ss.push_back(s);\n}\n\nvoid outhtml(string s,double mag){\n\tmakehtml_instance.out(s.c_str(),mag);\n}\n\nvoid randcolhtml(){\n\tchar ns[100];\n\tsprintf(ns,\"ctx.fillStyle = \\\"rgb(%d,%d,%d)\\\";\",rand()%128,rand()%128,rand()%128);\n\taddhtml(ns);\n\tsprintf(ns,\"ctx.strokeStyle = \\\"rgb(%d,%d,%d)\\\";\",rand()%128,rand()%128,rand()%128);\n\taddhtml(ns);\n}\n\nvoid inithtml(){\n\tmakehtml_instance.ss.clear();\n}\n\n\nconst double pi=3.14159265358979;\n\nstruct pos{\n\tdouble x,y;\n\tdouble norm,norm2;\n\tpos tov(pos a){\n\t\treturn (a-(*this));\n\t}\n\tpos operator+(pos a)const{\n\t\tpos res=a;\n\t\tres.x+=x; res.y+=y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos operator-(pos a)const{\n\t\tpos res=(*this);\n\t\tres.x-=a.x; res.y-=a.y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos scalar(double a){\n\t\tpos res=(*this);\n\t\tres.x*=a; res.y*=a;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tdouble dot(pos a){\n\t\treturn x*a.x + y*a.y;\n\t}\n\tdouble cross(pos a){\n\t\treturn x*a.y - y*a.x;\n\t}\n\tdouble theta(pos a){\n\t\tdouble nt=dot(a)/(norm*a.norm);\n\t\tnt=acos(max(-1.0,min(1.0,nt)));\n\t\tdouble ns=(cross(a)/(norm*a.norm));\n\t\tif(ns<0)nt*=-1;\n\t\treturn nt;\n\t}\n\tpos(double ix,double iy){\n\t\tx=ix; y=iy;\n\t\tnorm2=x*x+y*y;\n\t\tnorm=sqrt(norm2);\n\t}\n\tpos(){}\n\tstring str(){\n\t\tchar ns[50];\n\t\tsprintf(ns,\"(%lf %lf)\",x,y);\n\t\treturn\tstring(ns);\n\t}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\"); \n\t\tsprintf(ns,\"ctx.arc(%lf,%lf,%lf,0,360);\",x*mag,y*mag,5.0); addhtml(ns);\n\t\taddhtml(\"ctx.fill();\");\n\t}\n\tstatic pos polar(double r,double t){\n\t\treturn pos(r*cos(t),r*sin(t));\n\t}\n\tpos turn(double t){\n\t\t//t[rad]??????\n\t\treturn pos(x*cos(t)-y*sin(t),x*sin(t)+y*cos(t));\n\t}\n\tpos tolen(double a){\n\t\t//?????????a?????????\n\t\treturn this->scalar(a/norm);\n\t}\n\tbool  operator<(pos a) const{\n\t\t//if(x!=a.x)return (x<a.x);\n\t\t//return (y<a.y);\n\t\tif(y!=a.y)return (y<a.y);\n\t\treturn (x<a.x);\n\t}\t\n\tbool operator>(pos a)const{ return (a<(*this)); }\t\n};\nstruct line{\n\tpos p,q;\n\tpos vec;\n\tstring str(){\n\t\treturn (\"(\"+p.str()+\"-\"+q.str()+\")\");\n\t}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\");\n\t\tsprintf(ns,\"ctx.moveTo(%lf,%lf);\",p.x*mag,p.y*mag); addhtml(ns);\n\t\tsprintf(ns,\"ctx.lineTo(%lf,%lf);\",q.x*mag,q.y*mag); addhtml(ns);\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\tbool iscross(line a){\n\t\tdouble da,db;\n\t\tda=vec.cross( p.tov(a.p) );\n\t\tdb=vec.cross( p.tov(a.q) );\n\t\tif(da*db>=0)return false;\n\t\tda=a.vec.cross( a.p.tov(p) );\n\t\tdb=a.vec.cross( a.p.tov(q) );\n\t\treturn (da*db<0);\n\t}\n\tline(pos ip,pos iq){\n\t\tp=ip; q=iq;\n\t\tvec=p.tov(q);\n\t}\n\tline(){}\n\tdouble dist(pos a){\n\t\tif(p.tov(a).dot( p.tov(q) )<0)return p.tov(a).norm;\n\t\tif(q.tov(a).dot( q.tov(p) )<0)return q.tov(a).norm;\n\t\treturn abs(vec.cross(p.tov(a))/vec.norm);\n\t}\n\tdouble dist(line a){\n\t\tif(iscross(a))return 0;\n\t\treturn min( min(dist(a.p),dist(a.q)) , min(a.dist(this->p),a.dist(this->q)));\n\t}\n\tpos crosspos(line a){\n\t\t/*\n\t\tdouble d1=a.vec.cross(a.p.tov(p))/a.vec.norm;\n\t\tdouble d2=a.vec.cross(a.p.tov(q))/a.vec.norm;\n\t\tbool isc=(d1*d2<0);\n\t\td1=abs(d1); d2=abs(d2);\n\t\tdouble sc;\n\t\tif(!isc){\n\t\t\tif(d1>d2)sc = d1/(d1-d2);\n\t\t\telse sc=d1/(d2-d1);\n\t\t}\n\t\telse sc = d1/(d1+d2);\n\t\treturn (p+vec.scalar(sc));*/\n\t\t\n\t\tdouble t = a.vec.cross(a.p-p)/a.vec.cross(vec);\n\t\treturn (p+vec.scalar(t));\n\t}\n\tline bisection(){//?????´????????????\n\t\t//???????¨??????????90????????£???????????????\n\t\tpos fr=(p+q).scalar(0.5);\n\t\tpos to=fr+pos(-vec.y,vec.x);\n\t\treturn line(fr,to);\n\t}\n};\ndouble lowofcos_getcos(double a,double b,double c){\n\treturn ((a*a+b*b-c*c)/(2*a*b));\n}\nstruct circle{\n\tpos p;\n\tdouble r;\n\tline koten(circle a){\n\t\tpos cv=p.tov(a.p);\n\t\tdouble br=atan2(cv.y,cv.x);\n\t\tdouble dr=acos(lowofcos_getcos( r, cv.norm, a.r));\n\t\tpos p1= p+pos::polar(r,br+dr);\n\t\tpos p2= p+pos::polar(r,br-dr);\n\t\tif(p1>p2)swap(p1,p2);\n\t\treturn line(p1,p2);\n\t}\n\tcircle(pos ip,double ir){\n\t\tp=ip; r=ir;\n\t}\n\tcircle(){}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\"); \n\t\tsprintf(ns,\"ctx.arc(%lf,%lf,%lf,0,360);\",p.x*mag,p.y*mag,r*mag); addhtml(ns);\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\t\n\tvector<line> tangs(circle a){ //??\\?????????\n\t\t//validate AOJ 2201\n\t\tcircle b(*this);\n\t\tif(a.r<b.r)swap(a,b);\n\t\tvector<line> res;\n\t\tif((a.p-b.p).norm-(a.r-b.r)<0.0)return res;\n\t\tif((a.p-b.p).norm-(a.r-b.r)<1e-6){\n\t\t\tif((b.p-a.p).norm<1e-6)return res; //??¨???????????????\n\t\t\tpos rv=(b.p-a.p).tolen(a.r);\n\t\t\tres.push_back(line(rv+a.p,rv+a.p+rv.turn(pi/2.0)));\n\t\t\treturn res;\n\t\t}\n\t\t{\n\t\t\tpos cv=b.p-a.p;\n\t\t\tdouble th=acos((a.r-b.r)/cv.norm);\n\t\t\tpos p1 = cv.turn(th);\n\t\t\tres.push_back(line(a.p+p1.tolen(a.r),b.p+p1.tolen(b.r)));\n\t\t\tpos p2 = cv.turn(-th);\n\t\t\tres.push_back(line(a.p+p2.tolen(a.r),b.p+p2.tolen(b.r)));\n\t\t}\n\t\tif((a.p-b.p).norm-(a.r+b.r)<0.0)return res;\n\t\tif((a.p-b.p).norm-(a.r+b.r)<1e-6){\n\t\t\tpos rv=(b.p-a.p).tolen(a.r);\n\t\t\tres.push_back(line(rv+a.p,rv+a.p+rv.turn(pi/2.0)));\n\t\t\treturn res;\n\t\t}\n\t\t{\n\t\t\tpos cv=b.p-a.p;\n\t\t\tdouble th=acos((a.r+b.r)/cv.norm);\n\t\t\tpos p1 = cv.turn(th);\n\t\t\tres.push_back(line(a.p+p1.tolen(a.r),b.p+p1.tolen(-b.r)));\n\t\t\tpos p2 = cv.turn(-th);\n\t\t\tres.push_back(line(a.p+p2.tolen(a.r),b.p+p2.tolen(-b.r)));\n\t\t}\n\t\treturn res;\n\t}\n};\n\nstruct polygon{\n\tvector<pos> ps;\n\tpolygon(){}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\");\n\t\tint ls=ps.size();\n\t\tsprintf(ns,\"ctx.moveTo(%lf,%lf);\",ps[ls-1].x*mag,ps[ls-1].y*mag); addhtml(ns);\n\t\trep(i,ps.size()){\n\t\t\tsprintf(ns,\"ctx.lineTo(%lf,%lf);\",ps[i].x*mag,ps[i].y*mag); addhtml(ns);\n\t\t}\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\tdouble area(){\n\t\tdouble res=0;\n\t\trep(i,ps.size()){\n\t\t\tpos no=ps[i],to=ps[(i+1)%ps.size()];\n\t\t\tres+=(no.x+to.x)*(no.y-to.y);\n\t\t}\n\t\tif(res<0)reverse(ps.begin(),ps.end());\n\t\treturn abs(res)/2;\n\t}\n\tpolygon(pos a,pos b){\n\t\tps.push_back(a);\n\t\tps.push_back(pos(a.x,b.y));\n\t\tps.push_back(b);\n\t\tps.push_back(pos(b.x,a.y));\n\t}\n\tline gete(int a){\n\t\ta%=ps.size();\n\t\treturn line(ps[a],ps[(a+1)%ps.size()]);\n\t}\n\tint isin(pos a){//?????´??????2,?????£????????????1,?????????0\n\t\tdouble as=0;\n\t\trep(i,ps.size()){\n\t\t\tline ne=gete(i);\n\t\t\tif(ne.dist(a)<=0)return 1;\n\t\t\tpos v1=a.tov(ne.p);\n\t\t\tpos v2=a.tov(ne.q);\n\t\t\tas+=v1.theta(v2);\n\t\t}\n\t\tif(abs(as)<1e-6)return 0;\n\t\treturn 2;\n\t}\n\tpolygon convex_full(){\n\t\tpolygon res;\n\t\tint ns=ps.size();\n\t\tvector<pos> vs(2*ns);\n\t\tsort(ps.begin(),ps.end());\n\t\tint k=0;\n\t\trep(i,ns){\n\t\t\tpos np=ps[i];\n\t\t\twhile(k>1 && vs[k-2].tov(vs[k-1]).cross(vs[k-1].tov(np))<-1e-6)k--;\n\t\t\tvs[k]=np; k++;\n\t\t}\n\t\tint t=k;\n\t\tireg(i,0,ns-2){\n\t\t\tpos np=ps[i];\n\t\t\twhile(k>t && vs[k-2].tov(vs[k-1]).cross(vs[k-1].tov(np))<-1e-6)k--;\n\t\t\tvs[k]=np; k++;\n\t\t}\n\t\tvs.resize(k-1);\n\t\tswap(vs,res.ps);\n\t\treturn res;\n\t}\n\tpolygon cut(line a){//???????????????????????????\n\t\tpolygon res;\n\t\trep(i,ps.size()){\n\t\t\tline ne=gete(i);\n\t\t\tdouble d1=a.vec.cross(a.p.tov(ne.p));\n\t\t\tdouble d2=a.vec.cross(a.p.tov(ne.q));\n\t\t\tif(d1<1e-6)res.ps.push_back(ne.p); //?????£????????£???eps\n\t\t\tif(d1*d2<-1e-6)res.ps.push_back(a.crosspos(ne)); //?????£????????????eps\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvector<polygon> voronoi(vector<pos> ps){\n\t\t//validate AOJ 2160\n\t\tvector<polygon> res;\n\t\trep(i,ps.size()){\n\t\t\tpolygon np(*this);\n\t\t\trep(j,ps.size()){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tline nl = line(ps[j],ps[i]).bisection();\n\t\t\t\t\n\t\t\t\tnp = np.cut(nl);\n\t\t\t}\n\t\t\tres.push_back(np);\n\t\t}\n\t\treturn res;\t\t\n\t}\n\tpolygon mult(polygon a){\n\t\treturn a;\n\t}\n};\n\nint n;\nint main(void){\n\tfor(;;){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tvector<pos> ps;\n\t\trep(i,n){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf%lf\",&x,&y);\n\t\t\tps.push_back(pos(x,y));\n\t\t}\n\t\t\n\t\t//inithtml();\n\t\tvector<pos> cs;\n\t\trep(i,n){\n\t\t\t//ps[i].outh(100);\n\t\t\trep(j,i){\n\t\t\t\tline nl(ps[i],ps[j]);\n\t\t\t\tdouble d = nl.vec.norm;\n\t\t\t\tif(d>2.0)continue;\n\t\t\t\tpos av = nl.bisection().vec.tolen(sqrt(1.0-(d/2)*(d/2)));\n\t\t\t\tpos m=(ps[i]+ps[j]).scalar(0.5);\n\t\t\t\tcs.push_back(m+av);\n\t\t\t\tcs.push_back(m-av);\n\t\t\t\t//printf(\"%lf %lf\\n\",(m+av-ps[i]).norm,(m-av-ps[i]).norm);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=1;\n\t\trep(i,cs.size()){\n\t\t\t//cs[i].outh(100);\n\t\t\t//circle c(cs[i],1.0);\n\t\t\t//c.outh(100);\n\t\t\t//printf(\"%s\\n\",cs[i].str().c_str());\n\t\t\tint ns=0;\n\t\t\trep(j,ps.size()){\n\t\t\t\tif((cs[i]-ps[j]).norm<=1.0)ns++;\n\t\t\t}\n\t\t\tans=max(ans,ns);\n\t\t}\n\t\t//outhtml(\"o\",100);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-8\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n  Point operator + (const Point &p)const{\n    return Point(x+p.x,y+p.y);\n  }\n  Point operator / (double a)const{\n    return Point(x/a,y/a);\n  }\n  double d(const Point &p){\n    return abs(sqrt(pow(x-p.x,2)+pow(y-p.y,2)));\n  }\n};\n\nint main(){\n  int N;\n  while(cin >> N,N){\n    Point p[N];\n    for(int i = 0 ; i < N ; i++){\n      cin >> p[i].x >> p[i].y;\n    }\n    int res = 1;\n    for(int i = 0 ; i < N ; i++){\n      for(int j = i+1 ; j < N ; j++){\n        if(p[i].d(p[j]) + EPS > 2.0){\n          continue;\n        }\n        Point cp = (p[i]+p[j])/2.0;\n        double y = cp.d(p[i]);\n        double x = sqrt(1-pow(y,2));\n        Point c[2] = {cp,cp};\n        c[0].x += x; c[1].x -= x;\n        for(int k = 0 ; k < 2 ; k++){\n          int cnt = 2;\n          for(int l = 0 ; l < N ; l++){\n            if(i == l || j == l) continue;\n            if(c[k].d(p[l]) + EPS < 1.0){\n              cnt++;\n            }\n          }\n          res = max(res,cnt);\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <cmath>\n\nusing namespace std;\n\ntypedef pair<double,double> pos;\nconst double r = 1;\nconst double eps = 0.0000000001;\nint count(vector<pos> ps,double x,double y,int ban1,int ban2){\n\tint c=0;//2;\n\tfor(int i=0;i<ps.size();i++){\n\t\tif(//i!=ban1&&i!=ban2&&\n\t\t\t\tpow(ps[i].first-x,2)+pow(ps[i].second-y,2)<=pow(1.0+eps,2)){\n\t\t\tc++;\n\t\t}\n\t}\n\treturn c;\n}\n\nbool range(pos p1,pos p2,double r){\n\treturn pow(p1.first-p2.first,2)+pow(p1.second-p2.second,2) <= r*r;\n}\n\ndouble len(pos p){\n\treturn sqrt(pow(p.first,2)+pow(p.second,2));\n}\n\ndouble len2(pos p){\n\treturn (pow(p.first,2)+pow(p.second,2));\n}\n\nvector<pos> point2(pos p1,pos p2){\n\tpos m = make_pair((p1.first+p2.first)/2,(p1.second+p2.second)/2);\n\tpos vec = make_pair(p1.first-p2.first,p1.second-p2.second);\n\tpos q = m;//make_pair(p2.first+vec.first/2,p2.second+vec.second/2);\n\tdouble l = sqrt(1-pow(len(vec)/2.0,2));\n\tdouble ll = len(vec);\n\tpos vec2 = make_pair(-vec.second,vec.first);\n\tvec2.first=vec2.first/ll*l;\n\tvec2.second = vec2.second/ll*l;\n\tvector<pos> ret;\n\tret.push_back(make_pair(q.first+vec2.first,q.second+vec2.second));\n\tret.push_back(make_pair(q.first-vec2.first,q.second-vec2.second));\n\treturn ret;\n}\n\nint solve(vector<pos> ps){\n\tint mx=1;\n\tfor(int i=0;i<ps.size()-1;i++)\n\t\tfor(int k=i+1;k<ps.size();k++){\n\t\t\tif(range(ps[i],ps[k],2)){\n\t\t\t\t//cerr << \"*****\" << i << \" \" << k << endl;\n\t\t\t\tvector<pos> vp = point2(ps[i],ps[k]);\n\t\t\t\tmx = max(mx,count(ps,vp[0].first,vp[0].second,i,k));\n\t\t\t\tmx = max(mx,count(ps,vp[1].first,vp[1].second,i,k));\n\t\t\t}\n\t\t}\n\treturn mx;\n}\n\nint main(){\n\t//cerr << point2(make_pair(0,0),make_pair(1,1))[1].first << endl;\n\twhile(true){\n\t\tint n;\n\t\tvector<pos> v;\n\t\tcin >> n;\n\t\tif(n==0)return 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tv.push_back(make_pair(x,y));\n\t\t}\n\t\tcout << solve(v) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-12, pi = acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\n// ????????\\???\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\n// ????????????????????????\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\n// ??????\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\n// ??????\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\n// ????????????\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n  if (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n  if (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n  if (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n  return 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// ??´?????¨???????????¢\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res; // no intersection\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\n// ??????????????????\n// -1 => out\n//  0 => on\n//  1 => in\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\n// ??????\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\n// ????????????\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, Point p) {\n  for (Point q : ps) if (abs(q - p) < eps) return;\n  ps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n  g[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n  int n = p.size(), m = s.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (isis_sp(s[i], p[j]))\n      vec.emplace_back(abs(s[i].a - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      add_edge(g, from, to, abs(p[from] - p[to]));\n    }\n  }\n  return g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n  int n = p.size(), m = c.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n      vec.emplace_back(arg(c[i].p - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      ld angle = vec[j+1].first - vec[j].first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n    if (vec.size() >= 2) {\n      int from = vec.back().second, to = vec.front().first;\n      ld angle = vec.front().first - vec.back().first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n  }\n  return g;\n}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n  int N = p.size();\n  polygon.clear();\n  REP(i,1024) REP(j,1024) seg2p[i][j].clear();\n  vector<vector<tuple<ld,int,bool>>> tup(N);\n  REP(i,s.size()) {\n    int a = -1, b = -1;\n    REP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n    REP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n    assert(a >= 0 && b >= 0);\n    tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n    tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n  }\n  REP(i,N) sort(ALL(tup[i]));\n  REP(i,N) {\n    REP(j,tup[i].size()) {\n      ld angle; int pos = j, from = i, to; bool flag;\n      tie(angle, to, flag) = tup[i][j];\n      if (flag) continue;\n      vector<int> ps;\n      while (!flag) {\n        ps.push_back(from);\n        get<2>(tup[from][pos]) = true;\n        seg2p[from][to].push_back(polygon.size());\n        seg2p[to][from].push_back(polygon.size());\n        angle += pi + eps;\n        if (angle > pi) angle -= 2 * pi;\n        auto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n        if (it == tup[to].end()) it = tup[to].begin();\n        from = to; tie(angle, to, flag) = *it;\n        pos = it - tup[from].begin();\n      }\n      polygon.push_back(ps);\n    }\n  }\n  Graph g(polygon.size());\n  REP(i,N) REP(j,i) {\n    if (seg2p[i][j].size() == 2) {\n      int from = seg2p[i][j][0], to = seg2p[i][j][1];\n      g[from].push_back((Edge){from, to});\n      g[to].push_back((Edge){to, from});\n    }\n  }\n  return g;\n}\n\n\n/* ????????\\??¢????????¶ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n  fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n  Point v = l.b - l.a;\n  Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n  int n = p.size();\n  REP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<Point> v;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tld x, y; cin >> x >> y;\n\t\t\tv.push_back( Point(x, y) );\n\t\t}\n\t\tvector<Point> kh;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i+1; j < N; ++j) {\n\t\t\t\tvector<Point> cp = is_cc(Circle(v[i], 1), Circle(v[j], 1));\n\t\t\t\tfor (int k = 0; k < cp.size(); ++k) {\n\t\t\t\t\tkh.push_back(cp[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1;\n\t\tfor (int i = 0; i < kh.size(); ++i) {\n\t\t\tint cnt = 0;\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif ( abs(kh[i]-v[j]) <= 1+eps ) {\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\ntypedef complex<double> pt;\ntypedef pair<pt,pt> L;\ntypedef vector<P> poly;\nconst double EPS = 1e-15;\n#define x real()\n#define y imag()\n \ndouble dot(pt a,pt b){\n\treturn (conj(a)*b).x;\n}\ndouble cross(pt a,pt b){\n\treturn (conj(a)*b).y;\n}\nint ccw(pt a,pt b,pt c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > EPS) return 1; // counter clockwise\n\tif(cross(b,c) < -EPS) return -1; // clockwise\n\tif(dot(b,c) < -EPS) return 2; //c-a-b\n\tif(norm(b) < norm(c)) return -2; //a-b-c\n\treturn 0; //a-c-b\n}\nbool cmp(const pt& a,const pt& b){\n\tif(-EPS < a.x-b.x && a.x-b.x < EPS) return a.y < b.y;\n\telse return a.x < b.x;\n}\nvector<pt>convex_hull(vector<pt>ps)\n{\n\tsort(ps.begin(),ps.end(),cmp);\n\tint k=0,n = ps.size();\n\tvector<pt>qs(n*2);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\twhile(k>1 && ccw(qs[k-2],qs[k-1],ps[i]) == -1) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tfor(int i=n-2,t=k;i>=0;i--)\n\t{\n\t\twhile(k>t && ccw(qs[k-2],qs[k-1],ps[i]) == -1) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\npt intersect(pt a,pt b,pt c,pt d){\n\tdouble dev = (b.y-a.y)*(d.x-c.x)-(b.x-a.x)*(d.y-c.y);\n\t\n\tdouble d1, d2;\n \n\td1 = (c.y*d.x-c.x*d.y);\n\td2 = (a.y*b.x-a.x*b.y);\n \n\tpt ap1;\n\tap1.x = d1*(b.x-a.x) - d2*(d.x-c.x);\n\tap1.x /= dev;\n\tap1.y = d1*(b.y-a.y) - d2*(d.y-c.y);\n\tap1.y /= dev;\n \n\treturn ap1;\n}\nbool par(pt a,pt b,pt c,pt d){\n\tb.x -= a.x; b.y -= a.y;\n\td.x -= c.x; d.y -= c.y;\n\tif(abs(b.y*d.x - b.x*d.y) < EPS){\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ndouble PI = 3.1415926535897932;\nint main(){\n\twhile(1){\n\t\tint n; scanf(\"%d\",&n); if(!n) return 0; if(n==1){ puts(\"1\"); continue;}\n\t\tpt p[305];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tdouble a,b; scanf(\"%lf%lf\",&a,&b);\n\t\t\tp[i] = pt(a,b);\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=i+1;j<=n;j++){\n\t\t\t\tpt q = (p[i]+p[j])/2.0;\n\t\t\t\tpt r = (p[i]-p[j]); if(abs(r) >= 2.0) continue;\n\t\t\t\tpt p1 = q + r / abs(r) * polar(sqrt(1.0-abs(r)*abs(r)/4.0),PI/2);\n\t\t\t\tpt p2 = q - r / abs(r) * polar(sqrt(1.0-abs(r)*abs(r)/4.0),PI/2);\n\t\t\t\tint c=0,d=0;\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tif(k==i || k==j || abs(p1-p[k]) <= 1.0+EPS) c++;\n\t\t\t\t\tif(k==i || k==j || abs(p2-p[k]) <= 1.0+EPS) d++;\n\t\t\t\t}\n\t\t\t\tans = max(ans,max(c,d));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\nstruct Point{double x,y;};\ndouble dist(Point a,Point b) {return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));}\n#define eps 0.0001\n\nint main(void){\n    int N;\n    while(cin>>N,N){\n        vector<Point> p(N);\n        int maxcnt=1;\n        rep(i,N)cin>>p[i].x>>p[i].y;\n        rep(i,N){\n            for(int j=i+1;j<N;j++){\n                double d = dist(p[i],p[j]);\n                if(d>2.0)continue;\n                int sign[]={-1,1};\n                rep(s,2){\n                    Point C;\n                    C.x = p[i].x + cos(atan2(p[j].y-p[i].y,p[j].x-p[i].x) + sign[s]*acos(d/2.0));\n                    C.y = p[i].y + sin(atan2(p[j].y-p[i].y,p[j].x-p[i].x) + sign[s]*acos(d/2.0));\n                    int cnt=0;\n                    rep(k,N) cnt += (pow(C.x-p[k].x,2) + pow(C.y-p[k].y,2) <= 1.0+eps);\n                    if(maxcnt<cnt)maxcnt=cnt;\n                }\n            }\n        }\n        cout<<maxcnt<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nstruct Point{\n    double x,y;\n};\n\nvoid func(int N){\n\n    Point point[N];\n    double x_min = 100,y_min = 100,x_max = -1,y_max = -1;\n\n    for(int i = 0; i < N; i++){\n        scanf(\"%lf %lf\",&point[i].x,&point[i].y);\n        x_min = min(point[i].x,x_min);\n        y_min = min(point[i].y,y_min);\n        x_max = max(point[i].x,x_max);\n        y_max = max(point[i].y,y_max);\n    }\n\n    if(x_min > 1)x_min -= 0.0475;\n    if(y_min > 1)y_min -= 0.0475;\n    if(x_max < 9)x_max += 0.0475;\n    if(y_max < 9)y_max += 0.0475;\n\n    int count,max_count = 0;\n\n    for(double y = y_min; y <= y_max; y += 0.01){\n        for(double x = x_min; x <= x_max; x += 0.01){\n            count = 0;\n            for(int i = 0; i < N; i++){\n                if(sqrt((x-point[i].x)*(x-point[i].x)+(y-point[i].y)*(y-point[i].y)) <= 1.0)count++;\n            }\n            max_count = max(max_count,count);\n        }\n    }\n\n    printf(\"%d\\n\",max_count);\n}\n\n\nint main(){\n\n    int N;\n\n    while(true){\n        scanf(\"%d\",&N);\n        if(N == 0)break;\n\n        func(N);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\n\nmain(){\n  int n;\n  while(cin>>n,n){\n    double x[n],y[n];\n\n    rep(i,n)cin>>x[i]>>y[i];\n\n    int ans=0;\n\n    rep(i,n){\n      rep(j,i){\n\tdouble sx,sy;\n\tdouble tx=x[i]-x[j],ty=y[i]-y[j];\n\tdouble len=sqrt(tx*tx+ty*ty);\n\tif(len>2)continue;\n\tlen=sqrt(1-len*len/4);\n\tdouble theta=atan2(ty,tx)+M_PI/2;\n\tint tans=0;\n\tsx=(x[i]+x[j])/2+cos(theta)*len;\n\tsy=(y[i]+y[j])/2+sin(theta)*len;\n\trep(k,n){\n\t  tx=sx-x[k];\n\t  ty=sy-y[k];\n\t  if(tx*tx+ty*ty<=1+EPS)++tans;\n\t}\n\tans=max(ans,tans);\n\ttans=0;\n\tsx=(x[i]+x[j])/2-cos(theta)*len;\n\tsy=(y[i]+y[j])/2-sin(theta)*len;\n\trep(k,n){\n\t  tx=sx-x[k];\n\t  ty=sy-y[k];\n\t  if(tx*tx+ty*ty<=1+EPS)++tans;\n\t}\n\tans=max(ans,tans);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n#include <complex>\ntypedef complex<double> Point;\nconst double EPS = 1e-8;\n\n// 入力ストリームから実数二つをとって Point へ\nistream& operator >> ( istream &s, Point &a )\n{\n\tdouble r, i;\n\ts >> r >> i;\n\ta = Point( r, i );\n\treturn s;\n}\n\n// 単位ベクトル\nPoint unitVector( const Point &a )\n{\n\treturn a / abs( a );\n}\n\n// 法線ベクトル\nPoint normalVector1( const Point &a )\n{\n\treturn a * Point( 0, 1 );\n}\nPoint normalVector2( const Point &a )\n{\n\treturn a * Point( 0, -1 );\n}\nPoint ( *normalVectors[] )( const Point& ) = { normalVector1, normalVector2 };\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int n; cin >> n, n; )\n\t{\n\t\tvector<Point> ps( n );\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tcin >> ps[i];\n\t\t}\n\n\t\tint res = 0;\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tREP( j, 0, i )\n\t\t\t{\n\t\t\t\tconst Point &a = ps[i], &b = ps[j];\n\t\t\t\tREP( k, 0, 2 )\n\t\t\t\t{\n\t\t\t\t\tconst Point c = ( a + b ) / Point( 2, 0 ) + unitVector( normalVectors[k]( a - b ) ) * sqrt( 1 - pow( abs( a - b ) / 2., 2. ) );\n\n\t\t\t\t\tint tmp = 2;\n\t\t\t\t\tREP( l, 0, n )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( l == i || l == j )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttmp += abs( c - ps[l] ) <= 1 + EPS;\n\t\t\t\t\t}\n\t\t\t\t\tres = max( res, tmp );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#define llint long long\n#define eps 1e-9\n#define inf 1e18\n#define PI 3.14159265358979323846264\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\treturn vec2d(add(x, ope.x), add(y, ope.y));\n\t}\n\tvec2d operator-(vec2d ope){\n\t\treturn vec2d(add(x, -ope.x), add(y, -ope.y));\n\t}\n\tvec2d operator*(double t){\n\t\treturn vec2d(x*t, y*t);\n\t}\n\tvec2d operator/(double t){\n\t\treturn vec2d(x/t, y/t);\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn add(x*ope.y, -y*ope.x);\n\t}\n\tdouble norm(){\n\t\tdouble d2 = dot(*this);\n\t\tif(d2 > 0) return sqrt(d2);\n\t\treturn 0.0;\n\t}\n};\n\ndouble distPP(vec2d p, vec2d q){\n\treturn (p-q).norm();\n}\n\nllint n;\nvec2d p[305];\n\nllint check(vec2d c)\n{\n\t//cout << c.x << \" \" << c.y << endl;\n\t\n\tllint ret = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tif(distPP(c, p[i]) <= 1+eps) ret++;\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tfor(int i = 1; i <= n; i++) cin >> p[i].x >> p[i].y;\n\t\t\n\t\tllint ans = 1;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\tif(distPP(p[i], p[j]) > 2) continue;\n\t\t\t\tvec2d v = p[i]-p[j];\n\t\t\t\tdouble d = v.norm(), x = sqrt(1 - d*d/4);\n\t\t\t\t\n\t\t\t\tvec2d n = vec2d(v.y, -v.x);\n\t\t\t\tn = n / n.norm() * x;\n\t\t\t\t\n\t\t\t\tans = max(ans, check(p[j]+v/2+n));\n\t\t\t\tans = max(ans, check(p[j]+v/2-n));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\ntypedef complex<double> P;\n\nint n;\ndouble x[300], y[300];\n\nint main() {\n    while (cin >> n && n) {\n        for (int i=0; i<n; ++i) {\n            cin >> x[i] >> y[i];\n        }\n        int ret = 1;\n        for (int i=0; i<n; ++i) {\n            for (int j=0; j<n; ++j) {\n                if (i == j) continue;\n                P a = P(x[i], y[i]);\n                P b = P(x[j], y[j]);\n                P m = (a + b) / 2.0;\n                double h = sqrt(1.0 - norm(a - m));\n                P u = (a - b) / abs(a - b);\n                u = P(-u.imag(), u.real());\n                P c = (a + b) / 2.0 + u * h;\n                int cnt = 0;\n                for (int k=0; k<n; ++k) {\n                    P t(x[k], y[k]);\n                    if (norm(c - t) < 1.0 + 1e-8) {\n                        cnt ++;\n                    }\n                }\n                ret = max(ret, cnt);\n            }\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <complex>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\n#define equals(a, b) (fabs((a)-(b))<EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> Point;\n\nstruct Circle {\n    Point c;\n    double r;\n    Circle(Point c=Point(), double r=0.0) :\n        c(c),r(r){}\n};\n\nbool include(Circle c,Point p) {\n    return norm(c.c-p) <= c.r*c.r;\n}\n\nint n;\ndouble xs[301],ys[301];\n\n\nint f(double x,double y) {\n    int ret=0;\n    Circle c=Circle(Point{x,y},1);\n    rep(i,n) {\n        if(include(c,Point{xs[i],ys[i]})) ret++;\n    }\n\n    return ret;\n}\n\nvoid solve() {\n    rep(i,n) cin>>xs[i]>>ys[i];\n    int ans=0;\n    double x=0,y=0;\n    for(x=0;x<=10;x+=0.01) for(y=0;y<=10;y+=0.01) {\n        ans=max(ans,f(x,y));\n    }\n\n    cout<<ans<<endl;\n}\n\nint main() {\n    while(cin>>n) {\n        if(!n) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<math>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\ntypedef complex<double> Point;\n\nconst double EPS = 0.000001;\n\nint main(){\n\t\n\tA:;\n\t\n\tint n;\n\tcin>>n;\n\t\n\tif(n==0)return 0;\n\t\n\tvector<Point> point;\n\trep(i,n){\n\t\tdouble a,b;\n\t\tcin>>a>>b;\n\t\tpoint.push_back(Point(a,b));\n\t}\n\t\n\tint ans = 1;\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(i==j)continue;\n\t\t\t\n\t\t\tPoint p1 = point[j];\n\t\t\tPoint p0 = point[i];\n\t\t\t\n\t\t\tPoint diff = p1-p0;\n\t\t\tPoint d2 = diff/Point(2,0);\n\t\t\t\n\t\t\tdouble dlen = abs(d2);\n\t\t\tif(dlen>1.0)continue;\n\t\t\t\n\t\t\tdouble clen = sqrt(1-dlen*dlen);\n\t\t\tPoint e = d2*Point(0,1);\n\t\t\te = e/Point(abs(e),0)*Point(clen,0);\n\t\t\t\n\t\t\tPoint t = p0 + d2 + e;\n\t\t\t\n\t\t\tint count = 0;\n\t\t\trep(k,n){\n\t\t\t\tif(abs(t-point[k])<=1.0+EPS)count++;\n\t\t\t}\n\t\t\tans = max(ans,count);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n\t\n\tgoto A;\n}\n/*\n3\n6.47634 7.69628\n5.16828 4.79915\n6.69533 6.20378\n\n2\n0 0\n0.8 0\n\n2\n0 0\n0.5 0.5\n\n2\n0 0\n0 2\n\n6\n7.15296 4.08328\n6.50827 2.69466\n5.91219 3.86661\n5.29853 4.16097\n6.10838 3.46039\n6.34060 2.41599\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(N); i++)\n\nusing namespace std;\nnamespace geom{\n#define at(i) ((*this)[i])\n#define pb push_back\n#define X real()\n#define Y imag()\n#define SELF (*this)\ntypedef long double R;\ntypedef complex<R> P;\nconst R EPS = 1e-8;\nconst R PI=3.14159265358979323846264338327950288;\nenum { TURE = 1, FALSE = 0, BORDER= -1};\ninline int sig(const R&x){return (abs(x)<EPS?0:x>0?1:-1);}\ninline int less(const R &x,const R &y){return sig(x-y)?x<y:BORDER;}\ninline R inp(const P &a,const P &b){return (conj(a)*b).X;}\ninline R outp(const P &a,const P & b){return (conj(a)*b).Y;}\ninline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\ninline P unit(const P & p){return p/abs(p);}\ninline P proj(const P &s,const P &t){return t*inp(s,t)/norm(t);}\nstruct L :public vector<P>{\n  L(const P &p1,const P &p2){this->pb(p1);this->pb(p2);}\n  L(){}\n  P dir()const {return at(1)-at(0);}\n  int online(const P &p) const {return !sig(outp(p-at(0),dir()));}\n};\nstruct S: public L {\n    S(const P &p1, const P &p2): L(p1,p2){}\n    S(){}\n    int online(const P &p) const{\n        if(!sig(norm( p-at(0) )) || !sig(norm(p - at(1))) ) return BORDER;\n        return !sig(outp(p-at(0), dir())) && inp(p-at(0), dir()) > EPS && inp(p-at(1),-dir()) > -EPS;\n    }\n};\nstruct C :public P{\n  C(){}\n  C(const P &p,const R r):P(p),r(r){}\n  R r;\n  int inside(const P &p)const { return less(norm(p-SELF),r*r);}\n};\n//inline P proj(const P &s,const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\ninline int intersect (const C &a,const C &b){\n  return less((a.r-b.r)*(a.r-b.r),norm(a-b))+less(norm(a-b),(a.r+b.r)*(a.r+b.r))-1;\n}\n\ninline S crosspoint(const C &c1,const C &c2){\n  if(!intersect(c1,c2)) return S();\n  R d=abs(c1-c2);\n  R x=(c1.r*c1.r-c2.r*c2.r+d*d)/(2*d);\n  R h=sqrt(max<R>(0.,c1.r*c1.r-x*x));\n  P u=unit(c2-c1);\n  return S(c1+u*x+u*P(0,-1)*h,c1+u*x+u*P(0,1)*h);\n}\n\n// inline S crosspoint(const C &c,const L &l){\n//   R d2=dist2(l,c);\n//   if(c.r*c.r+EPS < d2) return S();\n//   P m= proj(c,l);\n//   P u = unit(l[1]-l[0]);\n//   R d=sqrt(max<R>(.0,c.r*c.r-d2));\n//   return S(m+u*d,m-u*d);\n// }\n\nS circlePPR(const P& a, const P& b, R r){\n    return crosspoint( C(a,r), C(b,r) );\n}\n}\nusing namespace geom;\n\nint main(){\n    int N;\n    while(cin>>N, N){\n        int ans = 1;\n        P po[305];\n        rep(i,N){\n            R x, y;\n            cin >> x >> y;\n            po[i] = P(x, y);\n        }\n        rep(i,N) rep(j,i){\n            //if( i==j ) continue;\n            S s = circlePPR( po[i], po[j], 1.0 );\n            //if( s.empty() ) continue;\n            //for(auto t: s) cout << t << \" \"; cout << endl;\n            for(auto k: s){\n                int count = 0;\n                rep(h,N){\n                    if( abs(k-po[h]) < 1.0 + EPS ){\n                        count++;\n                    }\n                }\n                ans = max(ans, count);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <bitset>\n#include <iostream>\n#include <iomanip>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <deque>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e16;\n\n/*\n<url:>\n問題文============================================================\n\n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\ntypedef complex<double> Point;\nconst double eps = 1e-9;\nPoint P[305];\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    int N;\n    while(true){\n        scanf(\"%d\",&N);\n        if(N == 0) break;\n        for(int i = 0; i < N;i++){\n            double x,y; scanf(\"%lf%lf\",&x,&y);\n            P[i] = Point(x,y);\n        }\n        if(N == 1){\n            printf(\"1\\n\");\n            continue;\n        }\n        int ans = 1;\n        for(int i = 0; i < N;i++){\n            for(int j = i + 1; j < N;j++){\n                double dist = abs(P[i] - P[j]);\n                if(dist > 2) continue;\n                double r = sqrt(1 - dist*dist/4);\n                double dx = -(P[i] - P[j]).imag()*r/dist;\n                double dy = (P[i] - P[j]).real()*r/dist;\n                Point np(dx,dy);\n                Point cp(np + (P[i] + P[j])/2.0);\n                \n                int cnt = 0;\n                for(int k = 0; k < N;k++){\n                    if(abs(cp - P[k]) < 1.0 + eps) cnt++;\n                }\n                ans = max(ans,cnt);\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\ntypedef pair<double, double> PD;\n\nconst double EPS = 1e-11;\ndouble sq(double x) { return x * x; }\n\nvector<PD> solve(double ax, double ay, double bx, double by) {\n  double sqdist = sq(ax - bx) + sq(ay - by);\n  double dist = sqrt(sqdist);\n  double ndist = sqrt(1 - sqdist / 4);\n  double ex = (bx - ax) / dist, ey = (by - ay) / dist;\n  vector<PD> ans(2);\n  REP(i, 0, 2) {\n    double coef = i == 0 ? 1 : -1;\n    ans[i].first = (ax + bx) / 2 + ey * coef * ndist;\n    ans[i].second = (ay + by) / 2 - ex * coef * ndist;\n  }\n  return ans;\n}\n\nint main(void) {\n  int n;\n  while(scanf(\"%d\", &n) && n) {\n    vector<double> x(n), y(n);\n    REP(i, 0, n) scanf(\"%lf%lf\", &x[i], &y[i]);\n    vector<PD> cand;\n    REP(i, 0, n) {\n      REP(j, 0, i) {\n\tfor (PD e: solve(x[i], y[i], x[j], y[j])) {\n\t  cand.push_back(e);\n\t}\n      }\n    }\n    int ma = 0;\n    for (PD c: cand) {\n      int cnt = 0;\n      REP(i, 0, n) {\n\tdouble sqdist = sq(x[i] - c.first) + sq(y[i] - c.second);\n\tif (sqdist <= 1 + EPS) {\n\t  cnt += 1;\n\t}\n      }\n      ma = max(ma, cnt);\n    }\n    printf(\"%d\\n\", ma);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\nR radNorP(R x) {\n    return fmod(fmod(x, 2*PI)+2*PI, 2*PI);\n}\n\nconst int MN = 330;\n\nP p[MN];\ntypedef pair<R, int> Pi;\n\nbool solve() {\n    int n;\n    cin >> n;\n    if (!n) return false;\n\n    for (int i = 0; i < n; i++) {\n        R x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n    }\n\n    int res = 1;\n    for (int i = 0; i < n; i++) {\n        vector<Pi> v;\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            if (2.0 < abs(p[j]-p[i])) continue;\n            R th = acos(abs(p[j]-p[i])/2.0);\n            R l = radNorP(arg(p[j]-p[i])-th);\n            R r = radNorP(arg(p[j]-p[i])+th);\n            if (r < l) {\n                v.push_back(Pi(l, 1));\n                v.push_back(Pi(2*PI, -1));\n                v.push_back(Pi(0, 1));\n                v.push_back(Pi(r, -1));\n            } else {\n                v.push_back(Pi(l, 1));\n                v.push_back(Pi(r, -1));\n            }\n\n        }\n\n        sort(v.begin(), v.end());\n        int sm = 1;\n        for (Pi p: v) {            \n            sm += p.second;\n            res = max(res, sm);\n        }\n    }\n    cout << res << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define mp            make_pair\n#define pb            push_back\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nconst int    INF = 1000000000;\nconst ll     MOD = 1000000007LL;\nconst double EPS = 1E-12;\n\ntemplate<typename T> T add(T x, T y){ if(abs(x+y) < EPS*(abs(x)+abs(y))) return 0; return x + y; }\ntemplate<typename T> inline bool semieq(T x, T y){ return abs(x - y) < EPS; }\ntemplate<typename T> inline bool semige(T x, T y){ return y - x < -EPS; }\ntemplate<typename T> inline bool semile(T x, T y){ return x - y < -EPS; }\n\n\nstruct Point : public complex<double>\n{\npublic:\n  Point() { this->real(0);  this->imag(0); }\n  Point(const double& x, const double& y) { this->real(x);  this->imag(y); }\n  Point(const complex<double> w)  { this->real(w.real());  this->imag(w.imag()); }\n  inline double dot(Point p){ return (conj(*this) * p).real(); }  // 内積\n  inline double det(Point p){ return (conj(*this) * p).imag(); }  // 外積\n};\n\nnamespace std\n{\n  inline bool operator < (const Point& a, const Point& b)\n  {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ntypedef vector<Point> Polygon;\ninline Point currPoint(vector<Point> P, int i){ return P[i]; }\ninline Point nextPoint(vector<Point> P, int i){ return P[(i+1)%P.size()]; }\ninline Point diffPoint(vector<Point> P, int i){ return nextPoint(P, i) - currPoint(P, i); }\n\n\nstruct Circle : Point\n{\nprivate:\n  Point p;\n  double r;\n\npublic:\n  Circle(Point p, double r) : p(p), r(r) {}\n  Circle(double x, double y, double r) : p(Point(x, y)), r(r) {}\n  inline Point center(){ return this->p; }\n  inline double radius(){ return this->r; }\n};\n\nint intersectionDeterminationOfCC(Circle A, Circle B)\n{\n  double d = abs(A.center() - B.center());\n  if(semile(d, A.radius() - B.radius())) return  1;  // B in A\n  if(semile(d, B.radius() - A.radius())) return -1;  // A in B\n  if(semieq(d, A.radius() - B.radius())) return  2;  // B in A（内接）\n  if(semieq(d, B.radius() - A.radius())) return -2;  // A in B（内接）\n  if(semige(d, A.radius() + B.radius())) return  3;  // 交わらない\n  if(semieq(d, A.radius() + B.radius())) return -3;  // 外接\n  return 4;  // 交わっている\n}\n\n\n// 交点を重複を許して丁度二つ返す。０個のときは事前に計算しておく。\nvector<Point> intersectionOfCC(Circle A, Circle B)\n{\n  vector<Point> ret;\n  Point p = B.center() + A.center();\n  Point d = B.center() - A.center();\n  double m = (B.radius() + A.radius()) / abs(B.center() - A.center());\n  double n = (B.radius() - A.radius()) / abs(B.center() - A.center());\n\n  double s = m * n;\n  double t = sqrt((m * m - 1.0) * (1.0 - n * n));\n\n  ret.pb((p + Point(s, -t) * d) / 2.0);\n  ret.pb((p + Point(s,  t) * d) / 2.0);\n\n  return ret;\n}\n\nconst double r = 1.0;\nint N;\ndouble x, y;\n\nint main()\n{\n  while((cin >> N) && N){\n    vector<Point> P;\n\n    rep(i, N){\n      cin >> x >> y;\n      P.pb(Point(x, y));\n    }\n\n    int res = 0;\n    rep(i, N) rep(j, i) if(!semige(abs(P[i] - P[j]), 2.0 * r)){\n      Circle A = Circle(P[i], r);\n      Circle B = Circle(P[j], r);\n      vector<Point> PP = intersectionOfCC(A, B);\n\n      vrep(v, PP){\n        int cnt = 0;\n        vrep(w, P) if(!semige(abs(*w - *v), r)) cnt += 1;\n        maxup(res, cnt);\n      }\n    }\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)n; i++)\n#define vec vector\n#define pdd pair<double, double>\n#define mp make_pair\n\ndouble dis(pdd a, pdd b)\n{\n\tpdd x = mp(a.first - b.first, a.second - b.second);\n\treturn sqrt(x.first * x.first + x.second * x.second);\n}\n\npdd find(pdd a, pdd b)\n{\n\tpdd v = mp(a.first - b.first, a.second - b.second);\n\tdouble d = sqrt(v.first * v.first + v.second * v.second);\n\t// double d = dis(a, b);\n\tif (d > 2.0) return mp(1000, 1000);\n\t// pdd o = mp(a.first + 0.5 * v.first, a.second + 0.5 * v.second);\n\tpdd o = mp((a.first + b.first) / 2.0, (a.second + b.second) / 2.0);\n\tpdd g = mp(v.second, - v.first);\n\tdouble s = sqrt(1.0 - d * d / 4.0);\n\t// double g_size = sqrt(g.first * g.first + g.second * g.second);\n\tdouble g_size = d;\n\tpdd ret = mp(o.first + g.first / g_size * s, o.second + g.second / g_size * s);\n\treturn ret;\n}\n\nint main(void)\n{\n\twhile(1) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tvec<pdd> a(n);\n\t\trep(i, n) cin >> a[i].first >> a[i].second;\n\t\t// if (n == 1) {\n\t\t// \tcout << 1 << endl;\n\t\t// \tcontinue;\n\t\t// }\n\n\t\tint MAX = 0;\n\t\trep(i, n) rep(j, n) {\n\t\t\tif (i == j) continue;\n\t\t\tpdd c = find(a[i], a[j]);\n\t\t\t// cout << i << \" \" << j << \" \" << c.first << \" \" << c.second << endl;\n\n\t\t\tint p = 0;\n\t\t\tif (c.first == 1000) p = 1;\n\t\t\telse {\n\t\t\t\t\trep(k, n) {\n\t\t\t\t\t// cout << dis(a[k], c) << \" \";\n\t\t\t\t\tif (dis(a[k], c) <= 1.0001) p++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// cout << p << endl;\n\t\t\tMAX = max(p, MAX);\n\t\t}\n\n\t\tcout << MAX << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\n\ntypedef pair<double, double> point;\nconst double EPS = 1e-6;\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tpoint p[333];\n\t\trep (i, n)\n\t\t\tscanf(\"%lf%lf\", &p[i].first, &p[i].second);\n\t\tsort(p, p + n);\n\n\t\tqueue<point> q;\n\t\trep (i, n)\n\t\t\tq.push(p[i]);\n\n\t\tlist<point> r;\n\t\tint res = 0;\n\t\tfor (int i = -10000; i <= 100000; ++i)\n\t\t{\n\t\t\tdouble cx = i * 1e-4;\n\t\t\twhile (!r.empty() && r.front().first < cx - 1 + EPS)\n\t\t\t\tr.pop_front();\n\t\t\twhile (!q.empty() && q.front().first < cx + 1 + EPS)\n\t\t\t\tr.push_back(q.front()), q.pop();\n\n\t\t\tvector<double> cy;\n\t\t\tforeach (it, r)\n\t\t\t{\n\t\t\t\tdouble x = it->first, y = it->second;\n\t\t\t\tdouble d = sqrt(1 - (x - cx) * (x - cx));\n\t\t\t\tcy.push_back(y - d);\n\t\t\t\tcy.push_back(y + d);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < cy.size(); ++i)\n\t\t\t{\n\t\t\t\tint c = 0;\n\t\t\t\tforeach (it, r)\n\t\t\t\t{\n\t\t\t\t\tdouble dx = cx - it->first;\n\t\t\t\t\tdouble dy = cy[i] - it->second;\n\t\t\t\t\tif (dx * dx + dy * dy < 1 + EPS)\n\t\t\t\t\t\t++c;\n\t\t\t\t}\n\t\t\t\tmax_swap(res, c);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <cmath>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\n// ----- debug macro -----\n#define DMPPT(p,stream) stream << (p).X << \",\" << (p).Y\n// ----- ----- ----- -----\n\n// ????????????????§???????????????????????????\\??????????????????????????¨???????????????\ntypedef complex<double> PT;\ntypedef complex<double> VC;\n\n// ??´??? or ???????????????????????????????????????\nVC get_vc_normal(VC a) {\n\ta = a * PT(0,-1);\n\treturn a / abs(a);\n}\n\nint N;\nconst double EPS = 1e-9;\n\n// rest code\nint main() {\n\twhile(cin >> N, N) {\n\t\tvector<PT> p;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp.push_back(PT(x,y));\n\t\t}\n\n\t\tint res = 1;\n\t\tfor(int i = 0; i < p.size(); i++) {\n\t\t\tfor(int j = 0; j < p.size(); j++) {\n\t\t\t\tif(i == j) continue;\n\t\t\t\tVC a, b;\n\t\t\t\tPT c[2];\n\t\t\t\tdouble len;\n\t\t\t\ta = (p[j] - p[i]) / 2.0;\n\t\t\t\tif(abs(a) > 1.0) continue;\n\t\t\t\tb = get_vc_normal(a);\n\t\t\t\tlen = sqrt(1.0 - norm(a));\n\t\t\t\tc[0] = p[i] + a + len*b;\n\t\t\t\tc[1] = p[i] + a - len*b;\n\n\t\t\t\tfor(int k = 0; k < 2; k++) {\n\t\t\t\t\tint tmp = 0;\n\t\t\t\t\tfor(int l = 0; l < p.size(); l++) {\n\t\t\t\t\t\tif(abs(c[k] - p[l]) < 1.0 + EPS) tmp++;\n\t\t\t\t\t}\n\t\t\t\t\tres = max(res, tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nstruct point{\n    double x;\n    double y;\n};\n\nint n;\npoint points[300];\n\ndouble getDist2(point a, point b){\n    return pow(a.x - b.x ,2) + pow(a.y - b.y, 2);\n}\n\ndouble getDist(point a, point b){\n    return sqrt(getDist2(a, b));\n}\n\nint findMaxCover(){\n    int ans = 1;\n    int count;\n    int sign[2] = {-1, 1};\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            point a, b;\n            a = points[i];\n            b = points[j];\n            if (getDist2(a, b) > 4.0) {\n                continue;\n            }\n            point m;\n            m.x = (a.x + b.x) / 2.0;\n            m.y = (a.y + b.y) / 2.0;\n            double v, u, d, e;\n            d = getDist(a, b);\n            v = (a.y - b.y) / d;\n            u = (a.x - b.x) / d;\n            d = getDist(a, b);\n            e = sqrt(1 - d * d / 4);\n            for (int k = 0; k < 2; k++) {\n                count = 0;\n                double p = m.x - e * v * sign[k];\n                double q = m.y + e * u * sign[k];\n                for (int l = 0; l < n; l++) {\n                    point t;\n                    t.x = p;\n                    t.y = q;\n                    if (l == i || l == j) {\n                        count++;\n                        continue;\n                    }\n                    if (getDist2(t, points[l]) <= 1.0) {\n                        count++;\n                    }\n                }\n                ans = max(ans, count);\n            }\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    while (true) {\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        for (int i = 0; i < n; i++) {\n            cin >> points[i].x >> points[i].y;\n        }\n        cout << findMaxCover() << endl;\n        \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1132&lang=jp\n#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n\nusing ll = long long;\n\nconst double EPS = 1e-6;\nconst double INF = 1e12;\n  typedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\n  namespace std {\n    bool operator < (const P& a, const P& b) {//x????????????\n      return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n  }\n  double cross(const P& a, const P& b) {//??????\n    return imag(conj(a)*b);\n  }\n  double dot(const P& a, const P& b) {//??????\n    return real(conj(a)*b);\n  }\n\n  struct L : public vector<P> {//??´???\n    L(){};\n    L(const P &a, const P &b) {\n      push_back(a); push_back(b);\n    }\n  };\n\n  typedef vector<P> G;\n\n  struct C {//???\n    P p; double r;\n    C(){};\n    C(const P &p, double r) : p(p), r(r) { }\n  };\n  int ccw(P a, P b, P c) {//3????????????????????§????????§??????????????????\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n  }\n  // L:line,S:segment,P:point\n  bool intersectLL(const L &l, const L &m) {\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n      abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n  }\n  bool intersectLS(const L &l, const L &s) {\n    return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n      cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n  }\n  bool intersectLP(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n  }\n  bool intersectSS(const L &s, const L &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n      ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n  }\n  bool intersectSP(const L &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n  }\n  // L & P intersection\n  P projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n  }\n  // L????????????P???????°????\n  P reflection(const L &l, const P &p) {\n    return p + 2.0 * (projection(l, p) - p);\n  }\n  double distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n  }\n  double distanceLL(const L &l, const L &m) {\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n  }\n  double distanceLS(const L &l, const L &s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n  }\n  double distanceSP(const L &s, const P &p) {\n    const P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n  }\n  double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n        min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n  }\n  double distancePP(const P &p,const P &q){\n    return dot((p - q), (p - q));\n  }\n  P crosspoint(const L &l, const L &m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n    return m[0] + B / A * (m[1] - m[0]);\n  }\n  P verticalvector(const P &a,const P &b){//2???????????????????????????????????????\n    if(a.real() == b.real()){\n      return {1.0,0};\n    }\n    if(a.imag() == b.imag()){\n      return {0,1.00};\n    }\n    P p = a - b;\n    P res = {-p.imag(),p.real()};\n    return res / abs(p);\n  }\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  double x,y;\n  while(cin >> n && n){\n    vector<P> ps(n);\n    rep(i,n){\n      cin >> x >> y;\n      ps[i] = {x,y};\n    }\n    ll ans = 1;\n    rep(i,n){\n      REP(j,i+1,n){\n        if (norm(ps[i] - ps[j]) > 4.0 + EPS) continue;\n        P m = (ps[i]+ps[j])/2.0;\n        P vv = verticalvector(ps[i],ps[j]);\n        double x = sqrt(1 - norm((ps[i] - ps[j]) / 2.0));\n        P c1 = vv * x + m,c2 = vv * (-x) + m;\n        ll cnt1 = 2,cnt2 = 2;\n        rep(k,n){\n          if(i == k || j == k) continue;\n          if(norm(ps[k] - c1) <= 1.0 + EPS){\n            cnt1++;\n          }\n          if(norm(ps[k] - c2) <= 1.0 + EPS){\n            cnt2++;\n          }\n        }\n        ans = max(ans,max(cnt1,cnt2));\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n\nusing namespace std;\n\n#define EPS (1e-6)\n\ndouble x[300], y[300];\n\nint sign[] = {+1, -1};\n\nint main(void) {\n  int n;\n  while (cin >> n, n) {\n    for (int i=0; i<n; i++) {\n      cin >> x[i] >> y[i];\n    }\n\n    int ans = 1;\n    for (int i=0; i<n; i++) {\n      for (int j=i+1; j<n; j++) {\n        double d = hypot(x[i]-x[j], y[i]-y[j]);\n        if ( d > 2.0 + EPS ) { continue; }\n\n        double mx = (x[i] + x[j]) / 2;\n        double my = (y[i] + y[j]) / 2;\n        double vx = (x[j] - x[i]) / d;\n        double vy = (y[j] - y[i]) / d;\n        double e = sqrt(1.0 - d*d/4.0);\n\n        for (int s=0; s<2; s++) {\n          double px = mx + sign[s]*e*vy;\n          double py = my - sign[s]*e*vx;\n\n          int cnt = 2;\n          for (int k=0; k<n; k++) {\n            if (k==i || k==j) { continue; }\n            if ( (px-x[k])*(px-x[k]) + (py-y[k])*(py-y[k]) < 1.0 + EPS ) { cnt++; }\n          }\n          if (cnt > ans) { ans = cnt; }\n        }\n      }\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\ntypedef double ld;\n\nstruct Point {\n    ld x, y;\n    Point(ld x, ld y) : x(x), y(y) {}\n    string to_s() {\n        ostringstream os;\n        os << x << ',' << y;\n        return os.str();\n    }\n    Point operator+(const Point& o) const {\n        return Point(x+o.x, y+o.y);\n    }\n    Point operator/(const int d) const {\n        return Point(x/d, y/d);\n    }\n};\n\nstruct Circle {\n    ld x, y;\n    ld r;\n    Circle(ld x=0, ld y=0, ld r=1) : x(x), y(y), r(r) {}\n    const static ld eps = 1e-10;\n    bool isIntersect(const Circle& o) const {\n        ld dx = o.x - x;\n        ld dy = o.y - y;\n        return (r + o.r) * (r + o.r) > (dx*dx + dy*dy);\n    }\n    pair<Point, Point> intersectionPoint(const Circle& o) const {\n        ld dx = o.x - x;\n        ld dy = o.y - y;\n        ld d = sqrt(dx*dx + dy*dy);\n\n        ld slope = dy / dx;\n        ld theta = atan(slope);\n        ld theta_p = acos((r*r - o.r*o.r + d*d) / (2*r*d));\n\n        return make_pair(\n                Point(x + r*cos(theta - theta_p), y + r*sin(theta - theta_p)),\n                Point(x + r*cos(theta + theta_p), y + r*sin(theta + theta_p)));\n    }\n    bool contains(ld px, ld py) const {\n        return r * r + eps > (px - x) * (px - x) + (py - y) * (py - y);\n    }\n    string to_s() {\n        ostringstream os;\n        os << x << ',' << y << ':' << r << endl;\n        return os.str();\n    }\n};\n\nint countContainingPoints(const Circle& c, const vector<Circle>& ps) {\n    int cnt = 0;\n    for (int i = 0; i < ps.size(); i++) \n        if (c.contains(ps[i].x, ps[i].y)) \n            cnt++;\n    return cnt;\n}\n\nPoint midPoint(pair<Point, Point>& pp) {\n    return (pp.first + pp.second) / 2;\n}\n\nint N;\nint main() {\n    vector<Circle> cs;\n    while (cin >> N, N) {\n        cs.clear(); cs.resize(N);\n        for (int i = 0; i < N; i++) cin >> cs[i].x >> cs[i].y;\n\n        vector<Point> ips; // Intersection PointS\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (i == j) continue;\n                if (!cs[i].isIntersect(cs[j])) continue;\n                pair<Point, Point> ip = cs[i].intersectionPoint(cs[j]);\n                ips.push_back(ip.first);\n                ips.push_back(ip.second);\n                //ips.push_back(midPoint(ip));\n            }\n        }\n\n        int maxPoint = 0;\n        for (int i = 0; i < ips.size(); i++) {\n            maxPoint = max(maxPoint, countContainingPoints(Circle(ips[i].x, ips[i].y, 1), cs));\n        }\n        cout << maxPoint << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n\nusing namespace std;\ntypedef pair<double, double> P;\nconst double EPS = 1e-4;\n\n#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n\nusing namespace std;\n\nvector<P> center(P a, P b)\n{\n    auto t = atan2(b.second - a.second, b.first - a.first);\n    auto x = hypot(a.first - b.first, a.second - b.second) / 2;\n    auto y = sqrt(1.0 - x * x);\n    auto cs = cos(t), sn = sin(t);\n    return { \n        { cs * x - sn * y + a.first, sn * x + cs * y + a.second },\n        { cs * x + sn * y + a.first, sn * x - cs * y + a.second }\n    };\n}\n\nint main()\n{\n    while (1) {\n        int n; cin >> n;\n        if (!n) break;\n        vector<P> pnt;\n        loop (n, i) {\n            double x, y; cin >> x >> y;\n            pnt.emplace_back(x, y);\n        }\n        int ans = 1;\n        loop (n, i) loop (n, j) {\n            auto ps = center(pnt[i], pnt[j]);\n            for (auto o : ps) {\n                int cnt = 0;\n                loop (n, l) {\n                    auto x = o.first - pnt[l].first;\n                    auto y = o.second - pnt[l].second;\n                    if (x * x + y * y < 1 + EPS) cnt++;\n                }\n                ans = max(ans, cnt);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P complex<double>\n#define X real()\n#define Y imag()\nconst double EPS = 1e-9;\n\nint n;\nvector<P> vv;\n\nint count_points(P a, P b, double mx, double my){\n    P v = (a - b);\n    double d_v = abs(v);\n    if(d_v >= 2.0 + EPS) return 0;\n    P m = v / 2.0 + b;\n    double half_d_v = d_v / 2;\n    double d = sqrt(1.0 - half_d_v * half_d_v);\n    P u = (v * P(mx, my)) / abs(v) * d;\n    //debug\n    //cout <<\"s \" <<a <<\", \" <<b <<endl;\n    //cout <<v <<\", \" <<d_v <<\", \" <<m <<\", \" <<d <<\", \" <<u <<endl;\n    int cnt = 0;\n    REP(i, n){\n        P c = m + u;\n        //cout <<\"c = \" <<c <<endl;\n        //cout <<\"! \" <<i <<\", \" <<vv[i] <<\": \" <<abs(c - vv[i]) <<endl;\n        if(abs(c - vv[i]) <= 1.0 + EPS) cnt++;\n    }\n    return cnt;\n}\n\nint main(){\n    while(cin >>n && n){\n        vv = vector<P>(n);\n        REP(i, n) cin >>vv[i].X >>vv[i].Y;\n\n        int ans = 1;\n        REP(a, n){\n            FOR(b, a + 1, n){\n                ans = max(ans, count_points(vv[a], vv[b], 0, 1));\n                ans = max(ans, count_points(vv[a], vv[b], 0, -1));\n            }\n        }\n        cout <<ans <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n// xy平面上の点(ベクトル)を表現するには、complex型を利用するとよい\ntypedef complex<double> P;\n\n// 辺の表現 (座標を2つ pair でもつ)\ntypedef pair<P, P> L;\n\n// 円の表現 (座標 P と 半径 d で表現する)\ntypedef pair<P, double> C;\n\n// 成分を取り出すのを簡単にする\n#define X real()\n#define Y imag()\n\n// 誤差(epsilon)の定義\n#define EPS (1e-10)\n\n// 2つの要素が等しいかどうか\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n\n// 2つのベクトルが等しいかどうか\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n\n// m は n より大きい(以上)かどうか\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n\n// m は n より小さい(以下)かどうか\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\n// 2つのベクトルの内積を求める\ndouble dot(P a, P b) {\n    return (a.X * b.X + a.Y * b.Y);\n}\n\n// 2つのベクトルの外積を求める\ndouble cross(P a, P b) {\n    return (a.X * b.Y - a.Y * b.X);\n}\n\n// 点 a と 点 b を通り、半径が r の円の中心を返す\nvector<P> circlesPointsRadius(P a, P b, double r) {\n    vector<P> cs;\n    P abH = (b-a) * 0.5;\n    double d = abs(abH);\n\n    if(d == 0 || d > r) return cs; // 必要なら !LE(d,r) として円1つになる側へ丸める\n    double dN = sqrt(r*r - d*d);   // 必要なら max(r*r - d*d, 0) とする\n    P n = abH * P(0,1) * (dN / d);\n    cs.push_back(a + abH + n);\n    if(dN > 0) cs.push_back(a + abH - n);\n    return cs;\n}\n\nint main() {\n    int N;\n\n    while(cin >> N, N) {\n        vector<P> ps;\n        for(int i=0; i<N; i++) {\n            double x, y; cin >> x >> y;\n            ps.push_back(P(x, y));\n        }\n\n        if(N == 1) cout << 1 << endl;\n        else if(N == 2) {\n            cout << 1 + (abs(ps[0] - ps[1]) < 2 + EPS) << endl;\n        }\n        else {\n            int ans = 1;\n            for(int i=0; i<N; i++) {\n                for(int j=i+1; j<N; j++) {\n                    // printf(\"i = %d, j = %d, abs = %f\\n\", i, j, abs(ps[i] - ps[j]));\n                    if(abs(ps[i] - ps[j]) > 2 + EPS) continue;\n                    // printf(\"valid\\n\");\n\n                    vector<P> centers = circlesPointsRadius(ps[i], ps[j], 1);\n                    for(auto c : centers) {\n                        int sum = 2;\n                        for(int k=0; k<N; k++) {\n                            if(i == k || j == k) continue;\n                            sum += (abs(c - ps[k]) < 1 + EPS);\n                        }\n                        ans = max(ans, sum);\n                    }\n                }\n            }\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double eps = 1e-5;\nconst int MAXN = 333;\nint N;\nP ps[MAXN];\n\nint calc(P c) {\n  int res = 0;\n  for(int i = 0; i < N; ++i) {\n    double d = norm(c - ps[i]);\n    if(d < 1.0 + eps) ++res;\n  }\n  return res;\n}\n\nint main() {\n  for(; cin >> N && N; ) {\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    int res = 0;\n    for(int i = 0; i < N; ++i) {\n      for(int j = i+1; j < N; ++j) {\n        P base = ps[j] - ps[i];\n        P m = ps[i] + base / 2.0;\n        double d = abs(base);\n        double a = sqrt(1.0 - d * d / 4.0);\n        P base2(-base.imag(), base.real());\n        base2 = base2 / abs(base2) * a;\n        res = max(res, max(calc(m + base2), calc(m - base2)));\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <complex>\n\n#define EPS (1e-10)\n\nusing namespace std;\n\nint count( vector<complex<double>> &vpos );\n\nint main(int argc, char const *argv[]) {\n    int n, result;\n    double x, y;\n    vector<complex<double>> vpos;\n    vector<int> results;\n\n    while(1){\n        cin>>n;\n        if( n == 0 ) break;\n        for(int i = 0; i < n; i++){\n            cin>>x>>y;\n            vpos.push_back( complex<double> (x,y) );\n        }\n        results.push_back( count( vpos ) );\n        vpos.clear();\n    }\n\n    for (auto it = results.begin(); it != results.end(); it++) {\n        cout<<*it<<endl;\n    }\n\n    return 0;\n}\n\nint count( vector<complex<double>> &vpos ){\n    int count = 0;\n    int tmp_count1, tmp_count2;\n    complex<double> m, n1, n2, center1, center2;\n\n    for(auto fi = vpos.begin(); fi != vpos.end(); fi++){\n        for(auto sc = vpos.begin(); sc != vpos.end(); sc++){\n            if( (*fi).real() == (*sc).real() ) continue;\n            tmp_count1 = 0;\n            tmp_count2 = 0;\n\n            m = ( (*fi) + (*sc) ) / 2.0;\n            n1 = ( (*fi) -  (*sc) ) * complex<double> ( 0.0, 1.0 );\n            n1 = n1 / abs(n1);\n            n2 = ( (*fi) -  (*sc) ) * complex<double> ( 0.0, -1.0 );\n            n2 = n2 / abs(n2);\n\n            double x = abs( (*fi) -  (*sc) ) / 2.0;\n            center1 =  m + n1 * sqrt( 1.0 - x * x );\n            center2 =  m + n2 * sqrt( 1.0 - x * x );\n\n            for(auto it = vpos.begin(); it != vpos.end(); it++){\n                double dist1 = abs( center1 - (*it) );\n                double dist2 = abs( center2 - (*it) );\n                if( dist1 <= 1.0 + EPS ){\n                    tmp_count1++;\n                }\n                if( dist2 <= 1.0 + EPS ){\n                    tmp_count2++;\n                }\n            }\n            if( count < max(tmp_count1, tmp_count2) ){\n                count = max(tmp_count1, tmp_count2);\n            }\n        }\n    }\n    return count;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n#define OUT 0\n#define ON 1\n#define IN 2\n#define EPS (1e-10)\nclass P{                    //???\npublic:\n\tdouble x,y;\n\t\n\tP(double _x=0,double _y=0):x(_x),y(_y){};\n\tP operator + (const P &p     )const{ return P( x+p.x , y+p.y ); }  //??????\n\tP operator - (const P &p     )const{ return P( x-p.x , y-p.y ); }  //??????\n\tP operator * (const double k )const{ return P( x*k   , y*k    ); } //??????\n\tP operator / (const double k )const{ return P( x/k   , y/k    ); } //??????\n\t\n\tbool operator == (const P &p){ return ( fabs(x-p.x)<EPS && fabs(y-p.y)<EPS ); }\n\tbool operator < (const P &p) const{ return ( x!=p.x ? x<p.x:y<p.y ); }\n\t\n\tdouble norm(){ return x*x+y*y; }        //?????????\n\tdouble abs() { return sqrt(norm()); }   //??§??????\n};\nstruct C{P p;double r;};    //???\nstruct S{P p1,p2;};         //??????\ntypedef vector<P> Polygon;  //????§???¢\ntypedef P Vector;           //????????????\ntypedef S L;                //??´???\n\ndouble norm (P p)               { return p.norm(); }\ndouble abs  (P p)               { return p.abs(); }\ndouble dot  (Vector a,Vector b) { return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b) { return a.x*b.y-a.y*b.x; }\ndouble sqDist(P a, P b)         {return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}\ndouble dist (P a, P b)          {return sqrt(sqDist(a,b));}\nVector vec(S a)                 {return P(a.p2.x-a.p1.x,a.p2.y-a.p1.y);}\n\nint ccw(P p0,P p1,P p2){    //AOJ_BOOK_P386 verified\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\t\n\tif( cross(a,b) > EPS  ) return 1 ;      //COUNTER_CLOCKWISE\n\tif( cross(a,b) < -EPS ) return -1;      //CLOCKWISE\n\tif( dot(a,b)   < -EPS ) return 2;       //ONLINE_BACK\n\tif( a.norm()   < b.norm() ) return -2;  //ONLINE_FRONT\n\t\n\treturn 0;                               //ON_SEGMENT;\n}\n\n//??´?????´????????? verified AOJ0058\nbool orthogonal(P p1,P p2,P p3,P p4){ return abs(dot(p1-p2,p3-p4))<EPS; }\n\n//??????????????????\nbool intersect(P p1,P p2,P p3,P p4){ return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); }\n\n//????????¨???????????¢ verified ARC042-B\ndouble dLP(S l, P p) { return abs(cross(l.p2-l.p1, p-l.p1)) /(l.p2-l.p1).abs(); }\n\n//?????????????????????????°???± verified AOJ CGL_1_A\nP project(S s, P p){\n\tVector base = s.p2-s.p1;\n\tdouble r = dot(p-s.p1, base)/norm(base);\n\treturn (base*r)+s.p1;\n}\n\n//????????????????????????????°? verified AOJ CGL_1_B\nP reflect(S s,P p){ return p+(project(s,p)-p)*2.0; }\n\n//??´?????¨??´????????¢??? verified AOJ CGL_2\nint rLL(L a,L b){\n\tif( cross(vec(a),vec(b))==0 ) return 2; //??????\n\tif( dot(vec(a),vec(b))==0 )   return 1; //?????´\n\treturn 0;\n}\n\n// ?????¨??????????????????\nint contains(C c, P p){\n\tdouble d = (c.p-p).abs();\n\tif(d-c.r>EPS) return OUT;\n\tif(abs(d-c.r)<EPS) return ON;\n\treturn IN;\n}\n\n//??´?????¨??????????????????(????????£???????????´??????????????±???)\nbool intersect_circle_(P center, double r, L line){\n\tif( dLP(line,center) <= r+EPS ) return true;\n\treturn false;\n}\n\n//????????¨???????????¢ verified QUPC-G\ndouble dSP(S s, P p){\n\tif(dot((s.p2-s.p1)   , p-s.p1) <= EPS) return (p - s.p1).abs();\n\tif(dot((s.p2-s.p1)*-1, p-s.p2) <= EPS) return (p - s.p2).abs();\n\treturn dLP(s, p);\n}\n\n//????????¨??????????????????(????????£???????????´??????????????±???) verified QUPC-G\nbool iCS(C c, S l){\n\tint c1 = contains(c, l.p1);\n\tint c2 = contains(c, l.p2);\n\tif(c1 > c2) swap(c1, c2);\n\t\n\t// (OUT, OUT) (OUT, ON) (OUT, IN) (ON, ON) (ON, IN) (IN, IN) ???6??????\n\tif(c1 == OUT && c2 == IN) return true;\n\tif(c1 == IN  && c2 == IN) return false;\n\tif(c1 == ON) return true; // (??\\????????¨???)\n\tdouble d = dSP(l, c.p);\n\tif(d-c.r<-EPS) return true;\n\tif(d-c.r>EPS) return false;\n\treturn true; // (??\\????????¨???)\n}\n\n//????´?????§???¢??????\nbool isSimple( Polygon pol ){\n\t//???????????????????????????pol?????\\????????????\n\tsize_t pol_size = pol.size()-1;\n\trep(i,pol_size){\n\t\tfor(int j=i+2;j<pol_size;j++){\n\t\t\tif( i==j || i==(j-1+pol_size)%pol_size || i==(j+1+pol_size)%pol_size )continue;\n\t\t\tif( intersect(pol[i], pol[i+1], pol[j], pol[j+1]) )return false;\n\t\t}\n\t}\n\treturn true;\n}\n\n//?????????????§???¢????????´?????????????????????????±??????? true???????????´ verified AOJ0012\nint isPointInsidePolygon(vector<P> pol,P p){\n\tint c=0;\n\trep(i,pol.size()){\n\t\tif( cross(pol[i]-pol[(i+1)%pol.size()] , p-pol[(i+1)%pol.size()])==0 ) return ON;\n\t\tif( cross(pol[i]-pol[(i+1)%pol.size()] , p-pol[(i+1)%pol.size()])>0 ) c++;\n\t}\n\tif( c%pol.size() )return OUT;\n\treturn IN;\n}\n\n//?????¨???????§???¢???????????¶???????????????\nint CPOLarea(C c ,Polygon pol){\n\tvector<L> lines;\n\tvector<int> res(pol.size());\n\tbool POLinC=true, isFar=true;\n\t\n\trep(i,pol.size()){\n\t\tif( contains(c,pol[i])==OUT )POLinC=false;\n\t\tres[i] = contains(c,pol[i]);\n\t\tlines.pb( L{ pol[i] , pol[(i+1)%pol.size()] });\n\t\tif( sqDist(c.p,pol[i])<c.r*c.r )isFar=false;\n\t}\n\t\n\tif( POLinC )                                        return 2;   //????§???¢??????????????¨b\n\tif( isPointInsidePolygon(pol, c.p)==IN && isFar )   return 3;   //????§???¢????????¨??????a\n\trep(i,lines.size()) if( iCS(c,lines[i]) )           return 1;   //????§???¢??¨????????????c\n\treturn 0;\n}\n\n//?????? verified AOJ0068,QUPC-G\n//???????????§??????\nbool cmp_x(const P& p, const P& q){\n\tif(p.x != q.x)return p.x<q.x;\n\treturn p.y<q.y;\n}\n\n//??????????±???????\nvector<P> convex_hull(vector<P> ps){\n\tint n = ps.size();\n\tsort(all(ps),cmp_x);\n\tint k=0;            //?????????????????°\n\tvector<P> qs(n*2);  //?§????????????????\n\t//?????´???????????????\n\trep(i,n){\n\t\twhile( k>1 && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n\t\tqs[k++]=ps[i];\n\t}\n\t//?????´???????????????\n\tfor(int i=n-2, t=k;i>=0;i--){\n\t\twhile( k>t && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n\t\tqs[k++]=ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n\n\n//2??????????????????r?????????????????§?¨?????±??????? verified AOJ1132\npair<P,P> geoGetCircleOf2pAndR(P p1,P p2,double r){\n\tP pc1,pc2, p3;\n\tdouble d, l, dx, dy ;\n\t\n\tp3 = (p1+p2)/2.0;\n\tl = sqDist(p2,p3);\n\t\n\tif  (r*r < l)return pair<P,P>(P(-INF,-INF),P(-INF,-INF));\n\t\n\td  = sqrt(r*r/l - 1.0) ;\n\tdx = d * (p2-p3).y ;\n\tdy = d * (p2-p3).x ;\n\t\n\tpc1.x = p3.x + dx ;\n\tpc1.y = p3.y - dy ;\n\t\n\tpc2.x = p3.x - dx ;\n\tpc2.y = p3.y + dy ;\n\n\treturn pair<P,P>(pc1,pc2);\n}\n\n\nint main(){\n\tint n;\n\twhile(cin>>n&&n){\n\t\tint ans=1;\n\t\tvector<P> ps(n);\n\t\trep(i,n)cin>>ps[i].x>>ps[i].y;\n\t\t\n\t\trep(i,n){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(dist(ps[i],ps[j])>2+EPS)continue;\n\t\t\t\tpair<P,P> res = geoGetCircleOf2pAndR(ps[i],ps[j],1);\n\t\t\t\tint suma=0,sumb=0;\n\t\t\t\trep(k,n){\n\t\t\t\t\tif(sqDist(ps[k],res.first )<1+EPS)suma++;\n\t\t\t\t\tif(sqDist(ps[k],res.second)<1+EPS)sumb++;\n\t\t\t\t}\n\t\t\t\tans = max(ans,max(suma,sumb));\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ndouble pow2(double d){\n\treturn d * d;\n}\n\nstruct Vector2{\n\tdouble x;\n\tdouble y;\n};\n\nVector2 P[500];\n\nint main(){\n\tint n;\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> P[i].x >> P[i].y;\n\t\t}\n\t\tdouble k, L_2, a, b;\n\t\t\n\t\tint max = 0;\n\t\t\n\t\tfor(int num1 = 0; num1 < n; num1++){\n\t\t\tfor(int num2 = num1 + 1; num2 < n; num2++){\n\t\t\t\tL_2 = pow2(P[num1].x - P[num2].x) + pow2(P[num1].y - P[num2].y);\n\t\t\t\tif(L_2 >= 4){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tk = sqrt((4 - L_2) / L_2);\n\t\t\t\t\n\t\t\t\ta = (k * (P[num1].y - P[num2].y) + P[num1].x + P[num2].x) / 2;\n\t\t\t\tb = (k * (P[num2].x - P[num1].x) + P[num1].y + P[num2].y) / 2;\n\t\t\t\t\n\t\t\t\tint count;\n\t\t\t\t\n\t\t\t\tcount = 0;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(i == num1 || i == num2){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(pow2(P[i].x - a) + pow2(P[i].y - b) < 1){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(max < count){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ta = (k * (P[num2].y - P[num1].y) + P[num1].x + P[num2].x) / 2;\n\t\t\t\tb = (k * (P[num1].x - P[num2].x) + P[num1].y + P[num2].y) / 2;\n\t\t\t\t\n\t\t\t\tcount = 0;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(i == num1 || i == num2){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(pow2(P[i].x - a) + pow2(P[i].y - b) < 1){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(max < count){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", max);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 300\n\ntypedef double P_type;\ntypedef complex<P_type> P;\nconst P_type P_eps = 1e-8; //整数の時はゼロ\n\nnamespace std{\n  template<class T> bool operator<(const complex<T> &a, const complex<T> &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n  }\n};\n\n/* 円の点包含判定 */\ndouble isContainedCP(P c, double r, P p){\n  //return abs(c-p) < r - P_eps; //円周上を含まない\n  return abs(c-p) < r + P_eps; //円周上を含む\n}\n\nint solve(){\n  int n;\n  double x[SIZE], y[SIZE];\n\n  scanf(\"%d\", &n);\n  if(n == 0) return false;\n\n  for(int i=0;i<n;i++){\n    scanf(\"%lf%lf\", x+i, y+i);\n  }\n\n  int ans = 0;\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i == j) continue;\n      P vec = P(x[i]-x[j], y[i]-y[j]);\n\n      if(abs(vec) > 2.0 + P_eps) continue;\n      \n      P p = P(-vec.imag(), vec.real());\n      p = p / abs(p) * sqrt(1 - norm(vec) / 4);\n      //debug(p);\n\n      p += vec / 2.0 + P(x[j], y[j]); \n\n      int counter = 0;\n      // debug(abs(p - P(x[i], y[i])));\n      \n      for(int k=0;k<n;k++){\n        counter += isContainedCP(p, 1, P(x[k], y[k]));\n      }\n\n      ans = max(ans, counter);\n    }\n  }\n\n  printf(\"%d\\n\", ans);\n  return true;\n}\n\n\nint main(){\n  while(solve());\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\ntypedef complex<double> P;\nint n;\nP in[305];\nmap<vector<bool>, int> memo;\n\nbool check(vector<bool> s, int p){\n\trep(i,n){\n\t\tif(s[i]){\n\t\t\tif(abs(in[i] - in[p]) > 2){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint dfs(vector<bool> s){\n\tif(memo.count(s)) return memo[s];\n\n\tint res = 0;\n\trep(i,n){\n\t\tif(not s[i]){\n\t\t\tif(check(s, i)){\n\t\t\t\ts[i] = true;\n\t\t\t\tres = max(res, dfs(s) + 1);\n\t\t\t\ts[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn memo[s] = res;\n}\n\nint main(){\n\twhile(cin >> n,n){\n\t\tmemo.clear();\n\t\trep(i,n){\n\t\t\tdouble a,b;\n\t\t\tcin >> a >> b;\n\t\t\tin[i] = P(a,b);\n\t\t}\n\n\t\tcout << dfs(vector<bool>(n,0)) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n#define EPS 1.0e-8\ntypedef complex<double> P;\n\nint main(){\n  int n;\n  P p[301];\n\n  while( cin>>n && n ){\n    for( int i=0;i<n;i++ )\n      cin >> p[i].real() >> p[i].imag();\n\n    int ans=0;\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ ){\n\tif( i==j ) \t  continue;\n\tif( abs( p[i]-p[j] )+EPS > 2.0 ) continue;\n\n\tP m  = (p[i]+p[j]) / 2.0;         // p[i]Æp[j]Ì_\n\tP nn = (p[i]-p[j]) * P(0.0,1.0);  // @üxNg\n\tnn = nn / abs(nn);\n\n\tdouble x = abs( p[i]-p[j] )/2.0;\n\tP c = m + nn*sqrt( 1.0-x*x );     // ~ÌS\n\n\tint num=0;\n\tfor( int k=0;k<n;k++ )\n\t  if( abs( c-p[k] ) < 1.0 + EPS  )\n\t    num++;\n\tans = max( ans,num );\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define REPP(i,j,n) for(int i=(j);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-5, pi = acos(-1.0);\nld dot(Point a, Point b){return real(conj(a)*b);}\nld cross(Point a, Point b){ return imag(conj(a)*b);}\n\nPoint p[310];\nint n;\n\nvoid solve(){\n  int result=1;\n  REP(i,n){\n    REPP(j,i+1,n){\n      Point ab=p[j]-p[i];\n      if(norm(ab)>4)continue;\n      Point q=(p[i]+p[j])/2.L;\n      Point aq=q-p[j];\n      Point normal=Point{imag(aq),-real(aq)}*sqrt(1-norm(aq))/abs(aq);\n      Point c=q+normal;\n      Point d=q-normal;\n      int cntc=0,cntd=0;\n      REP(k,n){\n\tif(norm(p[k]-c)<=1.L)cntc++;\n\tif(norm(p[k]-d)<=1.L)cntd++;\n      }\n      result=max({result,2,cntc,cntd});\n    }\n  }\n  cout<<result<<endl;\n}\n\nint main(){ _;\n  ld r,i;\n  while(cin>>n,n!=0){\n    REP(j,n){\n      cin>>r>>i;\n      p[j]=Point{r,i};\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1132>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\ntypedef complex<double> Point;\nint n;\nint solve(){\n    int res = 1;\n    vector<Point> ps(n);\n    for(int i = 0; i < n;i++){\n        double x,y; cin >> x >> y;\n        ps[i] = Point(x,y);\n    }\n    for(int i = 0; i < n;i++){\n        for(int j = i+1; j < n;j++){\n            double dist = abs(ps[i]-ps[j]);\n            if(dist > 2) continue;\n            Point mp = (ps[i]+ps[j])/2.;\n            Point dp = ps[i]-ps[j];\n            double x = sqrt(1-dist*dist/4);\n            Point cp = Point(-dp.imag()*x/dist+mp.real(),dp.real()*x/dist+mp.imag());\n            int cnt = 0;\n            for(int k = 0; k < n;k++){\n                if(abs(cp-ps[k]) <= 1.0) cnt++;\n            }\n            res = max(res,cnt);\n        }\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> n,n){\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n//eÍÍÌë·\n//1 * 10^(-5)\n#define EPS (1e-8)\n\nint n;\npair<double, double> p[301];\n\nint main() {\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> p[i].first >> p[i].second;\n\t\t}\n\t\tint maxPoints = 1;\n\t\t//2_ð~üãÉÂ~ðè\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdouble d = hypot(p[i].first - p[j].first, p[i].second - p[j].second);\n\t\t\t\tif (d > 2.0 + EPS) continue;\t//£ê·¬\n\t\t\t\t\n\t\t\t\t//_(»ê¼êÌÀWÌ½Ï)\n\t\t\t\tpair<double, double> m((p[i].first + p[j].first) / 2.0, (p[i].second + p[j].second) / 2.0);\n\t\t\t\t//PÊ@üxNg\n\t\t\t\t//\t@üxNgÌX«Íüªp[i]p[j]Æ|¯Ä-1C·Èí¿\n\t\t\t\t//\t\tv = (p[j].first - p[i].first, p[j].second - p[i].second)\n\t\t\t\t//\t±êÌ·³Ívx^2 + vy^2 = d^2\n\t\t\t\t//\tæÁÄPÊxNgÉ·éÉÍ\n\t\t\t\t//\t\t(vx/d)^2 + (vy/d)^2 = 1\n\t\t\t\tpair<double, double> ve((p[j].first - p[i].first) / d, (p[j].second - p[i].second) / d);\n\t\t\t\t//_©çSÜÅÌ£\n\t\t\t\tdouble l = sqrt(1.0 - d * d / 4.0);\n\t\t\t\t\n\t\t\t\t//_2Â©çèÜé~Í2Â\n\t\t\t\tfor (int s = -1; s < 2; s += 2) {//\n\t\t\t\t\tpair<double, double> c(m.first + s * l * ve.first, m.second - s * l * ve.second);\n\t\t\t\t\tint count = 2;\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tif (k==i || k==j) continue;//¯êÌ_ÍÜßÈ¢\n\t\t\t\t\t\tif (hypot(c.first - p[k].first, c.second - p[k].second) < 1.0 + EPS) count++;\n\t\t\t\t\t}\n\t\t\t\t\tmaxPoints = max(maxPoints, count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << maxPoints << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <utility>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nbool eqv(double a, double b) {\n    return abs(a-b) < 1e-10;\n}\n\nbool inCircle(const Point &p, const Point &center, double radius) {\n    double dist2 = norm(p-center);\n    double rad2 = radius*radius;\n    return dist2 < radius*radius || eqv(dist2, rad2);\n}\n\nint check(const Point &center, const vector<Point> &points) {\n    const int N = points.size();\n    int cnt = 0;\n    for(int i = 0; i < N; ++i) {\n        if(inCircle(points[i], center, 1)) ++cnt;\n    }\n    return cnt;\n}\n\nint test(int a, int b, const vector<Point> &points) {\n    const Point v(points[a]-points[b]);\n    const double hlen = abs(v)/2;\n\n    if(hlen*hlen >= 1) return 0;\n    const double plen = sqrt(1 - hlen*hlen);\n    Point perp = v*Point(0, 1);\n    perp /= abs(perp);\n    const Point mid = points[b] + v/2.0;\n    return max(check(mid + perp*plen, points), check(mid - perp*plen, points));\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        vector<Point> points(N);\n        for(int i = 0; i < N; ++i) {\n            cin >> points[i].real() >> points[i].imag();\n        }\n        int ans = 0;\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < i; ++j) {\n                ans = max(ans, test(i, j, points));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\n// 点\nclass Point {\n  public:\n    float x, y;\n    Point(double ix = 0.0, double iy = 0.0) {\n      set(ix, iy);\n    }\n    void set(double ix = 0.0, double iy = 0.0) {\n      x = ix;\n      y = iy;\n    }\n    double length() {\n      return sqrt(x * x + y * y);\n    }\n    double distanceTo(Point p) {\n      double dx = p.x - x, dy = p.y - y;\n      return sqrt(dx * dx + dy * dy);\n    }\n};\n\nint main() {\n  vector<int> results;\n  while (true) {\n    // 入力\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    vector<Point> p(n);\n    for (int i=0; i<n; i++) {\n      double x, y;\n      cin >> x >> y;\n      p[i].set(x, y);\n    }\n    \n    // とりあえず格子状に調べてみる（）\n    const float X = 100;\n    Point pc;\n    int max = 0;\n    for (int xi=0; xi<=X; xi++) {\n      for (int yi=0; yi<=X; yi++) {\n\tfloat x = xi * 10 / X, y = yi * 10 / X; // 0 ~ 10に補正\n\t// 距離が1以下のものをカウント\n\tpc.set(x, y);\n\tint count = 0;\n\tfor (int i=0; i<n; i++) {\n\t  if (pc.distanceTo(p[i]) <= 1) count++;\n\t}\n\tif (count > max) max = count;\n      }\n    }\n    results.push_back(max);\n  }\n  \n  int size = results.size();\n  for (int i=0; i<size; i++) {\n    cout << results[i] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <string>\nusing namespace std;\n\nvector<double> getAreaPointx(int x,int y,vector<double> lx,vector<double> ly)\n{\n\tvector<double> result;\n\tvector<double>::iterator itx=lx.begin();\n\tvector<double>::iterator ity=ly.begin();\n\twhile (itx != lx.end())\n\t{\n\t\tif ((*itx <= x+1) && (*itx >= x-2) && (*ity <= y+1) && (*ity >= y-2)){\n\t\t\tresult.push_back(*itx);\n\t\t}\n\t\titx++;\n\t\tity++;\n\t}\n\treturn result;\n}\n\nvector<double> getAreaPointy(int x,int y,vector<double> lx,vector<double> ly)\n{\n\tvector<double> result;\n\tvector<double>::iterator itx=lx.begin();\n\tvector<double>::iterator ity=ly.begin();\n\twhile (itx != lx.end())\n\t{\n\t\tif ((*itx <= x+1) && (*itx >= x-2) && (*ity <= y+1) && (*ity >= y-2)){\n\t\t\tresult.push_back(*ity);\n\t\t}\n\t\titx++;\n\t\tity++;\n\t}\n\treturn result;\n}\n\n\ndouble distance(double x1,double y1,double x2,double y2)\n{\n\treturn sqrt(pow((x1-x2),2)+pow((y1-y2),2));\n}\n\nint countInside(double x,double y,vector<double> lx,vector<double> ly)\n{\n\tint c=0;\n\tvector<double>::iterator itx=lx.begin();\n\tvector<double>::iterator ity=ly.begin();\n\twhile (itx != lx.end())\n\t{\n\t\tif (distance(x,y,*itx,*ity) <= 1)\n\t\t{\n\t\t\tc++;\n\t\t}\n\t\titx++;\n\t\tity++;\n\t}\n\treturn c;\n}\n\nint main(void) {\n\tvector<int> r;\n\twhile (true)\n\t{\n\t\tint n=0;\n\t\tscanf(\"%d\",&n);\n\t\tif (n==0){\n\t\t\tbreak;\n\t\t}\n\t\tvector<double> x,y;\n\t\tint map[12][12]={{0}};\n\t\tint maxx=0,maxy=0;\n\t\tint maxpoint=0;\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tdouble tx=0,ty=0;\n\t\t\tscanf(\"%lf %lf\", &tx, &ty);\n\t\t\tx.push_back(tx);\n\t\t\ty.push_back(ty);\n\t\t\tint ttx=0,tty=0;\n\t\t\tttx = int(round(tx+0.5));\n\t\t\ttty = int(round(ty+0.5));\n\t\t\tmap[ttx][tty]++;\n\t\t\tif (maxpoint < map[ttx][tty]){\n\t\t\t\tmaxpoint = map[ttx][tty];\n\t\t\t\tmaxx=ttx;\n\t\t\t\tmaxy=tty;\n\t\t\t}\n\t\t}\n\t\tfor (double dif=0.8; dif>=0.008; dif/=10)\n\t\t{\n\t\t\tfor (int i=1; i<=10; i++)\n\t\t\t{\n\t\t\t\tfor (int j=1; j<=10; j++)\n\t\t\t\t{\n\t\t\t\t\tint aroundpoint=0;\n\t\t\t\t\tfor (int k=-1; k<=1; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int l=-1; l<=1; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taroundpoint+=map[i+k][j+l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (maxpoint >= aroundpoint){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvector<double> lx=getAreaPointx(i,j,x,y);\n\t\t\t\t\t\tvector<double> ly=getAreaPointy(i,j,x,y);\n\t\t\t\t\t\tfor (double k=0; k<1; k+=dif)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (double l=0; l<1; l+=dif)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint tmp = countInside(i-1+k,j-1+l,lx,ly);\n\t\t\t\t\t\t\t\tif (tmp>maxpoint){\n\t\t\t\t\t\t\t\t\tmaxpoint = tmp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr.push_back(maxpoint);\n\t}\n\tfor(int i=0; i<r.size(); i++)\n\t{\n\t\tcout << r[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double r = 1.0;\nconst double PI = acos(-1.0);\nconst double sq2 = sqrt(2.0);\nconst double dx[] = {0.0, 1.0, 0.0, 1.0};\nconst double dy[] = {0.0, 0.0, 1.0, 1.0};\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y) : x(x), y(y) {}\n};\nstruct Rect {\n    double x, y, len; // ??????(x, y)??§?????????len?????£?????¢\n    int ub;\n    Rect() { ub = 0; }\n    Rect(double x, double y, double len, int ub) : x(x), y(y), len(len), ub(ub) {}\n};\nbool operator<(const Rect &a, const Rect &b) {\n    return a.ub < b.ub;\n}\ninline double Distance2(const Point &a, const Point &b) {\n    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\nint n;\nvector<Point> p;\n\nRect MakeRect(double x, double y, double l, int &ans) {\n    int num = 0, u_bound = 0;\n    const double len = l * l * 0.5 + sq2 * l + 1.0;\n    Point c(x + l * 0.5, y + l * 0.5);\n\n    for (int i = 0; i < n; ++i) {\n        double d = Distance2(c, p[i]);\n\n        if (d <= 1.0)\n            ++num;\n        if (d <= len)\n            ++u_bound;\n    }\n\n    ans = max(ans, num);\n\n    return Rect(x, y, l, u_bound);\n}\n\nint Solve() {\n    int ans = 1;\n    priority_queue<Rect> que;\n\n    que.push(MakeRect(0.0, 0.0, 10.0, ans));\n\n    while (!que.empty()) {\n        Rect now = que.top();\n        que.pop();\n\n        if (ans < now.ub) {\n            double half = now.len * 0.5;\n\n            for (int d = 0; d < 4; ++d) {\n                Rect r = MakeRect(now.x + half * dx[d], now.y + half * dy[d], half, ans);\n                if (ans < r.ub)\n                    que.push(r);\n            }\n        }\n    }\n\n    return ans;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n, n) {\n        p.resize(n);\n        for (int i = 0; i < n; ++i)\n            cin >> p[i].x >> p[i].y;\n\n        cout << Solve() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n\nusing namespace std;\n\nint n;\n\ndouble xi[300];\ndouble yi[300];\n\ndouble distant2(double x1,double y1,double x2,double y2)\n{\n\treturn (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n}\n\nint search(int i,int j)\n{\n\tdouble mx = (xi[i] + xi[j]) / 2,my = (yi[i] + yi[j]) / 2;\n\tdouble diff2 = distant2(mx,my,xi[i],yi[i]);\n\n\tif(diff2 > 1.0)\n\t\treturn 1; //1ツ古つつセツつッ\n\tdouble len = sqrt(1 - diff2);\n\tdouble diff = sqrt(diff2);\n\tdouble dx = len * (yi[i] - my) / diff,dy = len * (xi[i] - mx) / diff;\n\t\n\tint sign[] = {1,-1};\n\tint counter[2] = {0};\n\tfor(int s = 0; s < 2; s++)\n\t{\n\t\tdouble x = mx - sign[s] * dx,y = my + sign[s] * dy;\n\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tif(k == i || k == j){counter[s]++; continue;}\n\t\t\tif((x-xi[k])*(x-xi[k]) + (y-yi[k])*(y-yi[k])  < 1.0)\n\t\t\t\tcounter[s]++;\n\t\t}\n\t}\n\n\treturn max(counter[0],counter[1]);\n}\n\n\n\nint solve()\n{\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> xi[i] >> yi[i];\n\t}\n\n\tint count = 0;\n\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = i+1; j < n; j++){\n\t\t\tcount = max(count,search(i,j));\n\t\t}\n\t}\n\n\treturn count;\n}\n\nint main() {\n  while (cin >>n,n) {\n    cout << solve() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n\nusing namespace std;\n\ncomplex<double> points[300];\n\nconstexpr double epsilon = 1.0e-6;\n\nint count_points(const complex<double> &center,int N){\n  int num=0;\n  for(int i=0;i<N;++i){\n    double dist = abs(points[i]-center);\n    if(dist-1.0<=epsilon){\n      num++;\n    }\n  }\n  return num;\n}\n\nint main(){\n  int n;\n  while(cin >> n&&n>0){\n    for(int i=0;i<n;++i){\n      double x,y;\n      cin >> x >> y;\n      points[i] = complex<double>(x,y);\n    }\n    \n    int maxnum = 1;\n    for(int i=0;i<n-1;++i){\n      for(int j=i+1;j<n;++j){\n        complex<double> v = points[j]-points[i];\n        double dist = abs(v);\n        int circnum=0;\n        complex<double> center[2];\n        if(abs(dist-2.0)<=epsilon){\n          circnum = 1;\n          center[0] = (points[i]+points[j])/2.0;\n        }else if(dist-2.0<-epsilon){\n          circnum = 2;\n          complex<double> w = v/dist;\n          w *= complex<double>(0,1);\n          w *= sqrt(1.0-dist*dist/4.0);\n          center[0] = (points[i]+points[j])/2.0 + w;\n          center[1] = (points[i]+points[j])/2.0 - w;\n        }\n        for(int c=0;c<circnum;++c){\n          maxnum = max(maxnum,count_points(center[c],n));\n        }\n      }\n    }\n    cout << maxnum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <utility>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nbool eqv(double a, double b) {\n    return abs(a-b) < 1e-10;\n}\n\nbool inCircle(const Point &p, const Point &center, double radius) {\n    double dist2 = norm(p-center);\n    double rad2 = radius*radius;\n    return dist2 < radius*radius || eqv(dist2, rad2);\n}\n\nint check(const Point &center, const vector<Point> &points) {\n    const int N = points.size();\n    int cnt = 0;\n    for(int i = 0; i < N; ++i) {\n        if(inCircle(points[i], center, 1)) ++cnt;\n    }\n    return cnt;\n}\n\nint test(int a, int b, const vector<Point> &points) {\n    const Point v(points[a]-points[b]);\n    const double hlen = abs(v)/2;\n\n    if(hlen >= 1) return 0;\n    const double plen = sqrt(1 - hlen*hlen);\n    Point perp = v*Point(0, 1);\n    perp /= abs(perp);\n    const Point mid = (points[a]+points[b]) / 2.0;\n    return max(check(mid + perp*plen, points), check(mid - perp*plen, points));\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        vector<Point> points(N);\n        for(int i = 0; i < N; ++i) {\n            cin >> points[i].real() >> points[i].imag();\n        }\n        int ans = 0;\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < i; ++j) {\n                ans = max(ans, test(i, j, points));\n            }\n        }\n        if(N == 1) ans = 1;\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define REPP(i,j,n) for(int i=(j);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-5, pi = acos(-1.0);\nld dot(Point a, Point b){return real(conj(a)*b);}\nld cross(Point a, Point b){ return imag(conj(a)*b);}\n\nPoint p[310];\nint n;\n\nvoid solve(){\n  int result=1;\n  REP(i,n){\n    REPP(j,i+1,n){\n      Point ab=p[j]-p[i];\n      if(norm(ab)>4)continue;\n      Point q=(p[i]+p[j])/2.L;\n      Point aq=q-p[j];\n      Point normal=Point{imag(aq),-real(aq)}*sqrt(1-norm(aq))/abs(aq);\n      Point c=q+normal;\n      Point d=q-normal;\n      int cntc=0,cntd=0;\n      REP(k,n){\n\tif(norm(p[k]-c)<=1.0001L)cntc++;\n\tif(norm(p[k]-d)<=1.0001L)cntd++;\n      }\n      result=max({result,2,cntc,cntd});\n    }\n  }\n  cout<<result<<endl;\n}\n\nint main(){ _;\n  ld r,i;\n  while(cin>>n,n!=0){\n    REP(j,n){\n      cin>>r>>i;\n      p[j]=Point{r,i};\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1e-4;\n\nstruct Coor {\n\tdouble x, y;\n};\n\ndouble pw(double x) { return x * x; };\nint max(int n, int m) { return n > m ? n : m; };\n\nint main()\n{\n\tdouble n;\n\tvector<Coor> v(300);\n\n\twhile (cin >> n) {\n\t\tif (n == 0) break;\n\n\t\t\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> v.at(i).x >> v.at(i).y;\n\t\t}\n\n\t\tdouble x1, y1, x2, y2;\n\t\tint _max = 1;\n\n\t\tCoor mid;\n\n\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\tx1 = v.at(i).x; y1 = v.at(i).y;\n\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tx2 = v.at(j).x; y2 = v.at(j).y;\n\t\t\t\tmid.x = (x1 + x2) / 2;\n\t\t\t\tmid.y = (y1 + y2) / 2;\n\n\t\t\t\tdouble d = sqrt(pw(x1 - x2) + pw(y1 - y2));\n\t\t\t\tdouble dx = sqrt(1 - pw(d / 2)) * (y1 - y2) / d;\n\t\t\t\tdouble dy = sqrt(1 - pw(d / 2)) * (x2 - x1) / d;\n\n\t\t\t\tint ct1 = 0, ct2 = 0;\n\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tdouble tmp = pw(v.at(k).x - (mid.x + dx)) + pw(v.at(k).y - (mid.y + dy));\n\t\t\t\t\tif (sqrt(tmp) <= 1.0 + EPS) ct1++;\n\n\t\t\t\t\ttmp = pw(v.at(k).x - (mid.x - dx)) + pw(v.at(k).y - (mid.y - dy));\n\t\t\t\t\tif (sqrt(tmp) <= 1.0 + EPS) ct2++;\n\t\t\t\t}\n\n\t\t\t\t_max = max(_max, ct1);\n\t\t\t\t_max = max(_max, ct2);\n\t\t\t}\n\t\t}\n\n\t\tcout << _max << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-5;\n\nstruct Circle{\n  P c;\n  double r;\n  Circle(P c=P(0,0),double r=0):c(c),r(r){}\n};\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1=c1.r,r2=c2.r,d;\n  P p1=c1.c,p2=c2.c;\n  d=abs(p1-p2);\n  if(d<EPS&&abs(r1-r2)<EPS) return res;\n  if(r1+r2<d-EPS||d+EPS<abs(r1-r2)) return res; \n  double a=(r1*r1-r2*r2+d*d)/(2*d);\n  double h=sqrt(max(r1*r1-a*a,0.0));\n  P tmp1=p1+a/d*(p2-p1);\n  P tmp2=h/d*(p2-p1);\n  if(abs(tmp2)<EPS)res.push_back(tmp1);\n  else{\n    res.push_back(P(real(tmp1)-imag(tmp2),imag(tmp1)+real(tmp2)));\n    res.push_back(P(real(tmp1)+imag(tmp2),imag(tmp1)-real(tmp2)));\n  }\n  return res;\n}\n\ndouble getdistancepp(P a,P b){\n  return sqrt((a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag()));\n}\n\nint main(){\n  int n,ans;\n  double a,b;\n  P p[N];\n  while(1){\n    ans=0;\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>a>>b;\n      p[i]=P(a,b);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tCircle c1,c2;\n\tc1.c=p[i];\n\tc2.c=p[j];\n\tc1.r=c2.r=1;\n\tvector<P> r=getIntersectCC(c1,c2);\n\tif(!r.size())continue;\n\tfor(int k=0;k<r.size();k++){\n\t  int cnt=0;\n\t  for(int l=0;l<n;l++)\n\t    if(getdistancepp(r[k],p[l])<=1+EPS)cnt++;\t    \n\t  ans=max(ans,cnt);\n\t}\n      }\n    }\n    if(!ans&&n>=1)ans=1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<double,double> P;\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<P> v;\n    double x,y,mx1,mx2,my1,my2,p,q,a,b,c;\n    int ans=1;\n    int i,j,k,l;\n    for(i=0;i<n;i++){\n      cin >> x >> y;\n      v.push_back(P(x,y));\n    }\n    for(i=0;i<n;i++){\n      for(j=i+1;j<n;j++){\n        mx1=v[i].first;my1=v[i].second;\n\tmx2=v[j].first;my2=v[j].second;\n\t//cout << (mx1-mx2)*(mx1-mx2)+(my1-my2)*(my1-my2) << endl;\n\tif((mx1-mx2)*(mx1-mx2)+(my1-my2)*(my1-my2)>2.0*2.0) continue;\n\tp=(my1-my2)/(mx2-mx1);\n\tq=((mx1+mx2)-p*(my1+my2))/2;\n\t//cout << p << \":\" << q << endl;\n\ta=p*p+1;b=2*p*q-2*my1-2*mx1*p;c=q*q-2*mx1*q+mx1*mx1+my1*my1-1.0;\n\t//cout << a << \":\" << b << \":\" << c << endl;\n\tl=0;\n\t//cout << b*b-4*a*c << \"/\";\n\ty=(-b+sqrt(b*b-4*a*c))/(2*a);x=p*y+q;\n\t//cout << x << \":\" << y << endl;\n\tfor(k=0;k<n;k++){\n\t  if((v[k].first-x)*(v[k].first-x)\n\t     +(v[k].second-y)*(v[k].second-y)<=1.0001) l++;\n\t}\n\tl=0;\n\ty=(-b-sqrt(b*b-4*a*c))/(2*a);x=p*y+q;\n\tfor(k=0;k<n;k++){\n\t  if((v[k].first-x)*(v[k].first-x)\n\t     +(v[k].second-y)*(v[k].second-y)<=1.0001) l++;\n\t}\n\tans=max(ans,l);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <complex>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\n#define equals(a, b) (fabs((a)-(b))<EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\n\nstruct Circle {\n    Point c;\n    double r;\n    Circle(Point c=Point(), double r=0.0) :\n        c(c),r(r){}\n};\n\nstruct Segment {\n    Point p1, p2;\n};\n\nbool include(Circle c,Point p) {\n    return !(norm(c.c-p) > c.r*c.r);\n}\n\nint n;\ndouble xs[301],ys[301];\n\nPoint getMidpoint(Point p1, Point p2, Point p3) {\n    Point p=p1+p2+p3;\n    p/=3;\n\n    return p;\n}\n\nint f(Point p) {\n    int ret=0;\n    Circle c=Circle(p,1);\n    rep(i,n) {\n        if(include(c,Point{xs[i],ys[i]})) ret++;\n    }\n\n    return ret;\n}\n\nvoid solve() {\n    rep(i,n) cin>>xs[i]>>ys[i];\n    int ans=1;\n    rep(i,n) rep(j,n) if(i<j) {\n        Point p1=Point{xs[i],ys[i]};\n        Point p2=Point{xs[j],ys[j]};\n        Vector v=p1-p2;\n        if(abs(v) > 2.0) continue;\n        \n        Vector t=(v/abs(v))*Vector(0,1);\n        double h=sqrt(1-abs(v)*abs(v)/4.0);\n\n        Point p = p2+v/2.0 + t*h;\n\n\n        ans=max(ans,f(p));\n        p*=-1.0;\n        ans=max(ans,f(p));\n    }\n\n    cout<<ans<<endl;\n}\n\nint main() {\n    while(cin>>n) {\n        if(!n) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ld = long double;\nusing Point = complex<ld>;\n\nstruct Line{\n    Point a, b;\n    Line (Point a, Point b) : a(a), b(b) {}\n    Line () : Line(Point(), Point()) {}\n};\n\nstruct Circle{\n    Point p;\n    ld r;\n    Circle (Point p, ld r) : p(p), r(r) {}\n    Circle () : Circle(Point(),0.0) {}\n};\n\nconstexpr ld eps=1e-9, pi=acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nnamespace Geometry{\n    bool eq(ld a, ld b){\n        return abs(a-b) < eps;\n    }\n    //内積\n    ld dot(Point a, Point b){\n        return real(conj(a) * b);\n    }\n    //外積\n    ld cross(Point a, Point b){\n        return imag(conj(a) * b);\n    }\n    //3点の位置関係\n    int ccw (Point a, Point b, Point c) {\n        b -= a; c -= a;\n        if (cross(b, c) > eps) return 1;//a,b,cで反時計周り\n        if (cross(b, c) < -eps) return -1;//a,b,cで時計周り\n        if (dot(b, c) < 0) return 2;//c,a,bで直線\n        if (norm(b) < norm(c)) return -2;//a,b,cで直線\n        return 0;//a,c,bで直線\n    }\n\n//====================================================\n    Point inputPoint(){\n        ld x, y;\n        cin>>x>>y;\n        return Point(x, y);\n    }\n    //2直線の交差判定\n    bool isCrossed_ll(Line l, Line m){\n        return !eq(cross(l.b-l.a, m.b-m.a), 0);\n    }\n    //直線と線分の交差判定\n    bool isCrossed_ls(Line l, Line s){\n        return isCrossed_ll(l, s) && \n            cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps;\n    }\n    //線分と線分の交差判定\n    bool isCrossed_ss(Line s, Line t){\n        return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n            ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n    }\n    //点が直線上にあるか\n    bool isON_l(Line l, Point p){\n        return abs(cross(l.b-p, l.a-p)) < eps;\n    }\n    //点が線分上にあるか\n    bool isON_s(Line s, Point p){\n        return abs(s.a-p)+abs(s.b-p)-abs(s.b-s.a) < eps;\n    }\n\n    //点から直線への垂線の足\n    Point foot(Line l, Point p){\n        ld t = dot(p-l.a,l.a-l.b)/norm(l.a-l.b);\n        return l.a+t*(l.a-l.b);\n    }\n    //直線と直線の交点\n    Point intersection_ll(Line l, Line m){\n        Point lv=l.b-l.a, mv=m.b-m.a;\n        assert(cross(lv,mv)!=0);//平行\n        return l.a+lv*cross(mv,m.a-l.a)/cross(mv,lv);\n    }\n    //線分と線分の交点\n    Point intersection_ss(Line s, Line t){\n        assert(isCrossed_ll(s, t));\n        return intersection_ll(s,t);\n    }\n    //点と点の距離\n    ld dist_pp(Point p, Point q){\n        ld x=p.real()-q.real(), y=p.imag()-q.imag();\n        return sqrt(x*x+y*y);\n    }\n    //点と直線の距離\n    ld dist_lp(Line l, Point p) {\n        return abs(p - foot(l, p));\n    }\n    //直線と直線の距離\n    ld dist_ll(Line l, Line m){\n        return isCrossed_ll(l, m)?0:dist_lp(l, m.a);\n    }\n    //直線と線分の距離\n    ld dist_ls(Line l, Line s){\n        return isCrossed_ls(l, s)?0:min(dist_lp(l, s.a), dist_lp(l, s.b));\n    }\n    //線分と点の距離\n    ld dist_sp (Line s, Point p) {\n        Point r = foot(s, p);\n        return isON_s(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n    }\n    //線分と線分の距離\n    ld dist_ss (Line s, Line t) {\n        if (isCrossed_ss(s, t)) return 0;\n        return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n    }\n    //円と円の交点\n    vector<Point>intersection_cc(Circle c1, Circle c2){\n        vector<Point> res;\n        ld d = abs(c1.p - c2.p);\n        ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n        ld dfr = c1.r * c1.r - rc * rc;\n        if (abs(dfr) < eps) dfr = 0.0;\n        else if (dfr < 0.0) return res;\n        ld rs = sqrt(dfr);\n        Point diff = (c2.p - c1.p) / d;\n        res.push_back(c1.p + diff * Point(rc, rs));\n        if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n        return res;\n    }\n};\n\nint main(){\n    int n;\n    using namespace Geometry;\n    while(cin>>n,n){\n        vector<Point>g(n);\n        vector<Circle>Cs(n);\n        for(int i=0;i<n;++i){\n            g[i]=inputPoint();\n            Cs[i]={g[i],1.0};\n        }\n        int ans=0;\n        for(int i=0;i<n;++i){\n            for(int j=i+1;j<n;++j){\n                vector<Point>intersections(intersection_cc(Cs[i],Cs[j]));\n                for(auto intersection:intersections){\n                    int ret=0;\n                    for(int k=0;k<n;++k){\n                        if(dist_pp(intersection,g[k]) < 1.0){\n                            if(i == k || j==k)continue;\n                            ++ret;\n                        }\n                    }\n                    ans=max(ans,ret+2);\n                }\n            }\n        }\n        cout<<ans<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\nstruct makehtml{\n\tvector<string> ss;\n\t\n\tmakehtml(){}\n\t/*\n\tctx.beginPath()\n\tctx.moveTo(50.000000,100.000000);\n\tctx.lineTo(150.000000,100.000000);\n\tctx.stroke();\n\t\n\tctx.fillStyle = \"rgb(0,0,0)\";\n\t\n\tctx.beginPath();\n\tctx.arc(168,59,3,0,360);\n\tctx.fill();\n\n\t*/\n\t\n\tvoid out(const char* name,double mag){\n\t\tchar fname[100];\n\t\tsprintf(fname,\"%s.html\",name);\n\t\tFILE* fp = fopen(fname,\"w\");\n\t\tif(fp==NULL){\n\t\t\teprintf(\"can't open %s\\b\",fname);\n\t\t\texit(-1);\n\t\t}\n\t\tfprintf(fp,\"<html>\\n<head>\\n<title>\");\n\t\tfprintf(fp,\"%s\",name);\n\t\tfprintf(fp,\"</title>\\n</head>\\n<body>\\n\");\n\t\tfprintf(fp,\"<p>name: %s</p>\",name);\n\t\tfprintf(fp,\"<canvas id=\\\"vis\\\" width=\\\"%d\\\" height=\\\"%d\\\"></canvas>\",2000,2000);\n\t\tfprintf(fp,\"<script>\\n\");\n\t\tfprintf(fp,\"var vis = document.getElementById('vis');\\nvar ctx = vis.getContext('2d');\\n\");\n\t\t\n\t\trep(i,ss.size()){\n\t\t\tfprintf(fp,\"%s\\n\",ss[i].c_str());\n\t\t}\n\t\t\n\t\tfprintf(fp,\"</script>\\n\");\n\t\tfprintf(fp,\"</body>\\n</html>\\n\");\n\t\tfclose(fp);\n\t}\n\n} makehtml_instance;\n\n\nvoid addhtml(string s){\n\tmakehtml_instance.ss.push_back(s);\n}\n\nvoid outhtml(string s,double mag){\n\tmakehtml_instance.out(s.c_str(),mag);\n}\n\nvoid randcolhtml(){\n\tchar ns[100];\n\tsprintf(ns,\"ctx.fillStyle = \\\"rgb(%d,%d,%d)\\\";\",rand()%128,rand()%128,rand()%128);\n\taddhtml(ns);\n\tsprintf(ns,\"ctx.strokeStyle = \\\"rgb(%d,%d,%d)\\\";\",rand()%128,rand()%128,rand()%128);\n\taddhtml(ns);\n}\n\nvoid inithtml(){\n\tmakehtml_instance.ss.clear();\n}\n\n\nconst double pi=3.14159265358979;\n\nstruct pos{\n\tdouble x,y;\n\tdouble norm,norm2;\n\tpos tov(pos a){\n\t\treturn (a-(*this));\n\t}\n\tpos operator+(pos a)const{\n\t\tpos res=a;\n\t\tres.x+=x; res.y+=y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos operator-(pos a)const{\n\t\tpos res=(*this);\n\t\tres.x-=a.x; res.y-=a.y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos scalar(double a){\n\t\tpos res=(*this);\n\t\tres.x*=a; res.y*=a;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tdouble dot(pos a){\n\t\treturn x*a.x + y*a.y;\n\t}\n\tdouble cross(pos a){\n\t\treturn x*a.y - y*a.x;\n\t}\n\tdouble theta(pos a){\n\t\tdouble nt=dot(a)/(norm*a.norm);\n\t\tnt=acos(max(-1.0,min(1.0,nt)));\n\t\tdouble ns=(cross(a)/(norm*a.norm));\n\t\tif(ns<0)nt*=-1;\n\t\treturn nt;\n\t}\n\tpos(double ix,double iy){\n\t\tx=ix; y=iy;\n\t\tnorm2=x*x+y*y;\n\t\tnorm=sqrt(norm2);\n\t}\n\tpos(){}\n\tstring str(){\n\t\tchar ns[50];\n\t\tsprintf(ns,\"(%lf %lf)\",x,y);\n\t\treturn\tstring(ns);\n\t}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\"); \n\t\tsprintf(ns,\"ctx.arc(%lf,%lf,%lf,0,360);\",x*mag,y*mag,5.0); addhtml(ns);\n\t\taddhtml(\"ctx.fill();\");\n\t}\n\tstatic pos polar(double r,double t){\n\t\treturn pos(r*cos(t),r*sin(t));\n\t}\n\tpos turn(double t){\n\t\t//t[rad]??????\n\t\treturn pos(x*cos(t)-y*sin(t),x*sin(t)+y*cos(t));\n\t}\n\tpos tolen(double a){\n\t\t//?????????a?????????\n\t\treturn this->scalar(a/norm);\n\t}\n\tbool  operator<(pos a) const{\n\t\t//if(x!=a.x)return (x<a.x);\n\t\t//return (y<a.y);\n\t\tif(y!=a.y)return (y<a.y);\n\t\treturn (x<a.x);\n\t}\t\n\tbool operator>(pos a)const{ return (a<(*this)); }\t\n};\nstruct line{\n\tpos p,q;\n\tpos vec;\n\tstring str(){\n\t\treturn (\"(\"+p.str()+\"-\"+q.str()+\")\");\n\t}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\");\n\t\tsprintf(ns,\"ctx.moveTo(%lf,%lf);\",p.x*mag,p.y*mag); addhtml(ns);\n\t\tsprintf(ns,\"ctx.lineTo(%lf,%lf);\",q.x*mag,q.y*mag); addhtml(ns);\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\tbool iscross(line a){\n\t\tdouble da,db;\n\t\tda=vec.cross( p.tov(a.p) );\n\t\tdb=vec.cross( p.tov(a.q) );\n\t\tif(da*db>=0)return false;\n\t\tda=a.vec.cross( a.p.tov(p) );\n\t\tdb=a.vec.cross( a.p.tov(q) );\n\t\treturn (da*db<0);\n\t}\n\tline(pos ip,pos iq){\n\t\tp=ip; q=iq;\n\t\tvec=p.tov(q);\n\t}\n\tline(){}\n\tdouble dist(pos a){\n\t\tif(p.tov(a).dot( p.tov(q) )<0)return p.tov(a).norm;\n\t\tif(q.tov(a).dot( q.tov(p) )<0)return q.tov(a).norm;\n\t\treturn abs(vec.cross(p.tov(a))/vec.norm);\n\t}\n\tdouble dist(line a){\n\t\tif(iscross(a))return 0;\n\t\treturn min( min(dist(a.p),dist(a.q)) , min(a.dist(this->p),a.dist(this->q)));\n\t}\n\tpos crosspos(line a){\n\t\t/*\n\t\tdouble d1=a.vec.cross(a.p.tov(p))/a.vec.norm;\n\t\tdouble d2=a.vec.cross(a.p.tov(q))/a.vec.norm;\n\t\tbool isc=(d1*d2<0);\n\t\td1=abs(d1); d2=abs(d2);\n\t\tdouble sc;\n\t\tif(!isc){\n\t\t\tif(d1>d2)sc = d1/(d1-d2);\n\t\t\telse sc=d1/(d2-d1);\n\t\t}\n\t\telse sc = d1/(d1+d2);\n\t\treturn (p+vec.scalar(sc));*/\n\t\t\n\t\tdouble t = a.vec.cross(a.p-p)/a.vec.cross(vec);\n\t\treturn (p+vec.scalar(t));\n\t}\n\tline bisection(){//?????´????????????\n\t\t//???????¨??????????90????????£???????????????\n\t\tpos fr=(p+q).scalar(0.5);\n\t\tpos to=fr+pos(-vec.y,vec.x);\n\t\treturn line(fr,to);\n\t}\n};\n\n\nint n;\nint main(void){\n\tfor(;;){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tvector<pos> ps;\n\t\trep(i,n){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf%lf\",&x,&y);\n\t\t\tps.push_back(pos(x,y));\n\t\t}\n\t\t\n\t\tvector<pos> cs;\n\t\trep(i,n){\n\t\t\trep(j,i){\n\t\t\t\tline nl(ps[i],ps[j]);\n\t\t\t\tdouble d = nl.vec.norm;\n\t\t\t\tif(d>2.0)continue;\n\t\t\t\tpos av = nl.bisection().vec.tolen(sqrt(1.0-(d/2.0)*(d/2.0)));\n\t\t\t\tpos m=(ps[i]+ps[j]).scalar(0.5);\n\t\t\t\tcs.push_back(m+av);\n\t\t\t\tcs.push_back(m-av);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=1;\n\t\trep(i,cs.size()){\n\t\t\tint ns=0;\n\t\t\trep(j,ps.size()){\n\t\t\t\tif((cs[i]-ps[j]).norm<=1.0+1e-6)ns++;\n\t\t\t}\n\t\t\tans=max(ans,ns);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<limits>\n#include<iomanip>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\n\n\n\ntypedef pair<double,double> Point;\n#define F first\n#define S second\n#define MK make_pair\n#define equal abs(a-b)<=1e-8\n\nPoint pls(Point a,Point b){\n    return MK(a.F+b.F,a.S+b.S);\n}\n\nPoint mns(Point a,Point b){\n    return MK(a.F-b.F,a.S-b.S);\n}\n\nPoint T(Point t){\n    return MK(t.S,-1.0*t.F);\n}\n\ndouble abs(Point a){\n    return sqrt(a.F*a.F+a.S*a.S);\n}\n\ndouble norm(Point a){\n    return a.F*a.F+a.S*a.S;\n}\n\nPoint mid(Point a,Point b){\n    return MK((a.F+b.F)/2,(a.S+b.S)/2);\n}\n\nbool in(Point c,Point t){\n    if(norm(mns(t,c))<=1){return true;}\n    return false;\n}\n\n\nint main(){\n    while(1){\n        int n;\n        cin>>n;\n        if(n==0){break;}\n        vector<Point> vp;\n        int mx=0;\n        for(int i=0;i<n;i++){\n            double a,b;\n            cin>>a>>b;\n            vp.push_back(MK(a,b));\n        }\n        sort(vp.begin(),vp.end());\n        for(int i=0;i<vp.size();i++){\n            for(int t=i+1;t<vp.size() && vp[t].F-vp[i].F<=2;t++){\n                if(abs(mns(vp[t],vp[i]))>2){continue;}\n                Point m=mid(vp[i],vp[t]);\n                Point l=mns(vp[t],vp[i]);\n                Point lt=T(l);\n                double h=sqrt(1-abs(l)*abs(l)/4.0);\n                lt.F=h*lt.F/abs(l);\n                lt.S=h*lt.S/abs(l);\n                Point c=pls(m,lt);\n                int count=2;\n                for(int k=0;k<vp.size();k++){\n                    if(k!=i && k!=t && in(c,vp[k])){count++;}\n                }\n                mx=max(mx,count);\n                c=mns(m,lt);\n                count=2;\n                for(int k=0;k<vp.size();k++){\n                    if(k!=i && k!=t && in(c,vp[k])){count++;}\n                }\n                mx=max(mx,count);\n            }\n        }\n        cout<<mx<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\nstruct Point{double x,y;};\ndouble dist(Point a,Point b) {return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));}\n\nint main(void){\n    int N;\n    while(cin>>N,N){\n        vector<Point> p(N);\n        int maxcnt=1;\n        rep(i,N)cin>>p[i].x>>p[i].y;\n        rep(i,N){\n            for(int j=i+1;j<N;j++){\n                double d = dist(p[i],p[j]);\n                if(d>2.0)continue;\n                int sign[]={-1,1};\n                rep(s,2){\n                    Point C;\n                    C.x = p[i].x + cos(atan2(p[j].y-p[i].y,p[j].x-p[i].x) + sign[s]*acos(d/2.0));\n                    C.y = p[i].y + sin(atan2(p[j].y-p[i].y,p[j].x-p[i].x) + sign[s]*acos(d/2.0));\n                    int cnt=0;\n                    rep(k,N) cnt += (pow(C.x-p[k].x,2) + pow(C.y-p[k].y,2) <= 1.0);\n                    if(maxcnt<cnt)maxcnt=cnt;\n                }\n            }\n        }\n        cout<<maxcnt<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,N) for(int i=0;i<(int)(N);i++)\n#define REP(i,k,N) for(int i=k;i<(int)(N);i++)\n\n#define vi vector<int>\n#define pb push_back\n\n#define pdd pair<double,double>\n#define fi first\n#define se second\nconst double  EPS = 1e-8;\n\ndouble dist(double x,double y){\n    return x*x+y*y;\n};\n\nint main(){\n\n    int n;\n    while(cin >> n,n){\n        int ma = 0;\n        pdd p[330];\n        rep(i,n) cin >> p[i].fi >> p[i].se;\n        rep(i,n-1){\n            REP(j,i+1,n){\n                int cnt1 = 0,cnt2=0;\n                double x1,y1,x2,y2,x3,y3;\n                tie(x1,y1) = p[i];\n                tie(x2,y2) = p[j];\n                double cx1,cy1,cx2,cy2;\n                if(dist(x1-x2,y1-y2)  > 4+EPS  ) continue;\n\n                //はりまコーナー\n//                double ax,ay,bx1,by1,bx2,by2,mx,my,dx,dy;\n//                ax=x1-x2;ay=y1-y2;\n//                mx=(x1+x2)/2;my=(y1+y2)/2;\n//                by1 = (-0.5)*pow(ax,4)+pow(ax,2)+(-0.5)*pow(ax,2)*pow(ay,2)\n//                        /dist(ax,ay);\n//                by1 = sqrt(abs(by1));\n//                by2 = -1*by1;\n//                cy1= my+by1;\n//                cy2= my+by2;\n//                bx1= -1*(ay*by1)/ax;\n//                bx2= -1*(ay*by2)/ax;\n//                cx1=bx1+mx;\n//                cx2=bx2+mx;\n\n\n                //あじのりコーナー\n                double mx=(x1+x2)/2,my=(y1+y2)/2;\n\n                double ld = 1-dist((x1-x2),(y1-y2))/4;\n                ld = sqrt(ld);\n                double theta = atan((y2-y1)/(x2-x1));\n                cx1 = mx - sin(theta)*ld;\n                cy1 = my + cos(theta)*ld;\n                cx2 = mx + sin(theta)*ld;\n                cy2 = my - cos(theta)*ld;\n\n                for(int k = 0;k<n;k++) {\n                    tie(x3, y3) = p[k];\n                    if (EPS + 1> dist((cx1 - x3), (cy1 - y3))) cnt1++;\n                    if (EPS + 1> dist((cx2 - x3), (cy2 - y3))) cnt2++;\n                }\n                ma = max({cnt1,cnt2,ma});\n            }\n        }\n        cout<< ma << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<double> x(n), y(n);\n\t\tint ans = -1;\n\t\tREP(i, n)cin >> x[i] >> y[i];\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tdouble ax = x[j] - x[i], ay = y[j] - y[i];\n\t\t\t\tif (ax*ax + ay*ay+EPS > 4)continue;\n\t\t\t\tdouble px = x[i] + ax / 2 + sqrt((4 - (ax*ax + ay*ay)) / (4 * (ax*ax + ay*ay)))*ay,\n\t\t\t\tpy = y[i] + ay / 2 - sqrt((4 - (ax*ax + ay*ay)) / (4 * (ax*ax + ay*ay)))*ax;\n\t\t\t\tint cnt = 0;\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tif ((x[k] - px)*(x[k] - px) + (y[k] - py)*(y[k] - py) < 1+EPS)cnt++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, cnt);\n\t\t\t}\n\t\t}\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tdouble ax = x[j] - x[i], ay = y[j] - y[i];\n\t\t\t\tif (ax*ax + ay*ay+EPS > 4)continue;\n\t\t\t\tdouble px = x[i] + ax / 2 - sqrt((4 - (ax*ax + ay*ay)) / (4 * (ax*ax + ay*ay)))*ay,\n\t\t\t\t\tpy = y[i] + ay / 2 + sqrt((4 - (ax*ax + ay*ay)) / (4 * (ax*ax + ay*ay)))*ax;\n\t\t\t\tint cnt = 0;\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tif ((x[k] - px)*(x[k] - px) + (y[k] - py)*(y[k] - py) < 1+EPS)cnt++;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tans = max(ans, cnt);\n\t\t\t}\n\t\t}\n\t\tcout <<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> p;\nconst double eps = 1e-9;\n\nint n;\np ps[300];\n\nint main() {\n\twhile (cin >> n , n != 0) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tps[i] = p(x, y);\n\t\t}\n\n\t\tif (n == 1) {\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (!(norm(ps[i] - ps[j]) < 1.0 + eps)) continue;\n\t\t\t\tp v = ps[i] - ps[j], ve = v / abs(v);\n\t\t\t\tdouble l = sqrt(1 - norm(v) * 0.25);\n\t\t\t\tp vn1 = ve * p(0, 1) * l, vn2 = ve * p(0, -1) * l;\n\t\t\t\tp c1 = ps[j] + v * 0.5 + vn1, c2 = ps[j] + v * 0.5 + vn2;\n\t\t\t\tint count1 = 2, count2 = 2;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (k == i || k == j) continue;\n\t\t\t\t\tif (norm(c1 - ps[k]) < 1.0 + eps) count1++;\n\t\t\t\t\tif (norm(c2 - ps[k]) < 1.0 + eps) count2++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, count1);\n\t\t\t\tans = max(ans, count2);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\nusing P = complex<ld>;\nconst ld eps = 1e-10;\n\nint main()\n{\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<ld> x(N), y(N);\n\t\tvector<P> p(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tp[i] = P(x[i], y[i]);\n\t\t}\n\t\tvector<P> ko;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tif (norm(p[i] - p[j]) < 4.0 + eps) {\n\t\t\t\t\tauto d = p[i] - p[j];\n\t\t\t\t\tko.push_back(p[j] + (d * (ld)0.5) + d * P(0, 1) / abs(d) * sqrtl(1 - norm(d * (ld)0.5)));\n\t\t\t\t\tko.push_back(p[j] + (d * (ld)0.5) - d * P(0, 1) / abs(d) * sqrtl(1 - norm(d * (ld)0.5)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor (auto c : ko) {\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (norm(c - p[i]) < 1.0001 + eps) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = max(res, cnt);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nint INF=1e9;\nint MOD=1000000007;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ndouble EPS = 1e-10;\ndouble add(double a,double b){\n\tif(abs(a+b)<EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,p.x),add(y,-p.y));\n\t}\n\tP operator * (P p){\n\t\treturn P(x*p.x,y*p.y);\n\t}\n};\ndouble dist(P a,P b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\nint cnt(P pos,vector<P> dat){\n\tint res=0;\n\tREP(i,dat.size()){\n\t\tif(dist(pos,dat[i])<=1.0)res++;\n\t}\n\treturn res;\n}\nint main(){\n\tint n;\n\tdouble x,y;\n\twhile(scanf(\"%d\",&n)&&n){\n\t\tvector<P> dat;\n\t\tREP(i,n){\n\t\t\tcin>>x>>y;\n\t\t\tdat.PB(P(x,y));\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tP a=dat[i],b=dat[j];\n\t\t\t\tP mid=P((a.x+b.x)/2,(a.y+b.y)/2);\n\t\t\t\tdouble dx=a.y-b.y,dy=b.x-a.x;\n\t\t\t\tdouble dd=sqrt(dx*dx+dy*dy);\n\t\t\t\tdouble ddd=sqrt(1-dist(a,b)/2*dist(a,b)/2);\n\t\t\t\tdx=dx/dd*ddd;dy=dy/dd*ddd;\n\t\t\t\tans=max(ans,cnt(P(mid.x+dx,mid.y+dy),dat));\n\t\t\t\tans=max(ans,cnt(P(mid.x-dx,mid.y-dy),dat));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tG g(n);\n\t\trep(i,n)g[i]=pin();\n\t\tint out=0;\n\t\trep(i,n)rep(j,i)if(abs(g[i]-g[j])<2+EPS){\n\t\t\tdouble dis=abs(g[i]-g[j]);\n\t\t\tdouble c=atan(sqrt(4/dis/dis-1));\n\t\t\tP tur=g[j]-g[i];\n\t\t\ttur/=abs(tur);\n\t\t\tP p=g[i]+turn2(tur,c);\n\t\t\tint co=0;\n\t\t\trep(k,n)if(abs(p-g[k])<1+EPS)co++;\n\t\t\tout=max(out,co);\n\t\t\tco=0;\n\t\t\tp=g[i]+turn2(tur,-c);\n\t\t\trep(k,n)if(abs(p-g[k])<1+EPS)co++;\n\t\t\tout=max(out,co);\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nint main(){\n    while(true){\n        int N;\n        cin >> N;\n        if(N == 0) break;\n        vector<point> P(N);\n        for(int i=0;i<N;i++){\n            cin >> P[i].real() >> P[i].imag();\n        }\n\n        int ret = 1;\n\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                if(i == j) continue;\n                point p1 = P[i];\n                point p2 = P[j];\n\n                if(abs(p1-p2) <= 2.0+EPS){\n                    point d = p1 - p2;\n                    point m = (p1+p2)/(point(2,0));\n\n                    point nor = d * point(0,1);\n                    nor /= abs(nor);\n                    nor *= point(sqrt(1-(abs(d)/2)*(abs(d)/2)),0);\n\n                    point p = m + nor;\n                    int cnt = 0;\n                    for(int k=0;k<N;k++){\n                        if(abs(P[k]-p) <= 1+EPS) cnt++;\n                    }\n                    ret = max(ret,cnt);\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<math.h>\n\nusing namespace std;\ntypedef pair<double, double> P;\n\nint N;\ndouble X[300], Y[300];\nP d[300];\n\nP add(P p1, P p2) {\n  return P(p1.first + p2.first, p1.second + p2.second);\n}\n\nP minas(P p1, P p2) {\n  return P(p1.first - p2.first, p1.second - p2.second);\n}\n\nP mul(P p, double c) {\n  return P(p.first * c, p.second * c);\n}\n\nP ave(P p1, P p2) {\n  return P((p1.first + p2.first) / 2, (p1.second + p2.second) / 2);\n}\n\nvoid printP(P p) {\n  printf(\"P:(%f, %f)\\n\", p.first, p.second);\n}\n\ndouble square(P p) {\n  return p.first * p.first + p.second * p.second;\n}\n\ndouble size(P p) {\n  return sqrt(square(p));\n}\n\nint count(P p) {\n  // printP(p);\n  int counter = 0;\n  for (int i = 0; i < N; i++) {\n    if (square(minas(p, d[i])) <= 1.0001) counter++;\n  }\n  // printf(\"%d\\n\",counter);\n  return counter;\n}\n\nint check(int i, int j) {\n  if (square(minas(d[i], d[j])) > 4.0) return 0;\n  int ans = 0;\n  P average = ave(d[i], d[j]);\n  P dir = mul(minas(d[i], d[j]), 0.5);\n  // printP(average);\n  double s = sqrt(1.0 - square(dir));\n  // printf(\"!!!!!!%f\\n\",s);\n  P dir1 = P((Y[i] - Y[j]), - (X[i] - X[j]));\n  //printf(\"!!!!!!%f\\n\",size(dir1));\n  double r = s / size(dir1);\n  P d1 = add(average, mul(dir1, r));\n  P d2 = add(average, mul(dir1, -r));\n  return max(count(d1), count(d2));\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &N);\n    if (N == 0) break;\n    for (int i = 0; i < N; i++) scanf(\"%lf%lf\", &X[i], &Y[i]), d[i] = P(X[i], Y[i]);\n    int ans = 0;\n    for (int i = 0; i < N; i++)\n      for (int j = 0; j < i; j++)\n        ans = max(ans, check(i, j));\n    printf(\"%d\\n\", ans);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <bitset>\n#include <iostream>\n#include <iomanip>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <deque>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e16;\n\n/*\n<url:>\n問題文============================================================\n\n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\ntypedef pair<double,double> Point;\nconst double eps = 1e-9;\nPoint P[305];\n\ninline double Abs(const Point& p1,const Point& p2){\n    return sqrt((p1.first - p2.first)*(p1.first - p2.first) + (p1.second - p2.second)*(p1.second - p2.second));\n}\nint main(void) {\n//\tcin.tie(0); ios::sync_with_stdio(false);\n    int N;\n    while(true){\n        scanf(\"%d\",&N);\n        if(N == 0) break;\n        for(int i = 0; i < N;i++){\n            double x,y; scanf(\"%lf%lf\",&x,&y);\n            P[i] = Point(x,y);\n        }\n        if(N == 1){\n            printf(\"1\\n\");\n            continue;\n        }\n        int ans = 1;\n        for(int i = 0; i < N;i++){\n            for(int j = i + 1; j < N;j++){\n                double dist = Abs(P[i],P[j]);\n                if(dist > 2) continue;\n                double r = sqrt(1 - dist*dist/4);\n                Point cp = make_pair(-(P[i].second - P[j].second)*r/dist + (P[i].first + P[j].first)/2.0,\n                                     (P[i].first - P[j].first)*r/dist + (P[i].second + P[j].second)/2.0);\n                int cnt = 0;\n                for(int k = 0; k < N;k++){\n                    if(Abs(cp,P[k]) < 1.0 + eps) cnt++;\n                }\n                ans = max(ans,cnt);\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define X first\n#define Y second\n\nusing P=pair<double, double>;\n\nconst double EPS = 1e-14;\n\ndouble dist(P a, P b) {\n\tdouble dx = a.X - b.X;\n\tdouble dy = a.Y - b.Y;\n\treturn sqrt(dx*dx+dy*dy);\n}\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tvector<P> p(n), pl;\n\t\tfor(int i = 0; i < n; i++) cin >> p[i].X >> p[i].Y;\n\t\tfor(int i = 0; i < p.size(); i++) {\n\t\t\tP p1 = p[i];\n\t\t\tfor(int j = 0; j < p.size(); j++) {\n\t\t\t\tif(i==j) continue;\n\t\t\t\tP p2 = p[j];\n\t\t\t\tif(dist(p1, p2)+EPS > 2) continue;\n\n\t\t\t\tdouble dxy = dist(p1, p2);\n\t\t\t\tdouble l = sqrt(1-(dxy/2));\n\t\t\t\tdouble cx = (p1.X+p2.X)/2;\n\t\t\t\tdouble cy = (p1.Y+p2.Y)/2;\n\t\t\t\tdouble dx = (p2.X - p1.X);\n\t\t\t\tdouble dy = (p2.Y - p1.Y);\n\n\t\t\t\tdouble dlx = l/sqrt(dx*dx+dy*dy) * -dy;\n\t\t\t\tdouble dly = l/sqrt(dx*dx+dy*dy) * dx;\n\n\t\t\t\tpl.push_back(P(cx+dlx, cy+dly));\n\t\t\t\tpl.push_back(P(cx-dlx, cy-dly));\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(P p1:pl) {\n\t\t\tint tmp = 0;\n\t\t\tfor(P p2:p) {\n\t\t\t\tif(dist(p1, p2)+EPS <= 1) tmp++;\n\t\t\t}\n\t\t\tres = max(res, tmp);\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\ntypedef double ld;\n\nstruct Point {\n    ld x, y;\n    Point(ld x, ld y) : x(x), y(y) {}\n    string to_s() {\n        ostringstream os;\n        os << x << ',' << y;\n        return os.str();\n    }\n    Point operator+(const Point& o) const {\n        return Point(x+o.x, y+o.y);\n    }\n    Point operator/(const int d) const {\n        return Point(x/d, y/d);\n    }\n};\n\nstruct Circle {\n    ld x, y;\n    ld r;\n    Circle(ld x=0, ld y=0, ld r=1) : x(x), y(y), r(r) {}\n    const static ld eps = 1e-8;\n    bool isIntersect(const Circle& o) const {\n        ld dx = o.x - x;\n        ld dy = o.y - y;\n        return (r + o.r) * (r + o.r) > (dx*dx + dy*dy);\n    }\n    pair<Point, Point> intersectionPoint(const Circle& o) const {\n        ld dx = o.x - x;\n        ld dy = o.y - y;\n        ld d = sqrt(dx*dx + dy*dy);\n\n        ld slope = dy / dx;\n        ld theta = atan(slope);\n        ld theta_p = acos((r*r - o.r*o.r + d*d) / (2*r*d));\n\n        return make_pair(\n                Point(x + r*cos(theta - theta_p), y + r*sin(theta - theta_p)),\n                Point(x + r*cos(theta + theta_p), y + r*sin(theta + theta_p)));\n    }\n    bool contains(ld px, ld py) const {\n        return r * r + eps > (px - x) * (px - x) + (py - y) * (py - y);\n    }\n    string to_s() {\n        ostringstream os;\n        os << x << ',' << y << ':' << r << endl;\n        return os.str();\n    }\n};\n\nint countContainingPoints(const Circle& c, const vector<Circle>& ps) {\n    int cnt = 0;\n    for (int i = 0; i < ps.size(); i++) \n        if (c.contains(ps[i].x, ps[i].y)) \n            cnt++;\n    return cnt;\n}\n\nPoint midPoint(pair<Point, Point>& pp) {\n    return (pp.first + pp.second) / 2;\n}\n\nint N;\nint main() {\n    vector<Circle> cs;\n    while (cin >> N, N) {\n        cs.clear(); cs.resize(N);\n        for (int i = 0; i < N; i++) cin >> cs[i].x >> cs[i].y;\n\n        vector<Point> ips; // Intersection PointS\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (i == j) continue;\n                if (!cs[i].isIntersect(cs[j])) continue;\n                pair<Point, Point> ip = cs[i].intersectionPoint(cs[j]);\n                ips.push_back(ip.first);\n                ips.push_back(ip.second);\n                //ips.push_back(midPoint(ip));\n            }\n        }\n\n        int maxPoint = 0;\n        for (int i = 0; i < ips.size(); i++) {\n            maxPoint = max(maxPoint, countContainingPoints(Circle(ips[i].x, ips[i].y, 1), cs));\n        }\n        cout << maxPoint << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\n#define P complex<double>\n#define EPS 1.0e-4\n\nint main(){\n  int n;\n  P p[301];\n  int ans, num;\n\n  while( cin>>n && n ){\n    for( int i=0;i<n;i++ )\n      cin >> p[i].real() >> p[i].imag();\n\n    ans=0;\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ ){\n\tif( i==j )\n\t  continue;\n\tif( abs( p[i]-p[j] )+EPS > 2.0 )\n\t  continue;\n\n\tP m  = (p[i]+p[j]) / 2.0; // p[i]Æp[j]Ì_\n\tP nn = (p[i]-p[j]) * P(0,1);       // @üxNg\n\tnn = nn / abs(nn);\n\n\tdouble x = abs( p[i]-p[j] )/2;\n\tx = sqrt( 1-x*x );\n\tP c = m + x * nn;        // ~ÌS\n\n\tnum=0;\n\tfor( int k=0;k<n;k++ )\n\t  if( abs( c-p[k] ) < 1.0 + EPS  )\n\t    num++;\n\tans = max( ans,num );\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define REP(i,n) for(int i=0;i<n;i++)\nusing P = complex<double>;\nusing vp = vector<P>;\n\nvp points;\nvp cross;\n\nint main()\n{\n  int n;\n  while(cin >> n,n){\n    points.clear();\n    cross.clear();\n\n    REP(i,n){\n      double a,b;\n      cin >> a >> b;\n      points.push_back({a,b});\n\n    }\n    REP(i,n)REP(j,n){\n      P dif = (points[i]-points[j]);\n      if(abs(dif) <= 2){\n        auto veci = P({dif.real()/abs(dif),dif.imag()/abs(dif)});\n        auto semi = P({dif.real()/2,dif.imag()/2});\n\n        cross.push_back(points[j]+semi+P({veci.real()*sqrt(1-abs(semi)*abs(semi)),veci.imag()*sqrt(1-abs(semi)*abs(semi))})*P(0,1));\n        cross.push_back(points[j]+semi+P({veci.real()*sqrt(1-abs(semi)*abs(semi)),veci.imag()*sqrt(1-abs(semi)*abs(semi))})*P(0,-1));\n      }\n    }\n\n    int ma = 0;\n    REP(i,cross.size()){\n      int now = 0;\n      REP(j,n){\n      if(abs(cross[i]-points[j]) <= 1.0001){\n        now++;\n      }\n      ma = max(ma,now);\n      }\n    }\n    cout << max(1,ma) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nconst double pi = acos(-1);\n\nstruct Point{\n    double x, y;\n    \n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(x / a, y / a); }\n\n    double norm() {return x * x + y * y; }\n    double abs() {return sqrt(norm()); }\n\n    bool operator < (const Point &p) const{\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n\n    bool operator == (const Point &p) const{\n        return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n    }\n};\n\ntypedef Point Vector;\n\ndouble norm(Vector a){\n    return a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\n\ndouble arg(Vector p){\n    return atan2(p.y, p.x);\n}\n\nVector polar(double a, double r){\n    return Point(cos(r) * a, sin(r) * a);\n}\n\nint main(){\n    while(1){\n        int n; cin>>n;\n        if(n == 0) return 0;\n        vector<Point> p;\n        for(int i=0; i<n; i++){\n            double x, y; cin>>x>>y;\n            p.emplace_back(x, y);\n        }\n\n        int ans = 1;\n        for(int i=0; i<n; i++){\n            for(int j=i+1; j<n; j++){\n                Point p1 = p[i];\n                Point p2 = p[j];\n\n                double dist = abs(p1 - p2);\n\n                if(2.0 < dist) continue;\n\n                Point mp = {(p1.x + p2.x) / 2, (p1.y + p2.y) / 2};\n\n                double rad = arg(p2 - p1);\n                \n                double rad1 = rad + pi / 2;\n                double rad2 = rad - pi / 2;\n\n                double sideLength = sqrt(1.0 * 1.0 - abs(mp - p1) * abs(mp - p1));\n                \n                Point c1 = mp + polar(sideLength, rad1);\n                int sum = 0;\n                for(int k=0; k<n; k++){\n                    dist = abs(c1 - p[k]);\n                    if(1.0 + EPS < dist) continue;\n                    sum++;\n                }\n\n                ans = max(ans, sum);\n\n                Point c2 = mp + polar(sideLength, rad2);\n                sum = 0;\n                for(int k=0; k<n; k++){\n                    dist = abs(c2 - p[k]);\n                    if(1.0 + EPS < dist) continue;\n                    sum++;\n                }\n\n                ans = max(ans, sum);\n            }\n        }\n\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<utility>\nusing namespace std;\n\ndouble X[310],Y[310];\n\nbool check(double x1, double y1, double x2, double y2){\n    return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2) <= 1.0;\n}\n\nint main(){\n    int N;\n    while(1){\n        cin>>N;\n        if(!N) return 0;\n        for(int i=1;i<=N;++i){\n            cin >>X[i]>>Y[i];\n        }\n\n        int ans = 1;\n        for(int i=1;i<=N;++i){\n            for(int j=i+1;j<=N;++j){\n                double t = (X[i]-X[j])*(X[i]-X[j])+(Y[i]-Y[j])*(Y[i]-Y[j]);\n\n                if(t>=4.) continue;\n\n                double s = sqrt(1./t - 1./4.);\n                double p = (X[i]+X[j])/2., q = (Y[i]+Y[j])/2.;\n\n                double x = p + (Y[j]-Y[i])*s;\n                double y = q - (X[j]-X[i])*s;\n                int cnt = 2;\n                for(int k=1;k<=N;++k){\n                    if(k==i || k==j) continue;\n                    if(check(X[k],Y[k],x,y)) ++cnt;\n                }\n                ans=max(ans,cnt);\n\n                x = p - (Y[j]-Y[i])*s;\n                y = q + (X[j]-X[i])*s;\n                cnt = 2;\n                for(int k=1;k<=N;++k){\n                    if(k==i || k==j) continue;\n                    if(check(X[k],Y[k],x,y)) ++cnt;\n                }\n                ans=max(ans,cnt);\n            }\n        }\n        cout<<ans<<endl;\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-8;\n\nstruct Circle{\n  P c;\n  double r;\n  Circle(P c=P(0,0),double r=0):c(c),r(r){}\n};\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1=c1.r,r2=c2.r,d;\n  P p1=c1.c,p2=c2.c;\n  d=abs(p1-p2);\n  if(d<EPS&&abs(r1-r2)<EPS) return res;\n  if(r1+r2<d-EPS||d+EPS<abs(r1-r2)) return res; \n  double a=(r1*r1-r2*r2+d*d)/(2*d);\n  double h=sqrt(max(r1*r1-a*a,0.0));\n  P tmp1=p1+a/d*(p2-p1);\n  P tmp2=h/d*(p2-p1);\n  if(abs(tmp2)<EPS)res.push_back(tmp1);\n  else{\n    res.push_back(P(real(tmp1)-imag(tmp2),imag(tmp1)+real(tmp2)));\n    res.push_back(P(real(tmp1)+imag(tmp2),imag(tmp1)-real(tmp2)));\n  }\n  return res;\n}\n\ndouble getdistancepp(P a,P b){\n  return sqrt((a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag()));\n}\n\nint main(){\n  int n,ans=0;\n  double a,b;\n  P p[N];\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>a>>b;\n      p[i]=P(a,b);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tCircle c1,c2;\n\tc1.c=p[i];\n\tc2.c=p[j];\n\tc1.r=c2.r=1;\n\tvector<P> r=getIntersectCC(c1,c2);\n\tif(!r.size())continue;\n\tfor(int k=0;k<r.size();k++){\n\t  int cnt=0;\n\t  for(int l=0;l<n;l++)\n\t    if(getdistancepp(r[k],p[l])<=1+EPS)cnt++;\t    \n\t  ans=max(ans,cnt);\n\t}\n      }\n    }\n    if(!ans&&n>=1)ans=1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble distance(pair<double,double> p1,pair<double,double> p2){\n\treturn sqrt((p1.first-p2.first)*(p1.first-p2.first)+(p1.second-p2.second)*(p1.second-p2.second));\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<double> x(n);\n\t\tvector<double> y(n);\n\t\tint res=1;\n\t\tfor(int i=0;i<n;i++) cin>>x[i]>>y[i];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tpair<double,double> midp=make_pair((x[i]+x[j])/2,(y[i]+y[j])/2);\n\t\t\t\tdouble a=-(x[i]-x[j]),b=(y[i]-y[j]);\n\t\t\t\tif(a<0.000001) a=0;\n\t\t\t\tif(b<0.000001) b=0;\n\t\t\t\t//a(x-mid[i].first)+b(y-mid.second)=0\n\t\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\t\tpair<double,double> lef=midp;\n\t\t\t\t\t\tpair<double,double> rig;\n\t\t\t\t\t\tif(k==0) rig=make_pair(-b*1e8+midp.first,a*1e8+midp.second);\n\t\t\t\t\t\tif(k==1) rig=make_pair(b*1e8+midp.first,-a*1e8+midp.second);\n\t\t\t\t\t\twhile(distance(lef,rig)>=0.00000001){\n\t\t\t\t\t\t\t\tpair<double,double> mid=make_pair((lef.first+rig.first)/2,(lef.second+rig.second)/2);\n\t\t\t\t\t\t\t\tif(distance(mid,make_pair(x[i],y[i]))>1){\n\t\t\t\t\t\t\t\t\trig=mid;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tlef=mid;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint count=0;\n\t\t\t\t\t\tfor(int r=0;r<n;r++){\n\t\t\t\t\t\t\tif(distance(make_pair(x[r],y[r]),lef)<1+0.00001){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres=max(res,count);\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout<<res<<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <math.h>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n\nint circle();\n\n\ntypedef pair<double, double> pt;\n\n\n#define x first\n#define y second\n\n\npt points[305];\nint n;\n\n\ndouble dist(pt a, pt b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\n\npt get_circle(pt a, pt b) {\n    pt mid_point = make_pair((a.x + b.x) / 2, (a.y + b.y) / 2);\n    double angle = atan2(a.x - b.x, b.y - a.y);\n    double d = sqrt(1 - (dist(a, mid_point) * dist(b, mid_point)));\n    return make_pair(mid_point.x + d * cos(angle), mid_point.y + d * sin(angle));\n}\n\n\nint get_points_in_circle(pt c) {\n    int num_points = 0;\n    for (int i = 0; i < n; ++i) {\n        if (dist(points[i], c) < 1.0 + 1e-8) {\n            ++num_points;\n        }\n    }\n    return num_points;\n}\n\n\nint circle() {\n    int num_points = 0;\n\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (dist(points[i], points[j]) > 2) continue;\n            pt c1 = get_circle(points[i], points[j]);\n            pt c2 = get_circle(points[j], points[i]);\n            num_points = max(num_points, max(get_points_in_circle(c1), get_points_in_circle(c2)));\n        }\n    }\n\n    return num_points;\n}\n\n\nint main(int argc, char **argv) {\n    ios_base::sync_with_stdio(false); cin.tie(NULL);\n\n    while (cin >> n && n > 0) {\n        for (int i = 0; i < n; ++i) {\n            cin >> points[i].x >> points[i].y;\n        }\n\n        if (n == 1) {\n            cout << \"1\" << endl;\n        } else {\n            cout << circle() << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<complex>\n#include<vector>\n\nusing namespace std;\n\ntypedef complex<double> point;\n\n#define dist2(p1,p2) (real(((p1)-(p2))*conj((p1)-(p2))))\n\n#define mid(p1,p2) ((p1)+(p2))/2.0\n\n#define PI (3.1415926535)\n#define EPS (1e-6)\n\nconst point ang90 = point(0,1.0);\n\nbool test (const point &a,const point &b){\n    return real(a) < real(b);\n}\n\nint main(){\n  int n;\n  point p[300];\n  while(scanf(\"%d\",&n),n){\n    for(int i=0;i<n;i++){\n      double x,y;\n      scanf(\"%lf%lf\",&x,&y);\n      p[i]=point(x,y);\n    }\n    sort(p,p+n,test);\n    int ans=1;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n        if(real(p[j])-real(p[i]) > 2.0+EPS) break;\n        if(dist2(p[i],p[j])>4.0) continue;\n        point tmp = (p[i]-p[j]) * ang90;\n        tmp=(tmp/abs(tmp))*sqrt(1.0-dist2(p[i],p[j])/4.0);\n        point p1 = mid(p[i],p[j]) + tmp;\n        int count=0;\n        double rp=real(p1);\n        bool f=false;\n        for(int k=0;k<n;k++){\n          if(k==i||k==j){\n            count++;\n          }else{\n            if(f||(rp - real(p[k]) > 1.0 + EPS)) continue;\n            f=true;\n            if(real(p[k]) - rp > 1.0 + EPS) break;\n            if(dist2(p1,p[k])<1.0+EPS){\n              count++;\n            }\n          }\n        }\n        ans = max(count,ans);\n        p1 = mid(p[i],p[j]) - tmp;\n        rp=real(p1);\n        count=0;\n        f=false;\n        for(int k=0;k<n;k++){\n          if(k==i||k==j){\n            count++;\n          }else{\n            if(f||(rp - real(p[k]) > 1.0 + EPS)) continue;\n            if(real(p[k]) - rp > 1.0 + EPS) break;\n            if(dist2(p1,p[k])<1.0+EPS){\n              count++;\n            }\n          }\n        }\n        ans = max(count,ans);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define PI 3.141592653589793238\n// sqrtは重い\nusing namespace std;\ntypedef pair<double,double> P;\n\nvoid display(complex<double> a,complex<double> b){\n cout << \"(\" << a.real() <<\",\" << a.imag() <<\")\"<< \" \" <<\"(\"<< b.real() <<\",\" <<b.imag() << \")\" << endl;\n}\n\nint main(){\n  int n,ans;\n  double xin,yin,X;\n  complex<double> m;\n  while(cin >> n && n){\n    ans = 1;\n    complex<double> point[n];\n    for(int i=0;i<n;i++){\n      cin >> xin >> yin;\n      point[i] = complex<double>(xin,yin);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i == j)continue;\n\tcomplex<double> Rr = point[i]-point[j];\n\tif(abs(Rr) <= 2+EPS){\n\n\t  complex<double> UKPC,U,P1,P2;\n\t  UKPC = (point[i]+point[j])*0.5;\n       \n\t  double T = sqrt(1-norm(point[i]-point[j])*0.25);\n\n\t  UKPC = (point[i]+point[j])*0.5;\n\t               /* unit vector(単位べく利ゅ)             *//* T倍に拡大 ９０度回転 */ \n  \t  P1 = UKPC + (point[i]-point[j])/abs(point[i]-point[j])*polar(T,PI/2.0);\n\t  P2 = UKPC + (point[i]-point[j])/abs(point[i]-point[j])*polar(T,-PI/2.0);\n\t  //cout << \"P1 = \" << P1 << \", P2 = \" << P2 << endl;\n\t  int cnt=0;\n\t  complex<double> CalcP;\n\t  double Calc;\n\t  for(int k=0;k<n;k++){\n\t    Calc = abs(P1-point[k]);\n\t    if(Calc < 1.0+EPS){\n\t      cnt++;\n\t    }\n\t  }\t\n\n\t  ans = max(ans,cnt);\n\t  cnt = 0;\n\t  for(int k=0;k<n;k++){\n\t    Calc = abs(P2-point[k]);\n\t    if(fabs(Calc) < 1.0+EPS){\n\t      cnt++;\n\t    }\n\t  }\t\n  \n\t  ans = max(ans,cnt);\n\t  \n\n\t}\n\n      }\n    }\n\n    cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 301\nusing namespace std;\ntypedef complex <double> P;\nconst double EPS = 1e-8;\nP p[N];\nint n;\n\nint cnt(P c){\n  int res=0;\n  for(int i=0;i<n;i++)if(abs(c-p[i])<1+EPS) res++;\n  return res;\n}\n\nP get_C(P a,P b){\n  double x=abs(b-a);\n  if(x>2||a==b) return a;\n  return P(x/2,sqrt(1-x*x/4))*(b-a)/abs(b-a)+a;  \n}\n\n\nint main(){\n  while(1){\n  cin>>n;\n  if(!n)break;\n  double a,b;\n  for(int i=0;i<n;i++)cin>>a>>b,p[i]=P(a,b);\n  \n  int ans=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      ans=max(ans,cnt(get_C(p[i],p[j])));\n  cout <<ans<<endl;  \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        vector<long double> xs(n),ys(n);\n        rep(i,0,n) cin >> xs[i] >> ys[i];\n\n        auto count=[&](const long double x,const long double y){\n            int res=0;\n            rep(i,0,n) if((xs[i]-x)*(xs[i]-x)+(ys[i]-y)*(ys[i]-y)<=1+eps) ++res;\n            return res;\n        };\n\n        int ans=0;\n        rep(i,0,401){\n            const long double y=10.*i/400;\n            rep(j,0,n){\n                const long double tmp=1-(ys[j]-y)*(ys[j]-y);\n                if(tmp<0) continue;\n                const long double x1=xs[j]-sqrtl(tmp),x2=xs[j]+sqrt(tmp);\n                ans=max({ans,count(x1,y),count(x2,y)});\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\nconst double EPS = 1e-8;\ntypedef pair<double, double> pt;\n#define x first\n#define y second\n\npt operator-(pt a, pt b) {\n  return pt(a.x - b.x, a.y - b.y);\n}\n\nbool zero(double x) {\n  return fabs(x) <= EPS;\n}\n\ndouble sq(double a) { return a * a; }\n\ndouble dist(pt p, pt q) {\n  return sqrt(sq(p.x - q.x) + sq(p.y - q.y));\n}\n\npt midpoint(pt p1, pt p2){\n    double midx = (p1.x+p2.x)/2;\n    double midy = (p1.y+p2.y)/2;\n    return make_pair(midx, midy);\n}\n\nint get_max_points(pt centre, vector<pt> points){\n\n    int count = 0;\n    for (int i = 0; i < points.size(); i++){\n        pt current = points[i];\n        double num = sq(current.x - centre.x) + sq(current.y - centre.y);\n        // cout << num << endl;\n        // cout << fabs(num - 1) << endl;\n        if (sqrt(num) < 1+EPS) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint find_max_points(vector<pt> points){\n    // for every pair of two points, create a cricle and check num points in circle\n\n    int max_points = 0;\n    for (int i = 0; i < points.size(); ++i){\n        pt p1 = points[i];\n        for (int j = i+1; j < points.size(); ++j){\n            pt p2 = points[j];\n\n            pt mid = midpoint(p1, p2);\n            double q = dist(p1, p2);\n\n            double x1 = mid.x + sqrt(1-sq(q/2))*(p1.y-p2.y)/q;\n            double y1 = mid.y + sqrt(1-sq(q/2))*(p2.x-p1.x)/q;\n            pt c1(x1, y1);\n            int m = get_max_points(c1, points);\n            max_points = max(m, max_points);\n            // cout << mid.x << \" \" << mid.y << endl;\n            // int m = get_max_points(mid, points);\n            double x2 = mid.x - sqrt(1-sq(q/2))*(p1.y-p2.y)/q;\n            double y2 = mid.y - sqrt(1-sq(q/2))*(p2.x-p1.x)/q;\n            pt c2(x1, x2);\n            m = get_max_points(c2, points);\n\n            max_points = max(max_points, m);\n        }\n    }\n    // cout << max_points \n    return max_points;\n}\n\nint main(){\n\n    int n;\n\n    while (1){\n        cin >> n;\n        if (n == 0) break;\n        vector<pt> points;\n        for (int i = 0; i < n; ++i){\n            double x, y;\n            cin >> x >> y;\n            points.push_back(make_pair(x, y));\n        }\n        cout << find_max_points(points) << endl;\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\n#define eps (1e-10)\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double x,double y):x(x),y(y){}\n    Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n    Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n    Point operator*(Point p) {return Point(x*p.x-y*p.y,x*p.y+y*p.x);}\n    Point operator*(double k){return Point(x*k,y*k);}\n    double norm(){return x*x+y*y;}\n    double abs(){return sqrt(norm());}\n    bool operator == (const Point &p) const{return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n    double arg(){return atan2(y,x);}\n    double dot(Point p){return x*p.x+y*p.y;}\n    double det(Point p){return x*p.y-y*p.x;}\n};\nbool cmp_x(const Point& p,const Point& q){\n  if(p.x!=q.x) return p.x<q.x;\n  return p.y<q.y;\n}\nstruct Circle{\n    double r;\n    Point p;\n    Circle(){}\n    Circle(Point p,double r):p(p),r(r){}\n};\nbool isIntersectCC(Circle c1,Circle c2){\n    return (c1.p-c2.p).abs()<=c1.r+c2.r+eps;\n}\npair<Point,Point> CrossPointsCC(Circle c1,Circle c2){\n    assert(isIntersectCC(c1,c2));\n    double d=(c1.p-c2.p).abs();\n    double k=acos((d*d+c1.r*c1.r-c2.r*c2.r)/(c1.r*d*2));\n    return make_pair(c1.p+(c2.p-c1.p)*Point(cos(k),sin(k))*(c1.r/d),c1.p+(c2.p-c1.p)*Point(cos(-k),sin(-k))*(c1.r/d));\n}\nPoint p[301];\nint main(){\n    int n;\n    double x,y;\n    while(cin>>n,n){\n        rep(i,n){\n            cin>>x>>y;\n            p[i]=Point(x,y);\n        }\n        int mx=1;\n        rep(i,n)FOR(j,i+1,n){\n            if((p[i]-p[j]).abs()>2) continue;\n            pair<Point,Point> pp=CrossPointsCC(Circle(p[i],1.0),Circle(p[j],1.0));\n            int cnt=0,cnt2=0;\n            rep(k,n){\n                if((pp.first-p[k]).abs()<=1.0+eps) ++cnt;\n                if((pp.second-p[k]).abs()<=1.0+eps) ++cnt2;\n            }\n            mx=max(mx,max(cnt,cnt2));\n        }\n        cout<<mx<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> C;\n\nint solve(int N, vector<double>& x, vector<double>& y) {\n    vector<C> point(N);\n\n    for (int j = 0; j < N; ++j) {\n        point[j] = C(x[j], y[j]);\n    }\n\n    int ret = 0;\n\n    for (int j = 0; j < N; ++j) {\n        for (int k = j+1; k < N; ++k) {\n            C mid = (point[j] + point[k]) * 0.5;\n\n            C normal = (point[j] - point[k]) * C(0, 1);\n            normal /= abs(point[j] - point[k]);\n\n            double a = 1 - norm(mid - point[j]);\n\n            C centre1 = mid + a * normal;\n            int count = 0;\n            for (int l = 0; l < N; ++l) {\n                if (abs(centre1 - point[l]) < 1) {\n                    ++count;\n                }\n            }\n            ret = max(ret, count);\n\n            C centre2 = mid - a * normal;\n            count = 0;\n            for (int l = 0; l < N; ++l) {\n                if (abs(centre2 - point[l]) < 1.0001) {\n                    ++count;\n                }\n            }\n            ret = max(ret, count);\n\n        }\n    }\n\n    return ret;\n}\n\nint main () {\n    int N;\n    vector<double> x, y;\n\n    while (true) {\n        cin >> N;\n        if (N == 0) break;\n\n        x.resize(N);\n        y.resize(N);\n\n        for (int j = 0; j < N; ++j) {\n            cin >> x[j] >> y[j];\n        }\n\n        cout << solve(N, x, y) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-8\n#define INF 1000000\n\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n    Point operator *(const double d)const{\n        return Point(x*d,y*d);\n    }\n    bool operator <(const Point &p)const{\n        if(x==p.x) return y<p.y;\n        return x<p.x;\n    }\n    double norm(){\n        return x*x+y*y;\n    }\n\tbool input(){\n\t\tif(cin>>x>>y) return true;\n\t\treturn false;\n\t}\n};\n\nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n\tbool input(){\n\t\tif(a.input() && b.input()) return true;\n\t\treturn false;\n\t}\n};\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point _c,double _r){\n        c=_c; r=_r;\n    }\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n\ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n\nint ccw(Point a,Point b,Point c){\n\tPoint v1 = b-a;\n\tPoint v2 = c-a;\n    if(cross(v1,v2)>EPS) return +1;\n    if(cross(v1,v2)<-EPS) return -1;\n\tif(dot(v1,v2)<-EPS) return +2;\n\tif(v1.norm()<v2.norm()) return -2;\n    return 0;\n}\n\nbool intersect_ss(Line l,Line m){\n\treturn ccw(l.a,l.b,m.a)*ccw(l.a,l.b,m.b)<=0 && ccw(m.a,m.b,l.a)*ccw(m.a,m.b,l.b)<=0;\n}\n\nbool crosspoint_ll(Line l,Line m,Point &p){\n    Point a1,a2,b1,b2;\n    a1 = l.b-l.a; a2 = m.b-m.a;\n    b1 = m.a-l.a; b2 = l.a-m.b;\n    double s1,s2;\n    s1 = cross(a1,b1)/2; s2 = cross(a1,b2)/2;\n    if(s1+s2<EPS) return false;\n    p = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n    return true;\n}\n\nint crosspoint_ss(Line l,Line m,Point &p){\n    if(intersect_ss(l,m)==false) return 0;\n    if(crosspoint_ll(l,m,p)==true) return 1;\n\treturn -1;\n}\n\nint crosspoint_cc(Circle c1,Circle c2,Point &p1,Point &p2){\n    double d,a,t;\n    d = sqrt((c2.c-c1.c).norm());\n\tif(abs(c1.c.x-c2.c.x)<EPS && abs(c1.c.y-c2.c.y)<EPS && abs(c1.r-c2.r)<EPS)\n\t\treturn -1;\n    if(d<abs(c1.r-c2.r) || c1.r+c2.r<d) return 0;\n    a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    t = atan2(c2.c.y-c1.c.y,c2.c.x-c1.c.x);\n    p1 = Point(c1.c.x+c1.r*cos(t+a),c1.c.y+c1.r*sin(t+a));\n    p2 = Point(c1.c.x+c1.r*cos(t-a),c1.c.y+c1.r*sin(t-a));\n    if(abs(p1.x-p2.x)<EPS && abs(p1.y-p2.y)<EPS) return 1;\n    return 2;\n}\n\nint contains(Polygon g,Point p){\n\tLine l = Line(p,Point(INF,p.y));\n\tint cnt = 0, n = g.size();\n\tfor(int i=0;i<n;i++){\n\t\tPoint a = g[i]-p;\n\t\tPoint b = g[(i+1)%n]-p;\n\t\tif(ccw(g[i],g[(i+1)%n],p)==0) return 1;\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<=EPS && EPS<b.y && cross(a,b)>EPS) cnt++;\n\t}\n\tif((cnt&1)==1) return 2;\n\treturn 0;\n}\n\nPolygon andrewScan(Polygon s){\n\tif(s.size()<=2) return s;\n\tsort(s.begin(),s.end());\n\tPolygon g;\n\tfor(int i=0;i<s.size();i++){\n\t\tfor(int n=g.size(); n>=2 && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\tint upper_n = g.size();\n\tfor(int i=s.size()-2;i>=0;i--){\n\t\tfor(int n=g.size(); n>upper_n && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\treverse(g.begin(),g.end());\n\tg.pop_back();\n\treturn g;\n}\n\nint cntInsidePoint(Circle c,Polygon s){\n\tint cnt=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tif((s[i]-c.c).norm()<=1.0) cnt++;\n\t}\n\treturn cnt;\n}\n\nint main(){\n\tint N;\n\twhile(cin>>N,N){\n\t\tPolygon S;\n\t\tS.resize(N);\n\t\tfor(int i=0;i<N;i++) S[i].input();\n\t\tint ans = 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=i+1;j<N;j++){\n\t\t\t\tPoint p1,p2;\n\t\t\t\tif(crosspoint_cc(Circle(S[i],1),Circle(S[j],1),p1,p2)>0){\n\t\t\t\t\tans = max(ans,max(cntInsidePoint(Circle(p1,1),S),cntInsidePoint(Circle(p2,1),S)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\\\"%d\\\\n\\\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst double PI=acos(-1);\nconst double EPS=1e-6;\ntypedef complex<double>Point;\nPoint in(){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    return Point(x,y);\n}\n\nint N;\nPoint P[333];\n\nsigned main(){\n\n    Point r=polar(1.0,PI/2);\n    while(scanf(\"%lld\",&N),N){\n        rep(i,N)P[i]=in();\n\n        int ma=1;\n        rep(i,N)rep(j,N){\n            if(abs(P[i]-P[j])+EPS>2.0)continue;\n            Point b=(P[i]+P[j])*0.5;\n            Point v=(P[i]-P[j]);\n            v*=1.0/abs(v);\n            for(double d:{-1.0,1.0}){\n                Point u=v*d*sqrt(1.0-norm((P[i]-P[j])/2.0))*r;\n                Point p=b+u;\n                int cnt=0;\n                rep(k,N)if(abs(P[k]-p)<1.0+EPS)cnt++;\n                chmax(ma,cnt);\n            }\n        }\n        printf(\"%lld\\n\",ma);\n    }\n    return 0;\n}\n\\"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nP center1(P a ,P b ,double r){\n  return (a+b)/(P)2+(b-a)*P(0,1)*(P)(sqrt(r*r-norm((b-a)/(P)2))/abs(b-a));\n}\n\nP center2(P a ,P b ,double r){\n  return (a+b)/(P)2+(b-a)*P(0,-1)*(P)(sqrt(r*r-norm((b-a)/(P)2))/abs(b-a));\n}\n\nint main(){\n  int n;\n  while(true){\n    cin >>n;\n    if (!n)\n      break;\n    P dot[n];\n    double x,y;\n    for(int i=0;i<n;i++){\n      cin >>x >>y;\n      dot[i] = P(x,y);\n    }\n    set<int> near_dot[n];\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif (abs(dot[i]-dot[j])<2)\n\t  near_dot[i].insert(j);\n      }\n    }\n    \n    set<int>::iterator it;\n    int cnt,max=2;\n    P c;\n    for(int i=0;i<n;i++){\n      it = near_dot[i].begin();\n      while(it != near_dot[i].end()){\n\tc = center1(dot[i],dot[*it],1);\n\tcnt=2;\n\tfor(int j=0;j<n;j++)\n\t  if (abs(dot[j]-c)<1 && j!=i && j!=*it)\n\t    cnt++;\n\tif (max<cnt){\n\t  max=cnt;\n\t}\n\n\tc = center2(dot[i],dot[*it],1);\n\tcnt=2;\n\tfor(int j=0;j<n;j++)\n\t  if (abs(dot[j]-c)<1 && j!=i && j!=*it)\n\t    cnt++;\n\tif (max<cnt){\n\t  max=cnt;\n\t}\n\tit++;\n      }\n    }\n    cout << max << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n??\n#define MAX_N 300\nconst double PI=acos(-1.0);\n??\nstruct Point{\n????????double x,y;\n????????Point(){\n????????????????x=y=0;\n????????}\n????????bool operator<(const Point& p)const{\n????????????????return this->x < p.x;\n????????}\n};\n??\nstruct comp{\n????????bool operator()(const Point &P1, const Point &P2){\n????????????????return P1.x < P2.x;\n????????}\n????????bool operator()(const Point &P, double d){\n????????????????return P.x < d;\n????????}\n????????bool operator()(double d, const Point &P){\n????????????????return d < P.x;\n????????}\n};\n??\nPoint points[MAX_N];\nint N;\n??\ndouble distance(Point *a, Point *b){\n????????return std::sqrt(pow(a->x-b->x,2)+pow(a->y-b->y,2));\n}\n??\ndouble distance2(Point *a, Point *b){\n????????return pow(a->x-b->x,2)+pow(a->y-b->y,2);\n}\n??\nint solve(){\n????????Point C, *P1, *P2, *P3;\n????????int max=1;\n????????for(int i=0;i<N;i++){\n????????????????P1=&points[i];\n????????????????Point *LB,*UB;\n????????????????LB=std::lower_bound(points,points+N,P1->x-2.0001,comp());\n????????????????UB=std::upper_bound(points,points+N,P1->x+2.0001,comp());\n????????????????for(int j=(LB-points);j<(UB-points);j++){\n????????????????????????if(i==j) continue;\n????????????????????????P2=&points[j];\n????????????????????????if(distance(P1,P2)>2.0) continue;\n??\n????????????????????????double alpha,beta;\n????????????????????????alpha=acos(distance(P1,P2)/2.0);\n????????????????????????if((P2->x-P1->x)>=0){\n????????????????????????????????if((P2->y - P1->y)>=0){\n????????????????????????????????????????beta=atan((P2->y - P1->y) / (P2->x - P1->x));\n????????????????????????????????}else{\n????????????????????????????????????????beta=atan((P2->y - P1->y) / (P2->x - P1->x))+2.0*PI;\n????????????????????????????????}\n????????????????????????}else{\n????????????????????????????????beta=atan((P2->y - P1->y) / (P2->x - P1->x))+PI;\n????????????????????????}\n????????????????????????C.x=P1->x+cos(alpha+beta);\n????????????????????????C.y=P1->y+sin(alpha+beta);\n??\n????????????????????????int enclosed=0;\n????????????????????????Point *lb,*ub;\n????????????????????????lb=std::lower_bound(points,points+N,C.x-1.0001,comp());\n????????????????????????ub=std::upper_bound(points,points+N,C.x+1.0001,comp());\n????????????????????????for(int k=(lb-points);k<(ub-points);k++){\n????????????????????????????????if(k==i||k==j){\n????????????????????????????????????????enclosed++;\n????????????????????????????????????????continue;\n????????????????????????????????}\n????????????????????????????????P3=&points[k];\n????????????????????????????????if(distance2(P3,&C)<1.0) enclosed++;\n????????????????????????}\n????????????????????????if(enclosed>max) max=enclosed;\n????????????????????????if(max==N) return max;\n????????????????}\n????????}\n????????return max;\n}\n??\nint main(void){\n????????while(scanf(\"%d\",&N), N){\n????????????????for(int i=0;i<N;i++){\n????????????????????????scanf(\"%lf %lf\", &points[i].x, &points[i].y);\n????????????????}\n????????????????std::sort(points,points+N);\n????????????????printf(\"%d\\n\",solve());\n????????}\n????????return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS=1e-10;\n\ndouble add(double a,double b){\n  if(abs(a+b)<EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x,y;\n  point(){}\n  point(double x,double y) : x(x) , y(y) {}\n\n  point operator + (point p) {\n    return point(add(x,p.x),add(y,p.y));\n  }\n\n  point operator - (point p) {\n    return point(add(x,-p.x),add(y,-p.y));\n  }\n\n  point operator * (double d) {\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d) {\n    return point(x/d,y/d);\n  }\n\n  bool operator == (const point &p)const{\n    return abs(x-p.x)<EPS && abs(y-p.y)<EPS;\n  }\n};\n\nstruct circle{\n  point p;\n  double r;\n  circle(){}\n  circle(point p,double r):p(p),r(r){}\n};\n\ndouble dist(point a, point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nvector<point> circle_cross(circle a, circle b){\n  vector<point>ret;\n\n  double x=a.p.x-b.p.x,y=a.p.y-b.p.y;\n  double L=x*x+y*y;\n\n  if(L>pow(a.r+b.r,2))return ret;\n\n  L=sqrt(L);\n  double C=atan2(b.p.y-a.p.y,b.p.x-a.p.x);\n  double alpha=acos((L*L+a.r*a.r-b.r*b.r)/(2*L*a.r));\n\n  point r1,r2;\n  r1.x=a.p.x+cos(C+alpha),r1.y=a.p.y+sin(C+alpha);\n  r2.x=a.p.x+cos(C-alpha),r2.y=a.p.y+sin(C-alpha);\n\n  ret.push_back(r1),ret.push_back(r2);\n  return ret;\n}\n\nint main(void){\n\n  int n;\n  point a;\n  vector<point>P;\n  vector<circle>C;\n\n  while(cin >> n,n){\n    P.clear();\n    C.clear();\n    for(int i=0;i<n;i++){\n      cin >> a.x >> a.y;\n      P.push_back(a);\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(dist(P[i],P[j])>2.0+EPS)continue;\n\tvector<point>res=circle_cross(circle(P[i],1.0),circle(P[j],1.0));\n\tfor(int k=0;k<res.size();k++)\n\t  C.push_back(circle(res[k],1));\n      }\n    }\n\n    int ans=1;\n    for(int i=0;i<C.size();i++){\n      int cnt=0;\n      for(int j=0;j<P.size();j++)\n\tif(dist(C[i].p,P[j])<1.0+EPS)cnt++;\n\t\n      ans=max(ans,cnt);\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\nconst double INF = 1e10;\nconst double EPS = 1e-8;\n\nstruct Point {\n\tdouble x, y;\n\tPoint() : x(0), y(0) { }\n\tPoint(double x, double y) : x(x), y(y) { }\n\tPoint operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n\tPoint operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double s) const { return Point(x * s, y * s); }\n\tPoint operator/(double s) const { return Point(x / s, y / s); }\n\tPoint &operator+=(const Point &p){ x += p.x; y += p.y; return *this; }\n\tPoint &operator-=(const Point &p){ x -= p.x; y -= p.y; return *this; }\n\tPoint &operator*=(double s){ x *= s; y *= s; return *this; }\n\tPoint &operator/=(double s){ x /= s; y /= s; return *this; }\n\tbool operator==(const Point &p) const { return x == p.x && y == p.y; }\n\tbool operator!=(const Point &p) const { return x != p.x || y != p.y; }\n\tbool operator<(const Point &p) const {\n\t\treturn (x == p.x) ? (y < p.y) : (x < p.x);\n\t}\n};\ninline Point operator*(double s, const Point &p){ return p * s; }\n\ninline double norm(const Point &p){ return p.x * p.x + p.y * p.y; }\ninline double abs(const Point &p){ return sqrt(norm(p)); }\ninline double arg(const Point &p){ return atan2(p.y, p.x); }\ninline Point unit(const Point &p){ return p / abs(p); }\ninline Point ortho(const Point &p){ return Point(-p.y, p.x); }\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tvector<Point> p(n);\n\t\tfor(int i = 0; i < n; ++i){ cin >> p[i].x >> p[i].y; }\n\t\tconst double limit = (1.0 + EPS) * (1.0 + EPS);\n\t\tint answer = 1;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tconst Point a = p[i];\n\t\t\tfor(int j = i + 1; j < n; ++j){\n\t\t\t\tconst Point b = p[j];\n\t\t\t\tif(abs(b - a) > 2.0){ continue; }\n\t\t\t\tconst Point c = (a + b) * 0.5;\n\t\t\t\tconst Point v = unit(ortho(b - a));\n\t\t\t\tconst double t = sqrt(1.0 - norm(b - c));\n\t\t\t\tconst Point q[2] = { c + v * t, c + v * -t };\n\t\t\t\tfor(int k = 0; k < 2; ++k){\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tfor(int l = 0; l < n; ++l){\n\t\t\t\t\t\tif(norm(p[l] - q[k]) <= limit){ ++count; }\n\t\t\t\t\t}\n\t\t\t\t\tanswer = max(answer, count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<double,double> P;\n\nint n;\nint ans;\nvector<double> x, y;\nvector<P> v;\n\nvoid solve(){\n\tx.clear(); y.clear();\n\tx.resize(n); y.resize(n);\n\tans = 1;\n\trep(i,n) cin >> x[i] >> y[i];\n\tfor(int i = 0; i <= 1000; i++) for(int j = 0; j <= 1000; j++){\n\t\tdouble I = i/100.0, J = j/100.0;\n\t\tint cnt = 0;\n\t\trep(k,n){\n\t\t\tif((x[k]-I)*(x[k]-I)+(y[k]-J)*(y[k]-J) < 1) cnt++;\n\t\t}\n\t\tans = max(ans,cnt);\n\t}\n\tcout << ans << endl;\n}\n\nint main(){\n\twhile(cin >> n){\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> xy_t;\nint n, temp, ans;\nxy_t p[300];\nxy_t c[2];\n// 内積: a.x*b.x +a.y*b.y\ndouble dot_product(xy_t a, xy_t b) { return (conj(a)*b).real(); }\n\nbool center(xy_t a, xy_t b){\n    xy_t dir = b - a;\n    if(dot_product(dir, dir) > 4){\n        return false;\n    }\n    xy_t ver = xy_t(-dir.imag(), dir.real());\n    ver /= sqrt(dot_product(ver, ver));\n    double len = sqrt(1 - dot_product(dir, dir) / 4);\n    c[0] = a + dir / 2.0 - ver * len;\n    c[1] =  a + dir / 2.0 + ver * len;\n    return true;\n}\nint main(){\n    while(cin >> n && n){\n        ans = 1; // 最低でも一つは囲める\n        for(int i = 0; i < n; i++){\n            double x, y;\n            cin >> x >> y;\n            p[i] = xy_t(x, y);\n        }\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                if(center(p[i], p[j])){\n                    for(int l = 0; l < 2; l++){\n                        temp = 2;\n                        for(int k = 0; k < n; k++){\n                            if(k == i || k == j){\n                                continue;\n                            }\n                            xy_t vec = c[l] - p[k];\n                            if(dot_product(vec, vec) <= 1){\n                                temp++;\n                            }\n                        }\n                        ans = max(ans, temp);\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define ll1 1ll\n#define ONE 1ll\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\nsizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>\nistream &operator>>(istream &is, pair<T, S> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n\tcerr << endl;\n\trep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n\t\tif (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n\t\t\tcerr << \"INF\";\n\t\t}\n\t\telse\n\t\t\tcerr << v[i][j];\n\t\tcerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n\t}\n\tcerr << endl;\n}\n/*\ntypedef __int128_t Int;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\nstd::ostream::sentry s(dest);\n  if (s) {\n\t__uint128_t tmp = value < 0 ? -value : value;\n\tchar buffer[128];\n\tchar *d = std::end(buffer);\n\tdo {\n\t  --d;\n\t  *d = \"0123456789\"[tmp % 10];\n\t  tmp /= 10;\n\t} while (tmp != 0);\n\tif (value < 0) {\n\t  --d;\n\t  *d = '-';\n\t}\n\tint len = std::end(buffer) - d;\n\tif (dest.rdbuf()->sputn(d, len) != len) {\n\t  dest.setstate(std::ios_base::badbit);\n\t}\n  }\n  return dest;\n}\n\n__int128 parse(string &s) {\n  __int128 ret = 0;\n  for (int i = 0; i < s.length(); i++)\n\tif ('0' <= s[i] && s[i] <= '9')\n\t  ret = 10 * ret + s[i] - '0';\n  return ret;\n}\n*/\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T> bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<double>x(N), y(N); rep(i, 0, N) { cin >> x[i] >> y[i]; }\n\t\tauto d = [&](int i, int j) { return sqrt(pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2)); };\n\t\tauto calc = [&](double xx, double yy) {\n\t\t\tint cnt = 0;\n\t\t\trep(j, 0, N) {\n\t\t\t\tcnt += pow(x[j] - xx, 2) + pow(y[j] - yy, 2) < 1 + 1e-6;\n\t\t\t}\n\t\t\treturn cnt;\n\t\t};\n\t\tint ans = 1;\n\t\trep(i, 0, N)rep(j, i + 1, N) {\n\t\t\tdouble dx = x[i] - x[j], dy = y[i] - y[j];\n\t\t\tdouble d = sqrt(dx*dx + dy * dy);\n\t\t\tif (d > 2.0)continue;\n\t\t\tdouble xx = (x[i] + x[j]) / 2, yy = (y[i] + y[j]) / 2;\n\t\t\tdouble r = sqrt(1.0 - d * d / 4);\n\t\t\tdouble vx = dx / d * r;\n\t\t\tdouble vy = dy / d * r;\n\t\t\tchmax(ans, calc(xx - vy, yy + vx));\n\t\t\tchmax(ans, calc(xx + vy, yy - vx));\n\t\t}\n\t\tdump(ans);\n\t\tcout << ans << endl;\n\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#define EPS 1e-8\nusing namespace std;\ntypedef complex<double> P;\nstruct C{\n    P p;\n    double r;\n    C(const P& p, const double& r):\n        p(p), r(r) {}\n};\n\nP center(const P& a, const P& b, int lr){\n    P mid = (a+b)/P(2,0);\n    P len(sqrt(1-abs(b-mid)*abs(b-mid)),0);\n    P rot = P(imag(b-a),-real(b-a)) / P(abs(a-b),0);\n    if(lr==0){\n        return len*rot+mid;\n    }else{\n        return len*rot*P(-1,0)+mid;\n    }\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        vector<P> pset(n);\n        for(int i=0; i<n; i++){\n            double x,y;\n            cin >> x >> y;\n            pset[i] = P(x,y);\n        }\n\n        int mnop=0;\n        for(int i=0; i<n-1; i++){\n            for(int j=i+1; j<n; j++){\n                if(abs(pset[i]-pset[j]) < 2+EPS){\n                    for(int lr=0; lr<2; lr++){\n                        int count=0;\n                        P mid = center(pset[i], pset[j], lr);\n                        for(int k=0; k<n; k++){\n                            if(abs(pset[k]-mid) < 1+EPS){\n                                count++;\n                            }\n                        }\n                        mnop = max(mnop, count);\n                    }\n                }\n            }\n        }\n\n        if(mnop==0) mnop=1;\n        cout << mnop << endl;\n    }\n            \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <vector>\n#include <math.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\ntypedef pair<double, double> pt;\n#define x first\n#define y second\n\npt operator+(pt p, pt q) {\n  return (pt){p.x + q.x, p.y + q.y};\n}\npt operator-(pt p, pt q) {\n  return (pt){p.x - q.x, p.y - q.y};\n}\npt operator*(pt p, double c) {\n  return (pt){p.x * c, p.y * c};\n}\ndouble sq(double a) { return a * a; }\ndouble dist(pt p, pt q) {\n  return sqrt(sq(p.x - q.x) + sq(p.y - q.y));\n}\n\npt normal(pt a, pt b) {\n\tpt AB = b - a;\n\tdouble d = dist(a, b);\n\tpt n = pt(AB.y/d, -AB.x/d);\n\treturn n;\n}\n\nvoid solve(int N) {\n\tvector<pt> point;\n\tfor(int i=0; i < N; i++) {\n\t\tdouble a, b;\n\t\tcin >> a >> b;\n\t\tpoint.push_back(pt(a, b));\n\t}\n\n\tint ans = 1;\n\tfor(int i=0; i < N; i++) {\n\t\tfor(int j=i+1; j < N; j++) {\n\t\t\tpt A = point[i];\n\t\t\tpt B = point[j];\n\t\t\tpt M = pt((A.x + B.x)/2, (A.y + B.y)/2);\n\n\t\t\tif(dist(A, B) > 2.0 + EPS) continue;\n\n\t\t\tdouble l = sqrt(1 - sq(dist(A, M)));\n\t\t\tpt V = normal(A, B);\n\n\t\t\tpt C[2];\n\t\t\tC[0] = M + V*l;\n\t\t\tC[1] = M - V*l;\n\n\t\t\tfor(int t=0; t < 2; t++) {\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int k=0; k < N; k++) {\n\t\t\t\t\tif(dist(C[t], point[k]) < 1.0 + EPS) count++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, count);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\n\tint N;\n\twhile(cin >> N) {\n\t\tif(N == 0) break;\n\t\tsolve(N);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint main(void) {\n  for(int N; cin >> N, N > 0;) {\n    double x[300], y[300];\n    REP(i, 0, N) cin >> x[i] >> y[i];\n\n    int answer = 1;\n    REP(i, 0, N) {\n      REP(j, i + 1, N) {\n        double tan = (y[i] - y[j]) / (x[i] - x[j]);\n        double cot = (x[i] - x[j]) / (y[i] - y[j]);\n        double dsq = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n        if(dsq > 4.0) continue;\n        double l = sqrt(dsq - 1.);\n        double sx = (x[i] + x[j]) / 2.;\n        double sy = (y[i] + y[j]) / 2.;\n\n        double cx1 = sx - tan * l;\n        double cy1 = sy + cot * l;\n        int cnt1 = 0;\n        REP(k, 0, N) if(k == i || k == j || (x[k] - cx1) * (x[k] - cx1) + (y[k] - cy1) * (y[k] - cy1) <= 1.0) cnt1++;\n        answer = max(answer, cnt1);\n\n        double cx2 = sx + tan * l;\n        double cy2 = sy - cot * l;\n        int cnt2 = 0;\n        REP(k, 0, N) if(k == i || k == j || (x[k] - cx2) * (x[k] - cx2) + (y[k] - cy2) * (y[k] - cy2) <= 1.0) cnt2++;\n        answer = max(answer, cnt2);\n      }\n    }\n\n    cout << answer << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\n\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\n#define EPS 1e-9\n#define INF 1000000000\n\ndouble dis(Point a, Point b){ return abs(a - b); }\ndouble dot(Point a, Point b){ return a.real() * b.real() + a.imag() * b.imag(); }\ndouble cross(Point a, Point b){ return a.real() * b.imag() - a.imag() * b.real(); }\nint ccw(Point a, Point b, Point c){\n  if(cross(b - a, c - a) > EPS) return 1;\n  if(cross(b - a, c - a) < -EPS) return -1;\n  if(dot(b - a, c - a) < -EPS) return 2;\n  if(dis(a, b) + EPS < dis(c, a)) return -2;\n  return 0;\n}\nint ccw(Line a, Point b){ return ccw(a.first, a.second, b); }\n\nbool SegmentCross(Line a, Line b){\n  return ccw(a, b.first) * ccw(a, b.second) == -1\n    && ccw(b, a.first) * ccw(b, a.second) == - 1;\n}\n\nPoint MiddlePoint(Point a, Point b){\n  double x = (a.real() + b.real()) / 2;\n  double y = (a.imag() + b.imag()) / 2;\n  return Point(x, y);\n}\n\nLine Equidistant(Point a, Point b, double r = -1){\n  Point m = MiddlePoint(a, b);\n  double m_dis = dis(m, a);\n  double slope = (b.real() - a.real()) / (a.imag() - b.imag());\n  \n  if(r <= EPS){ r = m_dis * 2; }\n  \n  if(r <= m_dis + EPS){ return make_pair(Point(0, 0), Point(0, 0)); }\n\n  double target_dis = r * r - m_dis * m_dis;\n  double x = sqrt(target_dis / (1 + slope * slope));\n  double y = slope * x;\n  \n  Point s(m.real() + x, m.imag() + y);\n  Point t(m.real() - x, m.imag() - y);\n  \n  return make_pair(s, t);\n}\n\n\nint main(void){\n  while(true){\n    int n;\n    cin >> n;\n    if(n == 0){ break; }\n\n    double x, y;\n    vector<Point> P;\n    for(int i = 0; i < n; i++){\n      cin >> x >> y;\n      P.push_back(Point(x, y));\n    }\n\n    int ans = 1;\n    for(int i = 0; i < n; i++){\n      for(int j = i + 1; j < n; j++){\n        Line tmpLine = Equidistant(P[i], P[j], 1 - EPS);\n        if(tmpLine.first == tmpLine.second){ continue; }\n\n        Point center[] = {tmpLine.first, tmpLine.second};\n        for(int l = 0; l < 2; l++){\n          int count = 0;\n          for(int k = 0; k < n; k++){\n            if(dis(center[l], P[k]) <= 1.0 + EPS){\n              ++count;\n            }\n          }\n          \n          ans = max(ans, count);\n        }\n      }\n    }\n\n    // ??????\n    cout << ans << endl;\n     \n  }\n\n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\nR radNorP(R x) {\n    return fmod(fmod(x, 2*PI)+2*PI, 2*PI);\n}\n\nconst int MN = 330;\n\nP p[MN];\ntypedef pair<R, int> Pi;\n\nbool solve() {\n    int n;\n    cin >> n;\n    if (!n) return false;\n\n    for (int i = 0; i < n; i++) {\n        R x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n    }\n\n    int res = 1;\n    for (int i = 0; i < n; i++) {\n        vector<Pi> v;\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            if (2.0 < abs(p[j]-p[i])) continue;\n            R th = acos(abs(p[j]-p[i])/2.0);\n            R l = radNorP(arg(p[j]-p[i])-th-EPS);\n            R r = radNorP(arg(p[j]-p[i])+th+EPS);\n            if (r < l) {\n                v.push_back(Pi(l-EPS, 1));\n                v.push_back(Pi(2*PI+EPS, -1));\n                v.push_back(Pi(0-EPS, 1));\n                v.push_back(Pi(r+EPS, -1));\n            } else {\n                v.push_back(Pi(l-EPS, 1));\n                v.push_back(Pi(r+EPS, -1));\n            }\n\n        }\n\n        sort(v.begin(), v.end());\n        int sm = 1;\n        for (Pi p: v) {            \n            sm += p.second;\n            res = max(res, sm);\n        }\n    }\n    cout << res << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(u) begin(u),end(u)\n#define PB push_back\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\ntypedef long long int ll;\nconst int INF = (1<<30) - 1;\nconst double EPS = 1e-9;\nconst int MOD = 1000000007;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n#define X real()\n#define Y imag()\n\n\n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n    VP cs;\n    P abH = (b-a)*0.5;\n    D d = abs(abH);\n    if (d == 0 || d > r) return cs;\t// ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n    D dN = sqrt(r*r - d*d);\t\t\t\t\t// ???????????? max(r*r - d*d, 0) ??¨??????\n    P n = abH * P(0,1) * (dN / d);\n    cs.push_back(a + abH + n);\n    if (dN > 0) cs.push_back(a + abH - n);\n    return cs;\n}\n\nint N;\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    //cout.setf(ios::fixed);\n    \n    while(cin >> N, N){\n        vector<P> points(N);\n        for(int i=0; i<N; i++){\n            D x, y; cin >> x >> y;\n            points[i] = P(x, y);\n        }\n        \n        int ans = 1;\n        for(int i=0; i<N; i++)\n            for(int j=i+1; j<N; j++){\n                VP vs = circlesPointsRadius(points[i], points[j], 1);\n                for(auto v: vs){\n                    int tans = 0;\n                    for(auto p: points)\n                        if(LE(abs(p-v), 1))\n                            tans++;\n                    ans = max(ans, tans);\n                }\n            }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-9\nusing namespace std;\ntypedef complex<double> point;\n\npair<point, point> norm(point p){\n  return pair<point, point>(p*point(0, 1)/abs(p),\n                            p*point(0, -1)/abs(p));\n}\n\nvector<point> calcC(point a, point b){\n  point p = (b - a)/2.0;\n  pair<point, point> n = norm(p);\n  double unit = sqrt(1 - abs(p)*abs(p));\n  n.first  =  n.first*unit;\n  n.second = n.second*unit;\n  vector<point> res(2);\n  res[0] = a + p + n.first;\n  res[1] = a + p + n.second;\n  return res;\n}\nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n, n){;\n    point p[n];\n    for (int i = 0; i < n; i++) {\n      double real, imag;\n      cin >> real >> imag;\n      p[i] = complex<double>(real, imag);\n    }\n    int ans = 1, cnt = 0;\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        point a = p[i], b = p[j];\n        if(abs(b - a) > 2 - eps)continue;\n        vector<point> center = calcC(a, b);\n        for (int c = 0; c < 2; c++) {\n          cnt = 0;\n          for (int k = 0; k < n; k++) {\n            if(abs(center[c] - p[k]) <= 1 + eps)cnt++;\n          }\n          ans = max(ans, cnt);\n        }\n      }\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n\n\nusing namespace std;\n\ntypedef double Real;\n\nReal EPS = 1e-8;\n\nint sgn(Real a, Real b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\nReal sqr(Real a){return sqrt(max(a,(Real)0));}\n\nstruct Point{  \n  Real add(Real a, Real b){\n    if(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n    return a+b;\n  }\n\n  Real x, y;\n  Point(){}\n  Point(Real x,Real y) : x(x) , y(y){}\n\n  Point operator + (Point p){return Point(add(x,p.x), add(y,p.y));}\n  Point operator - (Point p){return Point(add(x,-p.x), add(y,-p.y));}\n  Point operator * (Real d){return Point(x*d,y*d);}\n  Point operator / (Real d){return Point(x/d,y/d);}\n  bool operator == (Point p){return !sgn(dist(p));}\n  bool operator < (Point p){return (p.x!=x)?p.x<x:p.y<y;}\n  Real norm(){return sqr(x*x+y*y);}\n  Real dist(Point a){return (*this-a).norm();}\n  Real dot(Point a){return x*a.x+y*a.y;}\n  Real cross(Point a){return x*a.y-y*a.x;}\n};\n\nstruct Circle{\n  Point p;\n  Real r;\n  Circle(){}\n  Circle(Point p, Real r) : p(p) , r(r){}\n  \n  vector<Point> intersectionPoints(Circle b){\n    vector<Point> res;\n\n    Point tmp=p-b.p;\n    if(tmp.norm()>pow(r+b.r,2))return res;\n\n    Real L = p.dist(b.p);\n    Real C = atan2(b.p.y-p.y,b.p.x-p.x);\n    Real a = acos((L*L+r*r-b.r*b.r)/(2*L*r));\n\n    res.push_back(Point(p.x+cos(C+a), p.y+sin(C+a)));\n    res.push_back(Point(p.x+cos(C-a), p.y+sin(C-a)));\n    return res;\n  }\n};\n\nint main(void){\n  int n;\n  Point a;\n  vector<Point>P;\n  vector<Circle>C;\n\n  while(cin >> n,n){\n    P.clear();\n    C.clear();\n    for(int i=0;i<n;i++){\n      cin >> a.x >> a.y;\n      P.push_back(a);\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(sgn(P[i].dist(P[j]),2.0)>=0)continue;\n\tvector<Point>res=Circle(P[i],1.0).intersectionPoints(Circle(P[j],1.0));\n\tfor(int k=0;k<res.size();k++)\n\t  C.push_back(Circle(res[k],1));\n      }\n    }\n\n    int ans=1;\n    for(int i=0;i<C.size();i++){\n      int cnt=0;\n      for(int j=0;j<P.size();j++)\n\tif(sgn(C[i].p.dist(P[j]),1.0)<=0)cnt++;\n\n      ans=max(ans,cnt);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>  \n#include<algorithm>  \n#include<math.h>  \nusing namespace std;  \nconst double eps=1e-8;  \nstruct Point {  \n    double x,y;  \n};  \nstruct Node{  \n    double angle;  \n    int in;  \n};  \nNode arc[1005];  \nPoint p[305];  \n  \ndouble dist(Point p,Point q){  \n    return sqrt((p.x-q.x)*(p.x-q.x)+(p.y-q.y)*(p.y-q.y));  \n}  \nint cmp(Node a,Node b){  \n    if(a.angle!=b.angle) return a.angle<b.angle;  \n    else return a.in>b.in;  \n}  \nint main(){  \n    #ifndef ONLINE_JUDGE  \n    freopen(\"in.txt\",\"r\",stdin);  \n    #endif // ONLINE_JUDGE  \n    int n;  \n    while(scanf(\"%d\",&n),n){  \n        int ans=1;  \n        for(int i=0;i<n;i++) scanf(\"%lf%lf\",&p[i].x,&p[i].y);  \n        for(int i=0;i<n;i++){  \n            int cnt=0;  \n            for(int j=0;j<n;j++){  \n                if(i==j) continue;  \n                if(dist(p[i],p[j])>2.0+eps) continue;  \n                double b=atan2(p[j].y-p[i].y,p[j].x-p[i].x);  \n                double a=acos(dist(p[i],p[j])/2);  \n                arc[cnt].angle=b-a; arc[cnt++].in=1; //把角度小的点作为入点  \n                arc[cnt].angle=b+a; arc[cnt++].in=-1;  \n            }  \n            sort(arc,arc+cnt,cmp);  \n            int tmp=1;  \n            for(int j=0;j<cnt;j++){  \n                //if(arc[j].in) tmp++;值为负时if也成立（只要非0都成立）  \n                tmp+=arc[j].in;  \n                ans=max(ans,tmp);  \n            }  \n        }  \n        printf(\"%d\\n\",ans);  \n    }  \n    return 0;  \n}  \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-9\nusing namespace std;\ntypedef complex<double> point;\n\ndouble dist(point a, point b){\n  return sqrt((a.real() - b.real())*(a.real() - b.real()) +\n              (a.imag() - b.imag())*(a.imag() - b.imag()));\n}\n\npair<point, point> norm(point p){\n  double unit = 1 / sqrt(p.real()*p.real() + p.imag()*p.imag());\n  return pair<point, point>(p*point(0, 1)/unit,\n                            p*point(0, -1)/unit);\n}\n\nvector<point> calcC(point a, point b){\n  point p = (b - a)/2.0;\n  pair<point, point> n = norm(p);\n  double unit = sqrt(1 - abs(p)*abs(p));\n  n.first  *= unit;\n  n.second *= unit;\n  vector<point> res(2);\n  res[0] = a + p + n.first;\n  res[1] = a + p + n.second;\n  return res;\n}\nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n, n){;\n    point p[n];\n    for (int i = 0; i < n; i++) {\n      double real, imag;\n      cin >> real >> imag;\n      p[i] = complex<double>(real, imag);\n    }\n    int ans = 0, cnt = 0;\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        point a = p[i], b = p[j];\n        if(dist(a, b) > 2 - eps)continue;\n        vector<point> center = calcC(a, b);\n        for (int c = 0; c < 2; c++) {\n          cnt = 0;\n          // std::cout << center[c].real() << \" \" <<\n          //   center[c].imag()<< std::endl;\n          for (int k = 0; k < n; k++) {\n            if(dist(center[c], p[k]) <= 1 - eps)cnt++;\n          }\n          ans = max(ans, cnt);\n        }\n      }\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS=1e-6;\n\nint main(void){\n\twhile(1){\n\t\tint n; cin >> n;\n\t\tif(!n) break;\n\n\t\tdouble x[333], y[333];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin>>x[i]>>y[i];\n\t\t}\n\n\t\tint ans=1;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(i==j) continue;\n\t\t\t\tdouble dx = x[i]-x[j];\n\t\t\t\tdouble dy = y[i]-y[j];\n\t\t\t\tdouble dist = sqrt(dx*dx+dy*dy);\n\t\t\t\tif(dist > 2.0+EPS) continue;\n\n\t\t\t\tdouble r = sqrt(1.0-dist*dist/4);\n\t\t\t\tdouble vx = -dy/dist*r;\n\t\t\t\tdouble vy = dx/dist*r;\n\t\t\t\tdouble xx = (x[i]+x[j])/2+vx;\n\t\t\t\tdouble yy = (y[i]+y[j])/2+vy;\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif((x[k]-xx)*(x[k]-xx)+(y[k]-yy)*(y[k]-yy) < 1.0+EPS)cnt++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, cnt);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-3;\n\nstruct Circle{\n  P c;\n  double r;\n  Circle(P c=P(0,0),double r=0):c(c),r(r){}\n};\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1=c1.r,r2=c2.r,d;\n  P p1=c1.c,p2=c2.c;\n  d=abs(p1-p2);\n  if(d<EPS&&abs(r1-r2)<EPS) return res;\n  if(r1+r2<d-EPS||d+EPS<abs(r1-r2)) return res; \n  double a=(r1*r1-r2*r2+d*d)/(2*d);\n  double h=sqrt(max(r1*r1-a*a,0.0));\n  P tmp1=p1+a/d*(p2-p1);\n  P tmp2=h/d*(p2-p1);\n  if(abs(tmp2)<EPS)res.push_back(tmp1);\n  else{\n    res.push_back(P(real(tmp1)-imag(tmp2),imag(tmp1)+real(tmp2)));\n    res.push_back(P(real(tmp1)+imag(tmp2),imag(tmp1)-real(tmp2)));\n  }\n  return res;\n}\n\ndouble getdistancepp(P a,P b){\n  return sqrt((a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag()));\n}\n\nint main(){\n  int n,ans=0;\n  double a,b;\n  P p[N];\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>a>>b;\n      p[i]=P(a,b);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tCircle c1,c2;\n\tc1.c=p[i];\n\tc2.c=p[j];\n\tc1.r=c2.r=1;\n\tvector<P> r=getIntersectCC(c1,c2);\n\tif(!r.size())continue;\n\tfor(int k=0;k<r.size();k++){\n\t  int cnt=0;\n\t  for(int l=0;l<n;l++)\n\t    if(getdistancepp(r[k],p[l])<=1+EPS)cnt++;\t    \n\t  ans=max(ans,cnt);\n\t}\n      }\n    }\n    if(!ans&&n==1)ans=1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nconst double EPS = 1e-8;\ntypedef pair<double,double> P;\n\ninline double dist(P p,P q){\n  return ( (p.first-q.first)*(p.first-q.first) + (p.second-q.second)*(p.second-q.second));\n}\n\nint main(){\n  int N;\n  double sign[2] = {+1, -1};\n  P p[301];\n  while(scanf(\"%d\",&N) != EOF){\n    if(N == 0)break;\n    REP(i,N)scanf(\"%lf %lf\",&p[i].first,&p[i].second);\n    int ans = 1;\n    REP(i,N){\n      FOR(j,i+1,N){\n        double dst = dist(p[i],p[j]);\n        if(dst > 4.0) continue;\n        P v((p[j].first-p[i].first)/dst, (p[j].second-p[i].second)/dst);\n        P m((p[j].first+p[i].first)/2.0, (p[j].second+p[i].second)/2.0);\n        double lth = sqrt(1.0-dst*dst/4.0);\n        REP(k,2){\n          double cx = m.first + sign[k] * v.first * lth;\n          double cy = m.second - sign[k] * v.second * lth;\n          P center(cx,cy);\n          int count = 0;\n          REP(l,N){\n            if(l == i || l == j || dist(center,p[l]) < 1){\n              count++;\n            }\n            if(N-l-1 + count < ans)break;\n          }\n          if(ans < count) ans = count;\n        }\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint ans;\n\ncomplex<double> MaxCoverCircle(vector<complex<double>> &p, double radius) {\n  const int n = p.size();\n  const double eps = 1e-6;\n  int num_points = 1;\n  complex<double> center_max(p[0]);\n\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      auto diff = p[i] - p[j];\n      double dist = abs(diff);\n\n      if (dist - 2*radius > eps) continue;\n\n      auto mid = p[j] + (diff/2.0);\n      auto mid_unit_normal = (diff*complex<double>(0, 1))/dist;\n      auto mid_to_center = sqrt(radius - dist*dist/4.0)*mid_unit_normal;\n\n      for (int k = 0; k < 2; ++k) {\n        mid_to_center *= -1;\n        auto center = mid + mid_to_center;\n\n        int cnt = 0;\n        for (int l = 0; l < n; ++l) {\n          auto q = p[l] - center;\n          if (q.real()*q.real() + q.imag()*q.imag() - radius*radius < eps) cnt++;\n        }\n\n        if (cnt > num_points) {\n          num_points = cnt;\n          center_max = center;\n        }\n      }\n    }\n  }\n  ans = num_points;\n  return center_max;\n}\n\nint main() {\n  int n;\n  while (cin >> n, n) {\n    vector<complex<double>> p;\n    p.reserve(n);\n    for (int i = 0; i < n; ++i) {\n      double x, y;\n      cin >> x >> y;\n      p.emplace_back(x, y);\n    }\n    MaxCoverCircle(p, 1);\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\nconst double EPS = 1e-4;\n\n#define x first\n#define y second\n\nvoid normalize(double &a, double &b){\n    double norm = sqrt(a*a + b*b);\n    a /= norm;\n    b /= norm;\n}\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        int ans = 1;\n        vector<pair<double,double>> v;\n        for(int i = 0; i < n; i++){\n            double a, b;\n            cin >> a >> b;\n            v.push_back({a,b});\n        }\n        for(int i = 0; i < n; i++){\n            for(int j = i+1; j < n; j++){\n                double dx = v[i].x-v[j].x, dy = v[i].y-v[j].y;\n                if(sqrt(dx*dx+dy*dy) > 2.0000)    continue;\n                double midx = (v[i].x+v[j].x)/2, midy = (v[i].y+v[j].y)/2;\n                double ux = 0, uy = 0, cx, cy;\n                if(dx == 0)         ux = 1;\n                else if(dy == 0)    uy = 1;\n                else                ux = 1, uy = -dx/dy;\n                normalize(ux, uy);\n                double scale = sqrt(1*1 - (v[i].x-midx)*(v[i].x-midx) - (v[i].y-midy)*(v[i].y-midy));\n                for(int k = -1; k <= 1; k++){\n                    if(k == 0)  continue;\n                    cx = midx + scale * ux * k;\n                    cy = midy + scale * uy * k;\n                    int tmp = 0;\n                    for(int l = 0; l < n; l++){\n                        if((v[l].x-cx)*(v[l].x-cx)+(v[l].y-cy)*(v[l].y-cy) <= 1+EPS)    tmp++;\n                    }\n                    ans = max(ans, tmp);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nP center1(P a ,P b ,double r){\n  return (a+b)/(P)2+(b-a)*P(0,1)*(P)(sqrt(r*r-norm((b-a)/(P)2))/abs(b-a));\n}\n\nP center2(P a ,P b ,double r){\n  return (a+b)/(P)2+(b-a)*P(0,-1)*(P)(sqrt(r*r-norm((b-a)/(P)2))/abs(b-a));\n}\n\nint main(){\n  int n;\n  while(true){\n    cin >>n;\n    if (!n)\n      break;\n    P dot[n];\n    double x,y;\n    for(int i=0;i<n;i++){\n      cin >>x >>y;\n      dot[i] = P(x,y);\n    }\n    set<int> near_dot[n];\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif (norm(dot[i]-dot[j])<4)\n\t  near_dot[i].insert(j);\n      }\n    }\n    \n    set<int>::iterator it;\n    int cnt,max=2;\n    P c;\n    for(int i=0;i<n;i++){\n      it = near_dot[i].begin();\n      while(it != near_dot[i].end()){\n\tc = center1(dot[i],dot[*it],1);\n\tcnt=2;\n\tfor(int j=0;j<n;j++)\n\t  if (norm(dot[j]-c)<=1 && j!=i && j!=*it)\n\t    cnt++;\n\tif (max<cnt){\n\t  max=cnt;\n\t}\n\n\tc = center2(dot[i],dot[*it],1);\n\tcnt=2;\n\tfor(int j=0;j<n;j++)\n\t  if (norm(dot[j]-c)<=1 && j!=i && j!=*it)\n\t    cnt++;\n\tif (max<cnt){\n\t  max=cnt;\n\t}\n\tit++;\n      }\n    }\n    cout << max << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define EPS 1.0e-5\nusing namespace std;\n\ntypedef struct {\n  double x,y;\n} P;\n\ndouble dis(P p ){\n  return sqrt( p.x*p.x + p.y*p.y );\n}\ndouble dis(P p1,P p2 ){\n  P p;\n  p.x = p1.x-p2.x;\n  p.y = p1.y-p2.y;\n  return dis( p );\n}\n\n\nint main(){\n  int n, mx;\n  P p[301], m, p1,p2, mv,dmv, c[2];\n  double x;\n\n  while( cin>>n && n ){\n    for( int i=0;i<n;i++ )\n      cin >> p[i].x >> p[i].y ;\n\n    mx=0;\n\n    for( int i=0;i<n;i++ ){\n      for( int j=i+1;j<n;j++ ){\n\tif( dis(p[i],p[j])<2.0 ){\n\t  p1=p[i]; p2=p[j];\n\t  m.x = (p1.x+p2.x)/2.0;\n\t  m.y = (p1.y+p2.y)/2.0;\n\n\t  x = sqrt( 1-dis(p1,m) );\n\t  // ツ陳心ツ点 cツづーツ仰づ淞づゥ\n\t  if( fabs( p1.x-p2.x ) < EPS ){\n\t    mv.x=1.0;  mv.y=0.0;\n\t  }else{\n\t    double a1 = ( p2.y-p1.y )/( p2.x-p1.x );\n\t    mv.x=1.0; mv.y=-1.0/a1;\n\t  }\n\t  double scale = dis( mv );\n\t  dmv.x = x*mv.x / scale;\n\t  dmv.y = x*mv.y / scale;\n\n\t  c[0].x=m.x+dmv.x; c[0].y=m.y+dmv.y;\n\t  c[1].x=m.x-dmv.x; c[2].y=m.y-dmv.y;\n\n\t  for( int cn=0;cn<2;cn++ ){\n\t    int sum=0;\n\t    for( int k=0;k<n;k++ ){\n\t      if( dis( c[cn],p[k] ) < 1.0+EPS )\n\t\tsum++;\n\t    }\n\t    if( mx<sum ) mx=sum;\n\t  }\n\t}\n      }\n    }\n    cout << mx << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 301\nusing namespace std;\ntypedef complex <double> P;\nconst double EPS = 1e-8;\nP p[N];\nint n;\n\nint cnt(P c){\n  int res=0;\n  for(int i=0;i<n;i++)if(abs(c-p[i])<1+EPS) res++;\n  return res;\n}\n\nP get_C(P a,P b){\n  double x=abs(b-a);\n  return P(x/2,sqrt(1-x*x/4))*(b-a)/abs(b-a)+a;  \n}\n\n\nint main(){\n  while(1){\n  cin>>n;\n  if(!n)break;\n  double a,b;\n  for(int i=0;i<n;i++)cin>>a>>b,p[i]=P(a,b);\n  \n  int ans=1;\n  for(int i=0;i<n;i++)\n    for(int j=i+1;j<n;j++)\n      if(abs(p[i]-p[j])<=2){\n\tans=max(ans,cnt(get_C(p[i],p[j])));\n\tans=max(ans,cnt(get_C(p[j],p[i])));\n      }\n  cout <<ans<<endl;  \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (1e9+7)\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n\nusing P=complex<double>;\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        int ans=1;\n        vector<P> c(n);\n        rep(i,n) { double p,q; cin>>p>>q; c[i]=P(p,q); }\n        rep(i,n)range(j,i+1,n){\n            P v=c[i]-c[j];\n            double d=abs(v);\n            if(d>2.0) continue;\n            P med=(c[i]+c[j])/2.0;\n            P nml=v/d*P(0,1)*sqrt(1-d*d/4);\n            P r1=med+nml;\n            P r2=med-nml;\n            int s1=0,s2=0;\n            rep(k,n){\n                s1+=(abs(r1-c[k])<=1.0);\n                s2+=(abs(r2-c[k])<=1.0);\n            }\n            ans=max(ans,max(s1,s2));\n        }\n        cout<<ans<<endl;\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Circle and Points\n\n// 平面走査ごり押し\n\n#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle().crosspoint()の戻り値\nusing namespace std;\n\nconst double EPS = 1e-6;\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\npublic:\n    double x, y;\n    Point(double a = 0.0, double b = 0.0) :x(a), y(b) {};\n    bool operator== (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    Point operator+(const Point&) const;\n    Point operator-(const Point&) const;\n    Point operator-() const;\n    Point times(double) const;\n    Point& operator=(const Point&);\n    Point& operator+=(const Point&);\n    Point& operator-=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    Point projection(const Line&) const;\n    Point reflection(const Line&) const;\n    int ccw(const Point&, const Point&) const;              // a.ccw(b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n};\nclass Segment {\npublic:\n    Point source, target;\n    Segment(Point a = Point(), Point b = Point()) :source(a), target(b) {};\n    Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n};\nclass Line {\npublic:\n    Point source, target;\n    Line(Point a = Point(), Point b = Point()) :source(a), target(b) {};\n    Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    Point projection(const Point&) const;\n    Point reflection(const Point&) const;\n    Point crosspoint(const Line&) const;\n};\nclass Circle {\npublic:\n    double x, y, r;\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :x(a), y(b), r(c) {};\n    Point point() const;\n    double distance(const Point&) const;                    // 円の中心と点の距離\n    double distance(const Circle&) const;                   // 円の中心同士の距離\n    bool include(const Point&) const;                       // 点を含むか\n    bool include(const Circle&) const;                      // 円を含むか\n    bool intersect(const Circle&) const;\n    vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x == p.x && y == p.y;}\nbool Point::operator<(const Point &p) const {return x != p.x ? x < p.x : y < p.y;}\nbool Point::operator>(const Point &p) const {return x != p.x ? x > p.x : y > p.y;}\nbool Point::operator<=(const Point &p) const {return x != p.x ? x < p.x : y <= p.y;}\nbool Point::operator>=(const Point &p) const {return x != p.x ? x > p.x : y >= p.y;}\nPoint Point::operator+(const Point& p) const {return Point(x + p.x, y + p.y);}\nPoint Point::operator-(const Point& p) const {return Point(x - p.x, y - p.y);}\nPoint Point::operator-() const {return Point(-x, -y);}\nPoint Point::times(double d) const {return Point(x * d, y * d);}\nPoint& Point::operator=(const Point& p) {x = p.x; y = p.y; return *this;}\nPoint& Point::operator+=(const Point& p) {x += p.x; y += p.y; return *this;}\nPoint& Point::operator-=(const Point& p) {x -= p.x; y -= p.y; return *this;}\ndouble Point::dot(const Point& p) const {return x * p.x + y * p.y;}\ndouble Point::cross(const Point& p) const {return x * p.y - y * p.x;}\ndouble Point::abs() const {return hypot(x, y);}\ndouble Point::norm() const {return x * x + y * y;}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nPoint Point::projection(const Line& l) const {return l.projection(*this);}\nPoint Point::reflection(const Line& l) const {return l.reflection(*this);}\nint Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > 0.0) return 1;\n    if(v1.cross(v2) < 0.0) return -1;\n    if(v1.dot(v2) < 0.0) return 2;\n    if(v1.norm() < v2.norm()) return -2;\n    return 0;\n}\n// Segment\nLine Segment::line() const {return Line(source, target);}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    double a = source.distance(p);\n    double b = target.distance(p);\n    return a < b ? a : b;\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source);\n    double b = distance(s.target);\n    double c = s.distance(source);\n    double d = s.distance(target);\n    a = a < b ? a : b;\n    a = a < c ? a : c;\n    return a < d ? a : d;\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {\n    return source.distance(p) + target.distance(p) - target.distance(source) <= EPS;\n}\nbool Segment::intersect(const Segment& s) const {\n    bool a = s.source.ccw(s.target, source) * s.source.ccw(s.target, target) <= EPS;\n    bool b = source.ccw(target, s.source) * source.ccw(target, s.target) <= EPS;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\n// Line\nSegment Line::segment() const {return Segment(source, target);}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source);\n    double b = distance(s.target);\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source);}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source - p;\n    Point v2 = target - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target - source;\n    Point v2 = s.source - source;\n    Point v3 = s.target - source;\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target - source;\n    Point v2 = l.target - l.source;\n    Point v3 = l.source - source;\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nPoint Line::projection(const Point& p) const {\n    Point v1 = p - source;\n    Point v2 = source - target;\n    return Point(source + v2.times(v1.dot(v2) / v2.norm()));\n}\nPoint Line::reflection(const Point& p) const {\n    return p + (projection(p) - p).times(2.0);\n}\nPoint Line::crosspoint(const Line& l) const {\n    Point v1 = target - source;\n    Point v2 = l.target - l.source;\n    Point v3 = target - l.source;\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source;\n    return l.source + v2.times(b / a);\n}\n// Circle\nPoint Circle::point() const {return Point(x, y);}\ndouble Circle::distance(const Point& p) const {return point().distance(p);}\ndouble Circle::distance(const Circle& c) const {return point().distance(c.point());}\nbool Circle::include(const Point& p) const {return distance(p) - r <= EPS;}\nbool Circle::include(const Circle& c) const {return distance(c) - (r - c.r) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return distance(c) - r - c.r <= EPS;}\nvector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y - y, c.x - x);\n    double d = distance(c);\n    double add = acos((d * d + r * r - c.r * c.r) / (2.0 * d * r));\n    vector<Point> result;\n    result.push_back(Point(x + r * cos(angle + add), y + r * sin(angle + add)));\n    result.push_back(Point(x + r * cos(angle - add), y + r * sin(angle - add)));\n    return result;\n}\n\nint main() {\n    int n;\n    while(cin>>n, n) {\n        vector<Circle> circle;\n        vector<Circle> crosspoint;\n        for(int i = 0; i < n; i++) {\n            double x, y;\n            cin>>x>>y;\n            circle.push_back(Circle(x, y, 1.0));\n        }\n        for(int i = 0; i < n - 1; i++) {\n            for(int j = i + 1; j < n; j++) {\n                if(!circle[i].intersect(circle[j])) continue;\n                vector<Point> p = circle[i].crosspoint(circle[j]);\n                crosspoint.push_back(Circle(p[0].x, p[0].y, 1.0));\n                crosspoint.push_back(Circle(p[1].x, p[1].y, 1.0));\n            }\n        }\n        int answer = 0;\n        for(int i = 0; i < crosspoint.size(); i++) {\n            int count = 0;\n            for(int j = 0; j < n; j++) {\n                if(crosspoint[i].include(circle[j].point())) count++;\n            }\n            if(answer < count) answer = count;\n        }\n        cout<<answer<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#define EPS 1.0e-5\nusing namespace std;\ntypedef double elem;\ntypedef complex<elem> point,vec;\ninline elem dist(const point &a, const point &b){return abs(a-b);}\ninline vec normr(const vec &v){return v*vec(0,-1);}\ninline vec norml(const vec &v){return v*vec(0,1);}\ninline vec unormr(const vec &v){return normr(v) / abs(v);}\ninline vec unorml(const vec &v){return norml(v) / abs(v);}\nint main(){\n\twhile(true){\n\t\tint ans = 0;\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tvector< point > points;\n\t\tfor(int i=0;i<n;++i){\n\t\t\telem x, y;\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tpoints.push_back( point(x,y) );\n\t\t}\n\t\tfor(unsigned int i = 0; i < points.size(); ++i){\n\t\t\tfor(unsigned int j = 0; j < points.size(); ++j){\n\t\t\t\tif( i != j && dist( points[i], points[j] ) < 2 ){\n\t\t\t\t\tint count_p = 0;\n\t\t\t\t\tint count_q = 0;\n\t\t\t\t\telem d = sqrt(1-pow(dist(points[i], points[j])/2,2 ) );\n\t\t\t\t\tpoint p,q;\n\t\t\t\t\tvec ab = points[j] - points[i];\n\t\t\t\t\tpoint t = 0.5 * ab + points[i];  \n\t\t\t\t\tp = d * unormr(ab) + t;\n\t\t\t\t\tq = d * unorml(ab) + t;\n\t\t\t\t\tfor(unsigned int k = 0; k < points.size(); ++k){\n\t\t\t\t\t\tif( dist(p, points[k]) <= 1.0+EPS ){ count_p++; }\n\t\t\t\t\t\tif( dist(q, points[k]) <= 1.0+EPS ){ count_q++; }\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans, max(count_q, count_p) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//???????????????????????????, ?????????????????????????????°????????????????????????????????????????????????2???????????¨???????????£?????\\????????¨?????§????????????\n//?????£???, 2??????????????????1?????????????????????????????????????????°??????????????????????£????, O(N^2)????????????????????????, ??¨?????§O(N^3)????????§?§£?????????\n#include <iostream>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> Point;\n\nint n;\ndouble x[300], y[300];\nvector<Point> points;\t//????£???????\n\nint main() {\n\twhile (cin >> n) {\n\t\tif (n == 0) break;\n\t\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\t\tif (n == 1) { cout << 1 << endl; continue; }\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tPoint p1 = Point(x[i], y[i]);\n\t\t\t\tPoint p2 = Point(x[j], y[j]);\n\t\t\t\tif (norm(p1 - p2) < 4) {\n\t\t\t\t\tdouble h = sqrt(1.0 - norm(p1 - p2) / 4.0);\n\t\t\t\t\tPoint t = p2 - p1; t /= abs(t);\n\t\t\t\t\tPoint u = t * Point(0, 1);\n\t\t\t\t\tpoints.push_back(p1 + t * abs(p1 - p2) / 2.0 + u * h);\n\t\t\t\t\tpoints.push_back(p1 + t * abs(p1 - p2) / 2.0 - u * h);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble eps = 1e-10;\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < points.size(); i++) {\n\t\t\tdouble px = points[i].real();\n\t\t\tdouble py = points[i].imag();\n\t\t\tint cnt = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ((x[j] - px) * (x[j] - px) + (y[j] - py) * (y[j] - py) < 1 + eps) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ans < cnt) ans = cnt;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\nR radNorP(R x) {\n    return fmod(fmod(x, 2*PI)+2*PI, 2*PI);\n}\n\nconst int MN = 330;\n\nP p[MN];\ntypedef pair<R, int> Pi;\n\nbool solve() {\n    int n;\n    scanf(\"%d\", &n);\n    if (!n) return false;\n\n    for (int i = 0; i < n; i++) {\n        R x, y;\n        scanf(\"%lf %lf\", &x, &y);\n        p[i] = P(x, y);\n    }\n\n    int res = 1;\n    vector<Pi> v;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            if (2.0 < abs(p[j]-p[i])) continue;\n            R th = acos(abs(p[j]-p[i])/2.0);\n            R l = radNorP(arg(p[j]-p[i])-th-EPS);\n            R r = radNorP(arg(p[j]-p[i])+th+EPS);\n            if (r < l) {\n                v.push_back(Pi(l-EPS, 1));\n                v.push_back(Pi(2*PI+EPS, -1));\n                v.push_back(Pi(0-EPS, 1));\n                v.push_back(Pi(r+EPS, -1));\n            } else {\n                v.push_back(Pi(l-EPS, 1));\n                v.push_back(Pi(r+EPS, -1));\n            }\n\n        }\n\n        sort(v.begin(), v.end());\n        int sm = 1;\n        for (Pi p: v) {            \n            sm += p.second;\n            res = max(res, sm);\n        }\n        v.clear();\n    }\n    cout << res << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> C;\n\nint solve(int N, vector<double>& x, vector<double>& y) {\n    vector<C> point(N);\n\n    for (int j = 0; j < N; ++j) {\n        point[j] = C(x[j], y[j]);\n    }\n\n    int ret = 1;\n\n    for (int j = 0; j < N; ++j) {\n        for (int k = j+1; k < N; ++k) {\n            C mid = (point[j] + point[k]) * 0.5;\n\n            C normal = (point[j] - point[k]) * C(0, 1);\n            normal /= abs(point[j] - point[k]);\n\n            double a = sqrt(1 - norm(mid - point[j]));\n\n            C centre1 = mid + a * normal;\n            int count = 0;\n            for (int l = 0; l < N; ++l) {\n                if (abs(centre1 - point[l]) < 1.0 + 1e-9) {\n                    ++count;\n                }\n            }\n            ret = max(ret, count);\n\n            C centre2 = mid - a * normal;\n            count = 0;\n            for (int l = 0; l < N; ++l) {\n                if (abs(centre2 - point[l]) < 1.0 + 1e-9) {\n                    ++count;\n                }\n            }\n            ret = max(ret, count);\n\n        }\n    }\n\n    return ret;\n}\n\nint main () {\n    int N;\n    vector<double> x, y;\n\n    while (true) {\n        cin >> N;\n        if (N == 0) break;\n\n        x.resize(N);\n        y.resize(N);\n\n        for (int j = 0; j < N; ++j) {\n            cin >> x[j] >> y[j];\n        }\n\n        cout << solve(N, x, y) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double r = 1.0;\nconst double PI = acos(-1.0);\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y) : x(x), y(y) {}\n};\ninline double Distance2(const Point &a, const Point &b) {\n    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    std::random_device rnd;\n    std::mt19937 mt(rnd());\n    std::uniform_real_distribution<> rand100(0.0, 10.0);\n\n    while (cin >> n, n) {\n        // Input\n        vector<Point> p(n);\n        for (int i = 0; i < n; ++i)\n            cin >> p[i].x >> p[i].y;\n\n        // Solve\n        int ans = 1;\n        auto start = std::chrono::high_resolution_clock::now();\n        auto end = std::chrono::high_resolution_clock::now();\n        auto take_time = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n\n        while (true) {\n            end = std::chrono::high_resolution_clock::now();\n            take_time = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n            if (280 < take_time.count())\n                break;\n\n            for (int i = 0; i < 10; ++i) {\n                Point c(rand100(mt), rand100(mt));\n                int num = 0;\n                for (int j = 0; j < n; ++j) {\n                    double d = Distance2(p[j], c);\n                    if (d <= 1.0)\n                        ++num;\n                }\n                ans = max(ans, num);\n            }\n        }\n\n        // Output\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<vector>\n#define mp make_pair\n#define pb push_back\n#define rep(i,n) for(int i = 0;i < n;i++)\nusing namespace std;\n\ndouble dist(double x1,double y1,double x2,double y2){\n    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\n\ndouble dist(double x1,double y1){\n    return dist(x1,y1,0,0);\n}\n\nvoid calccenter(double c[][2],double u1[],double u2[]){\n    double v[2]={u2[0]-u1[0],u2[1]-u1[1]};\n    rep(i,2) {\n        rep(j,2){\n            c[i][j]=(u1[j]+u2[j])/2.0;\n        }\n    }\n    double lenv = dist(v[0],v[1]);\n    double lent = sqrt(1-pow((lenv/2.0),2));\n    rep(i,2){\n        double dg = i?1.0:-1.0;\n        c[i][0]+=dg*(v[1]*lent/lenv);\n        c[i][1]-=dg*(v[0]*lent/lenv);\n    }\n}\n\nint main(){\n    int N;\n    while(1){\n        cin>>N;\n        if(!N)break;\n        double a[300][2];\n        rep(i,N){\n            cin>>a[i][0]>>a[i][1];\n        }\n        int ans = 0;\n        int temp = 0;\n        rep(u1,N){\n            for(int u2 = u1+1;u2<N;u2++){\n                double c[2][2];\n                calccenter(c,a[u1],a[u2]);\n                rep(k,2){\n                    temp = 0;\n                    rep(l,N){\n                        if(l==u1||l==u2){\n                            temp++;\n                        }else if(dist(c[k][0],c[k][1],a[l][0],a[l][1])<=1.0){\n                            temp++;\n                        }\n                    }\n                    ans = max(ans,temp);\n                }\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n#define EPS 1.0e-8\ntypedef complex<double> P;\n\nP center(P a, P b){\n  P m  = (a+b) / 2.0;         // p[i]Æp[j]Ì_\n  P n = (a-b) * P(0.0,1.0);  // @üxNg\n  n = n / abs(n);\n  \n  double x = abs( a-b )/2.0;\n  return m + n * sqrt( 1.0-x*x );     // ~ÌS\n}\n\nint main(){\n  int n;\n  P p[301];\n\n  while( cin>>n && n ){\n    for( int i=0;i<n;i++ )\n      cin >> p[i].real() >> p[i].imag();\n\n    int ans=0;\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ ){\n\tif( i==j ) \t  continue;\n\tif( abs( p[i]-p[j] )+EPS > 2.0 ) continue;\n\tP c = center( p[i],p[j] );\n\n\tint num=0;\n\tfor( int k=0;k<n;k++ )\n\t  if( abs( c-p[k] ) < 1.0 + EPS  )\n\t    num++;\n\tans = max( ans,num );\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\n\nclass P\n{\npublic:\n\tdouble x,y;\n\tP(double x=0.0,double y=0.0):x(x),y(y){}\n\tP operator+(const P p)const{return P(x+p.x,y+p.y);}\n\tP operator-(const P p)const{return P(x-p.x,y-p.y);}\n};\n\ndouble dis(P p1,P p2)\n{\n\treturn hypot(p1.x-p2.x,p1.y-p2.y);\n}\n\nP getc(P p1,P p2)\n{\n\tdouble theta=acos(dis(p1,p2)/2.0);\n\tdouble alpha=atan2(p2.y-p1.y,p2.x-p1.x);\n\treturn P(p1.x+cos(alpha-theta),p1.y+sin(alpha-theta));\n}\n\nbool in(P c,P p)\n{\n\treturn dis(c,p)<1.0+1e-9;\n}\n\nint main()\n{\n\tint n;\n\twhile(cin>>n,n)\n\t{\n\t\tP p[300];\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>p[i].x>>p[i].y;\n\t\t}\n\t\tint m=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=i+1;j<n;j++)\n\t\t\t{\n\t\t\t\tP a=p[i],b=p[j];\n\t\t\t\tP c=getc(a,b);\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t{\n\t\t\t\t\tif(k==i||k==j)cnt++;\n\t\t\t\t\telse if(in(c,p[k]))cnt++;\n\t\t\t\t}\n\t\t\t\tm>cnt?:m=cnt;\n\t\t\t}\n\t\t}\n\t\tcout<<m<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#define eq(a,b) (fabs(a-b) < eps)\n#define leq(a,b) (a - b < eps)\n#define lt(a,b) (a - b < -eps)\n\nconst double EPS = 1e-4; // epsilon\nconst double R = 1;      // radius of circle\n\n/* Distance from (x1,y1) to (x2,y2) */\ndouble dist(std::pair<double, double> a, std::pair<double, double> b) {\n    \n    double ax, ay, bx, by;\n    ax = a.first;\n    ay = a.second;\n    bx = b.first;\n    by = b.second;\n    return std::sqrt(\n                        (by - ay) * (by - ay) +\n                        (bx - ax) * (bx - ax)\n                    );\n}\n\n/* Midpoint of two points */\nstd::pair<double, double>\ngetMidpoint(std::pair<double, double> a, std::pair<double, double> b) {\n    std::pair<double, double> mid;\n    mid.first = (a.first + b.first) / 2;\n    mid.second = (a.second + b.second) / 2;\n    return mid;\n}\n\nstd::pair<std::pair<double,double>, std::pair<double,double>>\ncircleLineInter(std::pair<double, double> center, double r, double m, double c) {\n\n    std::pair<double,double> inter1;\n    std::pair<double,double> inter2;\n    \n    double p = center.first;\n    double q = center.second;\n    \n    double A = m*m + 1;\n    double B = 2*(m*c-m*q-p);\n    double C = q*q - r*r + p*p -2*c*q + c*c;\n    \n    inter1.first = (-B + std::sqrt(B*B - 4*A*C)) / (2*A);\n    inter1.second = m * inter1.first + c;\n    \n    inter2.first = (-B - std::sqrt(B*B - 4*A*C)) / (2*A);\n    inter2.second = m * inter2.first + c;\n    \n    return std::make_pair(inter1, inter2);\n}\n\ndouble getYInter(double m, std::pair<double, double> a) {\n    return a.second - m * a.first;\n}\n\ndouble getGradient(std::pair<double, double> a, std::pair<double, double> b) {\n    return (b.second - a.second) /\n           (b.first - a.first);\n}\n\nint main() {\n    int n;\n    while (std::cin >> n) {\n        if (n <= 0) break;\n        int maxPts = 1;\n        if (n > 1) {\n            std::vector<std::pair<double, double>> pts;\n        \n            // insert points into vector\n            for(int i = 0; i < n; ++i) {\n                double x, y;\n                std::cin >> x >> y;\n                pts.emplace_back(x, y);\n            }\n            \n            for (unsigned int i = 0; i < pts.size() - 1; ++i) {\n                for (unsigned int j = i + 1; j < pts.size(); ++j) {\n                    // std::pair<double, double> a, b;\n                    auto a = pts.at(i);\n                    auto b = pts.at(j);\n                    if( dist(a, b) <= 2*(R-EPS)) {\n                        int numPts = 0;\n                        \n                        auto midpoint = getMidpoint(a, b);\n                        auto m = getGradient(a,b);\n                        m = -1 / m;\n                        auto intersects = circleLineInter(a, R, m, getYInter(m, midpoint));\n                        \n                        auto c = intersects.first;\n                        // std::cout << c.first << \" \" << c.second << \"\\n\";\n                        for (unsigned int k = 0; k < pts.size(); ++k) {\n                            auto p = pts.at(k);\n                            if (dist(c, p) <= (R + EPS)) {\n                                numPts++;\n                            }\n                        }\n                        maxPts = std::max(numPts, maxPts);\n                        \n                        numPts = 0;\n                        c = intersects.second;\n                        // std::cout << c.first << \" \" << c.second << \"\\n\";\n                        for (unsigned int k = 0; k < pts.size(); ++k) {\n                            auto p = pts.at(k);\n                            if (dist(c, p) <= (R + EPS)) {\n                                numPts++;\n                            }\n                        }\n                        maxPts = std::max(numPts, maxPts);\n                    }\n                }\n            }\n        \n        }\n        std::cout << maxPts << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <algorithm>\n#include <utility>\n#include <iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define re real()\n#define im imag()\nusing namespace std;\nint main(){\n\twhile(true){\n\t\tint n,mx=1;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\tcomplex<double> p[300];\n\t\trep(i,n) scanf(\"%lf%lf\",&p[i].re,&p[i].im);\n\t\trep(i,n) rep(j,i){\n\t\t\tdouble d=abs(p[i]-p[j]);\n\t\t\tif(d>2) continue;\n\t\t\tcomplex<double> c=(p[i]+p[j])/2.0,dis=(p[i]-p[j])/d*sqrt(1-d*d/4);\n\t\t\tswap(dis.re,dis.im);\n\t\t\tdis.im=-dis.im;\n\t\t\tcomplex<double> cen=c+dis;\n\t\t\tint cnt=0;\n\t\t\trep(k,n) if(abs(cen-p[k])<=1.0000000001) cnt++;\n\t\t\tmx=max(mx,cnt);\n\t\t\tcen=c-dis;\n\t\t\tcnt=0;\n\t\t\trep(k,n) if(abs(cen-p[k])<=1.0000000001) cnt++;\n\t\t\tmx=max(mx,cnt);\n\t\t}\n\t\tprintf(\"%d\\n\",mx);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS (1e-10)\nusing namespace  std;\n\ntypedef complex<double> V;\n\nint n;\nvector<V> points;\n\npair<V, V> circles(const V& a, const V& b) {\n  V v = a - b;\n  double dist = abs(v);\n  V n1 = (v * V(0, 1)) / dist;\n  V n2 = (v * V(0, -1)) / dist;\n\n  dist /= 2;\n  double x = sqrt(1 - (dist * dist));\n\n  return make_pair((b + v / 2.) + x * n1, (b + v / 2.) + x * n2);\n}\n\nint countInCircle(const V& center) {\n  int count = 0;\n  for (auto p : points) {\n    if (abs(p - center) < 1 + EPS) count++;\n  }\n  return count;\n}\n\nint solve() {\n  int count = 1;\n  for (int i = 0; i < n - 1; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      if (abs(points[i] - points[j]) < 2 + EPS) {\n\tauto c = circles(points[i] , points[j]);\n\tcount = max(count, countInCircle(c.first));\n\tcount = max(count, countInCircle(c.second));\n      }\n    }\n  }\n  return count;\n}\n\nint main() {\n  while(cin >> n, n) {\n    points = vector<V>(n);\n    for (int i = 0; i < n; ++i) {\n      double x, y;\n      cin >> x >> y;\n      points[i] = V(x, y);\n    }\n\n    cout << solve() << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nclass P{\npublic:\n\tdouble x,y;\n\tP(){}\n\tP(double xx,double yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tP operator +(P p){\n\t\treturn P(x+p.x,y+p.y);\n\t}\n\tP operator -(P p){\n\t\treturn P(x-p.x,y-p.y);\n\t}\n\tP operator /(double d){\n\t\treturn P(x/d,y/d);\n\t}\n};\n\nint n;\nP p[301];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf%lf\",&p[i].x,&p[i].y);\n\t\t}\n\t\tint res=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tP np=p[j]-p[i];\n\t\t\t\t//printf(\"%lf %lf\\n\",np.x,np.y);\n\t\t\t\tdouble blen=np.x*np.x/4.0+np.y*np.y/4.0;\n\t\t\t\tif(blen>1.0)continue;\n\t\t\t\tdouble len=sqrt(1-blen);\n\t\t\t\tdouble dir=atan2(np.y,np.x);\n\t\t\t\tP cp=(p[i]+p[j])/2+P(len*cos(dir+M_PI/2),len*sin(dir+M_PI/2));\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tdouble len2=sqrt((cp.x-p[k].x)*(cp.x-p[k].x)+(cp.y-p[k].y)*(cp.y-p[k].y));\n\t\t\t\t\tif(len2<=1.0001)cnt++;\n\t\t\t\t}\n\t\t\t\tres=max(res,cnt);\n\t\t\t\tcp=(p[i]+p[j])/2+P(len*cos(dir-M_PI/2),len*sin(dir-M_PI/2));\n\t\t\t\tcnt=0;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tdouble len2=sqrt((cp.x-p[k].x)*(cp.x-p[k].x)+(cp.y-p[k].y)*(cp.y-p[k].y));\n\t\t\t\t\tif(len2<=1.0001)cnt++;\n\t\t\t\t}\n\t\t\t\tres=max(res,cnt);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#define EPS 0.0001\nusing namespace std;\ntypedef double elem;\ntypedef complex<elem> point,vec;\ninline elem dist(const point &a, const point &b){return abs(a-b);}\ninline vec normr(const vec &v){return v*vec(0,-1);}\ninline vec norml(const vec &v){return v*vec(0,1);}\ninline vec unormr(const vec &v){return normr(v) / abs(v);}\ninline vec unorml(const vec &v){return norml(v) / abs(v);}\nint main(){\n\twhile(true){\n\t\tint ans = 0;\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tif(n==1){\n\t\t\tprintf(\"1\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tvector< point > points;\n\t\tfor(int i=0;i<n;++i){\n\t\t\telem x, y;\n\t\t\tscanf(\"%Lf%Lf\", &x, &y);\n\t\t\tpoints.push_back( point(x,y) );\n\t\t}\n\t\tfor(unsigned int i = 0; i < points.size(); ++i){\n\t\t\tfor(unsigned int j = 0; j < points.size(); ++j){\n\t\t\t\tif( i != j && dist( points[i], points[j] ) < 2+EPS ){\n\t\t\t\t\tint count_p = 0;\n\t\t\t\t\tint count_q = 0;\n\t\t\t\t\telem d = sqrt(1-pow(dist(points[i], points[j])/2,2 ) );\n\t\t\t\t\tpoint p,q;\n\t\t\t\t\tvec ab = points[j] - points[i];\n\t\t\t\t\tpoint t = 0.5 * ab + points[i];  \n\t\t\t\t\tp = d * unormr(ab) + t;\n\t\t\t\t\tq = d * unorml(ab) + t;\n\t\t\t\t\tfor(unsigned int k = 0; k < points.size(); ++k){\n\t\t\t\t\t\tif( dist(p, points[k]) < 1.0+EPS ){ count_p++; }\n\t\t\t\t\t\tif( dist(q, points[k]) < 1.0+EPS ){ count_q++; }\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans, max(count_q, count_p) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n \n \nusing namespace std;\n \ntypedef double Real;\n \nReal EPS = 1e-8;\n \nint sgn(Real a, Real b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\nReal sqr(Real a){return sqrt(max(a,(Real)0));}\n \nstruct Point{  \n  Real add(Real a, Real b){\n    if(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n    return a+b;\n  }\n \n  Real x, y;\n  Point(){}\n  Point(Real x,Real y) : x(x) , y(y){}\n \n  Point operator + (Point p){return Point(add(x,p.x), add(y,p.y));}\n  Point operator - (Point p){return Point(add(x,-p.x), add(y,-p.y));}\n  Point operator * (Real d){return Point(x*d,y*d);}\n  Point operator / (Real d){return Point(x/d,y/d);}\n  bool operator == (Point p){return !sgn(dist(p));}\n  bool operator < (Point p){return (p.x!=x)?p.x<x:p.y<y;}\n  Real norm(){return sqr(x*x+y*y);}\n  Real dist(Point a){return (*this-a).norm();}\n  Real dot(Point a){return x*a.x+y*a.y;}\n  Real cross(Point a){return x*a.y-y*a.x;}\n};\n \nstruct Circle{\n  Point p;\n  Real r;\n  Circle(){}\n  Circle(Point p, Real r) : p(p) , r(r){}\n   \n  vector<Point> intersectionPoints(Circle b){\n    vector<Point> res;\n \n    Point tmp=p-b.p;\n    if(tmp.norm()>pow(r+b.r,2))return res;\n \n    Real L = p.dist(b.p);\n    Real C = atan2(b.p.y-p.y,b.p.x-p.x);\n    Real a = acos((L*L+r*r-b.r*b.r)/(2*L*r));\n \n    res.push_back(Point(p.x+cos(C+a), p.y+sin(C+a))*2);\n    res.push_back(Point(p.x+cos(C-a), p.y+sin(C-a))*2);\n    return res;\n  }\n};\n \nint main(void){\n  int n;\n  Point a;\n  vector<Point>P;\n  vector<Circle>C;\n \n  while(cin >> n,n){\n    P.clear();\n    C.clear();\n    for(int i=0;i<n;i++){\n      cin >> a.x >> a.y;\n      P.push_back(a);\n    }\n \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n    if(sgn(P[i].dist(P[j]),2.0)>=0)continue;\n    vector<Point>res=Circle(P[i],1.0).intersectionPoints(Circle(P[j],1.0));\n    for(int k=0;k<res.size();k++)\n      C.push_back(Circle(res[k],1));\n      }\n    }\n \n    int ans=1;\n    for(int i=0;i<C.size();i++){\n      int cnt=0;\n      for(int j=0;j<P.size();j++)\n    if(sgn(C[i].p.dist(P[j]),1.0)<=0)cnt++;\n \n      ans=max(ans,cnt);\n    }\n    cout << ans << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,N) for(int i=0;i<(int)(N);i++)\n#define REP(i,k,N) for(int i=k;i<(int)(N);i++)\n\n#define vi vector<int>\n#define pb push_back\n\n#define pdd pair<double,double>\n#define fi first\n#define se second\nconst double  EPS = 1e-9;\n\ndouble dist(double x,double y){\n    return x*x+y*y;\n};\n\nint main(){\n    ifstream in(\"d_in.txt\");\n    cin.rdbuf(in.rdbuf());\n    int n;\n    while(cin >> n,n){\n        int ma = 0;\n        pdd p[330];\n        rep(i,n) cin >> p[i].fi >> p[i].se;\n        rep(i,n-1){\n            REP(j,i+1,n){\n                int cnt1 = 0,cnt2=0;\n                double x1,y1,x2,y2,x3,y3;\n                tie(x1,y1) = p[i];\n                tie(x2,y2) = p[j];\n                double cx1,cy1,cx2,cy2;\n                if(dist(x1-x2,y1-y2)-4 > EPS  ) continue;\n\n                //はりまコーナー\n//                double ax,ay,bx1,by1,bx2,by2,mx,my,dx,dy;\n//                ax=x1-x2;ay=y1-y2;\n//                mx=(x1+x2)/2;my=(y1+y2)/2;\n//                by1 = (-0.5)*pow(ax,4)+pow(ax,2)+(-0.5)*pow(ax,2)*pow(ay,2)\n//                        /dist(ax,ay);\n//                by1 = sqrt(abs(by1));\n//                by2 = -1*by1;\n//                cy1= my+by1;\n//                cy2= my+by2;\n//                bx1= -1*(ay*by1)/ax;\n//                bx2= -1*(ay*by2)/ax;\n//                cx1=bx1+mx;\n//                cx2=bx2+mx;\n\n\n                //あじのりコーナー\n                double mx=(x1+x2)/2,my=(y1+y2)/2;\n\n                double ld = 1-dist((x1-x2)/2,(y1-y2)/2);\n                ld = sqrt(ld);\n                cx1 = mx - sin(atan((y2-y1)/(x2-x1)))*ld;\n                cy1 = my + cos(atan((y2-y1)/(x2-x1)))*ld;\n                cx2 = mx + sin(atan((y2-y1)/(x2-x1)))*ld;\n                cy2 = my - cos(atan((y2-y1)/(x2-x1)))*ld;\n\n                for(int k = 0;k<n;k++) {\n                    tie(x3, y3) = p[k];\n                    if (EPS > dist((cx1 - x3), (cy1 - y3))-1) cnt1++;\n                    if (EPS > dist((cx2 - x3), (cy2 - y3))-1) cnt2++;\n                }\n                ma = max({cnt1,cnt2,ma});\n            }\n        }\n        cout<< ma << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\n#define EPS 1e-8\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n\ntypedef complex<double> P;\n\nP getMiddle(P a, P b) {\n    return (a + b) / 2.0;\n}\n\nP getUnit(P a) {\n    return a / abs(a);\n}\n\npair<P, P> getNormals(P a) {\n    return make_pair((a / abs(a)) * P(0, 1), (a / abs(a)) * P(0, -1));\n}\n\nint main() {\n\n    while (true) {\n\n        int N;\n        cin >> N;\n\n        if (N == 0) break;\n\n        vector<P> points(N);\n        for (int i = 0; i < N; i++) {\n            double x, y;\n            cin >> x >> y;\n            points[i] = P(x, y);\n        }\n\n        int maxV = 1;\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n\n                P p1 = points[i];\n                P p2 = points[j];\n                P middle = getMiddle(p1, p2);\n\n                double a, b, c;\n                b = abs(middle - p2);\n                c = 1.0;\n                if (b * b + EPS > 1.0) continue;\n                a = sqrt(1.0 - b * b);\n\n                P o1 = middle + ((p2 - p1) / abs(p2 - p1)) * P(0, 1) * a;\n                P o2 = middle + ((p2 - p1) / abs(p2 - p1)) * P(0, -1) * a;\n\n                int count = 0;\n                for (int k = 0; k < N; k++) {\n                    double dx = o1.real() - points[k].real();\n                    double dy = o1.imag() - points[k].imag();\n                    if (dx * dx + dy * dy < 1.0 + EPS) count++;\n                }\n                maxV = max(maxV, count);\n\n                count = 0;\n                for (int k = 0; k < N; k++) {\n                    double dx = o2.real() - points[k].real();\n                    double dy = o2.imag() - points[k].imag();\n                    if (dx * dx + dy * dy < 1.0 + EPS) count++;\n                }\n                maxV = max(maxV, count);\n            }\n        }\n\n        cout << maxV << endl;\n\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\nusing namespace std;\n\n#include <bits/stdc++.h>\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic const DOUBLE d_PI = 3.14159265358979323846;\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n/*----------------------------------------------*/\n\n\n/*----------------------------------------------*/\n\nstruct VECTOR_2D {\n    DOUBLE dX;\n    DOUBLE dY;\n    VECTOR_2D(DOUBLE x, DOUBLE y) : dX(x), dY(y) {};\n    VECTOR_2D() : dX(0), dY(0) {};\n\n\tVECTOR_2D& operator-= (const VECTOR_2D a)\n    { \n        dX = dX - a.dX;\n        dY = dY - a.dY;\n        return *this;\n    };\n    const VECTOR_2D operator- (const VECTOR_2D a) const {\n\t\treturn VECTOR_2D(dX - a.dX, dY - a.dY);\n    };\n\n    DOUBLE norm(void)\n    {\n        return (dX * dX + dY * dY);\n    }\n\n    DOUBLE dist(void)\n    {\n        return sqrt(norm());\n    }\n\n    DOUBLE angle(void)\n    {\n        return atan2(dY, dX);\n    }\n};\n\n\nstruct PROBLEM_ONE {\n    SQWORD sqN;\n    vector<VECTOR_2D> vecCenter;\n};\n\nstatic DOUBLE normalizeAngle(DOUBLE dAngle)\n{\n    DOUBLE dRet = dAngle;\n    while (dRet < 0.0) {\n        dRet += (2.0 * d_PI);\n    }\n\n    while ((2.0 * d_PI) < dRet) {\n        dRet -= (2.0 * d_PI);\n    }\n\n    return dRet;\n}\n\n\nenum PNT_EVENT_TYPE {\n    PNT_EVENT_ADD = 0,\n    PNT_EVENT_SUB\n};\n\nstruct INTERSECTION {\n    DOUBLE dAngle;\n    SQWORD sqCircleIdx;\n    PNT_EVENT_TYPE  eEv;\n\n    INTERSECTION(DOUBLE d, SQWORD idx, PNT_EVENT_TYPE e): dAngle(d), sqCircleIdx(idx), eEv(e) {};\n};\n\nbool operator< (const INTERSECTION &a, const INTERSECTION &b)\n{\n    return a.dAngle < b.dAngle;\n}\n\n\nstatic void solve(PROBLEM_ONE &stPro) {\n\n    SQWORD sqMaxIntersect = 0;\n\n    for (SDWORD sqBaseIdx = 0; sqBaseIdx < stPro.sqN; sqBaseIdx++) {\n        VECTOR_2D stBase = stPro.vecCenter[sqBaseIdx];\n        vector<INTERSECTION> vecstIntersection;\n\n        for (SQWORD sqTgtIdx = 0; sqTgtIdx < stPro.sqN; sqTgtIdx++) {\n            VECTOR_2D stTgt = stPro.vecCenter[sqTgtIdx];\n            if (sqTgtIdx != sqBaseIdx) {\n                VECTOR_2D stRel = stTgt - stBase;\n                DOUBLE dDist = stRel.dist();\n\n                if (dDist < 2.0) {\n                    DOUBLE dCenterAngle = stRel.angle();\n                    DOUBLE dRelAngle = acos(dDist / 2.0);\n                    DOUBLE dAngle1 = normalizeAngle(dCenterAngle - dRelAngle);\n                    DOUBLE dAngle2 = normalizeAngle(dCenterAngle + dRelAngle);\n\n                    vecstIntersection.push_back(INTERSECTION{dAngle1, sqTgtIdx, PNT_EVENT_ADD});\n                    vecstIntersection.push_back(INTERSECTION{dAngle2, sqTgtIdx, PNT_EVENT_SUB});\n                }\n            }\n        }\n        sort(vecstIntersection.begin(), vecstIntersection.end());\n        set<SQWORD> setsqCurCrossing;\n        SQWORD sqCnt = 0;\n        for (SDWORD lCircle = 0; lCircle < 2; lCircle++) {\n            for (auto intsect: vecstIntersection) {\n                SQWORD sqCircleIdx = intsect.sqCircleIdx;\n                if (PNT_EVENT_ADD == intsect.eEv) {\n                    /* 追加 */\n                    setsqCurCrossing.insert(sqCircleIdx);\n                } else {\n                    /* 削除 */\n                    setsqCurCrossing.erase(sqCircleIdx);\n                }\n                sqCnt = max((SQWORD)setsqCurCrossing.size(), sqCnt);\n            }\n        }\n        sqMaxIntersect = max(sqMaxIntersect, sqCnt);\n    }\n    cout << (sqMaxIntersect + 1) << endl;\n}\n\n\nint main(void)\n{\n    vector<VECTOR_2D> vecCenter;\n\n    while(1) {\n        PROBLEM_ONE stPro;\n        cin >> stPro.sqN;\n        if (0 == stPro.sqN) {\n            break;\n        }\n\n        stPro.vecCenter.clear();\n        for (SQWORD sqIdx = 0; sqIdx < stPro.sqN; sqIdx++) {\n            DOUBLE dCenterX, dCenterY;\n            cin >> dCenterX >> dCenterY;\n\n            stPro.vecCenter.push_back(VECTOR_2D{dCenterX, dCenterY});\n        }\n        solve(stPro);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <set>\n\nusing namespace std;\n\n\nint main(){\n\tint n;\n\tdouble x1,y1,xc,yc,dis,vx,vy,ex,ey;\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\tvector<double> x(n);\n\t\tvector<double> y(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tif(n==1){\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans =0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(i==j)break;\n\t\t\t\txc = (x[i]+x[j])/2;\n\t\t\t\tyc = (y[i]+y[j])/2;\n\t\t\t\tdis = sqrt(1.0-(xc-x[i])*(xc-x[i])-(yc-y[i])*(yc-y[i]));\n\t\t\t\tvx = x[i]-x[j];\n\t\t\t\tvy = y[i]-y[j];\n\t\t\t\tex = dis * vy * sqrt(vx*vx+vy*vy);\n\t\t\t\tey = -dis* vx * sqrt(vx*vx+vy*vy);\n\t\t\t\tx1 = xc + ex;\n\t\t\t\ty1 = yc + ey;\n\t\t\t\tint count=0;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i||k==j)count +=1;\n\t\t\t\t\telse{\n\t\t\t\t\t\tif((x1-x[k])*(x1-x[k])+(y1-y[k])*(y1-y[k])<=1.0001){\n\t\t\t\t\t\t\tcount +=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = max(ans,count);\n\t\t\t\tx1 = xc - ex;\n\t\t\t\ty1 = yc - ey;\n\t\t\t\tcount = 0;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i||k==j)count +=1;\n\t\t\t\t\telse{\n\t\t\t\t\t\tif((x1-x[k])*(x1-x[k])+(y1-y[k])*(y1-y[k])<=1.0001){\n\t\t\t\t\t\t\tcount +=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = max(ans,count);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<limits>\n#include<iomanip>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\n\n\n\ntypedef pair<double,double> Point;\n#define F first\n#define S second\n#define MK make_pair\n\nPoint pls(Point a,Point b){\n    return MK(a.F+b.F,a.S+b.S);\n}\n\nPoint mns(Point a,Point b){\n    return MK(a.F-b.F,a.S-b.S);\n}\n\nPoint T(Point t){\n    return MK(t.S,-1.0*t.F);\n}\n\ndouble abs(Point a){\n    return sqrt(a.F*a.F+a.S*a.S);\n}\n\nPoint mid(Point a,Point b){\n    return MK(a.F/2+b.F/2,a.S/2+b.S/2);\n}\n\nbool in(Point c,Point t){\n    if(abs(mns(t,c))<=1){return true;}\n    return false;\n}\n\n\nint main(){\n    while(1){\n        int n;\n        cin>>n;\n        if(n==0){break;}\n        vector<Point> vp;\n        int mx=0;\n        for(int i=0;i<n;i++){\n            double a,b;\n            cin>>a>>b;\n            vp.push_back(MK(a,b));\n        }\n        sort(vp.begin(),vp.end());\n        for(int i=0;i<vp.size();i++){\n            for(int t=i+1;t<vp.size() && vp[t].F-vp[i].F<=2;t++){\n                if(abs(mns(vp[t],vp[i]))>2){continue;}\n                Point m=mid(vp[i],vp[t]);\n                Point l=mns(vp[t],vp[i]);\n                Point lt=T(l);\n                double h=sqrt(1-abs(l)*abs(l)/4);\n                lt.F=h*lt.F/abs(l);\n                lt.S=h*lt.S/abs(l);\n                Point c=pls(m,lt);\n                int count=2;\n                for(int k=0;k<vp.size();k++){\n                    if(k!=i && k!=t && in(c,vp[k])){count++;}\n                }\n                mx=max(mx,count);\n                c=mns(m,lt);\n                count=2;\n                for(int k=0;k<vp.size();k++){\n                    if(k!=i && k!=t && in(c,vp[k])){count++;}\n                }\n                mx=max(mx,count);\n            }\n        }\n        cout<<mx<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n#define OUT 0\n#define ON 1\n#define IN 2\n#define EPS 0.00009\n//#define EPS (1e-10)\nclass P{                    //テァツつケ\npublic:\n\tdouble x,y;\n\t\n\tP(double _x=0,double _y=0):x(_x),y(_y){};\n\tP operator + (const P &p     )const{ return P( x+p.x , y+p.y ); }  //テ・ツ環?ァツョツ?\n\tP operator - (const P &p     )const{ return P( x-p.x , y-p.y ); }  //テヲツクツ崚ァツョツ?\n\tP operator * (const double k )const{ return P( x*k   , y*k    ); } //テ、ツケツ療ァツョツ?\n\tP operator / (const double k )const{ return P( x/k   , y/k    ); } //テゥツ卍、テァツョツ?\n\t\n\tbool operator == (const P &p){ return ( fabs(x-p.x)<EPS && fabs(y-p.y)<EPS ); }\n\tbool operator < (const P &p) const{ return ( x!=p.x ? x<p.x:y<p.y ); }\n\t\n\tdouble norm(){ return x*x+y*y; }        //テ」ツδ偲」ツδォテ」ツδ?\n\tdouble abs() { return sqrt(norm()); }   //テ・ツ、ツァテ」ツ?催」ツ??\n};\nstruct C{P p;double r;};    //テ・ツ??\nstruct S{P p1,p2;};         //テァツキツ堙・ツ按?\ntypedef vector<P> Polygon;  //テ・ツ、ツ堙ィツァツ津・ツスツ「\ntypedef P Vector;           //テ」ツδ凖」ツつッテ」ツδ暗」ツδォ\ntypedef S L;                //テァツ崢エテァツキツ?\n\ndouble norm (P p)               { return p.norm(); }\ndouble abs  (P p)               { return p.abs(); }\ndouble dot  (Vector a,Vector b) { return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b) { return a.x*b.y-a.y*b.x; }\ndouble sqDist(P a, P b)         {return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}\ndouble dist (P a, P b)          {return sqrt(sqDist(a,b));}\nVector vec(S a)                 {return P(a.p2.x-a.p1.x,a.p2.y-a.p1.y);}\n\nint ccw(P p0,P p1,P p2){    //AOJ_BOOK_P386 verified\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\t\n\tif( cross(a,b) > EPS  ) return 1 ;      //COUNTER_CLOCKWISE\n\tif( cross(a,b) < -EPS ) return -1;      //CLOCKWISE\n\tif( dot(a,b)   < -EPS ) return 2;       //ONLINE_BACK\n\tif( a.norm()   < b.norm() ) return -2;  //ONLINE_FRONT\n\t\n\treturn 0;                               //ON_SEGMENT;\n}\n\n//テァツ崢エテァツキツ堙ァツ崢エティツ。ツ古・ツ按、テ・ツョツ?verified AOJ0058\nbool orthogonal(P p1,P p2,P p3,P p4){ return abs(dot(p1-p2,p3-p4))<EPS; }\n\n//テァツキツ堙・ツ按?、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?\nbool intersect(P p1,P p2,P p3,P p4){ return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); }\n\n//テァツキツ堙・ツ按?」ツ?ィテァツつケテ」ツ?ョティツキツ敕ゥツ崢「 verified ARC042-B\ndouble dLP(S l, P p) { return abs(cross(l.p2-l.p1, p-l.p1)) /(l.p2-l.p1).abs(); }\n\n//テァツキツ堙・ツ按?」ツ?ォテ・ツッツセテ」ツ?凖」ツつ凝ァツつケテ」ツ?ョテ・ツーツ?・ツスツア verified AOJ CGL_1_A\nP project(S s, P p){\n\tVector base = s.p2-s.p1;\n\tdouble r = dot(p-s.p1, base)/norm(base);\n\treturn (base*r)+s.p1;\n}\n\n//テァツキツ堙・ツ按?」ツ?ォテ・ツッツセテ」ツ?凖」ツつ凝ァツつケテ」ツ?ョテ・ツ渉催・ツーツ?verified AOJ CGL_1_B\nP reflect(S s,P p){ return p+(project(s,p)-p)*2.0; }\n\n//テァツ崢エテァツキツ堙」ツ?ィテァツ崢エテァツキツ堙」ツ?ョテゥツ鳴「テ、ツソツ?verified AOJ CGL_2\nint rLL(L a,L b){\n\tif( cross(vec(a),vec(b))==0 ) return 2; //テ、ツクツヲティツ。ツ?\n\tif( dot(vec(a),vec(b))==0 )   return 1; //テ・ツ楪づァツ崢エ\n\treturn 0;\n}\n\n// テ・ツ??」ツ?ィテァツつケテ」ツ?ョテ・ツ??・ツ、ツ姪・ツ按、テ・ツョツ?\nint contains(C c, P p){\n\tdouble d = (c.p-p).abs();\n\tif(d-c.r>EPS) return OUT;\n\tif(abs(d-c.r)<EPS) return ON;\n\treturn IN;\n}\n\n//テァツ崢エテァツキツ堙」ツ?ィテ・ツ??」ツ?ョテ、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?テゥツ?催」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝・ツ?エテ・ツ青暗」ツ?ッテ、ツコツ、テ・ツキツョテヲツ可アテ」ツ??\nbool intersect_circle_(P center, double r, L line){\n\tif( dLP(line,center) <= r+EPS ) return true;\n\treturn false;\n}\n\n//テァツキツ堙・ツ按?」ツ?ィテ・ツコツ療」ツ?ョティツキツ敕ゥツ崢「 verified QUPC-G\ndouble dSP(S s, P p){\n\tif(dot((s.p2-s.p1)   , p-s.p1) <= EPS) return (p - s.p1).abs();\n\tif(dot((s.p2-s.p1)*-1, p-s.p2) <= EPS) return (p - s.p2).abs();\n\treturn dLP(s, p);\n}\n\n//テァツキツ堙・ツ按?」ツ?ィテ・ツ??」ツ?ョテ、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?テゥツ?催」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝・ツ?エテ・ツ青暗」ツ?ッテ、ツコツ、テ・ツキツョテヲツ可アテ」ツ?? verified QUPC-G\nbool iCS(C c, S l){\n\tint c1 = contains(c, l.p1);\n\tint c2 = contains(c, l.p2);\n\tif(c1 > c2) swap(c1, c2);\n\t\n\t// (OUT, OUT) (OUT, ON) (OUT, IN) (ON, ON) (ON, IN) (IN, IN) テ」ツ?ョ6テゥツ?堙」ツつ?\n\tif(c1 == OUT && c2 == IN) return true;\n\tif(c1 == IN  && c2 == IN) return false;\n\tif(c1 == ON) return true; // (テヲツ篠・テ」ツ?凖」ツつ凝」ツ?ィテ」ツ??\n\tdouble d = dSP(l, c.p);\n\tif(d-c.r<-EPS) return true;\n\tif(d-c.r>EPS) return false;\n\treturn true; // (テヲツ篠・テ」ツ?凖」ツつ凝」ツ?ィテ」ツ??\n}\n\n//テ・ツ債佚ァツエツ氾・ツ、ツ堙ィツァツ津・ツスツ「テ・ツ按、テ・ツョツ?\nbool isSimple( Polygon pol ){\n\t//テ・ツ按敕」ツつ?」ツ?ョテァツつケテ」ツつ津ゥツ?催ィツ、ツ?」ツ?療」ツ?ヲpolテ」ツ?ォテ・ツ?・テ」ツつ古」ツ?ヲテ」ツ?甘」ツ??\n\tsize_t pol_size = pol.size()-1;\n\trep(i,pol_size){\n\t\tfor(int j=i+2;j<pol_size;j++){\n\t\t\tif( i==j || i==(j-1+pol_size)%pol_size || i==(j+1+pol_size)%pol_size )continue;\n\t\t\tif( intersect(pol[i], pol[i+1], pol[j], pol[j+1]) )return false;\n\t\t}\n\t}\n\treturn true;\n}\n\n//テァツつケテ」ツ?古・ツ?クテ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ョテ・ツ??・ツ?エテ」ツ?ォテ」ツ?づ」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ?凝」ツつ津ヲツアツづ」ツつ?」ツつ?trueテ」ツ?ェテ」ツつ嘉・ツ??・ツ?エ verified AOJ0012\nint isPointInsidePolygon(vector<P> pol,P p){\n\tint c=0;\n\trep(i,pol.size()){\n\t\tif( cross(pol[i]-pol[(i+1)%pol.size()] , p-pol[(i+1)%pol.size()])==0 ) return ON;\n\t\tif( cross(pol[i]-pol[(i+1)%pol.size()] , p-pol[(i+1)%pol.size()])>0 ) c++;\n\t}\n\tif( c%pol.size() )return OUT;\n\treturn IN;\n}\n\n//テ・ツ??」ツ?ィテ・ツ?クテ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ョテ、ツコツ、テ・ツキツョテァツ環カテヲツ?凝」ツつ津ィツェツソテ」ツ?ケテ」ツつ?\nint CPOLarea(C c ,Polygon pol){\n\tvector<L> lines;\n\tvector<int> res(pol.size());\n\tbool POLinC=true, isFar=true;\n\t\n\trep(i,pol.size()){\n\t\tif( contains(c,pol[i])==OUT )POLinC=false;\n\t\tres[i] = contains(c,pol[i]);\n\t\tlines.pb( L{ pol[i] , pol[(i+1)%pol.size()] });\n\t\tif( sqDist(c.p,pol[i])<c.r*c.r )isFar=false;\n\t}\n\t\n\tif( POLinC )                                        return 2;   //テ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ッテ・ツ??」ツ?ョテ・ツ??ゥツδィb\n\tif( isPointInsidePolygon(pol, c.p)==IN && isFar )   return 3;   //テ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ョテ・ツ??ゥツδィテ」ツ?ォテ・ツ??\n\trep(i,lines.size()) if( iCS(c,lines[i]) )           return 1;   //テ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ィテ・ツ??」ツ?ッテ、ツコツ、テ・ツキツョc\n\treturn 0;\n}\n\n//テ・ツ?クテ・ツ個?verified AOJ0068,QUPC-G\n//ティツセツ榲ヲツ崢クテゥツ??」ツ?ァテヲツッツ氾ィツシツ?\nbool cmp_x(const P& p, const P& q){\n\tif(p.x != q.x)return p.x<q.x;\n\treturn p.y<q.y;\n}\n\n//テ・ツ?クテ・ツ個?」ツつ津ヲツアツづ」ツつ?」ツつ?\nvector<P> convex_hull(vector<P> ps){\n\tint n = ps.size();\n\tsort(all(ps),cmp_x);\n\tint k=0;            //テ・ツ?クテ・ツ個?」ツ?ョテゥツ?づァツつケテヲツ閉ー\n\tvector<P> qs(n*2);  //テヲツァツ凝ヲツ按静、ツクツュテ」ツ?ョテ・ツ?クテ・ツ個?\n\t//テ、ツクツ凝・ツ?エテ・ツ?クテ・ツ個?」ツ?ョテ、ツスツ愿ヲツ按?\n\trep(i,n){\n\t\twhile( k>1 && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n\t\tqs[k++]=ps[i];\n\t}\n\t//テ、ツクツ甘・ツ?エテ・ツ?クテ・ツ個?」ツ?ョテ、ツスツ愿ヲツ按?\n\tfor(int i=n-2, t=k;i>=0;i--){\n\t\twhile( k>t && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n\t\tqs[k++]=ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n\n\n//2テァツつケテ」ツつ津ゥツ?堙」ツつ凝・ツ債甘・ツセツвテ」ツ?ョテ・ツ??」ツ?ョテ、ツクツュテ・ツソツε・ツコツァテヲツィツ凖」ツつ津ヲツアツづ」ツつ?」ツつ?\npair<P,P> geoGetCircleOf2pAndR(P p1,P p2,double r){\n\tP pc1=P(-INF,-INF), pc2(-INF,-INF), p3;\n\tdouble d, l, dx, dy ;\n\t\n\tp3 = (p1+p2)/2.0;\n\tl = sqDist(p2,p3);\n\t\n\tif  (r*r >= l) {\n\t\td  = sqrt(r*r / l - 1.0) ;\n\t\tdx = d * (p2.y - p3.y) ;\n\t\tdy = d * (p2.x - p3.x) ;\n\t\t\n\t\tpc1.x = p3.x + dx ;\n\t\tpc1.y = p3.y - dy ;\n\t\t\n\t\tpc2.x = p3.x - dx ;\n\t\tpc2.y = p3.y + dy ;\n\t}\n\treturn pair<P,P>(pc1,pc2);\n}\n\n\nint main(){\n\tint n;\n\twhile(cin>>n&&n){\n\t\tint ans=1;\n\t\tvector<P> ps(n);\n\t\trep(i,n)cin>>ps[i].x>>ps[i].y;\n\t\t\n\t\trep(i,n){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(dist(ps[i],ps[j])>2+EPS)continue;\n\t\t\t\tpair<P,P> res = geoGetCircleOf2pAndR(ps[i],ps[j],1);\n\t\t\t\tint suma=0,sumb=0;\n\t\t\t\trep(k,n){\n\t\t\t\t\tif(sqDist(ps[k],res.first )<1+EPS)suma++;\n\t\t\t\t\tif(sqDist(ps[k],res.second)<1+EPS)sumb++;\n\t\t\t\t}\n\t\t\t\tans = max(ans,max(suma,sumb));\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n};\n\nstruct Circle\n{\n\tPoint p; double r;\n\tCircle(Point a, double b) :p(a), r(b) {};\n};\n\ndouble dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;\t//counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;\t\t//c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;\t\t\t\t\t\t\t//a--c--b on line\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tdouble d = abs(c1.p - c2.p);\n\tdouble rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tdouble dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tdouble rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\n\n\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tint ans = 1;\n\t\tvector<Point> v;\n\t\tREP(i, n)\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tv.push_back(Point(x, y));\n\t\t}\n\t\tREP(i, n - 1)\n\t\t{\n\t\t\tFOR(j, 1 + 1, n)\n\t\t\t{\n\t\t\t\tCircle c1(v[i], 1), c2(v[j], 1);\n\t\t\t\tauto vp = is_cc(c1, c2);\n\n\t\t\t\tREP(k, vp.size())\n\t\t\t\t{\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tPoint tmp = vp[k];\n\t\t\t\t\tREP(l, n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (abs(tmp - v[l])-1<= EPS) cnt++;\n\t\t\t\t\t}\n\t\t\t\t\tchmax(ans, cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-12, pi = acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\n// ????????\\???\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\n// ????????????????????????\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\n// ??????\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\n// ??????\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\n// ????????????\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n  if (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n  if (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n  if (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n  return 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// ??´?????¨???????????¢\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res; // no intersection\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\n// ??????????????????\n// -1 => out\n//  0 => on\n//  1 => in\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\n// ??????\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\n// ????????????\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, Point p) {\n  for (Point q : ps) if (abs(q - p) < eps) return;\n  ps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n  g[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n  int n = p.size(), m = s.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (isis_sp(s[i], p[j]))\n      vec.emplace_back(abs(s[i].a - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      add_edge(g, from, to, abs(p[from] - p[to]));\n    }\n  }\n  return g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n  int n = p.size(), m = c.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n      vec.emplace_back(arg(c[i].p - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      ld angle = vec[j+1].first - vec[j].first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n    if (vec.size() >= 2) {\n      int from = vec.back().second, to = vec.front().first;\n      ld angle = vec.front().first - vec.back().first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n  }\n  return g;\n}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n  int N = p.size();\n  polygon.clear();\n  REP(i,1024) REP(j,1024) seg2p[i][j].clear();\n  vector<vector<tuple<ld,int,bool>>> tup(N);\n  REP(i,s.size()) {\n    int a = -1, b = -1;\n    REP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n    REP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n    assert(a >= 0 && b >= 0);\n    tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n    tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n  }\n  REP(i,N) sort(ALL(tup[i]));\n  REP(i,N) {\n    REP(j,tup[i].size()) {\n      ld angle; int pos = j, from = i, to; bool flag;\n      tie(angle, to, flag) = tup[i][j];\n      if (flag) continue;\n      vector<int> ps;\n      while (!flag) {\n        ps.push_back(from);\n        get<2>(tup[from][pos]) = true;\n        seg2p[from][to].push_back(polygon.size());\n        seg2p[to][from].push_back(polygon.size());\n        angle += pi + eps;\n        if (angle > pi) angle -= 2 * pi;\n        auto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n        if (it == tup[to].end()) it = tup[to].begin();\n        from = to; tie(angle, to, flag) = *it;\n        pos = it - tup[from].begin();\n      }\n      polygon.push_back(ps);\n    }\n  }\n  Graph g(polygon.size());\n  REP(i,N) REP(j,i) {\n    if (seg2p[i][j].size() == 2) {\n      int from = seg2p[i][j][0], to = seg2p[i][j][1];\n      g[from].push_back((Edge){from, to});\n      g[to].push_back((Edge){to, from});\n    }\n  }\n  return g;\n}\n\n\n/* ????????\\??¢????????¶ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n  fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n  Point v = l.b - l.a;\n  Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n  int n = p.size();\n  REP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<Point> v;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tld x, y; cin >> x >> y;\n\t\t\tv.push_back( Point(x, y) );\n\t\t}\n\t\tvector<Point> kh;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i+1; j < N; ++j) {\n\t\t\t\tvector<Point> cp = is_cc(Circle(v[i], 1), Circle(v[j], 1));\n\t\t\t\tfor (int k = 0; k < cp.size(); ++k) {\n\t\t\t\t\tkh.push_back(cp[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1;\n\t\tfor (int i = 0; i < kh.size(); ++i) {\n\t\t\tint cnt = 0;\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif ( abs(kh[i]-v[j]) <= 1+eps ) {\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double r = 1.0;\nconst double PI = acos(-1.0);\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y) : x(x), y(y) {}\n};\ninline double Distance2(const Point &a, const Point &b) {\n    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    std::random_device rnd;\n    std::mt19937 mt(rnd());\n    std::uniform_real_distribution<> rand100(0.0, 10.0);\n\n    while (cin >> n, n) {\n        // Input\n        vector<Point> p(n);\n        for (int i = 0; i < n; ++i)\n            cin >> p[i].x >> p[i].y;\n\n        // Solve\n        int ans = 1;\n        auto start = std::chrono::high_resolution_clock::now();\n        auto end = std::chrono::high_resolution_clock::now();\n        auto take_time = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n\n        while (true) {\n            end = std::chrono::high_resolution_clock::now();\n            take_time = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n            if (300 < take_time.count())\n                break;\n\n            for (int i = 0; i < 10; ++i) {\n                Point c(rand100(mt), rand100(mt));\n                int num = 0;\n                for (int j = 0; j < n; ++j) {\n                    double d = Distance2(p[j], c);\n                    if (d <= 1.0)\n                        ++num;\n                }\n                ans = max(ans, num);\n            }\n        }\n\n        // Output\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\ntypedef complex<double> C;\n#define EPS (1e-6)\n\nint n;\nC c[301];\n\nvoid solve() {\n  for(int i=0;i<n;i++)\n  cin>>c[i].real()>>c[i].imag();\n  \n  int res = 1;\n  for (int i = 0; i < n; i += 1) {\n    for (int j = i+1; j < n; j += 1) {\n      C v = c[j] - c[i];\n      double absv = abs(v);\n      if (absv > 2.0 + EPS) continue;\n      // _\n      C m = c[i] + (v / 2.0);\n      // ~ÜÅÌ£\n      double dist = sqrt(1.0 - absv * absv / 4.0);\n      // PÊ@üxNg\n      C unv  = (v * C(0, 1)) / absv;\n      // S\n      C nv = unv * dist;\n      for (int k = 0; k < 2; k += 1) {          \n        int cnt = 0;\n        nv *= -1;\n        C tc = m + nv;\n        for (int l = 0; l < n; l += 1) {\n          if (abs(tc - c[l]) < 1.0 + EPS) cnt++;\n        }\n        res = max(res, cnt);\n      }\n    }\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>n, n) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n#include <complex>\ntypedef complex<double> Point;\nconst double EPS = 1e-8;\n\n// 入力ストリームから実数二つをとって Point へ\nistream& operator >> ( istream &s, Point &a )\n{\n\tdouble r, i;\n\ts >> r >> i;\n\ta = Point( r, i );\n\treturn s;\n}\n\n// 単位ベクトル\nPoint unitVector( const Point &a )\n{\n\treturn a / abs( a );\n}\n\n// 法線ベクトル\nPoint normalVector1( const Point &a )\n{\n\treturn a * Point( 0, 1 );\n}\nPoint normalVector2( const Point &a )\n{\n\treturn a * Point( 0, -1 );\n}\nPoint ( *normalVectors[] )( const Point& ) = { normalVector1, normalVector2 };\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int n; cin >> n, n; )\n\t{\n\t\tvector<Point> ps( n );\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tcin >> ps[i];\n\t\t}\n\n\t\tint res = 0;\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tREP( j, 0, i )\n\t\t\t{\n\t\t\t\tconst Point &a = ps[i], &b = ps[j];\n\t\t\t\tREP( k, 0, 2 )\n\t\t\t\t{\n\t\t\t\t\tconst Point c = ( a + b ) / Point( 2, 0 ) + unitVector( normalVectors[k]( a - b ) ) * sqrt( 1 - pow( abs( a - b ) / 2., 2. ) );\n\t\t\t\t\tint tmp = 2;\n\t\t\t\t\tREP( l, 0, n )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( l == i || l == j )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp += abs( c - ps[l] ) <= 1.;\n\t\t\t\t\t}\n\t\t\t\t\tres = max( res, tmp );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define X first\n#define Y second\n\nusing R=long double;\nusing P=pair<R, R>;\n\nconst double EPS = 1e-10;\n\nR dist2(P a, P b) {\n\tR dx = a.X - b.X;\n\tR dy = a.Y - b.Y;\n\treturn dx*dx+dy*dy;\n}\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tvector<P> p(n), pl;\n\t\tfor(int i = 0; i < n; i++) cin >> p[i].X >> p[i].Y;\n\t\tfor(int i = 0; i < p.size(); i++) {\n\t\t\tP p1 = p[i];\n\t\t\tfor(int j = i+1; j < p.size(); j++) {\n\t\t\t\tP p2 = p[j];\n\t\t\t\tif(dist2(p1, p2)-EPS > 4.0) continue;\n\n\t\t\t\tR dxy2 = sqrt(dist2(p1, p2)/4.0);\n\t\t\t\tR l = sqrt(1-(dxy2*dxy2));\n\t\t\t\tR cx = (p1.X+p2.X)/2.0;\n\t\t\t\tR cy = (p1.Y+p2.Y)/2.0;\n\t\t\t\tR dx = (p2.X-p1.X);\n\t\t\t\tR dy = (p2.Y-p1.Y);\n\n\t\t\t\tR dlx = l/sqrt(dist2(p1, p2)) * dy;\n\t\t\t\tR dly = l/sqrt(dist2(p1, p2)) * -dx;\n\n\t\t\t\tpl.push_back(P(cx+dlx, cy+dly));\n\t\t\t\tpl.push_back(P(cx-dlx, cy-dly));\n\t\t\t}\n\t\t}\n\n\t\tint res = 1;\n\t\tfor(P p1:pl) {\n\t\t\tint tmp = 2;\n\t\t\tfor(P p2:p) {\n\t\t\t\tif(sqrt(dist2(p1, p2)) < 1.0-EPS) tmp++;\n\t\t\t}\n\t\t\tres = max(res, tmp);\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tG g(n);\n\t\trep(i,n)g[i]=pin();\n\t\tint out=1;\n\t\trep(i,n)rep(j,i)if(abs(g[i]-g[j])<2+EPS){\n\t\t\tdouble dis=abs(g[i]-g[j]);\n\t\t\tdouble c=atan(sqrt(4/dis/dis-1));\n\t\t\tP tur=g[j]-g[i];\n\t\t\ttur/=abs(tur);\n\t\t\tP p=g[i]+turn2(tur,c);\n\t\t\tint co=0;\n\t\t\trep(k,n)if(abs(p-g[k])<1+EPS)co++;\n\t\t\tout=max(out,co);\n\t\t\tco=0;\n\t\t\tp=g[i]+turn2(tur,-c);\n\t\t\trep(k,n)if(abs(p-g[k])<1+EPS)co++;\n\t\t\tout=max(out,co);\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n#include <complex>\ntypedef complex<double> Point;\n// O(n^2logn)\nint MaxPointCircle(const vector<Point> points, double r) {\n  const int n = points.size();\n  int ret = 1;\n  for (int i = 0; i < n; i++) {\n    vector<pair<double, int> > radians;\n    for (int j = 0; j < n; j++) {\n      double d = abs(points[i] - points[j]) / 2.0;\n      if (i == j || d * 2.0 - r * 2.0 > EPS) { continue; }\n      Point center = (points[i] + points[j]) / 2.0;\n      Point vect = (points[j] - points[i]) * Point(0, -1);\n      vect /= abs(vect);\n      double l = sqrt(r * r - d * d);\n      Point c1 = center + vect * l;\n      Point c2 = center - vect * l;\n      double arg1 = arg(c1 - points[i]) - EPS;\n      double arg2 = arg(c2 - points[i]) + EPS;\n      radians.push_back(make_pair(arg1, (j + 1)));\n      radians.push_back(make_pair(arg2, -(j + 1)));\n    }\n    if ((int)radians.size() / 2 < ret - 1) { continue; }\n    sort(radians.begin(), radians.end());\n    vector<bool> used(points.size(), false);\n    int lsum = 1;\n    REP(iter, 2) {\n      REP(j, radians.size()) {\n        int index = abs(radians[j].second) - 1;\n        bool start = radians[j].second > 0 ? true : false;\n        if (used[index] && !start) {\n          used[index] = false;\n          lsum--;\n        } else if (!used[index] && start) {\n          used[index] = true;\n          lsum++;\n        }\n        ret = max(ret, lsum);\n      }\n    }\n  }\n  return ret;\n}\n\nint main() {\n  int n;\n  while (scanf(\"%d\", &n), n) {\n    vector<Point> points(n);\n    REP(i, n) {\n      double x, y;\n      scanf(\"%lf %lf\", &x, &y);\n      points[i] = Point(x, y);\n    }\n    printf(\"%d\\n\", MaxPointCircle(points, 1.0));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define REP(i, n) for (ll (i) = 0 ; (i) < (ll)(n) ; ++(i))\n#define REPN(i, m, n) for (ll (i) = m ; (i) < (ll)(n) ; ++(i))\n#define REP_REV(i, n) for (ll (i) = (ll)(n) - 1 ; (i) >= 0 ; --(i))\n#define REPN_REV(i, m, n) for (ll (i) = (ll)(n) - 1 ; (i) >= m ; --(i))\n#define ALL(x) x.begin(), x.end()\n\n//#define INF (1e10)\n#define MOD (1000000007)\n\n#define print2D(h, w, arr) REP(i, h) { REP(j, w) cout << arr[i][j] << \" \"; cout << endl; }\ntemplate<class T> void print(const T& x) { cout << x << endl; }\ntemplate<class T, class... A> void print(const T& first, const A& ... rest) { cout << first << \" \"; prll(rest...); }\nstruct PreMain { PreMain() { cin.tie(0); ios::sync_with_stdio(false); } } premain;\n\ndouble eps = 1e-7;\ndouble inf = 1e10;\n\n\n#define N_MAX\t(300)\ndouble X[N_MAX];\ndouble Y[N_MAX];\n\nint main() {\n\twhile (true) {\n\t\tint N;\n\t\tcin >> N;\n\n\t\tif (0 == N) {\n\t\t\tbreak;\n\t\t}\n\n\t\t//input\n\t\tREP(i, N) {\n\t\t\tcin >> X[i] >> Y[i];\n\t\t}\n\n\t\tint ans = 1;\n\n\t\t//problem\n\t\t//2点を通る単位円に含まれる点を数える\n\t\tREP(i, N) REP(j, N) {\n\t\t\tif (i == j) continue;\n\t\t\tdouble dx = (X[i] - X[j]);\n\t\t\tdouble dy = (Y[i] - Y[j]);\n\t\t\tdouble d2 = (dx * dx) + (dy * dy);\n\t\t\tdouble d = sqrt(d2);\n\t\t\tif ((2.0 + eps) < d) continue;\n\n\t\t\tdouble v = sqrt(1.0 - (d2 / 4));\n\t\t\tdouble cx = (X[i] + X[j]) / 2 - (v * dy / d);\n\t\t\tdouble cy = (Y[i] + Y[j]) / 2 + (v * dx / d);\n\t\t\t\n\t\t\tint cnt = 0;\n\t\t\tREP(k, N) {\n\t\t\t\tdouble tmpx = (X[k] - cx);\n\t\t\t\tdouble tmpy = (Y[k] - cy);\n\t\t\t\tif ((tmpx * tmpx) + (tmpy * tmpy) < (1.0 + eps)) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ans < cnt) {\n\t\t\t\tans = cnt;\n\t\t\t}\n\t\t}\n\n\t\tprint(ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-8\ntypedef complex<double> Point;\n\nint main(){\n  int N;\n  while(cin >> N,N){\n    Point p[N];\n    for(int i = 0 ; i < N ; i++){\n      cin >> p[i].real() >> p[i].imag();\n    }\n    int res = 1;\n    for(int i = 0 ; i < N-1 ; i++){\n      for(int j = i+1 ; j < N ; j++){\n        Point np = p[j]-p[i];\n        double d = abs(np);\n        if(d + EPS > 2.0){ continue; }\n        np /= d;\n        np *= Point(0,1);\n        Point cp = (p[i]+p[j])/2.0;\n        Point v = sqrt(1.0-d*d/4.0)*np;\n        int cnt = 2;\n        Point center = cp + v;\n        for(int k = 0 ; k < N ; k++){\n          if(i == k || j == k) continue;\n          Point diff = center-p[k];\n          if(norm(diff) < 1.0 + EPS){\n            cnt++;\n          }\n        }\n        res = max(res,cnt);\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>  \n#include<iostream>  \n#include<algorithm>  \n#define EPS 1e-5\n\ntypedef std::pair<double,double> pt;\n#define x first\n#define y second\n\n\ndouble dist_square(pt a, pt b){\n    double x = a.x - b.x;\n    double y = a.y - b.y;\n    return x*x + y*y;\n}\n\nint solve(pt P,pt Q, std::vector<pt> pts){  \n    pt tmp=pt((P.x+Q.x)/2,(P.y+Q.y)/2);  \n    double angle=atan2(P.y-Q.y,P.x-Q.x)+acos(-1.0)/2;  \n    double len=sqrt(1-dist_square(P,Q)/4);  \n    tmp.x+=cos(angle)*len;  \n    tmp.y+=sin(angle)*len;  \n    int inside = 0;  \n    for(auto it = pts.begin();it != pts.end();++it){\n        if(dist_square(*it,tmp) <= 1+EPS) ++inside;\n    }  \n\n    return inside;  \n}  \nint main()  \n{  \n    int numPts;\n    std::cin >> numPts;\n    while(numPts != 0){  \n        if(numPts == 1){\n            std::cout << 1 << \"\\n\";\n            std::cin >> numPts;\n            continue;\n        }\n        std::vector<pt> pts;\n\n        for(int i=0;i<numPts;++i){\n            double x,y;\n            std::cin >> x >> y;\n            pts.push_back(pt(x,y));\n        }\n        std::sort(pts.begin(),pts.end(),[](pt a, pt b){\n            return a.x < b.x || (a.x == b.x && a.y < b.y);\n            });  \n\n        \n        int ans = 0;\n        for(auto it = pts.begin();it != pts.end();++it){\n            for(auto it2 = it + 1;it2 != pts.end();++it2){\n                if(dist_square(*it,*it2) <= 4){\n                    ans = std::max(ans,solve(*it,*it2,pts));\n                    ans = std::max(ans,solve(*it2,*it,pts));\n                }\n            }\n        }\n        std::cout << ans << \"\\n\";\n        std::cin >> numPts;\n    }  \n    return 0;  \n}  \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\n\nmain(){\n  int n;\n  while(cin>>n,n){\n    double x[n],y[n];\n\n    rep(i,n)cin>>x[i]>>y[i];\n\n    int ans=1;\n\n    rep(i,n){\n      rep(j,i){\n\tdouble sx,sy;\n\tdouble tx=x[i]-x[j],ty=y[i]-y[j];\n\tdouble len=sqrt(tx*tx+ty*ty);\n\tif(len>2)continue;\n\tlen=sqrt(1-len*len/4);\n\tdouble theta=atan2(ty,tx)+M_PI/2;\n\tint tans=0;\n\tsx=(x[i]+x[j])/2+cos(theta)*len;\n\tsy=(y[i]+y[j])/2+sin(theta)*len;\n\trep(k,n){\n\t  tx=sx-x[k];\n\t  ty=sy-y[k];\n\t  if(tx*tx+ty*ty<=1+EPS)++tans;\n\t}\n\tans=max(ans,tans);\n\ttans=0;\n\tsx=(x[i]+x[j])/2-cos(theta)*len;\n\tsy=(y[i]+y[j])/2-sin(theta)*len;\n\trep(k,n){\n\t  tx=sx-x[k];\n\t  ty=sy-y[k];\n\t  if(tx*tx+ty*ty<=1+EPS)++tans;\n\t}\n\tans=max(ans,tans);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nstatic const double EPS = 1e-8;\nstatic const double PI = 3.14159265;\n\ntypedef complex<double> P;\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { }};\n#define toRad(n) (n*(PI/180.0))\nvector<P> data;\npair<C,C> get(P a,P b){\n\tP diff = a-b;\n\tif(abs(diff) > 2)return make_pair(C(P(-1,-1),-1),C(P(-1,-1),-1));\n\tdouble theta = atan2(diff.imag(),diff.real()) + toRad(90);\n\tP mid = (a+b) / 2.0;\n\tdouble d = sqrt( 1 - (abs(diff)*abs(diff))/4.0 );\n\tdouble X = cos(theta)*d , Y = sin(theta)*d;\n\treturn make_pair(C(mid+P(X,Y),1),C(mid-P(X,Y),1));\n}\nint check(C t){\n\tint ret = 0;\n\trep(i,data.size()){\n\t\tif(abs(data[i]-t.p) < 1+EPS)ret++;\n\t}\n\treturn ret;\n}\nint main(){\n\tint n; \n\twhile(cin >> n , n){\n\t\tdata.resize(n);\n\t\trep(i,n){\n\t\t\tcin >> data[i].real() >> data[i].imag();\n\t\t}\n\t\tint ret = 0;\n\t\trep(i,n){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tpair<C,C> g = get(data[i],data[j]);\n\t\t\t\tret = max(ret,check(g.first));\n\t\t\t\tret = max(ret,check(g.second));\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,N) for(int i=0;i<(int)(N);i++)\n#define REP(i,k,N) for(int i=k;i<(int)(N);i++)\n\n#define vi vector<int>\n#define pb push_back\n\n#define pdd pair<double,double>\n#define fi first\n#define se second\nconst double  EPS = 1e-9;\n\ndouble dist(double x,double y){\n    return x*x+y*y;\n};\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        int ma = 0;\n        pdd p[330];\n        rep(i,n) cin >> p[i].fi >> p[i].se;\n        rep(i,n-1){\n            REP(j,i+1,n){\n                int cnt1 = 0,cnt2=0;\n                double x1,y1,x2,y2,x3,y3;\n                tie(x1,y1) = p[i];\n                tie(x2,y2) = p[j];\n                double cx1,cy1,cx2,cy2;\n                if(dist(x1-x2,y1-y2)>4) continue;\n\n                //はりまコーナー\n//                double ax,ay,bx1,by1,bx2,by2,mx,my,dx,dy;\n//                ax=x1-x2;ay=y1-y2;\n//                mx=(x1+x2)/2;my=(y1+y2)/2;\n//                by1 = (-0.5)*pow(ax,4)+pow(ax,2)+(-0.5)*pow(ax,2)*pow(ay,2)\n//                        /dist(ax,ay);\n//                by1 = sqrt(abs(by1));\n//                by2 = -1*by1;\n//                cy1= my+by1;\n//                cy2= my+by2;\n//                bx1= -1*(ay*by1)/ax;\n//                bx2= -1*(ay*by2)/ax;\n//                cx1=bx1+mx;\n//                cx2=bx2+mx;\n\n\n                //あじのりコーナー\n                double mx=(x1+x2)/2,my=(y1+y2)/2;\n\n                double ld = 1-dist((x1-x2)/2,(y1-y2)/2);\n                ld = sqrt(ld);\n                cx1 = mx - sin(atan((y2-y1)/(x2-x1)))*ld;\n                cy1 = my + cos(atan((y2-y1)/(x2-x1)))*ld;\n                cx2 = mx + sin(atan((y2-y1)/(x2-x1)))*ld;\n                cy2 = my - cos(atan((y2-y1)/(x2-x1)))*ld;\n\n                for(int k = 0;k<n;k++) {\n                    tie(x3, y3) = p[k];\n                    if (EPS > dist((cx1 - x3), (cy1 - y3))-1) cnt1++;\n                    if (EPS > dist((cx2 - x3), (cy2 - y3))-1) cnt2++;\n                }\n                ma = max({cnt1,cnt2,ma});\n            }\n        }\n        cout<< ma << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>/*{{{*/\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\nstatic const double PI (3.14159265358979323846);\nstatic const double EPS (1e-10);\n\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n#define FOR(i, b, e) for (typeof(b) i = (b); assert((i) <= (e)), i != (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((ll)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define DEBUG_ON\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) fprintf(stderr, fmt, __VA_ARGS__)\n\t#define darr(a) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#else\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n#endif\n/*}}}*/\n\nint N;\nvector<P> points;\n\nP middle_point(P a, P b)\n{\n\treturn a + (b-a) / 2.0;\n}\n\n// 点pを中心としてr(radian)回転 p(0,0)で原点を中心として回転\nP rotate(P t, P p ,double r){\n\t// double r=radians(angle);\n\treturn (t - p) * P(cos(r), sin(r)) + p;\n}\n\n// 2円 |x-a|=raと|x-b|=rbの交点計算\nbool intersection_c_c(P a, double ra, P b, double rb, P ans[]){\n\tdouble di = abs(a-b);\n\tif(di > ra+rb || di < abs(ra-rb)) return false;\n\tdouble t=(ra*ra - rb*rb + di*di) / (di+di);\n\tdouble rd = acos(t/ra);\n\n\tP dv = (b-a) / abs(b-a);\n\tP g1 = rotate(dv, P(0,0), rd);\n\tP g2 = rotate(dv, P(0,0), -rd);\n\tans[0] = a + g1*ra;\n\tans[1] = a + g2*ra;\n\treturn true;\n}\n\nint main(int argc, char const* argv[])\n{\n\twhile (cin >> N, N) {\n\t\tint ans = 1;\n\t\tpoints.clear();\n\t\tREP(i, N) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoints.PB(P(x, y));\n\t\t}\n\t\tREP(i, N) {\n\t\t\tFOR(j, i+1, N) {\n\t\t\t\tP p1 = points[i], p2 = points[j];\n\t\t\t\tdprt(\"(%lf, %lf) and (%lf, %lf)\\n\", p1.real(), p1.imag(), p2.real(), p2.imag());\n\t\t\t\tP centers[2];\n\t\t\t\tif (intersection_c_c(p1, 1, p2, 1, centers)) {\n\t\t\t\t\tREP(k, 2) {\n\t\t\t\t\t\tdprt(\" center: (%lf, %lf)\\n\", centers[k].real(), centers[k].imag());\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\tREP(l, N) {\n\t\t\t\t\t\t\tif (abs(centers[k] - points[l]) < 1.0 + EPS) {\n\t\t\t\t\t\t\t\t++cnt;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans = max(ans, cnt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    while(cin>>n,n){\n        vector<Point> ps(n);\n        for(int i=0;i<n;i++){\n            ps[i] = input_point();\n        }\n        if(n<=2){\n            cout<<n<<endl;\n            continue;\n        }\n        int res=0;\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++){\n                Circle c1=Circle(ps[i],1.0),c2=Circle(ps[j],1.0);\n                vector<Point> vs=is_cc(c1,c2);\n                int sz=vs.size();\n                if(sz==0) continue;\n                for(int k=0;k<sz;k++){\n                    Point p=vs[k];\n                    int tmp=0;\n                    for(int idx=0;idx<n;idx++){\n                        if(abs(ps[idx]-p)<=1+eps) tmp++;\n                    }\n                    res=max(res,tmp);\n                }\n            }\n        }\n        cout<<res<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <set>\n\nusing namespace std;\n\n\nint main(){\n\tint n;\n\tdouble x1,y1,xc,yc,dis,vx,vy,ex,ey;\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\tvector<double> x(n);\n\t\tvector<double> y(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tif(n==1){\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans =0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(i==j)break;\n\t\t\t\txc = (x[i]+x[j])/2;\n\t\t\t\tyc = (y[i]+y[j])/2;\n\t\t\t\tif((xc-x[i])*(xc-x[i])+(yc-y[i])*(yc-y[i])>0.9999)continue;\n\t\t\t\tdis = sqrt(1.0-(xc-x[i])*(xc-x[i])-(yc-y[i])*(yc-y[i]));\n\t\t\t\tvx = x[i]-x[j];\n\t\t\t\tvy = y[i]-y[j];\n\t\t\t\tex = dis * vy / sqrt(vx*vx+vy*vy);\n\t\t\t\tey = -dis* vx / sqrt(vx*vx+vy*vy);\n\t\t\t\tx1 = xc + ex;\n\t\t\t\ty1 = yc + ey;\n\t\t\t\tint count=0;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i||k==j)count +=1;\n\t\t\t\t\telse{\n\t\t\t\t\t\tif((x1-x[k])*(x1-x[k])+(y1-y[k])*(y1-y[k])<=1.0001){\n\t\t\t\t\t\t\tcount +=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = max(ans,count);\n\t\t\t\tx1 = xc - ex;\n\t\t\t\ty1 = yc - ey;\n\t\t\t\tcount = 0;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i||k==j)count +=1;\n\t\t\t\t\telse{\n\t\t\t\t\t\tif((x1-x[k])*(x1-x[k])+(y1-y[k])*(y1-y[k])<=1.0001){\n\t\t\t\t\t\t\tcount +=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = max(ans,count);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\ntypedef complex<double> P;\n\nvector<P> point;\n\nconst double EPS = 0.0000000001;\n\n\nvoid init(){\n  point.clear();\n}\n\n\nbool input(){\n  int n;\n  cin>>n;\n  if(n==0)return false;\n\n  rep(i,n){\n    double a ,b;\n    cin>>a>>b;\n    point.push_back(P(a,b));\n  }\n  return true;\n}\n\nvector<P> make_cand(){\n  vector<P> ret;\n  rep(i,point.size()){\n    reps(j,i+1,point.size()){\n      P dist = point[j]-point[i];\n      double d = abs(dist)/2;\n\n      if(d>1)continue;\n      double h = sqrt(1-d*d);\n      P e = dist/(d*2);\n\n      P e1 = e*P(0,1);\n      P e2 = e*P(0,-1);\n\n      P c1 = point[i]+e*d+h*e1;\n      P c2 = point[i]+e*d+h*e2;\n\n      //cout<<\"d=\"<<d<<\" h=\"<<h<<endl;\n      //cout<<point[i]<<\" \"<<point[j]<<\" \"<<c1<<\" \"<<c2<<endl;\n      ret.push_back(c1);\n      ret.push_back(c2);\n    }\n  }\n  rep(i,point.size()){\n    ret.push_back(point[i]);\n  }\n  return ret;\n}\n\nint count_in(P p){\n  int sum = 0;\n  rep(i,point.size()){\n    P d  = point[i]-p;\n    if(abs(d)<=1+EPS)sum++;\n  }\n  return sum;\n}\nint solve(){\n  vector<P> cand = make_cand();\n  int ans = 0;\n  rep(i,cand.size()){\n    ans = max(ans, count_in(cand[i]));\n  }\n  return ans;\n}\n\nint main(){\n  while(init(),input()){\n    printf(\"%d\\n\",solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nstatic const double EPS = 1e-8;\nstatic const double PI = 3.14159265;\n\ntypedef complex<double> P;\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { }};\n#define toRad(n) (n*(PI/180.0))\nvector<P> data;\npair<C,C> get(P a,P b){\n\tP diff = a-b;\n\tif(abs(diff) > 2)return make_pair(C(P(-1,-1),-1),C(P(-1,-1),-1));\n\tdouble theta = atan2(diff.imag(),diff.real()) + toRad(90);\n\tP mid = (a+b) / 2.0;\n\tdouble d = sqrt( 1 - (abs(diff)*abs(diff))/4.0 );\n\tdouble X = cos(theta)*d , Y = sin(theta)*d;\n\treturn make_pair(C(mid+P(X,Y),1),C(mid-P(X,Y),1));\n}\nint check(C t){\n\tint ret = 0;\n\trep(i,data.size()){\n\t\tif(abs(data[i]-t.p) <= 1+EPS)ret++;\n\t}\n\treturn ret;\n}\nint main(){\n\tint n; \n\twhile(cin >> n , n){\n\t\tdata.resize(n);\n\t\trep(i,n){\n\t\t\tcin >> data[i].real() >> data[i].imag();\n\t\t}\n\t\tint ret = 1;\n\t\trep(i,n){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tpair<C,C> g = get(data[i],data[j]);\n\t\t\t\tif(g.first.r == -1)continue;\n\t\t\t\tret = max(ret,check(g.first));\n\t\t\t\tret = max(ret,check(g.second));\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<set>\n \nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1001001001\n#define LLINF 1001001001001001001\n#define mp make_pair\n#define LLIandI pair<long long int , int>\n#define ll long long\n\n\n\n\n//xy平面上にN個の点が与えられる．\n//半径1の円をxy平面 上で動かして，それらの点をなるべくたくさん囲むようにする．\n//このとき，最 大でいくつの点を同時に囲めるかを答えなさい．\n//ここで，ある円が点を「囲む」 とは，その点が円の内部または円周上にあるときをいう．\n\nint main(){\n    while(1){\n        //1 <= N <= 300, 0.0 <= X <= 10.0, および0.0 <= Y <= 10.0と仮定してよい\n        int N;\n        scanf(\"%d\",&N);\n        if(N==0)break;\n        float X[303],Y[303];\n        rep(i,N){\n            scanf(\"%f %f\",&X[i],&Y[i]);\n        }\n        //二つの点を通る縁を全て考える\n        //二つの縁の組み合わせが300*299/2通り、\n        //それぞれについて2通りの縁が考えられる。\n        //3つの点が円を通過することがないという条件から、重複はない。\n        int ans=0;\n        rep(i,N){\n            rep(j,i){\n                //円の中心を計算\n                float nx=(X[i]+X[j])/2.0;//二等分点\n                float ny=(Y[i]+Y[j])/2.0;\n                float len1=sqrt(pow(X[i]-nx,2.0)+pow(Y[i]-ny,2.0));\n                if(len1>1.0)continue;\n                float ex=(Y[i]-ny)/len1;\n                float ey=-(X[i]-nx)/len1;\n                float len=sqrt(1.0-pow(len1,2.0));\n                for(float swi=-1.0;swi<=1.0;swi+=2.0){\n                    float cx=nx+ex*len*(swi);\n                    float cy=ny+ey*len*(swi);\n                    int sans=0;\n                    //単位ベクトル\n                    rep(k,N){\n                        if(k==i||k==j){sans++;}\n                        else{\n                            if(sqrt(pow(X[k]-cx,2.0)+pow(Y[k]-cy,2.0))<1.0)sans++;\n                        }\n                    }\n                    ans=max(ans,sans);\n                }\n            }\n        }\n        printf(\"%d\\n\",max(1,ans));\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\n\nconst long double EPS = 10e-6;\n\nclass Point{\n    public: \n    long double x,y;\n    \n    Point(long double x = 0.0, long double y = 0.0): x(x), y(y) {}\n    \n    Point operator + (Point p) const {\n        return Point(x+p.x, y+p.y);\n    }\n    Point operator - (Point p) const {\n        return Point(x-p.x, y-p.y);\n    }\n    Point operator * (long double a) const {\n        return Point(x*a, y*a);\n    }\n    Point operator / (long double a) const {\n        return Point(x/a, y/a);\n    }\n\n    long double norm() {\n        return x*x + y*y;\n    }\n    \n    long double dot(Point p) {\n        return x*p.x + y*p.y;\n    }\n};\n\nPoint calc_center(Point p, Point mid, Point midv){\n    long double norm = mid.norm();\n    midv = midv * sqrt((1.0 - norm) / norm);\n    return p+mid+midv;\n}\n\nint count(vector<Point> points, Point center){\n    int tmp = 0;\n    for(Point p: points){\n        if((p-center).norm() <= 1.0 + EPS) tmp++;\n    }\n    return tmp;\n}\n\nint main() {\n    int n;\n    while(scanf(\"%d\", &n) && n){\n        vector<Point> points(n);\n        rep(n) scanf(\"%Lf %Lf\", &points[i].x, &points[i].y);\n\n        int ans = 1;\n        rep(n){\n            repp(j, n){\n                if(j == i) continue;\n                Point mid = (points[j] - points[i]) * 0.5;\n                Point center = calc_center(points[i], mid, Point(mid.y, -mid.x));\n                ans = max(count(points, center), ans);\n\n                center = calc_center(points[i], mid, Point(-mid.y, mid.x));\n                ans = max(count(points, center), ans);\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int N;\n    while (cin >> N, N) {\n        static const complex<double> I = complex<double>(0, -1);\n        using Point = complex<double>;\n        vector<Point> points(N);\n        REP(i, N) {\n            double x, y; cin >> x >> y;\n            points[i] = Point(x, y);\n        }\n\n        int ans = 0;\n        REP(i, N) FOR(j, i+1, N) {\n            auto x = points[i];\n            auto y = points[j];\n            double l_sq = norm(x - y);\n            if (l_sq > 4) continue;\n            for(double d : {-1, 1}) {\n                Point middle = 0.5 * (x + y);\n                Point dir = (x - y) * I;\n                dir /= abs(dir);\n                Point center = middle + d*sqrt(1 - l_sq/4)*dir;\n\n                int count = 0;\n                REP(k, N) {\n                    if (norm(center - points[k]) <= 1 + 1e-10)\n                        ++count;\n                }\n                ans = max(ans, count);\n            }\n        }\n        cout << ans << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst double EPS = 1e-8;\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tdouble x[n], y[n];\n\t\trep(i,n) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tint maxi = 0;\n\t\trep(i, n) {\n\t\t\tfor(int j=i+1; j<n; j++) {\n\t\t\t\tif( ((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])) > 4.0 ) continue;\n\t\t\t\tdouble mx = (x[i]+x[j]) / 2.0;\n\t\t\t\tdouble my = (y[i]+y[j]) / 2.0;\n\t\t\t\tdouble px0, py0, px1, py1;\n\t\t\t\tif( fabs(y[i]-y[j]) < EPS ) {\n\t\t\t\t\tpx0 = px1 = mx;\n\t\t\t\t\tpy0 = my + sqrt(1.0 - (x[i]-mx)*(x[i]-mx));\n\t\t\t\t\tpy1 = my - sqrt(1.0 - (x[i]-mx)*(x[i]-mx));\n\t\t\t\t} else if( fabs(x[i]-x[j]) < EPS ) {\n\t\t\t\t\tpy0 = py1 = my;\n\t\t\t\t\tpx0 = mx + sqrt(1.0 - (y[i]-my)*(y[i]-my));\n\t\t\t\t\tpx1 = mx - sqrt(1.0 - (y[i]-my)*(y[i]-my));\n\t\t\t\t} else {\n\t\t\t\t\tdouble m = - (x[i]-x[j]) / (y[i]-y[j]);\n\t\t\t\t\tdouble l = sqrt(1.0 - ((x[i]-mx)*(x[i]-mx)+(y[i]-my)*(y[i]-my)));\n\t\t\t\t\tpx0 = mx + sqrt(l*l/(1.0+m*m));\n\t\t\t\t\tpx1 = mx - sqrt(l*l/(1.0+m*m));\n\t\t\t\t\tpy0 = my + m * (px0-mx);\n\t\t\t\t\tpy1 = my + m * (px1-mx);\n\t\t\t\t}\n\t\t\t\tint cnt0 = 0, cnt1 = 0;\n\t\t\t\trep(k, n) {\n\t\t\t\t\tdouble d0 = (px0-x[k])*(px0-x[k]) + (py0-y[k])*(py0-y[k]);\n\t\t\t\t\tif( d0 <= 1.0+EPS ) {\n\t\t\t\t\t\tcnt0++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(k, n) {\n\t\t\t\t\tdouble d1 = (px1-x[k])*(px1-x[k]) + (py1-y[k])*(py1-y[k]);\n\t\t\t\t\tif( d1 <= 1.0+EPS ) {\n\t\t\t\t\t\tcnt1++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxi = max(maxi, cnt0);\n\t\t\t\tmaxi = max(maxi, cnt1);\n\t\t\t}\n\t\t}\n\t\tcout << maxi << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\nusing P = complex<ld>;\nconst ld eps = 1e-7;\n\nint main()\n{\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<ld> x(N), y(N);\n\t\tvector<P> p(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tp[i] = P(x[i], y[i]);\n\t\t}\n\t\tvector<P> ko;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tif (norm(p[i] - p[j]) < 4.0 + eps) {\n\t\t\t\t\tauto d = p[i] - p[j];\n\t\t\t\t\tko.push_back(p[j] + (d * (ld)0.5) + d * P(0, 1) / abs(d) * sqrtl(1 - norm(d * (ld)0.5)));\n\t\t\t\t\tko.push_back(p[j] + (d * (ld)0.5) - d * P(0, 1) / abs(d) * sqrtl(1 - norm(d * (ld)0.5)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor (auto c : ko) {\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (norm(c - p[i]) < 1.0 + eps) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = max(res, cnt);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\nlong long int MOD = 1000000007;\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin >> N;\n\t\tif(N == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tdouble x[500], y[500];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < N; i++)for(int j = 0; j < N; j++){\n\t\t\tdouble vx = x[j] - x[i];\n\t\t\tdouble vy = y[j] - y[i];\n\t\t\tdouble norm = sqrt(vx * vx + vy * vy);\n\t\t\tif(norm > 2 || i == j){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble vnx = vx / norm;\n\t\t\tdouble vny = vy / norm;\n\t\t\tnorm /= 2;\n\t\t\tdouble norm2 = sqrt(1 - norm * norm);\n\t\t\tdouble v90x = -vny;\n\t\t\tdouble v90y = vnx;\n\t\t\tdouble centx = x[i] + vx / 2 + v90x * norm2;\n\t\t\tdouble centy = y[i] + vy / 2 + v90y * norm2;\n\t\t\tint S = 2;\n\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\tif(i == k || j == k){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble xx = centx - x[k];\n\t\t\t\tdouble yy = centy - y[k];\n\t\t\t\tif(xx * xx + yy * yy <= 1){\n\t\t\t\t\tS++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(S, ans);\n\t\t}\n\t\tcout << max(1, ans) << endl;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\ntypedef complex<double> P;\n\nint N;\nP dots[300];\n#define EPS (1e-6)\n\n\nint main(){\n\n\twhile(cin >> N && N != 0){\n        for(int i = 0; i < N; i++){\n            P p;\n            double x,y;\n            cin>>x>>y;\n            dots[i]=P(x,y);\n            //cin >> dots[i].second >> dots[i].first;\n\t\t}\n\t\tint maxCnt = 1;\n\t\t// ~ðìé½ßÌQ_ðßé\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = i+1; j < N; j++){\n                //pair<double,double> dot1,dot2;\n                P dot1,dot2;\n\t\t\t\tdot1 = dots[i];\n\t\t\t\tdot2 = dots[j];\n                //double v = sqrt((dot1.first - dot2.first)*(dot1.first - dot2.first)\n                //+(dot1.second - dot2.second)*(dot1.second - dot2.second));\n                double v=abs(dot1-dot2);\n\t\t\t\t// ñ_Ô£ª2æè¨¨«¯êÎÂ­êÈ¢\n\t\t\t\tif(v > 2.0 + EPS){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n                double x = sqrt(1 - (v/2)*(v/2));\n\t\t\t\t// ñgÌPÊ@üxNg\n\t\t\t\tP hose[2];\n                double y1 = -1.0/(dots[i].imag() - dots[j].imag());\n                double x1 = 1.0/(dots[i].real() - dots[j].real());\n                hose[0]=P(x1,y1);\n                double y2 = 1.0/(dots[i].imag() - dots[j].imag());\n                double x2 = -1.0/(dots[i].real() - dots[j].real());\n                hose[1]=P(x2,y2);\n\n\t\t\t\t//double dd1 = sqrt((hose[0].second)*(hose[0].second)+(hose[0].first)*(hose[0].first));\n                //double dd2 = sqrt((hose[1].second)*(hose[1].second)+(hose[1].first)*(hose[1].first));\n                double dd1=abs(hose[0]);\n                double dd2=abs(hose[1]);\n                hose[0]/=dd1;hose[0]*=x;\n                hose[1]/=dd2;hose[1]*=x;\n                P tmp=(dot1+dot2);\n                tmp/=2;\n                hose[0]+=tmp;\n                hose[1]+=tmp;\n\n    //            hose[0].first /= dd1; hose[0].second /= dd1;\n\t\t\t\t//hose[1].first /= dd2; hose[1].second /= dd2;\n\t\t\t\t// x{·é\n\t\t\t\t//hose[0].first *= x;hose[1].first *= x;\n\t\t\t\t//hose[0].second *= x;hose[1].second *= x;\n\n\t\t\t\t// mð«·\n\t\t\t\t//hose[0].first += (dot1.first + dot2.first)/2;\n\t\t\t\t//hose[0].second += (dot1.second + dot2.second)/2;\n\t\t\t\t//hose[1].first += (dot1.first + dot2.first)/2;\n\t\t\t\t//hose[1].second += (dot1.second + dot2.second)/2;\n\n\t\t\t\t// hose[0]Æhose[1]Í~ÌSÀW\n\t\t\t\t// e_ÉÖµÄ~ÌÉ¶Ý·é©Ç¤©ðßé\n\t\t\t\tfor(int k = 0; k < 2; k++){\n                    int cnt = 0;\n\t\t\t\t\tfor(int l = 0; l < N; l++){\n\t\t\t\t\t\t//double dist = sqrt((dots[l].first -hose[k].first)*(dots[l].first -hose[k].first)\n\t\t\t\t\t\t//\t+ (dots[l].second -hose[k].second)*(dots[l].second -hose[k].second));\n                        double dist=abs(dots[l]-hose[k]);\n\t\t\t\t\t\tif(dist <= 1.0 + EPS){\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmaxCnt = max(maxCnt,cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << maxCnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\n\nconst long double EPS = 10e-10;\n\nclass Segment;\n\nclass Point{\n    public: \n    long double x,y;\n    \n    Point(long double x = 0.0, long double y = 0.0): x(x), y(y) {}\n    \n    Point operator + (Point p) {\n        return Point(x+p.x, y+p.y);\n    }\n    Point operator - (Point p) {\n        return Point(x-p.x, y-p.y);\n    }\n    Point operator * (long double a) {\n        return Point(x*a, y*a);\n    }\n    Point operator / (long double a) {\n        return Point(x/a, y/a);\n    }\n    bool operator < (const Point &p) const {\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n    bool operator == (const Point &p) const {\n        return fabsl(x - p.x) < EPS && fabsl(y - p.y) < EPS;\n    }\n    \n    long double abs() {\n        return sqrt(norm());\n    }\n    \n    long double norm() {\n        return x*x + y*y;\n    }\n    \n    long double dot(Point p) {\n        return x*p.x + y*p.y;\n    }\n    \n    long double cross(Point p) {\n        return x*p.y - y*p.x;\n    }\n};\n\nclass Segment{\n    public: \n    Point p,q;\n    long double grad;\n    \n    Segment(Point p, Point q) {\n        this->p = p;\n        this->q = q;\n        this->grad = (q.y-p.y)/(q.x-p.x);\n    }\n    \n};\n\nclass Circle{\n    public:\n    Point c;\n    long double r;\n    \n    Circle(Point c = Point(), long double r = 0.0): c(c), r(r) {}\n};\n\nPoint calc_center(Point p, Point mid, Point midv){\n    midv = midv / midv.abs() * (1.0 - (p - mid).abs());\n    return mid+midv;\n}\n\nint count(vector<Point> points, Point center){\n    int tmp = 0;\n    for(Point p: points){\n        if((p-center).norm() <= 1.0) tmp++;\n    }\n    return tmp;\n}\n\nint main() {\n    int n;\n    while(scanf(\"%d\", &n) && n){\n        vector<Point> points(n);\n        rep(n) cin >> points[i].x >> points[i].y;\n\n        int ans = 1;\n        rep(n){\n            repp(j, n){\n                if(j == i) continue;\n                Point mid = (points[i] + points[j]) / 2;\n                Point center = calc_center(points[i], mid, Point(mid.y, -mid.x));\n                ans = max(count(points, center), ans);\n\n                center = calc_center(points[i], mid, Point(-mid.y, mid.x));\n                ans = max(count(points, center), ans);\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <stdio.h>\n#include <complex>\n#include <math.h>\n#include <assert.h>\n\nusing namespace std;\ntypedef complex<double> Complex;\n\nstatic const double E = 0.000001;\n\ninline bool collide_circle_circle(const Complex p1, const double r1, const Complex p2, const double r2) {\n  assert(r1 >= 0.0 && r2 >= 0.0);\n  Complex dif = p1 - p2;\n  return dif.real() * dif.real() + dif.imag() * dif.imag() <= (r1 + r2) * (r1 + r2) + E;\n}\n\n// include circle inside\ninline bool collide_circle_point(const Complex p1, const double r1, const Complex p2) {\n  return collide_circle_circle(p1, r1, p2, 0.0);\n}\n\ninline void intersection_circle_circle(const Complex p1, const double r1, const Complex p2, const double r2, int *size, Complex *ret1, Complex *ret2) {\n  assert(p1 != p2);\n  assert(ret1 != NULL && ret2 != NULL);\n  if (!collide_circle_circle(p1, r1, p2, r2)) {\n    if (size != NULL) { *size = 0; }\n    *ret1 = *ret2 = Complex(NAN, NAN);\n    return;\n  }\n  Complex center = (p1 * r2 + p2 * r1) / (r1 + r2);\n  Complex vect = (center - p1) * Complex(0.0, 1.0);\n  if (abs(vect) < E) {\n    *ret1 = *ret2 = center;\n    if (size != NULL) { *size = 1; }\n    return;\n  }\n  vect *= sqrt(r1 * r1 - norm(vect)) / abs(vect);\n  *ret1 = center + vect;\n  *ret2 = center + vect * Complex(-1.0, 0.0);\n  if (size != NULL) { *size = 2; }\n}\n\nComplex point[301];\n\nint main() {\n  int n;\n  while (scanf(\"%d\", &n), n != 0) {\n    for (int i = 0; i < n; i++) {\n      double a, b;\n      scanf(\"%lf %lf\", &a, &b);\n      point[i] = Complex(a, b);\n    }\n    int max_ans = 1;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < i; j++) {\n        if (!collide_circle_circle(point[i], 1.0, point[j], 1.0)) { continue; }\n        int size;\n        Complex m[2];\n        intersection_circle_circle(point[i], 1.0, point[j], 1.0, &size, &m[0], &m[1]);\n        for (int s = 0; s < size; s++) {\n          int ans = 0;\n          for (int k = 0; k < n; k++) {\n            if (collide_circle_point(m[s], 1.0, point[k])) {\n              ans++; }\n          }\n          max_ans = max(max_ans, ans);\n        }\n      }\n    }\n    printf(\"%d\\n\", max_ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-5;\n\nstruct Circle{\n  P c;\n  double r;\n  Circle(P c=P(0,0),double r=0):c(c),r(r){}\n};\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1=c1.r,r2=c2.r,d;\n  P p1=c1.c,p2=c2.c;\n  d=abs(p1-p2);\n  if(d<EPS&&abs(r1-r2)<EPS) return res;\n  if(r1+r2<d-EPS||d+EPS<abs(r1-r2)) return res; \n  double a=(r1*r1-r2*r2+d*d)/(2*d);\n  double h=sqrt(max(r1*r1-a*a,0.0));\n  P tmp1=p1+a/d*(p2-p1);\n  P tmp2=h/d*(p2-p1);\n  if(abs(tmp2)<EPS)res.push_back(tmp1);\n  else{\n    res.push_back(P(real(tmp1)-imag(tmp2),imag(tmp1)+real(tmp2)));\n    res.push_back(P(real(tmp1)+imag(tmp2),imag(tmp1)-real(tmp2)));\n  }\n  return res;\n}\n\ndouble getdistancepp(P a,P b){\n  return sqrt((a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag()));\n}\n\nint main(){\n  int n,ans=0;\n  double a,b;\n  P p[N];\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>a>>b;\n      p[i]=P(a,b);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tCircle c1,c2;\n\tc1.c=p[i];\n\tc2.c=p[j];\n\tc1.r=c2.r=1;\n\tvector<P> r=getIntersectCC(c1,c2);\n\tif(!r.size())continue;\n\tfor(int k=0;k<r.size();k++){\n\t  int cnt=0;\n\t  for(int l=0;l<n;l++)\n\t    if(getdistancepp(r[k],p[l])<=1+EPS)cnt++;\t    \n\t  ans=max(ans,cnt);\n\t}\n      }\n    }\n    if(!ans&&n>=1)ans=1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nconst double EPS = 1e-8;\ntypedef pair<double,double> P;\n\ndouble dist(P p,P q){\n  return ( (p.first-q.first)*(p.first-q.first) + (p.second-q.second)*(p.second-q.second));\n}\n\nint countP(double x,double y,vector<P>& p){\n  P t(x,y);\n  int ans = 0;\n  REP(i,p.size()){\n    if(dist(t,p[i]) < 1 + EPS){\n      ans ++;\n    }\n  }\n  return ans;\n}\n\nint main(){\n  int N;\n  double sign[2] = {+1, -1};\n  while(cin>>N,N){\n    vector<P> p(N);\n    REP(i,N)cin>>p[i].first>>p[i].second;\n    int ans = 1;\n    REP(i,N){\n      REP(j,N){\n        double dst = dist(p[i],p[j]);\n        if(dst > 4.0) continue;\n        P v((p[j].first-p[i].first)/dst, (p[j].second-p[i].second)/dst);\n        P m((p[j].first+p[i].first)/2.0, (p[j].second+p[i].second)/2.0);\n        REP(k,2){\n          double cx = m.first + sign[k] * v.first * (sqrt(1.0-dst*dst/4.0));\n          double cy = m.second - sign[k] * v.second * (sqrt(1.0-dst*dst/4.0));\n          int count = 0;\n          REP(l,N){\n            if(l == i || l == j || dist(P(cx,cy),p[l]) < 1){\n              count++;\n            }\n          }\n          ans = max(ans, count);\n        }\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////\n///   template   ///\n////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\nusing namespace std;\n\n//// MACRO ////\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define allof(c) c.begin(), c.end()\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define EPS 1e-10\n#define INF 1000000000\n\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n#define PREDIACTE(t,a) [](const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) [](const t & a, const t & b) -> bool\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n//// iota iterator ////\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n//// geo ////\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\npair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n//// bit ////\n#ifdef _MSC_VER\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n//// graph ////\nstruct Path\n{\n\tint from;\n\tint to;\n\tdouble cost;\n\tPath(int from = 0, int to = 0, double cost = 0) : from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\npair<double, vector<int>> prim(const vector<vector<double>> &costTable)\n{\n\tint N = costTable.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(0, 0, 0));\n\n\tvector<int> parent(N, -1);\n\tdouble totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(Path(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\npair<vector<double>, vector<int>> dijkstra(const vector<vector<Path>> &routes, int start = 0, int goal = -1)\n{\n\tint N = routes.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<double> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tPath next = Path(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n//// i/o ////\ntemplate <class T>\nclass vevector : public vector<vector<T>>\n{\npublic:\n\tvevector(int n = 0, int m = 0) : vector<vector<T>>(n, vector<T>(m)) { };\n\tvevector(int n, int m, const T &initial) : vector<vector<T>>(n, vector<T>(m, initial)) { };\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(read<T>(read<int>())); return v; }\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T> void write(const T &t, const T &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\ntemplate<class T>\nistream & operator>>(istream & in, complex<T> & n) { T r, i; in >> r >> i; n = complex<T>(r, i); return in; }\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\t// freopen(\"A.in\", \"r\", stdin);\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tauto testcases = INF; // read<int>();\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\n\t\tauto ps = read<P2>(N);\n\n\t\tint result = 1;\n\t\tREP(i_, N) FOR(j_, i_ + 1, N)\n\t\t{\n\t\t\tconst P2 i = ps[i_], j = ps[j_];\n\t\t\tdouble r = 1;\n\t\t\tif (abs(i - j) - 2 * r > -EPS) { continue; } // 遠すぎて円が作れない\n\n\t\t\tauto c = get_same_distance_points(i, j, r); // i と j から ちょうど r 離れた点\n\n\t\t\tauto c1 = Circle(c.first, r), c2 = Circle(c.second, r);\n\t\t\tresult = max<int>(result, count_if(allof(ps), [c1, r](P2 p) { return c1.Contains(p); }));\n\t\t\tresult = max<int>(result, count_if(allof(ps), [c2, r](P2 p) { return c2.Contains(p); }));\n\t\t}\n\n\t\twrite(result);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define EPS 1.0e-8\ntypedef complex<double> P;\n\nint main(){\n  int n;\n  P p[301];\n\n  while( cin>>n && n ){\n    for( int i=0;i<n;i++ )\n      cin >> p[i].real() >> p[i].imag();\n\n    int ans=0;\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ ){\n\tif( i==j ) \t  continue;\n\tif( abs( p[i]-p[j] )+EPS > 2.0 ) continue;\n\n\tP m  = (p[i]+p[j]) / 2.0;         // p[i]Æp[j]Ì_\n\tP nn = (p[i]-p[j]) * P(0.0,1.0);  // @üxNg\n\tnn = nn / abs(nn);\n\n\tdouble x = abs( p[i]-p[j] )/2.0;\n\tP c = m + nn*sqrt( 1.0-x*x );     // ~ÌS\n\n\tint num=0;\n\tfor( int k=0;k<n;k++ )\n\t  if( abs( c-p[k] ) < 1.0 + EPS  )\n\t    num++;\n\tans = max( ans,num );\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> coor;\n\n#define EPS 1e-5\n\ndouble in_cir(coor o, coor x)\n{\n  return abs(x - o);\n}\n\nint search(vector<coor> P)\n{\n  int mx = 0;\n  /*for (int i = 0; i < P.size(); i++) {\n    printf(\"%lf, %lf\\n\", P[i].real(), P[i].imag());\n    }*/\n  for (int i = 0; i < P.size(); i++) {\n    for (int j = i + 1; j < P.size(); j++) {\n      for (int k = 0; k < 2; k++) {\n\tif (abs(P[i] - P[j]) - 2.0 > -EPS) {continue;}\n\tcoor d = coor(P[i].imag() - P[j].imag(),\n\t\t      -(P[i].real() - P[j].real()));\n\tif (k == 1) {d = -d;}\n\td /= abs(d);\n\td *= sqrt(1 - norm(P[i] - P[j]) / 4);\n\t//printf(\"abs(d) = %lf\\n\", abs(d));\n\td += (P[i] + P[j]) / 2.0;\n\t//printf(\"%lf, %lf\\n\", d.real(), d.imag());\n\tint ctr = 2;\n\tfor (int l = 0; l < P.size(); l++) {\n\t  //printf(\"%lf\\n\", in_cir(d, P[l]));\n\t  if (l == i || l == j) {continue;}\n\t  if (in_cir(d, P[l]) - 1.0 < -EPS) {\n\t    ctr++;\n\t  }\n\t}\n\t//printf(\"_%d\\n\", ctr);\n\tmx = max(ctr, mx);\n\t\n      }\n    }\n  }\n  return mx;\n}\n\nint main()\n{\n  int N;\n  while (scanf(\"%d \", &N) == 1) {\n    if (N == 0) {\n      break;\n    }\n    vector<coor> P(N);\n    for (int i = 0; i < N; i++) {\n      double x, y;\n      scanf(\"%lf %lf \", &x, &y);\n      P[i] = coor(x, y);\n    }\n    printf(\"%d\\n\", search(P));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//suhan lee,saitama university\n\n//suhan lee,saitama university\n#include <bits/stdc++.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <complex>\nusing namespace std;\n \ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<bool> VB;\ntypedef pair<int, int> PII;\ntypedef long long ll;\ntypedef complex<double> cd;\ntypedef vector<cd> VC;\n#define all(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define repn(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define pb push_back \n#define pf push_front\nVC clist;\nint n,maxn;\ndouble kyori[300][300];\ndouble huris(VI blist,cd center,double kazu,int where){\n  if(where==n) {\n    // rep(i,kazu) cout<<blist[i]<<\"  \";\n    // cout<<endl<<endl;\n    return kazu;}\n  double locmax;\n  cd newcen;\n  if(kazu>0.5)\n    locmax= huris(blist,center,kazu,where+1);\n  else\n    locmax= huris(blist,clist[where+1],kazu,where+1);\n  if(abs(center-clist[where])>2)      \n    return locmax;\n  rep(i,(int)kazu)\n    if(kyori[blist[i]][where]>2) {\n      //    cout<<blist[i]<<\" \"<<where<<\"it can`t\\n\";\n      return locmax;\n    }\n  newcen=(clist[where]-(clist[where]-center)/abs(clist[where]-center));\n  if(kazu>3)\n \n  rep(i,(int)kazu)\n    if(abs(clist[blist[i]]-newcen)>1) {\n      return locmax;\n    }\n \n  if(abs(clist[where]-newcen)>1) \n    return locmax;\n \n  blist.pb(where);\n  return max(locmax,huris(blist,newcen,kazu+1,where+1));\n}\nint main(){\n  double x,y;\n  while(true){\n    cin>>n;\n    if(n==0) return 0;\n    maxn=0;\n    clist=VC(0);\n    rep(i,n){\n      cin>>x>>y;\n      cd tmpc(x,y);\n      clist.pb(tmpc);\n      rep(j,i){\n\tkyori[i][j]=kyori[j][i]=abs(clist[i]-clist[j]);\n      }\n    }\n\n    cout<<huris(VI(0),clist[0],0.0,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS (1e-6)\n\n\nvoid calc(double x1,double y1,double x2,double y2,double *c_x1,double *c_y1,double *c_x2,double *c_y2){\n  double midx,midy,hox,hoy,dx,dy,dis;\n  midx = (x1+x2) / 2.0 , midy = (y1+y2) / 2.0;\n  dx = x1-x2 , dy = y1-y2;\n  dis = sqrt(1 - pow(x1-midx,2.0) - pow(y1-midy,2.0));\n  hox = sqrt(pow(dy,2.0) / (pow(dy,2.0) + pow(dx,2.0)));\n  hoy = hox * (-1.0) * (dx / dy);\n  *c_x1 = midx + hox*dis,*c_y1 = midy + hoy*dis;\n  *c_x2 = midx - hox*dis,*c_y2 = midy - hoy*dis;\n}\n\nint main(){\n  int N;\n\n  while(cin >> N){\n    double x[300],y[300],c_x1,c_y1,c_x2,c_y2;\n    int count,m;\n    m = 0;\n    if(!(N)) break;\n    for(int i=0;i<N;i++) cin >> x[i] >> y[i];\n\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n        if(i == j) continue;\n        if(sqrt((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j])) > 2.0 + EPS  ) continue;\n        count = 2;\n        calc(x[i],y[i],x[j],y[j],&c_x1,&c_y1,&c_x2,&c_y2);\n        for(int k=0;k<N;k++){\n          if(k == i || k == j) continue;\n          if((x[k] - c_x1)*(x[k] - c_x1) + (y[k] - c_y1)*(y[k] - c_y1) < 1.0  ) count++;\n        }\n        if(m < count) m = count;\n        count = 2;\n        for(int k=0;k<N;k++){\n          if(k == i || k == j) continue;\n          if((x[k] - c_x2)*(x[k] - c_x2) + (y[k] - c_y2)*(y[k] - c_y2) < 1.0) count++;\n        }\n        if(m < count) m = count;\n      }\n    }\n\n    printf(\"%d\\n\",m);\n  }\n\n  return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\n#define EPS (1e-9)\n#define prev(P,i) P[(i+P.size()-1)%P.size()]\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\ntypedef complex < double > P; // P:点\nstruct L:public vector< P >{ // L:線分\n  L(){resize(2);}\n  L(const P& a,const P& b){push_back(a);push_back(b);}\n};\nstruct C{ //C:円\n  P p; double r;\n  C():p(0),r(0){}\n  C(const P& p, double r):p(p),r(r){};\n};\n\ndouble cross(const P& a,const P& b){\n  return imag(conj(a) * b);\n}\ndouble dot(const P& a,const P& b){\n  return real(conj(a) * b);\n}\nP projection(const L& l,const P& p){\n  double t = dot(p-l[0],l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t * (l[0] - l[1]);\n}\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c) > 0) return 1;\n  if(cross(b,c) < 0) return -1;\n  if(dot(b,c) < 0) return 2; // c--a--b\n  if(norm(b) < norm(c)) return -2; // a--b--c\n  return 0; // a--c--b\n}\nbool interectCC(const C& c,const C& d){\n  return (norm(c.p - d.p) - (c.r + d.r)*(c.r + d.r) < EPS) &&\n    (norm(c.p - d.p) - (c.r - d.r)*(c.r - d.r) > -EPS);\n}\npair< P , P > crosspointCC(const C& c,const C& q){\n  P a = conj(q.p - c.p);\n  P b = q.r  * q.r - c.r * c.r - (q.p - c.p) * a;\n  P C = c.r * c.r * (q.p - c.p);\n  P d = b * b - 4.0 * a * C;\n  P z1 = (-b * sqrt(d)) / (2.0 * a) + c.p;\n  P z2 = (-b - sqrt(d)) / (2.0 * a) + c.p;\n  return pair< P , P >( z1, z2);\n}\nint main(){\n  int n;\n  while(cin >> n , n){\n    vector < P > pts(n);\n    int ans = 1;\n    for(int i = 0 ; i < n ; i++ ){\n    cin >> pts[i].real() >> pts[i].imag();\n    }\n    for(int i = 0 ; i < n ; i++ ){\n      C c1 = C( pts[i], 1);\n      for(int j = 0 ; j < i ; j++ ){\n        C c2 = C( pts[j], 1);\n        if(interectCC(c1,c2)){\n          pair< P , P > nnr = crosspointCC( c1, c2);\n          int ret = 0, rec = 0;\n          for(int k = 0 ; k < n ; k++ ){\n            if(abs(nnr.first - pts[k]) <= 1 + EPS) ret++;\n            if(abs(nnr.second - pts[k]) <= 1 + EPS) rec++;\n          }\n          ans = max( ans, max( ret, rec));\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(u) begin(u),end(u)\n#define PB push_back\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\ntypedef long long int ll;\nconst int INF = (1<<30) - 1;\nconst double EPS = 1e-9;\nconst int MOD = 1000000007;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n#define X real()\n#define Y imag()\n\n\n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n    VP cs;\n    P abH = (b-a)*0.5;\n    D d = abs(abH);\n    if (d == 0 || d > r) return cs;\t// ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n    D dN = sqrt(r*r - d*d);\t\t\t\t\t// ???????????? max(r*r - d*d, 0) ??¨??????\n    P n = abH * P(0,1) * (dN / d);\n    cs.push_back(a + abH + n);\n    if (dN > 0) cs.push_back(a + abH - n);\n    return cs;\n}\n\nint N;\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    //cout.setf(ios::fixed);\n    \n    while(cin >> N, N){\n        vector<P> points(N);\n        for(int i=0; i<N; i++){\n            D x, y; cin >> x >> y;\n            points[i] = P(x, y);\n        }\n        \n        int ans = 0;\n        for(int i=0; i<N; i++)\n            for(int j=i+1; j<N; j++){\n                VP vs = circlesPointsRadius(points[i], points[j], 1);\n                for(auto v: vs){\n                    int tans = 0;\n                    for(auto p: points)\n                        if(LE(abs(p-v), 1))\n                            tans++;\n                    ans = max(ans, tans);\n                }\n            }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n#define P complex<double>\n#define EPS 1.0e-8\n\nint main(){\n  int n;\n  P p[301];\n\n  while( cin>>n && n ){\n    for( int i=0;i<n;i++ )\n      cin >> p[i].real() >> p[i].imag();\n\n    int ans=0;\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ ){\n\tif( i==j ) \t  continue;\n\tif( abs( p[i]-p[j] )+EPS > 2.0 ) continue;\n\n\tP m  = (p[i]+p[j]) / 2.0; // p[i]Æp[j]Ì_\n\tP nn = (p[i]-p[j]) * P(0,1);       // @üxNg\n\tnn = nn / abs(nn);\n\n\tdouble x = abs( p[i]-p[j] )/2.0;\n\tP c = m + nn*sqrt( 1.0-x*x );        // ~ÌS\n\n\tint num=0;\n\tfor( int k=0;k<n;k++ )\n\t  if( abs( c-p[k] ) < 1.0 + EPS  )\n\t    num++;\n\tans = max( ans,num );\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <cfloat>\nusing namespace std;\n\nconst double EPS = 1.0e-9;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    const Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    const Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    const Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y-p.y, 2.0) + pow(x-p.x, 2.0));\n    }\n    double dist2(const Point& p) const{\n        return pow(y-p.y, 2.0) + pow(x-p.x, 2.0);\n    }\n};\n\nint solve(vector<Point>& vp)\n{\n    int n = vp.size();\n    int ret = 1;\n\n    for(int i=0; i<n; ++i){\n        for(int j=i+1; j<n; ++j){\n            double dist = vp[i].dist(vp[j]);\n            if(dist > 2.0)\n                continue;\n\n            for(int k=0; k<2; ++k){\n                Point p = vp[j] - vp[i];\n                Point p1(p.x, p.y);\n                if(k == 0)\n                    p1.x *= -1;\n                else\n                    p1.y *= -1;\n                p = vp[i] + p * 0.5 + p1 * (sqrt(pow(dist, -2) - 0.25));\n                int num = 0;\n                for(int l=0; l<n; ++l){\n                    if(p.dist2(vp[l]) < 1.0 + EPS)\n                        ++ num;\n                }\n                ret = max(ret, num);\n            }\n        }\n    }\n\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            break;\n\n        vector<Point> p(n);\n        for(int i=0; i<n; ++i)\n            cin >> p[i].x >> p[i].y;\n        cout << solve(p) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return fabs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nint n;\ndouble x[300], y[300];\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\trep(i,n) cin >> x[i] >> y[i];\n\t\t\n\t\tint res = 1;\n\t\t// 2点に接する円のみ考える\n\t\trep(i,n) reps(j,i+1,n) {\n\t\t\tdouble d = sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]));\n\t\t\tif (d>2) continue;\n\t\t\tP I = P(x[i],y[i]), J = P(x[j],y[j]), C = (I+J)/2.0;\n\t\t\tdouble l = sqrt(1 - abs(I-C)*abs(I-C));\n\t\t\tP HA = P(I-J) * P(0,1), HB = P(I-J) * P(0,-1);\n\t\t\tHA /= abs(HA), HA *= l;\n\t\t\tHB /= abs(HB), HB *= l;\n\t\t\tdouble xi = (C+HA).real(), yi = (C+HA).imag(), xj = (C+HB).real(), yj = (C+HB).imag();\n\t\t\tint t = 0;\n\t\t\trep(k,n) if (sqrt((xi-x[k])*(xi-x[k]) + (yi-y[k])*(yi-y[k]))<=1) t++;\n\t\t\tchmax(res,t);\n\t\t\tt = 0;\n\t\t\trep(k,n) if (sqrt((xj-x[k])*(xj-x[k]) + (yj-y[k])*(yj-y[k]))<=1) t++;\n\t\t\tchmax(res,t);\n\t\t}\n\t\tcout << res << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> p;\nconst double eps = 1e-9;\n\nint n;\np ps[300];\n\nint main() {\n\twhile (cin >> n , n != 0) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tps[i] = p(x, y);\n\t\t}\n\n\t\tint ans = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (!(norm(ps[i] - ps[j]) < 4.0)) continue;\n\t\t\t\tp v = ps[i] - ps[j], ve = v / abs(v);\n\t\t\t\tdouble l = sqrt(1 - norm(v) * 0.25);\n\t\t\t\tp vn1 = ve * p(0, 1) * l, vn2 = ve * p(0, -1) * l;\n\t\t\t\tp c1 = ps[j] + v * 0.5 + vn1, c2 = ps[j] + v * 0.5 + vn2;\n\t\t\t\tint count1 = 2, count2 = 2;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (k == i || k == j) continue;\n\t\t\t\t\tif (norm(c1 - ps[k]) < 1.0 + eps) count1++;\n\t\t\t\t\tif (norm(c2 - ps[k]) < 1.0 + eps) count2++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, count1);\n\t\t\t\tans = max(ans, count2);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n#define F real()\n#define S imag()\n#define EPS (1e-6)\nint N;\nP D[333];\nstruct Circle{\n  double r;\n  P c;\n  Circle(){ r = 1.0; }\n  Circle(P c1){\n    c = c1;\n    r = 1.0;\n  }\n};\ndouble getK(P a,P b ){\n  return sqrt((a.F-b.F)*(a.F-b.F)+(a.S-b.S)*(a.S-b.S));\n}\n\nint getC(P a){\n  // cout << a.F << \" \" << a.S << endl;\n  int ret = 0;\n  for(int i=0;i<N;i++){\n    //cout << \" k \" << getK(a,D[i]) << endl;\n    if( 1.0+EPS >= getK(a,D[i]) ) ret++;\n  }\n  return ret;\n}\n\ndouble getAngle( P a ,P b ){\n  return atan((b.S-a.S)/(b.F-a.F));\n}\n\nvector<P> getIntersectCC(Circle C1,Circle C2){\n  vector<P> res;\n  double r1 = C1.r, r2 = C2.r, d;\n  P p1 = C1.c, p2 = C2.c;\n  d = abs(p1-p2);\n  \n  if( d < EPS && abs( r1 - r2 ) < EPS ) return res;\n  if( r1 + r2 < d - EPS || d + EPS < abs(r1-r2) ) return res;\n  \n  double a = (r1*r2 - r2*r2 + d*d ) / (2*d);\n  double h = sqrt( max( r1 * r1 - a*a , 0.0 ) );\n  P tmp1 = p1 + a/d * (p2-p1);\n  P tmp2 = h/d * (p2-p1);\n  \n  if( abs(tmp2) < EPS) res.push_back(tmp1);\n  else {\n    res.push_back( P(real(tmp1) - imag(tmp2), imag(tmp1) + real(tmp2)));\n    res.push_back( P(real(tmp1) + imag(tmp2), imag(tmp1) - real(tmp2)));\n  }\n}\n\nvector<P> getP(P a, P b){\n  return getIntersectCC( Circle(a), Circle(b) );\n}\n\nint main(){\n  while( cin >> N && N ){\n    for(int i=0;i<N;i++) {\n      cin >> D[i].real() >> D[i].imag();\n    }\n    int res = 1;\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n\tif( i==j ) continue;\n\tP r,l;\n\tvector<P> p = getP( D[i],D[j]);\n\tfor(int i=0;i<(int)p.size();i++){\n\t  res = max( res, getC(p[i]) );\n\t  res = max( res, getC(p[i]) );\n\t}\n\t//res = max( res, solve(i) );\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ndouble p[300][2];\nint n;\n\ndouble dis(double x1, double y1, double x2, double y2){\n    return sqrt(pow(x1-x2, 2) + pow(y1-y2, 2));\n}\n\nint circle(double x, double y, int i, int j){\n    int count = 2;\n    REP(k, n){\n        if(k!=i && k!=j){\n            if(dis(x, y, p[k][0], p[k][1]) < 1){\n                count += 1;\n            }\n        }\n    }\n    return count;\n}\n\nint main(){\n    while(1){\n        cin >> n;\n\n        if(n==0) break;\n\n        REP(i, n){\n            cin >> p[i][0];\n            cin >> p[i][1];\n        }\n\n        int output = 1;\n        REP(i, n){\n            for(int j=i+1; j<n; j++){\n                double cx = (p[i][0]+p[j][0]) / 2;\n                double cy = (p[i][1]+p[j][1]) / 2;\n                double d = dis(p[i][0], p[i][1], p[j][0], p[j][1]);\n\n                if(d>2){\n                    continue;\n                } else if (d==2){\n                    output = max(output, circle(cx, cy , i, j));\n                } else {\n                    double a1 = acos(d/2);\n                    double a2 = atan2((p[j][1]-p[i][1]), p[j][0]-p[i][0]);\n\n                    double x1 = p[i][0] + cos(a2+a1);\n                    double y1 = p[i][1] + sin(a2+a1);\n\n                    double x2 = p[i][0] + cos(a2-a1);\n                    double y2 = p[i][1] + sin(a2-a1);\n\n                    output = max(output, circle(x1, y1, i, j));\n                    output = max(output, circle(x2, y2, i, j));\n                }\n            }\n        }\n\n        cout << output << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nstruct Point{\n    double x,y;\n};\n\nvoid func(int N){\n\n    Point point[N];\n    double x_min = 100,y_min = 100,x_max = -1,y_max = -1;\n\n    for(int i = 0; i < N; i++){\n        scanf(\"%lf %lf\",&point[i].x,&point[i].y);\n        x_min = min(point[i].x,x_min);\n        y_min = min(point[i].y,y_min);\n        x_max = max(point[i].x,x_max);\n        y_max = max(point[i].y,y_max);\n    }\n\n    if(x_min > 1)x_min -= 0.05;\n    if(y_min > 1)y_min -= 0.05;\n    if(x_max < 9)x_max += 0.05;\n    if(y_max < 9)y_max += 0.05;\n\n    int count,max_count = 0;\n\n    for(double y = y_min; y <= y_max; y += 0.01){\n        for(double x = x_min; x <= x_max; x += 0.01){\n            count = 0;\n            for(int i = 0; i < N; i++){\n                if(sqrt((x-point[i].x)*(x-point[i].x)+(y-point[i].y)*(y-point[i].y)) <= 1.0)count++;\n            }\n            max_count = max(max_count,count);\n        }\n    }\n\n    printf(\"%d\\n\",max_count);\n}\n\n\nint main(){\n\n    int N;\n\n    while(true){\n        scanf(\"%d\",&N);\n        if(N == 0)break;\n\n        func(N);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble Dis(double x1, double y1, double x2, double y2);\nint main(void){\n\twhile(1){\n\t\tint n;\n\t\tint ans = 1;\n\t\tvector< pair<double, double> > p;\n\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tpair<double, double> t;\n\t\t\tcin >> t.first >> t.second;\n\t\t\tp.push_back(t);\n\t\t}\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t//中点\n\t\t\t\tdouble mpx = (p[i].first + p[j].first) / 2.0;\n\t\t\t\tdouble mpy = (p[i].second + p[j].second) / 2.0;\n\t\t\t\t//2点間の距離\n\t\t\t\tdouble d1 = Dis(p[i].first, p[i].second, p[j].first, p[j].second);\n\t\t\t\t//p[i]からp[j]へ向かうベクトル\n\t\t\t\tdouble v1x = (p[i].first - p[j].first) / d1;\n\t\t\t\tdouble v1y = (p[i].second - p[j].second) / d1;\n\t\t\t\t//中点から円の中心へ向かう単位ベクトル\n\t\t\t\tdouble v2x = -v1y;\n\t\t\t\tdouble v2y = v1x;\n\t\t\t\t//中心から円の中心へ向かうベクトルの長さ\n\t\t\t\tdouble d2 = sqrt(1.0 - (d1*d1/4.0));\n\n\t\t\t\t//円の中心の座標\n\t\t\t\tdouble cx = mpx + v2x * d2;\n\t\t\t\tdouble cy = mpy + v2y * d2;\n\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(k == i || k == j || (cx-p[k].first)*(cx-p[k].first) + (cy-p[k].second)*(cy-p[k].second) <= 1.0)\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt > ans){\n\t\t\t\t\tans = cnt;\n\t\t\t\t}\n\n\t\t\t\tcx = mpx - v2x * d2;\n\t\t\t\tcy = mpy - v2y * d2;\n\n\t\t\t\tcnt = 0;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(Dis(cx, cy, p[k].first, p[k].second) <= 1.0)\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt > ans){\n\t\t\t\t\tans = cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\n\t}\n\t\n\treturn 0;\n}\n\ndouble Dis(double x1, double y1, double x2, double y2){\n\treturn sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));\n}"
  },
  {
    "language": "C++",
    "code": "\n//Name: Circle and Points\n//Level: 3\n//Category: 幾何,円\n//Note:\n\n/*\n * 半径が固定なので，円周上に2点が乗っているときが境界状態．\n * すべての2点の組み合わせについて中心の来る場所（2点）を求め，内包判定を行う．\n * N=1のケースと，全ての点が互いに距離2以上離れているケースに注意．\n *\n * オーダーは O(N^3)．\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <utility>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nbool inCircle(const Point &p, const Point &center, double radius) {\n    double dist2 = norm(p-center);\n    double rad2 = radius*radius;\n    return dist2 < rad2+1e-9;\n}\n\nint check(const Point &center, const vector<Point> &points) {\n    const int N = points.size();\n    int cnt = 0;\n    for(int i = 0; i < N; ++i) {\n        if(inCircle(points[i], center, 1)) ++cnt;\n    }\n    return cnt;\n}\n\nint test(int a, int b, const vector<Point> &points) {\n    const Point v(points[a]-points[b]);\n    if(abs(v) >= 2) return 1;\n    const double hlen = abs(v)/2;\n\n    const double plen = sqrt(1 - hlen*hlen);\n    Point perp = v*Point(0, 1);\n    perp /= abs(perp);\n    const Point mid = points[b] + v/2.0;\n    return max(check(mid + perp*plen, points), check(mid - perp*plen, points));\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        vector<Point> points(N);\n        for(int i = 0; i < N; ++i) {\n            cin >> points[i].real() >> points[i].imag();\n        }\n        int ans = 0;\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < i; ++j) {\n                ans = max(ans, test(i, j, points));\n            }\n        }\n        if(N == 1) ans = 1;\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define PI 3.141592653589793238\n// sqrt重い\nusing namespace std;\ntypedef pair<double,double> P;\n\nvoid display(complex<double> a,complex<double> b){\n cout << \"(\" << a.real() <<\",\" << a.imag() <<\")\"<< \" \" <<\"(\"<< b.real() <<\",\" <<b.imag() << \")\" << endl;\n}\n\nint main(){\n  int n,ans;\n  double xin,yin,X;\n  complex<double> m;\n  while(cin >> n && n){\n    ans = 1;\n    complex<double> point[n];\n    for(int i=0;i<n;i++){\n      cin >> xin >> yin;\n      point[i] = complex<double>(xin,yin);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i == j)continue;\n\tcomplex<double> Rr = point[i]-point[j];\n\tif(abs(Rr) <= 2+EPS){\n\n\t  complex<double> UKPC,U,P1,P2;\n\t  UKPC = (point[i]+point[j])*0.5;       \n\t  double T = sqrt(1-norm(point[i]-point[j])*0.25);\n\n\t  UKPC = (point[i]+point[j])*0.5;\n  \t  P1 = UKPC + (point[i]-point[j])/abs(point[i]-point[j])*polar(T,PI/2.0);\n\t  P2 = UKPC + (point[i]-point[j])/abs(point[i]-point[j])*polar(T,-PI/2.0);\n\t  //cout << \"P1 = \" << P1 << \", P2 = \" << P2 << endl;\n\t  int cnt=0;\n\t  complex<double> CalcP;\n\t  double Calc;\n\t  for(int k=0;k<n;k++){\n\t    Calc = abs(P1-point[k]);\n\t    if(Calc < 1.0+EPS){\n\t      cnt++;\n\t    }\n\t  }\t\n\n\t  ans = max(ans,cnt);\n\t  cnt = 0;\n\t  for(int k=0;k<n;k++){\n\t    Calc = abs(P2-point[k]);\n\t    if(fabs(Calc) < 1.0+EPS){\n\t      cnt++;\n\t    }\n\t  }\t\n  \n\t  ans = max(ans,cnt);\n\t  \n\n\t}\n\n      }\n    }\n\n    cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-8\n#define INF 1000000\n \nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n    Point operator *(const double d)const{\n        return Point(x*d,y*d);\n    }\n    bool operator <(const Point &p)const{\n        if(x==p.x) return y<p.y;\n        return x<p.x;\n    }\n    double norm(){\n        return x*x+y*y;\n    }\n\tbool input(){\n\t\tif(cin>>x>>y) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n\tbool input(){\n\t\tif(a.input() && b.input()) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point _c,double _r){\n        c=_c; r=_r;\n    }\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n \nint ccw(Point a,Point b,Point c){ \n\tPoint v1 = b-a;\n\tPoint v2 = c-a;\n    if(cross(v1,v2)>EPS) return +1; \n    if(cross(v1,v2)<-EPS) return -1; \n\tif(dot(v1,v2)<-EPS) return +2; \n\tif(v1.norm()<v2.norm()) return -2; \n    return 0; \n}\n \nbool intersect_ss(Line l,Line m){\n\treturn ccw(l.a,l.b,m.a)*ccw(l.a,l.b,m.b)<=0 && ccw(m.a,m.b,l.a)*ccw(m.a,m.b,l.b)<=0;\n}\n \nbool crosspoint_ll(Line l,Line m,Point &p){\n    Point a1,a2,b1,b2;\n    a1 = l.b-l.a; a2 = m.b-m.a;\n    b1 = m.a-l.a; b2 = l.a-m.b;\n    double s1,s2;\n    s1 = cross(a1,b1)/2; s2 = cross(a1,b2)/2;\n    if(s1+s2<EPS) return false; \n    p = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n    return true;\n}\n \nint crosspoint_ss(Line l,Line m,Point &p){\n    if(intersect_ss(l,m)==false) return 0; \n    if(crosspoint_ll(l,m,p)==true) return 1;\n\treturn -1; \n}\n \nint crosspoint_cc(Circle c1,Circle c2,Point &p1,Point &p2){\n    double d,a,t;\n    d = sqrt((c2.c-c1.c).norm());\n\tif(abs(c1.c.x-c2.c.x)<EPS && abs(c1.c.y-c2.c.y)<EPS && abs(c1.r-c2.r)<EPS)\n\t\treturn -1; \n    if(d<abs(c1.r-c2.r) || c1.r+c2.r<d) return 0; \n    a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    t = atan2(c2.c.y-c1.c.y,c2.c.x-c1.c.x);\n    p1 = Point(c1.c.x+c1.r*cos(t+a),c1.c.y+c1.r*sin(t+a));\n    p2 = Point(c1.c.x+c1.r*cos(t-a),c1.c.y+c1.r*sin(t-a));\n    if(abs(p1.x-p2.x)<EPS && abs(p1.y-p2.y)<EPS) return 1; \n    return 2; \n}\n\nint contains(Polygon g,Point p){\n\tLine l = Line(p,Point(INF,p.y));\n\tint cnt = 0, n = g.size();\n\tfor(int i=0;i<n;i++){\n\t\tPoint a = g[i]-p;\n\t\tPoint b = g[(i+1)%n]-p;\n\t\tif(ccw(g[i],g[(i+1)%n],p)==0) return 1; \n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<=EPS && EPS<b.y && cross(a,b)>EPS) cnt++;\n\t}\n\tif((cnt&1)==1) return 2; \n\treturn 0; \n}\n\nPolygon andrewScan(Polygon s){\n\tif(s.size()<=2) return s;\n\tsort(s.begin(),s.end());\n\tPolygon g;\n\tfor(int i=0;i<s.size();i++){\n\t\tfor(int n=g.size(); n>=2 && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\tint upper_n = g.size();\n\tfor(int i=s.size()-2;i>=0;i--){\n\t\tfor(int n=g.size(); n>upper_n && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\treverse(g.begin(),g.end());\n\tg.pop_back();\n\treturn g;\n}\n\nint cntInsidePoint(Circle c,Polygon s){\n\tint cnt=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tif((s[i]-c.c).norm()<=1.0) cnt++;\n\t}\n\treturn cnt;\n}\n\nint main(){\n\tint N;\n\twhile(cin>>N,N){\n\t\tPolygon S;\n\t\tS.resize(N);\n\t\tfor(int i=0;i<N;i++) S[i].input();\n\t\tint ans = 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=i+1;j<N;j++){\n\t\t\t\tPoint p1,p2;\n\t\t\t\tif(crosspoint_cc(Circle(S[i],1),Circle(S[j],1),p1,p2)>0){\n\t\t\t\t\tans = max(ans,max(cntInsidePoint(Circle(p1,1),S),cntInsidePoint(Circle(p2,1),S)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nP readP() {\n    double x, y;\n    cin >> x >> y;\n    return P(x, y);\n}\n\n// rot p around q by theta (counter-clockwise)\nP rotP(P p, P q, double theta) {\n    p -= q;\n    double x = p.real(), y = p.imag();\n    p = P(x * cos(theta) - y * sin(theta), x * sin(theta) + y * cos(theta));\n    p += q;\n    return p;\n}\n\nP center(P p, P q) {\n    P v = p - q;\n    double theta = asin(abs(v) / 2);\n    v *= (1 / abs(v));\n    P u = rotP(v, p, theta);\n    return p + u;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    while (cin >> n, n) {\n        vector<P> p(n);\n        rep(i, n) p[i] = readP();\n\n        int ans = 1;\n        rep(i, n) {\n            rep(j, n) {\n                if (i == j) continue;\n                if (abs(p[i] - p[j]) <= 2) {\n                    P c = center(p[i], p[j]);\n                    int cnt = 2;\n                    rep(k, n) {\n                        if (k == i || k == j) continue;\n                        if (abs(p[k] - c) <= 1) {\n                            cnt++;\n                        }\n                    }\n                    ans = max(ans, cnt);\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n\nusing namespace std;\ntypedef pair<double, double> P;\nconst double EPS = 1e-4;\n\n#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n\nusing namespace std;\n\nvector<P> center(P a, P b)\n{\n    auto t = atan2(b.second - a.second, b.first - a.first);\n    auto x = hypot(a.first - b.first, a.second - b.second) / 2;\n    auto y = sqrt(1.0 - x * x);\n    auto cs = cos(t), sn = sin(t);\n    return { \n        { cs * x - sn * y + a.first, sn * x + cs * y + a.second },\n        { cs * x + sn * y + a.first, sn * x - cs * y + a.second }\n    };\n}\n\nint main()\n{\n    while (1) {\n        int n; cin >> n;\n        if (!n) break;\n        vector<P> pnt;\n        loop (n, i) {\n            double x, y; cin >> x >> y;\n            pnt.emplace_back(x, y);\n        }\n        int ans = 1;\n        loop (n, i) loop (n, j) {\n            auto ps = center(pnt[i], pnt[j]);\n            for (auto o : ps) {\n                int cnt = 0;\n                loop (n, l) {\n                    auto x = o.first - pnt[l].first;\n                    auto y = o.second - pnt[l].second;\n                    if (x * x + y * y < 1 + EPS) cnt++;\n                }\n                ans = max(ans, cnt);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\n\nconstexpr long double EPS = 10e-6;\nconstexpr long double radius = 1.0 + EPS;\nconstexpr long double diameter = 2.0 + EPS;\n\nclass Point{\n    public: \n    long double x,y;\n    Point(long double x = 0.0, long double y = 0.0): x(x), y(y) {}\n    Point operator + (Point p) const {\n        return Point(x+p.x, y+p.y);\n    }\n    Point operator - (Point p) const {\n        return Point(x-p.x, y-p.y);\n    }\n    Point operator * (long double a) const {\n        return Point(x*a, y*a);\n    }\n    Point operator / (long double a) const {\n        return Point(x/a, y/a);\n    }\n    long double norm() const {\n        return x*x + y*y;\n    }\n    long double dot(Point p) const {\n        return x*p.x + y*p.y;\n    }\n};\n\nint main() {\n    int n;\n    while(scanf(\"%d\", &n) && n){\n        vector<Point> points(n);\n        rep(n) scanf(\"%Lf %Lf\", &points[i].x, &points[i].y);\n\n        int ans = 1, tmp;\n        Point mid, midv, center;\n        long double c;\n        rep(n){\n            repp(j, n){\n                if(j == i) continue;\n                mid = points[j] - points[i];\n                if(mid.norm() > diameter*diameter) continue;\n                mid = mid * 0.5;\n                midv = Point(mid.y, -mid.x);\n                c = sqrt((1.0 - mid.norm())/midv.norm());\n                center = points[i] + mid + midv * c;\n                tmp = 0;\n                for(Point p: points){\n                    Point v = p-center;\n                    if(v.norm() <= radius) tmp++;\n                }\n                ans = max(tmp, ans);\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-8;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return fabs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nint n;\ndouble x[300], y[300];\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\trep(i,n) cin >> x[i] >> y[i];\n\t\t\n\t\tint res = 1;\n\t\t// 2点に接する円のみ考える\n\t\trep(i,n) reps(j,i+1,n) {\n\t\t\tdouble d = sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]));\n\t\t\tif (d>2) continue;\n\t\t\tP I = P(x[i],y[i]), J = P(x[j],y[j]), C = (I+J)/2.0;\n\t\t\tdouble l = sqrt(1. - abs(I-C)*abs(I-C));\n\t\t\tP HA = P(I-J) * P(0,1), HB = P(I-J) * P(0,-1);\n\t\t\tHA /= abs(HA), HA *= l;\n\t\t\tHB /= abs(HB), HB *= l;\n\t\t\tdouble xi = (C+HA).real(), yi = (C+HA).imag(), xj = (C+HB).real(), yj = (C+HB).imag();\n\t\t\tint t = 0;\n\t\t\trep(k,n) if (sqrt((xi-x[k])*(xi-x[k]) + (yi-y[k])*(yi-y[k]))<=1+eps) t++;\n\t\t\tchmax(res,t);\n\t\t\tt = 0;\n\t\t\trep(k,n) if (sqrt((xj-x[k])*(xj-x[k]) + (yj-y[k])*(yj-y[k]))<=1+eps) t++;\n\t\t\tchmax(res,t);\n\t\t}\n\t\tcout << res << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\ntypedef long double ld;\n\nstruct Point {\n    ld x, y;\n    Point(ld x=0.0, ld y=0.0) : x(x), y(y) {}\n    string to_s() {\n        ostringstream os;\n        os << x << ',' << y;\n        return os.str();\n    }\n    Point operator+(const Point& o) const {\n        return Point(x+o.x, y+o.y);\n    }\n};\n\nstruct Circle {\n    ld x, y;\n    ld r;\n    Circle(ld x=0.0, ld y=0.0, ld r=1.0) : x(x), y(y), r(r) {}\n    const static ld eps = 1e-7;\n    bool isIntersect(const Circle& o) const {\n        ld dx = o.x - x;\n        ld dy = o.y - y;\n        return (r + o.r) * (r + o.r) > (dx*dx + dy*dy);\n    }\n    pair<Point, Point> intersectionPoint(const Circle& o) const {\n        ld dx = x - o.x;\n        ld dy = y - o.y;\n        ld a = (dx*dx + dy*dy + r*r - o.r*o.r) / 2.0;\n        ld d = sqrt((dx*dx+dy*dy)*r*r-a*a);\n        Point p, q;\n        p.x = (a*dx + dy * d) / (dx*dx+dy*dy) + o.x;\n        q.x = (a*dx - dy * d) / (dx*dx+dy*dy) + o.x;\n        p.y = (a*dy - dx * d) / (dx*dx+dy*dy) + o.y;\n        q.y = (a*dy + dx * d) / (dx*dx+dy*dy) + o.y;\n        //cout << p.x << ',' << p.y << endl;\n        //cout << q.x << ',' << q.y << endl;\n        return make_pair(p, q);\n    }\n    bool contains(ld px, ld py) const {\n        return r*r + eps >= (px - x) * (px - x) + (py - y) * (py - y);\n    }\n    string to_s() {\n        ostringstream os;\n        os << x << ',' << y << ':' << r << endl;\n        return os.str();\n    }\n};\n\nint countContainingPoints(const Circle& c, const vector<Circle>& ps) {\n    int cnt = 0;\n    for (int i = 0; i < ps.size(); i++) \n        if (c.contains(ps[i].x, ps[i].y)) \n            cnt++;\n    return cnt;\n}\n\nint N;\nint main() {\n    //cout << Circle(0, 0, 5).intersectionPoint(Circle(8, 0, 5)).first.to_s() << endl;\n    vector<Circle> cs;\n    while (cin >> N, N) {\n        cs.clear(); cs.resize(N);\n        for (int i = 0; i < N; i++) cin >> cs[i].x >> cs[i].y;\n\n        vector<Point> ips; // Intersection PointS\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (i == j) continue;\n                if (!cs[i].isIntersect(cs[j])) continue;\n                pair<Point, Point> ip = cs[i].intersectionPoint(cs[j]);\n                ips.push_back(ip.first);\n                ips.push_back(ip.second);\n            }\n        }\n\n        int maxPoint = 0;\n        for (int i = 0; i < ips.size(); i++) {\n            maxPoint = max(maxPoint, countContainingPoints(Circle(ips[i].x, ips[i].y, 1.0), cs));\n        }\n        cout << maxPoint << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<vector>\n#define mp make_pair\n#define pb push_back\n#define rep(i,n) for(int i = 0;i < n;i++)\nusing namespace std;\n\ndouble dist(double x1,double y1,double x2,double y2){\n    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\n\ndouble dist(double x1,double y1){\n    return dist(x1,y1,0,0);\n}\n\nvoid calccenter(double c[][2],double u1[],double u2[]){\n    double v[2]={u2[0]-u1[0],u2[1]-u1[1]};\n    rep(i,2) {\n        rep(j,2){\n            c[i][j]=(u1[j]+u2[j])/2.0;\n        }\n    }\n    double lenv = dist(v[0],v[1]);\n    double lent = sqrt(1-pow((lenv/2.0),2));\n    rep(i,2){\n        double dg = i?1.0:-1.0;\n        c[i][0]+=dg*(v[1]*lent/lenv);\n        c[i][1]-=dg*(v[0]*lent/lenv);\n    }\n}\n\nint main(){\n    int N;\n    while(1){\n        cin>>N;\n        if(!N)break;\n        double a[300][2];\n        rep(i,N){\n            cin>>a[i][0]>>a[i][1];\n        }\n        int ans = 0;\n        int temp = 0;\n        if(N==1){\n            cout<<1<<endl;\n            break;\n        }\n        rep(u1,N){\n            for(int u2 = u1+1;u2<N;u2++){\n                double c[2][2];\n                calccenter(c,a[u1],a[u2]);\n                rep(k,2){\n                    temp = 0;\n                    rep(l,N){\n                        if(l==u1||l==u2){\n                            temp++;\n                        }else if(dist(c[k][0],c[k][1],a[l][0],a[l][1])<=1.0){\n                            temp++;\n                        }\n                    }\n                    ans = max(ans,temp);\n                }\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-7;\n\nstruct Circle{\n  P c;\n  double r;\n  Circle(P c=P(0,0),double r=0):c(c),r(r){}\n};\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1=c1.r,r2=c2.r,d;\n  P p1=c1.c,p2=c2.c;\n  d=abs(p1-p2);\n  if(d<EPS&&abs(r1-r2)<EPS) return res;\n  if(r1+r2<d-EPS||d+EPS<abs(r1-r2)) return res; \n  double a=(r1*r1-r2*r2+d*d)/(2*d);\n  double h=sqrt(max(r1*r1-a*a,0.0));\n  P tmp1=p1+a/d*(p2-p1);\n  P tmp2=h/d*(p2-p1);\n  if(abs(tmp2)<EPS)res.push_back(tmp1);\n  else{\n    res.push_back(P(real(tmp1)-imag(tmp2),imag(tmp1)+real(tmp2)));\n    res.push_back(P(real(tmp1)+imag(tmp2),imag(tmp1)-real(tmp2)));\n  }\n  return res;\n}\n\ndouble getdistancepp(P a,P b){\n  return sqrt((a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag()));\n}\n\nint main(){\n  int n,ans=0;\n  double a,b;\n  P p[N];\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>a>>b;\n      p[i]=P(a,b);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tCircle c1,c2;\n\tc1.c=p[i];\n\tc2.c=p[j];\n\tc1.r=c2.r=1;\n\tvector<P> r=getIntersectCC(c1,c2);\n\tif(!r.size())continue;\n\tfor(int k=0;k<r.size();k++){\n\t  int cnt=0;\n\t  for(int l=0;l<n;l++)\n\t    if(getdistancepp(r[k],p[l])<=1+EPS)cnt++;\t    \n\t  ans=max(ans,cnt);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define mp            make_pair\n#define pb            push_back\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nconst int    INF = 1000000000;\nconst ll     MOD = 1000000007LL;\nconst double EPS = 1E-12;\n\nstruct Point : public complex<double>\n{\npublic:\n  Point() { this->real(0);  this->imag(0); }\n  Point(const double& x, const double& y) { this->real(x);  this->imag(y); }\n  Point(const complex<double>& w)  { this->real(w.real());  this->imag(w.imag()); }\n  inline double dot(Point p){ return (conj(*this) * p).real(); }  // 内積\n  inline double det(Point p){ return (conj(*this) * p).imag(); }  // 外積\n};\n\nnamespace std\n{\n  inline bool operator < (const Point& a, const Point& b)\n  {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ntypedef vector<Point> Polygon;\ninline Point currPoint(vector<Point> P, int i){ return P[i]; }\ninline Point nextPoint(vector<Point> P, int i){ return P[(i+1)%P.size()]; }\ninline Point diffPoint(vector<Point> P, int i){ return nextPoint(P, i) - currPoint(P, i); }\n\n\nstruct Circle : Point\n{\nprivate:\n  Point p;\n  double r;\n\npublic:\n  Circle(Point& p, double r) : p(p), r(r) {}\n  Circle(double x, double y, double r) : p(Point(x, y)), r(r) {}\n  inline Point center(){ return this->p; }\n  inline double radius(){ return this->r; }\n};\n\nvector<Point> intersectionCC(Circle A, Circle B)\n{\n  vector<Point> ret;\n  Point p = B.center() + A.center();\n  Point d = B.center() - A.center();\n  double m = (B.radius() + A.radius()) / abs(B.center() - A.center());\n  double n = (B.radius() - A.radius()) / abs(B.center() - A.center());\n\n  double s = m * n;\n  double t = sqrt((m * m - 1.0) * (1.0 - n * n));\n\n  ret.pb((p + Point(s, -t) * d) / 2.0);\n  ret.pb((p + Point(s,  t) * d) / 2.0);\n\n  return ret;\n}\n\n\ntemplate<typename T> T add(T x, T y){ if(abs(x+y) < EPS*(abs(x)+abs(y))) return 0; return x + y; }\ntemplate<typename T> inline bool semieq(T x, T y){ return abs(x - y) < EPS; }\ntemplate<typename T> inline bool semige(T x, T y){ return y - x < -EPS; }\ntemplate<typename T> inline bool semile(T x, T y){ return x - y < -EPS; }\n\nconst double r = 1.0;\nconst int MAX_N = 300;\nint N;\ndouble x, y;\n\nint main()\n{\n  while(~scanf(\"%d\", &N) && N){\n    vector<Point> p;\n    int res = 0;\n    rep(i, N){\n      scanf(\"%lf %lf\", &x, &y);\n      p.pb(Point(x, y));\n   }\n\n    rep(i, N) rep(j, i) if(!semige(abs(p[i] - p[j]), 2.0)) {\n      vector<Point> pnt = intersectionCC(Circle(p[i], r), Circle(p[j], r));\n      vrep(v, pnt){\n        int cnt = 0;\n        vrep(w, p) if(!semige(abs(*w - *v), 1.0)) cnt += 1;\n        //        cerr << cnt << endl;\n        maxup(res, cnt);\n      }\n    }\n    printf(\"%d\\n\", res);\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(int i=(a),i##_cond=(b);i<i##_cond;++i)\ntemplate<class T>bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\n\nconst double EPS = 1e-8;\nusing P =  complex<double>;\nnamespace std {\n  bool isnan(const P&p){\n    return isnan(p.real()) or isnan(p.imag());\n  }\n}\nstruct C {\n  P p; double r;\n  C(const P &p_, double r_) : p(p_), r(r_) { }\n};\n\n// 交わらない場合はnanを返す\npair<P, P> crosspointCC(const C& c1, const C& c2){\n  double d = abs(c1.p - c2.p);\n  double rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n  double rs = sqrt(c1.r*c1.r - rc*rc);\n  P diff = (c2.p - c1.p) / d;\n  return make_pair(c1.p + diff * P(rc, rs), c1.p + diff * P(rc, -rs));\n}\n\nsigned main(){\n  int n;\n  while(cin >> n, n){\n    vector<P> ps(n);\n    rep(i,n){\n      double x, y; cin >> x >> y;\n      ps[i].real(x);\n      ps[i].imag(y);\n    }\n    vector<P> can;\n    rep(i,n) FOR(j,i+1,n){\n      C c1(ps[i],1), c2(ps[j],1);\n      auto tmp = crosspointCC(c1, c2);\n      if(not isnan(tmp.first))\n\tcan.push_back(tmp.first);\n      if((not isnan(tmp.second)) and abs(tmp.first - tmp.second) > EPS)\n\tcan.push_back(tmp.second);\n    }\n\n    int ans = 1;\n    rep(i,can.size()){\n      int tmp = 0;\n      rep(j,n)\n\tif(abs(can[i] - ps[j]) - EPS < 1) tmp++;\n      chmax(ans, tmp);\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ndouble x[300], y[300];\nint n;\n\nint count(double x0, double y0, int p, int q){\n\tint ret = 2;\n\tREP(i,n){\n\t\tif(i==p||i==q)continue;\n\t\tdouble dx = x0-x[i];\n\t\tdouble dy = y0-y[i];\n\t\tif(pow(dx, 2.0)+pow(dy, 2.0)<1.0)ret++;\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(1){\n\t\tint ret = 1;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tREP(i,n)scanf(\"%f %f\", &x[i],&y[i]);\n\t\tREP(i,n){\n\t\t\tFOR(j, i+1,n){\n\t\t\t\tdouble dx = x[j]-x[i];\n\t\t\t\tdouble dy = y[j]-y[i];\n\t\t\t\tdouble d = sqrt(pow(dx, 2.0)+pow(dy, 2.0));\n\t\t\t\tif(d < 1.0){\n\t\t\t\t\tdouble mx = (x[j]+x[i])*0.5;\n\t\t\t\t\tdouble my = (y[j]+y[i])*0.5;\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble x = mx-dy/d*sqrt(1-d*d/4.0);\n\t\t\t\t\t\tdouble y = my+dx/d*sqrt(1-d*d/4.0);\n\t\t\t\t\t\tret = max(ret, count(x, y, i, j));\n\t\t\t\t\t}\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble x = mx+dy/d*sqrt(1-d*d/4.0);\n\t\t\t\t\t\tdouble y = my-dx/d*sqrt(1-d*d/4.0);\n\t\t\t\t\t\tret = max(ret, count(x, y, i, j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 301\nusing namespace std;\ntypedef complex <double> P;\nconst double EPS = 1e-8;\nP p[N];\nint n;\n\nint cnt(P c){\n  int res=0;\n  for(int i=0;i<n;i++)\n    if(1-abs(c-p[i])>-EPS) res++;\n  return res;\n}\n\nP get_C(P a,P b){\n  double x=abs(b-a);\n  if(x>2) return a;\n  P c=P(x/2,sqrt(1-x*x/4))*(b-a)/abs(b-a)+a;\n\n  return c;  \n}\n\n\nint main(){\n  while(1){\n  cin>>n;\n  if(!n)break;\n  double a,b;\n  for(int i=0;i<n;i++)cin>>a>>b,p[i]=P(a,b);\n  \n  int ans=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      P c=get_C(p[i],p[j]);\n      ans=max(ans,cnt(c));\n    }\n  cout <<ans<<endl;  \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define EPS (1e-4)\ntypedef complex<double> P;\n\nint main() {\n  int n;\n  while (cin >> n, n) {\n    vector<P> a(n);\n    for (auto &e : a) {\n      double x, y;\n      cin >> x >> y;\n      e.real(x);\n      e.imag(y);\n    }\n    int m = 0;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if (abs(a[j] - a[i]) < 2.0 + EPS) {\n          P u = (a[j] - a[i]) / 2.0;\n          P v = P(-u.imag(), u.real()) / abs(u) * sqrt(1.0 - pow(abs(u), 2));\n          vector<P> o = {a[i] + u + v, a[i] + u - v};\n          for (auto e : o) {\n            int t = 2;\n            for (int k = 0; k < n; k++) {\n              if (k != i && k != j) {\n                t += abs(a[k] - e) < 1.0 + EPS;\n              }\n            }\n            m = max(m, t);\n          }\n        }\n      }\n    }\n    cout << m << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-8;\nusing P = complex<double>;\nint n;\nP p[300];\n\nint main(){\n  while (cin >> n, n){\n    for (int i = 0; i < n; i++){\n      double x, y;\n      cin >> x >> y;\n      p[i] = P(x, y);\n    }\n    vector<P> ps;\n    for (int i = 0; i < n; i++){\n      for (int j = 0; j < i; j++){\n        if (abs(p[i] - p[j]) >= 2.0) continue;\n        P v = p[j] - p[i];\n        P u = v * P(0.0, 1.0);\n        u *= sqrt(1.0 - abs(v) / 2.0) / abs(u);\n        ps.push_back(p[i] + v / 2.0 + u);\n        ps.push_back(p[i] + v / 2.0 - u);\n      }\n    }\n    int res = 1;\n    for (P c : ps){\n      int s = 0;\n      for (int i = 0; i < n; i++){\n        s += abs(c - p[i]) <= 1.0 + EPS;\n      }\n      res = max(res, s);\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\n\nclass P\n{\npublic:\n\tdouble x,y;\n\tP(double x=0.0,double y=0.0):x(x),y(y){}\n\tP operator+(const P p)const{return P(x+p.x,y+p.y);}\n\tP operator-(const P p)const{return P(x-p.x,y-p.y);}\n};\n\ndouble dis(P p1,P p2)\n{\n\treturn hypot(p1.x-p2.x,p1.y-p2.y);\n}\n\nP getc(P p1,P p2)\n{\n\tdouble theta=acos(dis(p1,p2)/2.0);\n\tdouble alpha=atan2(p2.y-p1.y,p2.x-p1.x);\n\treturn P(p1.x+cos(alpha-theta),p1.y+sin(alpha-theta));\n}\n\nbool in(P c,P p)\n{\n\treturn dis(c,p)<1.0+1e-9;\n}\n\nint main()\n{\n\tint n;\n\twhile(cin>>n,n)\n\t{\n\t\tP p[300];\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>p[i].x>>p[i].y;\n\t\t}\n\t\tif(n==1)\n\t\t{\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint m=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=i+1;j<n;j++)\n\t\t\t{\n\t\t\t\tP a=p[i],b=p[j];\n\t\t\t\tP c=getc(a,b);\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t{\n\t\t\t\t\tif(in(c,p[k]))cnt++;\n\t\t\t\t}\n\t\t\t\tm>cnt?:m=cnt;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tP a=p[i];\n\t\t\tint cnt=0;\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(in(a,p[j]))cnt++;\n\t\t\t}\n\t\t\tm>cnt?:m=cnt;\n\t\t}\n\t\tcout<<m<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\n\nconst long double EPS = 10e-6;\n\nclass Point{\n    public: \n    long double x,y;\n    \n    Point(long double x = 0.0, long double y = 0.0): x(x), y(y) {}\n    \n    Point operator + (Point p) {\n        return Point(x+p.x, y+p.y);\n    }\n    Point operator - (Point p) {\n        return Point(x-p.x, y-p.y);\n    }\n    Point operator * (long double a) {\n        return Point(x*a, y*a);\n    }\n    Point operator / (long double a) {\n        return Point(x/a, y/a);\n    }\n    bool operator < (const Point &p) const {\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n    bool operator == (const Point &p) const {\n        return fabsl(x - p.x) < EPS && fabsl(y - p.y) < EPS;\n    }\n    \n    long double abs() {\n        return sqrt(norm());\n    }\n    \n    long double norm() {\n        return x*x + y*y;\n    }\n    \n    long double dot(Point p) {\n        return x*p.x + y*p.y;\n    }\n    \n    long double cross(Point p) {\n        return x*p.y - y*p.x;\n    }\n};\n\nclass Segment{\n    public: \n    Point p,q;\n    long double grad;\n    \n    Segment(Point p, Point q): p(p), q(q) {\n        this->grad = (q.y-p.y)/(q.x-p.x);\n    }\n    \n};\n\nclass Circle{\n    public:\n    Point c;\n    long double r;\n    \n    Circle(Point c = Point(), long double r = 0.0): c(c), r(r) {}\n};\n\nPoint calc_center(Point p, Point mid, Point midv){\n    midv = midv / midv.abs() * sqrt((1.0 - mid.norm()));\n    return p+mid+midv;\n}\n\nint count(vector<Point> points, Point center){\n    int tmp = 0;\n    for(Point p: points){\n        if((p-center).norm() <= 1.0 + EPS) tmp++;\n    }\n    return tmp;\n}\n\nint main() {\n    int n;\n    while(scanf(\"%d\", &n) && n){\n        vector<Point> points(n);\n        rep(n) scanf(\"%Lf %Lf\", &points[i].x, &points[i].y);\n\n        int ans = 1;\n        rep(n){\n            repp(j, n){\n                if(j == i) continue;\n                Point mid = (points[j] - points[i]) * 0.5;\n                Point center = calc_center(points[i], mid, Point(mid.y, -mid.x));\n                ans = max(count(points, center), ans);\n\n                center = calc_center(points[i], mid, Point(-mid.y, mid.x));\n                ans = max(count(points, center), ans);\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <utility>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nbool eqv(double a, double b) {\n    return abs(a-b) < 1e-5;\n}\n\npair<double,double> key_point(double y, const Point &p) {\n    double len = sqrt(1.0 - pow(y-p.imag(), 2));\n    return make_pair(p.real()+len, p.real()-len);\n}\n\nbool inCircle(const Point &p, const Point &center, double radius) {\n    double dist2 = norm(p-center);\n    double rad2 = radius*radius;\n    return dist2 < radius*radius || eqv(dist2, rad2);\n}\n\nint check(const Point &center, const vector<Point> &points) {\n    const int N = points.size();\n    int cnt = 0;\n    for(int i = 0; i < N; ++i) {\n        if(inCircle(points[i], center, 1)) ++cnt;\n    }\n    return cnt;\n}\n\nint test(int a, int b, const vector<Point> &points) {\n    const Point v(points[a]-points[b]);\n    const double hlen = abs(v)/2;\n\n    if(hlen*hlen >= 1) return 0;\n    const double plen = sqrt(1 - hlen*hlen);\n    Point perp = v*Point(0, 1);\n    perp /= abs(perp);\n    const Point mid = points[b] + v/2.0;\n    return max(check(mid + perp*plen, points), check(mid - perp*plen, points));\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        vector<Point> points(N);\n        for(int i = 0; i < N; ++i) {\n            cin >> points[i].real() >> points[i].imag();\n        }\n        int ans = 0;\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < i; ++j) {\n                ans = max(ans, test(i, j, points));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n\n#define rep2(i, b, n) for(int i=b; i < n; ++i)\n#define rep(i, n) rep2(i, 0, n)\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<double, double> pdd;\n\ndouble distance_sq( pdd a, pdd b )\n{\n\tdouble cx = a.X - b.X;\n\tdouble cy = a.Y - b.Y;\n\treturn ((cx*cx) + (cy*cy));\n}\n\ndouble norm( pdd &v )\n{\n\tdouble len = sqrt((v.X*v.X) + (v.Y*v.Y));\n\tv.X /= len;\n\tv.Y /= len;\n\treturn len;\n}\n\nvoid rotate( pdd &p )\n{\n\tswap(p.X, p.Y);\n\tp.Y = -p.Y;\n}\n\nint main( void )\n{\n\tint n;\n\tpdd p[300];\n\twhile(cin >> n, n)\n\t{\n\t\trep(i, n) cin >> p[i].X >> p[i].Y;\n\t\tint Max = 0;\n\t\trep(i, n) {\n\t\t\trep2(j, i+1, n) {\n\t\t\t\tif(distance_sq(p[i], p[j]) < 4.0) {\n\t\t\t\t\tpdd v = make_pair(p[i].X-p[j].X, p[i].Y-p[j].Y);\n\t\t\t\t\tpdd c = make_pair(v.X / 2.0000, v.Y / 2.0000);\n\t\t\t\t\tpdd m = c;\n\t\t\t\t\tdouble len_c = norm(c);\n\t\t\t\t\tdouble sin_x = sqrt(1.0000 - (len_c*len_c));\n\t\t\t\t\trotate(c);\n\t\t\t\t\tc.X *= sin_x; c.Y *= sin_x;\n\t\t\t\t\t//p[j].X += m.X; p[j].Y += m.Y;\n\t\t\t\t\tpdd p3 = make_pair(p[j].X+m.X+c.X, p[j].Y+m.Y+c.Y);\n\t\t\t\t\tpdd p4 = make_pair(p[j].X+m.X-c.X, p[j].Y+m.Y-c.Y);\n\t\t\t\t\tint count_p3, count_p4;\n\t\t\t\t\tcount_p3 = count_p4 = 0;\n\t\t\t\t\trep(k, n) {\n\t\t\t\t\t\tif(distance_sq(p3, p[k]) < 1.000001) ++count_p3;\n\t\t\t\t\t\tif(distance_sq(p4, p[k]) < 1.000001) ++count_p4;\n\t\t\t\t\t}\n\t\t\t\t\tMax = max(Max, max(count_p3, count_p4));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << Max << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<sstream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define eps 1e-10\nconst double rs =1.;\n\nint count(double x,double y,double *dx,double *dy,int n){\n  int ret =0;\n  rep(i,n){\n    if ( (x-dx[i])*(x-dx[i])+(y-dy[i])*(y-dy[i]) <=1.+eps)ret++;\n  }\n  return ret;\n}\n\n\n\nint solve(double *x,double *y,int n){\n  int cnt=1;\n  rep(i,n){\n    REP(j,i+1,n){\n      double midx=(x[i]+x[j])/2.,midy=(y[i]+y[j])/2.;\n      double tx=x[i]-midx,ty=y[i]-midy;\n      double tr=sqrt(1-tx*tx-ty*ty);\n      if (isnan(tr))continue;\n      if ( tx==0 &&ty==0)continue;\n      double rate = tr/sqrt(tx*tx+ty*ty);\n      cnt=max(cnt,max(count(-ty*rate+midx,tx*rate+midy,x,y,n),\n\t\t      count(ty*rate+midx,-tx*rate+midy,x,y,n)));\n    }\n  }\n  return cnt;\n}\n\n\n\n\n\nmain(){\n  int n;\n  while(cin>>n&&n){\n    double x[n],y[n];\n    rep(i,n)cin>>x[i]>>y[i];\n    cout << solve(x,y,n)<<endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\n#include <ctime>\n#include <numeric>\n#include <fstream>\n#include <valarray>\nusing namespace std;\nstatic const double EPS = 1e-6;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> PI;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int(a.size()))\n#define F first\n#define S second\nconst long double pi=acos(-1.0);\nint dx[]={0,1,0,-1,1,1,-1,-1,0},dy[]={1,0,-1,0,1,-1,1,-1,0};\n\nint n;\npair<double,double> in[300];\nint ans;\n\nint getpointnum(double x,double y,double r){\n  int ret=0;\n  rep(i,n){\n    double tx=in[i].F-x;\n    double ty=in[i].S-y;\n    if(r*r+EPS>=tx*tx+ty*ty)++ret;\n  }\n  return ret;\n}\n\nvoid square(double x,double y,double wh){\n  int t=getpointnum(x+wh/2,y+wh/2,wh/sqrt(2)+1);\n  if(wh<=0.0001)return;\n  if(t<=ans)return;\n  ans=max(ans,getpointnum(x+wh/2,y+wh/2,1));\n\n  square(x,y,wh/2);\n  square(x+wh/2,y,wh/2);\n  square(x,y+wh/2,wh/2);\n  square(x+wh/2,y+wh/2,wh/2);    \n}\n\nvoid solve(){\n  rep(i,n)cin>>in[i].F>>in[i].S;\n  ans=1;\n\n  square(-1,-1,11);\n  cout<<ans<<endl;\n}\n\nmain(){\n  while(cin>>n,n)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#include<algorithm>\n#include<array>\n#include<cassert>\n#include<cmath>\n#include<vector>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\ntypedef double Real;\nconst Real EPS = 1e-8;\nint sign(Real d) { return d > EPS ? 1 : d < -EPS ? -1 : 0; }\n\n//define class ...\n\nstruct Point {\n\tReal x, y;\n\texplicit Point(Real x_ = 0, Real y_ = 0):x(x_), y(y_) {}\n\tPoint operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n\tPoint operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n\tPoint operator*(Real s) const { return Point(x * s, y * s); }\n\tPoint operator/(Real s) const { return Point(x / s, y / s); }\n\tbool operator<(const Point &p) const {\n\t\treturn sign(x - p.x) == -1 || (sign(x - p.x) == 0 && sign(y - p.y) == -1);\n\t}\n\tbool operator==(const Point &p) const {\n\t\treturn sign(x - p.x) == 0 && sign(y - p.y) == 0;\n\t}\n};\n\nistream &operator>>(istream &is, Point &p) {\n\treturn is >> p.x >> p.y;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n\treturn os << '(' << p.x << \", \" << p.y << ')';\n}\n\nstruct Line : public array<Point, 2> { //??????\n\tLine(const Point &a, const Point &b) { at(0) = a; at(1) = b; }\n};\n\nstruct Segment : public array<Point, 2> { //??´???\n\tSegment(const Point &a, const Point &b) { at(0) = a; at(1) = b; }\n};\n\nstruct Circle {\n\tPoint c;\n\tReal r;\n\tCircle(const Point &c_, Real r_): c(c_), r(r_) {}\n};\n\ntypedef vector<Point> Polygon;\n\n// define function\nPoint rotate90(const Point &p) { // ???????¨???¨???\n\treturn Point(-p.y, p.x);\n}\n\nPoint rotate(const Point &p, Real theta) {\n\tconst Real s = sin(theta), c = cos(theta);\n\treturn Point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\nReal angle(const Point &p) {\n\treturn atan2(p.y, p.x);\n}\n\nReal norm(const Point &p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\nReal abs(const Point &p) {\n\treturn sqrt(norm(p));\n}\n\nReal dot(const Point &a, const Point &b) { // ??????\n\treturn a.x * b.x + a.y * b.y;\n}\n\nReal cross(const Point &a, const Point &b) { // ??????\n\treturn a.x * b.y - a.y * b.x;\n}\n\nbool is_parallel(const Line &a, const Line &b) {\n\treturn sign( cross(a[1] - a[0], b[1] - b[0]) ) == 0;\n} \n\n// define app function\nenum { CCW = 1, CW = -1, BACK = 2, FRONT = -2, ON = 0};\n\nint ccw(const Point &a, const Point &b, const Point &c) {\n\tconst Point p = b - a;\n\tconst Point q = c - a;\n\tconst Real crs = cross(p, q); \n\t\n\tif(sign(crs) == 1) return CCW;\n\tif(sign(crs) == -1) return CW;\n\tif(sign(dot(p, q)) == -1) return BACK;\n\tif(sign(norm(p) - norm(q)) == -1) return FRONT;\n\treturn ON;\n}\n\nPoint project(const Line &l, const Point &p) {\n\tconst Point a = p - l[0];\n\tconst Point b = l[1] - l[0];\n\treturn l[0] + b * (dot(a, b) / norm(b));\n}\n\nPoint reflect(const Line &l, const Point &p) {\n\tconst Point t = project(l, p);\n\treturn t + (t - p);\n}\n\nbool intersect(const Segment &s, const Point &p) {\n\treturn ccw(s[0], s[1], p) == ON;\n}\n\nbool intersect(const Segment &a, const Segment &b) {\n\treturn ccw(a[0], a[1], b[0]) * ccw(a[0], a[1], b[1]) <= 0\n\t\t\t&& ccw(b[0], b[1], a[0]) * ccw(b[0], b[1], a[1]) <= 0;\n}\n\nbool intersect(const Line &l, const Point &p) {\n\treturn abs(ccw(l[0], l[1], p)) != 1;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n\treturn sign(cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0])) <= 0; \n}\n\nbool intersect(const Line &a, const Line &b) {\n\treturn sign(cross(a[1] - a[0], b[1] - b[0])) != 0\n\t\t\t|| sign(cross(a[1] - a[0], b[1] - a[0])) == 0;\n}\n\nReal dist(const Point &a, const Point &b) {\n\treturn abs(a - b);\n}\n\nReal dist(const Line &l, const Point &p) {\n\tconst Point a = l[1] - l[0];\n\tconst Point b = p - l[0];\t\n\treturn abs(cross(a, b)) / abs(a);\n}\n\nReal dist(const Line &l, const Segment &s) {\n\tif(intersect(l, s)) return 0;\n\treturn min(dist(l, s[0]), dist(l, s[1]));\n}\n\nReal dist(const Line &a, const Line & b) {\n\tif(intersect(a, b)) return 0;\n\treturn dist(a, b[0]);\n}\n\nReal dist(const Segment &s, const Point &p) {\n\tif(sign(dot(s[1] - s[0], p - s[0])) == -1) return dist(s[0], p);\n\tif(sign(dot(s[0] - s[1], p - s[1])) == -1) return dist(s[1], p);\n\treturn dist(Line(s[0], s[1]), p);\n}\n\nReal dist(const Segment &a, const Segment &b) {\n\tif(intersect(a, b)) return 0;\n\treturn min({dist(a, b[0]), dist(a, b[1]), dist(b, a[0]), dist(b, a[1])});\t\n}\n\nbool intersect(const Circle &a, const Circle &b) {\n\treturn sign(dist(a.c, b.c) - (a.r + b.r)) <= 0\n\t\t&& sign(dist(a.c, b.c) - abs(a.r - b.r)) >= 0;\n}\n\nbool intersect(const Circle &c, const Segment &s) {\n\treturn sign(dist(s, c.c) - c.r) <= 0;\n}\n\nbool intersect(const Circle &c, const Line &l) {\n\treturn sign(dist(l, c.c) - c.r) <= 0;\n}\n\nbool contain(const Circle &c, const Point &p) {\n\treturn sign(dist(c.c, p) - c.r) <= 0;\n}\n\nint contain(const Polygon &P, const Point &p) {\n\tbool res = 0;\n\tfor(int i = 0; i < P.size(); ++i) {\n\t\tPoint v1 = P[i] - p;\n\t\tPoint v2 = P[(i + 1) % P.size()] - p;\n\t\tif(v1.y > v2.y) swap(v1, v2);\n\n\t\tif(sign(cross(v1, v2)) == 0 && sign(dot(v1, v2)) <= 0) {\n\t\t\treturn 1; //on edge\n\t\t}\n\t\tif(sign(v1.y) <= 0 && sign(v2.y) == 1 && sign(cross(v1, v2)) == 1) {\n\t\t\tres = !res;\n\t\t}\n\t}\n\treturn (res ? 2 : 0);\n}\n\nPoint crosspoint(const Line &a, const Line &b) {\n\tassert(intersect(a, b));\n\tconst Real crs = cross(a[1] - a[0], b[1] - b[0]);\t\n\tif(sign(crs) == 0) return a[0];\t// same line\n\treturn b[0] + (b[1] - b[0]) * (cross(a[1] - a[0], a[1] - b[0]) / crs);\n}\n\n// ???????????????????????¨?????°????????§???????????????intersect????????????\nPoint crosspoint(const Segment &a, const Segment &b) {\n\tassert(intersect(a, b));\n\tconst Real crs = cross(a[1] - a[0], b[1] - b[0]);\t\n\tif(sign(crs) == 0) { //on same line\n\t\tif(intersect(a, b[0])) return b[0];\n\t\tif(intersect(a, b[1])) return b[1];\n\t\tif(intersect(b, a[0])) return a[0];\n\t\treturn a[1];\n\t}\n\treturn b[0] + (b[1] - b[0]) * (cross(a[1] - a[0], a[1] - b[0]) / crs);\n}\n\nvector<Point> crosspoint(const Circle &c, const Line &l) {\n\tconst Point p = project(l, c.c);\n\tconst Real h = dist(p, c.c);\n\n\tvector<Point> res;\n\tif(sign(h - c.r) == 1) {\n\t\t// nothing\n\t}\n\telse if(sign(h - c.r) == 0) {\n\t\tres.emplace_back(p);\n\t}\n\telse {\n\t\tconst Real b = sqrt(c.r * c.r - h * h);\n\t\tconst Point e = (l[1] - l[0]) / abs(l[1] - l[0]);\n\t\tres.emplace_back(p + e * b);\n\t\tres.emplace_back(p - e * b);\n\t}\n\treturn res;\n}\n\nvector<Point> crosspoint(const Circle &c, const Segment &s) {\n\tvector<Point> res;\n\tfor(const Point &p : crosspoint(c, Line(s[0], s[1]))) {\n\t\tif(intersect(s, p)) res.emplace_back(p);\n\t}\n\treturn res;\n}\n\nvector<Point> crosspoint(const Circle &a, const Circle &b) {\n\tif(!intersect(a, b)) return vector<Point>();\n\tvector<Point> res;\n\tconst Real d = dist(a.c, b.c);\n\n\tif(sign(d - (a.r - b.r)) == 0) {\n\t\tconst Point v = b.c - a.c;\n\t\tres.emplace_back(a.c + (v * (a.r / abs(v))));\n\t}\n\telse {\n\t\tconst Real theta = acos((a.r * a.r + d * d - b.r * b.r) / (2 * a.r * d));\n\t\tconst Real phi = angle(b.c - a.c);\n\t\tres.emplace_back(a.c + rotate(Point(a.r, 0), phi + theta));\n\t\tres.emplace_back(a.c + rotate(Point(a.r, 0), phi - theta));\n\t}\n\treturn res;\n}\n\nint main() {\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\tint n;\t\n\twhile(cin >> n && n) {\n\t\tvector<Circle> circles;\t\n\t\tPoint p; \n\t\tReal r = 1.0;\n\t\trep(i, n) {\n\t\t\tcin >> p;\n\t\t\tcircles.push_back(Circle(p, r));\n\t\t}\t\n\n\t\tvector<Circle> ccircles;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\t\tvector<Point> cp = crosspoint(circles[i], circles[j]); \t\n\t\t\t\tif(cp.size() == 0) continue;\n\t\t\t\tccircles.push_back(Circle(cp[0], r));\n\t\t\t\tif(cp.size() == 1) continue;\n\t\t\t\tccircles.push_back(Circle(cp[1], r));\n\t\t\t}\n\t\t}\n\t\n\t\tint ans = 1;\n\t\tint m = ccircles.size();\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint tmp = 0;\n\t\t\tfor(int j = 0; j < n; ++j) {\n\t\t\t\tif(contain(ccircles[i], circles[j].c)) ++tmp;\n\t\t\t}\n\t\t\tans = max(ans, tmp);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble Dis(double x1, double y1, double x2, double y2);\nint main(void){\n\twhile(1){\n\t\tint n;\n\t\tint ans = 1;\n\t\tvector< pair<double, double> > p;\n\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tpair<double, double> t;\n\t\t\tcin >> t.first >> t.second;\n\t\t\tp.push_back(t);\n\t\t}\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=i+1; j<n; j++){\n\t\t\t\t//中点\n\t\t\t\tdouble mpx = (p[i].first + p[j].first) / 2.0;\n\t\t\t\tdouble mpy = (p[i].second + p[j].second) / 2.0;\n\t\t\t\t//2点間の距離\n\t\t\t\tdouble d1 = Dis(p[i].first, p[i].second, p[j].first, p[j].second);\n\t\t\t\t//p[i]からp[j]へ向かうベクトル\n\t\t\t\tdouble v1x = (p[i].first - p[j].first) / d1;\n\t\t\t\tdouble v1y = (p[i].second - p[j].second) / d1;\n\t\t\t\t//中点から円の中心へ向かう単位ベクトル\n\t\t\t\tdouble v2x = -v1y;\n\t\t\t\tdouble v2y = v1x;\n\t\t\t\t//中心から円の中心へ向かうベクトルの長さ\n\t\t\t\tdouble d2 = sqrt(1.0 - (d1*d1/4.0));\n\n\t\t\t\t//円の中心の座標\n\t\t\t\tdouble cx = mpx + v2x * d2;\n\t\t\t\tdouble cy = mpy + v2y * d2;\n\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(k == i || k == j || (cx-p[k].first)*(cx-p[k].first) + (cy-p[k].second)*(cy-p[k].second) <= 1.0)\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt > ans){\n\t\t\t\t\tans = cnt;\n\t\t\t\t}\n\n\t\t\t\tcx = mpx - v2x * d2;\n\t\t\t\tcy = mpy - v2y * d2;\n\n\t\t\t\tcnt = 0;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(Dis(cx, cy, p[k].first, p[k].second) <= 1.0)\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt > ans){\n\t\t\t\t\tans = cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\n\t}\n\t\n\treturn 0;\n}\n\ndouble Dis(double x1, double y1, double x2, double y2){\n\treturn sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble distance(pair<double,double> p1,pair<double,double> p2){\n\treturn sqrt((p1.first-p2.first)*(p1.first-p2.first)+(p1.second-p2.second)*(p1.second-p2.second));\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<double> x(n);\n\t\tvector<double> y(n);\n\t\tint res=1;\n\t\tfor(int i=0;i<n;i++) cin>>x[i]>>y[i];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tpair<double,double> midp=make_pair((x[i]+x[j])/2,(y[i]+y[j])/2);\n\t\t\t\tdouble a=-(x[i]-x[j]),b=(y[i]-y[j]);\n\t\t\t\t//a(x-mid[i].first)+b(y-mid.second)=0\n\t\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\t\tpair<double,double> lef=midp;\n\t\t\t\t\t\tpair<double,double> rig;\n\t\t\t\t\t\tif(k==0) rig=make_pair(-b*1e5+midp.first,a*1e5+midp.second);\n\t\t\t\t\t\tif(k==1) rig=make_pair(b*1e5+midp.first,-a*1e5+midp.second);\n\t\t\t\t\t\twhile(distance(lef,rig)>=0.00001){\n\t\t\t\t\t\t\t\tpair<double,double> mid=make_pair((lef.first+rig.first)/2,(lef.second+rig.second)/2);\n\t\t\t\t\t\t\t\tif(distance(mid,make_pair(x[i],y[i]))>1){\n\t\t\t\t\t\t\t\t\trig=mid;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tlef=mid;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint count=0;\n\t\t\t\t\t\tfor(int r=0;r<n;r++){\n\t\t\t\t\t\t\tif(distance(make_pair(x[r],y[r]),lef)<1+0.00001){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres=max(res,count);\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout<<res<<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\nstruct Vector2{\n\tdouble x, y;\n\tVector2(){};\n\tVector2(double x, double y) : x(x), y(y){};\n\n\tdouble cross(const Vector2& p){\n\t\treturn x*p.y - y*p.x;\n\t}\n\n\tdouble dot(const Vector2& p) const{\n\t\treturn x*p.x + y*p.y;\n\t}\n\n\tconst Vector2 medPoint(const Vector2& v){\n\t\treturn {(x + v.x) / 2.0, (y + v.y) / 2.0};\n\t}\n\n\tconst bool operator == (const Vector2& v) const{\n\t\treturn abs(x - v.x) < EPS && abs(y - v.y) < EPS;\n\t}\n\tconst bool operator != (const Vector2& v) const{\n\t\treturn !(*this==(v));\n\t}\n\n\tconst Vector2 operator - (const Vector2& p) const{\n\t\treturn {x-p.x, y-p.y};\n\t}\n\n\tconst Vector2& operator += (const Vector2& p) {\n\t\tx += p.x;\n\t\ty += p.y;\n\t\treturn *this;\n\t}\n\n\tdouble dist2(const Vector2& p) const{\n\t\treturn ((*this) - p).dot((*this) - p);\n\t\t//return (x-p.x)*(x-p.x) + (y-p.y)*(y-p.y);\n\t}\n\n\tVector2 spin(double arg){\n\t\tdouble si = sin(arg);\n\t\tdouble co = cos(arg);\n\t\treturn {x*co - y*si, x*si + y*co};\n\t}\n};\n\nstruct Circle{\n\tVector2 p;\n\tdouble r;\n\tCircle(){};\n\tCircle(const Vector2 &p, double r) : p(p), r(r){};\n\tCircle(double x, double y, double r) : p({x, y}), r(r){};\n\n\tbool isPointIn(const Vector2& v) const{\n\t\treturn p.dist2(v) < r * r + EPS;\n\t}\n};\n\nvector<Circle> getCircles(const Vector2 &p1, const Vector2 &p2){\n\tif(p1.dist2(p2) > 4.0 + EPS) return {};\n\tvector<Circle> ret;\n\tVector2 p = p1 - p2;\n\t// double arg = atan2(p.y, p.x);\n\t// p = p.spin(-arg);\n\n\t// ret.pb({1.0, p.y/2.0, 1.0});\n\t// ret.pb({-1.0, p.y/2.0, 1.0});\n\n\tdouble arg = atan2(p.y, p.x);\n\tp = p.spin(-arg);\n\n\tdouble x = p.x/2.0, y = sqrt(1.0-x * x);\n\tret.pb({{x, y}, 1.0});\n\tret.pb({{x, -y}, 1.0});\n\n\trep(i, 2){\n\t\tret[i].p = ret[i].p.spin(arg);\n\t\tret[i].p += p2;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n && n){\n\t\tvector<Vector2> v;\n\t\trep(i, n){\n\t\t\tdouble x, y;\n\t\t\tcin>>x>>y;\n\t\t\tv.pb({x, y});\n\t\t}\n\t\tint ans = 1;\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tfor(int j = 0; j < i; j++){\n\t\t\t\tvector<Circle> c = getCircles(v[j], v[i]);\n\t\t\t\tfor(int k = 0; k < c.size(); k++){\n\t\t\t\t\tint tmp = 0;\n\t\t\t\t\tfor(int l = 0; l < n; l++){\n\t\t\t\t\t\tif(c[k].isPointIn(v[l])) tmp++;\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans, tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n#define rep(i,n) for (ll i=0;i<n;++i)\n#define rep2(i,a,b) for (ll i=a;i<b;++i)\nconst ll MOD=1000000007;\n\ntemplate<class T> inline bool chmin(T &a,T b){\n    if (a>b){\n        a=b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T &a,T b){\n    if (a<b){\n        a=b;\n        return true;\n    }\n    return false;\n}\n\ntypedef pair<double,double> Pdd;\n\nint main(){\n    int N;\n    while(cin >> N,N>0){\n        vector<Pdd> pos(N);\n        rep(i,N){\n            double x,y;\n            cin >> x >> y;\n            pos[i]=Pdd(x,y);\n        }\n        int ans=1;\n        rep(i,N){\n            rep2(j,i+1,N){\n                double x1=pos[i].first,y1=pos[i].second;\n                double x2=pos[j].first,y2=pos[j].second;\n                double dist=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n                if (dist>2.0){\n                    continue;\n                }\n                else {\n                    int count=2;\n                    double halfd=dist/2.0;\n                    double len=sqrt(1.0-halfd*halfd);\n                    double cx=(x1+x2)/2.0,cy=(y1+y2)/2.0;\n                    double dx=cx+(y2-y1)*len/dist;\n                    double dy=cy-(x2-x1)*len/dist;\n                    rep(k,N){\n                        if (k==i||k==j){\n                            continue;\n                        }\n                        double x=pos[k].first;\n                        double y=pos[k].second;\n                        if ((x-dx)*(x-dx)+(y-dy)*(y-dy)<=1.0){\n                            count++;\n                        }\n                    }\n                    chmax(ans,count);\n                    count=2;\n                    dx=cx-(y2-y1)*len/dist,dy=cy+(x2-x1)*len/dist;\n                    rep(k,N){\n                        if (k==i||k==j){\n                            continue;\n                        }\n                        double x=pos[k].first;\n                        double y=pos[k].second;\n                        if ((x-dx)*(x-dx)+(y-dy)*(y-dy)<=1.0){\n                            count++;\n                        }\n                    }\n                    chmax(ans,count);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define REPP(i,j,n) for(int i=(j);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-5, pi = acos(-1.0);\nld dot(Point a, Point b){return real(conj(a)*b);}\nld cross(Point a, Point b){ return imag(conj(a)*b);}\n\nPoint p[310];\nint n;\n\nvoid solve(){\n  int result=1;\n  REP(i,n){\n    REPP(j,i+1,n){\n      Point ab=p[j]-p[i];\n      if(norm(ab)>4)continue;\n      Point c=(p[i]+p[j])/2.L+Point{imag(ab),-real(ab)}*sqrt(1-norm(ab)/4.L)/abs(ab)/2.L;\n      Point d=(p[i]+p[j])/2.L+Point{-imag(ab),real(ab)}*sqrt(1-norm(ab)/4.L)/abs(ab)/2.L;\n      int cntc=0,cntd=0;\n      REP(k,n){\n\tif(abs(p[k]-c)<=1.0001L)cntc++;\n\tif(abs(p[k]-d)<=1.0001L)cntd++;\n      }\n      result=max({result,2,cntc,cntd});\n    }\n  }\n  cout<<result<<endl;\n}\n\nint main(){ _;\n  ld r,i;\n  while(cin>>n,n!=0){\n    REP(j,n){\n      cin>>r>>i;\n      p[j]=Point{r,i};\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-4;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        vector<long double> xs(n),ys(n);\n        rep(i,0,n) cin >> xs[i] >> ys[i];\n\n        auto count=[&](const long double x,const long double y){\n            int res=0;\n            rep(i,0,n) if((xs[i]-x)*(xs[i]-x)+(ys[i]-y)*(ys[i]-y)<=1+eps) ++res;\n            return res;\n        };\n\n        int ans=0;\n        rep(i,0,2001){\n            const long double y=10.*i/2000;\n            rep(j,0,n){\n                const long double tmp=1-(ys[j]-y)*(ys[j]-y);\n                if(tmp<0) continue;\n                const long double x1=xs[j]-sqrtl(tmp),x2=xs[j]+sqrt(tmp);\n                ans=max({ans,count(x1,y),count(x2,y)});\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#define EPS 0.0001\nusing namespace std;\ntypedef double elem;\ntypedef complex<elem> point,vec;\ninline elem dist(const point &a, const point &b){return abs(a-b);}\ninline vec normr(const vec &v){return v*vec(0,-1);}\ninline vec norml(const vec &v){return v*vec(0,1);}\ninline vec unormr(const vec &v){return normr(v) / abs(v);}\ninline vec unorml(const vec &v){return norml(v) / abs(v);}\nint main(){\n\twhile(true){\n\t\tint ans = 0;\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tif(n==1){\n\t\t\tprintf(\"1\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tvector< point > points;\n\t\tfor(int i=0;i<n;++i){\n\t\t\telem x, y;\n\t\t\tscanf(\"%Lf%Lf\", &x, &y);\n\t\t\tpoints.push_back( point(x,y) );\n\t\t}\n\t\tfor(unsigned int i = 0; i < points.size(); ++i){\n\t\t\tfor(unsigned int j = 0; j < points.size(); ++j){\n\t\t\t\tif( i != j && dist( points[i], points[j] ) < 2 ){\n\t\t\t\t\tint count_p = 0;\n\t\t\t\t\tint count_q = 0;\n\t\t\t\t\telem d = sqrt(1-pow(dist(points[i], points[j])/2,2 ) );\n\t\t\t\t\tpoint p,q;\n\t\t\t\t\tvec ab = points[j] - points[i];\n\t\t\t\t\tpoint t = 0.5 * ab + points[i];  \n\t\t\t\t\tp = d * unormr(ab) + t;\n\t\t\t\t\tq = d * unorml(ab) + t;\n\t\t\t\t\tfor(unsigned int k = 0; k < points.size(); ++k){\n\t\t\t\t\t\tif( dist(p, points[k]) <= 1.0+EPS ){ count_p++; }\n\t\t\t\t\t\tif( dist(q, points[k]) <= 1.0+EPS ){ count_q++; }\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans, max(count_q, count_p) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\ndouble x[400], y[400];\n\ndouble EPS = 1e-8;\n\nint main() {\n  int n;\n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n    int res = 1;\n    rep (i, n) cin >> x[i] >> y[i];\n    rep (i, n) rep (j, n) if (i < j && sqrt(pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2)) <= 2 + EPS) {\n      double mx = (x[i] + x[j]) / 2, my = (y[i] + y[j]) / 2;\n      double nx = -(my - y[i]), ny = (mx - x[i]);\n      double d = sqrt(max(1 - (pow(x[i] - mx, 2) + pow(y[i] - my, 2)), 0.));\n      double dx = nx / sqrt(nx * nx + ny * ny) * d;\n      double dy = ny / sqrt(nx * nx + ny * ny) * d;\n      double xx = mx + dx, yy = my + dy;\n      //cout << i <<  \" \" << j << endl;\n      //cout << d << endl;\n      //cout << dx << \" \" << dy << endl;\n      //cout << xx << \" \" << yy << endl;\n      int count = 0;\n      rep (k, n) {\n\t//cout << pow(x[k] - xx, 2) + pow(y[k] - yy, 2) << endl;\n\tif (pow(x[k] - xx, 2) + pow(y[k] - yy, 2) <= 1 + EPS * 10) ++count;\n      }\n      res = max(res, count);\n      xx = mx - dx, yy = mx - dy;\n      count = 0;\n      rep (k, n) {\n\t//cout << pow(x[k] - xx, 2) + pow(y[k] - yy, 2) << endl;\n\tif (pow(x[k] - xx, 2) + pow(y[k] - yy, 2) <= 1 + EPS * 10) ++count;\n      }\n      res = max(res, count);\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double EPS = 0.0000001;\nstruct point{\n  double x, y;\n  point(){\n  }\n  point(double x, double y): x(x), y(y){\n  }\n  point operator +(point P){\n    return point(x + P.x, y + P.y);\n  }\n  point operator -(point P){\n    return point(x - P.x, y - P.y);\n  }\n  point operator *(double k){\n    return point(x * k, y * k);\n  }\n  point operator /(double k){\n    return point(x / k, y / k);\n  }\n};\ndouble abs(point P){\n  return sqrt(pow(P.x, 2) + pow(P.y, 2));\n}\ndouble dist(point P, point Q){\n  return abs(Q - P);\n}\npoint midpoint(point P, point Q){\n  return (P + Q) / 2;\n}\npoint rotate90(point P){\n  return point(P.y, - P.x);\n}\npair<point, point> equal_distance(point P, point Q, double d){\n  point M = midpoint(P, Q);\n  double d2 = sqrt(pow(d, 2) - pow(dist(P, Q) / 2, 2));\n  point N = rotate90(Q - P) / dist(P, Q);\n  return make_pair(M + N * d2, M - N * d2);\n}\nint main(){\n  while (1){\n    int N;\n    cin >> N;\n    if (N == 0){\n      break;\n    }\n    vector<point> P(N);\n    for (int i = 0; i < N; i++){\n      cin >> P[i].x >> P[i].y;\n    }\n    vector<point> Q;\n    for (int i = 0; i < N; i++){\n      for (int j = i + 1; j < N; j++){\n        if (dist(P[i], P[j]) <= 2){\n          pair<point, point> tmp = equal_distance(P[i], P[j], 1);\n          Q.push_back(tmp.first);\n          Q.push_back(tmp.second);\n        }\n      }\n    }\n    int sz = Q.size();\n    int ans = 1;\n    for (int i = 0; i < sz; i++){\n      int cnt = 0;\n      for (int j = 0; j < N; j++){\n        if (dist(Q[i], P[j]) <= 1 + EPS){\n          cnt++;\n        }\n      }\n      ans = max(ans, cnt);\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstruct points{\n    double x;\n    double y;\n};\n\npoints p[300];\n\ndouble get_square(points a, points b){\n    return pow(a.x - b.x, 2.0) + pow(a.y - b.y, 2.0);\n}\n\ndouble get_dist(points a, points b){\n    return sqrt(get_square(a, b));\n}\n\nint find_max_cover(int n){\n    int count, max_cover = 1;\n    int sign[2] = {1, -1};\n    double d, e;\n    points m, q, v;\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i+1; j < n; j++) {\n            d = get_dist(p[i], p[j]);\n            if (d > 2.0){\n                continue;\n            }\n            m.x = (p[i].x + p[j].x) / 2.0;\n            m.y = (p[i].y + p[j].y) / 2.0;\n            v.x = (p[i].x - p[j].x) / d;\n            v.y = (p[i].y - p[j].y) / d;\n            e = sqrt(1.0 - d * d / 4.0);\n            for (int s = 0; s < 2; s++) {\n                q.x = m.x + sign[s] * e * v.y;\n                q.y = m.y - sign[s] * e * v.x;\n                count = 0;\n                for (int k = 0; k < n; k++) {\n                    if (k == i || k == j || get_square(q, p[k]) <= 1.0) {\n                        count++;\n                    }\n                }\n                max_cover = max(max_cover, count);\n            }\n        }\n    }\n    return max_cover;\n}\n\nint main()\n{\n    int n;\n    while (true) {\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        for (int i = 0; i < n; i++) {\n            cin >>p[i].x >> p[i].y;\n        }\n        cout << find_max_cover(n) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define EPS 1.0e-4\nusing namespace std;\n\ntypedef struct {\n  double x,y;\n} P;\n\ndouble dis(P p ){\n  return sqrt( p.x*p.x + p.y*p.y );\n}\ndouble dis(P p1,P p2 ){\n  P p;\n  p.x = p1.x-p2.x;\n  p.y = p1.y-p2.y;\n  return dis( p );\n}\n\n\nint main(){\n  int n, mx;\n  // mv : @üxNg\n  P p[301], m, p1,p2, mv,dmv, c[2];\n  double x;\n\n  while( cin>>n && n ){\n    for( int i=0;i<n;i++ )\n      cin >> p[i].x >> p[i].y ;\n\n    mx=0;\n\n    for( int i=0;i<n;i++ ){\n      for( int j=i+1;j<n;j++ ){\n\tif( dis(p[i],p[j]) < 2.0 ){\n\t  //\tif( dis(p[i],p[j]) < 2.0 + EPS ){\n\t  p1=p[i]; p2=p[j];\n\t  m.x = (p1.x+p2.x)/2.0;\n\t  m.y = (p1.y+p2.y)/2.0;\n\n\t  x = sqrt( 1-dis(p1,m) );\n\t  // S_ cðßé\n\t  if( fabs( p1.y-p2.y ) < EPS ){\n\t    mv.x=0.0;  mv.y=1.0;\n\t  }else if( fabs( p1.x-p2.x ) < EPS ){\n\t    mv.x=1.0;  mv.y=0.0;\n\t  }else{\n\t    double a1 = ( p2.y-p1.y )/( p2.x-p1.x );\n\t    mv.x=1.0; mv.y=-1.0/a1;\n\t  }\n\t  double scale = dis( mv );\n\t  dmv.x = x*mv.x / scale;\n\t  dmv.y = x*mv.y / scale;\n\n\t  c[0].x=m.x+dmv.x; c[0].y=m.y+dmv.y;\n\t  c[1].x=m.x-dmv.x; c[2].y=m.y-dmv.y;\n\t  /*\n\t  cout << \"m  \" << m.x    << \",\" << m.y    << endl;\n\t  cout << \"mv \" << mv.x   << \",\" << mv.y   << endl;\n\t  cout << \"dm \" << dmv.x  << \",\" << dmv.y  << endl;\n\t  cout << \"c0 \" << c[0].x << \",\" << c[0].y << endl;\n\t  cout << \"c1 \" << c[1].x << \",\" << c[1].y << endl;\n\t  */\n\n\t  for( int cn=0;cn<2;cn++ ){\n\t    int sum=0;\n\t    for( int k=0;k<n;k++ ){\n\t      if( dis( c[cn],p[k] ) < 1.0 )\n\t\t//\t      if( dis( c[cn],p[k] ) < 1.0 + EPS )\n\t\tsum++;\n\t    }\n\t    if( mx<sum ) mx=sum;\n\t  }\n\t}\n      }\n    }\n    cout << mx << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\ntypedef complex<double> Point;\n\nint calc(Point p, vector<Point>& ps){\n    int ans = 0;\n    for(int i = 0; i < ps.size(); i++){\n        if(abs(ps[i] - p) < 1.0 + EPS) {\n            ans++;\n        }\n    }\n    return ans;\n}\nvector<Point> touching_circle(Point a, Point b, double r){\n    vector<Point> res;\n\n    double d = abs(b - a);\n    if(d > 2 * r) return res;\n\n    Point mid = 0.5 * (a + b);\n    Point dir = polar(sqrt(r * r - d * d / 4), arg(b - a) + M_PI / 2);\n    res.push_back(mid + dir);\n    res.push_back(mid - dir);\n    return res;\n}\nint main(){\n    int N;\n    while(cin >> N && N){\n        vector<Point> ps(N);\n        REP(i, N){\n            double x, y;\n            cin >> x >> y;\n            ps[i] = Point(x, y);\n        }\n        int ans = 0;\n        REP(i, N) REP(j, N) if(abs(ps[i] - ps[j]) > EPS) {\n            vector<Point> tp = touching_circle(ps[i], ps[j], 1.0);\n            for(Point c : tp){\n            assert(abs(1.0 - abs(c - ps[i])) < EPS);\n            assert(abs(1.0 - abs(c - ps[j])) < EPS);\n                ans = max(ans, calc(c, ps));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n\nint main() {\n\tdouble x[300];\n\tdouble y[300];\n\n\twhile (true) {\n\t\tint N;\n\n\t\tscanf(\"%d\", &N);\n\t\tif (N == 0) break;\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tscanf(\"%lf%lf\", &x[i], &y[i]);\n\t\t}\n\n\t\tint max = 1;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tdouble dx = x[i] - x[j];\n\t\t\t\tdouble dy = y[i] - y[j];\n\t\t\t\tdouble dist = hypot(dx, dy);\n\t\t\t\tif (dist > 2.0) continue;\n\n\t\t\t\tdouble mx = (x[i] + x[j]) / 2;\n\t\t\t\tdouble my = (y[i] + y[j]) / 2;\n\t\t\t\tdouble l = sqrt(1.0 - dist * dist / 4);\n\t\t\t\tdouble cx = mx + (-dy) * l / dist;\n\t\t\t\tdouble cy = my + dx * l / dist;\n\t\t\t\tint count = 0;\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif (k == i || k == j ||\n\t\t\t\t\t\t(cx - x[k]) * (cx - x[k]) + (cy - y[k]) * (cy - y[k]) <= 1.0) count++;\n\t\t\t\t}\n\n\t\t\t\tif (max < count) max = count;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", max);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\nstruct Point {\n\tdouble x;\n\tdouble y;\n\tPoint(double _x = 0, double _y = 0) :x(_x), y(_y) {}\n\tPoint operator+(Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator-(Point p)  {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm() {\n\t\treturn x*x + y*y;\n\t}\n};\ntypedef Point Vector;\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle(Point _c = Point(), double _r = 0.0) :c(_c), r(_r) {}\n};\ndouble arg(Vector p) {\n\treturn atan2(p.y, p.x);\n}\nVector polar(double a, double r) {\n\treturn Point(cos(r)*a, sin(r)*a);\n}\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\ndouble X[300], Y[300];\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> X[i] >> Y[i];\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tCircle c1(Point(X[i], Y[i]), 1.0);\n\t\t\t\tCircle c2(Point(X[j], Y[j]), 1.0);\n\t\t\t\tif ((c1.c - c2.c).abs() > 2.0) continue;\n\t\t\t\tpair<Point, Point> c = getCrossPoints(c1, c2);\n\t\t\t\tint cnt1 = 0, cnt2 = 0;\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tPoint p(X[k], Y[k]);\n\t\t\t\t\tif ((p - c.first).abs() <= 1.0) cnt1++;\n\t\t\t\t\tif ((p - c.second).abs() <= 1.0) cnt2++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, cnt1);\n\t\t\t\tans = max(ans, cnt2);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nint main(){\n    while(true){\n        int N;\n        cin >> N;\n        if(N == 0) break;\n        vector<point> P(N);\n        for(int i=0;i<N;i++){\n            cin >> P[i].real() >> P[i].imag();\n        }\n\n        int ret = 1;\n\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                if(i == j) continue;\n                point p1 = P[i];\n                point p2 = P[j];\n\n                if(abs(p1-p2) <= 2.0+EPS){\n                    point d = p1 - p2;\n                    point m = (p1+p2)/(point(2,0));\n\n                    point nor = d * point(0,1);\n                    nor /= abs(nor);\n                    nor *= point(sqrt(1-(abs(d)/2)*(abs(d)/2)),0);\n\n                    point p = m + nor;\n                    int cnt = 0;\n                    for(int k=0;k<N;k++){\n                        if(abs(P[k]-p) <= 1+EPS) cnt++;\n                    }\n                    ret = max(ret,cnt);\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\ntypedef complex<double> P;\n\nvector<P> point;\n\nconst double EPS = 0.0000000001;\n\n\nvoid init(){\n  point.clear();\n}\n\n\nbool input(){\n  int n;\n  cin>>n;\n  if(n==0)return false;\n\n  rep(i,n){\n    double a ,b;\n    cin>>a>>b;\n    point.push_back(P(a,b));\n  }\n  return true;\n}\n\nvector<P> make_cand(){\n  vector<P> ret;\n  rep(i,point.size()){\n    reps(j,i+1,point.size()){\n      P dist = point[j]-point[i];\n      double d = abs(dist)/2;\n\n      if(d>1)continue;\n      double h = sqrt(1-d*d);\n      P e = dist/(d*2);\n\n      P e1 = e*P(0,1);\n      P e2 = e*P(0,-1);\n\n      P c1 = point[i]+e*d+h*e1;\n      P c2 = point[i]+e*d+h*e2;\n\n      //cout<<\"d=\"<<d<<\" h=\"<<h<<endl;\n      //cout<<point[i]<<\" \"<<point[j]<<\" \"<<c1<<\" \"<<c2<<endl;\n      ret.push_back(c1);\n      ret.push_back(c2);\n    }\n  }\n  return ret;\n}\n\nint count_in(P p){\n  int sum = 0;\n  rep(i,point.size()){\n    P d  = point[i]-p;\n    if(abs(d)<=1+EPS)sum++;\n  }\n  return sum;\n}\nint solve(){\n  vector<P> cand = make_cand();\n  int ans = 0;\n  rep(i,cand.size()){\n    ans = max(ans, count_in(cand[i]));\n  }\n  return ans;\n}\n\nint main(){\n  while(init(),input()){\n    printf(\"%d\\n\",solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <complex>\n\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,n) loop(i,0,n)\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef complex<double> vec;\n\ndouble const pi = acos(-1);\ndouble const eps = 1e-5;\n\nint main(){\n    int n;\n    while (cin >> n && n){\n        vector<vec> v(n);\n        rep(i, n){\n            double x, y; cin >> x >> y;\n            vec p(x, y);\n            v[i] = p;\n        }\n\n        if (n == 1) {\n            puts(\"1\");\n            continue;\n        }\n        int ans = 1;\n        rep(i, n)rep(j, i){\n            double d = abs(v[i] - v[j]);\n            if (d - eps > 2) continue;\n            ans = max(ans, 2);\n            double h = 1 - d*d / 4;\n            vec c1 = polar(h, arg(v[i] - v[j]) + pi / 2) + (v[i] + v[j]) / 2.;\n            vec c2 = polar(h, arg(v[i] - v[j]) - pi / 2) + (v[i] + v[j]) / 2.;\n            int a1 = 0, a2 = 0;\n            rep(k, n){\n                if (abs(c1 - v[k]) <= 1 - eps) a1++;\n                if (abs(c2 - v[k]) <= 1 - eps) a2++;\n            }\n            ans = max(ans, a1);\n            ans = max(ans, a2);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#define EPS 1e-9\nusing namespace std;\ntypedef complex<double> xy_t;\nint n;\nxy_t points[301];\nint count_in(xy_t center)\n{\n  int ans=0;\n  for(int i=0;i<n;i++)\n  {\n    if (abs(center-points[i])<1.0+EPS)\n      ans++;\n  }\n  return ans;\n}\nxy_t ppdcl(xy_t a)\n{\n  //return xy_t(a.imag(),-a.real());\n  return a*xy_t(0,1);\n}\nxy_t delta_v(xy_t C1,xy_t C2)\n{\n  xy_t half=(C1-C2)*0.5;\n  double l=abs(half);\n  return ppdcl(half)*sqrt(1-l*l)*(1.0/l);\n}\nint main()\n{\n  while(1)\n  {\n    cin>>n;\n    if (n==0) break;\n    double x,y;\n    for(int i=0;i<n;i++)\n    {\n      cin>>x>>y;\n      points[i]=xy_t(x,y);\n    }\n    int maxn=-1;\n    for(int i=0;i<n;i++)\n    {\n      for(int j=i;j<n;j++)\n      {\n        if(abs(points[i]-points[j])<2.0)\n        {\n          xy_t mid_p=(points[i]+points[j])*0.5;\n          maxn=max(maxn,count_in(mid_p+delta_v(points[i],points[j])));\n          maxn=max(maxn,count_in(mid_p-delta_v(points[i],points[j])));\n        }\n      }\n    }\n    cout<<maxn<<endl;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n//CCW??¨///////////////////////////////////\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n/////////////////////////////////////////\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\nstruct Circle{\n  Point c;\n  double r;\n};\ntypedef Point vect;\nstruct seg{Point p1,p2;};\n//????????´????????????\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\n//??¶???????????????absolute  ?????????????????¶?????????\ndouble abs(Point p){return sqrt(norm(p));}\n//?????????????????????????????????\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n//?????? ????????????????????????\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n//??´?????????????????¨?????\\?????????????????????\nbool C90(seg s1,seg s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//????????????????????¨?????\\??????????????????????????????????????????\nbool C0(seg s1,seg s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//?°???± ??????????????´???????????????\nPoint project(seg s,Point p){\n  Point base = s.p2-s.p1;\n  double r=dot(p-s.p1,base) / norm(base);\n  return s.p1+base*r;\n}\n//????°??????????????????????\nPoint reflection(seg s,Point p){\n  return  p+(project(s,p)-p)*2.0;\n}\n//2???????????¢   ???????????????\ndouble getDistancePP(Point a,Point b){\n  return abs(a-b);\n}\n//??´??????????????¢(????°?)???????????????\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n//?????????????????¢??????????????????\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n//????¨?????????????????¨??????????????????????????????????\nint CCW(Point p0,Point p1,Point p2){\n  Point a=p1-p0;\n  Point b=p2-p0;\n  if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS)return CLOCKWISE;\n  if(dot(a,b)<-EPS)return ONLINE_BACK;\n  if(norm(a)<norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n//????????????????????????????????????????????§?\\????\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return(CCW(p1,p2,p3)*CCW(p1,p2,p4)<=0&&CCW(p3,p4,p1)*CCW(p3,p4,p2)<=0);\n}\nbool intersect(seg s1,seg s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//2??????????§???¢?????\\??????????????????...????????????????????????\nbool squareintersect(seg s1,seg s2){\n  if(s1.p2.x<s2.p1.x||s2.p2.x<s1.p1.x)return 0;\n  if(s1.p2.y<s2.p1.y||s2.p2.y<s1.p1.y)return 0;\n  return 1;\n}\n//??????????????¢?????????????????????????????§??¨???????????????\ndouble getDistance(seg s1,seg s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n    min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n//??????????????????????????????(?´????????`)\nPoint getCrossPoint(seg s1,seg s2){\n  Point base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n//???????£????????????¢??????????????¢??????????????????????????\\????????????????????§???????????£???????????????????????????????????§?????????????????????\nint intersectCC(Circle a,Circle b){\n  double dist=abs(a.c-b.c);\n  if(dist>a.r+b.r+EPS)return 4;\n  if(dist>a.r+b.r-EPS)return 3;\n  if(dist>abs(a.r-b.r)+EPS)return 2;\n  if(dist>abs(a.r-b.r)-EPS)return 1;\n  return 0;\n}\n//?????¨??´???????????????2?????? (LINE)\nseg getCrossPoint(Circle c,seg l){\n  //assert(intersect(cc,l));\n  Point pr=project(l,c.c);\n  Point e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base =sqrt(c.r*c.r-norm(pr-c.c));\n  seg pp;pp.p1=(pr+e*base);pp.p2=(pr-e*base);\n  return pp;\n}\n//?????¨??´??????Line??????????????°\nint getCircleLine(Circle c,seg l){\n  seg a=getCrossPoint(c,l);\n  if(isnan(a.p1.x)&&isnan(a.p2.y))return 0;\n  else if(a.p1.x==a.p2.x&&a.p1.y==a.p2.y)return 1;\n  else return 2;\n}\n//??´?????¨????????\\???????????????\nbool intersectCirclesen(seg s,Circle t){\n  double a,b,c;\n  a=getDistancePP(s.p1,t.c);\n  b=getDistancePP(s.p2,t.c);\n  c=getDistanceSP(s,t.c);\n  if(a<t.r&&b>t.r)return 1;\n  if(b<t.r&&a>t.r)return 1;\n  if(a>=t.r&&b>=t.r&&c<=t.r)return 1;\n  return 0;\n}\n//??????\nPoint gaishin(Point a, Point b, Point c){\n  double a1,a2,b1,b2,c1,c2;\n  a1=2*(b.x-a.x);b1=2*(b.y-a.y);c1=a.x*a.x-b.x*b.x+a.y*a.y-b.y*b.y;\n  a2=2*(c.x-a.x);b2=2*(c.y-a.y);c2=a.x*a.x-c.x*c.x+a.y*a.y-c.y*c.y;\n  Point p;p.x=(b1*c2-b2*c1)/(a1*b2-a2*b1);p.y=(c1*a2-c2*a1)/(a1*b2-a2*b1);\n  return p;\n}\n//2??????????????????\ndouble arg(Point p){return atan2(p.y,p.x);}\nPoint polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\nseg getCrossPoints(Circle c1,Circle c2){\n  //assert(intersect(c1,c2));\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  seg s;s.p2=c1.c+polar(c1.r,t+a);s.p1=c1.c+polar(c1.r,t-a);\n  return s;\n}\n//???????????? ????????????->2 ??????->1  ????????\\???->0\ntypedef vector<Point> Polygon;\nint contains(Polygon g, Point p) {\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++) {\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n  }\n  return x ? 2 : 0;\n}\ndouble Area(Polygon p) {\n  double a=0;\n  for(int i=0;i<p.size();i++)a+=cross(p[i],p[(i+1)%p.size()]);\n  return a/2;\n}\n//???????§???¢??????\nbool isConvex(Polygon p){\n  for(int i=0;i<p.size();i++){\n    if(CCW(p[(i+1)%p.size()],p[i%p.size()],p[(i+2)%p.size()])==1)return false;\n  }\n  return true;\n}\n//?????¢???????????¢???(?????´)=ans\nPolygon convex_cut(Polygon p,seg l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(CCW(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(CCW(l.p1,l.p2,A)*CCW(l.p1,l.p2,B)<0){\n      seg s;s.p1=A;s.p2=B;\n      ans.push_back(getCrossPoint(l,s));\n    }\n  }\n  return ans;\n}\ndouble convex_diameter(Polygon p){\n  int n=p.size();\n  int i=0,j=0;\n  for(int k=0;k<n;k++){if(p[i]<p[k])i=k;if(p[k]<p[j])j=k;}\n  int si=i,sj=j;double ans=0.0;\n  while(i!=sj||j!=si){\n    ans=max(ans,abs(p[i]-p[j]));\n    if(cross((p[(i+1)%n]-p[i]),(p[(j+1)%n]-p[j]))<0)i=(i+1)%n;\n    else j=(j+1)%n;\n  }\n  return ans;\n}\n//?????? ??´??????????????????????????????????????¨?????????191,197?????????&&CCW(u[n-2],u[n-1],s[i])!=ONLINE_FRONT???????????????\nPolygon andrewScan(Polygon s) {\n  Polygon l, u;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<s.size();i++){\n    for(int n=u.size();n>=2&&CCW(u[n-2],u[n-1],s[i])!=-1&&CCW(u[n-2],u[n-1],s[i])!=ONLINE_FRONT;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&CCW(l[n-2],l[n-1],s[i])!=-1&&CCW(l[n-2],l[n-1],s[i])!=ONLINE_FRONT;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for( int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  return l;\n}\n//???a??¨???b??????d??¢??????2???\nseg identifyPoint(Point a,Point b,double d){\n  Circle c1,c2;\n  c1.c=a;c1.r=d;c2.c=b;c2.r=d;\n  return getCrossPoints(c1,c2);\n}\n//    ???????????°??¨??????\nseg scan(){seg a;scanf(\"%lf%lf%lf%lf\",&a.p1.x,&a.p1.y,&a.p2.x,&a.p2.y);return a;}\nvoid prin(seg a){printf(\"%.10f %.10f %.10f %.10f\\n\",a.p1.x,a.p1.y,a.p2.x,a.p2.y);}\n//\n/////------Library END-------//////////////////////////////////////\n//   exp?????????    //////a=x??§?¨????b=y??§?¨????c=?§?????????????d=????????????????????¢\n//    p[i][j].x=a-d*sin(M_PI/180*(72*j+c));\n//   p[i][j].y=b+d*cos(M_PI/180*(72*j+c));\n/////////////////////////////////////////////////\nint main(){\n  int n;\n  while(cin>>n,n){\n    Point p[n];int ans=1;\n    r(i,n)cin>>p[i].x>>p[i].y;\n    r(i,n)for(int j=i+1;j<n;j++){\n      if(getDistancePP(p[i],p[j])<2.0){\n      seg s=identifyPoint(p[i],p[j],1);\n      int a1=0,a2=0;\n      Point p3,p4;p3=s.p1;p4=s.p2;\n      r(k,n)if(abs(getDistancePP(p3,p[k]))<=1)a1++;\n      r(k,n)if(abs(getDistancePP(p4,p[k]))<=1)a2++;\n      ans=max(ans,max(a1,a2));}\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\ntypedef complex<double> P;\n\nint N;\nP dots[300];\n#define EPS (1e-6)\n\n// 2_ðÊé¼arÌ~Ì_ðßé\npair<P,P> calcCircleCenterPoint(P dot1,P dot2,double r){\n    double v=abs(dot1-dot2);\n    double x = sqrt(r*r - (v/2)*(v/2));\n    // ñgÌPÊ@üxNg\n    P hose[2];\n    //double y1 = -(1.0)/(dot1.imag() - dot2.imag());\n    //double x1 = 1.0/(dot1.real() - dot2.real());\n    double x1=-(dot1.imag()-dot2.imag());\n    double y1=(dot1.real() - dot2.real());\n    hose[0]=P(x1,y1);\n    //double y2 = 1.0/(dot1.imag() - dot2.imag());\n    //double x2 = -1.0/(dot1.real() - dot2.real());\n    double y2=-y1;\n    double x2=-x1;\n    hose[1]=P(x2,y2);\n    double dd1=abs(hose[0]);\n    double dd2=abs(hose[1]);\n    hose[0]/=dd1;hose[0]*=x;\n    hose[1]/=dd2;hose[1]*=x;\n    P tmp=(dot1+dot2);\n    tmp/=2;\n    hose[0]+=tmp;\n    hose[1]+=tmp;\n    return make_pair(hose[0],hose[1]);\n}\n\nint main(){\n\n\twhile(cin >> N && N != 0){\n        for(int i = 0; i < N; i++){\n            P p;\n            double x,y;\n            cin>>x>>y;\n            dots[i]=P(x,y);\n            //cin >> dots[i].second >> dots[i].first;\n\t\t}\n\t\tint maxCnt = 1;\n\t\t// ~ðìé½ßÌQ_ðßé\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = i+1; j < N; j++){\n                //pair<double,double> dot1,dot2;\n                P dot1,dot2;\n\t\t\t\tdot1 = dots[i];\n\t\t\t\tdot2 = dots[j];\n                //double v = sqrt((dot1.first - dot2.first)*(dot1.first - dot2.first)\n                //+(dot1.second - dot2.second)*(dot1.second - dot2.second));\n                double v=abs(dot1-dot2);\n\t\t\t\t// ñ_Ô£ª2æè¨¨«¯êÎÂ­êÈ¢\n\t\t\t\tif(v > 2.0 + EPS){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n    //            double x = sqrt(1 - (v/2)*(v/2));\n\t\t\t\t//// ñgÌPÊ@üxNg\n                P hose[2];\n                pair<P,P> tmp=calcCircleCenterPoint(dot1,dot2,1);\n                hose[0]=tmp.first;\n                hose[1]=tmp.second;\n    //            double y1 = -1.0/(dots[i].imag() - dots[j].imag());\n    //            double x1 = 1.0/(dots[i].real() - dots[j].real());\n    //            hose[0]=P(x1,y1);\n    //            double y2 = 1.0/(dots[i].imag() - dots[j].imag());\n    //            double x2 = -1.0/(dots[i].real() - dots[j].real());\n    //            hose[1]=P(x2,y2);\n\n\t\t\t\t////double dd1 = sqrt((hose[0].second)*(hose[0].second)+(hose[0].first)*(hose[0].first));\n    //            //double dd2 = sqrt((hose[1].second)*(hose[1].second)+(hose[1].first)*(hose[1].first));\n    //            double dd1=abs(hose[0]);\n    //            double dd2=abs(hose[1]);\n    //            hose[0]/=dd1;hose[0]*=x;\n    //            hose[1]/=dd2;hose[1]*=x;\n    //            P tmp=(dot1+dot2);\n    //            tmp/=2;\n    //            hose[0]+=tmp;\n    //            hose[1]+=tmp;\n\n    //            hose[0].first /= dd1; hose[0].second /= dd1;\n\t\t\t\t//hose[1].first /= dd2; hose[1].second /= dd2;\n\t\t\t\t// x{·é\n\t\t\t\t//hose[0].first *= x;hose[1].first *= x;\n\t\t\t\t//hose[0].second *= x;hose[1].second *= x;\n\n\t\t\t\t// mð«·\n\t\t\t\t//hose[0].first += (dot1.first + dot2.first)/2;\n\t\t\t\t//hose[0].second += (dot1.second + dot2.second)/2;\n\t\t\t\t//hose[1].first += (dot1.first + dot2.first)/2;\n\t\t\t\t//hose[1].second += (dot1.second + dot2.second)/2;\n\n\t\t\t\t// hose[0]Æhose[1]Í~ÌSÀW\n\t\t\t\t// e_ÉÖµÄ~ÌÉ¶Ý·é©Ç¤©ðßé\n\t\t\t\tfor(int k = 0; k < 2; k++){\n                    int cnt = 0;\n\t\t\t\t\tfor(int l = 0; l < N; l++){\n\t\t\t\t\t\t//double dist = sqrt((dots[l].first -hose[k].first)*(dots[l].first -hose[k].first)\n\t\t\t\t\t\t//\t+ (dots[l].second -hose[k].second)*(dots[l].second -hose[k].second));\n                        double dist=abs(dots[l]-hose[k]);\n\t\t\t\t\t\tif(dist <= 1.0 + EPS){\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmaxCnt = max(maxCnt,cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << maxCnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nconst double EPS=1e-9;\n\nint n;\nPoint p[300];\n\nint f(const Point &c){\n\tint res=0;\n\trep(i,n) if(abs(p[i]-c)<1+EPS) res++;\n\treturn res;\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\trep(i,n){ double x,y; scanf(\"%lf%lf\",&x,&y); p[i]=Point(x,y); }\n\n\t\tint ans=1;\n\t\trep(j,n) rep(i,j) {\n\t\t\tdouble d=abs(p[j]-p[i])/2;\n\t\t\tPoint v=(p[j]-p[i])/(2*d);\n\t\t\tif(d<1){\n\t\t\t\tans=max(ans,f(p[i]+d*v+sqrt(1-d*d)*v*Point(0,+1)));\n\t\t\t\tans=max(ans,f(p[i]+d*v+sqrt(1-d*d)*v*Point(0,-1)));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<map>\nusing namespace std;\n#define EPS (1e-9)\ntypedef complex < double > P; // P:点\nstruct C{ //C:円\n  P p; double r;\n  C():p(0),r(0){}\n  C(const P& p, double r):p(p),r(r){};\n};\nbool interectCC(const C& c,const C& d){\n  return (norm(c.p - d.p) - (c.r + d.r)*(c.r + d.r) < EPS) &&\n    (norm(c.p - d.p) - (c.r - d.r)*(c.r - d.r) > -EPS);\n}\npair< P , P > crosspointCC(const C& c,const C& q){\n  P a = conj(q.p - c.p);\n  P b = q.r  * q.r - c.r * c.r - (q.p - c.p) * a;\n  P C = c.r * c.r * (q.p - c.p);\n  P d = b * b - 4.0 * a * C;\n  P z1 = (-b * sqrt(d)) / (2.0 * a) + c.p;\n  P z2 = (-b - sqrt(d)) / (2.0 * a) + c.p;\n  return pair< P , P >( z1, z2);\n}\nint main(){\n  int n;\n  while(cin >> n , n){\n    vector < P > pts(n);\n    int ans = 1;\n    for(int i = 0 ; i < n ; i++ ){\n    cin >> pts[i].real() >> pts[i].imag();\n    }\n    for(int i = 0 ; i < n ; i++ ){\n      C c1 = C( pts[i], 1);\n      for(int j = 0 ; j < i ; j++ ){\n        C c2 = C( pts[j], 1);\n        if(interectCC(c1,c2)){\n          pair< P , P > nnr = crosspointCC( c1, c2);\n          int ret = 0, rec = 0;\n          for(int k = 0 ; k < n ; k++ ){\n            if(abs(nnr.first - pts[k]) <= 1 + EPS) ret++;\n            if(abs(nnr.second - pts[k]) <= 1 + EPS) rec++;\n          }\n          ans = max( ans, max( ret, rec));\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define FOR(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(x) x.begin(),x.end()\n#define ll long long\n\ntypedef pair<int,int> pii;\n\ntypedef complex<double> point;\nconst double R = 1.0;\nconst double EPS = 1e-6;\ndouble dist(point &p1,point &p2){\n\treturn abs(p1-p2);\n}\nstruct Square{\n\tdouble d,u,l,r;\n\tint up_bound;\n\t\n\tSquare(double _d,double _u, double _l,double _r,const vector<point>&ps):d(_d),u(_u),l(_l),r(_r){\n\t\tint res = 0;\n\t\tpoint c = {(l+r)/2,(d+u)/2};\n\t\tdouble ra = sqrt(2)*(r-l)/2+1;\n\t\tfor(auto p:ps){\n\t\t\tif(dist(c,p)<ra+EPS)res++;\n\t\t}\n\t\tup_bound=res;\n\t}\n\tint count(const vector<point>&ps,const double &R){\n\t\tpoint c = {(l+r)/2,(d+u)/2};\n\t\tint res = 0;\n\t\tfor(auto p:ps){\n\t\t\tif(dist(c,p)<R+EPS)res++;\n\t\t}\n\t\treturn res;\n\t}\n};\nnamespace std{\n\tbool operator<(const Square &S1, const Square &S2){\n\t\treturn S1.up_bound<S2.up_bound;\n\t}\n\tbool operator>(const Square &S1, const Square &S2){\n\t\treturn S1.up_bound>S2.up_bound;\n\t}\n}\nvoid solve() {\n\tint N;cin>>N;\n\tif(N==0)exit(0);\n\n\tint ans = 1;\n\tdouble l = 0,r = 10;\n\tvector<point>ps(N);\n\tREP(i,N){\n\t\tdouble x,y;cin>>x>>y;\n\t\tps[i]={x,y};\n\t}\n\tSquare s(-1e9,1e9,-1e9,1e9,ps);\n\tpriority_queue<Square,vector<Square>,greater<Square>>que;\n\tque.push(s);\n\tREP(_,500){\n\t\tvector<Square>nxt;\n\t\twhile(!que.empty()){\n\t\t\tSquare s = que.top();que.pop();\n\t\t\tif(s.up_bound<=ans)continue;\n\t\t\tans = max(ans,s.count(ps,R));\n\t\t\tdouble xl = s.l , xm = (s.l+s.r)/2.0,xr = s.r;\n\t\t\tdouble yl =s.d,ym = (s.d+s.u)/2.0,yr = s.u;\n\t\t\tSquare s1(yl,ym,xl,xm,ps);\n\t\t\tif(s1.up_bound>ans)nxt.push_back(s1);\n\n\t\t\tSquare s2(yl,ym,xm,xr,ps);\n\t\t\tif(s2.up_bound>ans)nxt.push_back(s2);\n\t\t\t\n\t\t\tSquare s3(ym,yr,xl,xm,ps);\n\t\t\tif(s3.up_bound>ans)nxt.push_back(s3);\n\t\t\t\n\t\t\tSquare s4(ym,yr,xm,xr,ps);\n\t\t\tif(s4.up_bound>ans)nxt.push_back(s4);\n\t\t}\n\t\tfor(auto s:nxt)que.push(s);\n\t}\n\tcout<<ans<<endl;\n}\nsigned main() {\n\twhile (true) {\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n\nusing namespace std;\ntypedef pair<double, double> P;\nconst double EPS = 1e-6;\n\n#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n\nusing namespace std;\n\ntemplate <typename T>\nclass Mat\n{\npublic:\n    vector<vector<T>> mat;\n    int rows, columns;\n\n    Mat<T>(int r, int c) : rows(r), columns(c) {\n        mat = vector<vector<T>>(rows, vector<T>(columns));\n    }\n\n    Mat<T>(initializer_list<initializer_list<T>> _mat)\n        : rows(_mat.size()), columns(_mat.begin()->size()) {\n        mat = vector<vector<T>>(rows, vector<T>(columns));\n        int i = 0;\n        for (auto&& row : _mat) {\n            copy(row.begin(), row.end(), mat[i++].begin());\n        }\n    }\n\n    vector<T> &operator [](int m) {\n        return mat[m];\n    }\n\n    vector<T> operator *(const vector<T> v) const {\n        vector<T> ret(rows);\n        for (int m = 0; m < rows; m++) {\n            for (int n = 0; n < columns; n++) {\n                ret[m] += mat[m][n] * v[n];\n            }\n        }\n        return ret;\n    }\n\n    Mat<T> operator *(Mat<T>& o) const {\n        Mat<T> ret(rows, o.columns);\n\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < o.columns; c++) {\n                for (int i = 0; i < columns; i++) {\n                    ret[r][c] += mat[r][i] * o[i][c];\n                }\n            }\n        }\n        return ret;\n    }\n\n    void operator *=(Mat<T>& o) {\n        *this = *this * o;\n    }\n\n    Mat<T> pow(int n) const {\n        Mat ans(rows, columns);\n        for (int i = 0; i < rows; i++) {\n            ans[i][i] = 1;\n        }\n\n        Mat base = *this;\n\n        for (int i = 0; n>>i; i++) {\n            if (n>>i&1) {\n                ans *= base;\n            }\n            base *= base;\n        }\n        return ans;\n    }\n\n    Mat<T> &t() {\n        vector<vector<T>> _mat(columns, vector<T>(rows));\n        for (int m = 0; m < rows; m++) for (int n = 0; n < columns; n++) {\n            _mat[n][m] = mat[m][n];\n        }\n        mat = _mat;\n        swap(rows, columns);\n        return *this;\n    }\n};\n\ndouble dist(P a, P b)\n{\n    return hypot(a.first - b.first, a.second - b.second);\n}\n\nvector<P> center(P a, P b)\n{\n    auto t = atan2(b.first - a.first, b.second - a.second);\n    auto d = dist(a, b) / 2;\n    vector<double> x1 = { d, sqrt(1.0 - d * d) };\n    vector<double> x2 = { d, -sqrt(1.0 - d * d) };\n    Mat<double> r = { { cos(t), -sin(t) }, { sin(t), cos(t) } };\n    vector<P> ans;\n    for (vector<double> v : { r * x1, r * x2 }) {\n        ans.emplace_back(v[0] + a.first, v[1] + a.second);\n    }\n    return ans;\n}\n\nint main()\n{\n    while (1) {\n        int n; cin >> n;\n        if (!n) break;\n        vector<P> pnt;\n        loop (n, i) {\n            double x, y; cin >> x >> y;\n            pnt.emplace_back(x, y);\n        }\n        int ans = 1;\n        loop (n, i) loop (n, j) {\n            if (dist(pnt[i], pnt[j]) < 2) ans = 2;\n        }\n        loop (n, i) loop (n, j) {\n            auto ps = center(pnt[i], pnt[j]);\n            for (auto o : ps) {\n                int cnt = 0;\n                loop (n, l) {\n                    if (dist(o, pnt[l]) < 1 + EPS) cnt++;\n                }\n                ans = max(ans, cnt);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble Dis(double x1, double y1, double x2, double y2);\nint main(void){\n\twhile(1){\n\t\tint n;\n\t\tint ans = 1;\n\t\tvector< pair<double, double> > p;\n\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tpair<double, double> t;\n\t\t\tcin >> t.first >> t.second;\n\t\t\tp.push_back(t);\n\t\t}\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t//中点\n\t\t\t\tdouble mpx = (p[i].first + p[j].first) / 2.0;\n\t\t\t\tdouble mpy = (p[i].second + p[j].second) / 2.0;\n\t\t\t\t//2点間の距離\n\t\t\t\tdouble d1 = Dis(p[i].first, p[i].second, p[j].first, p[j].second);\n\t\t\t\t//p[i]からp[j]へ向かうベクトル\n\t\t\t\tdouble v1x = (p[i].first - p[j].first) / d1;\n\t\t\t\tdouble v1y = (p[i].second - p[j].second) / d1;\n\t\t\t\t//中点から円の中心へ向かう単位ベクトル\n\t\t\t\tdouble v2x = -v1y;\n\t\t\t\tdouble v2y = v1x;\n\t\t\t\t//中心から円の中心へ向かうベクトルの長さ\n\t\t\t\tdouble d2 = sqrt(1.0 - (d1/2.0)*(d1/2.0));\n\n\t\t\t\t//円の中心の座標\n\t\t\t\tdouble cx = mpx + v2x * d2;\n\t\t\t\tdouble cy = mpy + v2y * d2;\n\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(k == i || k == j || Dis(cx, cy, p[k].first, p[k].second) <= 1.0)\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt > ans){\n\t\t\t\t\tans = cnt;\n\t\t\t\t}\n\n\t\t\t\tcx = mpx - v2x * d2;\n\t\t\t\tcy = mpy - v2y * d2;\n\n\t\t\t\tcnt = 0;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(Dis(cx, cy, p[k].first, p[k].second) <= 1.0)\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt > ans){\n\t\t\t\t\tans = cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\n\t}\n\t\n\treturn 0;\n}\n\ndouble Dis(double x1, double y1, double x2, double y2){\n\treturn sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#define EPS 1e-9\nusing namespace std;\ntypedef complex<double> xy_t;\nint n;\nxy_t points[301];\nint count_in(xy_t center)\n{\n  int ans=0;\n  for(int i=0;i<n;i++)\n  {\n    if (abs(center-points[i])<1.0+EPS)\n      ans++;\n  }\n  return ans;\n}\n/*xy_t ppdcl(xy_t a)\n{\n  return xy_t(a.imag(),-a.real());\n}\nxy_t delta_v(xy_t C1,xy_t C2)\n{\n  xy_t half=(C1-C2)*0.5;\n  double l=abs(half);\n  return ppdcl(half)*sqrt(1-l*l)*(1.0/l);\n}*/\nint main()\n{\n  while(1)\n  {\n    cin>>n;\n    if (n==0) break;\n    double x,y;\n    for(int i=0;i<n;i++)\n    {\n      cin>>x>>y;\n      points[i]=xy_t(x,y);\n    }\n    int maxn=-1;\n    for(int i=0;i<n;i++)\n    {\n      for(int j=i;j<n;j++)\n      {\n        /*if(abs(points[i]-points[j])<2.0)\n        {\n          xy_t mid_p=(points[i]+points[j])*0.5;\n          maxn=max(maxn,count_in(mid_p+delta_v(points[i],points[j])));\n          maxn=max(maxn,count_in(mid_p-delta_v(points[i],points[j])));\n        }*/\n        double d=abs(points[j]-points[i])/2;\n        xy_t v=(points[j]-points[i])/(2*d);\n        if(d<1)\n        {\n            maxn=max(maxn,count_in(points[i]+d*v+sqrt(1-d*d)*v*xy_t(0,+1)));\n            maxn=max(maxn,count_in(points[i]+d*v+sqrt(1-d*d)*v*xy_t(0,-1)));\n        }\n      }\n    }\n    cout<<maxn<<endl;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n\nstd::pair<double, double> p[300];\n\nint main() {\n\tint n;\n\twhile (std::cin >> n && n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble x, y;\n\t\t\tstd::cin >> x >> y;\n\t\t\tp[i] = std::make_pair(x, y);\n\t\t}\n\n\t\tint max = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tdouble l = std::pow(p[i].first - p[j].first, 2) + std::pow(p[i].second - p[j].second, 2);\n\t\t\t\tif (l > 4) continue;\n\n\t\t\t\t//?????¨??????????????????2??????????????????????????????\n\t\t\t\t//????????§?¨??¨????\n\t\t\t\tdouble l2 = std::sqrt(1 - std::pow(std::sqrt(l) / 2, 2));\n\t\t\t\tdouble a = std::atan((p[i].second - p[j].second) / (p[i].first - p[j].first)) + M_PI / 2;\n\t\t\t\tdouble dx = l2 * std::cos(a);\n\t\t\t\tdouble dy = l2 * std::sin(a);\n\t\t\t\tdouble cx = (p[i].first + p[j].first) / 2 + dx;\n\t\t\t\tdouble cy = (p[i].second + p[j].second) / 2 + dy;\n\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (std::pow(cx - p[k].first, 2) + std::pow(cy - p[k].second, 2) <= 1) cnt++;\n\t\t\t\t}\n\t\t\t\tmax = std::max(max, cnt);\n\n\t\t\t\tcnt = 0;\n\t\t\t\tcx -= dx * 2;\n\t\t\t\tcy -= dy * 2;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (std::pow(cx - p[k].first, 2) + std::pow(cy - p[k].second, 2) <= 1) cnt++;\n\t\t\t\t}\n\t\t\t\tmax = std::max(max, cnt);\n\t\t\t}\n\t\t}\n\t\tstd::cout << max << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "3\n1 0\n0 0\n0 1\n3\n6.47634 7.69628\n5.16828 4.79915\n6.69533 6.20378\n6\n7.15296 4.08328\n6.50827 2.69466\n5.91219 3.86661\n5.29853 4.16097\n6.10838 3.46039\n6.34060 2.41599\n8\n7.90650 4.01746\n4.10998 4.18354\n4.67289 4.01887\n6.33885 4.28388\n4.98106 3.82728\n5.12379 5.16473\n7.84664 4.67693\n4.02776 3.87990\n20\n6.65128 5.47490\n6.42743 6.26189\n6.35864 4.61611\n6.59020 4.54228\n4.43967 5.70059\n4.38226 5.70536\n5.50755 6.18163\n7.41971 6.13668\n6.71936 3.04496\n5.61832 4.23857\n5.99424 4.29328\n5.60961 4.32998\n6.82242 5.79683\n5.44693 3.82724\n6.70906 3.65736\n7.89087 5.68000\n6.23300 4.59530\n5.92401 4.92329\n6.24168 3.81389\n6.22671 3.62210\n0"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<double, double> pt;\nconst double EPS = 1e-4;\n#define x first\n#define y second\n\ndouble sq(double a) { return a * a; }\n\ndouble dist(pt p, pt q) {\n  return sqrt(sq(p.x - q.x) + sq(p.y - q.y));\n}\n\nbool lessthan(double a, double b) {\n    if (a - b <= EPS)\n        return true;\n    return false;\n}\n\npt midpoint(pt a, pt b) {\n    return pt((a.x + b.x)/2, (a.y + b.y)/2);\n}\n\npt operator+(pt a, pt b) {\n    return pt(a.x + b.x, a.y + b.y);\n}\n\npt operator-(pt a, pt b) {\n  return pt(a.x - b.x, a.y - b.y);\n}\n\npt operator*(pt a, double b) {\n    return pt(a.x * b, a.y * b);\n}\n\npt rotate(pt p, double a) {\n  pt res;\n  res.x = p.x * cos(a) - p.y * sin(a);\n  res.y = p.x * sin(a) + p.y * cos(a);\n  return res;\n}\n\n\n\nconst int maxn = 300;\npt pts[maxn + 1];\n\nint main() {\n    int N;\n    \n    cin >> N;\n\n    int maxcount = -1;\n    while (N != 0) {\n        if (maxcount != -1)\n            cout << maxcount << endl;\n        for (int i = 0; i < N; ++i) {\n            double x, y;\n            cin >> x >> y;\n            pts[i] = pt(x, y);\n        }\n        maxcount = 0;\n        for (int i = 0; i < N ; i++){\n            for (int j = 0; j < N; j++) {\n                if (j == i) continue;\n                // for every pair of points\n                if (dist(pts[i], pts[j]) > 2) continue;\n                pt A = pts[i];\n                pt B = pts[j];\n                cout << \"for points \" << A.x << \" \" << A.y << \" b: \" << B.x << \" \"<< B.y << endl;\n                pt M = midpoint(A, B);\n                //cout << \" M is \" << M.x << \" \" << M.y << endl;\n                pt BM = M - B;\n                double distBM = dist(B,M);\n                //cout << \"dist BM \" << distBM << endl; \n                double alpha = acos(distBM);\n                pt BK = rotate(BM, alpha);\n                pt BC = BK * (1 / distBM);\n                pt C = B + BC;\n                cout << \"C is  \"<< C.x << \" \" << C.y << endl;\n                int count = 2;\n                for (int k = 0; k < N; k++) {\n                    if (k == i || k == j) continue;\n                    if (lessthan(dist(C, pts[k]), 1)) count++; \n                }\n                maxcount = max(count, maxcount);\n            }\n        }\n        \n        cin >> N;\n    }\n    cout << maxcount;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define ALL(x) x.begin(), x.end()\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\nusing ll = long long;\nusing lld = long double;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VVL = vector<VL>;\nusing PII = pair<int, int>;\nusing Point = pair<lld, lld>;\nconst lld EPS = 1e-9;\n\nrandom_device rnd;\nmt19937 mt(rnd());\n\nlld dist(Point &a, Point &b)\n{\n    return sqrtl((a.first - b.first) * (a.first - b.first) + (a.second - b.second) * (a.second - b.second));\n}\n\nvoid update(Point &a, Point &center)\n{\n    Point differ = {a.first - center.first,\n                    a.second - center.second};\n    lld d = dist(center, a);\n    differ.first /= d;\n    differ.second /= d;\n    center.first += differ.first * (d - 1.0);\n    center.second += differ.second * (d - 1.0);\n}\n\npair<Point, Point> get_center_of_cirlce(Point &a, Point &b)\n{\n    Point center = {0, 0};\n    while (abs((lld)1.0 - dist(center, a)) > EPS || abs((lld)1.0 - dist(center, b)) > EPS)\n    {\n        update(a, center);\n        update(b, center);\n    }\n    //cerr << fixed << setprecision(18) << center.first << \" \" << center.second << endl;\n    //cerr << fixed << setprecision(18) << dist(center, a) << endl;\n    //cerr << fixed << setprecision(18) << dist(center, b) << endl;\n    Point differ1 = {a.first - center.first,\n                     a.second - center.second};\n    Point differ2 = {b.first - center.first,\n                     b.second - center.second};\n    Point other = {\n        -a.first - b.first + center.first,\n        -a.second - b.second + center.second};\n    return {center, other};\n}\n\nint calc(vector<Point> &v, Point &center)\n{\n    int ret = 0;\n    for (auto &&p : v)\n    {\n        //cerr << fixed << setprecision(18) << dist(p, center) << endl;\n        if (dist(p, center) <= 1.0 + 1e-6)\n        {\n            ret++;\n        }\n        else\n        {\n            //cerr << \"*\" << fixed << setprecision(18) << abs(1.0 - dist(p, center)) << endl;\n        }\n    }\n    return ret;\n}\n\nvoid solve()\n{\n    int n;\n    cin >> n;\n    if (n == 0)\n        exit(0);\n    vector<Point> v(n);\n    int ans = 1;\n    rep(i, n) cin >> v[i].first >> v[i].second;\n    rep(i, n)\n    {\n        rep(j, i + 1, n)\n        {\n            if (dist(v[i], v[j]) > 2.0 + EPS)\n            {\n                continue;\n            }\n            auto ret = get_center_of_cirlce(v[i], v[j]);\n            //cerr << fixed << setprecision(18) << abs(1.0 - dist(v[i], ret.first)) << endl;\n            chmax(ans, calc(v, ret.first));\n            chmax(ans, calc(v, ret.second));\n        }\n    }\n    cout << ans << endl;\n    return;\n}\n\nint main()\n{\n    while (true)\n    {\n        solve();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n#define EPS 1e-8\ntypedef complex<double> P;\n\nP center(P a, P b){\n  P m  = (a+b) / 2.0;    // p[i]Æp[j]Ì_\n  P n = (a-b) * P(0,1);  // @üxNg\n  n = n / abs(n);\n  \n  double x = abs( a-b )/2.0;\n  return m + n * sqrt( 1.0-x*x );     // ~ÌS\n}\n\nint main(){\n  int n;\n  P p[301];\n\n  while( cin>>n && n ){\n    for( int i=0;i<n;i++ )\n      cin >> p[i].real() >> p[i].imag();\n\n    int ans=0;\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ ){\n\tif( i==j ) \t  continue;\n\tif( abs( p[i]-p[j] )+EPS > 2.0 ) continue;\n\tP c = center( p[i],p[j] );\n\n\tint num=0;\n\tfor( int k=0;k<n;k++ )\n\t  if( abs( c-p[k] ) < 1.0 + EPS  )\n\t    num++;\n\tans = max( ans,num );\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1132&lang=jp\n// 解説AC（http://www.deqnotes.net/acmicpc/1981/）\n// ICPC:国内予選2004D\n// Circle and Points\n\n\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<queue>\n\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vector<int> >;\nusing pii = pair<int, int>;\nusing ppi = pair<pii, int>;\nusing pdd = pair<double, double>;\n\ndouble my_dist(pdd a, pdd b){\n  return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int ti = clock();\n  // start-----------------------------------------------\n  int n;\n  while(cin >> n, n){\n    vector<pdd> points(n);\n    for(pdd &i: points) cin >> i.first >> i.second;\n    int ans = 0;\n    for(int i = 0; i < n; i++){\n      for(int j = i+1; j < n; j++){\n        double mid_dist = my_dist(points[i], points[j]);\n        if(mid_dist > 4.0) continue;\n        int cnt = 0; double x, y;\n        pdd mid = {(points[i].first+points[j].first)/2.0, (points[i].second+points[j].second)/2.0};\n        double alpha, beta, a, b, c;\n        alpha = (points[i].second - points[j].second) / (points[j].first - points[i].first);\n        beta = mid.first - alpha * mid.second;\n        a = alpha * alpha + 1.0;\n        b = 2.0 * (alpha * beta - alpha * points[i].first - points[i].second);\n        c = (beta - points[i].first) * (beta - points[i].first) + points[i].second*points[i].second - 1.0;\n        y = (-b + sqrt(b*b - 4 * a * c)) / (2.0 * a);\n        x = alpha * y + beta;\n        for(int k = 0; k < n; k++){\n          if(my_dist({x, y}, points[k]) <= 1.0001) cnt++;\n        }\n        ans = max(ans, cnt);\n        cnt = 0;\n        // x = mid.first - sqrt(c_m_dist/(1.0 + alpha * alpha));\n        // y = mid.second - alpha * sqrt(c_m_dist / (1.0 + alpha * alpha));\n        y = (-b - sqrt(b*b - 4 * a * c)) / (2.0 * a);\n        x = alpha * y + beta;\n        for(int k = 0; k < n; k++){\n          if(my_dist({x, y}, points[k]) <= 1.0001) cnt++;\n        }\n        ans = max(ans, cnt);\n      }\n    }\n    cout << max(1, ans) << endl;\n  }\n  // end-----------------------------------------------\n  // cerr << 1.0 * (clock() - ti) / CLOCKS_PER_SEC << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble Dis(double x1, double y1, double x2, double y2);\nint main(void){\n\twhile(1){\n\t\tint n;\n\t\tint ans = 1;\n\t\tvector< pair<double, double> > p;\n\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tpair<double, double> t;\n\t\t\tcin >> t.first >> t.second;\n\t\t\tp.push_back(t);\n\t\t}\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=i+1; j<n; j++){\n\t\t\t\t//中点\n\t\t\t\tdouble mpx = (p[i].first + p[j].first) / 2.0;\n\t\t\t\tdouble mpy = (p[i].second + p[j].second) / 2.0;\n\t\t\t\t//2点間の距離\n\t\t\t\tdouble d1 = Dis(p[i].first, p[i].second, p[j].first, p[j].second);\n\t\t\t\t//p[i]からp[j]へ向かうベクトル\n\t\t\t\tdouble v1x = (p[j].first - p[i].first) / d1;\n\t\t\t\tdouble v1y = (p[j].second - p[i].second) / d1;\n\t\t\t\t//中点から円の中心へ向かう単位ベクトル\n\t\t\t\tdouble v2x = -v1y;\n\t\t\t\tdouble v2y = v1x;\n\t\t\t\t//中心から円の中心へ向かうベクトルの長さ\n\t\t\t\tdouble d2 = sqrt(1.0 - (d1*d1/4.0));\n\n\t\t\t\t//円の中心の座標\n\t\t\t\tdouble cx = mpx + v2x * d2;\n\t\t\t\tdouble cy = mpy + v2y * d2;\n\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(k == i || k == j || (cx-p[k].first)*(cx-p[k].first) + (cy-p[k].second)*(cy-p[k].second) <= 1.0)\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt > ans){\n\t\t\t\t\tans = cnt;\n\t\t\t\t}\n\n\t\t\t\tcx = mpx - v2x * d2;\n\t\t\t\tcy = mpy - v2y * d2;\n\n\t\t\t\tcnt = 0;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(k == i || k == j || (cx-p[k].first)*(cx-p[k].first) + (cy-p[k].second)*(cy-p[k].second) <= 1.0)\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt > ans){\n\t\t\t\t\tans = cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\n\t}\n\t\n\treturn 0;\n}\n\ndouble Dis(double x1, double y1, double x2, double y2){\n\treturn sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nint INF=1e9;\nint MOD=1000000007;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ndouble EPS = 1e-5;\ndouble add(double a,double b){\n\tif(abs(a+b)<EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,p.x),add(y,-p.y));\n\t}\n\tP operator * (P p){\n\t\treturn P(x*p.x,y*p.y);\n\t}\n};\ndouble dist(P a,P b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\nint cnt(P pos,vector<P> dat){\n\tint res=0;\n\tREP(i,dat.size()){\n\t\tif(dist(pos,dat[i])<=1.0+EPS)res++;\n\t}\n\treturn res;\n}\nint main(){\n\tint n;\n\tdouble x,y;\n\twhile(scanf(\"%d\",&n)&&n){\n\t\tvector<P> dat;\n\t\tREP(i,n){\n\t\t\tcin>>x>>y;\n\t\t\tdat.PB(P(x,y));\n\t\t}\n\t\tint ans=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tP a=dat[i],b=dat[j];\n\t\t\t\tP mid=P((a.x+b.x)/2.0,(a.y+b.y)/2.0);\n\t\t\t\tdouble dx=a.y-b.y,dy=b.x-a.x;\n\t\t\t\tdouble d=dist(a,b);\n\t\t\t\tif(d>2)continue;\n\t\t\t\tdouble dd=sqrt(dx*dx+dy*dy);\n\t\t\t\tdouble ddd=sqrt(1-d*d/4);\n\t\t\t\tdx=dx/dd*ddd;dy=dy/dd*ddd;\n\t\t\t\tans=max(ans,cnt(P(mid.x+dx,mid.y+dy),dat));\n\t\t\t\tans=max(ans,cnt(P(mid.x-dx,mid.y-dy),dat));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#define COS45 0.707107\nusing namespace std;\n\nclass Point {\npublic:\n  double x, y;\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n  Point operator +(Point p) {\n    return Point(x+p.x, y+p.y);\n  }\n  Point operator -(Point p) {\n    return Point(x-p.x, y-p.y);\n  }\n  Point operator *(double a) {\n    return Point(x*a, y*a);\n  }\n  Point operator /(double a) {\n    return Point(x/a, y/a);\n  }\n  bool operator ==(const Point &p) const {\n    return x == p.x && y == p.y;\n  }\n  bool operator <(const Point &p) const {\n    double l1 = x+y;\n    double l2 = p.x+p.y;\n    if(l1 != l2) return l1 < l2;\n    if(y != p.y) return y < p.y;\n    return x < p.x;\n  }\n};\n\ntypedef Point Vector;\n\ndouble norm(Point p1, Point p2) {\n  return (p1.x-p2.x)*(p1.x-p2.x) + (p1.y-p2.y)*(p1.y-p2.y);\n}\n\nint n;\nPoint p[300];\n\nint calc(Point p1, Point p2) {\n  Point m = Point((p1.x+p2.x)/2.0, (p1.y+p2.y)/2.0);\n  Point o;\n  Vector moto = Vector(p2.y-p1.y, p1.x-p2.x);\n  double l = sqrt(4.0/norm(p1,p2)-1)/2.0;\n  int cnt = 0;\n  int newCnt;\n  for(int t = 0; t < 2; t++) {\n    newCnt = 0;\n    if(t == 1) {\n      moto = moto * (-1);\n    }\n    o = m + moto * l;\n\n    for(int i = 0; i < n; i++) {\n      if(p[i].x > o.x + COS45 && p[i].y > o.y + COS45) break;\n      if(newCnt + n-i <= cnt) break;\n      if(p[i] == p1 || p[i] == p2) continue;\n      if((p[i].x-o.x)*(p[i].x-o.x) + (p[i].y-o.y)*(p[i].y-o.y) <= 1.0) {\n\tnewCnt++;\n      }\n    }\n    if(newCnt > cnt) cnt = newCnt;\n  }\n  return cnt + 2;\n}\n\nmain() {\n  while(1) {\n    int ans;\n    cin >> n;\n    if(n == 0) break;\n    for(int i = 0; i < n; i++) {\n      cin >> p[i].x >> p[i].y;\n    }\n    sort(p, &p[n]);\n    ans = -1;\n    for(int i = 0; i < n; i++) {\n      for(int j = i+1; j < n; j++) {\n\tans = max(ans, calc(p[i],p[j]));\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\nconst double PI=3.141592653589793238462643383279;\n\ninline bool inC(P p, P c, double r){return abs(p-c)<r+1e-9;}\n\ninline P getE(P p){return p/abs(p);}\n\ninline double sq(double x){ return  x*x;}\n\nint main(){\n    int n,i,j,k,ans,cnt;\n    double x, y;\n    while(scanf(\"%d\",&n)){\n        if(n==0) break;\n        ans=0;\n        vector<P> ps(n);\n        for(i=0; i<n; i++){\n            scanf(\"%lf%lf\",&x,&y);\n            ps[i] = P(x,y);\n        }\n        for(i=0;i<n;i++)\n            for(j=i+1;j<n;j++)if(abs(ps[i]-ps[j])<2){\n                double d=sqrt(1-sq(abs(ps[j]-ps[i])*0.5));\n                P c1=0.5*(ps[i]+ps[j])+getE(getE(ps[j]-ps[i]))*polar(d,PI/2);\n                P c2=0.5*(ps[i]+ps[j])+getE(getE(ps[j]-ps[i]))*polar(d,-PI/2);\n                cnt=0;\n                for(k=0;k<n;k++)if(inC(ps[k],c1,1.0))cnt++;\n                if(cnt>ans)ans=cnt;\n                cnt=0;\n                for(k=0;k<n;k++)if(inC(ps[k],c2,1.0))cnt++;\n                if(cnt>ans)ans=cnt;\n            }\n        if(ans==0) ans++;\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\ntypedef pair<double, double> PD;\n\nconst double EPS = 1e-11;\ndouble sq(double x) { return x * x; }\n\nvector<PD> solve(double ax, double ay, double bx, double by) {\n  double sqdist = sq(ax - bx) + sq(ay - by);\n  double dist = sqrt(sqdist);\n  double ndist = sqrt(1 - sqdist / 4);\n  double ex = (bx - ax) / dist, ey = (by - ay) / dist;\n  vector<PD> ans(2);\n  REP(i, 0, 2) {\n    double coef = i == 0 ? 1 : -1;\n    ans[i].first = (ax + bx) / 2 + ey * coef * ndist;\n    ans[i].second = (ay + by) / 2 - ex * coef * ndist;\n  }\n  return ans;\n}\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  while(cin >> n && n) {\n    vector<double> x(n), y(n);\n    REP(i, 0, n) cin >> x[i] >> y[i];\n    vector<PD> cand;\n    REP(i, 0, n) {\n      REP(j, 0, i) {\n\tfor (PD e: solve(x[i], y[i], x[j], y[j])) {\n\t  cand.push_back(e);\n\t}\n      }\n    }\n    int ma = 0;\n    for (PD c: cand) {\n      int cnt = 0;\n      REP(i, 0, n) {\n\tdouble sqdist = sq(x[i] - c.first) + sq(y[i] - c.second);\n\tif (sqdist <= 1 + EPS) {\n\t  cnt += 1;\n\t}\n      }\n      ma = max(ma, cnt);\n    }\n    cout << ma << \"\\n\";\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 1000000000\n#define sz(x) ((int)(x).size())\n#define sq(x) ((x)*(x))\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ndouble add(double a,double b){\n\tif(abs(a+b)<eps*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{\n\tdouble x,y;\n\tP() {}\n\tP(double x,double y) : x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tdouble dot(P p){\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tdouble norm(){\n\t\treturn sqrt(x*x+y*y);\n\t}\n\tdouble dist2(P p){\n\t\treturn sq(x-p.x)+sq(y-p.y);\n\t}\n\tP vert(){\n\t\treturn P(y,-x);\n\t}\n\tvoid dump(){\n\t\tprintf(\"%.12f %.12f\\n\",x,y);\n\t\treturn;\n\t}\n};\nint N;\nP pts[305];\nint solve(){\n\tscanf(\"%d\",&N);\n\tif(N==0)return 1;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%lf %lf\",&pts[i].x,&pts[i].y);\n\t}\n\tint ans = 0;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tP m = (pts[i]+pts[j])*0.5;\n\t\t\tP a = (pts[i]-pts[j]);\n\t\t\tdouble na = a.norm();\n\t\t\tif(na>2.0)continue;\n\t\t\ta = (a.vert())*(1/na);\n\t\t\ta = a*(sqrt(1-sq(na/2.0)));\n\t\t\tP b = m+a;\n\t\t\tP c = m-a;\n\t\t\t/*cout << i << ' ' << j << endl;\n\t\t\tm.dump();\n\t\t\ta.dump();\n\t\t\tb.dump();\n\t\t\tc.dump();\n\t\t\tcout << endl;*/\n\t\t\tint cnt = 0;\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t//printf(\"%d:%.12f\\n\",k,pts[k].dist2(b));\n\t\t\t\tif(pts[k].dist2(b)<=1.0+eps)cnt++;\n\t\t\t}\n\t\t\tans = max(ans,cnt);\n\t\t\tcnt = 0;\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t//printf(\"%d:%.12f\\n\",k,pts[k].dist2(c));\n\t\t\t\tif(pts[k].dist2(c)<=1.0+eps)cnt++;\n\t\t\t}\n\t\t\tans = max(ans,cnt);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\nint main(){\n\twhile(!solve()){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\n// #define double long double\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-6;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nP readP() {\n    double x, y;\n    cin >> x >> y;\n    return P(x, y);\n}\n\n// rot p around q by theta (counter-clockwise)\nP rotP(P p, P q, double theta) {\n    p -= q;\n    double x = p.real(), y = p.imag();\n    p = P(x * cos(theta) - y * sin(theta), x * sin(theta) + y * cos(theta));\n    p += q;\n    return p;\n}\n\nP center(P p, P q) {\n//     P v = q - p;\n//     double theta = asin(abs(v) / 2);\n//     v *= (1 / abs(v));\n//     P u = rotP(v, p, theta);\n//     return p + u;\n\n    P v = q - p;\n    P h = v * P(0., 1.) / abs(v);\n    return p + (v / 2.) + h;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    while (cin >> n, n) {\n        vector<P> p(n);\n        rep(i, n) p[i] = readP();\n\n        int ans = 1;\n        rep(i, n) {\n            rep(j, n) {\n                if (i == j) continue;\n                if (norm(p[i] - p[j]) > 4. + EPS) continue;\n                P c = center(p[i], p[j]);\n                int cnt = 2;\n                rep(k, n) {\n                    if (k == i || k == j) continue;\n                    if (norm(p[k] - c) < 1. + EPS) {\n                        cnt++;\n                    }\n                }\n                ans = max(ans, cnt);\n            }\n        }\n\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<iomanip>\nusing namespace std;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nstatic const int MAX_N = 300;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point{\n\tpublic:\n\t\tdouble x, y;\n\n\t\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\n\t\tPoint operator + (Point p){ return Point(x + p.x, y + p.y);}\n\t\tPoint operator - (Point p){ return Point(x - p.x, y - p.y);}\n\t\tPoint operator * (double a){ return Point(a * x, a * y);}\n\t\tPoint operator / (double a){ return Point(x / a, y / a);}\n\n\t\tdouble abs(){ return sqrt(norm());}\n\t\tdouble norm(){ return x * x + y * y;}\n\n\t\tbool operator < (const Point &p) const{\n\t\t\treturn x != p.x ? x < p.x : y < p.y;\n\t\t}\n\n\t\tbool operator == (const Point &p) const{\n\t\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t\t}\n};\n\nstruct Segment {\n\tPoint p1, p2;\n};\ntypedef Segment Line;\n\nclass Circle{\n\tpublic:\n\t\tPoint c;\n\t\tdouble r;\n\t\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b){\n\treturn a.x * b.x + a.y * b.y;\n}\ndouble cross(Vector a, Vector b){\n\treturn a.x * b.y - a.y * b.x;\n}\n\nPoint project(Segment s, Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif(cross(a, b) < -EPS) return CLOCKWISE;\n\tif(dot(a, b) < -EPS) return ONLINE_BACK;\n\tif(a.norm() < b.norm()) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nPoint getCrossPoint(Segment s1, Segment s2){\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\ndouble getDistance(Point a, Point b){\n\treturn (a - b).abs();\n}\n\ndouble arg(Vector p){return atan2(p.y, p.x);}\nVector polar(double a, double r){return Point(cos(r) * a, sin(r) * a);}\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\nbool comp(const Point &p1, const Point &p2){\n\treturn equals(p1.x, p2.x) ? (p1.y < p2.y) : (p1.x < p2.x);\n}\nint main(){\n\tint N;\n\tfor(;;){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\tPoint xy[MAX_N];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> xy[i].x >> xy[i].y;\n\t\t}\n\t\tsort(xy, xy + N, comp);\n\t\tint ans = 1;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = i + 1; j < N; j++){\n\t\t\t\tif(fabs(xy[i].x - xy[j].x) > 2.0) break;\n\t\t\t\tif(getDistance(xy[i], xy[j]) < 2.0) ans = max(ans, 2);\n\t\t\t\tpair<Point, Point> pp = getCrossPoints((Circle){xy[i], 20.0}, (Circle){xy[j], 20.0});\n\t\t\t\tfor(int k = j + 1; k < N; k++){\n\t\t\t\t\tpair<Point, Point> pp2 = getCrossPoints((Circle){xy[i], 20.0}, (Circle){xy[k], 20.0});\n\t\t\t\t\tPoint c = getCrossPoint((Line){pp.first, pp.second}, (Line){pp2.first, pp2.second});\n\t\t\t\t\tdouble r = getDistance(c, xy[i]);\n\t\t\t\t\tif(r > 1.0) continue;\n\t\t\t\t\tint cnt = 3;\n\t\t\t\t\tfor(int l = 0; l < N; l++){\n\t\t\t\t\t\tif(l == i || l == j || l == k) continue;\n\t\t\t\t\t\tif(xy[l].x > c.x && getDistance(xy[l], c) > r) break;\n\t\t\t\t\t\tif(getDistance(c, xy[l]) < r) cnt++;\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans, cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n//eÍÍÌë·\n//1 * 10^(-5)\n#define EPS (1e-8)\n\nint n;\npair<double, double> p[301];\n\nint main() {\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> p[i].first >> p[i].second;\n\t\t}\n\t\tint maxPoints = 1;\n\t\t//2_ð~üãÉÂ~ðè\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdouble d = hypot(p[i].first - p[j].first, p[i].second - p[j].second);\n\t\t\t\tif (d > 2.0 + EPS) continue;\t//£ê·¬\n\t\t\t\t\n\t\t\t\t//_(»ê¼êÌÀWÌ½Ï)\n\t\t\t\tpair<double, double> m((p[i].first + p[j].first) / 2.0, (p[i].second + p[j].second) / 2.0);\n\t\t\t\t//PÊ@üxNg\n\t\t\t\t//\t@üxNgÌX«Íüªp[i]p[j]Æ|¯Ä-1C·Èí¿\n\t\t\t\t//\t\tv = (p[j].second - p[i].second, p[j].first - p[i].first)\n\t\t\t\t//\t±êÌ·³Ívx^2 + vy^2 = d^2\n\t\t\t\t//\tæÁÄPÊxNgÉ·éÉÍ\n\t\t\t\t//\t\t(vx/d)^2 + (vy/d)^2 = 1\n\t\t\t\tpair<double, double> ve((p[j].second - p[i].second) / d, (p[j].first - p[i].first) / d);\n\t\t\t\t//_©çSÜÅÌ£\n\t\t\t\tdouble l = sqrt(1.0 - d * d / 4.0);\n\t\t\t\t\n\t\t\t\t//_2Â©çèÜé~Í2Â\n\t\t\t\tfor (int s = -1; s < 2; s += 2) {//\n\t\t\t\t\tpair<double, double> c(m.first + s * l * ve.first, m.second - s * l * ve.second);\n\t\t\t\t\tint count = 2;\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tif (k==i || k==j) continue;//¯êÌ_ÍÜßÈ¢\n\t\t\t\t\t\tif (hypot(c.first - p[k].first, c.second - p[k].second) < 1.0 + EPS) count++;\n\t\t\t\t\t}\n\t\t\t\t\tmaxPoints = max(maxPoints, count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << maxPoints << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1); // cos(pi) = -1\nconst double eps = 1e-9;\nstruct point{\n    double x, y;\n    point(double _x = 0,double _y=0){\n        x=_x;\n        y=_y;\n    }\n};\ndouble dist(point a,point b){\n    return sqrt((a.x-b.x) * (a.x-b.x)\n              + (a.y-b.y) * (a.y-b.y));\n}\npoint a[305];\nconst double r = 1;\nint solve(int n){\n    for(int i=1;i<=n;i++)   cin >> a[i].x >> a[i].y;\n\n    int answer = 1;\n\n    for(int i=1;i<=n;i++){\n        vector < pair<double, double> > lst;\n\n        for(int j=1;j<=n;j++){\n            if (dist(a[i], a[j]) > r * 2)   continue;\n            if (i == j) continue;\n\n            double alpha = atan2(a[j].y - a[i].y,\n                                 a[j].x - a[i].x);\n\n            if (alpha < 0)  alpha += pi * 2;\n\n            double beta = acos(dist(a[i], a[j]) / 2 / r);\n\n            double goc1 = alpha + beta;\n            double goc2 = alpha - beta;\n            if (goc1 > goc2)    swap(goc1, goc2);\n\n            if (goc1 < 0)\n                lst.push_back({0, goc2}),\n                lst.push_back({goc1 + pi*2, pi*2});\n            else if (goc2 > pi * 2)\n                lst.push_back({0, goc2 - pi*2}),\n                lst.push_back({goc1, pi*2});\n            else\n                lst.push_back({goc1, goc2});\n        }\n        vector <pair<double,int> > query;\n\n        for(auto v: lst)\n            query.push_back({v.first, 1}),\n            query.push_back({v.second + eps, -1}),\n\n        sort(query.begin(), query.end());\n\n        int current = 1;\n        for(auto v: query){\n            current += v.second;\n            answer = max(answer, current);\n        }\n    }\n    return answer;\n}\n\nint main(){\n    int n;\n    while (cin >> n){\n        if (!n) break;\n        cout << solve(n) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define mp            make_pair\n#define pb            push_back\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nconst int    INF = 1000000000;\nconst ll     MOD = 1000000007LL;\nconst double EPS = 1E-12;\n\ntemplate<typename T> T add(T x, T y){ if(abs(x+y) < EPS*(abs(x)+abs(y))) return 0; return x + y; }\ntemplate<typename T> inline bool semieq(T x, T y){ return abs(x - y) < EPS; }\ntemplate<typename T> inline bool semige(T x, T y){ return y - x < -EPS; }\ntemplate<typename T> inline bool semile(T x, T y){ return x - y < -EPS; }\n\n\nstruct Point : public complex<double>\n{\npublic:\n  Point() { this->real(0);  this->imag(0); }\n  Point(const double& x, const double& y) { this->real(x);  this->imag(y); }\n  Point(const complex<double> w)  { this->real(w.real());  this->imag(w.imag()); }\n  inline double dot(Point p){ return (conj(*this) * p).real(); }  // ??????\n  inline double det(Point p){ return (conj(*this) * p).imag(); }  // ??????\n};\n\nnamespace std\n{\n  inline bool operator < (const Point& a, const Point& b)\n  {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ntypedef vector<Point> Polygon;\ninline Point currPoint(vector<Point> P, int i){ return P[i]; }\ninline Point nextPoint(vector<Point> P, int i){ return P[(i+1)%P.size()]; }\ninline Point diffPoint(vector<Point> P, int i){ return nextPoint(P, i) - currPoint(P, i); }\n\n\nstruct Circle : Point\n{\nprivate:\n  Point p;\n  double r;\n\npublic:\n  Circle(Point p, double r) : p(p), r(r) {}\n  Circle(double x, double y, double r) : p(Point(x, y)), r(r) {}\n  inline Point center(){ return this->p; }\n  inline double radius(){ return this->r; }\n};\n\nint intersectionDeterminationOfCC(Circle A, Circle B)\n{\n  double d = abs(A.center() - B.center());\n  if(semile(d, A.radius() - B.radius())) return  1;  // B in A\n  if(semile(d, B.radius() - A.radius())) return -1;  // A in B\n  if(semieq(d, A.radius() - B.radius())) return  2;  // B in A????????\\???\n  if(semieq(d, B.radius() - A.radius())) return -2;  // A in B????????\\???\n  if(semige(d, A.radius() + B.radius())) return  3;  // ???????????????\n  if(semieq(d, A.radius() + B.radius())) return -3;  // ?????\\\n  return 4;  // ????????£?????????\n}\n\n// ???????????????????¨±??????????????????????????????????????¨????????????????¨???????????????????\nvector<Point> intersectionOfCC(Circle A, Circle B)\n{\n  vector<Point> ret(2);\n  double x1 = A.center().real(), y1 = A.center().imag(), r1 = A.radius();\n  double x2 = B.center().real(), y2 = B.center().imag(), r2 = B.radius();\n  double dx = x2 - x1;\n  double dy = y2 - y1;\n  double a = dx * dx + dy * dy;\n  double b = ((r1 * r1 - r2 * r2) / a + 1) / 2;\n  double d = r1 * r1 / a - b * b;\n  double x3 = x1 + dx * b;\n  double y3 = y1 + dy * b;\n  double x4 = -dy * sqrt(d);\n  double y4 =  dx * sqrt(d);\n  ret[0] = Point(x3 - x4, y3 - y4);\n  ret[1] = Point(x3 + x4, y3 + y4);\n  return ret;\n}\n\nconst double r = 1.0;\nint N;\ndouble x, y;\n\nint main()\n{\n  while((cin >> N) && N){\n    vector<Point> P;\n\n    rep(i, N){\n      cin >> x >> y;\n      P.pb(Point(x, y));\n    }\n\n    int res = 1;\n    rep(i, N) rep(j, i) if(!semige(abs(P[i] - P[j]), 2.0 * r)){\n      Circle A = Circle(P[i], r);\n      Circle B = Circle(P[j], r);\n      vector<Point> PP = intersectionOfCC(A, B);\n\n      vrep(v, PP){\n        int cnt = 0;\n        vrep(w, P) if(!semige(abs(*w - *v), r)) cnt += 1;\n        maxup(res, cnt);\n      }\n    }\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\nstruct makehtml{\n\tvector<string> ss;\n\t\n\tmakehtml(){}\n\t/*\n\tctx.beginPath()\n\tctx.moveTo(50.000000,100.000000);\n\tctx.lineTo(150.000000,100.000000);\n\tctx.stroke();\n\t\n\tctx.fillStyle = \"rgb(0,0,0)\";\n\t\n\tctx.beginPath();\n\tctx.arc(168,59,3,0,360);\n\tctx.fill();\n\n\t*/\n\t\n\tvoid out(const char* name,double mag){\n\t\tchar fname[100];\n\t\tsprintf(fname,\"%s.html\",name);\n\t\tFILE* fp = fopen(fname,\"w\");\n\t\tif(fp==NULL){\n\t\t\teprintf(\"can't open %s\\b\",fname);\n\t\t\texit(-1);\n\t\t}\n\t\tfprintf(fp,\"<html>\\n<head>\\n<title>\");\n\t\tfprintf(fp,\"%s\",name);\n\t\tfprintf(fp,\"</title>\\n</head>\\n<body>\\n\");\n\t\tfprintf(fp,\"<p>name: %s</p>\",name);\n\t\tfprintf(fp,\"<canvas id=\\\"vis\\\" width=\\\"%d\\\" height=\\\"%d\\\"></canvas>\",2000,2000);\n\t\tfprintf(fp,\"<script>\\n\");\n\t\tfprintf(fp,\"var vis = document.getElementById('vis');\\nvar ctx = vis.getContext('2d');\\n\");\n\t\t\n\t\trep(i,ss.size()){\n\t\t\tfprintf(fp,\"%s\\n\",ss[i].c_str());\n\t\t}\n\t\t\n\t\tfprintf(fp,\"</script>\\n\");\n\t\tfprintf(fp,\"</body>\\n</html>\\n\");\n\t\tfclose(fp);\n\t}\n\n} makehtml_instance;\n\n\nvoid addhtml(string s){\n\tmakehtml_instance.ss.push_back(s);\n}\n\nvoid outhtml(string s,double mag){\n\tmakehtml_instance.out(s.c_str(),mag);\n}\n\nvoid randcolhtml(){\n\tchar ns[100];\n\tsprintf(ns,\"ctx.fillStyle = \\\"rgb(%d,%d,%d)\\\";\",rand()%128,rand()%128,rand()%128);\n\taddhtml(ns);\n\tsprintf(ns,\"ctx.strokeStyle = \\\"rgb(%d,%d,%d)\\\";\",rand()%128,rand()%128,rand()%128);\n\taddhtml(ns);\n}\n\nvoid inithtml(){\n\tmakehtml_instance.ss.clear();\n}\n\n\nconst double pi=3.14159265358979;\n\nstruct pos{\n\tdouble x,y;\n\tdouble norm,norm2;\n\tpos tov(pos a){\n\t\treturn (a-(*this));\n\t}\n\tpos operator+(pos a)const{\n\t\tpos res=a;\n\t\tres.x+=x; res.y+=y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos operator-(pos a)const{\n\t\tpos res=(*this);\n\t\tres.x-=a.x; res.y-=a.y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos scalar(double a){\n\t\tpos res=(*this);\n\t\tres.x*=a; res.y*=a;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tdouble dot(pos a){\n\t\treturn x*a.x + y*a.y;\n\t}\n\tdouble cross(pos a){\n\t\treturn x*a.y - y*a.x;\n\t}\n\tdouble theta(pos a){\n\t\tdouble nt=dot(a)/(norm*a.norm);\n\t\tnt=acos(max(-1.0,min(1.0,nt)));\n\t\tdouble ns=(cross(a)/(norm*a.norm));\n\t\tif(ns<0)nt*=-1;\n\t\treturn nt;\n\t}\n\tpos(double ix,double iy){\n\t\tx=ix; y=iy;\n\t\tnorm2=x*x+y*y;\n\t\tnorm=sqrt(norm2);\n\t}\n\tpos(){}\n\tstring str(){\n\t\tchar ns[50];\n\t\tsprintf(ns,\"(%lf %lf)\",x,y);\n\t\treturn\tstring(ns);\n\t}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\"); \n\t\tsprintf(ns,\"ctx.arc(%lf,%lf,%lf,0,360);\",x*mag,y*mag,5.0); addhtml(ns);\n\t\taddhtml(\"ctx.fill();\");\n\t}\n\tstatic pos polar(double r,double t){\n\t\treturn pos(r*cos(t),r*sin(t));\n\t}\n\tpos turn(double t){\n\t\t//t[rad]??????\n\t\treturn pos(x*cos(t)-y*sin(t),x*sin(t)+y*cos(t));\n\t}\n\tpos tolen(double a){\n\t\t//?????????a?????????\n\t\treturn this->scalar(a/norm);\n\t}\n\tbool  operator<(pos a) const{\n\t\t//if(x!=a.x)return (x<a.x);\n\t\t//return (y<a.y);\n\t\tif(y!=a.y)return (y<a.y);\n\t\treturn (x<a.x);\n\t}\t\n\tbool operator>(pos a)const{ return (a<(*this)); }\t\n};\nstruct line{\n\tpos p,q;\n\tpos vec;\n\tstring str(){\n\t\treturn (\"(\"+p.str()+\"-\"+q.str()+\")\");\n\t}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\");\n\t\tsprintf(ns,\"ctx.moveTo(%lf,%lf);\",p.x*mag,p.y*mag); addhtml(ns);\n\t\tsprintf(ns,\"ctx.lineTo(%lf,%lf);\",q.x*mag,q.y*mag); addhtml(ns);\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\tbool iscross(line a){\n\t\tdouble da,db;\n\t\tda=vec.cross( p.tov(a.p) );\n\t\tdb=vec.cross( p.tov(a.q) );\n\t\tif(da*db>=0)return false;\n\t\tda=a.vec.cross( a.p.tov(p) );\n\t\tdb=a.vec.cross( a.p.tov(q) );\n\t\treturn (da*db<0);\n\t}\n\tline(pos ip,pos iq){\n\t\tp=ip; q=iq;\n\t\tvec=p.tov(q);\n\t}\n\tline(){}\n\tdouble dist(pos a){\n\t\tif(p.tov(a).dot( p.tov(q) )<0)return p.tov(a).norm;\n\t\tif(q.tov(a).dot( q.tov(p) )<0)return q.tov(a).norm;\n\t\treturn abs(vec.cross(p.tov(a))/vec.norm);\n\t}\n\tdouble dist(line a){\n\t\tif(iscross(a))return 0;\n\t\treturn min( min(dist(a.p),dist(a.q)) , min(a.dist(this->p),a.dist(this->q)));\n\t}\n\tpos crosspos(line a){\n\t\t/*\n\t\tdouble d1=a.vec.cross(a.p.tov(p))/a.vec.norm;\n\t\tdouble d2=a.vec.cross(a.p.tov(q))/a.vec.norm;\n\t\tbool isc=(d1*d2<0);\n\t\td1=abs(d1); d2=abs(d2);\n\t\tdouble sc;\n\t\tif(!isc){\n\t\t\tif(d1>d2)sc = d1/(d1-d2);\n\t\t\telse sc=d1/(d2-d1);\n\t\t}\n\t\telse sc = d1/(d1+d2);\n\t\treturn (p+vec.scalar(sc));*/\n\t\t\n\t\tdouble t = a.vec.cross(a.p-p)/a.vec.cross(vec);\n\t\treturn (p+vec.scalar(t));\n\t}\n\tline bisection(){//?????´????????????\n\t\t//???????¨??????????90????????£???????????????\n\t\tpos fr=(p+q).scalar(0.5);\n\t\tpos to=fr+pos(-vec.y,vec.x);\n\t\treturn line(fr,to);\n\t}\n};\ndouble lowofcos_getcos(double a,double b,double c){\n\treturn ((a*a+b*b-c*c)/(2*a*b));\n}\nstruct circle{\n\tpos p;\n\tdouble r;\n\tline koten(circle a){\n\t\tpos cv=p.tov(a.p);\n\t\tdouble br=atan2(cv.y,cv.x);\n\t\tdouble dr=acos(lowofcos_getcos( r, cv.norm, a.r));\n\t\tpos p1= p+pos::polar(r,br+dr);\n\t\tpos p2= p+pos::polar(r,br-dr);\n\t\tif(p1>p2)swap(p1,p2);\n\t\treturn line(p1,p2);\n\t}\n\tcircle(pos ip,double ir){\n\t\tp=ip; r=ir;\n\t}\n\tcircle(){}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\"); \n\t\tsprintf(ns,\"ctx.arc(%lf,%lf,%lf,0,360);\",p.x*mag,p.y*mag,r*mag); addhtml(ns);\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\t\n\tvector<line> tangs(circle a){ //??\\?????????\n\t\t//validate AOJ 2201\n\t\tcircle b(*this);\n\t\tif(a.r<b.r)swap(a,b);\n\t\tvector<line> res;\n\t\tif((a.p-b.p).norm-(a.r-b.r)<0.0)return res;\n\t\tif((a.p-b.p).norm-(a.r-b.r)<1e-6){\n\t\t\tif((b.p-a.p).norm<1e-6)return res; //??¨???????????????\n\t\t\tpos rv=(b.p-a.p).tolen(a.r);\n\t\t\tres.push_back(line(rv+a.p,rv+a.p+rv.turn(pi/2.0)));\n\t\t\treturn res;\n\t\t}\n\t\t{\n\t\t\tpos cv=b.p-a.p;\n\t\t\tdouble th=acos((a.r-b.r)/cv.norm);\n\t\t\tpos p1 = cv.turn(th);\n\t\t\tres.push_back(line(a.p+p1.tolen(a.r),b.p+p1.tolen(b.r)));\n\t\t\tpos p2 = cv.turn(-th);\n\t\t\tres.push_back(line(a.p+p2.tolen(a.r),b.p+p2.tolen(b.r)));\n\t\t}\n\t\tif((a.p-b.p).norm-(a.r+b.r)<0.0)return res;\n\t\tif((a.p-b.p).norm-(a.r+b.r)<1e-6){\n\t\t\tpos rv=(b.p-a.p).tolen(a.r);\n\t\t\tres.push_back(line(rv+a.p,rv+a.p+rv.turn(pi/2.0)));\n\t\t\treturn res;\n\t\t}\n\t\t{\n\t\t\tpos cv=b.p-a.p;\n\t\t\tdouble th=acos((a.r+b.r)/cv.norm);\n\t\t\tpos p1 = cv.turn(th);\n\t\t\tres.push_back(line(a.p+p1.tolen(a.r),b.p+p1.tolen(-b.r)));\n\t\t\tpos p2 = cv.turn(-th);\n\t\t\tres.push_back(line(a.p+p2.tolen(a.r),b.p+p2.tolen(-b.r)));\n\t\t}\n\t\treturn res;\n\t}\n};\n\nstruct polygon{\n\tvector<pos> ps;\n\tpolygon(){}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\");\n\t\tint ls=ps.size();\n\t\tsprintf(ns,\"ctx.moveTo(%lf,%lf);\",ps[ls-1].x*mag,ps[ls-1].y*mag); addhtml(ns);\n\t\trep(i,ps.size()){\n\t\t\tsprintf(ns,\"ctx.lineTo(%lf,%lf);\",ps[i].x*mag,ps[i].y*mag); addhtml(ns);\n\t\t}\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\tdouble area(){\n\t\tdouble res=0;\n\t\trep(i,ps.size()){\n\t\t\tpos no=ps[i],to=ps[(i+1)%ps.size()];\n\t\t\tres+=(no.x+to.x)*(no.y-to.y);\n\t\t}\n\t\tif(res<0)reverse(ps.begin(),ps.end());\n\t\treturn abs(res)/2;\n\t}\n\tpolygon(pos a,pos b){\n\t\tps.push_back(a);\n\t\tps.push_back(pos(a.x,b.y));\n\t\tps.push_back(b);\n\t\tps.push_back(pos(b.x,a.y));\n\t}\n\tline gete(int a){\n\t\ta%=ps.size();\n\t\treturn line(ps[a],ps[(a+1)%ps.size()]);\n\t}\n\tint isin(pos a){//?????´??????2,?????£????????????1,?????????0\n\t\tdouble as=0;\n\t\trep(i,ps.size()){\n\t\t\tline ne=gete(i);\n\t\t\tif(ne.dist(a)<=0)return 1;\n\t\t\tpos v1=a.tov(ne.p);\n\t\t\tpos v2=a.tov(ne.q);\n\t\t\tas+=v1.theta(v2);\n\t\t}\n\t\tif(abs(as)<1e-6)return 0;\n\t\treturn 2;\n\t}\n\tpolygon convex_full(){\n\t\tpolygon res;\n\t\tint ns=ps.size();\n\t\tvector<pos> vs(2*ns);\n\t\tsort(ps.begin(),ps.end());\n\t\tint k=0;\n\t\trep(i,ns){\n\t\t\tpos np=ps[i];\n\t\t\twhile(k>1 && vs[k-2].tov(vs[k-1]).cross(vs[k-1].tov(np))<-1e-6)k--;\n\t\t\tvs[k]=np; k++;\n\t\t}\n\t\tint t=k;\n\t\tireg(i,0,ns-2){\n\t\t\tpos np=ps[i];\n\t\t\twhile(k>t && vs[k-2].tov(vs[k-1]).cross(vs[k-1].tov(np))<-1e-6)k--;\n\t\t\tvs[k]=np; k++;\n\t\t}\n\t\tvs.resize(k-1);\n\t\tswap(vs,res.ps);\n\t\treturn res;\n\t}\n\tpolygon cut(line a){//???????????????????????????\n\t\tpolygon res;\n\t\trep(i,ps.size()){\n\t\t\tline ne=gete(i);\n\t\t\tdouble d1=a.vec.cross(a.p.tov(ne.p));\n\t\t\tdouble d2=a.vec.cross(a.p.tov(ne.q));\n\t\t\tif(d1<1e-6)res.ps.push_back(ne.p); //?????£????????£???eps\n\t\t\tif(d1*d2<-1e-6)res.ps.push_back(a.crosspos(ne)); //?????£????????????eps\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvector<polygon> voronoi(vector<pos> ps){\n\t\t//validate AOJ 2160\n\t\tvector<polygon> res;\n\t\trep(i,ps.size()){\n\t\t\tpolygon np(*this);\n\t\t\trep(j,ps.size()){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tline nl = line(ps[j],ps[i]).bisection();\n\t\t\t\t\n\t\t\t\tnp = np.cut(nl);\n\t\t\t}\n\t\t\tres.push_back(np);\n\t\t}\n\t\treturn res;\t\t\n\t}\n\tpolygon mult(polygon a){\n\t\treturn a;\n\t}\n};\n\nint n;\nint main(void){\n\tfor(;;){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tvector<pos> ps;\n\t\trep(i,n){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf%lf\",&x,&y);\n\t\t\tps.push_back(pos(x,y));\n\t\t}\n\t\t\n\t\t//inithtml();\n\t\tvector<pos> cs;\n\t\trep(i,n){\n\t\t\t//ps[i].outh(100);\n\t\t\trep(j,i){\n\t\t\t\tline nl(ps[i],ps[j]);\n\t\t\t\tdouble d = nl.vec.norm;\n\t\t\t\tif(d>2.0)continue;\n\t\t\t\tpos av = nl.bisection().vec.tolen(sqrt(1.0-(d/2)*(d/2)));\n\t\t\t\tpos m=(ps[i]+ps[j]).scalar(0.5);\n\t\t\t\tcs.push_back(m+av);\n\t\t\t\tcs.push_back(m-av);\n\t\t\t\t//printf(\"%lf %lf\\n\",(m+av-ps[i]).norm,(m-av-ps[i]).norm);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\trep(i,cs.size()){\n\t\t\t//cs[i].outh(100);\n\t\t\t//circle c(cs[i],1.0);\n\t\t\t//c.outh(100);\n\t\t\t//printf(\"%s\\n\",cs[i].str().c_str());\n\t\t\tint ns=0;\n\t\t\trep(j,ps.size()){\n\t\t\t\tif((cs[i]-ps[j]).norm<=1.0)ns++;\n\t\t\t}\n\t\t\tans=max(ans,ns);\n\t\t}\n\t\t//outhtml(\"o\",100);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <complex>\n\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,n) loop(i,0,n)\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef complex<double> vec;\n\ndouble const pi = acos(-1);\ndouble const eps = 1e-6;\n\nint main(){\n    int n;\n    while (cin >> n && n){\n        vector<vec> v(n);\n        rep(i, n){\n            double x, y; cin >> x >> y;\n            vec p(x, y);\n            v[i] = p;\n        }\n\n        if (n == 1) {\n            puts(\"1\");\n            continue;\n        }\n        int ans = 1;\n        rep(i, n)rep(j, i){\n            double d = abs(v[i] - v[j]);\n            if (d > 2) continue;\n            ans = max(ans, 2);\n            double h = 1 - d*d / 4;\n            vec c1 = polar(h, arg(v[i] - v[j]) + pi / 2) + (v[i] + v[j]) / 2.;\n            vec c2 = polar(h, arg(v[i] - v[j]) - pi / 2) + (v[i] + v[j]) / 2.;\n            int a1 = 0, a2 = 0;\n            rep(k, n){\n                if (abs(c1 - v[k]) <= 1) a1++;\n                if (abs(c2 - v[k]) <= 1) a2++;\n            }\n            ans = max(ans, a1);\n            ans = max(ans, a2);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={-1,0,1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-15;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef pair<int,Pii> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x = _x;\n        y = _y;\n    }\n    Point operator + (Point p){\n        return Point(x+p.x,y+p.y);\n    }\n  \n    Point operator - (Point p){\n        return Point(x-p.x,y-p.y);\n    }\n  \n    Point operator * (double k){\n        return Point(k*x,k*y);\n    }\n     \n    Point operator * (Point p){\n        return Point(p.x*x-p.y*y,p.x*y+p.y*x);\n    }\n\n    Point operator / (double k){\n        return Point(x/k,y/k);\n    }\n \t\n    Point operator = (Point p){\n    \tx = p.x;\n    \ty = p.y;\n    \treturn *this;\n    }\n\n    bool operator<(const Point &p)const{\n        return x!=p.x?x<p.x:y<p.y;\n    }\n\n};\ndouble dot(Point p, Point q){\n    return p.x*q.x+p.y*q.y;\n}\n  \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n  \ndouble norm(Point p){\n\t//ベクトルの大きさの2乗\n    return p.x*p.x+p.y*p.y;\n}\n  \ndouble pabs(Point p){\n\t//ベクトルの大きさ\n    return sqrt(norm(p));\n}\nPoint UnitVector(Point a){\n\t//単位ベクトル\n\treturn a/pabs(a);\n}\ntypedef vector<Point> Polygon;\nstruct Line : Polygon{\n    Line(){}\n    Line(Point p,Point q){\n        PB(p);\n        PB(q);  \n    }\n};\nstruct Circle{\n    Point p; //中心点\n    double r; //半径\n    Circle(){}\n    Circle(Point _p,double _r){\n        p = _p;\n        r = _r;\n    }\n};\nint ccw(Point a,Point b,Point c){\n    b = b-a;\n    c = c-a;\n    if(cross(b,c) > 0)return +1; //a→b で反時計に折れてc ccw\n    if(cross(b,c) < 0)return -1; //a→b で時計に折れてc ccw\n    if(dot(b,c) < 0)return +2; // c--a--b;\n    if(pabs(b)<pabs(c))return -2; //a--b--c\n    return 0; //a--c--b\n}\nbool intersectSS(Line l,Line m){\n    //lとmが交差してるかどうか\n    return (ccw(l[0],l[1],m[0])*ccw(l[0],l[1],m[1])<EPS)&&\n            (ccw(m[0],m[1],l[0])*ccw(m[0],m[1],l[1])<EPS);\n}\n\nbool intersectSP(Line l, Point p){\n\t//線分lと点pが交差してるか\n\treturn !ccw(l[0],l[1],p);\n}\n\nbool intersectLL(Line l,Line m){\n\treturn fabs(cross(l[1]-l[0],m[1]-m[0])) > EPS || //平行でない\n\t\t\tfabs(cross(l[1]-l[0],m[0]-l[0])) < EPS; //同一の線\n}\n\nint intercectCC(Circle a,Circle b,Point *p,Point *q){\n\tdouble dist = pabs(a.p-b.p);\n\tif(dist < fabs(a.r-b.r) || dist > a.r+b.r){\n\t\t//円の中心が一致しているとき\n\t\t//円の交点が存在しないとき\n\t\t*p = Point(1e15,1e15);\n\t\t*q = Point(1e15,1e15);\n\t\treturn 0;\n\t}\n\telse if(fabs(dist-a.r-b.r) < EPS){\n\t\t//円が1点で交わっているとき\n\t\tPoint way;\n\t\tway = b.p-a.p;\n\t\t*p = a.p+UnitVector(way)*a.r;\n\t\t*q = *p;\n\t\treturn 1;\n\t}\n\telse{\n\t\t//円が2点で交わっているとき\n        if(a.r < b.r){\n            swap(a.r,b.r);\n            swap(a.p,b.p);\n        }\n        double s = (a.r + b.r + dist) / 2.0 ;\n        double area = sqrt(s * (s - a.r) * (s - b.r) * (s - dist));\n        double h = 2.0 * area / dist;\n\n        Point  v = b.p-a.p;\n        v = UnitVector(v);\n        Point  m = a.p + (v*sqrt(a.r*a.r-h*h));\n        Point  n = v * Point(0.0,1.0);\n        \n        *p = m + (n * h);\n        *q = m - (n * h);\n        return 2;\n\t}\n}\n\ndouble TriangleArea(Point a,Point b,Point c){\n    b = b - a;\n    c = c - a;\n    return cross(b,c)*0.5; //負になることもあるので注意\n}\n \ndouble VertexArea(Polygon v){\n    double subArea = 0.0;\n    rep(i,v.size()-1){\n        subArea += TriangleArea(v[0],v[i],v[i+1]);\n    }\n    return subArea; //負になることもあるので注意\n}\n\nPoint crosspoint(Line l,Line m){\n\t//線分lと線分mの交点\n    if(intersectSS(l,m) == false)return Point(INF,INF);\n    return m[0]+(m[1]-m[0])*cross(l[1]-l[0],l[1]-m[0])/cross(l[1]-l[0],m[1]-m[0]);\n}\n \nPolygon ConvexHull(Polygon v){\n\tint n = v.size();\n\tint k = 0;\n\tsort(v.begin(),v.end());\n\tPolygon e(2*n);\n\tfor(int i=0;i<n;e[k++]=v[i++])\n\t\twhile(k>=2&&ccw(e[k-2],e[k-1],v[i])<=0)k--;\n\tfor(int i=n-2,t=k+1;i>=0;e[k++]=v[i--])\n\t\twhile(k>=t&&ccw(e[k-2],e[k-1],v[i])<=0)k--;\n\te.resize(k-1);\n\treturn e;\n}\n\nint main(){\n    int N;\n    while(scanf(\"%d\",&N),N){\n        Circle C[128];\n        vector< Point > points;\n        rep(i,N){\n            double x,y;\n            scanf(\"%lf %lf\",&x,&y);\n            C[i] = Circle(Point(x,y),1.);\n        }\n        int len = 0;\n        rep(i,N){\n            reps(j,i+1,N){\n                Point p,q;\n                int tmp = 0;\n                tmp = intercectCC(C[i],C[j],&p,&q);\n                if(tmp > 0){\n                    points.PB(p);\n                    points.PB(q);\n                    /*\n                    cout << i << \" \" << j << \"->\\n\";\n                    cout << \"1:\"<< p.x << \" \" << p.y << \"\\n\";\n                    cout << \"2:\"<< q.x << \" \" << q.y << \"\\n\";\n                    */\n                }\n            }\n        }\n        int ans = -INF;\n        rep(i,points.size()){\n            Point tar = points[i];\n            int cnt = 0;\n            rep(j,N){\n                Point base = C[j].p;\n                //cout << pabs(base-tar) << \" \";\n                if(pabs(base-tar)-1.<EPS){\n                    cnt++;\n                }\n            }\n            ans = max(ans,cnt);\n        }\n\n        printf(\"%d\\n\",ans);\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 310\n\nlong double x[MAX_N], y[MAX_N];\nint n, maxn;\n\nint main() {\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tmaxn = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tint sum = 0;\n\t\t\t\tlong double X = (x[i] + x[j]) / 2.0;\n\t\t\t\tlong double Y = (y[i] + y[j]) / 2.0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (((x[k] - X)*(x[k] - X) + (y[k] - Y)*(y[k] - Y)) <= 1) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint sum = 0;\n\t\t\tlong double X = x[i];\n\t\t\tlong double Y = y[i];\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (((x[k] - X)*(x[k] - X) + (y[k] - Y)*(y[k] - Y)) <= 1) {\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxn = max(maxn, sum);\n\t\t}\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\nusing namespace std;\ntypedef complex<double> P;\nint n;\nvector<P> p;\nint ret(){\n\tint cnt=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(abs(p[i]-p[j])>2.0)\n\t\t\t\tcontinue;\n\t\t\tP c=(p[i]+p[j])*0.5;\n\t\t\tdouble d=sqrt(1.0-abs(p[i]-c)*abs(p[i]-c));\n\t\t\tP l1=(p[i]-p[j])*P(0,1);\n\t\t\tP l2=(p[i]-p[j])*P(0,-1);\n\t\t\tl1=l1*d/abs(l1)+c;l2=l2*d/abs(l2)+c;\n\t\t\tint x=0,y=0;\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(abs(l1-p[k])<=1.0){\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif(abs(l2-p[k])<=1.0){\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tcnt=max(cnt,max(x,y));\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n\t\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tp.resize(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tp[i]=P(x,y);\n\t\t}\n\t\tcout<<ret()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 10;\ntypedef complex <double> point;\npoint a[N];\ndouble kc[N][N];\nint n;\nint quetgoc(int i,double r,int n){\n    vector<pair<double,bool> > goc;\n    for(int j=0;j<n;j++){\n        if(kc[i][j]<=2*r&&i!=j){\n            double B=acos(kc[i][j]/(2*r));\n            double A= arg(a[j]-a[i]);\n            double alpha=A-B;\n            double beta=A+B;\n            goc.push_back(make_pair(alpha,true));\n            goc.push_back(make_pair(beta,false));\n        }\n    }\n    sort(goc.begin(),goc.end());\n    int cnt=1,ans=1;\n     vector<pair<double, bool> >::iterator it;\n    for(it=goc.begin();it!=goc.end();++it){\n        if((*it).second) cnt++;\n        else cnt--;\n        if(cnt>ans) ans=cnt;\n    }\n    return ans;\n}\nint maxpoint(point a[],int n,int r){\n    for(int i=0;i<n-1;i++)\n        for(int j=i+1;j<n;j++)\n        kc[i][j]=kc[j][i]=abs(a[i]-a[j]);\n    int ans=0;\n    for(int i=0;i<n;i++)\n        ans=max(ans,quetgoc(i,r,n));\n    return ans;\n}\nsigned main()\n{\n    double x[10000],y[10000];\n    int t;\n    while(cin>>t&&t!=0){\n    for(int i=0;i<t;i++) a[i]=0;\n    for(int i=0;i<t;i++) cin>>x[i]>>y[i];\n    for(int i=0;i<t;i++) a[i]=point(x[i],y[i]);\n    int r = 1;\n    cout << maxpoint(a,t, r)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> C;\n\nint solve(int N, vector<double>& x, vector<double>& y) {\n    vector<C> point(N);\n\n    for (int j = 0; j < N; ++j) {\n        point[j] = C(x[j], y[j]);\n    }\n\n    int ret = 0;\n\n    for (int j = 0; j < N; ++j) {\n        for (int k = j+1; k < N; ++k) {\n            C mid = (point[j] + point[k]) * 0.5;\n\n            C normal = (point[j] - point[k]) * C(0, 1);\n            normal /= abs(point[j] - point[k]);\n\n            double a = 1 - norm(mid - point[j]);\n\n            C centre1 = mid + a * normal;\n            int count = 0;\n            for (int l = 0; l < N; ++l) {\n                if (abs(centre1 - point[l]) < 1) {\n                    ++count;\n                }\n            }\n            ret = max(ret, count);\n\n            C centre2 = mid - a * normal;\n            count = 0;\n            for (int l = 0; l < N; ++l) {\n                if (norm(centre2 - point[l]) <= 1.0000001) {\n                    ++count;\n                }\n            }\n            ret = max(ret, count);\n\n        }\n    }\n\n    return ret;\n}\n\nint main () {\n    int N;\n    vector<double> x, y;\n\n    while (true) {\n        cin >> N;\n        if (N == 0) break;\n\n        x.resize(N);\n        y.resize(N);\n\n        for (int j = 0; j < N; ++j) {\n            cin >> x[j] >> y[j];\n        }\n\n        cout << solve(N, x, y) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nstruct Point{\n    double x,y;\n};\n\nvoid func(int N){\n\n    Point point[N];\n    double x_min = 100,y_min = 100,x_max = -1,y_max = -1;\n\n    for(int i = 0; i < N; i++){\n        scanf(\"%lf %lf\",&point[i].x,&point[i].y);\n        x_min = min(point[i].x,x_min);\n        y_min = min(point[i].y,y_min);\n        x_max = max(point[i].x,x_max);\n        y_max = max(point[i].y,y_max);\n    }\n\n    if(x_min > 1)x_min -= 0.045;\n    if(y_min > 1)y_min -= 0.045;\n    if(x_max < 9)x_max += 0.045;\n    if(y_max < 9)y_max += 0.045;\n\n    int count,max_count = 0;\n\n    for(double y = y_min; y <= y_max; y += 0.01){\n        for(double x = x_min; x <= x_max; x += 0.01){\n            count = 0;\n            for(int i = 0; i < N; i++){\n                if(sqrt((x-point[i].x)*(x-point[i].x)+(y-point[i].y)*(y-point[i].y)) <= 1.0)count++;\n            }\n            max_count = max(max_count,count);\n        }\n    }\n\n    printf(\"%d\\n\",max_count);\n}\n\n\nint main(){\n\n    int N;\n\n    while(true){\n        scanf(\"%d\",&N);\n        if(N == 0)break;\n\n        func(N);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\n\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\n#define EPS 1e-9\n#define INF 1000000000\n\ndouble dis(Point a, Point b){ return abs(a - b); }\ndouble dot(Point a, Point b){ return a.real() * b.real() + a.imag() * b.imag(); }\ndouble cross(Point a, Point b){ return a.real() * b.imag() - a.imag() * b.real(); }\nint ccw(Point a, Point b, Point c){\n  if(cross(b - a, c - a) > EPS) return 1;\n  if(cross(b - a, c - a) < -EPS) return -1;\n  if(dot(b - a, c - a) < -EPS) return 2;\n  if(dis(a, b) + EPS < dis(c, a)) return -2;\n  return 0;\n}\nint ccw(Line a, Point b){ return ccw(a.first, a.second, b); }\n\nbool SegmentCross(Line a, Line b){\n  return ccw(a, b.first) * ccw(a, b.second) == -1\n    && ccw(b, a.first) * ccw(b, a.second) == - 1;\n}\n\nPoint MiddlePoint(Point a, Point b){\n  double x = (a.real() + b.real()) / 2;\n  double y = (a.imag() + b.imag()) / 2;\n  return Point(x, y);\n}\n\nLine Equidistant(Point a, Point b, double r = -1){\n  Point m = MiddlePoint(a, b);\n  double m_dis = dis(m, a);\n  double slope = (b.real() - a.real()) / (a.imag() - b.imag());\n  \n  if(r <= EPS){ r = m_dis * 2; }\n  \n  if(r <= m_dis + EPS){ return make_pair(Point(0, 0), Point(0, 0)); }\n\n  double target_dis = r * r - m_dis * m_dis;\n  double x = sqrt(target_dis / (1 + slope * slope));\n  double y = slope * x;\n  \n  Point s(m.real() + x, m.imag() + y);\n  Point t(m.real() - x, m.imag() - y);\n  \n  return make_pair(s, t);\n}\n\n\nint main(void){\n  //double a, b, c, d;\n  //cin >> a >> b >> c >> d;\n  //Equidistant(Point(a, b), Point(c, d));\n\n \n  while(true){\n    int n;\n    cin >> n;\n    if(n == 0){ break; }\n\n    double x, y;\n    vector<Point> P;\n    for(int i = 0; i < n; i++){\n      cin >> x >> y;\n      P.push_back(Point(x, y));\n    }\n\n    int ans = 0;\n    for(int i = 0; i < n; i++){\n      for(int j = i + 1; j < n; j++){\n        Line tmpLine = Equidistant(P[i], P[j], 1 - EPS);\n        if(tmpLine.first == tmpLine.second){ continue; }\n\n        Point center[] = {tmpLine.first, tmpLine.second};\n        for(int l = 0; l < 2; l++){\n          //printf(\"(%f, %f)(%f, %f) -> (%f, %f)\\n\", P[i].real(), P[i].imag(), P[j].real(), P[j].imag(),\n          //       center[l].real(), center[l].imag());\n          int count = 0;\n          for(int k = 0; k < n; k++){\n            //printf(\"  (%f, %f) %f\\n\", P[k].real(), P[k].imag(), dis(center[l], P[k]));\n            if(dis(center[l], P[k]) <= 1.0 + EPS){\n              ++count;\n            }\n          }\n          \n          ans = max(ans, count);\n        }\n      }\n    }\n\n    // ??????\n    cout << ans << endl;\n     \n  }\n\n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<double,double>P;\n\nconst int MAX_N = 100005;\n\nvector<P> a;\nint n;\n\ndouble dir(P p1,P p2)\n{\n    return (p1.first - p2.first) * (p1.first - p2.first) + (p1.second - p2.second) * (p1.second - p2.second);\n}\n\nvector<P> circle_center(P p1,P p2)\n{\n    vector<P> cs;\n    P mid = P((p1.first + p2.first) / 2.0,(p1.second + p2.second) / 2.0);\n    P vec = P(p1.first - p2.first,p1.second - p2.second);\n    double len = dir(vec,P(0.0,0.0));\n    double real_len = sqrt(len);\n    double len2 = sqrt(1.0 - len / 4.0);\n    cs.push_back(P(-vec.second * len2 / real_len + mid.first,vec.first * len2 / real_len + mid.second));\n    cs.push_back(P(vec.second * len2 / real_len + mid.first,-vec.first * len2 / real_len + mid.second));\n    return cs;\n}\n\nint main()\n{\n    while(1){\n        scanf(\"%d\",&n);\n        if(n == 0){\n            break;\n        }\n        a.clear();\n        rep(i,n){\n            double x,y;\n            scanf(\"%lf%lf\",&x,&y);\n            a.push_back(P(x,y));\n        }\n        int res = -1;\n        rep(i,n){\n            for(int j = i+1; j < n; j++){\n                if(dir(a[i],a[j]) < 4.0){\n                    int cnt = 0;\n                    vector<P> cs = circle_center(a[i],a[j]);\n                    rep(k,n){\n                        if(k != i && k != j && dir(a[k],cs[0]) <= 1.0){\n                            cnt++;\n                        }\n                    }\n                    res = max(res,cnt);\n                    cnt = 0;\n                    rep(k,n){\n                        if(k != i && k != j && dir(a[k],cs[1]) <= 1.0){\n                            cnt++;\n                        }\n                    }\n                    res = max(res,cnt);\n                }\n            }\n        }\n        printf(\"%d\\n\",res+2);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ndouble dist(double ax,double ay,double bx,double by){\n    return sqrt((ax-bx)*(ax-bx)+(ay-by)*(ay-by));\n}\nint n;\ndouble X[300],Y[300];\nint search(double x,double y){\n    int m=0;\n    rep(i,n) if(dist(x,y,X[i],Y[i])<1.0001) m++;\n    return m;\n}\nint main(){\n    while(true){\n        int ans=1;\n        cin>>n;\n        if(n==0) break;\n        rep(i,n) cin>>X[i]>>Y[i];\n        rep(i,n)for(int j=i+1;j<n;j++){\n            if(dist(X[i],Y[i],X[j],Y[j])>2) continue;\n            double mx=(X[i]+X[j])/2,my=(Y[i]+Y[j])/2,k=(Y[j]-Y[i])/(X[j]-X[i]);\n            double vx=1/dist(0,0,1,-1/k),vy=(-1/k)/dist(0,0,1,-1/k);\n            double a=sqrt(1-pow(dist(mx,my,X[i],Y[i]),2));\n            ans=max(ans,search(mx+a*vx,my+a*vy));\n            ans=max(ans,search(mx-a*vx,my-a*vy));\n        }\n        cout<<ans<<\"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <string>\nusing namespace std;\n\nvector<float> getAreaPointx(int x,int y,vector<float> lx,vector<float> ly)\n{\n\tvector<float> result;\n\tvector<float>::iterator itx=lx.begin();\n\tvector<float>::iterator ity=ly.begin();\n\twhile (itx != lx.end())\n\t{\n\t\tif ((*itx <= x+1) && (*itx >= x-2) && (*ity <= y+1) && (*ity >= y-2)){\n\t\t\tresult.push_back(*itx);\n\t\t}\n\t\titx++;\n\t\tity++;\n\t}\n\treturn result;\n}\n\nvector<float> getAreaPointy(int x,int y,vector<float> lx,vector<float> ly)\n{\n\tvector<float> result;\n\tvector<float>::iterator itx=lx.begin();\n\tvector<float>::iterator ity=ly.begin();\n\twhile (itx != lx.end())\n\t{\n\t\tif ((*itx <= x+1) && (*itx >= x-2) && (*ity <= y+1) && (*ity >= y-2)){\n\t\t\tresult.push_back(*ity);\n\t\t}\n\t\titx++;\n\t\tity++;\n\t}\n\treturn result;\n}\n\n\nfloat distance(float x1,float y1,float x2,float y2)\n{\n\treturn sqrt(pow((x1-x2),2)+pow((y1-y2),2));\n}\n\nint countInside(float x,float y,vector<float> lx,vector<float> ly)\n{\n\tint c=0;\n\tvector<float>::iterator itx=lx.begin();\n\tvector<float>::iterator ity=ly.begin();\n\twhile (itx != lx.end())\n\t{\n\t\tif (distance(x,y,*itx,*ity) <= 1)\n\t\t{\n\t\t\tc++;\n\t\t}\n\t\titx++;\n\t\tity++;\n\t}\n\treturn c;\n}\n\nint main(void) {\n\tvector<int> r;\n\twhile (true)\n\t{\n\t\tint n=0;\n\t\tscanf(\"%d\",&n);\n\t\tif (n==0){\n\t\t\tbreak;\n\t\t}\n\t\tvector<float> x,y;\n\t\tint map[12][12]={{0}};\n\t\tint maxx=0,maxy=0;\n\t\tint maxpoint=0;\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tfloat tx=0,ty=0;\n\t\t\tscanf(\"%f %f\", &tx, &ty);\n\t\t\tx.push_back(tx);\n\t\t\ty.push_back(ty);\n\t\t\tint ttx=0,tty=0;\n\t\t\tttx = int(round(tx+0.5));\n\t\t\ttty = int(round(ty+0.5));\n\t\t\tmap[ttx][tty]++;\n\t\t\tif (maxpoint < map[ttx][tty]){\n\t\t\t\tmaxpoint = map[ttx][tty];\n\t\t\t\tmaxx=ttx;\n\t\t\t\tmaxy=tty;\n\t\t\t}\n\t\t}\n\t\tfor (float dif=0.5; dif>=0.0049; dif/=100)\n\t\t{\n\t\t\tfor (int i=1; i<=10; i++)\n\t\t\t{\n\t\t\t\tfor (int j=1; j<=10; j++)\n\t\t\t\t{\n\t\t\t\t\tint aroundpoint=0;\n\t\t\t\t\tfor (int k=-1; k<=1; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int l=-1; l<=1; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taroundpoint+=map[i+k][j+l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (maxpoint >= aroundpoint){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvector<float> lx=getAreaPointx(i,j,x,y);\n\t\t\t\t\t\tvector<float> ly=getAreaPointy(i,j,x,y);\n\t\t\t\t\t\tfor (float k=0; k<1; k+=dif)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (float l=0; l<1; l+=dif)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint tmp = countInside(i-1+k,j-1+l,lx,ly);\n\t\t\t\t\t\t\t\tif (tmp>maxpoint){\n\t\t\t\t\t\t\t\t\tmaxpoint = tmp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr.push_back(maxpoint);\n\t}\n\tfor(int i=0; i<r.size(); i++)\n\t{\n\t\tcout << r[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef complex<double> P;\nconst double PI = 3.14159265;\nconst double eps = 1e-7;\n\ninline double dist(const P &p,const P &q) {\n    double dx = (p-q).real(),dy = (p-q).imag();\n    return sqrt(dx*dx+dy*dy);\n}\n\ndouble inner(const P &p,const P &q) {\n    return (conj(p)*q).real();\n}\n\ndouble outer(const P &p,const P &q) {\n    return (conj(p)*q).imag();\n}\n\nstruct Line {\n    P pos,dir;\n    Line(const P &p,const P &q) : pos(p), dir(q) {;}\n};\n\n// rotate to right , radian\nP rotate(const P &p,double degree) {\n    return P(p.real()*cos(degree)+p.imag()*(-sin(degree)),\n             p.real()*sin(degree)+p.imag()*cos(degree));\n}\n\nstruct Circle {\n    double r;\n    P c;\n    Circle(P c,double r) : c(c), r(r) {;}\n};\n\n// p in C?\ninline bool inC(const Circle &c,const P &p) {\n    return dist(c.c,p) < c.r + eps;\n}\n\npair<P,P> findCenter(P &p1,P &p2) {\n    P cp = p1+p2;\n    cp /= 2;\n\n//    cout<<\"cp = \"<<cp<<endl;\n    P od = p2-cp;\n\n//    cout<<\"original od = \"<<od<<endl;\n    od = rotate(od,PI/2);\n//    cout<<\"rotated od = \"<<od<<endl;\n\n    double abod = abs(od),abcp = norm(cp-p1);\n    double len = sqrt(1-abcp);\n\n    // cout<<\"abod = \"<<abod<<\" abcp = \"<<abcp<<endl;\n    // cout<<\"len = \"<<len<<endl;\n    P rep1 = cp + (od/abod)*len;\n    P rep2 = cp - (od/abod)*len;\n    return make_pair(rep1,rep2);\n}\n\nint main() {\n    int n;\n    while(cin>>n, n) {\n        vector<P> pv;\n        double x,y;\n        for(int i=0; i<n; ++i) {\n            cin>>x>>y;\n            pv.push_back(P(x,y));\n        }\n\n        int ans = 1;\n        for(int i=0; i<n; ++i) {\n            for(int j=i+1; j<n; ++j) {\n                if(dist(pv[i],pv[j]) > 2.0) continue;\n                pair<P,P> p = findCenter(pv[i],pv[j]);\n                int t1 = 0,t2 = 0;\n//                cout<<pv[i]<<\" \"<<pv[j]<<\" \"<<p.first<<\" \"<<p.second<<endl;\n                Circle c1(p.first,1.0);\n                Circle c2(p.second,1.0);\n                for(int k=0; k<n; ++k) {\n                    if(inC(c1,pv[k])) t1++;\n                    if(inC(c2,pv[k])) t2++;\n                }\n                ans = max(ans, max(t1,t2));\n            }\n        }\n\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\ntemplate<class T> bool operator<(const complex<T> &a, const complex<T> &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n}\n\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\n\ndouble dot(P a, P b){\n    return (a * conj(b)).X;\n}\ndouble cross(P a, P b){\n    return (a * conj(b)).Y;\n}\n\nvector<P> points;\ndeque<P> selected;\nint max_count;\n\nvoid search(int index) {\n    if(index > points.size()) return;\n    int selected_size = selected.size();\n\n    bool is_all_in_circle = true;\n    if(selected_size >= 2 && selected_size > max_count) {\n        // calc is all overlaps\n        vector<P> copied_selected;\n        copy(selected.begin(), selected.end(), back_inserter(copied_selected));\n\n        for (int i = 0; i < selected_size ; ++i) {\n            for (int j = 0; j < selected_size; ++j) {\n                if(i == j) continue;\n                // two point check\n                double d12 = abs(copied_selected[i] - copied_selected[j]);\n                if(d12 > 2.0 + 1e-10) {\n                    is_all_in_circle = false;\n                    break;\n                }\n\n                for (int k = 0; k < selected_size; ++k) {\n                    if(i == k || j == k) continue;\n                    // three point check\n                    P p1 = copied_selected[i];\n                    P p2 = copied_selected[j];\n                    P p3 = copied_selected[k];\n\n                    P center12 = P((p1.X + p2.X) / 2, (p1.Y + p2.Y) / 2);\n                    double allow_distance = 1 + sqrt(1 - ((d12 * d12) / 4));\n                    if(abs(center12 - p3)  > allow_distance + 1e-10) {\n                        is_all_in_circle = false;\n                        break;\n                    }\n                }\n\n            }\n            if(!is_all_in_circle) {\n                break;\n            }\n        }\n\n        copied_selected.clear();\n        copied_selected.shrink_to_fit();\n    }\n\n    if (is_all_in_circle) {\n        // update max count\n        if(selected_size > max_count) {\n            max_count = selected_size;\n        }\n\n        P p = points[index];\n        // remove bad situation\n        if(selected.empty() || abs(p - selected.front()) <= 2.0 + 1e-10) {\n            // take\n            selected.push_front(p);\n            search(index + 1);\n            selected.pop_front();\n        }\n\n        // for next dispatch\n        // not take\n        search(index + 1);\n    }\n}\n\nint main() {\n    int n;\n    while (cin >> n) {\n        if(n == 0) break;\n        points.clear();\n        points.shrink_to_fit();\n        selected.clear();\n        selected.shrink_to_fit();\n        max_count = 0;\n\n        // load points\n        for (char i = 0; i < n; ++i) {\n            double x;\n            double y;\n            cin >> x >> y;\n            P p = P(x, y);\n            points.push_back(p);\n        }\n\n        search(0);\n        cout << max_count << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ld = long double;\nusing Point = complex<ld>;\n\nstruct Line{\n    Point a, b;\n    Line (Point a, Point b) : a(a), b(b) {}\n    Line () : Line(Point(), Point()) {}\n};\n\nstruct Circle{\n    Point p;\n    ld r;\n    Circle (Point p, ld r) : p(p), r(r) {}\n    Circle () : Circle(Point(),0.0) {}\n};\n\nconstexpr ld eps=1e-9, pi=acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nnamespace Geometry{\n    bool eq(ld a, ld b){\n        return abs(a-b) < eps;\n    }\n    //内積\n    ld dot(Point a, Point b){\n        return real(conj(a) * b);\n    }\n    //外積\n    ld cross(Point a, Point b){\n        return imag(conj(a) * b);\n    }\n    //3点の位置関係\n    int ccw (Point a, Point b, Point c) {\n        b -= a; c -= a;\n        if (cross(b, c) > eps) return 1;//a,b,cで反時計周り\n        if (cross(b, c) < -eps) return -1;//a,b,cで時計周り\n        if (dot(b, c) < 0) return 2;//c,a,bで直線\n        if (norm(b) < norm(c)) return -2;//a,b,cで直線\n        return 0;//a,c,bで直線\n    }\n\n//====================================================\n    Point inputPoint(){\n        ld x, y;\n        cin>>x>>y;\n        return Point(x, y);\n    }\n    //2直線の交差判定\n    bool isCrossed_ll(Line l, Line m){\n        return !eq(cross(l.b-l.a, m.b-m.a), 0);\n    }\n    //直線と線分の交差判定\n    bool isCrossed_ls(Line l, Line s){\n        return isCrossed_ll(l, s) && \n            cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps;\n    }\n    //線分と線分の交差判定\n    bool isCrossed_ss(Line s, Line t){\n        return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n            ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n    }\n    //点が直線上にあるか\n    bool isON_l(Line l, Point p){\n        return abs(cross(l.b-p, l.a-p)) < eps;\n    }\n    //点が線分上にあるか\n    bool isON_s(Line s, Point p){\n        return abs(s.a-p)+abs(s.b-p)-abs(s.b-s.a) < eps;\n    }\n\n    //点から直線への垂線の足\n    Point foot(Line l, Point p){\n        ld t = dot(p-l.a,l.a-l.b)/norm(l.a-l.b);\n        return l.a+t*(l.a-l.b);\n    }\n    //直線と直線の交点\n    Point intersection_ll(Line l, Line m){\n        Point lv=l.b-l.a, mv=m.b-m.a;\n        assert(cross(lv,mv)!=0);//平行\n        return l.a+lv*cross(mv,m.a-l.a)/cross(mv,lv);\n    }\n    //線分と線分の交点\n    Point intersection_ss(Line s, Line t){\n        assert(isCrossed_ll(s, t));\n        return intersection_ll(s,t);\n    }\n    //点と点の距離\n    ld dist_pp(Point p, Point q){\n        ld x=p.real()-q.real(), y=p.imag()-q.imag();\n        return sqrt(x*x+y*y);\n    }\n    //点と直線の距離\n    ld dist_lp(Line l, Point p) {\n        return abs(p - foot(l, p));\n    }\n    //直線と直線の距離\n    ld dist_ll(Line l, Line m){\n        return isCrossed_ll(l, m)?0:dist_lp(l, m.a);\n    }\n    //直線と線分の距離\n    ld dist_ls(Line l, Line s){\n        return isCrossed_ls(l, s)?0:min(dist_lp(l, s.a), dist_lp(l, s.b));\n    }\n    //線分と点の距離\n    ld dist_sp (Line s, Point p) {\n        Point r = foot(s, p);\n        return isON_s(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n    }\n    //線分と線分の距離\n    ld dist_ss (Line s, Line t) {\n        if (isCrossed_ss(s, t)) return 0;\n        return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n    }\n    //円と円の交点\n    vector<Point>intersection_cc(Circle c1, Circle c2){\n        vector<Point> res;\n        ld d = abs(c1.p - c2.p);\n        ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n        ld dfr = c1.r * c1.r - rc * rc;\n        if (abs(dfr) < eps) dfr = 0.0;\n        else if (dfr < 0.0) return res;\n        ld rs = sqrt(dfr);\n        Point diff = (c2.p - c1.p) / d;\n        res.push_back(c1.p + diff * Point(rc, rs));\n        if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n        return res;\n    }\n};\n\nint main(){\n    int n;\n    using namespace Geometry;\n    while(cin>>n,n){\n        vector<Point>g(n);\n        vector<Circle>Cs(n);\n        for(int i=0;i<n;++i){\n            g[i]=inputPoint();\n            Cs[i]={g[i],1.0};\n        }\n        int ans=0;\n        for(int i=0;i<n;++i){\n            for(int j=0;j<n;++j){\n                vector<Point>intersections(intersection_cc(Cs[i],Cs[j]));\n                for(auto intersection:intersections){\n                    int ret=0;\n                    for(int k=0;k<n;++k){\n                        if(dist_pp(intersection,g[k]) < 1.0+eps){\n                            ++ret;\n                        }\n                    }\n                    ans=max(ans,ret);\n                }\n            }\n        }\n        cout<<ans<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<tuple>\n#include<list>\n#include<unordered_map>\n#define ll long long\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define vii vector<int>\n#define vll vector<ll>\n#define lb lower_bound\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep2(i,a,b) for(ll i=a;i<b;i++)\n#define repr(i,n) for(ll i=n-1;i>=0;i--)\n#define all(x) x.begin(),x.end()\n// #define int ll\nusing namespace std;\nconst int INF (1 << 30);\nconst ll LLINF (1LL << 55LL);\nconst int MOD = 1000000007;\nconst int MAX = 510000;\nconst double pi = acos(-1);\nconst double eps = 1e-9;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    while(true){\n        ll n,ans=1;\n        cin>>n;\n        if(n==0) break;\n        double x[310],y[310];\n        rep(i,n){\n            cin>>x[i]>>y[i];\n        }\n        rep(i,n){\n            rep(j,n){\n                if(i==j) continue;\n                double dx=x[i]-x[j],dy=y[i]-y[j];\n                double d=sqrt(dx*dx+dy*dy);\n                if(d>2+eps) continue;\n                double s=sqrt((1.0-d*d/4));\n                double vx=-dy/d*s;\n                double vy=dx/d*s;\n                double ox=(x[i]+x[j])/2+vx;\n                double oy=(y[i]+y[j])/2+vy;\n                ll cnt=0;\n                rep(k,n){\n                    if((x[k]-ox)*(x[k]-ox)+(y[k]-oy)*(y[k]-oy)<1.0+eps)cnt++;\n                }\n                ans=max(ans,cnt);\n            }   \n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define F first\n#define S second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\nconst int inf = 1LL << 55;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\n// ???/????????????\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n  \n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// ???\nstruct Circle {\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0):c(c), r(r){}\n};\n\n// ????§???¢\ntypedef vector<Point> Polygon;\n\n// ??????/??´???\nstruct Segment {\n  Point p1, p2;\n};\ntypedef Segment Line;\n\n// ????????????????????????\ndouble norm(Vector v)\n{\n  return v.x*v.x + v.y*v.y;\n}\n// ?????????????????§??????\ndouble abs(Vector v)\n{\n  return sqrt(norm(v));\n}\n// ?????????????????????\ndouble dot(Vector a, Vector b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n// ??????????????????????????§??????\ndouble cross(Vector a, Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n// ??´?????????\nbool isOrthogonal(Vector a, Vector b)\n{\n  return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2)\n{\n  return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ????????????\nbool isParallel(Vector a, Vector b)\n{\n  return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n  return isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2)\n{\n  return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ?°???±\nPoint project(Segment s, Point p)\n{\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\n// ????°?\nPoint reflect(Segment s, Point p)\n{\n  return p + (project(s, p) - p) * 2.0;\n}\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE         = -1;\nstatic const int ONLINE_BACK       = 2;\nstatic const int ONLINE_FRONT      = -2;\nstatic const int ON_SEGMENT        = 0;\n// ???????¨???????\nint ccw(Point p0, Point p1, Point p2)\n{\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n// ????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2)\n{\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n// ?????????????????¢\ndouble getDistance(Point a, Point b)\n{\n  return abs(a - b);\n}\n// ??´?????¨?????¨????????¢\ndouble getDistanceLP(Line l, Point p)\n{\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n// ????????¨?????¨????????¢\ndouble getDistanceSP(Segment s, Point p)\n{\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n// ????????????????????¢\ndouble getDistance(Segment s1, Segment s2)\n{\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n// ???????????????\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n// ???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l)\n{\n  // assert(intersect(c, l));\n  Vector pr = project(l, c.c);\n  Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n  double base = sqrt(c.r*c.r - norm(pr - c.c));\n  return make_pair(pr + e * base, pr - e * base);\n}\n// ???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\npair<Point, Point> getCrossPoints(Circle c1, Circle c2)\n{\n  // assert(intersect(c1, c2));\n  double d = abs(c1.c - c2.c);\n  double a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2*c1.r*d));\n  double t = arg(c2.c - c1.c);\n  return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n// ????????????\nstatic const int IN_POLYGON = 2;\nstatic const int ON_POLYGON = 1;\nstatic const int OUT_POLYGON = 0;\nint contains(Polygon g, Point p)\n{\n  int n = g.size();\n  bool x = false;\n  for(int i = 0; i < n; i++) {\n    Point a = g[i] - p, b = g[(i+1) % n] - p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON_POLYGON;\n    if(a.y > b.y) swap(a, b);\n    if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n  }\n  return (x ? IN_POLYGON : OUT_POLYGON);\n}\n\nsigned main()\n{\n  int N;\n  while(cin >> N, N) {\n    vector<Point> p(N);\n    rep(i, N) cin >> p[i].x >> p[i].y;\n    int ans = 1;\n    rep(i, N) reps(j, i+1, N) {\n      if(getDistance(p[i], p[j]) < 2.0 + EPS) {\n\tCircle c1(p[i], 1.0), c2(p[j], 1.0);\n\tauto cp = getCrossPoints(c1, c2);\n\tint cnt = 0;\n\trep(k, N) if(getDistance(cp.first, p[k]) < 1.0 + EPS) cnt++;\n\tans = max(ans, cnt);\n\tcnt = 0;\n\trep(k, N) if(getDistance(cp.second, p[k]) < 1.0 + EPS) cnt++;\n\tans = max(ans, cnt);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    double x, y;\n    while(cin >> n && n) {\n        vector<double> xs, ys;\n        for (int i=0; i<n; ++i) {\n            cin >> x >> y;\n            xs.push_back(x);\n            ys.push_back(y);\n        }\n        vector<double> cxs, cys;\n        for (int i=0; i<n; ++i) {\n            for (int j=i+1; j<n; ++j) {\n                cxs.push_back((xs[i] + xs[j]) / 2.0);\n                cys.push_back((ys[i] + ys[j]) / 2.0);\n                for (int k=j+1; k<n; ++k) {\n                    cxs.push_back((xs[i] + xs[j] + xs[k]) / 3.0);\n                    cys.push_back((ys[i] + ys[j] + ys[k]) / 3.0);\n                }\n            }\n        }\n        int ret = 1;\n        for (int i=0; i<(int)cxs.size(); ++i) {\n            double cx = cxs[i], cy = cys[i];\n            int cnt = 0;\n            for (int j=0; j<n; ++j) {\n                if ((xs[j] - cx) * (xs[j] - cx) + (ys[j] - cy) * (ys[j] - cy) < 1.0 + 1e-8) {\n                    cnt ++;\n                }\n            }\n            ret = max(ret, cnt);\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<pdd> p(n);\n\t\trep(i, n)cin >> p[i].first >> p[i].second;\n\t\tint m = 1;\n\t\trep(i, n)rep(j, i) {\n\t\t\tif (hypot(p[i].first - p[j].first, p[i].second - p[j].second) > 2.00005)continue;\n\t\t\tP s = { (p[i].first + p[j].first) / 2,(p[i].second + p[j].second) / 2 };\n\t\t\tP t = { (p[j].second - p[i].second) / 2,(p[i].first - p[j].first) / 2 };\n\t\t\tt = t / abs(t)*sqrt(1 - abs(t)*abs(t));\n\t\t\tP c = s + t;\n\t\t\tint cnt = 0;\n\t\t\trep(i, n)if (dist2(P{ p[i].first,p[i].second }-c) < 1.0001)cnt++;\n\t\t\tcmax(m, cnt);\n\t\t\tc = s - t;\n\t\t\tcnt = 0;\n\t\t\trep(i, n)if (dist2(P{ p[i].first,p[i].second }-c) < 1.0001)cnt++;\n\t\t\tcmax(m, cnt);\n\t\t}\n\t\tcout << m << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double eps = 1e-5;\nconst int MAXN = 333;\nint N;\nP ps[MAXN];\n\nint calc(P c) {\n  int res = 0;\n  for(int i = 0; i < N; ++i) {\n    double d = norm(c - ps[i]);\n    if(d < 1.0 + eps) ++res;\n  }\n  return res;\n}\n\nint main() {\n  for(; cin >> N && N; ) {\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    int res = 1;\n    for(int i = 0; i < N; ++i) {\n      for(int j = i+1; j < N; ++j) {\n        P base = ps[j] - ps[i];\n        P m = ps[i] + base / 2.0;\n        double d = abs(base);\n        double a = sqrt(1.0 - d * d / 4.0);\n        P base2(-base.imag(), base.real());\n        base2 = base2 / abs(base2) * a;\n        res = max(res, max(calc(m + base2), calc(m - base2)));\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n#define OUT 0\n#define ON 1\n#define IN 2\n#define EPS (1e-10)\nclass P{                    //テァツつケ\npublic:\n\tdouble x,y;\n\t\n\tP(double _x=0,double _y=0):x(_x),y(_y){};\n\tP operator + (const P &p     )const{ return P( x+p.x , y+p.y ); }  //テ・ツ環?ァツョツ?\n\tP operator - (const P &p     )const{ return P( x-p.x , y-p.y ); }  //テヲツクツ崚ァツョツ?\n\tP operator * (const double k )const{ return P( x*k   , y*k    ); } //テ、ツケツ療ァツョツ?\n\tP operator / (const double k )const{ return P( x/k   , y/k    ); } //テゥツ卍、テァツョツ?\n\t\n\tbool operator == (const P &p){ return ( fabs(x-p.x)<EPS && fabs(y-p.y)<EPS ); }\n\tbool operator < (const P &p) const{ return ( x!=p.x ? x<p.x:y<p.y ); }\n\t\n\tdouble norm(){ return x*x+y*y; }        //テ」ツδ偲」ツδォテ」ツδ?\n\tdouble abs() { return sqrt(norm()); }   //テ・ツ、ツァテ」ツ?催」ツ??\n};\nstruct C{P p;double r;};    //テ・ツ??\nstruct S{P p1,p2;};         //テァツキツ堙・ツ按?\ntypedef vector<P> Polygon;  //テ・ツ、ツ堙ィツァツ津・ツスツ「\ntypedef P Vector;           //テ」ツδ凖」ツつッテ」ツδ暗」ツδォ\ntypedef S L;                //テァツ崢エテァツキツ?\n\ndouble norm (P p)               { return p.norm(); }\ndouble abs  (P p)               { return p.abs(); }\ndouble dot  (Vector a,Vector b) { return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b) { return a.x*b.y-a.y*b.x; }\ndouble sqDist(P a, P b)         {return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}\ndouble dist (P a, P b)          {return sqrt(sqDist(a,b));}\nVector vec(S a)                 {return P(a.p2.x-a.p1.x,a.p2.y-a.p1.y);}\n\nint ccw(P p0,P p1,P p2){    //AOJ_BOOK_P386 verified\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\t\n\tif( cross(a,b) > EPS  ) return 1 ;      //COUNTER_CLOCKWISE\n\tif( cross(a,b) < -EPS ) return -1;      //CLOCKWISE\n\tif( dot(a,b)   < -EPS ) return 2;       //ONLINE_BACK\n\tif( a.norm()   < b.norm() ) return -2;  //ONLINE_FRONT\n\t\n\treturn 0;                               //ON_SEGMENT;\n}\n\n//テァツ崢エテァツキツ堙ァツ崢エティツ。ツ古・ツ按、テ・ツョツ?verified AOJ0058\nbool orthogonal(P p1,P p2,P p3,P p4){ return abs(dot(p1-p2,p3-p4))<EPS; }\n\n//テァツキツ堙・ツ按?、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?\nbool intersect(P p1,P p2,P p3,P p4){ return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); }\n\n//テァツキツ堙・ツ按?」ツ?ィテァツつケテ」ツ?ョティツキツ敕ゥツ崢「 verified ARC042-B\ndouble dLP(S l, P p) { return abs(cross(l.p2-l.p1, p-l.p1)) /(l.p2-l.p1).abs(); }\n\n//テァツキツ堙・ツ按?」ツ?ォテ・ツッツセテ」ツ?凖」ツつ凝ァツつケテ」ツ?ョテ・ツーツ?・ツスツア verified AOJ CGL_1_A\nP project(S s, P p){\n\tVector base = s.p2-s.p1;\n\tdouble r = dot(p-s.p1, base)/norm(base);\n\treturn (base*r)+s.p1;\n}\n\n//テァツキツ堙・ツ按?」ツ?ォテ・ツッツセテ」ツ?凖」ツつ凝ァツつケテ」ツ?ョテ・ツ渉催・ツーツ?verified AOJ CGL_1_B\nP reflect(S s,P p){ return p+(project(s,p)-p)*2.0; }\n\n//テァツ崢エテァツキツ堙」ツ?ィテァツ崢エテァツキツ堙」ツ?ョテゥツ鳴「テ、ツソツ?verified AOJ CGL_2\nint rLL(L a,L b){\n\tif( cross(vec(a),vec(b))==0 ) return 2; //テ、ツクツヲティツ。ツ?\n\tif( dot(vec(a),vec(b))==0 )   return 1; //テ・ツ楪づァツ崢エ\n\treturn 0;\n}\n\n// テ・ツ??」ツ?ィテァツつケテ」ツ?ョテ・ツ??・ツ、ツ姪・ツ按、テ・ツョツ?\nint contains(C c, P p){\n\tdouble d = (c.p-p).abs();\n\tif(d-c.r>EPS) return OUT;\n\tif(abs(d-c.r)<EPS) return ON;\n\treturn IN;\n}\n\n//テァツ崢エテァツキツ堙」ツ?ィテ・ツ??」ツ?ョテ、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?テゥツ?催」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝・ツ?エテ・ツ青暗」ツ?ッテ、ツコツ、テ・ツキツョテヲツ可アテ」ツ??\nbool intersect_circle_(P center, double r, L line){\n\tif( dLP(line,center) <= r+EPS ) return true;\n\treturn false;\n}\n\n//テァツキツ堙・ツ按?」ツ?ィテ・ツコツ療」ツ?ョティツキツ敕ゥツ崢「 verified QUPC-G\ndouble dSP(S s, P p){\n\tif(dot((s.p2-s.p1)   , p-s.p1) <= EPS) return (p - s.p1).abs();\n\tif(dot((s.p2-s.p1)*-1, p-s.p2) <= EPS) return (p - s.p2).abs();\n\treturn dLP(s, p);\n}\n\n//テァツキツ堙・ツ按?」ツ?ィテ・ツ??」ツ?ョテ、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?テゥツ?催」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝・ツ?エテ・ツ青暗」ツ?ッテ、ツコツ、テ・ツキツョテヲツ可アテ」ツ?? verified QUPC-G\nbool iCS(C c, S l){\n\tint c1 = contains(c, l.p1);\n\tint c2 = contains(c, l.p2);\n\tif(c1 > c2) swap(c1, c2);\n\t\n\t// (OUT, OUT) (OUT, ON) (OUT, IN) (ON, ON) (ON, IN) (IN, IN) テ」ツ?ョ6テゥツ?堙」ツつ?\n\tif(c1 == OUT && c2 == IN) return true;\n\tif(c1 == IN  && c2 == IN) return false;\n\tif(c1 == ON) return true; // (テヲツ篠・テ」ツ?凖」ツつ凝」ツ?ィテ」ツ??\n\tdouble d = dSP(l, c.p);\n\tif(d-c.r<-EPS) return true;\n\tif(d-c.r>EPS) return false;\n\treturn true; // (テヲツ篠・テ」ツ?凖」ツつ凝」ツ?ィテ」ツ??\n}\n\n//テ・ツ債佚ァツエツ氾・ツ、ツ堙ィツァツ津・ツスツ「テ・ツ按、テ・ツョツ?\nbool isSimple( Polygon pol ){\n\t//テ・ツ按敕」ツつ?」ツ?ョテァツつケテ」ツつ津ゥツ?催ィツ、ツ?」ツ?療」ツ?ヲpolテ」ツ?ォテ・ツ?・テ」ツつ古」ツ?ヲテ」ツ?甘」ツ??\n\tsize_t pol_size = pol.size()-1;\n\trep(i,pol_size){\n\t\tfor(int j=i+2;j<pol_size;j++){\n\t\t\tif( i==j || i==(j-1+pol_size)%pol_size || i==(j+1+pol_size)%pol_size )continue;\n\t\t\tif( intersect(pol[i], pol[i+1], pol[j], pol[j+1]) )return false;\n\t\t}\n\t}\n\treturn true;\n}\n\n//テァツつケテ」ツ?古・ツ?クテ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ョテ・ツ??・ツ?エテ」ツ?ォテ」ツ?づ」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ?凝」ツつ津ヲツアツづ」ツつ?」ツつ?trueテ」ツ?ェテ」ツつ嘉・ツ??・ツ?エ verified AOJ0012\nint isPointInsidePolygon(vector<P> pol,P p){\n\tint c=0;\n\trep(i,pol.size()){\n\t\tif( cross(pol[i]-pol[(i+1)%pol.size()] , p-pol[(i+1)%pol.size()])==0 ) return ON;\n\t\tif( cross(pol[i]-pol[(i+1)%pol.size()] , p-pol[(i+1)%pol.size()])>0 ) c++;\n\t}\n\tif( c%pol.size() )return OUT;\n\treturn IN;\n}\n\n//テ・ツ??」ツ?ィテ・ツ?クテ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ョテ、ツコツ、テ・ツキツョテァツ環カテヲツ?凝」ツつ津ィツェツソテ」ツ?ケテ」ツつ?\nint CPOLarea(C c ,Polygon pol){\n\tvector<L> lines;\n\tvector<int> res(pol.size());\n\tbool POLinC=true, isFar=true;\n\t\n\trep(i,pol.size()){\n\t\tif( contains(c,pol[i])==OUT )POLinC=false;\n\t\tres[i] = contains(c,pol[i]);\n\t\tlines.pb( L{ pol[i] , pol[(i+1)%pol.size()] });\n\t\tif( sqDist(c.p,pol[i])<c.r*c.r )isFar=false;\n\t}\n\t\n\tif( POLinC )                                        return 2;   //テ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ッテ・ツ??」ツ?ョテ・ツ??ゥツδィb\n\tif( isPointInsidePolygon(pol, c.p)==IN && isFar )   return 3;   //テ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ョテ・ツ??ゥツδィテ」ツ?ォテ・ツ??\n\trep(i,lines.size()) if( iCS(c,lines[i]) )           return 1;   //テ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ィテ・ツ??」ツ?ッテ、ツコツ、テ・ツキツョc\n\treturn 0;\n}\n\n//テ・ツ?クテ・ツ個?verified AOJ0068,QUPC-G\n//ティツセツ榲ヲツ崢クテゥツ??」ツ?ァテヲツッツ氾ィツシツ?\nbool cmp_x(const P& p, const P& q){\n\tif(p.x != q.x)return p.x<q.x;\n\treturn p.y<q.y;\n}\n\n//テ・ツ?クテ・ツ個?」ツつ津ヲツアツづ」ツつ?」ツつ?\nvector<P> convex_hull(vector<P> ps){\n\tint n = ps.size();\n\tsort(all(ps),cmp_x);\n\tint k=0;            //テ・ツ?クテ・ツ個?」ツ?ョテゥツ?づァツつケテヲツ閉ー\n\tvector<P> qs(n*2);  //テヲツァツ凝ヲツ按静、ツクツュテ」ツ?ョテ・ツ?クテ・ツ個?\n\t//テ、ツクツ凝・ツ?エテ・ツ?クテ・ツ個?」ツ?ョテ、ツスツ愿ヲツ按?\n\trep(i,n){\n\t\twhile( k>1 && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n\t\tqs[k++]=ps[i];\n\t}\n\t//テ、ツクツ甘・ツ?エテ・ツ?クテ・ツ個?」ツ?ョテ、ツスツ愿ヲツ按?\n\tfor(int i=n-2, t=k;i>=0;i--){\n\t\twhile( k>t && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n\t\tqs[k++]=ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n\n\n//2テァツつケテ」ツつ津ゥツ?堙」ツつ凝・ツ債甘・ツセツвテ」ツ?ョテ・ツ??」ツ?ョテ、ツクツュテ・ツソツε・ツコツァテヲツィツ凖」ツつ津ヲツアツづ」ツつ?」ツつ?\npair<P,P> geoGetCircleOf2pAndR(P p1,P p2,double r){\n\tP pc1=P(-INF,-INF), pc2(-INF,-INF), p3;\n\tdouble d, l, dx, dy ;\n\t\n\tp3 = (p1+p2)/2.0;\n\tl = sqDist(p2,p3);\n\t\n\tif  (r*r >= l) {\n\t\td  = sqrt(r*r / l - 1.0) ;\n\t\tdx = d * (p2.y - p3.y) ;\n\t\tdy = d * (p2.x - p3.x) ;\n\t\t\n\t\tpc1.x = p3.x + dx ;\n\t\tpc1.y = p3.y - dy ;\n\t\t\n\t\tpc2.x = p3.x - dx ;\n\t\tpc2.y = p3.y + dy ;\n\t}\n\treturn pair<P,P>(pc1,pc2);\n}\n\n\nint main(){\n\tint n;\n\twhile(cin>>n&&n){\n\t\tint ans=0;\n\t\tvector<P> ps(n);\n\t\trep(i,n)cin>>ps[i].x>>ps[i].y;\n\t\t\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(sqDist(ps[i],ps[j])>4+EPS)continue;\n\t\t\t\tpair<P,P> res = geoGetCircleOf2pAndR(ps[i],ps[j],1);\n\t\t\t\tint suma=0,sumb=0;\n\t\t\t\trep(k,n){\n\t\t\t\t\tif(sqDist(ps[k],res.first )<1+EPS)suma++;\n\t\t\t\t\tif(sqDist(ps[k],res.second)<1+EPS)sumb++;\n\t\t\t\t}\n\t\t\t\tans = max(ans,max(suma,sumb));\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef pair<double,double> Point;\n#define F first\n#define S second\n#define MK make_pair\n\nPoint pls(Point a,Point b){\n  return MK(a.F+b.F,a.S+b.S);\n}\n\nPoint mns(Point a,Point b){\n  return MK(a.F-b.F,a.S-b.S);\n}\n\nPoint T(Point t){\n  return MK(t.S,-1.0*t.F);\n}\n\ndouble abs(Point a){\n  return sqrt(a.F*a.F+a.S*a.S);\n}\n\nPoint mid(Point a,Point b){\n  return MK(a.F/2+b.F/2,a.S/2+b.S/2);\n}\n\nbool in(Point c,Point t){\n  if(abs(mns(t,c))<=1){return true;}\n  return false;\n}\n\n\nint main(){\n  while(1){\n  int n;\n  cin>>n;\n  if(n==0){break;}\n  vector<Point> vp;\n  int mx=0;\n  for(int i=0;i<n;i++){\n    double a,b;\n    cin>>a>>b;\n    vp.push_back(MK(a,b));\n  }\n  sort(vp.begin(),vp.end());\n  for(int i=0;i<vp.size();i++){\n    for(int t=i+1;t<vp.size() && vp[t].F-vp[i].F<=2;t++){\n      if(abs(mns(vp[t],vp[i]))>2){continue;}\n      Point m=mid(vp[i],vp[t]);\n      Point l=mns(vp[t],vp[i]);\n      Point lt=T(l);\n      double h=sqrt(1-abs(l)*abs(l)/4);\n      lt.F=h*lt.F/abs(l);\n      lt.S=h*lt.S/abs(l);\n      Point c=pls(m,lt);\n      int count=2;\n      for(int k=0;k<vp.size();k++){\n\tif(k!=i && k!=t && in(c,vp[k])){count++;}\n      }\n      mx=max(mx,count);\n    }\n  }\n  cout<<mx<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> xy_t;\n\nconst xy_t INF_VECT = xy_t(100, 100);\nconst xy_t ZERO_VECT = xy_t(0, 0);\n\nxy_t center(xy_t p, xy_t q);\n\nint main()\n{\n    int num;\n    while(1){\n        cin >> num;\n        if(num == 0) break;\n        \n        xy_t point[num];\n        for(int i = 0; i < num; i++){\n            double x, y;\n            cin >> x >> y;\n            point[i] = xy_t(x, y);\n        }\n\n        int max = 0;\n        for(int i = 0; i < num-1; i++){\n            for(int j = i+1; j < num; j++){\n                xy_t vec = center(point[i], point[j]);\n                if(vec != ZERO_VECT && vec != INF_VECT){\n                    xy_t mid = (point[i] + point[j]) * xy_t(0.5, 0);\n                    xy_t cent = mid + vec;\n                    int cnt = 0;\n                    for(int k =0; k < num; k++){\n                        xy_t r = point[k] - cent;\n                        if(abs(r) <= 1) cnt++;\n                    }\n                    if(cnt > max) max = cnt;\n\n                    cent = mid - vec;\n                    cnt = 0;\n                    for(int k =0; k < num; k++){\n                        xy_t r = point[k] - cent;\n                        if(abs(r) <= 1) cnt++;\n                    }\n                    if(cnt > max) max = cnt;\n                }\n            }\n        }\n        \n        cout << max << endl;\n        \n    }\n    return 0;\n}\n\n\nxy_t center(xy_t p, xy_t q)\n{    \n    xy_t r = q-p;\n    double d = abs(r);\n\n    if(d > 2){\n        return INF_VECT;\n    }\n    else if(d == 2){\n        return ZERO_VECT;\n    }\n    else{\n        double l = sqrt(4 - d*d) / 2;\n        xy_t r_ = r * xy_t(0, 1);\n        r_ *= xy_t(l/d, 0);\n        return r_;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,N) for(int i=0;i<(int)(N);i++)\n#define REP(i,k,N) for(int i=k;i<(int)(N);i++)\n\n#define vi vector<int>\n#define pb push_back\n\n#define pdd pair<double,double>\n#define fi first\n#define se second\nconst double  EPS = 1e-8;\n\ndouble dist(double x,double y){\n    return x*x+y*y;\n};\n\nint main(){\n//    ifstream in(\"d_in.txt\");\n//    cin.rdbuf(in.rdbuf());\n    int n;\n    while(cin >> n,n){\n        int ma = 0;\n        pdd p[330];\n        rep(i,n) cin >> p[i].fi >> p[i].se;\n        rep(i,n-1){\n            REP(j,i+1,n){\n                int cnt1 = 0,cnt2=0;\n                double x1,y1,x2,y2,x3,y3;\n                tie(x1,y1) = p[i];\n                tie(x2,y2) = p[j];\n                double cx1,cy1,cx2,cy2;\n                if(dist(x1-x2,y1-y2)  > 4+EPS  ) continue;\n\n                //はりまコーナー\n//                double ax,ay,bx1,by1,bx2,by2,mx,my,dx,dy;\n//                ax=x1-x2;ay=y1-y2;\n//                mx=(x1+x2)/2;my=(y1+y2)/2;\n//                by1 = (-0.5)*pow(ax,4)+pow(ax,2)+(-0.5)*pow(ax,2)*pow(ay,2)\n//                        /dist(ax,ay);\n//                by1 = sqrt(abs(by1));\n//                by2 = -1*by1;\n//                cy1= my+by1;\n//                cy2= my+by2;\n//                bx1= -1*(ay*by1)/ax;\n//                bx2= -1*(ay*by2)/ax;\n//                cx1=bx1+mx;\n//                cx2=bx2+mx;\n\n\n                //あじのりコーナー\n                double mx=(x1+x2)/2,my=(y1+y2)/2;\n\n                double ld = 1-dist((x1-x2)/2,(y1-y2)/2);\n                ld = sqrt(ld);\n                cx1 = mx - sin(atan((y2-y1)/(x2-x1)))*ld;\n                cy1 = my + cos(atan((y2-y1)/(x2-x1)))*ld;\n                cx2 = mx + sin(atan((y2-y1)/(x2-x1)))*ld;\n                cy2 = my - cos(atan((y2-y1)/(x2-x1)))*ld;\n\n                for(int k = 0;k<n;k++) {\n                    tie(x3, y3) = p[k];\n                    if (EPS + 1> dist((cx1 - x3), (cy1 - y3))) cnt1++;\n                    if (EPS + 1> dist((cx2 - x3), (cy2 - y3))) cnt2++;\n                }\n                ma = max({cnt1,cnt2,ma});\n            }\n        }\n        cout<< ma << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nconst double EPS = 1e-8;\n\nint n;\nPoint data[300];\n\nint calc(Point a, Point b){\n  int res = 0;\n  double d = abs(b - a) / 2.0;\n  Point ab = (b - a) / (2.0 * d);\n  if(d < 1){\n    Point o = ab * d;\n    d = sqrt(1.0 - d * d);\n    o += Point(d * ab.imag() + a.real(), -d * ab.real() + a.imag());\n    for(int i=0;i<n;i++){\n      if(abs(o - data[i]) < 1.0 + EPS) res++;\n    }\n  }\n  return res;\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      cin >> data[i].imag() >> data[i].real();\n    }\n    int ans = 1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        ans = max(ans, calc(data[i], data[j]));\n        ans = max(ans, calc(data[j], data[i]));\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define F first\n#define S second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\nconst int inf = 1LL << 55;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\n// ???/????????????\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n  \n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// ???\nstruct Circle {\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0):c(c), r(r){}\n};\n\n// ????§???¢\ntypedef vector<Point> Polygon;\n\n// ??????/??´???\nstruct Segment {\n  Point p1, p2;\n};\ntypedef Segment Line;\n\n// ????????????????????????\ndouble norm(Vector v)\n{\n  return v.x*v.x + v.y*v.y;\n}\n// ?????????????????§??????\ndouble abs(Vector v)\n{\n  return sqrt(norm(v));\n}\n// ?????????????????????\ndouble dot(Vector a, Vector b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n// ??????????????????????????§??????\ndouble cross(Vector a, Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n// ??´?????????\nbool isOrthogonal(Vector a, Vector b)\n{\n  return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2)\n{\n  return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ????????????\nbool isParallel(Vector a, Vector b)\n{\n  return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n  return isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2)\n{\n  return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ?°???±\nPoint project(Segment s, Point p)\n{\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\n// ????°?\nPoint reflect(Segment s, Point p)\n{\n  return p + (project(s, p) - p) * 2.0;\n}\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE         = -1;\nstatic const int ONLINE_BACK       = 2;\nstatic const int ONLINE_FRONT      = -2;\nstatic const int ON_SEGMENT        = 0;\n// ???????¨???????\nint ccw(Point p0, Point p1, Point p2)\n{\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n// ????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2)\n{\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n// ?????????????????¢\ndouble getDistance(Point a, Point b)\n{\n  return abs(a - b);\n}\n// ??´?????¨?????¨????????¢\ndouble getDistanceLP(Line l, Point p)\n{\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n// ????????¨?????¨????????¢\ndouble getDistanceSP(Segment s, Point p)\n{\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n// ????????????????????¢\ndouble getDistance(Segment s1, Segment s2)\n{\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n// ???????????????\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n// ???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l)\n{\n  // assert(intersect(c, l));\n  Vector pr = project(l, c.c);\n  Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n  double base = sqrt(c.r*c.r - norm(pr - c.c));\n  return make_pair(pr + e * base, pr - e * base);\n}\n// ???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\npair<Point, Point> getCrossPoints(Circle c1, Circle c2)\n{\n  // assert(intersect(c1, c2));\n  double d = abs(c1.c - c2.c);\n  double a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2*c1.r*d));\n  double t = arg(c2.c - c1.c);\n  return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n// ????????????\nstatic const int IN_POLYGON = 2;\nstatic const int ON_POLYGON = 1;\nstatic const int OUT_POLYGON = 0;\nint contains(Polygon g, Point p)\n{\n  int n = g.size();\n  bool x = false;\n  for(int i = 0; i < n; i++) {\n    Point a = g[i] - p, b = g[(i+1) % n] - p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON_POLYGON;\n    if(a.y > b.y) swap(a, b);\n    if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n  }\n  return (x ? IN_POLYGON : OUT_POLYGON);\n}\n\nsigned main()\n{\n  int N;\n  while(cin >> N, N) {\n    vector<Point> p(N);\n    rep(i, N) cin >> p[i].x >> p[i].y;\n    int ans = 0;\n    rep(i, N) reps(j, i+1, N) {\n      if(getDistance(p[i], p[j]) < 2.0 + EPS) {\n\tCircle c1(p[i], 1.0), c2(p[j], 1.0);\n\tauto cp = getCrossPoints(c1, c2);\n\tint cnt = 0;\n\trep(k, N) if(getDistance(cp.first, p[k]) < 1.0 + EPS) cnt++;\n\tans = max(ans, cnt);\n\tcnt = 0;\n\trep(k, N) if(getDistance(cp.second, p[k]) < 1.0 + EPS) cnt++;\n\tans = max(ans, cnt);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble Dis(double x1, double y1, double x2, double y2);\nint main(void){\n\twhile(1){\n\t\tint n;\n\t\tint ans = 1;\n\t\tvector< pair<double, double> > p;\n\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tpair<double, double> t;\n\t\t\tcin >> t.first >> t.second;\n\t\t\tp.push_back(t);\n\t\t}\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t//中点\n\t\t\t\tdouble mpx = (p[i].first + p[j].first) / 2.0;\n\t\t\t\tdouble mpy = (p[i].second + p[j].second) / 2.0;\n\t\t\t\t//2点間の距離\n\t\t\t\tdouble d1 = Dis(p[i].first, p[i].second, p[j].first, p[j].second);\n\t\t\t\t//p[i]からp[j]へ向かうベクトル\n\t\t\t\tdouble v1x = (p[i].first - p[j].first) / d1;\n\t\t\t\tdouble v1y = (p[i].second - p[j].second) / d1;\n\t\t\t\t//中点から円の中心へ向かう単位ベクトル\n\t\t\t\tdouble v2x = -v1y;\n\t\t\t\tdouble v2y = v1x;\n\t\t\t\t//中心から円の中心へ向かうベクトルの長さ\n\t\t\t\tdouble d2 = sqrt(1.0 - (d1*d1/4.0)));\n\n\t\t\t\t//円の中心の座標\n\t\t\t\tdouble cx = mpx + v2x * d2;\n\t\t\t\tdouble cy = mpy + v2y * d2;\n\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(k == i || k == j || Dis(cx, cy, p[k].first, p[k].second) <= 1.0)\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt > ans){\n\t\t\t\t\tans = cnt;\n\t\t\t\t}\n\n\t\t\t\tcx = mpx - v2x * d2;\n\t\t\t\tcy = mpy - v2y * d2;\n\n\t\t\t\tcnt = 0;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(Dis(cx, cy, p[k].first, p[k].second) <= 1.0)\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt > ans){\n\t\t\t\t\tans = cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\n\t}\n\t\n\treturn 0;\n}\n\ndouble Dis(double x1, double y1, double x2, double y2){\n\treturn sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>  \n#include <algorithm>\n#include <iostream>\n#include <utility>\n\nusing namespace std;\n\nconst double eps=1e-8; \nstruct point{\n\tdouble x,y;\t\n}P[310];\nint x,y,N;\nint ans=1;\n\ndouble cal_distance(point a, point b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\npoint cal_center(point a, point b){\n\tpoint mid,center;\n\tmid.x = (a.x+b.x)/2.0;\n\tmid.y = (a.y+b.y)/2.0;\n\tdouble angle = atan2(a.x-b.x,b.y-a.y);\n\tdouble line = sqrt(1-(cal_distance(a,mid)*cal_distance(a,mid)));\n\tcenter.x = mid.x+line*cos(angle);\n\tcenter.y = mid.y+line*sin(angle);\n\treturn center;\n}\n\nint main(){\n\twhile(cin >> N && N>0){\n\t\tfor (int i=0; i<N; i++){\n\t\t\t\tcin >> P[i].x >> P[i].y;\n\t\t\t}\n\t\t\tfor (int i=0; i<N; i++){\n\t\t\t\tfor (int j=i+1; j<N; j++){\n\t\t\t\t\tif (cal_distance(P[i],P[j]) > 2.0) continue;\n\t\t\t\t\tpoint center = cal_center(P[i], P[j]);\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tfor (int k=0; k<N;k++){\n\t\t\t\t\t\tif (cal_distance(P[k],center) < (1.0+eps)) count++;\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans,count);\n\t\t\t\t}\n\t\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> p;\nconst double eps = 1e-9;\n\nint n;\np ps[300];\n\nint main() {\n\twhile (cin >> n , n != 0) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tps[i] = p(x, y);\n\t\t}\n\n\t\tif (n == 1) {\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tp v = ps[i] - ps[j], ve = v / abs(v);\n\t\t\t\tdouble l = sqrt(1 - norm(v) * 0.25);\n\t\t\t\tp vn1 = ve * p(0, 1) * l, vn2 = ve * p(0, -1) * l;\n\t\t\t\tp c1 = ps[j] + v * 0.5 + vn1, c2 = ps[j] + v * 0.5 + vn2;\n\t\t\t\tint count1 = 2, count2 = 2;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (k == i || k == j) continue;\n\t\t\t\t\tif (norm(c1 - ps[k]) < 1.0 + eps) count1++;\n\t\t\t\t\tif (norm(c2 - ps[k]) < 1.0 + eps) count2++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, count1);\n\t\t\t\tans = max(ans, count2);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\ntypedef long double ld;\n\nstruct Point {\n    ld x, y;\n    Point(ld x=0.0, ld y=0.0) : x(x), y(y) {}\n    string to_s() {\n        ostringstream os;\n        os << x << ',' << y;\n        return os.str();\n    }\n    Point operator+(const Point& o) const {\n        return Point(x+o.x, y+o.y);\n    }\n};\n\nstruct Circle {\n    ld x, y;\n    ld r;\n    Circle(ld x=0.0, ld y=0.0, ld r=1.0) : x(x), y(y), r(r) {}\n    const static ld eps = 1e-8;\n    bool isIntersect(const Circle& o) const {\n        ld dx = o.x - x;\n        ld dy = o.y - y;\n        return (r + o.r) * (r + o.r) > (dx*dx + dy*dy);\n    }\n    pair<Point, Point> intersectionPoint(const Circle& o) const {\n        ld dx = x - o.x;\n        ld dy = y - o.y;\n        ld a = (dx*dx + dy*dy + r*r - o.r*o.r) / 2.0;\n        ld d = sqrt((dx*dx+dy*dy)*r*r-a*a);\n        Point p, q;\n        p.x = (a*dx + dy * d) / (dx*dx+dy*dy) + o.x;\n        q.x = (a*dx - dy * d) / (dx*dx+dy*dy) + o.x;\n        p.y = (a*dy - dx * d) / (dx*dx+dy*dy) + o.y;\n        q.y = (a*dy + dx * d) / (dx*dx+dy*dy) + o.y;\n        //cout << p.x << ',' << p.y << endl;\n        //cout << q.x << ',' << q.y << endl;\n        return make_pair(p, q);\n    }\n    bool contains(ld px, ld py) const {\n        return r*r + eps >= (px - x) * (px - x) + (py - y) * (py - y);\n    }\n    string to_s() {\n        ostringstream os;\n        os << x << ',' << y << ':' << r << endl;\n        return os.str();\n    }\n};\n\nint countContainingPoints(const Circle& c, const vector<Circle>& ps) {\n    int cnt = 0;\n    for (int i = 0; i < ps.size(); i++) \n        if (c.contains(ps[i].x, ps[i].y)) \n            cnt++;\n    return cnt;\n}\n\nint N;\nint main() {\n    //cout << Circle(0, 0, 5).intersectionPoint(Circle(8, 0, 5)).first.to_s() << endl;\n    vector<Circle> cs;\n    while (cin >> N, N) {\n        cs.clear(); cs.resize(N);\n        for (int i = 0; i < N; i++) cin >> cs[i].x >> cs[i].y;\n\n        vector<Point> ips; // Intersection PointS\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (i == j) continue;\n                if (!cs[i].isIntersect(cs[j])) continue;\n                pair<Point, Point> ip = cs[i].intersectionPoint(cs[j]);\n                ips.push_back(ip.first);\n                ips.push_back(ip.second);\n            }\n        }\n\n        if (ips.empty()) {\n            cout << 1 << endl;\n            continue;\n        }\n\n        int maxPoint = 0;\n        for (int i = 0; i < ips.size(); i++) {\n            maxPoint = max(maxPoint, countContainingPoints(Circle(ips[i].x, ips[i].y, 1.0), cs));\n        }\n        cout << maxPoint << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double R;//double long double の切り替え cmathの関数はオーバーロードに対応しているので問題ない\ntypedef complex<R> Point;\ntypedef pair<Point , Point> Line;\ntypedef pair<Point ,R > Circle;\ntypedef vector<Point> Poly;\n\n#define EPS (1e-10)//誤差\n#define EQ(a,b) (abs((a)-(b)) < EPS)//２つの実数が等しいか\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )//２つのベクトルが等しいか\n#define ft first\n#define sd second\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nR dot(Point a,Point b){//内積ok\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nR cross(Point a,Point b){//外積ok\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\n\n\nbool is_orthogonal(Line a,Line b){//2直線の直行判定ok\n    return EQ(dot(a.ft - a.sd,b.ft - b.sd),0.0);\n}\nbool is_parallel(Line a,Line b){//2直線の並行判定ok\n    return EQ(cross(a.ft - a.sd,b.ft - b.sd),0.0);\n}\n\n\n\n////////////////////交差判定\nint ccw(Point a,Point b,Point c){//ok\n    b -= a; c -= a;\n    if(cross(b,c) > EPS) return 1;//a→bで反時計周りに折れてb→c\n    if(cross(b,c) < -EPS) return -1;//a→bで時計周りに折れてb→c\n    if(dot(b,c) < -EPS) return 2;//c--a--b on same line\n    if(norm(c) - norm(b) > EPS) return -2;//a--b--c(absじゃなくて二乗するのは差が出やすいから?)\n    return 0;//a--c--bまたはb==c\n}\n\nbool is_intersection_ll(Line l,Line m){//２つの直線が交わるかok\n    return abs(cross(l.sd - l.ft,m.sd - m.ft)) > EPS || //平行でない\n        abs(cross(l.sd - l.ft,m.ft - l.ft)) < EPS; //平行だが同じ線\n}\n\nbool is_intersection_ls(Line l,Line s){//直線lと線分sが交わるか\n    return cross(l.sd - l.ft, s.ft-l.ft)*       // s[0] is left of l\n        cross(l.sd - l.ft, s.sd - l.ft) < EPS; // s[1] is right of l\n}\n\nbool is_intersection_lp(Line l,Point p){//直線lと点pが交わるか\n    return abs(cross(l.sd - p,l.ft - p));\n}\n\nbool is_intersection_ss(Line a,Line b){//２つの線分が交わるかok\n    return ccw(a.ft,a.sd,b.ft)*ccw(a.ft,a.sd,b.sd) <= 0 && ccw(b.ft,b.sd,a.ft)*ccw(b.ft,b.sd,a.sd) <= 0;\n}\n\nbool is_intersection_sp(Line s,Point p){//線分と点の交差判定 三角不等式の利用\n    return abs(s.ft - p) + abs(s.sd - p) - abs(s.ft - s.sd) < EPS;\n}\n\n\nbool intersection_cc(Circle c1,Circle c2){//２つの円の交差判定ok\n    return abs(c1.ft - c2.ft) - (c1.sd + c2.sd) < -EPS;\n}\n\n\n/////////////距離\nR dis_lp(Line l,Point p){//直線lと点pの距離ok\n    return abs(cross(l.sd - l.ft,p - l.ft)) / abs(l.sd - l.ft);\n}\n\nR dis_ll(Line l,Line m){//２つの直線の距離\n    return is_intersection_ll(l,m) ? 0.0 : dis_lp(l,m.ft);\n}\n\nR dis_ls(Line l,Line s){//直線lと線分sの距離\n    if(is_intersection_ls(l,s)) return 0.0;\n    return min(dis_lp(l,s.ft),dis_lp(l,s.sd));\n}\n\nR dis_sp(Line s,Point p){//線分sと点pの距離ok\n    if(dot(s.sd - s.ft,p - s.ft) < EPS) return abs(p - s.ft);\n    if(dot(s.ft - s.sd,p - s.sd) < EPS) return abs(p - s.sd);\n    return dis_lp(s,p);\n}\n\nR dis_ss(Line s,Line t){//２つの線分の距離ok\n    if(is_intersection_ss(s,t)) return 0.0;\n    return min(min(dis_sp(s,t.ft),dis_sp(s,t.sd)),\n            min(dis_sp(t,s.ft),dis_sp(t,s.sd)));\n}\n\n\n\n//////////////射影と反射\nPoint projection(Line l,Point p){//射影を求めるok\n    R t = dot(p - l.ft,l.ft - l.sd) / norm(l.ft - l.sd);\n    return l.ft + t * (l.ft - l.sd);\n}\n\nPoint reflection(Line l,Point p){//反射を求めるok\n    return p + (R)2.0 * (projection(l,p) - p);\n}\n\n//////////////垂直なベクトル\nPoint vertical_vec(Point v) {\n    return Point(-v.imag(),v.real());\n}\n\n//////////////ヴェクタを正規化\nPoint normalized(Point v) {\n    R a = abs(v);\n    return v / a;\n}\n\n//////////////交点(交差する保証してないときは交差判定してからつかってね)\n\nPoint intersection_ll(Line l,Line m){//交差判定してるなら線分にも使えるok\n    R A = cross(l.sd - l.ft,m.sd - m.ft);\n    R B = cross(l.sd - l.ft,l.sd - m.ft);\n    if(abs(A) < EPS && abs(B) < EPS) return m.ft;//同じ線\n    //if(abs(A) < EPS)assert(false);//並行で交点なし\n    return m.ft + B / A * (m.sd - m.ft);\n}\n\nLine intersection_of_two_circles(Circle c1,Circle c2){//ok ２つの円の交点をLineに入れて返す(r1 + r2 > sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2))を満たす必要があるok\n    R a =  abs(c2.ft - c1.ft);\n    R b = c1.sd;\n    R c = c2.sd;\n\n    R rc = (a  * a + b * b - c * c) / (2.0 * a);\n    R rs = sqrt(b * b - rc * rc);//C++ ではオーバーロードが可能であるため、sqrt または float 型を受け取る long double のオーバーロードを呼び出すことができます。 C プログラムでは、sqrt は常に double を受け取って返します。\n    Point diff = (c2.ft - c1.ft) / a;\n\n    Line p ;\n    p.ft = c1.ft + diff * rc + diff * Point(0,1) * rs;\n    p.sd = c1.ft + diff * rc + diff * Point(0,-1) * rs;\n\n    return p;\n}\n\n\n/////////////////////////polygon\n\n#define currP(P,i) P[(i) % P.size()]//今の頂点\n#define nextP(P,i) P[((i) + 1)%P.size()]//次の頂点\n\nint is_contains_p_in_Poly(Poly po,Point p){//点が多角形の内部(1)、境界(-1)、外部(0)のどこにあるかを判定ok\n    bool in = false;\n    REP(i,po.size()){\n        Point a = currP(po,i) - p,b = nextP(po,i) - p;\n        if(a.imag() > b.imag())swap(a,b);\n        if(a.imag() < EPS && EPS < b.imag())\n            if(cross(a,b) < -EPS) in = !in;\n        if(EQ(cross(a,b),0.0) && dot(a,b) < EPS)return  -1;\n    }\n    return in;\n}\n\nR area2(Poly po){//多角形の面積の二倍を求めるok\n    R A = 0.0;\n    REP(i,po.size())\n        A += cross(currP(po,i),nextP(po, i));\n    return A;\n}\n\n\n\n\n///////////////////////////凸\n\nbool comp_complex_real(Point a,Point b){//x→yの辞書順ok\n    if(EQ(a.real(),b.real()))\n        return b.imag() - a.imag() > EPS;\n    return b.real() - a.real() > EPS;\n}\n\nPoly convex_hull(Poly ps){//凸包ok\n    int n = ps.size(),k = 0;\n    sort(ps.begin(),ps.end(),comp_complex_real);\n    Poly ch(2*n);\n    for(int i = 0;i < n;ch[k++] = ps[i++])// lower-hull\n        while(k >= 2 && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0 && ccw(ch[k - 2],ch[k - 1],ps[i]) > -2) --k;//３つ目の条件は180度を含むときのみ必要\n    for(int i = n - 2,t = k + 1;i >= 0;ch[k++] = ps[i--])//upper-hull\n        while(k >= t && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0 && ccw(ch[k - 2],ch[k - 1],ps[i]) > -2) --k;//上に同じ\n    ch.resize(k - 1);\n    return ch;\n}\n#define prevP(P, i) P[(i+P.size()-1) % P.size()]\nbool isconvex(Poly P){//凸性判定時計回り反時計周りに対応\n    bool cl = false,ccl = false;\n    for(int i = 0;i < P.size();++i){\n        int c = ccw(prevP(P,i),currP(P,i),nextP(P,i));\n        if(c == -2)continue;//180度を含むときのみ　360度も含むときはc == -2 || c == 0\n        if(c == 1)ccl = true;\n        else if(c == 2)cl = true;\n        else return false;\n    }\n    return !(cl && ccl);\n}\nPoint p[1000];\nint n;\n\nint inner(Point c) {\n    int ret = 0;\n    REP(i,n) {\n        if(abs(c - p[i]) <= 1.0) {\n            ret++;\n        }\n    }\n    return ret;\n}\n\nint main(){\n    while(true) {\n        cin >> n;\n        if(n == 0)break;\n        REP(i,n) {\n            double x,y;\n\n            cin >> x >> y;\n\n            p[i] = Point(x,y);\n        }\n        int ans = 0;\n\n        REP(i,n) {\n            FOR(j,i+1,n) {\n                Point a = p[i];\n                Point b = p[j];\n\n                Point x = b - a;\n\n                Point y = vertical_vec(x);\n                y = normalized(y);\n\n                R c = abs(x) / 2;\n\n                if(c > 1)continue;\n\n                R d = sqrt(1 - c * c);\n\n                y *= d;\n\n                Point m = (a  + b) / 2.0;\n                ans = max(ans,inner(m+y));\n                ans = max(ans,inner(m-y));\n\n\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nconst double eps=1e-10;\ndouble add(double a,double b){\n    if(abs(a+b)<eps*(abs(a)+abs(b)))return 0;\n    return a+b;\n}\n\ntypedef pair<double,double> P;\nP operator+(const P& x,const P& y){\n    return {add(x.first,y.first),add(x.second,y.second)};\n}\n\nP operator-(const P& x,const P& y){\n    return {add(x.first,-y.first),add(x.second,-y.second)};\n\n}\n\nP operator*(const P& x,const double& y){\n    return {x.first*y,x.second*y};\n}\ndouble dot(P x,P y){\n    return add(x.first*y.first,x.second*y.second);\n\n\n}\n\ndouble det(P x,P y){\n    return add(x.first*y.second,-x.second*y.first);\n}\n\nbool onseg(P p1,P p2,P q){\n    return det(p1-q,p2-q)==0 &&dot(p1-q,p2-q)<=0; \n}\n\nP intersection(P p1,P p2,P q1,P q2){\n    return p1+(p2-p1)*(det(q2-q1,q1-p1)/det(q2-q1,p2-p1));\n}\n\nbool cross(P p1,P p2,P q1,P q2){\n    if(det(p1-p2,q1-q2)==0)return onseg(p1,p2,q1)||onseg(p1,p2,q2)||onseg(q1,q2,p1)||onseg(q1,q2,p2);\n    P ret=intersection(p1,p2,q1,q2);\n    return onseg(p1,p2,ret)&&onseg(q1,q2,ret);\n}\n\ndouble dist(P p1,P p2,P q){\n    if(dot(q-p1,p2-p1)<=0)return sqrt(dot(q-p1,q-p1));\n    if(dot(q-p2,p1-p2)<=0)return sqrt(dot(q-p2,q-p2));\n    P d=p1-p2;\n    P ret=q+P{d.second,-d.first};\n    P h=intersection(p1, p2, q, ret);\n    return sqrt(dot(q-h,q-h));\n}\ndouble d(P p,P q){\n    return sqrt(dot(p-q,p-q));\n}\n\nint main(){\n    int n;\n    while(cin>>n,n!=0){\n        P a[n];\n        rep(i,n)cin>>a[i].first>>a[i].second;\n        int ans=0;\n        rep(i,n)rep(j,n){\n            if(i==j)continue;\n            if(d(a[i],a[j])>2)continue;\n            P v=(a[i]-a[j])*(1.0/d(a[i],a[j]));\n            P h=P{v.second,-v.first};\n            P c=(a[i]+a[j])*(1.0/2)+h*sqrt(1.0-dot(a[i]-a[j],a[i]-a[j])/4);\n            int ret=2;\n            rep(k,n){\n                if(k==i||k==j)continue;\n                if(d(a[k],c)<=1)ret++;\n            }\n            ans=max(ans,ret);\n            c=(a[i]+a[j])*(1.0/2)-h*sqrt(1.0-dot(a[i]-a[j],a[i]-a[j])/4);\n            ret=2;\n            rep(k,n){\n                if(k==i||k==j)continue;\n                if(d(a[k],c)<=1)ret++;\n            }\n            ans=max(ans,ret);\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef long double Real;\n\nReal eps = 1e-9;\n\nReal add(Real a, Real b) {\n    if (abs(a+b) < eps * (abs(a)+abs(b))) return 0;\n    return a+b;\n}\n\nbool equal(Real a, Real b) {\n    return add(a, -b) == 0;\n}\n\nstruct P {\n    Real x, y;\n    P() {}\n    P(Real x, Real y) : x(x), y(y) {}\n    P operator+(P p) const {return P(add(x, p.x), add(y, p.y));}\n    P operator-(P p) const {return P(add(x, -p.x), add(y, -p.y));}\n    P operator*(Real d) const {return P(x*d, y*d);}\n    Real dot(P p) const {return add(x*p.x, y*p.y);} // ??????\n    Real det(P p) const {return add(x*p.y, -y*p.x);} // ??????\n    Real dist(P p) const {return sqrt((x-p.x)*(x-p.x) + (y-p.y)*(y-p.y));} // ?????¢\n    void normalize() {Real d = sqrt(x*x+y*y); x /= d; y /= d;} // ??£??????\n    bool operator<(const P& rhs) const {\n        if (x != rhs.x) return x < rhs.x;\n        return y < rhs.y;\n    }\n    bool operator==(const P& rhs) const {\n        return equal(x, rhs.x) && equal(y, rhs.y);\n    }\n};\nconst int MAXN = 333;\nP pnt[MAXN];\nint N;\n\nint calc(P center) {\n\tint ret = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tP vec = pnt[i]-center;\n\t\tif (vec.dot(vec) < 1+eps) {\n\t\t\tret++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (cin >> N) {\n    \tif (N==0) break;\n    \tfor (int i = 0; i < N; i++) \n    \t\tcin >> pnt[i].x >> pnt[i].y;\n    \tint ans = 1;\n    \tfor (int i = 0; i < N; i++) for (int j = i+1; j < N; j++) {\n    \t\tif (pnt[i].dist(pnt[j]) > 2) continue;\n    \t\t// diff ?????????\n    \t\tP vec = pnt[j]-pnt[i];\n    \t\t// vec ????????´????????????????????????\n    \t\tP n = P(vec.y, -vec.x);\n    \t\tn.normalize();\n    \t\tvec = vec*0.5;\n    \t\tReal len = sqrt(1-vec.dot(vec));\n    \t\tP cand1 = pnt[i] + vec + n*len;\n    \t\tP cand2 = pnt[i] + vec - n*len;\n    \t\tans = max(ans, calc(cand1));\n    \t\tans = max(ans, calc(cand2));\n    \t}\n    \tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define EPS 1e-8\ntypedef complex<double> Point;\n \nint main(){\n    int N;\n    while(cin >> N,N){\n\tPoint p[N];\n\tfor(int i = 0 ; i < N ; i++){\n\t    cin >> p[i].real() >> p[i].imag();\n\t}\n\tint res = 1;\n\tfor(int i = 0 ; i < N-1 ; i++){\n\t    for(int j = i+1 ; j < N ; j++){\n\t\tPoint np = p[j]-p[i];\n\t\tdouble d = abs(np);\n\t\tif(d + EPS > 2.0){ continue; }\n\t\tnp /= d;\n\t\tnp *= Point(0,1);\n\t\tPoint cp = (p[i]+p[j])/2.0;\n\t\tPoint v = sqrt(1.0-d*d/4.0)*np;\n\t\tint cnt = 2;\n\t\tPoint center = cp + v;\n\t\tfor(int k = 0 ; k < N ; k++){\n\t\t    if(i == k || j == k) continue;\n\t\t    Point diff = center-p[k];\n\t\t    if(norm(diff) < 1.0 + EPS){\n\t\t\tcnt++;\n\t\t    }\n\t\t}\n\t\tres = max(res,cnt);\n\t    }\n\t}\n\tcout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst double EPS = 1e-6;\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tdouble x[n], y[n];\n\t\trep(i,n) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tint maxi = 1;\n\t\trep(i, n) {\n\t\t\tfor(int j=i+1; j<n; j++) {\n\t\t\t\tif( ((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])) > 4.0 ) continue;\n\t\t\t\tdouble mx = (x[i]+x[j]) / 2.0;\n\t\t\t\tdouble my = (y[i]+y[j]) / 2.0;\n\t\t\t\tdouble px0, py0, px1, py1;\n\t\t\t\tif( fabs(y[i]-y[j]) < EPS ) {\n\t\t\t\t\tpx0 = px1 = mx;\n\t\t\t\t\tpy0 = my + sqrt(1.0 - (x[i]-mx)*(x[i]-mx));\n\t\t\t\t\tpy1 = my - sqrt(1.0 - (x[i]-mx)*(x[i]-mx));\n\t\t\t\t} else if( fabs(x[i]-x[j]) < EPS ) {\n\t\t\t\t\tpy0 = py1 = my;\n\t\t\t\t\tpx0 = mx + sqrt(1.0 - (y[i]-my)*(y[i]-my));\n\t\t\t\t\tpx1 = mx - sqrt(1.0 - (y[i]-my)*(y[i]-my));\n\t\t\t\t} else {\n\t\t\t\t\tdouble m = - (x[i]-x[j]) / (y[i]-y[j]);\n\t\t\t\t\tdouble l = sqrt(1.0 - ((x[i]-mx)*(x[i]-mx)+(y[i]-my)*(y[i]-my)));\n\t\t\t\t\tpx0 = mx + sqrt(l*l/(1.0+m*m));\n\t\t\t\t\tpx1 = mx - sqrt(l*l/(1.0+m*m));\n\t\t\t\t\tpy0 = my + m * (px0-mx);\n\t\t\t\t\tpy1 = my + m * (px1-mx);\n\t\t\t\t}\n\t\t\t\tint cnt0 = 0, cnt1 = 0;\n\t\t\t\trep(k, n) {\n\t\t\t\t\tdouble d0 = (px0-x[k])*(px0-x[k]) + (py0-y[k])*(py0-y[k]);\n\t\t\t\t\tif( d0 <= 1.0+EPS ) {\n\t\t\t\t\t\tcnt0++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(k, n) {\n\t\t\t\t\tdouble d1 = (px1-x[k])*(px1-x[k]) + (py1-y[k])*(py1-y[k]);\n\t\t\t\t\tif( d1 <= 1.0+EPS ) {\n\t\t\t\t\t\tcnt1++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxi = max(maxi, cnt0);\n\t\t\t\tmaxi = max(maxi, cnt1);\n\t\t\t}\n\t\t}\n\t\tcout << maxi << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1000000000;\nconst long long int llINF = 1000000000000000000;\n\nusing namespace std;\nusing ll = long long int;\nusing vl = vector<ll>;\nusing vvl = vector<vector<ll>>;\nusing vvvl = vector<vector<vector<ll>>>;\n\ntypedef pair<ll, ll> pll;\nbool paircomp(const pll &a, const pll &b) {\n  if (a.first == b.first)\n    return a.second < b.second;\n  return a.first < b.first;\n}\nstruct multi {\n  ll first;\n  ll second;\n  ll third;\n};\nbool multicomp(const multi &a, const multi &b) {\n  if (a.first == b.first)\n    return a.second < b.second;\n  return a.first < b.first;\n}\n#define REP(i, n) for (ll i = 0; i < (n); i++)\n#define RREP(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define FOR(i, a, b) for (ll i = (a); i < (b); i++)\n#define AUTO(i, m) for (auto &i : m)\n#define ALL(a) (a).begin(), (a).end()\n#define MAX(vec) *std::max_element(vec.begin(), vec.end())\n#define MIN(vec) *std::min_element(vec.begin(), vec.end())\n#define ARGMAX(vec)                                                            \\\n  std::distance(vec.begin(), std::max_element(vec.begin(), vec.end()))\n#define ARGMIN(vec)                                                            \\\n  std::distance(vec.begin(), std::min_element(vec.begin(), vec.end()))\n#define REV(T) greater<T>()\n#define PQ(T) priority_queue<T, vector<T>, greater<T>>\n#define VVL(a, b, c) vector<vector<ll>>(a, vector<ll>(b, c))\n#define VVVL(a, b, c, d)                                                       \\\n  vector<vector<vector<ll>>>(a, vector<vector<ll>>(b, vector<ll>(c, d)))\n#define SP(a) setprecision(a)\n#define SQRT(a) sqrt((long double)(a))\n#define DPOW(a, b) pow((long double)(a), (long double)(b))\n#define UNIQUE(vec)                                                            \\\n  do {                                                                         \\\n    sort(ALL((vec)));                                                          \\\n    (vec).erase(std::unique(ALL((vec))), (vec).end());                         \\\n  } while (0)\n\nll POW(ll n, ll m) {\n  if (m == 0) {\n    return 1;\n  } else if (m % 2 == 0) {\n    ll tmp = POW(n, m / 2);\n    return (tmp * tmp);\n  } else {\n    return (n * POW(n, m - 1));\n  }\n}\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nlong double calc(ll N) {\n  vector<long double> X(N, 0), Y(N, 0);\n  REP(i, N) cin >> X[i] >> Y[i];\n  ll ans = 1;\n  REP(i, N - 1) FOR(j, i + 1, N) {\n    long double dist2 = DPOW(X[i] - X[j], 2) + DPOW(Y[i] - Y[j], 2);\n    if (dist2 >= 4.00001)\n      continue;\n    long double dist = SQRT(dist2);\n    long double cx = (long double)(X[i] + X[j]) / 2;\n    long double cy = (long double)(Y[i] + Y[j]) / 2;\n    long double kdist = SQRT((long double)1 - (dist2 / 4));\n\n    long double kx1 = cx + ((-Y[i] + Y[j]) * kdist / dist);\n    long double ky1 = cy + ((X[i] - X[j]) * kdist / dist);\n    long double kx2 = cx - ((-Y[i] + Y[j]) * kdist / dist);\n    long double ky2 = cy - ((X[i] - X[j]) * kdist / dist);\n\n    ll ans1 = 0, ans2 = 0;\n    REP(k, N) {\n      if (DPOW(X[k] - kx1, 2) + DPOW(Y[k] - ky1, 2) <= 1.00001)\n        ans1++;\n      if (DPOW(X[k] - kx2, 2) + DPOW(Y[k] - ky2, 2) <= 1.00001)\n        ans2++;\n    }\n    ans = max(max(ans1, ans2), ans);\n  }\n  return ans;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  vl ANS;\n  while (true) {\n    ll N = 0;\n    cin >> N;\n    if (N == 0)\n      break;\n    ANS.push_back(calc(N));\n  }\n\n  AUTO(ans, ANS) cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nconst double eps=1e-8;\ntypedef pair<double,double> p;\n\ndouble dist(p a, p b)\n{\n    return sqrt((a.fi-b.fi)*(a.fi-b.fi)+(a.se-b.se)*(a.se-b.se));\n}\n\ndouble size(p a)\n{\n    return sqrt(a.fi*a.fi+a.se*a.se);\n}\n\nint main()\n{\n    int n;\n    while(cin >>n,n)\n    {\n        vector<p> v(n);\n        rep(i,n) scanf(\" %lf %lf\", &v[i].fi, &v[i].se);\n\n        int ans=1;\n        //select 2 points\n        rep(i,n)rep(j,i)\n        {\n            double d=dist(v[i],v[j]);\n            if(d>2.0) continue;\n\n            double r=sqrt(1.0 - (d*d/4.0));\n\n            double X=v[j].fi-v[i].fi, Y=v[j].se-v[i].se;\n\n            p v1=p(X,Y);\n            double v1size=size(v1);\n            v1.fi/=v1size; v1.se/=v1size;\n            v1.fi*=d/2; v1.se*=d/2;\n\n            p v2;\n            double v2size;\n            p c;\n\n            //2 candidate for center of circle\n            //first\n            int ct=0;\n            v2=p(-Y,X);\n            v2size=size(v2);\n            v2.fi/=v2size; v2.se/=v2size;\n            v2.fi*=r; v2.se*=r;\n\n            c.fi=v[i].fi+v1.fi+v2.fi; c.se=v[i].se+v1.se+v2.se;\n            assert(dist(c,v[i]));\n            rep(k,n)\n            {\n                if(k==i || k==j) ++ct;\n                else\n                {\n                    if(dist(c,v[k])<1.0) ++ct;\n                }\n            }\n            ans=max(ans,ct);\n\n            //second\n            ct=0;\n            v2=p(Y,-X);\n            v2size=size(v2);\n            v2.fi/=v2size; v2.se/=v2size;\n            v2.fi*=r; v2.se*=r;\n\n            c.fi=v[i].fi+v1.fi+v2.fi; c.se=v[i].se+v1.se+v2.se;\n            assert(dist(c,v[i]));\n            rep(k,n)\n            {\n                if(k==i || k==j) ++ct;\n                else\n                {\n                    if(dist(c,v[k])<1.0) ++ct;\n                }\n            }\n            ans=max(ans,ct);\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//???????????????????????????, ?????????????????????????????°????????????????????????????????????????????????2???????????¨???????????£?????\\????????¨?????§????????????\n//?????£???, 2??????????????????1?????????????????????????????????????????°??????????????????????£????, O(N^2)????????????????????????, ??¨?????§O(N^3)????????§?§£?????????\n#include <iostream>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> Point;\n\nint n;\ndouble x[300], y[300];\nvector<Point> points;\t//????£???????\n\nint main() {\n\twhile (cin >> n) {\n\t\tif (n == 0) break;\n\t\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\t\tif (n == 1) { cout << 1 << endl; continue; }\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tPoint p1 = Point(x[i], y[i]);\n\t\t\t\tPoint p2 = Point(x[j], y[j]);\n\t\t\t\tif (norm(p1 - p2) < 4) {\n\t\t\t\t\tdouble h = sqrt(1.0 - norm(p1 - p2) / 4.0);\n\t\t\t\t\tPoint t = p2 - p1; t /= abs(t);\n\t\t\t\t\tPoint u = t * Point(0, 1);\n\t\t\t\t\tpoints.push_back(p1 + t * abs(p1 - p2) / 2.0 + u * h);\n\t\t\t\t\tpoints.push_back(p1 + t * abs(p1 - p2) / 2.0 - u * h);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble eps = 1e-7;\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < points.size(); i++) {\n\t\t\tdouble px = points[i].real();\n\t\t\tdouble py = points[i].imag();\n\t\t\tint cnt = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ((x[j] - px) * (x[j] - px) + (y[j] - py) * (y[j] - py) < 1 + eps) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ans < cnt) ans = cnt;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <cmath>\n\nusing namespace std;\n\ntypedef pair<double,double> pos;\nconst double r = 1;\nconst double eps = 0.0000000001;\nint count(vector<pos> ps,double x,double y,int ban1,int ban2){\n\tint c=0;//2;\n\tfor(int i=0;i<ps.size();i++){\n\t\tif(//i!=ban1&&i!=ban2&&\n\t\t\t\tpow(ps[i].first-x,2)+pow(ps[i].second-y,2)<=pow(1.0+eps,2)){\n\t\t\tc++;\n\t\t}\n\t}\n\treturn c;\n}\n\nbool range(pos p1,pos p2,double r){\n\treturn pow(p1.first-p2.first,2)+pow(p1.second-p2.second,2) <= r*r;\n}\n\ndouble len(pos p){\n\treturn sqrt(pow(p.first,2)+pow(p.second,2));\n}\n\ndouble len2(pos p){\n\treturn (pow(p.first,2)+pow(p.second,2));\n}\n\nvector<pos> point2(pos p1,pos p2){\n\tpos m = make_pair((p1.first+p2.first)/2,(p1.second+p2.second)/2);\n\tpos vec = make_pair(p1.first-p2.first,p1.second-p2.second);\n\tpos q = m;//make_pair(p2.first+vec.first/2,p2.second+vec.second/2);\n\tdouble l = sqrt(1-pow(len(vec)/2.0,2));\n\tdouble ll = len(vec);\n\tpos vec2 = make_pair(-vec.second,vec.first);\n\tvec2.first=vec2.first/ll*l;\n\tvec2.second = vec2.second/ll*l;\n\tvector<pos> ret;\n\tret.push_back(make_pair(q.first+vec2.first,q.second+vec2.second));\n\tret.push_back(make_pair(q.first-vec2.first,q.second-vec2.second));\n\treturn ret;\n}\n\nint solve(vector<pos> ps){\n\tint mx=1;\n\tfor(int i=0;i<ps.size()-1;i++)\n\t\tfor(int k=i+1;k<ps.size();k++){\n\t\t\tif(range(ps[i],ps[k],2)){\n\t\t\t\t//cerr << \"*****\" << i << \" \" << k << endl;\n\t\t\t\tvector<pos> vp = point2(ps[i],ps[k]);\n\t\t\t\tmx = max(mx,count(ps,vp[0].first,vp[0].second,i,k));\n\t\t\t\tmx = max(mx,count(ps,vp[1].first,vp[1].second,i,k));\n\t\t\t}\n\t\t}\n\treturn mx;\n}\n\nint main(){\n\t//cerr << point2(make_pair(0,0),make_pair(1,1))[1].first << endl;\n\twhile(true){\n\t\tint n;\n\t\tvector<pos> v;\n\t\tcin >> n;\n\t\tif(n==0)return 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tv.push_back(make_pair(x,y));\n\t\t}\n\t\tcout << solve(v) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint N;\npair<double,double> dots[300];\n\nint main(){\n\n\twhile(cin >> N && N != 0){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tpair<double,double> p;\n\t\t\tcin >> dots[i].second >> dots[i].first;\n\t\t}\n\t\tint maxCnt = 1;\n\t\t// ~ðìé½ßÌQ_ðßé\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = i+1; j < N; j++){\n\t\t\t\tpair<double,double> dot1,dot2;\n\t\t\t\tdot1 = dots[i];\n\t\t\t\tdot2 = dots[j];\n\n\t\t\t\tdouble v = sqrt((dot1.first - dot2.first)*(dot1.first - dot2.first)\n\t\t\t\t\t+(dot1.second - dot2.second)*(dot1.second - dot2.second));\n\t\t\t\t// ñ_Ô£ª2æè¨¨«¯êÎÂ­êÈ¢\n\t\t\t\tif(v > 2){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdouble x = sqrt(1 - (v/2)*(v/2));\n\n\t\t\t\t// ñgÌPÊ@üxNg\n\t\t\t\tpair<double,double> hose[2];\n\t\t\t\those[0].first = -1.0/(dots[i].first - dots[j].first);\n\t\t\t\those[0].second = 1.0/(dots[i].second - dots[j].second);\n\t\t\t\those[1].first = 1.0/(dots[i].first - dots[j].first);\n\t\t\t\those[1].second = -1.0/(dots[i].second - dots[j].second);\n\n\t\t\t\tdouble dd1 = sqrt((hose[0].second)*(hose[0].second)+(hose[0].first)*(hose[0].first));\n\t\t\t\tdouble dd2 = sqrt((hose[1].second)*(hose[1].second)+(hose[1].first)*(hose[1].first));\n\t\t\t\those[0].first /= dd1; hose[0].second /= dd1;\n\t\t\t\those[1].first /= dd2; hose[1].second /= dd2;\n\n\t\t\t\t// x{·é\n\t\t\t\those[0].first *= x;hose[1].first *= x;\n\t\t\t\those[0].second *= x;hose[1].second *= x;\n\n\t\t\t\t// mð«·\n\t\t\t\those[0].first += (dot1.first + dot2.first)/2;\n\t\t\t\those[0].second += (dot1.second + dot2.second)/2;\n\t\t\t\those[1].first += (dot1.first + dot2.first)/2;\n\t\t\t\those[1].second += (dot1.second + dot2.second)/2;\n\n\t\t\t\t// hose[0]Æhose[1]Í~ÌSÀW\n\t\t\t\t// e_ÉÖµÄ~ÌÉ¶Ý·é©Ç¤©ðßé\n\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor(int l = 0; l < N; l++){\n\t\t\t\t\t\tdouble dist = sqrt((dots[l].first -hose[k].first)*(dots[l].first -hose[k].first)\n\t\t\t\t\t\t\t+ (dots[l].second -hose[k].second)*(dots[l].second -hose[k].second));\n\t\t\t\t\t\tif(dist <= 1){\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmaxCnt = max(maxCnt,cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << maxCnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\n/*\n\nTodo:\nLine??¨Segment?????????????????????\n\n*/\n\nconst double EPS = 1e-10;\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1)%P.size()]\n\n//0?¬?\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double a) { return Point(a * x, a * y); }\n\tPoint operator/(double a) { return Point(x / a, y / a); }\n\tbool operator<(const Point &p)const {\n\t\t//return y != p.y ? y < p.y : x < p.x; // y?????? -> x??????\n\t\treturn x != p.x ? x < p.x : y < p.y; // x?????? -> y??????\n\t}\n\tbool operator==(const Point &p)const { return equals(x, p.x) && equals(y, p.y); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n};\ninline ostream &operator << (ostream &os, const Point &p) { os << p.x << \" \" << p.y; return os; }\ninline istream &operator >> (istream &is, Point &p) { double x, y; is >> x >> y; p = Point(x, y); return is; }\n\n//1?¬?\nclass Vector :public Point {\npublic:\n\tusing Point::Point;\n\tVector(const Point &P) { x = P.x; y = P.y; }\n\tVector rotate(double rad) { return Vector(x*cos(rad) - y*sin(rad), x*sin(rad) + y*cos(rad)); }\n};\n\nclass Line {\npublic:\n\tPoint p1, p2;\n\tLine() {}\n\tLine(Point p1, Point p2) :p1(p1), p2(p2) {}\n};\nclass Segment :public Line {\npublic:\n\tusing Line::Line;\n\tSegment(const Line &L) { p1 = L.p1; p2 = L.p2; }\n\tVector vec() { return p2 - p1; }\n};\n\n\n//2?¬?\nclass Circle {\npublic:\n\tPoint c; //center\n\tdouble r; //radius\n\tCircle() {}\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>;\n\n//?????? dot product\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\n//?????? cross product ?????§???????????£????????????\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\n//????????¢??? radian ??? ??? degree\ndouble rad(double deg) { return acos(-1)*deg / 180; }\n//????§? argument\ndouble arg(Vector p) { return atan2(p.y, p.x); }\n//?\\???¢??? polar form\nVector polar(double r, double a) { return Point(cos(a)*r, sin(a)*r); }\n\nbool inrange(Point p, double x1, double y1, double x2, double y2) {\n\treturn x1 <= p.x&&p.x <= x2&&y1 <= p.y&&p.y <= y2;\n}\n\n//??´?????????\nbool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) { return is_orthogonal(a1 - a2, b1 - b2); }\nbool is_orthogonal(Segment s1, Segment s2) { return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//????????????\nbool is_parallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) { return is_parallel(a1 - a2, b1 - b2); }\nbool is_parallel(Segment s1, Segment s2) { return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//?°???±\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n//????°?\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p)*2.0; }\n\n//??????(p0,p1)????????????p2???????????¢???\nenum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\nint ccw(Vector a, Vector b) {\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\n\n//??´?????¨??´??????????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2); }\n//(?????????????¶????)\n\n//2??????????????¢\ndouble get_distance(Point a, Point b) { return (a - b).abs(); }\n//??´?????¨???????????¢\ndouble get_distance(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()); }\n//????????¨???????????¢\ndouble get_distance(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return (p - s.p2).abs();\n\treturn get_distance(Line(s), p);\n}\n//????????¨??????????????¢\ndouble get_distance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn\tmin(\n\t\tmin(get_distance(s1, s2.p1), get_distance(s1, s2.p2)),\n\t\tmin(get_distance(s2, s1.p1), get_distance(s2, s1.p2))\n\t);\n}\n\n//?????¨??´??????????????????\nbool intersect(Circle c, Line l) { return get_distance(l, c.c) <= c.r + EPS; }\n//?????¨?????????????????? ??±?????\\????????°\nint intersect(Circle c1, Circle c2) {\n\tdouble d = get_distance(c1.c, c2.c);\n\tif (d > c1.r + c2.r)return 4;\n\tif (d == c1.r + c2.r)return 3;\n\tif (d + c1.r == c2.r || d + c2.r == c1.r)return 1;\n\tif (d + c1.r < c2.r || d + c2.r < c1.r)return 0;\n\treturn 2;\n}\n\n//????????¨???????????????\nPoint get_cross_point(Segment s1, Segment s2) {\n\tassert(intersect(s1, s2));\n\tVector base = s2.p2 - s2.p1;\n\tdouble a1 = abs(cross(base, s1.p1 - s2.p1)); //area1\n\tdouble a2 = abs(cross(base, s1.p2 - s2.p1)); //area2\n\tdouble t = a1 / (a1 + a2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n//??´?????¨??´????????????\n//Point get_cross_point(Line l1, Line l2) {}\n\n//?????¨??´????????????\npair<Point, Point> get_cross_points(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r*c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n//?????¨????????????\npair<Point, Point> get_cross_points(Circle c1, Circle c2) {\n\tint m = intersect(c1, c2);\n\tassert(m != 4 && m != 0);\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//????????????\nenum { OUT = 0, ON, IN };\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS)return ON;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS&&EPS<b.y&&cross(a, b)>EPS)x = !x;\n\t}\n\treturn (x ? IN : OUT);\n}\n\nint contains(Circle c, Point p) {\n\tdouble d = get_distance(c.c, p);\n\tif (equals(d, c.r))return ON;\n\tif (d < c.r)return IN;\n\treturn OUT;\n}\n\n//????§???¢?????¢???\ndouble area(Polygon g) {\n\tdouble a = 0;\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\ta += cross(g[i], g[(i + 1) % g.size()]);\n\treturn a / 2.0;\n}\n\n//?????§????????????????¨??????????\nbool is_convex(Polygon g) {\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\tif (ccw(g[i], g[(i + 1) % g.size()], g[(i + 2) % g.size()]) == CLOCKWISE)\n\t\t\treturn false;\n\treturn true;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//???????????????????????????\nPolygon convex_hull(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\twhile (up.size() > 1 && ccw(up[up.size() - 2], up[up.size() - 1], p) != CLOCKWISE)up.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\twhile (down.size() > 1 && ccw(down[down.size() - 2], down[down.size() - 1], p) != COUNTER_CLOCKWISE)down.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); // ???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//?????????????????????\nPolygon convex_hull_with_points_online(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (up.size() > 1 && (_ccw = ccw(up[up.size() - 2], up[up.size() - 1], p)) != CLOCKWISE &&_ccw != ONLINE_FRONT)\n\t\t\tup.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (down.size() > 1 && (_ccw = ccw(down[down.size() - 2], down[down.size() - 1], p)) != COUNTER_CLOCKWISE && _ccw != ONLINE_FRONT)\n\t\t\tdown.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); // ???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//???????§???¢??????????????????????????¢\n//calipers https://en.wikipedia.org/wiki/Rotating_calipers\ndouble diameter(Polygon P) {\n\tP = convex_hull(P);\n\tauto mima = minmax_element(P.begin(), P.end());\n\tint I = mima.first - P.begin();\n\tint J = mima.second - P.begin();\n\tdouble maxd = get_distance(P[I], P[J]);\n\n\tint maxi, maxj, i, j;\n\ti = maxi = I;\n\tj = maxj = J;\n\tdo {\n\t\tif (ccw(next(P, i) - P[i], next(P, j) - P[j]) == COUNTER_CLOCKWISE)\n\t\t\tj = (j + 1) % P.size();\n\t\telse\n\t\t\ti = (i + 1) % P.size();\n\t\tif (maxd < get_distance(P[i], P[j])) {\n\t\t\tmaxd = get_distance(P[i], P[j]);\n\t\t\tmaxi = i, maxj = j;\n\t\t}\n\t} while (!(i == I&&j == J));\n\treturn maxd;\n}\n\nsigned main() {\n\tfor (int n; cin >> n&&n;) {\n\t\tvector<Circle> v(n);\n\t\tint ma = 1;\n\t\trep(i, 0, n) {\n\t\t\tcin >> v[i].c;\n\t\t\tv[i].r = 1.0;\n\t\t}\n\t\trep(i, 0, n)rep(j, 0, n) {\n\t\t\tif (i == j)continue;\n\t\t\tif (intersect(v[i], v[j]) == 4)continue;\n\t\t\tpair<Point, Point> cp = get_cross_points(v[i], v[j]);\n\t\t\tint cntf = 0, cnts = 0;\n\t\t\trep(k, 0, n)\n\t\t\t\tif (contains(v[k], cp.first))\n\t\t\t\t\tcntf++;\n\t\t\trep(k, 0, n)\n\t\t\t\tif (contains(v[k], cp.second))\n\t\t\t\t\tcnts++;\n\t\t\tma = max({ ma,cntf,cnts });\n\t\t}\n\t\tcout << ma << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//52行目から編集\n#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <unordered_set>\n#include <cassert>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<ll> > vvl;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\n\ntemplate<class T> bool chmin(T& a,T b){if(a > b){a = b;return true;}else return false;}\ntemplate<class T> bool chmax(T& a,T b){if(a < b){a = b;return true;}else return false;}\n///////////////////////////////////////////////////////////\n\nlong double add(long double a,long double b){\n    if(abs(a+b) < 1e-14 * (abs(a) + abs(b))) return 0;\n    else return a + b;\n}\nconstexpr long double EPS = 1e-14;\nconstexpr long double PI = 3.141592653589793237462;\nstruct V{\n    long double x,y;\n    long double add(long double a,long double b){\n        if(abs(a+b) < EPS * (abs(a) + abs(b))) return 0;\n        else return a + b;\n    }\n    ///////////////////////////////////////////////////\n    V(long double x = 0.0,long double y = 0.0):x(x),y(y){}\n    V& operator+=(const V& a){x=add(x,a.x),y=add(y,a.y);return *this;}\n    V& operator-=(const V& a){x=add(x,-a.x),y=add(y,-a.y);return *this;}\n    V& operator*=(const long double& a){x*=a,y*=a;return *this;}\n    V  operator+(const V& b) const{V a(*this);return a+= b;}\n    V  operator-(const V& b) const{V a(*this); return a-=b;}\n    V  operator*(const long double& b) const{V a(*this); return a*= b;}\n    bool  operator<(V& b){return getarg() > b.getarg();}\n    long double dot(V b){return add(x * b.x,y * b.y);}\n    long double det(V b){return add(x * b.y , -y * b.x);}\n    long double norm(){return sqrt(add(x*x , y*y));}\n    V  round(long double deg,bool argument = false){//弧度法で入力する時はargument = true\n        long double arg = (argument ? deg : PI*(deg/180.0)) ;\n        if(argument == true) arg = deg;else arg = PI * (deg / 180.0);\n        return V(add(x * cos(arg),-y * sin(arg)),add(x * sin(arg),y * cos(arg)));\n    }\n    V get_unit(){\n        return V(x / norm(),y / norm());\n    }\n    long double getarg(){\n        return atan2(y,x);// [PI,-PI]\n    }\n    friend ostream& operator<<(ostream& os,V& p){\n        os << fixed << setprecision(20);\n        os << \"(\" << p.x << \",\" << p.y << \")\";\n        return os;\n    }\n};\nstruct GeoUtil{\n    long double add(long double a,long double b){\n        if(abs(a+b) < EPS * (abs(a) + abs(b))) return 0;\n        else return a + b;\n    }\n    long double dist(V a,V b){\n        return sqrt(add(add(b.x,-a.x)*add(b.x,-a.x) , add(b.y,-a.y)*add(b.y,-a.y)));\n    }\n};\nstruct C{\n    V c;\n    long double r;\n    C(long double x = 0.0,long double y = 0.0,long double r = 0.0):c(x,y),r(r){}\n    pair<V,V> cross(const C& b){\n        GeoUtil GU;\n        long double r1 = r,r2 = b.r;\n        V v_1 = b.c - c;\n        long double d = v_1.norm();\n        long double x = add(add(r1*r1,-r2*r2),d*d)/(2.0*d);\n        long double ratio = x / d;\n        V v_2 = v_1 * ratio;\n        V p = c + v_2;\n        V v_3 = v_2.round(90.0);\n        v_3 = v_3.get_unit();\n        long double r3 = sqrt(add(r1*r1,-x*x));\n        v_3 = v_3 * r3;\n        V ans1 = p + v_3;\n        V ans2 = p - v_3;\n        V check = ans1 - c;\n        return make_pair(ans1,ans2);\n    }\n};\nvoid solve(int n){\n    GeoUtil GU;\n    vector<C> a(n);\n    rep(i,n){\n        long double x,y;cin >> x >> y;\n        a[i] = C(x,y,1.0);\n    }\n    int ans = 0;\n\n    for(int i = 0;i < n;i++){\n        C P = a[i];\n        int cnt = 0;\n        for(int j = 0;j < n;j++){\n            if(GU.dist(P.c,a[j].c) + EPS < 1.0)cnt++;\n        }\n        chmax(ans,cnt);\n    }\n    for(int i = 0;i < n-1;i++){\n        for(int j = i+1;j < n;j++){\n            if(GU.dist(a[i].c,a[j].c) - EPS > 2.000)continue; \n            V P1 = a[i].cross(a[j]).first;\n            V P2 = a[i].cross(a[j]).second;\n            int cnt = 0;\n            for(int k = 0;k < n;k++){\n                if(GU.dist(P1,a[k].c) - EPS < 1.0)cnt++;\n            }\n            chmax(ans,cnt);\n            cnt = 0;\n            for(int k = 0;k < n;k++){\n                if(GU.dist(P2,a[k].c) - EPS < 1.0)cnt++;\n            }\n            chmax(ans,cnt);\n        }\n    }\n    cout << ans << '\\n';\n}\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    while(1){\n        int n;cin >> n;\n        if(n)solve(n);\n        else break;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef complex<double> P;\nconst double PI = 3.14159265;\nconst double eps = 1e-7;\n\ninline double dist(const P &p,const P &q) {\n    double dx = (p-q).real(),dy = (p-q).imag();\n    return sqrt(dx*dx+dy*dy);\n}\n\n// rotate to right , radian\nP rotate(const P &p,double degree) {\n    return P(p.real()*cos(degree)+p.imag()*(-sin(degree)),\n             p.real()*sin(degree)+p.imag()*cos(degree));\n}\n\nstruct Circle {\n    double r;\n    P c;\n    Circle(P c,double r) : c(c), r(r) {;}\n};\n\n// p in C?\ninline bool inC(const Circle &c,const P &p) {\n    return dist(c.c,p) < c.r + eps;\n}\n\n// p1,p2©ç£dÌ2ÂÌ_ðÔ·\n// dist(p1-p2) > 2*dÌÆ«nanªÔéÌÉÓ\n// aoj 1132\npair<P,P> findCenter(P &p1,P &p2,double d) {\n    P cp = (p1+p2); cp /= 2;\n    P od = rotate(p2-cp,PI/2);\n\n    double abod = abs(p2-cp);//,abcp = norm(cp-p1);\n    double len = sqrt(d-norm(cp-p1));\n\n    P rep1 = cp + (od/abod)*len;\n    P rep2 = cp - (od/abod)*len;\n    return make_pair(rep1,rep2);\n}\n\nint main() {\n    int n;\n    while(cin>>n, n) {\n        vector<P> pv;\n        double x,y;\n        for(int i=0; i<n; ++i) {\n            cin>>x>>y;\n            pv.push_back(P(x,y));\n        }\n\n        int ans = 1;\n        for(int i=0; i<n; ++i) {\n            for(int j=i+1; j<n; ++j) {\n                if(dist(pv[i],pv[j]) > 2.0) continue;\n                pair<P,P> p = findCenter(pv[i],pv[j],1.0);\n                int t1 = 0,t2 = 0;\n                Circle c1(p.first,1.0);\n                Circle c2(p.second,1.0);\n                for(int k=0; k<n; ++k) {\n                    if(inC(c1,pv[k])) t1++;\n                    if(inC(c2,pv[k])) t2++;\n                }\n                ans = max(ans, max(t1,t2));\n            }\n        }\n\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nstruct Point{\n\tdouble x,y;\n};\n\nvoid func(int N){\n\n\tPoint point[N];\n\tdouble x_min = 100,y_min = 100,x_max = -1,y_max = -1;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf\",&point[i].x,&point[i].y);\n\t\tx_min = min(point[i].x,x_min);\n\t\ty_min = min(point[i].y,y_min);\n\t\tx_max = max(point[i].x,x_max);\n\t\ty_max = max(point[i].y,y_max);\n\t}\n\n\tif(x_min > 1)x_min -= 1;\n\tif(y_min > 1)y_min -= 1;\n\tif(x_max < 9)x_max += 1;\n\tif(y_max < 9)y_max += 1;\n\n\tint count,max_count = 0;\n\n\tfor(double y = y_min; y <= y_max; y += 0.015){\n\t\tfor(double x = x_min; x <= x_max; x += 0.015){\n\t\t\tcount = 0;\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tif(sqrt((x-point[i].x)*(x-point[i].x)+(y-point[i].y)*(y-point[i].y)) <= 1.0)count++;\n\t\t\t}\n\t\t\tmax_count = max(max_count,count);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",max_count);\n}\n\n\nint main(){\n\n\tint N;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc(N);\n\t}\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\n#define P complex<double>\n#define EPS 1.0e-4\n\nint main(){\n  int n;\n  P p[301];\n  int ans, num;\n\n  while( cin>>n && n ){\n    for( int i=0;i<n;i++ )\n      cin >> p[i].real() >> p[i].imag();\n\n    ans=0;\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ ){\n\tif( i==j )\n\t  continue;\n\t/*\n\tcout << i << \",\" << j << endl;\n\tcout << \" abs:\" << abs( p[i]-p[j] ) << endl;\n\t*/\n\tif( abs( p[i]-p[j] ) > 2.0 )\n\t  continue;\n\n\tP m  = (p[i]+p[j]) / 2.0; // p[i]Æp[j]Ì_\n\tP nn = (p[i]-p[j]) * P(0,1);       // @üxNg\n\tnn = nn / abs(nn);\n\n\tdouble x = abs( p[i]-p[j] )/2;\n\tx = sqrt( 1-x*x );\n\tP c = m + x * nn;        // ~ÌS\n\n\t//\tcout << \" \"<<c.real() << \"\\t\" << c.imag() << endl;\n\n\tnum=0;\n\tfor( int k=0;k<n;k++ )\n\t  if( abs( c-p[k] ) < 1.0 + EPS  )\n\t    num++;\n\tans = max( ans,num );\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n \nconst ll MOD=1e9+7;\nconst ll INF=1e18;\n \nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\n\ndouble p[305][2];\nint n;\n\ndouble dist(int a,int b){\n    return sqrt((p[a][0]-p[b][0])*(p[a][0]-p[b][0])+(p[a][1]-p[b][1])*(p[a][1]-p[b][1]));\n}\n\ndouble get_o(int i,double st,double en,double th,double b){\n    double diff = 1.0;\n    while(diff > 0.00001){\n        double half[2];\n        half[0] = (en+st)/2.0;\n        half[1] = th*half[0] + b;\n        if( (p[i][0]-half[0])*(p[i][0]-half[0]) + (p[i][1]-half[1])*(p[i][1]-half[1]) >1){\n            en = half[0];\n        }else{\n            st = half[0];\n        }\n        diff = en - st;\n        if(diff < 0 ) diff = -1.0 * diff;\n    }\n  //  cout << \"st:\" << st << \", en:\" << en << endl;\n    return st;\n}\n\nint find_ans(double x,double y,int a,int b){\n    int ans = 2;\n    for(int i = 0;i < n;i++){\n        if(i == a || i == b)continue;\n        if( (p[i][0]-x)*(p[i][0]-x) + (p[i][1]-y)*(p[i][1]-y) <= 1.0) ans++;\n    }\n    return ans;\n}\n\nint main(){\n    while(true){\n        cin >> n;\n        if(n == 0)break;\n        for(int i = 0;i < n;i++){\n            cin >> p[i][0] >> p[i][1];\n        }\n        int ans = 1;\n        for(int i = 0;i < n;i++){\n            for(int j = i+1;j < n;j++){\n                double d = dist(i,j);\n                if(d > 2.0)continue;\n                if(true){\n            //    if(p[i][1] != p[j][1]){\n                    double th = -(p[j][0]-p[i][0])/(p[j][1]-p[i][1]);\n                    double half[2];\n                    half[0] = (p[i][0]+p[j][0])/2.0;\n                    half[1] = (p[i][1]+p[j][1])/2.0;\n                    double b = half[1] - th*half[0];\n                    double o[2];\n                    o[0] = get_o(i,half[0],half[0]+1,th,b);\n                    o[1] = th*o[0] + b;\n                //    cout << \"x1:\" << p[i][0] << \",y1\" << p[i][1] << \",x2\" << p[j][0] << \",y2\" << p[j][1] << \",ox\" << o[0] << \",oy\" << o[1] << endl;\n                    ans = max(ans,find_ans(o[0],o[1],i,j));\n                    o[0] = get_o(i,half[0],half[0]-1,th,b);\n                    o[1] = th*o[0] + b;\n                //    cout << \"x1:\" << p[i][0] << \",y1\" << p[i][1] << \",x2\" << p[j][0] << \",y2\" << p[j][1] << \",ox\" << o[0] << \",oy\" << o[1] << endl;\n                    ans = max(ans,find_ans(o[0],o[1],i,j));\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nint n;\ndouble x[310], y[310];\ndouble eps = 1e-9;\n\ndouble pow(double a) {\n    return a * a;\n}\n\ndouble dist2(double ax, double ay, double bx, double by) {\n    return pow(ax - bx) + pow(ay - by);\n}\n\ndouble dist2(int i, int j) {\n    return dist2(x[i], y[i], x[j], y[j]);\n}\n\nint count(double cx, double cy) {\n    int ret = 0;\n    for (int i = 0; i < n; ++i) {\n        if (dist2(x[i], y[i], cx, cy) < 1 + eps)\n            ++ret;\n    }\n    return ret;\n}\n\nint main(){\n    while (true) {\n        cin >> n;\n        if (!n) return 0;\n        for (int i = 0; i < n; ++i) {\n            cin >> x[i] >> y[i];\n        }\n        int ans = 1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                double d2 = dist2(i, j);\n                double d = sqrt(d2);\n                if (d > 2)\n                    continue;\n                \n                double dis2 = 1 - d2 / 4;\n                double dis = sqrt(dis2);\n                double cx = (x[i] + x[j]) / 2;\n                double cy = (y[i] + y[j]) / 2;\n                double dx = (y[i] - y[j]) / d * dis;\n                double dy = (x[i] - x[j]) / d * dis;\n                ans = max(ans, max(count(cx + dx, cy - dy), count(cx - dx, cy + dy)));\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nstruct point {double x,y;};\n\nint N;\npoint P[310];\n\ndouble dist(point A, point B){\n\tdouble dx = A.x - B.x, dy = A.y - B.y;\n\treturn sqrt(dx*dx + dy*dy);\n}\n\nint func(void){\n\tint i,j,k,ans=1;\n\t\n\tREP(i,N) REP(j,N) if(i != j && dist(P[i],P[j]) < 2.0){\n\t\tdouble dx = (P[j].x - P[i].x) / 2.0, dy = (P[j].y - P[i].y) / 2.0;\n\t\tdouble d = sqrt(dx*dx + dy*dy);\n\t\tdouble t = sqrt(1.0 - d*d) / d;\n\t\tpoint O = {P[i].x + dx - t * dy, P[i].y + dy + t * dx};\n\t\t\n\t\tint tmp = 0;\n\t\tREP(k,N) if(dist(O,P[k]) < 1.00001) tmp++;\n\t\tans = max(ans,tmp);\n\t}\n\t\n\treturn ans;\n}\n\nint main(void){\n\tint i;\n\t\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\tREP(i,N) cin >> P[i].x >> P[i].y;\n\t\tint ans = func();\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <complex>\n\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,n) loop(i,0,n)\n\nusing namespace std;\ntypedef complex<double> vec;\n\ndouble const pi = acos(-1);\ndouble const eps = 1e-6;\n\nint main(){\n    int n;\n    while (cin >> n && n){\n        vector<vec> v(n);\n        rep(i, n){\n            double x, y; cin >> x >> y;\n            vec p(x, y);\n            v[i] = p;\n        }\n\n        if (n == 1) {\n            puts(\"1\");\n            continue;\n        }\n        int ans = 1;\n        rep(i, n)rep(j, n)if (i != j){\n            double d = abs(v[i] - v[j]);\n            if (d > 2) continue;\n            ans = max(ans, 2);\n            double h = sqrt(1 - d*d / 4);\n            vec c1 = polar(h, arg(v[i] - v[j]) + pi / 2) + (v[i] + v[j]) / 2.;\n            vec c2 = polar(h, arg(v[i] - v[j]) - pi / 2) + (v[i] + v[j]) / 2.;\n            int a1 = 0, a2 = 0;\n            rep(k, n){\n                if (abs(c1 - v[k]) <= 1) a1++;\n                if (abs(c2 - v[k]) <= 1) a2++;\n            }\n            ans = max(ans, a1);\n            ans = max(ans, a2);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nint INF=1e9;\nint MOD=1000000007;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ndouble EPS = 1e-5;\ndouble add(double a,double b){\n\tif(abs(a+b)<EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,p.x),add(y,-p.y));\n\t}\n\tP operator * (P p){\n\t\treturn P(x*p.x,y*p.y);\n\t}\n};\ndouble dist(P a,P b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\nint cnt(P pos,vector<P> dat){\n\tint res=0;\n\tREP(i,dat.size()){\n\t\tif(dist(pos,dat[i])<=1.0+EPS)res++;\n\t}\n\treturn res;\n}\nint main(){\n\tint n;\n\tdouble x,y;\n\twhile(scanf(\"%d\",&n)&&n){\n\t\tvector<P> dat;\n\t\tREP(i,n){\n\t\t\tcin>>x>>y;\n\t\t\tdat.PB(P(x,y));\n\t\t}\n\t\tint ans=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tP a=dat[i],b=dat[j];\n\t\t\t\tP mid=P((a.x+b.x)/2.0,(a.y+b.y)/2.0);\n\t\t\t\tdouble dx=a.y-b.y,dy=b.x-a.x;\n\t\t\t\tdouble d=dist(a,b);\n\t\t\t\tif(d>2)continue;\n\t\t\t\tdouble dd=sqrt(dx*dx+dy*dy);\n\t\t\t\tdouble ddd=sqrt(1-d*d/4);\n\t\t\t\tdx=dx*ddd/dd;dy=dy*ddd/dd;\n\t\t\t\tans=max(ans,cnt(P(mid.x+dx,mid.y+dy),dat));\n\t\t\t\tans=max(ans,cnt(P(mid.x-dx,mid.y-dy),dat));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <iostream>\n#include <cmath>\n#include <vector>\n\nconstexpr double pi = 3.14159265358979323846264338327950288419716939937510582097494459;\n\nint main() {\n\tfor (;;){\n\t\tint n;\n        std::cin >> n;\n\n\t\tif (n == 0) {\n\t\t\treturn 0;\n\t\t}\n\n        std::vector<std::complex<double>> arr;\n        arr.reserve(n);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble x, y;\n\n            std::cin >> x >> y;\n\n\t\t\tarr.emplace_back(x, y);\n\t\t}\n\n\t\tint max = 1;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t    for(int j = i + 1; j < n; j++) {\n\t\t\t\tauto sub = arr[j] - arr[i];\n\n\t\t\t\tif (std::abs(sub) >= 2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tauto sum = arr[j] + arr[i];\n\n\t\t\t\t{\n\t\t\t\t\tauto center = sum/2. + sub*std::polar(std::sqrt(1-std::abs(sub/2.) * std::abs(sub/2.))/std::abs(sub), pi/2);\n\n\t\t\t\t\tint counter = 0;\n\t\t\t\t\tfor(int k = 0; k < n; k++) {\n\t\t\t\t\t\tif(i == k || j == k || std::abs(arr[k]-center) <= 1) {\n\t\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (max < counter) {\n\t\t\t\t\t\tmax = counter;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tauto center = sum/2. + sub*std::polar(std::sqrt(1-std::abs(sub/2.) * std::abs(sub/2.))/std::abs(sub), -pi/2);\n\n\t\t\t\t\tint counter = 0;\n                    for(int k = 0; k < n; k++) {\n\t\t\t\t\t\tif(i == k || j == k || std::abs(arr[k]-center) <= 1) {\n\t\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (max < counter) {\n\t\t\t\t\t\tmax = counter;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        std::cout << max << std::endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define LP(i,n) for(int i = 0; i < n; i++)\n\nusing namespace std;\ntypedef pair<double,double> P;\n\ndouble Dist(double x1[], double x2[]){\n\treturn pow((x1[0]-x2[0])*(x1[0]-x2[0])+(x1[1]-x2[1])*(x1[1]-x2[1]),0.5);\n\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\twhile(n){\n\t\tint mx = 0;\n\t\tP p[300];\n\t\tLP(i,n){\n\t\t\tcin >> p[i].first >> p[i].second;\n\t\t}\n\t\tsort(p,p+n);\n\t\tdouble x[300][2];\n\t\tLP(i,n){\n\t\t\tx[i][0] = p[i].first;\n\t\t\tx[i][1] = p[i].second;\n\t\t}\n\t\tdouble dist[300][300];\n\t\tLP(i,n){\n\t\t\tLP(j,n){\n\t\t\t\tdist[i][j] = Dist(x[i],x[j]);\n\t\t\t}\n\t\t}\n\t\tLP(i,n){\n\t\t\tfor(int j = i+1; j < n; j++){\n\t\t\t\tif(x[j][0]-x[i][0] > 2){\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tif(dist[i][j] < 2){\n\t\t\t\t\t\tdouble m[] = {(x[j][0]+x[i][0])/2,(x[j][1]+x[i][1])/2};\n\t\t\t\t\t\tdouble d[] = {x[j][1]-x[i][1],-x[j][0]+x[i][0]};\n\t\t\t\t\t\tdouble O[] = {0,0};\n\t\t\t\t\t\tdouble _d = Dist(d,O);\n\t\t\t\t\t\tLP(k,2){\n\t\t\t\t\t\t\td[k] *= (pow(_d,-2)-0.25);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdouble o[2][2];\n\t\t\t\t\t\tLP(k,2){\n\t\t\t\t\t\t\tLP(l,2){\n\t\t\t\t\t\t\t\to[k][l] = m[l];\n\t\t\t\t\t\t\t\tif(k) o[k][l] += d[l];\n\t\t\t\t\t\t\t\telse o[k][l] -= d[l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLP(k,2){\n\t\t\t\t\t\t\tint s = 2;\n\t\t\t\t\t\t\tfor(int l = i+1; l < j; l++){\n\t\t\t\t\t\t\t\tif(Dist(x[l],o[k]) < 1) s++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int l = i-1; 0<=l && x[i][0]-x[l][0] < 2;l--){\n\t\t\t\t\t\t\t\tif(Dist(x[l],o[k]) < 1) s++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int l = j+1; l < n && x[l][0]-x[j][0] < 2; l++){\n\t\t\t\t\t\t\t\tif(Dist(x[l],o[k]) < 1) s++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmx = max(mx,s);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mx == 0) mx = 1;\n\t\tcout << mx << endl;\n\t\tcin >> n;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define EPS 1e-8\ntypedef complex<double> Point;\n \nint main(){\n    int N;\n    while(cin >> N,N){\n\tPoint p[N];\n\tfor(int i = 0 ; i < N ; i++){\n\t    cin >> p[i].real() >> p[i].imag();\n\t}\n\tint res = 1;\n\tfor(int i = 0 ; i < N-1 ; i++){\n\t    for(int j = i+1 ; j < N ; j++){\n\t\tPoint np = p[j]-p[i];\n\t\tdouble d = abs(np);\n\t\tif(d + EPS > 2.0){ continue; }\n\t\tnp /= d;\n\t\tnp *= Point(0,1);\n\t\tPoint cp = (p[i]+p[j])/2.0;\n\t\tPoint v = sqrt(1.0-d*d/4.0)*np;\n\t\tint cnt = 2;\n\t\tPoint center = cp + v;\n\t\tfor(int k = 0 ; k < N ; k++){\n\t\t    if(i == k || j == k) continue;\n\t\t    Point diff = center-p[k];\n\t\t    if(norm(diff) < 1.0 + EPS){\n\t\t\tcnt++;\n\t\t    }\n\t\t}\n\t\tres = max(res,cnt);\n\t    }\n\t}\n\tcout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *  Circle and Points (PKU 1981)\n *  by Kenji Inoue, 2007-01-05\n **/\n\n#include <iostream>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n#define EPS (1e-6)\n\nP p[300];\nP tmp;\n\nint main() {\n  int n;\n  while (cin >> n, n) {\n    for (int i=0; i<n; i++) {\n      cin >> p[i].real() >> p[i].imag();\n    }\n\n    int ans = 1;\n    for (int i=0; i<n; i++) {\n      for (int j=i+1; j<n; j++) {\n        P v = p[i] - p[j];\n        double absv = abs(v);\n        if (absv > 2.0 + EPS) { continue; }\n\n        P m = p[j] + (v / 2.0);\n        P unv = (v * P(0, 1)) / absv; // unit normal vector\n        P nv = sqrt(1.0 - absv*absv/4.0) * unv;\n        for (int s=0; s<2; s++) {\n          nv *= -1;\n          P c = m + nv; // center point of the circle\n\n          int cnt = 0;\n          for (int k=0; k<n; k++) {\n            // if (abs(p[k] - c) < 1.0 + EPS) { cnt++; } // too slow\n            tmp = p[k] - c;\n            if ( tmp.real()*tmp.real() + tmp.imag()*tmp.imag() < 1.0 + EPS ) { cnt++; }\n          }\n          if (cnt > ans) { ans = cnt; }\n        }\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\n#define rept(i,k,n) for(int i = (k); i < (int)(n); i++)\n#define Sort(v) sort(v.begin(),v.end())\n#define Reverse(v) reverse(v.begin(),v.end())\n#define X first\n#define Y second\n\ntypedef long long ll;\ntypedef pair<double,double> Pdd;\ntypedef pair<int,int> Pii;\n\nint n;\nvector<vector<int> > tree;\n\nint main(){\n    while(1){\n        int n;\n        cin>>n;\n        if(!n) return 0;\n        vector<Pdd> xy(n);\n        rep(i,n) cin>>xy[i].X>>xy[i].Y;\n        int ans =1;\n        rep(i,n) rep(j,n){\n            if(i==j) continue;\n            double dx=xy[i].X-xy[j].X, dy=xy[i].Y-xy[j].Y;\n            double d = sqrt(dx*dx+dy*dy);\n            if(d>2.000001)continue;\n            double dr = sqrt(1.0-d*d/4);\n            double xx=(xy[i].X+xy[j].X)/2+-dy/d*dr;\n            double yy=(xy[i].Y+xy[j].Y)/2+dx/d*dr;\n            int cnt=0;\n            rep(k,n){\n                if(pow(xy[k].X-xx,2.0)+pow((xy[k].Y-yy),2.0)<1.000001)cnt++;\n            }\n            ans = max(ans,cnt);\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <functional>\n#include <ctime>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n#define all(c) ((c).begin()), ((c).end())\n#define TEST(x,a) { auto y=(x); if (sign(y-a)) { cout << \"line \" << __LINE__  << #x << \" = \" << y << \" != \" << a << endl; exit(-1); } }\ndouble urand() { return rand() / (1.0 + RAND_MAX); }\n\nconst double PI = acos(-1.0);\n\n// implementation note: use EPS only this function\n// usage note: check sign(x) < 0, sign(x) > 0, or sign(x) == 0\n// notice: should be normalize to O(1)\nconst double EPS = 1e-8;\nint sign(double x) {\n  if (x < -EPS) return -1;\n  if (x > +EPS) return +1;\n  return 0;\n}\nstruct point {\n  typedef double T;\n  T x, y; \n  point &operator+=(point p) { x += p.x; y += p.y; return *this; }\n  point &operator-=(point p) { x -= p.x; y -= p.y; return *this; }\n  point &operator*=(T a)     { x *= a;   y *= a;   return *this; }\n  point &operator/=(T a)     { return *this *= (1.0/a); }\n  point operator-() const    { return {-x, -y}; }\n  bool operator==(point p) const { return !sign(x-p.x) && !sign(y-p.y); }\n  bool operator!=(point p) const { return !operator==(p); }\n  bool operator<(point p) const { return x!=p.x ? x<p.x : y<p.y; } // for sort\n};\npoint operator+(point p, point q) { return p += q; }\npoint operator-(point p, point q) { return p -= q; }\npoint operator*(point::T a, point p) { return p *= a; }\npoint operator*(point p, point::T a) { return p *= a; }\npoint operator/(point p, point::T a) { return p /= a; }\npoint::T dot(point p, point q) { return p.x*q.x+p.y*q.y; }\npoint::T cross(point p, point q) { return p.x*q.y-p.y*q.x; } // left turn > 0\npoint::T norm2(point p) { return dot(p,p); }\npoint::T norm(point p) { return sqrt(dot(p,p)); }\npoint::T dist(point p, point q) { return norm(p-q); }\npoint orth(point p) { return {-p.y, p.x}; }\n\nistream &operator>>(istream &is, point &p) { is>>p.x>>p.y;return is; }\nostream &operator<<(ostream &os, const point &p) { os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; return os; }\n\nint maximum_circle_cover(vector<point> ps, double r) {\n  struct range {\n    point p; // center\n    double w; // width\n    int hi;\n    bool operator<(range r) const {\n      return hi < r.hi;\n    }\n  };\n  double w = 0;\n  for (point p: ps) w = max({w, abs(p.x), abs(p.y)});\n  priority_queue<range> que;\n  que.push({{0,0}, w, (int)ps.size()});\n  point best_p;\n  int best = 0;\n  while (!que.empty()) {\n    range R = que.top(); que.pop();\n    if (R.hi <= best) continue;\n    //cout << \"processing \" << R.p << \" \" << R.w << \" \" << R.hi << \"/\" << best << endl;\n    double dx[] = {1,-1,-1,1}, dy[] = {1,1,-1,-1};\n    for (int i = 0; i < 4; ++i) {\n      range S = {R.p, R.w/2, 0};\n      S.p += S.w*point({dx[i], dy[i]});\n      int lo = 0;\n      for (point q: ps) {\n        auto d = dist(S.p, q);\n        if (sign(d - r) <= 0) ++lo;\n        if (sign(d - S.w*sqrt(2) - r) <= 0) ++S.hi;\n      }\n      if (lo > best) { best = lo; best_p = S.p; }\n      best = max(lo, best);\n      if (S.hi > best) que.push(S);\n    }\n  }\n  return best; //best_p;\n}\nint maximum_circle_cover3(vector<point> ps, double r) {\n\n  point best_p;\n  int best = 0;\n  function<void(point,double,vector<point>&)> rec = [&](point p, double w, vector<point> &ps) {\n    w /= 2;\n    const double dx[] = {1,-1,-1,1}, dy[] = {1,1,-1,-1};\n    point qs[4];\n    vector<point> pss[4];\n    for (int i = 0; i < 4; ++i) {\n      qs[i] = p + w * point({dx[i], dy[i]});\n      int lo = 0;\n      for (point q: ps) {\n        auto d = dist(qs[i], q);\n        if (sign(d - r) <= 0) ++lo;\n        if (sign(d - w*sqrt(2) - r) <= 0) pss[i].push_back(q);\n      }\n      if (lo > best) { best = lo; best_p = qs[i]; }\n    }\n    int a = 0, b = 1, c = 2, d = 3;\n    auto SW = [&](int &a, int &b) { if (pss[a].size() > pss[b].size()) swap(a, b); };\n    SW(a,b);SW(c,d);SW(b,d);SW(a,c);SW(b,c);\n    if (pss[d].size() > best) rec(qs[d], w, pss[d]);\n    if (pss[b].size() > best) rec(qs[b], w, pss[b]);\n    if (pss[c].size() > best) rec(qs[c], w, pss[c]);\n    if (pss[a].size() > best) rec(qs[a], w, pss[a]);\n  };\n  double w = 0;\n  for (point p: ps) w = max({w, abs(p.x), abs(p.y)});\n  rec({0,0}, w, ps);\n  return best; //best_p;\n}\n\nint maximum_circle_cover2(vector<point> ps, double r) {\n  int best = 0;\n  for (point p: ps) {\n    int count = 0;\n    vector<pair<double,int>> aux;\n    for (point q: ps) {\n      auto d = dist(p, q);\n      if (sign(d) == 0) ++count;\n      else if (sign(d - 2*r) <= 0) {\n        double theta = atan2(q.y-p.y, q.x-p.x);\n        double phi   = acos(min(1., d/(2*r)));\n        aux.push_back({theta-phi, -1});\n        aux.push_back({theta+phi, +1});\n      }\n    }\n    sort(all(aux));\n    /*\n    cout << \"for point \" << p << endl;\n    for (auto a: aux) \n      cout << \"(\" << a.fst << \",\" << a.snd << \") \";\n    cout << endl;\n    */\n\n    for (auto a: aux) \n      best = max(best, count -= a.snd);\n  }\n  return best;\n}\n\n\nvoid verify_maximum_circle_cover2() {\n  for (int n; scanf(\"%d\", &n) && n; ) {\n    vector<point> ps(n);\n    for (int i = 0; i < n; ++i) \n      scanf(\"%lf %lf\", &ps[i].x, &ps[i].y);\n    printf(\"%d\\n\", maximum_circle_cover(ps, 1.0));\n  }\n}\n\n\nint main() {\n  //verify_maximum_circle_cover();\n  verify_maximum_circle_cover2();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble distance(pair<double,double> p1,pair<double,double> p2){\n\treturn sqrt((p1.first-p2.first)*(p1.first-p2.first)+(p1.second-p2.second)*(p1.second-p2.second));\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<double> x(n);\n\t\tvector<double> y(n);\n\t\tint res=1;\n\t\tfor(int i=0;i<n;i++) cin>>x[i]>>y[i];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tpair<double,double> midp=make_pair((x[i]+x[j])/2,(y[i]+y[j])/2);\n\t\t\t\tdouble a=-(x[i]-x[j]),b=(y[i]-y[j]);\n\t\t\t\tif(a<0.000001) a=0;\n\t\t\t\tif(b<0.000001) b=0;\n\t\t\t\t//a(x-mid[i].first)+b(y-mid.second)=0\n\t\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\t\tpair<double,double> lef=midp;\n\t\t\t\t\t\tpair<double,double> rig;\n\t\t\t\t\t\tif(k==0) rig=make_pair(-b*1e8+midp.first,a*1e8+midp.second);\n\t\t\t\t\t\tif(k==1) rig=make_pair(b*1e8+midp.first,-a*1e8+midp.second);\n\t\t\t\t\t\twhile(distance(lef,rig)>=0.0000000001){\n\t\t\t\t\t\t\t\tpair<double,double> mid=make_pair((lef.first+rig.first)/2,(lef.second+rig.second)/2);\n\t\t\t\t\t\t\t\tif(distance(mid,make_pair(x[i],y[i]))>1){\n\t\t\t\t\t\t\t\t\trig=mid;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tlef=mid;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint count=2;\n\t\t\t\t\t\tif(distance(midp,lef)<0.000001) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor(int r=0;r<n;r++){\n\t\t\t\t\t\t\tif(distance(make_pair(x[r],y[r]),lef)<1+0.00005){\n\t\t\t\t\t\t\t\tif(r!=i && r!=j)count++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres=max(res,count);\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout<<res<<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#define EPS 0.0001\nusing namespace std;\ntypedef long double elem;\ntypedef complex<elem> point,vec;\ninline elem dist(const point &a, const point &b){return abs(a-b);}\ninline vec normr(const vec &v){return v*vec(0,-1);}\ninline vec norml(const vec &v){return v*vec(0,1);}\ninline vec unormr(const vec &v){return normr(v) / abs(v);}\ninline vec unorml(const vec &v){return norml(v) / abs(v);}\nint main(){\n\twhile(true){\n\t\tint ans = 0;\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tvector< point > points;\n\t\tfor(int i=0;i<n;++i){\n\t\t\telem x, y;\n\t\t\tscanf(\"%Lf%Lf\", &x, &y);\n\t\t\tpoints.push_back( point(x,y) );\n\t\t}\n\t\tfor(unsigned int i = 0; i < points.size(); ++i){\n\t\t\tfor(unsigned int j = 0; j < points.size(); ++j){\n\t\t\t\tif( i != j && dist( points[i], points[j] ) < 2 ){\n\t\t\t\t\tint count_p = 0;\n\t\t\t\t\tint count_q = 0;\n\t\t\t\t\telem d = sqrt(1-pow(dist(points[i], points[j])/2,2 ) );\n\t\t\t\t\tpoint p,q;\n\t\t\t\t\tvec ab = points[j] - points[i];\n\t\t\t\t\tpoint t = (long double)0.5 * ab + points[i];  \n\t\t\t\t\tp = d * unormr(ab) + t;\n\t\t\t\t\tq = d * unorml(ab) + t;\n\t\t\t\t\tfor(unsigned int k = 0; k < points.size(); ++k){\n\t\t\t\t\t\tif( dist(p, points[k]) <= 1.0+EPS ){ count_p++; }\n\t\t\t\t\t\tif( dist(q, points[k]) <= 1.0+EPS ){ count_q++; }\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans, max(count_q, count_p) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <complex>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nconst double EPS=1e-10;\n\n#define equals(a, b) (fabs((a)-(b))<EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\n\nstruct Circle {\n    Point c;\n    double r;\n    Circle(Point c=Point(), double r=0.0) :\n        c(c),r(r){}\n};\n\nstruct Segment {\n    Point p1, p2;\n};\n\nbool include(Circle c,Point p) {\n    return (norm(c.c-p) <= c.r*c.r+EPS);\n}\n\nint n;\ndouble xs[301],ys[301];\n\nPoint getMidpoint(Point p1, Point p2, Point p3) {\n    Point p=p1+p2+p3;\n    p/=3;\n\n    return p;\n}\n\nint f(Point p) {\n    int ret=0;\n    Circle c=Circle(p,1);\n    rep(i,n) {\n        if(include(c,Point{xs[i],ys[i]})) ret++;\n    }\n\n    return ret;\n}\n\nvoid solve() {\n    rep(i,n) cin>>xs[i]>>ys[i];\n    int ans=1;\n    rep(i,n) rep(j,n) if(i<j) {\n        Point p1=Point{xs[i],ys[i]};\n        Point p2=Point{xs[j],ys[j]};\n        Vector v=p1-p2;\n        if(abs(v) > 2.0+EPS) continue;\n        \n        Vector t=(v/abs(v))*Vector(0,1);\n        double h=sqrt(1-abs(v)*abs(v)/4.0);\n\n        Point p = p2+v/2.0 + t*h;\n\n\n        ans=max(ans,f(p));\n        t*=-1.0;\n        p = p2+v/2.0 + t*h;\n        ans=max(ans,f(p));\n    }\n\n    cout<<ans<<endl;\n}\n\nint main() {\n    while(cin>>n) {\n        if(!n) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\npair<double, double> nor(pair<double, double> a){\n\tdouble dist = hypot(a.first,a.second);\n\treturn {a.first/dist,a.second/dist};\n}\ndouble dis(pair<double, double> a, pair<double, double> b) {\n\treturn sqrt((a.first - b.first)*(a.first - b.first) + (a.second - b.second)*(a.second - b.second));\n}\n\npair<double, double> sum(pair<double, double> a, pair<double, double> b) {\n\treturn{ a.first + b.first,a.second + b.second };\n}\n\npair<double, double> sub(pair<double, double> a, pair<double, double> b) {\n\treturn{ a.first - b.first,a.second - b.second };\n}\n\npair<double, double> mal(pair<double, double> a, double b) {\n\treturn{ a.first *b,a.second *b };\n}\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<pair<double, double>> point(n);\n\t\tREP(i, n)\n\t\t\tcin >> point[i].first >> point[i].second;\n\t\tint ans = 1;\n\t\tREP(i, n)\n\t\t\tFOR(j, i + 1, n) {\n\t\t\tdouble d = dis(point[i], point[j]);\n\t\t\tif (d <2.0) {\n\t\t\t\tint cnt = 2;\n\t\t\t\tpair<double, double> ba = sub(point[i], point[j]);\n\t\t\t\tpair<double, double> vba = { -ba.second,ba.first };\n\t\t\t\tpair<double, double> cen1 = sum(point[j], sum(mal(ba, 0.5), mal(nor(vba), sqrt(1-d*d/4))));\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tif (i == k || j == k)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dis(cen1, point[k]) <= 1.0)\n\t\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, cnt);\n\t\t\t\tcnt = 2;\n\t\t\t\tpair<double, double> cen2 = sum(point[j], sum(mal(ba, 0.5), mal(nor(vba), -sqrt(1 - d*d / 4))));\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tif (i == k || j == k)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dis(cen2, point[k]) <= 1.0)\n\t\t\t\t\t\tcnt++;\n\t\t\t\t}\n\n\t\t\t\tans = max(ans, cnt);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\n\nconst long double EPS = 10e-10;\n\nclass Segment;\n\nclass Point{\n    public: \n    long double x,y;\n    \n    Point(long double x = 0.0, long double y = 0.0): x(x), y(y) {}\n    \n    Point operator + (Point p) {\n        return Point(x+p.x, y+p.y);\n    }\n    Point operator - (Point p) {\n        return Point(x-p.x, y-p.y);\n    }\n    Point operator * (long double a) {\n        return Point(x*a, y*a);\n    }\n    Point operator / (long double a) {\n        return Point(x/a, y/a);\n    }\n    bool operator < (const Point &p) const {\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n    bool operator == (const Point &p) const {\n        return fabsl(x - p.x) < EPS && fabsl(y - p.y) < EPS;\n    }\n    \n    long double abs() {\n        return sqrt(norm());\n    }\n    \n    long double norm() {\n        return x*x + y*y;\n    }\n    \n    long double dot(Point p) {\n        return x*p.x + y*p.y;\n    }\n    \n    long double cross(Point p) {\n        return x*p.y - y*p.x;\n    }\n};\n\nclass Segment{\n    public: \n    Point p,q;\n    long double grad;\n    \n    Segment(Point p, Point q) {\n        this->p = p;\n        this->q = q;\n        this->grad = (q.y-p.y)/(q.x-p.x);\n    }\n    \n};\n\nclass Circle{\n    public:\n    Point c;\n    long double r;\n    \n    Circle(Point c = Point(), long double r = 0.0): c(c), r(r) {}\n};\n\n\n\nint main() {\n    int n;\n    while(scanf(\"%d\", &n) && n){\n        vector<Point> points(n);\n        rep(n) cin >> points[i].x >> points[i].y;\n\n        int ans = 1;\n        rep(n){\n            repp(j, n){\n                if(j == i) continue;\n                Point mid = (points[i] + points[j]) / 2;\n                Point midv = Point(mid.y, -mid.x);\n                midv = midv / midv.abs() * (1.0 - (points[i] - mid).abs());\n                Point center = mid + midv;\n                int tmp = 0;\n                repp(k, n){\n                    if((points[k]-center).norm() <= 1.0) tmp++;\n                }\n                ans = max(tmp, ans);\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\n#define EPS (1e-7)\n#define X second\n#define Y first\n\nint main(){\n\n  while(true){\n    int N, ans = 1, n = 0;\n    long double x, y;\n    vector<long double> line;\n    vector<pair<long double,int> > ip;\n    vector<pair<long double, long double> > points;\n    \n    cin>>N;\n\n    if(!N) break;\n\n    \n    for(int i = 0; i < N; i++){\n      cin>>x>>y;\n      \n      points.push_back(make_pair(y,x));\n      line.push_back(y+1.0);\n      line.push_back(y-1.0);\n    }\n\n    for(int i = 0; i < N; i++){\n      for(int j = i+1; j < N; j++){\n       \tif((points[i].X-points[j].X)*(points[i].X-points[j].X) + (points[i].Y-points[j].Y)*(points[i].Y-points[j].Y) > 4.0) continue;\n       \tlong double X = points[i].X - points[j].X, Y = points[i].Y - points[j].X, a, x1, x2, y1, y2;\n\t\t\t\n       \ta = (X*X + Y*Y)/2.0;\n       \ty1 = (a*Y - X*sqrt(X*X+Y*Y - a*a))/(X*X+Y*Y) + points[j].Y;\t\n       \ty2 = (a*Y + X*sqrt(X*X+Y*Y - a*a))/(X*X+Y*Y) + points[j].Y;\t\n       \tline.push_back(y1);\n       \tline.push_back(y2);\n       \t\t\n      }\n    }\n\n    sort(line.begin(), line.end());\n\n    for(int i = 0; i < line.size()-1; i++){\n      line[i] = (line[i+1]+line[i])/2.0;\n    }\n    line.pop_back();\n    sort(points.begin(),points.end());\n\n    for(int i = 0; i < line.size(); i++){\n      \n      for(int j = n; j < N; j++){\n\tlong double a = fabs(line[i] - points[j].Y), b;\n\tif(a < 1.0){\n\t  b = sqrt(1.0 - a*a);\n\t  ip.push_back(make_pair(points[j].X-b,0));\n\t  ip.push_back(make_pair(points[j].X+b,1));\n\t}\n      }\n\n      sort(ip.begin(), ip.end());\n      \n      for(int j = 0, num = 0; j < ip.size(); j++,ans = max(ans,num) ) num += ip[j].second?-1:1;\n      \n      ip.clear();\n    }\n\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<vector>\n#define mp make_pair\n#define pb push_back\n#define rep(i,n) for(int i = 0;i < n;i++)\nusing namespace std;\n\ndouble dist(double x1,double y1,double x2,double y2){\n    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\n\ndouble dist(double x1,double y1){\n    return dist(x1,y1,0,0);\n}\n\nvoid calccenter(double c[][2],double u1[],double u2[]){\n    double v[2]={u2[0]-u1[0],u2[1]-u1[1]};\n    rep(i,2) {\n        rep(j,2){\n            c[i][j]=(u1[j]+u2[j])/2.0;\n        }\n    }\n    double lenv = dist(v[0],v[1]);\n    double lent = sqrt(1-pow((lenv/2.0),2));\n    rep(i,2){\n        double dg = i?1.0:-1.0;\n        c[i][0]+=dg*(v[1]*lent/lenv);\n        c[i][1]-=dg*(v[0]*lent/lenv);\n    }\n}\n\nint main(){\n    int N;\n    while(1){\n        cin>>N;\n        if(!N)break;\n        double a[300][2];\n        rep(i,N){\n            cin>>a[i][0]>>a[i][1];\n        }\n        int ans = 1;\n        int temp = 0;\n        if(N==1){\n            cout<<1<<endl;\n            continue;\n        }\n        rep(u1,N){\n            for(int u2 = u1+1;u2<N;u2++){\n                double c[2][2];\n                if(dist(a[u1][0],a[u1][1],a[u2][0],a[u2][1])>2){\n                    continue;\n                }\n                calccenter(c,a[u1],a[u2]);\n                rep(k,2){\n                    temp = 0;\n                    rep(l,N){\n                        if(l==u1||l==u2){\n                            temp++;\n                        }else if(dist(c[k][0],c[k][1],a[l][0],a[l][1])<=1.0){\n                            temp++;\n                        }\n                    }\n                    ans = max(ans,temp);\n                }\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\ndouble x[300],y[300];\ndouble px[90000],py[90000];\nint main(){\n    int a;\n    while(scanf(\"%d\",&a),a){\n        for(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n        int now=0;\n        for(int i=0;i<a;i++){\n            for(int j=i+1;j<a;j++){\n                if((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])<4.0000001){\n                    double d=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n                    double mx=(x[i]+x[j])/2;\n                    double my=(y[i]+y[j])/2;\n                    double s=sqrt(1-d*d/4);\n                    double theta=atan((y[i]-y[j])/(x[i]-x[j]));\n                    px[now]=mx-sin(theta)*s;\n                    py[now++]=my+cos(theta)*s;\n                    px[now]=mx+sin(theta)*s;\n                    py[now++]=my-cos(theta)*s;\n                }\n            }\n        }\n        int ret=1;\n        for(int i=0;i<now;i++){\n            int k=0;\n            for(int j=0;j<a;j++)if((px[i]-x[j])*(px[i]-x[j])+(py[i]-y[j])*(py[i]-y[j])<1.0000001)k++;\n            ret=max(ret,k);\n        }\n        printf(\"%d\\n\",ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\nconst double PI=3.141592653589793238462643383279;\n\nbool inC(P p, P c, double r){return abs(p-c)<r+1e-9;}\n\nP getE(P p){return p/abs(p);}\n\ndouble sq(double x){ return  x*x;}\n\nint main(){\n    int n,i,j,k,ans,cnt;\n    double x, y;\n    while(scanf(\"%d\",&n)){\n        if(n==0) break;\n        ans=1;\n        vector<P> ps(n);\n        for(i=0; i<n; i++){\n            scanf(\"%lf%lf\",&x,&y);\n            ps[i] = P(x,y);\n        }\n        for(i=0;i<n;i++)\n            for(j=i+1;j<n;j++)if(abs(ps[i]-ps[j])<2){\n                double d=sqrt(1-sq(abs(ps[j]-ps[i])*0.5));\n                P c1=0.5*(ps[i]+ps[j])+getE(getE(ps[j]-ps[i]))*polar(d,PI/2);\n                P c2=0.5*(ps[i]+ps[j])+getE(getE(ps[j]-ps[i]))*polar(d,-PI/2);\n                cnt=0;\n                for(k=0;k<n;k++)if(inC(ps[k],c1,1.0))cnt++;\n                if(cnt>ans)ans=cnt;\n                cnt=0;\n                for(k=0;k<n;k++)if(inC(ps[k],c2,1.0))cnt++;\n                if(cnt>ans)ans=cnt;\n            }\n       // if(ans==0) ans++;\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<limits>\n#include<iomanip>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\n\n\n\ntypedef pair<double,double> Point;\n#define F first\n#define S second\n#define MK make_pair\n\nPoint pls(Point a,Point b){\n    return MK(a.F+b.F,a.S+b.S);\n}\n\nPoint mns(Point a,Point b){\n    return MK(a.F-b.F,a.S-b.S);\n}\n\nPoint T(Point t){\n    return MK(t.S,-1.0*t.F);\n}\n\ndouble abs(Point a){\n    return sqrt(a.F*a.F+a.S*a.S);\n}\n\ndouble norm(Point a){\n    return a.F*a.F+a.S*a.S;\n}\n\nPoint mid(Point a,Point b){\n    return MK((a.F+b.F)/2,(a.S+b.S)/2);\n}\n\nbool in(Point c,Point t){\n    if(norm(mns(t,c))<=1){return true;}\n    return false;\n}\n\n\nint main(){\n    while(1){\n        int n;\n        cin>>n;\n        if(n==0){break;}\n        vector<Point> vp;\n        int mx=0;\n        for(int i=0;i<n;i++){\n            double a,b;\n            cin>>a>>b;\n            vp.push_back(MK(a,b));\n        }\n        sort(vp.begin(),vp.end());\n        for(int i=0;i<vp.size();i++){\n            for(int t=i+1;t<vp.size() && vp[t].F-vp[i].F<=2;t++){\n                if(abs(mns(vp[t],vp[i]))>2){continue;}\n                Point m=mid(vp[i],vp[t]);\n                Point l=mns(vp[t],vp[i]);\n                Point lt=T(l);\n                double h=sqrt(1.0-abs(l)*abs(l)/4.0);\n                lt.F=h*lt.F/abs(l);\n                lt.S=h*lt.S/abs(l);\n                Point c=pls(m,lt);\n                int count=2;\n                for(int k=0;k<vp.size();k++){\n                    if(k!=i && k!=t && in(c,vp[k])){count++;}\n                }\n                mx=max(mx,count);\n                c=mns(m,lt);\n                count=2;\n                for(int k=0;k<vp.size();k++){\n                    if(k!=i && k!=t && in(c,vp[k])){count++;}\n                }\n                mx=max(mx,count);\n            }\n        }\n        cout<<mx<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define sz(x) ((int)(x).size())\n#define sq(x) ((x)*(x))\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ndouble add(double a,double b){\n\tif(abs(a+b)<eps*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{\n\tdouble x,y;\n\tP() {}\n\tP(double x,double y) : x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tdouble dot(P p){\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tdouble norm(){\n\t\treturn sqrt(x*x+y*y);\n\t}\n\tdouble dist2(P p){\n\t\treturn sq(x-p.x)+sq(y-p.y);\n\t}\n\tP vert(){\n\t\treturn P(y,-x);\n\t}\n\tvoid dump(){\n\t\tprintf(\"%.12f %.12f\\n\",x,y);\n\t\treturn;\n\t}\n};\nint N;\nP pts[305];\nint solve(){\n\tscanf(\"%d\",&N);\n\tif(N==0)return 1;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%lf %lf\",&pts[i].x,&pts[i].y);\n\t}\n\tint ans = 0;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tP m = (pts[i]+pts[j])*0.5;\n\t\t\tP a = (pts[i]-pts[j]);\n\t\t\tdouble na = a.norm();\n\t\t\tif(na>2.0)continue;\n\t\t\ta = (a.vert())*(sqrt(1-sq(na/2.0))/na);\n\t\t\tP b = m+a;\n\t\t\tP c = m-a;\n\t\t\t/*cout << i << ' ' << j << endl;\n\t\t\tm.dump();\n\t\t\ta.dump();\n\t\t\tb.dump();\n\t\t\tc.dump();\n\t\t\tcout << endl;*/\n\t\t\tint cnt = 0;\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t//if(1.0<pts[k].dist2(b)&&pts[k].dist2(b)<=1.0+eps)printf(\"%d:%.12f\\n\",k,pts[k].dist2(b));\n\t\t\t\tif(pts[k].dist2(b)<=1.0+eps)cnt++;\n\t\t\t}\n\t\t\tans = max(ans,cnt);\n\t\t\tcnt = 0;\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t//if(1.0<pts[k].dist2(c)&&pts[k].dist2(c)<=1.0+eps)printf(\"%d:%.12f\\n\",k,pts[k].dist2(c));\n\t\t\t\tif(pts[k].dist2(c)<=1.0+eps)cnt++;\n\t\t\t}\n\t\t\tans = max(ans,cnt);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\nint main(){\n\twhile(!solve()){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <utility>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nbool inCircle(const Point &p, const Point &center, double radius) {\n    double dist2 = norm(p-center);\n    double rad2 = radius*radius;\n    return dist2 < rad2+1e-9;\n}\n\nint check(const Point &center, const vector<Point> &points) {\n    const int N = points.size();\n    int cnt = 0;\n    for(int i = 0; i < N; ++i) {\n        if(inCircle(points[i], center, 1)) ++cnt;\n    }\n    return cnt;\n}\n\nint test(int a, int b, const vector<Point> &points) {\n    const Point v(points[a]-points[b]);\n    if(abs(v) >= 2) return 1;\n    const double hlen = abs(v)/2;\n\n    const double plen = sqrt(1 - hlen*hlen);\n    Point perp = v*Point(0, 1);\n    perp /= abs(perp);\n    const Point mid = (points[a]+points[b]) / 2.0;\n    return max(check(mid + perp*plen, points), check(mid - perp*plen, points));\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        vector<Point> points(N);\n        for(int i = 0; i < N; ++i) {\n            cin >> points[i].real() >> points[i].imag();\n        }\n        int ans = 0;\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < i; ++j) {\n                ans = max(ans, test(i, j, points));\n            }\n        }\n        if(N == 1) ans = 1;\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tusing Point = std::complex<long double>;\n\tlong double epsilon{1e-6};\n\n\tint N;\n\tstd::vector<Point> points;\n\n\tint countPoints(int pi_1, int pi_2)\n\t{\n\t\tPoint &p1{points[pi_1]}, &p2{points[pi_2]};\n\t\tif (std::abs(p1 - p2) > 2 + epsilon) return 0;\n\t\tPoint center{p1 + std::polar((long double)1.0, std::acos(std::abs(p2 - p1) / 2) + std::arg(p2 - p1))};\n\t\tint count{};\n\t\tfor (auto& e: points)\n\t\t\tif (std::abs(e - center) <= 1 + epsilon)\n\t\t\t\tcount++;\n\t\treturn count;\n\t}\npublic:\n\tbool is_last_query_{};\n\tSolve()\n\t{\n\t\tscanf(\"%d\", &N);\n\t\tif (N == 0)\n\t\t{\n\t\t\tis_last_query_ = true;\n\t\t\treturn;\n\t\t}\n\t\tpoints.resize(N);\n\t\tfor (auto& e: points)\n\t\t{\n\t\t\tlong double r, i;\n\t\t\tstd::cin >> r >> i;\n\t\t\te.real(r);\n\t\t\te.imag(i);\n\t\t}\n\t\tint max{1};\n\t\tfor (int i{}; i < N; i++)\n\t\t\tfor (int j{}; j < N; j++)\n\t\t\t\tif (i != j)\n\t\t\t\t\tmax = std::max(max, countPoints(i, j));\n\t\tprintf(\"%d\\n\", max);\n\t\treturn;\n\t}\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query_);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\ntypedef pair<double,double> P;\n\ninline double dist(P p,P q){\n  return ( (p.first-q.first)*(p.first-q.first) + (p.second-q.second)*(p.second-q.second));\n}\n\nint main(){\n  int N;\n  double sign[2] = {+1, -1};\n  P p[310];\n  while(scanf(\"%d\",&N) != EOF){\n    if(N == 0)break;\n    REP(i,N)scanf(\"%lf %lf\",&p[i].first,&p[i].second);\n    int ans = 1;\n    REP(i,N)REP(j,N)if(i!=j){\n      double dst = dist(p[i],p[j]);\n      if(dst > 4.0) continue;\n      /*\n       P v((p[j].first-p[i].first)/dst, (p[j].second-p[i].second)/dst);\n       P m((p[j].first+p[i].first)/2.0, (p[j].second+p[i].second)/2.0);\n       double lth = sqrt(1.0-(dst*dst)/4.0);\n       REP(k,2){\n       double cx = m.first + sign[k] * v.first * lth;\n       double cy = m.second - sign[k] * v.second * lth;\n       P center(cx,cy);\n       int count = 0;\n       REP(l,N){\n       if(l == i || l == j || dist(center,p[l]) < 1.00001){\n       count++;\n       }\n       if(N-l-1 + count < ans)break;\n       }\n       if(ans < count) ans = count;\n       }\n       */\n      P dp((p[j].first-p[i].first)/2.0 , (p[j].second-p[i].second)/2.0);\n      double d = sqrt(dist(P(0,0),dp));\n      double t = sqrt(1.0-d*d)/d;\n      P center(p[i].first + dp.first - t * dp.second, p[i].second + dp.second + t * dp.first);\n      int count = 0;\n      REP(k,N){\n        if(dist(center,p[k]) < 0.00001 + 1)count++;\n      }\n      ans = max(ans,count);\n    }\n    printf(\"%d\\n\",ans);\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define mp make_pair\n#define pb push_back\n#define EB emplace_back\n#define fi first\n#define se second\n#define all(v) ALL(v)\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\nconstexpr double eps = 1e-14; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint N;\n\nvoid solve(){\n    vector<double> x(N),y(N);\n    rep(i,N){ cin >> x[i] >> y[i]; }\n\n    int ans=1;\n    rep(i,N) rep(j,N) if(i!=j){\n        double vx = x[i]-x[j];\n        double vy = y[i]-y[j];\n        double d = sqrt(vx*vx+vy*vy);\n        if(d>2) continue;\n        double r = sqrt(1-(d/2)*(d/2));\n\n        double rx =  -vy*r/d;\n        double ry = vx*r/d;\n\n        double cx = (x[i]+x[j])/2 + rx;\n        double cy = (y[i]+y[j])/2 + ry;\n\n        int cnt=0;\n        rep(k,N){\n            double tx = cx-x[k];\n            double ty = cy-y[k];\n            double dd = sqrt(tx*tx+ty*ty);\n            if(dd<=1) cnt++;\n        }\n        ans = max(ans,cnt);\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    while(cin>>N){\n        if(N==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\n#define x first\n#define y second\nconst int N = 300 + 1;\n\ntypedef pair<double, double> point;\npoint points[N];\ndouble distances[N][N];\n\ndouble sq(double d) {\n  return d * d;\n}\n\ndouble dist(point a, point b) {\n  return sqrt(sq(a.x - b.x) + sq(a.y - b.y));\n}\n\nint main() {\n  int n;\n  cin >> n;\n  while (n) {\n    for (int i = 0; i < n; ++i) {\n      double x, y;\n      cin >> x >> y;\n      points[i] = {x, y};\n    }\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        distances[i][j] = dist(points[i], points[j]);\n\n    // for each point,\n    //  for every other point\n    //    for every point currently selected\n    //      check if it goes past the bounds\n    //    add the point if its contained\n    //\n    int m = 0;\n    for (int i = 0; i < n; ++i) {\n      vector<int> selected = {i};\n      for (int j = 0; j < n; ++j) {\n        if (i == j) continue;\n        bool contained = true;\n        for (auto k : selected) {\n          if (distances[j][k] > 2.0) {\n            contained = false;\n            break;\n          }\n        }\n        if (contained) selected.push_back(j);\n        /*\n        cout << i << ' ' << j << \": \" << endl;\n        for (auto p : selected) cout << p << ' ';\n        cout << endl;\n        */\n      }\n\n      m = max(m, (int)selected.size());\n    }\n\n    cout << m << endl;\n\n    cin >> n;\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\nusing P = complex<ld>;\nconst ld eps = 1e-10;\n\nint main()\n{\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<ld> x(N), y(N);\n\t\tvector<P> p(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tp[i] = P(x[i], y[i]);\n\t\t}\n\t\tvector<P> ko;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tif (norm(p[i] - p[j]) < 4.0 + eps) {\n\t\t\t\t\tauto d = p[i] - p[j];\n\t\t\t\t\tko.push_back(p[j] + (d * (ld)0.5) + d * P(0, 1) / abs(d) * sqrtl(1 - norm(d * (ld)0.5)));\n\t\t\t\t\tko.push_back(p[j] + (d * (ld)0.5) - d * P(0, 1) / abs(d) * sqrtl(1 - norm(d * (ld)0.5)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor (auto c : ko) {\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (norm(c - p[i]) < 1.0 + eps) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = max(res, cnt);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\nconst double sqrt2 = sqrt(2.0); \nconst double eps = 1e-6;\nchar dx[] = {-1,1,-1,1};\nchar dy[] = {1,1,-1,-1};\n\nclass Square{\npublic:\n\tint bound; double x, y, size;\n\tSquare(int bound, double x, double y, double size) : bound(bound), x(x), y(y), size(size) {}\n\tbool operator < (const Square &s) const { return bound < s.bound; }\n};\n\ninline double sqr(double x) { return x*x; }\n\nint main(){\n\tint N;\n\tdouble x[300], y[300];\n\twhile(cin >> N){\n\t\tif(!N) break;\n\t\tfor(int i=0;i<N;i++) cin >> x[i] >> y[i];\n\t\tint ans = 1;\n\t\tpriority_queue<Square> qu;\n\t\tqu.push(Square(N, 5.0, 5.0, 10.0));\n\t\twhile(!qu.empty()){\n\t\t\tSquare s = qu.top(); qu.pop();\n\t\t\tif(s.bound <= ans) break;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tdouble nx = s.x + dx[i]*s.size/2.0;\n\t\t\t\tdouble ny = s.y + dy[i]*s.size/2.0;\n\t\t\t\tint c = 0, upper = 0;\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tdouble dist = sqr(x[j]-nx)+sqr(y[j]-ny);\n\t\t\t\t\tif(dist < 1.0+eps) c++;\n\t\t\t\t\tif(dist < sqr(1.0+sqrt2*s.size/2.0)+eps) upper++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, c);\n\t\t\t\tif(upper > ans) qu.push(Square(upper, nx, ny, s.size/2.0));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\nstatic const double PI = acos(-1);\ndouble sc(double a){return sqrt(1.0-a*a);}\n\nclass Point{\npublic:\n double x, y;\n Point ( double x = 0, double y = 0): x(x), y(y){}\n Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n Point operator * ( double a ){ return Point(x*a, y*a); }\n Point operator / ( double a ){ return Point(x/a, y/a); }\n double abs() { return sqrt(norm());}\n double norm() { return x*x + y*y; }\n bool operator < ( const Point &p ) const {\n   return x != p.x ? x < p.x : y < p.y;\n }\n bool operator == ( const Point &p ) const {\n   return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n }\n};\n\ntypedef Point Vector;\n\nclass Segment{\n   public:\n   Point p1, p2;\n   Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n};\ntypedef Segment Line;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\nPoint rotate( Point a, double si,double co){\n return Point(a.x*co-a.y*si,a.x*si+a.y*co);\n}\nPoint rotate( Point a, double n){\n return Point( a.x*cos(n)-a.y*sin(n) , a.x*sin(n)+a.y*cos(n) );\n}\n\nPoint getCrossPointCC(Point p1,double r1,Point p2,double r2){\n double a=r2,b=r1,c=getDistance(p1,p2);\n double cos_A = (b*b+c*c-a*a) / (2.0*b*c);\n double sin_A = sqrt(1.0-cos_A*cos_A);\n Vector v=p2-p1;\n v = v * r1 / c;\n return p1+rotate(v,sin_A,cos_A);\n}\n\nSegment getSegmentCC(Point p1,double r1,Point p2,double r2,bool flg=false){\n double b=getDistance(p1,p2),c=r1+r2;\n double a=sqrt(b*b-c*c);\n double cos_A=(b==0?1:c/b),sin_A=(b==0?0:a/b);\n\n if(flg)sin_A=-sin_A;\n \n Vector v1 = (p2-p1),v2 = (p1-p2);\n v1 = v1 * r1 / b;\n v1 = rotate(v1,sin_A,cos_A);\n v2 = v2 * r2 / b;\n v2 = rotate(v2,sin_A,cos_A);\n return Segment(p1+v1,p2+v2);\n}\n\nSegment getSegmentCC2(Point p1,double r1,Point p2,double r2,bool flg=false){\n if(r1>r2){\n   swap(p1,p2);\n   swap(r1,r2);\n }\n double c=abs(r1-r2),b=getDistance(p1,p2);\n double a=sqrt( b*b - c*c );\n\n double cos_A=c/b,sin_A=a/b;\n if(flg)sin_A=-sin_A;\n\n Vector v1 = p1-p2;\n v1 = v1 * r1 / b;\n v1 = rotate( v1, sin_A,cos_A);\n Vector v2 = v1 * r2 / r1;\n return Segment(p1+v1,p2+v2);\n}\n\ndouble getDistanceLP(Line s,Point p){\n return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\n\nPoint t[500];\nint n;\n\nint calc(Point p){\n  int res=0;\n  for(int i=0;i<n;i++){\n    double c = getDistance(p,t[i]);\n    if(c < 1.0 + EPS )res++;\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>n&&n){\n    int ans=1;\n    for(int i=0;i<n;i++){\n      cin>>t[i].x>>t[i].y;\n    }\n    for(int i=0;i<n-1;i++){\n      for(int j=i+1;j<n;j++){\n\n\tif( getDistance(t[i],t[j]) < 2.0 +EPS){\n\t  Point A = getCrossPointCC(t[i],1.0,t[j],1.0);\n\t  Point B = getCrossPointCC(t[j],1.0,t[i],1.0);\n\t  \n\t  ans=max(ans, calc(A));\n\t  ans=max(ans, calc(B));\n\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <utility>\nusing namespace std;\n\n#define EPS 1e-8\n\ntypedef complex<double> P;\ntypedef const P &rP;\n\nconst double pi = acos(-1.0);\n\nvoid intrcc(rP p1, double r1, rP p2, double r2, vector<P> &ret){\n\tdouble d = abs(p2 - p1);\n\tdouble phi = arg(p2 - p1);\n\t\n\tdouble ct = (d * d + r1 * r1 - r2 * r2) / (2.0 * d * r1);\n\tif(abs(d) < EPS || abs(ct) > 1.0 + EPS){ return; }\n\tif(ct > 1.0){ ct = 1.0; }\n\telse if(ct < -1.0){ ct = -1.0; }\n\t\n\tdouble theta = acos(ct);\n\n\tret.push_back(p1 + polar(r1, phi + theta));\n\tret.push_back(p1 + polar(r1, phi - theta));\n}\n\nint main(){\n\tvector<P> chk;\n\tchk.reserve(100000);\n\n\tint n;\n\twhile(scanf(\"%d\", &n), n){\n\t\tchk.clear();\n\n\t\tvector<P> ps(n);\n\t\tdouble x, y;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tps[i] = P(x, y);\n\t\t\t\n\t\t\tfor(int j = 0; j < i; ++j){\n\t\t\t\tintrcc(ps[i], 1.0, ps[j], 1.0, chk);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 1;\n\t\tfor(int i = 0; i < chk.size(); ++i){\n\t\t\tint cnt = 0;\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tif(abs(ps[j] - chk[i]) < 1.0 + EPS){\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, cnt);\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// Circle and Points\n\n// 平面走査ごり押し\n// wrong answer\n// EPS変えてもダメ　1e-3, 1e-5, 1e-10, 1e-12\n\n#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle().crosspoint()の戻り値\nusing namespace std;\n\nconst double EPS = 1e-10;\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\npublic:\n    double x, y;\n    Point(double a = 0.0, double b = 0.0) :x(a), y(b) {};\n    bool operator== (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    Point operator+(const Point&) const;\n    Point operator-(const Point&) const;\n    Point operator-() const;\n    Point times(double) const;\n    Point& operator=(const Point&);\n    Point& operator+=(const Point&);\n    Point& operator-=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    Point projection(const Line&) const;\n    Point reflection(const Line&) const;\n    int ccw(const Point&, const Point&) const;              // a.ccw(b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n};\nclass Segment {\npublic:\n    Point source, target;\n    Segment(Point a = Point(), Point b = Point()) :source(a), target(b) {};\n    Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n};\nclass Line {\npublic:\n    Point source, target;\n    Line(Point a = Point(), Point b = Point()) :source(a), target(b) {};\n    Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    Point projection(const Point&) const;\n    Point reflection(const Point&) const;\n    Point crosspoint(const Line&) const;\n};\nclass Circle {\npublic:\n    double x, y, r;\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :x(a), y(b), r(c) {};\n    Point point() const;\n    double distance(const Point&) const;                    // 円の中心と点の距離\n    double distance(const Circle&) const;                   // 円の中心同士の距離\n    bool include(const Point&) const;                       // 点を含むか\n    bool include(const Circle&) const;                      // 円を含むか\n    bool intersect(const Circle&) const;\n    vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x == p.x && y == p.y;}\nbool Point::operator<(const Point &p) const {return x != p.x ? x < p.x : y < p.y;}\nbool Point::operator>(const Point &p) const {return x != p.x ? x > p.x : y > p.y;}\nbool Point::operator<=(const Point &p) const {return x != p.x ? x < p.x : y <= p.y;}\nbool Point::operator>=(const Point &p) const {return x != p.x ? x > p.x : y >= p.y;}\nPoint Point::operator+(const Point& p) const {return Point(x + p.x, y + p.y);}\nPoint Point::operator-(const Point& p) const {return Point(x - p.x, y - p.y);}\nPoint Point::operator-() const {return Point(-x, -y);}\nPoint Point::times(double d) const {return Point(x * d, y * d);}\nPoint& Point::operator=(const Point& p) {x = p.x; y = p.y; return *this;}\nPoint& Point::operator+=(const Point& p) {x += p.x; y += p.y; return *this;}\nPoint& Point::operator-=(const Point& p) {x -= p.x; y -= p.y; return *this;}\ndouble Point::dot(const Point& p) const {return x * p.x + y * p.y;}\ndouble Point::cross(const Point& p) const {return x * p.y - y * p.x;}\ndouble Point::abs() const {return hypot(x, y);}\ndouble Point::norm() const {return x * x + y * y;}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nPoint Point::projection(const Line& l) const {return l.projection(*this);}\nPoint Point::reflection(const Line& l) const {return l.reflection(*this);}\nint Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > 0.0) return 1;\n    if(v1.cross(v2) < 0.0) return -1;\n    if(v1.dot(v2) < 0.0) return 2;\n    if(v1.norm() < v2.norm()) return -2;\n    return 0;\n}\n// Segment\nLine Segment::line() const {return Line(source, target);}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    double a = source.distance(p);\n    double b = target.distance(p);\n    return a < b ? a : b;\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source);\n    double b = distance(s.target);\n    double c = s.distance(source);\n    double d = s.distance(target);\n    a = a < b ? a : b;\n    a = a < c ? a : c;\n    return a < d ? a : d;\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {\n    return source.distance(p) + target.distance(p) - target.distance(source) <= EPS;\n}\nbool Segment::intersect(const Segment& s) const {\n    bool a = s.source.ccw(s.target, source) * s.source.ccw(s.target, target) <= EPS;\n    bool b = source.ccw(target, s.source) * source.ccw(target, s.target) <= EPS;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\n// Line\nSegment Line::segment() const {return Segment(source, target);}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source);\n    double b = distance(s.target);\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source);}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source - p;\n    Point v2 = target - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target - source;\n    Point v2 = s.source - source;\n    Point v3 = s.target - source;\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target - source;\n    Point v2 = l.target - l.source;\n    Point v3 = l.source - source;\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nPoint Line::projection(const Point& p) const {\n    Point v1 = p - source;\n    Point v2 = source - target;\n    return Point(source + v2.times(v1.dot(v2) / v2.norm()));\n}\nPoint Line::reflection(const Point& p) const {\n    return p + (projection(p) - p).times(2.0);\n}\nPoint Line::crosspoint(const Line& l) const {\n    Point v1 = target - source;\n    Point v2 = l.target - l.source;\n    Point v3 = target - l.source;\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source;\n    return l.source + v2.times(b / a);\n}\n// Circle\nPoint Circle::point() const {return Point(x, y);}\ndouble Circle::distance(const Point& p) const {return point().distance(p);}\ndouble Circle::distance(const Circle& c) const {return point().distance(c.point());}\nbool Circle::include(const Point& p) const {return distance(p) - r <= EPS;}\nbool Circle::include(const Circle& c) const {return distance(c) - (r - c.r) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return distance(c) - r - c.r <= EPS;}\nvector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y - y, c.x - x);\n    double d = distance(c);\n    double add = acos((d * d + r * r - c.r * c.r) / (2.0 * d * r));\n    vector<Point> result;\n    result.push_back(Point(x + r * cos(angle + add), y + r * sin(angle + add)));\n    result.push_back(Point(x + r * cos(angle - add), y + r * sin(angle - add)));\n    return result;\n}\n\nint main() {\n    int n;\n    while(cin>>n, n) {\n        vector<Circle> circle;\n        vector<Circle> crosspoint;\n        for(int i = 0; i < n; i++) {\n            double x, y;\n            cin>>x>>y;\n            circle.push_back(Circle(x, y, 1.0));\n            crosspoint.push_back(Circle(x, y, 1.0));\n        }\n        for(int i = 0; i < n - 1; i++) {\n            for(int j = i + 1; j < n; j++) {\n                if(!circle[i].intersect(circle[j])) continue;\n                vector<Point> p = circle[i].crosspoint(circle[j]);\n                crosspoint.push_back(Circle(p[0].x, p[0].y, 1.0));\n                crosspoint.push_back(Circle(p[1].x, p[1].y, 1.0));\n            }\n        }\n        int answer = 0;\n        for(int i = 0; i < crosspoint.size(); i++) {\n            int count = 0;\n            for(int j = 0; j < n; j++) {\n                if(crosspoint[i].include(circle[j].point())) count++;\n            }\n            if(answer < count) answer = count;\n        }\n        cout<<answer<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\n#define EPS 1.0e-8\n#define P complex<double>\n\nint main(){\n  int n;\n  P p[301];\n\n  while( cin>>n && n ){\n    for( int i=0;i<n;i++ )\n      cin >> p[i].real() >> p[i].imag();\n\n    int ans=0;\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ ){\n\tif( i==j ) \t  continue;\n\tif( abs( p[i]-p[j] )+EPS > 2.0 ) continue;\n\n\tP m  = (p[i]+p[j]) / 2.0; // p[i]Æp[j]Ì_\n\tP nn = (p[i]-p[j]) * P(0,1);       // @üxNg\n\tnn = nn / abs(nn);\n\n\tdouble x = abs( p[i]-p[j] )/2.0;\n\tP c = m + nn*sqrt( 1.0-x*x );        // ~ÌS\n\n\tint num=0;\n\tfor( int k=0;k<n;k++ )\n\t  if( abs( c-p[k] ) < 1.0 + EPS  )\n\t    num++;\n\tans = max( ans,num );\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nclass Point{\npublic:\n\tdouble x;\n\tdouble y;\n\tPoint() : x(0),y(0){}\n\tPoint(double _x,double _y){\n\t\tx = _x;\n\t\ty = _y;\n\t}\n};\n\nclass Region{\npublic:\n\tint larger_num;\n\tint smaller_num;\n\tdouble size;\n\tdouble x;\n\tdouble y;\n\tRegion(double _x,double _y,double _size,int _larger_num,int _smaller_num){\n\t\tx = _x;\n\t\ty = _y;\n\t\tsize = _size;\n\t\tlarger_num = _larger_num;\n\t\tsmaller_num = _smaller_num;\n\t}\n\n\tbool operator<(const Region& r) const{\n\t\treturn larger_num < r.larger_num;\n\t}\n};\n\nvoid save(double x,double y,double size,const vector<Point>& points,priority_queue<Region>& que,int* maxv){\n\tint larger_num=0;\n\tint smaller_num=0;\n\tdouble cx = x + (size / 2.0);\n\tdouble cy = y + (size / 2.0);\n\n\tfor(int i=0;i<points.size();i++){\n\t\tdouble d = sqrt((points[i].x - cx) * (points[i].x - cx)\n\t\t\t+ (points[i].y - cy) * (points[i].y - cy));\n\t\tif(d <= 1.0) smaller_num++;\n\t\tif(d <= 1.0 + (size/2.0)*sqrt(2.0)) larger_num++;\n\t}\n\n\tif(*maxv >= larger_num) return;\n\t*maxv = max(*maxv,smaller_num);\n\n\tque.push(Region(x,y,size,larger_num,smaller_num));\n}\n\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tvector<Point> points;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf %lf\",&x,&y);\n\t\t\tpoints.push_back(Point(x,y));\n\t\t}\n\n\t\tpriority_queue<Region> que;\n\n\t\tint maxv = 1;\n\t\tsave(0,0,10,points,que,&maxv);\n\n\t\twhile(!que.empty()){\n\t\t\tRegion re = que.top();\n\t\t\tint larger = re.larger_num;\n\t\t\tint smaller = re.smaller_num;\n\t\t\tdouble size = re.size;\n\t\t\tdouble x = re.x;\n\t\t\tdouble y = re.y;\n\n\t\t\tque.pop();\n\t\t\n\t\t\tsave(x,y,size/2.0,points,que,&maxv);\n\t\t\tsave(x+size/2.0,y,size/2.0,points,que,&maxv);\n\t\t\tsave(x,y+size/2.0,size/2.0,points,que,&maxv);\n\t\t\tsave(x+size/2.0,y+size/2.0,size/2.0,points,que,&maxv);\n\t\t}\n\n\t\tprintf(\"%d\\n\",maxv);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nP readP() {\n    double x, y;\n    cin >> x >> y;\n    return P(x, y);\n}\n\n// rot p around q by theta (counter-clockwise)\nP rotP(P p, P q, double theta) {\n    p -= q;\n    double x = p.real(), y = p.imag();\n    p = P(x * cos(theta) - y * sin(theta), x * sin(theta) + y * cos(theta));\n    p += q;\n    return p;\n}\n\nP center(P p, P q) {\n    P v = p - q;\n    double theta = asin(abs(v) / 2);\n    v *= (1 / abs(v));\n    P u = rotP(v, p, theta);\n    return p + u;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    while (cin >> n, n) {\n        vector<P> p(n);\n        rep(i, n) p[i] = readP();\n\n        int ans = 1;\n        rep(i, n) {\n            rep(j, n) {\n                if (i == j) continue;\n                if (abs(p[i] - p[j]) < 2 + EPS) {\n                    P c = center(p[i], p[j]);\n                    int cnt = 2;\n                    rep(k, n) {\n                        if (k == i || k == j) continue;\n                        if (abs(p[k] - c) < 1 + EPS) {\n                            cnt++;\n                        }\n                    }\n                    ans = max(ans, cnt);\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <cmath>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\n// ----- debug macro -----\n#define DMPPT(p,stream) stream << (p).X << \",\" << (p).Y\n// ----- ----- ----- -----\n\n// ???????§???????????§????????????£°????£°?????????????????????§???????????\\?????¶????????????????????¶????????????????¨????????§???????????£???\ntypedef complex<double> PT;\ntypedef complex<double> VC;\n\n// ??¶??´??±???or ??±?£?????????????????????´??????????£??????§???????????????????????VC get_vc_normal(VC a) {\n\ta = a * PT(0,-1);\n\treturn a / abs(a);\n}\n\nint N;\nconst double EPS = 1e-9;\n\n// rest code\nint main() {\n\twhile(cin >> N, N) {\n\t\tvector<PT> p;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp.push_back(PT(x,y));\n\t\t}\n\n\t\tint res = 1;\n\t\tfor(int i = 0; i < p.size(); i++) {\n\t\t\tfor(int j = 0; j < p.size(); j++) {\n\t\t\t\tif(i == j) continue;\n\t\t\t\tVC a, b;\n\t\t\t\tPT c[2];\n\t\t\t\tdouble len;\n\t\t\t\ta = (p[j] - p[i]) / 2.0;\n\t\t\t\tif(abs(a) > 1.0) continue;\n\t\t\t\tb = get_vc_normal(a);\n\t\t\t\tlen = sqrt(1.0 - norm(a));\n\t\t\t\tc[0] = p[i] + a + len*b;\n\t\t\t\tc[1] = p[i] + a - len*b;\n\n\t\t\t\tfor(int k = 0; k < 2; k++) {\n\t\t\t\t\tint tmp = 0;\n\t\t\t\t\tfor(int l = 0; l < p.size(); l++) {\n\t\t\t\t\t\tif(abs(c[k] - p[l]) < 1.0 + EPS) tmp++;\n\t\t\t\t\t}\n\t\t\t\t\tres = max(res, tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,N) for(int i=0;i<(int)(N);i++)\n#define REP(i,k,N) for(int i=k;i<(int)(N);i++)\n\n#define vi vector<int>\n#define pb push_back\n\n#define pdd pair<double,double>\n#define fi first\n#define se second\nconst double  EPS = 1e-9;\n\ndouble dist(double x,double y){\n    return x*x+y*y;\n};\n\nint main(){\n\n    int n;\n    while(cin >> n,n){\n        int ma = 0;\n        pdd p[330];\n        rep(i,n) cin >> p[i].fi >> p[i].se;\n        rep(i,n-1){\n            REP(j,i+1,n){\n                int cnt1 = 0,cnt2=0;\n                double x1,y1,x2,y2,x3,y3;\n                tie(x1,y1) = p[i];\n                tie(x2,y2) = p[j];\n                double cx1,cy1,cx2,cy2;\n                if(dist(x1-x2,y1-y2)-4 > EPS  ) continue;\n\n                //はりまコーナー\n//                double ax,ay,bx1,by1,bx2,by2,mx,my,dx,dy;\n//                ax=x1-x2;ay=y1-y2;\n//                mx=(x1+x2)/2;my=(y1+y2)/2;\n//                by1 = (-0.5)*pow(ax,4)+pow(ax,2)+(-0.5)*pow(ax,2)*pow(ay,2)\n//                        /dist(ax,ay);\n//                by1 = sqrt(abs(by1));\n//                by2 = -1*by1;\n//                cy1= my+by1;\n//                cy2= my+by2;\n//                bx1= -1*(ay*by1)/ax;\n//                bx2= -1*(ay*by2)/ax;\n//                cx1=bx1+mx;\n//                cx2=bx2+mx;\n\n\n                //あじのりコーナー\n                double mx=(x1+x2)/2,my=(y1+y2)/2;\n\n                double ld = 1-dist((x1-x2)/2,(y1-y2)/2);\n                ld = sqrt(ld);\n                cx1 = mx - sin(atan((y2-y1)/(x2-x1)))*ld;\n                cy1 = my + cos(atan((y2-y1)/(x2-x1)))*ld;\n                cx2 = mx + sin(atan((y2-y1)/(x2-x1)))*ld;\n                cy2 = my - cos(atan((y2-y1)/(x2-x1)))*ld;\n\n                for(int k = 0;k<n;k++) {\n                    tie(x3, y3) = p[k];\n                    if (EPS > dist((cx1 - x3), (cy1 - y3))-1) cnt1++;\n                    if (EPS > dist((cx2 - x3), (cy2 - y3))-1) cnt2++;\n                }\n                ma = max({cnt1,cnt2,ma});\n            }\n        }\n        cout<< ma << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <map>\n\nint n;\ndouble x[512];\ndouble y[512];\n\nvoid init() {\n  for(int i = 0; i < (int)512; ++i) {\n    x[i] = y[i] = 0.0;\n  }\n} \n\ninline double Heron(double a, double b, double c) {\n  double s = (a + b + c) / 2;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\nclass solve_ {\npublic:\n  int operator() (void) {\n    int res = 0;\n    for(int i = 0; i < (int)n; ++i) {\n      for(int j = 0; j < (int)i; ++j) {\n        res = std::max(res, CountPoints(i, j));\n      }\n    }\n    return res;\n  }\n  int CountPoints(int i, int j) {\n    double dx = x[i] - x[j];\n    double dy = y[i] - y[j];\n    double dist = sqrt(dx * dx + dy * dy);\n    auto t1 = std::pair<double, double>((x[i] + x[j]) / 2, (y[i] + y[j]) / 2);\n    auto t2 = std::pair<double, double>(dx / dist, dy / dist);\n    double h = 2 * Heron(1, 1, dist) / dist;\n    auto t3 = std::pair<double, double>(t2.first * h, t2.second * h);\n    auto c1 = std::pair<double, double>(t1.first + t3.second, t1.second - t3.first);\n    auto c2 = std::pair<double, double>(t1.first - t3.second, t1.second + t3.first);\n    int count1 = 0;\n    int count2 = 0;\n    {\n      double cx = c1.first, cy = c1.second;\n      for(int k = 0; k < (int)n; ++k) {\n        if( k == i or k == j ) continue;\n        if( (cx - x[k]) * (cx - x[k]) + (cy - y[k]) * (cy - y[k]) <= 1 ) {\n          count1 += 1;\n        }\n      }\n    }\n    {\n      double cx = c2.first, cy = c2.second;\n      for(int k = 0; k < (int)n; ++k) {\n        if( k == i or k == j ) continue;\n        if( (cx - x[k]) * (cx - x[k]) + (cy - y[k]) * (cy - y[k]) <= 1 ) {\n          count2 += 1;\n        }\n      }\n    }\n    int res = std::max(count1, count2) + 2;\n    //printf(\"(%d, %d) -> %d\\n\", i, j, res);\n    return res;\n  }\n};\nsolve_ solve;\n\nint main() {\n  for(;;) {\n    init();\n    scanf(\"%d\", &n);\n    if( n == 0 ) break;\n    for(int i = 0; i < (int)n; ++i) {\n      scanf(\"%lf %lf\", &x[i], &y[i]);\n    }\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n}\n\nclass Circle{\n\tpublic:\n\t\tPoint c;\n\t\tdouble r;\n\t\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n\treturn (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n\treturn ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n\treturn isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n\treturn isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n\treturn EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n\treturn isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n\treturn distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n\tif ( dot(b-a, c-a) < EPS ) return abs(c-a);\n\tif ( dot(a-b, c-b) < EPS ) return abs(c-b);\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n\treturn distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n\treturn ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t\t\tccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n\treturn isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n\tVector base = b2 - b1;\n\tdouble d1 = abs(cross(base, a1 - b1));\n\tdouble d2 = abs(cross(base, a2 - b1));\n\tdouble t = d1 / (d1 + d2);\n\n\treturn Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n\treturn intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n\treturn !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n\treturn isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n\tPoint a = a2 - a1; Point b = b2 - b1;\n\treturn a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n\treturn intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n\tif(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n\treturn min(\n\t\t\tmin(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n\t\t\t\tdistanceLsPoint(s1.p1, s1.p2, s2.p2)),\n\t\t\tmin(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n\t\t\t\tdistanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n\tSegment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n\treturn distanceLL(s1, s2);\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n\treturn Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n\tdouble x, y;\n\tx = p.real() * cos(angle) - p.imag() * sin(angle);\n\ty = p.real() * sin(angle) + p.imag() * cos(angle);\n\treturn Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n\tint n = g.size();\n\tbool x = false;\n\trep(i,n){\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n\t\tif( a.imag() > b.imag() ) swap(a, b);\n\t\tif( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n\t}\n\treturn ( x ? IN : OUT );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\n//??????\nPolygon convexHull( Polygon s ){\n\tPolygon u;\n\tif( s.size() < 3 ) return s;\n\tsort(s.begin(), s.end());\n\n\trange(i,0,s.size()){\n\t\t//== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n\t\t//!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n\t\tfor(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.emplace_back(s[i]);\n\t}\n\n\tfor(int i = s.size() - 2; i >= 0; i--){\n\t\t//????????? == ??¨ != ????????´??????\n\t\tfor(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.emplace_back(s[i]);\n\t}\n\n\treverse(u.begin(), u.end());\n\tu.pop_back();\n\n\t//?????????????????????????????§??????????????????????????????????¨??????????????????????\n\t/*\n\t   int i = 0;\n\t   while(i < u.size() - 1){\n\t   if(u[i].imag() > u[i + 1].imag()){\n\t   u.emplace_back(u[i]);\n\t   u.erase(u.begin());\n\t   continue;\n\t   }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n\t   u.emplace_back(u[i]);\n\t   u.erase(u.begin());\n\t   continue;\n\t   }\n\t   break;\n\t   }\n\t   */\n\n\treturn u;\n}\n\n//?????£?????????????????¨?????????????§???¢?????´???????±???????\ndouble diameterOfConvexPolygon(Polygon p){\n\tPolygon s = convexHull(p);\n\tint n = s.size();\n\n\tif(n == 2) return abs(s[1] - s[0]);\n\n\tint i = 0, j = 0;\n\trep(k,n){\n\t\tif(not (s[i] < s[k])) i = k;\n\t\tif(s[j] < s[k]) j = k;\n\t}\n\n\tdouble ret = 0.0;\n\tint is = i, js = j;\n\n\twhile(i != js || j != is){\n\t\tret = max(ret, abs(s[i] - s[j]));\n\t\tif(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n\t\t\ti = (i + 1) % n;\n\t\t}else{\n\t\t\tj = (j + 1) % n;\n\t\t}\n\t}\n\treturn ret;\n}\n\n//???????§???¢??????????????????????????¢??°??????????????????????????????????????\\????????????\nPoint getCrossPointLL(Line a, Line b){\n\tdouble A = cross(a.p2 - a.p1, b.p2 - b.p1);\n\tdouble B = cross(a.p2 - a.p1, a.p2 - b.p1);\n\tif(abs(A) < EPS && abs(B) < EPS) return b.p1;\n\treturn b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n\tPolygon q;\n\trep(i,p.size()){\n\t\tPoint a = p[i], b = p[(i + 1) % p.size()];\n\t\tif (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\tq.emplace_back(getCrossPointLL(Line{a, b}, l));\n\t\t}\n\t}\n\treturn q;\n}\n\n//????§???¢?????¢???\ndouble AreaOfTriangle(Point a, Point b, Point c){\n\tdouble w, x, y, z;\n\tw = b.real()-a.real();\n\tx = b.imag()-a.imag();\n\ty = c.real()-a.real();\n\tz = c.imag()-a.imag();\n\treturn abs((w * z - x * y) / 2);\n}\n\n//????§???¢?????¢???\ndouble areaOfPolygon(Polygon g){\n\tint n = g.size();\n\tdouble ret = 0.0;\n\trep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n\treturn abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n\tint n = g.size();\n\trep(i,n){\n\t\tif(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n\t}\n\treturn true;\n}\n\n//???????§???¢?????????l??§??????????????????????§???¢?????°\nint dividedPolygonNumber(Polygon p, Line l){\n\tint cnt = 0;\n\trep(i,p.size()){\n\t\tif(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n\t}\n\treturn cnt / 2 + 1;\n}\n\n//????§???¢??????????±???¨??????????????§?¨?\nPoint pointSymmetry(Polygon g){\n\tint size = g.size() / 2;\n\tif(g.size() % 2) return Point{INF,INF};\n\n\tset<Point> s;\n\trep(i,size){\n\t\trep(j,size){\n\t\t\tif(i == j) continue;\n\t\t\ts.insert(intersectionLs(g[i], g[i + size], g[j], g[j + size]));\n\t\t}\n\t}\n\tif(s.size() > 1) return Point{INF,INF};\n\treturn *s.begin();\n}\n\n\n\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tCircle c[305];\n\t\tPoint in[305];\n\t\trep(i,n){\n\t\t\tdouble a,b;\n\t\t\tcin >> a >> b;\n\t\t\tin[i] = Point{a,b};\n\t\t\tc[i] = Circle{Point(a,b), 1};\n\t\t}\n\n\t\tint ans = 1;\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tif(i == j) continue;\n\t\t\t\tif(abs(c[i].c - c[j].c) > 2) continue;\n\t\t\t\tpair<Point, Point> p =  getCrossPoints(c[i], c[j]);\n\t\t\t\tint cnt = 0, cnt_ = 0;\n\t\t\t\trep(k,n){ if(abs(p.first - in[k]) <= 1) cnt++; }\n\t\t\t\trep(k,n){ if(abs(p.second - in[k]) <= 1) cnt_++; }\n\t\t\t\tans = max(ans, max(cnt, cnt_));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double r = 1.0;\nconst double PI = acos(-1.0);\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y) : x(x), y(y) {}\n};\ninline double Distance2(const Point &a, const Point &b) {\n    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    std::random_device rnd;\n    std::mt19937 mt(rnd());\n    std::uniform_real_distribution<> rand100(0.0, 10.0);\n\n    while (cin >> n, n) {\n        // Input\n        vector<Point> p(n);\n        for (int i = 0; i < n; ++i)\n            cin >> p[i].x >> p[i].y;\n\n        // Solve\n        int ans = 1;\n        auto start = std::chrono::high_resolution_clock::now();\n        auto end = std::chrono::high_resolution_clock::now();\n        auto take_time = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n\n        while (true) {\n            end = std::chrono::high_resolution_clock::now();\n            take_time = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n            if (1000 < take_time.count())\n                break;\n\n            for (int i = 0; i < 10; ++i) {\n                Point c(rand100(mt), rand100(mt));\n                int num = 0;\n                for (int j = 0; j < n; ++j) {\n                    double d = Distance2(p[j], c);\n                    if (d <= 1.0)\n                        ++num;\n                }\n                ans = max(ans, num);\n            }\n        }\n\n        // Output\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\ntypedef long double ld;\n\nstruct Point {\n    ld x, y;\n    Point(ld x=0.0, ld y=0.0) : x(x), y(y) {}\n    string to_s() {\n        ostringstream os;\n        os << x << ',' << y;\n        return os.str();\n    }\n    Point operator+(const Point& o) const {\n        return Point(x+o.x, y+o.y);\n    }\n};\n\nstruct Circle {\n    ld x, y;\n    ld r;\n    Circle(ld x=0.0, ld y=0.0, ld r=1.0) : x(x), y(y), r(r) {}\n    const static ld eps = 1e-8;\n    bool isIntersect(const Circle& o) const {\n        ld dx = o.x - x;\n        ld dy = o.y - y;\n        return (r + o.r) * (r + o.r) > (dx*dx + dy*dy);\n    }\n    pair<Point, Point> intersectionPoint(const Circle& o) const {\n        ld dx = x - o.x;\n        ld dy = y - o.y;\n        ld a = (dx*dx + dy*dy + r*r - o.r*o.r) / 2.0;\n        ld d = sqrt((dx*dx+dy*dy)*r*r-a*a);\n        Point p, q;\n        p.x = (a*dx + dy * d) / (dx*dx+dy*dy) + o.x;\n        q.x = (a*dx - dy * d) / (dx*dx+dy*dy) + o.x;\n        p.y = (a*dy - dx * d) / (dx*dx+dy*dy) + o.y;\n        q.y = (a*dy + dx * d) / (dx*dx+dy*dy) + o.y;\n        //cout << p.x << ',' << p.y << endl;\n        //cout << q.x << ',' << q.y << endl;\n        return make_pair(p, q);\n    }\n    bool contains(ld px, ld py) const {\n        return r*r + eps >= (px - x) * (px - x) + (py - y) * (py - y);\n    }\n    string to_s() {\n        ostringstream os;\n        os << x << ',' << y << ':' << r << endl;\n        return os.str();\n    }\n};\n\nint countContainingPoints(const Circle& c, const vector<Circle>& ps) {\n    int cnt = 0;\n    for (int i = 0; i < ps.size(); i++) \n        if (c.contains(ps[i].x, ps[i].y)) \n            cnt++;\n    return cnt;\n}\n\nint N;\nint main() {\n    //cout << Circle(0, 0, 5).intersectionPoint(Circle(8, 0, 5)).first.to_s() << endl;\n    vector<Circle> cs;\n    while (cin >> N, N) {\n        cs.clear(); cs.resize(N);\n        for (int i = 0; i < N; i++) cin >> cs[i].x >> cs[i].y;\n\n        vector<Point> ips; // Intersection PointS\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (i == j) continue;\n                if (!cs[i].isIntersect(cs[j])) continue;\n                pair<Point, Point> ip = cs[i].intersectionPoint(cs[j]);\n                ips.push_back(ip.first);\n                ips.push_back(ip.second);\n            }\n        }\n\n        int maxPoint = 0;\n        for (int i = 0; i < ips.size(); i++) {\n            maxPoint = max(maxPoint, countContainingPoints(Circle(ips[i].x, ips[i].y, 1.0), cs));\n        }\n        cout << maxPoint << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define PI (3.141592653589793238462643383279)\ntemplate<class T>\nstruct point{\n\tT x, y;\n\tpoint &operator+=(const point &a ){ x += a.x; y += a.y; }\n\tpoint &operator-=(const point &a ){ x -= a.x; y -= a.y; }\n\tpoint operator+(const point &a )const{ return (point){x+a.x, y+a.y }; }\n\tpoint operator-(const point &a )const{ return (point){x-a.x, y-a.y }; }\n\toperator point<double>()const{ return (point<double>){x, y }; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c, const point<T> &a ){ return (point<T>){c*a.x, c*a.y }; }\npoint<double> &operator/=(point<double> &a, double c ){ a.x /= c; a.y /= c; return a; }\ntemplate<class T>\npoint<double> operator/(const point<T> &a, double c ){ return (point<double>){ a.x/c, a.y/c }; }\n\n// for integar number\ntemplate<class T>\nbool operator<(const point<T> &a, const point<T> &b ){\n\treturn (a.x < b.x || ((a.x == b.x ) && (a.y < b.y ) ) );\n}\n\ntemplate<class T>\nbool operator==(const point<T> &a, const point<T> &b ){\n\treturn a.x == b.x && a.y == b.y;\n} \n\ntemplate<class T>\nbool operator!=(const point<T> &a, const point<T> &b ){\n\treturn a.x != b.x || a.y != b.y;\n}\n\n//  for real number\nbool operator<(const point<double> &a, const point<double> &b ){\n\treturn (a.x + EPS < b.x || (abs (a.x - b.x ) < EPS && (a.y + EPS < b.y ) ) );\n}\n\nbool operator==(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x) < EPS && abs (a.y - b.y ) < EPS;\n}\n\nbool operator!=(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x ) > EPS || abs (a.y - b.y ) > EPS;\n}\n\n// inner product\ntemplate<class T>\nT dot(const point<T> &a, const point<T> &b ){ return a.x*b.x + a.y*b.y; }\n\n// outer product\ntemplate<class T>\nT cross(const point<T> &a, const point<T> &b ){ return a.x*b.y - a.y*b.x; }\n\n// distance between origin(0,0) to point a\ntemplate<class T>\ndouble abs(const point<T> &a ){ return sqrt (a.x*a.x + a.y*a.y ); }\n\ntemplate<class T>\nT abs2(const point<T> &a ){ return a.x*a.x + a.y*a.y; }\n\npoint<double> rot(const point<double> &a, double theta ){\n\treturn (point<double>){a.x*cos(theta) - a.y*sin(theta), a.x*sin(theta) + a.y*cos(theta ) };\n}\n\n// x 軸の正方向を基準とした場合のベクトル a の角度を [0, 2*PI) の範囲で求める\ntemplate<class T> double arg(const point<T> &a ){\n\tdouble t = atan2(a.y, a.x );\n\treturn t<0.? t+2.*PI : t;\n}\n\ntemplate<class T>\nstruct line{\n\tpoint<T> a, b;\n\toperator line<double>()const{ return (line<double>){a, b}; }\n};\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a, b;\n\toperator line<T>()const { return (line<T>){a,b}; }\n};\n\ntemplate<class T>\nstruct polygon:vector< point<T> >{\n\tpolygon(){}\n\tpolygon(int n ):vector< point<T> >(n){}\n};\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n};\n\n// 点 p を直線 L 上に射影した点を求める\n// \tVerified: AOJ 0081 A Symmetric Point\ntemplate<class T>\npoint<double> proj(const point<T> &p, const line<T> &L ){\n\treturn L.a + dot (p-L.a, L.b-L.a )/abs2 (L.b - L.a )*(L.b - L.a );\n}\n\n/*\n\t三角形の面積（外積）\n\n\t説明\n\t\t三頂点で定まる三角形の面積（の２倍）を求める\n\t引数\n\t\ta : 頂点\n\t\tb : 頂点\n\t\tc : 頂点\n\t戻り値\n\t\t三角形の面積の２倍\n\t\t縮退しているときは 0\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t２倍を返しているのは、座標値が整数のときにはこの値も整数になるから。\n*/\ntemplate<class T>\nT area2(const point<T> &a, const point<T> &b, const point<T> &c ){\n\treturn abs(cross(b-a,c-a));\n}\n/*\n\t三角形の面積（Heron）\n\n\t説明\n\t\t三辺の長さで定まる三角形の面積を求める\n\t引数\n\t\ta : 一辺の長さ\n\t\tb : 一辺の長さ\n\t\tc : 一辺の長さ\n\t戻り値\n\t\t三角形の面積\n\t\t三角形が作れないとき、縮退しているときには 0\n\t制約\n\t\ta>=0, b>=0, c>=0\n\t\ta<b+c, b<c+a, c<a+b（三角形の成立条件）\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n*/\ndouble area(double a, double b, double c ){\n\treturn sqrt((a+b-c)*(b+c-a)*(c+a-b)*(a+b-c))/4.;\n}\n\n/*\n\t多角形の面積\n\n\t説明\n\t\t多角形の面積（２倍）を求める\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\t三角形の面積の２倍\n\t\t縮退しているときは 0\n\t制約\n\t\tG は単純\n\t計算量\n\t\tO(n)\n\t備考\n\t\t２倍を返しているのは、座標値が整数のときにはこの値も整数になるから。\n\t\t多角形は CCW でも CW でもよい\n\n\t\tVerified: AOJ 0079: Area of Polygon\n*/\ntemplate<class T>\nT area2(const polygon<T> &G ){\n\tint n = G.size();\n\tT a = 0;\n\trep (i, n ) a+=cross(G[i], G[(i+1)%n] );\n\treturn abs (a );\n}\n\n/*\n\t回転方向\n\n\t説明\n\t\t３点の位置関係を求める\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t\tc : 点\n\t戻り値\n\t\ta-b-c の順に反時計回りに回転しているとき CCW\n\t\ta-b-c の順に時計回りに回転しているとき CW\n\t\ta-b-c が同一直線上にあるとき ON\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t2 点以上が同一の点であれば常に ON を返すことに注意\n\n*/\n\n// (A)\nenum{CCW = 1, CW = -1, ON = 0 };\ntemplate<class T>\nint ccw(const point<T> &a, const point<T> &b, const point<T> &c ){\n\tT rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n\n// (B)\n\n//enum{CCW = 1, CW = -1, ON = 0 };\nint ccw (const point<double> &a, const point<double> &b, const point<double> &c ){\n\tdouble rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n\n/*\n\t反時計回りに変換\n\n\t説明\n\t\t多角形の頂点の順番が CW であれば CCW に変換する\n\t\t元々 CCW であれば何もしない\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\tなし（引数 G が更新される）\n\t制約\n\t\tG は単純\n\t計算量\n\t\tO(n)\n\t備考\n\t\t単純多角形とは自己交差しない多角形のこと\n\t\tVerified: AOJ 0035: Is it Convex?\n*/\n// (A)\ntemplate<class T>\nvoid to_ccw(polygon<T> &G ){\n\tint n = G.size();\n\tT A = 0;\n\trep (i, n ) A+=cross(G[i], G[(i+1)%n] );\n\tif (A < 0 ) reverse (ALL (G ) );\n}\n\n// (B)\nvoid to_ccw(polygon<double> &G ){\n\tint n = G.size();\n\tdouble A = 0.;\n\trep (i, n ) A+=cross(G[i], G[(i+1)%n] );\n\tif (A<-EPS ) reverse (ALL (G ) );\n}\n\n/*\n\t点と点の距離\n\n\t説明\n\t\t点と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\t点 a と 点 b の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n*/\ntemplate<class T>\ndouble dist(const point<T> &a, const point<T> &b ){\n\treturn sqrt ((a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y ) );\n}\n\ntemplate<class T>\nT dist2(const point<T> &a, const point<T> &b ){\n\treturn (a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y );\n}\n\n/*\n\t直線と点の距離\n\n\t説明\n\t\t直線と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\tL : 直線\n\t\tp : 点\n\t戻り値\n\t\t直線 L と点 p の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\n*/\ntemplate<class T>\ndouble dist(const line<T> &L, const point<T> &p ){\n\treturn abs (cross (L.b-L.a, p-L.a))/dist(L.a, L.b );\n}\n\n/*\n\t線分と点の距離\n\n\t説明\n\t\t線分と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の２乗\n\t引数\n\t\tS : 線分\n\t\tp : 点\n\t戻り値\n\t\t線分 S と点 p の距離\n\t計算量\n\t\tO(1)\n\t備考\n\t\tdist2 は <= 0 で正しい。(ESP を使わなくてよい. )\n\t\n*/\ntemplate<class T>\ndouble dist(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist (p, S.b );\n\treturn abs (cross (S.b-S.a, p - S.a ) )/dist (S.a, S.b );\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist2 (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist2 (p, S.b );\n\treturn (double)cross (S.b-S.a, p - S.a )*cross (S.b-S.a, p - S.a )/dist (S.a, S.b );\n}\n\n/*\n\t線分と線分の距離\n*/\n\n/*\n\t三角形と点の包含判定\n\n\t説明\n\t\t三角形 abc が点 p を含むかどうかを判定する\n\t引数\n\t\ta : 頂点\n\t\tb : 頂点\n\t\tc : 頂点\n\t戻り値\n\t\t含むなら true, 含まないなら false\n\t制約\n\t\t三角形は縮退していないこと\n\t\tすなわち、三点が同一直線上にないこと、（特に、どの二点も等しくないこと\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形は CCW でも CW でもよい\n\t\t点が三角形の境界になるときは含むと判定する\n\t\tVerified: AOJ 0012: A Point in a Triangle\n\t\tVerified: AOJ 0143: Altair and Vega \n*/\ntemplate<class T>\nbool cover(const point<T> &a, const point<T> &b, const point<T> &c, const point<T> &p ){\n\tint d1 = ccw (p, a, b );\n\tint d2 = ccw (p, b, c );\n\tint d3 = ccw (p, c, a );\n\treturn !((d1 == CCW && d2 == CW ) || (d1 == CCW && d3 == CW ) || (d2 == CCW && d3 == CW ) || (d1 == CW && d2 == CCW ) || (d1 == CW && d3 == CCW ) || (d2 == CW && d3 == CCW ) );\n}\n\n/*\n\t直線と点の包含判定\n*/\n\n/*\n\t線分と点の包含判定\n*/\n\n/*\n\t多角形と点の包含判定\n*/\n\n/*\n\t多角形と多角形の包含判定\n*/\n\n/*\n\t円と点の包含判定\n\n\t説明\n\t\t円が点を含むかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tC : 円\n\t\tp : 点\n\t戻り値\n\t\t含むなら true, 含まないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n*/\n// (A)\ntemplate<class T>\nbool cover (const circle<T> &C, const point<T> &p ){\n\treturn dist2(C.c, p) <= C.r*C.r;\n}\n\n// (B)\nbool cover (const circle<double> &C, const point<double> &p ){\n\treturn dist (C.c, p ) < C.r + EPS;\n}\n\n/*\n\t直線と直線の交差判定\n*/\n\n/*\n\t直線と線分の交差判定\n*/\n\n/*\n\t線分と線分の交差判定\n\n\t説明\n\t\t線分と線分が交わるかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tS1 : 線分\n\t\tS2 : 線分\n\t戻り値\n\t\t交わるなら true, 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\tbounding box によるラフチェックは必要。（ ccw による判定だと、二線分が同一直線上にあるとき間違う。)\n\n*/\n// (A)\ntemplate<class T>\nbool intersect(const segment<T> &S1, const segment<T> &S2 ){\n\tif (max (S1.a.x, S1.b.x ) < min (S2.a.x, S2.b.x )\n\t|| max (S1.a.y, S1.b.y ) < min (S2.a.y, S2.b.y )\n\t|| max (S2.a.x, S2.b.x ) < min (S1.a.x, S1.b.x )\n\t|| max (S2.a.y, S2.b.y ) < min (S1.a.y, S1.b.y ) ) return false;\n\treturn ccw (S1.a, S1.b, S2.a )*ccw (S1.a, S1.b, S2.b ) <= 0\n\t\t&& ccw (S2.a, S2.b, S1.a )*ccw (S2.a, S2.b, S1.b ) <= 0;\n}\n\n/*\n\t多角形と線分の交差判定\n\n\t説明\n\t\t多角形と線分が交わるかどうかを判定する\n\t引数\n\t\tG : 多角形\n\t\tS : 線分\n\t戻り値\n\t\t交わるなら true, 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(n)\n\t備考\n\t\tG は凸でなくていい。\n\t\tG は境界を含む\n\t\tS が G の内部にあるときは交わると判定する\n*/\ntemplate<class T>\nbool intersect(const polygon<T> &G, const segment<T> &S ){\n\tint n = G.size();\n\tif (cover(G, S.a ) || cover (G, S.b ) ) return true;\n\trep (i, n ) if (intersect((segment<T>){G[i], G[(i+1)%n]}, S ) ) return true;\n\treturn false;\n}\n\n/*\n\t多角形と多角形の交差判定\n*/\n\n/*\n\t円と直線の交差判定\n\n\t説明\n\t\t円と直線が交わるかどうかを判定する\n\t引数\t\n\t\tC: 円\n\t\tL: 直線\n\t戻り値\n\t\t交点の個数\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t\n*/\nint intersect(const circle<double> &C, const line<double> &L ){\n\tpoint<double> m=proj(C.c, L );\n\tdouble d = abs (C.c - m );\n\tif (C.r + EPS < d ) return 0;\n\tif (C.r - EPS < d ) return 1;\n\treturn 2;\n}\n\n/*\n\t円と線分の交差判定\n\n\t説明\n\t\t円と線分が交わるかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tC : 円\n\t\tS : 線分\n\t戻り値\n\t\t交わるなら true 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t線分が円の内部になるときは交わると判定する。\n*/\n// (A)\ntemplate<class T>\nbool intersect(const circle<T> &C, const segment<T> &S ){\n\treturn dist2(S, C.c ) <= C.r*C.r;\n}\n// (B)\nbool intersect(const circle<double> &C, const segment<double> &S ){\n\treturn dist(S, C.c ) < C.r + EPS;\n}\n\n/*\n\t二直線の交点\n\n\t説明\n\t\t二直線の交点を求める\n\t\t(A)（直線を特徴付ける点の）座標値が整数\n\t\t(B)（直線を特徴付ける点の）座標値が実数\n\t引数\n\t\tL1 : 直線\n\t\tL2 : 直線\n\t戻り値\n\t\tL1 と L2 の交点\n\t制約\n\t\t二直線は交点を持つこと。（平行でない or L1 == L2 )\n\t計算量\n\t\tO(1)\n\t備考\n\t\t交点が複数あるとき（L1 == L2）は L1.a を返す。\n\t\tこの仕様は線分 S と直線 L の交点を求めたいとき重要。\n\t\t（ S と L が同一直線上にあるときにも、S を第１引数に指定することで交点が正しく求まる。）\n\n*/\n// (A)\ntemplate<class T>\npoint<double> get_intersect(const line<T> &L1, const line<T> &L2 ){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif (a1==0) return L1.a;\t// L1 == L2\n\treturn (point<double>)L2.a+a2/a1*(point<double>)(L2.b-L2.a);\n}\n// (B)\npoint<double> get_intersect(const line<double> &L1, const line<double> &L2 ){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif (a1<EPS) return L1.a;\t// L1 == L2\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\n/*\n\t二線分の交点\n*/\n\n/*\n\t円と直線の交点\n*/\n\n/*\n\t円と円の交点\n\n\t説明\n\t\t円と円の交点を求める\n\t引数\n\t\tC1 : 円\n\t\tC2 : 円\n\t\tres : 計算結果（交点の集合）\n\t戻り値\n\t\t交点の個数\n\t\tただし、交点が無限個になる（２つの円が等しい）ときは -1\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\tres は初期化されない\n\t\t交点が無限個あるときは res には何も追加されない\n\t\tVerified: AOJ 0090 Overlaps of Seals\n*/\nint get_intersect(const circle<double> &C1, const circle<double> &C2, vector< point<double> > &res ){\n\tdouble r1=C1.r,r2=C2.r;\n\tpoint<double> p1=C1.c,p2=C2.c;\n\n\tdouble d=abs(p1-p2);\n\tif (d<EPS && abs(r1-r2)<EPS ){\t// C1 == C2\n\t\treturn -1;\n\t}else\n\tif (r1+r2<d-EPS || d+EPS<abs(r1-r2) ){\n\t\treturn 0;\n\t}else{\n\t\tdouble a = (r1*r1-r2*r2+d*d)/(2.*d);\n\t\tdouble h = sqrt(max(r1*r1-a*a, 0. ) );\n\t\tpoint<double> tmp1 = p1+a/d*(p2-p1);\n\t\tpoint<double> tmp2 = h/d*(p2-p1);\n\t\tif (abs(tmp2)<EPS ){\n\t\t\tres.push_back (tmp1 );\n\t\t\treturn 1;\n\t\t}else{\n\t\t\tres.push_back ((point<double>){tmp1.x-tmp2.y, tmp1.y+tmp2.x});\n\t\t\tres.push_back ((point<double>){tmp1.x+tmp2.y, tmp1.y-tmp2.x});\n\t\t\treturn 2;\n\t\t} // end if\n\t} // end if\n}\n\n/*\n\t点から円に引いた接線の交点\n*/\n\n/*\n\t円と円の共通接線\n*/\n\n/*\n\t垂直二等分線\n\n\t説明\n\t\t二点 a, b の垂直二等分線を求める\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\ta と b の垂直二等分線\n\t計算量\n\t\tO(1)\n\t備考\n\t\t垂直二等分線を L とすると、L.a から L.b の方向を見たとき、左手に点 a が来る。\n*/\ntemplate<class T>\nline<double> perp_bisector(const point<T> &a, const point<T> &b ){\n\treturn (line<double>){(point<double>){(a.x-a.y+b.x+b.y)/2.0, (a.y+a.x+b.y-b.x)/2.0 },\n\t\t\t\t\t\t\t(point<double>){(a.x+a.y+b.x-b.y)/2.0, (a.y-a.x+b.y+b.x)/2.0 }};\n}\n\n/*\n\t点対称\n\n\t説明\n\t\t点 b を基準に点 a を点対称を求める\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\t点対称の点\n\t計算量\n\t\tO(1)\n\t備考\n\n*/\ntemplate<class T>\npoint<T> symmetry_point (const point<T> a, const point<T> b )\n{\n\treturn (point<T>){2*b.x-a.x, 2*b.y-a.y};\n}\n\n/*\n\t多角形の重心の座標\n\n\t説明\n\t\t頂点数 n の凸多角形をひとつの頂点を基準に n - 2 個の三角形に分割した三角形の面積を Sk,\n\t\t重心を gk とおくと n の凸多角形の重心 G は\n\n\t\tG = \\sum_{k=1}^{n-2}Sk*gk/(\\sum_{k=1}^{n-2}Sk)\n\n\t\tで求められる。\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\t点\n\t計算量\n\t\tO(n)\n\t備考\n\t\tVerified: AOJ 2442: ConvexCut しかし EPS=1e-6 にしないと WA.\n*/\ntemplate<class T>\npoint<T> centerG(const polygon<T> &G ){\n\tint n = G.size();\n\tdouble S = 0.;\n\tpoint<double> g; g.x = 0.; g.y = 0.;\n\tint u = G.size()-1;\n\tfor (int i = 0; i < n; u=i++ ){\n\t\tdouble sk = cross (G[u], G[i] );\n\t\tS += sk;\n\t\tg.x += (G[u].x + G[i].x)*sk;\n\t\tg.y += (G[u].y + G[i].y)*sk;\n\t} // end for\n\tg /= (3.*S);\n\n\treturn g;\n/*\n\tint n = G.size();\n\tdouble ar = 0.;\n\tdouble x = 0., y = 0.;\n\trep (i, n - 2 ){\n\t\tdouble k = area2 (G[n-1], G[i], G[i+1] );\n\t\tar += k;\n\t\tx += (G[n-1].x + G[i].x)*k;\n\t\ty += (G[n-1].y + G[i].y)*k;\n\t} // end rep\n\tx /= (3.*ar );\n\ty /= (3.*ar );\n\t\n\treturn (point<T>){x,y};\n*/\n}\n\n/*\n\t二点と半径で定まる円\n*/\n\n/*\n\t凸性判定\n\t\n\t説明\n\t\t多角形が凸かどうかを判定する\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\tG は単調かつ頂点の順番が CCW で与えられていること\n\t計算量\n\t\tO(n)\n\t備考\n\t\tVerified: AOJ 0035: Is it Convex?\n*/\ntemplate<class T>\nbool is_convex(const polygon<T> &G ){\n\tint n = G.size();\n\trep (i, n ) if (ccw (G[i], G[(i+1)%n], G[(i+2)%n])== CW ) return false;\n\treturn true;\n}\n\n/*\n\t凸包\n\n\t説明\n\t\t点集合の凸包を求める\n\t引数\n\t\tP : 点集合\n\t戻り値\n\t\tP の凸包\n\t制約\n\t\tなし\n\t計算量\n\t\tO(n log n )\n\t備考\n\t\tP は破壊される。\n\n\t\tsort は (x, y ) の辞書順。\n\n\t\t凸包の同じ直線上にある頂点は端のものだけを拾う。\n\t\t辺上になる頂点を全部拾うようにしたいときは != CCW を ==CW と修正すればよい。\n*/\ntemplate<class T>\npolygon<T> convex_hull(vector< point<T> > &P ){\n\tint n = P.size();\n\tpolygon<T> CH;\n\tif (n <= 1 ){\n\t\tCH.insert (CH.end(), P.begin(), P.end() );\n\t\treturn CH;\n\t} // end if\n\tsort (ALL (P ) );\n\trep (cnt, 2 ){\n\t\tint m = 0;\n\t\tvector< point<T> > half(n );\n\t\trep (i, n ){\n\t\t\thalf[m++] = P[i];\n\t\t\twhile (m >= 3 && ccw (half[m-3], half[m-2], half[m-1] ) != CCW ){\n\t\t\t\thalf[m-2] = half[m-1];\n\t\t\t\tm--;\n\t\t\t} // end while\n\t\t} // end rep\n\t\tCH.insert (CH.end(), half.begin(), half.begin()+m-1 );\n\t\treverse (ALL (P ) );\n\t} // end rep\n\t\n\treturn CH;\n}\n\n/*\n\t凸多角形の切断\n*/\n\n/*\n\t内接円の半径\n\n\t説明\n\t\t辺長がそれぞれ、a, b, c である三角形の内接円の半径を求める\n\t引数\n\t\ta: 辺長\n\t\tb: 辺長\n\t\tc: 辺長\n\t戻り値\n\t\t内接円の半径\n\t制約\n\t\ta >= 0, b >= 0, c >= 0\n\t\ta < b + c, c < c + a, c < a + b (三角形の成立条件)\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n*/\ndouble inradius(double a, double b, double c ){\n\treturn sqrt ((b+c-a)*(c+a-b)*(a+b-c)/(a+b+c))/2.;\n}\n\n/*\n\t外接円\n\n\t説明\n\t\t三角形 abc の外接円を求める\n\t引数\n\t\ta: 頂点\n\t\tb: 頂点\n\t\tc: 頂点\n\t戻り値\n\t\t外接円\n\t制約\n\t\ta, b, c は同一直線上にないこと\n\t計算量\n\t\tO(1)\n\t備考\n\t\ta, b, c が同一直線上にあるときは外接円は存在しない\n\t\t頂点が整数座標のとき、外心の座標と半径の二乗は有理数となる\n\n\t\tVerified: AOJ 0010 Circumscribed Circle of a Triangle\n\n*/\ncircle<double> circumcircle(const point<double> &a, point<double> b, point<double> c ){\n\tb-=a; c-=a;\n\tdouble A2 = abs2(b-c), B2 = abs2(b), C2 = abs2(c);\n\tdouble d = 2*cross(b,c);\n\tdouble nx = c.y*B2-b.y*C2;\n\tdouble ny = b.x*C2-c.x*B2;\n\tdouble r2 = A2*B2*C2/(d*d);\n\treturn (circle<double>){a+(point<double>){nx/d, ny/d}, sqrt(r2)};\n}\n\n/*\n\t外接円の半径\n\t\n\t説明\n\t\t辺長がそれぞれ a, b, c である三角形の外接円の半径を求める\n\t引数\n\t\ta : 辺長\n\t\tb : 辺長\n\t\tc : 辺長\n\t戻り値\n\t\t外接円の半径\n\t制約\n\t\ta >= 0, b >= 0, c >= 0\n\t\ta < b + c, b < c + a, c < a + b (三角形の成立条件)\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n\n\t\tVerified: AOJ 0010 Circumscribed Circle of a Triangle\n\n*/\ndouble circumradius(double a, double b, double c ){\n\treturn a*b*c/sqrt((a+b+c)*(b+c-a)*(c+a-b)*(a+b-c) );\n}\n\n/*\n\t最小包含球\n*/\n\n/*\n\t線分アレンジメント\n*/\n\n/*\n\t最近点対\n\n\t説明\n\t\t最近点対問題を解く\n\t引数\n\t\tn : 点の個数\n\t\tp : 点集合\n\t戻り値\n\t\t最近点対の距離\n\t制約\n\t\tn>=2\n\t計算量\n\t\tO(n log n)\n\t備考\n\t\tsort は (x,y) の辞書順。\n\t\tP の順番は破壊される（内部でソートするため）\n*/\nstruct cmp_y{\nbool operator()(const point<double> &a, const point<double> &b ){\n\treturn (a.y+EPS<b.y || (abs(a.y-b.y)<EPS && a.x+EPS<b.x ) );\n}};\n\ndouble closest_pair(int n, point<double> *P){\n\tsort (P, P+n );\n\tdouble d = dist(P[0],P[1] );\n\tset<point<double>, cmp_y> S;\n\tset<point<double>, cmp_y>::iterator it_l, it_r, it;\n\tfor (int i = 0, j = 0; i < n; i++ ){\n\t\tit_l = S.lower_bound ((point<double>){0,P[i].y-d-1.});\n\t\tit_r = S.upper_bound ((point<double>){0,P[i].y+d+1.});\n\t\tfor (it=it_l;it!=it_r;++it) d=min(d, dist(*it,P[i]));\n\t\twhile(P[i].x-P[j].x>d+EPS ) S.erase(P[j++] );\n\t\tS.insert(P[i] );\n\t} // end for\n\n\treturn d;\n}\n\n/*\n\t楕円の周長\n*/\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.1132\", \"r\", stdin );\n\tint n;\n\twhile (scanf (\"%d\", &n ), n ){\n\t\tvector< circle<double> > c(n );\n\t\trep (i, n ) scanf (\"%lf %lf\", &c[i].c.x, &c[i].c.y ), c[i].r = 1.;\n\t\tvector< point<double> > cand; cand.clear();\n\t\trep (i, n ){\n\t\t\tfor (int j = i+1; j < n; j++ ){\n\t\t\t\tvector< point<double> > dummy; dummy.clear();\n\t\t\t\tint ans = get_intersect (c[i], c[j], dummy );\n\t\t\t\tif (ans == 1 || ans == 2 ){\n\t\t\t\t\trep (j, dummy.size() ) cand.push_back (dummy[j] );\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t} // end rep\n\t\tcand.erase (unique (ALL (cand ) ), cand.end() );\n\t\tint m = cand.size();\n\t\tint res = 1;\n\t\trep (j, m ){\n\t\t\tint curr = 0;\n\t\t\trep (i, n ) if (cover (c[i], cand[j] ) ) curr++;\n\t\t\tres = max (res, curr );\n\t\t} // end rep\n\t\tprintf (\"%d\\n\", res );\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#define EPS 1e-9\nusing namespace std;\ntypedef complex<double> xy_t;\nint n;\nxy_t points[301];\nint count_in(xy_t center)\n{\n  int ans=0;\n  for(int i=0;i<n;i++)\n  {\n    if (abs(center-points[i])<1.0+EPS)\n      ans++;\n  }\n  return ans;\n}\nxy_t ppdcl(xy_t a)\n{\n  //return xy_t(a.imag(),-a.real());\n  return a*xy_t(0,1);\n}\nxy_t delta_v(xy_t C1,xy_t C2)\n{\n  xy_t half=(C1-C2)*0.5;\n  double l=abs(half);\n  return ppdcl(half)*sqrt(1-l*l)*(1.0/l);\n}\nint main()\n{\n  while(1)\n  {\n    cin>>n;\n    if (n==0) break;\n    double x,y;\n    for(int i=0;i<n;i++)\n    {\n      cin>>x>>y;\n      points[i]=xy_t(x,y);\n    }\n    int maxn=-1;\n    for(int i=0;i<n;i++)\n    {\n      for(int j=i+1;j<n;j++)\n      {\n        if(abs(points[i]-points[j])<2.0)\n        {\n          xy_t mid_p=(points[i]+points[j])*0.5;\n          maxn=max(maxn,count_in(mid_p+delta_v(points[i],points[j])));\n          maxn=max(maxn,count_in(mid_p-delta_v(points[i],points[j])));\n        }\n      }\n    }\n    cout<<maxn<<endl;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS (1e-6)\n\n\nvoid calc(double x1,double y1,double x2,double y2,double *c_x1,double *c_y1,double *c_x2,double *c_y2){\n  double midx,midy,hox,hoy,dx,dy,dis;\n  midx = (x1+x2) / 2.0 , midy = (y1+y2) / 2.0;\n  dx = x1-x2 , dy = y1-y2;\n  dis = sqrt(1 - pow(x1-midx,2.0) - pow(y1-midy,2.0));\n  hox = sqrt(pow(dy,2.0) / (pow(dy,2.0) + pow(dx,2.0)));\n  hoy = hox * (-1.0) * (dx / dy);\n  *c_x1 = midx + hox*dis,*c_y1 = midy + hoy*dis;\n  *c_x2 = midx - hox*dis,*c_y2 = midy - hoy*dis;\n}\n\nint main(){\n  int N;\n\n  while(cin >> N){\n    double x[300],y[300],c_x1,c_y1,c_x2,c_y2;\n    int count,m;\n    m = 1;\n    if(!(N)) break;\n    for(int i=0;i<N;i++) cin >> x[i] >> y[i];\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n        if(i == j) continue;\n        if(sqrt((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j])) > 2.0 + EPS  ) continue;\n        count = 2;\n        calc(x[i],y[i],x[j],y[j],&c_x1,&c_y1,&c_x2,&c_y2);\n        for(int k=0;k<N;k++){\n          if(k == i || k == j) continue;\n          if((x[k] - c_x1)*(x[k] - c_x1) + (y[k] - c_y1)*(y[k] - c_y1) < 1.0 + EPS  ) count++;\n        }\n        if(m < count) m = count;\n        count = 2;\n        for(int k=0;k<N;k++){\n          if(k == i || k == j) continue;\n          if((x[k] - c_x2)*(x[k] - c_x2) + (y[k] - c_y2)*(y[k] - c_y2) < 1.0 + EPS) count++;\n        }\n        if(m < count) m = count;\n      }\n    }\n\n    printf(\"%d\\n\",m);\n  }\n\n  return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <string>\nusing namespace std;\n\nvector<double> getAreaPointx(int x,int y,vector<double> lx,vector<double> ly)\n{\n\tvector<double> result;\n\tvector<double>::iterator itx=lx.begin();\n\tvector<double>::iterator ity=ly.begin();\n\twhile (itx != lx.end())\n\t{\n\t\tif ((*itx <= x+1) && (*itx >= x-2) && (*ity <= y+1) && (*ity >= y-2)){\n\t\t\tresult.push_back(*itx);\n\t\t}\n\t\titx++;\n\t\tity++;\n\t}\n\treturn result;\n}\n\nvector<double> getAreaPointy(int x,int y,vector<double> lx,vector<double> ly)\n{\n\tvector<double> result;\n\tvector<double>::iterator itx=lx.begin();\n\tvector<double>::iterator ity=ly.begin();\n\twhile (itx != lx.end())\n\t{\n\t\tif ((*itx <= x+1) && (*itx >= x-2) && (*ity <= y+1) && (*ity >= y-2)){\n\t\t\tresult.push_back(*ity);\n\t\t}\n\t\titx++;\n\t\tity++;\n\t}\n\treturn result;\n}\n\n\ndouble distance(double x1,double y1,double x2,double y2)\n{\n\treturn sqrt(pow((x1-x2),2)+pow((y1-y2),2));\n}\n\nint countInside(double x,double y,vector<double> lx,vector<double> ly)\n{\n\tint c=0;\n\tvector<double>::iterator itx=lx.begin();\n\tvector<double>::iterator ity=ly.begin();\n\twhile (itx != lx.end())\n\t{\n\t\tif (distance(x,y,*itx,*ity) <= 1)\n\t\t{\n\t\t\tc++;\n\t\t}\n\t\titx++;\n\t\tity++;\n\t}\n\treturn c;\n}\n\nint main(void) {\n\tvector<int> r;\n\twhile (true)\n\t{\n\t\tint n=0;\n\t\tscanf(\"%d\",&n);\n\t\tif (n==0){\n\t\t\tbreak;\n\t\t}\n\t\tvector<double> x,y;\n\t\tint map[12][12]={{0}};\n\t\tint maxx=0,maxy=0;\n\t\tint maxpoint=0;\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tdouble tx=0,ty=0;\n\t\t\tscanf(\"%lf %lf\", &tx, &ty);\n\t\t\tx.push_back(tx);\n\t\t\ty.push_back(ty);\n\t\t\tint ttx=0,tty=0;\n\t\t\tttx = int(round(tx+0.5));\n\t\t\ttty = int(round(ty+0.5));\n\t\t\tmap[ttx][tty]++;\n\t\t\tif (maxpoint < map[ttx][tty]){\n\t\t\t\tmaxpoint = map[ttx][tty];\n\t\t\t\tmaxx=ttx;\n\t\t\t\tmaxy=tty;\n\t\t\t}\n\t\t}\n\t\tfor (double dif=0.5; dif>=0.005; dif/=10)\n\t\t{\n\t\t\tfor (int i=1; i<=10; i++)\n\t\t\t{\n\t\t\t\tfor (int j=1; j<=10; j++)\n\t\t\t\t{\n\t\t\t\t\tint aroundpoint=0;\n\t\t\t\t\tfor (int k=-1; k<=1; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int l=-1; l<=1; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taroundpoint+=map[i+k][j+l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (maxpoint >= aroundpoint){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvector<double> lx=getAreaPointx(i,j,x,y);\n\t\t\t\t\t\tvector<double> ly=getAreaPointy(i,j,x,y);\n\t\t\t\t\t\tfor (double k=0; k<1; k+=dif)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (double l=0; l<1; l+=dif)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint tmp = countInside(i-1+k,j-1+l,lx,ly);\n\t\t\t\t\t\t\t\tif (tmp>maxpoint){\n\t\t\t\t\t\t\t\t\tmaxpoint = tmp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr.push_back(maxpoint);\n\t}\n\tfor(int i=0; i<r.size(); i++)\n\t{\n\t\tcout << r[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n\n#define EPS\t1.0e-10\n#define rep(idx, m)\tfor(int idx = 0, idx##Max = m; idx < idx##Max; idx ++)\n\ntemplate<class LHS, class OP, class RHS>\nclass CExp\n{\n\tconst LHS\t&m_lhs;\n\tconst RHS\t&m_rhs;\n\t\npublic:\n\tCExp(const LHS &lhs, const RHS &rhs) : m_lhs(lhs), m_rhs(rhs) {}\n};\n\ntypedef struct _POINT\n{\n\tdouble x, y;\n\t\n/*\ttemplate<class T>\n\t_POINT operator =(const &T rhs)\n\t{\n\t\treturn(*this);\n\t}*/\n\t_POINT operator *=(double s)\n\t{\n\t\tx *= s, y *= s;\n\t\treturn(*this);\n\t}\n\t_POINT operator /=(double s)\n\t{\n\t\tx /= s, y /= s;\n\t\treturn(*this);\n\t}\n\tdouble Abs()\t{\treturn(::sqrt(x * x + y * y));\t}\n\tdouble Abs2()\t{\treturn(x * x + y * y);\t}\n\t_POINT(double _x, double _y) : x(_x), y(_y) {}\n\t_POINT() {}\n} POINT;\n\nint main()\n{\n\tint count;\n\tint pointNum;\n\tstd::vector<POINT> points;\n\t\n\twhile(std::cin >> pointNum, pointNum)\n\t{\n\t\tpoints.resize(pointNum);\n\t\trep(i, points.size())\n\t\t{\n\t\t\tstd::cin >> points[i].x >> points[i].y;\n\t\t}\n\t\t\n\t\tint maxCount = 0;\n\t\trep(i, points.size())\n\t\t{\n\t\t\trep(j, points.size())\n\t\t\t{\n\t\t\t\tif(i == j)\t{\tcontinue;\t}\n\t\t\t\tPOINT diff(points[i].x - points[j].x, points[i].y - points[j].y);\n\t\t\t\tif(diff.Abs() > 2.0 + EPS)\t{\tcontinue;\t}\n\t\t\t\tPOINT normal(diff.y, -diff.x);\n\t\t\t\tdouble distToCenter = ::sqrt(1 - normal.Abs2() / 4);\n\t\t\t\t\n\t\t\t\tnormal *= distToCenter / normal.Abs();\n\t\t\t\t\n\t\t\t\tPOINT center(points[j].x + diff.x / 2 + normal.x, points[j].y + diff.y / 2 + normal.y);\n\t\t\t\t\n\t\t\t\tcount = 0;\n\t\t\t\trep(k, points.size())\n\t\t\t\t{\n\t\t\t\t\tdouble x = points[k].x - center.x;\n\t\t\t\t\tdouble y = points[k].y - center.y;\n\t\t\t\t\t\n\t\t\t\t\tif(x * x + y * y <= 1 + EPS)\t{\tcount ++;\t}\n\t\t\t\t}\n\t\t\t\tif(maxCount < count)\t{\tmaxCount = count;\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << maxCount << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<math.h>\n\nusing namespace std;\ntypedef pair<double, double> P;\n\nint N;\ndouble X[300], Y[300];\nP d[300];\n\nP add(P p1, P p2) {\n  return P(p1.first + p2.first, p1.second + p2.second);\n}\n\nP minas(P p1, P p2) {\n  return P(p1.first - p2.first, p1.second - p2.second);\n}\n\nP mul(P p, double c) {\n  return P(p.first * c, p.second * c);\n}\n\nP ave(P p1, P p2) {\n  return P((p1.first + p2.first) / 2, (p1.second + p2.second) / 2);\n}\n\nvoid printP(P p) {\n  printf(\"P:(%f, %f)\\n\", p.first, p.second);\n}\n\ndouble square(P p) {\n  return p.first * p.first + p.second * p.second;\n}\n\ndouble size(P p) {\n  return sqrt(square(p));\n}\n\nint count(P p) {\n  // printP(p);\n  int counter = 0;\n  for (int i = 0; i < N; i++) {\n    if (square(minas(p, d[i])) <= 1.00001) counter++;\n  }\n  return counter;\n}\n\nint check(int i, int j) {\n  if (square(minas(d[i], d[j])) > 4.0) return 0;\n  int ans = 0;\n  P average = ave(d[i], d[j]);\n  P dir = mul(minas(d[i], d[j]), 0.5);\n  // printP(average);\n  double s = sqrt(1.0 - square(dir));\n  // printf(\"!!!!!!%f\\n\",s);\n  P dir1 = P((Y[i] - Y[j]), - (X[i] - X[j]));\n  //printf(\"!!!!!!%f\\n\",size(dir1));\n  double r = s / size(dir1);\n  P d1 = add(average, mul(dir1, r));\n  P d2 = add(average, mul(dir1, -r));\n  return max(count(d1), count(d2));\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &N);\n    if (N == 0) break;\n    for (int i = 0; i < N; i++) scanf(\"%lf%lf\", &X[i], &Y[i]), d[i] = P(X[i], Y[i]);\n    int ans = 0;\n    for (int i = 0; i < N; i++)\n      for (int j = 0; j < i; j++)\n        ans = max(ans, check(i, j));\n    printf(\"%d\\n\", ans);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <numeric>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<((x))<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n#define long long long\n#define EPS 1e-8\n\n// ???????°???°???????????????\ninline double add(double a, double b){\n  if(abs(a+b) < EPS*(abs(a) + abs(b))) return 0;\n  return a+b;\n}\n\nstruct Point{\n  double x,y;\n  Point() {}\n  Point(double nx, double ny) : x(nx), y(ny) {}\n  inline Point operator + (const Point & p){ return Point(add(x, p.x), add(y, p.y)); }\n  inline Point operator - (const Point & p){ return Point(add(x,-p.x), add(y,-p.y)); }\n  inline Point operator * (double d){ return Point(x*d, y*d); }\n  inline double dot(const Point & p){ return add(x * p.x, y*p.y); }  //??????\n  inline double det(const Point & p){ return add(x * p.y, -y*p.x); } //??????\n  inline double dist(const Point & p){ return sqrt((x-p.x)*(x-p.x) + (y-p.y)*(y-p.y)); }\n  inline bool operator < (const Point & p) const {\n    if(x != p.x) return x < p.x;\n    else return y < p.y;\n  }\n  inline bool operator == (const Point & p) const {\n    return (add(x, -p.x)==0) && (add(y, -p.y)==0);\n  }\n  friend ostream& operator<<(ostream& os, const Point& p) {\n    os << \"[\" << p.x << \",\" << p.y << \"]\";\n    return os;\n  }\n};\n\npair<Point, Point> calcCenter(Point &p1, Point &p2){\n  if(add(p1.x, -p2.x)==0){\n    double y = (p1.y + p2.y)/2;\n    double dx = sqrt(1 - (p1.y - y)*(p1.y - y));\n    return mp(Point(p1.x+dx, y), Point(p1.x-dx,y));\n  }\n  // 2???????????´???????????? Ax + By + C = 0 , A != 0\n  double A = 2*(p1.x - p2.x);\n  double B = 2*(p1.y - p2.y);\n  double C = - p1.x*p1.x + p2.x*p2.x - p1.y*p1.y + p2.y*p2.y;\n  // x = py+q\n  double p = -B/A; double q = -C/A;\n\n  // p1, p2 ??¨????????¢???1?????? ay^2 + 2by + c = 0\n  double a = 1 + p*p;\n  double b = p*q - p1.x*p - p1.y;\n  double c = q*q - 2*p1.x*q + p1.x*p1.x + p1.y*p1.y - 1;\n\n  double rt = sqrt(b*b-a*c);\n  double y1 = (-b+rt)/a;\n  double y2 = (-b-rt)/a;\n\n  return mp(Point(p*y1+q, y1), Point(p*y2+q, y2));\n}\n\nint main(){\n  int n;\n  while(scanf(\"%d\", &n), n){\n    vector<Point> vec;\n    rep(i,n){\n      double x,y;\n      scanf(\"%lf %lf\", &x, &y);\n      vec.pb(Point(x,y));\n    }\n\n    int res=1;\n    rep(i,n) repl(j,i+1,n) if(vec[i].dist(vec[j]) <= 2+EPS){\n      pair<Point, Point> pr = calcCenter(vec[i], vec[j]);\n//      cout << pr.fi << pr.se << endl;\n      int cnt=0;\n      rep(k,n) if(pr.fi.dist(vec[k]) <= 1+EPS) cnt++;\n      res = max(res, cnt);\n      cnt=0;\n      rep(k,n) if(pr.se.dist(vec[k]) <= 1+EPS) cnt++;\n      res = max(res, cnt);\n    }\n\n    printf(\"%d\\n\", res);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\nint main(){\n\tint n;\n\tcin >> n;\n\twhile(n){\n\t\tcomplex<long double> p[300];\n\t\tint s = 1;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tlong double a,b;\n\t\t\tcin >> a >> b;\n\t\t\tp[i] = complex<long double>(a,b);\n\t\t}\n\t\tfor(int i  = 0; i < n; i++){\n\t\t\tfor(int j = i+1; j < n; j++){\n\t\t\t\tif(abs(p[i]-p[j]) < 2){\n\t\t\t\t\tcomplex<long double> _p = polar(pow(1-norm(p[i]-p[j])/4,0.5),arg(p[i]-p[j])+M_PI_2);\n\t\t\t\t\tcomplex<long double> o[2];\n\t\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\t\to[k] = complex<long double>(real(p[i]+p[j])/2,imag(p[i]+p[j])/2);\n\t\t\t\t\t}\n\t\t\t\t\to[0] += _p;\n\t\t\t\t\to[1] -= _p;\n\t\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\t\tint t = 0;\n\t\t\t\t\t\tfor(int l = 0; l < n; l++){\n\t\t\t\t\t\t\tif(abs(p[l]-o[k]) <= 1.0001) ++t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts = max(s,t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << s << endl;\n\t\tcin >> n;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<double, double> PD;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nvector<PD> cli(double a, double b, double c, PD c1) {\n  double l = a * a + b * b, k = a * c1.fi + b * c1.se + c, d = l - k * k;\n  vector<PD> v;\n  if (d > 0) {\n    double ds = sqrt(d), apl = a / l, bpl = b / l;\n    double xc = c1.fi - apl * k, xd = bpl * ds, yc = c1.se - bpl * k, yd = apl * ds;\n    v.pb(PD(xc - xd, yc + yd)), v.pb(PD(xc + xd, yc - yd));\n  } else if (d == 0) {\n    v.pb(PD(c1.fi - a * k / l, c1.se - b * k / l));\n  }\n  return v;\n}\n\nvector<PD> cci(PD c1, PD c2) {\n  double a = c1.fi - c2.fi, b = c1.se - c2.se;\n  return cli(2.0 * a, 2.0 * b, 0 - a * (c1.fi + c2.fi) - b * (c1.se + c2.se), c1);\n}\n\nbool dist(PD p1, PD p2) {\n  return (pow(p1.fi - p2.fi, 2.0) + pow(p1.se - p2.se, 2.0)) <= 1.0 + 1e-7;\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int n;\n  while(cin >> n, n) {\n    vector<PD> v(n);\n    rep(i, n) cin >> v[i].fi >> v[i].se;\n\n    int maxi = 1;\n    rep(i, n - 1)repl(j, i + 1, n) {\n      vector<PD> p = cci(v[i], v[j]);\n      rep(k, p.size()) {\n        int cnt = 0;\n        rep(l, n) {\n          if (dist(p[k], v[l])) cnt++;\n        }\n        maxch(maxi, cnt);\n      }\n    }\n\n    cout << maxi << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n\nusing namespace std;\ntypedef pair<double, double> P;\nconst double EPS = 1e-5;\n\n#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n\nusing namespace std;\n\ndouble dist(P a, P b)\n{\n    return hypot(a.first - b.first, a.second - b.second);\n}\n\nvector<P> center(P a, P b)\n{\n    auto t = atan2(b.first - a.first, b.second - a.second);\n    auto x = dist(a, b) / 2;\n    auto y = sqrt(1.0 - x * x);\n    auto cs = cos(t), sn = sin(t);\n    return { \n        { cs * x - sn * y + a.first, sn * x + cs * y + a.second },\n        { cs * x + sn * y + a.first, sn * x - cs * y + a.second }\n    };\n}\n\nint main()\n{\n    while (1) {\n        int n; cin >> n;\n        if (!n) break;\n        vector<P> pnt;\n        loop (n, i) {\n            double x, y; cin >> x >> y;\n            pnt.emplace_back(x, y);\n        }\n        int ans = 1;\n        loop (n, i) loop (n, j) {\n            auto ps = center(pnt[i], pnt[j]);\n            for (auto o : ps) {\n                int cnt = 0;\n                loop (n, l) {\n                    //if (dist(o, pnt[l]) < 1 + EPS) cnt++;\n                }\n                ans = max(ans, cnt);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include \"math.h\"\n\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\nconst int INF = 10000000;\nint dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1};\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<double, double> P;\n\n/** Problem1132 : Circle and Point **/\nint main()\n{\n\tint N, ans;\n\tdouble X, Y;\n\tvector<P> points;\n\t\n\twhile (cin>>N, N) {\n\t\tans=0;\n\t\t\n\t\tpoints.clear();\n\t\trep(i, N) {\n\t\t\tcin >> X >> Y;\n\t\t\tpoints.push_back(P(X, Y));\n\t\t}\n\n\t\tfor (double x=0.0; x<=10.0; x+=0.01) {\n\t\t\tfor (double y=0.0; y<=10.0; y+=0.01) {\n\t\t\t\tint num=0;\n\t\t\t\tvector<P>::iterator it = points.begin();\n\t\t\t\tfor (; it!=points.end(); it++) {\n\t\t\t\t\tdouble d = (it->first-x)*(it->first-x) + (it->second-y)*(it->second-y);\n\t\t\t\t\tif (d<1.001) {\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ans<num)\n\t\t\t\t\tans = num;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-9;\n\nstruct Circle{\n  P c;\n  double r;\n  Circle(P c=P(0,0),double r=0):c(c),r(r){}\n};\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1=c1.r,r2=c2.r,d;\n  P p1=c1.c,p2=c2.c;\n  d=abs(p1-p2);\n  if(d<EPS&&abs(r1-r2)<EPS) return res;\n  if(r1+r2<d-EPS||d+EPS<abs(r1-r2)) return res; \n  double a=(r1*r1-r2*r2+d*d)/(2*d);\n  double h=sqrt(max(r1*r1-a*a,0.0));\n  P tmp1=p1+a/d*(p2-p1);\n  P tmp2=h/d*(p2-p1);\n  if(abs(tmp2)<EPS)res.push_back(tmp1);\n  else{\n    res.push_back(P(real(tmp1)-imag(tmp2),imag(tmp1)+real(tmp2)));\n    res.push_back(P(real(tmp1)+imag(tmp2),imag(tmp1)-real(tmp2)));\n  }\n  return res;\n}\n\ndouble getdistancepp(P a,P b){\n  return sqrt((a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag()));\n}\n\nint main(){\n  int n,ans=0;\n  double a,b;\n  P p[N];\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>a>>b;\n      p[i]=P(a,b);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tCircle c1,c2;\n\tc1.c=p[i];\n\tc2.c=p[j];\n\tc1.r=c2.r=1;\n\tvector<P> r=getIntersectCC(c1,c2);\n\tif(!r.size())continue;\n\tfor(int k=0;k<r.size();k++){\n\t  int cnt=0;\n\t  for(int l=0;l<n;l++)\n\t    if(getdistancepp(r[k],p[l])<=1+EPS)cnt++;\t    \n\t  ans=max(ans,cnt);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2004à\\ID Circle and Points\n\n#include <iostream>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\nconst double sqrt2 = sqrt(2.0); \nconst double eps = 1e-6;\nchar dx[] = {-1,1,-1,1};\nchar dy[] = {1,1,-1,-1};\n\nclass Square{\npublic:\n\tint bound; double x, y, size;\n\tSquare(int bound, double x, double y, double size) : bound(bound), x(x), y(y), size(size) {}\n\tbool operator < (const Square &s) const { return bound < s.bound; }\n};\n\ninline double sqr(double x) { return x*x; }\n\nint main(){\n\tint N;\n\tdouble x[300], y[300];\n\twhile(cin >> N){\n\t\tif(!N) break;\n\t\tfor(int i=0;i<N;i++) cin >> x[i] >> y[i];\n\t\tint ans = 1;\n\t\tpriority_queue<Square> qu;\n\t\tqu.push(Square(N, 5.0, 5.0, 10.0));\n\t\twhile(!qu.empty()){\n\t\t\tSquare s = qu.top(); qu.pop();\n\t\t\tif(s.bound <= ans) break;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tdouble nx = s.x + dx[i]*s.size/2.0;\n\t\t\t\tdouble ny = s.y + dy[i]*s.size/2.0;\n\t\t\t\tint c = 0, upper = 0;\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tdouble dist = sqr(x[j]-nx)+sqr(y[j]-ny);\n\t\t\t\t\tif(dist < 1.0+eps) c++;\n\t\t\t\t\tif(dist < sqr(1.0+sqrt2*s.size/2.0)+eps) upper++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, c);\n\t\t\t\tif(upper > ans) qu.push(Square(upper, nx, ny, s.size/2.0));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\nstruct Point {\n\tdouble x;\n\tdouble y;\n\tPoint(double _x = 0, double _y = 0) :x(_x), y(_y) {}\n\tPoint operator+(Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator-(Point p)  {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm() {\n\t\treturn x*x + y*y;\n\t}\n};\ntypedef Point Vector;\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle(Point _c = Point(), double _r = 0.0) :c(_c), r(_r) {}\n};\ndouble arg(Vector p) {\n\treturn atan2(p.y, p.x);\n}\nVector polar(double a, double r) {\n\treturn Point(cos(r)*a, sin(r)*a);\n}\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\ndouble X[300], Y[300];\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> X[i] >> Y[i];\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tCircle c1(Point(X[i], Y[i]), 1.0);\n\t\t\t\tCircle c2(Point(X[j], Y[j]), 1.0);\n\t\t\t\tif ((c1.c - c2.c).abs() >= 2.0001) continue;\n\t\t\t\tpair<Point, Point> c = getCrossPoints(c1, c2);\n\t\t\t\tint cnt1 = 0, cnt2 = 0;\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tPoint p(X[k], Y[k]);\n\t\t\t\t\tif ((p - c.first).abs() <= 1.0001) cnt1++;\n\t\t\t\t\tif ((p - c.second).abs() <= 1.0001) cnt2++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, cnt1);\n\t\t\t\tans = max(ans, cnt2);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\ntypedef complex<double> pt;\ntypedef pair<pt,pt> L;\ntypedef vector<P> poly;\nconst double EPS = 1e-11;\n#define x real()\n#define y imag()\n \ndouble dot(pt a,pt b){\n\treturn (conj(a)*b).x;\n}\ndouble cross(pt a,pt b){\n\treturn (conj(a)*b).y;\n}\nint ccw(pt a,pt b,pt c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > EPS) return 1; // counter clockwise\n\tif(cross(b,c) < -EPS) return -1; // clockwise\n\tif(dot(b,c) < -EPS) return 2; //c-a-b\n\tif(norm(b) < norm(c)) return -2; //a-b-c\n\treturn 0; //a-c-b\n}\nbool cmp(const pt& a,const pt& b){\n\tif(-EPS < a.x-b.x && a.x-b.x < EPS) return a.y < b.y;\n\telse return a.x < b.x;\n}\nvector<pt>convex_hull(vector<pt>ps)\n{\n\tsort(ps.begin(),ps.end(),cmp);\n\tint k=0,n = ps.size();\n\tvector<pt>qs(n*2);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\twhile(k>1 && ccw(qs[k-2],qs[k-1],ps[i]) == -1) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tfor(int i=n-2,t=k;i>=0;i--)\n\t{\n\t\twhile(k>t && ccw(qs[k-2],qs[k-1],ps[i]) == -1) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\npt intersect(pt a,pt b,pt c,pt d){\n\tdouble dev = (b.y-a.y)*(d.x-c.x)-(b.x-a.x)*(d.y-c.y);\n\t\n\tdouble d1, d2;\n \n\td1 = (c.y*d.x-c.x*d.y);\n\td2 = (a.y*b.x-a.x*b.y);\n \n\tpt ap1;\n\tap1.x = d1*(b.x-a.x) - d2*(d.x-c.x);\n\tap1.x /= dev;\n\tap1.y = d1*(b.y-a.y) - d2*(d.y-c.y);\n\tap1.y /= dev;\n \n\treturn ap1;\n}\nbool par(pt a,pt b,pt c,pt d){\n\tb.x -= a.x; b.y -= a.y;\n\td.x -= c.x; d.y -= c.y;\n\tif(abs(b.y*d.x - b.x*d.y) < EPS){\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ndouble PI = 3.1415926535897932;\nint main(){\n\twhile(1){\n\t\tint n; scanf(\"%d\",&n); if(!n) return 0; if(n==1){ puts(\"1\"); continue;}\n\t\tpt p[305];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tdouble a,b; scanf(\"%lf%lf\",&a,&b);\n\t\t\tp[i] = pt(a,b);\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=i+1;j<=n;j++){\n\t\t\t\tpt q = (p[i]+p[j])/2.0;\n\t\t\t\tpt r = (p[i]-p[j]); if(abs(r) > 2.0+EPS) continue;\n\t\t\t\tpt p1 = q + r / abs(r) * polar(sqrt(1.0-abs(r)*abs(r)/4.0),PI/2);\n\t\t\t\tpt p2 = q - r / abs(r) * polar(sqrt(1.0-abs(r)*abs(r)/4.0),-PI/2);\n\t\t\t\tint c=0,d=0;\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tif(k==i || k==j || abs(p1-p[k]) <= 1.0+EPS) c++;\n\t\t\t\t\tif(k==i || k==j || abs(p2-p[k]) <= 1.0+EPS) d++;\n\t\t\t\t}\n\t\t\t\tans = max(ans,max(c,d));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<double, double> pii;\n#define rep(i, n) REP(i, 0, (n))\n#define REP(i, a, n) for(int i=(a); i<(n); i++)\n\nstruct Vec2D {\n    double x, y;\n    Vec2D() : x(0.0), y(0.0) {}\n    Vec2D(double x, double y) : x(x), y(y) {}\n    Vec2D operator=(const Vec2D& v) { x=v.x; y=v.y; return *this; }\n    Vec2D operator-() { return Vec2D(-x, -y); }\n    Vec2D operator+(const Vec2D& v) { return Vec2D(x+v.x, y+v.y); }\n    Vec2D operator-(const Vec2D& v) { return Vec2D(x-v.x, y-v.y); }\n    double operator*(const Vec2D& v) { return x*v.x + y*v.y; }\n    Vec2D operator*(double k) { return Vec2D(x*k, y*k); }\n    Vec2D operator/(double k) { return Vec2D(x/k, y/k); }\n    double norm() { return sqrt(x*x + y*y); }\n    Vec2D normalize() { return Vec2D(x, y)/norm(); }\n    Vec2D normal() { return Vec2D(y, -x).normalize(); }\n};\nostream& operator<<(ostream& os, const Vec2D& v) {\n    os << \"Vec2D [ x: \" << v.x << \", y: \" << v.y << \" ]\";\n    return os;\n}\nistream& operator>>(std::istream& is, Vec2D& v) {\n    is >> v.x >> v.y;\n    return is;\n}\n\nint N;\nVec2D ps[300];\n\nint main() {\n    while(cin>>N, N) {\n        rep(i, N) cin >> ps[i];\n        \n        int ans = 1;\n        rep(i, N-1) {\n            REP(j, i+1, N) {\n                Vec2D d = ps[i]-ps[j];\n                if(d.norm() > 2.0001) continue;\n                double x = sqrt(1 - pow(d.norm()/2.0, 2));\n                Vec2D n = d.normal(), m = (ps[i]+ps[j])/2.0;\n                Vec2D o;\n                int cnt_p = 0;\n                o = m + (n*x);\n                rep(k, N) if((ps[k]-o).norm()<1.0001) cnt_p++;\n                int cnt_n = 0;\n                o = m - (n*x);\n                rep(k, N) if((ps[k]-o).norm()<1.0001) cnt_n++;\n                ans = max(ans, max(cnt_p, cnt_n));\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <string> \n#include <vector> \n#include <cmath> \n#include <algorithm> \n#include <cstdlib> \n#include <ctime> \n#include <cstdio> \n#include <functional> \n#include <set> \n#include <sstream> \n\n\nusing namespace std; \n\nint main(){\n\n\tint n;\n\tconst double eps=1e-6;\n\twhile(true){\n\n\t\tcin>>n;\n\n\t\tif(n==0) return 0;\n\n\t\tint ans=0;\n\t\tvector< double > x(n),y(n);\n\n\t\tfor(int i=0;i<n;i++) cin>>x[i]>>y[i];\n\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tconst double d=hypot(x[i]-x[j],y[i]-y[j]);\n\t\t\t\tif(d>2.0+eps) continue;\n\n\t\t\t\tconst double mx=(x[i]+x[j])/2.0;\n\t\t\t\tconst double my=(y[i]+y[j])/2.0;\n\t\t\t\tconst double dvx=(x[i]-x[j])/d;\n\t\t\t\tconst double dvy=(y[i]-y[j])/d;\n\n\t\t\t\tconst double cx1=mx+dvy*sqrt(1.0-d*d/4.0);\n\t\t\t\tconst double cy1=my-dvx*sqrt(1.0-d*d/4.0);\n\n\t\t\t\tconst double cx2=mx-dvy*sqrt(1.0-d*d/4.0);\n\t\t\t\tconst double cy2=my+dvx*sqrt(1.0-d*d/4.0);\n\n\t\t\t\tint res=2;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i || k==j) continue;\n//\t\t\t\t\tif(hypot(x[k]-cx1,y[k]-cy1)<1.0+eps) res++;\n\t\t\t\t\tif((x[k]-cx1)*(x[k]-cx1)+(y[k]-cy1)*(y[k]-cy1)<1.0+eps) res++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tans=max(ans,res);\n\n\t\t\t\tres=2;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i || k==j) continue;\n//\t\t\t\t\tif(hypot(x[k]-cx2,y[k]-cy2)<1.0+eps) res++;\n\t\t\t\t\tif((x[k]-cx2)*(x[k]-cx2)+(y[k]-cy2)*(y[k]-cy2)<1.0+eps) res++;\n\t\t\t\t}\n\n\t\t\t\tans=max(ans,res);\n\n\t\t\t}\n\t\t}\n\n\t\tcout<<ans<<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <utility>\n#include <stdio.h>\n\n#if 0 \n  #define SPAM(a) printf a\n#else\n  #define SPAM(a) (void)0\n#endif\n\nusing namespace std;\nconst double EPS= 1e-5;\nconst double MAXDIST = 2.0;\nconst double MAXRAD  = 1.0;\n\n\ntypedef pair<double,double> Point;\n\n//TODO check all function good for double\n//DONE check printf good for double\nvector<Point > pointList;\n\nusing namespace std;\n\nint inRange(Point A, Point B, double num){\n    double dx, dy, d;\n    dx = A.first - B.first;\n    dy = A.second - B.second;\n    d = hypot(dx,dy);\n    SPAM((\"                    d = %lf\\n\", d));\n    if (abs(num-d) < 0.00001 ){\n            SPAM((\"REALLY CLOSE\\n\"));\n    }\n    if ( EPS > d -num ){\n        return 1;\n    }\n    return 0;\n}\n\nint get_Centre(Point pA,\n               Point pB,\n               Point &pC, \n               Point &pD )\n{\n   // SPAM((\"in get Centre\\n\"));\n  double x0 = pA.first;\n  double y0 = pA.second;\n  double x1 = pB.first;\n  double y1 = pB.second;\n  \n  \n  double a, dx, dy, d, h, rx, ry;\n  double x2, y2;\n\n  /* dx and dy are the vertical and horizontal distances between\n   * the circle centers.\n   */\n  dx = x1 - x0;\n  dy = y1 - y0;\n  //SPAM((\"dx = %lf, dy = %lf\\n\", dx, dyi));\n  \n  /* Determine the straight-line distance between the centers. */\n  //d = sqrt((dy*dy) + (dx*dx));\n  d = hypot(dx,dy); // Suggested by Keith Briggs\n  //SPAM(\"         d = %lf\\n\", d);\n\n  /* Check for solvability. */\n  if (EPS > MAXDIST -d)\n  {\n    /* no solution. circles do not intersect. */\n    return 0;\n  }\n    //SPAM(\"check solvability\\n\");\n\n  /* 'point 2' is the point where the line through the circle\n   * intersection points crosses the line between the circle\n   * centers.  \n   */\n\n  /* Determine the distance from point 0 to point 2. */\n  a = ( d / 2.0 ) ;\n  //SPAM(\"a = %lf\\n\", a);\n    \n  /* Determine the coordinates of point 2. */\n  x2 = (x0 + x1)/2.0 ;\n  y2 = (y0 + y1)/2.0 ;\n\n  /* Determine the distance from point 2 to either of the\n   * intersection points.\n   */\n    //SPAM(\"before sqrt\\n\");\n  //h = sqrt(1 - a*a);\n  //SPAM(\"a*a = %lf\\n\", a*a);\n  \n  h = sqrtl(MAXRAD - a*a);\n  //SPAM(\"h = %lf\\n\", h);\n  //SPAM(\"after sqrt\\n\");\n  /* Now determine the offsets of the intersection points from\n   * point 2.\n   */\n  //SPAM(\"get Offset\\n\");\n  //SPAM(\"          rx = -dy * (h / d) = %lf * (%lf /  %lf)\\n\", -dy, h, d);\n  //SPAM(\"          ry = dx * (h / d) = %lf * (%lf /  %lf)\\n\", dx, h, d);\n  rx = -dy * (h/d);\n  ry = dx * (h/d);\n  //SPAM(\"          rx = %lf, ry = %lf\\n\", rx, ry);\n  //SPAM(\"get int points\\n\");\n  /* Determine the absolute intersection points. */\n  pC.first = x2 + rx;\n  pC.second = y2 + ry;\n  pD.first = x2 - rx;\n  pD.second = y2 - ry;\n  //SPAM(\"in getCentre pC = (%lf, %lf)\\n\", pC.first, pC.second);\n\n  return 1;\n}\n\nint main(){\n    //for each iteration until 0\n    int N;\n    scanf(\"%d\", &N);\n    while(N !=0){\n        pointList.clear();\n        //for each set of points\n        for(int i=0; i < N; i++){\n            //take in points \n            double X,Y;\n            scanf(\"%lf %lf\", &X, &Y);\n            pointList.push_back(make_pair(X,Y));\n        }        \n            \n        //SPAM(\"put all points in\\n\");\n        //setMax = 0\n        int setMax = 0;\n        //for each point\n        for(int i =0; i < N-1; i++){\n            Point pA;\n            pA = pointList[i];\n            SPAM((\"pA = (%lf, %lf)\\n\", pA.first, pA.second));\n            //for each second point (point1 -> fin)\n            for (int j=i+1; j < N; j++){\n                Point pB = pointList[j];\n                \n                //SPAM(\"finding centre\\n\");\n                //find centre\n                Point pC, pD;\n                //SPAM(\"--------> pB = (%lf,%lf)\\n\", pB.first, pB.second);\n                //continue if distance > 2\n                if( get_Centre(pA, pB, pC, pD) == 0){\n                    //SPAM(\"         not in range\\n\");\n                    continue;\n                }\n                //SPAM(\"out getCentre pC = (%lf, %lf)\\n\", pC.first, pC.second);\n                //SPAM(\"after get_Centre\\n\");\n                //circleMax = 0;\n                int circleCMax = 0;\n                //SPAM(\"          going through points\\n\");\n                //go through all points \n                for(auto p: pointList){\n                    //see if centre-> point < 1, circleMax++\n                    SPAM((\"                    p = (%lf, %lf)\\n\", p.first, p.second));\n                    if ( inRange(p, pC, MAXRAD)){\n                        circleCMax++;\n                        SPAM((\"                        in range\\n\"));\n                    }\n                }\n                SPAM((\"        circleCMax = %d\\n\\n\", circleCMax));\n                setMax = max(setMax, circleCMax);\n                int circleDMax = 0;\n                for(auto p: pointList){\n                    //see if centre-> point < 1, circleMax++\n                    SPAM((\"                    p = (%lf, %lf)\\n\", p.first, p.second));\n                    if ( inRange(p, pD, MAXRAD)){\n                        circleDMax++;\n                        SPAM((\"                        in range\\n\"));\n                    }\n                }\n                SPAM((\"        circleDMax = %d\\n\\n\", circleDMax));\n                setMax = max(setMax, circleDMax);   \n            }\n                \n        }\n        //print setMax\n        if(setMax == 0){\n            printf(\"1\\n\");\n        } else {\n            printf(\"%d\\n\", setMax);\n        }\n        \n        //scan next N in\n        scanf(\"%d\", &N);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\n#define MAX_N 310\n\nlong double x[MAX_N], y[MAX_N];\nint n, maxn;\n\nint main() {\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tmaxn = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tint sum = 0;\n\t\t\t\tlong double X = (x[i] + x[j]) / 2.0;\n\t\t\t\tlong double Y = (y[i] + y[j]) / 2.0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (((x[k] - X)*(x[k] - X) + (y[k] - Y)*(y[k] - Y)) <= 1) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\t\t\t\tlong double X1, Y1, X2, Y2, X3, Y3, VX2, VY2, Dist, Dist2;\n\t\t\t\tDist = sqrt((x[j] - x[i])*(x[j] - x[i]) + (y[j] - y[i])*(y[j] - y[i]));\n\t\t\t\tDist2 = sqrt(4 - Dist*Dist);\n\t\t\t\tX2 = x[j] - x[i]; Y2 = y[j] - y[i];\n\t\t\t\tVX2 = (X2 / Dist)*Dist2 / 2; VY2 = (Y2 / Dist)*Dist2 / 2;\n\t\t\t\tX1 = X + VY2; Y1 = Y - VX2;\n\t\t\t\tX3 = X - VY2; Y3 = Y + VX2;\n\n\t\t\t\tsum = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (((x[k] - X1)*(x[k] - X1) + (y[k] - Y1)*(y[k] - Y1)) <= 1) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\t\t\t\tsum = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (((x[k] - X3)*(x[k] - X3) + (y[k] - Y3)*(y[k] - Y3)) <= 1) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint sum = 0;\n\t\t\tlong double X = x[i];\n\t\t\tlong double Y = y[i];\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (((x[k] - X)*(x[k] - X) + (y[k] - Y)*(y[k] - Y)) <= 1) {\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxn = max(maxn, sum);\n\t\t}\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\nconst double PI=3.141592653589793238462643383279;\n\nbool inC(P p, P c, double r){return abs(p-c)<r+1e-9;}\n\nP getE(P p){return p/abs(p);}\n\ndouble sq(double x){ return  x*x;}\n\nint main(){\n    int n,i,j,k,ans,cnt;\n    double x, y;\n    while(scanf(\"%d\",&n)){\n        if(n==0) break;\n        ans=0;\n        vector<P> ps(n);\n        for(i=0; i<n; i++){\n            scanf(\"%lf%lf\",&x,&y);\n            ps[i] = P(x,y);\n        }\n        for(i=0;i<n;i++)\n            for(j=i+1;j<n;j++)if(abs(ps[i]-ps[j])<2){\n                double d=sqrt(1-sq(abs(ps[j]-ps[i])*0.5));\n                P c1=0.5*(ps[i]+ps[j])+getE(getE(ps[j]-ps[i]))*polar(d,PI/2);\n                P c2=0.5*(ps[i]+ps[j])+getE(getE(ps[j]-ps[i]))*polar(d,-PI/2);\n                cnt=0;\n                for(k=0;k<n;k++)if(inC(ps[k],c1,1.0))cnt++;\n                if(cnt>ans)ans=cnt;\n                cnt=0;\n                for(k=0;k<n;k++)if(inC(ps[k],c2,1.0))cnt++;\n                if(cnt>ans)ans=cnt;\n            }\n        if(ans==0) ans++;\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#define EPS 1.0e-10\nusing namespace std;\ntypedef double elem;\ntypedef complex<elem> point,vec;\ninline elem dist(const point &a, const point &b){return abs(a-b);}\ninline vec normr(const vec &v){return v*vec(0,-1);}\ninline vec norml(const vec &v){return v*vec(0,1);}\ninline vec unormr(const vec &v){return normr(v) / abs(v);}\ninline vec unorml(const vec &v){return norml(v) / abs(v);}\nint main(){\n\twhile(true){\n\t\tint ans = 0;\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tif(n==1){\n\t\t\tprintf(\"1\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tvector< point > points;\n\t\tfor(int i=0;i<n;++i){\n\t\t\telem x, y;\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tpoints.push_back( point(x,y) );\n\t\t}\n\t\tfor(unsigned int i = 0; i < points.size(); ++i){\n\t\t\tfor(unsigned int j = 0; j < points.size(); ++j){\n\t\t\t\tif( i != j && dist( points[i], points[j] ) <= 2 ){\n\t\t\t\t\tint count_p = 0;\n\t\t\t\t\tint count_q = 0;\n\t\t\t\t\telem d = sqrt(1-pow(dist(points[i], points[j])/2,2 ) );\n\t\t\t\t\tpoint p,q;\n\t\t\t\t\tvec ab = points[j] - points[i];\n\t\t\t\t\tpoint t = 0.5 * ab + points[i];  \n\t\t\t\t\tp = d * unormr(ab) + t;\n\t\t\t\t\tq = d * unorml(ab) + t;\n\t\t\t\t\t//cout << i << \",\" << j << endl;\n\t\t\t\t\tfor(unsigned int k = 0; k < points.size(); ++k){\n\t\t\t\t\t\t//cout << dist(p,points[k]) << \" \" << dist(q,points[k]) << endl;\n\n\t\t\t\t\t\tif( dist(p, points[k]) <= 1+EPS ){ count_p++; }\n\t\t\t\t\t\tif( dist(q, points[k]) <= 1+EPS ){ count_q++; }\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans, max(count_q, count_p) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<double> x(n), y(n);\n\t\tint ans = 1;\n\t\tREP(i, n)cin >> x[i] >> y[i];\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tdouble ax = x[j] - x[i], ay = y[j] - y[i];\n\t\t\t\tif (ax*ax + ay*ay+EPS > 4)continue;\n\t\t\t\tdouble px = x[i] + ax / 2 + sqrt((4 - (ax*ax + ay*ay)) / (4 * (ax*ax + ay*ay)))*ay,\n\t\t\t\tpy = y[i] + ay / 2 - sqrt((4 - (ax*ax + ay*ay)) / (4 * (ax*ax + ay*ay)))*ax;\n\t\t\t\tint cnt = 0;\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tif ((x[k] - px)*(x[k] - px) + (y[k] - py)*(y[k] - py) < 1+EPS)cnt++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, cnt);\n\t\t\t}\n\t\t}\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tdouble ax = x[j] - x[i], ay = y[j] - y[i];\n\t\t\t\tif (ax*ax + ay*ay+EPS > 4)continue;\n\t\t\t\tdouble px = x[i] + ax / 2 - sqrt((4 - (ax*ax + ay*ay)) / (4 * (ax*ax + ay*ay)))*ay,\n\t\t\t\t\tpy = y[i] + ay / 2 + sqrt((4 - (ax*ax + ay*ay)) / (4 * (ax*ax + ay*ay)))*ax;\n\t\t\t\tint cnt = 0;\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tif ((x[k] - px)*(x[k] - px) + (y[k] - py)*(y[k] - py) < 1+EPS)cnt++;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tans = max(ans, cnt);\n\t\t\t}\n\t\t}\n\t\tcout <<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint N;\npair<double,double> dots[300];\n#define EPS (1e-6)\n\n\nint main(){\n\n\twhile(cin >> N && N != 0){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tpair<double,double> p;\n\t\t\tcin >> dots[i].second >> dots[i].first;\n\t\t}\n\t\tint maxCnt = 1;\n\t\t// ~ðìé½ßÌQ_ðßé\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = i+1; j < N; j++){\n\t\t\t\tpair<double,double> dot1,dot2;\n\t\t\t\tdot1 = dots[i];\n\t\t\t\tdot2 = dots[j];\n\n\t\t\t\tdouble v = sqrt((dot1.first - dot2.first)*(dot1.first - dot2.first)\n\t\t\t\t\t+(dot1.second - dot2.second)*(dot1.second - dot2.second));\n\t\t\t\t// ñ_Ô£ª2æè¨¨«¯êÎÂ­êÈ¢\n\t\t\t\tif(v > 2.0 + EPS){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdouble x = sqrt(1 - (v/2)*(v/2));\n\n\t\t\t\t// ñgÌPÊ@üxNg\n\t\t\t\tpair<double,double> hose[2];\n\t\t\t\those[0].first = -1.0/(dots[i].first - dots[j].first);\n\t\t\t\those[0].second = 1.0/(dots[i].second - dots[j].second);\n\t\t\t\those[1].first = 1.0/(dots[i].first - dots[j].first);\n\t\t\t\those[1].second = -1.0/(dots[i].second - dots[j].second);\n\n\t\t\t\tdouble dd1 = sqrt((hose[0].second)*(hose[0].second)+(hose[0].first)*(hose[0].first));\n\t\t\t\tdouble dd2 = sqrt((hose[1].second)*(hose[1].second)+(hose[1].first)*(hose[1].first));\n\t\t\t\those[0].first /= dd1; hose[0].second /= dd1;\n\t\t\t\those[1].first /= dd2; hose[1].second /= dd2;\n\n\t\t\t\t// x{·é\n\t\t\t\those[0].first *= x;hose[1].first *= x;\n\t\t\t\those[0].second *= x;hose[1].second *= x;\n\n\t\t\t\t// mð«·\n\t\t\t\those[0].first += (dot1.first + dot2.first)/2;\n\t\t\t\those[0].second += (dot1.second + dot2.second)/2;\n\t\t\t\those[1].first += (dot1.first + dot2.first)/2;\n\t\t\t\those[1].second += (dot1.second + dot2.second)/2;\n\n\t\t\t\t// hose[0]Æhose[1]Í~ÌSÀW\n\t\t\t\t// e_ÉÖµÄ~ÌÉ¶Ý·é©Ç¤©ðßé\n\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor(int l = 0; l < N; l++){\n\t\t\t\t\t\tdouble dist = sqrt((dots[l].first -hose[k].first)*(dots[l].first -hose[k].first)\n\t\t\t\t\t\t\t+ (dots[l].second -hose[k].second)*(dots[l].second -hose[k].second));\n\t\t\t\t\t\tif(dist < 1.0 + EPS){\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmaxCnt = max(maxCnt,cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << maxCnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\nnamespace Ps{\n\tconst double EPS = 1e-8;\n\tconst double INF = 1e12;\n\n\ttypedef complex<double> P;\n\t#define X(a) (real(a))\n\t#define Y(a) (imag(a))\n\t\n\t// a×b\n\tdouble cross(const P& a,const P& b){\n\t\treturn imag(conj(a)*b);\n\t}\n\t// a・b\n\tdouble dot(const P&a,const P& b) {\n\t\treturn real(conj(a)*b);\n\t}\n\n\t int ccw(const P& a,P b,P c){\n\t\tb -= a; c -= a;\n\t\t  if (cross(b,c) > 0)   return +1;       // counter clockwise\n\t\t  if (cross(b,c) < 0)   return -1;       // clockwise\n\t\t  if (dot(b,c) < 0)     return +2;       // c--a--b on line\n\t\t  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n\t\t  return 0;\n\t  }\n\n\t  double pfmod(double v,double MOD){\n\t\treturn fmod(fmod(v,MOD)+MOD,MOD);\n\t }\n\t  double AbsArg(double a){\n\t  \tdouble ret=pfmod(max(a,-a),2*M_PI);\n\t  \treturn min(ret,2*M_PI-ret);\n\t }\n\n}\nusing namespace Ps;\n\n\n\nclass Main{\n\tpublic:\n\n\tint N;\n\tvector<P> ps;\n\tvoid run(){\n\t\t// ifstream cin(\"D2\");\n//\t\tofstream cout( \"D2.out\" );\n\t\t\n\t\twhile(true){\n\t\t\tcin >> N;if(N==0)break;\n\t\t\tps=vector<P>(N);\n\t\t\tREP(i,N){\n\t\t\t\tdouble x,y;cin >> x >> y;\n\t\t\t\tps[i]=P(x,y);\n\t\t\t} \n\t\t\tint Mv=1;\n\t\t\tREP(i,N)REP(j,N)if(i!=j){//二点選んで距離1の点を取る\n\t\t\t\tP dir=(ps[i]-ps[j])*0.5;\n\t\t\t\tdir*=P(cos(M_PI/2),sin(M_PI/2));\n\t\t\t\tif(abs(dir)>1)continue;\n\t\t\t\tP m=(ps[i]+ps[j])*0.5;\n\t\t\t\tP o=m+dir*(sqrt(1-pow(abs(dir),2))/abs(dir));\n\t\t\t\t\n\t\t\t\tint v=0;\n\t\t\t\tREP(k,N)if(abs(ps[k]-o)<=1+EPS)v++;\n\t\t\t\t\n\n\t\t\t\tMv=max(Mv,v);\n\t\t\t}\n\t\t\tcout << Mv <<endl;\n\t\t}\n\t}\n\n\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n//CCW??¨///////////////////////////////////\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n/////////////////////////////////////////\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\nstruct Circle{\n  Point c;\n  double r;\n};\ntypedef Point vect;\nstruct seg{Point p1,p2;};\n//????????´????????????\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\n//??¶???????????????absolute  ?????????????????¶?????????\ndouble abs(Point p){return sqrt(norm(p));}\n//?????????????????????????????????\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n//?????? ????????????????????????\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n//??´?????????????????¨?????\\?????????????????????\nbool C90(seg s1,seg s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//????????????????????¨?????\\??????????????????????????????????????????\nbool C0(seg s1,seg s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//?°???± ??????????????´???????????????\nPoint project(seg s,Point p){\n  Point base = s.p2-s.p1;\n  double r=dot(p-s.p1,base) / norm(base);\n  return s.p1+base*r;\n}\n//????°??????????????????????\nPoint reflection(seg s,Point p){\n  return  p+(project(s,p)-p)*2.0;\n}\n//2???????????¢   ???????????????\ndouble getDistancePP(Point a,Point b){\n  return abs(a-b);\n}\n//??´??????????????¢(????°?)???????????????\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n//?????????????????¢??????????????????\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n//????¨?????????????????¨??????????????????????????????????\nint CCW(Point p0,Point p1,Point p2){\n  Point a=p1-p0;\n  Point b=p2-p0;\n  if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS)return CLOCKWISE;\n  if(dot(a,b)<-EPS)return ONLINE_BACK;\n  if(norm(a)<norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n//????????????????????????????????????????????§?\\????\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return(CCW(p1,p2,p3)*CCW(p1,p2,p4)<=0&&CCW(p3,p4,p1)*CCW(p3,p4,p2)<=0);\n}\nbool intersect(seg s1,seg s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//2??????????§???¢?????\\??????????????????...????????????????????????\nbool squareintersect(seg s1,seg s2){\n  if(s1.p2.x<s2.p1.x||s2.p2.x<s1.p1.x)return 0;\n  if(s1.p2.y<s2.p1.y||s2.p2.y<s1.p1.y)return 0;\n  return 1;\n}\n//??????????????¢?????????????????????????????§??¨???????????????\ndouble getDistance(seg s1,seg s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n    min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n//??????????????????????????????(?´????????`)\nPoint getCrossPoint(seg s1,seg s2){\n  Point base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n//???????£????????????¢??????????????¢??????????????????????????\\????????????????????§???????????£???????????????????????????????????§?????????????????????\nint intersectCC(Circle a,Circle b){\n  double dist=abs(a.c-b.c);\n  if(dist>a.r+b.r+EPS)return 4;\n  if(dist>a.r+b.r-EPS)return 3;\n  if(dist>abs(a.r-b.r)+EPS)return 2;\n  if(dist>abs(a.r-b.r)-EPS)return 1;\n  return 0;\n}\n//?????¨??´???????????????2?????? (LINE)\nseg getCrossPoint(Circle c,seg l){\n  //assert(intersect(cc,l));\n  Point pr=project(l,c.c);\n  Point e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base =sqrt(c.r*c.r-norm(pr-c.c));\n  seg pp;pp.p1=(pr+e*base);pp.p2=(pr-e*base);\n  return pp;\n}\n//?????¨??´??????Line??????????????°\nint getCircleLine(Circle c,seg l){\n  seg a=getCrossPoint(c,l);\n  if(isnan(a.p1.x)&&isnan(a.p2.y))return 0;\n  else if(a.p1.x==a.p2.x&&a.p1.y==a.p2.y)return 1;\n  else return 2;\n}\n//??´?????¨????????\\???????????????\nbool intersectCirclesen(seg s,Circle t){\n  double a,b,c;\n  a=getDistancePP(s.p1,t.c);\n  b=getDistancePP(s.p2,t.c);\n  c=getDistanceSP(s,t.c);\n  if(a<t.r&&b>t.r)return 1;\n  if(b<t.r&&a>t.r)return 1;\n  if(a>=t.r&&b>=t.r&&c<=t.r)return 1;\n  return 0;\n}\n//??????\nPoint gaishin(Point a, Point b, Point c){\n  double a1,a2,b1,b2,c1,c2;\n  a1=2*(b.x-a.x);b1=2*(b.y-a.y);c1=a.x*a.x-b.x*b.x+a.y*a.y-b.y*b.y;\n  a2=2*(c.x-a.x);b2=2*(c.y-a.y);c2=a.x*a.x-c.x*c.x+a.y*a.y-c.y*c.y;\n  Point p;p.x=(b1*c2-b2*c1)/(a1*b2-a2*b1);p.y=(c1*a2-c2*a1)/(a1*b2-a2*b1);\n  return p;\n}\n//2??????????????????\ndouble arg(Point p){return atan2(p.y,p.x);}\nPoint polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\nseg getCrossPoints(Circle c1,Circle c2){\n  //assert(intersect(c1,c2));\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  seg s;s.p2=c1.c+polar(c1.r,t+a);s.p1=c1.c+polar(c1.r,t-a);\n  return s;\n}\n//???????????? ????????????->2 ??????->1  ????????\\???->0\ntypedef vector<Point> Polygon;\nint contains(Polygon g, Point p) {\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++) {\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n  }\n  return x ? 2 : 0;\n}\ndouble Area(Polygon p) {\n  double a=0;\n  for(int i=0;i<p.size();i++)a+=cross(p[i],p[(i+1)%p.size()]);\n  return a/2;\n}\n//???????§???¢??????\nbool isConvex(Polygon p){\n  for(int i=0;i<p.size();i++){\n    if(CCW(p[(i+1)%p.size()],p[i%p.size()],p[(i+2)%p.size()])==1)return false;\n  }\n  return true;\n}\n//?????¢???????????¢???(?????´)=ans\nPolygon convex_cut(Polygon p,seg l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(CCW(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(CCW(l.p1,l.p2,A)*CCW(l.p1,l.p2,B)<0){\n      seg s;s.p1=A;s.p2=B;\n      ans.push_back(getCrossPoint(l,s));\n    }\n  }\n  return ans;\n}\ndouble convex_diameter(Polygon p){\n  int n=p.size();\n  int i=0,j=0;\n  for(int k=0;k<n;k++){if(p[i]<p[k])i=k;if(p[k]<p[j])j=k;}\n  int si=i,sj=j;double ans=0.0;\n  while(i!=sj||j!=si){\n    ans=max(ans,abs(p[i]-p[j]));\n    if(cross((p[(i+1)%n]-p[i]),(p[(j+1)%n]-p[j]))<0)i=(i+1)%n;\n    else j=(j+1)%n;\n  }\n  return ans;\n}\n//?????? ??´??????????????????????????????????????¨?????????191,197?????????&&CCW(u[n-2],u[n-1],s[i])!=ONLINE_FRONT???????????????\nPolygon andrewScan(Polygon s) {\n  Polygon l, u;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<s.size();i++){\n    for(int n=u.size();n>=2&&CCW(u[n-2],u[n-1],s[i])!=-1&&CCW(u[n-2],u[n-1],s[i])!=ONLINE_FRONT;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&CCW(l[n-2],l[n-1],s[i])!=-1&&CCW(l[n-2],l[n-1],s[i])!=ONLINE_FRONT;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for( int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  return l;\n}\n//???a??¨???b??????d??¢??????2???\nseg identifyPoint(Point a,Point b,double d){\n  Circle c1,c2;\n  c1.c=a;c1.r=d;c2.c=b;c2.r=d;\n  return getCrossPoints(c1,c2);\n}\n//    ???????????°??¨??????\nseg scan(){seg a;scanf(\"%lf%lf%lf%lf\",&a.p1.x,&a.p1.y,&a.p2.x,&a.p2.y);return a;}\nvoid prin(seg a){printf(\"%.10f %.10f %.10f %.10f\\n\",a.p1.x,a.p1.y,a.p2.x,a.p2.y);}\n//\n/////------Library END-------//////////////////////////////////////\n//   exp?????????    //////a=x??§?¨????b=y??§?¨????c=?§?????????????d=????????????????????¢\n//    p[i][j].x=a-d*sin(M_PI/180*(72*j+c));\n//   p[i][j].y=b+d*cos(M_PI/180*(72*j+c));\n/////////////////////////////////////////////////\nint main(){\n  int n;\n  while(cin>>n,n){\n    Point p[n];int ans=1;\n    r(i,n)cin>>p[i].x>>p[i].y;\n    r(i,n)for(int j=i+1;j<n;j++){\n      seg s=identifyPoint(p[i],p[j],1);\n      int a1=0,a2=0;\n      Point p3,p4;p3=s.p1;p4=s.p2;\n      r(k,n)if(abs(getDistancePP(p3,p[k])-1)<EPS)a1++;\n      r(k,n)if(abs(getDistancePP(p4,p[k])-1)<EPS)a2++;\n      ans=max(ans,max(a1,a2));\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){\n    rep(i,v.size()) os << v[i] << (i+1==v.size()?\"\":\" \");\n    return os;\n}\n\ntypedef double R;\ntypedef complex<R> P;\nR const eps = 1e-8;\nint main(){\n    int n;\n    while(cin>>n && n){\n        vector<P> ps(n);\n        rep(i,n){\n            R x,y; cin >> x >> y;\n            ps[i] = P(x,y);\n        }\n\n        int ans = 0;\n        rep(i,n)rep(j,n)if(i!=j){\n            P & p = ps[i];\n            P & q = ps[j];\n            R d = abs(p-q);\n            if(d > 2) continue;\n            P m = (p+q)/2.;\n            R l = sqrt(1-(d/2)*(d/2));\n            P c = m + (p-m)*(d/2)*l * P(0,1);\n            int cnt = 0;\n            rep(k,n){\n                if(abs(c-ps[k]) < 1+eps) cnt++;\n            }\n            ans = max(ans,cnt);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <set>\n\nusing namespace std;\n\n\nint main(){\n\tint n;\n\tdouble x1,y1,xc,yc,dis,vx,vy,ex,ey;\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\tvector<double> x(n);\n\t\tvector<double> y(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tif(n==1){\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans =0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(i==j)break;\n\t\t\t\txc = (x[i]+x[j])/2;\n\t\t\t\tyc = (y[i]+y[j])/2;\n\t\t\t\tdis = sqrt(1.0-(xc-x[i])*(xc-x[i])-(yc-y[i])*(yc-y[i]));\n\t\t\t\tvx = x[i]-x[j];\n\t\t\t\tvy = y[i]-y[j];\n\t\t\t\tex = dis * vy / sqrt(vx*vx+vy*vy);\n\t\t\t\tey = -dis* vx / sqrt(vx*vx+vy*vy);\n\t\t\t\tx1 = xc + ex;\n\t\t\t\ty1 = yc + ey;\n\t\t\t\tint count=0;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i||k==j)count +=1;\n\t\t\t\t\telse{\n\t\t\t\t\t\tif((x1-x[k])*(x1-x[k])+(y1-y[k])*(y1-y[k])<=1.0001){\n\t\t\t\t\t\t\tcount +=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = max(ans,count);\n\t\t\t\tx1 = xc - ex;\n\t\t\t\ty1 = yc - ey;\n\t\t\t\tcount = 0;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i||k==j)count +=1;\n\t\t\t\t\telse{\n\t\t\t\t\t\tif((x1-x[k])*(x1-x[k])+(y1-y[k])*(y1-y[k])<=1.0001){\n\t\t\t\t\t\t\tcount +=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = max(ans,count);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<complex>\n#include<numeric>\n#include<bitset>\n#define INF 1001001001\n#define EPS 0.000000001\nusing namespace std;\ntypedef vector<int> vint;\ntypedef vector<vint> vvint;\ntypedef pair<int,int> pint;\n\ntypedef complex<double> pt;\n\nint main(){\n\tpt p[310];\n\tint i,j,ii;\n\tint n;\n\t\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tfor(i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf %lf\",&x,&y);\n\t\t\tp[i] = pt(x,y);\n\t\t}\n\t\t\n\t\tint mx=1;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\tdouble l = abs(p[i]-p[j]);\n\t\t\t\tdouble k = sqrt(1-(l*l/4.0));\n\t\t\t\tpt m = (p[i]+p[j])/2.0;\n\t\t\t\tpt v(-imag(p[i]-p[j]),real(p[i]-p[j]));\n\t\t\t\tdouble r = abs(v);\n\t\t\t\tv= v*k/r;\n\t\t\t\tint cnt;\n\t\t\t\t\n\t\t\t\tp[n] = m+v;\n\t\t\t\tcnt=0;\n\t\t\t\tfor(ii=0;ii<n;ii++){\n\t\t\t\t\tif(norm(p[ii]-p[n])<=1.000001) cnt++;\n\t\t\t\t}\n\t\t\t\tmx = max(mx,cnt);\n\t\t\t\t\n\t\t\t\tp[n]=m-v;\n\t\t\t\tcnt=0;\n\t\t\t\tfor(ii=0;ii<n;ii++){\n\t\t\t\t\tif(norm(p[ii]-p[n])<=1.000001) cnt++;\n\t\t\t\t}\n\t\t\t\tmx = max(mx,cnt);\n\t\t\t}\n\t\t}\n\t\tcout << mx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\nconst int INF = 10000000;\nint dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1};\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<double, double> P;\n\n/** Problem1132 : Circle and Point **/\nint main()\n{\n\tint N, ans;\n\tdouble X, Y;\n\tvector<P> points;\n\t\n\twhile (cin>>N, N) {\n\t\tans=0;\n\t\t\n\t\tpoints.clear();\n\t\trep(i, N) {\n\t\t\tcin >> X >> Y;\n\t\t\tpoints.push_back(P(X, Y));\n\t\t}\n\n\t\tfor (double x=0.0; x<=10.0; x+=0.1) {\n\t\t\tfor (double y=0.0; y<=10.0; y+=0.1) {\n\t\t\t\tint num=0;\n\t\t\t\tvector<P>::iterator it = points.begin();\n\t\t\t\tfor (; it!=points.end(); it++) {\n\t\t\t\t\tdouble d = (it->first-x)*(it->first-x) + (it->second-y)*(it->second-y);\n\t\t\t\t\tif (d<1) {\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ans<num)\n\t\t\t\t\tans = num;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////\n///   template   ///\n////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\nusing namespace std;\n\n//// MACRO ////\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define allof(c) c.begin(), c.end()\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define EPS 1e-10\n#define INF 1000000000\n\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n#define PREDIACTE(t,a) [](const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) [](const t & a, const t & b) -> bool\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n//// iota iterator ////\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n//// geo ////\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\npair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n//// bit ////\n#ifdef _MSC_VER\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n//// graph ////\nstruct Path\n{\n\tint from;\n\tint to;\n\tdouble cost;\n\tPath(int from = 0, int to = 0, double cost = 0) : from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\npair<double, vector<int>> prim(const vector<vector<double>> &costTable)\n{\n\tint N = costTable.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(0, 0, 0));\n\n\tvector<int> parent(N, -1);\n\tdouble totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(Path(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\npair<vector<double>, vector<int>> dijkstra(const vector<vector<Path>> &routes, int start = 0, int goal = -1)\n{\n\tint N = routes.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<double> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tPath next = Path(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n//// i/o ////\ntemplate <class T>\nclass vevector : public vector<vector<T>>\n{\npublic:\n\tvevector(int n = 0, int m = 0) : vector<vector<T>>(n, vector<T>(m)) { };\n\tvevector(int n, int m, const T &initial) : vector<vector<T>>(n, vector<T>(m, initial)) { };\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(read<T>(read<int>())); return v; }\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T> void write(const T &t, const T &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\ntemplate<class T>\nistream & operator>>(istream & in, complex<T> & n) { T r, i; in >> r >> i; n = complex<T>(r, i); return in; }\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\t// freopen(\"A.in\", \"r\", stdin);\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tauto testcases = INF; // read<int>();\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\n\t\tauto ps = read<P2>(N);\n\n\t\tint result = N;\n\t\tREP(i_, N) FOR(j_, i_ + 1, N)\n\t\t{\n\t\t\tconst P2 i = ps[i_], j = ps[j_];\n\t\t\tdouble r = 1;\n\t\t\tif (abs(i - j) - 2 * r > -EPS) { continue; } // 遠すぎて円が作れない\n\n\t\t\tauto c = get_same_distance_points(i, j, r); // i と j から ちょうど r 離れた点\n\n\t\t\tauto c1 = Circle(c.first, r), c2 = Circle(c.second, r);\n\t\t\tresult = max<int>(result, count_if(allof(ps), [c1, r](P2 p) { return c1.Contains(p); }));\n\t\t\tresult = max<int>(result, count_if(allof(ps), [c2, r](P2 p) { return c2.Contains(p); }));\n\t\t}\n\n\t\twrite(result);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nstruct Point{\n    double x,y;\n};\n\nvoid func(int N){\n\n    Point point[N];\n    double x_min = 100,y_min = 100,x_max = -1,y_max = -1;\n\n    for(int i = 0; i < N; i++){\n        scanf(\"%lf %lf\",&point[i].x,&point[i].y);\n        x_min = min(point[i].x,x_min);\n        y_min = min(point[i].y,y_min);\n        x_max = max(point[i].x,x_max);\n        y_max = max(point[i].y,y_max);\n    }\n\n    if(x_min > 1)x_min -= 0.03;\n    if(y_min > 1)y_min -= 0.03;\n    if(x_max < 9)x_max += 0.03;\n    if(y_max < 9)y_max += 0.03;\n\n    int count,max_count = 0;\n\n    for(double y = y_min; y <= y_max; y += 0.01){\n        for(double x = x_min; x <= x_max; x += 0.01){\n            count = 0;\n            for(int i = 0; i < N; i++){\n                if(sqrt((x-point[i].x)*(x-point[i].x)+(y-point[i].y)*(y-point[i].y)) <= 1.0)count++;\n            }\n            max_count = max(max_count,count);\n        }\n    }\n\n    printf(\"%d\\n\",max_count);\n}\n\n\nint main(){\n\n    int N;\n\n    while(true){\n        scanf(\"%d\",&N);\n        if(N == 0)break;\n\n        func(N);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cassert>\nusing namespace std;\n\nusing ld = long double;\n\nconstexpr ld eps = 1e-9;\n\nnamespace geometry2d {\n\n\nusing point = std::complex<long double>;\n\nbool eq(long double a, long double b) {\n    return (std::abs(a-b) < eps);\n}\n\n\nlong double dot(point a, point b) {\n    return std::real(std::conj(a) * b);\n}\n\nlong double cross(point a, point b) {\n    return std::imag(std::conj(a) * b);\n}\n\n\nclass segment {\npublic:\n    segment()\n        : a(point(0, 0)),\n          b(point(0, 0))\n    {}\n    segment(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n\n    point a, b;\n};\n\nclass line {\npublic:\n    line()\n        : a(point(0, 0)), b(point(0, 0))\n    {}\n    line(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n    line(segment s)\n        : a(s.a), b(s.b)\n    {}\n\n    point a, b;\n};\n\nclass circle {\npublic:\n    circle()\n        : p(point(0, 0)), r(0)\n    {}\n    circle(point p_, long double r_)\n        : p(p_), r(r_)\n    {}\n\n    point p;\n    long double r;\n};\n\n\nint ccw(point a, point b, point c) {\n    b -= a; c -= a;\n    if(cross(b, c) > eps)           return 1;  // a -> b -> c : counterclockwise\n    if(cross(b, c) < -eps)          return -1; // a -> b -> c : clockwise\n    if(dot(b, c) < 0)               return 2;  // c -> a -> b : line\n    if(std::norm(b) < std::norm(c)) return -2; // a -> b -> c : line\n    return 0;                                  // a -> c -> b : line\n}\n\n\nbool isis_ll(line l, line m) {\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(line l, segment s) {\n    return (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - s.a) < eps);\n}\n\nbool isis_lp(line l, point p) {\n    return (std::abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(segment s, point p) {\n    return (std::abs(s.a - p) + std::abs(s.b - p) - std::abs(s.b - s.a) < eps);\n}\n\nbool isis_ss(segment s, segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n        && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n\npoint proj(line l, point p) {\n    long double t = dot(p - l.a, l.a - l.b) / std::norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\npoint is_ll(line s, line t) {\n    point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nlong double dist_lp(line l, point p) {\n    return std::abs(p - proj(l, p));\n}\n\nlong double dist_ll(line l, line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nlong double dist_ls(line l, segment s) {\n    return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nlong double dist_sp(segment s, point p) {\n    point r = proj(line(s), p);\n    return isis_sp(s, r) ? std::abs(r - p) : std::min(std::abs(s.a - p), std::abs(s.b - p));\n}\n\nlong double dist_ss(segment s, segment t) {\n    if(isis_ss(s, t)) return 0;\n    long double d1 = std::min(dist_sp(s, t.a), dist_sp(s, t.b));\n    long double d2 = std::min(dist_sp(t, s.a), dist_sp(t, s.b));\n    return std::min(d1, d2);\n}\n\n\nstd::vector<point> is_cc(circle const& c1, circle const& c2) {\n    std::vector<point> res;\n    ld d = std::abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if(std::abs(dfr) < eps) {\n        dfr = 0.0;\n    } else if(dfr < 0.0) {\n        return res;\n    }\n\n    ld rs = sqrt(dfr);\n    point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * point(rc, rs));\n    if(dfr != 0.0) {\n        res.push_back(c1.p + diff * point(rc, -rs));\n    }\n    return res;\n}\n\n\n} // namespace geometry2d\n\nusing namespace geometry2d;\n\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<point> points(n);\n        for(int i=0; i<n; ++i) {\n            ld x, y;\n            cin >> x >> y;\n            points[i] = point(x, y);\n        }\n        int ans = 0;\n        for(int i=0; i<n; ++i) {\n            for(int j=i+1; j<n; ++j) {\n                circle c1(points[i], 1), c2(points[j], 1);\n                auto ps = is_cc(c1, c2);\n                for(int k=0; k<ps.size(); ++k) {\n                    int cnt = 0;\n                    for(int l=0; l<n; ++l) {\n                        if(abs(ps[k] - points[l]) - 1.0 > eps) {\n                            continue;\n                        }\n                        cnt++;\n                    }\n                    ans = max(ans, cnt);\n                }\n            }\n        }\n        cout << (ans == 0 ? 1 : ans) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double r = 1.0;\nconst double PI = acos(-1.0);\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y) : x(x), y(y) {}\n};\ninline double Distance2(const Point &a, const Point &b) {\n    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    std::random_device rnd;\n    std::mt19937 mt(rnd());\n    std::uniform_real_distribution<> rand100(0.0, 10.0);\n\n    while (cin >> n, n) {\n        // Input\n        vector<Point> p(n);\n        for (int i = 0; i < n; ++i)\n            cin >> p[i].x >> p[i].y;\n\n        // Solve\n        int ans = 1;\n        auto start = std::chrono::high_resolution_clock::now();\n        auto end = std::chrono::high_resolution_clock::now();\n        auto take_time = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n\n        while (true) {\n            end = std::chrono::high_resolution_clock::now();\n            take_time = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n            if (380 < take_time.count())\n                break;\n\n            for (int i = 0; i < 10; ++i) {\n                Point c(rand100(mt), rand100(mt));\n                int num = 0;\n                for (int j = 0; j < n; ++j) {\n                    double d = Distance2(p[j], c);\n                    if (d <= 1.0)\n                        ++num;\n                }\n                ans = max(ans, num);\n            }\n        }\n\n        // Output\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <map>\n\n// +, -, *, /, sqrt, >, >=, <, <=, ==\ntemplate<typename T>\nclass Point2 {\npublic:\n  Point2() {}\n  Point2(T x_, T y_) : x(x_), y(y_) {}\n  Point2 operator * (T b) { return Point2<T>(x*b, y*b); };\n  Point2 operator / (T b) { return Point2<T>(x/b, y/b); };\n  T x, y;\n};\n\nclass Mean_ {\npublic:\n  template<typename T>\n  Point2<T> operator() (Point2<T> a, Point2<T> b) {\n    return Point2<T>((a.x + b.x) / 2.0, (a.y + b.y) / 2.0);\n  }\n};\nMean_ Mean;\n\nclass Distance_ {\npublic:\n  template<typename T>\n  T operator () (Point2<T> a, Point2<T> b) {\n    T dx = a.x - b.x;\n    T dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n  }\n};\nDistance_ Distance;\n\nclass Heron_ {\npublic:\n  template<typename T>\n  T operator () (T a, T b, T c) {\n    T s = (a + b + c) / 2.0;\n    return sqrt(s*(s-a)*(s-b)*(s-c));\n  }\n};\nHeron_ Heron;\n\nclass CenterCoord_ {\npublic:\n  template<typename T>\n  bool check(Point2<T> a, Point2<T> b, T r) {\n    T dist = Distance(a, b);\n    if( dist >= r * 2.0 ) return false;\n    return true;\n  }\n  template<typename T>\n  std::pair<Point2<T>, Point2<T> > operator () (Point2<T> a, Point2<T> b, T r) {\n    T dist = Distance(a, b);\n    assert( dist < 2.0 );\n    auto t1 = Mean(a, b);\n    auto t2 = Point2<T>((a.x - b.x) / dist, (a.y - b.y) / dist);\n    T h = 2 * Heron(r, r, dist) / dist;\n    auto t3 = t2 * h;\n    auto c1 = Point2<T>(t1.x + t3.y, t1.y - t3.x);\n    auto c2 = Point2<T>(t1.x - t3.y, t1.y + t3.x);\n    return std::pair<Point2<T>, Point2<T> >(c1, c2);\n  }\n};\nCenterCoord_ CenterCoord;\n\nclass InCircle_ {\npublic:\n  template<typename T>\n  bool operator () (Point2<T> center, T r, Point2<T> target) {\n    return Distance(center, target) <= r;\n  }\n};\nInCircle_ InCircle;\n\nint n;\nPoint2<double> p[512];\n\nvoid init() {\n  for(int i = 0; i < (int)512; ++i) {\n    p[i].x = p[i].y = 0.0;\n  }\n} \n\n\nclass solve_ {\npublic:\n  int operator() (void) {\n    int res = 1;\n    for(int i = 0; i < (int)n; ++i) {\n      for(int j = 0; j < (int)i; ++j) {\n        res = std::max(res, CountPoints(i, j));\n      }\n    }\n    return res;\n  }\n  int CountPoints(int i, int j) {\n    if( not CenterCoord.check(p[i], p[j], 1.0) ) return 0;\n    auto c12 = CenterCoord(p[i], p[j], 1.0);\n    auto c1 = c12.first;\n    auto c2 = c12.second;\n    int count1 = 0;\n    int count2 = 0;\n    for(int k = 0; k < (int)n; ++k) {\n      if( k == i or k == j ) continue;\n      if( InCircle(c1, 1.0, p[k]) ) {\n        count1 += 1;\n      }\n      if( InCircle(c2, 1.0, p[k]) ) {\n        count2 += 1;\n      }\n    }\n    int res = std::max(count1, count2) + 2;\n    return res;\n  }\n};\nsolve_ solve;\n\nint main() {\n  for(;;) {\n    init();\n    scanf(\"%d\", &n);\n    if( n == 0 ) break;\n    for(int i = 0; i < (int)n; ++i) {\n      scanf(\"%lf %lf\", &p[i].x, &p[i].y);\n    }\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<complex>\nusing namespace std;\n\ncomplex<double> p[300];\n\ncomplex<double> core(int a,int b){\n  complex<double> res,mid,norm;\n\n  mid = (p[a]+p[b]) / 2.0;\n\n  norm = (p[a] - p[b]) * complex<double>(0,1);\n  norm = norm / abs(norm);\n  norm = norm * sqrt(1.0 - abs(mid-p[a])*abs(mid-p[a]));\n\n  res = norm + mid;\n  return res;\n}\n  \n\nint main(){\n  int n;\n  complex<double> o,r;\n  int max,tmp;\n\n  while(1){\n    cin >> n;\n    if(!n)break;\n\n    for(int i=0;i<n;i++)cin >> p[i].real() >> p[i].imag();\n\n    max = 1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tr = p[i]-p[j];\n\tif(i!=j && r.real()*r.real() + r.imag()*r.imag() < 4.0){\n\t  o = core(i,j);\n\t  tmp = 2;\n\t  for(int k=0;k<n;k++){\n\t    if(k!=i && k!=j){\n\t      r = o-p[k];\n\t      if( r.real()*r.real() + r.imag()*r.imag() <1.0)tmp++;\n\t    }\n\t  }\n\t  if(max < tmp)max = tmp;\n\t}\n      }\n    }\n    cout << max << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (n); i ++)\n\nconst double EPS = 1e-8;\n\nint n;\ndouble x[303], y[303];\n\nint main() {\n        while (cin >> n && n) {\n                rep(i, n) cin >> x[i] >> y[i];\n                int ans = 1;\n                rep(i, n) rep(j, n) {\n                        if (i == j) continue;\n                        double dx = x[i] - x[j], dy = y[i] - y[j];\n                        double d = sqrt(dx * dx + dy * dy);\n                        if (d > 2.0 + EPS) continue;\n                        double r = sqrt(1.0 - (d / 2.0) * (d / 2.0));\n                        double vx = -dy / d * r;\n                        double vy = dx / d * r;\n                        double xx = (x[i] + x[j]) / 2.0 + vx;\n                        double yy = (y[i] + y[j]) / 2.0 + vy;\n                        int cnt = 0;\n                        rep(k, n) if ((x[k] - xx) * (x[k] - xx) + (y[k] - yy) * (y[k] - yy) < 1.0 + EPS) cnt ++;\n                        ans = max(ans, cnt);\n                }\n                cout << ans << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <deque>\n#include <utility>\n\n#define REP(i, n) FOR(i, 0, n)\n#define FOR(i, a, b) for(int i = int(a); i < int(b); ++i)\n#define RREP(i, n) RFOR(i, 0, n)\n#define RFOR(i, a, b) for(int i = int(b) - 1; i >= int(a); --i)\n\nconstexpr double EPS = 1e-7;\n\nsigned main() {\n\n\twhile (true) {\n\t\tint n;\n\t\tstd::cin >> n;\n\t\tif (n == 0) break;\n\n\t\tstd::vector<double> x(n), y(n);\n\t\tREP(i, n) std::cin >> x[i] >> y[i];\n\n\t\tint ans = 0;\n\n\t\tREP(i, n) FOR(j, i + 1, n) {\n\t\t\tdouble dist = std::hypot(x[i] - x[j], y[i] - y[j]);\n\t\t\tif (dist > 2 + EPS) continue;\n\n\t\t\t// iとjの中点m\n\t\t\tdouble mx = (x[i] + x[j]) / 2;\n\t\t\tdouble my = (y[i] + y[j]) / 2;\n\n\t\t\t// 線分ijから中心への距離\n\t\t\tdouble r = std::sqrt(1 - (dist / 2) * (dist / 2));\n\n\t\t\t// 中心c\n\t\t\tfor (int sign = -1; sign <= 1; sign += 2) {\n\t\t\t\t// 移動のベクトルv\n\t\t\t\tdouble vx = sign * r * (y[j] - y[i]) / dist;\n\t\t\t\tdouble vy = sign * r * -(x[j] - x[i]) / dist;\n\n\t\t\t\tdouble cx = mx + vx;\n\t\t\t\tdouble cy = my + vy;\n\n\t\t\t\tint cnt = 0;\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tif (std::hypot(cx - x[k], cy - y[k]) < 1 + EPS) ++cnt;\n\t\t\t\t}\n\t\t\t\tans = std::max(ans, cnt);\n\t\t\t}\n\t\t}\n\t\tstd::cout << ans << \"\\n\";\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdint>\n#include <vector>\n#include <array>\n\nusing namespace std;\n\ntypedef array<double, 2> Point;\n\n\nuint32_t specialSolve(const vector<Point> v, double centerX, double centerY)\n{\n    uint32_t cnt = 0;\n    for(const auto& p: v)\n    {\n        const auto r = sqrt(pow(p[0] - centerX, 2) + pow(p[1] - centerY, 2));\n        if(r <= 1 || abs(r - 1) <= 1.0E-5)\n            ++cnt;\n    }\n\n    return cnt;\n}\n\n\nuint32_t solve(const vector<Point>& ps)\n{\n    const auto N = ps.size();\n\n    uint32_t maxCount = 0;\n    for(uint32_t i = 0; i < N; ++i)\n    {\n        auto const x1 = ps[i][0],\n                   y1 = ps[i][1];\n\n        for(uint32_t j = i + 1; j < N; ++j)\n        {\n            auto const x2 = ps[j][0],\n                       y2 = ps[j][1];\n\n            auto const a = -(x2 - x1)/(y2 - y1);\n            auto const a2 = pow(a, 2.0);\n            auto const ds2_4 = pow(x1 - x2, 2) + pow(y1 - y2, 2);\n            auto const dt2 = 1 - ds2_4/4;\n\n            // 2点は同じ半径1の円に入ることはない\n            if(dt2 < 0)\n                continue;\n\n            auto const dx = sqrt(dt2 / (1 + a2));\n            auto const dy = dx * a;\n            auto const avgPosX = (x2 + x1) / 2,\n                       avgPosY = (y2 + y1) / 2;\n            auto const m1 = specialSolve(ps, avgPosX + dx, avgPosY + dy),\n                       m2 = specialSolve(ps, avgPosX - dx, avgPosY - dy);\n\n            if(maxCount < m1)\n                maxCount = m1;\n            if(maxCount < m2)\n                maxCount = m2;\n        }\n    }\n\n\n    return maxCount;\n}\n\n\n\nint main()\n{\n    while(1)\n    {\n        uint32_t N;\n        cin >> N;\n\n        if(N == 0)\n            break;\n\n        vector<Point> ps;\n        for(uint32_t i = 0; i < N; ++i){\n            double a, b;\n            cin >> a >> b;\n            Point p = {a, b};\n            ps.push_back(p);\n        }\n\n\n        auto ans = solve(ps);\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <limits>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS = 1e-9;\n\nbool tolerant_eq(double a, double b){ return abs(a - b) < EPS; }\n\nstruct Point {\n\tdouble x, y;\n\texplicit Point(const double &x = 0.0, const double &y = 0.0) :\n\t\tx(x), y(y)\n\t{ }\n\n\tstatic Point invalid(){\n\t\tdouble qnan = numeric_limits<double>::quiet_NaN();\n\t\treturn Point(qnan, qnan);\n\t}\n\tbool is_valid() const { return !(isnan(x) || isnan(y)); }\n\n\tPoint operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n\tPoint &operator+=(const Point &p){ return *this = *this + p; }\n\tPoint operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n\tPoint &operator-=(const Point &p){ return *this = *this - p; }\n\tPoint operator*(double s) const { return Point(x * s, y * s); }\n\tPoint &operator*=(double s){ return *this = *this * s; }\n\tPoint operator/(double s) const { return Point(x / s, y / s); }\n\tPoint &operator/=(double s){ return *this = *this / s; }\n\n\tbool operator==(const Point &p) const { return x == p.x && y == p.y; }\n\tbool operator!=(const Point &p) const { return x != p.x || y != p.y; }\n\tbool operator<(const Point &p) const {\n\t\treturn (x == p.x) ? (y < p.y) : (x < p.x);\n\t}\n};\n\nPoint operator*(double s, const Point &p){ return p * s; }\n\nbool tolerant_eq(const Point &a, const Point &b){\n\treturn tolerant_eq(a.x, b.x) && tolerant_eq(a.y, b.y);\n}\ndouble abs(const Point &p){ return sqrt(p.x * p.x + p.y * p.y); }\nPoint unit(const Point &p){ return p / abs(p); }\nPoint ortho(const Point &p){ return Point(-p.y, p.x); }\ndouble cross(const Point &a, const Point &b){ return a.x * b.y - a.y * b.x; }\ndouble dot(const Point &a, const Point &b){ return a.x * b.x + a.y * b.y; }\nint ccw(const Point &a, const Point &b, const Point &c){\n\tPoint d = b - a, e = c - a;\n\tif(cross(d, e) > 0.0){ return 1; }\n\tif(cross(d, e) < 0.0){ return -1; }\n\tif(dot(d, e) < 0.0){ return 2; }\n\tif(abs(d) < abs(e)){ return -2; }\n\treturn 0;\n}\n\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\texplicit Circle(const Point &c = Point(), double r = 0.0) :\n\t\tc(c), r(r)\n\t{ }\n\n\tstatic Circle invalid(){\n\t\tdouble qnan = numeric_limits<double>::quiet_NaN();\n\t\treturn Circle(Point::invalid(), qnan);\n\t}\n\tbool is_valid() const { return c.is_valid() && !isnan(r); }\n\n\tbool operator<(const Circle &i) const {\n\t\treturn (r == i.r) ? (c < i.c) : (r < i.r);\n\t}\n};\n\nbool intersect(const Circle &a, const Circle &b){\n\treturn abs(a.c - b.c) <= a.r + b.r;\n}\n\nvector<Point> crosspoint(const Circle &a, const Circle &b){\n\tif(!intersect(a, b)){ return vector<Point>(); }\n\tdouble l = abs(b.c - a.c), s = (l + a.r + b.r) / 2.0;\n\tdouble S = sqrt(s * (s - l) * (s - a.r) * (s - b.r));\n\tdouble d = (S * 2) / l, t = sqrt(a.r * a.r - d * d);\n\tPoint v = t * unit(b.c - a.c);\n\tPoint w = d * unit(ortho(v));\n\tPoint x = a.c + v + w, y = a.c + v - w;\n\tif(tolerant_eq(x, y)){ return vector<Point>(1, x); }\n\tvector<Point> ans(2); ans[0] = x; ans[1] = y;\n\treturn ans;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcout << setiosflags(ios::fixed) << setprecision(10);\n\twhile(true){\n\t\tint N;\n\t\tcin >> N;\n\t\tif(N == 0){ break; }\n\t\tvector<Point> points(N);\n\t\tfor(int i = 0; i < N; ++i){ cin >> points[i].x >> points[i].y; }\n\t\tint answer = 0;\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tCircle ci(points[i], 1.0);\n\t\t\tfor(int j = i + 1; j < N; ++j){\n\t\t\t\tCircle cj(points[j], 1.0);\n\t\t\t\tif(!intersect(ci, cj)){ continue; }\n\t\t\t\tvector<Point> cp = crosspoint(ci, cj);\n\t\t\t\tfor(int k = 0; k < cp.size(); ++k){\n\t\t\t\t\tPoint c = cp[k];\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tfor(int l = 0; l < N; ++l){\n\t\t\t\t\t\tif(abs(c - points[l]) <= 1.0 + EPS){ ++count; }\n\t\t\t\t\t}\n\t\t\t\t\tanswer = max(answer, count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing VI = vector<ll>;\nusing VV = vector<VI>;\nusing VS = vector<string>;\nusing PII = pair<ll, ll>;\n\n// tourist set\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << '\\n'; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n// tourist set end\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i,b) FOR(i, 0, b)\n#define ALL(v) (v).begin(), (v).end()\n#define p(s) cout<<(s)<<'\\n'\n#define p2(s, t) cout << (s) << \" \" << (t) << '\\n'\n#define br() p(\"\")\n#define pn(s) cout << (#s) << \" \" << (s) << '\\n'\n#define p_yes() p(\"YES\")\n#define p_no() p(\"NO\")\n#define SZ(x) ((int)(x).size())\n#define SORT(A) sort(ALL(A))\n#define RSORT(A) sort(ALL(A), greater<ll>())\n#define MP make_pair\n\nvoid no(){p_no(); exit(0);}\nvoid yes(){p_yes(); exit(0);}\n\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e18;\nconst double PI = acos(-1);\n\ntypedef complex<double> C;\n#define X real()\n#define Y imag()\n\n// 2点を与えると, それを通る半径rの円の中央2つを返す\nvector<C> f(C a, C b, double r){\n  vector<C> ret;\n  \n  // a, bの距離が大きすぎると作れない\n  {\n    double d = abs(a-b);\n    if(d>2*r) return ret;\n  }\n\n  C c = (a+b)/2.0;\n\n  double temp = r*r - norm(a-c);\n  double x = sqrt(temp);\n\n  //中央に向かうベクトル\n  C d = c-a;\n  C e = {-d.Y, d.X}; // 垂直ベクトル\n  C f = e / abs(e); // 単位ベクトル\n\n  ret.push_back(c+x*f);\n  ret.push_back(c-x*f);\n\n  return ret;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // input\n    ll N;\n\n    while(cin>>N){\n      if(N==0) return 0;\n\n      vector<C> V;\n      rep(i, N){\n        double a, b; cin >> a >> b;\n        V.push_back(C(a,b));\n      }\n      ll ma = 1;\n      // 2点を選ぶ\n      rep(i, N){\n        FOR(j, i+1, N){\n          auto A = f(V[i], V[j], 1);\n          for(auto center : A){\n            ll cnt = 0;\n            for(auto c : V){\n              double d = abs(center - c);\n              d -= 0.0001;\n              if(1>=d) cnt++;\n            }\n            chmax(ma, cnt);\n          }\n        }\n      }\n      p(ma);\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                     #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,pa>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                  \n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                             double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \nbool parareru(Point a,Point b,Point c,Point d){\n//\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n\treturn abs(cross(a-b,d-c))<EPS;\n}\ndouble distance_ls_p(Point a, Point b, Point c) {\n  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n  return abs(cross(b-a, c-a)) / (b-a).absv();\n}\nbool is_intersected_ls(Segment a,Segment b) {\n\tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n//\t\tcout<<\"sss\"<<endl;\n\t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n\t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n\t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n\t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n\t\treturn false;\n\t}\n  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n}\n\ndouble segment_dis(Segment a,Segment b){\n\tif(is_intersected_ls(a,b))return 0;\n\tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n\tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n\treturn r;\n}\n\n\n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\n\n\n\nPoint p[310];\nint n;\n\nint ch(int a,int b){\n\tif((p[a]-p[b]).absv()>2.0) return 0;\n\tPoint m=(p[a]+p[b])/2.0;\n\tPoint e=(p[b]-p[a])/(p[b]-p[a]).absv();\n\tPoint g;\n\tg.x=e.y;\n\tg.y=-e.x;\n\tdouble d=(p[a]-p[b]).absv()/2.0;\n\tdouble dd=sqrt(1.0-d*d);\n\tPoint s1=m+g*dd,s2=m-g*dd;\n\tint co=0,co2=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(i==a||i==b) continue;\n\t\tif((p[i]-s1).absv()<1)co++;\n\t\tif((p[i]-s2).absv()<1)co2++;\n\t}\n\t\n\treturn 2+max(co,co2);\n\t\n}\n\nsigned main(){\n\n\tint cnt=0;\n\twhile(1){\n\t\t\n\t\tcin>>n;\n\t\tif(n==0) return 0;\n//cout<<cnt<<\" \"<<n<<endl;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>p[i].x>>p[i].y;\n\t\t}\n\t\tif(n==1){\n\t\t\tcout<<1<<endl;\n\t\t}\n\t\telse{\n\t\t\tint ans=1;\n\t\t\tfor(int i=0;i<n;i++)for(int j=i+1;j<n;j++){\n\t\t\t\tans=max(ans,ch(i,j));\n\t\t\t}\n\t\t\tcout<<ans<<endl;\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define LP(i,n) for(int i = 0; i < n; i++)\n\nusing namespace std;\ntypedef pair<double,double> P;\n\ndouble Dist(double x1[], double x2[]){\n\treturn pow((x1[0]-x2[0])*(x1[0]-x2[0])+(x1[1]-x2[1])*(x1[1]-x2[1]),0.5);\n\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\twhile(n){\n\t\tint mx = 0;\n\t\tif(n >= 2){\n\t\t\tP p[300];\n\t\t\tLP(i,n){\n\t\t\t\tcin >> p[i].first >> p[i].second;\n\t\t\t}\n\t\t\tsort(p,p+n);\n\t\t\tdouble x[300][2];\n\t\t\tLP(i,n){\n\t\t\t\tx[i][0] = p[i].first;\n\t\t\t\tx[i][1] = p[i].second;\n\t\t\t}\n\t\t\tdouble dist[300][300];\n\t\t\tLP(i,n){\n\t\t\t\tLP(j,n){\n\t\t\t\t\tdist[i][j] = Dist(x[i],x[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tLP(i,n){\n\t\t\t\tfor(int j = i+1; j < n; j++){\n\t\t\t\t\tif(x[j][0]-x[i][0] > 2){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(dist[i][j] <= 2){\n\t\t\t\t\t\t\tdouble m[] = {(x[j][0]+x[i][0])/2,(x[j][1]+x[i][1])/2};\n\t\t\t\t\t\t\tdouble d[] = {x[j][1]-x[i][1],-x[j][0]+x[i][0]};\n\t\t\t\t\t\t\tdouble O[] = {0,0};\n\t\t\t\t\t\t\tdouble _d = Dist(d,O);\n\t\t\t\t\t\t\tLP(k,2){\n\t\t\t\t\t\t\t\td[k] *= (pow(_d,-2)-0.25);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdouble o[2][2];\n\t\t\t\t\t\t\tLP(k,2){\n\t\t\t\t\t\t\t\tLP(l,2){\n\t\t\t\t\t\t\t\t\to[k][l] = m[l];\n\t\t\t\t\t\t\t\t\tif(k) o[k][l] += d[l];\n\t\t\t\t\t\t\t\t\telse o[k][l] -= d[l];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tLP(k,2){\n\t\t\t\t\t\t\t\tint s = 0;\n\t\t\t\t\t\t\t\tfor(int l = i; l < j; l++){\n\t\t\t\t\t\t\t\t\tif(Dist(x[l],o[k]) <= 1) s++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int l = i-1; 0<=l && x[i][0]-x[l][0] <= 1;l--){\n\t\t\t\t\t\t\t\t\tif(Dist(x[l],o[k]) <= 1) s++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int l = j; l < n && x[l][0]-x[j][0] <= 1; l++){\n\t\t\t\t\t\t\t\t\tif(Dist(x[l],o[k]) <= 1) s++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmx = max(mx,s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else mx = 1;\n\t\tcout << mx << endl;\n\t\tcin >> n;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double r = 1.0;\nconst double PI = acos(-1.0);\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y) : x(x), y(y) {}\n};\ninline double Distance2(const Point &a, const Point &b) {\n    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    std::random_device rnd;\n    std::mt19937 mt(rnd());\n    std::uniform_real_distribution<> rand100(0.0, 10.0);\n\n    while (cin >> n, n) {\n        // Input\n        vector<Point> p(n);\n        for (int i = 0; i < n; ++i)\n            cin >> p[i].x >> p[i].y;\n\n        // Solve\n        int ans = 1;\n        auto start = std::chrono::high_resolution_clock::now();\n        auto end = std::chrono::high_resolution_clock::now();\n        auto take_time = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n\n        while (true) {\n            end = std::chrono::high_resolution_clock::now();\n            take_time = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n            if (400 < take_time.count())\n                break;\n\n            for (int i = 0; i < 10; ++i) {\n                Point c(rand100(mt), rand100(mt));\n                int num = 0;\n                for (int j = 0; j < n; ++j) {\n                    double d = Distance2(p[j], c);\n                    if (d <= 1.0)\n                        ++num;\n                }\n                ans = max(ans, num);\n            }\n        }\n\n        // Output\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double R;//double long double の切り替え cmathの関数はオーバーロードに対応しているので問題ない\ntypedef complex<R> Point;\ntypedef pair<Point , Point> Line;\ntypedef pair<Point ,R > Circle;\ntypedef vector<Point> Poly;\n\n#define EPS (1e-10)//誤差\n#define EQ(a,b) (abs((a)-(b)) < EPS)//２つの実数が等しいか\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )//２つのベクトルが等しいか\n#define ft first\n#define sd second\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nR dot(Point a,Point b){//内積ok\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nR cross(Point a,Point b){//外積ok\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\n\n\nbool is_orthogonal(Line a,Line b){//2直線の直行判定ok\n    return EQ(dot(a.ft - a.sd,b.ft - b.sd),0.0);\n}\nbool is_parallel(Line a,Line b){//2直線の並行判定ok\n    return EQ(cross(a.ft - a.sd,b.ft - b.sd),0.0);\n}\n\n\n\n////////////////////交差判定\nint ccw(Point a,Point b,Point c){//ok\n    b -= a; c -= a;\n    if(cross(b,c) > EPS) return 1;//a→bで反時計周りに折れてb→c\n    if(cross(b,c) < -EPS) return -1;//a→bで時計周りに折れてb→c\n    if(dot(b,c) < -EPS) return 2;//c--a--b on same line\n    if(norm(c) - norm(b) > EPS) return -2;//a--b--c(absじゃなくて二乗するのは差が出やすいから?)\n    return 0;//a--c--bまたはb==c\n}\n\nbool is_intersection_ll(Line l,Line m){//２つの直線が交わるかok\n    return abs(cross(l.sd - l.ft,m.sd - m.ft)) > EPS || //平行でない\n        abs(cross(l.sd - l.ft,m.ft - l.ft)) < EPS; //平行だが同じ線\n}\n\nbool is_intersection_ls(Line l,Line s){//直線lと線分sが交わるか\n    return cross(l.sd - l.ft, s.ft-l.ft)*       // s[0] is left of l\n        cross(l.sd - l.ft, s.sd - l.ft) < EPS; // s[1] is right of l\n}\n\nbool is_intersection_lp(Line l,Point p){//直線lと点pが交わるか\n    return abs(cross(l.sd - p,l.ft - p));\n}\n\nbool is_intersection_ss(Line a,Line b){//２つの線分が交わるかok\n    return ccw(a.ft,a.sd,b.ft)*ccw(a.ft,a.sd,b.sd) <= 0 && ccw(b.ft,b.sd,a.ft)*ccw(b.ft,b.sd,a.sd) <= 0;\n}\n\nbool is_intersection_sp(Line s,Point p){//線分と点の交差判定 三角不等式の利用\n    return abs(s.ft - p) + abs(s.sd - p) - abs(s.ft - s.sd) < EPS;\n}\n\n\nbool intersection_cc(Circle c1,Circle c2){//２つの円の交差判定ok\n    return abs(c1.ft - c2.ft) - (c1.sd + c2.sd) < -EPS;\n}\n\n\n/////////////距離\nR dis_lp(Line l,Point p){//直線lと点pの距離ok\n    return abs(cross(l.sd - l.ft,p - l.ft)) / abs(l.sd - l.ft);\n}\n\nR dis_ll(Line l,Line m){//２つの直線の距離\n    return is_intersection_ll(l,m) ? 0.0 : dis_lp(l,m.ft);\n}\n\nR dis_ls(Line l,Line s){//直線lと線分sの距離\n    if(is_intersection_ls(l,s)) return 0.0;\n    return min(dis_lp(l,s.ft),dis_lp(l,s.sd));\n}\n\nR dis_sp(Line s,Point p){//線分sと点pの距離ok\n    if(dot(s.sd - s.ft,p - s.ft) < EPS) return abs(p - s.ft);\n    if(dot(s.ft - s.sd,p - s.sd) < EPS) return abs(p - s.sd);\n    return dis_lp(s,p);\n}\n\nR dis_ss(Line s,Line t){//２つの線分の距離ok\n    if(is_intersection_ss(s,t)) return 0.0;\n    return min(min(dis_sp(s,t.ft),dis_sp(s,t.sd)),\n            min(dis_sp(t,s.ft),dis_sp(t,s.sd)));\n}\n\n\n\n//////////////射影と反射\nPoint projection(Line l,Point p){//射影を求めるok\n    R t = dot(p - l.ft,l.ft - l.sd) / norm(l.ft - l.sd);\n    return l.ft + t * (l.ft - l.sd);\n}\n\nPoint reflection(Line l,Point p){//反射を求めるok\n    return p + (R)2.0 * (projection(l,p) - p);\n}\n\n//////////////垂直なベクトル\nPoint vertical_vec(Point v) {\n    return Point(-v.imag(),v.real());\n}\n\n//////////////ヴェクタを正規化\nPoint normalized(Point v) {\n    R a = abs(v);\n    return v / a;\n}\n\n//////////////交点(交差する保証してないときは交差判定してからつかってね)\n\nPoint intersection_ll(Line l,Line m){//交差判定してるなら線分にも使えるok\n    R A = cross(l.sd - l.ft,m.sd - m.ft);\n    R B = cross(l.sd - l.ft,l.sd - m.ft);\n    if(abs(A) < EPS && abs(B) < EPS) return m.ft;//同じ線\n    //if(abs(A) < EPS)assert(false);//並行で交点なし\n    return m.ft + B / A * (m.sd - m.ft);\n}\n\nLine intersection_of_two_circles(Circle c1,Circle c2){//ok ２つの円の交点をLineに入れて返す(r1 + r2 > sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2))を満たす必要があるok\n    R a =  abs(c2.ft - c1.ft);\n    R b = c1.sd;\n    R c = c2.sd;\n\n    R rc = (a  * a + b * b - c * c) / (2.0 * a);\n    R rs = sqrt(b * b - rc * rc);//C++ ではオーバーロードが可能であるため、sqrt または float 型を受け取る long double のオーバーロードを呼び出すことができます。 C プログラムでは、sqrt は常に double を受け取って返します。\n    Point diff = (c2.ft - c1.ft) / a;\n\n    Line p ;\n    p.ft = c1.ft + diff * rc + diff * Point(0,1) * rs;\n    p.sd = c1.ft + diff * rc + diff * Point(0,-1) * rs;\n\n    return p;\n}\n\n\n/////////////////////////polygon\n\n#define currP(P,i) P[(i) % P.size()]//今の頂点\n#define nextP(P,i) P[((i) + 1)%P.size()]//次の頂点\n\nint is_contains_p_in_Poly(Poly po,Point p){//点が多角形の内部(1)、境界(-1)、外部(0)のどこにあるかを判定ok\n    bool in = false;\n    REP(i,po.size()){\n        Point a = currP(po,i) - p,b = nextP(po,i) - p;\n        if(a.imag() > b.imag())swap(a,b);\n        if(a.imag() < EPS && EPS < b.imag())\n            if(cross(a,b) < -EPS) in = !in;\n        if(EQ(cross(a,b),0.0) && dot(a,b) < EPS)return  -1;\n    }\n    return in;\n}\n\nR area2(Poly po){//多角形の面積の二倍を求めるok\n    R A = 0.0;\n    REP(i,po.size())\n        A += cross(currP(po,i),nextP(po, i));\n    return A;\n}\n\n\n\n\n///////////////////////////凸\n\nbool comp_complex_real(Point a,Point b){//x→yの辞書順ok\n    if(EQ(a.real(),b.real()))\n        return b.imag() - a.imag() > EPS;\n    return b.real() - a.real() > EPS;\n}\n\nPoly convex_hull(Poly ps){//凸包ok\n    int n = ps.size(),k = 0;\n    sort(ps.begin(),ps.end(),comp_complex_real);\n    Poly ch(2*n);\n    for(int i = 0;i < n;ch[k++] = ps[i++])// lower-hull\n        while(k >= 2 && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0 && ccw(ch[k - 2],ch[k - 1],ps[i]) > -2) --k;//３つ目の条件は180度を含むときのみ必要\n    for(int i = n - 2,t = k + 1;i >= 0;ch[k++] = ps[i--])//upper-hull\n        while(k >= t && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0 && ccw(ch[k - 2],ch[k - 1],ps[i]) > -2) --k;//上に同じ\n    ch.resize(k - 1);\n    return ch;\n}\n#define prevP(P, i) P[(i+P.size()-1) % P.size()]\nbool isconvex(Poly P){//凸性判定時計回り反時計周りに対応\n    bool cl = false,ccl = false;\n    for(int i = 0;i < P.size();++i){\n        int c = ccw(prevP(P,i),currP(P,i),nextP(P,i));\n        if(c == -2)continue;//180度を含むときのみ　360度も含むときはc == -2 || c == 0\n        if(c == 1)ccl = true;\n        else if(c == 2)cl = true;\n        else return false;\n    }\n    return !(cl && ccl);\n}\nPoint p[1000];\nint n;\n\nint inner(Point c) {\n    int ret = 0;\n    REP(i,n) {\n        if(abs(c - p[i]) <= 1.0) {\n            ret++;\n        }\n    }\n    return ret;\n}\n\nint main(){\n    while(true) {\n        cin >> n;\n        if(n == 0)break;\n        REP(i,n) {\n            double x,y;\n\n            cin >> x >> y;\n\n            p[i] = Point(x,y);\n        }\n        int ans = 0;\n\n        REP(i,n) {\n            FOR(j,i+1,n) {\n                Point a = p[i];\n                Point b = p[j];\n\n                Point x = b - a;\n\n                Point y = vertical_vec(x);\n                y = normalized(y);\n\n                R c = abs(x) / 2;\n\n                if(c > 1)continue;\n\n                R d = sqrt(1 - c * c);\n\n                y *= d;\n\n                Point m = (a  + b) / 2.0;\n                ans = max(ans,inner(m+y));\n                ans = max(ans,inner(m-y));\n\n\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define mp            make_pair\n#define pb            push_back\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nconst int    INF = 1000000000;\nconst ll     MOD = 1000000007LL;\nconst double EPS = 1E-12;\n\ntemplate<typename T> T add(T x, T y){ if(abs(x+y) < EPS*(abs(x)+abs(y))) return 0; return x + y; }\ntemplate<typename T> inline bool semieq(T x, T y){ return abs(x - y) < EPS; }\ntemplate<typename T> inline bool semige(T x, T y){ return y - x < -EPS; }\ntemplate<typename T> inline bool semile(T x, T y){ return x - y < -EPS; }\n\n\nstruct Point : public complex<double>\n{\npublic:\n  Point() { this->real(0);  this->imag(0); }\n  Point(const double& x, const double& y) { this->real(x);  this->imag(y); }\n  Point(const complex<double> w)  { this->real(w.real());  this->imag(w.imag()); }\n  inline double dot(Point p){ return (conj(*this) * p).real(); }  // 内積\n  inline double det(Point p){ return (conj(*this) * p).imag(); }  // 外積\n};\n\nnamespace std\n{\n  inline bool operator < (const Point& a, const Point& b)\n  {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ntypedef vector<Point> Polygon;\ninline Point currPoint(vector<Point> P, int i){ return P[i]; }\ninline Point nextPoint(vector<Point> P, int i){ return P[(i+1)%P.size()]; }\ninline Point diffPoint(vector<Point> P, int i){ return nextPoint(P, i) - currPoint(P, i); }\n\n\nstruct Circle : Point\n{\nprivate:\n  Point p;\n  double r;\n\npublic:\n  Circle(Point p, double r) : p(p), r(r) {}\n  Circle(double x, double y, double r) : p(Point(x, y)), r(r) {}\n  inline Point center(){ return this->p; }\n  inline double radius(){ return this->r; }\n};\n\nint intersectionDeterminationOfCC(Circle A, Circle B)\n{\n  double d = abs(A.center() - B.center());\n  if(semile(d, A.radius() - B.radius())) return  1;  // B in A\n  if(semile(d, B.radius() - A.radius())) return -1;  // A in B\n  if(semieq(d, A.radius() - B.radius())) return  2;  // B in A（内接）\n  if(semieq(d, B.radius() - A.radius())) return -2;  // A in B（内接）\n  if(semige(d, A.radius() + B.radius())) return  3;  // 交わらない\n  if(semieq(d, A.radius() + B.radius())) return -3;  // 外接\n  return 4;  // 交わっている\n}\n\n\n// 交点を重複を許して丁度二つ返す。０個のときは事前に計算しておく。\nvector<Point> intersectionOfCC(Circle A, Circle B)\n{\n  vector<Point> ret;\n  Point p = B.center() + A.center();\n  Point d = B.center() - A.center();\n  double m = (B.radius() + A.radius()) / abs(B.center() - A.center());\n  double n = (B.radius() - A.radius()) / abs(B.center() - A.center());\n\n  double s = m * n;\n  double t = sqrt((m * m - 1.0) * (1.0 - n * n));\n\n  ret.pb((p + Point(s, -t) * d) / 2.0);\n  ret.pb((p + Point(s,  t) * d) / 2.0);\n\n  return ret;\n}\n\nconst double r = 1.0;\nint N;\ndouble x, y;\n\nint main()\n{\n  while((cin >> N) && N){\n    vector<Point> P;\n\n    rep(i, N){\n      cin >> x >> y;\n      P.pb(Point(x, y));\n    }\n\n    int res = 1;\n    rep(i, N) rep(j, i) if(!semige(abs(P[i] - P[j]), 2.0 * r)){\n      Circle A = Circle(P[i], r);\n      Circle B = Circle(P[j], r);\n      vector<Point> PP = intersectionOfCC(A, B);\n\n      vrep(v, PP){\n        int cnt = 0;\n        vrep(w, P) if(!semige(abs(*w - *v), r)) cnt += 1;\n        maxup(res, cnt);\n      }\n    }\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\ntypedef complex<double> P;\n#define PI acos(-1)\n#define EPS 1e-10\n#define INF 1e9\n\nint N;\nP p[300];\n\nint solve()\n{\n\tint ans = 1;\n\n\trep(i, 0, N) rep(j, i + 1, N)\n\t{\n\t\tdouble dd = abs(p[i] - p[j]);\n\n\t\tif (2.0 < dd - EPS) continue;\n\n\t\tP vec = p[i] - p[j];\n\t\tP m = p[i] + p[j]; m /= 2.0;\n\t\tP grad = P(-imag(vec), real(vec));\n\t\tgrad /= abs(grad);\n\n\t\tP c = m + grad * sqrt(1 - abs(vec) * abs(vec) / 4.0);\n\n\t\tint cnt = 0;\n\t\trep(k, 0, N)\n\t\t{\n\t\t\tdouble d = abs(p[k] - c);\n\t\t\tif (d <= 1.0 + EPS) cnt++;\n\t\t}\n\t\tans = max(ans, cnt);\n\n\t\tc = m - grad * sqrt(1 - abs(vec) * abs(vec) / 4.0);\n\n\t\tcnt = 0;\n\t\trep(k, 0, N)\n\t\t{\n\t\t\tdouble d = abs(p[k] - c);\n\t\t\tif (d <= 1.0 + EPS) cnt++;\n\t\t}\n\t\tans = max(ans, cnt);\n\t}\n\n\treturn ans;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (1)\n\t{\n\t\tcin >> N;\n\t\tif (N == 0) return 0;\n\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tdouble x, y; cin >> x >> y;\n\t\t\tp[i] = P(x, y);\n\t\t}\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\n#define MAX_N 310\n\nlong double x[MAX_N], y[MAX_N];\nint n, maxn;\n\nint main() {\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tmaxn = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tint sum = 0;\n\n\t\t\t\tlong double X = (x[i] + x[j]) / 2.0;\n\t\t\t\tlong double Y = (y[i] + y[j]) / 2.0;\n\n\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t{\n\t\t\t\t\tif (((x[k] - X)*(x[k] - X) + (y[k] - Y)*(y[k] - Y)) <= 1) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\n\t\t\t\tlong double X1, Y1, X2, Y2, X3, Y3, VX2, VY2, Dist, Dist2;\n\n\t\t\t\tDist = sqrtl((x[j] - x[i])*(x[j] - x[i]) + (y[j] - y[i])*(y[j] - y[i]));\n\t\t\t\tDist2 = sqrtl(4 - Dist*Dist);\n\n\t\t\t\tX2 = x[j] - x[i]; Y2 = y[j] - y[i];\n\t\t\t\tVX2 = (X2 / Dist)*Dist2 / 2; VY2 = (Y2 / Dist)*Dist2 / 2;\n\n\t\t\t\tX1 = X + VY2; Y1 = Y - VX2;\n\t\t\t\tX3 = X - VY2; Y3 = Y + VX2;\n\n\t\t\t\tsum = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (((x[k] - X1)*(x[k] - X1) + (y[k] - Y1)*(y[k] - Y1)) <= 1.0001) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\t\t\t\tsum = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (((x[k] - X3)*(x[k] - X3) + (y[k] - Y3)*(y[k] - Y3)) <= 1) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint sum = 0;\n\t\t\tlong double X = x[i];\n\t\t\tlong double Y = y[i];\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (((x[k] - X)*(x[k] - X) + (y[k] - Y)*(y[k] - Y)) <= 1) {\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxn = max(maxn, sum);\n\t\t}\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\nusing P = complex<ld>;\nconst ld eps = 1e-6;\n\nint main()\n{\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<ld> x(N), y(N);\n\t\tvector<P> p(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tp[i] = P(x[i], y[i]);\n\t\t}\n\t\tvector<P> ko;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tif (norm(p[i] - p[j]) < 4.0 + eps) {\n\t\t\t\t\tauto d = p[i] - p[j];\n\t\t\t\t\tko.push_back(p[j] + (d * (ld)0.5) + d * P(0, 1) / abs(d) * sqrtl(1 - norm(d * (ld)0.5)));\n\t\t\t\t\tko.push_back(p[j] + (d * (ld)0.5) - d * P(0, 1) / abs(d) * sqrtl(1 - norm(d * (ld)0.5)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor (auto c : ko) {\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (norm(c - p[i]) < 1.0 + eps) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = max(res, cnt);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\ndouble x[300];\ndouble y[300];\ndouble X[90000];\ndouble eps=0.000000001;\ndouble Y[90000];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\t\n\t\tint at=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=i+1;j<a;j++){\n\t\t\t\tdouble d=sqrt(1.0-((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]))/4)/sqrt(((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));\n\t\t\t\tX[at]=(x[i]+x[j])/2-d*(y[j]-y[i]);\n\t\t\t\tY[at++]=(y[i]+y[j])/2+d*(x[j]-x[i]);\n\t\t\t\tX[at]=(x[i]+x[j])/2+d*(y[j]-y[i]);\n\t\t\t\tY[at++]=(y[i]+y[j])/2-d*(x[j]-x[i]);\n\t\t\t}\n\t\t}\n\t\tint ret=1;\n\t\tfor(int i=0;i<at;i++){\n\t\t\tint val=0;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif((X[i]-x[j])*(X[i]-x[j])+(Y[i]-y[j])*(Y[i]-y[j])<1.0+eps)val++;\n\t\t\t}\n\t\t\tret=max(ret,val);\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){\n    rep(i,v.size()) os << v[i] << (i+1==v.size()?\"\":\" \");\n    return os;\n}\n\ntypedef double R;\ntypedef complex<R> P;\nR const eps = 1e-8;\nR const pi = acos(-1);\n\nint main(){\n    int n;\n    while(cin>>n && n){\n        vector<P> ps(n);\n        rep(i,n){\n            R x,y; cin >> x >> y;\n            ps[i] = P(x,y);\n        }\n        int ans = 1;\n        rep(i,n)rep(j,i){\n            P & p = ps[i];\n            P & q = ps[j];\n            R d = abs(p-q)/2;\n            if(d+eps > 1.0) continue;\n            P m = (p+q)/R(2);\n            R l = sqrt(1-d*d);\n            P c = m + (p-m)/d*l*P(0,1);\n            int cnt = 0;\n            dump(abs(c-p));\n            rep(k,n) if(abs(c-ps[k]) < 1.0+eps) cnt++;\n            ans = max(ans,cnt);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,n) loop(i,0,n)\n\nusing namespace std;\ntypedef complex<double> vec;\n\ndouble const pi = acos(-1);\ndouble const eps = 1e-6;\n\nint main(){\n    int n;\n    while (cin >> n && n){\n        vector<vec> v(n);\n        rep(i, n){\n            double x, y; cin >> x >> y;\n            vec p(x, y);\n            v[i] = p;\n        }\n\n        int ans = 1;\n        rep(i, n)rep(j, n)if (i != j){\n            vec dir = v[i] - v[j];\n            double d = abs(dir);\n            if (d > 2) continue;\n            ans = max(ans, 2);\n            double h = sqrt(1 - d*d / 4);\n            vec med = v[i] + v[j];\n            med /= 2;\n            vec c1 = polar(h, arg(dir) + pi / 2) + med;\n            vec c2 = polar(h, arg(dir) - pi / 2) + med;\n            int a1 = 0, a2 = 0;\n            rep(k, n){\n                if (abs(c1 - v[k]) <= 1) a1++;\n                if (abs(c2 - v[k]) <= 1) a2++;\n            }\n            ans = max(ans, a1);\n            ans = max(ans, a2);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\n#include<memory>\nusing namespace std;\nusing ll=long long;\n\nusing dbl = double;\nusing P = complex<dbl>;\n\nconst dbl EPS = 1e-10;\nvoid solve(int n){\n    vector<P> ps(n);\n    for(int i=0;i<n;i++){\n        dbl x,y;\n        cin>>x>>y;\n        ps[i] = {x,y};\n    }\n\n    if(n==1){\n        cout<<1<<endl;\n        return;\n    }\n    \n    auto f=[&](P center){\n        int res = 0;\n        for(auto p:ps){\n            if(abs(center-p)<=1+EPS) res++;\n        }\n        return res;\n    };\n    auto calc=[&](P a,P b){\n        if(abs(a-b)>=2+EPS) return 0;\n        P c = (a+b)/dbl(2);\n        P d = (a-b)*P(0,1);\n        dbl len = sqrt(max(1-abs(a-c)*abs(a-c),dbl(0)));\n        d = d/abs(d)*len;\n        return max(f(c+d),f(c-d));\n    };\n    int res = 1;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<i;j++){\n            res = max(res,calc(ps[i],ps[j]));\n        }\n    }\n    cout<<res<<endl;\n    return;\n}\nint main(){\n    int n;\n    while(cin>>n,n){\n        solve(n);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <complex>\n\nusing namespace std;\ntypedef long long ll;\ntypedef complex<double> Point;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nint n;\nint ans;\ndouble R;\nPoint points[3000];\npair<double, int> radian[30000];\nbool used[3000];\n\nint calc(int s) {\n  int ret = 1;\n  int m = 0;\n  REP(i, n) {\n    double d = abs(points[s] - points[i]) / 2.0;\n    if (i == s || d * 2.0 > R * 2) { continue; }\n    Point center = (points[s] + points[i]) / 2.0;\n    Point vect = (points[i] - points[s]) * Point(0, -1);\n    vect /= abs(vect);\n    double l = sqrt(R * R - d * d);\n    Point c1 = center + vect * l;\n    Point c2 = center - vect * l;\n    double arg1 = arg(c1 - points[s]) - EPS;\n    double arg2 = arg(c2 - points[s]) + EPS;\n    radian[m++] = pair<double, int>(arg1 + 0 * PI, (i + 1));\n    radian[m++] = pair<double, int>(arg2 + 0 * PI, -(i + 1));\n  }\n  if (m / 2 < ans - 1) { return 0; }\n  sort(radian, radian + m);\n  MEMSET(used, false);\n  int lsum = 1;\n  REP(iter, 2) {\n    REP(i, m) {\n      int index = abs(radian[i].second) - 1;\n      bool start = radian[i].second > 0 ? true : false;\n      if (used[index] && !start) {\n        used[index] = false;\n        lsum--;\n      } else if (!used[index] && start) {\n        used[index] = true;\n        lsum++;\n      }\n      ret = max(ret, lsum);\n    }\n  }\n  return ret;\n}\n\nint main() {\n  R = 1.0;\n  while (scanf(\"%d %lf\", &n), n) {\n    REP(i, n) {\n      double x, y;\n      scanf(\"%lf %lf\", &x, &y);\n      points[i] = Point(x, y);\n    }\n    ans = 0;\n    REP(i, n) {\n      ans = max(ans, calc(i));\n    }\n    printf(\"It is possible to cover %d points.\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\nconst double PI=3.1415926535897932;\n\nbool inC(P p, P c, double r){\n    return abs(p-c)<r+1e-8;\n}\n\nint main(){\n    int n,i,j,k,ans,cnt;\n    double x, y;\n    while(scanf(\"%d\",&n)){\n        if(n==0) break;\n        ans=0;\n        vector<P> ps(n);\n        for(i=0; i<n; i++){\n            scanf(\"%lf%lf\",&x,&y);\n            ps[i] = P(x,y);\n        }\n        for(i=0;i<n;i++)\n            for(j=i+1;j<n;j++)if(abs(ps[i]-ps[j])<2){\n                cnt=0;\n                double d=sqrt(1-abs(ps[j]-ps[i])*abs(ps[j]-ps[i])*0.25)\n                /abs(ps[j]-ps[i]);\n                P c1=(ps[i]+ps[j])/2.0+(ps[j]-ps[i])*polar(d,PI/2);\n                P c2=(ps[i]+ps[j])/2.0+(ps[j]-ps[i])*polar(d,-PI/2);\n                for(k=0;k<n;k++){\n                    cnt += inC(ps[k],c1,1.0);\n                }\n                if(cnt>ans)ans=cnt;\n                cnt=0;\n                for(k=0;k<n;k++){\n                    cnt += inC(ps[k],c2,1.0);\n                }\n                if(cnt>ans)ans=cnt;\n            }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-5;\n\nstruct Circle{\n  P c;\n  double r;\n  Circle(P c=P(0,0),double r=0):c(c),r(r){}\n};\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1=c1.r,r2=c2.r,d;\n  P p1=c1.c,p2=c2.c;\n  d=abs(p1-p2);\n  if(d<EPS&&abs(r1-r2)<EPS) return res;\n  if(r1+r2<d-EPS||d+EPS<abs(r1-r2)) return res; \n  double a=(r1*r1-r2*r2+d*d)/(2*d);\n  double h=sqrt(max(r1*r1-a*a,0.0));\n  P tmp1=p1+a/d*(p2-p1);\n  P tmp2=h/d*(p2-p1);\n  if(abs(tmp2)<EPS)res.push_back(tmp1);\n  else{\n    res.push_back(P(real(tmp1)-imag(tmp2),imag(tmp1)+real(tmp2)));\n    res.push_back(P(real(tmp1)+imag(tmp2),imag(tmp1)-real(tmp2)));\n  }\n  return res;\n}\n\ndouble getdistancepp(P a,P b){\n  return sqrt((a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag()));\n}\n\nint main(){\n  int n,ans=0;\n  double a,b;\n  P p[N];\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>a>>b;\n      p[i]=P(a,b);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tCircle c1,c2;\n\tc1.c=p[i];\n\tc2.c=p[j];\n\tc1.r=c2.r=1;\n\tvector<P> r=getIntersectCC(c1,c2);\n\tif(!r.size())continue;\n\tfor(int k=0;k<r.size();k++){\n\t  int cnt=0;\n\t  for(int l=0;l<n;l++)\n\t    if(getdistancepp(r[k],p[l])<=1+EPS)cnt++;\t    \n\t  ans=max(ans,cnt);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <utility>\n#include <stdio.h>\n\n#if 0\n  #define SPAM(a) printf a\n#else\n  #define SPAM(a) (void)0\n#endif\n\nusing namespace std;\n\n#define FLOATCONV 100000\n#define MAXDIST   200000\n#define MAXRAD    100000\n\ntypedef long long ll;\ntypedef pair<ll,ll> Point;\n\n\nvector<Point > pointList;\n\nusing namespace std;\n\nint inRange(Point A, Point B, ll num){\n    ll dx, dy, d;\n    dx = A.first - B.first;\n    dy = A.second - B.second;\n    d = hypot(dx,dy);\n    SPAM((\"                    d = %llu\\n\", d));\n    if (abs(num-d) < 10000 ){\n            SPAM((\"REALLY CLOSE\\n\"));\n    }\n    if ( num > d ){\n        return 1;\n    }\n    return 0;\n}\n\nint get_Centre(Point pA,\n               Point pB,\n               Point &pC )\n{\n   // SPAM((\"in get Centre\\n\"));\n  ll x0 = pA.first;\n  ll y0 = pA.second;\n  ll x1 = pB.first;\n  ll y1 = pB.second;\n  \n  \n  ll a, dx, dy, d, h, rx, ry;\n  ll x2, y2;\n\n  /* dx and dy are the vertical and horizontal distances between\n   * the circle centers.\n   */\n  dx = x1 - x0;\n  dy = y1 - y0;\n  //SPAM((\"dx = %llu, dy = %llu\\n\", dx, dyi));\n  ll maxradsq = (ll)MAXRAD * (ll)MAXRAD;\n  /* Determine the straight-line distance between the centers. */\n  //d = sqrt((dy*dy) + (dx*dx));\n  d = hypot(dx,dy); // Suggested by Keith Briggs\n  //SPAM(\"         d = %llu\\n\", d);\n\n  /* Check for solvability. */\n  if (d > MAXDIST)\n  {\n    /* no solution. circles do not intersect. */\n    return 0;\n  }\n    //SPAM(\"check solvability\\n\");\n\n  /* 'point 2' is the point where the line through the circle\n   * intersection points crosses the line between the circle\n   * centers.  \n   */\n\n  /* Determine the distance from point 0 to point 2. */\n  a = ( d / 2.0 ) ;\n  //SPAM(\"a = %llu\\n\", a);\n    \n  /* Determine the coordinates of point 2. */\n  x2 = (x0 + x1)/2.0 ;\n  y2 = (y0 + y1)/2.0 ;\n\n  /* Determine the distance from point 2 to either of the\n   * intersection points.\n   */\n    //SPAM(\"before sqrt\\n\");\n  //h = sqrt(1 - a*a);\n  //SPAM(\"a*a = %llu\\n\", a*a);\n  \n  //SPAM(\"MAXRAD*MAXRAD = %llu\\n\", maxradsq);\n  h = sqrtl(maxradsq - a*a);\n  //SPAM(\"h = %llu\\n\", h);\n  //SPAM(\"after sqrt\\n\");\n  /* Now determine the offsets of the intersection points from\n   * point 2.\n   */\n  //SPAM(\"get Offset\\n\");\n  //SPAM(\"          rx = -dy * (h / d) = %llu * (%llu /  %llu)\\n\", -dy, h, d);\n  //SPAM(\"          ry = dx * (h / d) = %llu * (%llu /  %llu)\\n\", dx, h, d);\n  rx = -dy * (h/d);\n  ry = dx * (h/d);\n  //SPAM(\"          rx = %llu, ry = %llu\\n\", rx, ry);\n  //SPAM(\"get int points\\n\");\n  /* Determine the absolute intersection points. */\n  pC.first = x2 + rx;\n  pC.second = y2 + ry;\n  //SPAM(\"in getCentre pC = (%llu, %llu)\\n\", pC.first, pC.second);\n\n  return 1;\n}\n\nint main(){\n    //for each iteration until 0\n    int N;\n    scanf(\"%d\", &N);\n    while(N !=0){\n        pointList.clear();\n        //for each set of points\n        for(int i=0; i < N; i++){\n            //take in points \n            double X,Y;\n            scanf(\"%lf %lf\", &X, &Y);\n            pointList.push_back(make_pair((ll) (X * FLOATCONV), (ll) (Y * FLOATCONV)));\n        }        \n            \n        //SPAM(\"put all points in\\n\");\n        //setMax = 0\n        int setMax = 0;\n        //for each point\n        for(int i =0; i < N-1; i++){\n            Point pA;\n            pA = pointList[i];\n            SPAM((\"pA = (%llu, %llu)\\n\", pA.first, pA.second));\n            //for each second point (point1 -> fin)\n            for (int j=i+1; j < N; j++){\n                Point pB = pointList[j];\n                \n                //SPAM(\"finding centre\\n\");\n                //find centre\n                Point pC;\n                //SPAM(\"--------> pB = (%llu,%llu)\\n\", pB.first, pB.second);\n                //continue if distance > 2\n                if( get_Centre(pA, pB, pC) == 0){\n                    //SPAM(\"         not in range\\n\");\n                    continue;\n                }\n                //SPAM(\"out getCentre pC = (%llu, %llu)\\n\", pC.first, pC.second);\n                //SPAM(\"after get_Centre\\n\");\n                //circleMax = 0;\n                int circleMax = 0;\n                //SPAM(\"          going through points\\n\");\n                //go through all points \n                for(auto p: pointList){\n                    //see if centre-> point < 1, circleMax++\n                    SPAM((\"                    p = (%llu, %llu)\\n\", p.first, p.second));\n                    if ( inRange(p, pC, MAXRAD)){\n                        circleMax++;\n                        SPAM((\"                        in range\\n\"));\n                    }\n                }\n                SPAM((\"        circleMax = %d\\n\\n\", circleMax));\n                setMax = max(setMax, circleMax);   \n             }\n                \n        }\n        //print setMax\n        printf(\"%d\\n\", setMax);\n        \n        //scan next N in\n        scanf(\"%d\", &N);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <tuple>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nint N;\ndouble x[300];\ndouble y[300];\ninline double dist2(double a, double b)\n{\n\treturn a*a+b*b;\n}\nvoid exec()\n{\n\tcin >> N;\n\tif(N==0){\n\t\texit(0);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tint ret=1;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tdouble dx=(x[i]-x[j])/2;\n\t\t\tdouble dy=(y[i]-y[j])/2;\n\t\t\tdouble r2=dx*dx+dy*dy;\n\t\t\tdouble R=sqrt(1/r2-1);\n\t\t\tdouble px=x[j]+dx-R*dy;\n\t\t\tdouble py=y[j]+dy+R*dx;\n\t\t\tdouble qx=x[j]+dx+R*dy;\n\t\t\tdouble qy=y[j]+dy-R*dx;\n\t\t\tint sp=0,sq=0;\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\tif(k==i||k==j){\n\t\t\t\t\tsp++;sq++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(dist2(x[k]-px,y[k]-py)<=1){\n\t\t\t\t\tsp++;\n\t\t\t\t}\n\t\t\t\tif(dist2(x[k]-qx,y[k]-qy)<=1){\n\t\t\t\t\tsq++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret=max(ret,sp);\n\t\t\tret=max(ret,sq);\n\t\t}\n\t}\n\tcout << ret << endl;\n}\nint main() {\n\twhile(1)\n\t\texec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nconst double EPS = 1e-8;\ntypedef pair<double,double> P;\n\ninline double dist(P p,P q){\n  return ( (p.first-q.first)*(p.first-q.first) + (p.second-q.second)*(p.second-q.second));\n}\n\nint main(){\n  int N;\n  double sign[2] = {+1, -1};\n  while(cin>>N,N){\n    vector<P> p(N);\n    REP(i,N)cin>>p[i].first>>p[i].second;\n    int ans = 1;\n    REP(i,N){\n      REP(j,N){\n        double dst = dist(p[i],p[j]);\n        if(dst > 4.0) continue;\n        P v((p[j].first-p[i].first)/dst, (p[j].second-p[i].second)/dst);\n        P m((p[j].first+p[i].first)/2.0, (p[j].second+p[i].second)/2.0);\n        double lth = sqrt(1.0-dst*dst/4.0);\n        REP(k,2){\n          double cx = m.first + sign[k] * v.first * lth;\n          double cy = m.second - sign[k] * v.second * lth;\n          P center(cx,cy);\n          int count = 0;\n          REP(l,N){\n            if(l == i || l == j || dist(center,p[l]) < 1){\n              count++;\n            }\n          }\n          ans = max(ans, count);\n        }\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i)\n\n#define X() real()\n#define Y() imag()\n#define x(p) (p).X()\n#define y(p) (p).Y()\n#define SZ(P) (int)(P.size())\n#define curr(P, i) P[(i)%SZ(P)]\n#define next(P, i) P[(i+1)%SZ(P)]\n#define prev(P, i) P[(i+SZ(P)-1)%SZ(P)]?´\n\nusing D = double;\nusing P = complex<D>;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return x(a) != x(b) ? x(a) < x(b) : y(a) < y(b);\n  }\n}\nD dot(const P& a, const P& b) {\n  return x(conj(a)*b);\n}\nD cross(const P& a, const P& b) {\n  return y(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a;\n  c -= a;\n  if(cross(b, c) > 0) return +1;\n  if(cross(b, c) < 0) return -1;\n  if(dot(b, c) < 0) return +2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\nstruct C {\n  P p;\n  D r;\n};\n\nP makeP(D arg, D r=1.0) {\n  return r * P{cos(arg), sin(arg)};\n}\nP rotP(const P& p, D arg) {\n  return p * makeP(arg);\n} \n\nvector<P> getNorm(const P& p) {\n  return {rotP(p, PI/2.0)/abs(p), rotP(p, -PI/2.0)/abs(p)};\n}\n\nvector<C> makeC(const P& a, const P& b, D r = 1.0) {\n  P m = (a+b)/2.0;\n  D d = sqrt(r*r-abs(m-a)*abs(m-a));\n  auto ps = getNorm(b-a);\n  rep(i, 2) ps[i] = d*ps[i]+m;\n  vector<C> ret;\n  rep(i, 2) ret.push_back(C{ps[i], r});\n  return ret;\n}\nbool include(const C& c, const P& p) {\n  return abs(c.p-p) < c.r+EPS;\n}\n\nint main() {\n  int n;\n  while(cin >> n && n) {\n    vector<P> ps(n);\n    rep(i, n) {\n      D x, y;\n      cin >> x >> y;\n      ps[i] = P{x, y};\n    }\n    int ans = 0;\n    rep(i, n) rep(j, i) {\n      auto cs = makeC(ps[i], ps[j]);\n      for(auto& c : cs) {\n\tint tmp = 0;\t\n\trep(k, n) if(include(c, ps[k])) tmp++;\n\tans = max(ans, tmp);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define rrep(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); --i)\n#define sz(c) ((int)c.size())\n#define all(c) c.begin(), c.end()\n\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nconst int INF = 1e9;\nconst double EPS = 1e-6;\ntemplate <class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T> using heap = priority_queue<T, vector<T>, greater<T>>;\n\nusing Point = complex<double>;\n\nstruct Circle {\n    Point c;\n    double r;\n};\n\n// 円と円の交点\npair<Point, Point> get_cross_points(Circle c1, Circle c2) {\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r - c2.r * c2.r + d * d) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return {c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a)};\n}\n\nvoid solve(int N) {\n    vector<Circle> C(N);\n    rep(i, 0, N) {\n        double x, y;\n        cin >> x >> y;\n        C[i] = {Point(x, y), 1};\n    }\n\n    auto check_intersect = [&](int i, int j) {\n        return abs(C[i].c - C[j].c) < C[i].r + C[j].r;\n    };\n\n    auto check_inner = [&](Circle c, Point p) {\n        return abs(c.c - p) <= c.r + EPS;\n    };\n\n    int ans = 0;\n    rep(i, 0, N) {\n        rep(j, i + 1, N) {\n            if (check_intersect(i, j)) {\n                auto cps = get_cross_points(C[i], C[j]);\n                int cnt = 0;\n                rep(k, 0, N) {\n                    if (check_inner(C[k], cps.first)) {\n                        cnt++;\n                    }\n                }\n                chmax(ans, cnt);\n                cnt = 0;\n                rep(k, 0, N) {\n                    if (check_inner(C[k], cps.second)) {\n                        cnt++;\n                    }\n                }\n                chmax(ans, cnt);\n            }\n        }\n    }\n    rep(i, 0, N) {\n        int cnt = 0;\n        rep(k, 0, N) {\n            if (check_inner(C[k], C[i].c)) {\n                cnt++;\n            }\n        }\n        chmax(ans, cnt);\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n    while (1) {\n        int N;\n        cin >> N;\n        if (N == 0) break;\n        solve(N);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n// ??\\??? ????????¨???\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;}\ntemplate<class T> bool operator< (T a, T b){return a < b-eps;}\ntemplate<class T> bool operator<=(T a, T b){return a < b+eps;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n#define X real()\n#define Y imag()\n\ntypedef bool B;\ntypedef long double D;\ntypedef complex<D> P;\n\nP p[310];\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tdouble ix,iy;\n\t\trep(i,n){\n\t\t\tscanf(\"%lf %lf\",&ix,&iy);\n\t\t\tp[i].real(ix),p[i].imag(iy);\n\t\t}\n\t\tint ans=1;\n\t\trep(i,n)rep(j,n){\n\t\t\tif(i==j) continue;\n\t\t\tD d=norm(p[j]-p[i]);\n\t\t\tif(d>4.0) continue;\n\t\t\tP v=(p[j]-p[i])/P(2.0,0.0);\n\t\t\tD s=sqrt((1.0-norm(v))/norm(v));\n\t\t\tP cnt1=p[i]+v+s*P(v.imag(),-v.real());\n\t\t\tint num=2;\n\t\t\trep(k,n){\n\t\t\t\tif(k==i||k==j) continue;\n\t\t\t\tif(norm(p[k]-cnt1)<1.0) num++;\n\t\t\t}\n\t\t\tans=max(ans,num);\n\t\t\tP cnt2=p[i]+v+s*P(-v.imag(),v.real());\n\t\t\tint num2=2;\n\t\t\trep(k,n){\n\t\t\t\tif(k==i||k==j) continue;\n\t\t\t\tif(norm(p[k]-cnt2)<1.0) num2++;\n\t\t\t}\n\t\t\tans=max(ans,num2);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ld = long double;\nusing Point = complex<ld>;\n\nstruct Line{\n    Point a, b;\n    Line (Point a, Point b) : a(a), b(b) {}\n    Line () : Line(Point(), Point()) {}\n};\n\nstruct Circle{\n    Point p;\n    ld r;\n    Circle (Point p, ld r) : p(p), r(r) {}\n    Circle () : Circle(Point(),0.0) {}\n};\n\nconstexpr ld eps=1e-9, pi=acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nnamespace Geometry{\n    bool eq(ld a, ld b){\n        return abs(a-b) < eps;\n    }\n    //内積\n    ld dot(Point a, Point b){\n        return real(conj(a) * b);\n    }\n    //外積\n    ld cross(Point a, Point b){\n        return imag(conj(a) * b);\n    }\n    //3点の位置関係\n    int ccw (Point a, Point b, Point c) {\n        b -= a; c -= a;\n        if (cross(b, c) > eps) return 1;//a,b,cで反時計周り\n        if (cross(b, c) < -eps) return -1;//a,b,cで時計周り\n        if (dot(b, c) < 0) return 2;//c,a,bで直線\n        if (norm(b) < norm(c)) return -2;//a,b,cで直線\n        return 0;//a,c,bで直線\n    }\n\n//====================================================\n    Point inputPoint(){\n        ld x, y;\n        cin>>x>>y;\n        return Point(x, y);\n    }\n    //2直線の交差判定\n    bool isCrossed_ll(Line l, Line m){\n        return !eq(cross(l.b-l.a, m.b-m.a), 0);\n    }\n    //直線と線分の交差判定\n    bool isCrossed_ls(Line l, Line s){\n        return isCrossed_ll(l, s) && \n            cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps;\n    }\n    //線分と線分の交差判定\n    bool isCrossed_ss(Line s, Line t){\n        return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n            ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n    }\n    //点が直線上にあるか\n    bool isON_l(Line l, Point p){\n        return abs(cross(l.b-p, l.a-p)) < eps;\n    }\n    //点が線分上にあるか\n    bool isON_s(Line s, Point p){\n        return abs(s.a-p)+abs(s.b-p)-abs(s.b-s.a) < eps;\n    }\n\n    //点から直線への垂線の足\n    Point foot(Line l, Point p){\n        ld t = dot(p-l.a,l.a-l.b)/norm(l.a-l.b);\n        return l.a+t*(l.a-l.b);\n    }\n    //直線と直線の交点\n    Point intersection_ll(Line l, Line m){\n        Point lv=l.b-l.a, mv=m.b-m.a;\n        assert(cross(lv,mv)!=0);//平行\n        return l.a+lv*cross(mv,m.a-l.a)/cross(mv,lv);\n    }\n    //線分と線分の交点\n    Point intersection_ss(Line s, Line t){\n        assert(isCrossed_ll(s, t));\n        return intersection_ll(s,t);\n    }\n    //点と点の距離\n    ld dist_pp(Point p, Point q){\n        ld x=p.real()-q.real(), y=p.imag()-q.imag();\n        return sqrt(x*x+y*y);\n    }\n    //点と直線の距離\n    ld dist_lp(Line l, Point p) {\n        return abs(p - foot(l, p));\n    }\n    //直線と直線の距離\n    ld dist_ll(Line l, Line m){\n        return isCrossed_ll(l, m)?0:dist_lp(l, m.a);\n    }\n    //直線と線分の距離\n    ld dist_ls(Line l, Line s){\n        return isCrossed_ls(l, s)?0:min(dist_lp(l, s.a), dist_lp(l, s.b));\n    }\n    //線分と点の距離\n    ld dist_sp (Line s, Point p) {\n        Point r = foot(s, p);\n        return isON_s(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n    }\n    //線分と線分の距離\n    ld dist_ss (Line s, Line t) {\n        if (isCrossed_ss(s, t)) return 0;\n        return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n    }\n    //円と円の交点\n    vector<Point>intersection_cc(Circle c1, Circle c2){\n        vector<Point> res;\n        ld d = abs(c1.p - c2.p);\n        ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n        ld dfr = c1.r * c1.r - rc * rc;\n        if (abs(dfr) < eps) dfr = 0.0;\n        else if (dfr < 0.0) return res;\n        ld rs = sqrt(dfr);\n        Point diff = (c2.p - c1.p) / d;\n        res.push_back(c1.p + diff * Point(rc, rs));\n        if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n        return res;\n    }\n};\n\nint main(){\n    int n;\n    using namespace Geometry;\n    while(cin>>n,n){\n        vector<Point>g(n);\n        vector<Circle>Cs(n);\n        for(int i=0;i<n;++i){\n            g[i]=inputPoint();\n            Cs[i]={g[i],1.0};\n        }\n        int ans=1;\n        for(int i=0;i<n;++i){\n            for(int j=i+1;j<n;++j){\n                vector<Point>intersections(intersection_cc(Cs[i],Cs[j]));\n                for(auto intersection:intersections){\n                    int ret=0;\n                    for(int k=0;k<n;++k){\n                        if(dist_pp(intersection,g[k]) < 1.0){\n                            if(i == k || j==k)continue;\n                            ++ret;\n                        }\n                    }\n                    ans=max(ans,ret+2);\n                }\n            }\n        }\n        cout<<ans<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nstruct UnionFind {\n    int sz;\n    std::vector<int> par;\n    UnionFind(int sz) {\n        this->sz = sz;\n        par.clear();\n        par.resize(sz, -1);\n    }\n    int root(int x) {\n        return par[x] < 0 ? x : par[x] = root(par[x]);\n    }\n    void unite(int a, int b) {\n        int roota = root(a);\n        int rootb = root(b);\n        if(roota == rootb) return;\n        if(par[rootb] < par[roota]) std::swap(roota, rootb);\n        par[roota] += par[rootb];\n        par[rootb] = roota;\n    }\n    bool same(int a, int b) {\n        return (root(a) == root(b));\n    }\n    int size(int a) {\n        return -par[root(a)];\n    }\n};\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nusing ld = long double;\nusing Point = std::complex<ld>;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std\n{\nbool operator<(const Point &lhs, const Point &rhs)\n{\n if (lhs.real() < rhs.real() - eps)\n  return true;\n if (lhs.real() > rhs.real() + eps)\n  return false;\n return lhs.imag() < rhs.imag();\n}\n}\nPoint input_point()\n{\n ld x, y;\n std::cin >> x >> y;\n return Point(x, y);\n}\nbool eq(ld a, ld b)\n{\n return (abs(a - b) < eps);\n}\nld dot(Point a, Point b)\n{\n return real(conj(a) * b);\n}\nld cross(Point a, Point b)\n{\n return imag(conj(a) * b);\n}\nint ccw(Point a, Point b, Point c)\n{\n b -= a;\n c -= a;\n if (cross(b, c) > eps)\n  return 1;\n if (cross(b, c) < -eps)\n  return -1;\n if (dot(b, c) < 0)\n  return 2;\n if (norm(b) < norm(c))\n  return -2;\n return 0;\n}\nint main() {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int n; cin >> n;\n    if(n == 0) break;\n    vector<Point> v(n);\n    for(int i=0;i<n;++i) {\n      double x, y; cin >> x >> y;\n      v[i] = Point(x, y);\n    }\n    int ma = 1;\n    for(int i=0;i<n;++i) {\n      for(int j=i+1;j<n;++j) {\n        Point mid = (v[i] + v[j]) / (ld)2.0;\n        Point diff = (v[i] - v[j]) / (ld)2.0;\n        ld l2 = abs(diff);\n        if(l2 + eps > 1) continue;\n        ld tang = 1.0 / (l2 * l2) - 1;\n        Point d(-imag(diff), real(diff));\n        Point test1 = mid + d * sqrt(tang);\n        Point test2 = mid - d * sqrt(tang);\n        int cnt1 = 0, cnt2 = 0;\n        for(int k=0;k<n;++k) {\n          if(abs(v[k] - test1) < 1 + eps) {\n            cnt1++;\n          }\n          if(abs(v[k] - test2) < 1 + eps) {\n            cnt2++;\n          }\n        }\n        ma = max(ma, max(cnt1, cnt2));\n      }\n    }\n    cout << ma << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-8\n#define INF 1000000\n \nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n    Point operator *(const double d)const{\n        return Point(x*d,y*d);\n    }\n    bool operator <(const Point &p)const{\n        if(x==p.x) return y<p.y;\n        return x<p.x;\n    }\n    double norm(){\n        return x*x+y*y;\n    }\n\tbool input(){\n\t\tif(cin>>x>>y) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n\tbool input(){\n\t\tif(a.input() && b.input()) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point _c,double _r){\n        c=_c; r=_r;\n    }\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n \nint ccw(Point a,Point b,Point c){ \n\tPoint v1 = b-a;\n\tPoint v2 = c-a;\n    if(cross(v1,v2)>EPS) return +1; \n    if(cross(v1,v2)<-EPS) return -1; \n\tif(dot(v1,v2)<-EPS) return +2; \n\tif(v1.norm()<v2.norm()) return -2; \n    return 0; \n}\n \nbool intersect_ss(Line l,Line m){\n\treturn ccw(l.a,l.b,m.a)*ccw(l.a,l.b,m.b)<=0 && ccw(m.a,m.b,l.a)*ccw(m.a,m.b,l.b)<=0;\n}\n \nbool crosspoint_ll(Line l,Line m,Point &p){\n    Point a1,a2,b1,b2;\n    a1 = l.b-l.a; a2 = m.b-m.a;\n    b1 = m.a-l.a; b2 = l.a-m.b;\n    double s1,s2;\n    s1 = cross(a1,b1)/2; s2 = cross(a1,b2)/2;\n    if(s1+s2<EPS) return false; \n    p = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n    return true;\n}\n \nint crosspoint_ss(Line l,Line m,Point &p){\n    if(intersect_ss(l,m)==false) return 0; \n    if(crosspoint_ll(l,m,p)==true) return 1;\n\treturn -1; \n}\n \nint crosspoint_cc(Circle c1,Circle c2,Point &p1,Point &p2){\n    double d,a,t;\n    d = sqrt((c2.c-c1.c).norm());\n\tif(abs(c1.c.x-c2.c.x)<EPS && abs(c1.c.y-c2.c.y)<EPS && abs(c1.r-c2.r)<EPS)\n\t\treturn -1; \n    if(d<abs(c1.r-c2.r) || c1.r+c2.r<d) return 0; \n    a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    t = atan2(c2.c.y-c1.c.y,c2.c.x-c1.c.x);\n    p1 = Point(c1.c.x+c1.r*cos(t+a),c1.c.y+c1.r*sin(t+a));\n    p2 = Point(c1.c.x+c1.r*cos(t-a),c1.c.y+c1.r*sin(t-a));\n    if(abs(p1.x-p2.x)<EPS && abs(p1.y-p2.y)<EPS) return 1; \n    return 2; \n}\n\nint contains(Polygon g,Point p){\n\tLine l = Line(p,Point(INF,p.y));\n\tint cnt = 0, n = g.size();\n\tfor(int i=0;i<n;i++){\n\t\tPoint a = g[i]-p;\n\t\tPoint b = g[(i+1)%n]-p;\n\t\tif(ccw(g[i],g[(i+1)%n],p)==0) return 1; \n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<=EPS && EPS<b.y && cross(a,b)>EPS) cnt++;\n\t}\n\tif((cnt&1)==1) return 2; \n\treturn 0; \n}\n\nPolygon andrewScan(Polygon s){\n\tif(s.size()<=2) return s;\n\tsort(s.begin(),s.end());\n\tPolygon g;\n\tfor(int i=0;i<s.size();i++){\n\t\tfor(int n=g.size(); n>=2 && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\tint upper_n = g.size();\n\tfor(int i=s.size()-2;i>=0;i--){\n\t\tfor(int n=g.size(); n>upper_n && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\treverse(g.begin(),g.end());\n\tg.pop_back();\n\treturn g;\n}\n\nint cntInsidePoint(Circle c,Polygon s){\n\tint cnt=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tif((s[i]-c.c).norm()<=1+EPS) cnt++;\n\t}\n\treturn cnt;\n}\n\nint main(){\n\tint N;\n\twhile(cin>>N,N){\n\t\tPolygon S;\n\t\tS.resize(N);\n\t\tfor(int i=0;i<N;i++) S[i].input();\n\t\tint ans = 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=i+1;j<N;j++){\n\t\t\t\tPoint p1,p2;\n\t\t\t\tif(crosspoint_cc(Circle(S[i],1),Circle(S[j],1),p1,p2)>0){\n\t\t\t\t\tans = max(ans,max(cntInsidePoint(Circle(p1,1),S),cntInsidePoint(Circle(p2,1),S)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans==0) puts(\"1\");\n\t\telse printf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n\n#ifdef _DEBUG\n#define typeof(X) std::identity<decltype(X)>::type //C++0x (for vs2010)\n#else\n#define typeof(X) __typeof__(X) // for gcc\n#endif\n\n#define sz(a)  int((a).size())\n#define FOREACH(it, c) for (typeof((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define FOR(i,count) for (int i = 0; i < (count); i++)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nusing namespace std;\nstatic const double EPS = 1e-6;\ntypedef long long ll;\nconst int MODULO = 1000000007;\nconst int INF = 100000000; //1e8\n\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\ntypedef complex<double> Cd;\n\nint n;\nCd pt[300];\n\ndouble sqr(double x) { return x * x; }\n\nint C(Cd &o){\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tCd c = pt[i] - o;\n\t\tif(sqr(c.real()) + sqr(c.imag()) <= 1.0 + EPS)\n\t\t\tcnt++;\n\t}\n\treturn cnt;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tdouble x,y; cin>>x>>y;\n\t\tpt[i] = Cd(x,y);\n\t}\n\n\tint ans = 1;\n\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif(i == j) continue;\n\t\t\tCd e = (pt[j] - pt[i]);\n\t\t\tdouble len = abs(e);\n\t\t\tif(len > 2.0 + EPS) continue;\n\t\t\tCd md = pt[i] + e / 2.0;\n\t\t\te /= len;\n\t\t\te *= Cd(0,1);\n\t\t\tdouble o_dis = sqrt(1.0 - sqrt(len / 2));\n\t\t\tstatic int dir[] = {1,-1};\n\t\t\tfor (int k = 0; k < 2; k++){\n\t\t\t\tCd o = md + dir[k] * o_dis * e; // 中心を出す\n\t\t\t\t//printf(\"%d %d %lf %lf\\n\",i,j,o.real(),o.imag());\n\t\t\t\tans = max(ans,C(o));\n\t\t\t}\n\t\t}\n\t};\n\n\treturn ans;\n\n}\n\n\nint main(){\n\twhile(cin>>n,n){\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n// 問題名：\"Circle and Points\"\n// https://onlinejudge.u-aizu.ac.jp/problems/1132\n// 所要時間… 考察：10分程度 実装：20分程度\n\n/*\n***方針***\n最大数囲む半径1の円の囲み方が有るときに、囲む点を変えずに少なくとも2点を同時に円周上に持ってくることができる。したがって、周上に2点が存在するような円のみを考えれば良い。周上に置く2点を決めた時、考えられる半径1の円の囲み方は最大2通り存在する（2点間の距離が2より大きいと存在しない）。この2点の選び方はNC2=O(N^2)通りなので、それぞれについて円で囲まれる点を一つづつ数えると、計算量はO(N^3)となりN<=300で間に合いそうである。\n\n***学んだこと***\ncomplex型によって、平面上の点の操作が容易となる（複素平面的扱いにより変数の数を減らすことが可能）。\n*/\n\nint main() {\n  int n;\n  while (cin >> n, n > 0) {\n    // 入力\n    vector<complex<double>> p(n);\n    double xt, yt;\n    for (int i = 0; i < n; i++) {\n      cin >> xt >> yt;\n      p[i].real(xt);\n      p[i].imag(yt);\n    }\n\n    int ret =\n        1;  // 1<=Nなので答えは必ず1以上（0とすると、下のループに入らない場合にバグる）\n    for (int i = 0; i < n; i++) {  // 円周に来る2点の組でループ\n      for (int j = i + 1; j < n; j++) {\n        if (abs(p[i] - p[j]) > 2)\n          continue;  // 2点間の距離が2より大きかったら無視\n\n        // 回転操作と実数倍で、2つの点p[i],p[j]から円の中心を二つ求める（c+pmとc-pm）\n        complex<double> pm = (p[i] + p[j]) / 2.0;\n        complex<double> c = p[i] - pm;\n        double d = abs(c);\n        c *= sqrt(1 - d * d) / d * 1.0i;\n        int cntp = 0, cntm = 0;\n\n        // できる2つの円について、含まれる点の個数を数える\n        // ちょうど周上に来る2点を確実に入れるために、ボーダーを少し広めに設定（制約上、外の点を含むことはない）\n        for (int k = 0; k < n; k++) {\n          if (abs(p[k] - (c + pm)) < 1.00005) cntp++;\n          if (abs(p[k] - (-c + pm)) < 1.00005) cntm++;\n        }\n        ret = max({ret, cntp, cntm});  // 大きいものを採用\n      }\n    }\n    cout << ret << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\n#define VN(v) # v\n#define print(a) cout << a << \"#\" << VN(a) << endl;\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    ll n; \n    while (cin >> n && n) {\n        vld x(n), y(n); rep(i, n) cin >> x[i] >> y[i];\n        auto d = [&](ll i, ll j) { return (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]); };\n        ll ret = 1;\n        for (int i = 0; i < n-1; i++) {\n            for (int j = i+1; j < n; j++) {\n                ld dij = d(i, j);\n                if (dij >= 4) continue;\n                ld x1 = x[i], y1 = y[i], x0 = x[j], y0 = y[j];\n                for (auto dir : {1, -1}) {\n                    ld xc = x0 + (x1 - x0) / 2.0l + (-(y1 - y0)) * dir \n                        * sqrtl(1.0l - ((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0)) / 4.0l) \n                        / sqrtl((y1 - y0) * (y1 - y0)  + (x1 - x0) * (x1 - x0));\n                    ld yc = y0 + (y1 - y0) / 2.0l + (+(x1 - x0)) * dir \n                        * sqrtl(1.0l - ((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0)) / 4.0l) \n                        / sqrtl((y1 - y0) * (y1 - y0)  + (x1 - x0) * (x1 - x0));\n//                    cout << x1 << \" \" << y1 << \" \" << x0 << \" \" << y0 << \" : \" << xc << \" \" << yc << endl;\n                    ll m = 2;\n                    rep(k, n) {\n                        if (k == i || k == j) continue;\n                        if ((xc - x[k]) * (xc - x[k]) + (yc - y[k]) * (yc - y[k]) < 1) \n                            m++;\n                    }\n                    chmax(ret, m);\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<28;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nstruct point{\n\tdouble x,y;\n\tpoint operator+(point p){\n\t\treturn point{x+p.x,y+p.y};\n\t}\n\tpoint operator-(point p){\n\t\treturn point{x-p.x,y-p.y};\n\t}\n\tpoint operator*(double p){\n\t\treturn point{x*p,y*p};\n\t}\n\tpoint operator/(double p){\n\t\tif(!p) return point{0,0}; \n\t\treturn point{x/p,y/p};\n\t}\n\tbool operator==(point p){\n\t\treturn fabs(x-p.x)<eps&&fabs(y-p.y)<eps;\n\t}\n\tbool operator<(point p){\n\t\tif(fabs(x-p.x)>eps) return x<p.x;\n\t\treturn y<p.y;\n\t}\n};\n\ntypedef pair<point,point> pp;\ntypedef vector<point> VP;\nconst point O{0,0};\n\ndouble Length(point x,point y){\n\tpoint z=y-x;\n\treturn sqrt(z.x*z.x+z.y*z.y);\n}\n\npoint Normal(point p){\n\treturn point{p.y,-p.x};\n}\n\nint n;\nVP p;\n\nint f(point q){\n\tint res=0;\n\tfor(int i=0;i<n;i++) if(Length(p[i],q)<1+eps) res++;\n\treturn res;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(!n) break;\n\t\tp=VP(n);\n\t\tfor(int i=0;i<n;i++) cin>>p[i].x>>p[i].y;\n\t\tint res=1;\n\t\tfor(int i=0;i<n;i++) for(int j=i+1;j<n;j++){\n\t\t\tpoint c=(p[i]+p[j])/2,e=Normal(p[i]-p[j]);\n\t\t\tdouble l=Length(c,p[i]);\n\t\t\te=e/Length(O,e)*sqrt(1.0-l*l);\n\t\t\tres=max(res,max(f(c+e),f(c-e)));\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *  Circle and Points (PKU 1981)\n *  by Kenji Inoue, 2007-01-05\n **/\n\n#include <iostream>\n#include <math.h>\n\nusing namespace std;\n\n#define EPS (1e-6)\n\ndouble x[300], y[300];\n\nint sign[] = {+1, -1};\n\nint main(void) {\n  int n;\n  while (cin >> n, n) {\n    for (int i=0; i<n; i++) {\n      cin >> x[i] >> y[i];\n    }\n\n    int ans = 1;\n    for (int i=0; i<n; i++) {\n      for (int j=i+1; j<n; j++) {\n        double d = hypot(x[i]-x[j], y[i]-y[j]);\n        if ( d > 2.0 + EPS ) { continue; }\n\n        double mx = (x[i] + x[j]) / 2;\n        double my = (y[i] + y[j]) / 2;\n        double vx = (x[j] - x[i]) / d;\n        double vy = (y[j] - y[i]) / d;\n        double e = sqrt(1.0 - d*d/4.0);\n\n        for (int s=0; s<2; s++) {\n          double px = mx + sign[s]*e*vy;\n          double py = my - sign[s]*e*vx;\n\n          int cnt = 2;\n          for (int k=0; k<n; k++) {\n            if (k==i || k==j) { continue; }\n            if ( (px-x[k])*(px-x[k]) + (py-y[k])*(py-y[k]) < 1.0 + EPS ) { cnt++; }\n          }\n          if (cnt > ans) { ans = cnt; }\n        }\n      }\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n#define EPS 1e-8\ntypedef complex<double> P;\n\nP center(P a, P b){\n  P m  = (a+b) / 2.0;    // p[i]Æp[j]Ì_\n  P n = (a-b) * P(0,1);  // @üxNg\n  n = n / abs(n);\n  \n  double x = abs( a-b )/2.0;\n  return m + n * sqrt( 1.0-x*x );     // ~ÌS\n}\n\nint main(){\n  int n;\n  P p[301];\n\n  while( cin>>n && n ){\n    for( int i=0;i<n;i++ )\n      cin >> p[i].real() >> p[i].imag();\n\n    int ans=1;\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ ){\n\tif( i==j ) \t  continue;\n\tif( abs( p[i]-p[j] )+EPS > 2.0 ) continue;\n\tP c = center( p[i],p[j] );\n\n\tint num=0;\n\tfor( int k=0;k<n;k++ )\n\t  if( abs( c-p[k] ) < 1.0 + EPS  )\n\t    num++;\n\tans = max( ans,num );\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, n) FOR(i, 0, n)\n#define FOR(i, a, b) for(int i=a; i<b; i++)\ntypedef long double ld;\ntypedef complex<ld> pt;\n#define LAR(a, b) ((a)=max((a), (b)))\n\nint n;\npt p[305];\n\nint cnt(pt c, int x, int y){\n\tint ret=0;\n\tREP(i, n){\n\t\tif(i==x || i == y) ret++;\n\t\telse ret+=(abs(c-p[i])<1);\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(scanf(\"%d\", &n), n){\n\t\tREP(i, n){\n\t\t\tld x, y; scanf(\"%Lf%Lf\", &x, &y);\n\t\t\tp[i]=pt(x, y);\n\t\t}\n\t\tint ans=1;\n\t\tREP(i, n){\n\t\t\tFOR(j, i+1, n){\n\t\t\t\tif(abs(p[i]-p[j])>2) continue;\n\t\t\t\tpt r = (p[j]-p[i])/2.0L;\n\t\t\t\tpt s = r * (pt)1il;\n\t\t\t\ts *= sqrt(1 - abs(r)*abs(r)) / abs(s);\n\t\t\t\tLAR(ans, cnt(p[i]+r+s, i, j));\n\t\t\t\tLAR(ans, cnt(p[i]+r-s, i, j));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nconst double EPS=1e-9;\n\nint n;\nPoint p[300];\n\nint f(const Point &c){\n\tint res=0;\n\trep(i,n) if(abs(p[i]-c)<1+EPS) res++;\n\treturn res;\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\trep(i,n){ double x,y; scanf(\"%lf%lf\",&x,&y); p[i]=Point(x,y); }\n\n\t\tint ans=0;\n\t\trep(j,n) rep(i,j) {\n\t\t\tPoint v=0.5*(p[j]-p[i]);\n\t\t\tdouble d=abs(v);\n\t\t\tif(d<1-EPS){\n\t\t\t\tans=max(ans,f(p[i]+v+(sqrt(1-d*d)/d)*v*Point(0,+1)));\n\t\t\t\tans=max(ans,f(p[i]+v+(sqrt(1-d*d)/d)*v*Point(0,-1)));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nstruct Point{\n    double x,y;\n};\n\nvoid func(int N){\n\n    Point point[N];\n    double x_min = 100,y_min = 100,x_max = -1,y_max = -1;\n\n    for(int i = 0; i < N; i++){\n        scanf(\"%lf %lf\",&point[i].x,&point[i].y);\n        x_min = min(point[i].x,x_min);\n        y_min = min(point[i].y,y_min);\n        x_max = max(point[i].x,x_max);\n        y_max = max(point[i].y,y_max);\n    }\n\n    if(x_min > 1)x_min -= 0.05;\n    if(y_min > 1)y_min -= 0.05;\n    if(x_max < 9)x_max += 0.05;\n    if(y_max < 9)y_max += 0.05;\n\n    int count,max_count = 0;\n\n    for(double y = y_min; y <= y_max; y += 0.0101){\n        for(double x = x_min; x <= x_max; x += 0.0101){\n            count = 0;\n            for(int i = 0; i < N; i++){\n                if(sqrt((x-point[i].x)*(x-point[i].x)+(y-point[i].y)*(y-point[i].y)) <= 1.0)count++;\n            }\n            max_count = max(max_count,count);\n        }\n    }\n\n    printf(\"%d\\n\",max_count);\n}\n\n\nint main(){\n\n    int N;\n\n    while(true){\n        scanf(\"%d\",&N);\n        if(N == 0)break;\n\n        func(N);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\n// y???real(), x???imag()\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool cmp_y(const P &a, const P &b){\n\t\treturn a.imag() != b.imag() ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n// circle\nstruct C {\n\tP p; double r;\n\tC(const P& p, double r) : p(p), r(r) {}\n};\n\n// 2???p1, p2?????????????????????r?????????2?????????\nvector<C> calcCircle(P p1, P p2, double r) {\n\tif(abs(p1-p2) > 2*r) return {};\n\tP p3 = {(p1.real()+p2.real())/2, (p1.imag()+p2.imag())/2};\n\t// cout << p3.real() << \" \" << p3.imag() << endl;\n\tdouble l = abs(p1-p3);\n\t// cout << \"l:\" << l << endl;\n\t// ????????????p_1p_2\n\tP p1p2 = p2-p1;\n\tdouble a = p1p2.real(), b = p1p2.imag();\n\tdouble dx = b*sqrt((r*r-l*l)/(a*a+b*b)), dy = a*sqrt((r*r-l*l)/(a*a+b*b));\n\t// cout << \"dx:\" << dx << \" dy:\" << dy << endl;\n\treturn {{{p3.real()+dx, p3.imag()-dy}, r}, {{p3.real()-dx, p3.imag()+dy}, r}};\n}\n\n// ???p??????c????????¨????????¨??????????????????\nbool intersectCP(C c, P p) { return abs(p-c.p) <= c.r + EPS; }\n\nP po[305];\nsigned main(void)\n{\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n    REP(i, n) {\n      double x, y;\n      cin >> x >> y;\n      po[i] = {x, y};\n    }\n\n    int ans = 0;\n    REP(i, n) FOR(j, i+1, n) {\n      vector<C> ret = calcCircle(po[i], po[j], 1);\n      if(ret.size() == 0) continue;\n      // cout << \"i:\" << i << \" j:\" << j << endl;\n      // cout << ret[0].p.real() << \" \" << ret[0].p.imag() << \" \" << ret[0].r << endl;\n      // cout << ret[1].p.real() << \" \" << ret[1].p.imag() << \" \" << ret[1].r << endl;\n      int num = 0;\n      REP(k, n) {\n        num += intersectCP(ret[0], po[k])?1:0;\n        // if(intersectCP(ret[0], po[k])) cout << k << \" \";\n      }\n      chmax(ans, num);\n      // cout << \"num:\" << num << endl;\n      num = 0;\n      REP(k, n) {\n        num += intersectCP(ret[1], po[k])?1:0;\n        // if(intersectCP(ret[1], po[k])) cout << k << \" \";\n      }\n      // cout << \"num:\" << num << endl;\n      chmax(ans, num);\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<double,double> P;\n\nbool cmp_x (const P& firstEof, const P& secondEof) {\n    if (firstEof.first == secondEof.first) return firstEof.second < secondEof.second;\n    return firstEof.first < secondEof.first;\n}\n\nint main () {\n    int n;\n    while (cin >> n, n) {\n        vector<P> v;\n\n        for (int i = 0; i < n; i++) {\n            double x, y;\n            cin >> x >> y;\n            v.push_back(P(x,y));\n        }\n\n        sort(v.begin(), v.end(), cmp_x);\n\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            vector<P> tmp;\n            tmp.push_back(v[i]);\n            int k = i + 1;\n            while (k < n && fabs(v[k].first - v[i].first) < 2.0) {\n                bool flag = true;\n                for (int j = 0; j < tmp.size(); j++) {\n                    int dis = pow(v[k].first - tmp[j].first, 2.) + pow(v[k].second - tmp[j].second, 2.);\n                    if (dis > 4.) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    tmp.push_back(v[k]);\n                }\n                k++;\n            }\n            res = max(res, (int)tmp.size());\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#define COS45 0.707107\nusing namespace std;\n\nclass Point {\npublic:\n  double x, y;\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n  Point operator +(Point p) {\n    return Point(x+p.x, y+p.y);\n  }\n  Point operator -(Point p) {\n    return Point(x-p.x, y-p.y);\n  }\n  Point operator *(double a) {\n    return Point(x*a, y*a);\n  }\n  Point operator /(double a) {\n    return Point(x/a, y/a);\n  }\n  bool operator ==(const Point &p) const {\n    return x == p.x && y == p.y;\n  }\n  bool operator <(const Point &p) const {\n    double l1 = x+y;\n    double l2 = p.x+p.y;\n    if(l1 != l2) return l1 < l2;\n    if(y != p.y) return y < p.y;\n    return x < p.x;\n  }\n};\n\ntypedef Point Vector;\n\ndouble norm(Point p1, Point p2) {\n  return (p1.x-p2.x)*(p1.x-p2.x) + (p1.y-p2.y)*(p1.y-p2.y);\n}\n\nint n;\nPoint p[300];\n\nint calc(Point p1, Point p2) {\n  Point m = Point((p1.x+p2.x)/2.0, (p1.y+p2.y)/2.0);\n  Point o;\n  Vector moto = Vector(p2.y-p1.y, p1.x-p2.x);\n  int cnt = 0;\n  int newCnt;\n  double p1p2 = norm(p1,p2);\n  if(p1p2 > 4) return 1;\n  double l = sqrt(4.0/p1p2-1)/2.0;\n\n  for(int t = 0; t < 2; t++) {\n    newCnt = 0;\n    if(t == 1) {\n      moto = moto * (-1);\n    }\n    o = m + moto * l;\n\n    for(int i = 0; i < n; i++) {\n      if(p[i].x > o.x + COS45 && p[i].y > o.y + COS45) break;\n      if(newCnt + n-i <= cnt) break;\n      if(p[i] == p1 || p[i] == p2) continue;\n      if((p[i].x-o.x)*(p[i].x-o.x) + (p[i].y-o.y)*(p[i].y-o.y) <= 1.0) {\n\tnewCnt++;\n      }\n    }\n    if(newCnt > cnt) cnt = newCnt;\n  }\n  return cnt + 2;\n}\n\nmain() {\n  while(1) {\n    int ans;\n    cin >> n;\n    if(n == 0) break;\n    for(int i = 0; i < n; i++) {\n      cin >> p[i].x >> p[i].y;\n    }\n    sort(p, &p[n]);\n    ans = -1;\n    for(int i = 0; i < n; i++) {\n      for(int j = i+1; j < n; j++) {\n\tans = max(ans, calc(p[i],p[j]));\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <deque>\n#include <utility>\n\n#define REP(i, n) FOR(i, 0, n)\n#define FOR(i, a, b) for(int i = int(a); i < int(b); ++i)\n#define RREP(i, n) RFOR(i, 0, n)\n#define RFOR(i, a, b) for(int i = int(b) - 1; i >= int(a); --i)\n\nconstexpr double EPS = 1e-7;\n\nsigned main() {\n\n\twhile (true) {\n\t\tint n;\n\t\tstd::cin >> n;\n\t\tif (n == 0) break;\n\n\t\tstd::vector<double> x(n), y(n);\n\t\tREP(i, n) std::cin >> x[i] >> y[i];\n\n\t\tint ans = 1;\n\n\t\tREP(i, n) FOR(j, i + 1, n) {\n\t\t\tdouble dist = std::hypot(x[i] - x[j], y[i] - y[j]);\n\t\t\tif (dist > 2 + EPS) continue;\n\n\t\t\t// iとjの中点m\n\t\t\tdouble mx = (x[i] + x[j]) / 2;\n\t\t\tdouble my = (y[i] + y[j]) / 2;\n\n\t\t\t// 線分ijから中心への距離\n\t\t\tdouble r = std::sqrt(1 - (dist / 2) * (dist / 2));\n\n\t\t\t// 中心c\n\t\t\tfor (int sign = -1; sign <= 1; sign += 2) {\n\t\t\t\t// 移動のベクトルv\n\t\t\t\tdouble vx = sign * r * (y[j] - y[i]) / dist;\n\t\t\t\tdouble vy = sign * r * -(x[j] - x[i]) / dist;\n\n\t\t\t\tdouble cx = mx + vx;\n\t\t\t\tdouble cy = my + vy;\n\n\t\t\t\tint cnt = 0;\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tif (std::hypot(cx - x[k], cy - y[k]) < 1 + EPS) ++cnt;\n\t\t\t\t}\n\t\t\t\tans = std::max(ans, cnt);\n\t\t\t}\n\t\t}\n\t\tstd::cout << ans << \"\\n\";\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef stderr_path\n#define LOCAL\n#endif\n#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#else\n#pragma GCC optimize(\"Ofast\")\n#endif\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n\n// #define NDEBUG\n#define debug_stream std::cerr\n#define iostream_untie true\n#define __precision__ 10\n\n#define all(v) std::begin(v), std::end(v)\n#define rall(v) std::rbegin(v), std::rend(v)\n#define __odd(n) ((n)&1)\n#define __even(n) (not __odd(n))\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n\nusing i64 = int_fast64_t;\nusing pii = std::pair<int, int>;\nusing pll = std::pair<int_fast64_t, int_fast64_t>;\ntemplate <class T>\nusing heap = std::priority_queue<T>;\ntemplate <class T>\nusing minheap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T>\nconstexpr T inf = std::numeric_limits<T>::max() / T(2) - T(1123456);\n\nnamespace execution\n{\n    std::chrono::system_clock::time_point start_time, end_time;\n    void print_elapsed_time()\n    {\n        end_time = std::chrono::system_clock::now();\n        std::cerr << \"\\n----- Exec time : \";\n        std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(\n                         end_time - start_time)\n                         .count();\n        std::cerr << \" ms -----\\n\\n\";\n    }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie)\n            {\n                std::ios::sync_with_stdio(false);\n                std::cin.tie(nullptr);\n            }\n            std::cout << std::fixed << std::setprecision(__precision__);\n#ifdef stderr_path\n            if(freopen(stderr_path, \"a\", stderr))\n            {\n                std::cerr << std::fixed << std::setprecision(__precision__);\n            }\n#endif\n#ifdef stdout_path\n            if(not freopen(stdout_path, \"w\", stdout))\n            {\n                freopen(\"CON\", \"w\", stdout);\n                std::cerr << \"Failed to open the stdout file\\n\\n\";\n            }\n            std::cout << \"\";\n#endif\n#ifdef stdin_path\n            if(not freopen(stdin_path, \"r\", stdin))\n            {\n                freopen(\"CON\", \"r\", stdin);\n                std::cerr << \"Failed to open the stdin file\\n\\n\";\n            }\n#endif\n#ifdef LOCAL\n            std::cerr << \"----- stderr at LOCAL -----\\n\\n\";\n            atexit(print_elapsed_time);\n            start_time = std::chrono::system_clock::now();\n#else\n            fclose(stderr);\n#endif\n        }\n    } __setupper;\n} // namespace execution\n\nclass myclock_t\n{\n    std::chrono::system_clock::time_point built_pt, last_pt;\n    int built_ln, last_ln;\n    std::string built_func, last_func;\n    bool is_built;\n\n  public:\n    explicit myclock_t() : is_built(false)\n    {\n    }\n    void build(int crt_ln, const std::string &crt_func)\n    {\n        is_built = true;\n        last_pt = built_pt = std::chrono::system_clock::now();\n        last_ln = built_ln = crt_ln, last_func = built_func = crt_func;\n    }\n    void set(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built)\n        {\n            last_pt = std::chrono::system_clock::now();\n            last_ln = crt_ln, last_func = crt_func;\n        }\n        else\n        {\n            debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \"\n                         << \"myclock_t::set failed (yet to be built!)\\n\";\n        }\n    }\n    void get(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built)\n        {\n            std::chrono::system_clock::time_point crt_pt(\n                std::chrono::system_clock::now());\n            int64_t diff =\n                std::chrono::duration_cast<std::chrono::milliseconds>(crt_pt -\n                                                                      last_pt)\n                    .count();\n            debug_stream << diff << \" ms elapsed from\"\n                         << \" [ \" << last_ln << \" : \" << last_func << \" ]\";\n            if(last_ln == built_ln) debug_stream << \" (when built)\";\n            debug_stream << \" to\"\n                         << \" [ \" << crt_ln << \" : \" << crt_func << \" ]\"\n                         << \"\\n\";\n            last_pt = built_pt, last_ln = built_ln, last_func = built_func;\n        }\n        else\n        {\n            debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \"\n                         << \"myclock_t::get failed (yet to be built!)\\n\";\n        }\n    }\n};\n#ifdef LOCAL\nmyclock_t __myclock;\n#define build_clock() __myclock.build(__LINE__, __func__)\n#define set_clock() __myclock.set(__LINE__, __func__)\n#define get_clock() __myclock.get(__LINE__, __func__)\n#else\n#define build_clock() ((void)0)\n#define set_clock() ((void)0)\n#define get_clock() ((void)0)\n#endif\n\nnamespace std\n{\n    template <class RAitr>\n    void rsort(RAitr __first, RAitr __last)\n    {\n        sort(__first, __last, greater<>());\n    }\n    template <class T>\n    size_t hash_combine(size_t seed, T const &key)\n    {\n        return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2));\n    }\n    template <class T, class U>\n    struct hash<pair<T, U>>\n    {\n        size_t operator()(pair<T, U> const &pr) const\n        {\n            return hash_combine(hash_combine(0, pr.first), pr.second);\n        }\n    };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1>\n    struct tuple_hash_calc\n    {\n        static size_t apply(size_t seed, tuple_t const &t)\n        {\n            return hash_combine(\n                tuple_hash_calc<tuple_t, index - 1>::apply(seed, t),\n                get<index>(t));\n        }\n    };\n    template <class tuple_t>\n    struct tuple_hash_calc<tuple_t, 0>\n    {\n        static size_t apply(size_t seed, tuple_t const &t)\n        {\n            return hash_combine(seed, get<0>(t));\n        }\n    };\n    template <class... T>\n    struct hash<tuple<T...>>\n    {\n        size_t operator()(tuple<T...> const &t) const\n        {\n            return tuple_hash_calc<tuple<T...>>::apply(0, t);\n        }\n    };\n    template <class T, class U>\n    istream &operator>>(std::istream &s, pair<T, U> &p)\n    {\n        return s >> p.first >> p.second;\n    }\n    template <class T, class U>\n    ostream &operator<<(std::ostream &s, const pair<T, U> p)\n    {\n        return s << p.first << \" \" << p.second;\n    }\n    template <class T>\n    istream &operator>>(istream &s, vector<T> &v)\n    {\n        for(T &e : v)\n        {\n            s >> e;\n        }\n        return s;\n    }\n    template <class T>\n    ostream &operator<<(ostream &s, const vector<T> &v)\n    {\n        bool is_front = true;\n        for(const T &e : v)\n        {\n            if(not is_front)\n            {\n                s << ' ';\n            }\n            else\n            {\n                is_front = false;\n            }\n            s << e;\n        }\n        return s;\n    }\n    template <class tuple_t, size_t index>\n    struct tupleos\n    {\n        static ostream &apply(ostream &s, const tuple_t &t)\n        {\n            tupleos<tuple_t, index - 1>::apply(s, t);\n            return s << \" \" << get<index>(t);\n        }\n    };\n    template <class tuple_t>\n    struct tupleos<tuple_t, 0>\n    {\n        static ostream &apply(ostream &s, const tuple_t &t)\n        {\n            return s << get<0>(t);\n        }\n    };\n    template <class... T>\n    ostream &operator<<(ostream &s, const tuple<T...> &t)\n    {\n        return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(\n            s, t);\n    }\n    template <>\n    ostream &operator<<(ostream &s, const tuple<> &t)\n    {\n        return s;\n    }\n    string revstr(string str)\n    {\n        reverse(str.begin(), str.end());\n        return str;\n    }\n} // namespace std\n\n#ifdef LOCAL\n#define dump(...)                                                              \\\n    debug_stream << \"[ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ]\\n\",       \\\n        dump_func(#__VA_ARGS__, __VA_ARGS__)\ntemplate <class T>\nvoid dump_func(const char *ptr, const T &x)\n{\n    debug_stream << '\\t';\n    for(char c = *ptr; c != '\\0'; c = *++ptr)\n    {\n        if(c != ' ') debug_stream << c;\n    }\n    debug_stream << \" : \" << x << '\\n';\n}\ntemplate <class T, class... rest_t>\nvoid dump_func(const char *ptr, const T &x, rest_t... rest)\n{\n    debug_stream << '\\t';\n    for(char c = *ptr; c != ','; c = *++ptr)\n    {\n        if(c != ' ') debug_stream << c;\n    }\n    debug_stream << \" : \" << x << \",\\n\";\n    dump_func(++ptr, rest...);\n}\n#else\n#define dump(...) ((void)0)\n#endif\ntemplate <class P>\nvoid read_range(P __first, P __second)\n{\n    for(P i = __first; i != __second; ++i)\n        std::cin >> *i;\n}\ntemplate <class P>\nvoid write_range(P __first, P __second)\n{\n    for(P i = __first; i != __second;\n        std::cout << (++i == __second ? '\\n' : ' '))\n    {\n        std::cout << *i;\n    }\n}\n\n// substitute y for x.\ntemplate <class T>\nvoid subst(T &x, const T &y)\n{\n    x = y;\n}\n// substitue y for x iff x > y.\ntemplate <class T>\nbool chmin(T &x, const T &y)\n{\n    return x > y ? x = y, true : false;\n}\n// substitue y for x iff x < y.\ntemplate <class T>\nbool chmax(T &x, const T &y)\n{\n    return x < y ? x = y, true : false;\n}\ntemplate <class T>\nconstexpr T minf(const T &x, const T &y)\n{\n    return std::min(x, y);\n}\ntemplate <class T>\nconstexpr T maxf(const T &x, const T &y)\n{\n    return std::max(x, y);\n}\n// binary search.\ntemplate <class int_t, class F>\nint_t bin(int_t ok, int_t ng, const F &f)\n{\n    while(std::abs(ok - ng) > 1)\n    {\n        int_t mid = (ok + ng) / 2;\n        (f(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N>\nvoid init(A (&array)[N], const T &val)\n{\n    std::fill((T *)array, (T *)(array + N), val);\n}\nvoid reset()\n{\n}\ntemplate <class A, class... rest_t>\nvoid reset(A &array, rest_t... rest)\n{\n    memset(array, 0, sizeof(array));\n    reset(rest...);\n}\n// a integer uniformly and randomly chosen from the interval [l, r).\ntemplate <typename int_t>\nint_t rand_int(int_t l, int_t r)\n{\n    static std::random_device seed_gen;\n    static std::mt19937 engine(seed_gen());\n    std::uniform_int_distribution<int_t> unid(l, r - 1);\n    return unid(engine);\n}\n// a real number uniformly and randomly chosen from the interval [l, r).\ntemplate <typename real_t>\nreal_t rand_real(real_t l, real_t r)\n{\n    static std::random_device seed_gen;\n    static std::mt19937 engine(seed_gen());\n    std::uniform_real_distribution<real_t> unid(l, r);\n    return unid(engine);\n}\n\n/* The main code follows. */\n\nusing namespace std;\n// using namespace math;\n\nsigned main()\n{\n    void __solve();\n    void __precalc();\n\n    unsigned int t = inf<int>;\n    // cin >> t;\n    __precalc();\n\n#ifdef LOCAL\n\n#endif\n\n    while(t--)\n    {\n        __solve();\n    }\n}\n\nvoid __precalc()\n{\n}\n\nusing pdd=pair<double,double>;\n\ndouble dist(pdd x, pdd y)\n{\n    double dx=x.first-y.first;\n    double dy=x.second-y.second;\n    return dx*dx+dy*dy;\n}\n\n\n\nvoid __solve()\n{\n    int n; cin>>n;\n    if(not n) return;\n    // vector<vector<double>> di(n,vector<double>(n));\n\n    vector<pdd> p(n);\n    cin>>p;\n\n    auto count=[&](pdd o)->int\n    {\n        int ret=0;\n        for(auto e:p)\n        {\n            if(dist(e,o)<=1.0001)\n            {\n                ret++;\n            }\n        }\n        return ret;\n    };\n\n    int ans=1;\n\n    for(int i=0; i<n; ++i)\n    {\n        for(int j=0; j<i; ++j)\n        {\n            pdd mid=make_pair((p[i].first+p[j].first)/2,(p[i].second+p[j].second)/2);\n            double nor=sqrt(dist(p[i],p[j]));\n            double dis=dist(p[i],mid);\n\n            if(dis>1.0) continue;\n\n            double d=sqrt(1-dist(p[i],mid));\n            pdd nv=make_pair((p[j].second-p[i].second)*d/nor,(p[i].first-p[j].first)*d/nor);\n\n            {\n                pdd cent=make_pair(mid.first+nv.first,mid.second+nv.second);\n                chmax(ans,count(cent));\n            }\n\n            nv.first*=-1,nv.second*=-1;\n\n            {\n                pdd cent=make_pair(mid.first+nv.first,mid.second+nv.second);\n                chmax(ans,count(cent));\n            }\n        }\n    }\n\n    cout<<ans<<\"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\n#define all(c) ((c).begin()),((c).end())\n#define debug(c) cerr<<\"> \"<<#c<<\" = \"<<(c)<<endl;\n#define iter(c) __typeof((c).begin())\n#define tr(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,a,b) for(int i=(int)(a);i<=(int)(b);i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\n#define EPS 1.0e-6\n\n//ツ点\ntypedef complex<double> P;\n\nstruct C{\n\tP p;\n\tdouble r;\n};\n\nvector<P> isCC(const C &c1, const C &c2) {\n\tdouble d = abs(c1.p - c2.p);\n\tif (c1.r + c2.r - d < -EPS || fabs(c1.r - c2.r) - d > EPS) return vector<P>();\n\tdouble x = (d*d + c1.r * c1.r - c2.r * c2.r) / 2 / d;\n\tdouble y = sqrt(c1.r * c1.r - x * x);\n\tP diff = (c2.p - c1.p) / d;\n\tvector<P> res(2);\n\tres[0] = c1.p + diff * P(x, y);\n\tres[1] = c1.p + diff * P(x, -y);\n\treturn res;\n}\n\nint main() {\n\tfor (int N; cin >> N, N != 0; ) {\n\t\tvector<P> ps;\n\t\trep (i, N) {\n\t\t\tdouble x, y; cin >> x >> y;\n\t\t\tps.pb(P(x, y));\n\t\t}\n\t\tint res = 0;\n\t\trep (i, N) REP (j, i + 1, N-1) {\n\t\t\tvector<P> isp = isCC((C){ps[i],1},(C){ps[j],1});\n\t\t\trep (k, isp.size()) {\n\t\t\t\tint cnt = 0;\n\t\t\t\trep (l, N) if (abs(isp[k] - ps[l]) <= 1 + EPS) cnt++;\n\t\t\t\tres = max(res, cnt);\n\t\t\t}\n\t\t}\n\t\tif (res == 0) res++;\n\t\tcout << res <<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n\nusing namespace std;\n\nint main(){\n\n\tint n;\n\tdouble x[301],y[301];\n\tint cnt,ans;\n\n\twhile(1){\n\n\t\tcin>>n;\n\t\tif(n==0) break;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x[i]>>y[i];\n\t\t}\n\n\t\tans=0;\n\t\tfor(double i=0.5;i<=9.5;i+=0.01){\n\t\t\tfor(double j=0.5;j<=9.5;j+=0.01){\n\t\t\t\tcnt=0;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(pow(i-x[k],2.0)+pow(j-y[k],2.0)<=1+1e-9) cnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt>ans) ans=cnt;\n\t\t\t\tcnt=0;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\ntypedef double Num;\ntypedef complex<Num> Pt2;\n\nstruct Circle2 {\n  Pt2 p; Num r;\n  Circle2(Pt2 p, Num r) : p(p), r(r) {}\n};\n\nconst double eps = 1e-10;\nconst double pi  = 3.14159265358979323846;\n\nPt2  ortho(Pt2 v)        { return v*Pt2(0,1); }\nPt2  unit (Pt2 v)        { return v/abs(v);   }\n\nvector<Circle2> make_circle(Pt2 a, Pt2 b, Num r) {\n\tNum d = abs(b-a)/2.0;\n\td = sqrt(r*r-d*d); // assert(r*r-d*d >= 0)\n\tPt2 p = (b+a)/2.0;\n\tPt2 v = unit(ortho(b-a)) * d;\n\n\tvector<Circle2> ret;\n\tret.push_back(Circle2(p+v,r));\n\tret.push_back(Circle2(p-v,r));\n\treturn ret;\n}\n\nbool into_circle(Circle2 p, Pt2 a) {\n\treturn abs(a-p.p)*abs(a-p.p) < p.r*p.r+eps;\n}\n\nint main()\n{\n\tint N;\n\twhile(cin>>N, N)\n\t{\n\t\tPt2 ps[300];\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tNum x,y;\n\t\t\tcin>>x>>y;\n\t\t\tps[i]=Pt2(x,y);\n\t\t}\n\n\t\tint ans=0;\n\t\tfor(int i=  0; i<N; i++)\n\t\tfor(int j=i+1; j<N; j++) {\n\t\t\tif(abs(ps[i]-ps[j]) > 2.0) continue;\n\n\t\t\tvector<Circle2> cs = make_circle(ps[i], ps[j], 1.0);\n\t\t\tfor(int k=0; k<2; k++){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int l=0; l<N; l++) {\n\t\t\t\t\tif(into_circle(cs[k], ps[l])) cnt++;\n\t\t\t\t}\n\t\t\t\tans=max(ans,cnt);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <string>\nusing namespace std;\n\nvector<double> getAreaPointx(int x,int y,vector<double> lx,vector<double> ly)\n{\n\tvector<double> result;\n\tvector<double>::iterator itx=lx.begin();\n\tvector<double>::iterator ity=ly.begin();\n\twhile (itx != lx.end())\n\t{\n\t\tif ((*itx <= x+1) && (*itx >= x-2) && (*ity <= y+1) && (*ity >= y-2)){\n\t\t\tresult.push_back(*itx);\n\t\t}\n\t\titx++;\n\t\tity++;\n\t}\n\treturn result;\n}\n\nvector<double> getAreaPointy(int x,int y,vector<double> lx,vector<double> ly)\n{\n\tvector<double> result;\n\tvector<double>::iterator itx=lx.begin();\n\tvector<double>::iterator ity=ly.begin();\n\twhile (itx != lx.end())\n\t{\n\t\tif ((*itx <= x+1) && (*itx >= x-2) && (*ity <= y+1) && (*ity >= y-2)){\n\t\t\tresult.push_back(*ity);\n\t\t}\n\t\titx++;\n\t\tity++;\n\t}\n\treturn result;\n}\n\n\ndouble distance(double x1,double y1,double x2,double y2)\n{\n\treturn sqrt(pow((x1-x2),2)+pow((y1-y2),2));\n}\n\nint countInside(double x,double y,vector<double> lx,vector<double> ly)\n{\n\tint c=0;\n\tvector<double>::iterator itx=lx.begin();\n\tvector<double>::iterator ity=ly.begin();\n\twhile (itx != lx.end())\n\t{\n\t\tif (distance(x,y,*itx,*ity) <= 1)\n\t\t{\n\t\t\tc++;\n\t\t}\n\t\titx++;\n\t\tity++;\n\t}\n\treturn c;\n}\n\nint main(void) {\n\tvector<int> r;\n\twhile (true)\n\t{\n\t\tint n=0;\n\t\tscanf(\"%d\",&n);\n\t\tif (n==0){\n\t\t\tbreak;\n\t\t}\n\t\tvector<double> x,y;\n\t\tint map[12][12]={{0}};\n\t\tint maxpoint=0;\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tdouble tx=0,ty=0;\n\t\t\tscanf(\"%lf %lf\", &tx, &ty);\n\t\t\tx.push_back(tx);\n\t\t\ty.push_back(ty);\n\t\t\tint ttx=0,tty=0;\n\t\t\tttx = int(round(tx+0.5));\n\t\t\ttty = int(round(ty+0.5));\n\t\t\tmap[ttx][tty]++;\n\t\t\tif (maxpoint < map[ttx][tty]){\n\t\t\t\tmaxpoint = map[ttx][tty];\n\t\t\t}\n\t\t}\n\t\tfor (int i=1; i<=10; i++)\n\t\t{\n\t\t\tfor (int j=1; j<=10; j++)\n\t\t\t{\n\t\t\t\tint aroundpoint=0;\n\t\t\t\tfor (int k=-1; k<=1; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (int l=-1; l<=1; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\taroundpoint+=map[i+k][j+l];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (maxpoint >= aroundpoint){\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tvector<double> lx=getAreaPointx(i,j,x,y);\n\t\t\t\t\tvector<double> ly=getAreaPointy(i,j,x,y);\n\t\t\t\t\tfor (double k=0; k<1; k+=0.01)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (double l=0; l<1; l+=0.01)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint tmp = countInside(i-1+k,j-1+l,lx,ly);\n\t\t\t\t\t\t\tif (tmp>maxpoint){\n\t\t\t\t\t\t\tmaxpoint = tmp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr.push_back(maxpoint);\n\t}\n\tfor(int i=0; i<r.size(); i++)\n\t{\n\t\tcout << r[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> C;\n\nint solve(int N, vector<double>& x, vector<double>& y) {\n    vector<C> point(N);\n\n    for (int j = 0; j < N; ++j) {\n        point[j] = C(x[j], y[j]);\n    }\n\n    int ret = 0;\n\n    for (int j = 0; j < N; ++j) {\n        for (int k = 0; k < N; ++k) {\n            C mid = (point[j] + point[k]) * 0.5;\n\n            C normal = (point[j] - point[k]) * C(0, 1);\n            normal /= abs(point[j] - point[k]);\n\n            double a = 1 - norm(mid - point[j]);\n\n            C centre1 = mid + a * normal;\n            int count = 0;\n            for (int l = 0; l < N; ++l) {\n                if (abs(centre1 - point[l]) < 1) {\n                    ++count;\n                }\n            }\n            ret = max(ret, count);\n\n            C centre2 = mid - a * normal;\n            count = 0;\n            for (int l = 0; l < N; ++l) {\n                if (abs(centre2 - point[l]) < 1.0001) {\n                    ++count;\n                }\n            }\n            ret = max(ret, count);\n\n        }\n    }\n\n    return ret;\n}\n\nint main () {\n    int N;\n    vector<double> x, y;\n\n    while (true) {\n        cin >> N;\n        if (N == 0) break;\n\n        x.resize(N);\n        y.resize(N);\n\n        for (int j = 0; j < N; ++j) {\n            cin >> x[j] >> y[j];\n        }\n\n        cout << solve(N, x, y) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n  int to, cost;\n  bool operator < (const edge& e) const { return cost < e.cost; }\n  bool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n  bool operator < (const Point& a, const Point& b)\n  {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\nstruct Line\n{\n  Point a, b;\n  Line(Point p, Point q) :a(p), b(q) {};\n};\n\nstruct Circle\n{\n  Point p; double r;\n  Circle(Point a, double b) :p(a), r(b) {};\n};\n\ndouble dot(Point a, Point b)\n{\n  return real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b)\n{\n  return imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n  b -= a; c -= a;\n  if (cross(b, c) > EPS) return 1;\t//counter cloclwise\n  if (cross(b, c) < -EPS) return -1;  //cloclwise\n  if (dot(b, c) < 0) return 2;\t\t//c--a--b on line \n  if (norm(b) < norm(c)) return -2;   //a--b--c on line\n  return 0;\t\t\t\t\t\t\t//a--c--b on line\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n  vector<Point> res;\n  double d = abs(c1.p - c2.p);\n  double rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n  double dfr = pow(c1.r, 2) - rc*rc;\n  if (abs(dfr) < EPS) dfr = 0;\n  if (dfr < 0.0) return res;\n  double rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff*Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n  return res;\n}\n\n\n\n\nint main()\n{\n  int n;\n  while (cin >> n, n)\n  {\n    int ans = 1;\n    vector<Point> v;\n    REP(i, n)\n    {\n      double x, y;\n      cin >> x >> y;\n      v.push_back(Point(x, y));\n    }\n    REP(i, n - 1)\n    {\n      FOR(j, 1 + 1, n)\n      {\n        Circle c1(v[i], 1), c2(v[j], 1);\n        auto vp = is_cc(c1, c2);\n\n        REP(k, vp.size())\n        {\n          int cnt = 0;\n          Point tmp = vp[k];\n          REP(l, n)\n          {\n            if (abs(tmp - v[l])-1<= EPS) cnt++;\n          }\n          chmax(ans, cnt);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <complex>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int> > vii;\ntypedef vector<vector<string> > vss;\ntypedef pair<int, int> pii;\n#define INF 0x7fffffff\n//#define INFLL 0x7fffffffffffffff\n#define INFLL LLONG_MAX\n#define SIZE(v) int((v).size())\n#define ALL(v) (v).begin(), (v).end()\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define FORic(i,y,x) for(int i=y;i<=x;i++)\n#define FORdc(i,y,x) for(int i=y;i>=x;i--)\n#define FILL(a,v) memset(a, v, sizeof(a))\n#define PI 3.14159265358979323846\n\ntypedef complex<double> P; /* _ */\ntypedef pair<P, double> C; /* ~ */\nstruct L { P p, q; L(P p, P q) : p(p), q(q) {} }; /* üª */\n\nconst double EPS = 1e-13;\n\n// complexÉå¬ÖWªKvÈê(intersCSÅgp)\nbool operator < (const P &a, const P &b) {\n\treturn make_pair(real(a),imag(a)) < make_pair(real(b),imag(b));\n}\n\n\n// ~Ìð_ðÔ·(æÉð·»èK{)\npair<P,P> crossCC(C c1, C c2){\n\tdouble r1 = c1.second;\n\tdouble r2 = c2.second;\n\tdouble r3 = abs(c1.first-c2.first);\n\tdouble rc = (r3*r3+r1*r1-r2*r2)/(2*r3);\n\tdouble rs = sqrt(r1*r1-rc*rc);\n\tP dif = (c2.first-c1.first)/r3;\n\tP p1 = c1.first+dif*P(rc,rs);\n\tP p2 = c1.first+dif*P(rc,-rs);\n\treturn make_pair(p1,p2);\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n){\n\t\tif(!n) break;\n\t\tvector<P> all;\n\t\tFOR(i, n){\n\t\t\tdouble x, y;\n\t\t\tcin>>x>>y;\n\t\t\tall.push_back(P(x,y));\n\t\t}\n\t\tvector<P> couho;\n\t\tFOR(i, n-1){\n\t\t\tFORic(j, i+1, n-1){\n\t\t\t\tif(abs(all[j]-all[i])<=2+EPS){\n\t\t\t\t\tpair<P,P> temp = crossCC(C(all[i], 1), C(all[j], 1));\n\t\t\t\t\tcouho.push_back(temp.first);\n\t\t\t\t\tcouho.push_back(temp.second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(SIZE(couho)==0){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = 0;\n\t\tFOR(i, SIZE(couho)){\n\t\t\tint count = 0;\n\t\t\tFOR(j, n){\n\t\t\t\tif(abs(couho[i]-all[j])<=1+EPS){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, count);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n\nusing namespace std;\ntypedef pair<double, double> P;\nconst double EPS = 1e-4;\n\n#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n\nusing namespace std;\n\ndouble dist(P a, P b)\n{\n    return hypot(a.first - b.first, a.second - b.second);\n}\n\nvector<P> center(P a, P b)\n{\n    auto t = atan2(b.first - a.first, b.second - a.second);\n    auto x = dist(a, b) / 2;\n    auto y = sqrt(1.0 - x * x);\n    auto cs = cos(t), sn = sin(t);\n    return { \n        { cs * x - sn * y + a.first, sn * x + cs * y + a.second },\n        { cs * x + sn * y + a.first, sn * x - cs * y + a.second }\n    };\n}\n\nint main()\n{\n    while (1) {\n        int n; cin >> n;\n        if (!n) break;\n        vector<P> pnt;\n        loop (n, i) {\n            double x, y; cin >> x >> y;\n            pnt.emplace_back(x, y);\n        }\n        int ans = 1;\n        loop (n, i) loop (n, j) {\n            auto ps = center(pnt[i], pnt[j]);\n            for (auto o : ps) {\n                int cnt = 0;\n                loop (n, l) {\n                    auto x = o.first - pnt[l].first;\n                    auto y = o.second - pnt[l].second;\n                    if (x * x + y * y < 1 + EPS) cnt++;\n                    //if (dist(o, pnt[l]) < 1 + EPS) cnt++;\n                }\n                ans = max(ans, cnt);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\n#define MAX_N 310\n\nlong double x[MAX_N], y[MAX_N];\nint n, maxn;\n\nint main() {\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tmaxn = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tint sum = 0;\n\n\t\t\t\tlong double X = (x[i] + x[j]) / 2.0;\n\t\t\t\tlong double Y = (y[i] + y[j]) / 2.0;\n\n\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t{\n\t\t\t\t\tif (((x[k] - X)*(x[k] - X) + (y[k] - Y)*(y[k] - Y)) <= 1) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\n\t\t\t\tlong double X1, Y1, X2, Y2, X3, Y3, VX2, VY2, Dist, Dist2;\n\n\t\t\t\tDist = sqrt((x[j] - x[i])*(x[j] - x[i]) + (y[j] - y[i])*(y[j] - y[i]));\n\t\t\t\tDist2 = sqrt(4 - Dist*Dist);\n\t\t\t\tX2 = x[j] - x[i]; Y2 = y[j] - y[i];\n\t\t\t\tVX2 = (X2 / Dist)*Dist2 / 2; VY2 = (Y2 / Dist)*Dist2 / 2;\n\t\t\t\tX1 = X + VY2; Y1 = Y - VX2;\n\t\t\t\tX3 = X - VY2; Y3 = Y + VX2;\n\n\t\t\t\tsum = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (((x[k] - X1)*(x[k] - X1) + (y[k] - Y1)*(y[k] - Y1)) <= 1) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\t\t\t\tsum = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (((x[k] - X3)*(x[k] - X3) + (y[k] - Y3)*(y[k] - Y3)) <= 1) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint sum = 0;\n\t\t\tlong double X = x[i];\n\t\t\tlong double Y = y[i];\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (((x[k] - X)*(x[k] - X) + (y[k] - Y)*(y[k] - Y)) <= 1) {\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxn = max(maxn, sum);\n\t\t}\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<double,double> P;\ntypedef pair<int,P> PP;\n\nint n;\nint ans;\nvector<double> x, y;\nvector<PP> v;\n\nvoid solve(){\n\tx.clear(); y.clear(); v.clear();\n\tx.resize(n); y.resize(n);\n\tans = 1;\n\trep(i,n) cin >> x[i] >> y[i];\n\tfor(int i = 0; i <= 1000; i++) for(int j = 0; j <= 1000; j++){\n\t\tdouble I = i/100.0, J = j/100.0;\n\t\tint cnt = 0;\n\t\trep(k,n){\n\t\t\tif((x[k]-I)*(x[k]-I)+(y[k]-J)*(y[k]-J) < 1) cnt++;\n\t\t}\n\t\tv.push_back(PP(cnt,P(I,J)));\n\t}\n\tsort(v.begin(),v.end(), greater<PP>());\n\trep(u,10){\n\t\tP p = v[u].second;\n\t\tfor(int i = 0; i <= 100; i++) for(int j = 0; j <= 100; j++){\n\t\t\tdouble I = p.first-0.005+i/10000.0, J = p.second-0.005+j/10000.0;\n\t\t\tint cnt = 0;\n\t\t\trep(k,n){\n\t\t\t\tif((x[k]-I)*(x[k]-I)+(y[k]-J)*(y[k]-J) < 1) cnt++;\n\t\t\t}\n\t\t\tans = max(ans,cnt);\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nint main(){\n\twhile(cin >> n){\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n#define OUT 0\n#define ON 1\n#define IN 2\n#define EPS 0.00009\n//#define EPS (1e-10)\nclass P{                    //テァツつケ\npublic:\n\tdouble x,y;\n\t\n\tP(double _x=0,double _y=0):x(_x),y(_y){};\n\tP operator + (const P &p     )const{ return P( x+p.x , y+p.y ); }  //テ・ツ環?ァツョツ?\n\tP operator - (const P &p     )const{ return P( x-p.x , y-p.y ); }  //テヲツクツ崚ァツョツ?\n\tP operator * (const double k )const{ return P( x*k   , y*k    ); } //テ、ツケツ療ァツョツ?\n\tP operator / (const double k )const{ return P( x/k   , y/k    ); } //テゥツ卍、テァツョツ?\n\t\n\tbool operator == (const P &p){ return ( fabs(x-p.x)<EPS && fabs(y-p.y)<EPS ); }\n\tbool operator < (const P &p) const{ return ( x!=p.x ? x<p.x:y<p.y ); }\n\t\n\tdouble norm(){ return x*x+y*y; }        //テ」ツδ偲」ツδォテ」ツδ?\n\tdouble abs() { return sqrt(norm()); }   //テ・ツ、ツァテ」ツ?催」ツ??\n};\nstruct C{P p;double r;};    //テ・ツ??\nstruct S{P p1,p2;};         //テァツキツ堙・ツ按?\ntypedef vector<P> Polygon;  //テ・ツ、ツ堙ィツァツ津・ツスツ「\ntypedef P Vector;           //テ」ツδ凖」ツつッテ」ツδ暗」ツδォ\ntypedef S L;                //テァツ崢エテァツキツ?\n\ndouble norm (P p)               { return p.norm(); }\ndouble abs  (P p)               { return p.abs(); }\ndouble dot  (Vector a,Vector b) { return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b) { return a.x*b.y-a.y*b.x; }\ndouble sqDist(P a, P b)         {return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}\ndouble dist (P a, P b)          {return sqrt(sqDist(a,b));}\nVector vec(S a)                 {return P(a.p2.x-a.p1.x,a.p2.y-a.p1.y);}\n\nint ccw(P p0,P p1,P p2){    //AOJ_BOOK_P386 verified\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\t\n\tif( cross(a,b) > EPS  ) return 1 ;      //COUNTER_CLOCKWISE\n\tif( cross(a,b) < -EPS ) return -1;      //CLOCKWISE\n\tif( dot(a,b)   < -EPS ) return 2;       //ONLINE_BACK\n\tif( a.norm()   < b.norm() ) return -2;  //ONLINE_FRONT\n\t\n\treturn 0;                               //ON_SEGMENT;\n}\n\n//テァツ崢エテァツキツ堙ァツ崢エティツ。ツ古・ツ按、テ・ツョツ?verified AOJ0058\nbool orthogonal(P p1,P p2,P p3,P p4){ return abs(dot(p1-p2,p3-p4))<EPS; }\n\n//テァツキツ堙・ツ按?、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?\nbool intersect(P p1,P p2,P p3,P p4){ return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); }\n\n//テァツキツ堙・ツ按?」ツ?ィテァツつケテ」ツ?ョティツキツ敕ゥツ崢「 verified ARC042-B\ndouble dLP(S l, P p) { return abs(cross(l.p2-l.p1, p-l.p1)) /(l.p2-l.p1).abs(); }\n\n//テァツキツ堙・ツ按?」ツ?ォテ・ツッツセテ」ツ?凖」ツつ凝ァツつケテ」ツ?ョテ・ツーツ?・ツスツア verified AOJ CGL_1_A\nP project(S s, P p){\n\tVector base = s.p2-s.p1;\n\tdouble r = dot(p-s.p1, base)/norm(base);\n\treturn (base*r)+s.p1;\n}\n\n//テァツキツ堙・ツ按?」ツ?ォテ・ツッツセテ」ツ?凖」ツつ凝ァツつケテ」ツ?ョテ・ツ渉催・ツーツ?verified AOJ CGL_1_B\nP reflect(S s,P p){ return p+(project(s,p)-p)*2.0; }\n\n//テァツ崢エテァツキツ堙」ツ?ィテァツ崢エテァツキツ堙」ツ?ョテゥツ鳴「テ、ツソツ?verified AOJ CGL_2\nint rLL(L a,L b){\n\tif( cross(vec(a),vec(b))==0 ) return 2; //テ、ツクツヲティツ。ツ?\n\tif( dot(vec(a),vec(b))==0 )   return 1; //テ・ツ楪づァツ崢エ\n\treturn 0;\n}\n\n// テ・ツ??」ツ?ィテァツつケテ」ツ?ョテ・ツ??・ツ、ツ姪・ツ按、テ・ツョツ?\nint contains(C c, P p){\n\tdouble d = (c.p-p).abs();\n\tif(d-c.r>EPS) return OUT;\n\tif(abs(d-c.r)<EPS) return ON;\n\treturn IN;\n}\n\n//テァツ崢エテァツキツ堙」ツ?ィテ・ツ??」ツ?ョテ、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?テゥツ?催」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝・ツ?エテ・ツ青暗」ツ?ッテ、ツコツ、テ・ツキツョテヲツ可アテ」ツ??\nbool intersect_circle_(P center, double r, L line){\n\tif( dLP(line,center) <= r+EPS ) return true;\n\treturn false;\n}\n\n//テァツキツ堙・ツ按?」ツ?ィテ・ツコツ療」ツ?ョティツキツ敕ゥツ崢「 verified QUPC-G\ndouble dSP(S s, P p){\n\tif(dot((s.p2-s.p1)   , p-s.p1) <= EPS) return (p - s.p1).abs();\n\tif(dot((s.p2-s.p1)*-1, p-s.p2) <= EPS) return (p - s.p2).abs();\n\treturn dLP(s, p);\n}\n\n//テァツキツ堙・ツ按?」ツ?ィテ・ツ??」ツ?ョテ、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?テゥツ?催」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝・ツ?エテ・ツ青暗」ツ?ッテ、ツコツ、テ・ツキツョテヲツ可アテ」ツ?? verified QUPC-G\nbool iCS(C c, S l){\n\tint c1 = contains(c, l.p1);\n\tint c2 = contains(c, l.p2);\n\tif(c1 > c2) swap(c1, c2);\n\t\n\t// (OUT, OUT) (OUT, ON) (OUT, IN) (ON, ON) (ON, IN) (IN, IN) テ」ツ?ョ6テゥツ?堙」ツつ?\n\tif(c1 == OUT && c2 == IN) return true;\n\tif(c1 == IN  && c2 == IN) return false;\n\tif(c1 == ON) return true; // (テヲツ篠・テ」ツ?凖」ツつ凝」ツ?ィテ」ツ??\n\tdouble d = dSP(l, c.p);\n\tif(d-c.r<-EPS) return true;\n\tif(d-c.r>EPS) return false;\n\treturn true; // (テヲツ篠・テ」ツ?凖」ツつ凝」ツ?ィテ」ツ??\n}\n\n//テ・ツ債佚ァツエツ氾・ツ、ツ堙ィツァツ津・ツスツ「テ・ツ按、テ・ツョツ?\nbool isSimple( Polygon pol ){\n\t//テ・ツ按敕」ツつ?」ツ?ョテァツつケテ」ツつ津ゥツ?催ィツ、ツ?」ツ?療」ツ?ヲpolテ」ツ?ォテ・ツ?・テ」ツつ古」ツ?ヲテ」ツ?甘」ツ??\n\tsize_t pol_size = pol.size()-1;\n\trep(i,pol_size){\n\t\tfor(int j=i+2;j<pol_size;j++){\n\t\t\tif( i==j || i==(j-1+pol_size)%pol_size || i==(j+1+pol_size)%pol_size )continue;\n\t\t\tif( intersect(pol[i], pol[i+1], pol[j], pol[j+1]) )return false;\n\t\t}\n\t}\n\treturn true;\n}\n\n//テァツつケテ」ツ?古・ツ?クテ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ョテ・ツ??・ツ?エテ」ツ?ォテ」ツ?づ」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ?凝」ツつ津ヲツアツづ」ツつ?」ツつ?trueテ」ツ?ェテ」ツつ嘉・ツ??・ツ?エ verified AOJ0012\nint isPointInsidePolygon(vector<P> pol,P p){\n\tint c=0;\n\trep(i,pol.size()){\n\t\tif( cross(pol[i]-pol[(i+1)%pol.size()] , p-pol[(i+1)%pol.size()])==0 ) return ON;\n\t\tif( cross(pol[i]-pol[(i+1)%pol.size()] , p-pol[(i+1)%pol.size()])>0 ) c++;\n\t}\n\tif( c%pol.size() )return OUT;\n\treturn IN;\n}\n\n//テ・ツ??」ツ?ィテ・ツ?クテ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ョテ、ツコツ、テ・ツキツョテァツ環カテヲツ?凝」ツつ津ィツェツソテ」ツ?ケテ」ツつ?\nint CPOLarea(C c ,Polygon pol){\n\tvector<L> lines;\n\tvector<int> res(pol.size());\n\tbool POLinC=true, isFar=true;\n\t\n\trep(i,pol.size()){\n\t\tif( contains(c,pol[i])==OUT )POLinC=false;\n\t\tres[i] = contains(c,pol[i]);\n\t\tlines.pb( L{ pol[i] , pol[(i+1)%pol.size()] });\n\t\tif( sqDist(c.p,pol[i])<c.r*c.r )isFar=false;\n\t}\n\t\n\tif( POLinC )                                        return 2;   //テ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ッテ・ツ??」ツ?ョテ・ツ??ゥツδィb\n\tif( isPointInsidePolygon(pol, c.p)==IN && isFar )   return 3;   //テ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ョテ・ツ??ゥツδィテ」ツ?ォテ・ツ??\n\trep(i,lines.size()) if( iCS(c,lines[i]) )           return 1;   //テ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ィテ・ツ??」ツ?ッテ、ツコツ、テ・ツキツョc\n\treturn 0;\n}\n\n//テ・ツ?クテ・ツ個?verified AOJ0068,QUPC-G\n//ティツセツ榲ヲツ崢クテゥツ??」ツ?ァテヲツッツ氾ィツシツ?\nbool cmp_x(const P& p, const P& q){\n\tif(p.x != q.x)return p.x<q.x;\n\treturn p.y<q.y;\n}\n\n//テ・ツ?クテ・ツ個?」ツつ津ヲツアツづ」ツつ?」ツつ?\nvector<P> convex_hull(vector<P> ps){\n\tint n = ps.size();\n\tsort(all(ps),cmp_x);\n\tint k=0;            //テ・ツ?クテ・ツ個?」ツ?ョテゥツ?づァツつケテヲツ閉ー\n\tvector<P> qs(n*2);  //テヲツァツ凝ヲツ按静、ツクツュテ」ツ?ョテ・ツ?クテ・ツ個?\n\t//テ、ツクツ凝・ツ?エテ・ツ?クテ・ツ個?」ツ?ョテ、ツスツ愿ヲツ按?\n\trep(i,n){\n\t\twhile( k>1 && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n\t\tqs[k++]=ps[i];\n\t}\n\t//テ、ツクツ甘・ツ?エテ・ツ?クテ・ツ個?」ツ?ョテ、ツスツ愿ヲツ按?\n\tfor(int i=n-2, t=k;i>=0;i--){\n\t\twhile( k>t && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n\t\tqs[k++]=ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n\n\n//2テァツつケテ」ツつ津ゥツ?堙」ツつ凝・ツ債甘・ツセツвテ」ツ?ョテ・ツ??」ツ?ョテ、ツクツュテ・ツソツε・ツコツァテヲツィツ凖」ツつ津ヲツアツづ」ツつ?」ツつ?\npair<P,P> geoGetCircleOf2pAndR(P p1,P p2,double r){\n\tP pc1=P(-INF,-INF), pc2(-INF,-INF), p3;\n\tdouble d, l, dx, dy ;\n\t\n\tp3 = (p1+p2)/2.0;\n\tl = sqDist(p2,p3);\n\t\n\tif  (r*r >= l) {\n\t\td  = sqrt(r*r / l - 1.0) ;\n\t\tdx = d * (p2.y - p3.y) ;\n\t\tdy = d * (p2.x - p3.x) ;\n\t\t\n\t\tpc1.x = p3.x + dx ;\n\t\tpc1.y = p3.y - dy ;\n\t\t\n\t\tpc2.x = p3.x - dx ;\n\t\tpc2.y = p3.y + dy ;\n\t}\n\treturn pair<P,P>(pc1,pc2);\n}\n\n\nint main(){\n\tint n;\n\twhile(cin>>n&&n){\n\t\tint ans=0;\n\t\tvector<P> ps(n);\n\t\trep(i,n)cin>>ps[i].x>>ps[i].y;\n\t\t\n\t\trep(i,n){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(dist(ps[i],ps[j])>2+EPS)continue;\n\t\t\t\tpair<P,P> res = geoGetCircleOf2pAndR(ps[i],ps[j],1);\n\t\t\t\tint suma=0,sumb=0;\n\t\t\t\trep(k,n){\n\t\t\t\t\tif(sqDist(ps[k],res.first )<1+EPS)suma++;\n\t\t\t\t\tif(sqDist(ps[k],res.second)<1+EPS)sumb++;\n\t\t\t\t}\n\t\t\t\tans = max(ans,max(suma,sumb));\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double r = 1.0;\nconst double PI = acos(-1.0);\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y) : x(x), y(y) {}\n};\ninline double Distance2(const Point &a, const Point &b) {\n    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    std::random_device rnd;\n    std::mt19937 mt(rnd());\n    std::uniform_real_distribution<> rand100(0.0, 10.0);\n\n    while (cin >> n, n) {\n        // Input\n        vector<Point> p(n);\n        for (int i = 0; i < n; ++i)\n            cin >> p[i].x >> p[i].y;\n\n        // Solve\n        int ans = 1;\n        auto start = std::chrono::high_resolution_clock::now();\n        auto end = std::chrono::high_resolution_clock::now();\n        auto take_time = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n\n        while (true) {\n            end = std::chrono::high_resolution_clock::now();\n            take_time = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n            if (350 < take_time.count())\n                break;\n\n            for (int i = 0; i < 10; ++i) {\n                Point c(rand100(mt), rand100(mt));\n                int num = 0;\n                for (int j = 0; j < n; ++j) {\n                    double d = Distance2(p[j], c);\n                    if (d <= 1.0)\n                        ++num;\n                }\n                ans = max(ans, num);\n            }\n        }\n\n        // Output\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\nconst double PI=3.141592653589793238462643383279;\n\nbool inC(P p, P c, double r){return abs(p-c)<r+1e-9;}\n\nP getE(P p){return p/abs(p);}\n\ndouble sq(double x){ return  x*x;}\n\nint main(){\n    int n,i,j,k,ans,cnt;\n    double x, y;\n    while(scanf(\"%d\",&n)){\n        if(n==0) break;\n        ans=0;\n        vector<P> ps(n);\n        for(i=0; i<n; i++){\n            scanf(\"%lf%lf\",&x,&y);\n            ps[i] = P(x,y);\n        }\n        for(i=0;i<n;i++)\n            for(j=i+1;j<n;j++)if(abs(ps[i]-ps[j])<2){\n                double d=sqrt(1-sq(abs(ps[j]-ps[i])*0.5));\n                P c1=0.5*(ps[i]+ps[j])+getE(getE(ps[j]-ps[i]))*polar(d,PI/2);\n                P c2=0.5*(ps[i]+ps[j])+getE(getE(ps[j]-ps[i]))*polar(d,-PI/2);\n                cnt=0;\n                for(k=0;k<n;k++)if(inC(ps[k],c1,1.0))cnt++;\n                if(cnt>ans)ans=cnt;\n                cnt=0;\n                for(k=0;k<n;k++)if(inC(ps[k],c2,1.0))cnt++;\n                if(cnt>ans)ans=cnt;\n            }\n        if(ans==0) ans++;\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define REPR(i, n) for(int i = n; i >= 0; i--)\n#define FOR(i, m, n) for(int i = m; i < n; i++)\n#define FORR(i, m, n) for(int i = m; i >= n; i--)\n#define INF (ll)2e9\n#define MOD ((ll)1e9+7)\n#define ALL(v) v.begin(), v.end()\n#define SZ(x) ((int)(x).size())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define y0 y3487465\n#define y1 y8687969\n#define j0 j1347829\n#define j1 j234892\n#define next asdnext\n#define prev asdprev\n#define bit(n) (1LL<<(n))\n#define cauto const auto&\n#define println(v) cout << v << \"\\n\";\n\nvoid show(vector<vector<ll>>& arr, int w) {\n    cout << right << setw(w) << \"#\";\n    REP(i, SZ(arr[0]))  {\n        cout << right << setw(w) << i;\n    }\n    cout << endl;\n    REP(i, SZ(arr)) {\n        cout << right << setw(w) << i;\n        REP(j, SZ(arr[0])){\n            cout << right << setw(w) << arr[i][j];\n        }\n        cout << endl;\n    }\n}\n\ninline vector<vector<vector<ll>>> makeVector(ll i, ll j, ll k) {\n    vector<vector<vector<ll>>> v(i, vector<vector<ll>>(j, vector<ll>(k, 0)));\n    return v;\n}\ninline vector<vector<ll>> makeVector(ll i, ll j) {\n    vector<vector<ll>> v(i, vector<ll>(j, 0));\n    return v;\n}\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ntemplate <class InputIterator>\nInputIterator adv(InputIterator x, typename std::iterator_traits<InputIterator>::difference_type n) {\n    advance(x, n);\n    return x;\n}\n\nclass mod {\n    static ll fact[];\npublic:\n\n    template<class... A>\n    static ll mul(A... args) {\n        ll res = 1;\n        for (ll i : std::initializer_list<ll>{args...}) {\n            res = (res * i) % MOD;\n        }\n        return res;\n    }\n\n    static ll power(ll base, ll exp) {\n        if (exp == 0) return 1;\n        if (exp & 1) {\n            return mul(base, power(base, exp - 1));\n        } else {\n            ll p = power(base, exp / 2);\n            return mul(p, p);\n        }\n    }\n\n    static ll factorial(int n) {\n        if (fact[n] != 0) return fact[n];\n        if (n == 0) return 1;\n        return fact[n] = mul(n, factorial(n - 1));\n    }\n\n    static ll inverse(int n) {\n        return power(n, MOD - 2);\n    }\n\n    static ll comb(int n, int r) {\n        if (r < 0 || r > n) return 0;\n        return mul(factorial(n), inverse(factorial(n - r)), inverse(factorial(r)));\n    }\n\n    template<class... A>\n    static ll div(ll dividend, A... args) {\n        ll res = dividend;\n        for (ll i : std::initializer_list<ll>{args...}) {\n            res = mul(res, inverse(i));\n        }\n        return res;\n    }\n\n    template<class... A>\n    static ll add(A... args) {\n        ll res = 0;\n        for (ll i : std::initializer_list<ll>{args...}) {\n            res = (res + i) % MOD;\n        }\n        return res;\n    }\n\n    template<class... A>\n    static ll sub(ll l, A... args) {\n        ll res = l;\n        for (ll i : std::initializer_list<ll>{args...}) {\n            res = (res - i + MOD) % MOD;\n        }\n        return res;\n    }\n};\nll mod::fact[(int) 1e6 + 1];\n\nint ni() {\n    int i;\n    cin >> i;\n    return i;\n}\nll nll() {\n    ll l;\n    cin >> l;\n    return l;\n}\n\ndouble dist(double x1, double y1, double x2, double y2) {\n    return sqrt(pow(x1-x2, 2) + pow(y1-y2, 2));\n}\n\nint count_dots(double cx, double cy, vector<pair<double, double>>& points, int p, int q) {\n    int count = 2;\n    REP(i, SZ(points)) {\n        if (i == p || i == q) continue;\n        if (dist(points[i].first, points[i].second, cx, cy) <= 1) count++;\n    }\n    return count;\n}\n\nint main()\n{\n    while(true) {\n        int N = ni();\n        if (N == 0) break;\n\n        vector<pair<double, double>> points(N);\n        REP(i, N) {\n            double x, y;\n            cin >> x >> y;\n            points[i] = make_pair(x, y);\n        }\n\n        int ans = 1;\n\n        REP(pi, N) {\n            FOR(qi, pi+1, N) {\n                double x1 = points[pi].first, y1 = points[pi].second;\n                double x2 = points[qi].first, y2 = points[qi].second;\n\n                double a = -(x2-x1)/(y2-y1);\n                double b = (y2*y2 - y1*y1 + x2*x2 - x1*x1) / (y2 - y1) / 2;\n\n                double A = a*a + 1;\n                double B = -2*x1 + 2 * a * b - 2 * a * y1;\n                double C = x1*x1 + b*b - 2*b*y1 + y1*y1 - 1;\n\n                double D = B*B - 4 * A * C;\n                if (B*B - 4 * A * C >= 0) {\n                    double cx = (-B + sqrt(D)) / (2 * A);\n                    double cy = a * cx + b;\n                    ans = max(ans, count_dots(cx, cy, points, pi, qi));\n                    cx = (-B - sqrt(D)) / (2 * A);\n                    cy = a * cx + b;\n                    ans = max(ans, count_dots(cx, cy, points, pi, qi));\n                }\n\n            }\n\n        }\n\n        println(ans);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <complex>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nld dot (P a, P b) { return real(conj(a) * b); }\nld cross (P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n  bool operator<(const P &lhs, const P &rhs) {\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag() : lhs.real() < rhs.real();\n  }\n}\n\nstruct sq {\n  P p;\n  ld sz;\n  sq(P p_, ld sz_) : p(p_), sz(sz_) {}\n};\n\nbool operator<(const sq& l, const sq& r) { return l.p < r.p; }\n\npair<int, int> f(const VP& vp, sq s) {\n  ld margin = s.sz / sqrt(2.0);\n  P c = s.p + P(s.sz / 2.0, s.sz / 2.0);\n  int mx = 0;\n  int mn = 0;\n  for(P p : vp) {\n    if(abs(p-c) <= 1 + margin) {\n      ++mx;\n      if(abs(p-c) <= 1 - margin) {\n        ++mn;\n      }\n    }\n  }\n  return make_pair(mx, mn);\n}\n\nint calc(const VP& vp) {\n  std::priority_queue<pair<int, sq>> q;\n  int mx_of_mn = 0;\n  sq start(P(), 10.0);\n  q.push(make_pair(f(vp,start).first, start));\n  while (!q.empty()){\n    auto p = q.top(); q.pop();\n    if (mx_of_mn >= p.first) return mx_of_mn;\n    REP(i,2)REP(j,2){\n      P c = p.second.p + P(i * p.second.sz / 2, j * p.second.sz / 2);\n      sq ns(c, p.second.sz / 2);\n      auto rng = f(vp, ns);\n      mx_of_mn = max(mx_of_mn, rng.second);\n      q.push(make_pair(rng.first, ns));\n    }\n  }\n  return mx_of_mn;\n}\n\nint main() {\n  while(1){\n    int n;\n    cin >> n;\n    if(!n) break;\n    VP vp;\n    REP(i,n){\n      ld x,y;\n      cin >> x >> y;\n      vp.emplace_back(x,y);\n    }\n    cout << calc(vp) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#define EPS 1e-9\nusing namespace std;\ntypedef complex<double> xy_t;\nint n;\nxy_t points[301];\nint count_in(xy_t center)\n{\n  int ans=0;\n  for(int i=0;i<n;i++)\n  {\n    if (abs(center-points[i])<1.0+EPS)\n      ans++;\n  }\n  return ans;\n}\n\nxy_t ppdcl(xy_t a)\n{\n  return xy_t(a.imag(),-a.real());\n}\nxy_t delta_v(xy_t C1,xy_t C2)\n{\n  xy_t half=(C1-C2)*0.5;\n  double l=abs(half);\n  return ppdcl(half)*sqrt(1-l*l)*(1.0/l);\n}\n\nint main()\n{\n  while(1)\n  {\n    cin>>n;\n    if (n==0) break;\n    double x,y;\n    for(int i=0;i<n;i++)\n    {\n      cin>>x>>y;\n      points[i]=xy_t(x,y);\n    }\n    int maxn=1;\n    for(int i=0;i<n;i++)\n    {\n      for(int j=i;j<n;j++)\n      {\n        if(abs(points[i]-points[j])<2.0+EPS)\n        {\n          xy_t mid_p=(points[i]+points[j])*0.5;\n          maxn=max(maxn,count_in(mid_p+delta_v(points[i],points[j])));\n          maxn=max(maxn,count_in(mid_p-delta_v(points[i],points[j])));\n        }\n        /*double d=abs(points[j]-points[i])/2;\n        xy_t v=(points[j]-points[i])/(2*d);\n        if(d<1)\n        {\n            maxn=max(maxn,count_in(points[i]+d*v+sqrt(1-d*d)*v*xy_t(0,+1)));\n            maxn=max(maxn,count_in(points[i]+d*v+sqrt(1-d*d)*v*xy_t(0,-1)));\n        }*/\n      }\n    }\n    cout<<maxn<<endl;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\nint n;\nP pts[353];\n\nint check(P c){\n  int ret = 0;\n  REP(i,n){\n    if(abs(c-pts[i])<=1.00001)ret++;\n  }\n  return ret;\n}\n\nint main(){\n  while(true){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    REP(i,n){\n      double x,y;\n      scanf(\"%lf%lf\",&x,&y);\n      pts[i] = P(x,y);\n    }\n    int ans = 0;\n    REP(i,n)REP(j,i){\n      P a,b;\n      a = pts[i];\n      b = pts[j];\n      double l = abs(b-a);\n      if(l>2.0)continue;\n      double h = sqrt(1.0-l*l/4.0);\n      P c;\n      c = a + (b-a)/2.0 + (b-a)*P(0,1)*h/l;\n      ans = max(ans,check(c));\n      c = a + (b-a)/2.0 + (b-a)*P(0,-1)*h/l;\n      ans = max(ans,check(c));\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define LP(i,n) for(int i = 0; i < n; i++)\n\nusing namespace std;\ntypedef pair<double,double> P;\n\ndouble Dist(double x1[], double x2[]){\n\treturn pow((x1[0]-x2[0])*(x1[0]-x2[0])+(x1[1]-x2[1])*(x1[1]-x2[1]),0.5);\n\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\twhile(n){\n\t\tP p[300];\n\t\tLP(i,n){\n\t\t\tcin >> p[i].first >> p[i].second;\n\t\t}\n\t\tsort(p,p+n);\n\t\tdouble x[300][2];\n\t\tLP(i,n){\n\t\t\tx[i][0] = p[i].first;\n\t\t\tx[i][1] = p[i].second;\n\t\t}\n\t\tdouble dist[300][300];\n\t\tLP(i,n){\n\t\t\tLP(j,n){\n\t\t\t\tdist[i][j] = Dist(x[i],x[j]);\n\t\t\t}\n\t\t}\n\t\tint mx = 0;\n\t\tLP(i,n){\n\t\t\tfor(int j = i+1; j < n; j++){\n\t\t\t\tif(x[j][0]-x[i][0] > 2){\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tif(dist[i][j] < 2){\n\t\t\t\t\t\tdouble m[] = {(x[j][0]+x[i][0])/2,(x[j][1]+x[i][1])/2};\n\t\t\t\t\t\tdouble d[] = {x[j][1]-x[i][1],-x[j][0]+x[i][0]};\n\t\t\t\t\t\tdouble O[] = {0,0};\n\t\t\t\t\t\tdouble _d = Dist(d,O);\n\t\t\t\t\t\tLP(k,2){\n\t\t\t\t\t\t\td[k] *= (pow(_d,-2)-0.25);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdouble o[2][2];\n\t\t\t\t\t\tLP(k,2){\n\t\t\t\t\t\t\tLP(l,2){\n\t\t\t\t\t\t\t\to[k][l] = m[l];\n\t\t\t\t\t\t\t\tif(k) o[k][l] += d[l];\n\t\t\t\t\t\t\t\telse o[k][l] -= d[l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLP(k,2){\n\t\t\t\t\t\t\tint s = 2;\n\t\t\t\t\t\t\tfor(int l = i+1; l < j; l++){\n\t\t\t\t\t\t\t\tif(Dist(x[l],o[k]) < 1) s++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int l = i-1; 0<=l && x[i][0]-x[l][0] < 1;l--){\n\t\t\t\t\t\t\t\tif(Dist(x[l],o[k]) < 1) s++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int l = j+1; l < n && x[l][0]-x[j][0] < 1; l++){\n\t\t\t\t\t\t\t\tif(Dist(x[l],o[k]) < 1) s++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmx = max(mx,s);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << mx << endl;\n\t\tcin >> n;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\nint main() {\n\n  while( true ) {\n\n    long long int n;\n    cin >> n;\n    if ( n == 0 ) break;\n\n    vector< double > x, y;\n\n    for ( long long int i = 0; i < n; i++ ) {\n\n      double in_x, in_y;\n      cin >> in_x >> in_y;\n      x.push_back( in_x );\n      y.push_back( in_y );\n\n    }\n\n    long long int ans = 1;\n\n    for ( long long int i = 0; i < n; i++ ) {\n\n      vector< pair< double, long long int > > v;\n\n      for ( long long int j = 0; j < n; j++ ) {\n\n\tif ( i == j ) continue;\n\n\tdouble dx = x[i] - x[j];\n\tdouble dy = y[i] - y[j];\n\tdouble ang = atan2( dy, dx );\n\tdouble d = sqrt( dx * dx + dy * dy );\n\tif ( d > 2.0 ) continue;\n\tdouble a = acos( d / 2 );\n\n\tv.push_back( make_pair( ang - a, 0 ) );\n\tv.push_back( make_pair( ang + a, 1 ) );\n\tv.push_back( make_pair( ang - a - M_PI * 2, 0 ) );\n\tv.push_back( make_pair( ang + a - M_PI * 2, 1 ) );\n\tv.push_back( make_pair( ang - a + M_PI * 2, 0 ) );\n\tv.push_back( make_pair( ang + a + M_PI * 2, 1 ) );\n\n      }\n\n      sort( v.begin(), v.end() );\n\n      long long int cnt = 1;\n\n      for ( long long int j = 0; j < v.size(); j++ ) {\n\n\tif ( v[j].second == 0 ) {\n\t  cnt++;\n\t  ans = max( ans, cnt );\n\t}else {\n\t  cnt--;\n\t}\n      }\n\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\n#define EPS (1e-10)\n\ntypedef complex<double> P;\n\nint main(void){\n\tint n;\n\n\twhile(cin>>n && n){\n\t\tP p[n];\n\t\trep(i,n) cin>>p[i].real()>>p[i].imag();\n\n\t\tint ans = 0;\n\t\trep(i,n-1)REP(j,i+1,n){\n\t\t\tP v = p[i] - p[j];\n\t\t\tif(abs(v) > 2) continue;\n\n\t\t\tP q = P((p[i].real()+p[j].real())/2, (p[i].imag()+p[j].imag())/2);\n\t\t\tdouble dist = sqrt(1 - pow(abs(p[i]-p[j])/2, 2));\n\t\t\tP n1 = (v * P(0,+1)) / abs(v);\n\t\t\tP n2 = (v * P(0,-1)) / abs(v);\n\t\t\tP o1 = q + n1 * dist;\n\t\t\tP o2 = q + n2 * dist;\n\n\t\t\tint sum = 0;\n\t\t\trep(k,n){\n\t\t\t\tif(abs(o1 - p[k]) < 1 + EPS) sum++;\n\t\t\t}\n\n\t\t\tans = max(ans,sum);\n\t\t\tsum = 0;\n\n\t\t\trep(k,n){\n\t\t\t\tif(abs(o2 - p[k]) < 1 + EPS) sum++;\n\t\t\t}\n\t\t\tans = max(ans,sum);\n\t\t}\n\n\t\tcout<<(ans==0?1:ans)<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include <set>\n#include <utility>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nconstexpr long long mod = 1000000007;\n\nconstexpr double eps = 0.00001;\n\nint n;\ndouble p[300][2];\n\ninline double dist2(double x1, double y1, double x2, double y2) {\n    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n}\n\nint cnt_c(double x, double y) {\n    int ret = 0;\n    for (int i = 0; i < n; i++) {\n        if (dist2(x, y, p[i][0], p[i][1]) < (1.0 + eps) * (1.0 + eps)) ret++;\n    }\n    return ret;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) return 0;\n        int r = 1;\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf %lf\", &p[i][0], &p[i][1]);\n        }\n        for (int i = 0; i < n; i++)\n            for (int j = i + 1; j < n; j++) {\n                if (dist2(p[i][0], p[i][1], p[j][0], p[j][1]) > (2 + eps) * (2 + eps)) continue;\n                double ok, ng, dr;\n                ok = dr = atan2(p[j][1] - p[i][1], p[j][0] - p[i][0]);\n                ng = ok + M_PI;\n                while (abs(ok - ng) > eps / 1000) {\n                    double m = (ok + ng) / 2;\n                    if (dist2(p[i][0] + cos(m), p[i][1] + sin(m), p[j][0], p[j][1]) <= 1)\n                        ok = m;\n                    else ng = m;\n                }\n                double is = (ok + ng) / 2;\n                r = max(r, cnt_c(p[i][0] + cos(is), p[i][1] + sin(is)));\n                r = max(r, cnt_c(p[i][0] + cos(dr * 2 - is), p[i][1] + sin(dr * 2 - is)));\n            }\n        cout << r << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\n#define FOR(i, a, b) for (int i = a; i < b; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define RFOR(i, a, b) for (int i = b - 1; i >= a; i--)\n#define RREP(i, n) RFOR(i, 0, n)\n#define rep(i, a, b) for (auto i = a; i < b; i++)\n#define rrep(i, a, b) for (auto i = a; i > b; i--)\n#define range(i, a, b) (a <= i && i < b)\n#define fi first\n#define fs first\n#define se second\n#define sc second\n//#define int long long\nusing namespace std;\nusing vec = vector<int>;\nusing mat = vector<vec>;\n#define ll long long\n\n#define mp make_pair\n#define all(v) begin(v), end(v)\n//#define M_PI 3.14159265353238\n#define pb push_back\n\nnamespace geo\n{\n#define IL inline\n\ttypedef double D;\n\ttypedef bool B;\n\ttypedef complex<D> P;\n#define X real()\n#define Y imag()\n\tostream &operator<<(ostream &out, const P &point1) // Pの出力\n\t{\n\t\tout << '(' << point1.X << \", \" << point1.Y << ')';\n\t\treturn out;\n\t}\n\tB comp(const P &l, const P &r)\n\t{\n\t\treturn (l.X == r.X) ? l.Y < r.Y : l.X < r.X;\n\t}\n\ttypedef pair<P, P> L;  //line\n\ttypedef pair<P, P> LS; //line segment\n\ttypedef pair<P, D> C;  //circle\n\ttypedef vector<P> Poly;\n\tconst D EPS = 1e-9;\n\t//Decompotision Macro\n#define DCl(a, b, l) \\\n  P a, b;            \\\n  tie(a, b) = l\n#define DCc(a, b, c) \\\n  P a;               \\\n  D b;               \\\n  tie(a, b) = c\n\n//A dot B\n\tIL D dot(P a, P b) { return a.X * b.X + a.Y * b.Y; }\n\t//A cross B\n\tIL D cross(P a, P b) { return a.X * b.Y - a.Y * b.X; }\n\tIL D ccw(P a, P b, P c)\n\t{\n\t\treturn cross(b - a, c - a);\n\t}\n\n\t// 未検証!!\n\tIL P rotation(P a, double angle) {\n\t\ta *= exp(complex<double>(.0, angle * M_PI / 180.0));\n\t\treturn a;\n\t}\n\n\tIL int sgn(P a, P b, P c)\n\t{\n\t\tif (cross(b - a, c - a) > EPS)\n\t\t\treturn 1;\n\t\tif (cross(b - a, c - a) < -EPS)\n\t\t\treturn -1;\n\t\tif (dot(b - a, c - a) < -EPS)\n\t\t\treturn 2; // b-a-c\n\t\tif (dot(a - b, c - b) < -EPS)\n\t\t\treturn -2; // a-b-c\n\t\treturn 0;\n\t}\n\tIL D signed_distance_P_L(P p, L l)\n\t{\n\t\tDCl(a, b, l);\n\t\treturn ccw(a, b, p) / abs(b - a);\n\t}\n\n\tIL D distance_P_L(P p, L l) // 点と直線の距離\n\t{\n\t\treturn abs(signed_distance_P_L(p, l));\n\t}\n\n\tIL D distance_P_P(P p1, P p2) // 二点間距離\n\t{\n\t\treturn abs(p1 - p2);\n\t}\n\n\tIL D distance_P_LS(P p, LS ls) // 点と線分の距離\n\t{\n\t\tDCl(a, b, ls);\n\t\tif (dot(b - a, p - a) < EPS)\n\t\t\treturn abs(p - a);\n\t\tif (dot(a - b, p - b) < EPS)\n\t\t\treturn abs(p - b);\n\t\treturn abs(cross(b - a, p - a)) / abs(b - a);\n\t}\n\n\tIL B is_L_L(L p, L q)\n\t{\n\t\tDCl(a, b, p);\n\t\tDCl(c, d, q);\n\t\treturn abs(cross(a - b, c - d)) > EPS ||\n\t\t\tabs(cross(a - b, d - b)) < EPS;\n\t}\n\tIL B is_L_LS(L l, LS ls)\n\t{\n\t\tDCl(a, b, l);\n\t\tDCl(c, d, ls);\n\t\treturn ccw(a, b, c) * ccw(a, b, d) < EPS;\n\t}\n\tIL B is_LS_LS(LS p, LS q)\n\t{\n\t\tDCl(a, b, p);\n\t\tDCl(c, d, q);\n\t\treturn sgn(a, b, c) * sgn(a, b, d) <= 0 && sgn(c, d, a) * sgn(c, d, b) <= 0;\n\t}\n\n\tIL D distance_LS_LS(LS p, LS q)\n\t{\n\t\tif (is_LS_LS(p, q))\n\t\t\treturn 0;\n\t\treturn min({ distance_P_LS(p.fi, q),\n\t\t\t\t\tdistance_P_LS(p.se, q),\n\t\t\t\t\tdistance_P_LS(q.fi, p),\n\t\t\t\t\tdistance_P_LS(q.se, p) });\n\t}\n\n\t//caution: have to use isintersected_L_L before this function\n\tIL P cross_L_L(L p, L q)\n\t{\n\t\tDCl(a, b, p);\n\t\tD d1 = signed_distance_P_L(a, q);\n\t\tD d2 = signed_distance_P_L(b, q);\n\t\treturn (a * d2 - b * d1) / (d2 - d1);\n\t}\n\n\tIL B is_C_C(C p, C q)\n\t{\n\t\tDCc(cp, rp, p);\n\t\tDCc(cq, rq, q);\n\t\tD d = abs(cp - cq);\n\t\treturn abs(rp - rq) - d < EPS &&\n\t\t\trp + rq - d > -EPS;\n\t}\n\tIL LS cross_C_C(C p, C q)\n\t{\n\t\tDCc(cp, rp, p);\n\t\tDCc(cq, rq, q);\n\t\tD d = abs(cp - cq);\n\t\tD rc = (d * d + rp * rp - rq * rq) / (2 * d);\n\t\tD rs = sqrt(rp * rp - rc * rc);\n\t\tP diff = (cq - cp) / d;\n\t\treturn { cp + P(rc, rs) * diff, cp + P(rc, -rs) * diff };\n\t}\n\tIL Poly convex_hull(Poly p)\n\t{\n\t\tint n = p.size();\n\t\tPoly res(2 * n);\n\t\tint k = 0, t;\n\t\tsort(all(p), comp);\n\t\trep(i, 0, n)\n\t\t{\n\t\t\twhile (k > 1 && ccw(res[k - 2], res[k - 1], p[i]) < EPS)\n\t\t\t\tk--;\n\t\t\tres[k++] = p[i];\n\t\t}\n\t\tt = k;\n\t\trep(j, 0, n - 1)\n\t\t{\n\t\t\tint i = n - 2 - j;\n\t\t\twhile (k > t && ccw(res[k - 2], res[k - 1], p[i]) < EPS)\n\t\t\t\tk--;\n\t\t\tres[k++] = p[i];\n\t\t}\n\t\tres.resize(k - 1);\n\t\treturn res;\n\t}\n\tIL B convex_in(Poly &l, P &p)\n\t{\n\t\tint a = 0, b = l.size(), c;\n\t\tD A, C;\n\t\tP g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n\t\twhile (b - a > 1)\n\t\t{\n\t\t\tc = (a + b) / 2;\n\t\t\tA = cross(l[a] - g, p - l[a]);\n\t\t\tC = cross(l[c] - g, p - l[c]);\n\t\t\tif (cross(l[a] - g, l[c] - g) >= 0)\n\t\t\t{\n\t\t\t\tif (A > -EPS && C < -EPS)\n\t\t\t\t\tb = c;\n\t\t\t\telse\n\t\t\t\t\ta = c;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (C < -EPS || A > -EPS)\n\t\t\t\t\tb = c;\n\t\t\t\telse\n\t\t\t\t\ta = c;\n\t\t\t}\n\t\t}\n\t\treturn (cross(l[b % l.size()] - l[a], p - l[b % l.size()]) > -EPS);\n\t}\n\n\t//not necessary?\n\tIL D convex_area(Poly &l)\n\t{\n\t\tdouble res = 0;\n\t\tint n = l.size();\n\t\trep(i, 2, n)\n\t\t\tres += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n\t\treturn res;\n\t}\n\tIL D area(Poly &l)\n\t{\n\t\tdouble res = 0;\n\t\tint n = l.size();\n\t\trep(i, 0, n)\n\t\t\tres += cross(l[i], l[(i + 1) % n]);\n\t\treturn abs(res) / 2.0;\n\t}\n\tinline vector<L> tangent_line(C c, P p)\n\t{\n\t\tvector<L> res;\n\t\tDCc(cp, r, c);\n\t\tP v = p - cp;\n\t\tD dist = abs(v);\n\t\tif (dist - r > -EPS)\n\t\t{\n\t\t\tdouble _cos = r / dist;\n\t\t\tdouble _sin = sqrt(1.0 - _cos * _cos);\n\t\t\tv = v * (r / dist);\n\t\t\t{\n\t\t\t\tP e = P(_cos * v.X - _sin * v.Y, _sin * v.X + _cos * v.Y);\n\t\t\t\tres.push_back({ p, cp + e });\n\t\t\t}\n\t\t\tif (dist - r > EPS)\n\t\t\t{\n\t\t\t\tP e = P(_cos * v.X + _sin * v.Y, -_sin * v.X + _cos * v.Y);\n\t\t\t\tres.push_back({ p, cp + e });\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tIL vector<L> inner_common_tangent_line(C p, C q)\n\t{\n\t\tvector<L> res;\n\t\tDCc(Mp, Rp, p);\n\t\tDCc(Mq, Rq, q);\n\t\tD dist = abs(Mp - Mq);\n\t\tif (dist - (Rp + Rq) > -EPS)\n\t\t{\n\t\t\tP mid = (Mq * Rp + Mp * Rq) / (Rp + Rq);\n\t\t\tres = tangent_line(p, mid);\n\t\t}\n\t\treturn res;\n\t}\n\tinline vector<L> outer_common_tangent_line(C p, C q)\n\t{\n\t\tvector<L> res;\n\t\tDCc(Mp, Rp, p);\n\t\tDCc(Mq, Rq, q);\n\t\tP v = Mp - Mq;\n\t\tD dist = abs(v);\n\t\tif (dist - abs(Rp - Rq) > -EPS)\n\t\t{\n\t\t\tif (abs(Rp - Rq) < EPS)\n\t\t\t{\n\t\t\t\tP e = v * P(0, 1);\n\t\t\t\te = e / dist;\n\t\t\t\tres.pb(L(Mp + e, Mq + e));\n\t\t\t\tres.pb(L(Mp - e, Mq - e));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tP mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n\t\t\t\tres = tangent_line(p, mid);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tvector<Poly> decomposition(Poly p)\n\t{\n\t\tint n = p.size();\n\t\tvector<Poly> res;\n\t\twhile (n >= 3)\n\t\t{\n\t\t\t[&]() {\n\t\t\t\trep(i, 0, n)\n\t\t\t\t{\n\t\t\t\t\tP a = p[i];\n\t\t\t\t\tP b = p[(i + 1) % n];\n\t\t\t\t\tP c = p[(i + 2) % n];\n\t\t\t\t\tif (ccw(a, b, c) < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif ([&]() {\n\t\t\t\t\t\trep(j, 3, n)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP d = p[(i + j) % n];\n\t\t\t\t\t\t\t\tif (ccw(a, b, d) > -EPS && ccw(b, c, d) > -EPS && ccw(c, a, d) > -EPS)\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}())\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tPoly nxt;\n\t\t\t\t\t\trep(j, 0, n) if ((i + j) % n != (i + 1) % n)\n\t\t\t\t\t\t\tnxt.push_back(p[(i + j) % n]);\n\t\t\t\t\t\tswap(p, nxt);\n\t\t\t\t\t\tres.push_back({ a, b, c });\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}();\n\t\t}\n\t\treturn res;\n\t}\n\tint in_triangle(P p, Poly q)\n\t{\n\t\trep(i, 0, 3) if (abs(p - q[i]) < EPS) return 3; //on point\n\t\trep(i, 0, 3)\n\t\t{\n\t\t\tint s = sgn(q[i], q[(i + 1) % 3], p);\n\t\t\tif (s != 1)\n\t\t\t{\n\t\t\t\tif (s == 0)\n\t\t\t\t\treturn 2; //on line\n\t\t\t\telse\n\t\t\t\t\treturn 0; // not in\n\t\t\t}\n\t\t}\n\t\treturn 1; // inside triangle\n\t}\n\tint in_C(P q, C c) // 円での点の内外判定(円周上も判定)\n\t{\n\t\tDCc(p, r, c);\n\t\tif (abs(r - abs(p - q)) < EPS)\n\t\t\treturn 2; // 円周\n\t\treturn r - abs(p - q) > -EPS ? 1 : 0;\n\t}\n\tint is_triangle_C(Poly t, C c)\n\t{\n\t\tt = convex_hull(t);\n\t\tDCc(p, r, c);\n\t\tint cnt = 0;\n\t\trep(i, 0, 3)\n\t\t\tcnt += (in_C(t[i], c) > 0);\n\t\tif (cnt == 3)\n\t\t\treturn 3; // t in c\n\t\tif (cnt == 0)\n\t\t{\n\t\t\tdouble d = distance_P_LS(p, LS(t[2], t[0]));\n\t\t\trep(i, 0, 2)\n\t\t\t\td = min(d, distance_P_LS(p, LS(t[i], t[i + 1])));\n\t\t\tif (r - d > EPS)\n\t\t\t\treturn 1; //intersect\n\t\t\tif (in_triangle(p, t))\n\t\t\t\treturn 2; //c in t\n\t\t\telse if (r - d < -EPS)\n\t\t\t\treturn 0; //not intersect\n\t\t}\n\t\treturn 1; //intersect\n\t}\n\n\t//p must be convex and ccw\n\tLS diameter(Poly &p)\n\t{\n\t\tint n = p.size();\n\t\tint is = 0, js = 0;\n\t\trep(i, 0, n) if (p[i].Y > p[is].Y)\n\t\t\tis = i;\n\t\trep(i, 0, n) if (p[i].Y < p[js].Y)\n\t\t\tjs = i;\n\t\tLS res = { p[is], p[js] };\n\t\t{\n\t\t\tint i = is;\n\t\t\tint j = js;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tint ni = (i + 1) % n;\n\t\t\t\tint nj = (j + 1) % n;\n\t\t\t\tif (cross(p[ni] - p[i], p[nj] - p[j]) < EPS)\n\t\t\t\t\ti = ni;\n\t\t\t\telse\n\t\t\t\t\tj = nj;\n\t\t\t\tif (abs(res.fi - res.se) < abs(p[i] - p[j]))\n\t\t\t\t\tres = LS(p[i], p[j]);\n\t\t\t} while (i != is || j != js);\n\t\t}\n\t\treturn res;\n\t}\n\n\tPoly cross_C_L(C c, L v)\n\t{\n\t\tDCc(p, r, c);\n\t\tDCl(a, b, v);\n\t\ta -= p;\n\t\tb -= p;\n\t\tP u = a - b;\n\t\tu = P(-u.Y, u.X);\n\t\tP x = cross_L_L({ a, b }, { P(0, 0), u });\n\t\tD d = abs(x);\n\t\tPoly res;\n\t\tif (d - r > EPS)\n\t\t\treturn res;\n\t\tD y = sqrt(r * r - d * d);\n\t\tres.pb(p + x + (b - a) * y / abs(b - a));\n\t\t//if(d-r>-EPS)return res;\n\t\tres.pb(p + x + (a - b) * y / abs(b - a));\n\t\treturn res;\n\t}\n\n\tpair<C, C> GetC_p_p_r(P p1, P p2, D r) // 二点と半径から２つの円を求める\n\t{\n\t\tD d = distance_P_P(p1, p2);\n\t\tassert(d <= 2. * r); // 二点間の距離は2 * r以内じゃないと同じ円周上に存在することはできない.\n\t\tP mid = (p1 + p2) / 2.;\n\t\tP NormalVector = (p1 - p2) / d * sqrt(r * r - d * d / 4.);\n\t\tNormalVector = P(NormalVector.Y, -NormalVector.X);\n\t\tP center1 = mid + NormalVector;\n\t\tP center2 = mid - NormalVector;\n\t\treturn mp(C(center1, r), C(center2, r));\n\t}\n}\n\nvoid solve(int &n) {\n\tusing namespace geo;\n\tvector<P> ps;\n\trep(i, 0, n) {\n\t\tdouble x, y; cin >> x >> y;\n\t\tps.pb(P{ x, y });\n\t}\n\tint ans = 1;\n\trep(i, 0, n) {\n\t\trep(j, 0, n) {\n\t\t\tif (i == j) continue;\n\t\t\tif (distance_P_P(ps[i], ps[j]) > 2.) continue;\n\t\t\tpair<C, C> circles = GetC_p_p_r(ps[i], ps[j], 1.);\n\t\t\tC now1 = circles.first;\n\t\t\tint cnt = 2;\n\t\t\trep(k, 0, n) {\n\t\t\t\tif (k == i || k == j) continue;\n\t\t\t\tif (distance_P_P(now1.first, ps[k]) <= 1.) cnt++;\n\t\t\t}\n\t\t\tans = max(ans, cnt);\n\t\t\tC now2 = circles.second;\n\t\t\tcnt = 2;\n\t\t\trep(k, 0, n) {\n\t\t\t\tif (k == i || k == j) continue;\n\t\t\t\tif (distance_P_P(now2.fi, ps[k]) <= 1.) cnt++;\n\t\t\t}\n\t\t\tans = max(ans, cnt);\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) solve(n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\ninline point rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\ninline point rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ninline double angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ninline double abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ninline double norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ninline double dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ninline double cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\ninline int ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\ninline point projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\ninline bool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\ninline bool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\ninline bool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\ninline bool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ninline bool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\ninline bool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\ninline bool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ninline double dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ninline double dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ninline double dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ninline double dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ninline double dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\ninline double dist(const point& a, const point& b) {\n\treturn abs(a - b);\n}\n\ninline point crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn m.a + (m.b - m.a) * cross(l.b - l.a, l.a - m.a) * (1.0 / tmp);\n}\n\ninline point crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\ninline vector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ninline double areaTriangle(point a, point b, const point& c) {\n\ta = a - c;\n\tb = b - c;\n\treturn fabs(a.x * b.y - b.x * a.y) / 2.0;\n}\n\ninline double area(const polygon& p) {\n\tconst int num = p.size();\n\tif(num < 3)\n\t\treturn 0;\n\n\tif(num == 3)\n\t\treturn areaTriangle(p[0], p[1], p[2]);\n\n\tdouble res = cross(p[num - 1], p[0]);\n\tfor(int i = 1; i < num; ++i)\n\t\tres += cross(p[i - 1], p[i]);\n\n\treturn res * 0.5;\n}\n\n// L.aからL.bの方向を見た場合に，点aが左側に来る．\ninline line bisector(const point& a, const point& b) {\n\treturn line(point((a.x - a.y + b.x + b.y) / 2.0, (a.y + a.x + b.y - b.x) / 2.0),\n\t\t\t\tpoint((a.x + a.y + b.x - b.y) / 2.0, (a.y - a.x + b.y + b.x) / 2.0));\n}\n\n// L.aからL.bを向いた時の左側を残して切断する．\ninline polygon convex_cut(const polygon& p, const line& l) {\n\tconst int num = p.size();\n\tpolygon res;\n\tfor(int i = 0; i < num; ++i) {\n\t\tconst int next = (i + 1) % num;\n\t\tconst int tmp = ccw(l.a, l.b, p[i]);\n\t\tif(tmp != -1)\n\t\t\tres.push_back(p[i]);\n\n\t\tif(tmp * ccw(l.a, l.b, p[next]) < 0)\n\t\t\tres.push_back(crosspoint(l, line(p[i], p[next])));\n\t}\n\n\treturn res;\n}\n\nvector<point> tangent(const circle& c, const point& p) {\n\tconst double x = norm(p - c.c);\n\tdouble d = x - c.r * c.r;\n\tif(d < -EPS) return vector<point>();\n\td = max(d, 0.0);\n\tconst point q1 = (p - c.c) * (c.r * c.r / x);\n\tconst point q2 = rotate90((p - c.c) * (-c.r * sqrt(d) / x));\n\tvector<point> res;\n\tres.push_back(c.c + q1 - q2);\n\tres.push_back(c.c + q1 + q2);\n\treturn res;\n}\n\nvector<line> tangent(const circle &a, const circle& b) {\n\tvector<line> res;\n\tif(abs(a.r - b.r) < EPS) {\n\t\tpoint dir = b.c - a.c;\n\t\tdir = rotate90(dir * (a.r / abs(dir)));\n\t\tres.push_back(line(a.c + dir, b.c + dir));\n\t\tres.push_back(line(a.c - dir, b.c - dir));\n\t}\n\telse {\n\t\tpoint p = a.c * (-b.r) + b.c * a.r;\n\t\tp = p * (1.0 / (a.r - b.r));\n\t\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\t\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\t\tres.push_back(line(ps[i], qs[i]));\n\t}\n\n\tpoint p = a.c * b.r + b.c * a.r;\n\tp = p * (1.0 / (a.r + b.r));\n\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\tres.push_back(line(ps[i], qs[i]));\n\n\treturn res;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n, n;) {\n\t\tvector<point> points;\n\t\tpoints.reserve(n);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoints.push_back(point(x, y));\n\t\t}\n\n\t\tint ans = 1;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tconst circle c1 = circle(points[i], 1.0);\n\t\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\t\tconst circle c2 = circle(points[j], 1.0);\n\t\t\t\tvector<point> center = crosspoint(c1, c2);\n\t\t\t\tif(center.size() != 2)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor(int k = 0; k < 2; ++k) {\n\t\t\t\t\tint cnt = 2;\n\t\t\t\t\tfor(int l = 0; l < n; ++l) {\n\t\t\t\t\t\tif(l == i || l == j)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tif(dist(center[k], points[l]) < 1.0)\n\t\t\t\t\t\t\t++cnt;\n\t\t\t\t\t}\n\n\t\t\t\t\tchmax(ans, cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nstruct EndPoint{\n  Point p;\n  int seg,st;\n  EndPoint(){}\n  EndPoint(Point p,int seg,int st):p(p),seg(seg),st(st){}\n  bool operator<(const EndPoint &ep)const{\n    if(p.y==ep.p.y) return st<ep.st;\n    return p.y<ep.p.y;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) is>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\nvector<vector<pair<int, double> > >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps);\n  \nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  return getDistanceSP(s,c.c)<=c.r;\n}\n\nint intersectCS(Circle c,Segment s){\n  if(norm(project(s,c.c)-c.c)-c.r*c.r>EPS) return 0;\n  double d1=abs(c.c-s.p1),d2=abs(c.c-s.p2);\n  if(d1<c.r+EPS&&d2<c.r+EPS) return 0;\n  if((d1<c.r-EPS&&d2>c.r+EPS)||(d1>c.r+EPS&&d2<c.r-EPS)) return 1;\n  Point h=project(s,c.c);\n  if(dot(s.p1-h,s.p2-h)<0) return 2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  for(int k=0;k<2;k++){\n    if(getDistanceSP(s1,s2.p1)<EPS) return s2.p1; \n    if(getDistanceSP(s1,s2.p2)<EPS) return s2.p2;\n    swap(s1,s2);\n  }\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCS(Circle c,Segment s){\n  Line l(s);\n  Polygon res=getCrossPointCL(c,l);\n  if(intersectCS(c,s)==2) return res;\n  if(res.size()>1u){\n    if(dot(l.p1-res[0],l.p2-res[0])>0) swap(res[0],res[1]);\n    res.pop_back();\n  }\n  return res;\n}\n\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n  \n  return ls;\n}\n\ndouble closest_pair(Polygon &a,int l=0,int r=-1){\n  if(r<0){\n    r=a.size();\n    sort(a.begin(),a.end(),sort_x);\n  }\n  if(r-l<=1) return abs(a[0]-a[1]);\n  int m=(l+r)>>1;\n  double x=a[m].x;\n  double d=min(closest_pair(a,l,m),closest_pair(a,m,r));\n  inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,sort_y);\n\n  Polygon b;\n  for(int i=l;i<r;i++){\n    if(fabs(a[i].x-x)>=d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dy=a[i].y-next(b.rbegin(),j)->y;\n      if(dy>=d) break;\n      d=min(d,abs(a[i]-*next(b.rbegin(),j)));\n    }\n    b.emplace_back(a[i]);\n  }\n  return d;\n}\n\nvector<vector<pair<int, double> > >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps){\n  int n=ss.size();\n  for(int i=0;i<n;i++){\n    ps.emplace_back(ss[i].p1);\n    ps.emplace_back(ss[i].p2);\n    for(int j=i+1;j<n;j++)\n      if(intersectSS(ss[i],ss[j]))\n        ps.emplace_back(getCrossPointSS(ss[i],ss[j]));\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n\n  vector<vector<pair<int, double> > > G(ps.size());\n  for(int i=0;i<n;i++){\n    vector<pair<double,int> > ls;\n    for(int j=0;j<(int)ps.size();j++)\n      if(getDistanceSP(ss[i],ps[j])<EPS)\n        ls.emplace_back(make_pair(norm(ss[i].p1-ps[j]),j));\n      \n    sort(ls.begin(),ls.end());\n    for(int j=0;j+1<(int)ls.size();j++){\n      int a=ls[j].second,b=ls[j+1].second;\n      G[a].emplace_back(b,abs(ps[a]-ps[b]));\n      G[b].emplace_back(a,abs(ps[a]-ps[b]));\n    }\n  }\n  return G;\n}\n\nint manhattanIntersection(vector<Segment> ss,const int INF){\n  const int BTM = 0;\n  const int LFT = 1;\n  const int RGH = 2;\n  const int TOP = 3;\n  \n  int n=ss.size();\n  vector<EndPoint> ep;\n  for(int i=0;i<n;i++){\n    if(ss[i].p1.y==ss[i].p2.y){\n      if(ss[i].p1.x>ss[i].p2.x) swap(ss[i].p1,ss[i].p2);\n      ep.emplace_back(ss[i].p1,i,LFT);\n      ep.emplace_back(ss[i].p2,i,RGH);\n    }else{\n      if(ss[i].p1.y>ss[i].p2.y) swap(ss[i].p1,ss[i].p2);      \n      ep.emplace_back(ss[i].p1,i,BTM);\n      ep.emplace_back(ss[i].p2,i,TOP);\n    }    \n  }   \n  sort(ep.begin(),ep.end());\n\n  set<int> bt;\n  bt.insert(INF);\n  \n  int cnt=0;\n  for(int i=0;i<n*2;i++){\n    if(ep[i].st==TOP){\n      bt.erase(ep[i].p.x);\n    }else if(ep[i].st==BTM){\n      bt.emplace(ep[i].p.x);\n    }else if(ep[i].st==LFT){\n      auto b=bt.lower_bound(ss[ep[i].seg].p1.x);\n      auto e=bt.upper_bound(ss[ep[i].seg].p2.x);\n      cnt+=distance(b,e);\n    }    \n  }\n  \n  return cnt;\n}\n\ndouble area(Polygon ps,Circle c){\n  if(ps.size()<3u) return 0;\n  function<double(Circle, Point, Point)> dfs=\n    [&](Circle c,Point a,Point b){\n      Vector va=c.c-a,vb=c.c-b;\n      double f=cross(va,vb),res=0;\n      if(equals(f,0.0)) return res;\n      if(max(abs(va),abs(vb))<c.r+EPS) return f;\n      Vector d(dot(va,vb),cross(va,vb));\n      if(getDistanceSP(Segment(a,b),c.c)>c.r-EPS)\n        return c.r*c.r*atan2(d.y,d.x);\n      auto u=getCrossPointCS(c,Segment(a,b));\n      if(u.empty()) return res;\n      if(u.size()>1u&&dot(u[1]-u[0],a-u[0])>0) swap(u[0],u[1]);\n      u.emplace(u.begin(),a);\n      u.emplace_back(b);\n      for(int i=1;i<(int)u.size();i++)\n        res+=dfs(c,u[i-1],u[i]);\n      return res;\n    };\n  double res=0;\n  for(int i=0;i<(int)ps.size();i++)\n    res+=dfs(c,ps[i],ps[(i+1)%ps.size()]);\n  return res/2;\n}\n\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    Polygon ps(n);\n    cin>>ps;\n    \n    auto calc=\n      [&](Point p)->int{\n        int res=0;\n        for(int i=0;i<n;i++)\n          if(abs(p-ps[i])<1.0+EPS) res++;\n        return res;\n      };\n    \n    int ans=1;    \n    for(int i=0;i<n;i++){\n      for(int j=0;j<i;j++){\n        if(abs(ps[i]-ps[j])>2.0) continue;\n        auto qs=getCrossPointCC(Circle(ps[i],1),Circle(ps[j],1));\n        for(auto q:qs) chmax(ans,calc(q));\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double R;//double long double ??????????????? cmath?????¢??°??????????????????????????????????????????????????§????????????\ntypedef complex<R> Point;\ntypedef pair<Point , Point> Line;\ntypedef pair<Point ,R > Circle;\ntypedef vector<Point> Poly;\n\n#define EPS (1e-10)//??????\n#define EQ(a,b) (abs((a)-(b)) < EPS)//??????????????°???????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )//????????????????????????????????????\n#define ft first\n#define sd second\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nR dot(Point a,Point b){//??????ok\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nR cross(Point a,Point b){//??????ok\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\n\n\nbool is_orthogonal(Line a,Line b){//2??´????????´?????????ok\n    return EQ(dot(a.ft - a.sd,b.ft - b.sd),0.0);\n}\nbool is_parallel(Line a,Line b){//2??´??????????????????ok\n    return EQ(cross(a.ft - a.sd,b.ft - b.sd),0.0);\n}\n\n\n\n////////////////////????????????\nint ccw(Point a,Point b,Point c){//ok\n    b -= a; c -= a;\n    if(cross(b,c) > EPS) return 1;//a???b??§???????¨???¨???????????????b???c\n    if(cross(b,c) < -EPS) return -1;//a???b??§????¨???¨???????????????b???c\n    if(dot(b,c) < -EPS) return 2;//c--a--b on same line\n    if(norm(c) - norm(b) > EPS) return -2;//a--b--c(abs??????????????????????????????????????????????????????????)\n    return 0;//a--c--b?????????b==c\n}\n\nbool is_intersection_ll(Line l,Line m){//???????????´??????????????????ok\n    return abs(cross(l.sd - l.ft,m.sd - m.ft)) > EPS || //????????§??????\n        abs(cross(l.sd - l.ft,m.ft - l.ft)) < EPS; //?????????????????????\n}\n\nbool is_intersection_ls(Line l,Line s){//??´???l??¨??????s???????????????\n    return cross(l.sd - l.ft, s.ft-l.ft)*       // s[0] is left of l\n        cross(l.sd - l.ft, s.sd - l.ft) < EPS; // s[1] is right of l\n}\n\nbool is_intersection_lp(Line l,Point p){//??´???l??¨???p???????????????\n    return abs(cross(l.sd - p,l.ft - p));\n}\n\nbool is_intersection_ss(Line a,Line b){//??????????????????????????????ok\n    return ccw(a.ft,a.sd,b.ft)*ccw(a.ft,a.sd,b.sd) <= 0 && ccw(b.ft,b.sd,a.ft)*ccw(b.ft,b.sd,a.sd) <= 0;\n}\n\nbool is_intersection_sp(Line s,Point p){//????????¨?????????????????? ????§??????????????????¨\n    return abs(s.ft - p) + abs(s.sd - p) - abs(s.ft - s.sd) < EPS;\n}\n\n\nbool intersection_cc(Circle c1,Circle c2){//???????????????????????????ok\n    return abs(c1.ft - c2.ft) - (c1.sd + c2.sd) < -EPS;\n}\n\n\n/////////////?????¢\nR dis_lp(Line l,Point p){//??´???l??¨???p????????¢ok\n    return abs(cross(l.sd - l.ft,p - l.ft)) / abs(l.sd - l.ft);\n}\n\nR dis_ll(Line l,Line m){//???????????´???????????¢\n    return is_intersection_ll(l,m) ? 0.0 : dis_lp(l,m.ft);\n}\n\nR dis_ls(Line l,Line s){//??´???l??¨??????s????????¢\n    if(is_intersection_ls(l,s)) return 0.0;\n    return min(dis_lp(l,s.ft),dis_lp(l,s.sd));\n}\n\nR dis_sp(Line s,Point p){//??????s??¨???p????????¢ok\n    if(dot(s.sd - s.ft,p - s.ft) < EPS) return abs(p - s.ft);\n    if(dot(s.ft - s.sd,p - s.sd) < EPS) return abs(p - s.sd);\n    return dis_lp(s,p);\n}\n\nR dis_ss(Line s,Line t){//???????????????????????¢ok\n    if(is_intersection_ss(s,t)) return 0.0;\n    return min(min(dis_sp(s,t.ft),dis_sp(s,t.sd)),\n            min(dis_sp(t,s.ft),dis_sp(t,s.sd)));\n}\n\n\n\n//////////////?°???±??¨????°?\nPoint projection(Line l,Point p){//?°???±????±???????ok\n    R t = dot(p - l.ft,l.ft - l.sd) / norm(l.ft - l.sd);\n    return l.ft + t * (l.ft - l.sd);\n}\n\nPoint reflection(Line l,Point p){//????°?????±???????ok\n    return p + (R)2.0 * (projection(l,p) - p);\n}\n\n\n\n\n//////////////??????(????????????????¨???????????????¨??????????????????????????????????????£??????)\n\nPoint intersection_ll(Line l,Line m){//????????????????????????????????????????????????ok\n    R A = cross(l.sd - l.ft,m.sd - m.ft);\n    R B = cross(l.sd - l.ft,l.sd - m.ft);\n    if(abs(A) < EPS && abs(B) < EPS) return m.ft;//?????????\n    //if(abs(A) < EPS)assert(false);//????????§????????????\n    return m.ft + B / A * (m.sd - m.ft);\n}\n\nLine intersection_of_two_circles(Circle c1,Circle c2){//ok ????????????????????????Line?????\\????????????(r1 + r2 > sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2))???????????????????????????ok\n    R a =  abs(c2.ft - c1.ft);\n    R b = c1.sd;\n    R c = c2.sd;\n\n    R rc = (a  * a + b * b - c * c) / (2.0 * a);\n    R rs = sqrt(b * b - rc * rc);//C++ ??§???????????????????????????????????§???????????????sqrt ????????? float ?????????????????? long double ????????????????????????????????????????????¨?????§???????????? C ????????°????????§??????sqrt ????????? double ??????????????£??????????????????\n    Point diff = (c2.ft - c1.ft) / a;\n\n    Line p ;\n    p.ft = c1.ft + diff * rc + diff * Point(0,1) * rs;\n    p.sd = c1.ft + diff * rc + diff * Point(0,-1) * rs;\n\n    return p;\n}\n\n\n/////////////////////////polygon\n\n#define currP(P,i) P[(i) % P.size()]//????????????\n#define nextP(P,i) P[((i) + 1)%P.size()]//?¬??????????\n\nint is_contains_p_in_Poly(Poly po,Point p){//??????????§???¢????????¨(1)????¢????(-1)????????¨(0)??????????????????????????????ok\n    bool in = false;\n    REP(i,po.size()){\n        Point a = currP(po,i) - p,b = nextP(po,i) - p;\n        if(a.imag() > b.imag())swap(a,b);\n        if(a.imag() < EPS && EPS < b.imag())\n            if(cross(a,b) < -EPS) in = !in;\n        if(EQ(cross(a,b),0.0) && dot(a,b) < EPS)return  -1;\n    }\n    return in;\n}\n\nR area2(Poly po){//????§???¢?????¢????????????????±???????ok\n    R A = 0.0;\n    REP(i,po.size())\n        A += cross(currP(po,i),nextP(po, i));\n    return A;\n}\n\n\n\n\n///////////////////////////???\n\nbool comp_complex_real(Point a,Point b){//x???y????????????ok\n    if(EQ(a.real(),b.real()))\n        return b.imag() - a.imag() > EPS;\n    return b.real() - a.real() > EPS;\n}\n\nPoly convex_hull(Poly ps){//??????ok\n    int n = ps.size(),k = 0;\n    sort(ps.begin(),ps.end(),comp_complex_real);\n    Poly ch(2*n);\n    for(int i = 0;i < n;ch[k++] = ps[i++])// lower-hull\n        while(k >= 2 && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0 && ccw(ch[k - 2],ch[k - 1],ps[i]) > -2) --k;//?????????????????¶???180??????????????¨???????????????\n    for(int i = n - 2,t = k + 1;i >= 0;ch[k++] = ps[i--])//upper-hull\n        while(k >= t && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0 && ccw(ch[k - 2],ch[k - 1],ps[i]) > -2) --k;//????????????\n    ch.resize(k - 1);\n    return ch;\n}\n#define prevP(P, i) P[(i+P.size()-1) % P.size()]\nbool isconvex(Poly P){//?????§??????????¨??????????????¨???¨????????????\n    bool cl = false,ccl = false;\n    for(int i = 0;i < P.size();++i){\n        int c = ccw(prevP(P,i),currP(P,i),nextP(P,i));\n        if(c == -2)continue;//180??????????????¨????????????360??????????????¨??????c == -2 || c == 0\n        if(c == 1)ccl = true;\n        else if(c == 2)cl = true;\n        else return false;\n    }\n    return !(cl && ccl);\n}\n\n#define MAX_N 300 \nint n;\nvector<int> G[MAX_N];\n\nPoint p[MAX_N];\n\nbool input(){\n    cin >> n;\n    REP(i,n){\n        R x,y;\n        cin >> x >> y;\n        p[i] = Point(x,y);\n    }\n}\nbool use[MAX_N];\nbool use2[MAX_N];\nvoid solve(){\n    REP(i,n)G[i].clear();\n    REP(i,n){\n        FOR(j,i+1,n){\n            if(abs(p[i] - p[j]) - 2.0 < EPS){\n                G[i].pb(j);\n                G[j].pb(i);\n            }\n        }\n    }\n    \n    int maxi = 0;\n    REP(i,n){\n        fill(use,use+n,false);\n        use[i] = true;\n        REP(j,G[i].size()){\n            use[G[i][j]] = true;\n        }\n        REP(j,G[i].size()){\n            int k = G[i][j];\n            fill(use2,use2+n,false);\n            use2[k] = true;\n            REP(l,G[k].size())\n                use2[G[k][l]] = true;\n            REP(l,n){\n                use[l] = (use[l] && use2[l]);\n            }\n        }\n        int sum = 0;\n        REP(j,n){\n            sum += use[j];\n        }\n        maxi = max(maxi,sum);\n    }\n    printf(\"%d\\n\",maxi);\n}\n\nint main(){\n    while(input()){\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define mp make_pair\n#define pb push_back\n#define EB emplace_back\n#define fi first\n#define se second\n#define all(v) ALL(v)\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\nconstexpr double eps = 1e-14; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint N;\n\nvoid solve(){\n    vector<double> x(N),y(N);\n    rep(i,N){ cin >> x[i] >> y[i]; }\n\n    int ans=1;\n    rep(i,N) rep(j,N) if(i!=j){\n        //cout << \"i,j = \" << i << \",\" << j << endl;\n        double vx = x[i]-x[j];\n        double vy = y[i]-y[j];\n        double d = sqrt(vx*vx+vy*vy);\n        if(d+eps>2) continue;\n        double r = sqrt(1-(d/2)*(d/2));\n\n        double rx =  -vy*r/d;\n        double ry = vx*r/d;\n\n        double cx = (x[i]+x[j])/2 + rx;\n        double cy = (y[i]+y[j])/2 + ry;\n\n        int cnt=0;\n        rep(k,N){\n            double tx = cx-x[k];\n            double ty = cy-y[k];\n            double dd = sqrt(tx*tx+ty*ty);\n            //cout << \"dd=\" << dd << endl;\n            if(dd<=1+eps) cnt++;\n        }\n        //cout << \"cnt : \" << cnt << endl;\n        ans = max(ans,cnt);\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    while(cin>>N){\n        if(N==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n\nusing namespace std;\n\n\nclass Circle {\npublic:\n\tcomplex<double> p;\n\tdouble r;\n\tCircle (complex<double> p0, double r0) {\n\t\tp = p0;\n\t\tr = r0;\n\t}\n};\n\nvector<complex<double> > intersectCC(Circle a, Circle b) {\n\tvector<complex<double> > res(2);\n\n\tauto d = abs(a.p - b.p);\n\tauto c = (d*d + a.r*a.r - b.r*b.r) / (2*d);\n\tauto s = sqrt(a.r*a.r - c*c);\n\tauto diff = (b.p - a.p) / d;\n\n\tres[0] = a.p + diff * complex<double>(c, s);\n\tres[1] = a.p + diff * complex<double>(c, -s);\n\n\treturn res;\n}\n\n\nbool containsCP(Circle c, complex<double> p) {\n\tconst double EPS = 10e-7;\n\tauto d = abs(c.p - p);\n\treturn d <= c.r + EPS;\n}\n\n\nint main()\n{\n\tint n;\n\n\twhile (cin >> n, n) {\n\t\tvector<complex<double> > ps(n);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble x[2];\n\t\t\tcin >> x[0] >> x[1];\n\t\t\tps[i] = complex<double>(x[0], x[1]);\n\t\t}\n\n\t\tauto res = 1;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tif (abs(ps[i]-ps[j]) > 2) continue;\n\t\t\t\tauto cp = intersectCC(Circle(ps[i], 1.0), Circle(ps[j], 1.0));\n\t\t\t\tint cnt = 0;\n\t\t\t\t\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (containsCP(Circle(cp[0], 1.0), ps[k])) cnt++;\n\t\t\t\t}\n\n\t\t\t\tres = max(cnt, res);\n\t\t\t\tcnt = 0;\n\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (containsCP(Circle(cp[1], 1.0), ps[k])) cnt++;\n\t\t\t\t}\n\t\t\t\tres = max(cnt, res);\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define EPS 1.0e-5\nusing namespace std;\n\ntypedef struct {\n  double x,y;\n} P;\n\ndouble dis(P p ){\n  return sqrt( p.x*p.x + p.y*p.y );\n}\ndouble dis(P p1,P p2 ){\n  P p;\n  p.x = p1.x-p2.x;\n  p.y = p1.y-p2.y;\n  return dis( p );\n}\n\n\nint main(){\n  int n, mx;\n  P p[301], m, p1,p2, mv,dmv, c[2];\n  double x;\n\n  while( cin>>n && n ){\n    for( int i=0;i<n;i++ )\n      cin >> p[i].x >> p[i].y ;\n\n    mx=0;\n\n    for( int i=0;i<n;i++ ){\n      for( int j=i+1;j<n;j++ ){\n\tif( dis(p[i],p[j])<2.0 ){\n\t  p1=p[i]; p2=p[j];\n\t  m.x = (p1.x+p2.x)/2.0;\n\t  m.y = (p1.y+p2.y)/2.0;\n\n\t  x = sqrt( 1-dis(p1,m) );\n\t  // ツ陳心ツ点 cツづーツ仰づ淞づゥ\n\t  if( fabs( p1.x-p2.x ) < EPS ){\n\t    mv.x=1.0;  mv.y=0.0;\n\t  }else{\n\t    double a1 = ( p2.y-p1.y )/( p2.x-p1.x );\n\t    mv.x=1.0; mv.y=-1.0/a1;\n\t  }\n\t  double scale = dis( mv );\n\t  dmv.x = x*mv.x / scale;\n\t  dmv.y = x*mv.y / scale;\n\n\t  c[0].x=m.x+dmv.x; c[0].y=m.y+dmv.y;\n\t  c[1].x=m.x-dmv.x; c[2].y=m.y-dmv.y;\n\n\t  for( int cn=0;cn<2;cn++ ){\n\t    int sum=0;\n\t    for( int k=0;k<n;k++ ){\n\t      if( dis( c[cn],p[k] ) < 1.0 )\n\t\tsum++;\n\t    }\n\t    if( mx<sum ) mx=sum;\n\t  }\n\t}\n      }\n    }\n    cout << mx << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <stdio.h>\n#include <complex>\n#include <math.h>\n#include <assert.h>\n\nusing namespace std;\ntypedef complex<double> Complex;\n\nstatic const double E = 0.000001;\n\ninline bool collide_circle_circle(const Complex p1, const double r1, const Complex p2, const double r2) {\n  assert(r1 >= 0.0 && r2 >= 0.0);\n  Complex dif = p1 - p2;\n  return dif.real() * dif.real() + dif.imag() * dif.imag() <= (r1 + r2) * (r1 + r2) + E;\n}\n\n// include circle inside\ninline bool collide_circle_point(const Complex p1, const double r1, const Complex p2) {\n  return collide_circle_circle(p1, r1, p2, 0.0);\n}\n\ninline void intersection_circle_circle(const Complex p1, const double r1, const Complex p2, const double r2, int *size, Complex *ret1, Complex *ret2) {\n  assert(p1 != p2);\n  assert(ret1 != NULL && ret2 != NULL);\n  if (!collide_circle_circle(p1, r1, p2, r2)) {\n    if (size != NULL) { *size = 0; }\n    *ret1 = *ret2 = Complex(NAN, NAN);\n    return;\n  }\n  Complex center = (p1 * r2 + p2 * r1) / (r1 + r2);\n  Complex vect = (center - p1) * Complex(0.0, 1.0);\n  if (abs(vect) < E) {\n    *ret1 = *ret2 = center;\n    if (size != NULL) { *size = 1; }\n    return;\n  }\n  vect *= sqrt(r1 * r1 - norm(vect)) / abs(vect);\n  *ret1 = center + vect;\n  *ret2 = center + vect * Complex(-1.0, 0.0);\n  if (size != NULL) { *size = 2; }\n}\n\nComplex point[301];\n\nint main() {\n  int n;\n  while (scanf(\"%d\", &n), n != 0) {\n    for (int i = 0; i < n; i++) {\n      double a, b;\n      scanf(\"%lf %lf\", &a, &b);\n      point[i] = Complex(a, b);\n    }\n    int max_ans = 1;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < i; j++) {\n        if (!collide_circle_circle(point[i], 1.0, point[j], 1.0)) { continue; }\n        int size;\n        Complex m[2];\n        intersection_circle_circle(point[i], 1.0, point[j], 1.0, &size, &m[0], &m[1]);\n        for (int s = 0; s < size; s++) {\n          int ans = 0;\n          for (int k = 0; k < n; k++) {\n            if (collide_circle_point(m[s], 1.0, point[k])) {\n              ans++; }\n          }\n          max_ans = max(max_ans, ans);\n        }\n      }\n    }\n    printf(\"%d\\n\", max_ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\n#include <ctime>\n#include <numeric>\n#include <fstream>\n#include <valarray>\nusing namespace std;\nstatic const double EPS = 1e-6;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> PI;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int(a.size()))\n#define F first\n#define S second\nconst long double pi=acos(-1.0);\nint dx[]={0,1,0,-1,1,1,-1,-1,0},dy[]={1,0,-1,0,1,-1,1,-1,0};\n\nint n;\npair<double,double> in[300];\nint ans;\n\nint getpointnum(double x,double y,double r){\n  int ret=0;\n  rep(i,n){\n    double tx=in[i].F-x;\n    double ty=in[i].S-y;\n    if(r*r+EPS>=tx*tx+ty*ty)++ret;\n  }\n  return ret;\n}\n\nvoid square(double x,double y,double wh){\n  int t=getpointnum(x+wh/2,y+wh/2,wh/sqrt(2)+1);\n  if(t<=ans)return;\n  ans=max(ans,getpointnum(x+wh/2,y+wh/2,1));\n\n  square(x,y,wh/2);\n  square(x+wh/2,y,wh/2);\n  square(x,y+wh/2,wh/2);\n  square(x+wh/2,y+wh/2,wh/2);    \n}\n\nvoid solve(){\n  rep(i,n)cin>>in[i].F>>in[i].S;\n  ans=1;\n\n  square(-1,-1,11);\n  cout<<ans<<endl;\n}\n\nmain(){\n  while(cin>>n,n)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define cd complex<double>\n\ncomplex<double> ci = complex<double>(0.0,1.0);\ncomplex<double> mci = complex<double>(0.0,-1.0);\n\nint main(){\n\n  while(1){\n    int n;\n    cin >> n;\n    if (n==0)break;\n    vector<complex<double> > p(n);\n    rep(i,n){\n      double real,imag;\n      cin >> real >> imag;\n      p[i] = complex<double>(real,imag);\n    }\n    int summax = 1;\n    rep(i,n){\n      rep(j,n){\n        if (i==j)continue;\n        if (abs(p[i]-p[j])>2)continue;\n        complex<double> mid = (p[i]+p[j])/2.0;\n        double l = abs(p[i]-mid);\n        double h = sqrt(1-l*l);\n        complex<double> c1 = mid + (mid-p[i])*ci*h/l;\n        complex<double> c2 = mid + (mid-p[i])*mci*h/l;\n\n        int sum1 = 2,sum2 = 2;\n        rep(k,n){\n          if(k==i||k==j)continue;\n          if(abs(p[k]-c1)<1.0)sum1++;\n          if(abs(p[k]-c2)<1.0)sum2++;\n        }\n        if (max(sum1,sum2)>summax)summax=max(sum1,sum2);\n      }\n    }\n    cout << summax << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <string>\nusing namespace std;\n\nvector<float> getAreaPointx(int x,int y,vector<float> lx,vector<float> ly)\n{\n\tvector<float> result;\n\tvector<float>::iterator itx=lx.begin();\n\tvector<float>::iterator ity=ly.begin();\n\twhile (itx != lx.end())\n\t{\n\t\tif ((*itx <= x+1) && (*itx >= x-2) && (*ity <= y+1) && (*ity >= y-2)){\n\t\t\tresult.push_back(*itx);\n\t\t}\n\t\titx++;\n\t\tity++;\n\t}\n\treturn result;\n}\n\nvector<float> getAreaPointy(int x,int y,vector<float> lx,vector<float> ly)\n{\n\tvector<float> result;\n\tvector<float>::iterator itx=lx.begin();\n\tvector<float>::iterator ity=ly.begin();\n\twhile (itx != lx.end())\n\t{\n\t\tif ((*itx <= x+1) && (*itx >= x-2) && (*ity <= y+1) && (*ity >= y-2)){\n\t\t\tresult.push_back(*ity);\n\t\t}\n\t\titx++;\n\t\tity++;\n\t}\n\treturn result;\n}\n\n\nfloat distance(float x1,float y1,float x2,float y2)\n{\n\treturn sqrt(pow((x1-x2),2)+pow((y1-y2),2));\n}\n\nint countInside(float x,float y,vector<float> lx,vector<float> ly)\n{\n\tint c=0;\n\tvector<float>::iterator itx=lx.begin();\n\tvector<float>::iterator ity=ly.begin();\n\twhile (itx != lx.end())\n\t{\n\t\tif (distance(x,y,*itx,*ity) <= 1)\n\t\t{\n\t\t\tc++;\n\t\t}\n\t\titx++;\n\t\tity++;\n\t}\n\treturn c;\n}\n\nint main(void) {\n\tvector<int> r;\n\twhile (true)\n\t{\n\t\tint n=0;\n\t\tscanf(\"%d\",&n);\n\t\tif (n==0){\n\t\t\tbreak;\n\t\t}\n\t\tvector<float> x,y;\n\t\tint map[12][12]={{0}};\n\t\tint maxx=0,maxy=0;\n\t\tint maxpoint=0;\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tfloat tx=0,ty=0;\n\t\t\tscanf(\"%f %f\", &tx, &ty);\n\t\t\tx.push_back(tx);\n\t\t\ty.push_back(ty);\n\t\t\tint ttx=0,tty=0;\n\t\t\tttx = int(round(tx+0.5));\n\t\t\ttty = int(round(ty+0.5));\n\t\t\tmap[ttx][tty]++;\n\t\t\tif (maxpoint < map[ttx][tty]){\n\t\t\t\tmaxpoint = map[ttx][tty];\n\t\t\t\tmaxx=ttx;\n\t\t\t\tmaxy=tty;\n\t\t\t}\n\t\t}\n\t\tfor (float dif=0.5; dif>=0.005; dif/=100)\n\t\t{\n\t\t\tfor (int i=1; i<=10; i++)\n\t\t\t{\n\t\t\t\tfor (int j=1; j<=10; j++)\n\t\t\t\t{\n\t\t\t\t\tint aroundpoint=0;\n\t\t\t\t\tfor (int k=-1; k<=1; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int l=-1; l<=1; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taroundpoint+=map[i+k][j+l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (maxpoint >= aroundpoint){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvector<float> lx=getAreaPointx(i,j,x,y);\n\t\t\t\t\t\tvector<float> ly=getAreaPointy(i,j,x,y);\n\t\t\t\t\t\tfor (float k=0; k<1; k+=dif)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (float l=0; l<1; l+=dif)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint tmp = countInside(i-1+k,j-1+l,lx,ly);\n\t\t\t\t\t\t\t\tif (tmp>maxpoint){\n\t\t\t\t\t\t\t\t\tmaxpoint = tmp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr.push_back(maxpoint);\n\t}\n\tfor(int i=0; i<r.size(); i++)\n\t{\n\t\tcout << r[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nint INF=1e9;\nint MOD=1000000007;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ndouble EPS = 1e-10;\ndouble add(double a,double b){\n\tif(abs(a+b)<EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,p.x),add(y,-p.y));\n\t}\n\tP operator * (P p){\n\t\treturn P(x*p.x,y*p.y);\n\t}\n};\ndouble dist(P a,P b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\nint cnt(P pos,vector<P> dat){\n\tint res=0;\n\tREP(i,dat.size()){\n\t\tif(dist(pos,dat[i])<=1.0)res++;\n\t}\n\treturn res;\n}\nint main(){\n\tint n;\n\tdouble x,y;\n\twhile(scanf(\"%d\",&n)&&n){\n\t\tvector<P> dat;\n\t\tREP(i,n){\n\t\t\tcin>>x>>y;\n\t\t\tdat.PB(P(x,y));\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tP a=dat[i],b=dat[j];\n\t\t\t\tif(dist(a,b)>2.0){\n\t\t\t\t\tans=max(ans,1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tP mid=P((a.x+b.x)/2,(a.y+b.y)/2);\n\t\t\t\tdouble dx=a.y-b.y,dy=b.x-a.x;\n\t\t\t\tdouble dd=sqrt(dx*dx+dy*dy);\n\t\t\t\tdouble ddd=sqrt(1-dist(a,b)/2*dist(a,b)/2);\n\t\t\t\tdx=dx/dd*ddd;dy=dy/dd*ddd;\n\t\t\t\tans=max(ans,cnt(P(mid.x+dx,mid.y+dy),dat));\n\t\t\t\tans=max(ans,cnt(P(mid.x-dx,mid.y-dy),dat));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nP center1(P a ,P b ,double r){\n  return (a+b)/(P)2+(b-a)*P(0,1)*(P)(sqrt(r*r-norm((b-a)/(P)2))/abs(b-a));\n}\n\nP center2(P a ,P b ,double r){\n  return (a+b)/(P)2+(b-a)*P(0,-1)*(P)(sqrt(r*r-norm((b-a)/(P)2))/abs(b-a));\n}\n\nint main(){\n  int n;\n  while(true){\n    cin >>n;\n    if (!n)\n      break;\n    P dot[n];\n    double x,y;\n    for(int i=0;i<n;i++){\n      cin >>x >>y;\n      dot[i] = P(x,y);\n    }\n    set<int> near_dot[n];\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif (norm(dot[i]-dot[j])<4)\n\t  near_dot[i].insert(j);\n      }\n    }\n    \n    set<int>::iterator it;\n    int cnt,max=2;\n    P c;\n    for(int i=0;i<n;i++){\n      it = near_dot[i].begin();\n      while(it != near_dot[i].end()){\n\tc = center1(dot[i],dot[*it],1);\n\tcnt=2;\n\tfor(int j=0;j<n;j++)\n\t  if (norm(dot[j]-c)<1 && j!=i && j!=*it)\n\t    cnt++;\n\tif (max<cnt){\n\t  max=cnt;\n\t}\n\n\tc = center2(dot[i],dot[*it],1);\n\tcnt=2;\n\tfor(int j=0;j<n;j++)\n\t  if (norm(dot[j]-c)<1 && j!=i && j!=*it)\n\t    cnt++;\n\tif (max<cnt){\n\t  max=cnt;\n\t}\n\tit++;\n      }\n    }\n    cout << max << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\n// 点\nclass Point {\n  public:\n    float x, y;\n    Point(double ix = 0.0, double iy = 0.0) {\n      set(ix, iy);\n    }\n    void set(double ix = 0.0, double iy = 0.0) {\n      x = ix;\n      y = iy;\n    }\n    void copy(Point p) {\n      x = p.x;\n      y = p.y;\n    }\n    double length() {\n      return sqrt(x * x + y * y);\n    }\n    double distanceTo(Point p) {\n      double dx = p.x - x, dy = p.y - y;\n      return sqrt(dx * dx + dy * dy);\n    }\n    void setCentroidOf(Point p1, Point p2) {\n      x = (p1.x + p2.x) / 2;\n      y = (p1.y + p2.y) / 2;\n    }\n};\n\nint main() {\n  vector<int> results;\n  while (true) {\n    // 入力\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    vector<Point> p(n);\n    for (int i=0; i<n; i++) {\n      double x, y;\n      cin >> x >> y;\n      p[i].set(x, y);\n    }\n    \n    const int nC2 = n * (n - 1) / 2 + n;\n    vector<Point> px(n); // 現時点で有力な点\n    for (int i=0; i<n; i++) px[i].copy(p[i]);\n    vector<Point> cp(nC2); // 中点たち\n    int previousMaxScore = 0; // 前回のループでの最高スコア\n    int maxScoreConst = 0; // 同じ最高スコアが連続して記録された回数\n    while (true) {\n      // 与えられた点の中点たち（+もとの点）を候補点とする\n      int cpi = 0;\n      for (int i=0; i<n-1; i++) {\n\tfor (int j=i+1; j<n; j++) {\n\t  cp[cpi++].setCentroidOf(px[i], px[j]);\n\t}\n      }\n      for (int i=0; i<n; i++) cp[cpi++].copy(px[i]);\n      // 各点のスコアを算出\n      vector<int> scores(nC2);\n      for (int i=0; i<nC2; i++) {\n\tscores[i] = 0;\n\tfor (int j=0; j<n; j++) {\n\t  if (cp[i].distanceTo(p[j]) <= 1) scores[i]++;\n\t}\n      }\n      // cpをスコア降順にバブルソート\n      for (int i=0; i<nC2; i++) {\n\tfor (int j=0; j<nC2-1; j++) {\n\t  if (scores[j] < scores[j + 1]) {\n\t    double jx = cp[j].x, jy = cp[j].y;\n\t    cp[j].copy(cp[j + 1]);\n\t    cp[j + 1].set(jx, jy);\n\t    int js = scores[j];\n\t    scores[j] = scores[j + 1];\n\t    scores[j + 1] = js;\n\t  }\n\t}\n      }\n      // このループの最大スコア\n      int maxScore = scores[0];\n      //cout << maxScore << \" -> \";\n      if (maxScore == previousMaxScore) {\n\t// 最大スコアが3回連続で更新されなかったら確定\n\tpreviousMaxScore = maxScore;\n\tif (++maxScoreConst >= 3) break;\n      } else {\n\tpreviousMaxScore = maxScore;\n\tmaxScoreConst = 0;\n      }\n      // スコアが上位nの点を次のループの中点の素として採用\n      for (int i=0; i<n; i++) px[i].copy(cp[i]);\n    }\n    \n    results.push_back(previousMaxScore);\n    //cout << endl;\n  }\n  \n  int size = results.size();\n  for (int i=0; i<size; i++) {\n    cout << results[i] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\n#define rep(i, n)       rep2(i, 0, n)\n#define rep2(i, m, n)   for(int i = m; i < (int)(n); ++i)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> Pt;\n\nconst double EPS = 1e-9;\n\nint main()\n{\n    int n;\n    while (cin >> n, n) {\n        double x, y;\n        vector<Pt> p;\n        rep (i, n) {\n            cin >> x >> y;\n            p.push_back(Pt(x, y));\n        }\n        \n        int ans = 1;\n        rep (i, n) rep2 (j, i + 1, n) {\n            double d = abs(p[i] - p[j]);\n            if (d > 2.0) continue;\n            \n            Pt m = (p[i] + p[j]) / 2.0;\n            Pt v = Pt(p[i].Y - p[j].Y, p[j].X - p[i].X);\n            v /= abs(v);\n            v *= sqrt(1.0 - d * d / 4.0);\n            \n            int t1 = 0, t2 = 0;\n            Pt c1 = m + v, c2 = m - v;\n            rep (k, n) {\n                if (abs(p[k] - c1) < 1.0 + EPS) ++t1;\n                if (abs(p[k] - c2) < 1.0 + EPS) ++t2;\n            }\n            ans = max(max(t1, t2), ans);\n        }\n        \n        cout << ans << endl;        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\n\ntypedef pair<double, double> point;\nconst double EPS = 1e-6;\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tpoint p[333];\n\t\trep (i, n)\n\t\t\tscanf(\"%lf%lf\", &p[i].first, &p[i].second);\n\t\tsort(p, p + n);\n\n\t\tqueue<point> q;\n\t\trep (i, n)\n\t\t\tq.push(p[i]);\n\n\t\tlist<point> r;\n\t\tint res = 0;\n\t\tfor (int i = -1000; i <= 10000; ++i)\n\t\t{\n\t\t\tdouble cx = i * 1e-3;\n\t\t\twhile (!r.empty() && r.front().first < cx - 1 + EPS)\n\t\t\t\tr.pop_front();\n\t\t\twhile (!q.empty() && q.front().first < cx + 1 + EPS)\n\t\t\t\tr.push_back(q.front()), q.pop();\n\n\t\t\tvector<double> cy;\n\t\t\tforeach (it, r)\n\t\t\t{\n\t\t\t\tdouble x = it->first, y = it->second;\n\t\t\t\tdouble d = sqrt(1 - (x - cx) * (x - cx));\n\t\t\t\tcy.push_back(y - d);\n\t\t\t\tcy.push_back(y + d);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < cy.size(); ++i)\n\t\t\t{\n\t\t\t\tint c = 0;\n\t\t\t\tforeach (it, r)\n\t\t\t\t{\n\t\t\t\t\tdouble dx = cx - it->first;\n\t\t\t\t\tdouble dy = cy[i] - it->second;\n\t\t\t\t\tif (dx * dx + dy * dy < 1 + EPS)\n\t\t\t\t\t\t++c;\n\t\t\t\t}\n\t\t\t\tmax_swap(res, c);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble EPS=1e-5;\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<complex<double>> p(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tp[i]=complex<double>(x,y);\n\t\t}\n\n\t\tint res=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(abs(p[i]-p[j])>=2) continue;\n\t\t\t\tcomplex<double> mid=(p[i]+p[j])/complex<double>(2.0,0.0);\n\t\t\t\tauto a=(p[i]-p[j]);\n\t\t\t\tauto v=a*complex<double>(0,1);\n\t\t\t\tv=v/abs(v);\n\t\t\t\tdouble d=abs(mid-p[i]);\n\t\t\t\tdouble t=sqrt(1-d*d);\n\t\t\t\tcomplex<double> c[2]={mid+t*v,mid-t*v};\n\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\tint kai=0;\n\t\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\t\tif(abs(c[k]-p[i])<1+EPS) kai++;\n\t\t\t\t\t}\n\t\t\t\t\tres=max(res,kai);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nstatic const int MAX_N = 300;\n\n#define EPS (1e-10)\n\nclass Point{\n\tpublic:\n\t\tdouble x, y;\n\n\t\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\n\t\tPoint operator + (Point p){ return Point(x + p.x, y + p.y);}\n\t\tPoint operator - (Point p){ return Point(x - p.x, y - p.y);}\n\t\tPoint operator * (double a){ return Point(a * x, a * y);}\n\t\tPoint operator / (double a){ return Point(x / a, y / a);}\n\n\t\tdouble abs(){ return sqrt(norm());}\n\t\tdouble norm(){ return x * x + y * y;}\n\n\t\tbool operator < (const Point &p) const{\n\t\t\treturn x != p.x ? x < p.x : y < p.y;\n\t\t}\n\n\t\tbool operator == (const Point &p) const{\n\t\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t\t}\n};\n\nclass Circle{\n\tpublic:\n\t\tPoint c;\n\t\tdouble r;\n\t\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef Point Vector;\n\nint N;\nPoint p[MAX_N];\n\ndouble arg(Vector p){return atan2(p.y, p.x);}\nVector polar(double a, double r){return Point(cos(r) * a, sin(r) * a);}\n\ndouble getDistance(Point a, Point b){\n\treturn (a - b).abs();\n}\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\nbool comp(const Point &a, const Point &b){\n\treturn a.x < b.x;\n}\n\nint main(){\n\tfor(;;){\n\t\tscanf(\"%d\", &N);\n\t\tif(N == 0) break;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%lf %lf\", &p[i].x, &p[i].y);\n\t\t}\n\t\tsort(p, p + N, comp);\n\t\tint res = 1;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = i + 1; j < N; j++){\n\t\t\t\tif(p[j].x - p[i].x > 2.0) break;\n\t\t\t\telse if(getDistance(p[i], p[j]) > 2.0) continue;\n\t\t\t\tpair<Point, Point> pp = getCrossPoints((Circle){p[i], 1.0}, (Circle){p[j], 1.0});\n\t\t\t\tPoint p1 = pp.first, p2 = pp.second;\n\t\t\t\tint cnt1 = 2, cnt2 = 2;\n\t\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\t\tif(k == i || k == j) continue;\n\t\t\t\t\tif(p[k].x - p[j].x > 1.0) break;\n\t\t\t\t\tif(getDistance(p1, p[k]) < 1.0) cnt1++;\n\t\t\t\t\tif(getDistance(p2, p[k]) < 1.0) cnt2++;\n\t\t\t\t}\n\t\t\t\tres = max(res, max(cnt1, cnt2));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\ntypedef complex<double> point;\n\nint main(){\n\t\n\tA:;\n\tint n;\n\tcin>>n;\n\tif(n==0)return 0;\n\t\n\tpoint p[333];\n\t\n\trep(i,n){\n\t\tdouble a,b;\n\t\tcin>>a>>b;\n\t\tp[i] = point(a,b);\n\t}\n\tdouble eps = 1E-11;\n\tint ans = 0;\n\trep(i,n){\n\t\treps(j,i+1,n){\n\t\t\tpoint d = (p[j]-p[i])/point(2,0);\n\t\t\tdouble dlen = abs(d);\n\t\t\tif(dlen>1)continue;\n\t\t\t\n\t\t\t//cout<<p[j]<<\" \"<<p[i]<<\" \"<<d<<\" \"<<dlen<<endl;\n\t\t\t\n\t\t\tpoint center = p[i]+d;\n\t\t\tpoint e1 = d/point(dlen,0)*point(0,1)*point(sqrt(1-dlen*dlen),0);\n\t\t\tpoint e2 = d/point(dlen,0)*point(0,-1)*point(sqrt(1-dlen*dlen),0);\n\t\t\t\n\t\t\tpoint t1 = center+e1;\n\t\t\tpoint t2 = center+e2;\n\t\t\t\n\t\t\t//cout<<t1<<\" \"<<t2<<endl;\n\t\t\t\n\t\t\tint count1 = 0;\n\t\t\tint count2 = 0;\n\t\t\trep(k,n){\n\t\t\t\tif(abs(t1-p[k])<1+eps)count1++;\n\t\t\t\tif(abs(t2-p[k])<1+eps)count2++;\n\t\t\t}\n\t\t\t\n\t\t\tans = max(ans,count1);\n\t\t\tans = max(ans,count2);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n\t\n\tgoto A;\n}\n\n/*\n3\n0 1\n1 0\n1 1\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n//CCW??¨///////////////////////////////////\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n/////////////////////////////////////////\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\nstruct Circle{\n  Point c;\n  double r;\n};\ntypedef Point vect;\nstruct seg{Point p1,p2;};\n//????????´????????????\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\n//??¶???????????????absolute  ?????????????????¶?????????\ndouble abs(Point p){return sqrt(norm(p));}\n//?????????????????????????????????\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n//?????? ????????????????????????\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n//??´?????????????????¨?????\\?????????????????????\nbool C90(seg s1,seg s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//????????????????????¨?????\\??????????????????????????????????????????\nbool C0(seg s1,seg s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//?°???± ??????????????´???????????????\nPoint project(seg s,Point p){\n  Point base = s.p2-s.p1;\n  double r=dot(p-s.p1,base) / norm(base);\n  return s.p1+base*r;\n}\n//????°??????????????????????\nPoint reflection(seg s,Point p){\n  return  p+(project(s,p)-p)*2.0;\n}\n//2???????????¢   ???????????????\ndouble getDistancePP(Point a,Point b){\n  return abs(a-b);\n}\n//??´??????????????¢(????°?)???????????????\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n//?????????????????¢??????????????????\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n//????¨?????????????????¨??????????????????????????????????\nint CCW(Point p0,Point p1,Point p2){\n  Point a=p1-p0;\n  Point b=p2-p0;\n  if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS)return CLOCKWISE;\n  if(dot(a,b)<-EPS)return ONLINE_BACK;\n  if(norm(a)<norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n//????????????????????????????????????????????§?\\????\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return(CCW(p1,p2,p3)*CCW(p1,p2,p4)<=0&&CCW(p3,p4,p1)*CCW(p3,p4,p2)<=0);\n}\nbool intersect(seg s1,seg s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//2??????????§???¢?????\\??????????????????...????????????????????????\nbool squareintersect(seg s1,seg s2){\n  if(s1.p2.x<s2.p1.x||s2.p2.x<s1.p1.x)return 0;\n  if(s1.p2.y<s2.p1.y||s2.p2.y<s1.p1.y)return 0;\n  return 1;\n}\n//??????????????¢?????????????????????????????§??¨???????????????\ndouble getDistance(seg s1,seg s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n    min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n//??????????????????????????????(?´????????`)\nPoint getCrossPoint(seg s1,seg s2){\n  Point base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n//???????£????????????¢??????????????¢??????????????????????????\\????????????????????§???????????£???????????????????????????????????§?????????????????????\nint intersectCC(Circle a,Circle b){\n  double dist=abs(a.c-b.c);\n  if(dist>a.r+b.r+EPS)return 4;\n  if(dist>a.r+b.r-EPS)return 3;\n  if(dist>abs(a.r-b.r)+EPS)return 2;\n  if(dist>abs(a.r-b.r)-EPS)return 1;\n  return 0;\n}\n//?????¨??´???????????????2?????? (LINE)\nseg getCrossPoint(Circle c,seg l){\n  //assert(intersect(cc,l));\n  Point pr=project(l,c.c);\n  Point e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base =sqrt(c.r*c.r-norm(pr-c.c));\n  seg pp;pp.p1=(pr+e*base);pp.p2=(pr-e*base);\n  return pp;\n}\n//?????¨??´??????Line??????????????°\nint getCircleLine(Circle c,seg l){\n  seg a=getCrossPoint(c,l);\n  if(isnan(a.p1.x)&&isnan(a.p2.y))return 0;\n  else if(a.p1.x==a.p2.x&&a.p1.y==a.p2.y)return 1;\n  else return 2;\n}\n//??´?????¨????????\\???????????????\nbool intersectCirclesen(seg s,Circle t){\n  double a,b,c;\n  a=getDistancePP(s.p1,t.c);\n  b=getDistancePP(s.p2,t.c);\n  c=getDistanceSP(s,t.c);\n  if(a<t.r&&b>t.r)return 1;\n  if(b<t.r&&a>t.r)return 1;\n  if(a>=t.r&&b>=t.r&&c<=t.r)return 1;\n  return 0;\n}\n//??????\nPoint gaishin(Point a, Point b, Point c){\n  double a1,a2,b1,b2,c1,c2;\n  a1=2*(b.x-a.x);b1=2*(b.y-a.y);c1=a.x*a.x-b.x*b.x+a.y*a.y-b.y*b.y;\n  a2=2*(c.x-a.x);b2=2*(c.y-a.y);c2=a.x*a.x-c.x*c.x+a.y*a.y-c.y*c.y;\n  Point p;p.x=(b1*c2-b2*c1)/(a1*b2-a2*b1);p.y=(c1*a2-c2*a1)/(a1*b2-a2*b1);\n  return p;\n}\n//2??????????????????\ndouble arg(Point p){return atan2(p.y,p.x);}\nPoint polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\nseg getCrossPoints(Circle c1,Circle c2){\n  //assert(intersect(c1,c2));\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  seg s;s.p2=c1.c+polar(c1.r,t+a);s.p1=c1.c+polar(c1.r,t-a);\n  return s;\n}\n//???????????? ????????????->2 ??????->1  ????????\\???->0\ntypedef vector<Point> Polygon;\nint contains(Polygon g, Point p) {\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++) {\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n  }\n  return x ? 2 : 0;\n}\ndouble Area(Polygon p) {\n  double a=0;\n  for(int i=0;i<p.size();i++)a+=cross(p[i],p[(i+1)%p.size()]);\n  return a/2;\n}\n//???????§???¢??????\nbool isConvex(Polygon p){\n  for(int i=0;i<p.size();i++){\n    if(CCW(p[(i+1)%p.size()],p[i%p.size()],p[(i+2)%p.size()])==1)return false;\n  }\n  return true;\n}\n//?????¢???????????¢???(?????´)=ans\nPolygon convex_cut(Polygon p,seg l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(CCW(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(CCW(l.p1,l.p2,A)*CCW(l.p1,l.p2,B)<0){\n      seg s;s.p1=A;s.p2=B;\n      ans.push_back(getCrossPoint(l,s));\n    }\n  }\n  return ans;\n}\ndouble convex_diameter(Polygon p){\n  int n=p.size();\n  int i=0,j=0;\n  for(int k=0;k<n;k++){if(p[i]<p[k])i=k;if(p[k]<p[j])j=k;}\n  int si=i,sj=j;double ans=0.0;\n  while(i!=sj||j!=si){\n    ans=max(ans,abs(p[i]-p[j]));\n    if(cross((p[(i+1)%n]-p[i]),(p[(j+1)%n]-p[j]))<0)i=(i+1)%n;\n    else j=(j+1)%n;\n  }\n  return ans;\n}\n//?????? ??´??????????????????????????????????????¨?????????191,197?????????&&CCW(u[n-2],u[n-1],s[i])!=ONLINE_FRONT???????????????\nPolygon andrewScan(Polygon s) {\n  Polygon l, u;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<s.size();i++){\n    for(int n=u.size();n>=2&&CCW(u[n-2],u[n-1],s[i])!=-1&&CCW(u[n-2],u[n-1],s[i])!=ONLINE_FRONT;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&CCW(l[n-2],l[n-1],s[i])!=-1&&CCW(l[n-2],l[n-1],s[i])!=ONLINE_FRONT;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for( int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  return l;\n}\n//???a??¨???b??????d??¢??????2???\nseg identifyPoint(Point a,Point b,double d){\n  Circle c1,c2;\n  c1.c=a;c1.r=d;c2.c=b;c2.r=d;\n  return getCrossPoints(c1,c2);\n}\n//    ???????????°??¨??????\nseg scan(){seg a;scanf(\"%lf%lf%lf%lf\",&a.p1.x,&a.p1.y,&a.p2.x,&a.p2.y);return a;}\nvoid prin(seg a){printf(\"%.10f %.10f %.10f %.10f\\n\",a.p1.x,a.p1.y,a.p2.x,a.p2.y);}\n//\n/////------Library END-------//////////////////////////////////////\n//   exp?????????    //////a=x??§?¨????b=y??§?¨????c=?§?????????????d=????????????????????¢\n//    p[i][j].x=a-d*sin(M_PI/180*(72*j+c));\n//   p[i][j].y=b+d*cos(M_PI/180*(72*j+c));\n/////////////////////////////////////////////////\nint main(){\n  int n;\n  while(cin>>n,n){\n    Point p[n];int ans=0;\n    r(i,n)cin>>p[i].x>>p[i].y;\n    r(i,n)for(int j=i+1;j<n;j++){\n      seg s=identifyPoint(p[i],p[j],1);\n      int a1=0,a2=0;\n      Point p3,p4;p3=s.p1;p4=s.p2;\n      r(k,n)if(abs(getDistancePP(p3,p[k])-1)<EPS)a1++;\n      r(k,n)if(abs(getDistancePP(p4,p[k])-1)<EPS)a2++;\n      ans=max(ans,max(a1,a2));\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define LP(i,n) for(int i = 0; i < n; i++)\n\nusing namespace std;\ntypedef pair<double,double> P;\n\ndouble Dist(double x1[], double x2[]){\n\treturn pow((x1[0]-x2[0])*(x1[0]-x2[0])+(x1[1]-x2[1])*(x1[1]-x2[1]),0.5);\n\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\twhile(n){\n\t\tP p[300];\n\t\tLP(i,n){\n\t\t\tcin >> p[i].first >> p[i].second;\n\t\t}\n\t\tsort(p,p+n);\n\t\tdouble x[300][2];\n\t\tLP(i,n){\n\t\t\tx[i][0] = p[i].first;\n\t\t\tx[i][1] = p[i].second;\n\t\t}\n\t\tdouble dist[300][300];\n\t\tLP(i,n){\n\t\t\tLP(j,n){\n\t\t\t\tdist[i][j] = Dist(x[i],x[j]);\n\t\t\t}\n\t\t}\n\t\tint mx = 0;\n\t\tLP(i,n){\n\t\t\tfor(int j = i+1; j < n; j++){\n\t\t\t\tif(x[j][0]-x[i][0] > 2){\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tif(dist[i][j] <= 2){\n\t\t\t\t\t\tdouble m[] = {(x[j][0]+x[i][0])/2,(x[j][1]+x[i][1])/2};\n\t\t\t\t\t\tdouble d[] = {x[j][1]-x[i][1],-x[j][0]+x[i][0]};\n\t\t\t\t\t\tdouble O[] = {0,0};\n\t\t\t\t\t\tdouble _d = Dist(d,O);\n\t\t\t\t\t\tLP(k,2){\n\t\t\t\t\t\t\td[k] *= (pow(_d,-2)-0.25);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdouble o[2][2];\n\t\t\t\t\t\tLP(k,2){\n\t\t\t\t\t\t\tLP(l,2){\n\t\t\t\t\t\t\t\to[k][l] = m[l];\n\t\t\t\t\t\t\t\tif(k) o[k][l] += d[l];\n\t\t\t\t\t\t\t\telse o[k][l] -= d[l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLP(k,2){\n\t\t\t\t\t\t\tint s = 2;\n\t\t\t\t\t\t\tfor(int l = i+1; l < j; l++){\n\t\t\t\t\t\t\t\tif(Dist(x[l],o[k]) <= 1) s++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int l = i-1; 0<=l && x[i][0]-x[l][0] <= 1;l--){\n\t\t\t\t\t\t\t\tif(Dist(x[l],o[k]) <= 1) s++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int l = j+1; l < n && x[l][0]-x[j][0] <= 1; l++){\n\t\t\t\t\t\t\t\tif(Dist(x[l],o[k]) <= 1) s++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmx = max(mx,s);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << mx << endl;\n\t\tcin >> n;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <functional>\n#include <ctime>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n#define all(c) ((c).begin()), ((c).end())\n#define TEST(x,a) { auto y=(x); if (sign(y-a)) { cout << \"line \" << __LINE__  << #x << \" = \" << y << \" != \" << a << endl; exit(-1); } }\ndouble urand() { return rand() / (1.0 + RAND_MAX); }\n\nconst double PI = acos(-1.0);\n\n// implementation note: use EPS only this function\n// usage note: check sign(x) < 0, sign(x) > 0, or sign(x) == 0\n// notice: should be normalize to O(1)\nconst double EPS = 1e-8;\nint sign(double x) {\n  if (x < -EPS) return -1;\n  if (x > +EPS) return +1;\n  return 0;\n}\nstruct point {\n  typedef double T;\n  T x, y; \n  point &operator+=(point p) { x += p.x; y += p.y; return *this; }\n  point &operator-=(point p) { x -= p.x; y -= p.y; return *this; }\n  point &operator*=(T a)     { x *= a;   y *= a;   return *this; }\n  point &operator/=(T a)     { return *this *= (1.0/a); }\n  point operator-() const    { return {-x, -y}; }\n  bool operator==(point p) const { return !sign(x-p.x) && !sign(y-p.y); }\n  bool operator!=(point p) const { return !operator==(p); }\n  bool operator<(point p) const { return x!=p.x ? x<p.x : y<p.y; } // for sort\n};\npoint operator+(point p, point q) { return p += q; }\npoint operator-(point p, point q) { return p -= q; }\npoint operator*(point::T a, point p) { return p *= a; }\npoint operator*(point p, point::T a) { return p *= a; }\npoint operator/(point p, point::T a) { return p /= a; }\npoint::T dot(point p, point q) { return p.x*q.x+p.y*q.y; }\npoint::T cross(point p, point q) { return p.x*q.y-p.y*q.x; } // left turn > 0\npoint::T norm2(point p) { return dot(p,p); }\npoint::T norm(point p) { return sqrt(dot(p,p)); }\npoint::T dist(point p, point q) { return norm(p-q); }\npoint orth(point p) { return {-p.y, p.x}; }\n\nistream &operator>>(istream &is, point &p) { is>>p.x>>p.y;return is; }\nostream &operator<<(ostream &os, const point &p) { os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; return os; }\n\nint maximum_circle_cover(vector<point> ps, double r) {\n  struct range {\n    point p; // center\n    double w; // width\n    int hi;\n    bool operator<(range r) const {\n      return hi < r.hi;\n    }\n  };\n  double w = 0;\n  for (point p: ps) w = max({w, abs(p.x), abs(p.y)});\n  priority_queue<range> que;\n  que.push({{0,0}, w, (int)ps.size()});\n  point best_p;\n  int best = 0;\n  while (!que.empty()) {\n    range R = que.top(); que.pop();\n    if (R.hi <= best) continue;\n    //cout << \"processing \" << R.p << \" \" << R.w << \" \" << R.hi << \"/\" << best << endl;\n    double dx[] = {1,-1,-1,1}, dy[] = {1,1,-1,-1};\n    for (int i = 0; i < 4; ++i) {\n      range S = {R.p, R.w/2, 0};\n      S.p += S.w*point({dx[i], dy[i]});\n      int lo = 0;\n      for (point q: ps) {\n        auto d = dist(S.p, q);\n        if (sign(d - r) <= 0) ++lo;\n        if (sign(d - S.w*sqrt(2) - r) <= 0) ++S.hi;\n      }\n      if (lo > best) { best = lo; best_p = S.p; }\n      best = max(lo, best);\n      if (S.hi > best) que.push(S);\n    }\n  }\n  return best; //best_p;\n}\nint maximum_circle_cover3(vector<point> ps, double r) {\n\n  point best_p;\n  int best = 0;\n  function<void(point,double,vector<point>&)> rec = [&](point p, double w, vector<point> &ps) {\n    w /= 2;\n    const double dx[] = {1,-1,-1,1}, dy[] = {1,1,-1,-1};\n    point qs[4];\n    vector<point> pss[4];\n    for (int i = 0; i < 4; ++i) {\n      qs[i] = p + w * point({dx[i], dy[i]});\n      int lo = 0;\n      for (point q: ps) {\n        auto d = dist(qs[i], q);\n        if (sign(d - r) <= 0) ++lo;\n        if (sign(d - w*sqrt(2) - r) <= 0) pss[i].push_back(q);\n      }\n      if (lo > best) { best = lo; best_p = qs[i]; }\n    }\n    int a = 0, b = 1, c = 2, d = 3;\n    auto SW = [&](int &a, int &b) { if (pss[a].size() > pss[b].size()) swap(a, b); };\n    SW(a,b);SW(c,d);SW(b,d);SW(a,c);SW(b,c);\n    if (pss[d].size() > best) rec(qs[d], w, pss[d]);\n    if (pss[b].size() > best) rec(qs[b], w, pss[b]);\n    if (pss[c].size() > best) rec(qs[c], w, pss[c]);\n    if (pss[a].size() > best) rec(qs[a], w, pss[a]);\n  };\n  double w = 0;\n  for (point p: ps) w = max({w, abs(p.x), abs(p.y)});\n  rec({0,0}, w, ps);\n  return best; //best_p;\n}\n\nint maximum_circle_cover2(vector<point> ps, double r) {\n  int best = 0;\n  for (point p: ps) {\n    int count = 0;\n    vector<pair<double,int>> aux;\n    for (point q: ps) {\n      auto d = dist(p, q);\n      if (sign(d) == 0) ++count;\n      else if (sign(d - 2*r) <= 0) {\n        double theta = atan2(q.y-p.y, q.x-p.x);\n        double phi   = acos(min(1., d/(2*r)));\n        aux.push_back({theta-phi, -1});\n        aux.push_back({theta+phi, +1});\n      }\n    }\n    sort(all(aux));\n    /*\n    cout << \"for point \" << p << endl;\n    for (auto a: aux) \n      cout << \"(\" << a.fst << \",\" << a.snd << \") \";\n    cout << endl;\n    */\n\n    for (auto a: aux) \n      best = max(best, count -= a.snd);\n  }\n  return best;\n}\n\n\nvoid verify_maximum_circle_cover2() {\n  for (int n; scanf(\"%d\", &n) && n; ) {\n    vector<point> ps(n);\n    for (int i = 0; i < n; ++i) \n      scanf(\"%lf %lf\", &ps[i].x, &ps[i].y);\n    printf(\"%d\\n\", maximum_circle_cover1(ps, 1.0));\n  }\n}\n\n\nint main() {\n  //verify_maximum_circle_cover();\n  verify_maximum_circle_cover2();\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef complex<double> Point;\nconst double eps = 1e-9;\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint N; \n\twhile (cin >> N, N) {\n\t\tvector<Point> P(N);\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\tdouble x, y; cin >> x >> y;\n\t\t\tP[i] = Point(x, y);\n\t\t}\n\t\tif (N == 1) { cout << 1 << endl; return 0; }\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < N;i++) for (int j = i + 1; j < N;j++) {\n\t\t\tdouble dist = abs(P[i] - P[j]);\n\t\t\tif (dist > 2) continue;\n\t\t\tdouble r = sqrt(1 - dist*dist / 4);\n\t\t\tdouble difx = -(P[i] - P[j]).imag()*r / dist;\n\t\t\tdouble dify = (P[i] - P[j]).real()*r / dist;\n\t\t\tPoint new_P(difx, dify);\n\t\t\tPoint check_P(new_P + (P[i] + P[j]) / 2.0);\n\t\t\t\n\t\t\tint cnt = 0;\n\t\t\tfor (int k = 0; k < N;k++) {\n\t\t\t\tif (abs(check_P - P[k]) < 1.0 + eps)cnt++;\n\t\t\t}\n\t\t\tans = max(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// aribon3-6_f\n#include <bits/stdc++.h>\n#ifdef LOCAL\n#include \"../cxx-prettyprint/prettyprint.hpp\"\n#endif\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define REP(i, n) for (int (i) = 0 ; (i) < (int)(n) ; ++(i))\n#define REPN(i, m, n) for (int (i) = m ; (i) < (int)(n) ; ++(i))\n#define REP_REV(i, n) for (int (i) = (int)(n) - 1 ; (i) >= 0 ; --(i))\n#define REPN_REV(i, m, n) for (int (i) = (int)(n) - 1 ; (i) >= m ; --(i))\n#define ALL(x) x.begin(), x.end()\n\n#define INF ((1 << 29)-1)\n#define MOD (1000000007)\n\n#define print2D(h, w, arr) REP(i, h) { REP(j, w) cout << arr[i][j] << \" \"; cout << endl; }\ntemplate<class T> void print(const T& x){cout << x << endl;}\ntemplate<class T, class... A> void print(const T& first, const A&... rest) { cout << first << \" \"; print(rest...); }\nstruct PreMain {PreMain(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(20);}} premain;\n\n// ベクトル\nnamespace Geom {\n\n    const double eps = 1e-9;\n\n    struct Point {\n        double x, y;\n        explicit Point(double x=0, double y=0): x(x), y(y) {}\n        Point& operator+=(const Point& v){ x += v.x; y+= v.y; return *this;}\n        Point operator+(const Point& v) const{return Point(*this) += v;}\n        Point& operator-=(const Point& v){x -= v.x; y-= v.y; return *this;}\n        Point operator-(const Point& v) const{return Point(*this) -= v;}\n        Point& operator*=(double s){x *= s; y *= s; return *this;}\n        Point operator*(double s) const{return Point(*this) *= s;}\n        Point& operator/=(double s){x /= s; y /= s; return *this;}\n        Point operator/(double s) const{return Point(*this) /= s;}\n        double dot(const Point& v) const {return x*v.x + y*v.y;}        /* 内積 */\n        double cross(const Point& v) const {return x*v.y - v.x*y;}      /* 外積 */\n        double norm2() const {return x*x + y*y;}                        /* ノルムの二乗*/\n        double norm() const {return sqrt(norm2());}                     /* ノルム */\n        int quadrant() const { if(y > 0) return x>0 ? 1:2; else return x>0 ? 4:3;} /* 象限判定 */\n        Point rot(double theta) {return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y);} // 回転\n        Point rot90() {return Point(-y, x);} // 90度回転\n    };\n\n    ostream& operator<<(ostream& os, const Point& v) {os<<\"(\"<<v.x<<\",\"<<v.y<<\")\"; return os;}\n    istream& operator>>(istream& is, Point& v){ is >> v.x >> v.y; return is;}\n\n    // 点a, b, cからなる三角形の面積\n    double calc_triangle_area(Point a, Point b, Point c) {\n        Point v1 = b - a;\n        Point v2 = c - a;\n        return abs(v1.cross(v2)) / 2;\n    }\n\n    // 点a, bを通る直線と点cとの距離\n    double calc_distance_between_point_and_line(Point a, Point b, Point c) {\n        return abs((b-a).cross(c-a)) / (b-a).norm();\n    }\n\n    // 点a, bを端点とする線分と点cとの距離\n    double calc_distance_between_point_and_segment(Point a, Point b, Point c) {\n        if ((b-a).dot(c-a) < eps) return (c-a).norm();\n        if ((a-b).dot(c-b) < eps) return (c-b).norm();\n        return calc_distance_between_point_and_line(a, b, c);\n    }\n\n    // 点a, bを端点とする線分と点cと点dを端点とする線分の距離\n    double calc_distance_between_segments(Point a, Point b, Point c, Point d) {\n        double d0 = calc_distance_between_point_and_segment(a, b, c);\n        double d1 = calc_distance_between_point_and_segment(a, b, d);\n        double d2 = calc_distance_between_point_and_segment(c, d, a);\n        double d3 = calc_distance_between_point_and_segment(c, d, b);\n        return min(min(d0, d1), min(d2, d3));\n    }\n\n    enum RELATION_BETWEEN_SEGMENT_AND_POINT {\n        COUNTER_CLOCKWISE = 1,     // p1とp2のp0を挟んだ位置関係が反時計回り\n        CLOCKWISE = -1,            // 時計回り\n        ONLINE_BACK = 2,           // p1とp2がp0を挟んで直線状にある\n        ONLINE_FRONT = -2,         // p0とp2の間にp1がある\n        ON_SEGMENT = 0,            // p0とp1の間にp2がある\n    };\n\n    // 点cが点a, bを端点とする線分のどちら側にあるか、enumで返す\n    RELATION_BETWEEN_SEGMENT_AND_POINT ccw_ex(Point p0, Point p1, Point p2) {\n        Point v1 = p1 - p0;\n        Point v2 = p2 - p0;\n        if(v1.cross(v2) > eps) return COUNTER_CLOCKWISE;    // 1\n        if(v1.cross(v2) < -eps) return CLOCKWISE;           // -1\n        if(v1.dot(v2) < -eps) return ONLINE_BACK;           // 2\n        if(v1.norm() < v2.norm()) return ONLINE_FRONT;      // -2\n        return ON_SEGMENT;                                  // 0\n    }\n\n    // 点cが点a, bを端点とする線分のどちら側にあるか\n    int ccw(Point p0, Point p1, Point p2) {\n        Point v1 = p1 - p0;\n        Point v2 = p2 - p0;\n        if(v1.cross(v2) > eps) return 1;\n        if(v1.cross(v2) < -eps) return -1;\n        return 0;\n    }\n\n    // p1,p2を端点とする線分Aとp3,p4を端点とする線分Bの交差判定\n    // include_end=trueなら端点が重なっていても交差しているとみなす\n    bool intersect(Point p1, Point p2, Point p3, Point p4, bool include_end=true) {\n\n        bool is_otherside;\n        bool is_inside;\n\n        if (include_end){\n            is_otherside = ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0; // Aの両側にBの端点があるかどうか。どちらかがAの直線状にいてもOK\n            is_inside = ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0;    // Aの端点の内側にBがいるかどうか。\n        } else {\n            is_otherside = ccw(p1,p2,p3) * ccw(p1,p2,p4) < 0; // Aの両側にBの端点があるかどうか\n            is_inside = ccw(p3,p4,p1) * ccw(p3,p4,p2) < 0;    // Aの端点の内側にBがいるかどうか\n        }\n        return is_otherside && is_inside;\n    }\n\n\n    // 円\n    struct Circle {\n        Point c;\n        double r;\n        Circle(){}\n        Circle(Point c, double r):c(c),r(r){}\n\n        // 円が点pを含むかどうか　include_circumは円周上を含むとするかどうか\n        bool does_include_point(Point p, bool include_circum = true){\n            double d = (p - c).norm();\n            if (include_circum){\n                return d < r + eps;\n            } else {\n                return d < r - eps;\n            }\n        }\n    };\n\n    // 点p1, p2を通る半径rの円を返す\n    vector<Circle> calc_circle_on_two_points(Point p1, Point p2, double r){\n\n        Point p12_half = (p2 - p1) / 2.0;\n\n        double n_vec_norm2 = r*r - p12_half.norm2();\n        if (n_vec_norm2 < 0) return vector<Circle>();\n\n        double n_vec_norm = sqrt(n_vec_norm2);\n        Point n_vec = p12_half.rot90() * n_vec_norm / p12_half.norm();\n\n        vector<Circle> ret;\n        ret.emplace_back(p1 + p12_half + n_vec, 1.0);\n        ret.emplace_back(p1 + p12_half - n_vec, 1.0);\n        return ret;\n    }\n\n\n}\n\n\nint main() {\n#ifdef LOCAL\n    ifstream in(\"../in.txt\"); cin.rdbuf(in.rdbuf());\n#endif\n\n    using namespace Geom;\n\n    while (true){\n        int N;\n        cin >> N;\n        if (N == 0) break;\n\n        vector<Point> points(N);\n        REP(i, N) cin >> points[i];\n\n        int ans = 1;\n        REP(i, N) REPN(j, i+1, N) {\n            vector<Circle> circles = calc_circle_on_two_points(points[i], points[j], 1.0);\n            for (auto circle : circles){\n\n                int nums = 0;\n                REP(k, N){\n                    if (circle.does_include_point(points[k])) {\n                        nums++;\n                    }\n                }\n                ans = max(ans, nums);\n            }\n        }\n        print(ans);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define MOD_TYPE 1\n\n#pragma region Macros\n#include <bits/stdc++.h>\nusing namespace std;\n/*\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\nusing multiInt = boost::multiprecision::cpp_int;\nusing lld = boost::multiprecision::cpp_dec_float_100;\n*/\n/*\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n*/\nusing ll = long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pld = pair<ld, ld>;\ntemplate <typename Q_type>\nusing smaller_queue = priority_queue<Q_type, vector<Q_type>, greater<Q_type>>;\n\nconstexpr ll MOD = (MOD_TYPE == 1 ? (ll)(1e9 + 7) : 998244353);\n//constexpr ll MOD = 1;\nconstexpr int INF = (int)1e9;\nconstexpr ll LINF = (ll)4e18;\nconstexpr double PI = acos(-1.0);\nconstexpr double EPS = 1e-8;\nconstexpr int Dx[] = {0, 0, -1, 1, -1, 1, -1, 1, 0};\nconstexpr int Dy[] = {1, -1, 0, 0, -1, -1, 1, 1, 0};\n\n#define REP(i, m, n) for (ll i = m; i < (ll)(n); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define REPI(i, m, n) for (int i = m; i < (int)(n); ++i)\n#define repi(i, n) REPI(i, 0, n)\n#define MP make_pair\n#define MT make_tuple\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\") << \"\\n\"\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\") << \"\\n\"\n#define possible(n) cout << ((n) ? \"possible\" : \"impossible\") << \"\\n\"\n#define Possible(n) cout << ((n) ? \"Possible\" : \"Impossible\") << \"\\n\"\n#define Yay(n) cout << ((n) ? \"Yay!\" : \":(\") << \"\\n\"\n#define all(v) v.begin(), v.end()\n#define NP(v) next_permutation(all(v))\n#define dbg(x) cerr << #x << \":\" << x << \"\\n\";\n\ninline void init_main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << setprecision(30) << setiosflags(ios::fixed);\n}\ntemplate <typename T>\ninline bool chmin(T &a, T b)\n{\n  if (a > b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <typename T>\ninline bool chmax(T &a, T b)\n{\n  if (a < b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\ninline ll CEIL(ll a, ll b)\n{\n  return (a + b - 1) / b;\n}\ntemplate <typename A, size_t N, typename T>\ninline void Fill(A (&array)[N], const T &val)\n{\n  fill((T *)array, (T *)(array + N), val);\n}\ntemplate <typename T, typename U>\nconstexpr ostream &operator<<(ostream &os, pair<T, U> &p) noexcept\n{\n  os << p.first << \" \" << p.second;\n  return os;\n}\n#pragma endregion\n\nusing Real = double;\nusing Point = complex<Real>;\n\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point &p, const Real &d)\n{\n  return Point(real(p) * d, imag(p) * d);\n}\n\nistream &operator>>(istream &is, Point &p)\n{\n  Real a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p)\n{\n  return os << fixed << setprecision(20) << p.real() << \" \" << p.imag();\n}\n\n// 点 p を反時計回りに theta 回転\ninline Point rotate(Real theta, const Point &p)\n{\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\nReal radian_to_degree(Real r)\n{\n  return (r * 180.0 / PI);\n}\n\nReal degree_to_radian(Real d)\n{\n  return (d * PI / 180.0);\n}\n\n// a-b-c の角度のうち小さい方を返す\nReal get_angle(const Point &a, const Point &b, const Point &c)\n{\n  const Point v(b - a), w(c - b);\n  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta)\n    swap(alpha, beta);\n  Real theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std\n{\nbool operator<(const Point &a, const Point &b)\n{\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nstruct Line\n{\n  Point a, b;\n\n  Line() = default;\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(Real A, Real B, Real C) // Ax + By = C\n  {\n    if (eq(A, 0))\n      a = Point(0, C / B), b = Point(1, C / B);\n    else if (eq(B, 0))\n      b = Point(C / A, 0), b = Point(C / A, 1);\n    else\n      a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p)\n  {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a)\n  {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line\n{\n  Segment() = default;\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle\n{\n  Point p;\n  Real r;\n\n  Circle() = default;\n\n  Circle(Point p, Real r) : p(p), r(r) {}\n};\n\nusing Points = vector<Point>;\nusing Polygon = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\n\ninline Real cross(const Point &a, const Point &b)\n{\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\ninline Real dot(const Point &a, const Point &b)\n{\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\n// 点の回転方向\nint ccw(const Point &a, Point b, Point c)\n{\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS)\n    return +1; // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS)\n    return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0)\n    return +2; // \"ONLINE_BACK\"\n  if (norm(b) < norm(c))\n    return -2; // \"ONLINE_FRONT\"\n  return 0;    // \"ON_SEGMENT\"\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\n// 平行判定\ninline bool parallel(const Line &a, const Line &b)\n{\n  return eq(cross(a.b - a.a, b.b - b.a), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\n// 垂直判定\ninline bool orthogonal(const Line &a, const Line &b)\n{\n  return eq(dot(a.a - a.b, b.a - b.b), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A\n// 射影\n// 直線 l に p から垂線を引いた交点を求める\ninline Point projection(const Line &l, const Point &p)\n{\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\ninline Point projection(const Segment &l, const Point &p)\n{\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B\n// 反射\n// 直線 l を対称軸として点 p  と線対称にある点を求める\ninline Point reflection(const Line &l, const Point &p)\n{\n  return p + (projection(l, p) - p) * 2.0;\n}\n\n// pを通りlに垂直な直線\ninline Line verticalline(const Line &l, const Point &p)\n{\n  Real a = imag(l.b) - imag(l.a);\n  Real b = real(l.a) - real(l.b);\n  return Line(b, -a, a * imag(p) - b * real(p));\n}\n\ninline bool intersect(const Line &l, const Point &p)\n{\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\ninline bool intersect(const Line &l, const Line &m)\n{\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\ninline bool intersect(const Segment &s, const Point &p)\n{\n  return ccw(s.a, s.b, p) == 0;\n}\n\ninline bool intersect(const Line &l, const Segment &s)\n{\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\ninline Real distance(const Line &l, const Point &p);\n\ninline bool intersect(const Circle &c, const Line &l)\n{\n  return distance(l, c.p) <= c.r + EPS;\n}\n\ninline bool intersect(const Circle &c, const Point &p)\n{\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment &s, const Segment &t)\n{\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l)\n{\n  if (norm(projection(l, c.p) - c.p) - c.r * c.r > EPS)\n    return 0;\n  auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS)\n    return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS)\n    return 1;\n  const Point h = projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0)\n    return 2;\n  return 0;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\nint intersect(Circle c1, Circle c2)\n{\n  if (c1.r < c2.r)\n    swap(c1, c2);\n  Real d = abs(c1.p - c2.p);\n  if (c1.r + c2.r < d)\n    return 4;\n  if (eq(c1.r + c2.r, d))\n    return 3;\n  if (c1.r - c2.r < d)\n    return 2;\n  if (eq(c1.r - c2.r, d))\n    return 1;\n  return 0;\n}\n\ninline Real distance(const Point &a, const Point &b)\n{\n  return abs(a - b);\n}\n\ninline Real distance(const Line &l, const Point &p)\n{\n  return abs(p - projection(l, p));\n}\n\ninline Real distance(const Line &l, const Line &m)\n{\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\ninline Real distance(const Segment &s, const Point &p)\n{\n  Point r = projection(s, p);\n  if (intersect(s, r))\n    return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\nReal distance(const Segment &a, const Segment &b)\n{\n  if (intersect(a, b))\n    return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\nReal distance(const Line &l, const Segment &s)\n{\n  if (intersect(l, s))\n    return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m)\n{\n  Real A = cross(l.b - l.a, m.b - m.a);\n  Real B = cross(l.b - l.a, l.b - m.a);\n  if (eq(abs(A), 0.0) && eq(abs(B), 0.0))\n    return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Segment &l, const Segment &m)\n{\n  return crosspoint(Line(l), Line(m));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\npair<Point, Point> crosspoint(const Circle &c, const Line l)\n{\n  Point pr = projection(l, c.p);\n  Point e = (l.b - l.a) / abs(l.b - l.a);\n  if (eq(distance(l, c.p), c.r))\n    return {pr, pr};\n  double base = sqrt(c.r * c.r - norm(pr - c.p));\n  return {pr - e * base, pr + e * base};\n}\n\npair<Point, Point> crosspoint(const Circle &c, const Segment &l)\n{\n  Line aa = Line(l.a, l.b);\n  if (intersect(c, l) == 2)\n    return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\npair<Point, Point> crosspoint(const Circle &c1, const Circle &c2)\n{\n  Real d = abs(c1.p - c2.p);\n  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F\n// 点 p を通る円 c の接線\npair<Point, Point> tangent(const Circle &c1, const Point &p2)\n{\n  return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G\n// 円 c1, c2 の共通接線\nLines tangent(Circle c1, Circle c2)\n{\n  Lines ret;\n  if (c1.r < c2.r)\n    swap(c1, c2);\n  Real g = norm(c1.p - c2.p);\n  if (eq(g, 0))\n    return ret;\n  Point u = (c2.p - c1.p) / sqrt(g);\n  Point v = rotate(PI * 0.5, u);\n  for (int s : {-1, 1})\n  {\n    Real h = (c1.r + s * c2.r) / sqrt(g);\n    if (eq(1 - h * h, 0))\n    {\n      ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);\n    }\n    else if (1 - h * h > 0)\n    {\n      Point uu = u * h, vv = v * sqrt(1 - h * h);\n      ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);\n      ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);\n    }\n  }\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B\n// 凸性判定\nbool is_convex(const Polygon &p)\n{\n  int n = (int)p.size();\n  for (int i = 0; i < n; i++)\n  {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1)\n      return false;\n  }\n  return true;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A\n// 凸包\nPolygon convex_hull(Polygon &p)\n{\n  int n = (int)p.size(), k = 0;\n  if (n <= 2)\n    return p;\n  sort(p.begin(), p.end());\n  vector<Point> ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = p[i++])\n  {\n    while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < EPS)\n      --k;\n  }\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--])\n  {\n    while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < EPS)\n      --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\n// 多角形と点の包含判定\nenum\n{\n  OUT,\n  ON,\n  IN\n};\n\nint contains(const Polygon &Q, const Point &p)\n{\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++)\n  {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag())\n      swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0)\n      in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0)\n      return ON;\n  }\n  return in ? IN : OUT;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\n// 線分の重複除去\nvoid merge_segments(vector<Segment> &segs)\n{\n  auto merge_if_able = [](Segment &s1, const Segment &s2) {\n    if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS)\n      return false;\n    if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1)\n      return false;\n    if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2)\n      return false;\n    s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n    return true;\n  };\n\n  for (int i = 0; i < segs.size(); i++)\n  {\n    if (segs[i].b < segs[i].a)\n      swap(segs[i].a, segs[i].b);\n  }\n  for (int i = 0; i < segs.size(); i++)\n  {\n    for (int j = i + 1; j < segs.size(); j++)\n    {\n      if (merge_if_able(segs[i], segs[j]))\n      {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\n// 線分アレンジメント\n// 任意の2線分の交点を頂点としたグラフを構築する\nvector<vector<int>> segment_arrangement(vector<Segment> &segs, vector<Point> &ps)\n{\n  vector<vector<int>> g;\n  int N = (int)segs.size();\n  for (int i = 0; i < N; i++)\n  {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for (int j = i + 1; j < N; j++)\n    {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if (cross(p1, p2) == 0)\n        continue;\n      if (intersect(segs[i], segs[j]))\n      {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int)ps.size();\n  g.resize(M);\n  for (int i = 0; i < N; i++)\n  {\n    vector<int> vec;\n    for (int j = 0; j < M; j++)\n    {\n      if (intersect(segs[i], ps[j]))\n      {\n        vec.emplace_back(j);\n      }\n    }\n    for (int j = 1; j < vec.size(); j++)\n    {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C\n// 凸多角形の切断\n// 直線 l.a-l.b で切断しその左側にできる凸多角形を返す\nPolygon convex_cut(const Polygon &U, Line l)\n{\n  Polygon ret;\n  for (int i = 0; i < U.size(); i++)\n  {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1)\n      ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0)\n    {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A\n// 多角形の面積\nReal area(const Polygon &p)\n{\n  Real A = 0;\n  for (int i = 0; i < p.size(); ++i)\n  {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A * 0.5;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_H\n// 円と多角形の共通部分の面積\nReal area(const Polygon &p, const Circle &c)\n{\n  if (p.size() < 3)\n    return 0.0;\n  function<Real(Circle, Point, Point)> cross_area = [&](const Circle &c, const Point &a, const Point &b) {\n    Point va = c.p - a, vb = c.p - b;\n    Real f = cross(va, vb), ret = 0.0;\n    if (eq(f, 0.0))\n      return ret;\n    if (max(abs(va), abs(vb)) < c.r + EPS)\n      return f;\n    if (distance(Segment(a, b), c.p) > c.r - EPS)\n      return c.r * c.r * arg(vb * conj(va));\n    auto u = crosspoint(c, Segment(a, b));\n    vector<Point> tot{a, u.first, u.second, b};\n    for (int i = 0; i + 1 < tot.size(); i++)\n    {\n      ret += cross_area(c, tot[i], tot[i + 1]);\n    }\n    return ret;\n  };\n  Real A = 0;\n  for (int i = 0; i < p.size(); i++)\n  {\n    A += cross_area(c, p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B\n// 凸多角形の直径(最遠頂点対間距離)\nReal convex_diameter(const Polygon &p)\n{\n  int N = (int)p.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < N; i++)\n  {\n    if (p[i].imag() > p[is].imag())\n      is = i;\n    if (p[i].imag() < p[js].imag())\n      js = i;\n  }\n  Real maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do\n  {\n    if (cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0)\n    {\n      j = (j + 1) % N;\n    }\n    else\n    {\n      i = (i + 1) % N;\n    }\n    if (norm(p[i] - p[j]) > maxdis)\n    {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxdis);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\n// 最近点対\nReal closest_pair(Points ps)\n{\n  if (ps.size() <= 1)\n    throw(0);\n  sort(begin(ps), end(ps));\n\n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n  vector<Point> beet(ps.size());\n  const Real INF = 1e18;\n\n  function<Real(int, int)> rec = [&](int left, int right) {\n    if (right - left <= 1)\n      return INF;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    int ptr = 0;\n    for (int i = left; i < right; i++)\n    {\n      if (abs(real(ps[i]) - x) >= ret)\n        continue;\n      for (int j = 0; j < ptr; j++)\n      {\n        auto luz = ps[i] - beet[ptr - j - 1];\n        if (imag(luz) >= ret)\n          break;\n        ret = min(ret, abs(luz));\n      }\n      beet[ptr++] = ps[i];\n    }\n    return ret;\n  };\n  return rec(0, (int)ps.size());\n}\n\nvoid solve()\n{\n  int n;\n  cin >> n;\n  if (n == 0)\n    exit(0);\n  vector<Point> v(n);\n  rep(i, n) cin >> v[i];\n  int Max = 0;\n  rep(i, n) REP(j, i + 1, n)\n  {\n    Circle c1(v[i], 1.0), c2(v[j], 1.0);\n    int isct = intersect(c1, c2);\n    assert(isct != 1);\n    if (isct == 0)\n      continue;\n    Point p1, p2;\n    tie(p1, p2) = crosspoint(c1, c2);\n    int cnt = 0;\n    rep(t, n)\n    {\n      if (distance(v[t], p1) < 1.0 + EPS)\n        cnt++;\n    }\n    chmax(Max, cnt);\n    cnt = 0;\n    rep(t, n)\n    {\n      if (distance(v[t], p2) < 1.0 + EPS)\n        cnt++;\n    }\n    chmax(Max, cnt);\n  }\n  if (Max == 0)\n    Max = 1;\n  cout << Max << \"\\n\";\n}\n\nint main()\n{\n  init_main();\n\n  while (1)\n  {\n    solve();\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\nconst int INF = 10000000;\nint dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1};\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<double, double> P;\n\n/** Problem1132 : Circle and Point **/\nint main()\n{\n\tint N, ans;\n\tdouble X, Y;\n\tvector<P> points;\n\t\n\twhile (cin>>N, N) {\n\t\tans=0;\n\t\t\n\t\tpoints.clear();\n\t\trep(i, N) {\n\t\t\tcin >> X >> Y;\n\t\t\tpoints.push_back(P(X, Y));\n\t\t}\n\n\t\tfor (double x=0.0; x<=10.0; x+=0.01) {\n\t\t\tfor (double y=0.0; y<=10.0; y+=0.01) {\n\t\t\t\tint num=0;\n\t\t\t\tvector<P>::iterator it = points.begin();\n\t\t\t\tfor (; it!=points.end(); it++) {\n\t\t\t\t\tdouble d = (it->first-x)*(it->first-x) + (it->second-y)*(it->second-y);\n\t\t\t\t\tif (d<1) {\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ans<num)\n\t\t\t\t\tans = num;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <cmath>\nusing namespace std;\ntypedef complex<double> point;\n\npoint ins[310];\nint main(){\n    for(;;){\n        int N;\n        scanf(\"%d\",&N);\n        if(N==0) break;\n        double x,y;\n        for(int i=0;i<N;i++){\n            scanf(\"%lf%lf\",&x,&y);\n            ins[i]=point(x,y);\n        }\n        int ma=1;\n        for(int i=0;i<N;i++){\n            for(int j=i+1;j<N;j++){\n                double no=norm(ins[i]-ins[j]);\n                if(no<4){\n                    double di=sqrt(1-no/4);\n                    point hen=(ins[i]-ins[j])*point(cos(M_PI/2),sin(M_PI/2))*(di/sqrt(norm(ins[i]-ins[j])));\n                    point cen[2];\n                    cen[0]=(ins[i]+ins[j])/2.0+hen;\n                    cen[1]=(ins[i]+ins[j])/2.0-hen;\n                    for(int k=0;k<2;k++){\n                        int cnt=2;\n                        for(int l=0;l<N;l++){\n                            if(l==i || l==j) continue;\n                            if(norm(cen[k]-ins[l])<1) cnt++;\n                        }\n                        ma=max(ma,cnt);\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\",ma);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-6;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        vector<long double> xs(n),ys(n);\n        rep(i,0,n) cin >> xs[i] >> ys[i];\n\n        auto count=[&](const long double x,const long double y){\n            int res=0;\n            rep(i,0,n) if((xs[i]-x)*(xs[i]-x)+(ys[i]-y)*(ys[i]-y)<=1+eps) ++res;\n            return res;\n        };\n\n        int ans=0;\n        rep(i,0,401){\n            const long double y=10.*i/400;\n            rep(j,0,n){\n                const long double tmp=1-(ys[j]-y)*(ys[j]-y);\n                if(tmp<0) continue;\n                const long double x1=xs[j]-sqrtl(tmp),x2=xs[j]+sqrt(tmp);\n                ans=max({ans,count(x1,y),count(x2,y)});\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n\nusing namespace std;\n\nint n;\ndouble x[300];\ndouble y[300];\n\ndouble dist(double x1, double y1, double x2, double y2) {\n    double dx = abs(x1 - x2);\n    double dy = abs(y1 - y2);\n    return sqrt(dx * dx + dy * dy);\n}\n\nint count(double cx, double cy, int i, int j) {\n    int ans = 0;\n    for (int k = 0; k < n; ++k) {\n        if (k == i || k == j || dist(cx, cy, x[k], y[k]) < 1) ans++;\n    }\n    return ans;\n}\n\nvoid solve() {\n    for (int i = 0; i < n; ++i) {\n        cin >> x[i] >> y[i];\n    }\n\n    int ans = 1;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (i == j) continue;\n            double d = dist(x[i], y[i], x[j], y[j]);\n            if (d > 2.) continue;\n            double dx = x[j] - x[i];\n            double dy = y[j] - y[i];\n            double r = sqrt(1 - (d * d / 4));\n            // cout << r << endl;\n            double cx = x[i] + dx / 2 - dy * r / d;\n            // cout << d << endl;\n            double cy = y[i] + dy / 2 + dx * r / d;\n            // cout << x[i] << \", \" << y[i] << \" - \" << x[j] << \", \" << y[j] << \" : \" << cx << \", \"<< cy << endl;\n            ans = max(ans, count(cx, cy, i, j));\n        }\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    while (1) {\n        cin >> n;\n        if (n == 0) break;\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\n\n/* 幾何の基本 */\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n// -1 => out\n//  0 => on\n//  1 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nPolygon convex_cut(const Polygon &ps, Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n\t\t\tQ.push_back(is_ll(l, m));\n\t}\n\treturn Q;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\nvector<Point>ps;\n\nint check(Point& center) {\n\tint num = 0;\n\tfor (int i = 0; i < ps.size(); ++i) {\n\t\tif (abs(ps[i] - center) <= 1) {\n\t\t\tnum++;\n\t\t}\n\t}\n\treturn num;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\n\t\tps.clear();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tlong double x, y; cin >> x >> y;\n\t\t\tps.push_back({ x,y });\n\t\t}\t\t\n\t\tif (N == 1) {\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tif (abs(ps[i] - ps[j]) > 2)continue;\n\t\t\t\tLine l(ps[i], ps[j]);\n\t\t\t\tPoint center = (ps[i] + ps[j])*0.5l;\n\t\t\t\tPoint vec(imag(ps[i] - ps[j]), -real(ps[i] - ps[j]));\n\t\t\t\tlong double nl = sqrt(0.9999999 - norm(center - ps[i]));\n\t\t\t\tlong double oldl = abs(vec);\n\t\t\t\tvec *=nl / oldl;\n\t\t\t\tPoint checkcenter = center + vec;\n\t\t\t\tans = max(ans,check(checkcenter));\n\t\t\t\tcheckcenter = center - vec;\n\t\t\t\tans = max(ans, check(checkcenter));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-4;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        vector<long double> xs(n),ys(n);\n        rep(i,0,n) cin >> xs[i] >> ys[i];\n\n        auto count=[&](const long double x,const long double y){\n            int res=0;\n            rep(i,0,n) if((xs[i]-x)*(xs[i]-x)+(ys[i]-y)*(ys[i]-y)<=1+eps) ++res;\n            return res;\n        };\n\n        int ans=0;\n        rep(i,0,2001){\n            const long double y=10.*i/2000;\n            rep(j,0,n){\n                const long double tmp=1-(ys[j]-y)*(ys[j]-y);\n                if(tmp<0) continue;\n                const long double x1=xs[j]-sqrtl(tmp),x2=xs[j]+sqrt(tmp);\n                ans=max({ans,count(x1,y),count(x2,y)});\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> coor;\n\n#define EPS 1e-5\n\ndouble in_cir(coor o, coor x)\n{\n  return abs(x - o);\n}\n\nint search(vector<coor> P)\n{\n  int mx = 0;\n  /*for (int i = 0; i < P.size(); i++) {\n    printf(\"%lf, %lf\\n\", P[i].real(), P[i].imag());\n    }*/\n  for (int i = 0; i < P.size(); i++) {\n    for (int j = i + 1; j < P.size(); j++) {\n      for (int k = 0; k < 2; k++) {\n\tif (abs(P[i] - P[j]) > 2) {continue;}\n\tcoor d = coor(P[i].imag() - P[j].imag(),\n\t\t      -(P[i].real() - P[j].real()));\n\tif (k == 1) {d = -d;}\n\td /= abs(d);\n\td *= sqrt(1 - norm(P[i] - P[j]) / 4);\n\t//printf(\"abs(d) = %lf\\n\", abs(d));\n\td += (P[i] + P[j]) / 2.0;\n\t//printf(\"%lf, %lf\\n\", d.real(), d.imag());\n\tint ctr = 2;\n\tfor (int l = 0; l < P.size(); l++) {\n\t  //printf(\"%lf\\n\", in_cir(d, P[l]));\n\t  if (l == i || l == j) {continue;}\n\t  if (in_cir(d, P[l]) < 1) {\n\t    ctr++;\n\t  }\n\t}\n\t//printf(\"_%d\\n\", ctr);\n\tmx = max(ctr, mx);\n\t\n      }\n    }\n  }\n  return mx;\n}\n\nint main()\n{\n  int N;\n  while (scanf(\"%d \", &N) == 1) {\n    if (N == 0) {\n      break;\n    }\n    vector<coor> P(N);\n    for (int i = 0; i < N; i++) {\n      double x, y;\n      scanf(\"%lf %lf \", &x, &y);\n      P[i] = coor(x, y);\n    }\n    printf(\"%d\\n\", search(P));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct P{\n  double x, y;\n  bool operator<(const P& r) const{\n\treturn x < r.x || (x == r.x && y < r.y);\n  }\n};\nint N;\nP point[310];\n\ndouble dist(P& cir, int i){\n  return (cir.x - point[i].x)*(cir.x - point[i].x)\n\t+ (cir.y - point[i].y)*(cir.y - point[i].y);\n}\n\nint cnt(P& c){\n  int res = 0;\n  for(int i=0;i<N;++i)\n\tif(dist(c, i) <= 1.0)\n\t  ++res;\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(true){\n\tcin >> N; if(N == 0) break;\n\tREP(i,N) cin >> point[i].x >> point[i].y;\n\tsort(point, point+N);\n\n\tint ans = 0;\n\tP c;\n\tfor(int i1=0;i1<N;++i1){\n\t  for(int i2=i1+1;i2<N;++i2){\n\t\tfor(int j1=0;j1<N;++j1){\n\t\t  for(int j2=j1+1;j2<N;++j2){\n\t\t\tc.x = (point[i1].x + point[i2].x) / 2.0;\n\t\t\tc.y = (point[j1].y + point[j2].y) / 2.0;\n\t\t\tans = max(ans, cnt(c));\n\t\t  }\n\t\t}\n\t  }\n\t}\n\t\n\tcout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n)       rep2(i, 0, n)\n#define rep2(i, m, n)   for(int i = m; i < (int)(n); ++i)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> Pt;\n\nconst double EPS = 1e-6;\n\nint main()\n{\n    int n;\n    while (cin >> n, n) {\n        double x, y;\n        vector<Pt> p;\n        rep (i, n) {\n            cin >> x >> y;\n            p.push_back(Pt(x, y));\n        }\n        \n        int ans = 1;\n        rep (i, n) rep2 (j, i + 1, n) {\n            double d = abs(p[i] - p[j]);\n            if (d > 2.0 + EPS) continue;\n            \n            Pt m = (p[i] + p[j]) / 2.0;\n            Pt v = Pt(p[i].Y - p[j].Y, p[j].X - p[i].X);\n            v /= abs(v);\n            v *= sqrt(1.0 - abs(p[i] - p[j]) / 2.0);\n            \n            int t1 = 0, t2 = 0;\n            Pt c1 = m + v, c2 = m - v;\n            rep (k, n) {\n                if (abs(p[k] - c1) < 1.0 + EPS) ++t1;\n                if (abs(p[k] - c2) < 1.0 + EPS) ++t2;\n            }\n            ans = max(max(t1, t2), ans);\n        }\n        \n        cout << ans << endl;        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst long double eps=1e-3;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        vector<long double> xs(n),ys(n);\n        rep(i,0,n) cin >> xs[i] >> ys[i];\n\n        auto count=[&](const long double x,const long double y){\n            int res=0;\n            rep(i,0,n) if((xs[i]-x)*(xs[i]-x)+(ys[i]-y)*(ys[i]-y)<=1+eps) ++res;\n            return res;\n        };\n\n        int ans=0;\n        rep(i,0,3001){\n            const long double y=10.*i/3000;\n            rep(j,0,n){\n                const long double tmp=1-(ys[j]-y)*(ys[j]-y);\n                if(tmp<0) continue;\n                const long double x1=xs[j]-sqrtl(tmp),x2=xs[j]+sqrt(tmp);\n                ans=max({ans,count(x1,y),count(x2,y)});\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-10;\n\nstruct Circle{\n  P c;\n  double r;\n  Circle(P c=P(0,0),double r=0):c(c),r(r){}\n};\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1=c1.r,r2=c2.r,d;\n  P p1=c1.c,p2=c2.c;\n  d=abs(p1-p2);\n  if(d<EPS&&abs(r1-r2)<EPS) return res;\n  if(r1+r2<d-EPS||d+EPS<abs(r1-r2)) return res; \n  double a=(r1*r1-r2*r2+d*d)/(2*d);\n  double h=sqrt(max(r1*r1-a*a,0.0));\n  P tmp1=p1+a/d*(p2-p1);\n  P tmp2=h/d*(p2-p1);\n  if(abs(tmp2)<EPS)res.push_back(tmp1);\n  else{\n    res.push_back(P(real(tmp1)-imag(tmp2),imag(tmp1)+real(tmp2)));\n    res.push_back(P(real(tmp1)+imag(tmp2),imag(tmp1)-real(tmp2)));\n  }\n  return res;\n}\n\ndouble getdistancepp(P a,P b){\n  return sqrt((a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag()));\n}\n\nint main(){\n  int n,ans=0;\n  double a,b;\n  P p[N];\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>a>>b;\n      p[i]=P(a,b);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tCircle c1,c2;\n\tc1.c=p[i];\n\tc2.c=p[j];\n\tc1.r=c2.r=1;\n\tvector<P> r=getIntersectCC(c1,c2);\n\tif(!r.size())continue;\n\tfor(int k=0;k<r.size();k++){\n\t  int cnt=0;\n\t  for(int l=0;l<n;l++)\n\t    if(getdistancepp(r[k],p[l])<=1+EPS)cnt++;\t    \n\t  ans=max(ans,cnt);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\ntypedef long double ld;\n\nstruct Point {\n    ld x, y;\n    Point(ld x, ld y) : x(x), y(y) {}\n    string to_s() {\n        ostringstream os;\n        os << x << ',' << y;\n        return os.str();\n    }\n    Point operator+(const Point& o) const {\n        return Point(x+o.x, y+o.y);\n    }\n    Point operator/(const int d) const {\n        return Point(x/d, y/d);\n    }\n};\n\nstruct Circle {\n    ld x, y;\n    ld r;\n    Circle(ld x=0, ld y=0, ld r=1) : x(x), y(y), r(r) {}\n    const static ld eps = 1e-10;\n    bool isIntersect(const Circle& o) const {\n        ld dx = o.x - x;\n        ld dy = o.y - y;\n        return (r + o.r) * (r + o.r) > (dx*dx + dy*dy);\n    }\n    pair<Point, Point> intersectionPoint(const Circle& o) const {\n        //cout << x << ',' << y << \" and \" << o.x << ',' << o.y << endl;\n        ld dx = o.x - x;\n        ld dy = o.y - y;\n        //cout << \"dx: \" << dx << \" dy: \" << dy << endl;\n        ld d = sqrt(dx*dx + dy*dy);\n        //cout << \"d: \" << d << endl;\n\n        ld slope;\n        ld theta;\n        if (dx < eps) {\n            if (y < o.y) {\n                theta = M_PI / 2;\n            } else {\n                theta = - M_PI / 2;\n            }\n        } else {\n            slope = dy / dx;\n            theta = atan(slope);\n        }\n        //cout << \"theta: \" << theta << endl;\n        ld theta_p = acos((r*r - o.r*o.r + d*d) / (2*r*d));\n        //cout << \"theta_p: \" << theta_p << endl;\n\n        return make_pair(\n                Point(x + r*cos(theta - theta_p), y + r*sin(theta - theta_p)),\n                Point(x + r*cos(theta + theta_p), y + r*sin(theta + theta_p)));\n    }\n    bool contains(ld px, ld py) const {\n        return r * r + eps > (px - x) * (px - x) + (py - y) * (py - y);\n    }\n    string to_s() {\n        ostringstream os;\n        os << x << ',' << y << ':' << r << endl;\n        return os.str();\n    }\n};\n\nint countContainingPoints(const Circle& c, const vector<Circle>& ps) {\n    int cnt = 0;\n    for (int i = 0; i < ps.size(); i++) \n        if (c.contains(ps[i].x, ps[i].y)) \n            cnt++;\n    return cnt;\n}\n\nPoint midPoint(pair<Point, Point>& pp) {\n    return (pp.first + pp.second) / 2;\n}\n\nint N;\nint main() {\n    vector<Circle> cs;\n    while (cin >> N, N) {\n        cs.clear(); cs.resize(N);\n        for (int i = 0; i < N; i++) cin >> cs[i].x >> cs[i].y;\n\n        vector<Point> ips; // Intersection PointS\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (i == j) continue;\n                if (!cs[i].isIntersect(cs[j])) continue;\n                pair<Point, Point> ip = cs[i].intersectionPoint(cs[j]);\n                ips.push_back(ip.first);\n                ips.push_back(ip.second);\n                //ips.push_back(midPoint(ip));\n            }\n        }\n\n        int maxPoint = 0;\n        for (int i = 0; i < ips.size(); i++) {\n            maxPoint = max(maxPoint, countContainingPoints(Circle(ips[i].x, ips[i].y, 1), cs));\n        }\n        cout << maxPoint << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>/*{{{*/\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\nstatic const double PI (3.14159265358979323846);\nstatic const double EPS (1e-10);\n\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n#define FOR(i, b, e) for (typeof(b) i = (b); assert((i) <= (e)), i != (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((ll)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define DEBUG_ON_\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) fprintf(stderr, fmt, __VA_ARGS__)\n\t#define darr(a) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#else\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n#endif\n/*}}}*/\n\nint N;\nvector<P> points;\n\nP middle_point(P a, P b)\n{\n\treturn a + (b-a) / 2.0;\n}\n\n// 点pを中心としてr(radian)回転 p(0,0)で原点を中心として回転\nP rotate(P t, P p ,double r){\n\t// double r=radians(angle);\n\treturn (t - p) * P(cos(r), sin(r)) + p;\n}\n\n// 2円 |x-a|=raと|x-b|=rbの交点計算\nbool intersection_c_c(P a, double ra, P b, double rb, P ans[]){\n\tdouble di = abs(a-b);\n\tif(di > ra+rb || di < abs(ra-rb)) return false;\n\tdouble t=(ra*ra - rb*rb + di*di) / (di+di);\n\tdouble rd = acos(t/ra);\n\n\tP dv = (b-a) / abs(b-a);\n\tP g1 = rotate(dv, P(0,0), rd);\n\tP g2 = rotate(dv, P(0,0), -rd);\n\tans[0] = a + g1*ra;\n\tans[1] = a + g2*ra;\n\treturn true;\n}\n\nint main(int argc, char const* argv[])\n{\n\twhile (cin >> N, N) {\n\t\tint ans = 1;\n\t\tpoints.clear();\n\t\tREP(i, N) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoints.PB(P(x, y));\n\t\t}\n\t\tREP(i, N) {\n\t\t\tFOR(j, i+1, N) {\n\t\t\t\tP p1 = points[i], p2 = points[j];\n\t\t\t\tdprt(\"(%lf, %lf) and (%lf, %lf)\\n\", p1.real(), p1.imag(), p2.real(), p2.imag());\n\t\t\t\tP centers[2];\n\t\t\t\tif (intersection_c_c(p1, 1, p2, 1, centers)) {\n\t\t\t\t\tREP(k, 2) {\n\t\t\t\t\t\tdprt(\" center: (%lf, %lf)\\n\", centers[k].real(), centers[k].imag());\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\tREP(l, N) {\n\t\t\t\t\t\t\tif (abs(centers[k] - points[l]) < 1.0 + EPS) {\n\t\t\t\t\t\t\t\t++cnt;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans = max(ans, cnt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n#include <complex>\ntypedef complex<double> Point;\nconst double EPS = 1e-8;\n\n// テ・ツ?・テ・ツ環崚」ツつケテ」ツδ暗」ツδェテ」ツδシテ」ツδ?」ツ?凝」ツつ嘉・ツョツ淌ヲツ閉ーテ、ツコツ古」ツ?、テ」ツつ津」ツ?ィテ」ツ?」テ」ツ?ヲ Point テ」ツ?ク\nistream& operator >> ( istream &s, Point &a )\n{\n\tdouble r, i;\n\ts >> r >> i;\n\ta = Point( r, i );\n\treturn s;\n}\n\n// テ・ツ債佚、ツスツ催」ツδ凖」ツつッテ」ツδ暗」ツδォ\nPoint unitVector( const Point &a )\n{\n\treturn a / abs( a );\n}\n\n// テヲツウツ陛ァツキツ堙」ツδ凖」ツつッテ」ツδ暗」ツδォ\nPoint normalVector1( const Point &a )\n{\n\treturn a * Point( 0, 1 );\n}\nPoint normalVector2( const Point &a )\n{\n\treturn a * Point( 0, -1 );\n}\nPoint ( *normalVectors[] )( const Point& ) = { normalVector1, normalVector2 };\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int n; cin >> n, n; )\n\t{\n\t\tvector<Point> ps( n );\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tcin >> ps[i];\n\t\t}\n\n\t\tint res = 0;\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tREP( j, 0, i )\n\t\t\t{\n\t\t\t\tconst Point &a = ps[i], &b = ps[j];\n\t\t\t\tREP( k, 0, 2 )\n\t\t\t\t{\n\t\t\t\t\tconst Point c = ( a + b ) / Point( 2, 0 ) + unitVector( normalVectors[k]( a - b ) ) * sqrt( 1 - pow( abs( a - b ) / 2., 2. ) );\n\n\t\t\t\t\tint tmp = 2;\n\t\t\t\t\tREP( l, 0, n )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( l == i || l == j )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttmp += abs( c - ps[l] ) <= 1 + EPS;\n\t\t\t\t\t}\n\t\t\t\t\tres = max( res, tmp );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#define EPS 1.0e-10\nusing namespace std;\ntypedef double elem;\ntypedef complex<elem> point,vec;\ninline elem dist(const point &a, const point &b){return abs(a-b);}\ninline vec normr(const vec &v){return v*vec(0,-1);}\ninline vec norml(const vec &v){return v*vec(0,1);}\ninline vec unormr(const vec &v){return normr(v) / abs(v);}\ninline vec unorml(const vec &v){return norml(v) / abs(v);}\nint main(){\n\twhile(true){\n\t\tint ans = 1;\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tvector< point > points;\n\t\tfor(int i=0;i<n;++i){\n\t\t\telem x, y;\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tpoints.push_back( point(x,y) );\n\t\t}\n\t\tfor(unsigned int i = 0; i < points.size(); ++i){\n\t\t\tfor(unsigned int j = i + 1; j < points.size(); ++j){\n\t\t\t\tif( dist( points[i], points[j] ) <= 2 ){\n\t\t\t\t\tint count_p = 0;\n\t\t\t\t\tint count_q = 0;\n\t\t\t\t\telem d = (elem)sqrt( 1.0 - pow( dist(points[i], points[j]) / 2.0, 2.0 ) );\n\t\t\t\t\tpoint p,q;\n\t\t\t\t\tvec ab = points[j] - points[i];\n\t\t\t\t\tpoint t = 0.5 * ab + points[i];  \n\t\t\t\t\tp = d * unormr(ab) + t;\n\t\t\t\t\tq = d * unorml(ab) + t;\n\t\t\t\t\t//cout << i << \",\" << j << endl;\n\t\t\t\t\tfor(unsigned int k = 0; k < points.size(); ++k){\n\t\t\t\t\t\t//cout << dist(p,points[k]) << \" \" << dist(q,points[k]) << endl;\n\n\t\t\t\t\t\tif( dist(p, points[k]) <= 1+EPS ){ count_p++; }\n\t\t\t\t\t\tif( dist(q, points[k]) <= 1+EPS ){ count_q++; }\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans, max(count_q, count_p) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-8\ntypedef complex<double> Point;\n\nint main(){\n  int N;\n  while(cin >> N,N){\n    Point p[N];\n    for(int i = 0 ; i < N ; i++){\n      cin >> p[i].real() >> p[i].imag();\n    }\n    int res = 1;\n    for(int i = 0 ; i < N-1 ; i++){\n      for(int j = i+1 ; j < N ; j++){\n        Point np = p[j]-p[i];\n        double d = abs(np);\n        if(d + EPS > 2.0){ continue; }\n        np /= d;\n        np *= Point(0,1);\n        Point cp = (p[i]+p[j])/2.0;\n        Point v = sqrt(1.0-d*d/4.0)*np;\n        for(int k = 0 ; k < 2 ; k++){\n          int cnt = 2;\n          np *= (-1);\n          Point center = cp + v;\n          for(int l = 0 ; l < N ; l++){\n            if(i == l || j == l) continue;\n            Point diff = center-p[l];\n            if(norm(diff) < 1.0 + EPS){\n              cnt++;\n            }\n          }\n          res = max(res,cnt);\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\nint main() {\n  const complex<double> I(0,1);\n  complex<double> d2(2,0);\n  for(int tci = 0; ; tci++) {\n    int n; scanf(\"%d\", &n);\n    if(!n) break;\n    complex<double> *pts = new complex<double>[n];\n    for(int i = 0; i < n; i++) {\n      scanf(\"%lf%lf\", &pts[i].real(), &pts[i].imag());\n    }\n    int maxcnt = 1;\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n        if(i==j) continue;\n        complex<double> d = (pts[i] - pts[j]) / d2;\n        double absd = abs(d);\n        complex<double> k = d*I/absd * sqrt(1-absd*absd);\n        complex<double> c = (pts[i] + pts[j]) / d2 + k;\n        int cnt = 0;\n        for(int k = 0; k < n; k++) {\n          cnt += (abs(pts[k]-c) <= 1 + 1e-9);\n        }\n        maxcnt = max(maxcnt, cnt);\n      }\n    }\n    delete[] pts;\n    printf(\"%d\\n\", maxcnt);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\nstruct Point{double x,y;};\ndouble dist(Point a,Point b) {return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));}\n#define eps 0.0001\n\nint main(void){\n    int N;\n    while(cin>>N,N){\n        vector<Point> p(N);\n        int maxcnt=0;\n        rep(i,N)cin>>p[i].x>>p[i].y;\n        rep(i,N){\n            for(int j=i+1;j<N;j++){\n                double d = dist(p[i],p[j]);\n                if(d>2.0)continue;\n                Point C1,C2;\n                C1.x = p[i].x + cos(atan2(p[j].y-p[i].y,p[j].x-p[i].x) + acos(d/2.0));\n                C1.y = p[i].y + sin(atan2(p[j].y-p[i].y,p[j].x-p[i].x) + acos(d/2.0));\n                C2.x = p[i].x + cos(atan2(p[j].y-p[i].y,p[j].x-p[i].x) - acos(d/2.0));\n                C2.y = p[i].y + sin(atan2(p[j].y-p[i].y,p[j].x-p[i].x) - acos(d/2.0));\n                int cnt=0;\n                rep(k,N){\n                    if(pow(C1.x-p[k].x,2) + pow(C1.y-p[k].y,2) <= 1.0+eps)cnt++;\n                }\n                if(maxcnt<cnt)maxcnt=cnt;\n                cnt=0;\n                rep(k,N){\n                    if(pow(C2.x-p[k].x,2) + pow(C2.y-p[k].y,2) <= 1.0+eps)cnt++;\n                }\n                if(maxcnt<cnt)maxcnt=cnt;\n            }\n        }\n        cout<<maxcnt<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-3;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        vector<long double> xs(n),ys(n);\n        rep(i,0,n) cin >> xs[i] >> ys[i];\n\n        auto count=[&](const long double x,const long double y){\n            int res=0;\n            rep(i,0,n) if((xs[i]-x)*(xs[i]-x)+(ys[i]-y)*(ys[i]-y)<=1+eps) ++res;\n            return res;\n        };\n\n        int ans=0;\n        rep(i,0,401){\n            const long double y=10.*i/400;\n            rep(j,0,n){\n                const long double tmp=1-(ys[j]-y)*(ys[j]-y);\n                if(tmp<0) continue;\n                const long double x1=xs[j]-sqrtl(tmp),x2=xs[j]+sqrt(tmp);\n                ans=max({ans,count(x1,y),count(x2,y)});\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>  \n#include<cstdlib>  \n#include<cstring>  \n#include<cmath>  \n#include<algorithm>  \n#define eps 1e-8  \nusing namespace std;  \nstruct point{  \n    double x,y;  \n}A[310];  \ndouble dist(point a,point b){  \n    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));  \n}  \nvoid getmid(point p1,point p2,point &center){//????????????????????????????????????  \n    point mid;  \n    mid.x=(p1.x+p2.x)/2.0;mid.y=(p1.y+p2.y)/2.0;  \n    double angle=atan2(p1.x-p2.x,p2.y-p1.y);  \n    double dcm=sqrt(1-dist(p1,mid)*dist(p1,mid));  \n    center.x=mid.x+dcm*cos(angle);center.y=mid.y+dcm*sin(angle);  \n}  \nint main()  \n{  \n    int n,i,j,k;  \n    while(scanf(\"%d\",&n),n){  \n        for(i=0;i<n;++i){  \n            scanf(\"%lf%lf\",&A[i].x,&A[i].y);  \n        }  \n        int ans=1;  \n        for(i=0;i<n;++i){  \n            for(j=i+1;j<n;++j){  \n                if(dist(A[i],A[j])>2.0)continue;  \n                point center;  \n                getmid(A[i],A[j],center);  \n                int cnt=0;  \n                for(k=0;k<n;++k){  \n                    if(dist(A[k],center)<1.0+eps)cnt++;  \n                }  \n                ans=max(ans,cnt);   \n            }  \n        }  \n        printf(\"%d\\n\",ans);  \n    }  \n    return 0;  \n} "
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n\ndouble ds(double x1,double y1,double x2,double y2){\n  return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\n\nint main(){\n  int n;\n  while(1){\n  cin>>n;\n  if(n==0)break;\n  double x[310],y[310];\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n  }\n\n  int ma=1;\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      double d=ds(x[i],y[i],x[j],y[j]);\n      if(d>2.0)continue;\n      double tx=(x[i]+x[j])/2;\n      double ty=(y[i]+y[j])/2;\n      double k=sqrt(1-(d/2.0)*(d/2.0));\n      double vx,vy,tvx,tvy;\n      vx=x[i]-tx;\n      vy=y[i]-ty; \n      tvx=-vy;\n      tvy=vx;\n      double l=sqrt(tvx*tvx+tvy*tvy);\n      tvx/=l;\n      tvy/=l;\n      int cnt=2;\n      // cout<<tvx<<\" \"<<tvy<<endl;\n      double ox,oy;\n      ox=tx+tvx*k;\n      oy=ty+tvy*k;\n      //cout<<ox<<\" \"<<oy<<endl;\n      for(int k=0;k<n;k++){\n\t   if(i==k||j==k)continue;\n\t   if(ds(ox,oy,x[k],y[k])<=1)cnt++;\n      }\n      ma=max(ma,cnt);\n      cnt=2;\n      ox=tx-tvx*k;\n      oy=ty-tvy*k;\n      //cout<<ox<<\" \"<<oy<<endl;\n      for(int k=0;k<n;k++){\n\t   if(i==k||j==k)continue;\n\tif(ds(ox,oy,x[k],y[k])<=1)cnt++;\n      }\n      ma=max(ma,cnt);\n    }\n  }\n  cout<<ma<<endl;\n}\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define REP(i,n) for(int i=0;i<n;i++)\nusing P = complex<double>;\nusing vp = vector<P>;\n\nvp points;\nvp cross;\n\nint main()\n{\n  int n;\n  while(cin >> n,n){\n    points.clear();\n    cross.clear();\n\n    REP(i,n){\n      double a,b;\n      cin >> a >> b;\n      points.push_back({a,b});\n\n    }\n    REP(i,n)REP(j,n){\n      auto dif = (points[i]-points[j]);\n      if(abs(dif) <= 2){\n        auto veci = dif/P(abs(dif),abs(dif));\n        cross.push_back(points[j]+dif/P(2,2)+veci*P(0,1));\n        cross.push_back(points[j]+dif/P(2.2)+veci*P(0,-1));\n      }\n    }\n\n    int ma = 0;\n    REP(i,cross.size()){\n      int now = 0;\n      REP(j,n){\n      if(abs(cross[i]-points[j]) <= 1){\n        now++;\n      }\n      ma = max(ma,now);\n      }\n    }\n    cout << ma << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double eps = 1e-5;\nconst int MAXN = 333;\nint N;\nP ps[MAXN];\n\nint calc(P c) {\n  int res = 0;\n  for(int i = 0; i < N; ++i) {\n    double d = abs(c - ps[i]);\n    if(d < 1+eps) ++res;\n  }\n  return res;\n}\n\nint main() {\n  for(; cin >> N && N; ) {\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    int res = 0;\n    for(int i = 0; i < N; ++i) {\n      for(int j = i+1; j < N; ++j) {\n        double d = abs(ps[i] - ps[j]);\n        P base = ps[i] - ps[j];\n        P m = ps[j] + base / 2.0;\n        P base2(-base.imag(), base.real());\n        double a = sqrt(1.0 - d * d / 4.0);\n        base2 = base2 / abs(base2) * a;\n        res = max(res, max(calc(m + base2), calc(m - base2)));\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n// ??????????????§?????????????????§???3????????????????????????????±?????????????????????¨?????????\n\ndouble pow2(double d){\n\treturn d * d;\n}\n\nstruct Vector2{\n\tdouble x;\n\tdouble y;\n};\n\nVector2 P[500];\n\nint main(){\n\tint n;\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> P[i].x >> P[i].y;\n\t\t}\n\t\tdouble k, L_2, a, b;\n\t\t\n\t\tint max = 0;\n\t\t\n\t\tfor(int num1 = 0; num1 < n; num1++){\n\t\t\tfor(int num2 = num1 + 1; num2 < n; num2++){\n\t\t\t\tL_2 = pow2(P[num1].x - P[num2].x) + pow2(P[num1].y - P[num2].y);\n\t\t\t\tif(L_2 > 4){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tk = sqrt((4 - L_2) / L_2);\n\t\t\t\t\n\t\t\t\ta = (k * (P[num1].y - P[num2].y) + P[num1].x + P[num2].x) / 2;\n\t\t\t\tb = (k * (P[num2].x - P[num1].x) + P[num1].y + P[num2].y) / 2;\n\t\t\t\t\n\t\t\t\tint count;\n\t\t\t\t\n\t\t\t\tcount = 0;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(i == num1 || i == num2){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(pow2(P[i].x - a) + pow2(P[i].y - b) <= 1){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(max < count){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ta = (k * (P[num2].y - P[num1].y) + P[num1].x + P[num2].x) / 2;\n\t\t\t\tb = (k * (P[num1].x - P[num2].x) + P[num1].y + P[num2].y) / 2;\n\t\t\t\t\n\t\t\t\tcount = 0;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(i == num1 || i == num2){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(pow2(P[i].x - a) + pow2(P[i].y - b) <= 1){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(max < count){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", max);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n//CCW??¨///////////////////////////////////\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n/////////////////////////////////////////\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\nstruct Circle{\n  Point c;\n  double r;\n};\ntypedef Point vect;\nstruct seg{Point p1,p2;};\n//????????´????????????\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\n//??¶???????????????absolute  ?????????????????¶?????????\ndouble abs(Point p){return sqrt(norm(p));}\n//?????????????????????????????????\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n//?????? ????????????????????????\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n//??´?????????????????¨?????\\?????????????????????\nbool C90(seg s1,seg s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//????????????????????¨?????\\??????????????????????????????????????????\nbool C0(seg s1,seg s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//?°???± ??????????????´???????????????\nPoint project(seg s,Point p){\n  Point base = s.p2-s.p1;\n  double r=dot(p-s.p1,base) / norm(base);\n  return s.p1+base*r;\n}\n//????°??????????????????????\nPoint reflection(seg s,Point p){\n  return  p+(project(s,p)-p)*2.0;\n}\n//2???????????¢   ???????????????\ndouble getDistancePP(Point a,Point b){\n  return abs(a-b);\n}\n//??´??????????????¢(????°?)???????????????\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n//?????????????????¢??????????????????\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n//????¨?????????????????¨??????????????????????????????????\nint CCW(Point p0,Point p1,Point p2){\n  Point a=p1-p0;\n  Point b=p2-p0;\n  if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS)return CLOCKWISE;\n  if(dot(a,b)<-EPS)return ONLINE_BACK;\n  if(norm(a)<norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n//????????????????????????????????????????????§?\\????\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return(CCW(p1,p2,p3)*CCW(p1,p2,p4)<=0&&CCW(p3,p4,p1)*CCW(p3,p4,p2)<=0);\n}\nbool intersect(seg s1,seg s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//2??????????§???¢?????\\??????????????????...????????????????????????\nbool squareintersect(seg s1,seg s2){\n  if(s1.p2.x<s2.p1.x||s2.p2.x<s1.p1.x)return 0;\n  if(s1.p2.y<s2.p1.y||s2.p2.y<s1.p1.y)return 0;\n  return 1;\n}\n//??????????????¢?????????????????????????????§??¨???????????????\ndouble getDistance(seg s1,seg s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n    min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n//??????????????????????????????(?´????????`)\nPoint getCrossPoint(seg s1,seg s2){\n  Point base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n//???????£????????????¢??????????????¢??????????????????????????\\????????????????????§???????????£???????????????????????????????????§?????????????????????\nint intersectCC(Circle a,Circle b){\n  double dist=abs(a.c-b.c);\n  if(dist>a.r+b.r+EPS)return 4;\n  if(dist>a.r+b.r-EPS)return 3;\n  if(dist>abs(a.r-b.r)+EPS)return 2;\n  if(dist>abs(a.r-b.r)-EPS)return 1;\n  return 0;\n}\n//?????¨??´???????????????2?????? (LINE)\nseg getCrossPoint(Circle c,seg l){\n  //assert(intersect(cc,l));\n  Point pr=project(l,c.c);\n  Point e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base =sqrt(c.r*c.r-norm(pr-c.c));\n  seg pp;pp.p1=(pr+e*base);pp.p2=(pr-e*base);\n  return pp;\n}\n//?????¨??´??????Line??????????????°\nint getCircleLine(Circle c,seg l){\n  seg a=getCrossPoint(c,l);\n  if(isnan(a.p1.x)&&isnan(a.p2.y))return 0;\n  else if(a.p1.x==a.p2.x&&a.p1.y==a.p2.y)return 1;\n  else return 2;\n}\n//??´?????¨????????\\???????????????\nbool intersectCirclesen(seg s,Circle t){\n  double a,b,c;\n  a=getDistancePP(s.p1,t.c);\n  b=getDistancePP(s.p2,t.c);\n  c=getDistanceSP(s,t.c);\n  if(a<t.r&&b>t.r)return 1;\n  if(b<t.r&&a>t.r)return 1;\n  if(a>=t.r&&b>=t.r&&c<=t.r)return 1;\n  return 0;\n}\n//??????\nPoint gaishin(Point a, Point b, Point c){\n  double a1,a2,b1,b2,c1,c2;\n  a1=2*(b.x-a.x);b1=2*(b.y-a.y);c1=a.x*a.x-b.x*b.x+a.y*a.y-b.y*b.y;\n  a2=2*(c.x-a.x);b2=2*(c.y-a.y);c2=a.x*a.x-c.x*c.x+a.y*a.y-c.y*c.y;\n  Point p;p.x=(b1*c2-b2*c1)/(a1*b2-a2*b1);p.y=(c1*a2-c2*a1)/(a1*b2-a2*b1);\n  return p;\n}\n//2??????????????????\ndouble arg(Point p){return atan2(p.y,p.x);}\nPoint polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\nseg getCrossPoints(Circle c1,Circle c2){\n  //assert(intersect(c1,c2));\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  seg s;s.p2=c1.c+polar(c1.r,t+a);s.p1=c1.c+polar(c1.r,t-a);\n  return s;\n}\n//???????????? ????????????->2 ??????->1  ????????\\???->0\ntypedef vector<Point> Polygon;\nint contains(Polygon g, Point p) {\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++) {\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n  }\n  return x ? 2 : 0;\n}\ndouble Area(Polygon p) {\n  double a=0;\n  for(int i=0;i<p.size();i++)a+=cross(p[i],p[(i+1)%p.size()]);\n  return a/2;\n}\n//???????§???¢??????\nbool isConvex(Polygon p){\n  for(int i=0;i<p.size();i++){\n    if(CCW(p[(i+1)%p.size()],p[i%p.size()],p[(i+2)%p.size()])==1)return false;\n  }\n  return true;\n}\n//?????¢???????????¢???(?????´)=ans\nPolygon convex_cut(Polygon p,seg l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(CCW(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(CCW(l.p1,l.p2,A)*CCW(l.p1,l.p2,B)<0){\n      seg s;s.p1=A;s.p2=B;\n      ans.push_back(getCrossPoint(l,s));\n    }\n  }\n  return ans;\n}\ndouble convex_diameter(Polygon p){\n  int n=p.size();\n  int i=0,j=0;\n  for(int k=0;k<n;k++){if(p[i]<p[k])i=k;if(p[k]<p[j])j=k;}\n  int si=i,sj=j;double ans=0.0;\n  while(i!=sj||j!=si){\n    ans=max(ans,abs(p[i]-p[j]));\n    if(cross((p[(i+1)%n]-p[i]),(p[(j+1)%n]-p[j]))<0)i=(i+1)%n;\n    else j=(j+1)%n;\n  }\n  return ans;\n}\n//?????? ??´??????????????????????????????????????¨?????????191,197?????????&&CCW(u[n-2],u[n-1],s[i])!=ONLINE_FRONT???????????????\nPolygon andrewScan(Polygon s) {\n  Polygon l, u;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<s.size();i++){\n    for(int n=u.size();n>=2&&CCW(u[n-2],u[n-1],s[i])!=-1&&CCW(u[n-2],u[n-1],s[i])!=ONLINE_FRONT;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&CCW(l[n-2],l[n-1],s[i])!=-1&&CCW(l[n-2],l[n-1],s[i])!=ONLINE_FRONT;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for( int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  return l;\n}\n//???a??¨???b??????d??¢??????2???\nseg identifyPoint(Point a,Point b,double d){\n  Circle c1,c2;\n  c1.c=a;c1.r=d;c2.c=b;c2.r=d;\n  return getCrossPoints(c1,c2);\n}\n//    ???????????°??¨??????\nseg scan(){seg a;scanf(\"%lf%lf%lf%lf\",&a.p1.x,&a.p1.y,&a.p2.x,&a.p2.y);return a;}\nvoid prin(seg a){printf(\"%.10f %.10f %.10f %.10f\\n\",a.p1.x,a.p1.y,a.p2.x,a.p2.y);}\n//\n/////------Library END-------//////////////////////////////////////\n//   exp?????????    //////a=x??§?¨????b=y??§?¨????c=?§?????????????d=????????????????????¢\n//    p[i][j].x=a-d*sin(M_PI/180*(72*j+c));\n//   p[i][j].y=b+d*cos(M_PI/180*(72*j+c));\n/////////////////////////////////////////////////\nint main(){\n  int n;\n  while(cin>>n,n){\n    Point p[n];int ans=1;\n    r(i,n)cin>>p[i].x>>p[i].y;\n    r(i,n)for(int j=i+1;j<n;j++){\n      if(getDistancePP(p[i],p[j])<=2.0){\n      seg s=identifyPoint(p[i],p[j],1);\n      int a1=0,a2=0;\n      Point p3,p4;p3=s.p1;p4=s.p2;\n      r(k,n)if(abs(getDistancePP(p3,p[k]))<=1.000001)a1++;\n      r(k,n)if(abs(getDistancePP(p4,p[k]))<=1.000001)a2++;\n      ans=max(ans,max(a1,a2));}\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\ntypedef complex<double> Point;\n\nint calc(Point p, vector<Point>& ps){\n    int ans = 0;\n    for(int i = 0; i < ps.size(); i++){\n        if(abs(ps[i] - p) < 1.0 + EPS) {\n            ans++;\n        }\n    }\n    return ans;\n}\nvector<Point> touching_circle(Point a, Point b, double r){\n    vector<Point> res;\n\n    double d = abs(b - a);\n    if(d > 2 * r) return res;\n\n    Point mid = 0.5 * (a + b);\n    Point dir = polar(sqrt(r * r - d * d / 4), arg(b - a) + M_PI / 2);\n    res.push_back(mid + dir);\n    res.push_back(mid - dir);\n    return res;\n}\nint main(){\n    int N;\n    while(cin >> N && N){\n        vector<Point> ps(N);\n        REP(i, N){\n            double x, y;\n            cin >> x >> y;\n            ps[i] = Point(x, y);\n        }\n        int ans = 0;\n        REP(i, N) REP(j, N) if(abs(ps[i] - ps[j]) > EPS) {\n            vector<Point> tp = touching_circle(ps[i], ps[j], 1.0);\n            for(Point c : tp){\n                ans = max(ans, calc(c, ps));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef complex<double> P;\nconst double EPS = 1e-8;\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    vector<P> v;\n    REP(i,n) {\n      double x,y;\n      cin >> x >> y;\n      v.push_back(P(x,y));\n    }\n    int ans = 0;\n    REP(i,n-1) {\n      for (int j=i+1;j<n;j++) {\n        P m = (v[i]+v[2])*P(0.5,0);\n        P a = v[i]-v[j];\n        double dis = abs(a);\n        if (1-dis*dis/4<0) continue;\n        double d = sqrt(1-dis*dis/4);\n        int hoge[]={1,-1};\n        REP(k,2) {\n          P un = (a * P(0, hoge[k])) / dis;\n          P o1 = m + un*d;\n          int sum = 0;\n          REP(l,n) {\n            if (norm(v[l]-o1)<1+EPS) sum++;\n          }\n          ans = max(ans,sum);\n        }\n      }\n    }\n    cout << ans << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\nvoid chmax(int &a,int b){\ta=max(a,b);\treturn;\t}\n\n#define EPS 1e-8\n#define EQ(x, y) (abs((x)-(y))<EPS)\n#define GE(x, y) ((x)>(y)||EQ(x, y))\n#define LE(x, y) ((x)<(y)||EQ(x, y))\n\ntypedef complex<double> point;//changed\ntypedef point vec;//changed\ntypedef array<point, 2> line;//changed\ntypedef vector<point> poly;//changed\n\nstruct circle {//changed\n\tpoint c;\n\tdouble r;\n};\n\nvector<point> CrosspointCC(circle c1, circle c2) {\n\tvector<point> ret;\n\tdouble d = abs(c1.c - c2.c);\n\tdouble rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n\tdouble dfr = c1.r*c1.r - rc*rc;\n\n\tif (EQ(dfr, 0.0)) dfr = 0.0;\n\telse if(dfr < 0.0) return ret;\n\n\tdouble rs = sqrt(dfr);\n\tvec sgn = (c2.c - c1.c) / d;\n\tret.emplace_back(c1.c + sgn*point(rc, rs));\n\tif (dfr > 0.0) ret.emplace_back(c1.c + sgn*point(rc, -rs));\n\treturn ret;\n}\n\n#define MAX_N 300\nint n;\npoint p[MAX_N];\n\nvoid solve(){\n\tint ans=1;\n\tfor(int i=0;i<n;++i) for(int j=i+1;j<n;++j){\n\t\tcircle c1=(circle){p[i],1.0},c2=(circle){p[j],1.0};\n\t\tvector<point> v=CrosspointCC(c1,c2);\n\t\tfor(int l=0;l<v.size();++l){\n\t\t\tpoint q=v[l];\n\t\t\tint b=2;\n\t\t\tfor(int k=0;k<n;++k) if(k!=i&&k!=j) if(abs(p[k]-q)<=1.0) ++b;\n\t\t\tchmax(ans,b);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\twhile(true){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tdouble a,b;\n\t\t\tscanf(\"%lf %lf\",&a,&b);\n\t\t\tp[i]=complex<double>(a,b);\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 300\n\ntypedef double P_type;\ntypedef complex<P_type> P;\nconst P_type P_eps = 1e-8; //整数の時はゼロ\n\nnamespace std{\n  template<class T> bool operator<(const complex<T> &a, const complex<T> &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n  }\n};\n\n/* 円の点包含判定 */\ndouble isContainedCP(P c, double r, P p){\n  //return abs(c-p) < r - P_eps; //円周上を含まない\n  return abs(c-p) < r + P_eps; //円周上を含む\n}\n\nint solve(){\n  int n;\n  double x[SIZE], y[SIZE];\n\n  scanf(\"%d\", &n);\n  if(n == 0) return false;\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%lf%lf\", x+i, y+i);\n  }\n\n  int ans = 1;\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i == j) continue;\n      P vec = P(x[i]-x[j], y[i]-y[j]);\n\n      if(abs(vec) > 2.0 + P_eps) continue;\n      \n      P p = P(-vec.imag(), vec.real());\n      p = p / abs(p) * sqrt(1 - norm(vec) / 4);\n      //debug(p);\n\n      p += vec / 2.0 + P(x[j], y[j]); \n\n      int counter = 0;\n      // debug(abs(p - P(x[i], y[i])));\n      \n      for(int k=0;k<n;k++){\n        counter += isContainedCP(p, 1, P(x[k], y[k]));\n      }\n\n      ans = max(ans, counter);\n    }\n  }\n\n  printf(\"%d\\n\", ans);\n  return true;\n}\n\n\nint main(){\n  while(solve());\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define EPS (1e-4)\ntypedef complex<double> P;\n\nint main() {\n  int n;\n  while (cin >> n, n) {\n    vector<P> a(n);\n    for (auto &e : a) {\n      double x, y;\n      cin >> x >> y;\n      e.real(x);\n      e.imag(y);\n    }\n    vector<P> o;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if (abs(a[j] - a[i]) < 2.0 + EPS) {\n          P u = (a[j] - a[i]) / 2.0;\n          P v = P(-u.imag(), u.real()) / abs(u) * sqrt(1.0 - pow(abs(u), 2));\n          o.push_back(a[i] + u + v);\n          o.push_back(a[i] + u - v);\n        }\n      }\n    }\n    int m = 0;\n    for (auto e : o) {\n      int t = 0;\n      for (int i = 0; i < n; i++) {\n        t += abs(a[i] - e) < 1.0 + EPS;\n      }\n      m = max(m, t);\n    }\n    cout << m << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <complex>\n#include <vector>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P, double> C;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nP n_vector(P a){\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nvector<P> cpcc(C a, C b){\n  double d = abs(a.first-b.first), ra = a.second, rb = b.second;\n  double t = (ra*ra-rb*rb+d*d)/2/d, h = sqrt(ra*ra-t*t);\n  P m = t/abs(b.first-a.first)*(b.first-a.first)+a.first;\n  vector<P> cp(2,m);\n  P n = n_vector(a.first-b.first);\n  cp[0] -= h*n;\n  cp[1] += h*n;\n  return cp;\n}\n\n\nint main(){\n  int N;\n  double x, y;\n  while(cin >> N, N){\n    P ps[N];\n    for(int i = 0; i < N; ++i){\n      cin >> x >> y;\n      ps[i] = P(x,y);\n    }\n    if(N == 1){\n      cout << 1 << endl;\n      continue;\n    }\n    vector<P> cps;\n    for(int i = 0; i < N; ++i){\n      for(int j = i+1; j < N; ++j){\n\tif(abs(ps[i]-ps[j]) <= 2 + EPS){\n\t  vector<P> cp = cpcc(C(ps[i],1),C(ps[j],1));\n\t  for(int k = 0; k < cp.size(); ++k)\n\t    cps.push_back(cp[k]);\n\t}\n      }\n    }\n    int n = cps.size(), ans = 0;;\n    for(int i = 0; i < n; ++i){\n      int cnt = 0;\n      for(int j = 0; j < N; ++j){\n\tif(norm(cps[i]-ps[j]) <= 1 + EPS)\n\t  ++cnt;\n      }\n      ans = max(ans, cnt);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,N) for(int i=0;i<(int)(N);i++)\n#define REP(i,k,N) for(int i=k;i<(int)(N);i++)\n\n#define vi vector<int>\n#define pb push_back\n\n#define pdd pair<double,double>\n#define fi first\n#define se second\nconst double  EPS = 1e-7;\n\ndouble dist(double x,double y){\n    return x*x+y*y;\n};\n\nint main(){\n//    ifstream in(\"d_in.txt\");\n//    cin.rdbuf(in.rdbuf());\n    int n;\n    while(cin >> n,n){\n        int ma = 1;\n        pdd p[330];\n        rep(i,n) cin >> p[i].fi >> p[i].se;\n        rep(i,n-1){\n            REP(j,i+1,n){\n\n                double x1,y1,x2,y2,x3,y3;\n                tie(x1,y1) = p[i];\n                tie(x2,y2) = p[j];\n                double cx1,cy1,cx2,cy2;\n                if(dist(x1-x2,y1-y2)  > 4+EPS  ) continue;\n\n                //はりまコーナー\n//                double ax,ay,bx1,by1,bx2,by2,mx,my,dx,dy;\n//                ax=x1-x2;ay=y1-y2;\n//                mx=(x1+x2)/2;my=(y1+y2)/2;\n//                by1 = (-0.5)*pow(ax,4)+pow(ax,2)+(-0.5)*pow(ax,2)*pow(ay,2)\n//                        /dist(ax,ay);\n//                by1 = sqrt(abs(by1));\n//                by2 = -1*by1;\n//                cy1= my+by1;\n//                cy2= my+by2;\n//                bx1= -1*(ay*by1)/ax;\n//                bx2= -1*(ay*by2)/ax;\n//                cx1=bx1+mx;\n//                cx2=bx2+mx;\n\n\n                //あじのりコーナー\n                double mx=(x1+x2)/2,my=(y1+y2)/2;\n\n                double ld = sqrt(1-dist((x1-x2),(y1-y2))/4);\n                double theta = atan((y2-y1)/(x2-x1));\n                cx1 = mx - sin(theta)*ld;\n                cy1 = my + cos(theta)*ld;\n                cx2 = mx + sin(theta)*ld;\n                cy2 = my - cos(theta)*ld;\n\n                int cnt1 = 0,cnt2=0;\n                for(int k = 0;k<n;k++) {\n                    tie(x3, y3) = p[k];\n                    if (EPS + 1> dist((cx1 - x3), (cy1 - y3))) cnt1++;\n                    if (EPS + 1> dist((cx2 - x3), (cy2 - y3))) cnt2++;\n                }\n                ma = max({cnt1,cnt2,ma});\n            }\n        }\n        cout<< ma << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\ntypedef pair<double, double> PD;\n\nconst double EPS = 1e-11;\ndouble sq(double x) { return x * x; }\n\nvoid solve(double ax, double ay, double bx, double by, int &ma,\n\t\t const vector<double> &x, const vector<double> &y) {\n  double sqdist = sq(ax - bx) + sq(ay - by);\n  if (sqdist >= 4 + EPS) return;\n  double dist = sqrt(sqdist);\n  double ndist = sqrt(1 - sqdist / 4);\n  double ex = (bx - ax) / dist, ey = (by - ay) / dist;\n  int n = x.size();\n  REP(i, 0, 2) {\n    double coef = i == 0 ? 1 : -1;\n    double cx = (ax + bx) / 2 + ey * coef * ndist;\n    double cy = (ay + by) / 2 - ex * coef * ndist;\n    int cnt = 0;\n    REP(j, 0, n) {\n      double sqdist = sq(x[j] - cx) + sq(y[j] - cy);\n      if (sqdist <= 1 + EPS) {\n\tcnt += 1;\n      }\n    }\n    ma = max(ma, cnt);\n  }\n}\n\nint main(void) {\n  int n;\n  while(scanf(\"%d\", &n) && n) {\n    vector<double> x(n), y(n);\n    REP(i, 0, n) scanf(\"%lf%lf\", &x[i], &y[i]);\n    int ma = 1;\n    REP(i, 0, n) {\n      REP(j, 0, i) {\n        solve(x[i], y[i], x[j], y[j], ma, x, y);\n      }\n    }\n    printf(\"%d\\n\", ma);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\nconst double PI=3.141592653589793238462643383279;\n\nbool inC(P p, P c, double r){return abs(p-c)<r+1e-9;}\n\nP getE(P p){return p/abs(p);}\n\ndouble sq(double x){ return  x*x;}\n\nint main(){\n    int n,i,j,k,ans,cnt;\n    double x, y;\n    while(scanf(\"%d\",&n)){\n        if(n==0) break;\n        ans=0;\n        vector<P> ps(n);\n        for(i=0; i<n; i++){\n            scanf(\"%lf%lf\",&x,&y);\n            ps[i] = P(x,y);\n        }\n        for(i=0;i<n;i++)\n            for(j=i+1;j<n;j++)if(abs(ps[i]-ps[j])<2){\n                double d=sqrt(1-sq(abs(ps[j]-ps[i])*0.5));\n                P c1=0.5*(ps[i]+ps[j])+getE(getE(ps[j]-ps[i]))*polar(d,PI/2);\n                P c2=0.5*(ps[i]+ps[j])+getE(getE(ps[j]-ps[i]))*polar(d,-PI/2);\n                cnt=0;\n                for(k=0;k<n;k++)if(inC(ps[k],c1,1.0))cnt++;\n                if(cnt>ans)ans=cnt;\n                cnt=0;\n                for(k=0;k<n;k++)if(inC(ps[k],c2,1.0))cnt++;\n                if(cnt>ans)ans=cnt;\n            }\n        if(ans==0) ans++;\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> p;\n\nint n;\np ps[300];\n\nint main() {\n\twhile (cin >> n , n != 0) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tps[i] = p(x, y);\n\t\t}\n\n\t\tif (n == 1) {\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tp v = ps[i] - ps[j], ve = v / abs(v);\n\t\t\t\tdouble l = sqrt(1 - norm(v) * 0.25);\n\t\t\t\tp vn1 = ve * p(0, 1) * l, vn2 = ve * p(0, -1) * l;\n\t\t\t\tp c1 = ps[j] + v * 0.5 + vn1, c2 = ps[j] + v * 0.5 + vn2;\n\t\t\t\tint count1 = 2, count2 = 2;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (k == i || k == j) continue;\n\t\t\t\t\tif (norm(c1 - ps[k]) <= 1.0) count1++;\n\t\t\t\t\tif (norm(c2 - ps[k]) <= 1.0) count2++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, count1);\n\t\t\t\tans = max(ans, count2);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint N;\npair<double,double> dots[300];\n#define EPS (1e-6)\n\n\nint main(){\n\n\twhile(cin >> N && N != 0){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tpair<double,double> p;\n\t\t\tcin >> dots[i].second >> dots[i].first;\n\t\t}\n\t\tint maxCnt = 1;\n\t\t// ~ðìé½ßÌQ_ðßé\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = i+1; j < N; j++){\n\t\t\t\tpair<double,double> dot1,dot2;\n\t\t\t\tdot1 = dots[i];\n\t\t\t\tdot2 = dots[j];\n\n\t\t\t\tdouble v = sqrt((dot1.first - dot2.first)*(dot1.first - dot2.first)\n\t\t\t\t\t+(dot1.second - dot2.second)*(dot1.second - dot2.second));\n\t\t\t\t// ñ_Ô£ª2æè¨¨«¯êÎÂ­êÈ¢\n\t\t\t\tif(v > 2.0 + EPS){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdouble x = sqrt(1 - (v/2)*(v/2));\n\n\t\t\t\t// ñgÌPÊ@üxNg\n\t\t\t\tpair<double,double> hose[2];\n\t\t\t\those[0].first = -1.0/(dots[i].first - dots[j].first);\n\t\t\t\those[0].second = 1.0/(dots[i].second - dots[j].second);\n\t\t\t\those[1].first = 1.0/(dots[i].first - dots[j].first);\n\t\t\t\those[1].second = -1.0/(dots[i].second - dots[j].second);\n\n\t\t\t\tdouble dd1 = sqrt((hose[0].second)*(hose[0].second)+(hose[0].first)*(hose[0].first));\n\t\t\t\tdouble dd2 = sqrt((hose[1].second)*(hose[1].second)+(hose[1].first)*(hose[1].first));\n\t\t\t\those[0].first /= dd1; hose[0].second /= dd1;\n\t\t\t\those[1].first /= dd2; hose[1].second /= dd2;\n\n\t\t\t\t// x{·é\n\t\t\t\those[0].first *= x;hose[1].first *= x;\n\t\t\t\those[0].second *= x;hose[1].second *= x;\n\n\t\t\t\t// mð«·\n\t\t\t\those[0].first += (dot1.first + dot2.first)/2;\n\t\t\t\those[0].second += (dot1.second + dot2.second)/2;\n\t\t\t\those[1].first += (dot1.first + dot2.first)/2;\n\t\t\t\those[1].second += (dot1.second + dot2.second)/2;\n\n\t\t\t\t// hose[0]Æhose[1]Í~ÌSÀW\n\t\t\t\t// e_ÉÖµÄ~ÌÉ¶Ý·é©Ç¤©ðßé\n\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor(int l = 0; l < N; l++){\n\t\t\t\t\t\tdouble dist = sqrt((dots[l].first -hose[k].first)*(dots[l].first -hose[k].first)\n\t\t\t\t\t\t\t+ (dots[l].second -hose[k].second)*(dots[l].second -hose[k].second));\n\t\t\t\t\t\tif(dist <= 1.0 + EPS){\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmaxCnt = max(maxCnt,cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << maxCnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<28;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nstruct point{\n\tdouble x,y;\n\tpoint operator+(point p){\n\t\treturn point{x+p.x,y+p.y};\n\t}\n\tpoint operator-(point p){\n\t\treturn point{x-p.x,y-p.y};\n\t}\n\tpoint operator*(double p){\n\t\treturn point{x*p,y*p};\n\t}\n\tpoint operator/(double p){\n\t\tif(!p) return point{0,0}; \n\t\treturn point{x/p,y/p};\n\t}\n\tbool operator==(point p){\n\t\treturn fabs(x-p.x)<eps&&fabs(y-p.y)<eps;\n\t}\n\tbool operator<(point p){\n\t\tif(fabs(x-p.x)>eps) return x<p.x;\n\t\treturn y<p.y;\n\t}\n};\n\ntypedef pair<point,point> pp;\ntypedef vector<point> VP;\nconst point O{0,0};\n\ndouble Length(point x,point y){\n\tpoint z=y-x;\n\treturn sqrt(z.x*z.x+z.y*z.y);\n}\n\npoint Normal(point p){\n\treturn point{p.y,-p.x};\n}\n\nint n;\nVP p;\n\nint f(point q){\n\tint res=0;\n\tfor(int i=0;i<n;i++) if(Length(p[i],q)<1+eps) res++;\n\treturn res;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(!n) break;\n\t\tp=VP(n);\n\t\tfor(int i=0;i<n;i++) cin>>p[i].x>>p[i].y;\n\t\tint res=0;\n\t\tfor(int i=0;i<n;i++) for(int j=i+1;j<n;j++){\n\t\t\tpoint c=(p[i]+p[j])/2,e=Normal(p[i]-p[j]);\n\t\t\tdouble l=Length(c,p[i]);\n\t\t\te=e/Length(O,e)*sqrt(1.0-l*l);\n\t\t\tres=max(res,max(f(c+e),f(c-e)));\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> C;\n\nint solve(int N, vector<double>& x, vector<double>& y) {\n    vector<C> point(N);\n\n    for (int j = 0; j < N; ++j) {\n        point[j] = C(x[j], y[j]);\n    }\n\n    int ret = 1;\n\n    for (int j = 0; j < N; ++j) {\n        for (int k = j+1; k < N; ++k) {\n            C mid = (point[j] + point[k]) * 0.5;\n\n            C normal = (point[j] - point[k]) * C(0, 1);\n            normal /= abs(point[j] - point[k]);\n\n            double a = sqrt(1 - norm(mid - point[j]));\n\n            C centre1 = mid + a * normal;\n            int count = 0;\n            for (int l = 0; l < N; ++l) {\n                if (abs(centre1 - point[l]) < 1.0) {\n                    ++count;\n                }\n            }\n            ret = max(ret, count);\n\n            C centre2 = mid - a * normal;\n            count = 0;\n            for (int l = 0; l < N; ++l) {\n                if (abs(centre2 - point[l]) < 1.0) {\n                    ++count;\n                }\n            }\n            ret = max(ret, count);\n\n        }\n    }\n\n    return ret;\n}\n\nint main () {\n    int N;\n    vector<double> x, y;\n\n    while (true) {\n        cin >> N;\n        if (N == 0) break;\n\n        x.resize(N);\n        y.resize(N);\n\n        for (int j = 0; j < N; ++j) {\n            cin >> x[j] >> y[j];\n        }\n\n        cout << solve(N, x, y) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ndouble p[300][2];\nint n;\n\ndouble dis(double x1, double y1, double x2, double y2){\n    return sqrt(pow(x1-x2, 2) + pow(y1-y2, 2));\n}\n\nint circle(double x, double y, int i, int j){\n    int count = 2;\n    REP(k, n){\n        if(k!=i && k!=j){\n            if(dis(x, y, p[k][0], p[k][1]) < 1){\n                count += 1;\n            }\n        }\n    }\n    return count;\n}\n\nint main(){\n    while(1){\n        cin >> n;\n\n        if(n==0) break;\n\n        REP(i, n){\n            cin >> p[i][0];\n            cin >> p[i][1];\n        }\n\n        int output = 0;\n        REP(i, n){\n            for(int j=i+1; j<n; j++){\n                double cx = (p[i][0]+p[j][0]) / 2;\n                double cy = (p[i][1]+p[j][1]) / 2;\n                double d = dis(p[i][0], p[i][1], p[j][0], p[j][1]);\n\n                if(d>2){\n                    continue;\n                } else if (d==2){\n                    output = max(output, circle(cx, cy , i, j));\n                } else {\n                    double a1 = acos(d/2);\n                    double a2 = atan2((p[j][1]-p[i][1]), p[j][0]-p[i][0]);\n\n                    double x1 = p[i][0] + cos(a2+a1);\n                    double y1 = p[i][1] + sin(a2+a1);\n\n                    double x2 = p[i][0] + cos(a2-a1);\n                    double y2 = p[i][1] + sin(a2-a1);\n\n                    output = max(output, circle(x1, y1, i, j));\n                    output = max(output, circle(x2, y2, i, j));\n                }\n            }\n        }\n\n        cout << output << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-8;\nusing P = complex<double>;\nint n;\nP p[300];\n\nint main(){\n  while (cin >> n, n){\n    for (int i = 0; i < n; i++){\n      double x, y;\n      cin >> x >> y;\n      p[i] = P(x, y);\n    }\n    vector<P> ps;\n    for (int i = 0; i < n; i++){\n      for (int j = 0; j < i; j++){\n        if (abs(p[i] - p[j]) >= 2.0) continue;\n        P v = p[j] - p[i];\n        P u = v * P(0.0, 1.0);\n        u *= sqrt(1.0 - abs(v) * abs(v) / 4.0) / abs(u);\n        ps.push_back(p[i] + v / 2.0 + u);\n        ps.push_back(p[i] + v / 2.0 - u);\n      }\n    }\n    int res = 1;\n    for (P c : ps){\n      int s = 0;\n      for (int i = 0; i < n; i++){\n        s += abs(c - p[i]) <= 1.0 + EPS;\n      }\n      res = max(res, s);\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-9\nusing namespace std;\n\ntypedef complex<double> P;\n\nP rot (P x, P p, double ang) {\n    ang = ang / 180.0 * M_PI;\n    double p1 = p.real() - x.real();\n    double p2 = p.imag() - x.imag();\n    return P( p1 * cos(ang) - p2 * sin(ang) + x.real()\n              , p1 * sin(ang) + p2 * cos(ang) + x.imag() );\n}\n\nint main () {\n    int n;\n    while (cin >> n, n) {\n        vector<P> v(n);\n        for (auto &i : v) {\n            double x, y;\n            cin >> x >> y;\n            i = P(x,y);\n        }\n\n        int res = 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i != j && abs(v[i] - v[j]) <= 2. + EPS) {\n                    int count = 0;\n                    P m = P(abs(v[i].real() + v[j].real()) / 2., abs(v[i].imag() + v[j].imag()) / 2.);\n                    P p = m + (m - v[i]) / abs(m - v[i]) * sqrt(1. - pow(abs(m - v[i]), 2.));\n                    p = rot(m, p, 90);\n                    for (int k = 0; k < n; k++) {\n                        if (abs(p - v[k]) <= 1. + EPS) count++;\n                    }\n\n                    res = max(res, count);\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nstruct Point{\n    double x,y;\n};\n\nvoid func(int N){\n\n    Point point[N];\n    double x_min = 100,y_min = 100,x_max = -1,y_max = -1;\n\n    for(int i = 0; i < N; i++){\n        scanf(\"%lf %lf\",&point[i].x,&point[i].y);\n        x_min = min(point[i].x,x_min);\n        y_min = min(point[i].y,y_min);\n        x_max = max(point[i].x,x_max);\n        y_max = max(point[i].y,y_max);\n    }\n\n    int count,max_count = 0;\n\n    for(double y = y_min; y <= y_max; y += 0.01){\n        for(double x = x_min; x <= x_max; x += 0.01){\n            count = 0;\n            for(int i = 0; i < N; i++){\n                if(sqrt((x-point[i].x)*(x-point[i].x)+(y-point[i].y)*(y-point[i].y)) <= 1.0)count++;\n            }\n            max_count = max(max_count,count);\n        }\n    }\n\n    printf(\"%d\\n\",max_count);\n}\n\n\nint main(){\n\n    int N;\n\n    while(true){\n        scanf(\"%d\",&N);\n        if(N == 0)break;\n\n        func(N);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <complex>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\n#define equals(a, b) (fabs((a)-(b))<EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> Point;\n\nstruct Circle {\n    Point c;\n    double r;\n    Circle(Point c=Point(), double r=0.0) :\n        c(c),r(r){}\n};\n\nbool include(Circle c,Point p) {\n    return !(norm(c.c-p) > c.r*c.r);\n}\n\nint n;\ndouble xs[301],ys[301];\n\nPoint getMidpoint(Point p1, Point p2, Point p3) {\n    Point p=p1+p2+p3;\n    p/=3;\n\n    return p;\n}\n\nint f(Point p) {\n    int ret=0;\n    Circle c=Circle(p,1);\n    rep(i,n) {\n        if(include(c,Point{xs[i],ys[i]})) ret++;\n    }\n\n    return ret;\n}\n\nvoid solve() {\n    rep(i,n) cin>>xs[i]>>ys[i];\n    int ans=0;\n    double x=0,y=0;\n    rep(i,n) rep(j,n) if(i<j) {\n        rep(k,n) if(j<k) {\n            Point p=getMidpoint(Point{xs[i],ys[i]},Point{xs[j],ys[j]},Point{xs[k],ys[k]});\n            ans=max(ans,f(p));\n        }\n        Point p=Point{(xs[i]+xs[j])/2,(ys[i]+ys[j])/2};\n\n        ans=max(ans,f(p));\n    }\n\n    cout<<ans<<endl;\n}\n\nint main() {\n    while(cin>>n) {\n        if(!n) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define LP(i,n) for(int i = 0; i < n; i++)\n\nusing namespace std;\ntypedef pair<double,double> P;\n\ndouble Dist(double x1[], double x2[]){\n\treturn pow((x1[0]-x2[0])*(x1[0]-x2[0])+(x1[1]-x2[1])*(x1[1]-x2[1]),0.5);\n\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\twhile(n){\n\t\tint mx = 0;\n\t\tP p[300];\n\t\tLP(i,n){\n\t\t\tcin >> p[i].first >> p[i].second;\n\t\t}\n\t\tsort(p,p+n);\n\t\tdouble x[300][2];\n\t\tLP(i,n){\n\t\t\tx[i][0] = p[i].first;\n\t\t\tx[i][1] = p[i].second;\n\t\t}\n\t\tdouble dist[300][300];\n\t\tLP(i,n){\n\t\t\tLP(j,n){\n\t\t\t\tdist[i][j] = Dist(x[i],x[j]);\n\t\t\t}\n\t\t}\n\t\tLP(i,n){\n\t\t\tfor(int j = i+1; j < n; j++){\n\t\t\t\tif(x[j][0]-x[i][0] > 2){\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tif(dist[i][j] < 2){\n\t\t\t\t\t\tdouble m[] = {(x[j][0]+x[i][0])/2,(x[j][1]+x[i][1])/2};\n\t\t\t\t\t\tdouble d[] = {x[j][1]-x[i][1],-x[j][0]+x[i][0]};\n\t\t\t\t\t\tdouble O[] = {0,0};\n\t\t\t\t\t\tdouble _d = Dist(d,O);\n\t\t\t\t\t\tLP(k,2){\n\t\t\t\t\t\t\td[k] *= (pow(_d,-2)-0.25);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdouble o[2][2];\n\t\t\t\t\t\tLP(k,2){\n\t\t\t\t\t\t\tLP(l,2){\n\t\t\t\t\t\t\t\to[k][l] = m[l];\n\t\t\t\t\t\t\t\tif(k) o[k][l] += d[l];\n\t\t\t\t\t\t\t\telse o[k][l] -= d[l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLP(k,2){\n\t\t\t\t\t\t\tint s = 2;\n\t\t\t\t\t\t\tfor(int l = i+1; l < j; l++){\n\t\t\t\t\t\t\t\tif(Dist(x[l],o[k]) < 1) s++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int l = i-1; 0<=l && x[i][0]-x[l][0] < 1;l--){\n\t\t\t\t\t\t\t\tif(Dist(x[l],o[k]) < 1) s++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int l = j+1; l < n && x[l][0]-x[j][0] < 1; l++){\n\t\t\t\t\t\t\t\tif(Dist(x[l],o[k]) < 1) s++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmx = max(mx,s);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mx == 0) mx = 1;\n\t\tcout << mx << endl;\n\t\tcin >> n;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ndouble EPS=1e-10;\n\ndouble add(double a,double b){\n  if(abs(a+b)<EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x,y;\n  point(){}\n  point(double x,double y) : x(x) , y(y) {}\n\n  point operator + (point p) {\n    return point(add(x,p.x),add(y,p.y));\n  }\n  point operator - (point p) {\n    return point(add(x,-p.x),add(y,-p.y));\n  }\n  point operator * (double d) {\n    return point(x*d,y*d);\n  }\n  point operator / (double d) {\n    return point(x/d,y/d);\n  }\n  bool operator == (const point &p)const{\n    return abs(x-p.x)<EPS && abs(y-p.y)<EPS;\n  }\n};\n\nstruct circle{\n  point p;\n  double r;\n  circle(){}\n  circle(point p,double r):p(p),r(r){}\n};\n\ndouble dist(point a, point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nvector<point> circle_cross_point(circle a, circle b){\n  vector<point>ret;\n\n  double x=a.p.x-b.p.x,y=a.p.y-b.p.y;\n  double L=x*x+y*y;\n\n  if(L>pow(a.r+b.r,2))return ret;\n\n  L=sqrt(L);\n  double C=atan2(b.p.y-a.p.y,b.p.x-a.p.x);\n  double alpha=acos((L*L+a.r*a.r-b.r*b.r)/(2*L*a.r));\n\n  point r1,r2;\n  r1.x=a.p.x+cos(C+alpha),r1.y=a.p.y+sin(C+alpha);\n  r2.x=a.p.x+cos(C-alpha),r2.y=a.p.y+sin(C-alpha);\n\n  ret.push_back(r1),ret.push_back(r2);\n  return ret;\n}\n\nint main(void){\n  int n;\n  point a;\n  vector<point>P;\n  vector<circle>C;\n\n  while(cin >> n,n){\n    P.clear();\n    C.clear();\n    for(int i=0;i<n;i++){\n      cin >> a.x >> a.y;\n      P.push_back(a);\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(dist(P[i],P[j])>2.0+EPS)continue;\n\tvector<point>res=circle_cross_point(circle(P[i],1.0),circle(P[j],1.0));\n\tfor(int k=0;k<res.size();k++)\n\t  C.push_back(circle(res[k],1));\n      }\n    }\n\n    int ans=1;\n    for(int i=0;i<C.size();i++){\n      int cnt=0;\n      for(int j=0;j<P.size();j++)\n\tif(dist(C[i].p,P[j])<1.0+EPS)cnt++;\n\n      ans=max(ans,cnt);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\nusing DD = double;\nconst DD INF = 1LL<<60;      // to be set appropriately\nconst DD EPS = 1e-5;;        // to be set appropriately\nconst DD PI = acosl(-1.0);\nDD torad(int deg) {return (DD)(deg) * PI / 180;}\nDD todeg(DD ang) {return ang * 180 / PI;}\n\n/* Point */\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\ninline Point operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\ninline Point operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\ninline Point operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}\ninline Point operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}\ninline Point operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\ninline Point operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}\ninline Point conj(const Point &p) {return Point(p.x, -p.y);}\ninline Point rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\ninline Point rot90(const Point &p) {return Point(-p.y, p.x);}\ninline DD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\ninline DD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\ninline DD norm(const Point &p) {return dot(p, p);}\ninline DD abs(const Point &p) {return sqrt(dot(p, p));}\ninline DD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\ninline bool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}\ninline bool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\ninline bool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\ninline Point operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\n/* Line */\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n    friend ostream& operator << (ostream &s, const Line &l) {return s << '{' << l[0] << \", \" << l[1] << '}';}\n};\n\n/* Circle */\nstruct Circle : Point {\n    DD r;\n    Circle(Point p = Point(0.0, 0.0), DD r = 0.0) : Point(p), r(r) {}\n    friend ostream& operator << (ostream &s, const Circle &c) {return s << '(' << c.x << \", \" << c.y << \", \" << c.r << ')';}\n};\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nPoint proj_for_crosspoint(const Point &p, const Line &l) {\n    DD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nvector<Point> crosspoint(const Line &l, const Line &m) {\n    vector<Point> res;\n    DD d = cross(m[1] - m[0], l[1] - l[0]);\n    if (abs(d) < EPS) return vector<Point>();\n    res.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n    return res;\n}\nvector<Point> crosspoint(const Circle &e, const Circle &f) {\n    vector<Point> res;\n    DD d = abs(e - f);\n    if (d < EPS) return vector<Point>();\n    if (d > e.r + f.r + EPS) return vector<Point>();\n    if (d < abs(e.r - f.r) - EPS) return vector<Point>();\n    DD rcos = (d * d + e.r * e.r - f.r * f.r) / (2.0 * d), rsin;\n    if (e.r - abs(rcos) < EPS) rsin = 0;\n    else rsin = sqrt(e.r * e.r - rcos * rcos);\n    Point dir = (f - e) / d;\n    Point p1 = e + dir * Point(rcos, rsin);\n    Point p2 = e + dir * Point(rcos, -rsin);\n    res.push_back(p1);\n    if (!eq(p1, p2)) res.push_back(p2);\n    return res;\n}\n\nvoid solve() {\n\tint n;\n    while(cin >> n) {\n        if(n == 0) break;\n        vector<Point> p(n);\n        for(int i = 0; i < n; ++ i) {\n            cin >> p[i].x >> p[i].y;\n        }\n        vector<Point> alt;\n        for(int i = 0; i < n; ++ i) {\n            for(int j = i + 1; j < n; ++ j) {\n                Circle c1(p[i], 1.0), c2(p[j], 1.0);\n                for(auto x: crosspoint(c1, c2)) {\n                    alt.push_back(x);\n                }\n            }\n        }\n        int ans = 1;\n        for(auto pp: alt) {\n            int cnt = 0;\n            for(int i = 0; i < n; ++ i) {\n                if(abs(p[i] - pp) <= 1.0 + EPS) ++ cnt;\n            }\n            ans = max(ans, cnt);\n        }\n        cout << ans << endl;\n    }\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> coor;\n\n#define EPS 1e-9\n\ndouble in_cir(coor o, coor x)\n{\n  return abs(x - o);\n}\n\nint search(vector<coor> P)\n{\n  int mx = 0;\n  /*for (int i = 0; i < P.size(); i++) {\n    printf(\"%lf, %lf\\n\", P[i].real(), P[i].imag());\n    }*/\n  for (int i = 0; i < P.size(); i++) {\n    for (int j = i + 1; j < P.size(); j++) {\n      for (int k = 0; k < 2; k++) {\n\tif (abs(P[i] - P[j]) - 2.0 > -EPS) {continue;}\n\tcoor d = coor(P[i].imag() - P[j].imag(),\n\t\t      -(P[i].real() - P[j].real()));\n\tif (k == 1) {d = -d;}\n\td /= abs(d);\n\td *= sqrt(1 - norm(P[i] - P[j]) / 4);\n\t//printf(\"abs(d) = %lf\\n\", abs(d));\n\td += (P[i] + P[j]) / 2.0;\n\t//printf(\"%lf, %lf\\n\", d.real(), d.imag());\n\tint ctr = 2;\n\tfor (int l = 0; l < P.size(); l++) {\n\t  //printf(\"%lf\\n\", in_cir(d, P[l]));\n\t  if (l == i || l == j) {continue;}\n\t  if (in_cir(d, P[l]) - 1.0 < -EPS) {\n\t    ctr++;\n\t  }\n\t}\n\t//printf(\"_%d\\n\", ctr);\n\tmx = max(ctr, mx);\n\t\n      }\n    }\n  }\n  return mx;\n}\n\nint main()\n{\n  int N;\n  while (scanf(\"%d \", &N) == 1) {\n    if (N == 0) {\n      break;\n    }\n    vector<coor> P(N);\n    for (int i = 0; i < N; i++) {\n      double x, y;\n      scanf(\"%lf %lf \", &x, &y);\n      P[i] = coor(x, y);\n    }\n    printf(\"%d\\n\", search(P));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <limits>\n#include <iostream>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <iomanip>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\nusing ll=long long int;\nusing pii=pair<int,int>;\nusing pil=pair<int,ll>;\nusing pli=pair<ll,int>;\nusing pll=pair<ll,ll>;\nusing psi=pair<string,int>;\nusing pis=pair<int,string>;\nusing psl=pair<string,ll>;\nusing pls=pair<ll,string>;\nusing pss=pair<string,string>;\n\n\n\ntemplate<typename T> using vc=vector<T>;\ntemplate<typename T> using vvc=vector<vector<T>>;\ntemplate<typename T> using vvvc=vector<vector<vector<T>>>;\ntemplate<typename T> using vvvvc=vector<vvvc<T>>;\ntemplate<typename T> using vvvvvc=vector<vvvvc<T>>;\n\ntemplate<class T,class U>inline constexpr bool chmin(T&a,const U b){if(a<=b)return false;a=b;return true;}\ntemplate<class T,class U>inline constexpr bool chmax(T&a,const U b){if(a>=b)return false;a=b;return true;}\n#define bit(n,k) ( (n>>k)&1 )\n\ninline void bin101(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); \n    cout<<fixed<<setprecision(20);\n}\n\n//デバッグ\ntemplate<typename T>\ninline void vout(const vector<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        cout<<i<<\" \"<<v[i]<<'\\n';\n    }\n    cout<<\"end\\n\"<<endl;\n}\n//デバッグ\ntemplate<typename T>\ninline void vout(const vvc<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        int ssz=v[i].size();\n        for(int j=0;j<ssz;j++){\n            cout<<i<<\" \"<<j<<\" \"<<v[i][j]<<'\\n';\n        }\n    }\n    cout<<\"end\\n\"<<endl;\n}\n//デバッグ\ntemplate<typename T>\ninline void vout(const vvvc<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        int ssz=v[i].size();\n        for(int j=0;j<ssz;j++){\n            int sssz=v[i][j].size();\n            for(int k=0;k<sssz;k++){\n                cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<v[i][j][k]<<'\\n';\n            }\n        }\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\n\n//pair cout\ntemplate<typename T, typename U>\ninline ostream &operator<<(ostream &os,const pair<T,U> &p) {\n  os<<p.first<<\" \"<<p.second;\n  return os;\n}\n\n//pair cin\ntemplate<typename T, typename U>\ninline istream &operator>>(istream &is,pair<T,U> &p) {\n  is>>p.first>>p.second;\n  return is;\n}\n\n//ソート\ntemplate<typename T>\ninline void vsort(vector<T> &v){\n    sort(v.begin(),v.end());\n}\n\n//逆順ソート\ntemplate<typename T>\ninline void rvsort(vector<T> &v){\n  sort(v.rbegin(),v.rend());\n}\n\n//要素数a 初期値x\ntemplate<typename T>\ninline vector<T> vmake(int a,T x){\n  return vector<T>(a,x);\n}\n\n//data[a][b] 初期値x\ntemplate<typename T>\ninline vector<vector<T>> vmake(int a,int b,T x){\n  return vector<vector<T>>(a, vector<T>(b,x));\n}\n\n//data[a][b][c] 初期値x\ntemplate<typename T>\ninline vector<vector<vector<T>>> vmake(int a,int b,int c,T x){\n  return vector<vector<vector<T>>> (a, vector<vector<T>>(b, vector<T>(c, x)));\n}\n\n//data[a][b][c][d]　初期値x\ntemplate<typename T>\ninline vector<vector<vector<vector<T>>>> vmake(int a,int b,int c,int d,T x){\n  return vector<vector<vector<vector<T>>>> (a,vvvc<T>(b,vvc<T>(c,vc<T>(d,x))));\n}\n\n//data[a][b][c][d][e] 初期値x\ntemplate<typename T>\ninline vvvvvc<T> vmake(int a,int b,int c,int d,int e,T x){\n  return vvvvvc<T> (a,vvvvc<T>(b,vvvc<T>(c,vvc<T>(d,vc<T>(e,x)))));\n}\n\n//1ビットの数を返す\ninline int popcount(int x){\n  return __builtin_popcount(x);\n}\n//1ビットの数を返す\ninline int popcount(ll x){\n  return __builtin_popcountll(x);\n}\n\n//queのfront() pop()\ntemplate<typename T>\ninline T pop(queue<T> &que){\n    T x=que.front();\n    que.pop();\n    return x;\n}\n\n//priority_que top() pop()\ntemplate<typename T>\ninline T pop(priority_queue<T> &que){\n  T x=que.top();\n  que.pop();\n  return x;\n}\n\n//stack top() pop()\ntemplate<typename T>\ninline T pop(stack<T> &st){\n  T x=st.top();\n  st.pop();\n  return x;\n}\n\n#define intsz(x) ( (int)x.size()  )\n\n/*\n満たすものの個数を返す\nmode:0 x未満\nmode:1 x以下の数\nmode:2 x以上の数\nmode:3 x超\nmode:4 x\n*/\ntemplate<typename T>\ninline int count_bound(vector<T> &v,T x,int mode){\n    switch(mode){\n        case 0:\n            return lower_bound(v.begin(),v.end(),x)-v.begin();\n        case 1:\n            return upper_bound(v.begin(),v.end(),x)-v.begin();\n        case 2:\n            return v.end()-lower_bound(v.begin(),v.end(),x);\n        case 3:\n            return v.end()-upper_bound(v.begin(),v.end(),x);\n        case 4:\n            return upper_bound(v.begin(),v.end(),x)-lower_bound(v.begin(),v.end(),x);\n    }\n}\n\n/*\nmode:0 xより小さい数で最大の数\nmode:1 x以下の数で最大の数\nmode:2 x以上の数で最小の数\nmode:3 xより大きい数で最小の数\n*/\ntemplate<typename T>\ninline T value_bound(vector<T> &v,T x,int mode){\n    switch(mode){\n        case 0:\n            return *(--lower_bound(v.begin(),v.end(),x));\n        case 1:\n            return *(--upper_bound(v.begin(),v.end(),x));\n        case 2:\n            return *lower_bound(v.begin(),v.end(),x);\n        case 3:\n            return *upper_bound(v.begin(),v.end(),x);\n    }\n}\n\n\n\nconstexpr int MAX=1<<30;\n//constexpr ll INF=1LL<<62;\nconstexpr ll MOD=1e9+7;\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1};\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\nusing DD=double;\n\n\n#define EPS 1e-10\n#define eq(a,b) (abs( (a) - (b) )<EPS)\nconst DD PI=acosl(-1.0);\nconstexpr DD INF=1LL<<62;\n\n//点\nusing P=complex<DD>;\n//ベクトル\nusing V=P;\n//線分\nstruct Segment{\n    P a,b;\n    Segment()=default;\n    Segment(P a,P b) :a(a),b(b){}\n    Segment(DD ax,DD ay,DD bx,DD by):a(ax,ay),b(bx,by){}\n    Segment(DD r,P a) :a(a),b(a+polar(1.0,r)){} \n\n};\n//直線\nusing Line=Segment;\n//円\nstruct Circle{\n    P p;\n    DD r;\n    Circle()=default;\n    Circle(P p,DD r):p(p),r(r){}\n};\nusing Polygon=vector<P>;\n\n//++++++++++++++++基本計算++++++++++++++//\ninline DD torad(const DD &deg){return deg*PI/180;}\ninline DD todeg(const DD &rad){return rad*180/PI;}\n//内積\ninline DD dot(const V &a,const V &b){\n    return real(a*conj(b));\n}\n//外積\ninline DD cross(const V &a,const V &b){\n    return imag(conj(a)*b);\n}\n//ベクトルvを反時計回りにr度回転\ninline V rotate(const V &v,const DD r){\n    return v*V(cos(r),sin(r));\n}\ninline bool xy(const P &a,const P &b){\n    if(real(a)+EPS<=real(b)) return true;\n    if(eq(real(a),real(b)) && imag(a)+EPS<imag(b)) return true;\n    return false;\n}\ninline bool yx(const P &a,const P &b){\n    if(imag(a)+EPS<imag(b)) return true;\n    if(eq(imag(a),imag(b)) && real(a)+EPS<real(b)) return true;\n    return false;\n}\n\n//++++++++++++++++平行や直交+++++++++++++++//\ninline bool isOrthogonal(const V &a,const V &b){\n    return eq(dot(a,b),0.0);\n}\ninline bool isOrthogonal(const Segment &a,const Segment &b){\n    return eq(dot(a.a-a.b,b.a-b.b),0);\n}\ninline bool isParallel(const V &a,const V &b){\n    return eq(cross(a,b),0.0);\n}\ninline bool isParallel(const Segment &a,const Segment &b){\n    return eq(cross(a.a-a.b,b.a-b.b),0);\n}\n//線分a-bに対してcがどの位置にあるか\n//ccwの簡略版 反時計回り:1 時計回り:-1 直線上:0\ninline int ccw(const P &a,const P &b,const P &c){\n    DD cr=cross(b-a,c-a);\n    if(cr>EPS) return 1;\n    if(cr<-EPS) return -1;\n    return 0;\n}\n\n//線分a-bに対してcがどの位置にあるか\n//反時計回り:1　時計回り:-1 直線上(a,b,c:-2 a,c,b:0 c,a,b:2) \ninline int ccwH(P a,P b,P c){\n    b-=a;c-=a;\n    if(cross(b,c)>EPS) return 1;\n    if(cross(b,c)<-EPS) return -1;\n    if(dot(b,c)<-EPS) return 2;\n    if(norm(b)<norm(c)) return -2;\n    return 0;\n}\n\n\n//+++++++++++++++射影+++++++++++++++++++++//\ninline P project(const P &p,const Segment &s){\n    V base=s.b-s.a;\n    DD r=dot(p-s.a,base)/norm(base);\n    return s.a+base*r;\n}\ninline P reflect(const P &p,const Segment &s){\n    return p+(project(p,s)-p)*2.0;\n}\n/*++++++++++点との距離++++++++++++++++++*/\n//点と直線の距離\ninline DD dis(const P &p,const Line &l){return abs(cross(l.b-l.a,p-l.a))/abs(l.b-l.a);}\n//点と線分の距離\ninline DD disPS(const P &p,const Segment &s){\n    if( dot(s.b-s.a,p-s.a)<0.0 ) return abs(p-s.a);\n    if( dot(s.a-s.b,p-s.b)<0.0 ) return abs(p-s.b);\n    return dis(p,s); //点と直線の距離\n}\n\n\n//+++++++++++++++線分と直線+++++++++++++++++//\n\n//線分a-b,c-dは交差するか?\ninline bool intersect(const P &a,const P &b,const P &c,const P &d){\n    return(ccwH(a,b,c)*ccwH(a,b,d)<=0 && ccwH(c,d,a)*ccwH(c,d,b)<=0);\n}\n//線分s,tは交差するか？\ninline bool intersect(const Segment &s,const Segment &t){\n    return intersect(s.a,s.b,t.a,t.b);\n}\n//線分と線分の交点\n//これをやる前にintersectで判定\ninline P crossPoint(const Segment &s,const Segment &t){\n    V base=t.b-t.a;\n    DD d1=abs(cross(base,s.a-t.a));\n    DD d2=abs(cross(base,s.b-t.a));\n    DD r=d1/(d1+d2);\n    return s.a+(s.b-s.a)*r;\n}\n//線分と線分の距離\ninline DD dis(const Segment &s,const Segment t){\n    if(intersect(s,t)) return 0.0;\n    return min(min(disPS(t.a,s),disPS(t.b,s)),min(disPS(s.a,t),disPS(s.b,t)) );\n}\n\n//+++++++++++円++++++++++++++++//\n\n//円cと直線lの交点\n//abs(l,c.p)<c.r+EPSが必要\npair<P,P> crossPoint(const Line &l,const Circle &c){\n    P pr=project(c.p,l);\n    V e=(l.b-l.a)/(abs(l.b-l.a));\n    DD base=sqrt(c.r*c.r-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n//線分sと円cの交点\nvector<P> crossPointSC(const Segment &s,const Circle &c){\n    vector<P> ret;\n    if(dis(c.p,s)>=c.r+EPS) return ret;\n    auto p=crossPoint(s,c);\n    if(dot(p.first-s.a,s.b-s.a)>0 && dot(p.first-s.b,s.a-s.b)>0) ret.push_back(p.first);\n    if(dot(p.second-s.a,s.b-s.a)>0 && dot(p.second-s.b,s.a-s.b)>0) ret.push_back(p.second);\n    if(xy(s.a,s.b)) sort(ret.begin(),ret.end(),xy);\n    else sort(ret.rbegin(),ret.rend(),xy);\n    return ret;\n}\n\n//共通接線の数\n//離れている:4 外接:3 交わる:2 内接:1 内包:0\ninline int intersect(const Circle &a,const Circle &b){\n    DD d=abs(a.p-b.p);\n    if(d>a.r+b.r+EPS) return 4;\n    if(eq(d,a.r+b.r)) return 3;\n    if(eq(d,abs(a.r-b.r))) return 1;\n    if(d<abs(a.r-b.r)-EPS) return 0;\n    return 2;\n}\n\n//円c1と円c2の交点\n//これを使う前に交点があるかどうかを判定する\nvector<P> crossPoint(const Circle &a,const Circle &b){\n    vector<P> ret;\n    if(abs(a.p-b.p)>a.r+b.r+EPS) return ret;\n    DD d=abs(a.p-b.p);\n    DD s=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n    DD t=arg(b.p-a.p);\n    if(eq(s,0)) ret.emplace_back(a.p+polar(a.r,t+s));\n    else ret.push_back(a.p+polar(a.r,t+s)),ret.push_back(a.p+polar(a.r,t-s));\n    return ret;\n}\n\n//pがcの外にあるかの判定が必要\nvector<P> TanLine(const P &p,const Circle &c){\n    vector<P> ret;\n    DD d=abs(p-c.p);\n    if(d<=c.r-EPS) return ret;\n    if(eq(d,c.r)){\n        ret.push_back(p);\n        return ret;\n    } \n    return crossPoint(c,Circle(p,sqrt(d*d-c.r*c.r)));\n}\n//https://ei1333.github.io/luzhiled/snippets/geometry/template.html\n//↑すごい。丸写し\n//円c1,c2の共通接線\n//接点をつないで線にしている(１個だけ追加するときに注意)\nvector<Line> TanLine(Circle a,Circle b){\n    vector<Line> ret;\n    if(a.r<b.r) swap(a,b);\n    DD g=abs(a.p-b.p);\n    if(eq(g,0)) return ret;\n    V u=(b.p-a.p)/g;\n    V v=rotate(u,PI*0.5);\n    for(DD s:{-1,1}){\n        DD h=(a.r+s*b.r)/g;\n        if(eq(1-h*h,0)){\n            ret.emplace_back(a.p+u*a.r,a.p+(u+v)*a.r);\n        }else if(1-h*h>0){\n            V uu=u*h,vv=v*sqrt(1-h*h);\n            ret.emplace_back(a.p+(uu+vv)*a.r,b.p-(uu+vv)*b.r*s);\n            ret.emplace_back(a.p+(uu-vv)*a.r,b.p-(uu-vv)*b.r*s);\n        }\n    }\n    return ret;\n}\n\n\nsigned main(){\n    bin101();\n\n    while(true){\n        int n;\n        cin>>n;\n        if(n==0) return 0;\n\n        vector<P> v;\n        for(int i=0;i<n;i++){\n            DD a,b;\n            cin>>a>>b;\n            v.emplace_back(a,b);\n        }\n        //中心点の候補\n        vector<P> koho;\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++){\n                DD dist=abs(v[i]-v[j]);\n                if(dist>2-EPS) continue;\n                DD x=sqrt(1-dist*dist/4);\n                P t=(v[i]+v[j])/2.0;\n\n                koho.push_back(t+polar(x,arg(v[i]-v[j])+PI/2));\n                koho.push_back(t+polar(x,arg(v[i]-v[j])-PI/2));                \n            }\n        }\n        int ans=0;\n        for(int i=0;i<(int)koho.size();i++){\n            P c=koho[i];\n            int cnt=0;\n            for(int j=0;j<n;j++){\n                if(abs(c-v[j])<1+EPS) cnt++;\n            }\n            chmax(ans,cnt);\n        }\n        if(ans==0) ans++;\n        cout<<ans<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n\nusing namespace std;\n\nint main(){\n\n\tint n;\n\tdouble x[301],y[301];\n\tint cnt,ans;\n\n\twhile(1){\n\n\t\tcin>>n;\n\t\tif(n==0) break;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x[i]>>y[i];\n\t\t}\n\n\t\tans=0;\n\t\tfor(double i=0;i<=10;i+=0.01){\n\t\t\tfor(double j=0;j<=10;j+=0.01){\n\t\t\t\tcnt=0;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(pow(i-x[k],2.0)+pow(j-y[k],2.0)<=1) cnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt>ans) ans=cnt;\n\t\t\t\tcnt=0;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<iostream>\nusing namespace std;\n#define EPS 1.0e-6\n#define F(I,J,N) for(int I=J;I<N;I++)\n\nclass point{\npublic:\n\tdouble x,y;\n\tpoint(){}\n\tpoint(double x,double y){\n\t\tthis->x=x;\n\t\tthis->y=y;\n\t}\n\tdouble len(point &p){\n\t\treturn sqrt((x-p.x)*(x-p.x)+(y-p.y)*(y-p.y));\n\t}\n\tdouble len(){\n\t\treturn sqrt(x*x+y*y);\n\t}\n\tpoint operator*(double d){\n\t\tpoint p(x*d,y*d);\n\t\treturn p;\n\t}\n\tpoint operator/(double d){\n\t\tpoint p(x/d,y/d);\n\t\treturn p;\n\t}\n\tpoint operator+(const point &o){\n\t\tpoint p(x+o.x,y+o.y);\n\t\treturn p;\n\t}\n\tpoint operator-(const point &o){\n\t\tpoint p(x-o.x,y-o.y);\n\t\treturn p;\n\t}\n\tpoint& operator=(const point &o){\n\t\tthis->x=o.x;\n\t\tthis->y=o.y;\n\t\treturn *this;\n\t}\n\tbool operator==(const point &o){\n\t\treturn (x==o.x && y==o.y);\n\t}\n\tbool operator!=(const point &o){\n\t\treturn !(x==o.x && y==o.y);\n\t}\n};\n\nint main(){\n\tint n;\n\tpoint *p;\n\tint ans;\n\tpoint c,ce,h;\n\twhile(cin>>n){\n\t\tc=ce;\n\t\tif(n==0) break;\n\t\tp=new point[n];\n\t\tans=0;\n\t\tF(i,0,n) cin>>p[i].x>>p[i].y;\n\t\tF(i,0,n-1){\n\t\t\tF(j,i+1,n){\n\t\t\t\tif(p[i].len(p[j])<2+EPS){\n\t\t\t\t\tc=(p[i]+p[j])/2;\n\t\t\t\t\th.x=-(p[i]-p[j]).y;\n\t\t\t\t\th.y=(p[i]-p[j]).x;\n\t\t\t\t\tdouble len=p[i].len(p[j]);\n\t\t\t\t\tlen=sqrt(1-len*len/4);\n\t\t\t\t\th=h*(len/h.len());\n\n\t\t\t\t\tce=c+h;\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tF(k,0,n) if(ce.len(p[k])<1+EPS) cnt++;\n\t\t\t\t\tans=max(ans,cnt);\n\n\t\t\t\t\tce=c-h;\n\t\t\t\t\tcnt=0;\n\t\t\t\t\tF(k,0,n) if(ce.len(p[k])<1+EPS) cnt++;\n\t\t\t\t\tans=max(ans,cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t\tdelete []p;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst long double eps=1e-3;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        vector<long double> xs(n),ys(n);\n        rep(i,0,n) cin >> xs[i] >> ys[i];\n\n        auto count=[&](const long double x,const long double y){\n            int res=0;\n            rep(i,0,n) if((xs[i]-x)*(xs[i]-x)+(ys[i]-y)*(ys[i]-y)<=1+eps) ++res;\n            return res;\n        };\n\n        int ans=0;\n        rep(i,0,2401){\n            const long double y=10.*i/2400;\n            rep(j,0,n){\n                const long double tmp=1-(ys[j]-y)*(ys[j]-y);\n                if(tmp<0) continue;\n                const long double x1=xs[j]-sqrtl(tmp),x2=xs[j]+sqrt(tmp);\n                ans=max({ans,count(x1,y),count(x2,y)});\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//Name: Circle and Points\n//Level: 3\n//Category: 幾何,円\n//Note:\n\n/*\n * 半径が固定なので，円周上に2点が乗っているときが境界状態．\n * すべての2点の組み合わせについて中心の来る場所（2点）を求め，内包判定を行う．\n * N=1のケースと，全ての点が互いに距離2以上離れているケースに注意．\n *\n * オーダーは O(N^3)．\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <utility>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nbool inCircle(const Point &p, const Point &center, double radius) {\n    double dist2 = norm(p-center);\n    double rad2 = radius*radius;\n    return dist2 < rad2+1e-9;\n}\n\nint check(const Point &center, const vector<Point> &points) {\n    const int N = points.size();\n    int cnt = 0;\n    for(int i = 0; i < N; ++i) {\n        if(inCircle(points[i], center, 1)) ++cnt;\n    }\n    return cnt;\n}\n\nint test(int a, int b, const vector<Point> &points) {\n    const Point v(points[a]-points[b]);\n    if(abs(v) >= 2) return 1;\n    const double hlen = abs(v)/2;\n\n    const double arg = acos(hlen);\n    const Point unit = v / abs(v);\n    return max(check(points[b] + unit*polar(1.0, arg), points), check(points[b] + unit*polar(1.0, -arg), points));\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        vector<Point> points(N);\n        for(int i = 0; i < N; ++i) {\n            cin >> points[i].real() >> points[i].imag();\n        }\n        int ans = 0;\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < i; ++j) {\n                ans = max(ans, test(i, j, points));\n            }\n        }\n        if(N == 1) ans = 1;\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\n// #define double long double\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-6;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nP readP() {\n    double x, y;\n    cin >> x >> y;\n    return P(x, y);\n}\n\n// rot p around q by theta (counter-clockwise)\nP rotP(P p, P q, double theta) {\n    p -= q;\n    double x = p.real(), y = p.imag();\n    p = P(x * cos(theta) - y * sin(theta), x * sin(theta) + y * cos(theta));\n    p += q;\n    return p;\n}\n\nP center(P p, P q) {\n    // P v = q - p;\n    // double theta = asin(abs(v) / 2);\n    // v *= (1 / abs(v));\n    // P u = rotP(v, p, theta);\n    // return p + u;\n\n    // P v = q - p;\n    // P h = v * P(0., 1.) / abs(v);\n    // return p + (v / 2.) + h;\n\n    P v = q - p;\n    P h = P(v.imag(), -v.real());\n    h /= abs(h);\n    h *= sqrt(1 - norm(v / 2.));\n    P c = p + (v / 2.) + h;\n    return c;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    while (cin >> n, n) {\n        vector<P> p(n);\n        rep(i, n) p[i] = readP();\n\n        int ans = 1;\n        rep(i, n) {\n            rep2(j, i + 1, n) {\n                if (i == j) continue;\n                if (norm(p[i] - p[j]) > 4. + EPS) continue;\n                rep(s, 2) {\n                    P c = (s ? center(p[i], p[j]) : center(p[j], p[i]));\n                    int cnt = 2;\n                    rep(k, n) {\n                        if (k == i || k == j) continue;\n                        if (norm(p[k] - c) < 1. + EPS) {\n                            cnt++;\n                        }\n                    }\n                    ans = max(ans, cnt);\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#define EPS 10e-6\nusing namespace std;\ntypedef complex<double> xy_t;\nint n;\nxy_t points[301];\nint count_in(xy_t center)\n{\n  int ans=0;\n  for(int i=0;i<n;i++)\n  {\n    if (abs(center-points[i])<1.0+EPS)\n      ans++;\n  }\n  return ans;\n}\nxy_t ppdcl(xy_t a)\n{\n  return xy_t(a.imag(),-a.real());\n}\nxy_t delta_v(xy_t C1,xy_t C2)\n{\n  xy_t half=(C1-C2)*0.5;\n  double l=abs(half);\n  return ppdcl(half)*sqrt(1-l*l)*(1.0/l);\n}\nint main()\n{\n  while(1)\n  {\n    cin>>n;\n    if (n==0) break;\n    double x,y;\n    for(int i=0;i<n;i++)\n    {\n      cin>>x>>y;\n      points[i]=xy_t(x,y);\n    }\n    int maxn=-1;\n    for(int i=0;i<n;i++)\n    {\n      for(int j=i+1;j<n;j++)\n      {\n        if(abs(points[i]-points[j])<2.0+EPS)\n        {\n          xy_t mid_p=(points[i]+points[j])*0.5;\n          maxn=max(maxn,count_in(mid_p+delta_v(points[i],points[j])));\n          maxn=max(maxn,count_in(mid_p-delta_v(points[i],points[j])));\n        }\n      }\n    }\n    cout<<maxn<<endl;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <iterator>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst double EPS=1e-10;\n\nstruct Square{\n\tdouble x,y,d,n;\n\tSquare(){}\n\tSquare(double x,double y,double d,int n):x(x),y(y),d(d),n(n){}\n\tbool operator<(const Square& s)const{return n<s.n;}\n\tbool operator>(const Square& s)const{return n>s.n;}\n};\n\ninline double myhypot(double x,double y)\n{\n\treturn sqrt(x*x+y*y);\n}\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tvd xs(n),ys(n);\n\t\trep(i,n)\n\t\t\tcin>>xs[i]>>ys[i];\n\t\tdouble xmin=*min_element(allof(xs));\n\t\tdouble xmax=*max_element(allof(xs));\n\t\tdouble ymin=*min_element(allof(ys));\n\t\tdouble ymax=*max_element(allof(ys));\n\t\tpriority_queue<Square> pq;\n\t\tpq.push(Square((xmin+xmax)/2,(ymin+ymax)/2,max(xmax-xmin,ymax-ymin)/2,n));\n\t\tint res=1;\n\t\twhile(!pq.empty()){\n\t\t\tSquare s=pq.top(); pq.pop();\n\t\t\tif(s.n<=res)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint temp=0;\n\t\t\trep(i,n)\n\t\t\t\tif(myhypot(xs[i]-s.x,ys[i]-s.y)<1+EPS)\n\t\t\t\t\ttemp++;\n\t\t\tres=max(res,temp);\n\t\t\t\n\t\t\tif(s.d<1e-5)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tdouble nd=s.d/2;\n\t\t\tdouble nx[]={s.x-nd,s.x-nd,s.x+nd,s.x+nd};\n\t\t\tdouble ny[]={s.y-nd,s.y+nd,s.y-nd,s.y+nd};\n\t\t\trep(k,4){\n\t\t\t\tdouble x=nx[k],y=ny[k];\n\t\t\t\ttemp=0;\n\t\t\t\trep(i,n){\n\t\t\t\t\tif(myhypot(x-xs[i],y-ys[i])<nd*sqrt(2)+1+EPS)\n\t\t\t\t\t\ttemp++;\n\t\t\t\t}\n\t\t\t\tif(temp>res)\n\t\t\t\t\tpq.push(Square(x,y,nd,temp));\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nconst double eps=1e-8;\ntypedef pair<double,double> p;\n\ndouble dist(p a, p b)\n{\n    return sqrt((a.fi-b.fi)*(a.fi-b.fi)+(a.se-b.se)*(a.se-b.se));\n}\n\ndouble size(p a)\n{\n    return sqrt(a.fi*a.fi+a.se*a.se);\n}\n\nint main()\n{\n    int n;\n    while(cin >>n,n)\n    {\n        vector<p> v(n);\n        rep(i,n) scanf(\" %lf %lf\", &v[i].fi, &v[i].se);\n\n        int ans=0;\n        //select 2 points\n        rep(i,n)rep(j,i)\n        {\n            double d=dist(v[i],v[j]);\n            if(d>2.0) continue;\n\n            double r=sqrt(1.0 - (d*d/4.0));\n\n            double X=v[j].fi-v[i].fi, Y=v[j].se-v[i].se;\n\n            p v1=p(X,Y);\n            double v1size=size(v1);\n            v1.fi/=v1size; v1.se/=v1size;\n            v1.fi*=d/2; v1.se*=d/2;\n\n            p v2;\n            double v2size;\n            p c;\n\n            //2 candidate for center of circle\n            int ct=0;\n            v2=p(-Y,X);\n\n            v2size=size(v2);\n            v2.fi/=v2size; v2.se/=v2size;\n            v2.fi*=r; v2.se*=r;\n            c.fi=v[i].fi+v1.fi+v2.fi; c.se=v[i].se+v1.se+v2.se;\n            //printf(\"c =%lf,%lf\\n\",c.fi,c.se);\n            rep(k,n)\n            {\n                if(k==i || k==j) ++ct;\n                else\n                {\n                    if(dist(c,v[k])<1.0) ++ct;\n                }\n            }\n            ans=max(ans,ct);\n\n            ct=0;\n            v2=p(Y,-X);\n            v2size=size(v2);\n            v2.fi/=v2size; v2.se/=v2size;\n            v2.fi*=r; v2.se*=r;\n\n            c.fi=v[i].fi+v1.fi+v2.fi; c.se=v[i].se+v1.se+v2.se;\n            rep(k,n)\n            {\n                if(k==i || k==j) ++ct;\n                else\n                {\n                    if(dist(c,v[k])<1.0) ++ct;\n                }\n            }\n            ans=max(ans,ct);\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n\n/*\ncout<<fixed<<setprecision(20);\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-7;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\ndouble dis(double ax,double ay,double bx,double by){return (ax-bx)*(ax-bx)+(ay-by)*(ay-by);}\nint count_num(vector<double>&zX,vector<double>&zY,double x,double y){\n\tint i,n,ans=0;n=zX.size();\n\tfor(i=0;i<n;i++){\n\t\tif(dis(zX[i],zY[i],x,y)<=1+eps){ans++;}\n\t}\n\treturn ans;\n}\nbool solve(void){\n\tint i,j,n,ans=0;cin>>n;\n\tif(n==0){return false;}\n\tvector<double>zX(n);\n\tvector<double>zY(n);\n\tfor(i=0;i<n;i++){cin>>zX[i]>>zY[i];}\n\tfor(i=0;i<n;i++){maxeq(ans,count_num(zX,zY,zX[i],zY[i]));}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=i+1;j<n;j++){\n\t\t\tdouble kyo=sqrt(dis(zX[i],zY[i],zX[j],zY[j]));\n\t\t\tif(kyo>=2){continue;}\n\t\t\tdouble cx=(zX[i]+zX[j])/2;\n\t\t\tdouble cy=(zY[i]+zY[j])/2;\n\t\t\tdouble wari=sqrt(4-kyo*kyo)/kyo;\n\t\t\tmaxeq(ans,count_num(zX,zY,cx+wari*(cy-zY[i]),cy-wari*(cx-zX[i])));\n\t\t\tmaxeq(ans,count_num(zX,zY,cx-wari*(cy-zY[i]),cy+wari*(cx-zX[i])));\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn true;\n}\nint main(void){\n\twhile(solve()){}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1000000000\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint median_Point(Point a,Point b){\n  Vector v=a-b;\n  return b+(v/2);\n}\n\nPoint PointRotation(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\nvector<Point> vp;\nint ans;\nint n;\n\npair<Circle,Circle> makeCircle(Point a,Point b){\n  Point m=median_Point(a,b);\n  double d=sqrt(1-abs(m-b)*abs(m-b));\n  Vector v=(PointRotation(m,a,90)-m)*(d/abs(m-a));\n  Point A=m+v,B=m-v;\n  return mp(Circle(A,1),Circle(B,1));\n}\n\nint PointsInCircle(Circle C)\n{\n  int num=0;\n  for(int i=0;i<n;i++){\n    if(abs(vp[i]-C.c)<=1+eps)num++;\n  }\n  return num;\n}\n\nint main()\n{\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    vp.clear();\n    vp.resize(n);\n    for(int i=0;i<n;i++)cin>>vp[i].x>>vp[i].y;\n    ans=1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i==j)continue;\n\tif(2<abs(vp[i]-vp[j]))continue;\n\tpair<Circle,Circle> pc=makeCircle(vp[i],vp[j]);\n\tans=max(ans,PointsInCircle(pc.f));\n\tans=max(ans,PointsInCircle(pc.s));\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\nclass Line {\npublic:\n\tPoint a, b;\n};\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2 * d);\n\tld dfr = c1.r*c1.r - rc * rc;\n\tif (abs(dfr) < eps)dfr = 0.0;\n\tif (dfr < 0.0)return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0)res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\nld dis(Point x, Point y) {\n\treturn sqrt(dot(y - x, y - x));\n}\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tPoint a[300];\n\t\trep(i, n) {\n\t\t\tld x, y; cin >> x >> y; a[i] = { x,y };\n\t\t}\n\t\tint ma = 1;\n\t\trep(i, n) {\n\t\t\tRep(j, i + 1, n) {\n\t\t\t\tCircle s = { a[i],(ld)1.0 };\n\t\t\t\tCircle t = { a[j],(ld)1.0 };\n\t\t\t\tvector<Point> v = is_cc(s, t);\n\t\t\t\trep(l, (int)v.size()) {\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\trep(k, n) {\n\t\t\t\t\t\tif (dis(a[k], v[l]) <= (ld)1.0 + eps)cnt++;\n\t\t\t\t\t}\n\t\t\t\t\tma = max(ma, cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ma << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\ntypedef complex<double> pt;\ntypedef pair<pt,pt> L;\ntypedef vector<P> poly;\nconst double EPS = 1e-11;\n#define x real()\n#define y imag()\n \ndouble dot(pt a,pt b){\n\treturn (conj(a)*b).x;\n}\ndouble cross(pt a,pt b){\n\treturn (conj(a)*b).y;\n}\nint ccw(pt a,pt b,pt c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > EPS) return 1; // counter clockwise\n\tif(cross(b,c) < -EPS) return -1; // clockwise\n\tif(dot(b,c) < -EPS) return 2; //c-a-b\n\tif(norm(b) < norm(c)) return -2; //a-b-c\n\treturn 0; //a-c-b\n}\nbool cmp(const pt& a,const pt& b){\n\tif(-EPS < a.x-b.x && a.x-b.x < EPS) return a.y < b.y;\n\telse return a.x < b.x;\n}\nvector<pt>convex_hull(vector<pt>ps)\n{\n\tsort(ps.begin(),ps.end(),cmp);\n\tint k=0,n = ps.size();\n\tvector<pt>qs(n*2);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\twhile(k>1 && ccw(qs[k-2],qs[k-1],ps[i]) == -1) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tfor(int i=n-2,t=k;i>=0;i--)\n\t{\n\t\twhile(k>t && ccw(qs[k-2],qs[k-1],ps[i]) == -1) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\npt intersect(pt a,pt b,pt c,pt d){\n\tdouble dev = (b.y-a.y)*(d.x-c.x)-(b.x-a.x)*(d.y-c.y);\n\t\n\tdouble d1, d2;\n \n\td1 = (c.y*d.x-c.x*d.y);\n\td2 = (a.y*b.x-a.x*b.y);\n \n\tpt ap1;\n\tap1.x = d1*(b.x-a.x) - d2*(d.x-c.x);\n\tap1.x /= dev;\n\tap1.y = d1*(b.y-a.y) - d2*(d.y-c.y);\n\tap1.y /= dev;\n \n\treturn ap1;\n}\nbool par(pt a,pt b,pt c,pt d){\n\tb.x -= a.x; b.y -= a.y;\n\td.x -= c.x; d.y -= c.y;\n\tif(abs(b.y*d.x - b.x*d.y) < EPS){\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(1){\n\t\tint n; scanf(\"%d\",&n); if(!n) return 0; if(n==1){ puts(\"1\"); continue;}\n\t\tpt p[305];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tdouble a,b; scanf(\"%lf%lf\",&a,&b);\n\t\t\tp[i] = pt(a,b);\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=i+1;j<=n;j++){\n\t\t\t\tpt q = (p[i]+p[j])/2.0;\n\t\t\t\tpt r = (p[i]-p[j]); if(abs(r) > 2.0+EPS) continue;\n\t\t\t\tpt p1 = q + r / abs(r) * pt(0,sqrt(1.0-abs(r)*abs(r)/4.0));\n\t\t\t\tpt p2 = q - r / abs(r) * pt(0,sqrt(1.0-abs(r)*abs(r)/4.0));\n\t\t\t\tint c=0,d=0;\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tif(abs(p1-p[k]) <= 1.0+EPS) c++;\n\t\t\t\t\tif(abs(p2-p[k]) <= 1.0+EPS) d++;\n\t\t\t\t}\n\t\t\t\tans = max(ans,max(c,d));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<stack>\n#include<string>\n#include<bitset>\n#include<random>\n#include<time.h>\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-7\n#define REP(i,m) for(long long i=0; i<(ll)m; i++)\n#define FOR(i,n,m) for(long long i=n; i<(ll)m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nstruct Po {\n\tld x;\n\tld y;\n};\n\nld dist(Po p, Po q) {\n\treturn sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2));\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile(1) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tvector<Po> p(n);\n\t\tREP(i,n) cin>>p[i].x>>p[i].y;\n\t\tll ans=1;\n\t\tREP(i,n) {\n\t\t\tFOR(j,i+1,n) {\n\t\t\t\tld d=dist(p[i],p[j]);\n\t\t\t\t//cout<<i<<\" \"<<j<<\":\"<<d<<endl;\n\t\t\t\tif(d>2) continue;\n\t\t\t\tPo diff; diff.x=p[j].x-p[i].x; diff.y=p[j].y-p[i].y;\n\t\t\t\tdiff.x/=d; diff.y/=d;\n\t\t\t\tld th=acos(d/2);\n\t\t\t\t//cout<<th<<endl;\n\t\t\t\tPo c1=p[i],c2=p[i];\n\t\t\t\tc1.x+=cos(th)*diff.x-sin(th)*diff.y;\n\t\t\t\tc1.y+=sin(th)*diff.x+cos(th)*diff.y;\n\t\t\t\tc2.x+=cos(-th)*diff.x-sin(-th)*diff.y;\n\t\t\t\tc2.y+=sin(-th)*diff.x+cos(-th)*diff.y;\n\t\t\t\t//cout<<c1.x<<\" \"<<c1.y<<\" \"<<dist(p[i],c1)<<\" \"<<dist(p[j],c1)<<endl;\n\t\t\t\t//cout<<c2.x<<\" \"<<c2.y<<\" \"<<dist(p[i],c2)<<\" \"<<dist(p[j],c2)<<endl;\n\t\t\t\tll cnt1=0,cnt2=0;\n\t\t\t\tREP(k,n) {\n\t\t\t\t\tif(dist(p[k],c1)<=1+EPS) cnt1++;\n\t\t\t\t\tif(dist(p[k],c2)<=1+EPS) cnt2++;\n\t\t\t\t}\n\t\t\t\tans=max({ans,cnt1,cnt2});\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst double PI=acos(-1);\nconst double EPS=1e-6;\n\nint N;\ndouble x[333],y[333];\n\nsigned main(){\n    while(cin>>N,N){\n        rep(i,N)cin>>x[i]>>y[i];\n\n        int ma=1;\n        rep(i,N)rep(j,N){\n            if(i==j)continue;\n            double dx=x[i]-x[j],dy=y[i]-y[j];\n            double d=sqrt(dx*dx+dy*dy);\n            if(d>2+EPS)continue;\n            double r=sqrt(1.0-d*d/4);\n            double vx=-dy/d*r;\n            double vy=dx/d*r;\n\n            double xx=(x[i]+x[j])/2+vx;\n            double yy=(y[i]+y[j])/2+vy;\n            int cnt=0;\n            rep(k,N){\n                if((x[k]-xx)*(x[k]-xx)+(y[k]-yy)*(y[k]-yy)<1.0+EPS)cnt++;\n            }\n            chmax(ma,cnt);\n        }\n        printf(\"%lld\\n\",ma);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ndouble x[300], y[300];\nint n;\n\nint count(double x0, double y0, int p, int q){\n\tint ret = 2;\n\tREP(i,n){\n\t\tif(i==p||i==q)continue;\n\t\tdouble dx = x0-x[i];\n\t\tdouble dy = y0-y[i];\n\t\tif(pow(dx, 2.0)+pow(dy, 2.0)<1.0)ret++;\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(1){\n\t\tint ret = 1;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tREP(i,n)scanf(\"%f %f\", &x[i],&y[i]);\n\t\tREP(i,n){\n\t\t\tFOR(j, i+1,n){\n\t\t\t\tdouble dx = x[j]-x[i];\n\t\t\t\tdouble dy = y[j]-y[i];\n\t\t\t\tdouble d = sqrt(pow(dx, 2.0)+pow(dy, 2.0));\n\t\t\t\tif(d < 2.0){\n\t\t\t\t\tdouble mx = (x[j]+x[i])*0.5;\n\t\t\t\t\tdouble my = (y[j]+y[i])*0.5;\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble x1 = mx-dy/d*sqrt(1.0-d*d/4.0);\n\t\t\t\t\t\tdouble y1 = my+dx/d*sqrt(1.0-d*d/4.0);\n\t\t\t\t\t\tret = max(ret, count(x1, y1, i, j));\n\t\t\t\t\t}\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble x1 = mx+dy/d*sqrt(1.0-d*d/4.0);\n\t\t\t\t\t\tdouble y1 = my-dx/d*sqrt(1.0-d*d/4.0);\n\t\t\t\t\t\tret = max(ret, count(x1, y1, i, j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#define EPS 10e-6\nusing namespace std;\ntypedef complex<double> xy_t;\nint n;\nxy_t points[301];\nint count_in(xy_t center)\n{\n  int ans=0;\n  for(int i=0;i<n;i++)\n  {\n    if (abs(center-points[i])<=1+EPS)\n      ans++;\n  }\n  return ans;\n}\nxy_t ppdcl(xy_t a)\n{\n  return xy_t(a.imag(),-a.real());\n}\nxy_t delta_v(xy_t C1,xy_t C2)\n{\n  xy_t half=(C1-C2)*0.5;\n  double l=abs(half);\n  return ppdcl(half)*sqrt(1-l*l)*(1/l);\n}\nint main()\n{\n  while(1)\n  {\n    cin>>n;\n    if (n==0) break;\n    double x,y;\n    for(int i=0;i<n;i++)\n    {\n      cin>>x>>y;\n      points[i]=xy_t(x,y);\n    }\n    int maxn=-1;\n    for(int i=0;i<n;i++)\n    {\n      for(int j=i+1;j<n;j++)\n      {\n        if(abs(points[i]-points[j])<=4+EPS)\n        {\n          xy_t mid_p=(points[i]+points[j])*0.5;\n          maxn=max(maxn,count_in(mid_p+delta_v(points[i],points[j])));\n          maxn=max(maxn,count_in(mid_p-delta_v(points[i],points[j])));\n        }\n      }\n    }\n    cout<<maxn<<endl;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\n#define MAX_N 310\n\ndouble x[MAX_N], y[MAX_N];\nint n, maxn;\n\nint main() {\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tmaxn = 1;\n\t\tfor (double i = -10; i <= 10; i += 0.02) {\n\t\t\tfor (double j = -10; j <= 10; j += 0.02) {\n\t\t\t\tdouble X = i, Y = j;\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (((x[k] - X)*(x[k] - X) + (y[k] - Y)*(y[k] - Y)) <= 1) { sum++; }\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\t\t\t}\n\t\t}\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef complex<double> P;\n\nconst double EPS = 1e-8;\n\nint main()\n{\n\tint n;\n\twhile(scanf(\"%d\", &n), n){\n\t\tP p[300];\n\t\trep(i, n)\n\t\t\tscanf(\"%lf%lf\", &p[i].real(), &p[i].imag());\n\n\t\tint ans = 1;\n\t\trep(i, n) rep(j, i){\n\t\t\tdouble l = 1.0 - norm(p[i]-p[j])/4.0;\n\t\t\tif(l < 0.0)\n\t\t\t\tcontinue;\n\t\t\tl = sqrt(l);\n\n\t\t\tP center = (p[i] + p[j]) / 2.0;\n\t\t\tP ll = l * (p[i] - p[j])/abs(p[i] - p[j]) * P(0.0, 1.0);\n\t\t\tP c[] = {center+ll, center-ll};\n\t\t\trep(k, 2){\n\t\t\t\tint cnt = 0;\n\t\t\t\trep(m, n){\n\t\t\t\t\tif(norm(c[k] - p[m]) <= 1.0 + EPS)\n\t\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t\tans = max(ans, cnt);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define EPS 1.0e-4\nusing namespace std;\n\ntypedef struct {\n  double x,y;\n} P;\n\ndouble dis(P p ){\n  return sqrt( p.x*p.x + p.y*p.y );\n}\ndouble dis(P p1,P p2 ){\n  P p;\n  p.x = p1.x-p2.x;\n  p.y = p1.y-p2.y;\n  return dis( p );\n}\n\n\nint main(){\n  int n, mx;\n  // mv : @üxNg\n  P p[301], m, p1,p2, mv,dmv, c[2];\n  double x;\n\n  while( cin>>n && n ){\n    for( int i=0;i<n;i++ )\n      cin >> p[i].x >> p[i].y ;\n\n    mx=0;\n\n    for( int i=0;i<n;i++ ){\n      for( int j=i+1;j<n;j++ ){\n\tif( dis(p[i],p[j]) < 2.0 + EPS ){\n\t  p1=p[i]; p2=p[j];\n\t  m.x = (p1.x+p2.x)/2.0;\n\t  m.y = (p1.y+p2.y)/2.0;\n\n\t  x = sqrt( 1-dis(p1,m) );\n\t  // S_ cðßé\n\t  if( fabs( p1.y-p2.y ) < EPS ){\n\t    mv.x=1.0;  mv.y=0.0;\n\t  }else if( fabs( p1.x-p2.x ) < EPS ){\n\t    mv.x=0.0;  mv.y=1.0;\n\t  }else{\n\t    double a1 = ( p2.y-p1.y )/( p2.x-p1.x );\n\t    mv.x=1.0; mv.y=-1.0/a1;\n\t  }\n\t  double scale = dis( mv );\n\t  dmv.x = x*mv.x / scale;\n\t  dmv.y = x*mv.y / scale;\n\n\t  c[0].x=m.x+dmv.x; c[0].y=m.y+dmv.y;\n\t  c[1].x=m.x-dmv.x; c[2].y=m.y-dmv.y;\n\n\t  cout << \"m  \" << m.x    << \",\" << m.y    << endl;\n\t  cout << \"c0 \" << c[0].x << \",\" << c[0].y << endl;\n\t  cout << \"c1 \" << c[1].x << \",\" << c[1].y << endl;\n\n\n\t  for( int cn=0;cn<2;cn++ ){\n\t    int sum=0;\n\t    for( int k=0;k<n;k++ ){\n\t      if( dis( c[cn],p[k] ) < 1.0 + EPS )\n\t\tsum++;\n\t    }\n\t    if( mx<sum ) mx=sum;\n\t  }\n\t}\n      }\n    }\n    cout << mx << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n#include <complex>\ntypedef complex<double> Point;\nconst double EPS = 1e-8;\n\n// テ・ツ?・テ・ツ環崚」ツつケテ」ツδ暗」ツδェテ」ツδシテ」ツδ?」ツ?凝」ツつ嘉・ツョツ淌ヲツ閉ーテ、ツコツ古」ツ?、テ」ツつ津」ツ?ィテ」ツ?」テ」ツ?ヲ Point テ」ツ?ク\nistream& operator >> ( istream &s, Point &a )\n{\n\tdouble r, i;\n\ts >> r >> i;\n\ta = Point( r, i );\n\treturn s;\n}\n\n// テ・ツ債佚、ツスツ催」ツδ凖」ツつッテ」ツδ暗」ツδォ\nPoint unitVector( const Point &a )\n{\n\treturn a / abs( a );\n}\n\n// テヲツウツ陛ァツキツ堙」ツδ凖」ツつッテ」ツδ暗」ツδォ\nPoint normalVector1( const Point &a )\n{\n\treturn a * Point( 0, 1 );\n}\nPoint normalVector2( const Point &a )\n{\n\treturn a * Point( 0, -1 );\n}\nPoint ( *normalVectors[] )( const Point& ) = { normalVector1, normalVector2 };\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int n; cin >> n, n; )\n\t{\n\t\tvector<Point> ps( n );\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tcin >> ps[i];\n\t\t}\n\n\t\tint res = 1;\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tREP( j, 0, i )\n\t\t\t{\n\t\t\t\tconst Point &a = ps[i], &b = ps[j];\n\t\t\t\tif ( 2 + EPS < abs( a - b ) )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tREP( k, 0, 2 )\n\t\t\t\t{\n\t\t\t\t\tconst Point c = ( a + b ) / Point( 2, 0 ) + unitVector( normalVectors[k]( a - b ) ) * sqrt( 1 - pow( abs( a - b ) / 2., 2. ) );\n\t\t\t\t\tint tmp = 2;\n\t\t\t\t\tREP( l, 0, n )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( l == i || l == j )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp += abs( c - ps[l] ) <= 1. + EPS;\n\t\t\t\t\t}\n\t\t\t\t\tres = max( res, tmp );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <cmath>\n\nusing namespace std;\n\ntypedef pair<double,double> pos;\nconst double r = 1;\nconst double eps = 0.0001;\nint count(vector<pos> ps,double x,double y,int ban1,int ban2){\n\tint c=0;//2;\n\tfor(int i=0;i<ps.size();i++){\n\t\tif(//i!=ban1&&i!=ban2&&\n\t\t\t\tpow(ps[i].first-x,2)+pow(ps[i].second-y,2)<=pow(1.0+eps,2)){\n\t\t\tc++;\n\t\t}\n\t}\n\treturn c;\n}\n\nbool range(pos p1,pos p2,double r){\n\treturn pow(p1.first-p2.first,2)+pow(p1.second-p2.second,2) <= r*r;\n}\n\ndouble len(pos p){\n\treturn sqrt(pow(p.first,2)+pow(p.second,2));\n}\n\ndouble len2(pos p){\n\treturn (pow(p.first,2)+pow(p.second,2));\n}\n\nvector<pos> point2(pos p1,pos p2){\n\tpos m = make_pair((p1.first+p2.first)/2,(p1.second+p2.second)/2);\n\tpos vec = make_pair(p1.first-p2.first,p1.second-p2.second);\n\tpos q = m;//make_pair(p2.first+vec.first/2,p2.second+vec.second/2);\n\tdouble l = sqrt(1-pow(len(vec)/2.0,2));\n\tdouble ll = len(vec);\n\tpos vec2 = make_pair(-vec.second,vec.first);\n\tvec2.first=vec2.first/ll*l;\n\tvec2.second = vec2.second/ll*l;\n\tvector<pos> ret;\n\tret.push_back(make_pair(q.first+vec2.first,q.second+vec2.second));\n\tret.push_back(make_pair(q.first-vec2.first,q.second-vec2.second));\n\treturn ret;\n}\n\nint solve(vector<pos> ps){\n\tint mx=0;\n\tfor(int i=0;i<ps.size()-1;i++)\n\t\tfor(int k=i+1;k<ps.size();k++){\n\t\t\tif(range(ps[i],ps[k],2)){\n\t\t\t\t//cerr << \"*****\" << i << \" \" << k << endl;\n\t\t\t\tvector<pos> vp = point2(ps[i],ps[k]);\n\t\t\t\tmx = max(mx,count(ps,vp[0].first,vp[0].second,i,k));\n\t\t\t\tmx = max(mx,count(ps,vp[1].first,vp[1].second,i,k));\n\t\t\t}\n\t\t}\n\treturn mx;\n}\n\nint main(){\n\t//cerr << point2(make_pair(0,0),make_pair(1,1))[1].first << endl;\n\twhile(true){\n\t\tint n;\n\t\tvector<pos> v;\n\t\tcin >> n;\n\t\tif(n==0)return 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tv.push_back(make_pair(x,y));\n\t\t}\n\t\tcout << solve(v) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\n#define Sq(x) ((x)*(x))\n\n#define Foreach(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n\nconst double PI = M_PI;\nconst double EPS = 0.0001;\n\nstruct Point{\n  double x,y;\n\n  Point(){}\n  Point(double x, double y) : x(x), y(y) {}\n};\n\nPoint operator+(const Point &a, const Point &b){\n  return Point(a.x + b.x, a.y + b.y);\n}\n\nPoint operator-(const Point &a, const Point &b){\n  return Point(a.x - b.x, a.y - b.y);\n}\n\nPoint operator*(const Point &a, const double k){\n  return Point(a.x * k, a.y * k);\n}\n\nPoint operator*(const Point &a,const Point &b){\n  return Point(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\n\nPoint operator/(const Point &p, const double k){\n  return Point(p.x / k, p.y / k);\n}\n\ndouble dot(const Point &a, const Point &b){\n  return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Point &a, const Point &b){\n  return a.x * b.y - a.y * b.x;\n}\n\ndouble norm(const Point &p){\n  return dot(p, p);\n}\n\ndouble abs(const Point &p){\n  return sqrt(norm(p));\n}\n\ntypedef Point Vector;\n\nstruct Circle : Point{\n  double r;\n  Circle(Point p = Point(0,0), double r = 0) : Point(p), r(r) {}\n};\n\ndouble distPP(const Point &a, const Point &b) {\n  return sqrt(Sq(a.x-b.x) + Sq(a.y-b.y));\n}\n\nbool isPointInCircle(const Point &p, const Circle &c) {\n  return abs(p - c) <= c.r + EPS;\n}\n\nPoint rotate90(const Point &p) {\n  return Point(-p.y, p.x);\n}\n\n/* テ・ツソツ?ィツヲツ?」ツ?ェテ」ツ?凝」ツ?」テ」ツ??*/\nvector<Point> getCrossPointCC_R1(const Circle &c1, const Circle &c2) {\n  vector<Point> ret;\n\n  double dist = abs( c1 - c2 );\n  if( abs( c1 - c2 ) < EPS || abs( c1 + c2 ) > dist ) return vector<Point>();\n  \n  Point cent = ( c1 + c2 ) / 2;\n  \n  Vector v1 = c1 - cent;\n  Vector v2 = rotate90(v1);\n  ret.push_back(cent + v1);\n\n  v1 = c2 - cent;\n  v2 = rotate90(v2);\n  ret.push_back(cent + v2);\n\n  return ret;\n}\n\n/*\nテ」ツ??」ツ?セテ」ツ?湘・ツ仰陛」ツ?凝」ツ?ェテ」ツ??\nPoint rotateVector(const Vector &p, double th) {\n  return Point(p.x * cos(th) - p.y*sin(th), p.x * sin(th) + p.y * cos(th));\n}\n*/\n\nint main() {\n  int n;\n  Point p[300];\n  \n  while(cin >> n && n) {\n    for(int i=0; i<n; i++) {\n      cin >> p[i].x >> p[i].y;\n    }\n    \n    int ans = 1;\n    for(int i=0; i<n-1; i++) {\n      for(int j=i+1; j<n; j++) {\n\tif(distPP(p[i], p[j]) + EPS > 2.0) continue;\n\t\n\tPoint cent((p[i]+p[j])/2);\n\tdouble a = distPP(p[i], cent);\n\tdouble b = sqrt(1.0 - a*a);\n\t\n\tVector v1 = p[i] - cent;\n\tVector v2 = rotate90(v1);\n\tPoint center = cent + ((v2/abs(v2)) * b);\n\tCircle c1(center, 1.0);\n\tint cnt = 0;\n\tfor(int k=0; k<n; k++) {\n\t  cnt += isPointInCircle(p[k], c1);\n\t}\n\tans = max(ans, cnt);\n\t\n\tcenter = cent + ((v2/abs(v2)) * -b);\n\tCircle c2(center, 1.0);\n\tcnt = 0;\n\tfor(int k=0; k<n; k++) {\n\t  cnt += isPointInCircle(p[k], c2);\n\t}\n\tans = max(ans, cnt);\n      }\n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        vector<long double> xs(n),ys(n);\n        rep(i,0,n) cin >> xs[i] >> ys[i];\n\n        auto count=[&](const long double x,const long double y){\n            int res=0;\n            rep(i,0,n) if((xs[i]-x)*(xs[i]-x)+(ys[i]-y)*(ys[i]-y)<=1+eps) ++res;\n            return res;\n        };\n\n        int ans=0;\n        rep(i,0,2001){\n            const long double y=10.*i/2000;\n            rep(j,0,n){\n                const long double tmp=1-(ys[j]-y)*(ys[j]-y);\n                if(tmp<0) continue;\n                const long double x1=xs[j]-sqrtl(tmp),x2=xs[j]+sqrt(tmp);\n                ans=max({ans,count(x1,y),count(x2,y)});\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> pt;\n#define rep(i,n) for(int i=0;i<n;i++)\nint n;\npt z[305];\nint check(pt C){\n\tint ret = 0;\n\trep(i,n){\n\t\tif(abs(z[i]-C) <= 1.0+1e-12) ret++;\n\t}\n\tassert(ret>=2);\n\treturn ret;\n}\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0) return 0;\n\t\trep(i,n){\n\t\t\tdouble x,y; scanf(\"%lf%lf\",&x,&y);\n\t\t\tz[i] = pt(x,y);\n\t\t}\n\t\tint ans = 1;\n\t\trep(i,n) for(int j=i+1;j<n;j++){\n\t\t\tif(abs(z[i]-z[j]) > 2.0+1e-12) continue;\n\t\t\tpt mid = (z[i]+z[j])/2.0;\n\t\t\tdouble leng = sqrt(1.0-abs(z[i]-z[j])*abs(z[i]-z[j])/4.0);\n\t\t\tpt c1 = mid + (z[i]-z[j])/abs(z[i]-z[j]) * polar(leng,3.141592653589/2.0);\n\t\t\tpt c2 = mid - (z[i]-z[j])/abs(z[i]-z[j]) * polar(leng,3.141592653589/2.0);\n\t\t\tans = max(ans,check(c1));\n\t\t\tans = max(ans,check(c2));\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#define EPS 1e-8\nusing namespace std;\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\n\nbool equidistantpoint(const P& a, const P& b, double r, vector<P>& ep){\n    if(abs(b-a)>r*2+EPS) return false;\n    P mid = (a+b)/P(2,0);\n    P len = P(sqrt(r*r-norm(b-mid)),0);\n    P rot = P((b-a).Y,(a-b).X) / P(abs(b-a),0);\n    ep.resize(2);\n    ep[0] = len*rot + mid;\n    ep[1] = -len*rot + mid;\n    return true;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        vector<P> pset(n);\n        for(int i=0; i<n; i++){\n            double x,y;\n            cin >> x >> y;\n            pset[i] = P(x,y);\n        }\n\n        int mnop=0;\n        for(int i=0; i<n-1; i++){\n            for(int j=i+1; j<n; j++){\n                vector<P> endpoints;\n                bool ret = equidistantpoint(pset[i], pset[j], 1, endpoints);\n                if(!ret)continue;\n                for(int lr=0; lr<2; lr++){\n                    int count=0;\n                    for(int k=0; k<n; k++){\n                        if(abs(pset[k]-endpoints[lr]) < 1+EPS){\n                            count++;\n                        }\n                    }\n                    mnop = max(mnop, count);\n                }\n            }\n        }\n\n        if(mnop==0) mnop=1;\n        cout << mnop << endl;\n    }\n            \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <functional>\n#include <ctime>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n#define all(c) ((c).begin()), ((c).end())\n#define TEST(x,a) { auto y=(x); if (sign(y-a)) { cout << \"line \" << __LINE__  << #x << \" = \" << y << \" != \" << a << endl; exit(-1); } }\ndouble urand() { return rand() / (1.0 + RAND_MAX); }\n\nconst double PI = acos(-1.0);\n\n// implementation note: use EPS only this function\n// usage note: check sign(x) < 0, sign(x) > 0, or sign(x) == 0\n// notice: should be normalize to O(1)\nconst double EPS = 1e-8;\nint sign(double x) {\n  if (x < -EPS) return -1;\n  if (x > +EPS) return +1;\n  return 0;\n}\nstruct point {\n  typedef double T;\n  T x, y; \n  point &operator+=(point p) { x += p.x; y += p.y; return *this; }\n  point &operator-=(point p) { x -= p.x; y -= p.y; return *this; }\n  point &operator*=(T a)     { x *= a;   y *= a;   return *this; }\n  point &operator/=(T a)     { return *this *= (1.0/a); }\n  point operator-() const    { return {-x, -y}; }\n  bool operator==(point p) const { return !sign(x-p.x) && !sign(y-p.y); }\n  bool operator!=(point p) const { return !operator==(p); }\n  bool operator<(point p) const { return x!=p.x ? x<p.x : y<p.y; } // for sort\n};\npoint operator+(point p, point q) { return p += q; }\npoint operator-(point p, point q) { return p -= q; }\npoint operator*(point::T a, point p) { return p *= a; }\npoint operator*(point p, point::T a) { return p *= a; }\npoint operator/(point p, point::T a) { return p /= a; }\npoint::T dot(point p, point q) { return p.x*q.x+p.y*q.y; }\npoint::T cross(point p, point q) { return p.x*q.y-p.y*q.x; } // left turn > 0\npoint::T norm2(point p) { return dot(p,p); }\npoint::T norm(point p) { return sqrt(dot(p,p)); }\npoint::T dist(point p, point q) { return norm(p-q); }\npoint orth(point p) { return {-p.y, p.x}; }\n\nistream &operator>>(istream &is, point &p) { is>>p.x>>p.y;return is; }\nostream &operator<<(ostream &os, const point &p) { os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; return os; }\n\nint maximum_circle_cover(vector<point> ps, double r) {\n  struct range {\n    point p; // center\n    double w; // width\n    int hi;\n    bool operator<(range r) const {\n      return hi < r.hi;\n    }\n  };\n  double w = 0;\n  for (point p: ps) w = max({w, abs(p.x), abs(p.y)});\n  priority_queue<range> que;\n  que.push({{0,0}, w, (int)ps.size()});\n  point best_p;\n  int best = 0;\n  while (!que.empty()) {\n    range R = que.top(); que.pop();\n    if (R.hi <= best) continue;\n    //cout << \"processing \" << R.p << \" \" << R.w << \" \" << R.hi << \"/\" << best << endl;\n    double dx[] = {1,-1,-1,1}, dy[] = {1,1,-1,-1};\n    for (int i = 0; i < 4; ++i) {\n      range S = {R.p, R.w/2, 0};\n      S.p += S.w*point({dx[i], dy[i]});\n      int lo = 0;\n      for (point q: ps) {\n        auto d = dist(S.p, q);\n        if (sign(d - r) <= 0) ++lo;\n        if (sign(d - S.w*sqrt(2) - r) <= 0) ++S.hi;\n      }\n      if (lo > best) { best = lo; best_p = S.p; }\n      best = max(lo, best);\n      if (S.hi > best) que.push(S);\n    }\n  }\n  return best; //best_p;\n}\nint maximum_circle_cover3(vector<point> ps, double r) {\n\n  point best_p;\n  int best = 0;\n  function<void(point,double,vector<point>&)> rec = [&](point p, double w, vector<point> &ps) {\n    w /= 2;\n    const double dx[] = {1,-1,-1,1}, dy[] = {1,1,-1,-1};\n    point qs[4];\n    vector<point> pss[4];\n    for (int i = 0; i < 4; ++i) {\n      qs[i] = p + w * point({dx[i], dy[i]});\n      int lo = 0;\n      for (point q: ps) {\n        auto d = dist(qs[i], q);\n        if (sign(d - r) <= 0) ++lo;\n        if (sign(d - w*sqrt(2) - r) <= 0) pss[i].push_back(q);\n      }\n      if (lo > best) { best = lo; best_p = qs[i]; }\n    }\n    int a = 0, b = 1, c = 2, d = 3;\n    auto SW = [&](int &a, int &b) { if (pss[a].size() > pss[b].size()) swap(a, b); };\n    SW(a,b);SW(c,d);SW(b,d);SW(a,c);SW(b,c);\n    if (pss[d].size() > best) rec(qs[d], w, pss[d]);\n    if (pss[b].size() > best) rec(qs[b], w, pss[b]);\n    if (pss[c].size() > best) rec(qs[c], w, pss[c]);\n    if (pss[a].size() > best) rec(qs[a], w, pss[a]);\n  };\n  double w = 0;\n  for (point p: ps) w = max({w, abs(p.x), abs(p.y)});\n  rec({0,0}, w, ps);\n  return best; //best_p;\n}\n\nint maximum_circle_cover2(vector<point> ps, double r) {\n  int best = 0;\n  for (point p: ps) {\n    int count = 0;\n    vector<pair<double,int>> aux;\n    for (point q: ps) {\n      auto d = dist(p, q);\n      if (sign(d) == 0) ++count;\n      else if (sign(d - 2*r) <= 0) {\n        double theta = atan2(q.y-p.y, q.x-p.x);\n        double phi   = acos(min(1., d/(2*r)));\n        aux.push_back({theta-phi, -1});\n        aux.push_back({theta+phi, +1});\n      }\n    }\n    sort(all(aux));\n    /*\n    cout << \"for point \" << p << endl;\n    for (auto a: aux) \n      cout << \"(\" << a.fst << \",\" << a.snd << \") \";\n    cout << endl;\n    */\n\n    for (auto a: aux) \n      best = max(best, count -= a.snd);\n  }\n  return best;\n}\n\n\nvoid verify_maximum_circle_cover2() {\n  for (int n; scanf(\"%d\", &n) && n; ) {\n    vector<point> ps(n);\n    for (int i = 0; i < n; ++i) \n      scanf(\"%lf %lf\", &ps[i].x, &ps[i].y);\n    printf(\"%d\\n\", maximum_circle_cover3(ps, 1.0));\n  }\n}\n\n\nint main() {\n  //verify_maximum_circle_cover();\n  verify_maximum_circle_cover2();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={-1,0,1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-15;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef pair<int,Pii> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x = _x;\n        y = _y;\n    }\n    Point operator + (Point p){\n        return Point(x+p.x,y+p.y);\n    }\n  \n    Point operator - (Point p){\n        return Point(x-p.x,y-p.y);\n    }\n  \n    Point operator * (double k){\n        return Point(k*x,k*y);\n    }\n     \n    Point operator * (Point p){\n        return Point(p.x*x-p.y*y,p.x*y+p.y*x);\n    }\n\n    Point operator / (double k){\n        return Point(x/k,y/k);\n    }\n \t\n    Point operator = (Point p){\n    \tx = p.x;\n    \ty = p.y;\n    \treturn *this;\n    }\n\n    bool operator<(const Point &p)const{\n        return x!=p.x?x<p.x:y<p.y;\n    }\n\n};\ndouble dot(Point p, Point q){\n    return p.x*q.x+p.y*q.y;\n}\n  \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n  \ndouble norm(Point p){\n\t//ベクトルの大きさの2乗\n    return p.x*p.x+p.y*p.y;\n}\n  \ndouble pabs(Point p){\n\t//ベクトルの大きさ\n    return sqrt(norm(p));\n}\nPoint UnitVector(Point a){\n\t//単位ベクトル\n\treturn a/pabs(a);\n}\ntypedef vector<Point> Polygon;\nstruct Line : Polygon{\n    Line(){}\n    Line(Point p,Point q){\n        PB(p);\n        PB(q);  \n    }\n};\nstruct Circle{\n    Point p; //中心点\n    double r; //半径\n    Circle(){}\n    Circle(Point _p,double _r){\n        p = _p;\n        r = _r;\n    }\n};\nint ccw(Point a,Point b,Point c){\n    b = b-a;\n    c = c-a;\n    if(cross(b,c) > 0)return +1; //a→b で反時計に折れてc ccw\n    if(cross(b,c) < 0)return -1; //a→b で時計に折れてc ccw\n    if(dot(b,c) < 0)return +2; // c--a--b;\n    if(pabs(b)<pabs(c))return -2; //a--b--c\n    return 0; //a--c--b\n}\nbool intersectSS(Line l,Line m){\n    //lとmが交差してるかどうか\n    return (ccw(l[0],l[1],m[0])*ccw(l[0],l[1],m[1])<EPS)&&\n            (ccw(m[0],m[1],l[0])*ccw(m[0],m[1],l[1])<EPS);\n}\n\nbool intersectSP(Line l, Point p){\n\t//線分lと点pが交差してるか\n\treturn !ccw(l[0],l[1],p);\n}\n\nbool intersectLL(Line l,Line m){\n\treturn fabs(cross(l[1]-l[0],m[1]-m[0])) > EPS || //平行でない\n\t\t\tfabs(cross(l[1]-l[0],m[0]-l[0])) < EPS; //同一の線\n}\n\nint intercectCC(Circle a,Circle b,Point *p,Point *q){\n\tdouble dist = pabs(a.p-b.p);\n\tif(dist < fabs(a.r-b.r) || dist > a.r+b.r){\n\t\t//円の中心が一致しているとき\n\t\t//円の交点が存在しないとき\n\t\t*p = Point(1e15,1e15);\n\t\t*q = Point(1e15,1e15);\n\t\treturn 0;\n\t}\n\telse if(fabs(dist-a.r-b.r) < EPS){\n\t\t//円が1点で交わっているとき\n\t\tPoint way;\n\t\tway = b.p-a.p;\n\t\t*p = a.p+UnitVector(way)*a.r;\n\t\t*q = *p;\n\t\treturn 1;\n\t}\n\telse{\n\t\t//円が2点で交わっているとき\n        if(a.r < b.r){\n            swap(a.r,b.r);\n            swap(a.p,b.p);\n        }\n        double s = (a.r + b.r + dist) / 2.0 ;\n        double area = sqrt(s * (s - a.r) * (s - b.r) * (s - dist));\n        double h = 2.0 * area / dist;\n\n        Point  v = b.p-a.p;\n        v = UnitVector(v);\n        Point  m = a.p + (v*sqrt(a.r*a.r-h*h));\n        Point  n = v * Point(0.0,1.0);\n        \n        *p = m + (n * h);\n        *q = m - (n * h);\n        return 2;\n\t}\n}\n\ndouble TriangleArea(Point a,Point b,Point c){\n    b = b - a;\n    c = c - a;\n    return cross(b,c)*0.5; //負になることもあるので注意\n}\n \ndouble VertexArea(Polygon v){\n    double subArea = 0.0;\n    rep(i,v.size()-1){\n        subArea += TriangleArea(v[0],v[i],v[i+1]);\n    }\n    return subArea; //負になることもあるので注意\n}\n\nPoint crosspoint(Line l,Line m){\n\t//線分lと線分mの交点\n    if(intersectSS(l,m) == false)return Point(INF,INF);\n    return m[0]+(m[1]-m[0])*cross(l[1]-l[0],l[1]-m[0])/cross(l[1]-l[0],m[1]-m[0]);\n}\n \nPolygon ConvexHull(Polygon v){\n\tint n = v.size();\n\tint k = 0;\n\tsort(v.begin(),v.end());\n\tPolygon e(2*n);\n\tfor(int i=0;i<n;e[k++]=v[i++])\n\t\twhile(k>=2&&ccw(e[k-2],e[k-1],v[i])<=0)k--;\n\tfor(int i=n-2,t=k+1;i>=0;e[k++]=v[i--])\n\t\twhile(k>=t&&ccw(e[k-2],e[k-1],v[i])<=0)k--;\n\te.resize(k-1);\n\treturn e;\n}\n\nint main(){\n    int N;\n    while(scanf(\"%d\",&N),N){\n        Circle C[328];\n        vector< Point > points;\n        rep(i,N){\n            double x,y;\n            scanf(\"%lf %lf\",&x,&y);\n            C[i] = Circle(Point(x,y),1.);\n        }\n        int len = 0;\n        rep(i,N){\n            reps(j,i+1,N){\n                Point p,q;\n                int tmp = 0;\n                tmp = intercectCC(C[i],C[j],&p,&q);\n                if(tmp > 0){\n                    points.PB(p);\n                    points.PB(q);\n                    /*\n                    cout << i << \" \" << j << \"->\\n\";\n                    cout << \"1:\"<< p.x << \" \" << p.y << \"\\n\";\n                    cout << \"2:\"<< q.x << \" \" << q.y << \"\\n\";\n                    */\n                }\n            }\n        }\n        int ans = -INF;\n        rep(i,points.size()){\n            Point tar = points[i];\n            int cnt = 0;\n            rep(j,N){\n                Point base = C[j].p;\n                //cout << pabs(base-tar) << \" \";\n                if(pabs(base-tar)-1.<EPS){\n                    cnt++;\n                }\n            }\n            ans = max(ans,cnt);\n        }\n\n        printf(\"%d\\n\",ans);\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS=1e-10;\n\ndouble add(double a,double b){\n  if(abs(a+b)<EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x,y;\n  point(){}\n  point(double x,double y) : x(x) , y(y) {}\n\n  point operator + (point p) {\n    return point(add(x,p.x),add(y,p.y));\n  }\n\n  point operator - (point p) {\n    return point(add(x,-p.x),add(y,-p.y));\n  }\n\n  point operator * (double d) {\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d) {\n    return point(x/d,y/d);\n  }\n\n  bool operator == (const point &p)const{\n    return abs(x-p.x)<EPS && abs(y-p.y)<EPS;\n  }\n};\n\nstruct circle{\n  point p;\n  double r;\n  circle(){}\n  circle(point p,double r):p(p),r(r){}\n};\n\ndouble dist(point a, point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nvector<point> circle_cross(circle a, circle b){\n  vector<point>ret;\n\n  double x=a.p.x-b.p.x,y=a.p.y-b.p.y;\n  double L=x*x+y*y;\n\n  if(L>pow(a.r+b.r,2))return ret;\n\n  L=sqrt(L);\n  double C=atan2(b.p.y-a.p.y,b.p.x-a.p.x);\n  double alpha=acos((L*L+a.r*a.r-b.r*b.r)/(2*L*a.r));\n\n  point r1,r2;\n  r1.x=a.p.x+cos(C+alpha),r1.y=a.p.y+sin(C+alpha);\n  r2.x=a.p.x+cos(C-alpha),r2.y=a.p.y+sin(C-alpha);\n\n  ret.push_back(r1),ret.push_back(r2);\n  return ret;\n}\n\nint main(void){\n\n  int n;\n  point a;\n  vector<point>P;\n  vector<circle>C;\n\n  while(cin >> n,n){\n    P.clear();\n    C.clear();\n    for(int i=0;i<n;i++){\n      cin >> a.x >> a.y;\n      P.push_back(a);\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(dist(P[i],P[j])>2.0+EPS)continue;\n\tvector<point>res=circle_cross(circle(P[i],1.0),circle(P[j],1.0));\n\tfor(int k=0;k<res.size();k++){\n\t  C.push_back(circle(res[k],1));\n\t}\n      }\n    }\n\n    int ans=1;\n    for(int i=0;i<C.size();i++){\n      int cnt=0;\n      for(int j=0;j<P.size();j++)\n\tif(dist(C[i].p,P[j])<1.0+EPS)cnt++;\n\t\n      ans=max(ans,cnt);\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<map>\nusing namespace std;\n#define INF 1e+10\n#define EPS 1e-10\n#define EQ(a,b) (abs(a-b)<EPS)\n\n//誤差を考慮して足し算\ndouble add(double a,double b){\n\tif(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{//2次元ベクトル\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tbool operator ==(P p){\n\t\treturn x==p.x && y==p.y;\n\t}\n\tbool equal(P p){\n\t\treturn (x-p.x)*(x-p.x)+(y-p.y)*(y-p.y) < EPS*EPS;\n\t}\t\n\tdouble dot(P p){//内積\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){//外積\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n};\n//線分p1-p2上に点qがあるか判定\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n//直線p1-p2と直線q1-q2の交点\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*( (q2-q1).det(q1-p1)/(q2-q1).det(p2-p1) );\n}\n//線分p1-p2と線分q1-q2が交差するか\nbool intersecting(P p1,P p2,P q1,P q2){\n\tif(on_seg(p1,p2,q1)||on_seg(p1,p2,q2)||on_seg(q1,q2,p1)||on_seg(q1,q2,p2))return true;\n\tif((p1-p2).det(q1-q2)==0 )return false;//平行\n\tP a=intersection(p1,p2,q1,q2);\n\treturn on_seg(p1,p2,a) && on_seg(q1,q2,a);\n}\nP rotate(P p,double rad){\n\tdouble s=sin(rad),c=cos(rad);\n\treturn P(c*p.x-s*p.y, s*p.x+c*p.y);\n}\ndouble dist(P p,P q){\n\tp = p-q;\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\n\n//円同士の交点を計算\npair<P,P> circle_intersection(double x1,double y1,double r1,double x2,double y2,double r2){\n\tx2 -= x1;\n\ty2 -= y1;\n\tdouble rad = atan2(y2,x2);\n\tP tmp = rotate(P(x2,y2),-rad);\n\tx2 = tmp.x;\n\ty2 = tmp.y;\n\tdouble x = (r1*r1-r2*r2+x2*x2)/(2*x2);\n\tif(abs(r1) < abs(x))return make_pair(P(0,0),P(0,0));//交点なし\n\tdouble y = sqrt(r1*r1-x*x);\n\treturn make_pair( P(x1,y1)+rotate(P(x,y),rad) ,  P(x1,y1)+rotate(P(x,-y),rad) );\n}\n//2点を通る円の中心座標\npair<P,P> circle_on_2P(P p,P q,double r){\n\tif(2*r < dist(p,q))return make_pair(P(0,0),P(0,0));//解なし\n\tif(q.x < p.x)swap(p,q);\n\tq = q - p;\n\tdouble rad = atan2(q.y,q.x);\n\tP tmp = rotate(q,-rad);\n\tdouble x = tmp.x/2;\n\tdouble y = sqrt(4*r*r-tmp.x*tmp.x)/2;\n\treturn make_pair( p+rotate(P(x,y),rad) ,  p+rotate(P(x,-y),rad) );\n}\n\nint n;\nP c[300];\nint calc(P p,P q){\n\tif (2 < dist(p,q))return 1;\n\tpair<P,P> pa = circle_on_2P(p,q,1.0);\n\tint res=0,t=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(dist(pa.first,c[i]) <= 1+1e-4)t++;\n\t}\n\tres = t;\n\tt=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(dist(pa.second,c[i]) <= 1+1e-4)t++;\n\t}\n\tres = max(res,t);\n\treturn res;\n}\nint main(){\n\twhile(cin>>n&&n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tc[i] = P(x,y);\n\t\t}\n\t\tint ans=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tans = max(ans,calc(c[i],c[j]));\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        vector<long double> xs(n),ys(n);\n        rep(i,0,n) cin >> xs[i] >> ys[i];\n\n        auto count=[&](const long double x,const long double y){\n            int res=0;\n            rep(i,0,n) if((xs[i]-x)*(xs[i]-x)+(ys[i]-y)*(ys[i]-y)<=1+eps) ++res;\n            return res;\n        };\n\n        int ans=0;\n        rep(i,0,2001){\n            const long double y=10.*i/2000;\n            rep(j,0,n){\n                const long double tmp=1-(ys[j]-y)*(ys[j]-y);\n                if(tmp<0) continue;\n                const long double x1=xs[j]-sqrtl(tmp),x2=xs[j]+sqrt(tmp);\n                ans=max({ans,count(x1,y),count(x2,y)});\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,N) for(int i=0;i<(int)(N);i++)\n#define REP(i,k,N) for(int i=k;i<(int)(N);i++)\n\n#define vi vector<int>\n#define pb push_back\n\n#define pdd pair<double,double>\n#define fi first\n#define se second\nconst double  EPS = 1e-6;\n\ndouble dist(double x,double y){\n    return x*x+y*y;\n};\n\nint main(){\n//    ifstream in(\"d_in.txt\");\n//    cin.rdbuf(in.rdbuf());\n    int n;\n    while(cin >> n,n){\n        int ma = 0;\n        pdd p[330];\n        rep(i,n) cin >> p[i].fi >> p[i].se;\n        rep(i,n-1){\n            REP(j,i+1,n){\n\n                double x1,y1,x2,y2,x3,y3;\n                tie(x1,y1) = p[i];\n                tie(x2,y2) = p[j];\n                double cx1,cy1,cx2,cy2;\n                if(dist(x1-x2,y1-y2)  > 4+EPS  ) continue;\n\n                //はりまコーナー\n//                double ax,ay,bx1,by1,bx2,by2,mx,my,dx,dy;\n//                ax=x1-x2;ay=y1-y2;\n//                mx=(x1+x2)/2;my=(y1+y2)/2;\n//                by1 = (-0.5)*pow(ax,4)+pow(ax,2)+(-0.5)*pow(ax,2)*pow(ay,2)\n//                        /dist(ax,ay);\n//                by1 = sqrt(abs(by1));\n//                by2 = -1*by1;\n//                cy1= my+by1;\n//                cy2= my+by2;\n//                bx1= -1*(ay*by1)/ax;\n//                bx2= -1*(ay*by2)/ax;\n//                cx1=bx1+mx;\n//                cx2=bx2+mx;\n\n\n                //あじのりコーナー\n                double mx=(x1+x2)/2,my=(y1+y2)/2;\n\n                double ld = sqrt(1-dist((x1-x2),(y1-y2))/4);\n                double theta = atan((y2-y1)/(x2-x1));\n                cx1 = mx - sin(theta)*ld;\n                cy1 = my + cos(theta)*ld;\n                cx2 = mx + sin(theta)*ld;\n                cy2 = my - cos(theta)*ld;\n\n                int cnt1 = 0,cnt2=0;\n                for(int k = 0;k<n;k++) {\n                    tie(x3, y3) = p[k];\n                    if (EPS + 1> dist((cx1 - x3), (cy1 - y3))) cnt1++;\n                    if (EPS + 1> dist((cx2 - x3), (cy2 - y3))) cnt2++;\n                }\n                ma = max({cnt1,cnt2,ma});\n            }\n        }\n        cout<< ma << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 310\n\nlong double x[MAX_N], y[MAX_N];\nint n, maxn;\n\nint main() {\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tmaxn = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tint sum = 0;\n\t\t\t\tlong double X = (x[i] + x[j]) / 2.0;\n\t\t\t\tlong double Y = (y[i] + y[j]) / 2.0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (((x[k] - X)*(x[k] - X) + (y[k] - Y)*(y[k] - Y)) <= 1) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\t\t\t\tlong double X1, Y1, X2, Y2, X3, Y3, VX2, VY2, Dist, Dist2;\n\t\t\t\tDist = sqrt((x[j] - x[i])*(x[j] - x[i]) + (y[j] - y[i])*(y[j] - y[i]));\n\t\t\t\tDist2 = sqrt(4 - Dist*Dist);\n\t\t\t\tX2 = x[j] - x[i]; Y2 = y[j] - y[i];\n\t\t\t\tVX2 = (X2 / Dist)*Dist2 / 2; VY2 = (Y2 / Dist)*Dist2 / 2;\n\t\t\t\tX1 = X + VY2; Y1 = Y - VX2;\n\t\t\t\tX3 = X - VY2; Y3 = Y + VX2;\n\n\t\t\t\tsum = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (((x[k] - X1)*(x[k] - X1) + (y[k] - Y1)*(y[k] - Y1)) <= 1) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\t\t\t\tsum = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (((x[k] - X3)*(x[k] - X3) + (y[k] - Y3)*(y[k] - Y3)) <= 1) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, sum);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint sum = 0;\n\t\t\tlong double X = x[i];\n\t\t\tlong double Y = y[i];\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (((x[k] - X)*(x[k] - X) + (y[k] - Y)*(y[k] - Y)) <= 1) {\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxn = max(maxn, sum);\n\t\t}\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <complex>\n\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,n) loop(i,0,n)\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef complex<double> vec;\n\ndouble const pi = acos(-1);\ndouble const eps = 1e-9;\n\nint main(){\n    int n;\n    while(cin >> n && n){\n        vector<vec> v(n);\n        rep(i, n){\n            double x, y; cin >> x >> y;\n            vec p(x, y);\n            v[i] = p;\n        }\n        int ans = 0;\n        rep(i, n)rep(j, i){\n            double d = abs(v[i] - v[j]);\n            if (d - eps > 2) continue;\n            double h = 1 - d*d/4;\n            vec c1 = polar(h, arg(v[i] - v[j]) + pi / 2) + (v[i] + v[j]) / 2.;\n            vec c2 = polar(h, arg(v[i] - v[j]) - pi / 2) + (v[i] + v[j]) / 2.;\n            int a1 = 0, a2 = 0;\n            rep(k, n){\n                if (abs(c1 - v[k]) <= 1 + eps) a1++;\n                if (abs(c2 - v[k]) <= 1 + eps) a2++;\n            }\n            ans = max(ans, a1);\n            ans = max(ans, a2);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble distance(pair<double,double> p1,pair<double,double> p2){\n\treturn sqrt((p1.first-p2.first)*(p1.first-p2.first)+(p1.second-p2.second)*(p1.second-p2.second));\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<double> x(n);\n\t\tvector<double> y(n);\n\t\tint res=1;\n\t\tfor(int i=0;i<n;i++) cin>>x[i]>>y[i];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tpair<double,double> midp=make_pair((x[i]+x[j])/2,(y[i]+y[j])/2);\n\t\t\t\tdouble a=-(x[i]-x[j]),b=(y[i]-y[j]);\n\t\t\t\tif(a<0.000001) a=0;\n\t\t\t\tif(b<0.000001) b=0;\n\t\t\t\t//a(x-mid[i].first)+b(y-mid.second)=0\n\t\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\t\tpair<double,double> lef=midp;\n\t\t\t\t\t\tpair<double,double> rig;\n\t\t\t\t\t\tif(k==0) rig=make_pair(-b*1e7+midp.first,a*1e7+midp.second);\n\t\t\t\t\t\tif(k==1) rig=make_pair(b*1e6+midp.first,-a*1e6+midp.second);\n\t\t\t\t\t\twhile(distance(lef,rig)>=0.00000001){\n\t\t\t\t\t\t\t\tpair<double,double> mid=make_pair((lef.first+rig.first)/2,(lef.second+rig.second)/2);\n\t\t\t\t\t\t\t\tif(distance(mid,make_pair(x[i],y[i]))>1){\n\t\t\t\t\t\t\t\t\trig=mid;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tlef=mid;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint count=0;\n\t\t\t\t\t\tfor(int r=0;r<n;r++){\n\t\t\t\t\t\t\tif(distance(make_pair(x[r],y[r]),lef)<1+0.000001){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres=max(res,count);\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout<<res<<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef long double Real;\n\nReal eps = 1e-9;\n\nReal add(Real a, Real b) {\n    if (abs(a+b) < eps * (abs(a)+abs(b))) return 0;\n    return a+b;\n}\n\nbool equal(Real a, Real b) {\n    return add(a, -b) == 0;\n}\n\nstruct P {\n    Real x, y;\n    P() {}\n    P(Real x, Real y) : x(x), y(y) {}\n    P operator+(P p) const {return P(add(x, p.x), add(y, p.y));}\n    P operator-(P p) const {return P(add(x, -p.x), add(y, -p.y));}\n    P operator*(Real d) const {return P(x*d, y*d);}\n    Real dot(P p) const {return add(x*p.x, y*p.y);} // ??????\n    Real det(P p) const {return add(x*p.y, -y*p.x);} // ??????\n    Real dist(P p) const {return sqrt((x-p.x)*(x-p.x) + (y-p.y)*(y-p.y));} // ?????¢\n    void normalize() {Real d = sqrt(x*x+y*y); x /= d; y /= d;} // ??£??????\n    bool operator<(const P& rhs) const {\n        if (x != rhs.x) return x < rhs.x;\n        return y < rhs.y;\n    }\n    bool operator==(const P& rhs) const {\n        return equal(x, rhs.x) && equal(y, rhs.y);\n    }\n};\nconst int MAXN = 333;\nP pnt[MAXN];\nint N;\n\nint calc(P center) {\n\tint ret = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tP vec = pnt[i]-center;\n\t\tif (vec.dot(vec) < 1+eps) {\n\t\t\tret++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (cin >> N) {\n    \tif (N==0) break;\n    \tfor (int i = 0; i < N; i++) \n    \t\tcin >> pnt[i].x >> pnt[i].y;\n    \tint ans = min(2, N);\n    \tfor (int i = 0; i < N; i++) for (int j = i+1; j < N; j++) {\n    \t\tif (pnt[i].dist(pnt[j]) > 2) continue;\n    \t\t// diff ?????????\n    \t\tP vec = pnt[j]-pnt[i];\n    \t\t// vec ????????´????????????????????????\n    \t\tP n = P(vec.y, -vec.x);\n    \t\tn.normalize();\n    \t\tvec = vec*0.5;\n    \t\tReal len = sqrt(1-vec.dot(vec));\n    \t\tP cand1 = pnt[i] + vec + n*len;\n    \t\tP cand2 = pnt[i] + vec - n*len;\n    \t\tans = max(ans, calc(cand1));\n    \t\tans = max(ans, calc(cand2));\n    \t}\n    \tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n// xy平面上の点(ベクトル)を表現するには、complex型を利用するとよい\ntypedef complex<double> P;\n\n// 辺の表現 (座標を2つ pair でもつ)\ntypedef pair<P, P> L;\n\n// 円の表現 (座標 P と 半径 d で表現する)\ntypedef pair<P, double> C;\n\n// 成分を取り出すのを簡単にする\n#define X real()\n#define Y imag()\n\n// 誤差(epsilon)の定義\n#define EPS (1e-10)\n\n// 2つの要素が等しいかどうか\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n\n// 2つのベクトルが等しいかどうか\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n\n// m は n より大きい(以上)かどうか\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n\n// m は n より小さい(以下)かどうか\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\n// 2つのベクトルの内積を求める\ndouble dot(P a, P b) {\n    return (a.X * b.X + a.Y * b.Y);\n}\n\n// 2つのベクトルの外積を求める\ndouble cross(P a, P b) {\n    return (a.X * b.Y - a.Y * b.X);\n}\n\n// 点 a と 点 b を通り、半径が r の円の中心を返す\nvector<P> circlesPointsRadius(P a, P b, double r) {\n    vector<P> cs;\n    P abH = (b-a) * 0.5;\n    double d = abs(abH);\n\n    if(d == 0 || d > r) return cs; // 必要なら !LE(d,r) として円1つになる側へ丸める\n    double dN = sqrt(r*r - d*d);   // 必要なら max(r*r - d*d, 0) とする\n    P n = abH * P(0,1) * (dN / d);\n    cs.push_back(a + abH + n);\n    if(dN > 0) cs.push_back(a + abH - n);\n    return cs;\n}\n\nint main() {\n    int N;\n\n    while(cin >> N, N) {\n        vector<P> ps;\n        for(int i=0; i<N; i++) {\n            double x, y; cin >> x >> y;\n            ps.push_back(P(x, y));\n        }\n\n        if(N == 1) cout << 1 << endl;\n        else if(N == 2) {\n            cout << (abs(ps[0] - ps[1]) < 2 + EPS) << endl;\n        }\n        else {\n            int ans = 0;\n            for(int i=0; i<N; i++) {\n                for(int j=i+1; j<N; j++) {\n                    // printf(\"i = %d, j = %d, abs = %f\\n\", i, j, abs(ps[i] - ps[j]));\n                    if(abs(ps[i] - ps[j]) > 2 - EPS) continue;\n\n                    vector<P> centers = circlesPointsRadius(ps[i], ps[j], 1);\n                    for(auto c : centers) {\n                        int sum = 2;\n                        for(int k=0; k<N; k++) {\n                            if(i == k || j == k) continue;\n                            sum += (abs(c - ps[k]) < 1 + EPS);\n                        }\n                        ans = max(ans, sum);\n                    }\n                }\n            }\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nstruct Point{\n    double x,y;\n};\n\nvoid func(int N){\n\n    Point point[N];\n    double x_min = 100,y_min = 100,x_max = -1,y_max = -1;\n\n    for(int i = 0; i < N; i++){\n        scanf(\"%lf %lf\",&point[i].x,&point[i].y);\n        x_min = min(point[i].x,x_min);\n        y_min = min(point[i].y,y_min);\n        x_max = max(point[i].x,x_max);\n        y_max = max(point[i].y,y_max);\n    }\n\n    int count,max_count = 0;\n\n    for(double y = y_min; y <= y_max; y += 0.01){\n        for(double x = x_min; x <= x_max; x += 0.01){\n            count = 0;\n            for(int i = 0; i < N; i++){\n                if(sqrt((x-point[i].x)*(x-point[i].x)+(y-point[i].y)*(y-point[i].y)) <  1)count++;\n            }\n            max_count = max(max_count,count);\n        }\n    }\n\n    printf(\"%d\\n\",max_count);\n}\n\n\nint main(){\n\n    int N;\n\n    while(true){\n        scanf(\"%d\",&N);\n        if(N == 0)break;\n\n        func(N);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 1e-10\n#define equals(a,b) (fabs( (a) - (b) )< EPS )\n// c++ 11,14\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\ntypedef struct point{\n\tdouble x,y;\n\tpoint(){};\n\tpoint(double x ,double y):x(x),y(y){};\n\tpoint operator + (point &p){ return point(x+p.x,y+p.y);\t}\n\tpoint operator - (point &p){ return point(x-p.x,y-p.y);\t}\n\tpoint operator * (point &p){ return point(x*p.x-y*p.y,x*p.y+y*p.x) ;}\n\tpoint operator * (double a){ return point(x*a,y*a);\t}\n\tpoint operator / (double a){ return point(x/a,y/a);\t}\n\t\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x+y*y; }\n\t\n\tbool operator < (const point &p) const { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (const point &p) const { return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS; }\n}point;\n\ndouble abs(point a){return a.abs();}\ndouble norm(point a){return a.norm();}\ntypedef struct circle{\n\tpoint p;\n\tdouble r;\n} circle;\ntypedef complex<double> C;\ntypedef struct { \n\tpoint s,e;\n} line;\n\nC convert(point a){ return C(a.x,a.y); }\npoint convert( C a){ return point(a.real(),a.imag() );}\ndouble dot(point a,point b){ return a.x*b.x+a.y*b.y ; } //内積　a・b\ndouble cross(point a,point b){ return a.x*b.y - a.y*b.x ; }//外積(z成分)　a×b\npoint vec(line l){return l.e-l.s;}\nline make(point s,point e){\n\tline res; res.s=s; res.e=e;\n\treturn res;\n}\ncircle make(point p,double r){ circle c;\n\tc.p = p ;\n\tc.r = r;\n\treturn c;\n}\npoint make(){ \n\tdouble x,y; cin>>x>>y;\n       \treturn point(x,y);\n}\nline lmake(){\n\tpoint p0=make();\n\tpoint p1=make();\n\treturn make(p0,p1);\n}\n//直交\nbool isorthogonal(point a,point b){ return equals(dot(a,b), 0.0); }\nbool isorthogonal(line l1,line l2){ return isorthogonal(vec(l1),vec(l2)); }\n//平行\nbool isparallel(point a,point b){ return equals(cross(a,b),0.0); }\nbool isparallel(line l1,line l2){ return isparallel(vec(l1),vec(l2)); }\n//射影\npoint project(line s,point p){\n\tpoint base = vec(s);\n\tdouble r=dot(p-s.s,base)/base.norm();\n\tbase = base*r;\n\treturn s.s+base;\n}\n//反射\npoint reflect(line l,point p){\n\tpoint tmp=project(l,p)-p;\n\ttmp= tmp*2.0;\n\treturn p+tmp;\n\n}\n//交差判定\n\nint ccw(point p0,point p1,point p2){\n\tpoint a = p1-p0;\n\tpoint b = p2-p0;\nif(cross(a,b)>EPS) return 1;//counter_clockwise\nif(cross(a,b)<-EPS) return -1;//clockwise\nif(dot(a,b)<-EPS)return 2;//online_back\nif(a.norm()<b.norm() ) return -2;//online_front\nreturn 0;//on_segment\n}\n// circle_versino\nint ccw(circle c0,circle c1){\n\tdouble  d = abs(c0.p-c1.p);\n\tdouble r0 = c0.r,r1 = c1.r;\n\t\n\t//c0in c1\n\tif(d<r1-r0)return -2;\n\t//c1 in c0\n\tif(d<r0-r1)return 2;\n\t//c0 cross c1\n\tif(abs(r0-r1)<=d&&d<=r0+r1)return 1;\n\t//c0 not cross c1\n\treturn 0;\n\n}\n\n// line p1-p2 line p3-p4\nbool intersect(point p1,point p2,point p3,point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); \n}\n// line l1,l2\nbool intersect(line l1,line l2){ return intersect(l1.s,l1.e,l2.s,l2.e); }\n\n\n//距離\n//point-point\ndouble distance(point a,point b){ return abs(a-b); }\n//point-line(直線）\ndouble distance2(line l,point p){\n\treturn abs(cross(vec(l),p-l.s)/abs(l.e-l.s));\n}\n//point-line(線分)\ndouble distance(line l,point p){\n\tif( dot(vec(l),p-l.s) <0.0 ) return abs(p-l.s);\n\tif( dot(l.s-l.e,p-l.e) <0.0 ) return abs(p-l.e);\n\treturn distance2(l,p);\n}\n//line-line\ndouble distance(line l1,line l2){\n\tif(intersect(l1,l2))\treturn 0.0;\n\treturn min(min(distance(l1,l2.s),distance(l1,l2.e) ), min(distance(l2,l1.s),distance(l2,l1.e) ) );\n}\n\n//交点\npoint crosspoint(line l1,line l2){\n\tpoint base = vec(l2);\n\tdouble d1 = abs(cross(base,l1.s-l2.s) );\n\tdouble d2 = abs(cross(base,l1.e-l2.s) );\n\tdouble t = d1/(d1+d2);\n\tpoint tmp = vec(l1)*t;\n\treturn l1.s+tmp;\n}\n//面積\ndouble area(vector<point> p,int n){\n\tdouble ans=0.0;\n\tfor(int i=0;i<n-2;i++){\n\tans+=cross(p[i+2]-p[0],p[i+1]-p[0]);\n\t}\n\treturn abs(ans)/2;\n}\ndouble area(vector<point> p){\n\treturn area(p,p.size());\n}\n//内包\nint contains(vector<point> g,point p){\nint n=g.size();\nbool flag=false;\n\tfor(int i=0;i<n;i++){\n\t\tpoint a=g[i]-p, b=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b) )<EPS && dot(a,b) <EPS)return 1;\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) flag=!flag;\n\t}\n\treturn (flag? 2:0);\n}\n//凸包\nvector<point> andrewscan(vector<point> s){\n\tvector<point> u,l;\n\tif(s.size() <3) return s;\n\tsort(s.begin(),s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\n\tfor(int i=2;i<s.size();i++){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor(int i=s.size()-3;i>=0;i--){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n}\n//直径\ndouble convex_diameter(vector<point> g){\n\tint n=g.size();\n\tint is=0,js=0;\n\tfor(int i=1;i<n;i++){\n\t\tif(g[is].y < g[i].y)is =i;\n\t\tif(g[i].y < g[js].y)js=i;\n\t}\n\tdouble maxd = abs((g[is]-g[js]));\n\tint i,mi,j,mj;\n\ti=mi=is;\n\tj=mj=js;\n\tdo{\n\t\tif(cross(g[(i+1)%n]-g[i],g[(j+1)%n]-g[j])>=0)j=(j+1)%n;\n\t\telse i=(i+1)%n;\n\t\tif(abs(g[i]-g[j])>maxd){\n\t\t\t//cerr<<i<<' '<<j<<' '<<norm(g[i]-g[j])<<endl;\n\t\t\tmaxd =abs(g[i]-g[j]);\n\t\t\tmi=i;mj=j;\n\t\t}\n\t}while(i!=is||j!=js);\n\treturn maxd;\n}\n// 90度　回転　反時計周り\npoint roll_l(point a){\n\treturn point(-a.y,a.x);\n}\t\n\n//2点を通る半径rの円を返す  hanten = 1 or -1\ncircle make(point a,point b,double r,int hanten){\n\tline l1  = make(a,b);\n\tpoint m = a+b;\n\tm = m/2.0;\n\tpoint  e = roll_l(vec(l1) );\n\te = e/e.abs();\n\tdouble d = abs(vec(l1) )/2.0;\n\tdouble lng = sqrt(r*r-d*d)*(double)hanten;\n\te = e*lng;\n\t\n\tpoint  o =m+e;\t//中心\n\treturn make(o,r);\t\n}\n// 円の中にあるか\nbool is_in(point p,circle c){\n\tpoint o = c.p;\n\tif(abs(p-o) <= c.r+EPS) return true;\n\telse return false;\n}\n//円に入る点の数\nint in_circle(vector<point> &g,circle c){\n\tint cnt = 0;\n\tfor(int i=0;i<g.size();i++){\n\t\tif(is_in(g[i],c) ){\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\n//半径1でより多くの点を囲める数\nint solve(vector<point> &g){\n\tint n = g.size();\n\tif(n==1) return 1;\n\tif(n==2){\n\t\tif(abs(g[0]-g[1])<2.0) return 2;\n\t\telse return 1;\n\t}\n\tint res = 0;\n\tdouble r = 1.0;\n\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tpoint a = g[i];\n\t\t\t\tpoint b = g[j];\n\t\t\t\tif(abs(a-b) > 2.0) continue;\n\t\t\t\tcircle c  = make(a,b,r,1);\n\t\t\t\tres  = max(res,in_circle(g,c) );\n\t\t\t\tc = make(a,b,r , -1);\n\t\t\t\tres  = max(res,in_circle(g,c) );\n\t\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tvector<point> g(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tg[i] = make();\n\t\t}\n\t\tcout<<solve(g)<<endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-8;\n\nint main() {\n\tfor (;;) {\n\t\tint N; cin >> N;\n\t\tif (N == 0) break;\n\t\tvector<double> x(N), y(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> x[i] >> y[i];\n\t\tint maxi = 1;\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tdouble dx = x[j] - x[i], dy = y[j] - y[i];\n\t\t\t\tdouble d = sqrt(dx * dx + dy * dy);\n\t\t\t\tif (d > 2) continue;\n\t\t\t\tdouble h = sqrt(1 - d * d / 4);\n\t\t\t\tdouble ox = x[i] + dx / 2 - dy / d * h;\n\t\t\t\tdouble oy = y[i] + dy / 2 + dx / d * h;\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tdouble dx = x[k] - ox, dy = y[k] - oy;\n\t\t\t\t\tdouble d = sqrt(dx * dx + dy * dy);\n\t\t\t\t\tif (d <= 1 + EPS) cnt++;\n\t\t\t\t}\n\t\t\t\tmaxi = max(maxi, cnt);\n\t\t\t}\n\t\tcout << maxi << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//30\n#include<iostream>\n#include<complex>\n#include<cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nint main(){\n  for(int n;cin>>n,n;){\n    P p[300];\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin>>x>>y;\n      p[i]=P(x,y);\n    }\n    int ans=1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i==j||abs(p[i]-p[j])>2)continue;\n\tP c=p[i]+polar(1.,arg(p[j]-p[i])+acos(abs(p[j]-p[i])/2));\n\tint cc=0;\n\tfor(int k=0;k<n;k++){\n\t  cc+=abs(p[k]-c)<1+1e-9;\n\t}\n\tif(ans<cc){\n\t  ans=cc;\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> Point;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n)<(m)+EPS)\n#define GE(n,m) ((n)+EPS>(m))\n#define EQ(n,m) (abs((n)-(m))<EPS)\nconst double EPS=1e-8;\n\n//center of circle going through two given points of which radius equals to r\nvector<Point> centergivenradius(const Point &a,const Point &b,const double &r){\n    vector<Point> cs;\n    Point ls=(b-a)*0.5;\n    double dist=abs(ls);\n    if (dist==0.0||dist>r) return cs;\n    double len=sqrt(r*r-dist*dist);\n    Point n=ls*Point(0.0,1.0)*(len/dist);\n    cs.emplace_back(a+ls+n);\n    if (GE(len,0.0)) cs.emplace_back(a+ls-n);\n    return cs;\n}\n\nvoid solve(int N){\n    vector<Point> P;\n    for (int i=0;i<N;++i){\n        double x,y; cin >> x >> y;\n        P.emplace_back(x,y);\n    }\n    int ans=1;\n    for (int i=0;i<N;++i){\n        for (int j=i+1;j<N;++j){\n            double dist=norm(P[i]-P[j]);\n            if (GE(dist,4.0)) continue;\n            vector<Point> center=centergivenradius(P[i],P[j],1.0);\n            for (int l=0;l<2;++l){\n                int cnt=2;\n                for (int k=0;k<N;++k){\n                    if (k==i||k==j) continue;\n                    cnt+=(LE(norm(P[k]-center[l]),1.0));\n                }\n                ans=max(ans,cnt);\n            }\n        }\n    }\n    cout << ans << '\\n';\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    while(cin >> N,N){\n        solve(N);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// Circle and Points\n\n// 平面走査ごり押し\n\n#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle().crosspoint()の戻り値\nusing namespace std;\n\nconst double EPS = 1e-3;\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\npublic:\n    double x, y;\n    Point(double a = 0.0, double b = 0.0) :x(a), y(b) {};\n    bool operator== (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    Point operator+(const Point&) const;\n    Point operator-(const Point&) const;\n    Point operator-() const;\n    Point times(double) const;\n    Point& operator=(const Point&);\n    Point& operator+=(const Point&);\n    Point& operator-=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    Point projection(const Line&) const;\n    Point reflection(const Line&) const;\n    int ccw(const Point&, const Point&) const;              // a.ccw(b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n};\nclass Segment {\npublic:\n    Point source, target;\n    Segment(Point a = Point(), Point b = Point()) :source(a), target(b) {};\n    Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n};\nclass Line {\npublic:\n    Point source, target;\n    Line(Point a = Point(), Point b = Point()) :source(a), target(b) {};\n    Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    Point projection(const Point&) const;\n    Point reflection(const Point&) const;\n    Point crosspoint(const Line&) const;\n};\nclass Circle {\npublic:\n    double x, y, r;\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :x(a), y(b), r(c) {};\n    Point point() const;\n    double distance(const Point&) const;                    // 円の中心と点の距離\n    double distance(const Circle&) const;                   // 円の中心同士の距離\n    bool include(const Point&) const;                       // 点を含むか\n    bool include(const Circle&) const;                      // 円を含むか\n    bool intersect(const Circle&) const;\n    vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x == p.x && y == p.y;}\nbool Point::operator<(const Point &p) const {return x != p.x ? x < p.x : y < p.y;}\nbool Point::operator>(const Point &p) const {return x != p.x ? x > p.x : y > p.y;}\nbool Point::operator<=(const Point &p) const {return x != p.x ? x < p.x : y <= p.y;}\nbool Point::operator>=(const Point &p) const {return x != p.x ? x > p.x : y >= p.y;}\nPoint Point::operator+(const Point& p) const {return Point(x + p.x, y + p.y);}\nPoint Point::operator-(const Point& p) const {return Point(x - p.x, y - p.y);}\nPoint Point::operator-() const {return Point(-x, -y);}\nPoint Point::times(double d) const {return Point(x * d, y * d);}\nPoint& Point::operator=(const Point& p) {x = p.x; y = p.y; return *this;}\nPoint& Point::operator+=(const Point& p) {x += p.x; y += p.y; return *this;}\nPoint& Point::operator-=(const Point& p) {x -= p.x; y -= p.y; return *this;}\ndouble Point::dot(const Point& p) const {return x * p.x + y * p.y;}\ndouble Point::cross(const Point& p) const {return x * p.y - y * p.x;}\ndouble Point::abs() const {return hypot(x, y);}\ndouble Point::norm() const {return x * x + y * y;}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nPoint Point::projection(const Line& l) const {return l.projection(*this);}\nPoint Point::reflection(const Line& l) const {return l.reflection(*this);}\nint Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > 0.0) return 1;\n    if(v1.cross(v2) < 0.0) return -1;\n    if(v1.dot(v2) < 0.0) return 2;\n    if(v1.norm() < v2.norm()) return -2;\n    return 0;\n}\n// Segment\nLine Segment::line() const {return Line(source, target);}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    double a = source.distance(p);\n    double b = target.distance(p);\n    return a < b ? a : b;\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source);\n    double b = distance(s.target);\n    double c = s.distance(source);\n    double d = s.distance(target);\n    a = a < b ? a : b;\n    a = a < c ? a : c;\n    return a < d ? a : d;\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {\n    return source.distance(p) + target.distance(p) - target.distance(source) <= EPS;\n}\nbool Segment::intersect(const Segment& s) const {\n    bool a = s.source.ccw(s.target, source) * s.source.ccw(s.target, target) <= EPS;\n    bool b = source.ccw(target, s.source) * source.ccw(target, s.target) <= EPS;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\n// Line\nSegment Line::segment() const {return Segment(source, target);}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source);\n    double b = distance(s.target);\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source);}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source - p;\n    Point v2 = target - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target - source;\n    Point v2 = s.source - source;\n    Point v3 = s.target - source;\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target - source;\n    Point v2 = l.target - l.source;\n    Point v3 = l.source - source;\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nPoint Line::projection(const Point& p) const {\n    Point v1 = p - source;\n    Point v2 = source - target;\n    return Point(source + v2.times(v1.dot(v2) / v2.norm()));\n}\nPoint Line::reflection(const Point& p) const {\n    return p + (projection(p) - p).times(2.0);\n}\nPoint Line::crosspoint(const Line& l) const {\n    Point v1 = target - source;\n    Point v2 = l.target - l.source;\n    Point v3 = target - l.source;\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source;\n    return l.source + v2.times(b / a);\n}\n// Circle\nPoint Circle::point() const {return Point(x, y);}\ndouble Circle::distance(const Point& p) const {return point().distance(p);}\ndouble Circle::distance(const Circle& c) const {return point().distance(c.point());}\nbool Circle::include(const Point& p) const {return distance(p) - r <= EPS;}\nbool Circle::include(const Circle& c) const {return distance(c) - (r - c.r) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return distance(c) - r - c.r <= EPS;}\nvector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y - y, c.x - x);\n    double d = distance(c);\n    double add = acos((d * d + r * r - c.r * c.r) / (2.0 * d * r));\n    vector<Point> result;\n    result.push_back(Point(x + r * cos(angle + add), y + r * sin(angle + add)));\n    result.push_back(Point(x + r * cos(angle - add), y + r * sin(angle - add)));\n    return result;\n}\n\nint main() {\n    int n;\n    while(cin>>n, n) {\n        vector<Circle> circle;\n        vector<Circle> crosspoint;\n        for(int i = 0; i < n; i++) {\n            double x, y;\n            cin>>x>>y;\n            circle.push_back(Circle(x, y, 1.0));\n        }\n        for(int i = 0; i < n - 1; i++) {\n            for(int j = i + 1; j < n; j++) {\n                if(!circle[i].intersect(circle[j])) continue;\n                vector<Point> p = circle[i].crosspoint(circle[j]);\n                crosspoint.push_back(Circle(p[0].x, p[0].y, 1.0));\n                crosspoint.push_back(Circle(p[1].x, p[1].y, 1.0));\n            }\n        }\n        int answer = 0;\n        for(int i = 0; i < crosspoint.size(); i++) {\n            int count = 0;\n            for(int j = 0; j < n; j++) {\n                if(crosspoint[i].include(circle[j].point())) count++;\n            }\n            if(answer < count) answer = count;\n        }\n        cout<<answer<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint main(void) {\n  for(int N; cin >> N, N > 0;) {\n    double x[300], y[300];\n    REP(i, 0, N) cin >> x[i] >> y[i];\n\n    int answer = 1;\n    REP(i, 0, N) {\n      REP(j, i + 1, N) {\n        double tan = (y[i] - y[j]) / (x[i] - x[j]);\n        double cot = (x[i] - x[j]) / (y[i] - y[j]);\n        double dsq = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n        if(dsq > 4.0) continue;\n        double l = sqrt(dsq - 1.);\n        double sx = (x[i] + x[j]) / 2.;\n        double sy = (y[i] + y[j]) / 2.;\n\n        double cx1 = sx - tan * l;\n        double cy1 = sy + cot * l;\n        int cnt1 = 0;\n        REP(k, 0, N) if(k == i || k == j || (x[k] - cx1) * (x[k] - cx1) + (y[k] - cy1) * (y[k] - cy1) <= 1.0) cnt1++;\n        answer = max(answer, cnt1);\n\n        double cx2 = sx + tan * l;\n        double cy2 = sy - cot * l;\n        int cnt2 = 0;\n        REP(k, 0, N) if(k == i || k == j || (x[k] - cx2) * (x[k] - cx2) + (y[k] - cy2) * (y[k] - cy2) <= 1.0) cnt2++;\n        answer = max(answer, cnt2);\n      }\n    }\n\n    cout << answer << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <tuple>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nint N;\ndouble x[300];\ndouble y[300];\ninline double dist2(double a, double b)\n{\n\treturn a*a+b*b;\n}\nvoid exec()\n{\n\tcin >> N;\n\tif(N==0){\n\t\texit(0);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tint ret=1;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tdouble dx=(x[i]-x[j])/2;\n\t\t\tdouble dy=(y[i]-y[j])/2;\n\t\t\tdouble r2=dx*dx+dy*dy;\n\t\t\tif(r2>1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble R=sqrt(1/r2-1);\n\t\t\tdouble px=x[j]+dx-R*dy;\n\t\t\tdouble py=y[j]+dy+R*dx;\n\t\t\tdouble qx=x[j]+dx+R*dy;\n\t\t\tdouble qy=y[j]+dy-R*dx;\n\t\t\tint sp=0,sq=0;\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\tif(k==i||k==j){\n\t\t\t\t\tsp++;sq++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(dist2(x[k]-px,y[k]-py)<=1){\n\t\t\t\t\tsp++;\n\t\t\t\t}\n\t\t\t\tif(dist2(x[k]-qx,y[k]-qy)<=1){\n\t\t\t\t\tsq++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret=max(ret,sp);\n\t\t\tret=max(ret,sq);\n\t\t}\n\t}\n\tcout << ret << endl;\n}\nint main() {\n\twhile(1)\n\t\texec();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble distance(pair<double,double> p1,pair<double,double> p2){\n\treturn sqrt((p1.first-p2.first)*(p1.first-p2.first)+(p1.second-p2.second)*(p1.second-p2.second));\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<double> x(n);\n\t\tvector<double> y(n);\n\t\tint res=1;\n\t\tfor(int i=0;i<n;i++) cin>>x[i]>>y[i];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tpair<double,double> midp=make_pair((x[i]+x[j])/2,(y[i]+y[j])/2);\n\t\t\t\tdouble a=-(x[i]-x[j]),b=(y[i]-y[j]);\n\t\t\t\tif(a<0.000001) a=0;\n\t\t\t\tif(b<0.000001) b=0;\n\t\t\t\t//a(x-mid[i].first)+b(y-mid.second)=0\n\t\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\t\tpair<double,double> lef=midp;\n\t\t\t\t\t\tpair<double,double> rig;\n\t\t\t\t\t\tif(k==0) rig=make_pair(-b*1e8+midp.first,a*1e8+midp.second);\n\t\t\t\t\t\tif(k==1) rig=make_pair(b*1e8+midp.first,-a*1e8+midp.second);\n\t\t\t\t\t\twhile(distance(lef,rig)>=0.00000001){\n\t\t\t\t\t\t\t\tpair<double,double> mid=make_pair((lef.first+rig.first)/2,(lef.second+rig.second)/2);\n\t\t\t\t\t\t\t\tif(distance(mid,make_pair(x[i],y[i]))>1){\n\t\t\t\t\t\t\t\t\trig=mid;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tlef=mid;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint count=0;\n\t\t\t\t\t\tfor(int r=0;r<n;r++){\n\t\t\t\t\t\t\tif(distance(make_pair(x[r],y[r]),lef)<1+0.0001){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres=max(res,count);\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout<<res<<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\n\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\nconst double EPS = 1e-8;\n\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) {\n    for(T &a : v) is >> a; return is;\n}\nusing Coordinate = double;\nbool eq(Coordinate a, Coordinate b) {\n    return abs(a - b) < EPS;\n}\n/*\n * Point\n */\nstruct Point {\n    Coordinate x,y;\n    Point():x(0),y(0){}\n    Point(Coordinate x,Coordinate y):x(x),y(y){}\n    pair<Coordinate,Coordinate> to_pair() const { return make_pair(x,y); }\n    bool operator == (const Point &a) const { return eq(x, a.x) && eq(y, a.y); }\n    bool operator != (const Point &a) const { return !(*this == a); }\n    \n    Point operator + (const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator - (const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator - () const { return Point(-x, -y); }\n    Point& operator += (const Point& p) { x += p.x; y += p.y; return *this; }\n    Point& operator -= (const Point& p) { x -= p.x; y -= p.y; return *this; }\n};\ntemplate<typename T> Point operator * (T k, const Point &p) { return Point(k * p.x, k * p.y); }\ntemplate<typename T> Point operator / (const Point &p, T k) { return Point(p.x / k, p.y / k); }\ndouble dot(const Point &a, const Point &b) { return a.x * b.x + a.y * b.y; }\ndouble cross(const Point &a, const Point &b) { return a.x * b.y - a.y * b.x; }\ndouble norm(const Point& a) { return sqrt( dot(a, a) ); }\n\nistream &operator >> (istream& is, Point& p){ return is >> p.x >> p.y;}\n\ndouble distance(const Point& a, const Point& b) { return norm(a - b); }\ndouble distance2(const Point& a, const Point& b) { return dot(a - b, a - b); }\n\n// ??£?????´???????????????\nPoint orthonormal(Point &p) {\n    Point p2 = Point(-1 * p.y, p.x); //rotate(p, 90);\n    return p2 / norm(p2);\n}\n\nPoint midPoint(const Point &a, const Point &b) {\n    return Point((a.x + b.x) / 2, (a.y + b.y) / 2);\n}\n\n\nbool solve() {\n    int n; cin >> n;\n    if(n == 0) return 0;\n    vector<Point> P(n); cin >> P;\n    int ans = 1;\n    rep(i, n) rep(j, i) if(distance(P[i], P[j]) <= 2.0 + EPS){\n        Point a = P[i] - P[j];\n        Point mid = midPoint(P[i], P[j]);\n        double len = sqrt(1 - distance2(mid, P[j]));\n        Point c = len * orthonormal(a) + mid;\n        int cnt = 0;\n        rep(l, n) {\n            cnt += distance2(P[l], c) <= 1.0 + EPS;\n        }\n        ans = max(ans, cnt);\n    }\n    cout << ans << endl;\n    return 1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <utility>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nbool eqv(double a, double b) {\n    return abs(a-b) < 1e-10;\n}\n\nbool inCircle(const Point &p, const Point &center, double radius) {\n    double dist2 = norm(p-center);\n    double rad2 = radius*radius;\n    return dist2 < radius*radius || eqv(dist2, rad2);\n}\n\nint check(const Point &center, const vector<Point> &points) {\n    const int N = points.size();\n    int cnt = 0;\n    for(int i = 0; i < N; ++i) {\n        if(inCircle(points[i], center, 1)) ++cnt;\n    }\n    return cnt;\n}\n\nint test(int a, int b, const vector<Point> &points) {\n    const Point v(points[a]-points[b]);\n    const double hlen = abs(v)/2;\n\n    if(hlen >= 1) return 0;\n    const double plen = sqrt(1 - hlen*hlen);\n    Point perp = v*Point(0, 1);\n    perp /= abs(perp);\n    const Point mid = points[b] + v/2.0;\n    return max(check(mid + perp*plen, points), check(mid - perp*plen, points));\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        vector<Point> points(N);\n        for(int i = 0; i < N; ++i) {\n            cin >> points[i].real() >> points[i].imag();\n        }\n        int ans = 0;\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < i; ++j) {\n                ans = max(ans, test(i, j, points));\n            }\n        }\n        if(N == 1) ans = 1;\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-4;\n\nint main() {\n\tfor (;;) {\n\t\tint N; cin >> N;\n\t\tif (N == 0) break;\n\t\tvector<double> x(N), y(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> x[i] >> y[i];\n\t\tint maxi = 1;\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tdouble dx = x[j] - x[i], dy = y[j] - y[i];\n\t\t\t\tdouble d = sqrt(dx * dx + dy * dy);\n\t\t\t\tif (d > 2) continue;\n\t\t\t\tdouble h = sqrt(1 - d * d / 4);\n\t\t\t\tdouble ox = x[i] + dx / 2 - dy / d * h;\n\t\t\t\tdouble oy = y[i] + dy / 2 + dx / d * h;\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tdouble dx = x[k] - ox, dy = y[k] - oy;\n\t\t\t\t\tdouble d2 = dx * dx + dy * dy;\n\t\t\t\t\tif (d <= 1 + EPS) cnt++;\n\t\t\t\t}\n\t\t\t\tmaxi = max(maxi, cnt);\n\t\t\t}\n\t\tcout << maxi << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#include <math.h>\nint main(){\n\tint n=0;\n\twhile(cin>>n && n!=0){\n\t\tdouble x[300]={},y[300]={};\n\t\tint ans=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x[i]>>y[i];\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(i!=j){\n\t\t\t\t\tdouble dx=x[i]-x[j],dy=y[i]-y[j];\n\t\t\t\t\tdouble dd=dx*dx+dy*dy;\n\t\t\t\t\tif(dd<4.0){\n\t\t\t\t\t\tdouble h=pow(1.0-dd/4.0,1.0/2.0),d=pow(dd,1.0/2.0);\n\t\t\t\t\t\tdouble px=(x[i]+x[j])/2.0+h*dy/d,py=(y[i]+y[j])/2.0-h*dx/d;\n\t\t\t\t\t\tint a=0;\n\t\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\t\tif((x[k]-px)*(x[k]-px)+(y[k]-py)*(y[k]-py)<1.0001) a++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(a>ans)ans=a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vld = vector<ld>; \n\nint main(void) {\n    ll n; \n    while (cin >> n && n) {\n        vld x(n), y(n); rep(i, n) cin >> x[i] >> y[i];\n        auto d = [&](ll i, ll j) { return (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]); };\n        ll ret = 1;\n        for (int i = 0; i < n-1; i++) {\n            for (int j = i+1; j < n; j++) {\n                ld dij = d(i, j);\n                if (dij >= 4.0l) continue;\n                ld x1 = x[i], y1 = y[i], x0 = x[j], y0 = y[j];\n                for (auto dir : {1.0l, -1.0l}) {\n                    ld xc = x0 + (x1 - x0) / 2.0l + (-(y1 - y0)) * dir \n                        * sqrtl(1.0l - ((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0)) / 4.0l) \n                        / sqrtl((y1 - y0) * (y1 - y0)  + (x1 - x0) * (x1 - x0));\n                    ld yc = y0 + (y1 - y0) / 2.0l + (+(x1 - x0)) * dir \n                        * sqrtl(1.0l - ((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0)) / 4.0l) \n                        / sqrtl((y1 - y0) * (y1 - y0)  + (x1 - x0) * (x1 - x0));\n                    ll m = 2;\n                    rep(k, n) {\n                        if (k == i || k == j) continue;\n                        if ((xc - x[k]) * (xc - x[k]) + (yc - y[k]) * (yc - y[k]) < 1.0l) \n                            m++;\n                    }\n                    chmax(ret, m);\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define dis(p,q) ((p)*(p)+(q)*(q))\nint main(){\n  int i,j,k;\n  int n;\n  while(cin>>n,n){\n    double x[300],y[300];\n    for(i=0;i<n;++i)\n      cin>>x[i]>>y[i];    \n    int mx=1;\n    for(i=0;i<n-1;++i){\n      for(j=i+1;j<n;++j){\n\tdouble d=dis(x[i]-x[j],y[i]-y[j]);\n\tif(d<=4){\n\t  double cx[2],cy[2],a=atan2(y[i]-y[j],x[i]-x[j]);\n\t  int sm[2]={2,2};\n\t  d=sqrt(1-d/4);\n\t  cx[0]=(x[i]+x[j])/2+cos(a+M_PI/2)*d;\n\t  cy[0]=(y[i]+y[j])/2+sin(a+M_PI/2)*d;\n\t  cx[1]=(x[i]+x[j])/2+cos(a-M_PI/2)*d;\n\t  cy[1]=(y[i]+y[j])/2+sin(a-M_PI/2)*d;\n\t  for(k=0;k<n;++k){\n\t    if(k!=i&&k!=j){\n\t      if(dis(x[k]-cx[0],y[k]-cy[0])<=1)\n\t\t++sm[0];\n\t      if(dis(x[k]-cx[1],y[k]-cy[1])<=1)\n\t\t++sm[1];\n\t    }\n\t  }\n\t  mx=max(max(mx,sm[0]),sm[1]);\n\t}\n      }\n    }\n    cout<<mx<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nstruct Point{\n    double x,y;\n};\n\nvoid func(int N){\n\n    Point point[N];\n    double x_min = 100,y_min = 100,x_max = -1,y_max = -1;\n\n    for(int i = 0; i < N; i++){\n        scanf(\"%lf %lf\",&point[i].x,&point[i].y);\n        x_min = min(point[i].x,x_min);\n        y_min = min(point[i].y,y_min);\n        x_max = max(point[i].x,x_max);\n        y_max = max(point[i].y,y_max);\n    }\n\n    if(x_min > 1)x_min -= 0.05;\n    if(y_min > 1)y_min -= 0.05;\n    if(x_max < 9)x_max += 0.05;\n    if(y_max < 9)y_max += 0.05;\n\n    int count,max_count = 0;\n\n    for(double y = y_min; y <= y_max; y += 0.01){\n        for(double x = x_min; x <= x_max; x += 0.01){\n            count = 0;\n            for(int i = 0; i < N; i++){\n                if(sqrt((x-point[i].x)*(x-point[i].x)+(y-point[i].y)*(y-point[i].y)) <= 1.0)count++;\n            }\n            max_count = max(max_count,count);\n        }\n    }\n\n    printf(\"%d\\n\",max_count);\n}\n\n\nint main(){\n\n    int N;\n\n    while(true){\n        scanf(\"%d\",&N);\n        if(N == 0)break;\n\n        func(N);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define re real()\n#define im imag()\nusing namespace std;\ntypedef complex<double> P;\nint main(){\n\twhile(true){\n\t\tint n,mx=1;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\tcomplex<double> p[300];\n\t\trep(i,n){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf%lf\",&x,&y);\n\t\t\tp[i]=P(x,y);\n\t\t}\n\t\trep(i,n) rep(j,i){\n\t\t\tdouble d=abs(p[i]-p[j]);\n\t\t\tif(d>2) continue;\n\t\t\tP c=(p[i]+p[j])/2.0,dis=(p[i]-p[j])/d*sqrt(1-d*d/4);\n\t\t\tdis=P(dis.im,-dis.re);\n\t\t\tP cen=c+dis;\n\t\t\tint cnt=0;\n\t\t\trep(k,n) if(abs(cen-p[k])<=1.0000000001) cnt++;\n\t\t\tmx=max(mx,cnt);\n\t\t\tcen=c-dis;\n\t\t\tcnt=0;\n\t\t\trep(k,n) if(abs(cen-p[k])<=1.0000000001) cnt++;\n\t\t\tmx=max(mx,cnt);\n\t\t}\n\t\tprintf(\"%d\\n\",mx);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\nusing namespace std;\ntypedef complex<double> P;\nint n;\nvector<P> p;\nint ret(){\n\tint cnt=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(abs(p[i]-p[j])>2.0)\n\t\t\t\tcontinue;\n\t\t\tP c=(p[i]+p[j])*0.5;\n\t\t\tdouble d=sqrt(1.0-abs(p[i]-c)*abs(p[i]-c));\n\t\t\tP l1=(p[i]-p[j])*P(0,1);\n\t\t\tP l2=(p[i]-p[j])*P(0,-1);\n\t\t\tl1=l1*d/abs(l1)+c;l2=l2*d/abs(l2)+c;\n\t\t\tint x=2,y=2;\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(k==i||k==j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(abs(l1-p[k])<=1.0){\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif(abs(l2-p[k])<=1.0){\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tcnt=max(cnt,max(x,y));\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n\t\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tp.resize(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tp[i]=P(x,y);\n\t\t}\n\t\tcout<<ret()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef complex<double> P;\nconst double PI = 3.14159265;\nconst double eps = 1e-7;\n\ninline double dist(const P &p,const P &q) {\n    double dx = (p-q).real(),dy = (p-q).imag();\n    return sqrt(dx*dx+dy*dy);\n}\n\ndouble inner(const P &p,const P &q) {\n    return (conj(p)*q).real();\n}\n\ndouble outer(const P &p,const P &q) {\n    return (conj(p)*q).imag();\n}\n\nstruct Line {\n    P pos,dir;\n    Line(const P &p,const P &q) : pos(p), dir(q) {;}\n};\n\n// rotate to right , radian\nP rotate(const P &p,double degree) {\n    return P(p.real()*cos(degree)+p.imag()*(-sin(degree)),\n             p.real()*sin(degree)+p.imag()*cos(degree));\n}\n\nstruct Circle {\n    double r;\n    P c;\n    Circle(P c,double r) : c(c), r(r) {;}\n};\n\n// p in C?\ninline bool inC(const Circle &c,const P &p) {\n    return dist(c.c,p) < c.r + eps;\n}\n\n// p1,p2©ç£dÌ2ÂÌ_ðÔ·\n// dist(p1-p2) > 2*dÌÆ«nanªÔéÌÉÓ\npair<P,P> findCenter(P &p1,P &p2,double d) {\n    P cp = p1+p2;\n    cp /= 2;\n\n//    cout<<\"cp = \"<<cp<<endl;\n    P od = p2-cp;\n\n//    cout<<\"original od = \"<<od<<endl;\n    od = rotate(od,PI/2);\n//    cout<<\"rotated od = \"<<od<<endl;\n\n    double abod = abs(od),abcp = norm(cp-p1);\n    double len = sqrt(d-abcp);\n\n    // cout<<\"abod = \"<<abod<<\" abcp = \"<<abcp<<endl;\n    // cout<<\"len = \"<<len<<endl;\n    P rep1 = cp + (od/abod)*len;\n    P rep2 = cp - (od/abod)*len;\n    return make_pair(rep1,rep2);\n}\n\nint main() {\n    int n;\n    while(cin>>n, n) {\n        vector<P> pv;\n        double x,y;\n        for(int i=0; i<n; ++i) {\n            cin>>x>>y;\n            pv.push_back(P(x,y));\n        }\n\n        int ans = 1;\n        for(int i=0; i<n; ++i) {\n            for(int j=i+1; j<n; ++j) {\n                if(dist(pv[i],pv[j]) > 2.0) continue;\n                pair<P,P> p = findCenter(pv[i],pv[j],1.0);\n                int t1 = 0,t2 = 0;\n//                cout<<pv[i]<<\" \"<<pv[j]<<\" \"<<p.first<<\" \"<<p.second<<endl;\n                Circle c1(p.first,1.0);\n                Circle c2(p.second,1.0);\n                for(int k=0; k<n; ++k) {\n                    if(inC(c1,pv[k])) t1++;\n                    if(inC(c2,pv[k])) t2++;\n                }\n                ans = max(ans, max(t1,t2));\n            }\n        }\n\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#include <math.h>\nint main(){\n\tint n=0;\n\twhile(cin>>n && n!=0){\n\t\tdouble x[300]={},y[300]={};\n\t\tint ans=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x[i]>>y[i];\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(i!=j){\n\t\t\t\t\tdouble dx=x[i]-x[j],dy=y[i]-y[j];\n\t\t\t\t\tdouble dd=dx*dx+dy*dy;\n\t\t\t\t\tif(dd<4.0){\n\t\t\t\t\t\tdouble h=pow(1.0-dd/4.0,1.0/2.0),d=pow(dd,1.0/2.0);\n\t\t\t\t\t\tdouble px=(x[i]+x[j])/2.0+h*dy/d,py=(y[i]+y[j])/2.0-h*dx/d;\n\t\t\t\t\t\tint a=0;\n\t\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\t\tif((x[k]-px)*(x[k]-px)+(y[k]-py)*(y[k]-py)<1.001) a++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(a>ans)ans=a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define X first\n#define Y second\n\nusing P=pair<double, double>;\n\nconst double EPS = 1e-14;\n\ndouble dist(P a, P b) {\n\tdouble dx = a.X - b.X;\n\tdouble dy = a.Y - b.Y;\n\treturn sqrt(dx*dx+dy*dy);\n}\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tvector<P> p(n), pl;\n\t\tfor(int i = 0; i < n; i++) cin >> p[i].X >> p[i].Y;\n\t\tfor(int i = 0; i < p.size(); i++) {\n\t\t\tP p1 = p[i];\n\t\t\tfor(int j = 0; j < p.size(); j++) {\n\t\t\t\tif(i==j) continue;\n\t\t\t\tP p2 = p[j];\n\t\t\t\tif(dist(p1, p2) > 2) continue;\n\n\t\t\t\tdouble dxy = dist(p1, p2);\n\t\t\t\tdouble l = sqrt(1-(dxy/2));\n\t\t\t\tdouble cx = (p1.X+p2.X)/2;\n\t\t\t\tdouble cy = (p1.Y+p2.Y)/2;\n\t\t\t\tdouble dx = (p2.X - p1.X);\n\t\t\t\tdouble dy = (p2.Y - p1.Y);\n\n\t\t\t\tdouble dlx = l/sqrt(dx*dx+dy*dy) * -dy;\n\t\t\t\tdouble dly = l/sqrt(dx*dx+dy*dy) * dx;\n\n\t\t\t\tpl.push_back(P(cx+dlx, cy+dly));\n\t\t\t\tpl.push_back(P(cx-dlx, cy-dly));\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(P p1:pl) {\n\t\t\tint tmp = 0;\n\t\t\tfor(P p2:p) {\n\t\t\t\tif(dist(p1, p2) <= 1+EPS) tmp++;\n\t\t\t}\n\t\t\tres = max(res, tmp);\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vld = vector<ld>; \n\nint main(void) {\n    ll n; \n    while (cin >> n && n) {\n        vld x(n), y(n); rep(i, n) cin >> x[i] >> y[i];\n        auto d = [&](ll i, ll j) { return (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]); };\n        ll ret = 1;\n        for (int i = 0; i < n-1; i++) {\n            for (int j = i+1; j < n; j++) {\n                ld dij = d(i, j);\n                if (dij >= 4) continue;\n                ld x1 = x[i], y1 = y[i], x0 = x[j], y0 = y[j];\n                for (auto dir : {1, -1}) {\n                    ld xc = x0 + (x1 - x0) / 2.0l + (-(y1 - y0)) * dir \n                        * sqrtl(1.0l - ((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0)) / 4.0l) \n                        / sqrtl((y1 - y0) * (y1 - y0)  + (x1 - x0) * (x1 - x0));\n                    ld yc = y0 + (y1 - y0) / 2.0l + (+(x1 - x0)) * dir \n                        * sqrtl(1.0l - ((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0)) / 4.0l) \n                        / sqrtl((y1 - y0) * (y1 - y0)  + (x1 - x0) * (x1 - x0));\n//                    cout << x1 << \" \" << y1 << \" \" << x0 << \" \" << y0 << \" : \" << xc << \" \" << yc << endl;\n                    ll m = 2;\n                    rep(k, n) {\n                        if (k == i || k == j) continue;\n                        if ((xc - x[k]) * (xc - x[k]) + (yc - y[k]) * (yc - y[k]) < 1) \n                            m++;\n                    }\n                    chmax(ret, m);\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,N) for(int i=0;i<(int)(N);i++)\n#define REP(i,k,N) for(int i=k;i<(int)(N);i++)\n\n#define vi vector<int>\n#define pb push_back\n\n#define pdd pair<double,double>\n#define fi first\n#define se second\nconst double  EPS = 1e-9;\n\ndouble dist(double x,double y){\n    return x*x+y*y;\n};\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        int ma = 0;\n        pdd p[330];\n        rep(i,n) cin >> p[i].fi >> p[i].se;\n        rep(i,n-1){\n            REP(j,i+1,n){\n                int cnt1 = 0,cnt2=0;\n                double x1,y1,x2,y2,x3,y3;\n                tie(x1,y1) = p[i];\n                tie(x2,y2) = p[j];\n                double cx1,cy1,cx2,cy2;\n                if(dist(x1-x2,y1-y2)>4) continue;\n\n                //はりまコーナー\n//                double ax,ay,bx1,by1,bx2,by2,mx,my,dx,dy;\n//                ax=x1-x2;ay=y1-y2;\n//                mx=(x1+x2)/2;my=(y1+y2)/2;\n//                by1 = (-0.5)*pow(ax,4)+pow(ax,2)+(-0.5)*pow(ax,2)*pow(ay,2)\n//                        /dist(ax,ay);\n//                by1 = sqrt(abs(by1));\n//                by2 = -1*by1;\n//                cy1= my+by1;\n//                cy2= my+by2;\n//                bx1= -1*(ay*by1)/ax;\n//                bx2= -1*(ay*by2)/ax;\n//                cx1=bx1+mx;\n//                cx2=bx2+mx;\n\n\n                //あじのりコーナー\n                double mx=(x1+x2)/2,my=(y1+y2)/2;\n\n                double ld = 1-dist((x1-x2)/2,(y1-y2)/2);\n                ld = sqrt(ld);\n                cx1 = mx - sin(atan2(y2-y1,x2-x1))*ld;\n                cy1 = my + cos(atan2(y2-y1,x2-x1))*ld;\n                cx2 = mx + sin(atan2(y2-y1,x2-x1))*ld;\n                cy2 = my - cos(atan2(y2-y1,x2-x1))*ld;\n\n                for(int k = 0;k<n;k++) {\n                    tie(x3, y3) = p[k];\n                    if (EPS > dist((cx1 - x3), (cy1 - y3))-1) cnt1++;\n                    if (EPS > dist((cx2 - x3), (cy2 - y3))-1) cnt2++;\n                }\n                ma = max({cnt1,cnt2,ma});\n            }\n        }\n        cout<< ma << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\n#define P complex<double>\n#define EPS 1.0e-4\n\nint main(){\n  int n;\n  P p[301];\n\n  while( cin>>n && n ){\n    for( int i=0;i<n;i++ )\n      cin >> p[i].real() >> p[i].imag();\n\n    int ans=0;\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ ){\n\tif( i==j ) \t  continue;\n\tif( abs( p[i]-p[j] )+EPS > 2.0 ) continue;\n\n\tP m  = (p[i]+p[j]) / 2.0; // p[i]Æp[j]Ì_\n\tP nn = (p[i]-p[j]) * P(0,1);       // @üxNg\n\tnn = nn / abs(nn);\n\n\tdouble x = abs( p[i]-p[j] )/2.0;\n\tP c = m + nn*sqrt( 1.0-x*x );        // ~ÌS\n\n\tint num=0;\n\tfor( int k=0;k<n;k++ )\n\t  if( abs( c-p[k] ) < 1.0 + EPS  )\n\t    num++;\n\tans = max( ans,num );\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)n; i++)\n#define vec vector\n#define pdd pair<double, double>\n#define mp make_pair\n\ndouble dis(pdd a, pdd b)\n{\n\tpdd x = mp(a.first - b.first, a.second - b.second);\n\treturn sqrt(x.first * x.first + x.second * x.second);\n}\n\npdd find(pdd a, pdd b)\n{\n\tpdd v = mp(a.first - b.first, a.second - b.second);\n\tdouble d = sqrt(v.first * v.first + v.second * v.second);\n\t// double d = dis(a, b);\n\tif (d > 2.0) return mp(1000, 1000);\n\t// pdd o = mp(a.first + 0.5 * v.first, a.second + 0.5 * v.second);\n\tpdd o = mp((a.first + b.first) / 2.0, (a.second + b.second) / 2.0);\n\tpdd g = mp(v.second, - v.first);\n\tdouble s = sqrt(1.0 - d * d / 4.0);\n\t// double g_size = sqrt(g.first * g.first + g.second * g.second);\n\tdouble g_size = d;\n\tpdd ret = mp(o.first + g.first / g_size * s, o.second + g.second / g_size * s);\n\treturn ret;\n}\n\nint main(void)\n{\n\twhile(1) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tvec<pdd> a(n);\n\t\trep(i, n) cin >> a[i].first >> a[i].second;\n\t\tif (n == 1) {\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint MAX = 0;\n\t\trep(i, n) rep(j, n) {\n\t\t\tif (i == j) continue;\n\t\t\tpdd c = find(a[i], a[j]);\n\t\t\t// cout << i << \" \" << j << \" \" << c.first << \" \" << c.second << endl;\n\n\t\t\tint p = 0;\n\t\t\tif (c.first == 1000) p = 1;\n\t\t\telse {\n\t\t\t\t\trep(k, n) {\n\t\t\t\t\t// cout << dis(a[k], c) << \" \";\n\t\t\t\t\tif (dis(a[k], c) <= 1.0001) p++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// cout << p << endl;\n\t\t\tMAX = max(p, MAX);\n\t\t}\n\n\t\tcout << MAX << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<double, double> P;\n\nint N;\nP pos[300];\n\ndouble calcabs(P a, P b){\n  return sqrt(pow(a.first - b.first, 2) + pow(a.second - b.second, 2));\n}\n\nint main(){\n  while(1){\n    cin >> N;\n    if(N == 0)break;\n    for(int i = 0; i < N; i++)cin >> pos[i].first >> pos[i].second;\n    \n    int ans = 1;\n\n    for(int i = 0; i < N; i++){\n    for(int j = i + 1; j < N; j++){\n\tif(calcabs(pos[i], pos[j]) > 2)continue;\n\t\n\tP center[2];\n\t//calc the center of the circle which we put on the selected 2 points.\n\t\n\tcenter[0].first = (pos[i].first + pos[j].first) / 2.0 + \n\t  sqrt(1.0 - pow(calcabs(pos[i], pos[j]) , 2)/ 4.0) * \n\t  1.0 / calcabs(pos[i], pos[j]) * (-1 * (pos[i].second - pos[j].second));\n\t\n\tcenter[0].second = (pos[i].second + pos[j].second) / 2.0 + \n\t  sqrt(1.0 - pow(calcabs(pos[i], pos[j]), 2) / 4.0) * \n\t  1.0 / calcabs(pos[i], pos[j]) *  (pos[i].first - pos[j].first);\n\t\n\tcenter[1].first = (pos[i].first + pos[j].first) / 2.0 - \n\t  sqrt(1.0 - pow(calcabs(pos[i], pos[j]), 2) / 4.0) * \n\t  1.0 / calcabs(pos[i], pos[j]) * (-1 * (pos[i].second - pos[j].second));\n\t\n\tcenter[1].second = (pos[i].second + pos[j].second) / 2.0 - \n\t  sqrt(1.0 - pow(calcabs(pos[i], pos[j]), 2) / 4.0) * \n\t  1.0 / calcabs(pos[i], pos[j]) *  (pos[i].first - pos[j].first);\n\t\n\tint cnt = 0;\n\tfor(int k = 0; k < N; k++){\n\t  if(calcabs(center[0], pos[k]) <= 1.0001)cnt++;\n\t}\n\tans = max(ans, cnt);\n\t\n\tcnt = 0;\n\tfor(int k = 0; k < N; k++){\n\t  if(calcabs(center[1], pos[k]) <= 1.0001)cnt++;\n\t}\n\tans = max(ans, cnt);\n\t\n    }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(a); (i)<(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(a)-1; (i)>=(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, int> pli;\ntypedef complex<double> xy_t;\n\nconst lint mod = 1e9 + 7;\n\nint n;\nxy_t p[310];\nconst double pi = acos(-1.0);\n\nbool in_circle(xy_t t, xy_t c){\n    return abs(t - c) <= 1;\n}\n\nint cnt(int k, double t){\n    xy_t c = p[k] + xy_t(cos(t), sin(t));\n    int ret = 1;\n    rep(i, n)if(i != k){\n        ret += in_circle(p[i], c);\n    }\n    return ret;\n}\n\nint main(){\n    while(scanf(\"%d\", &n) && n){\n        rep(i, n){\n            double x, y;\n            scanf(\"%lf%lf\", &x, &y);\n            p[i] = xy_t(x, y);\n        }\n        int ans = 0;\n        rep(i, n)rep(d, 500){\n            ans = max(ans, cnt(i, 2*pi*d/500));\n        }\n        printf(\"%d\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\n\nconst long double EPS = 10e-6;\n\nclass Point{\n    public: \n    long double x,y;\n    \n    Point(long double x = 0.0, long double y = 0.0): x(x), y(y) {}\n    \n    Point operator + (Point p) const {\n        return Point(x+p.x, y+p.y);\n    }\n    Point operator - (Point p) const {\n        return Point(x-p.x, y-p.y);\n    }\n    Point operator * (long double a) const {\n        return Point(x*a, y*a);\n    }\n    Point operator / (long double a) const {\n        return Point(x/a, y/a);\n    }\n\n    long double norm() {\n        return x*x + y*y;\n    }\n    \n    long double dot(Point p) {\n        return x*p.x + y*p.y;\n    }\n};\n\nPoint calc_center(Point p, Point mid, Point midv){\n    long double norm = mid.norm();\n    midv = midv * sqrt((1.0 - norm) / norm);\n    return p+mid+midv;\n}\n\nint count(vector<Point> points, Point center){\n    int tmp = 0;\n    for(Point p: points){\n        Point v = p-center;\n        if(v.norm() <= 1.0 + EPS) tmp++;\n    }\n    return tmp;\n}\n\nint main() {\n    int n;\n    while(scanf(\"%d\", &n) && n){\n        vector<Point> points(n);\n        rep(n) scanf(\"%Lf %Lf\", &points[i].x, &points[i].y);\n\n        int ans = 1;\n        rep(n){\n            repp(j, n){\n                if(j == i) continue;\n                Point mid = (points[j] - points[i]);\n                mid = mid * 0.5;\n                Point center = calc_center(points[i], mid, Point(mid.y, -mid.x));\n                ans = max(count(points, center), ans);\n\n                center = calc_center(points[i], mid, Point(-mid.y, mid.x));\n                ans = max(count(points, center), ans);\n            }\n        }\n        printf(\"%d\\n\", ans);\n        debug(ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<double> comd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define fst\tfirst\n#define scn second\n#define bucnt(x)\t__buildin__popcount(x)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl\n\nconst ll inf = (ll)1e9;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-9;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\ndouble Dist2(pdd a, pdd b) {\n\treturn (a.fst - b.fst)*(a.fst - b.fst) + (a.scn - b.scn)*(a.scn - b.scn);\n}\n\nvector<pdd> getCenter(pdd a, pdd b) {\n\tvector<pdd> ret;\n\tpdd c = mp((a.fst + b.fst) / 2.0, (a.scn + b.scn) / 2.0);\n\tpdd v = mp(a.scn - b.scn, b.fst - a.fst);\n\tdouble D = sqrt(v.fst*v.fst + v.scn*v.scn);\n\tv.fst /= D;\tv.scn /= D;\n\tD = sqrt(1 - Dist2(a, b)/4.0);\n\tv.fst *= D;\tv.scn *= D;\n\tret.push_back(mp(c.fst + v.fst, c.scn + v.scn));\n\tret.push_back(mp(c.fst - v.fst, c.scn - v.scn));\n\treturn ret;\n}\n\nint main() {\n\twhile (true) {\n\t\tint n;\tcin >> n;\n\t\tif (n == 0)\tbreak;\n\t\tvector<pdd> p(n,mp(0,0));\n\t\trep(i, n) cin >> p[i].fst >> p[i].scn;\n\t\tint ret = 1;\n\t\trep(i, n) {\n\t\t\trep(j, i) {\n\t\t\t\tif (Dist2(p[i], p[j]) <= 4.0) {\n\t\t\t\t\tvector<pdd> c = getCenter(p[i], p[j]);\n\t\t\t\t\tint tmp = 0;\n\t\t\t\t\trep(k, n) {\n\t\t\t\t\t\tif (Dist2(c[0], p[k]) <= 1.0 + eps)\ttmp++;\n\t\t\t\t\t}\n\t\t\t\t\tret = max(ret, tmp);\n\t\t\t\t\ttmp = 0;\n\t\t\t\t\trep(k, n) {\n\t\t\t\t\t\tif (Dist2(c[1], p[k]) <= 1.0 + eps)\ttmp++;\n\t\t\t\t\t}\n\t\t\t\t\tret = max(ret, tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1.0e-8;\n\nint n;\ndouble xs[311];\ndouble ys[311];\n\nvoid solve() {\n    int maxval = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            double dx = xs[i] - xs[j];\n            double dy = ys[i] - ys[j];\n            if (dx * dx + dy * dy >= 4.0 - EPS) continue;\n\n            double mx = 0.5 * (xs[i] + xs[j]);\n            double my = 0.5 * (ys[i] + ys[j]);\n            double nx = -(ys[i] - ys[j]);\n            double ny = xs[i] - xs[j];\n            double nl = sqrt(nx * nx + ny * ny);\n            double cl = sqrt(1.0 - 0.25 * nl * nl);\n            nx = cl * nx / nl;\n            ny = cl * ny / nl;\n\n\n            int cnt;\n            double cx, cy;\n\n            cx = mx + nx;\n            cy = my + ny;\n            cnt = 0;\n            for (int k = 0; k < n; k++) {\n                dx = cx - xs[k];\n                dy = cy - ys[k];\n                if (dx * dx + dy * dy <= 1.0 + EPS) cnt++;\n            }\n            maxval = max(maxval, cnt);\n\n            cx = mx - nx;\n            cy = my - ny;\n            cnt = 0;\n            for (int k = 0; k < n; k++) {\n                dx = cx - xs[k];\n                dy = cy - ys[k];\n                if (dx * dx + dy * dy <= 1.0 + EPS) cnt++;\n            }\n            maxval = max(maxval, cnt);\n        }\n    }\n    printf(\"%d\\n\", maxval);\n}\n\nint main(int argc, char** argv) {\n    while (cin >> n) {\n        if (n == 0) break;\n        for (int i = 0; i < n; i++) {\n            cin >> xs[i] >> ys[i];\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define eps 1.0e-9\n\nusing namespace std;\n\nint N;\ndouble x[305], y[305];\n\nint count(double cx, double cy)\n{\n\tint ret = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tif( (cx - x[i])*(cx - x[i]) + (cy - y[i])*(cy - y[i]) <= 1 + eps) ret++;\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\tfor(int i = 0; i < N; i++) cin >> x[i] >> y[i];\n\t\t\n\t\tint ans = 1;\n\t\tdouble cx, cy;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\t\n\t\t\t\tdouble px = x[j] - x[i];\n\t\t\t\tdouble py = y[j] - y[i];\n\t\t\t\tdouble pnorm = sqrt(px*px + py*py);\n\t\t\t\tpx /= pnorm;\n\t\t\t\tpy /= pnorm;\n\t\t\t\t\n\t\t\t\tdouble mx = (x[i] + x[j]) / 2.0;\n\t\t\t\tdouble my = (y[i] + y[j]) / 2.0;\n\t\t\t\t\n\t\t\t\tdouble qnorm = 1 - pnorm*pnorm/4.0;\n\t\t\t\tif(qnorm < eps) continue;\n\t\t\t\tqnorm = sqrt(qnorm);\n\t\t\t\tdouble qx = qnorm * py;\n\t\t\t\tdouble qy = qnorm * -px;\n\t\t\t\t\n\t\t\t\tans = max(ans, count(mx + qx, my + qy));\n\t\t\t\tans = max(ans, count(mx - qx, my - qy));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <numeric>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<((x))<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n#define long long long\n#define EPS 1e-8\n\n// ???????°???°???????????????\ninline double add(double a, double b){\n  if(abs(a+b) < EPS*(abs(a) + abs(b))) return 0;\n  return a+b;\n}\n\nstruct Point{\n  double x,y;\n  Point() {}\n  Point(double nx, double ny) : x(nx), y(ny) {}\n  inline Point operator + (const Point & p){ return Point(add(x, p.x), add(y, p.y)); }\n  inline Point operator - (const Point & p){ return Point(add(x,-p.x), add(y,-p.y)); }\n  inline Point operator * (double d){ return Point(x*d, y*d); }\n  inline double dot(const Point & p){ return add(x * p.x, y*p.y); }  //??????\n  inline double det(const Point & p){ return add(x * p.y, -y*p.x); } //??????\n  inline double dist(const Point & p){ return sqrt((x-p.x)*(x-p.x) + (y-p.y)*(y-p.y)); }\n  inline bool operator < (const Point & p) const {\n    if(x != p.x) return x < p.x;\n    else return y < p.y;\n  }\n  inline bool operator == (const Point & p) const {\n    return (add(x, -p.x)==0) && (add(y, -p.y)==0);\n  }\n  friend ostream& operator<<(ostream& os, const Point& p) {\n    os << \"[\" << p.x << \",\" << p.y << \"]\";\n    return os;\n  }\n};\n\npair<Point, Point> calcCenter(Point &p1, Point &p2){\n  if(add(p1.x, -p2.x)==0){\n    double y = (p1.y + p2.y)/2;\n    double dx = sqrt(1 - (p1.y - y)*(p1.y - y));\n    return mp(Point(p1.x+dx, y), Point(p1.x-dx,y));\n  }\n  // 2???????????´???????????? Ax + By + C = 0 , A != 0\n  double A = 2*(p1.x - p2.x);\n  double B = 2*(p1.y - p2.y);\n  double C = - p1.x*p1.x + p2.x*p2.x - p1.y*p1.y + p2.y*p2.y;\n  // x = py+q\n  double p = -B/A; double q = -C/A;\n\n  // p1, p2 ??¨????????¢???1?????? ay^2 + 2by + c = 0\n  double a = 1 + p*p;\n  double b = p*q - p1.x*p - p1.y;\n  double c = q*q - 2*p1.x*q + p1.x*p1.x + p1.y*p1.y - 1;\n\n  double rt = sqrt(b*b-a*c);\n  double y1 = (-b+rt)/a;\n  double y2 = (-b-rt)/a;\n\n  return mp(Point(p*y1+q, y1), Point(p*y2+q, y2));\n}\n\nint main(){\n  int n;\n  while(scanf(\"%d\", &n), n){\n    vector<Point> vec;\n    rep(i,n){\n      double x,y;\n      scanf(\"%lf %lf\", &x, &y);\n      vec.pb(Point(x,y));\n    }\n\n    int res=0;\n    rep(i,n) repl(j,i+1,n) if(vec[i].dist(vec[j]) < 2){\n      pair<Point, Point> pr = calcCenter(vec[i], vec[j]);\n//      cout << pr.fi << pr.se << endl;\n      int cnt=0;\n      rep(k,n) if(pr.fi.dist(vec[k]) < 1) cnt++;\n      res = max(res, cnt);\n      cnt=0;\n      rep(k,n) if(pr.se.dist(vec[k]) < 1) cnt++;\n      res = max(res, cnt);\n    }\n\n    printf(\"%d\\n\", res);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 301\nusing namespace std;\ntypedef complex <double> P;\nconst double EPS = 1e-8;\nP p[N];\nint n;\n\nint cnt(P c){\n  int res=0;\n  for(int i=0;i<n;i++)\n    if(1-abs(c-p[i])>-EPS) res++;\n  return res;\n}\n\nP get_C(P a,P b){\n  double x=abs(b-a);\n  if(x>2||a==b) return a;\n  P c=P(x/2,sqrt(1-x*x/4))*(b-a)/abs(b-a)+a;\n\n  return c;  \n}\n\n\nint main(){\n  while(1){\n  cin>>n;\n  if(!n)break;\n  double a,b;\n  for(int i=0;i<n;i++)cin>>a>>b,p[i]=P(a,b);\n  \n  int ans=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      P c=get_C(p[i],p[j]);\n      ans=max(ans,cnt(c));\n    }\n  cout <<ans<<endl;  \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\nかかった時間：約1時間半\n最初はわかりませんが、aojで他の人のソースコードを参考して、\n先生のヒント「2点を通る円だけを考えれば十分である」がわかりました。\n簡単に作成し、でも何度もwrong answerでした。\n困っている時に、先生のヒントの「例外ケースにも注意」を思い出しました。\nそして点が一つしかない場合にプログラムが何も処理していないと発見しました。\n初条件を変えればacceptedを得ました。\n#endif\n#include <iostream>\n#include <complex>\n#include <cmath>\n#define EPS 1e-9\nusing namespace std;\ntypedef complex<double> xy_t;\nint n;\nxy_t points[301];\nint count_in(xy_t center)\n{\n  int ans=0;\n  for(int i=0;i<n;i++)\n  {\n    if (abs(center-points[i])<1.0+EPS)\n      ans++;\n  }\n  return ans;\n}\n\nxy_t ppdcl(xy_t a)\n{\n  return xy_t(a.imag(),-a.real());\n}\nxy_t delta_v(xy_t C1,xy_t C2)\n{\n  xy_t half=(C1-C2)*0.5;\n  double l=abs(half);\n  return ppdcl(half)*sqrt(1-l*l)*(1.0/l);\n}\n\nint main()\n{\n  while(1)\n  {\n    cin>>n;\n    if (n==0) break;\n    double x,y;\n    for(int i=0;i<n;i++)\n    {\n      cin>>x>>y;\n      points[i]=xy_t(x,y);\n    }\n    int maxn=1;\n    for(int i=0;i<n;i++)\n    {\n      for(int j=i;j<n;j++)\n      {\n        if(abs(points[i]-points[j])<2.0+EPS)\n        {\n          xy_t mid_p=(points[i]+points[j])*0.5;\n          maxn=max(maxn,count_in(mid_p+delta_v(points[i],points[j])));\n          maxn=max(maxn,count_in(mid_p-delta_v(points[i],points[j])));\n        }\n      }\n    }\n    cout<<maxn<<endl;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\n\nconst long double EPS = 10e-10;\n\nclass Point{\n    public: \n    long double x,y;\n    \n    Point(long double x = 0.0, long double y = 0.0): x(x), y(y) {}\n    \n    Point operator + (Point p) {\n        return Point(x+p.x, y+p.y);\n    }\n    Point operator - (Point p) {\n        return Point(x-p.x, y-p.y);\n    }\n    Point operator * (long double a) {\n        return Point(x*a, y*a);\n    }\n    Point operator / (long double a) {\n        return Point(x/a, y/a);\n    }\n    bool operator < (const Point &p) const {\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n    bool operator == (const Point &p) const {\n        return fabsl(x - p.x) < EPS && fabsl(y - p.y) < EPS;\n    }\n    \n    long double abs() {\n        return sqrt(norm());\n    }\n    \n    long double norm() {\n        return x*x + y*y;\n    }\n    \n    long double dot(Point p) {\n        return x*p.x + y*p.y;\n    }\n    \n    long double cross(Point p) {\n        return x*p.y - y*p.x;\n    }\n};\n\nint main() {\n    int n;\n    while(scanf(\"%d\", &n) && n){\n        vector<Point> points(n);\n        rep(n) cin >> points[i].x >> points[i].y;\n\n        int ans = 1;\n        rep(n){ /* 円周上の点 */\n            repp(j, n){ /* 直径上の点 */\n                if(j == i) continue;\n                Point p = points[j] - points[i];\n                if(p.abs() > 2.0) continue;\n                int tmp = 2;\n                repp(k, n){ /* 円の中に入る？ */\n                    if(k == i || k == j) continue;\n                    Point q = points[k] - points[i];\n                    long double cos_ = p.dot(q) / (p.abs() * q.abs());\n                    // printf(\"%d %d %d\\n\", i, j, k);\n                    // printf(\"%Lf %Lf\\n\", q.abs(), 2.0*cos_);\n                    if(q.abs() <= 2.0*abs(cos_)) tmp++;\n                }\n                ans = max(ans, tmp);\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nstruct Point{\n    double x,y;\n};\n\nvoid func(int N){\n\n    Point point[N];\n    double x_min = 100,y_min = 100,x_max = -1,y_max = -1;\n\n    for(int i = 0; i < N; i++){\n        scanf(\"%lf %lf\",&point[i].x,&point[i].y);\n        x_min = min(point[i].x,x_min);\n        y_min = min(point[i].y,y_min);\n        x_max = max(point[i].x,x_max);\n        y_max = max(point[i].y,y_max);\n    }\n\n    if(x_min > 1)x_min -= 0.05;\n    if(y_min > 1)y_min -= 0.05;\n    if(x_max < 9)x_max += 0.05;\n    if(y_max < 9)y_max += 0.05;\n\n    int count,max_count = 0;\n\n    for(double y = y_min; y <= y_max; y += 0.01){\n        for(double x = x_min; x <= x_max; x += 0.01){\n            count = 0;\n            for(int i = 0; i < N; i++){\n                if(sqrt((x-point[i].x)*(x-point[i].x)+(y-point[i].y)*(y-point[i].y)) <= 1.0)count++;\n            }\n            max_count = max(max_count,count);\n        }\n    }\n\n    printf(\"%d\\n\",max_count);\n}\n\n\nint main(){\n\n    int N;\n\n    while(true){\n        scanf(\"%d\",&N);\n        if(N == 0)break;\n\n        func(N);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\ntypedef complex<double> Point;\n\nint calc(Point p, vector<Point>& ps){\n    int ans = 0;\n    for(int i = 0; i < ps.size(); i++){\n        if(abs(ps[i] - p) < 1.0 + EPS) {\n            ans++;\n        }\n    }\n    return ans;\n}\nvector<Point> touching_circle(Point a, Point b, double r){\n    vector<Point> res;\n\n    double d = abs(b - a);\n    if(d > 2 * r) return res;\n\n    Point mid = 0.5 * (a + b);\n    Point dir = polar(sqrt(r * r - d * d / 4), arg(b - a) + M_PI / 2);\n    res.push_back(mid + dir);\n    res.push_back(mid - dir);\n    return res;\n}\nint main(){\n    int N;\n    while(cin >> N && N){\n        vector<Point> ps(N);\n        REP(i, N){\n            double x, y;\n            cin >> x >> y;\n            ps[i] = Point(x, y);\n        }\n        int ans = 1;\n        REP(i, N) REP(j, N) if(abs(ps[i] - ps[j]) > EPS) {\n            vector<Point> tp = touching_circle(ps[i], ps[j], 1.0);\n            for(Point c : tp){\n                ans = max(ans, calc(c, ps));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(N); i++)\n\nusing namespace std;\nnamespace geom{\n#define at(i) ((*this)[i])\n#define pb push_back\n#define X real()\n#define Y imag()\n#define SELF (*this)\ntypedef long double R;\ntypedef complex<R> P;\nconst R EPS = 1e-12;\nconst R PI=3.14159265358979323846264338327950288;\nenum { TURE = 1, FALSE = 0, BORDER= -1};\ninline int sig(const R&x){return (abs(x)<EPS?0:x>0?1:-1);}\ninline int less(const R &x,const R &y){return sig(x-y)?x<y:BORDER;}\ninline R inp(const P &a,const P &b){return (conj(a)*b).X;}\ninline R outp(const P &a,const P & b){return (conj(a)*b).Y;}\ninline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\ninline P unit(const P & p){return p/abs(p);}\ninline P proj(const P &s,const P &t){return t*inp(s,t)/norm(t);}\nstruct L :public vector<P>{\n  L(const P &p1,const P &p2){this->pb(p1);this->pb(p2);}\n  L(){}\n  P dir()const {return at(1)-at(0);}\n  int online(const P &p) const {return !sig(outp(p-at(0),dir()));}\n};\nstruct S: public L {\n    S(const P &p1, const P &p2): L(p1,p2){}\n    S(){}\n    int online(const P &p) const{\n        if(!sig(norm( p-at(0) )) || !sig(norm(p - at(1))) ) return BORDER;\n        return !sig(outp(p-at(0), dir())) && inp(p-at(0), dir()) > EPS && inp(p-at(1),-dir()) > -EPS;\n    }\n};\nstruct C :public P{\n  C(){}\n  C(const P &p,const R r):P(p),r(r){}\n  R r;\n  int inside(const P &p)const { return less(norm(p-SELF),r*r);}\n};\n//inline P proj(const P &s,const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\ninline int intersect (const C &a,const C &b){\n  return less((a.r-b.r)*(a.r-b.r),norm(a-b))+less(norm(a-b),(a.r+b.r)*(a.r+b.r))-1;\n}\n\ninline S crosspoint(const C &c1,const C &c2){\n  if(!intersect(c1,c2)) return S();\n  R d=abs(c1-c2);\n  R x=(c1.r*c1.r-c2.r*c2.r+d*d)/(2*d);\n  R h=sqrt(max<R>(0.,c1.r*c1.r-x*x));\n  P u=unit(c2-c1);\n  return S(c1+u*x+u*P(0,-1)*h,c1+u*x+u*P(0,1)*h);\n}\n\n// inline S crosspoint(const C &c,const L &l){\n//   R d2=dist2(l,c);\n//   if(c.r*c.r+EPS < d2) return S();\n//   P m= proj(c,l);\n//   P u = unit(l[1]-l[0]);\n//   R d=sqrt(max<R>(.0,c.r*c.r-d2));\n//   return S(m+u*d,m-u*d);\n// }\n\nS circlePPR(const P& a, const P& b, R r){\n    return crosspoint( C(a,r), C(b,r) );\n}\n}\nusing namespace geom;\n\nint main(){\n    int N;\n    while(cin>>N, N){\n        int ans = 0;\n        P po[305];\n        rep(i,N){\n            R x, y;\n            cin >> x >> y;\n            po[i] = P(x, y);\n        }\n        rep(i,N) rep(j,i){\n            //if( i==j ) continue;\n            S s = circlePPR( po[i], po[j], 1.0 );\n            //if( s.empty() ) continue;\n            //for(auto t: s) cout << t << \" \"; cout << endl;\n            for(auto k: s){\n                int count = 0;\n                rep(h,N){\n                    if( abs(k-po[h]) < 1.0 + EPS ){\n                        count++;\n                    }\n                }\n                ans = max(ans, count);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ndouble x[300], y[300];\nint n;\n\nint count(double x0, double y0, int p, int q){\n\tint ret = 2;\n\tREP(i,n){\n\t\tif(i==p||i==q)continue;\n\t\tdouble dx = x0-x[i];\n\t\tdouble dy = y0-y[i];\n\t\tif(pow(dx, 2.0)+pow(dy, 2.0)<1.0)ret++;\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(1){\n\t\tint ret = 1;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tREP(i,n)scanf(\"%lf %lf\", &x[i],&y[i]);\n\t\tREP(i,n){\n\t\t\tFOR(j, i+1,n){\n\t\t\t\tdouble dx = x[j]-x[i];\n\t\t\t\tdouble dy = y[j]-y[i];\n\t\t\t\tdouble d = sqrt(pow(dx, 2.0)+pow(dy, 2.0));\n\t\t\t\tif(d < 2.0){\n\t\t\t\t\tdouble mx = (x[j]+x[i])*0.5;\n\t\t\t\t\tdouble my = (y[j]+y[i])*0.5;\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble x1 = mx-dy/d*sqrt(1.0-d*d/4.0);\n\t\t\t\t\t\tdouble y1 = my+dx/d*sqrt(1.0-d*d/4.0);\n\t\t\t\t\t\tret = max(ret, count(x1, y1, i, j));\n\t\t\t\t\t}\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble x1 = mx+dy/d*sqrt(1.0-d*d/4.0);\n\t\t\t\t\t\tdouble y1 = my-dx/d*sqrt(1.0-d*d/4.0);\n\t\t\t\t\t\tret = max(ret, count(x1, y1, i, j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,N) for(int i=0;i<(int)(N);i++)\n#define REP(i,k,N) for(int i=k;i<(int)(N);i++)\n\n#define vi vector<int>\n#define pb push_back\n\n#define pdd pair<double,double>\n#define fi first\n#define se second\nconst double  EPS = 1e-7;\n\ndouble dist(double x,double y){\n    return x*x+y*y;\n};\n\nint main(){\n//    ifstream in(\"d_in.txt\");\n//    cin.rdbuf(in.rdbuf());\n    int n;\n    while(cin >> n,n){\n        int ma = 1;\n        pdd p[330];\n        rep(i,n) cin >> p[i].fi >> p[i].se;\n        rep(i,n-1){\n            REP(j,i+1,n){\n\n                double x1,y1,x2,y2,x3,y3;\n                tie(x1,y1) = p[i];\n                tie(x2,y2) = p[j];\n                double cx1,cy1,cx2,cy2;\n                if(dist(x1-x2,y1-y2)  > 4+EPS  ) continue;\n\n                //はりまコーナー\n//                double ax,ay,bx1,by1,bx2,by2,mx,my,dx,dy;\n//                ax=x1-x2;ay=y1-y2;\n//                mx=(x1+x2)/2;my=(y1+y2)/2;\n//                by1 = (-0.5)*pow(ax,4)+pow(ax,2)+(-0.5)*pow(ax,2)*pow(ay,2)\n//                        /dist(ax,ay);\n//                by1 = sqrt(abs(by1));\n//                by2 = -1*by1;\n//                cy1= my+by1;\n//                cy2= my+by2;\n//                bx1= -1*(ay*by1)/ax;\n//                bx2= -1*(ay*by2)/ax;\n//                cx1=bx1+mx;\n//                cx2=bx2+mx;\n\n\n                //あじのりコーナー\n                double mx=(x1+x2)/2,my=(y1+y2)/2;\n\n                double ld = sqrt(1-dist((x1-x2),(y1-y2))/4);\n                double theta = atan((y2-y1)/(x2-x1));\n                cx1 = mx - sin(theta)*ld;\n                cy1 = my + cos(theta)*ld;\n                cx2 = mx + sin(theta)*ld;\n                cy2 = my - cos(theta)*ld;\n\n                int cnt1 = 0,cnt2=0;\n                for(int k = 0;k<n;k++) {\n                    tie(x3, y3) = p[k];\n                    if (EPS + 1> dist((cx1 - x3), (cy1 - y3))) cnt1++;\n                    if (EPS + 1> dist((cx2 - x3), (cy2 - y3))) cnt2++;\n                }\n                ma = max({cnt1,cnt2,ma});\n            }\n        }\n        cout<< ma << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\n#define all(c) ((c).begin()),((c).end())\n#define debug(c) cerr<<\"> \"<<#c<<\" = \"<<(c)<<endl;\n#define iter(c) __typeof((c).begin())\n#define tr(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,a,b) for(int i=(int)(a);i<=(int)(b);i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\n#define EPS 1.0e-10\n\n//ツ点\ntypedef complex<double> P;\n\nstruct C{\n\tP p;\n\tdouble r;\n};\n\nvector<P> isCC(const C &c1, const C &c2) {\n\tdouble d = abs(c1.p - c2.p);\n\tdouble x = (d*d + c1.r * c1.r - c2.r * c2.r) / 2 / d;\n\tdouble y = c1.r * c1.r - x * x;\n\tif(y < -EPS) return vector<P>();\n\tif(y < 0) y = 0;\n\tP diff = (c2.p - c1.p) / d;\n\tvector<P> res(2);\n\tres[0] = c1.p + diff * P(x, y);\n\tres[1] = c1.p + diff * P(x, -y);\n\treturn res;\n}\n\nint main() {\n\tfor (int N; cin >> N, N != 0; ) {\n\t\tvector<P> ps;\n\t\trep (i, N) {\n\t\t\tdouble x, y; cin >> x >> y;\n\t\t\tps.pb(P(x, y));\n\t\t}\n\t\tint res = 0;\n\t\trep (i, N) REP (j, i + 1, N-1) {\n\t\t\tvector<P> isp = isCC((C){ps[i],1},(C){ps[j],1});\n\t\t\trep (k, isp.size()) {\n\t\t\t\tint cnt = 0;\n\t\t\t\trep (l, N) if (abs(isp[k] - ps[l]) <= 1) cnt++;\n\t\t\t\tres = max(res, cnt);\n\t\t\t}\n\t\t}\n\t\tcout << res <<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//???????????????????????????, ?????????????????????????????°????????????????????????????????????????????????2???????????¨???????????£?????\\????????¨?????§????????????\n//?????£???, 2??????????????????1?????????????????????????????????????????°??????????????????????£????, O(N^2)????????????????????????, ??¨?????§O(N^3)????????§?§£?????????\n#include <iostream>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> Point;\n\nint n;\ndouble x[300], y[300];\nvector<Point> points;\t//????£???????\n\nint main() {\n\twhile (cin >> n || n) {\n\t\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\t\tif (n == 1) { cout << 1 << endl; continue; }\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tPoint p1 = Point(x[i], y[i]);\n\t\t\t\tPoint p2 = Point(x[j], y[j]);\n\t\t\t\tif (norm(p1 - p2) < 4) {\n\t\t\t\t\tdouble h = sqrt(1.0 - norm(p1 - p2) / 4.0);\n\t\t\t\t\tPoint t = p2 - p1; t /= abs(t);\n\t\t\t\t\tPoint u = t * Point(0, 1);\n\t\t\t\t\tpoints.push_back(p1 + t * abs(p1 - p2) / 2.0 + u * h);\n\t\t\t\t\tpoints.push_back(p1 + t * abs(p1 - p2) / 2.0 - u * h);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble eps = 1e-7;\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < points.size(); i++) {\n\t\t\tint cnt = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tPoint p = Point(x[j], y[j]);\n\t\t\t\tif (norm(points[i] - p) < 1 + eps) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ans < cnt) ans = cnt;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nclass Point {\npublic:\n  double x, y;\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n  Point operator +(Point p) {\n    return Point(x+p.x, y+p.y);\n  }\n  Point operator -(Point p) {\n    return Point(x-p.x, y-p.y);\n  }\n  Point operator *(double a) {\n    return Point(x*a, y*a);\n  }\n  Point operator /(double a) {\n    return Point(x/a, y/a);\n  }\n  bool operator ==(const Point &p) const {\n    return x == p.x && y == p.y;\n  }\n  bool operator <(const Point &p) const {\n    double l1 = x+y;\n    double l2 = p.x+p.y;\n    if(l1 != l2) return l1 < l2;\n    if(y != p.y) return y < p.y;\n    return x < p.x;\n  }\n};\n\ntypedef Point Vector;\n\ndouble norm(Point p1, Point p2) {\n  return (p1.x-p2.x)*(p1.x-p2.x) + (p1.y-p2.y)*(p1.y-p2.y);\n}\n\nint n;\nPoint p[300];\n\nint calc(Point p1, Point p2) {\n  Point m = Point((p1.x+p2.x)/2.0, (p1.y+p2.y)/2.0);\n  Point o;\n  Vector moto = Vector(p2.y-p1.y, p1.x-p2.x);\n  int cnt = 0;\n  int newCnt;\n  double p1p2 = norm(p1,p2);\n  if(p1p2 > 4) return 1;\n  double l = sqrt(4.0/p1p2-1)/2.0;\n\n  for(int t = 0; t < 2; t++) {\n    newCnt = 0;\n    if(t == 1) {\n      moto = moto * (-1);\n    }\n    o = m + moto * l;\n\n    for(int i = 0; i < n; i++) {\n      if(newCnt + n-i <= cnt) break;\n      if(p[i] == p1 || p[i] == p2) continue;\n      if((p[i].x-o.x)*(p[i].x-o.x) + (p[i].y-o.y)*(p[i].y-o.y) <= 1.0) {\n\tnewCnt++;\n      }\n    }\n    if(newCnt > cnt) cnt = newCnt;\n  }\n  return cnt + 2;\n}\n\nmain() {\n  while(1) {\n    int ans;\n    cin >> n;\n    if(n == 0) break;\n    for(int i = 0; i < n; i++) {\n      cin >> p[i].x >> p[i].y;\n    }\n    sort(p, &p[n]);\n    ans = -1;\n    for(int i = 0; i < n; i++) {\n      for(int j = i+1; j < n; j++) {\n\tans = max(ans, calc(p[i],p[j]));\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\ntypedef pair<double, double> PD;\n\nconst double EPS = 1e-11;\ndouble sq(double x) { return x * x; }\n\nvoid solve(double ax, double ay, double bx, double by, int &ma,\n\t\t const vector<double> &x, const vector<double> &y) {\n  double sqdist = sq(ax - bx) + sq(ay - by);\n  if (sqdist >= 4 + EPS) return;\n  double dist = sqrt(sqdist);\n  double ndist = sqrt(1 - sqdist / 4);\n  double ex = (bx - ax) / dist, ey = (by - ay) / dist;\n  int n = x.size();\n  REP(i, 0, 2) {\n    double coef = i == 0 ? 1 : -1;\n    double cx = (ax + bx) / 2 + ey * coef * ndist;\n    double cy = (ay + by) / 2 - ex * coef * ndist;\n    int cnt = 0;\n    REP(j, 0, n) {\n      double sqdist = sq(x[j] - cx) + sq(y[j] - cy);\n      if (sqdist <= 1 + EPS) {\n\tcnt += 1;\n      }\n    }\n    ma = max(ma, cnt);\n  }\n}\n\nint main(void) {\n  int n;\n  while(scanf(\"%d\", &n) && n) {\n    vector<double> x(n), y(n);\n    REP(i, 0, n) scanf(\"%lf%lf\", &x[i], &y[i]);\n    int ma = 0;\n    REP(i, 0, n) {\n      REP(j, 0, i) {\n        solve(x[i], y[i], x[j], y[j], ma, x, y);\n      }\n    }\n    printf(\"%d\\n\", ma);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef complex<double> P;\nconst double EPS = 1e-8;\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    vector<P> v;\n    REP(i,n) {\n      double x,y;\n      cin >> x >> y;\n      v.push_back(P(x,y));\n    }\n    int ans = 1;\n    REP(i,n-1) {\n      for (int j=i+1;j<n;j++) {\n        P m = (v[i]+v[j])*P(0.5,0);\n        //cout << \"m \"<< m << endl;\n        P a = v[i]-v[j];\n        double dis = abs(a);\n        if (1-dis*dis/4<0) continue;\n        double d = sqrt(1-dis*dis/4);\n        int hoge[]={1,-1};\n        REP(k,2) {\n          P un = (a * P(0, hoge[k])) / dis;\n          P o1 = m + un*d;\n          //cout << o1 << endl;\n          int sum = 0;\n          REP(l,n) {\n            if (norm(v[l]-o1)<1+EPS) sum++;\n          }\n          ans = max(ans,sum);\n        }\n      }\n    }\n    cout << ans << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(N); i++)\n\nusing namespace std;\nnamespace geom{\n#define at(i) ((*this)[i])\n#define pb push_back\n#define X real()\n#define Y imag()\n#define SELF (*this)\ntypedef long double R;\ntypedef complex<R> P;\nconst R EPS = 1e-8;\nconst R PI=3.14159265358979323846264338327950288;\nenum { TURE = 1, FALSE = 0, BORDER= -1};\ninline int sig(const R&x){return (abs(x)<EPS?0:x>0?1:-1);}\ninline int less(const R &x,const R &y){return sig(x-y)?x<y:BORDER;}\ninline R inp(const P &a,const P &b){return (conj(a)*b).X;}\ninline R outp(const P &a,const P & b){return (conj(a)*b).Y;}\ninline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\ninline P unit(const P & p){return p/abs(p);}\ninline P proj(const P &s,const P &t){return t*inp(s,t)/norm(t);}\nstruct L :public vector<P>{\n  L(const P &p1,const P &p2){this->pb(p1);this->pb(p2);}\n  L(){}\n  P dir()const {return at(1)-at(0);}\n  int online(const P &p) const {return !sig(outp(p-at(0),dir()));}\n};\nstruct S: public L {\n    S(const P &p1, const P &p2): L(p1,p2){}\n    S(){}\n    int online(const P &p) const{\n        if(!sig(norm( p-at(0) )) || !sig(norm(p - at(1))) ) return BORDER;\n        return !sig(outp(p-at(0), dir())) && inp(p-at(0), dir()) > EPS && inp(p-at(1),-dir()) > -EPS;\n    }\n};\nstruct C :public P{\n  C(){}\n  C(const P &p,const R r):P(p),r(r){}\n  R r;\n  int inside(const P &p)const { return less(norm(p-SELF),r*r);}\n};\n//inline P proj(const P &s,const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\ninline int intersect (const C &a,const C &b){\n  return less((a.r-b.r)*(a.r-b.r),norm(a-b))+less(norm(a-b),(a.r+b.r)*(a.r+b.r))-1;\n}\n\ninline S crosspoint(const C &c1,const C &c2){\n  if(!intersect(c1,c2)) return S();\n  R d=abs(c1-c2);\n  R x=(c1.r*c1.r-c2.r*c2.r+d*d)/(2*d);\n  R h=sqrt(max<R>(0.,c1.r*c1.r-x*x));\n  P u=unit(c2-c1);\n  return S(c1+u*x+u*P(0,-1)*h,c1+u*x+u*P(0,1)*h);\n}\n\n// inline S crosspoint(const C &c,const L &l){\n//   R d2=dist2(l,c);\n//   if(c.r*c.r+EPS < d2) return S();\n//   P m= proj(c,l);\n//   P u = unit(l[1]-l[0]);\n//   R d=sqrt(max<R>(.0,c.r*c.r-d2));\n//   return S(m+u*d,m-u*d);\n// }\n\nS circlePPR(const P& a, const P& b, R r){\n    return crosspoint( C(a,r), C(b,r) );\n}\n}\nusing namespace geom;\n\nint main(){\n    int N;\n    while(cin>>N, N){\n        int ans = 1;\n        P po[305];\n        rep(i,N){\n            R x, y;\n            cin >> x >> y;\n            po[i] = P(x, y);\n        }\n        rep(i,N) rep(j,i){\n            //if( i==j ) continue;\n            S s = circlePPR( po[i], po[j], 1.0 );\n            //if( s.empty() ) continue;\n            //for(auto t: s) cout << t << \" \"; cout << endl;\n            for(auto k: s){\n                int count = 0;\n                rep(h,N){\n                    if( abs(k-po[h]) < 1.0 + EPS ){\n                        count++;\n                    }\n                }\n                ans = max(ans, count);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n\n////////////////////////////\n// 基本要素 (点, 線分, 円)\n////////////////////////////\n\nusing DD = double;\nconst DD INF = 1LL<<60;      // to be set appropriately\nconst DD EPS = 1e-4;        // to be set appropriately\nconst DD PI = acosl(-1.0);\nDD torad(int deg) {return (DD)(deg) * PI / 180;}\nDD todeg(DD ang) {return ang * 180 / PI;}\n\n/* Point */\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\ninline Point operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\ninline Point operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\ninline Point operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}\ninline Point operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}\ninline Point operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\ninline Point operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}\ninline Point conj(const Point &p) {return Point(p.x, -p.y);}\ninline Point rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\ninline Point rot90(const Point &p) {return Point(-p.y, p.x);}\ninline DD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\ninline DD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\ninline DD norm(const Point &p) {return dot(p, p);}\ninline DD abs(const Point &p) {return sqrt(dot(p, p));}\ninline DD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\ninline bool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}\ninline bool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\ninline bool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\ninline Point operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\n/* Line */\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n    friend ostream& operator << (ostream &s, const Line &l) {return s << '{' << l[0] << \", \" << l[1] << '}';}\n};\n\n/* Circle */\nstruct Circle : Point {\n    DD r;\n    Circle(Point p = Point(0.0, 0.0), DD r = 0.0) : Point(p), r(r) {}\n    friend ostream& operator << (ostream &s, const Circle &c) {return s << '(' << c.x << \", \" << c.y << \", \" << c.r << ')';}\n};\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nPoint proj_for_crosspoint(const Point &p, const Line &l) {\n    DD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nvector<Point> crosspoint(const Line &l, const Line &m) {\n    vector<Point> res;\n    DD d = cross(m[1] - m[0], l[1] - l[0]);\n    if (abs(d) < EPS) return vector<Point>();\n    res.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n    return res;\n}\nvector<Point> crosspoint(const Circle &e, const Circle &f) {\n    vector<Point> res;\n    DD d = abs(e - f);\n    if (d < EPS) return vector<Point>();\n    if (d > e.r + f.r + EPS) return vector<Point>();\n    if (d < abs(e.r - f.r) - EPS) return vector<Point>();\n    DD rcos = (d * d + e.r * e.r - f.r * f.r) / (2.0 * d), rsin;\n    if (e.r - abs(rcos) < EPS) rsin = 0;\n    else rsin = sqrt(e.r * e.r - rcos * rcos);\n    Point dir = (f - e) / d;\n    Point p1 = e + dir * Point(rcos, rsin);\n    Point p2 = e + dir * Point(rcos, -rsin);\n    res.push_back(p1);\n    if (!eq(p1, p2)) res.push_back(p2);\n    return res;\n}\nvector<Point> crosspoint(const Circle &e, const Line &l) {\n    vector<Point> res;\n    Point p = proj_for_crosspoint(e, l);\n    DD rcos = abs(e - p), rsin;\n    if (rcos > e.r + EPS) return vector<Point>();\n    else if (e.r - rcos < EPS) rsin = 0;\n    else rsin = sqrt(e.r * e.r - rcos * rcos);\n    Point dir = (l[1] - l[0]) / abs(l[1] - l[0]);\n    Point p1 = p + dir * rsin;\n    Point p2 = p - dir * rsin;\n    res.push_back(p1);\n    if (!eq(p1, p2)) res.push_back(p2);\n    return res;\n}\n\n\n\nint main() {\n    int N;\n    while (cin >> N, N) {\n        vector<Point> v(N);\n        for (int i = 0; i < N; ++i) cin >> v[i].x >> v[i].y;\n\n        vector<Point> alt;\n        for (int i = 0; i < N; ++i) {\n            for (int j = i+1; j < N; ++j) {\n                Circle c1(v[i], 1.0), c2(v[j], 1.0);\n                auto cp = crosspoint(c1, c2);\n                for (auto p : cp) alt.push_back(p);\n            }\n        }\n\n        int res = 1;\n        for (auto p : alt) {\n            int tmp = 0;\n            for (auto q : v) if (abs(p-q) < 1.0 + EPS) ++tmp;\n            res = max(res, tmp);\n        }\n        cout << res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble distance(pair<double,double> p1,pair<double,double> p2){\n\treturn sqrt((p1.first-p2.first)*(p1.first-p2.first)+(p1.second-p2.second)*(p1.second-p2.second));\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<double> x(n);\n\t\tvector<double> y(n);\n\t\tint res=1;\n\t\tfor(int i=0;i<n;i++) cin>>x[i]>>y[i];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tpair<double,double> midp=make_pair((x[i]+x[j])/2,(y[i]+y[j])/2);\n\t\t\t\tdouble a=-(x[i]-x[j]),b=(y[i]-y[j]);\n\t\t\t\tif(a<0.000001) a=0;\n\t\t\t\tif(b<0.000001) b=0;\n\t\t\t\t//a(x-mid[i].first)+b(y-mid.second)=0\n\t\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\t\tpair<double,double> lef=midp;\n\t\t\t\t\t\tpair<double,double> rig;\n\t\t\t\t\t\tif(k==0) rig=make_pair(-b*1e8+midp.first,a*1e8+midp.second);\n\t\t\t\t\t\tif(k==1) rig=make_pair(b*1e8+midp.first,-a*1e8+midp.second);\n\t\t\t\t\t\twhile(distance(lef,rig)>=0.0000000001){\n\t\t\t\t\t\t\t\tpair<double,double> mid=make_pair((lef.first+rig.first)/2,(lef.second+rig.second)/2);\n\t\t\t\t\t\t\t\tif(distance(mid,make_pair(x[i],y[i]))>1){\n\t\t\t\t\t\t\t\t\trig=mid;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tlef=mid;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint count=0;\n\t\t\t\t\t\tfor(int r=0;r<n;r++){\n\t\t\t\t\t\t\tif(distance(make_pair(x[r],y[r]),lef)<1+0.00005){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres=max(res,count);\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout<<res<<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\nconst int MAXN = 333;\nint N;\nP ps[MAXN];\n\nint calc(P c) {\n  int res = 0;\n  for(int i = 0; i < N; ++i) {\n    double d = abs(c - ps[i]);\n    if(d < 1+eps) ++res;\n  }\n  return res;\n}\n\nint main() {\n  for(; cin >> N && N; ) {\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    int res = 0;\n    for(int i = 0; i < N; ++i) {\n      for(int j = i+1; j < N; ++j) {\n        double d = abs(ps[i] - ps[j]);\n        P base = ps[i] - ps[j];\n        P m = ps[j] + base / 2.0;\n        P base2(-base.imag(), base.real());\n        double a = sqrt(1.0 - d * d / 4.0);\n        base2 = base2 / abs(base2) * a;\n        res = max(res, max(calc(m + base2), calc(m - base2)));\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nint INF=1e9;\nint MOD=1000000007;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ndouble EPS = 1e-10;\ndouble add(double a,double b){\n\tif(abs(a+b)<EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,p.x),add(y,-p.y));\n\t}\n\tP operator * (P p){\n\t\treturn P(x*p.x,y*p.y);\n\t}\n};\ndouble dist(P a,P b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\nint cnt(P pos,vector<P> dat){\n\tint res=0;\n\tREP(i,dat.size()){\n\t\tif(dist(pos,dat[i])<=1.0)res++;\n\t}\n\treturn res;\n}\nint main(){\n\tint n;\n\tdouble x,y;\n\twhile(scanf(\"%d\",&n)&&n){\n\t\tvector<P> dat;\n\t\tREP(i,n){\n\t\t\tcin>>x>>y;\n\t\t\tdat.PB(P(x,y));\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tP a=dat[i],b=dat[j];\n\t\t\t\tP mid=P((a.x+b.x)/2,(a.y+b.y)/2);\n\t\t\t\tif(dist(a,b)>2){\n\t\t\t\t\tans=max(ans,1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble dx=a.y-b.y,dy=b.x-a.x;\n\t\t\t\tdouble dd=sqrt(dx*dx+dy*dy);\n\t\t\t\tdouble ddd=sqrt(1-dist(a,b)/2*dist(a,b)/2);\n\t\t\t\tdx=dx/dd*ddd;dy=dy/dd*ddd;\n\t\t\t\tans=max(ans,cnt(P(mid.x+dx,mid.y+dy),dat));\n\t\t\t\tans=max(ans,cnt(P(mid.x-dx,mid.y-dy),dat));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> P;\nconst LL MOD = 1000000007LL;\nconst double EPS = 1e-10;\nstruct Point {\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\tPoint operator+(Point &p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator-(Point &p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator*(double a) {\n\t\treturn Point(x*a, y*a);\n\t}\n\tPoint operator/(double a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm() {\n\t\treturn x*x + y*y;\n\t}\n\tbool operator<(const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator==(const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\ntypedef Point Vector;\nstruct Segment {\n\tPoint p1, p2;\n};\ntypedef Segment Line;\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\ntypedef vector<Point> Polygon;\ndouble norm(Vector a) {\n\treturn a.x*a.x + a.y*a.y;\n}\ndouble abs(Vector a) {\n\treturn sqrt(norm(a));\n}\ndouble dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\ndouble cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\nbool equals(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base*r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\ndouble getDistance(Point a, Point b) {\n\treturn abs(a - b);\n}\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\nbool intersect(Circle c, Line l) {\n\treturn getDistanceLP(l, c.c) <= c.r;\n}\nbool intersect(Circle c1, Circle c2) {\n\treturn getDistance(c1.c, c2.c) <= c1.r + c2.r;\n}\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r*c.r - norm(pr - c.c));\n\treturn make_pair(pr + e*base, pr - e*base);\n}\ndouble arg(Vector p) {\n\treturn atan2(p.y, p.x);\n}\nVector polar(double a, double r) {\n\treturn Vector(cos(r)*a, sin(r)*a);\n}\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\tassert(intersect(c1, c2));\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tPoint p[300];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = Point(x, y);\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tVector d = p[j] - p[i];\n\t\t\t\tif (d.abs() > 2.0) continue;\n\t\t\t\tPoint m = p[i] + d / 2.0;\n\t\t\t\tVector r = Vector(-d.y, d.x);\n\t\t\t\tr = r / r.abs()*sqrt(1 - pow(d.abs() / 2.0, 2));\n\t\t\t\tPoint p1 = m + r;\n\t\t\t\tPoint p2 = m - r;\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tint cnt2 = 0;\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif ((p[k] - p1).abs() <= 1) cnt1++;\n\t\t\t\t\tif ((p[k] - p2).abs() <= 1) cnt2++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, max(cnt1, cnt2));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <complex>\n\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,n) loop(i,0,n)\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef complex<double> vec;\n\ndouble const pi = acos(-1);\ndouble const eps = 1e-6;\n\nint main(){\n    int n;\n    while (cin >> n && n){\n        vector<vec> v(n);\n        rep(i, n){\n            double x, y; cin >> x >> y;\n            vec p(x, y);\n            v[i] = p;\n        }\n\n        if (n == 1) {\n            puts(\"1\");\n            break;\n        }\n        if (n == 2){\n            if (abs(v[0] - v[1]) < 2 - eps) {\n                puts(\"2\"); break;\n            }\n            else{\n                puts(\"1\"); break;\n            }\n        }\n\n        int ans = 0;\n        rep(i, n)rep(j, i){\n            double d = abs(v[i] - v[j]);\n            if (d - eps > 2) continue;\n            double h = 1 - d*d / 4;\n            vec c1 = polar(h, arg(v[i] - v[j]) + pi / 2) + (v[i] + v[j]) / 2.;\n            vec c2 = polar(h, arg(v[i] - v[j]) - pi / 2) + (v[i] + v[j]) / 2.;\n            int a1 = 0, a2 = 0;\n            rep(k, n){\n                if (abs(c1 - v[k]) <= 1 - eps) a1++;\n                if (abs(c2 - v[k]) <= 1 - eps) a2++;\n            }\n            ans = max(ans, a1);\n            ans = max(ans, a2);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Control.Applicative\nimport Data.Array\n\neps :: Double\neps = 1.0e-8\n\ndata Point = Point (Double, Double) deriving (Show)\nadd (Point (x1, y1)) (Point (x2, y2)) = Point (x1 + x2, y1 + y2)\nsub (Point (x1, y1)) (Point (x2, y2)) = Point (x1 - x2, y1 - y2)\nmul (Point (x, y)) s = Point (x * s, y * s)\ndet (Point (x1, y1)) (Point (x2, y2)) = x1 * y2 - y1 * x2\nnrm (Point (x, y)) = Point (x / n, y / n) where n = sqrt $ (x * x + y * y)\ndist (Point (x1, y1)) (Point (x2, y2)) = sqrt (dx * dx + dy * dy) where\n    dx = x1 - x2\n    dy = y1 - y2\n\ngetX (Point (x, _)) = x\ngetY (Point (_, y)) = y\n\nparsePoint :: String -> Point\nparsePoint str =\n    let [x, y] = map read $ words str\n    in Point (x, y)\n\ncalcCenter :: Point -> Point -> (Point, Point)\ncalcCenter a b =\n    let m = (a `add` b) `mul` 0.5\n        d = sqrt (1.0 - (dist a m))\n        e = a `sub` b\n        n = nrm $ Point (negate $ getY e, getX e)\n        c1 = m `add` (n `mul` d)\n        c2 = m `sub` (n `mul` d)\n    in (c1, c2)\n\nsolve' :: [Point] -> Int\nsolve' pts =\n    let np    = length pts\n        parr  = listArray (0,np-1) pts\n        pairs = [ (parr ! i, parr ! j) | i <- [0..np-1], j <- [i+1..np-1] ]\n    in if null pairs\n        then 1\n        else maximum $ map countUp pairs where\n            countUp (p, q) =\n                if (dist p q) >= 2.0 - eps\n                    then 1\n                    else\n                        let (c1, c2) = calcCenter p q\n                            m1 = length $ filter (\\p -> (dist p c1) <= 1.0 + eps) pts\n                            m2 = length $ filter (\\p -> (dist p c2) <= 1.0 + eps) pts\n                        in (max m1 m2)\n\nsolve :: [String] -> [Int]\nsolve []   = []\nsolve cont =\n    let n           = read (head cont) :: Int\n        (crds, rst) = splitAt n (tail cont)\n        pts         = map parsePoint crds\n    in if n == 0 then []\n                 else (solve' pts) : solve rst\n\nmain :: IO ()\nmain = do\n    contents <- getContents\n    mapM_ print $ solve $ lines contents"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Control.Applicative\nimport Debug.Trace\n\ndata Point = Point (Double, Double) deriving (Show)\nadd (Point (x1, y1)) (Point (x2, y2)) = Point (x1 + x2, y1 + y2)\nsub (Point (x1, y1)) (Point (x2, y2)) = Point (x1 - x2, y1 - y2)\nmul (Point (x, y)) s = Point (x * s, y * s)\ndet (Point (x1, y1)) (Point (x2, y2)) = x1 * y2 - y1 * x2\nnrm (Point (x, y)) = Point (x / n, y / n) where n = sqrt $ (x * x + y * y)\ndist (Point (x1, y1)) (Point (x2, y2)) = sqrt (dx * dx + dy * dy) where\n    dx = x1 - x2\n    dy = y1 - y2\n\ngetX (Point (x, _)) = x\ngetY (Point (_, y)) = y\n\nparsePoint :: String -> Point\nparsePoint str =\n    let [x, y] = map read $ words str\n    in Point (x, y)\n\ncalcCenter :: Point -> Point -> (Point, Point)\ncalcCenter a b =\n    let m = (a `add` b) `mul` 0.5\n        d = sqrt (1.0 - (dist a m))\n        e = a `sub` b\n        n = nrm $ Point (negate $ getY e, getX e)\n        c1 = m `add` (n `mul` d)\n        c2 = m `sub` (n `mul` d)\n    in (c1, c2)\n\nsolve' :: [Point] -> Int\nsolve' pts =\n    let cs = [ calcCenter a b | a <- pts, b <- pts ]\n        inside p q = (dist p q) <= 1.0\n        countIn c = length $ filter (\\p -> inside c p) pts\n        m1 = maximum $ map (countIn . fst) cs\n        m2 = maximum $ map (countIn . snd) cs\n    in (max m1 m2)\n\nsolve :: [String] -> [Int]\nsolve []   = []\nsolve cont =\n    let n           = read (head cont) :: Int\n        (crds, rst) = splitAt n (tail cont)\n        pts         = map parsePoint crds\n    in if n == 0 then []\n                 else (solve' pts) : solve rst\n\nmain :: IO ()\nmain = do\n    contents <- getContents\n    mapM_ print $ solve $ lines contents"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Control.Applicative\nimport Data.Array\n\neps :: Double\neps = 1.0e-8\n\ntype Point = (Double, Double)\nadd (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)\nsub (x1, y1) (x2, y2) = (x1 - x2, y1 - y2)\nmul (x, y) s = (x * s, y * s)\nnrm  (x, y) = (x / n, y / n) where n = sqrt $ (x * x + y * y)\ndst  (x, y) = sqrt $ (x * x + y * y)\ndst2 (x, y) = x * x + y * y\ngetX (x, _) = x\ngetY (_, y) = y\n\nparsePoint :: String -> Point\nparsePoint str =\n    let [x, y] = map read $ words str\n    in (x, y)\n\ncalcCenter :: Point -> Point -> (Point, Point)\ncalcCenter a b =\n    let m = (a `add` b) `mul` 0.5\n        d = sqrt (1.0 - ((dst $ a `sub` m) ** 2.0))\n        e = a `sub` b\n        n = nrm $ (negate $ getY e, getX e)\n        c1 = m `add` (n `mul` d)\n        c2 = m `sub` (n `mul` d)\n    in (c1, c2)\n\nsolve' :: [Point] -> Int\nsolve' pts =\n    let np    = length pts\n        parr  = listArray (0, np-1) pts\n        pairs = [ (parr ! i, parr ! j) | i <- [0..np-1], j <- [i+1..np-1] ]\n    in if null pairs\n        then 1\n        else maximum $ map countUp pairs where\n            countUp (p, q) =\n                if (dst2 $ p `sub` q) >= 4.0 - eps\n                    then 1\n                    else\n                        let (c1, c2) = calcCenter p q\n                            m1 = length $ filter (\\p -> (dst2 $ p `sub` c1) <= 1.0 + eps) pts\n                            m2 = length $ filter (\\p -> (dst2 $ p `sub` c2) <= 1.0 + eps) pts\n                        in (max m1 m2)\n\nsolve :: [String] -> [Int]\nsolve []   = []\nsolve cont =\n    let n           = read (head cont) :: Int\n        (crds, rst) = splitAt n (tail cont)\n        pts         = map parsePoint crds\n    in if n == 0 then []\n                 else (solve' pts) : solve rst\n\nmain :: IO ()\nmain = do\n    contents <- getContents\n    mapM_ print $ solve $ lines contents"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Control.Applicative\nimport Data.Array\n\neps :: Double\neps = 1.0e-8\n\ndata Point = Point (Double, Double) deriving (Show)\nadd (Point (x1, y1)) (Point (x2, y2)) = Point (x1 + x2, y1 + y2)\nsub (Point (x1, y1)) (Point (x2, y2)) = Point (x1 - x2, y1 - y2)\nmul (Point (x, y)) s = Point (x * s, y * s)\nnrm (Point (x, y)) = Point (x / n, y / n) where n = sqrt $ (x * x + y * y)\ndst  (Point (x, y)) = sqrt $ (x * x + y * y)\ndst2 (Point (x, y)) = x * x + y * y\ngetX (Point (x, _)) = x\ngetY (Point (_, y)) = y\n\nparsePoint :: String -> Point\nparsePoint str =\n    let [x, y] = map read $ words str\n    in Point (x, y)\n\ncalcCenter :: Point -> Point -> (Point, Point)\ncalcCenter a b =\n    let m = (a `add` b) `mul` 0.5\n        d = sqrt (1.0 - ((dst $ a `sub` m) ** 2.0))\n        e = a `sub` b\n        n = nrm $ Point (negate $ getY e, getX e)\n        c1 = m `add` (n `mul` d)\n        c2 = m `sub` (n `mul` d)\n    in (c1, c2)\n\nsolve' :: [Point] -> Int\nsolve' pts =\n    let np    = length pts\n        parr  = listArray (0, np-1) pts\n        pairs = [ (parr ! i, parr ! j) | i <- [0..np-1], j <- [i+1..np-1] ]\n    in if null pairs\n        then 1\n        else maximum $ map countUp pairs where\n            countUp (p, q) =\n                if (dst2 $ p `sub` q) >= 4.0 - eps\n                    then 1\n                    else\n                        let (c1, c2) = calcCenter p q\n                            m1 = length $ filter (\\p -> (dst2 $ p `sub` c1) <= 1.0 + eps) pts\n                            m2 = length $ filter (\\p -> (dst2 $ p `sub` c2) <= 1.0 + eps) pts\n                        in (max m1 m2)\n\nsolve :: [String] -> [Int]\nsolve []   = []\nsolve cont =\n    let n           = read (head cont) :: Int\n        (crds, rst) = splitAt n (tail cont)\n        pts         = map parsePoint crds\n    in if n == 0 then []\n                 else (solve' pts) : solve rst\n\nmain :: IO ()\nmain = do\n    contents <- getContents\n    mapM_ print $ solve $ lines contents"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Control.Applicative\n\neps :: Double\neps = 1.0e-8\n\ndata Point = Point (Double, Double) deriving (Show)\nadd (Point (x1, y1)) (Point (x2, y2)) = Point (x1 + x2, y1 + y2)\nsub (Point (x1, y1)) (Point (x2, y2)) = Point (x1 - x2, y1 - y2)\nmul (Point (x, y)) s = Point (x * s, y * s)\ndet (Point (x1, y1)) (Point (x2, y2)) = x1 * y2 - y1 * x2\nnrm (Point (x, y)) = Point (x / n, y / n) where n = sqrt $ (x * x + y * y)\ndist (Point (x1, y1)) (Point (x2, y2)) = sqrt (dx * dx + dy * dy) where\n    dx = x1 - x2\n    dy = y1 - y2\n\ngetX (Point (x, _)) = x\ngetY (Point (_, y)) = y\n\nparsePoint :: String -> Point\nparsePoint str =\n    let [x, y] = map read $ words str\n    in Point (x, y)\n\ncalcCenter :: Point -> Point -> (Point, Point)\ncalcCenter a b =\n    let m = (a `add` b) `mul` 0.5\n        d = sqrt (1.0 - (dist a m))\n        e = a `sub` b\n        n = nrm $ Point (negate $ getY e, getX e)\n        c1 = m `add` (n `mul` d)\n        c2 = m `sub` (n `mul` d)\n    in (c1, c2)\n\nsolve' :: [Point] -> Int\nsolve' pts =\n    let np    = length pts\n        pairs = [ (pts !! i, pts !! j) | i <- [0..np-1], j <- [i+1..np-1] ]\n    in if null pairs\n        then 1\n        else maximum $ map countUp pairs where\n            countUp (p, q) =\n                if (dist p q) >= 2.0 - eps\n                    then 1\n                    else\n                        let (c1, c2) = calcCenter p q\n                            m1 = length $ filter (\\p -> (dist p c1) <= 1.0 + eps) pts\n                            m2 = length $ filter (\\p -> (dist p c2) <= 1.0 + eps) pts\n                        in (max m1 m2)\n\nsolve :: [String] -> [Int]\nsolve []   = []\nsolve cont =\n    let n           = read (head cont) :: Int\n        (crds, rst) = splitAt n (tail cont)\n        pts         = map parsePoint crds\n    in if n == 0 then []\n                 else (solve' pts) : solve rst\n\nmain :: IO ()\nmain = do\n    contents <- getContents\n    mapM_ print $ solve $ lines contents"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Control.Applicative\n\neps :: Double\neps = 1.0e-8\n\ndata Point = Point (Double, Double) deriving (Show)\nadd (Point (x1, y1)) (Point (x2, y2)) = Point (x1 + x2, y1 + y2)\nsub (Point (x1, y1)) (Point (x2, y2)) = Point (x1 - x2, y1 - y2)\nmul (Point (x, y)) s = Point (x * s, y * s)\ndet (Point (x1, y1)) (Point (x2, y2)) = x1 * y2 - y1 * x2\nnrm (Point (x, y)) = Point (x / n, y / n) where n = sqrt $ (x * x + y * y)\ndist (Point (x1, y1)) (Point (x2, y2)) = sqrt (dx * dx + dy * dy) where\n    dx = x1 - x2\n    dy = y1 - y2\n\ngetX (Point (x, _)) = x\ngetY (Point (_, y)) = y\n\nparsePoint :: String -> Point\nparsePoint str =\n    let [x, y] = map read $ words str\n    in Point (x, y)\n\ncalcCenter :: Point -> Point -> (Point, Point)\ncalcCenter a b =\n    let m = (a `add` b) `mul` 0.5\n        d = sqrt (1.0 - (dist a m))\n        e = a `sub` b\n        n = nrm $ Point (negate $ getY e, getX e)\n        c1 = m `add` (n `mul` d)\n        c2 = m `sub` (n `mul` d)\n    in (c1, c2)\n\nsolve' :: [Point] -> Int\nsolve' pts =\n    let np    = length pts\n        pairs = [ (pts !! i, pts !! j) | i <- [0..np-1], j <- [i+1..np-1] ]\n    in if null pairs\n        then 1\n        else maximum $ map countUp pairs where\n            countUp (p, q) =\n                if (dist p q) >= 2.0 - eps\n                    then 1\n                    else\n                        let (c1, c2) = calcCenter p q\n                            m1 = length $ filter (\\p -> (dist p c1) <= 1.0 + eps) pts\n                            m2 = length $ filter (\\p -> (dist p c2) <= 1.0 + eps) pts\n                        in (max m1 m2)\n\nsolve :: [String] -> [Int]\nsolve []   = []\nsolve cont =\n    let n           = read (head cont) :: Int\n        (crds, rst) = splitAt n (tail cont)\n        pts         = map parsePoint crds\n    in if n == 0 then []\n                 else (solve' pts) : solve rst\n\nmain :: IO ()\nmain = do\n    contents <- getContents\n    mapM_ print $ solve $ lines contents"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Control.Applicative\nimport Debug.Trace\n\ndata Point = Point (Double, Double) deriving (Show)\nadd (Point (x1, y1)) (Point (x2, y2)) = Point (x1 + x2, y1 + y2)\nsub (Point (x1, y1)) (Point (x2, y2)) = Point (x1 - x2, y1 - y2)\nmul (Point (x, y)) s = Point (x * s, y * s)\ndet (Point (x1, y1)) (Point (x2, y2)) = x1 * y2 - y1 * x2\nnrm (Point (x, y)) = Point (x / n, y / n) where n = sqrt $ (x * x + y * y)\ndist (Point (x1, y1)) (Point (x2, y2)) = sqrt (dx * dx + dy * dy) where\n    dx = x1 - x2\n    dy = y1 - y2\n\n\nparsePoint :: String -> Point\nparsePoint str =\n    let [x, y] = map read $ words str\n    in Point (x, y)\n\ncalcCenter :: Point -> Point -> Point -> Point\ncalcCenter a b c =\n    let aa = dist a b\n        bb = dist b c\n        cc = dist c a\n        a2 = aa * aa\n        b2 = bb * bb\n        c2 = cc * cc\n        s  = 0.5 * (abs ((b `sub` a) `det` (c `sub` a)))\n        cent = ( (a `mul` (a2 * (b2 + c2 - a2)))\n               `add` (b `mul` (b2 * (c2 + a2 - b2)))\n               `add` (c `mul` (c2 * (a2 + b2 - c2)))) `mul` (1.0 / (16.0 * s * s))\n        r  = dist a cent\n    in a `add` (nrm (cent `sub` a))\n\nsolve' :: [Point] -> Int\nsolve' pts =\n    let inside p q = (dist p q) <= 1.0\n        countIn c = length $ filter (\\p -> inside c p) pts\n    in maximum $ map countIn [ calcCenter a b c | a <- pts, b <- pts, c <- pts ]\n\nsolve :: [String] -> [Int]\nsolve []   = []\nsolve cont =\n    let n           = read (head cont) :: Int\n        (crds, rst) = splitAt n (tail cont)\n        pts         = map parsePoint crds\n    in if n == 0 then []\n                 else (solve' pts) : solve rst\n\nmain :: IO ()\nmain = do\n    contents <- getContents\n    mapM_ print $ solve $ lines contents"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Control.Applicative\nimport Debug.Trace\n\ndata Point = Point (Double, Double) deriving (Show)\nadd (Point (x1, y1)) (Point (x2, y2)) = Point (x1 + x2, y1 + y2)\nsub (Point (x1, y1)) (Point (x2, y2)) = Point (x1 - x2, y1 - y2)\nmul (Point (x, y)) s = Point (x * s, y * s)\ndet (Point (x1, y1)) (Point (x2, y2)) = x1 * y2 - y1 * x2\nnrm (Point (x, y)) = Point (x / n, y / n) where n = sqrt $ (x * x + y * y)\ndist (Point (x1, y1)) (Point (x2, y2)) = sqrt (dx * dx + dy * dy) where\n    dx = x1 - x2\n    dy = y1 - y2\n\n\nparsePoint :: String -> Point\nparsePoint str =\n    let [x, y] = map read $ words str\n    in Point (x, y)\n\ncalcCenter :: Point -> Point -> Point -> Point\ncalcCenter a b c =\n    let aa = dist a b\n        bb = dist b c\n        cc = dist c a\n        a2 = aa * aa\n        b2 = bb * bb\n        c2 = cc * cc\n        s  = 0.5 * (abs ((b `sub` a) `det` (c `sub` a)))\n        cent = ( (a `mul` (a2 * (b2 + c2 - a2)))\n               `add` (b `mul` (b2 * (c2 + a2 - b2)))\n               `add` (c `mul` (c2 * (a2 + b2 - c2)))) `mul` (1.0 / (16.0 * s * s))\n        r  = dist a cent\n    in a `add` (nrm (cent `sub` a))\n\nsolve' :: [Point] -> Int\nsolve' pts =\n    let cs = [ calcCenter a b c | a <- pts, b <- pts, c <- pts ]\n        inside p q = (dist p q) <= 1.0\n        countIn c = length $ filter (\\p -> inside c p) pts\n    in maximum $ map countIn cs\n\nsolve :: [String] -> [Int]\nsolve []   = []\nsolve cont =\n    let n           = read (head cont) :: Int\n        (crds, rst) = splitAt n (tail cont)\n        pts         = map parsePoint crds\n    in if n == 0 then []\n                 else (solve' pts) : solve rst\n\nmain :: IO ()\nmain = do\n    contents <- getContents\n    mapM_ print $ solve $ lines contents"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Control.Applicative\nimport Data.Array\n\neps :: Double\neps = 1.0e-8\n\ndata Point = Point (Double, Double) deriving (Show)\nadd (Point (x1, y1)) (Point (x2, y2)) = Point (x1 + x2, y1 + y2)\nsub (Point (x1, y1)) (Point (x2, y2)) = Point (x1 - x2, y1 - y2)\nmul (Point (x, y)) s = Point (x * s, y * s)\ndet (Point (x1, y1)) (Point (x2, y2)) = x1 * y2 - y1 * x2\nnrm (Point (x, y)) = Point (x / n, y / n) where n = sqrt $ (x * x + y * y)\ndst (Point (x, y)) = sqrt $ (x * x + y * y)\n\ngetX (Point (x, _)) = x\ngetY (Point (_, y)) = y\n\nparsePoint :: String -> Point\nparsePoint str =\n    let [x, y] = map read $ words str\n    in Point (x, y)\n\ncalcCenter :: Point -> Point -> (Point, Point)\ncalcCenter a b =\n    let m = (a `add` b) `mul` 0.5\n        d = sqrt (1.0 - ((dst $ a `sub` m) ** 2.0))\n        e = a `sub` b\n        n = nrm $ Point (negate $ getY e, getX e)\n        c1 = m `add` (n `mul` d)\n        c2 = m `sub` (n `mul` d)\n    in (c1, c2)\n\nsolve' :: [Point] -> Int\nsolve' pts =\n    let np    = length pts\n        parr  = listArray (0, np-1) pts\n        pairs = [ (parr ! i, parr ! j) | i <- [0..np-1], j <- [i+1..np-1] ]\n    in if null pairs\n        then 1\n        else maximum $ map countUp pairs where\n            countUp (p, q) =\n                if (dst $ p `sub` q) >= (2.0 - eps)\n                    then 1\n                    else\n                        let (c1, c2) = calcCenter p q\n                            m1 = length $ filter (\\p -> (dst $ p `sub` c1) <= 1.0 + eps) pts\n                            m2 = length $ filter (\\p -> (dst $ p `sub` c2) <= 1.0 + eps) pts\n                        in (max m1 m2)\n\nsolve :: [String] -> [Int]\nsolve []   = []\nsolve cont =\n    let n           = read (head cont) :: Int\n        (crds, rst) = splitAt n (tail cont)\n        pts         = map parsePoint crds\n    in if n == 0 then []\n                 else (solve' pts) : solve rst\n\nmain :: IO ()\nmain = do\n    contents <- getContents\n    mapM_ print $ solve $ lines contents"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns #-}\nimport Control.Monad\nimport Control.Applicative\nimport Data.Array\n\neps :: Double\neps = 1.0e-8\n\nparsePoint :: String -> (Double, Double)\nparsePoint str =\n    let [x, y] = map read $ words str\n    in (x, y)\n\ninside :: (Double, Double) -> (Double, Double) -> Bool\ninside (x1, y1) (x2, y2) =\n    let dx = x1 - x2\n        dy = y1 - y2\n    in dx * dx + dy * dy <= 1.0 + eps\n\ncountUp :: [(Double, Double)] -> ((Double, Double), (Double, Double)) -> Int\ncountUp pts ((x1, y1), (x2, y2)) =\n    let dx = x1 - x2\n        dy = y1 - y2\n        l2 = dx * dx + dy * dy\n    in if l2 >= 4.0 - eps\n            then 1\n            else\n                let mx = (x1 + x2) * 0.5\n                    my = (y1 + y2) * 0.5\n                    l  = sqrt l2\n                    m  = sqrt (1.0 - 0.25 * l2)\n                    nx = m * (-dy) / l\n                    ny = m * dx    / l\n                    m1 = length $ filter (inside (mx + nx, my + ny)) pts\n                    m2 = length $ filter (inside (mx - nx, my - ny)) pts\n                in (max m1 m2)\n\nsolve' :: [(Double, Double)] -> Int\nsolve' pts =\n    let np    = length pts\n        parr  = listArray (0, np-1) pts\n        pairs = [ (parr ! i, parr ! j) | i <- [0..np-1], j <- [i+1..np-1] ]\n    in if null pairs\n           then 1\n           else maximum $ map (countUp pts) pairs\n\nsolve :: [String] -> [Int]\nsolve []   = []\nsolve cont =\n    let n           = read (head cont) :: Int\n        (crds, rst) = splitAt n (tail cont)\n        pts         = map parsePoint crds\n    in if n == 0 then []\n                 else (solve' pts) : solve rst\n\nmain :: IO ()\nmain = do\n    contents <- getContents\n    mapM_ print $ solve $ lines contents"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Control.Applicative\nimport Data.Array\n\neps :: Double\neps = 1.0e-8\n\ndata Point = Point (Double, Double) deriving (Show)\n\nadd :: Point -> Point -> Point\nadd (Point (x1, y1)) (Point (x2, y2)) = Point (x1 + x2, y1 + y2)\n\nsub :: Point -> Point -> Point\nsub (Point (x1, y1)) (Point (x2, y2)) = Point (x1 - x2, y1 - y2)\n\nmul :: Point -> Double -> Point\nmul (Point (x, y)) s = Point (x * s, y * s)\n\nnrm :: Point -> Point\nnrm (Point (x, y)) = Point (x / n, y / n) where n = sqrt $ (x * x + y * y)\n\ndst :: Point -> Double\ndst  (Point (x, y)) = sqrt $ (x * x + y * y)\n\ndst2 :: Point -> Double\ndst2 (Point (x, y)) = x * x + y * y\n\ngetX :: Point -> Double\ngetX (Point (x, _)) = x\n\ngetY :: Point -> Double\ngetY (Point (_, y)) = y\n\nparsePoint :: String -> Point\nparsePoint str =\n    let [x, y] = map read $ words str\n    in Point (x, y)\n\ncalcCenter :: Point -> Point -> (Point, Point)\ncalcCenter a b =\n    let m = (a `add` b) `mul` 0.5\n        d = sqrt (1.0 - ((dst $ a `sub` m) ** 2.0))\n        e = a `sub` b\n        n = nrm $ Point (negate $ getY e, getX e)\n        c1 = m `add` (n `mul` d)\n        c2 = m `sub` (n `mul` d)\n    in (c1, c2)\n\nsolve' :: [Point] -> Int\nsolve' pts =\n    let np    = length pts\n        parr  = listArray (0, np-1) pts\n        pairs = [ (parr ! i, parr ! j) | i <- [0..np-1], j <- [i+1..np-1] ]\n    in if null pairs\n        then 1\n        else maximum $ map countUp pairs where\n            countUp (p, q) =\n                if (dst2 $ p `sub` q) >= 4.0 - eps\n                    then 1\n                    else\n                        let (c1, c2) = calcCenter p q\n                            m1 = length $ filter (\\p -> (dst2 $ p `sub` c1) <= 1.0 + eps) pts\n                            m2 = length $ filter (\\p -> (dst2 $ p `sub` c2) <= 1.0 + eps) pts\n                        in (max m1 m2)\n\nsolve :: [String] -> [Int]\nsolve []   = []\nsolve cont =\n    let n           = read (head cont) :: Int\n        (crds, rst) = splitAt n (tail cont)\n        pts         = map parsePoint crds\n    in if n == 0 then []\n                 else (solve' pts) : solve rst\n\nmain :: IO ()\nmain = do\n    contents <- getContents\n    mapM_ print $ solve $ lines contents"
  },
  {
    "language": "C",
    "code": "#include\"env.h\"\ndouble X[300],Y[300],x,y,d,s,t,p,q;\nN,i,j,m,c;\nC(k){\n\tc=0;\n\tfor(k=N;k--;c>m?m=c:0)\n\t\tc+=k==i|k==j|hypot(X[k]-p,Y[k]-q)<1;\n}\nmain(){\n\tfor(;scanf(\"%d\",&N)*N;printf(\"%d \\n\",m)){\n\t\tfor(i=N;i--;)\n\t\t\tscanf(\"%lf%lf\",X+i,Y+i);\n\t\tfor(m=1;++i<N;)\n\t\t\tfor(j=i;j--;\n\t\t\t\t\td<2?\n\t\t\t\t\t\ts=(X[i]+X[j])/2,t=(Y[i]+Y[j])/2,\n\t\t\t\t\t\tx*=d=sqrt(1-d*d/4)/d,y*=d,\n\t\t\t\t\t\tp=s-y,q=t+x,C(),p=s+y,q=t-x,C()\n\t\t\t\t\t:0)\n\t\t\t\td=hypot(x=X[i]-X[j],y=Y[i]-Y[j]);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count, maxcount;\n\tfloat x, y;\n\tfloat point[300][2] = {{ 0.0 }};\n\n\twhile (1) {\n\t\tscanf(\"%d\\n\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tmaxcount = 0;\n\t\tfor (x = 1; x < 10; x += 0.05) {\n\t\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= ((x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1]))) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0.0;\n\t\t\tpoint[i][1] = 0.0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count;\n\tint maxcount = 0;\n\tdouble x, y;\n\tfloat point[300][2];\n\n\twhile (1) {\n\t\tmaxcount = 0;\n\t\tcount = 0;\n\n\t\tscanf(\"%d\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tfor (x = 1; x < 10; x += 0.01) {\n\t\t\tfor (y = 1; y < 10; y += 0.01) {\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0;\n\t\t\tpoint[i][1] = 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count;\n\tint maxcount = 0;\n\tdouble x, y;\n\tfloat point[300][2];\n\n\twhile (1) {\n\t\tmaxcount = 0;\n\n\t\tscanf(\"%d\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tfor (x = 1; x < 10; x += 0.05) {\n\t\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0;\n\t\t\tpoint[i][1] = 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#define p2(x) ((x)*(x))\n#define mul(rx,ry,x1,y1,x2,y2) ((rx)=(x1)*(x2)-(y1)*(y2),(ry)=(x2)*(y1)+(x1)*(y2))\n#define R 1\ndouble X[300],Y[300],hyp,t,pl,dx,dy,x[2],y[2];\nint main(){int N,M,m,i,j,k,z;for(;scanf(\"%d\",&N),N;printf(\"%d\\n\",M)){\n\tfor(i=0;i<N;i++)scanf(\"%lf%lf\",X+i,Y+i);\n\tfor(M=1,i=0;i<N;i++)for(j=i+1;j<N;j++){\n\t\thyp=hypot(X[j]-X[i],Y[j]-Y[i]);\n\t\tif(hyp>2*R)continue;\n\t\t//t=( p2(R)-p2(R)+p2(hyp) )/( 2*hyp );\n\t\tt=hyp/2;\n\t\tpl=sqrt(p2(R)-p2(t));\n\t\tdx=(X[j]-X[i])/hyp;\n\t\tdy=(Y[j]-Y[i])/hyp;\n\t\tmul(x[0],y[0],dx,dy,t,pl);\n\t\tmul(x[1],y[1],dx,dy,t,-pl);\n\t\tfor(z=0;z<2;z++){\n\t\t\tx[z]+=X[i],y[z]+=Y[i];\n\t\t\tfor(m=k=0;k<N;k++)if(p2(X[k]-x[z])+p2(Y[k]-y[z])<p2(R))m++;\n\t\t\tif(M<m)M=m;\n\t\t}\n\t}\n}return 0;}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define SQ(x) ((x) * (x))\n#define EPS 1e-5\n\ntypedef struct {\n    double x;\n    double y;\n} POINT;\n\nint dist(POINT a, POINT b, double d)\n{\n    if (sqrt(SQ(a.x - b.x) + SQ(a.y - b.y)) - d > EPS){\n        return (0);\n    }\n    return (1);\n}\n\nint max(int a, int b)\n{\n    if (a > b){\n        return (a);\n    }\n    return (b);\n}\n\nint main(void)\n{\n    POINT seal[300], v;\n    static POINT l[180000];\n    int s;\n    double a, a0, d, t;\n    int n;\n    int count, ans;\n    int i, j, k;\n    \n    while (1){\n        scanf(\"%d\", &n);\n        \n        if (!n){\n            break;\n        }\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%lf%*c%lf\", &seal[i].x, &seal[i].y);\n        }\n        \n        s = 0;\n        \n        for (i = 0; i < n; i++){\n            for (j = 0; j < n; j++){\n                if (dist(seal[i], seal[j], 2) && i != j){\n                    d = sqrt(SQ(seal[i].x - seal[j].x) + SQ(seal[i].y - seal[j].y));\n                    a = atan2(seal[j].y - seal[i].y, seal[j].x - seal[i].x);\n                    a0 = acos(0.5 * d);\n                    \n                    l[s].x = seal[i].x + cos(a0 + a);\n                    l[s].y = seal[i].y + sin(a0 + a);\n                    s++;\n                    l[s].x = seal[i].x + cos(a0 - a);\n                    l[s].y = seal[i].y + sin(a0 - a);\n                    s++;\n                }\n            }\n        }\n                    \n        ans = 1;\n        for (i = 0; i < s; i++){\n            count = 0;\n            for (j = 0; j < n; j++){\n                if (dist(seal[j], l[i], 1)){\n                    count++;\n                }\n            }\n            ans = max(ans, count);\n        }\n        \n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count, maxcount;\n\tdouble x, y;\n\tfloat point[300][2] = {0};\n\n\twhile (1) {\n\t\tscanf(\"%d\\n\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tmaxcount = 0;\n\t\tfor (x = 1; x < 10; x += 0.05) {\n\t\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0;\n\t\t\tpoint[i][1] = 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nint main(void) {\n\tint i, num, count;\n\tint maxcount = 0;\n\tdouble x, y;\n\tfloat point[300][2];\n\n\twhile (1) {\n\t\tmaxcount = 0;\n\n\t\tscanf(\"%d\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tfor (x = 1; x < 10; x += 0.01) {\n\t\t\tfor (y = 1; y < 10; y += 0.01) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0;\n\t\t\tpoint[i][1] = 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count;\n\tint maxcount = 0;\n\tdouble x, y;\n\tfloat point[300][2];\n\n\twhile (1) {\n\t\tmaxcount = 0;\n\t\tcount = 0;\n\n\t\tscanf(\"%d\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tfor (x = 1; x < 10; x += 0.05) {\n\t\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0;\n\t\t\tpoint[i][1] = 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count;\n\tint maxcount = 0;\n\tdouble x, y;\n\tfloat point[300][2];\n\n\twhile (1) {\n\t\tmaxcount = 0;\n\n\t\tscanf(\"%d\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tfor (x = 1; x < 10; x += 0.02) {\n\t\t\tfor (y = 1; y < 10; y += 0.02) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0;\n\t\t\tpoint[i][1] = 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define EPS 1e-5\n\nfloat point[300][2] = { {0.0} };\nfloat l[180000][2] = { { 0.0 } };\n\nint search(int num);\nint dist(int a, int b, double d);\nint dist2(int a, int b, double d);\n\nint main(void) {\n\tint i, num;\n\n\twhile (1) {\n\t\tscanf(\"%d\\n\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tprintf(\"%d\\n\", search(num));\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0.0;\n\t\t\tpoint[i][1] = 0.0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint search(int num) {\n\tint i, j, s = 0;\n\tint count, maxcount;\n\tdouble a, a0, d;\n\n\tfor (i = 0; i < num; i++) {\n\t\tfor (j = 0; j < num; j++) {\n\t\t\tif (dist(i, j, 2) && i != j) {\n\n\t\t\t\tfloat X = (point[i][0] - point[j][0]);\n\t\t\t\tfloat Y = (point[i][1] - point[j][1]);\n\n\t\t\t\td = sqrt(X*X + Y*Y);\n\t\t\t\ta = atan2(point[j][1] - point[i][1], point[j][0] - point[i][0]);\n\t\t\t\ta0 = acos(0.5 * d);\n\n\t\t\t\tl[s][0] = point[i][0] + cos(a0 + a);\n\t\t\t\tl[s][1] = point[i][1] + sin(a0 + a);\n\t\t\t\ts++;\n\t\t\t\tl[s][0] = point[i][0] + cos(a0 - a);\n\t\t\t\tl[s][1] = point[i][1] + sin(a0 - a);\n\t\t\t\ts++;\n\t\t\t}\n\t\t}\n\t}\n\n\tmaxcount = 1;\n\tfor (i = 0; i < s; i++) {\n\t\tcount = 0;\n\t\tfor (j = 0; j < num; j++) {\n\t\t\tif (dist2(j, i, 1)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif (count > maxcount) {\n\t\t\tmaxcount = count;\n\t\t}\n\t}\n\treturn maxcount;\n}\n\nint dist(int a, int b, double d){\n\tfloat X = (point[a][0] - point[b][0]);\n\tfloat Y = (point[a][1] - point[b][1]);\n\tif (sqrt(X*X + Y*Y) - d > EPS) {\n\t\treturn (0);\n\t}\n\treturn (1);\n}\n\nint dist2(int a, int b, double d) {\n\tfloat X = (point[a][0] - l[b][0]);\n\tfloat Y = (point[a][1] - l[b][1]);\n\tif (sqrt(X*X + Y*Y) - d > EPS) {\n\t\treturn (0);\n\t}\n\treturn (1);\n}"
  },
  {
    "language": "C",
    "code": "double X[300],Y[300],x,y,d,s,t,p,q;\nN,i,j,m,c;\nC(k){\n\tc=0;\n\tfor(k=N;k--;c>m?m=c:0)\n\t\tc+=k==i|k==j|hypot(X[k]-p,Y[k]-q)<1;\n}\nmain(){\n\tfor(;scanf(\"%d\",&N)*N;printf(\"%d \\n\",m)){\n\t\tfor(i=N;i--;)\n\t\t\tscanf(\"%lf%lf\",X+i,Y+i);\n\t\tfor(m=1;++i<N;)\n\t\t\tfor(j=i;j--;\n\t\t\t\t\td<2?\n\t\t\t\t\t\ts=(X[i]+X[j])/2,t=(Y[i]+Y[j])/2,\n\t\t\t\t\t\tx*=d=sqrt(1-d*d/4)/d,y*=d,\n\t\t\t\t\t\tp=s-y,q=t+x,C(),p=s+y,q=t-x,C()\n\t\t\t\t\t:0)\n\t\t\t\td=hypot(x=X[i]-X[j],y=Y[i]-Y[j]);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nint main(void) {\n\tint i, num, count, maxcount;\n\tfloat x, y;\n\tfloat point[300][2] = {0.0};\n\n\twhile (1) {\n\t\tscanf(\"%d\\n\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tmaxcount = 0;\n\t\tfor (x = 1; x < 10; x += 0.05) {\n\t\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0;\n\t\t\tpoint[i][1] = 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<math.h>\ntypedef struct{double x,y;}P;\nint pgeta(P*p){return~scanf(\"%lf%lf\",&p->x,&p->y);}\ndouble pabs(P p){return hypot(p.x,p.y);}\ndouble pabssq(P p){return p.x*p.x+p.y*p.y;}\nP pmake(double x,double y){P p;p.x=x;p.y=y;return p;}\nP padd(P a,P b){return pmake(a.x+b.x,a.y+b.y);}\nP psub(P a,P b){return pmake(a.x-b.x,a.y-b.y);}\nP pmul(P a,double b){return pmake(a.x*b,a.y*b);}\nP pdiv(P a,double b){return pmake(a.x/b,a.y/b);}\nP punit(P p){return pdiv(p,pabs(p));}//PÊxNg\nP prot_l(P p){return pmake(-p.y,p.x);}//xNgÌ¶90xñ]\nP pnormal_l(P p){return punit(prot_l(p));}//@üxNg(¶)\nP pcenter(P a,P b){return pmake((a.x+b.x)/2,(a.y+b.y)/2);}//_\ndouble distsq_p_p(P a,P b){return pabssq(psub(a,b));}//2_Ì£Ìñæ\n\nmain(){\n\tint N,i,j,k,c,cm;\n\tP q[300];\n\tfor(;scanf(\"%d\",&N)*N;){\n\t\tfor(i=0;i<N;i++)\n\t\t\tpgeta(q+i);\n\t\tcm=1;//ß¢2_ª³­ÄàA1_ÍÆè ¦¸Íßé\n\t\tfor(i=0;i<N;i++){\n\t\t\tfor(j=0;j<i;j++){\n\t\t\t\tP a=q[i];\n\t\t\t\tP b=q[j];\n\t\t\t\tP ab=psub(a,b);\n\t\t\t\tdouble absq=pabssq(ab);\n\t\t\t\tif(absq<=4){\n\t\t\t\t\tP m=pcenter(a,b);\n\t\t\t\t\tP mpn=pnormal_l(ab);\n\t\t\t\t\tP mp=pmul(mpn,sqrt(1-absq/4));\n\t\t\t\t\t{\n\t\t\t\t\t\tP p=padd(m,mp);\n\t\t\t\t\t\tc=0;\n\t\t\t\t\t\tfor(k=0;k<N;k++){\n\t\t\t\t\t\t\tif(k==i||k==j||distsq_p_p(q[k],p)<1)\n\t\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(c>cm)\n\t\t\t\t\t\t\tcm=c;\n\t\t\t\t\t}\n\t\t\t\t\t{\n\t\t\t\t\t\tP p=psub(m,mp);\n\t\t\t\t\t\tc=0;\n\t\t\t\t\t\tfor(k=0;k<N;k++){\n\t\t\t\t\t\t\tif(k==i||k==j||distsq_p_p(q[k],p)<1)\n\t\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(c>cm)\n\t\t\t\t\t\t\tcm=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d \\n\",cm);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count, maxcount;\n\tdouble x, y;\n\tfloat point[300][2] = {0};\n\n\twhile (1) {\n\t\tscanf(\"%d\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tmaxcount = 0;\n\t\tfor (x = 1; x < 10; x += 0.05) {\n\t\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0;\n\t\t\tpoint[i][1] = 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count;\n\tint maxcount = 0;\n\tdouble x, y;\n\tfloat point[300][2];\n\n\twhile (1) {\n\t\tmaxcount = 0;\n\t\tcount = 0;\n\n\t\tscanf(\"%d\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tfor (x = 1; x < 10; x += 0.02) {\n\t\t\tfor (y = 1; y < 10; y += 0.02) {\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0;\n\t\t\tpoint[i][1] = 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nfloat point[300][2] = { { 0.0 } };\nint search(int num);\n\nint main(void) {\n\tint i, num;\n\tchar e;\n\n\twhile (scanf(\"%d\\n\", &num), num) {\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t\tscanf(\"%c\", &e);\n\t\t}\n\t\tprintf(\"%d\\n\", search(num));\n\t}\n\treturn 0;\n}\n\nint search(int num) {\n\tfloat x, y;\n\tint i, count, maxcount = 0;\n\tfor (x = 1; x < 10; x++) {\n\t\tfor (y = 1; y < 10; y++) {\n\t\t\tcount = 0;\n\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\tif (1.0 >= ((x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1]))) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count > maxcount) {\n\t\t\t\tmaxcount = count;\n\t\t\t}\n\t\t\tif (maxcount == num) {\n\t\t\t\treturn maxcount;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxcount;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n \n#define N_MAX 300\n \nfloat point[N_MAX][2];\n \nint main() {\n  int n, big;\n   \n  while (scanf(\"%d\\n\", &n), n) {\n    int i;\n    float x, y;\n     \n    for (i = 0; i < n; i++) {\n      scanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n    }\n     \n    big = 0;\n     \n    for (x = 1; x < 10; x += 0.05) {\n      for (y = 1; y < 10; y += 0.05) {\n    int count = 0;\n    for (i = 0; i < n; i++) {\n      if (1.0 >=  (x - point[i][0]) * (x - point[i][0])\n               + (y - point[i][1]) * (y - point[i][1])) {\n        count++;\n      }\n    }\n     \n    if (count > big) {\n      big = count;\n    }\n      }\n    }\n     \n    printf(\"%d\\n\", big);\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count, maxcount;\n\tfloat x, y;\n\tchar e;\n\tfloat point[300][2] = {{ 0.0 }};\n\n\twhile (scanf(\"%d\\n\", &num), num) {\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t\tscanf(\"%c\", &e);\n\t\t}\n\n\t\tmaxcount = 0;\n\t\tfor (x = 1; x < 10; x++) {\n\t\t\tfor (y = 1; y < 10; y++) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= ((x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1]))) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t\tif (maxcount == num) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count, maxcount;\n\tfloat x, y;\n\tchar e;\n\tfloat point[300][2] = {{ 0.0 }};\n\n\twhile (1) {\n\t\tscanf(\"%d\\n\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t\tscanf(\"%c\", &e);\n\t\t}\n\n\t\tmaxcount = 0;\n\t\tfor (x = 1; x < 10; x += 0.1) {\n\t\t\tfor (y = 1; y < 10; y += 0.1) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= ((x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1]))) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nfloat point[300][2] = { {0.0} };\nint search(int num);\n\nint main(void) {\n\tint i, num;\n\tchar e;\n\n\twhile (1) {\n\t\tscanf(\"%d\\n\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\t\tprintf(\"%d\\n\", search(num));\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0.0;\n\t\t\tpoint[i][1] = 0.0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint search(int num) {\n\tfloat x, y;\n\tint i, count, maxcount = 0;\n\tfor (x = 1; x < 10; x += 0.05) {\n\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\tcount = 0;\n\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\tif (1.0 >= ((x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1]))) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count > maxcount) {\n\t\t\t\tmaxcount = count;\n\t\t\t}\n\t\t\tif (maxcount == num) {\n\t\t\t\treturn maxcount;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxcount;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nfloat point[300][2] = { {0.0} };\nint search(int num);\n\nint main(void) {\n\tint i, num;\n\n\twhile (1) {\n\t\tscanf(\"%d\\n\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tprintf(\"%d\\n\", search(num));\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0.0;\n\t\t\tpoint[i][1] = 0.0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint search(int num) {\n\tfloat x, y;\n\tint i, count, maxcount = 0;\n\n\tfor (x = 1; x < 10; x += 0.05) {\n\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\tcount = 0;\n\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\tfloat X = x - point[i][0];\n\t\t\t\tfloat Y = y - point[i][1];\n\t\t\t\tif (1.0 >= (X*X + Y*Y)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count > maxcount) {\n\t\t\t\tmaxcount = count;\n\t\t\t}\n\t\t\tif (maxcount == num) {\n\t\t\t\treturn maxcount;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxcount;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n \n \nint main() {\n\tint point_num, ans;\n\tfloat point[300][2];   \n\tfor(;;){\n\t\tscanf(\"%d\\n\", &point_num);\n\t\tif(point_num == 0)\n\t\t\tbreak;\n\t\tint i;\n\t\tfloat x, y;\n\t\tfor (i = 0; i < point_num; i++)\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\tans = 0;\n\t\t\n\t\tfor (x = 1; x < 10; x += 0.01) {\n\t\t\tfor (y = 1; y < 10; y += 0.01) {\n\t\t\t\tint count = 0;\n\t\t\t\tfor (i = 0; i < point_num; i++) {\n\t\t\t\t\tif (1.0 >=  (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1]))\n\t\t\t\t\t\tcount++;\n\t\t\t\tif (count > ans)\n\t\t\t\t\tans = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nint main(void) {\n\tint i, num, count;\n\tint maxcount = 0;\n\tdouble x, y;\n\tfloat point[300][2];\n\n\twhile (1) {\n\t\tmaxcount = 0;\n\n\t\tscanf(\"%d\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tfor (x = 1; x < 10; x += 0.01) {\n\t\t\tfor (y = 1; y < 10; y += 0.01) {\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0;\n\t\t\tpoint[i][1] = 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nfloat point[300][2] = { {0.0} };\nint search(int num);\n\nint main(void) {\n\tint i, num;\n\n\twhile (1) {\n\t\tscanf(\"%d\\n\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tprintf(\"%d\\n\", search(num));\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0.0;\n\t\t\tpoint[i][1] = 0.0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint search(int num) {\n\tfloat x, y;\n\tint i, count, maxcount = 0;\n\tfor (x = 1; x < 10; x += 0.005) {\n\t\tfor (y = 1; y < 10; y += 0.005) {\n\t\t\tcount = 0;\n\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\tfloat X = x - point[i][0];\n\t\t\t\tfloat Y = y - point[i][1];\n\t\t\t\tif (1.0 >= (X*X + Y*Y)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count > maxcount) {\n\t\t\t\tmaxcount = count;\n\t\t\t}\n\t\t\tif (maxcount == num) {\n\t\t\t\treturn maxcount;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxcount;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define EPS 1e-7\n\nint main(void) {\n\tint n;\n\tint i,j;\n\tint count,max;\n\tdouble x[300],y[300];\n\tdouble cx,cy;\n\tsrand(65537);\n\twhile(scanf(\"%d\",&n)==1 && n!=0) {\n\t\tfor(i=0;i<n;i++)scanf(\"%lf%lf\",&x[i],&y[i]);\n\t\tmax=0;\n\t\tfor(i=0;i<10000;i++) {\n\t\t\tcx=(double)rand()/RAND_MAX*10.0;\n\t\t\tcy=(double)rand()/RAND_MAX*10.0;\n\t\t\tcount=0;\n\t\t\tfor(j=0;j<n;j++) {\n\t\t\t\tif((x[j]-cx)*(x[j]-cx)+(y[j]-cy)*(y[j]-cy)<1+EPS)count++;\n\t\t\t}\n\t\t\tif(count>max)max=count;\n\t\t\tif(max==n)break;\n\t\t}\n\t\tprintf(\"%d\\n\",max);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n\ntypedef struct point2d{\n  double x,y;\n} point;\n\ndouble distance(point a,point b){\n  double dx=a.x-b.x;\n  double dy=a.y-b.y;\n  return sqrt(dx*dx+dy*dy);\n}\n\nint solve(const point *p,const int n){\n  int i,j;\n  int max=1;\n  for(i=0;i<n;i++){\n    for(j=i+1;j<n;j++){\n      double d=distance(p[i],p[j]);\n      if(d>2.0) continue;\n      double dx=p[i].x-p[j].x;\n      double dy=p[i].y-p[j].y;\n      point mid=(point){(p[i].x+p[j].x)/2,(p[i].y+p[j].y)/2};\n      point c=(point){mid.x-dy/d*sqrt(1-d*d/4),mid.y+dx/d*sqrt(1-d*d/4)};\n      int cnt=2;\n      int k;\n      for(k=0;k<n;k++){\n\tif(k==i || k==j) continue;\n\tif(distance(c,p[k])<=1.0) cnt++;\n      }\n      if(max<cnt) max=cnt;\n      c=(point){mid.x+dy/d*sqrt(1-d*d/4),mid.y-dx/d*sqrt(1-d*d/4)};\n      cnt=2;\n      for(k=0;k<n;k++){\n\tif(k==i || k==j) continue;\n\tif(distance(c,p[k])<=1.0) cnt++;\n      }\n      if(max<cnt) max=cnt;\n    }\n  }\n  return max;\n}\n\nvoid run(void){\n  while(1){\n    int n;\n    scanf(\"%d\",&n);\n    if(n==0) break;\n    point p[300];\n    int i;\n    for(i=0;i<n;i++){\n      double x,y;\n      scanf(\"%lf%lf\",&x,&y);\n      p[i]=(point){x,y};\n    }\n    int ans=solve(p,n);\n    printf(\"%d\\n\",ans);\n  }\n}\n\nint main(void){\n  run();\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nint main(void) {\n\tint i, num, count, maxcount;\n\tfloat x, y;\n\tfloat point[300][2] = {0};\n\n\twhile (1) {\n\t\tscanf(\"%d\\n\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tmaxcount = 0;\n\t\tfor (x = 1; x < 10; x += 0.05) {\n\t\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0;\n\t\t\tpoint[i][1] = 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nint main(void) {\n\tfloat point[300][2] = {0.0};\n\n\twhile (1) {\n\t\tint i, num, count, maxcount;\n\t\tfloat x, y;\n\t\tscanf(\"%d\\n\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tmaxcount = 0;\n\t\tfor (x = 1; x < 10; x += 0.05) {\n\t\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0;\n\t\t\tpoint[i][1] = 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count;\n\tint maxcount = 0;\n\tdouble x, y;\n\tfloat point[300][2];\n\n\twhile (1) {\n\t\tmaxcount = 0;\n\n\t\tscanf(\"%d\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tfor (x = 1; x < 10; x += 0.02) {\n\t\t\tfor (y = 1; y < 10; y += 0.02) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0;\n\t\t\tpoint[i][1] = 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count;\n\tint maxcount = 0;\n\tdouble x, y;\n\tfloat point[300][2];\n\n\twhile (1) {\n\t\tmaxcount = 0;\n\t\tcount = 0;\n\n\t\tscanf(\"%d\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tfor (x = 1; x < 10; x += 0.01) {\n\t\t\tfor (y = 1; y < 10; y += 0.01) {\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0;\n\t\t\tpoint[i][1] = 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "float X[300],Y[300],x,y,d,s,t,p,q;N,i,j,m;C(c,k){c=0;for(k=N;k--;c>m?m=c:0)c+=k==i|k==j|hypot(X[k]-p,Y[k]-q)<1;}main(){for(;scanf(\"%d\",&N)*N;printf(\"%d\\n\",m)){for(i=N;i--;)scanf(\"%f%f\",X+i,Y+i);for(m=1;++i<N;)for(j=i;j--;d<2?s=(X[i]+X[j])/2,t=(Y[i]+Y[j])/2,x*=d=sqrt(1-d/2)/d,y*=d,C(p=s-y,q=t+x),C(p=s+x,q=t-y):0)d=hypot(x=X[i]-X[j],y=Y[i]-Y[j]);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n \n \nint main() {\n\tint point_num, ans;\n\tfloat point[300][2];   \n\tfor(;;){\n\t\tscanf(\"%d\\n\", &point_num);\n\t\tif(point_num == 0)\n\t\t\tbreak;\n\t\tint i;\n\t\tfloat x, y;\n\t\tfor (i = 0; i < point_num; i++)\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\tans = 0;\n\t\t\n\t\tfor (x = 1; x < 10; x += 0.0001) {\n\t\t\tfor (y = 1; y < 10; y += 0.0001) {\n\t\t\t\tint count = 0;\n\t\t\t\tfor (i = 0; i < point_num; i++) {\n\t\t\t\t\tif (1.0 >=  (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1]))\n\t\t\t\t\t\tcount++;\n\t\t\t\tif (count > ans)\n\t\t\t\t\tans = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define EPS 1e-7\n\n#define ENSYURITU 3.1415926535897932384626433832795028841\n\nint main(void) {\n    int n;\n    int i,j,k;\n    int count,max;\n    int loopmax;\n    double x[300],y[300];\n    double cx,cy;\n    while(scanf(\"%d\",&n)==1 && n!=0) {\n        for(i=0;i<n;i++)scanf(\"%lf%lf\",&x[i],&y[i]);\n        max=0;\n        loopmax=500000/n;\n        for(k=0;k<n;k++) {\n            for(i=0;i<loopmax;i++) {\n                cx=x[k]+cos(2*ENSYURITU*i/loopmax);\n                cy=y[k]+sin(2*ENSYURITU*i/loopmax);\n                count=0;\n                for(j=0;j<n;j++) {\n                    if((x[j]-cx)*(x[j]-cx)+(y[j]-cy)*(y[j]-cy)<1+EPS)count++;\n                }\n                if(count>max)max=count;\n                if(max==n)break;\n            }\n        }\n        printf(\"%d\\n\",max);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n \n \nint main() {\n\tint point_num, ans;\n\tfloat point[300][2];   \n\tfor(;;){\n\t\tscanf(\"%d\\n\", &point_num);\n\t\tif(point_num == 0)\n\t\t\tbreak;\n\t\tint i;\n\t\tfloat x, y;\n\t\tfor (i = 0; i < point_num; i++)\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\tans = 0;\n\t\t\n\t\tfor (x = 1; x < 10; x += 0.01) {\n\t\t\tfor (y = 1; y < 10; y += 0.01) {\n\t\t\t\tint count = 0;\n\t\t\t\tfor (i = 0; i < point_num; i++) {\n\t\t\t\t\tif (1.0 >=  (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1]))\n\t\t\t\t\t\tcount++;\n\t\t\t\tif (count > ans)\n\t\t\t\t\tans = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<math.h>\ntypedef struct{double x,y;}P;\nint pgeta(P*p){return~scanf(\"%lf%lf\",&p->x,&p->y);}\ndouble pabs(P p){return hypot(p.x,p.y);}\ndouble pabssq(P p){return p.x*p.x+p.y*p.y;}\nP pmake(double x,double y){P p;p.x=x;p.y=y;return p;}\nP padd(P a,P b){return pmake(a.x+b.x,a.y+b.y);}\nP psub(P a,P b){return pmake(a.x-b.x,a.y-b.y);}\nP pmul(P a,double b){return pmake(a.x*b,a.y*b);}\nP pdiv(P a,double b){return pmake(a.x/b,a.y/b);}\nP punit(P p){return pdiv(p,pabs(p));}//PÊxNg\nP prot_l(P p){return pmake(-p.y,p.x);}//xNgÌ¶90xñ]\nP pnormal_l(P p){return punit(prot_l(p));}//@üxNg(¶)\nP pcenter(P a,P b){return pmake((a.x+b.x)/2,(a.y+b.y)/2);}//_\ndouble distsq_p_p(P a,P b){return pabssq(psub(a,b));}//2_Ì£Ìñæ\n\nmain(){\n\tint N,i,j,k,c,cm;\n\tP q[300];\n\tfor(;scanf(\"%d\",&N)*N;){\n\t\tfor(i=0;i<N;i++)\n\t\t\tpgeta(q+i);\n\t\tcm=0;\n\t\tfor(i=0;i<N;i++){\n\t\t\tfor(j=0;j<i;j++){\n\t\t\t\tP a=q[i];\n\t\t\t\tP b=q[j];\n\t\t\t\tP ab=psub(a,b);\n\t\t\t\tdouble absq=pabssq(ab);\n\t\t\t\tif(absq<=4){\n\t\t\t\t\tP m=pcenter(a,b);\n\t\t\t\t\tP mpn=pnormal_l(ab);\n\t\t\t\t\tP mp=pmul(mpn,sqrt(1-absq/4));\n\t\t\t\t\t{\n\t\t\t\t\t\tP p=padd(m,mp);\n\t\t\t\t\t\tc=0;\n\t\t\t\t\t\tfor(k=0;k<N;k++){\n\t\t\t\t\t\t\tif(k==i||k==j||distsq_p_p(q[k],p)<=1)\n\t\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(c>cm)\n\t\t\t\t\t\t\tcm=c;\n\t\t\t\t\t}\n\t\t\t\t\t{\n\t\t\t\t\t\tP p=psub(m,mp);\n\t\t\t\t\t\tc=0;\n\t\t\t\t\t\tfor(k=0;k<N;k++){\n\t\t\t\t\t\t\tif(k==i||k==j||distsq_p_p(q[k],p)<=1)\n\t\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(c>cm)\n\t\t\t\t\t\t\tcm=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d \\n\",cm);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "double X[300],Y[300],x,y,d,s,t,p,q;N,i,j,m;C(c,k){c=0;for(k=N;k--;c>m?m=c:0)c+=k==i|k==j|hypot(X[k]-p,Y[k]-q)<1;}main(){for(;scanf(\"%d\",&N)*N;printf(\"%d\\n\",m)){for(i=N;i--;)scanf(\"%lf%lf\",X+i,Y+i);for(m=1;++i<N;)for(j=i;j--;d<2?s=(X[i]+X[j])/2,t=(Y[i]+Y[j])/2,x*=d=sqrt(1-d/2)/d,y*=d,C(p=s-y,q=t+x),C(p=s+x,q=t-y):0)d=hypot(x=X[i]-X[j],y=Y[i]-Y[j]);}}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#define p2(x) ((x)*(x))\n#define mul(rx,ry,x1,y1,x2,y2) ((rx)=(x1)*(x2)-(y1)*(y2),(ry)=(x2)*(y1)+(x1)*(y2))\n#define R 1\ndouble X[300],Y[300],hyp,t,pl,dx,dy,x[2],y[2];\nint main(){int N,M,m,i,j,k,z;for(;scanf(\"%d\",&N),N;printf(\"%d\\n\",M)){\n\tfor(i=0;i<N;i++)scanf(\"%lf%lf\",X+i,Y+i);\n\tfor(M=1,i=0;i<N;i++)for(j=i+1;j<N;j++){\n\t\thyp=hypot(X[j]-X[i],Y[j]-Y[i]);\n\t\tif(hyp>2*R)continue;\n\t\t//t=( p2(R)-p2(R)+p2(hyp) )/( 2*hyp );\n\t\tt=hyp/2;\n\t\tpl=sqrt(p2(R)-p2(t));\n\t\tdx=(X[j]-X[i])/hyp;\n\t\tdy=(Y[j]-Y[i])/hyp;\n\t\tmul(x[0],y[0],dx,dy,t,pl);\n\t\tmul(x[1],y[1],dx,dy,t,-pl);\n\t\tfor(z=0;z<2;z++){\n\t\t\tx[z]+=X[i],y[z]+=Y[i];\n\t\t\tfor(m=k=0;k<N;k++)if(p2(X[k]-x[z])+p2(Y[k]-y[z])<p2(R)-1e-9)m++;\n\t\t\tif(M<m)M=m;\n\t\t}\n\t}\n}return 0;}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nfloat point[300][2] = { {0.0} };\nint search(int num);\n\nint main(void) {\n\tint i, num;\n\n\twhile (1) {\n\t\tscanf(\"%d\\n\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tprintf(\"%d\\n\", search(num));\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0.0;\n\t\t\tpoint[i][1] = 0.0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint search(int num) {\n\tfloat x, y;\n\tint i, count, maxcount = 0;\n\tfor (x = 1; x < 10; x += 0.0001) {\n\t\tfor (y = 1; y < 10; y += 0.0001) {\n\t\t\tcount = 0;\n\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\tfloat X = x - point[i][0];\n\t\t\t\tfloat Y = y - point[i][1];\n\t\t\t\tif (1.0 >= (X*X + Y*Y)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count > maxcount) {\n\t\t\t\tmaxcount = count;\n\t\t\t}\n\t\t\tif (maxcount == num) {\n\t\t\t\treturn maxcount;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxcount;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define EPS 1e-5\n\nfloat point[300][2] = { {0.0} };\nfloat l[300][2] = { { 0.0 } };\nint search(int num);\nint dist(int a, int b, double d);\nint dist2(int a, int b, double d);\n\nint main(void) {\n\tint i, num;\n\n\twhile (1) {\n\t\tscanf(\"%d\\n\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tprintf(\"%d\\n\", search(num));\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0.0;\n\t\t\tpoint[i][1] = 0.0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint search(int num) {\n\tint s, i, j;\n\tint count, maxcount;\n\tdouble a, a0, d;\n\n\ts = 0;\n\n\tfor (i = 0; i < num; i++) {\n\t\tfor (j = 0; j < num; j++) {\n\t\t\tif (dist(i, j, 2) && i != j) {\n\n\t\t\t\tfloat X = (point[i][0] - point[j][0]);\n\t\t\t\tfloat Y = (point[i][1] - point[j][1]);\n\n\t\t\t\td = sqrt(X*X + Y*Y);\n\t\t\t\ta = atan2(point[j][1] - point[i][1], point[j][0] - point[i][0]);\n\t\t\t\ta0 = acos(0.5 * d);\n\n\t\t\t\tl[s][0] = point[i][0] + cos(a0 + a);\n\t\t\t\tl[s][1] = point[i][1] + sin(a0 + a);\n\t\t\t\ts++;\n\t\t\t\tl[s][0] = point[i][0] + cos(a0 - a);\n\t\t\t\tl[s][1] = point[i][1] + sin(a0 - a);\n\t\t\t\ts++;\n\t\t\t}\n\t\t}\n\t}\n\n\tmaxcount = 1;\n\tfor (i = 0; i < s; i++) {\n\t\tcount = 0;\n\t\tfor (j = 0; j < num; j++) {\n\t\t\tif (dist2(j, i, 1)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif (count > maxcount) {\n\t\t\tmaxcount = count;\n\t\t}\n\t}\n\treturn maxcount;\n}\n\nint dist(int a, int b, double d){\n\tfloat X = (point[a][0] - point[b][0]);\n\tfloat Y = (point[a][1] - point[b][1]);\n\tif (sqrt(X*X + Y*Y) - d > EPS) {\n\t\treturn (0);\n\t}\n\treturn (1);\n}\n\nint dist2(int a, int b, double d) {\n\tfloat X = (point[a][0] - l[b][0]);\n\tfloat Y = (point[a][1] - l[b][1]);\n\tif (sqrt(X*X + Y*Y) - d > EPS) {\n\t\treturn (0);\n\t}\n\treturn (1);\n}"
  },
  {
    "language": "C",
    "code": "float X[300],Y[300],x,y,d;N,j,m,c;C(k){c=0;for(k=N;k--;c>m?m=c:0)c+=hypot(X[k]-x/2-X[j]-y*d,Y[k]-y/2-Y[j]+x*d)<1.0001;}main(i){for(;scanf(\"%d\",&N)*N;printf(\"%d\\n\",m)){for(i=N;i--;)scanf(\"%f%f\",X+i,Y+i);for(m=1;++i<N;)for(j=i;j--;d<4?C(d=sqrt(1/d-.25)),C(d=-d):0)x=X[i]-X[j],y=Y[i]-Y[j],d=x*x+y*y;}}"
  },
  {
    "language": "C",
    "code": "double X[300],Y[300],x,y,d,s,t,p,q;\nN,i,j,m,c;\nC(k){\n\tc=0;\n\tfor(k=N;k--;c>m?m=c:0)\n\t\tc+=k==i|k==j|hypot(X[k]-p,Y[k]-q)<1;\n}\nmain(){\n\tfor(;scanf(\"%d\",&N)*N;printf(\"%d \\n\",m)){\n\t\tfor(i=N;i--;)\n\t\t\tscanf(\"%lf%lf\",X+i,Y+i);\n\t\tfor(m=1;++i<N;)\n\t\t\tfor(j=i;j--;\n\t\t\t\t\td<2?\n\t\t\t\t\t\ts=(X[i]+X[j])/2,t=(Y[i]+Y[j])/2,\n\t\t\t\t\t\tx*=d=sqrt(1-d*d/4)/d,y*=d,\n\t\t\t\t\t\tp=s-y,q=t+x,C(),p=s+x,q=t-y,C()\n\t\t\t\t\t:0)\n\t\t\t\td=hypot(x=X[i]-X[j],y=Y[i]-Y[j]);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count;\n\tint maxcount = 0;\n\tdouble x, y;\n\tfloat point[300][2];\n\n\twhile (1) {\n\t\tmaxcount = 0;\n\t\tcount = 0;\n\n\t\tscanf(\"%d\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tfor (x = 1; x < 10; x += 0.02) {\n\t\t\tfor (y = 1; y < 10; y += 0.02) {\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count, maxcount;\n\tfloat x, y;\n\tchar e;\n\tfloat point[300][2] = {{ 0.0 }};\n\n\twhile (scanf(\"%d\\n\", &num), num) {\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t\tscanf(\"%c\", &e);\n\t\t}\n\n\t\tmaxcount = 0;\n\t\tfor (x = 1; x < 10; x += 0.05) {\n\t\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= ((x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1]))) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t\tif (maxcount == num) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint main(){\n  int n,i,j,l,max,c;\n  double x[310],y[310],k,s,t,a,b,e=1e-6;\n  while(scanf(\"%d\",&n),n){\n    max=1;\n    for(i=0;i<n;i++)scanf(\"%lf %lf\",&x[i],&y[i]);\n    for(i=0;i<n;i++){\n      for(j=i+1;j<n;j++){\n\ta=(x[i]-x[j])/2;\n\tb=(y[i]-y[j])/2;\n\tif(hypot(a,b)-e>1)continue;\n\tk=tan(acos(hypot(a,b)));\n\ts=x[j]+a+k*b;\n\tt=y[j]+b-k*a;\n\tfor(l=c=0;l<n;l++){\n\t  if(hypot(x[l]-s,y[l]-t)-e<1)c++;\n\t}\n\tif(max<c)max=c;\n\ts=x[j]+a-k*b;\n\tt=y[j]+b+k*a;\n\tfor(l=c=0;l<n;l++){\n\t  if(hypot(x[l]-s,y[l]-t)-e<1)c++;\n\t}\n\tif(max<c)max=c;\n      }\n    }\n    printf(\"%d\\n\",max);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count, maxcount;\n\tfloat x, y;\n\tchar e;\n\tfloat point[300][2] = {{ 0.0 }};\n\n\twhile (1) {\n\t\tscanf(\"%d\\n\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t\tscanf(\"%c\", &e);\n\t\t}\n\n\t\tmaxcount = 0;\n\t\tfor (x = 1; x < 10; x += 0.05) {\n\t\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= ((x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1]))) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0.0;\n\t\t\tpoint[i][1] = 0.0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count, maxcount;\n\tfloat x, y;\n\tchar e;\n\tfloat point[300][2] = {{ 0.0 }};\n\n\twhile (1) {\n\t\tscanf(\"%d\\n\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t\tscanf(\"%s\", &e);\n\t\t}\n\n\t\tmaxcount = 0;\n\t\tfor (x = 1; x < 10; x += 0.05) {\n\t\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= ((x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1]))) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0.0;\n\t\t\tpoint[i][1] = 0.0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, x, y, num, count;\n\tint maxcount = 0;\n\tfloat point[300][2];\n\twhile (1) {\n\t\tmaxcount = 0;\n\t\tscanf(\"%d\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tfor (x = 1; x < 10; x += 0.01) {\n\t\t\tfor (y = 1; y < 10; y += 0.01) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count;\n\tint maxcount = 0;\n\tdouble x, y;\n\tfloat point[300][2];\n\n\twhile (1) {\n\t\tmaxcount = 0;\n\n\t\tscanf(\"%d\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tfor (x = 1; x < 10; x += 0.01) {\n\t\t\tfor (y = 1; y < 10; y += 0.01) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0;\n\t\t\tpoint[i][1] = 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nfloat point[300][2] = { { 0.0 } };\n\nint main(void) {\n\tint i, num;\n\tchar e;\n\n\twhile (scanf(\"%d\\n\", &num), num) {\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t\tscanf(\"%c\", &e);\n\t\t}\n\t\tprintf(\"%d\\n\", search(num));\n\t}\n\treturn 0;\n}\n\nint search(int num) {\n\tfloat x, y;\n\tint i, count, maxcount = 0;\n\tfor (x = 1; x < 10; x++) {\n\t\tfor (y = 1; y < 10; y++) {\n\t\t\tcount = 0;\n\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\tif (1.0 >= ((x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1]))) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count > maxcount) {\n\t\t\t\tmaxcount = count;\n\t\t\t}\n\t\t\tif (maxcount == num) {\n\t\t\t\treturn maxcount;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxcount;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1132: Circle and Points\n// 2017.10.31 bal4u@cc\n\n#include <stdio.h>\n#include <math.h>\n\n#define EPS 1e-5\ndouble x[301], y[301];\n\nint main()\n{\n\tint n, i, j, k, f, ans;\n\tdouble dx, dy, d, dd, a, ax, ay, x0, y0;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tfor (i = 0; i < n; i++) scanf(\"%lf%lf\", x+i, y+i);\n\t\tans = 1;\n\t\tfor (i = 0; i < n; i++) for (j = i+1; j < n; j++) {\n            dx = x[i]-x[j], dy = y[i]-y[j];\n            dd = dx*dx + dy*dy; d = sqrt(dd);\n            if (d <= 2+EPS) {\n\t            a = sqrt(1.0 - dd/4);\n\t\t        ax= -dy/d*a, ay = dx/d*a;\n\t\t\t\tx0 = (x[i]+x[j])/2 + ax, y0 = (y[i]+y[j])/2 + ay;\n\t\t\t\tfor (f = 0, k = 0; k < n; k++) {\n\t\t\t\t\tif ((x[k]-x0)*(x[k]-x0)+(y[k]-y0)*(y[k]-y0) < 1+EPS) f++;\n\t\t\t\t}\n\t\t\t\tif (f > ans) ans = f;\n\t\t\t}\n        }\n        printf(\"%d\\n\", ans);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count, maxcount;\n\tfloat x, y;\n\tchar e;\n\tfloat point[300][2] = {{ 0.0 }};\n\n\twhile (scanf(\"%d\\n\", &num),num) {\n\t\tmaxcount = 0;\n\t\tfor (x = 1; x < 10; x += 0.05) {\n\t\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t\t\t\tscanf(\"%c\", &e);\n\t\t\t\t\tif (1.0 >= ((x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1]))) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint main(){\n  int n,i,j,l,max,c;\n  double x[310],y[310],k,s,t,a,b,e=1e-6;\n  while(scanf(\"%d\",&n),n){\n    for(i=max=0;i<n;i++)scanf(\"%lf %lf\",&x[i],&y[i]);\n    for(i=0;i<n;i++){\n      for(j=i+1;j<n;j++){\n\ta=(x[i]-x[j])/2;\n\tb=(y[i]-y[j])/2;\n\tif(hypot(a,b)-e>1)continue;\n\tk=tan(acos(hypot(a,b)));\n\ts=x[j]+a+k*b;\n\tt=y[j]+b-k*a;\n\tfor(l=c=0;l<n;l++){\n\t  if(hypot(x[l]-s,y[l]-t)-e<1)c++;\n\t}\n\tif(max<c)max=c;\n\ts=x[j]+a-k*b;\n\tt=y[j]+b+k*a;\n\tfor(l=c=0;l<n;l++){\n\t  if(hypot(x[l]-s,y[l]-t)-e<1)c++;\n\t}\n\tif(max<c)max=c;\n      }\n    }\n    printf(\"%d\\n\",max);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define EPS 1e-7\n\nint main(void) {\n\tint n;\n\tint i,j;\n\tint count,max;\n\tdouble x[300],y[300];\n\tdouble cx,cy;\n\tsrand(65537);\n\twhile(scanf(\"%d\",&n)==1 && n!=0) {\n\t\tfor(i=0;i<n;i++)scanf(\"%lf%lf\",&x[i],&y[i]);\n\t\tmax=0;\n\t\tfor(i=0;i<1000000;i++) {\n\t\t\tcx=(i/1000)*10.0/1000.0;\n\t\t\tcy=(i%1000)*10.0/1000.0;\n\t\t\tcount=0;\n\t\t\tfor(j=0;j<n;j++) {\n\t\t\t\tif((x[j]-cx)*(x[j]-cx)+(y[j]-cy)*(y[j]-cy)<1+EPS)count++;\n\t\t\t}\n\t\t\tif(count>max)max=count;\n\t\t\tif(max==n)break;\n\t\t}\n\t\tprintf(\"%d\\n\",max);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count, maxcount;\n\tfloat x, y;\n\tchar e;\n\tfloat point[300][2] = {{ 0.0 }};\n\n\twhile (scanf(\"%d\\n\", &num),num) {\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t\tscanf(\"%c\", &e);\n\t\t}\n\n\t\tmaxcount = 0;\n\t\tfor (x = 1; x < 10; x += 0.05) {\n\t\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= ((x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1]))) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ndouble dis( double x1,double y1,double x2,double y2 ){\n  x1-=x2;  y1-=y2;\n  x1*=x1;  y1*=y1;\n  return x1+y1 ;\n}\nint main(void){\n  int n;\n  double x[300],y[300];\n  double x0,y0,x1,y1,x2,y2, xc1,yc1,xc2,yc2;\n  double a,b,c,d,e,f;\n  int i,j,k,l;\n  int max;\n\n  while( 1 ){\n    scanf(\"%d \",&n);\n    if( !n )\n      break;\n    for(i =0;i<n;i++)\n      scanf(\"%lf %lf \",&x[i],&y[i] );\n\n    max = 0;\n    for( i=0;i<n-1;i++){\n      for( j=i+1;j<n;j++){\n\tx1=x[i]; y1=y[i];\n\tx2=x[j]; y2=y[j];\n\tif( dis(x1,y1,x2,y2) > 4.0 )\n\t  continue;\n\n\tx0 = ( x1+x2 )/2; y0 = ( y1+y2 )/2;\n\t// determin (xc1,yc1) , (xc2,yc2)\n\te = x0*(x2-x1)/(y2-y1);\n\tf =    (x2-x1)/(y2-y1);\n\n\ta = x0-x1; b=y0-y1;\n\td = 1.0-a*a-b*b;\n\n\ta = f+1.0;\n\tb = -2.0*(x0+e*f);\n\tc = x0*x0+y0*y0-d;\n\n\txc1 = ( -b+sqrt( b*b-4.0*a*c ) )/(2.0*a);\n\txc2 = ( -b-sqrt( b*b-4.0*a*c ) )/(2.0*a);\n\tyc1 = e-f*xc1 +y0;\n\tyc2 = e-f*xc2 +y0;\n\n\t/*/\t\n\tprintf(\"(%f %f) (%f %f) (%f %f)\\n\",xc1,yc1,x1,y1,x2,y2);\n\tprintf(\"1-1 %f\\n\",dis(xc1,yc1,x1,y1) );\n\tprintf(\"1-2 %f\\n\",dis(xc1,yc1,x2,y2) );\n\tprintf(\"1-0 %f\\n\",dis(xc1,yc1,x0,y0) );\n\n\tprintf(\"2-1 %f\\n\",dis(xc2,yc2,x1,y1) );\n\tprintf(\"2-2 %f\\n\",dis(xc2,yc2,x2,y2) );\n\tprintf(\"2-0 %f\\n\",dis(xc2,yc2,x0,y0) );\n\t//\t*/\n\n\n\tk=2;\n\tfor( l=0;l<n;l++ ){\n\t  if( l==i || l==j )\n\t    continue;\n\t  if( dis(x[l],y[l],xc1,yc1)<=1.0 )\n\t    k++;\n\t}\n\tif( max<k )\n\t  max=k;\n\tk=2;\n\tfor( l=0;l<n;l++ ){\n\t  if( l==i || l==j )\n\t    continue;\n\t  if( dis(x[l],y[l],xc2,yc2)<=1.0 )\n\t    k++;\n\t}\n\tif( max<k )\n\t  max=k;\n      }\n    }\n    printf(\"%d\\n\",max);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count, maxcount;\n\tfloat x, y;\n\tchar e;\n\tfloat point[300][2] = {{ 0.0 }};\n\n\twhile (1) {\n\t\tscanf(\"%d\\n\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t\tscanf(\"%c\", &e);\n\t\t}\n\n\t\tmaxcount = 0;\n\t\tfor (x = 1; x < 10; x += 0.05) {\n\t\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= ((x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1]))) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count;\n\tint maxcount = 0;\n\tdouble x, y;\n\tfloat point[300][2];\n\n\twhile (1) {\n\t\tmaxcount = 0;\n\t\tcount = 0;\n\n\t\tscanf(\"%d\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tfor (x = 1; x < 10; x += 0.02) {\n\t\t\tfor (y = 1; y < 10; y += 0.02) {\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0;\n\t\t\tpoint[i][1] = 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count, maxcount;\n\tdouble x, y;\n\tfloat point[300][2] = {0};\n\n\twhile (1) {\n\t\tscanf(\"%d\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tmaxcount = 0;\n\t\tfor (x = 1; x < 10; x += 0.05) {\n\t\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0;\n\t\t\tpoint[i][1] = 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count;\n\tint maxcount = 0;\n\tdouble x, y;\n\tfloat point[300][2];\n\n\twhile (1) {\n\t\tmaxcount = 0;\n\t\tcount = 0;\n\n\t\tscanf(\"%d\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tfor (x = 1; x < 10; x += 0.05) {\n\t\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<math.h>\ntypedef struct{double x,y;}P;\nint pgeta(P*p){return~scanf(\"%lf%lf\",&p->x,&p->y);}\ndouble pabs(P p){return hypot(p.x,p.y);}\ndouble pabssq(P p){return p.x*p.x+p.y*p.y;}\nP pmake(double x,double y){P p;p.x=x;p.y=y;return p;}\nP padd(P a,P b){return pmake(a.x+b.x,a.y+b.y);}\nP psub(P a,P b){return pmake(a.x-b.x,a.y-b.y);}\nP pmul(P a,double b){return pmake(a.x*b,a.y*b);}\nP pdiv(P a,double b){return pmake(a.x/b,a.y/b);}\nP punit(P p){return pdiv(p,pabs(p));}//PÊxNg\nP prot_l(P p){return pmake(-p.y,p.x);}//xNgÌ¶90xñ]\nP pnormal_l(P p){return punit(prot_l(p));}//@üxNg(¶)\nP pcenter(P a,P b){return pmake((a.x+b.x)/2,(a.y+b.y)/2);}//_\ndouble dist_p_p(P a,P b){return pabs(psub(a,b));}//2_Ì£\ndouble distsq_p_p(P a,P b){return pabssq(psub(a,b));}//2_Ì£Ìñæ\n\nmain(){\n\tint N,i,j,k,c,max;\n\tP q[300];\n\tfor(;scanf(\"%d\",&N)*N;){\n\t\tfor(i=0;i<N;i++)\n\t\t\tpgeta(q+i);\n\t\tmax=0;\n\t\tfor(i=0;i<N;i++){\n\t\t\tfor(j=0;j<i;j++){\n\t\t\t\tP a=q[i];\n\t\t\t\tP b=q[j];\n\t\t\t\tP ab=psub(a,b);\n\t\t\t\tP m=pcenter(a,b);\n\t\t\t\tP mpn=pnormal_l(ab);\n\t\t\t\tP mp=pmul(mpn,sqrt(1-pabssq(ab)/4));\n\t\t\t\t{\n\t\t\t\t\tP p=padd(m,mp);\n\t\t\t\t\tc=0;\n\t\t\t\t\tfor(k=0;k<N;k++){\n\t\t\t\t\t\tif(k==i||k==j||distsq_p_p(q[k],p)<1)\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t\tif(c>max)\n\t\t\t\t\t\tmax=c;\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tP p=psub(m,mp);\n\t\t\t\t\tc=0;\n\t\t\t\t\tfor(k=0;k<N;k++){\n\t\t\t\t\t\tif(k==i||k==j||distsq_p_p(q[k],p)<1)\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t\tif(c>max)\n\t\t\t\t\t\tmax=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d \\n\",max);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, x, y, num, count;\n\tint maxcount = 0;\n\tfloat point[300][2];\n\twhile (1) {\n\t\tmaxcount = 0;\n\t\tscanf(\"%d\", num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tfor (x = 1; x < 10; x += 0.01) {\n\t\t\tfor (y = 1; y < 10; y += 0.01) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count, maxcount;\n\tfloat x, y;\n\tfloat point[300][2] = {0};\n\n\twhile (1) {\n\t\tscanf(\"%d\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tmaxcount = 0;\n\t\tfor (x = 1; x < 10; x += 0.05) {\n\t\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0;\n\t\t\tpoint[i][1] = 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nint main(void) {\n\tfloat point[300][2] = {0.0};\n\n\twhile (1) {\n\t\tint i, num, count, maxcount;\n\t\tfloat x, y;\n\t\tscanf(\"%d\\n\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tmaxcount = 0;\n\t\tfor (x = 1; x < 10; x += 0.05) {\n\t\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= ((x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1]))) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0;\n\t\t\tpoint[i][1] = 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nfloat point[300][2];\n\nint main(void) {\n\tint i, num, count, maxcount;\n\tfloat x, y;\n\n\twhile (1) {\n\t\tscanf(\"%d\\n\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tmaxcount = 0;\n\t\tfor (x = 1; x < 10; x += 0.05) {\n\t\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#define p2(x) ((x)*(x))\n#define mul(rx,ry,x1,y1,x2,y2) ((rx)=(x1)*(x2)-(y1)*(y2),(ry)=(x2)*(y1)+(x1)*(y2))\n#define R 1\ndouble X[300],Y[300],hyp,t,pl,dx,dy,x[2],y[2];\nint main(){int N,M,m,i,j,k,z;for(;scanf(\"%d\",&N),N;printf(\"%d\\n\",M)){\n\tfor(i=0;i<N;i++)scanf(\"%lf%lf\",X+i,Y+i);\n\tfor(M=1,i=0;i<N;i++)for(j=i+1;j<N;j++){\n\t\thyp=hypot(X[j]-X[i],Y[j]-Y[i]);\n\t\tif(hyp>2*R)continue;\n\t\t//t=( p2(R)-p2(R)+p2(hyp) )/( 2*hyp );\n\t\tt=hyp/2;\n\t\tpl=sqrt(p2(R)-p2(t));\n\t\tdx=(X[j]-X[i])/hyp;\n\t\tdy=(Y[j]-Y[i])/hyp;\n\t\tmul(x[0],y[0],dx,dy,t,pl);\n\t\tmul(x[1],y[1],dx,dy,t,-pl);\n\t\tfor(z=0;z<2;z++){\n\t\t\tx[z]+=X[i],y[z]+=Y[i];\n\t\t\tfor(m=k=0;k<N;k++)if(p2(X[k]-x[z])+p2(Y[k]-y[z])<p2(R)+1e-9)m++;\n\t\t\tif(M<m)M=m;\n\t\t}\n\t}\n}return 0;}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define EPS 1e-7\n\n#define ENSYURITU 3.1415926535897932384626433832795028841\n\nint main(void) {\n\tint n;\n\tint i,j,k;\n\tint count,max;\n\tint loopmax;\n\tdouble x[300],y[300];\n\tdouble cx,cy;\n\twhile(scanf(\"%d\",&n)==1 && n!=0) {\n\t\tfor(i=0;i<n;i++)scanf(\"%lf%lf\",&x[i],&y[i]);\n\t\tmax=0;\n\t\tloopmax=500000/n;\n\t\tfor(k=0;k<n;k++) {\n\t\t\tfor(i=0;i<loopmax;i++) {\n\t\t\t\tcx=x[k]+cos(2*ENSYURITU*i/loopmax);\n\t\t\t\tcy=y[k]+sin(2*ENSYURITU*i/loopmax);\n\t\t\t\tcount=0;\n\t\t\t\tfor(j=0;j<n;j++) {\n\t\t\t\t\tif((x[j]-cx)*(x[j]-cx)+(y[j]-cy)*(y[j]-cy)<1+EPS)count++;\n\t\t\t\t}\n\t\t\t\tif(count>max)max=count;\n\t\t\t\tif(max==n)break;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",max);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#define p2(x) ((x)*(x))\n#define mul(rx,ry,x1,y1,x2,y2) ((rx)=(x1)*(x2)-(y1)*(y2),(ry)=(x2)*(y1)+(x1)*(y2))\n#define R 1\ndouble X[300],Y[300],hyp,t,pl,dx,dy,x[2],y[2];\nint main(){int N,M,m,i,j,k,z;for(;scanf(\"%d\",&N),N;printf(\"%d\\n\",M)){\n\tfor(i=0;i<N;i++)scanf(\"%lf%lf\",X+i,Y+i);\n\tfor(M=1,i=0;i<N;i++)for(j=i+1;j<N;j++){\n\t\thyp=hypot(X[j]-X[i],Y[j]-Y[i]);\n\t\tif(hyp>2*R)continue;\n\t\t//t=( p2(R)-p2(R)+p2(hyp) )/( 2*hyp );\n\t\tt=hyp/2;\n\t\tpl=sqrt(p2(R)-p2(t));\n\t\tdx=(X[j]-X[i])/hyp;\n\t\tdy=(Y[j]-Y[i])/hyp;\n\t\tmul(x[0],y[0],dx,dy,t,pl);\n\t\tmul(x[1],y[1],dx,dy,t,-pl);\n\t\tfor(z=0;z<2;z++){\n\t\t\tx[z]+=X[i],y[z]+=Y[i];\n\t\t\tfor(m=k=0;k<N;k++)if(p2(X[k]-x[z])+p2(Y[k]-y[z])<p2(R)+1e-9)m++;\n\t\t\tif(M<m)M=m;\n\t\t}\n\t}\n}return 0;}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n \n#define N_MAX 300\n \nfloat point[N_MAX][2];\n \nint main() {\n  int n, big;\n   \n  while (scanf(\"%d\\n\", &n), n) {\n    int i;\n    float x, y;\n     \n    for (i = 0; i < n; i++) {\n      scanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n    }\n     \n    big = 0;\n     \n    for (x = 1; x < 10; x += 0.05) {\n      for (y = 1; y < 10; y += 0.05) {\n    int count = 0;\n    for (i = 0; i < n; i++) {\n      if (1.0 >=  (x - point[i][0]) * (x - point[i][0])\n               + (y - point[i][1]) * (y - point[i][1])) {\n        count++;\n      }\n    }\n     \n    if (count > big) {\n      big = count;\n    }\n      }\n    }\n     \n    printf(\"%d\\n\", big);\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#define p2(x) ((x)*(x))\n#define mul(rx,ry,x1,y1,x2,y2) ((rx)=(x1)*(x2)-(y1)*(y2),(ry)=(x2)*(y1)+(x1)*(y2))\n#define R 1\ndouble X[300],Y[300],hyp,t,pl,dx,dy,x[2],y[2];\nmain(N,M,m,i,j,k,z){for(;scanf(\"%d\",&N),N;printf(\"%d\\n\",M)){\n\tfor(i=0;i<N;i++)scanf(\"%lf%lf\",X+i,Y+i);\n\tfor(M=1,i=0;i<N;i++)for(j=i+1;j<N;j++){\n\t\thyp=hypot(X[j]-X[i],Y[j]-Y[i]);\n\t\tif(hyp>2*R)continue;\n\t\t//t=( p2(R)-p2(R)+p2(hyp) )/( 2*hyp );\n\t\tt=hyp/2;\n\t\tpl=sqrt(p2(R)-p2(t));\n\t\tdx=(X[j]-X[i])/hyp;\n\t\tdy=(Y[j]-Y[i])/hyp;\n\t\tmul(x[0],y[0],dx,dy,t,pl);\n\t\tmul(x[1],y[1],dx,dy,t,-pl);\n\t\tx[0]+=X[i],x[1]+=X[i],y[0]+=Y[i],y[1]+=Y[i];\n\t\tfor(z=0;z<2;z++){\n\t\t\tfor(m=k=0;k<N;k++)if(p2(X[k]-x[z])+p2(Y[k]-y[z])<R*R+1e-9)m++;\n\t\t\tif(M<m)M=m;\n\t\t}\n\t}\n}return 0;}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nfloat point[300][2] = { {0.0} };\nint search(int num);\n\nint main(void) {\n\tint i, num;\n\n\twhile (1) {\n\t\tscanf(\"%d\\n\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\t\tprintf(\"%d\\n\", search(num));\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0.0;\n\t\t\tpoint[i][1] = 0.0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint search(int num) {\n\tfloat x, y;\n\tint i, count, maxcount = 0;\n\tfor (x = 1; x < 10; x += 0.01) {\n\t\tfor (y = 1; y < 10; y += 0.01) {\n\t\t\tcount = 0;\n\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\tif (1.0 >= ((x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1]))) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count > maxcount) {\n\t\t\t\tmaxcount = count;\n\t\t\t}\n\t\t\tif (maxcount == num) {\n\t\t\t\treturn maxcount;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxcount;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nconst double EPS = 1e-8;\n\nint n;\nPoint data[300];\n\nint calc(Point a, Point b){\n  int res = 0;\n  double d = abs(b - a) / 2.0;\n  Point ab = (b - a) / (2.0 * d);\n  if(d < 1){\n    Point o = ab * d;\n    d = sqrt(1.0 - d * d);\n    o += Point(d * ab.imag() + a.real(), -d * ab.real() + a.imag());\n    for(int i=0;i<n;i++){\n      if(abs(o - data[i]) < 1.0 + EPS) res++;\n    }\n  }\n  return res;\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      cin >> data[i].imag() >> data[i].real();\n    }\n    int ans = 1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        ans = max(ans, calc(data[i], data[j]));\n        ans = max(ans, calc(data[j], data[i]));\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C",
    "code": "double X[300],Y[300],x,y,d,s,t,p,q;N,i,j,m;C(c,k){c=0;for(k=N;k--;c>m?m=c:0)c+=k==i|k==j|hypot(X[k]-p,Y[k]-q)<1;}main(){for(;scanf(\"%d\",&N)*N;printf(\"%d\\n\",m)){for(i=N;i--;)scanf(\"%lf%lf\",X+i,Y+i);for(m=1;++i<N;)for(j=i;j--;d<2?s=(X[i]+X[j])/2,t=(Y[i]+Y[j])/2,x*=d=sqrt(1-d*d/4)/d,y*=d,C(p=s-y,q=t+x),C(p=s+x,q=t-y):0)d=hypot(x=X[i]-X[j],y=Y[i]-Y[j]);}\n{int n;for(n=1000000;n--;)getchar();}\n}"
  },
  {
    "language": "C",
    "code": "float X[300],Y[300],x,y,d,s,t;N,i,j,m;C(c,k){c=0;for(k=N;k--;c>m?m=c:0)c+=k==i|k==j|hypot(X[k]-s,Y[k]-t)<1;}main(){for(;scanf(\"%d\",&N)*N;printf(\"%d\\n\",m)){for(i=N;i--;)scanf(\"%f%f\",X+i,Y+i);for(m=1;++i<N;)for(j=i;j--;d<4?s=(X[i]+X[j])/2-(y*=d=sqrt(1/d-.25)),C(t=(Y[i]+Y[j])/2+(x*=d)),s+=x+=y,C(t-=x):0)x=X[i]-X[j],y=Y[i]-Y[j],d=x*x+y*y;}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count, maxcount;\n\tdouble x, y;\n\tfloat point[300][2] = {0};\n\n\twhile (1) {\n\t\tscanf(\"%d\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tmaxcount = 0;\n\t\tfor (x = 1; x < 10; x += 0.01) {\n\t\t\tfor (y = 1; y < 10; y += 0.01) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0;\n\t\t\tpoint[i][1] = 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n \n#define N_MAX 300\n \nfloat point[N_MAX][2];\n \nint main() {\n  int n, big;\n   \n  while (scanf(\"%d\\n\", &n), n) {\n    int i;\n    float x, y;\n     \n    for (i = 0; i < n; i++) {\n      scanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n    }\n     \n    big = 0;\n     \n    for (x = 1; x < 10; x += 0.05) {\n      for (y = 1; y < 10; y += 0.05) {\n    int count = 0;\n    for (i = 0; i < n; i++) {\n      if (1.0 >=  (x - point[i][0]) * (x - point[i][0])\n               + (y - point[i][1]) * (y - point[i][1])) {\n        count++;\n      }\n    }\n     \n    if (count > big) {\n      big = count;\n    }\n      }\n    }\n     \n    printf(\"%d\\n\", big);\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count, maxcount;\n\tfloat x, y;\n\tchar e;\n\tfloat point[300][2] = {{ 0.0 }};\n\n\twhile (1) {\n\t\tscanf(\"%d\\n\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t\tscanf(\"%c\", &e);\n\t\t}\n\n\t\tmaxcount = 0;\n\t\tfor (x = 1; x < 10; x += 0.1) {\n\t\t\tfor (y = 1; y < 10; y += 0.1) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= ((x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1]))) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0.0;\n\t\t\tpoint[i][1] = 0.0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define EPS 1e-7\n\nint main(void) {\n\tint n;\n\tint i,j;\n\tint count,max;\n\tdouble x[300],y[300];\n\tdouble cx,cy;\n\tsrand(65537);\n\twhile(scanf(\"%d\",&n)==1 && n!=0) {\n\t\tfor(i=0;i<n;i++)scanf(\"%lf%lf\",&x[i],&y[i]);\n\t\tmax=0;\n\t\tfor(i=0;i<1000000;i++) {\n\t\t\tcx=(double)rand()/RAND_MAX*10.0;\n\t\t\tcy=(double)rand()/RAND_MAX*10.0;\n\t\t\tcount=0;\n\t\t\tfor(j=0;j<n;j++) {\n\t\t\t\tif((x[j]-cx)*(x[j]-cx)+(y[j]-cy)*(y[j]-cy)<1+EPS)count++;\n\t\t\t}\n\t\t\tif(count>max)max=count;\n\t\t\tif(max==n)break;\n\t\t}\n\t\tprintf(\"%d\\n\",max);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<math.h>\ntypedef struct{double x,y;}P;\nint pgeta(P*p){return~scanf(\"%lf%lf\",&p->x,&p->y);}\ndouble pabs(P p){return hypot(p.x,p.y);}\ndouble pabssq(P p){return p.x*p.x+p.y*p.y;}\nP pmake(double x,double y){P p;p.x=x;p.y=y;return p;}\nP padd(P a,P b){return pmake(a.x+b.x,a.y+b.y);}\nP psub(P a,P b){return pmake(a.x-b.x,a.y-b.y);}\nP pmul(P a,double b){return pmake(a.x*b,a.y*b);}\nP pdiv(P a,double b){return pmake(a.x/b,a.y/b);}\nP punit(P p){return pdiv(p,pabs(p));}//PÊxNg\nP prot_l(P p){return pmake(-p.y,p.x);}//xNgÌ¶90xñ]\nP pnormal_l(P p){return punit(prot_l(p));}//@üxNg(¶)\nP pcenter(P a,P b){return pmake((a.x+b.x)/2,(a.y+b.y)/2);}//_\ndouble dist_p_p(P a,P b){return pabs(psub(a,b));}//2_Ì£\n\nmain(){\n\tint N,i,j,k,c,max;\n\tP q[300];\n\tfor(;scanf(\"%d\",&N)*N;){\n\t\tfor(i=0;i<N;i++)\n\t\t\tpgeta(q+i);\n\t\tmax=0;\n\t\tfor(i=0;i<N;i++){\n\t\t\tfor(j=0;j<i;j++){\n\t\t\t\tP a=q[i];\n\t\t\t\tP b=q[j];\n\t\t\t\tP ab=psub(a,b);\n\t\t\t\tP m=pcenter(a,b);\n\t\t\t\tP mpn=pnormal_l(ab);\n\t\t\t\tP mp=pmul(mpn,sqrt(1-pabssq(ab)/4));\n\t\t\t\t{\n\t\t\t\t\tP p=padd(m,mp);\n\t\t\t\t\tc=0;\n\t\t\t\t\tfor(k=0;k<N;k++){\n\t\t\t\t\t\tif(k==i||k==j||dist_p_p(q[k],p)<1)\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t\tif(c>max)\n\t\t\t\t\t\tmax=c;\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tP p=psub(m,mp);\n\t\t\t\t\tc=0;\n\t\t\t\t\tfor(k=0;k<N;k++){\n\t\t\t\t\t\tif(k==i||k==j||dist_p_p(q[k],p)<1)\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t\tif(c>max)\n\t\t\t\t\t\tmax=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d \\n\",max);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<math.h>\ntypedef struct{double x,y;}P;\nint pgeta(P*p){return~scanf(\"%lf%lf\",&p->x,&p->y);}\ndouble pabs(P p){return hypot(p.x,p.y);}\ndouble pabssq(P p){return p.x*p.x+p.y*p.y;}\nP pmake(double x,double y){P p;p.x=x;p.y=y;return p;}\nP padd(P a,P b){return pmake(a.x+b.x,a.y+b.y);}\nP psub(P a,P b){return pmake(a.x-b.x,a.y-b.y);}\nP pmul(P a,double b){return pmake(a.x*b,a.y*b);}\nP pdiv(P a,double b){return pmake(a.x/b,a.y/b);}\nP punit(P p){return pdiv(p,pabs(p));}//PÊxNg\nP prot_l(P p){return pmake(-p.y,p.x);}//xNgÌ¶90xñ]\nP pnormal_l(P p){return punit(prot_l(p));}//@üxNg(¶)\nP pcenter(P a,P b){return pmake((a.x+b.x)/2,(a.y+b.y)/2);}//_\ndouble dist_p_p(P a,P b){return pabs(psub(a,b));}//2_Ì£\ndouble distsq_p_p(P a,P b){return pabssq(psub(a,b));}//2_Ì£Ìñæ\n\nmain(){\n\tint N,i,j,k,c,max;\n\tP q[300];\n\tfor(;scanf(\"%d\",&N)*N;){\n\t\tfor(i=0;i<N;i++)\n\t\t\tpgeta(q+i);\n\t\tmax=0;\n\t\tfor(i=0;i<N;i++){\n\t\t\tfor(j=0;j<i;j++){\n\t\t\t\tP a=q[i];\n\t\t\t\tP b=q[j];\n\t\t\t\tP ab=psub(a,b);\n\t\t\t\tdouble absq=pabssq(ab);\n\t\t\t\tif(absq<=4){\n\t\t\t\t\tP m=pcenter(a,b);\n\t\t\t\t\tP mpn=pnormal_l(ab);\n\t\t\t\t\tP mp=pmul(mpn,sqrt(1-absq/4));\n\t\t\t\t\t{\n\t\t\t\t\t\tP p=padd(m,mp);\n\t\t\t\t\t\tc=0;\n\t\t\t\t\t\tfor(k=0;k<N;k++){\n\t\t\t\t\t\t\tif(k==i||k==j||distsq_p_p(q[k],p)<1)\n\t\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(c>max)\n\t\t\t\t\t\t\tmax=c;\n\t\t\t\t\t}\n\t\t\t\t\t{\n\t\t\t\t\t\tP p=psub(m,mp);\n\t\t\t\t\t\tc=0;\n\t\t\t\t\t\tfor(k=0;k<N;k++){\n\t\t\t\t\t\t\tif(k==i||k==j||distsq_p_p(q[k],p)<1)\n\t\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(c>max)\n\t\t\t\t\t\t\tmax=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d \\n\",max);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define EPS 1e-5\n\nfloat point[300][2] = { {0.0} };\nfloat l[300][2] = { { 0.0 } };\nint search(int num);\nint dist(int a, int b, double d);\n\nint main(void) {\n\tint i, num;\n\n\twhile (1) {\n\t\tscanf(\"%d\\n\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tprintf(\"%d\\n\", search(num));\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0.0;\n\t\t\tpoint[i][1] = 0.0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint search(int num) {\n\tint s, i, j;\n\tint count, maxcount;\n\tdouble a, a0, d;\n\n\ts = 0;\n\n\tfor (i = 0; i < num; i++) {\n\t\tfor (j = 0; j < num; j++) {\n\t\t\tif (dist(i, j, 2) && i != j) {\n\n\t\t\t\tfloat X = (point[i][0] - point[j][0]);\n\t\t\t\tfloat Y = (point[i][1] - point[j][1]);\n\n\t\t\t\td = sqrt(X*X + Y*Y);\n\t\t\t\ta = atan2(point[j][1] - point[i][1], point[j][0] - point[i][0]);\n\t\t\t\ta0 = acos(0.5 * d);\n\n\t\t\t\tl[s][0] = point[i][0] + cos(a0 + a);\n\t\t\t\tl[s][1] = point[i][1] + sin(a0 + a);\n\t\t\t\ts++;\n\t\t\t\tl[s][0] = point[i][0] + cos(a0 - a);\n\t\t\t\tl[s][1] = point[i][1] + sin(a0 - a);\n\t\t\t\ts++;\n\t\t\t}\n\t\t}\n\t}\n\n\tmaxcount = 1;\n\tfor (i = 0; i < s; i++) {\n\t\tcount = 0;\n\t\tfor (j = 0; j < num; j++) {\n\t\t\tif (dist2(j, i, 1)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif (count > maxcount) {\n\t\t\tmaxcount = count;\n\t\t}\n\t}\n\treturn maxcount;\n}\n\nint dist(int a, int b, double d){\n\tfloat X = (point[a][0] - point[b][0]);\n\tfloat Y = (point[a][1] - point[b][1]);\n\tif (sqrt(X*X + Y*Y) - d > EPS) {\n\t\treturn (0);\n\t}\n\treturn (1);\n}\n\nint dist2(int a, int b, double d) {\n\tfloat X = (point[a][0] - l[b][0]);\n\tfloat Y = (point[a][1] - l[b][1]);\n\tif (sqrt(X*X + Y*Y) - d > EPS) {\n\t\treturn (0);\n\t}\n\treturn (1);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count, maxcount;\n\tfloat x, y;\n\tfloat point[300][2] = {0.0};\n\n\twhile (1) {\n\t\tscanf(\"%d\\n\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tmaxcount = 0;\n\t\tfor (x = 1; x < 10; x += 0.05) {\n\t\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= ((x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1]))) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0.0;\n\t\t\tpoint[i][1] = 0.0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count;\n\tint maxcount = 0;\n\tdouble x, y;\n\tfloat point[300][2];\n\twhile (1) {\n\t\tmaxcount = 0;\n\t\tscanf(\"%d\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tfor (x = 1; x < 10; x += 0.01) {\n\t\t\tfor (y = 1; y < 10; y += 0.01) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nfloat point[300][2] = { {0.0} };\nint search(int num);\n\nint main(void) {\n\tint i, num;\n\tchar e;\n\n\twhile (1) {\n\t\tscanf(\"%d\\n\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\t}\n\t\tprintf(\"%d\\n\", search(num));\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0.0;\n\t\t\tpoint[i][1] = 0.0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint search(int num) {\n\tfloat x, y;\n\tint i, count, maxcount = 0;\n\tfor (x = 1; x < 10; x += 0.05) {\n\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\tcount = 0;\n\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\tif (1.0 >= ((x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1]))) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count > maxcount) {\n\t\t\t\tmaxcount = count;\n\t\t\t}\n\t\t\tif (maxcount == num) {\n\t\t\t\treturn maxcount;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxcount;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n \n \nint main() {\n\tint point_num, ans;\n\tfloat point[300][2];   \n\tfor(;;){\n\t\tscanf(\"%d\\n\", &point_num);\n\t\tif(point_num == 0)\n\t\t\tbreak;\n\t\tint i;\n\t\tfloat x, y;\n\t\tfor (i = 0; i < point_num; i++)\n\t\t\tscanf(\"%f %f\\n\", &point[i][0], &point[i][1]);\n\t\tans = 0;\n\t\t\n\t\tfor (x = 1; x < 10; x += 0.005) {\n\t\t\tfor (y = 1; y < 10; y += 0.005) {\n\t\t\t\tint count = 0;\n\t\t\t\tfor (i = 0; i < point_num; i++) {\n\t\t\t\t\tif (1.0 >=  (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1]))\n\t\t\t\t\t\tcount++;\n\t\t\t\tif (count > ans)\n\t\t\t\t\tans = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint i, num, count, maxcount;\n\tdouble x, y;\n\tfloat point[300][2] = {0};\n\n\twhile (1) {\n\t\tscanf(\"%d\", &num);\n\t\tif (num == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tscanf(\"%f %f\", &point[i][0], &point[i][1]);\n\t\t}\n\n\t\tmaxcount = 0;\n\t\tfor (x = 1; x < 10; x += 0.05) {\n\t\t\tfor (y = 1; y < 10; y += 0.05) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tif (1.0 >= (x - point[i][0]) * (x - point[i][0]) + (y - point[i][1]) * (y - point[i][1])) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count > maxcount) {\n\t\t\t\t\tmaxcount = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxcount);\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tpoint[i][0] = 0;\n\t\t\tpoint[i][1] = 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tnew Main().calc();\n\t}\n\n\tdouble[] x;\n\tdouble[] y;\n\tint n;\n\tvoid calc(){\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = cin.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tx = new double[n];\n\t\t\ty = new double[n];\n\t\t\tint i,j;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tx[i] = cin.nextDouble();\n\t\t\t\ty[i] = cin.nextDouble();\n\t\t\t}\n\t\t\tint ret = 0;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tret = Math.max(ret, getnum(x[i],y[i]));\n\t\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\t\tif(Math.hypot(x[i]-x[j], y[i]-y[j]) > 2) continue;\n\t\t\t\t\tret = Math.max(ret, getmax(new int[]{i,j}));\n\t\t\t\t\tret = Math.max(ret, getmax(new int[]{j,i}));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ret);\n\t\t}\n\t}\n\n\tint getmax(int[] nums){\n\t\tdouble nx = 0;\n\t\tdouble ny = 0;\n\t\tfor(int a : nums){\n\t\t\tnx += x[a]/nums.length;\n\t\t\tny += y[a]/nums.length;\n\t\t}\n\t\tdouble vx = nx-x[nums[0]];\n\t\tdouble vy = ny-y[nums[0]];\n\t\tdouble d = Math.hypot(vx, vy);\n\t\tdouble nokori = Math.sqrt(1-d*d);\n\t\tnx += vy / Math.hypot(vx, vy) * nokori;\n\t\tny -= vx / Math.hypot(vx, vy) * nokori;\n\t\treturn getnum(nx,ny);\n\t}\n\n\tint getnum(double nx, double ny){\n\t\tint ret = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif((nx-x[i])*(nx-x[i])+ (ny-y[i]) * (ny-y[i])<=1) ret++;\n\t\t}\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D[] points = new Point2D[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tpoints[i] = new Point2D(sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tint max = 1;\n\t\t\t\n\t\t\tfor(int fst = 0; fst < n; fst++){\n\t\t\t\tfor(int snd = 0; snd < n; snd++){\n\t\t\t\t\tPoint2D[] cross = Point2D.cross_ss(points[fst], 1, points[snd], 1);\n\t\t\t\t\t\n\t\t\t\t\tfor(Point2D cross_c : cross){\n\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\t\tif(cross_c.dist(points[i]) <= 1.0 + Point2D.EPS){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tmax = Math.max(max, count);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t\t\n\t}\n}\n\nclass Point2D {\n    public double x;\n    public double y;\n \n    public static final double EPS = 1e-3;\n \n    public Point2D(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n \n    public Point2D(Point2D point) {\n        this.x = point.x;\n        this.y = point.y;\n    }\n \n    public String toString() {\n        return x + \",\" + y;\n    }\n \n    @Override\n    public boolean equals(Object o) {\n        if (o instanceof Point2D) {\n            Point2D another = (Point2D) o;\n            if (this.x - EPS < another.x && this.x + EPS > another.x\n                    && this.y - EPS < another.y && this.y + EPS > another.y) {\n                return true;\n            }\n             \n            return false;\n \n            // return this.x == another.x && this.y == another.y;\n        }\n        return false;\n    }\n \n    public Point2D add(double x, double y) {\n        return new Point2D(this.x + x, this.y + y);\n    }\n \n    public Point2D sub(double x, double y) {\n        return add(-x, -y);\n    }\n \n    public Point2D add(Point2D another) {\n        return add(another.x, another.y);\n    }\n \n    public Point2D sub(Point2D another) {\n        return sub(another.x, another.y);\n    }\n \n    public Point2D mul(double d) {\n        return new Point2D(this.x * d, this.y * d);\n    }\n \n    public Point2D div(double d) {\n        return new Point2D(this.x / d, this.y / d);\n    }\n \n    public double dot(double x, double y) {\n        return this.x * x + this.y * y;\n    }\n \n    public double dot(Point2D another) {\n        return dot(another.x, another.y);\n    }\n \n    public double cross(double x, double y) {\n        return this.x * y - this.y * x;\n    }\n \n    public double cross(Point2D another) {\n        return cross(another.x, another.y);\n    }\n \n    public double dist(double x, double y) {\n        return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n                * (this.y - y));\n    }\n \n    public double dist(Point2D another) {\n        return dist(another.x, another.y);\n    }\n \n    public double dist_o() {\n        return dist(0, 0);\n    }\n \n    public Point2D unit() {\n        return div(dist_o());\n    }\n \n    public boolean pol(Point2D start, Point2D end) {\n        return end.sub(start).cross(this.sub(start)) < EPS;\n    }\n \n    public boolean pos(Point2D start, Point2D end) {\n        return (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n    }\n \n    public double pld(Point2D start, Point2D end) {\n        return Math.abs((end.sub(start).cross(this.sub(start)))\n                / end.sub(start).dist_o());\n    }\n \n    public double psd(Point2D start, Point2D end) {\n        if (end.sub(start).dot(this.sub(start)) < EPS) {\n            return this.dist(start);\n        } else if (start.sub(end).dot(this.sub(end)) < EPS) {\n            return this.dist(end);\n        } else {\n            return end.sub(start).cross(this.sub(start)) / end.dist(start);\n        }\n    }\n \n    public static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS)\n                && (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n    }\n \n    public static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return a1.sub(a2).cross(b1.sub(b2)) < EPS;\n    }\n \n    public static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D b = b2.sub(b1);\n        double d1 = Math.abs(b.cross(a1.sub(b1)));\n        double d2 = Math.abs(b.cross(a2.sub(b1)));\n        double t = d1 / (d1 + d2);\n        Point2D a = a2.sub(a1), v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D a = a2.sub(a1);\n        Point2D b = b2.sub(b1);\n        double t = b.cross(b1.sub(a1)) / b.cross(a);\n        Point2D v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n            double r2) {\n        double dis = p1.dist(p2);\n \n        if (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n            return new Point2D[0]; // same\n        }\n \n        if (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n            Point2D tmp = p2.sub(p1);\n            tmp = tmp.mul(r1 / tmp.dist_o());\n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis + EPS > r1 + r2) {\n            return new Point2D[0]; // out\n        }\n \n        double dis_m = Math.abs(r1 - r2);\n \n        if (dis_m + EPS > dis && dis_m - EPS < dis) {\n            Point2D tmp = null;\n            if (r1 > r2) {\n                tmp = p2.sub(p1);\n            } else {\n                tmp = p1.sub(p2);\n            }\n \n            double min = Math.min(r1, r2);\n \n            tmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n \n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis_m + EPS > dis) {\n            return new Point2D[0]; // inner\n        } else {\n            Point2D ret[] = new Point2D[2];\n \n            double theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n                    / (2 * dis * r1));\n            double a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n \n            ret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n                    * Math.sin(a + theta) + p1.y);\n            ret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n                    * Math.sin(a - theta) + p1.y);\n            return ret;\n        }\n    }\n \n    public void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n            Point2D ans[]) {\n        if (c.pld(start, end) > r + EPS)\n            return;\n        Point2D v = end.sub(start).unit();\n        double delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n                - start.dist(c) * start.dist(c) + r * r;\n        double t = -v.dot(start.sub(c));\n        double s = Math.sqrt(delta);\n        ans[0] = start.add(v.mul(t + s));\n        ans[1] = start.add(v.mul(t + s));\n    }\n \n    public Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n        Point2D v = b.sub(a).unit();\n        v = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n                (-1) * v.y, v.x);\n        return v.mul(p.pld(a, b));\n    }\n \n    public double area(Point2D a, Point2D b, Point2D c) {\n        return Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tfinal double EPS = 1.0e-08;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdouble [] x = new double[n];\n\t\t\tdouble [] y = new double[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t}\n\t\t\tint ans = 1;\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tfor(int j=i+1; j < n; j++){\n\t\t\t\t\tdouble midx = (x[i] + x[j]) / 2.0;\n\t\t\t\t\tdouble midy = (y[i] + y[j]) / 2.0;\n\t\t\t\t\tdouble halfdis = Point2D.distance(x[i], y[i], x[j], y[j]) / 2;\n\t\t\t\t\tif(halfdis> 1.0 + EPS){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble midxV = x[i] - midx;\n\t\t\t\t\tdouble midyV = y[i] - midy;\n\t\t\t\t\tdouble tocenterDis = Math.sqrt(1.0 - halfdis * halfdis);\n\t\t\t\t\tfor(int k=0; k <= 1;k++){\n\t\t\t\t\t\tdouble midxV2, midyV2;\n\t\t\t\t\t\tif(k==0){\n\t\t\t\t\t\t\tmidxV2 = midyV * -1;\n\t\t\t\t\t\t\tmidyV2 = midxV;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tmidxV2 = midyV;\n\t\t\t\t\t\t\tmidyV2 = midxV * -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdouble dis2 = Math.sqrt(midxV2 * midxV2 + midyV2 * midyV2);\n\t\t\t\t\t\tdouble cx = (midxV2) * tocenterDis / dis2 + midx;\n\t\t\t\t\t\tdouble cy = (midyV2) * tocenterDis / dis2 + midy;\n\t\t\t\t\t\t//System.out.println(\"cx= \" + cx + \"cy \" + cy);\n\t\t\t\t\t\tint res = getCount(cx,cy,x,y);\n\t\t\t\t\t\tans = Math.max(ans, res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate int getCount(double cx, double cy, double[] x, double[] y) {\n\t\tint count = 0;\n\t\tfor(int i=0; i < x.length;i++){\n\t\t\tdouble res = Point2D.distance(cx, cy, x[i], y[i]);\n\t\t\tif(res<= 1.0 + EPS){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D[] points = new Point2D[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tpoints[i] = new Point2D(sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tint max = 1;\n\t\t\t\n\t\t\tfor(int fst = 0; fst < n; fst++){\n\t\t\t\tfor(int snd = 0; snd < n; snd++){\n\t\t\t\t\tPoint2D[] cross = Point2D.cross_ss(points[fst], 1, points[snd], 1);\n\t\t\t\t\t\n\t\t\t\t\tfor(Point2D cross_c : cross){\n\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\t\tif(cross_c.dist(points[i]) < 1.0 + Point2D.EPS){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tmax = Math.max(max, count);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t\t\n\t}\n}\n\nclass Point2D {\n    public double x;\n    public double y;\n \n    public static final double EPS = 1e-6;\n \n    public Point2D(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n \n    public Point2D(Point2D point) {\n        this.x = point.x;\n        this.y = point.y;\n    }\n \n    public String toString() {\n        return x + \",\" + y;\n    }\n \n    @Override\n    public boolean equals(Object o) {\n        if (o instanceof Point2D) {\n            Point2D another = (Point2D) o;\n            if (this.x - EPS < another.x && this.x + EPS > another.x\n                    && this.y - EPS < another.y && this.y + EPS > another.y) {\n                return true;\n            }\n             \n            return false;\n \n            // return this.x == another.x && this.y == another.y;\n        }\n        return false;\n    }\n \n    public Point2D add(double x, double y) {\n        return new Point2D(this.x + x, this.y + y);\n    }\n \n    public Point2D sub(double x, double y) {\n        return add(-x, -y);\n    }\n \n    public Point2D add(Point2D another) {\n        return add(another.x, another.y);\n    }\n \n    public Point2D sub(Point2D another) {\n        return sub(another.x, another.y);\n    }\n \n    public Point2D mul(double d) {\n        return new Point2D(this.x * d, this.y * d);\n    }\n \n    public Point2D div(double d) {\n        return new Point2D(this.x / d, this.y / d);\n    }\n \n    public double dot(double x, double y) {\n        return this.x * x + this.y * y;\n    }\n \n    public double dot(Point2D another) {\n        return dot(another.x, another.y);\n    }\n \n    public double cross(double x, double y) {\n        return this.x * y - this.y * x;\n    }\n \n    public double cross(Point2D another) {\n        return cross(another.x, another.y);\n    }\n \n    public double dist(double x, double y) {\n        return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n                * (this.y - y));\n    }\n \n    public double dist(Point2D another) {\n        return dist(another.x, another.y);\n    }\n \n    public double dist_o() {\n        return dist(0, 0);\n    }\n \n    public Point2D unit() {\n        return div(dist_o());\n    }\n \n    public boolean pol(Point2D start, Point2D end) {\n        return end.sub(start).cross(this.sub(start)) < EPS;\n    }\n \n    public boolean pos(Point2D start, Point2D end) {\n        return (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n    }\n \n    public double pld(Point2D start, Point2D end) {\n        return Math.abs((end.sub(start).cross(this.sub(start)))\n                / end.sub(start).dist_o());\n    }\n \n    public double psd(Point2D start, Point2D end) {\n        if (end.sub(start).dot(this.sub(start)) < EPS) {\n            return this.dist(start);\n        } else if (start.sub(end).dot(this.sub(end)) < EPS) {\n            return this.dist(end);\n        } else {\n            return end.sub(start).cross(this.sub(start)) / end.dist(start);\n        }\n    }\n \n    public static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS)\n                && (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n    }\n \n    public static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return a1.sub(a2).cross(b1.sub(b2)) < EPS;\n    }\n \n    public static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D b = b2.sub(b1);\n        double d1 = Math.abs(b.cross(a1.sub(b1)));\n        double d2 = Math.abs(b.cross(a2.sub(b1)));\n        double t = d1 / (d1 + d2);\n        Point2D a = a2.sub(a1), v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D a = a2.sub(a1);\n        Point2D b = b2.sub(b1);\n        double t = b.cross(b1.sub(a1)) / b.cross(a);\n        Point2D v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n            double r2) {\n        double dis = p1.dist(p2);\n \n        if (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n            return new Point2D[0]; // same\n        }\n \n        if (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n            Point2D tmp = p2.sub(p1);\n            tmp = tmp.mul(r1 / tmp.dist_o());\n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis + EPS > r1 + r2) {\n            return new Point2D[0]; // out\n        }\n \n        double dis_m = Math.abs(r1 - r2);\n \n        if (dis_m + EPS > dis && dis_m - EPS < dis) {\n            Point2D tmp = null;\n            if (r1 > r2) {\n                tmp = p2.sub(p1);\n            } else {\n                tmp = p1.sub(p2);\n            }\n \n            double min = Math.min(r1, r2);\n \n            tmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n \n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis_m + EPS > dis) {\n            return new Point2D[0]; // inner\n        } else {\n            Point2D ret[] = new Point2D[2];\n \n            double theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n                    / (2 * dis * r1));\n            double a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n \n            ret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n                    * Math.sin(a + theta) + p1.y);\n            ret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n                    * Math.sin(a - theta) + p1.y);\n            return ret;\n        }\n    }\n \n    public void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n            Point2D ans[]) {\n        if (c.pld(start, end) > r + EPS)\n            return;\n        Point2D v = end.sub(start).unit();\n        double delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n                - start.dist(c) * start.dist(c) + r * r;\n        double t = -v.dot(start.sub(c));\n        double s = Math.sqrt(delta);\n        ans[0] = start.add(v.mul(t + s));\n        ans[1] = start.add(v.mul(t + s));\n    }\n \n    public Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n        Point2D v = b.sub(a).unit();\n        v = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n                (-1) * v.y, v.x);\n        return v.mul(p.pld(a, b));\n    }\n \n    public double area(Point2D a, Point2D b, Point2D c) {\n        return Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D[] points = new Point2D[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tpoints[i] = new Point2D(sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tint max = 1;\n\t\t\t\n\t\t\tfor(int fst = 0; fst < n; fst++){\n\t\t\t\tfor(int snd = 0; snd < n; snd++){\n\t\t\t\t\tPoint2D[] cross = Point2D.cross_ss(points[fst], 1, points[snd], 1);\n\t\t\t\t\t\n\t\t\t\t\tfor(Point2D cross_c : cross){\n\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\t\tif(cross_c.dist(points[i]) < 1.0 + Point2D.EPS){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tmax = Math.max(max, count);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t\t\n\t}\n}\n\nclass Point2D {\n    public double x;\n    public double y;\n \n    public static final double EPS = 1e-6;\n \n    public Point2D(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n \n    public Point2D(Point2D point) {\n        this.x = point.x;\n        this.y = point.y;\n    }\n \n    public String toString() {\n        return x + \",\" + y;\n    }\n \n    @Override\n    public boolean equals(Object o) {\n        if (o instanceof Point2D) {\n            Point2D another = (Point2D) o;\n            if (this.x - EPS < another.x && this.x + EPS > another.x\n                    && this.y - EPS < another.y && this.y + EPS > another.y) {\n                return true;\n            }\n             \n            return false;\n \n            // return this.x == another.x && this.y == another.y;\n        }\n        return false;\n    }\n \n    public Point2D add(double x, double y) {\n        return new Point2D(this.x + x, this.y + y);\n    }\n \n    public Point2D sub(double x, double y) {\n        return add(-x, -y);\n    }\n \n    public Point2D add(Point2D another) {\n        return add(another.x, another.y);\n    }\n \n    public Point2D sub(Point2D another) {\n        return sub(another.x, another.y);\n    }\n \n    public Point2D mul(double d) {\n        return new Point2D(this.x * d, this.y * d);\n    }\n \n    public Point2D div(double d) {\n        return new Point2D(this.x / d, this.y / d);\n    }\n \n    public double dot(double x, double y) {\n        return this.x * x + this.y * y;\n    }\n \n    public double dot(Point2D another) {\n        return dot(another.x, another.y);\n    }\n \n    public double cross(double x, double y) {\n        return this.x * y - this.y * x;\n    }\n \n    public double cross(Point2D another) {\n        return cross(another.x, another.y);\n    }\n \n    public double dist(double x, double y) {\n        return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n                * (this.y - y));\n    }\n \n    public double dist(Point2D another) {\n        return dist(another.x, another.y);\n    }\n \n    public double dist_o() {\n        return dist(0, 0);\n    }\n \n    public Point2D unit() {\n        return div(dist_o());\n    }\n \n    public boolean pol(Point2D start, Point2D end) {\n        return end.sub(start).cross(this.sub(start)) < EPS;\n    }\n \n    public boolean pos(Point2D start, Point2D end) {\n        return (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n    }\n \n    public double pld(Point2D start, Point2D end) {\n        return Math.abs((end.sub(start).cross(this.sub(start)))\n                / end.sub(start).dist_o());\n    }\n \n    public double psd(Point2D start, Point2D end) {\n        if (end.sub(start).dot(this.sub(start)) < EPS) {\n            return this.dist(start);\n        } else if (start.sub(end).dot(this.sub(end)) < EPS) {\n            return this.dist(end);\n        } else {\n            return end.sub(start).cross(this.sub(start)) / end.dist(start);\n        }\n    }\n \n    public static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS)\n                && (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n    }\n \n    public static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return a1.sub(a2).cross(b1.sub(b2)) < EPS;\n    }\n \n    public static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D b = b2.sub(b1);\n        double d1 = Math.abs(b.cross(a1.sub(b1)));\n        double d2 = Math.abs(b.cross(a2.sub(b1)));\n        double t = d1 / (d1 + d2);\n        Point2D a = a2.sub(a1), v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D a = a2.sub(a1);\n        Point2D b = b2.sub(b1);\n        double t = b.cross(b1.sub(a1)) / b.cross(a);\n        Point2D v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n            double r2) {\n        double dis = p1.dist(p2);\n \n        if (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n            return new Point2D[0]; // same\n        }\n \n        if (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n            Point2D tmp = p2.sub(p1);\n            tmp = tmp.mul(r1 / tmp.dist_o());\n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis + EPS > r1 + r2) {\n            return new Point2D[0]; // out\n        }\n \n        double dis_m = Math.abs(r1 - r2);\n \n        if (dis_m + EPS > dis && dis_m - EPS < dis) {\n            Point2D tmp = null;\n            if (r1 > r2) {\n                tmp = p2.sub(p1);\n            } else {\n                tmp = p1.sub(p2);\n            }\n \n            double min = Math.min(r1, r2);\n \n            tmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n \n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis_m + EPS > dis) {\n            return new Point2D[0]; // inner\n        } else {\n            Point2D ret[] = new Point2D[2];\n \n            double theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n                    / (2 * dis * r1));\n            double a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n \n            ret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n                    * Math.sin(a + theta) + p1.y);\n            ret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n                    * Math.sin(a - theta) + p1.y);\n            return ret;\n        }\n    }\n \n    public void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n            Point2D ans[]) {\n        if (c.pld(start, end) > r + EPS)\n            return;\n        Point2D v = end.sub(start).unit();\n        double delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n                - start.dist(c) * start.dist(c) + r * r;\n        double t = -v.dot(start.sub(c));\n        double s = Math.sqrt(delta);\n        ans[0] = start.add(v.mul(t + s));\n        ans[1] = start.add(v.mul(t + s));\n    }\n \n    public Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n        Point2D v = b.sub(a).unit();\n        v = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n                (-1) * v.y, v.x);\n        return v.mul(p.pld(a, b));\n    }\n \n    public double area(Point2D a, Point2D b, Point2D c) {\n        return Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.awt.geom.Point2D.Double;\nimport java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tPoint2D.Double[] p = new Point2D.Double[n];\n\t\t\tfor(int i=0;i<n;i++) p[i] = new Point2D.Double(sc.nextDouble(), sc.nextDouble());\n\t\t\t\n\t\t\tArrays.sort(p, new Comparator<Point2D.Double>(){\n\t\t\t\tpublic int compare(Point2D.Double o1, Point2D.Double o2) {\n\t\t\t\t\tif(o1.y-o2.y>0) return 1;\n\t\t\t\t\telse return -1;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tint max = 1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\tif(p[j].y-p[i].y>2.0001) break;\n\t\t\t\t\tif(p[j].distance(p[i])>2.0001) continue;\n\t\t\t\t\t\n\t\t\t\t\tdouble a, b, c, A, B, C;\n\t\t\t\t\tdouble xa = p[i].x;\n\t\t\t\t\tdouble ya = p[i].y;\n\t\t\t\t\tdouble xb = p[j].x;\n\t\t\t\t\tdouble yb = p[j].y;\n\t\t\t\t\tdouble[] x = new double[2];\n\t\t\t\t\tdouble[] y = new double[2];\n\t\t\t\t\t\n\t\t\t\t\tA = xa-xb;\n\t\t\t\t\tB = ya-yb;\n\t\t\t\t\tC = (A*xa+A*xb+B*ya+B*yb)/2;\n\t\t\t\t\tif(A==0){\n\t\t\t\t\t\tc = (C/B-ya)*(C/B-ya)+xa*xa-1;\n\t\t\t\t\t\tx[0] = xa+Math.sqrt(xa*xa-c);\n\t\t\t\t\t\tx[1] = xa-Math.sqrt(xa*xa-c);\n\t\t\t\t\t\ty[0] = C/B;\n\t\t\t\t\t\ty[1] = C/B;\n\t\t\t\t\t}else if(B==0){\n\t\t\t\t\t\tc = (C/A-xa)*(C/A-xa)+ya*ya-1;\n\t\t\t\t\t\ty[0] = ya+Math.sqrt(ya*ya-c);\n\t\t\t\t\t\ty[1] = ya-Math.sqrt(ya*ya-c);\n\t\t\t\t\t\tx[0] = C/A;\n\t\t\t\t\t\tx[1] = C/A;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ta = 1+(A*A)/(B*B);\n\t\t\t\t\t\tb = (2*A*ya*B-2*A*C-2*xa*B*B)/(B*B);\n\t\t\t\t\t\tc = (C/B-ya)*(C/B-ya)+xa*xa-1;\n\t\t\t\t\t\tx[0] = (-b+Math.sqrt(b*b-4*a*c))/(2*a);\n\t\t\t\t\t\tx[1] = (-b-Math.sqrt(b*b-4*a*c))/(2*a);\n\t\t\t\t\t\ty[0] = (C-A*x[0])/B;\n\t\t\t\t\t\ty[1] = (C-A*x[1])/B;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int d=0;d<2;d++){\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\tfor(int e=0;e<n;e++){\n\t\t\t\t\t\t\tif(p[e].y-y[d]>1.0001) break;\n\t\t\t\t\t\t\tif(p[e].distance(x[d], y[d])<1.0001) cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmax = Math.max(max, cnt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.NoSuchElementException;\nimport java.util.Collections;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tFS fs = new FS();\n\t\twhile(true) {\n\t\t\tint n = fs.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tif(n==1) {\n\t\t\t\tdouble x = fs.nextDouble();\n\t\t\t\tdouble y = fs.nextDouble();\n\t\t\t\tSystem.out.println(1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble[] px = new double[n];\n\t\t\tdouble[] py = new double[n];\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\tpx[i] = fs.nextDouble();\n\t\t\t\tpy[i] = fs.nextDouble();\n\t\t\t}\n\t\t\tArrayList<Double> csx = new ArrayList<Double>();\n\t\t\tArrayList<Double> csy = new ArrayList<Double>();\n\t\t\tfor(int i=0; i<n-1; i++) {\n\t\t\t\tfor(int j=i+1; j<n; j++) {\n\t\t\t\t\tdouble vx = px[j]-px[i];\n\t\t\t\t\tdouble vy = py[j]-py[i];\n\t\t\t\t\tdouble l = Math.sqrt(Math.pow(vx,2.0)+Math.pow(vy,2.0));\n\t\t\t\t\tif(l > 2.0) continue;\n\t\t\t\t\tdouble r = Math.sqrt(1.0 - Math.pow(l/2.0, 2.0));\n\t\t\t\t\tvx = vx/l*r;\n\t\t\t\t\tvy = vy/l*r;\n\t\t\t\t\tdouble mx = (px[i]+px[j])/2.0;\n\t\t\t\t\tdouble my = (py[i]+py[j])/2.0;\n\t\t\t\t\tcsx.add(mx-vy);\n\t\t\t\t\tcsy.add(my+vx);\n\t\t\t\t\tcsx.add(mx+vy);\n\t\t\t\t\tcsy.add(my-vx);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint maxCount = 1;\n\t\t\tfor(int i=0; i<csx.size(); i++) {\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\t\tif(Math.pow(csx.get(i)-px[j],2.0)+Math.pow(csy.get(i)-py[j],2.0) <= 1.0000000001) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxCount = Math.max(maxCount, count);\n\t\t\t}\n\t\t\tSystem.out.println(maxCount);\n\t\t}\n\t}\n\n\t// Read Class\n\tstatic class FS {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() { return hasNextByte() ? buffer[ptr++] : -1;}\n\t\tprivate boolean isPrintableChar(int c) {return 33 <= c && c <= 126;}\n\t\tprivate void skipUnprintable() {while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\n\t\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if(b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tP[] ps;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\tps = new P[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tps[i] = new P(sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\tint cnt_max = 0;\n\t\t\tint cnt = 0;\n\t\t\tfor(int i=0;i<n-1;i++) for(int j=i+1;j<n;j++) {\n\t\t\t\t\n\t\t\t\tif( sqrt(dis( ps[i], ps[j] )) < 2.0 ) {\n\t\t\t\t\tP m = new P( (ps[i].x+ps[j].x)/2, (ps[i].y+ps[j].y)/2);\n\t\t\t\t\tdouble d = sqrt(1-dis(ps[i], m ));\n\t\t\t\t\tP dp = new P((ps[i].y-ps[j].y), -(ps[i].x-ps[j].x));\n\t\t\t\t\tdp.nom();\n\t\t\t\t\tdp.mult(d);\n\t\t\t\t\tP c[] = new P[2];\n\t\t\t\t\tc[0] = m.add(dp);\n\t\t\t\t\tdp.mult(-1.0);\n\t\t\t\t\tc[1] = m.add(dp);\n\t\t\t\t\tfor(int l=0;l<2;l++) {\n\t\t\t\t\t\tcnt = 0;\n//\t\t\t\t\t\tLinkedList<Double> dist = new LinkedList<Double>();\n//\t\t\t\t\t\tLinkedList<Integer> ind = new LinkedList<Integer>();\n\t\t\t\t\t\tfor(int k=0;k<n;k++) {\n//\t\t\t\t\t\t\tdebug(dis(c[l], ps[k]));\n\t\t\t\t\t\t\tif(sqrt(dis(c[l], ps[k])) < 1.0 || k==i||k==j) {\n//\t\t\t\t\t\t\t\tdist.add(dis(c[l], ps[k]));\n//\t\t\t\t\t\t\t\tind.add(k);\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tdebug(dis( ps[i], ps[j] ), cnt_max, cnt);\n\t\t\t\t\t\tcnt_max = max(cnt_max, cnt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt_max);\n\t\t}\n\t}\n\t\n\tdouble dis( P p1, P p2 ) {\n\t\treturn (p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\t\n\tclass P {\n\t\tdouble x, y;\n\t\tP (double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tvoid nom() {\n\t\t\tdouble nom = sqrt(x*x + y*y);\n\t\t\tx /= nom;\n\t\t\ty /= nom;\n\t\t}\n\t\tP add(P p) {\n\t\t\tx += p.x;\n\t\t\ty += p.y;\n\t\t\treturn new P(x, y);\n\t\t}\n\t\tP mult(double d) {\n\t\t\tx *= d;\n\t\t\ty *= d;\n\t\t\treturn new P(x, y);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)) {\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tdouble[] x=new double[n+1];\n\t\t\t\tdouble[] y=new double[n+1];\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tx[i]=sc.nextDouble();\n\t\t\t\t\ty[i]=sc.nextDouble();\n\t\t\t\t}\n\t\t\t\tint count=0;\n\t\t\t\tint max=1;\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tfor(int j=i+1; j<n; j++) {\n\t\t\t\t\t\tdouble d=Math.sqrt((x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i]));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(d<=2.0000) {\n\t\t\t\t\t\t\tdouble cx=(x[i]+x[j])/2.0;//2点の真ん中\n\t\t\t\t\t\t\tdouble cy=(y[i]+y[j])/2.0;\n\t\t\t\t\t\t\t//System.out.printf(\"%f+%f→%f, %f+%f→%f\\n\", x[i], x[j],cx, y[i], y[j],cy);\n\t\t\t\t\t\t\tdouble vx=(y[j]-y[i])/d;//法線ベクトルの単位ベクトル\n\t\t\t\t\t\t\tdouble vy=-((x[j]-x[i])/d);\n\t\t\t\t\t\t\tdouble e=Math.sqrt(1.0-d*d/4.0);//交点cx,cyから中心までの距離\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tdouble px=cx+e*vx;//中心座標(円1) \n\t\t\t\t\t\t\tdouble py=cy+e*vy;\n\t\t\t\t\t\t\tfor(int k=0; k<n; k++) {\n\t\t\t\t\t\t\t\tif(k==i || k==j || Math.sqrt((x[k]-px)*(x[k]-px)+(y[k]-py)*(y[k]-py))<=1.0000) {\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmax=Math.max(count, max);\n\t\t\t\t\t\t\tcount=0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tpx=cx-e*vx;//(円2)\n\t\t\t\t\t\t\tpy=cy-e*vy;\n\t\t\t\t\t\t\tfor(int k=0; k<n; k++) {\n\t\t\t\t\t\t\t\tif(k==i || k==j || Math.sqrt((x[k]-px)*(x[k]-px)+(y[k]-py)*(y[k]-py))<=1.0000) {\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmax=Math.max(count, max);\n\t\t\t\t\t\t\tcount=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(max);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int n;\n\tstatic double[] px, py;\n\t\n\tstatic int min;\n\t\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tScanner sca = new Scanner(System.in);\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tn = sca.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\t\n\t\t\tpx = new double[n];\n\t\t\tpy = new double[n];\n\t\t\t\n\t\t\tint i, j;\n\t\t\tfor(i = 0;i < n;i++)\n\t\t\t{\n\t\t\t\tpx[i] = sca.nextDouble();\n\t\t\t\tpy[i] = sca.nextDouble();\n\t\t\t}\n\t\t\t\n\t\t\tmin = 1;\n\t\t\tfor(i = 0;i < n;i++)\n\t\t\t{\n\t\t\t\tfor(j = i + 1;j < n;j++)\n\t\t\t\t{\n\t\t\t\t\tdouble dx = px[i] - px[j];\n\t\t\t\t\tdouble dy = py[i] - py[j];\n\t\t\t\t\tdouble dd = dx * dx + dy * dy;\n\t\t\t\t\t\n\t\t\t\t\tif(dd > 4) continue;\n\t\t\t\t\t\n\t\t\t\t\t// 中心を求める\n\t\t\t\t\tdouble d = Math.sqrt(dd);\n\t\t\t\t\tdouble xm = (px[i] + px[j]) / 2;\n\t\t\t\t\tdouble ym = (py[i] + py[j]) / 2;\n\t\t\t\t\tdouble l = d / 2;\n\t\t\t\t\tdouble e = Math.sqrt(1 - l * l);\n\t\t\t\t\t\n\t\t\t\t\tdouble center1x = xm + dy / d * e;\n\t\t\t\t\tdouble center1y = ym - dx / d * e;\n\t\t\t\t\t\n\t\t\t\t\tdouble center2x = xm - dy / d * e;\n\t\t\t\t\tdouble center2y = ym + dx / d * e;\n\t\t\t\t\t\n\t\t\t\t\t// 数える\n\t\t\t\t\tint count = 0, k;\n\t\t\t\t\tfor(k = 0;k < n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdx = center1x - px[k];\n\t\t\t\t\t\tdy = center1y - py[k];\n\t\t\t\t\t\tdd = dx * dx + dy * dy;\n\t\t\t\t\t\tif(dd < 1 + 1e-10) count++;\n\t\t\t\t\t}\n\t\t\t\t\tif(min < count) min = count;\n\t\t\t\t\t\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tfor(k = 0;k < n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdx = center2x - px[k];\n\t\t\t\t\t\tdy = center2y - py[k];\n\t\t\t\t\t\tdd = dx * dx + dy * dy;\n\t\t\t\t\t\tif(dd < 1 + 1e-10) count++;\n\t\t\t\t\t}\n\t\t\t\t\tif(min < count) min = count;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.awt.geom.*;\nimport static java.util.Arrays.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true){\n\t\t\tint n = Integer.parseInt(stdIn.next());\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdouble[] x = new double[n];\n\t\t\tdouble[] y = new double[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tx[i] = Double.parseDouble(stdIn.next());\n\t\t\t\ty[i] = Double.parseDouble(stdIn.next());\n\t\t\t}\n\t\t\tint[] sign = {+1,-1};\n\t\t\tint counter = 1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\tdouble l = Math.sqrt(Math.pow(x[i]-x[j],2)+Math.pow(y[i]-y[j],2));\n\t\t\t\t\tif(l>4.0+Math.pow(10,-6)){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble mx = (x[i]+x[j])/2.0;\n\t\t\t\t\tdouble my = (y[i]+y[j])/2.0;\n\t\t\t\t\tdouble vx = (x[j]-x[i])/2.0;\n\t\t\t\t\tdouble vy = (y[j]-y[i])/2.0;\n\t\t\t\t\tdouble e = Math.sqrt(1.0-l*l/4.0);\n\t\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\t\tdouble px = mx + sign[k]*e*vy;\n\t\t\t\t\t\tdouble py = my + sign[k]*e*vx;\n\n\t\t\t\t\t\tint cnt = 2;\n\t\t\t\t\t\tfor(int s=0;s<n;s++){\n\t\t\t\t\t\t\tif(s==i||s==j){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((px-x[s])*(px-x[s])+(py-y[s])*(py-y[s])<1.0+Math.pow(10,-6)){\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(counter<cnt){\n\t\t\t\t\t\t\tcounter = cnt;\n\t\t\t\t\t\t}\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tout.println(counter);\n\t\t\tout.flush();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Point2D> points = new LinkedList<Point2D>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tpoints.add(new Point2D(sc.nextDouble(), sc.nextDouble()));\n\t\t\t}\n\t\t\t\n\t\t\tint max = 1;\n\t\t\tfor(Point2D src : points){\n\t\t\t\tint count = 1;\n\t\t\t\t\n\t\t\t\tfor(Point2D dest : points){\n\t\t\t\t\tPoint2D[] circles = Point2D.cross_ss(src, 1.0, dest, 1.0);\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(Arrays.toString(circles));\n\t\t\t\t\t\n\t\t\t\t\tfor(Point2D circle : circles){\n\t\t\t\t\t\tint inner = 0;\n\t\t\t\t\t\tfor(Point2D elem : points){\n\t\t\t\t\t\t\tif(circle.dist(elem) < 1.0){\n\t\t\t\t\t\t\t\tinner++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tcount = Math.max(count, inner);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t\t\n\t}\n\n}\n\nclass Point2D {\n\tpublic double x;\n\tpublic double y;\n\n\tpublic static final double EPS = 1e-9;\n\n\tpublic Point2D(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tpublic Point2D(Point2D point) {\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t}\n\n\tpublic String toString() {\n\t\treturn x + \",\" + y;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (o instanceof Point2D) {\n\t\t\tPoint2D another = (Point2D) o;\n\t\t\tif (this.x - EPS < another.x && this.x + EPS > another.x\n\t\t\t\t\t&& this.y - EPS < another.y && this.y + EPS > another.y) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\n\t\t\t// return this.x == another.x && this.y == another.y;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic Point2D add(double x, double y) {\n\t\treturn new Point2D(this.x + x, this.y + y);\n\t}\n\n\tpublic Point2D sub(double x, double y) {\n\t\treturn add(-x, -y);\n\t}\n\n\tpublic Point2D add(Point2D another) {\n\t\treturn add(another.x, another.y);\n\t}\n\n\tpublic Point2D sub(Point2D another) {\n\t\treturn sub(another.x, another.y);\n\t}\n\n\tpublic Point2D mul(double d) {\n\t\treturn new Point2D(this.x * d, this.y * d);\n\t}\n\n\tpublic Point2D div(double d) {\n\t\treturn new Point2D(this.x / d, this.y / d);\n\t}\n\n\tpublic double dot(double x, double y) {\n\t\treturn this.x * x + this.y * y;\n\t}\n\n\tpublic double dot(Point2D another) {\n\t\treturn dot(another.x, another.y);\n\t}\n\n\tpublic double cross(double x, double y) {\n\t\treturn this.x * y - this.y * x;\n\t}\n\n\tpublic double cross(Point2D another) {\n\t\treturn cross(another.x, another.y);\n\t}\n\n\tpublic double dist(double x, double y) {\n\t\treturn Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n\t\t\t\t* (this.y - y));\n\t}\n\n\tpublic double dist(Point2D another) {\n\t\treturn dist(another.x, another.y);\n\t}\n\n\tpublic double dist_o() {\n\t\treturn dist(0, 0);\n\t}\n\n\tpublic Point2D unit() {\n\t\treturn div(dist_o());\n\t}\n\n\tpublic boolean pol(Point2D start, Point2D end) {\n\t\treturn end.sub(start).cross(this.sub(start)) < EPS;\n\t}\n\n\tpublic boolean pos(Point2D start, Point2D end) {\n\t\treturn (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n\t}\n\n\tpublic double pld(Point2D start, Point2D end) {\n\t\treturn Math.abs((end.sub(start).cross(this.sub(start)))\n\t\t\t\t/ end.sub(start).dist_o());\n\t}\n\n\tpublic double psd(Point2D start, Point2D end) {\n\t\tif (end.sub(start).dot(this.sub(start)) < EPS) {\n\t\t\treturn this.dist(start);\n\t\t} else if (start.sub(end).dot(this.sub(end)) < EPS) {\n\t\t\treturn this.dist(end);\n\t\t} else {\n\t\t\treturn end.sub(start).cross(this.sub(start)) / end.dist(start);\n\t\t}\n\t}\n\n\tpublic static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS)\n\t\t\t\t&& (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n\t}\n\n\tpublic static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn a1.sub(a2).cross(b1.sub(b2)) < EPS;\n\t}\n\n\tpublic static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble d1 = Math.abs(b.cross(a1.sub(b1)));\n\t\tdouble d2 = Math.abs(b.cross(a2.sub(b1)));\n\t\tdouble t = d1 / (d1 + d2);\n\t\tPoint2D a = a2.sub(a1), v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D a = a2.sub(a1);\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble t = b.cross(b1.sub(a1)) / b.cross(a);\n\t\tPoint2D v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n\t\t\tdouble r2) {\n\t\tdouble dis = p1.dist(p2);\n\n\t\tif (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n\t\t\treturn new Point2D[0]; // same\n\t\t}\n\n\t\tif (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n\t\t\tPoint2D tmp = p2.sub(p1);\n\t\t\ttmp = tmp.mul(r1 / tmp.dist_o());\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis + EPS > r1 + r2) {\n\t\t\treturn new Point2D[0]; // out\n\t\t}\n\n\t\tdouble dis_m = Math.abs(r1 - r2);\n\n\t\tif (dis_m + EPS > dis && dis_m - EPS < dis) {\n\t\t\tPoint2D tmp = null;\n\t\t\tif (r1 > r2) {\n\t\t\t\ttmp = p2.sub(p1);\n\t\t\t} else {\n\t\t\t\ttmp = p1.sub(p2);\n\t\t\t}\n\n\t\t\tdouble min = Math.min(r1, r2);\n\n\t\t\ttmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis_m + EPS > dis) {\n\t\t\treturn new Point2D[0]; // inner\n\t\t} else {\n\t\t\tPoint2D ret[] = new Point2D[2];\n\n\t\t\tdouble theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n\t\t\t\t\t/ (2 * dis * r1));\n\t\t\tdouble a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n\n\t\t\tret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a + theta) + p1.y);\n\t\t\tret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a - theta) + p1.y);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n\t\t\tPoint2D ans[]) {\n\t\tif (c.pld(start, end) > r + EPS)\n\t\t\treturn;\n\t\tPoint2D v = end.sub(start).unit();\n\t\tdouble delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n\t\t\t\t- start.dist(c) * start.dist(c) + r * r;\n\t\tdouble t = -v.dot(start.sub(c));\n\t\tdouble s = Math.sqrt(delta);\n\t\tans[0] = start.add(v.mul(t + s));\n\t\tans[1] = start.add(v.mul(t + s));\n\t}\n\n\tpublic Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n\t\tPoint2D v = b.sub(a).unit();\n\t\tv = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n\t\t\t\t(-1) * v.y, v.x);\n\t\treturn v.mul(p.pld(a, b));\n\t}\n\n\tpublic double area(Point2D a, Point2D b, Point2D c) {\n\t\treturn Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D[] points = new Point2D[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tpoints[i] = new Point2D(sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tint max = 0;\n\t\t\t\n\t\t\tfor(int fst = 0; fst < n; fst++){\n\t\t\t\tfor(int snd = fst + 1; snd < n; snd++){\n\t\t\t\t\tPoint2D[] cross = Point2D.cross_ss(points[fst], 1, points[snd], 1);\n\t\t\t\t\t\n\t\t\t\t\tif(cross.length < 2){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tPoint2D center = new Point2D((cross[0].x + cross[1].x) / 2, (cross[0].y + cross[1].y) / 2);\n\t\t\t\t\t\n\t\t\t\t\tPoint2D diff = center.sub(cross[0]).unit();\n\t\t\t\t\t\n\t\t\t\t\tdouble length = Math.cos(Math.asin(cross[0].dist(center)));\n\t\t\t\t\t\n\t\t\t\t\tPoint2D cir1 = center.add(cross[0].sub(center).mul(length));\n\t\t\t\t\tPoint2D cir2 = center.add(cross[1].sub(center).mul(length));\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(cir1.dist(points[fst]) + \" \" + cir1.dist(points[snd]));\n\t\t\t\t\t//System.out.println(cir2.dist(points[fst]) + \" \" + cir2.dist(points[snd]));\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(cross[0] + \" \" + cross[1] + \" \" + center + \" \" + diff + \" \" + cir1 + \" \" + cir2);\n\t\t\t\t\t\n\t\t\t\t\tint count_1 = 0, count_2 = 0;\n\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\tif(cir1.dist(points[i]) <= 1.0 + Point2D.EPS){\n\t\t\t\t\t\t\tcount_1++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(cir2.dist(points[i]) <= 1.0 + Point2D.EPS){\n\t\t\t\t\t\t\tcount_2++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmax = Math.max(max, count_1);\n\t\t\t\t\tmax = Math.max(max, count_2);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t\t\n\t}\n}\n\nclass Point2D {\n    public double x;\n    public double y;\n \n    public static final double EPS = 1e-4;\n \n    public Point2D(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n \n    public Point2D(Point2D point) {\n        this.x = point.x;\n        this.y = point.y;\n    }\n \n    public String toString() {\n        return x + \",\" + y;\n    }\n \n    @Override\n    public boolean equals(Object o) {\n        if (o instanceof Point2D) {\n            Point2D another = (Point2D) o;\n            if (this.x - EPS < another.x && this.x + EPS > another.x\n                    && this.y - EPS < another.y && this.y + EPS > another.y) {\n                return true;\n            }\n             \n            return false;\n \n            // return this.x == another.x && this.y == another.y;\n        }\n        return false;\n    }\n \n    public Point2D add(double x, double y) {\n        return new Point2D(this.x + x, this.y + y);\n    }\n \n    public Point2D sub(double x, double y) {\n        return add(-x, -y);\n    }\n \n    public Point2D add(Point2D another) {\n        return add(another.x, another.y);\n    }\n \n    public Point2D sub(Point2D another) {\n        return sub(another.x, another.y);\n    }\n \n    public Point2D mul(double d) {\n        return new Point2D(this.x * d, this.y * d);\n    }\n \n    public Point2D div(double d) {\n        return new Point2D(this.x / d, this.y / d);\n    }\n \n    public double dot(double x, double y) {\n        return this.x * x + this.y * y;\n    }\n \n    public double dot(Point2D another) {\n        return dot(another.x, another.y);\n    }\n \n    public double cross(double x, double y) {\n        return this.x * y - this.y * x;\n    }\n \n    public double cross(Point2D another) {\n        return cross(another.x, another.y);\n    }\n \n    public double dist(double x, double y) {\n        return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n                * (this.y - y));\n    }\n \n    public double dist(Point2D another) {\n        return dist(another.x, another.y);\n    }\n \n    public double dist_o() {\n        return dist(0, 0);\n    }\n \n    public Point2D unit() {\n        return div(dist_o());\n    }\n \n    public boolean pol(Point2D start, Point2D end) {\n        return end.sub(start).cross(this.sub(start)) < EPS;\n    }\n \n    public boolean pos(Point2D start, Point2D end) {\n        return (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n    }\n \n    public double pld(Point2D start, Point2D end) {\n        return Math.abs((end.sub(start).cross(this.sub(start)))\n                / end.sub(start).dist_o());\n    }\n \n    public double psd(Point2D start, Point2D end) {\n        if (end.sub(start).dot(this.sub(start)) < EPS) {\n            return this.dist(start);\n        } else if (start.sub(end).dot(this.sub(end)) < EPS) {\n            return this.dist(end);\n        } else {\n            return end.sub(start).cross(this.sub(start)) / end.dist(start);\n        }\n    }\n \n    public static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS)\n                && (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n    }\n \n    public static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return a1.sub(a2).cross(b1.sub(b2)) < EPS;\n    }\n \n    public static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D b = b2.sub(b1);\n        double d1 = Math.abs(b.cross(a1.sub(b1)));\n        double d2 = Math.abs(b.cross(a2.sub(b1)));\n        double t = d1 / (d1 + d2);\n        Point2D a = a2.sub(a1), v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D a = a2.sub(a1);\n        Point2D b = b2.sub(b1);\n        double t = b.cross(b1.sub(a1)) / b.cross(a);\n        Point2D v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n            double r2) {\n        double dis = p1.dist(p2);\n \n        if (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n            return new Point2D[0]; // same\n        }\n \n        if (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n            Point2D tmp = p2.sub(p1);\n            tmp = tmp.mul(r1 / tmp.dist_o());\n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis + EPS > r1 + r2) {\n            return new Point2D[0]; // out\n        }\n \n        double dis_m = Math.abs(r1 - r2);\n \n        if (dis_m + EPS > dis && dis_m - EPS < dis) {\n            Point2D tmp = null;\n            if (r1 > r2) {\n                tmp = p2.sub(p1);\n            } else {\n                tmp = p1.sub(p2);\n            }\n \n            double min = Math.min(r1, r2);\n \n            tmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n \n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis_m + EPS > dis) {\n            return new Point2D[0]; // inner\n        } else {\n            Point2D ret[] = new Point2D[2];\n \n            double theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n                    / (2 * dis * r1));\n            double a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n \n            ret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n                    * Math.sin(a + theta) + p1.y);\n            ret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n                    * Math.sin(a - theta) + p1.y);\n            return ret;\n        }\n    }\n \n    public void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n            Point2D ans[]) {\n        if (c.pld(start, end) > r + EPS)\n            return;\n        Point2D v = end.sub(start).unit();\n        double delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n                - start.dist(c) * start.dist(c) + r * r;\n        double t = -v.dot(start.sub(c));\n        double s = Math.sqrt(delta);\n        ans[0] = start.add(v.mul(t + s));\n        ans[1] = start.add(v.mul(t + s));\n    }\n \n    public Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n        Point2D v = b.sub(a).unit();\n        v = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n                (-1) * v.y, v.x);\n        return v.mul(p.pld(a, b));\n    }\n \n    public double area(Point2D a, Point2D b, Point2D c) {\n        return Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tdouble EPS = 1e-12;\n\tdouble INF = 1e12;\n\n\tclass Point {\n\t\tdouble x, y;\n\n\t\tPoint(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tclass Segment {\n\t\tPoint a, b;\n\n\t\tSegment(Point a, Point b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t}\n\n\tclass Line {\n\t\tPoint a, b;\n\n\t\tLine(Point a, Point b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t}\n\n\tclass Circle {\n\t\tPoint c;\n\t\tdouble r;\n\n\t\tCircle(Point c, double r) {\n\t\t\tthis.c = c;\n\t\t\tthis.r = r;\n\t\t}\n\t}\n\n\tdouble norm(Point a) {\n\t\treturn Math.sqrt(a.x * a.x + a.y * a.y);\n\t}\n\n\tPoint sub(Point a, Point b) {\n\t\treturn new Point(a.x - b.x, a.y - b.y);\n\t}\n\n\tdouble dot(Point a, Point b) {\n\t\treturn a.x * b.x + a.y * b.y;\n\t}\n\n\tdouble cross(Point a, Point b) {\n\t\treturn a.x * b.y - a.y * b.x;\n\t}\n\n\tdouble abs(double a) {\n\t\treturn 0 < a ? a : -a;\n\t}\n\n\t// 交点の個数が0または無限の時はreturn null;\n\tPoint[] crossPoint(Circle c1, Circle c2) {\n\t\tdouble d = norm(sub(c1.c, c2.c));\n\t\tif (d < EPS && abs(c1.r - c2.r) < EPS) {\n\t\t\treturn null;\n\t\t} else if (c1.r + c2.r < d - EPS || d + EPS < abs(c1.r - c2.r)) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tdouble a = (c1.r * c1.r - c2.r * c2.r + d * d) / (2 * d);\n\t\t\tdouble h = Math.sqrt(Math.max(c1.r * c1.r - a * a, 0));\n\t\t\tPoint p1 = new Point(c1.c.x + a / d * (c2.c.x - c1.c.x), c1.c.y + a / d * (c2.c.y - c1.c.y));\n\t\t\tPoint p2 = new Point(h / d * (c2.c.x - c1.c.x), h / d * (c2.c.y - c1.c.y));\n\t\t\tif (norm(p2) < EPS) {\n\t\t\t\treturn new Point[] { p1 };\n\t\t\t} else {\n\t\t\t\treturn new Point[] { new Point(p1.x - p2.y, p1.y + p2.x), new Point(p1.x + p2.y, p1.y - p2.x) };\n\t\t\t}\n\t\t}\n\t}\n\n\tboolean isCover(Circle c, Point p) {\n\t\treturn norm(sub(c.c, p)) <= c.r + EPS;\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tPoint[] p = new Point[n];\n\t\t\tCircle[] c = new Circle[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tp[i] = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\t\tc[i] = new Circle(p[i], 1.);\n\t\t\t}\n\n\t\t\tint max = 1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (2 <= norm(sub(c[i].c, c[j].c))) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tPoint[] cp = crossPoint(c[i], c[j]);\n\t\t\t\t\tif (cp == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = 0; k < cp.length; k++) {\n\t\t\t\t\t\tCircle nc = new Circle(cp[k], 1.);\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\t\tif (isCover(nc, p[l])) {\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmax = Math.max(max, cnt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tint n=in.nextInt();\n\t\t\tif(n==0)\n\t\t\t\treturn;\n\t\t\tPoint p[]=new Point[n];\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tp[i]=new Point(in.nextDouble(), in.nextDouble());\n\t\t\tint max=1;\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=i+1;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tdouble d=Point.point_distance(p[i],p[j]);\n\t\t\t\t\tif(d>2)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t//中点\n\t\t\t\t\tdouble mx=(p[i].x+p[j].x)/2;\n\t\t\t\t\tdouble my=(p[i].y+p[j].y)/2;\n\t\t\t\t\t//i->jの単位ベクトル\n\t\t\t\t\tdouble vx=(p[j].x-p[i].x)/d;\n\t\t\t\t\tdouble vy=(p[j].y-p[i].y)/d;\n\t\t\t\t\t//m->cの距離\n\t\t\t\t\tdouble e=Math.sqrt(1-d*d/4);\n\t\t\t\t\tPoint pc=new Point(mx+e*vy,my-e*vx);\n\t\t\t\t\tint cnt=2;\n\t\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(k!=i&&k!=j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdouble tmp_dis=Point.point_distance(pc,p[k]);\n\t\t\t\t\t\t\tif(tmp_dis<=1)\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpc=new Point(mx-e*vy,my+e*vx);\n\t\t\t\t\tcnt=2;\n\t\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(k!=i&&k!=j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdouble tmp_dis=Point.point_distance(pc,p[k]);\n\t\t\t\t\t\t\tif(tmp_dis<=1)\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmax=Math.max(max,cnt);\n\t\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tstatic public void debug(Object... o)\n\t{\n\t\tSystem.err.println(Arrays.deepToString(o));\n\t}\n}\n\nclass Point\n{\n\tdouble x;\n\tdouble y;\n\tPoint(double x,double y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n\n\t//線分p1-p2と線分p3-p4が交差しているかを判定 true->交差(=含みで接する含む) false->交差せず\n\tstatic boolean lineCross(Point p1,Point p2,Point p3,Point p4)\n\t{\n\t\tdouble a=(p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x);\n\t\tdouble b=(p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x);\n\t\tdouble c=(p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x);\n\t\tdouble d=(p3.x-p4.x)*(p2.y-p3.y)+(p3.y-p4.y)*(p3.x-p2.x);\n\t\treturn a*b<=0 && c*d<=0;\n\t}\n\n\t//クラスメソッド\n\tstatic double point_distance(Point p1,Point p2)\n\t{\n\t\treturn Math.hypot(p1.x-p2.x, p1.y-p2.y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tnew Main().calc();\n\t}\n\n\tdouble[] x;\n\tdouble[] y;\n\tint n;\n\tboolean[][] memo;\n\tvoid calc(){\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = cin.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tx = new double[n];\n\t\t\ty = new double[n];\n\t\t\tmemo = new boolean[n][n];\n\t\t\tint i,j,k;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tx[i] = cin.nextDouble();\n\t\t\t\ty[i] = cin.nextDouble();\n\t\t\t}\n\t\t\tint ret = 0;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tret = Math.max(ret, getmax(new int[]{i}));\n\t\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\t\tif(memo[i][j]) continue;\n\t\t\t\t\tif(Math.hypot(x[i]-x[j], y[i]-y[j]) > 2) continue;\n\t\t\t\t\tret = Math.max(ret, getmax(new int[]{i,j}));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ret);\n\t\t}\n\t}\n\n\tint getmax(int[] nums){\n\t\tdouble nx = 0;\n\t\tdouble ny = 0;\n\t\tfor(int a : nums){\n\t\t\tnx += x[a]/nums.length;\n\t\t\tny += y[a]/nums.length;\n\t\t}\n\t\tdouble move = 0.7;\n\t\tfor(int i=0;i<20;i++){\n\t\t\tdouble maxdist = 0;\n\t\t\tint num = 0;\n\t\t\tfor(int a :nums){\n\t\t\t\tdouble dist = Math.hypot(nx-x[a], ny-y[a]);\n\t\t\t\tif(maxdist<dist){\n\t\t\t\t\tmaxdist = dist;\n\t\t\t\t\tnum = a;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(maxdist<1) break;\n\t\t\tnx += (x[num]-nx)*move;\n\t\t\tny += (y[num]-ny)*move;\n\t\t\tmove *= 0.7;\n\t\t}\n\t\treturn getnum(nx,ny);\n\t}\n\n\tint getnum(double nx, double ny){\n\t\tint ret = 0;\n\t\tList<Integer> l = new LinkedList<Integer>();\n\t\tfor(int i = 0;i <n;i++){\n\t\t\tif(Math.hypot(nx-x[i], ny-y[i])<=1){\n\t\t\t\tfor(int a : l) memo[a][i] = true;\n\t\t\t\tl.add(i);\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass point {\n\t\tdouble x;\n\t\tdouble y;\n\n\t\tpoint(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpoint[] getP(point tar) {\n\t\t\tdouble nx = tar.x + x;\n\t\t\tdouble ny = tar.y + y;\n\t\t\tnx /= 2;\n\t\t\tny /= 2;\n\t\t\tpoint np = new point(nx, ny);\n\t\t\tdouble v = np.d2(this);\n\t\t\tif (v > 1) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tdouble dx = tar.y - y;\n\t\t\tdouble dy = x - tar.x;\n\n\t\t\tdouble len = dx * dx + dy * dy;\n\t\t\tlen = Math.sqrt(len);\n\n\t\t\tdx /= len;\n\t\t\tdy /= len;\n\n\t\t\tpoint[] ret = new point[2];\n\n\t\t\tret[0] = new point(np.x + dx * Math.sqrt(1 - v), np.y + dy\n\t\t\t\t\t* Math.sqrt(1 - v));\n\t\t\tret[1] = new point(np.x - dx * Math.sqrt(1 - v), np.y - dy\n\t\t\t\t\t* Math.sqrt(1 - v));\n\t\t\treturn ret;\n\t\t}\n\n\t\tdouble d2(point tar) {\n\t\t\treturn (tar.x - x) * (tar.x - x) + (tar.y - y) * (tar.y - y);\n\t\t}\n\t\tboolean near(point tar){\n\t\t\treturn d2(tar) < 1;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpoint p[] = new point[n];\n\n\t\t\t\n\t\t\tfor(int i= 0; i <n ;i++){\n\t\t\t\tp[i] = new point(sc.nextDouble(),sc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tint ans = 1;\n\t\t\tfor(int i = 0; i < n; i ++){\n\t\t\t\tfor(int j =i+1 ; j < n ; j++){\n\t\t\t\t\tpoint np[] = p[i].getP(p[j]);\n\t\t\t\t\tif(np == null){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor(point c : np){\n\t\t\t\t\t\tint a = 2;\n\t\t\t\t\t\tfor(int z = 0; z < n ; z++){\n\t\t\t\t\t\t\tif(z == i || z==j){\n//\t\t\t\t\t\t\t\tSystem.out.println(c.d2(p[z]));\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(c.near(p[z])){\n\t\t\t\t\t\t\t\ta++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans = Math.max(a,ans);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\tstatic double[] X, Y;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tX = new double[N];\n\t\t\tY = new double[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tX[i] = sc.nextDouble();\n\t\t\t\tY[i] = sc.nextDouble();\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tstatic int solve() {\n\t\tif (N == 1) return 1;\n\t\tif (N == 2) {\n\t\t\treturn dist(0, 1) < 2 ? 2 : 1;\n\t\t}\n\t\tint ans = 1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tdouble d = dist(i, j);\n\t\t\t\tif (d > 2) continue;\n\t\t\t\tdouble dx = (X[j] - X[i]) / 2;\n\t\t\t\tdouble dy = (Y[j] - Y[i]) / 2;\n\t\t\t\tdouble len = sq(dx, dy);\n\t\t\t\tdouble ex = dx / len;\n\t\t\t\tdouble ey = dx / len;\n\t\t\t\tdouble lenC = Math.sqrt(1 - len);\n\t\t\t\t{\n\t\t\t\t\tdouble cx = X[i] + dx - ey * lenC;\n\t\t\t\t\tdouble cy = Y[i] + dy + ex * lenC;\n\t\t\t\t\tans = Math.max(ans, count(cx, cy));\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tdouble cx = X[i] + dx + ey * lenC;\n\t\t\t\t\tdouble cy = Y[i] + dy - ex * lenC;\n\t\t\t\t\tans = Math.max(ans, count(cx, cy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tstatic int count(double cx, double cy) {\n\t\tint c = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdouble d = sq(X[i] - cx, Y[i] - cy);\n\t\t\tif (d <= 1 + 1e-8) ++c;\n\t\t}\n\t\treturn c;\n\t}\n\n\tstatic double dist(int i, int j) {\n\t\treturn sq(X[i] - X[j], Y[i] - Y[j]);\n\t}\n\n\tstatic double sq(double x, double y) {\n\t\treturn Math.sqrt(x * x + y * y);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Point2D> points = new LinkedList<Point2D>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tpoints.add(new Point2D(sc.nextDouble(), sc.nextDouble()));\n\t\t\t}\n\t\t\t\n\t\t\tint max = 0;\n\t\t\tfor(Point2D src : points){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(Point2D dest : points){\n\t\t\t\t\tPoint2D[] circles = Point2D.cross_ss(src, 1.0, dest, 1.0);\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(Arrays.toString(circles));\n\t\t\t\t\t\n\t\t\t\t\tfor(Point2D circle : circles){\n\t\t\t\t\t\tint inner = 0;\n\t\t\t\t\t\tfor(Point2D elem : points){\n\t\t\t\t\t\t\tif(circle.dist(elem) < 1.0 + Point2D.EPS){\n\t\t\t\t\t\t\t\tinner++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tcount = Math.max(count, inner);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t\t\n\t}\n\n}\n\nclass Point2D {\n\tpublic double x;\n\tpublic double y;\n\n\tpublic static final double EPS = 1e-9;\n\n\tpublic Point2D(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tpublic Point2D(Point2D point) {\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t}\n\n\tpublic String toString() {\n\t\treturn x + \",\" + y;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (o instanceof Point2D) {\n\t\t\tPoint2D another = (Point2D) o;\n\t\t\tif (this.x - EPS < another.x && this.x + EPS > another.x\n\t\t\t\t\t&& this.y - EPS < another.y && this.y + EPS > another.y) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\n\t\t\t// return this.x == another.x && this.y == another.y;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic Point2D add(double x, double y) {\n\t\treturn new Point2D(this.x + x, this.y + y);\n\t}\n\n\tpublic Point2D sub(double x, double y) {\n\t\treturn add(-x, -y);\n\t}\n\n\tpublic Point2D add(Point2D another) {\n\t\treturn add(another.x, another.y);\n\t}\n\n\tpublic Point2D sub(Point2D another) {\n\t\treturn sub(another.x, another.y);\n\t}\n\n\tpublic Point2D mul(double d) {\n\t\treturn new Point2D(this.x * d, this.y * d);\n\t}\n\n\tpublic Point2D div(double d) {\n\t\treturn new Point2D(this.x / d, this.y / d);\n\t}\n\n\tpublic double dot(double x, double y) {\n\t\treturn this.x * x + this.y * y;\n\t}\n\n\tpublic double dot(Point2D another) {\n\t\treturn dot(another.x, another.y);\n\t}\n\n\tpublic double cross(double x, double y) {\n\t\treturn this.x * y - this.y * x;\n\t}\n\n\tpublic double cross(Point2D another) {\n\t\treturn cross(another.x, another.y);\n\t}\n\n\tpublic double dist(double x, double y) {\n\t\treturn Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n\t\t\t\t* (this.y - y));\n\t}\n\n\tpublic double dist(Point2D another) {\n\t\treturn dist(another.x, another.y);\n\t}\n\n\tpublic double dist_o() {\n\t\treturn dist(0, 0);\n\t}\n\n\tpublic Point2D unit() {\n\t\treturn div(dist_o());\n\t}\n\n\tpublic boolean pol(Point2D start, Point2D end) {\n\t\treturn end.sub(start).cross(this.sub(start)) < EPS;\n\t}\n\n\tpublic boolean pos(Point2D start, Point2D end) {\n\t\treturn (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n\t}\n\n\tpublic double pld(Point2D start, Point2D end) {\n\t\treturn Math.abs((end.sub(start).cross(this.sub(start)))\n\t\t\t\t/ end.sub(start).dist_o());\n\t}\n\n\tpublic double psd(Point2D start, Point2D end) {\n\t\tif (end.sub(start).dot(this.sub(start)) < EPS) {\n\t\t\treturn this.dist(start);\n\t\t} else if (start.sub(end).dot(this.sub(end)) < EPS) {\n\t\t\treturn this.dist(end);\n\t\t} else {\n\t\t\treturn end.sub(start).cross(this.sub(start)) / end.dist(start);\n\t\t}\n\t}\n\n\tpublic static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS)\n\t\t\t\t&& (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n\t}\n\n\tpublic static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn a1.sub(a2).cross(b1.sub(b2)) < EPS;\n\t}\n\n\tpublic static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble d1 = Math.abs(b.cross(a1.sub(b1)));\n\t\tdouble d2 = Math.abs(b.cross(a2.sub(b1)));\n\t\tdouble t = d1 / (d1 + d2);\n\t\tPoint2D a = a2.sub(a1), v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D a = a2.sub(a1);\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble t = b.cross(b1.sub(a1)) / b.cross(a);\n\t\tPoint2D v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n\t\t\tdouble r2) {\n\t\tdouble dis = p1.dist(p2);\n\n\t\tif (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n\t\t\treturn new Point2D[0]; // same\n\t\t}\n\n\t\tif (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n\t\t\tPoint2D tmp = p2.sub(p1);\n\t\t\ttmp = tmp.mul(r1 / tmp.dist_o());\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis + EPS > r1 + r2) {\n\t\t\treturn new Point2D[0]; // out\n\t\t}\n\n\t\tdouble dis_m = Math.abs(r1 - r2);\n\n\t\tif (dis_m + EPS > dis && dis_m - EPS < dis) {\n\t\t\tPoint2D tmp = null;\n\t\t\tif (r1 > r2) {\n\t\t\t\ttmp = p2.sub(p1);\n\t\t\t} else {\n\t\t\t\ttmp = p1.sub(p2);\n\t\t\t}\n\n\t\t\tdouble min = Math.min(r1, r2);\n\n\t\t\ttmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis_m + EPS > dis) {\n\t\t\treturn new Point2D[0]; // inner\n\t\t} else {\n\t\t\tPoint2D ret[] = new Point2D[2];\n\n\t\t\tdouble theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n\t\t\t\t\t/ (2 * dis * r1));\n\t\t\tdouble a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n\n\t\t\tret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a + theta) + p1.y);\n\t\t\tret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a - theta) + p1.y);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n\t\t\tPoint2D ans[]) {\n\t\tif (c.pld(start, end) > r + EPS)\n\t\t\treturn;\n\t\tPoint2D v = end.sub(start).unit();\n\t\tdouble delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n\t\t\t\t- start.dist(c) * start.dist(c) + r * r;\n\t\tdouble t = -v.dot(start.sub(c));\n\t\tdouble s = Math.sqrt(delta);\n\t\tans[0] = start.add(v.mul(t + s));\n\t\tans[1] = start.add(v.mul(t + s));\n\t}\n\n\tpublic Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n\t\tPoint2D v = b.sub(a).unit();\n\t\tv = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n\t\t\t\t(-1) * v.y, v.x);\n\t\treturn v.mul(p.pld(a, b));\n\t}\n\n\tpublic double area(Point2D a, Point2D b, Point2D c) {\n\t\treturn Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tnew Main().calc();\n\t}\n\n\tdouble[] x;\n\tdouble[] y;\n\tint n;\n\tvoid calc(){\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = cin.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tx = new double[n];\n\t\t\ty = new double[n];\n\t\t\tint i,j,k;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tx[i] = cin.nextDouble();\n\t\t\t\ty[i] = cin.nextDouble();\n\t\t\t}\n\t\t\tint ret = 0;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tret = Math.max(ret, getmax(new int[]{i}));\n\t\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\t\tif(Math.hypot(x[i]-x[j], y[i]-y[j]) > 2) continue;\n\t\t\t\t\tret = Math.max(ret, getmax(new int[]{i,j}));\n\t\t\t\t\tfor(k=j+1;k<n;k++){\n\t\t\t\t\t\tif(Math.hypot(x[k]-x[j], y[k]-y[j]) > 2) continue;\n\t\t\t\t\t\tif(Math.hypot(x[i]-x[k], y[i]-y[k]) > 2) continue;\n\t\t\t\t\t\tret = Math.max(ret, getmax(new int[]{i,j,k}));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ret);\n\t\t}\n\t}\n\n\tint getmax(int[] nums){\n\t\tdouble nx = 0;\n\t\tdouble ny = 0;\n\t\tfor(int a : nums){\n\t\t\tnx += x[a]/nums.length;\n\t\t\tny += y[a]/nums.length;\n\t\t}\n\t\tdouble move = 0.7;\n\t\tfor(int i=0;i<30;i++){\n\t\t\tdouble maxdist = 0;\n\t\t\tint num = 0;\n\t\t\tfor(int a :nums){\n\t\t\t\tdouble dist = Math.hypot(nx-x[a], ny-y[a]);\n\t\t\t\tif(maxdist<dist){\n\t\t\t\t\tmaxdist = dist;\n\t\t\t\t\tnum = a;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(maxdist<1) break;\n\t\t\tnx += (x[num]-nx)*move;\n\t\t\tny += (y[num]-ny)*move;\n\t\t\tmove *= 0.7;\n\t\t}\n\t\treturn getnum(nx,ny);\n\t}\n\n\tint getnum(double nx, double ny){\n\t\tint ret = 0;\n\t\tfor(int i = 0;i <n;i++){\n\t\t\tif(Math.hypot(nx-x[i], ny-y[i])<=1) ret++;\n\t\t}\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = -1;\n\t\twhile (n != 0) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)\n\t\t\t\tbreak;\n\t\t\tdouble[] x = new double[n];\n\t\t\tdouble[] y = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t}\n\t\t\tlong ans = 1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (dis_sq(x[i], y[i], x[j], y[j]) > 4)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble[][] c = calc_center(x[i], y[i], x[j], y[j]);\n\t\t\t\t\tfor (int sign = 0; sign < 2; sign++) {\n\t\t\t\t\t\tlong sum = 2;\n\t\t\t\t\t\tdouble cx = c[sign][0];\n\t\t\t\t\t\tdouble cy = c[sign][1];\n\t\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\t\tif (k == i || k == j)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tif (dis_sq(cx, cy, x[k], y[k]) <= 1) {\n\t\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans= Math.max(ans, sum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tdouble[][] calc_center(double x1, double y1, double x2, double y2) {\n\t\tdouble[][] c = new double[2][2];\n\t\tdouble t = Math.sqrt(1 / ((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)) - 1.0 / 4.0);\n\t\tc[0][0] = (x1 + x2) / 2 + (y1 - y2) * t;\n\t\tc[0][1] = (y1 + y2) / 2 + (x2 - x1) * t;\n\t\tc[1][0] = (x1 + x2) / 2 - (y1 - y2) * t;\n\t\tc[1][1] = (y1 + y2) / 2 - (x2 - x1) * t;\n\t\treturn c;\n\t}\n\n\tdouble dis_sq(double x1, double y1, double x2, double y2) {\n\t\treturn (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tP[] ps;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\tps = new P[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tps[i] = new P(sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\tint cnt_max = 0;\n\t\t\tint cnt = 0;\n\t\t\tfor(int i=0;i<n-1;i++) for(int j=i+1;j<n;j++) {\n\t\t\t\t\n\t\t\t\tif( sqrt(dis( ps[i], ps[j] )) < 2.0 ) {\n\t\t\t\t\tP m = new P( (ps[i].x+ps[j].x)/2, (ps[i].y+ps[j].y)/2);\n\t\t\t\t\tdouble d = sqrt(1-dis(ps[i], m ));\n\t\t\t\t\tP dp = new P((ps[i].y-ps[j].y), -(ps[i].x-ps[j].x));\n\t\t\t\t\tdp.nom();\n\t\t\t\t\tdp.mult(d);\n\t\t\t\t\tP c[] = new P[2];\n\t\t\t\t\tc[0] = m.add(dp);\n\t\t\t\t\tdp.mult(-1.0);\n\t\t\t\t\tc[1] = m.add(dp);\n\t\t\t\t\tfor(int l=0;l<2;l++) {\n\t\t\t\t\t\tcnt = 0;\n//\t\t\t\t\t\tLinkedList<Double> dist = new LinkedList<Double>();\n//\t\t\t\t\t\tLinkedList<Integer> ind = new LinkedList<Integer>();\n\t\t\t\t\t\tfor(int k=0;k<n;k++) {\n//\t\t\t\t\t\t\tdebug(dis(c[l], ps[k]));\n\t\t\t\t\t\t\tif(dis(c[l], ps[k]) < 1.0 || k==i||k==j) {\n//\t\t\t\t\t\t\t\tdist.add(dis(c[l], ps[k]));\n//\t\t\t\t\t\t\t\tind.add(k);\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tdebug(dis( ps[i], ps[j] ), cnt_max, cnt);\n\t\t\t\t\t\tcnt_max = max(cnt_max, cnt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt_max);\n\t\t}\n\t}\n\t\n\tdouble dis( P p1, P p2 ) {\n\t\treturn (p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\t\n\tclass P {\n\t\tdouble x, y;\n\t\tP (double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tvoid nom() {\n\t\t\tdouble nom = sqrt(x*x + y*y);\n\t\t\tx /= nom;\n\t\t\ty /= nom;\n\t\t}\n\t\tP add(P p) {\n\t\t\tx += p.x;\n\t\t\ty += p.y;\n\t\t\treturn new P(x, y);\n\t\t}\n\t\tP mult(double d) {\n\t\t\tx *= d;\n\t\t\ty *= d;\n\t\t\treturn new P(x, y);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tfinal double EPS = 1.0e-08;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdouble [] x = new double[n];\n\t\t\tdouble [] y = new double[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tfor(int j=i+1; j < n; j++){\n\t\t\t\t\tdouble midx = (x[i] + x[j]) / 2.0;\n\t\t\t\t\tdouble midy = (y[i] + y[j]) / 2.0;\n\t\t\t\t\tdouble halfdis = Point2D.distance(x[i], y[i], x[j], y[j]) / 2;\n\t\t\t\t\tif(halfdis > 1.0 + EPS){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble midxV = x[i] - midx;\n\t\t\t\t\tdouble midyV = y[i] - midy;\n\t\t\t\t\tdouble tocenterDis = Math.sqrt(1.0 - halfdis * halfdis);\n\t\t\t\t\tfor(int k=0; k <= 1;k++){\n\t\t\t\t\t\tdouble midxV2, midyV2;\n\t\t\t\t\t\tif(k==0){\n\t\t\t\t\t\t\tmidxV2 = midyV * -1;\n\t\t\t\t\t\t\tmidyV2 = midxV;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tmidxV2 = midyV;\n\t\t\t\t\t\t\tmidyV2 = midxV * -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdouble cx = (midxV2) * tocenterDis + midx;\n\t\t\t\t\t\tdouble cy = (midyV2) * tocenterDis + midy;\n\t\t\t\t\t\tint res = getCount(cx,cy,x,y);\n\t\t\t\t\t\tans = Math.max(ans, res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate int getCount(double cx, double cy, double[] x, double[] y) {\n\t\tint count = 0;\n\t\tfor(int i=0; i < x.length;i++){\n\t\t\tdouble res = Point2D.distance(cx, cy, x[i], y[i]);\n\t\t\tif(res <= 1.0 + EPS){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)) {\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tdouble[] x=new double[n+1];\n\t\t\t\tdouble[] y=new double[n+1];\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tx[i]=sc.nextDouble();\n\t\t\t\t\ty[i]=sc.nextDouble();\n\t\t\t\t}\n\t\t\t\tint count=0;\n\t\t\t\tint max=1;\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tfor(int j=i+1; j<n; j++) {\n\t\t\t\t\t\tdouble d=Math.sqrt((x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i]));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(d<=2.0) {\n\t\t\t\t\t\t\tdouble cx=(x[i]+x[j])/2.0;//2点の真ん中\n\t\t\t\t\t\t\tdouble cy=(y[i]+y[j])/2.0;\n\t\t\t\t\t\t\tdouble vx=(y[j]-y[i])/d;//法線ベクトルの単位ベクトル\n\t\t\t\t\t\t\tdouble vy=-((x[j]-x[i])/d);\n\t\t\t\t\t\t\tdouble e=Math.sqrt(1.0-d*d/4.0);//交点cx,cyから中心までの距離\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tdouble px=cx+e*vx;//中心座標(円1) \n\t\t\t\t\t\t\tdouble py=cy+e*vy;\n\t\t\t\t\t\t\tfor(int k=0; k<n; k++) {\n\t\t\t\t\t\t\t\tif(k==i || k==j || Math.sqrt((x[k]-px)*(x[k]-px)+(y[k]-py)*(y[k]-py))<=1.0) {\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmax=Math.max(count, max);\n\t\t\t\t\t\t\tcount=0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tpx=cx-e*vx;//(円2)\n\t\t\t\t\t\t\tpy=cy-e*vy;\n\t\t\t\t\t\t\tfor(int k=0; k<n; k++) {\n\t\t\t\t\t\t\t\tif(k==i || k==j || Math.sqrt((x[k]-px)*(x[k]-px)+(y[k]-py)*(y[k]-py))<=1.0000) {\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmax=Math.max(count, max);\n\t\t\t\t\t\t\tcount=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(max);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint n = ir.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\treturn;\n\t\t\tP[] ps = new P[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tps[i] = new P(ir.nextDouble(), ir.nextDouble());\n\t\t\tint ret = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (ps[i].sub(ps[j]).norm() <= 2.0) {\n\t\t\t\t\t\tP m = ps[i].add(ps[j]).mul(0.5);\n\t\t\t\t\t\tP t = ps[i].sub(ps[j]).perpendicular()\n\t\t\t\t\t\t\t\t.mul(Math.sqrt(sum(1.0, -Math.pow(m.sub(ps[i]).norm(), 2))));\n\t\t\t\t\t\tret = Math.max(ret, check(m.add(t), ps, i, j));\n\t\t\t\t\t\tret = Math.max(ret, check(m.add(t.mul(-1.0)), ps, i, j));\n//\t\t\t\t\t\tout.println(m.toString() + \" \" + t.toString() + \" \" + ret + \" \" + i + \" \" + j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ret);\n\t\t}\n\t}\n\n\tstatic int check(P c, P[] ps, int a, int b) {\n\t\tint ret = 2;\n\t\tfor (int i = 0; i < ps.length; i++) {\n\t\t\tif (i == a || i == b)\n\t\t\t\tcontinue;\n\t\t\tif (sum(1.0, -ps[i].sub(c).norm()) >= 0.0)\n\t\t\t\tret++;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic final double EPS = 1e-7;\n\n\tpublic static double sum(double a, double b) {\n\t\tif (Math.abs(a + b) < EPS * (Math.abs(a) + Math.abs(b)))\n\t\t\treturn 0.0;\n\t\treturn a + b;\n\t}\n\n\tstatic class P {\n\n\t\tpublic double x, y;\n\n\t\tpublic P(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic double getX() {\n\t\t\treturn this.x;\n\t\t}\n\n\t\tpublic double getY() {\n\t\t\treturn this.y;\n\t\t}\n\n\t\tpublic double norm() {\n\t\t\treturn Math.sqrt(sum(this.x * this.x, this.y * this.y));\n\t\t}\n\n\t\tpublic P add(P v) {\n\t\t\treturn new P(sum(this.x, v.x), sum(this.y, v.y));\n\t\t}\n\n\t\tpublic P sub(P v) {\n\t\t\treturn new P(sum(this.x, -v.x), sum(this.y, -v.y));\n\t\t}\n\n\t\tpublic P mul(double k) {\n\t\t\treturn new P(this.x * k, this.y * k);\n\t\t}\n\n\t\tpublic double dot(P v) {\n\t\t\treturn sum(this.x * v.x, this.y * v.y);\n\t\t}\n\n\t\tpublic double det(P v) {\n\t\t\treturn sum(this.x * v.y, -this.y * v.x);\n\t\t}\n\n\t\tpublic P perpendicular() {\n\t\t\treturn new P(this.y / norm(), -this.x / norm());\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(this.x) + \" \" + String.valueOf(this.y);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "public class Main{\n  public void run(java.io.InputStream in, java.io.PrintStream out){\n    java.util.Scanner sc = new java.util.Scanner(in);\n    int n, i, j, max, a;\n    double[] x, y;\n\n    for(;;out.println(max)){\n      n = sc.nextInt(); if(n == 0)break;\n      x = new double[n]; y = new double[n];\n      for(i = 0;i < n;i++){\n        x[i] = sc.nextDouble(); y[i] = sc.nextDouble();\n      }\n      max = 1;\n      for(i = 0;i < n;i++)for(j = i + 1;j < n;j++){\n        if((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) < 4){\n          a = solve(x, y, n, i, j);\n          if(max < a)max = a;\n        }\n      }\n    }\n\n    sc.close();\n  }\n  public static void main(String[] args){\n    (new Main()).run(System.in, System.out);\n  }\n  private static int solve(double[] x, double[] y, int n, int i, int j){\n    int count, res, k;\n    double ax, ay, bx, by, hx, hy, lx, ly, s, ah;\n\n    lx = x[j] - x[i]; ly = y[j] - y[i];\n    s = lx * lx + ly * ly;\n    ah = Math.sqrt(s) / 2;\n\n    hx = x[i] + lx * ah / Math.sqrt(s);\n    hy = y[i] + ly * ah / Math.sqrt(s);\n\n    bx = ly * Math.sqrt((1.0 - ah * ah) / s);\n    by = -lx * Math.sqrt((1.0 - ah * ah) / s);\n\n    ax = hx + bx; ay = hy + by;\n    bx = hx - bx; by = hy - by;\n\n    count = 0;\n    for(k = 0;k < n;k++)\n      if((ax - x[k]) * (ax - x[k]) + (ay - y[k]) * (ay - y[k]) < 1.00001)count++;\n    res = count;\n    count = 0;\n    for(k = 0;k < n;k++)\n      if((bx - x[k]) * (bx - x[k]) + (by - y[k]) * (by - y[k]) < 1.00001)count++;\n    if(res < count)res = count;\n    return res;\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tdouble EPS = 1e-12;\n\tdouble INF = 1e12;\n\n\tclass Point {\n\t\tdouble x, y;\n\n\t\tPoint(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tclass Segment {\n\t\tPoint a, b;\n\n\t\tSegment(Point a, Point b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t}\n\n\tclass Line {\n\t\tPoint a, b;\n\n\t\tLine(Point a, Point b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t}\n\n\tclass Circle {\n\t\tPoint c;\n\t\tdouble r;\n\n\t\tCircle(Point c, double r) {\n\t\t\tthis.c = c;\n\t\t\tthis.r = r;\n\t\t}\n\t}\n\n\tdouble norm(Point a) {\n\t\treturn Math.hypot(a.x, a.y);\n\t}\n\n\tPoint sub(Point a, Point b) {\n\t\treturn new Point(a.x - b.x, a.y - b.y);\n\t}\n\n\tdouble dot(Point a, Point b) {\n\t\treturn a.x * b.x + a.y * b.y;\n\t}\n\n\tdouble cross(Point a, Point b) {\n\t\treturn a.x * b.y - a.y * b.x;\n\t}\n\n\tdouble abs(double a) {\n\t\treturn 0 < a ? a : -a;\n\t}\n\n\t// 交点の個数が0または無限の時はreturn null;\n\tPoint[] crossPoint(Circle c1, Circle c2) {\n\t\tdouble d = norm(sub(c1.c, c2.c));\n\t\tif (d < EPS && abs(c1.r - c2.r) < EPS) {\n\t\t\treturn null;\n\t\t} else if (c1.r + c2.r < d - EPS || d + EPS < abs(c1.r - c2.r)) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tdouble a = (c1.r * c1.r - c2.r * c2.r + d * d) / (2 * d);\n\t\t\tdouble h = Math.sqrt(Math.max(c1.r * c1.r - a * a, 0));\n\t\t\tPoint p1 = new Point(c1.c.x + a / d * (c2.c.x - c1.c.x), c1.c.y + a / d * (c2.c.y - c1.c.y));\n\t\t\tPoint p2 = new Point(h / d * (c2.c.x - c1.c.x), h / d * (c2.c.y - c1.c.y));\n\t\t\tif (norm(p2) < EPS) {\n\t\t\t\treturn new Point[] { p1 };\n\t\t\t} else {\n\t\t\t\treturn new Point[] { new Point(p1.x - p2.y, p1.y + p2.x), new Point(p1.x + p2.y, p1.y - p2.x) };\n\t\t\t}\n\t\t}\n\t}\n\n\tboolean isCover(Circle c, Point p) {\n\t\treturn norm(sub(c.c, p)) <= c.r + EPS;\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tPoint[] p = new Point[n];\n\t\t\tCircle[] c = new Circle[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tp[i] = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\t\tc[i] = new Circle(p[i], 1.);\n\t\t\t}\n\n\t\t\tint max = 1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tPoint[] cp = crossPoint(c[i], c[j]);\n\t\t\t\t\tif (cp == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = 0; k < cp.length; k++) {\n\t\t\t\t\t\tCircle nc = new Circle(cp[k], 1.);\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\t\tif (isCover(nc, p[l])) {\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmax = Math.max(max, cnt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Point2D.Double;\nimport java.util.*;\n  \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n  \n    public static void main(String[] args) {\n        new Main(); \n    }\n  \n    public Main() {\n        new aoj2151().doIt();\n    }\n    class aoj2151{\n    \tPoint2D[] p = new Point2D[301];\n    \tint ans(int n){\n    \t\tint result = 1;\n    \t\tfor(int i = 0;i < n;i++){\n    \t\t\tfor(int j = i+1;j < n;j++){\n    \t\t\t\tdouble dot = p[i].distance(p[j]);\n//    \t\t\t\tSystem.out.println(dot);\n    \t\t\t\tif(dot > 2.0 + 0.000001)continue;\n    \t\t\t\tdouble e = Math.sqrt(1.0 - dot*dot/4.0);\n    \t\t\t\tfor (int pm = 0; pm < 2; ++pm) {\n    \t\t\t\t\tPoint2D c = new Point2D.Double(p[i].getX()+p[j].getX()/2.0 + (p[j].getY()-p[i].getY())*e/dot,\n    \t\t\t\t\t\t\t(p[i].getY()+p[j].getY())/2.0 - (p[j].getX()-p[i].getX())*e/dot);\n    \t\t\t\t\tint cnt = 2;\n    \t\t\t\t\tfor (int k = 0; k < n; ++k) {\n    \t\t\t\t\t\tif (k == i || k == j)continue;\n    \t\t\t\t        if ((c.getX()-p[k].getX())*(c.getX()-p[k].getX())+(c.getY()-p[k].getY())*(c.getY()-p[k].getY()) <= 1.0 + 0.000001)cnt++;\n    \t\t\t\t      }\n    \t\t\t\t      result = Math.max(result, cnt);\n    \t\t\t\t      e *= -1.0;\n    \t\t\t\t    }\n    \t\t\t\t}\n    \t\t\t}\n    \t\treturn result;\n    \t}\n    \tvoid doIt(){\n    \t\twhile(true){\n    \t\t\tint n = sc.nextInt();\n    \t\t\tif(n == 0)break;\n    \t\t\tfor(int i = 0;i < n;i++){\n    \t\t\t\tp[i] = new Point2D.Double(sc.nextDouble(),sc.nextDouble());\n    \t\t\t}\n    \t\t\tSystem.out.println(ans(n));\n    \t\t}\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tP[] ps;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\tps = new P[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tps[i] = new P(sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\tint cnt_max = 1;\n\t\t\tint cnt = 0;\n\t\t\tfor(int i=0;i<n-1;i++) for(int j=i+1;j<n;j++) {\n\t\t\t\t\n\t\t\t\tif( sqrt(dis( ps[i], ps[j] )) < 2.0 ) {\n\t\t\t\t\tP m = new P( (ps[i].x+ps[j].x)/2, (ps[i].y+ps[j].y)/2);\n\t\t\t\t\tdouble d = sqrt(1-dis(ps[i], m ));\n\t\t\t\t\tP dp = new P((ps[i].y-ps[j].y), -(ps[i].x-ps[j].x));\n\t\t\t\t\tdp.nom();\n\t\t\t\t\tdp.mult(d);\n\t\t\t\t\tP c[] = new P[2];\n\t\t\t\t\tc[0] = m.add(dp);\n\t\t\t\t\tdp.mult(-1.0);\n\t\t\t\t\tc[1] = m.add(dp);\n\t\t\t\t\tfor(int l=0;l<2;l++) {\n\t\t\t\t\t\tcnt = 0;\n//\t\t\t\t\t\tLinkedList<Double> dist = new LinkedList<Double>();\n//\t\t\t\t\t\tLinkedList<Integer> ind = new LinkedList<Integer>();\n\t\t\t\t\t\tfor(int k=0;k<n;k++) {\n\t\t\t\t\t\t\tif(dis(c[l], ps[k]) < 1.0 || k==i||k==j) {\n\t\t\t\t\t\t\tdebug(dis(c[l], ps[k]));\n//\t\t\t\t\t\t\t\tdist.add(dis(c[l], ps[k]));\n//\t\t\t\t\t\t\t\tind.add(k);\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdebug(c[l].x, c[l].y, i, j, cnt);\n\t\t\t\t\t\tcnt_max = max(cnt_max, cnt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt_max);\n\t\t}\n\t}\n\t\n\tdouble dis( P p1, P p2 ) {\n\t\treturn (p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\t\n\tclass P {\n\t\tdouble x, y;\n\t\tP (double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tvoid nom() {\n\t\t\tdouble nom = sqrt(x*x + y*y);\n\t\t\tx /= nom;\n\t\t\ty /= nom;\n\t\t}\n\t\tP add(P p) {\n\t\t\tx += p.x;\n\t\t\ty += p.y;\n\t\t\treturn new P(x, y);\n\t\t}\n\t\tP mult(double d) {\n\t\t\tx *= d;\n\t\t\ty *= d;\n\t\t\treturn new P(x, y);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D[] points = new Point2D[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tpoints[i] = new Point2D(sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tint max = 0;\n\t\t\t\n\t\t\tfor(int fst = 0; fst < n; fst++){\n\t\t\t\tfor(int snd = 0; snd < n; snd++){\n\t\t\t\t\tPoint2D[] cross = Point2D.cross_ss(points[fst], 1, points[snd], 1);\n\t\t\t\t\t\n\t\t\t\t\tfor(Point2D cross_c : cross){\n\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\t\tif(cross_c.dist(points[i]) <= 1.0 + Point2D.EPS){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tmax = Math.max(max, count);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t\t\n\t}\n}\n\nclass Point2D {\n    public double x;\n    public double y;\n \n    public static final double EPS = 1e-3;\n \n    public Point2D(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n \n    public Point2D(Point2D point) {\n        this.x = point.x;\n        this.y = point.y;\n    }\n \n    public String toString() {\n        return x + \",\" + y;\n    }\n \n    @Override\n    public boolean equals(Object o) {\n        if (o instanceof Point2D) {\n            Point2D another = (Point2D) o;\n            if (this.x - EPS < another.x && this.x + EPS > another.x\n                    && this.y - EPS < another.y && this.y + EPS > another.y) {\n                return true;\n            }\n             \n            return false;\n \n            // return this.x == another.x && this.y == another.y;\n        }\n        return false;\n    }\n \n    public Point2D add(double x, double y) {\n        return new Point2D(this.x + x, this.y + y);\n    }\n \n    public Point2D sub(double x, double y) {\n        return add(-x, -y);\n    }\n \n    public Point2D add(Point2D another) {\n        return add(another.x, another.y);\n    }\n \n    public Point2D sub(Point2D another) {\n        return sub(another.x, another.y);\n    }\n \n    public Point2D mul(double d) {\n        return new Point2D(this.x * d, this.y * d);\n    }\n \n    public Point2D div(double d) {\n        return new Point2D(this.x / d, this.y / d);\n    }\n \n    public double dot(double x, double y) {\n        return this.x * x + this.y * y;\n    }\n \n    public double dot(Point2D another) {\n        return dot(another.x, another.y);\n    }\n \n    public double cross(double x, double y) {\n        return this.x * y - this.y * x;\n    }\n \n    public double cross(Point2D another) {\n        return cross(another.x, another.y);\n    }\n \n    public double dist(double x, double y) {\n        return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n                * (this.y - y));\n    }\n \n    public double dist(Point2D another) {\n        return dist(another.x, another.y);\n    }\n \n    public double dist_o() {\n        return dist(0, 0);\n    }\n \n    public Point2D unit() {\n        return div(dist_o());\n    }\n \n    public boolean pol(Point2D start, Point2D end) {\n        return end.sub(start).cross(this.sub(start)) < EPS;\n    }\n \n    public boolean pos(Point2D start, Point2D end) {\n        return (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n    }\n \n    public double pld(Point2D start, Point2D end) {\n        return Math.abs((end.sub(start).cross(this.sub(start)))\n                / end.sub(start).dist_o());\n    }\n \n    public double psd(Point2D start, Point2D end) {\n        if (end.sub(start).dot(this.sub(start)) < EPS) {\n            return this.dist(start);\n        } else if (start.sub(end).dot(this.sub(end)) < EPS) {\n            return this.dist(end);\n        } else {\n            return end.sub(start).cross(this.sub(start)) / end.dist(start);\n        }\n    }\n \n    public static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS)\n                && (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n    }\n \n    public static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return a1.sub(a2).cross(b1.sub(b2)) < EPS;\n    }\n \n    public static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D b = b2.sub(b1);\n        double d1 = Math.abs(b.cross(a1.sub(b1)));\n        double d2 = Math.abs(b.cross(a2.sub(b1)));\n        double t = d1 / (d1 + d2);\n        Point2D a = a2.sub(a1), v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D a = a2.sub(a1);\n        Point2D b = b2.sub(b1);\n        double t = b.cross(b1.sub(a1)) / b.cross(a);\n        Point2D v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n            double r2) {\n        double dis = p1.dist(p2);\n \n        if (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n            return new Point2D[0]; // same\n        }\n \n        if (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n            Point2D tmp = p2.sub(p1);\n            tmp = tmp.mul(r1 / tmp.dist_o());\n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis + EPS > r1 + r2) {\n            return new Point2D[0]; // out\n        }\n \n        double dis_m = Math.abs(r1 - r2);\n \n        if (dis_m + EPS > dis && dis_m - EPS < dis) {\n            Point2D tmp = null;\n            if (r1 > r2) {\n                tmp = p2.sub(p1);\n            } else {\n                tmp = p1.sub(p2);\n            }\n \n            double min = Math.min(r1, r2);\n \n            tmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n \n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis_m + EPS > dis) {\n            return new Point2D[0]; // inner\n        } else {\n            Point2D ret[] = new Point2D[2];\n \n            double theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n                    / (2 * dis * r1));\n            double a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n \n            ret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n                    * Math.sin(a + theta) + p1.y);\n            ret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n                    * Math.sin(a - theta) + p1.y);\n            return ret;\n        }\n    }\n \n    public void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n            Point2D ans[]) {\n        if (c.pld(start, end) > r + EPS)\n            return;\n        Point2D v = end.sub(start).unit();\n        double delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n                - start.dist(c) * start.dist(c) + r * r;\n        double t = -v.dot(start.sub(c));\n        double s = Math.sqrt(delta);\n        ans[0] = start.add(v.mul(t + s));\n        ans[1] = start.add(v.mul(t + s));\n    }\n \n    public Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n        Point2D v = b.sub(a).unit();\n        v = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n                (-1) * v.y, v.x);\n        return v.mul(p.pld(a, b));\n    }\n \n    public double area(Point2D a, Point2D b, Point2D c) {\n        return Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  double f(double rad) {\n    return Math.pow(Math.sin(rad), 2.0) + Math.pow(1 - Math.cos(rad), 2.0);\n  }\n\n  double findRadEPS() {\n    double left = 0;\n    double right = Math.PI / 2;\n    while (right - left > 1e-6) {\n      double mid = (left + right) / 2;\n      double res = f(mid);\n      if (res < 1e-4) {\n        left = mid;\n      } else {\n        right = mid;\n      }\n    }\n    return left;\n  }\n\n  void run() {\n    double RAD_EPS = findRadEPS();\n//    debug(RAD_EPS, 2 * Math.PI / RAD_EPS);\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      double[] x = new double[n];\n      double[] y = new double[n];\n      for (int i = 0; i < n; ++i) {\n        x[i] = sc.nextDouble();\n        y[i] = sc.nextDouble();\n      }\n      int max = 0;\n      for (int i = 0; i < n; ++i) {\n        for (int j = 0; j * RAD_EPS < 2 * Math.PI; ++j) {\n          double ex = x[i] + Math.cos(j * RAD_EPS);\n          double ey = y[i] + Math.sin(j * RAD_EPS);\n          int cnt = 0;\n          for (int k = 0; k < n; ++k) {\n            double dist = Math.sqrt(Math.pow(x[k] - ex, 2.0) + Math.pow(y[k] - ey, 2.0));\n            if (dist < 1 + 1e-4) {\n              ++cnt;\n            }\n          }\n          max = Math.max(max, cnt);\n        }\n      }\n      System.out.println(max);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-6;\n\n\tint n;\n\tP[] ps;\n\t\n\tvoid run() {\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tps=new P[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble x=sc.nextDouble();\n\t\t\t\tdouble y=sc.nextDouble();\n\t\t\t\tps[i]=new P(x,y);\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\tif(n==1){\n\t\t\tprintln(\"1\");\n\t\t\treturn;\n\t\t}\n\t\tint ans=0;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int i=j+1;i<n;i++){\n\t\t\t\tP p1=ps[i];\n\t\t\t\tP p2=ps[j];\n\t\t\t\tP d=p1.sub(p2);\n\t\t\t\tif(d.abs()>2+EPS){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble v=d.abs();\n\t\t\t\td=d.div(v);\n\t\t\t\tdouble t=sqrt(1-(v/2)*(v/2));\n\t\t\t\tP m=p1.add(p2).div(2);\n\t\t\t\tP c1=m.add(d.rot90().mul(t));\n\t\t\t\tP c2=m.add(d.rot90().mul(-t));\n\t\t\t\tans=max(ans,count(c1));\n\t\t\t\tans=max(ans,count(c2));\n//\t\t\t\tdebug(c1.x,c1.y);\n//\t\t\t\tdebug(c2.x,c2.y);\n//\t\t\t\tdebug(count(c1),count(c2));\n\t\t\t}\n\t\t}\n//\t\tdebug(ans);\n\t\tprintln(ans+\"\");\n\t}\n\t\n\tint count(P p){\n\t\tint res=2;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(p.sub(ps[i]).abs()<1+EPS){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tclass P{\n\t\tdouble x, y;\n\t\t\n\t\tP(double x,double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t\t\n\t\tP add(P p){return new P(x+p.x,y+p.y);}\n\t\tP sub(P p){return new P(x-p.x,y-p.y);}\n\t\tP mul(double m){return new P(x*m,y*m);}\n\t\tP div(double d){return new P(x/d,y/d);}\n\t\t\n\t\tdouble abs(){ return sqrt(abs2()); }\n\t\tdouble abs2(){ return x*x+y*y; }\n\t\tP rot90(){ return new P(-y,x); }\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tfinal double EPS = 1.0e-08;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdouble [] x = new double[n];\n\t\t\tdouble [] y = new double[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t}\n\t\t\tint ans = 1;\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tfor(int j=i+1; j < n; j++){\n\t\t\t\t\tdouble midx = (x[i] + x[j]) / 2.0;\n\t\t\t\t\tdouble midy = (y[i] + y[j]) / 2.0;\n\t\t\t\t\tdouble halfdis = Point2D.distance(x[i], y[i], x[j], y[j]) / 2;\n\t\t\t\t\tif(halfdis > 1.0 + EPS){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble midxV = x[i] - midx;\n\t\t\t\t\tdouble midyV = y[i] - midy;\n\t\t\t\t\tdouble tocenterDis = Math.sqrt(1.0 - halfdis * halfdis);\n\t\t\t\t\tfor(int k=0; k <= 1;k++){\n\t\t\t\t\t\tdouble midxV2, midyV2;\n\t\t\t\t\t\tif(k==0){\n\t\t\t\t\t\t\tmidxV2 = midyV * -1;\n\t\t\t\t\t\t\tmidyV2 = midxV;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tmidxV2 = midyV;\n\t\t\t\t\t\t\tmidyV2 = midxV * -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdouble cx = (midxV2) * tocenterDis + midx;\n\t\t\t\t\t\tdouble cy = (midyV2) * tocenterDis + midy;\n\t\t\t\t\t\tint res = getCount(cx,cy,x,y);\n\t\t\t\t\t\tans = Math.max(ans, res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate int getCount(double cx, double cy, double[] x, double[] y) {\n\t\tint count = 0;\n\t\tfor(int i=0; i < x.length;i++){\n\t\t\tdouble res = Point2D.distance(cx, cy, x[i], y[i]);\n\t\t\tif(res <= 1.0 + EPS){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-9;\n\n\tint n;\n\tP[] ps;\n\t\n\tvoid run() {\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tps=new P[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble x=sc.nextDouble();\n\t\t\t\tdouble y=sc.nextDouble();\n\t\t\t\tps[i]=new P(x,y);\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\tint ans=0;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int i=j+1;i<n;i++){\n\t\t\t\tP p1=ps[i];\n\t\t\t\tP p2=ps[j];\n\t\t\t\tP d=p1.sub(p2);\n\t\t\t\tif(d.abs()>2+EPS){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble v=d.abs();\n\t\t\t\td=d.div(v);\n\t\t\t\tdouble t=sqrt(1-(v/2)*(v/2));\n\t\t\t\tP m=p1.add(p2).div(2);\n\t\t\t\tP c1=m.add(d.rot90().mul(t));\n\t\t\t\tP c2=m.add(d.rot90().mul(-t));\n\t\t\t\tans=max(ans,count(c1));\n\t\t\t\tans=max(ans,count(c2));\n//\t\t\t\tdebug(c1.x,c1.y);\n//\t\t\t\tdebug(c2.x,c2.y);\n//\t\t\t\tdebug(count(c1),count(c2));\n\t\t\t}\n\t\t}\n//\t\tdebug(ans);\n\t\tprintln(ans+\"\");\n\t}\n\t\n\tint count(P p){\n\t\tint res=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble d=p.sub(ps[i]).abs();\n\t\t\tif(d<1+EPS){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tclass P{\n\t\tdouble x, y;\n\t\t\n\t\tP(double x,double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t\t\n\t\tP add(P p){return new P(x+p.x,y+p.y);}\n\t\tP sub(P p){return new P(x-p.x,y-p.y);}\n\t\tP mul(double m){return new P(x*m,y*m);}\n\t\tP div(double d){return new P(x/d,y/d);}\n\t\t\n\t\tdouble abs(){ return sqrt(abs2()); }\n\t\tdouble abs2(){ return x*x+y*y; }\n\t\tP rot90(){ return new P(-y,x); }\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    static double[] x,y;\n    static int n;\n    static int max;\n\n    public static void main(String[] args){\n\tScanner sc = new Scanner(System.in);\n\n\tn = sc.nextInt();\n\n\twhile(n!=0){\n\t    max = 1;\n\t    x = new double[n];\n\t    y = new double[n];\n\n\t    for(int i=0; i<n; i++){\n\t\tx[i] = sc.nextDouble();\n\t\ty[i] = sc.nextDouble();\n\t    }\n\n\t    solve();\n\t    System.out.println(max);\n\n\t    n = sc.nextInt();\n\t}\n    }\n\n   public static void solve(){\n\tfor(int i=0; i<n; i++){\n\t    for(int j=i+1; j<n; j++){\n\t\tdouble ab = getDist(x[i],y[i],x[j],y[j]);\n\t\tif(ab<=2){\n\t\t    double mx = (x[i]+x[j])/2;//点aと点bの中点m\n\t\t    double my = (y[i]+y[j])/2;\n\t\t    double mc = Math.sqrt(1-(ab*ab)/4);//中点mから中心cまでの距離\n\t\t    double[][] nv = getNormalVector(x[i]-x[j],y[i]-y[j]);\n\n\t\t    int count = 0;\n\t\t    for(int l=0; l<2; l++){\n\t\t\tdouble cx = mx + nv[l][0]*mc;//中点cの座標\n\t\t\tdouble cy = my + nv[l][1]*mc;\n\t\t\tfor(int k=0; k<n; k++){\n\t\t\t    if(getDist2(cx,cy,x[k],y[k])<1.0+(1e-6)){count++;}\n\t\t\t}\n\t\t\tif(count>max){max = count;}\n\t\t\tcount = 0;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    //a-bの絶対値（ab間の距離）\n    public static double getDist(double x1,double y1,double x2,double y2){\n\treturn Math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n    }\n\n    //絶対値なしの比較用　絶対値取る処理は重いため\n    public static double getDist2(double x1,double y1,double x2,double y2){\n\treturn (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n    }\n\n    //単位法線ベクトルを求める\n    public static double[][] getNormalVector(double x, double y){\n\t\n\tdouble d = Math.sqrt(x*x+y*y);//|a|\n\t\n\tdouble[][] nv = new double[2][2];\n\t\n\tnv[0][0] = -y/d;\n\tnv[0][1] = x/d;\n\tnv[1][0] = y/d;\n\tnv[1][1] = -x/d;\n\t\n\treturn nv;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Point2D.Double;\nimport java.util.*;\n  \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n  \n    public static void main(String[] args) {\n        new Main(); \n    }\n  \n    public Main() {\n        new aoj2151().doIt();\n    }\n    class aoj2151{\n    \tPoint2D[] p = new Point2D[301];\n    \tint ans(int n){\n    \t\tint result = 0;\n    \t\tfor(int i = 0;i < n;i++){\n    \t\t\tfor(int j = i+1;j < n;j++){\n    \t\t\t\tdouble dot = Math.sqrt(p[i].getX() - p[j].getX())*(p[i].getX() - p[j].getX())\n    \t\t\t\t\t\t+ (p[i].getY() - p[j].getY())*(p[i].getY() - p[j].getY());\n    \t\t\t\tif(dot > 2.0)continue;\n    \t\t\t\tPoint2D m = new Point2D.Double((p[i].getX() + p[j].getX())/2,(p[i].getY() + p[j].getY())/2);\n    \t\t\t\tPoint2D v = new Point2D.Double((p[j].getX() - p[i].getX())/dot,(p[j].getY() - p[i].getY())/dot);\n    \t\t\t\tdouble e = Math.sqrt(1.0 - dot*dot/4.0);\n    \t\t\t\tPoint2D rp = new Point2D.Double(m.getX() - e*v.getY(),m.getY() + e*v.getX());\n    \t\t\t\tPoint2D lp = new Point2D.Double(m.getX() + e*v.getY(),m.getY() - e*v.getX());\n    \t\t\t\tint point = 2;\n\t\t            int point2 = 2;\n    \t\t\t\tfor (int k=0; k<n; k++) {\n    \t\t            if (k==i || k==j)continue;\n    \t\t            double check_rx = (rp.getX()-p[k].getX())*(rp.getX()-p[k].getX());\n    \t\t            double check_ry = (rp.getY()-p[k].getY())*(rp.getY()-p[k].getY());\n    \t\t            double check_lx = (lp.getX()-p[k].getX())*(lp.getX()-p[k].getX());\n    \t\t            double check_ly = (lp.getY()-p[k].getY())*(lp.getY()-p[k].getY());\n    \t\t            if (check_rx + check_ry < 1.0) {\n    \t\t            \tpoint++;\n    \t\t            }\n    \t\t            if (check_lx + check_ly < 1.0) {\n    \t\t            \tpoint2++;\n    \t\t            }\n    \t\t        }\n    \t\t\t\tresult = Math.max(result, point);\n\t\t            result = Math.max(result, point2);\n    \t\t\t}\n    \t\t}\n    \t\treturn result;\n    \t}\n    \tvoid doIt(){\n    \t\twhile(true){\n    \t\t\tint n = sc.nextInt();\n    \t\t\tif(n == 0)break;\n    \t\t\tfor(int i = 0;i < n;i++){\n    \t\t\t\tp[i] = new Point2D.Double(sc.nextDouble(),sc.nextDouble());\n    \t\t\t}\n    \t\t\tSystem.out.println(ans(n));\n    \t\t}\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n    static int n;\n    static double[] x, y;\n    static int ans;\n\n    public static void main(String[] args) {\n        FastScanner fs = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        while (true) {\n            n = fs.nextInt();\n            if (n == 0){\n                break;\n            }\n\n            x = new double[n];\n            y = new double[n];\n            for(int i = 0;i < n;i++){\n                x[i] = fs.nextDouble();\n                y[i] = fs.nextDouble();\n            }\n\n            ans = 1;\n            // 2点選ぶ全探索\n            for(int i = 0;i < n;i++){\n                for(int j = i+1;j<n;j++){\n                    // そもそも2以上離れているなら無視\n                    double dist = Math.sqrt(Math.pow(x[i] - x[j], 2) + Math.pow(y[i] - y[j], 2));\n                    if(dist > 2){\n                        continue;\n                    }\n\n                    double mx = (x[i] + x[j]) / 2;\n                    double my = (y[i] + y[j]) / 2;\n                    double m_dist = Math.sqrt(1 - (dist / 2) * (dist / 2));\n\n                    int temp = 0;\n                    double c1x = mx + (y[i] - y[j]) / dist * m_dist;\n                    double c1y = my - (x[i] - x[j]) / dist * m_dist;\n                    for(int k = 0;k < n;k++){\n                        if(Math.pow(x[k] - c1x, 2) + Math.pow(y[k] - c1y, 2) < 1 + 1e-10){\n                            temp += 1;\n                        }\n                    }\n                    ans = Math.max(ans, temp);\n\n                    temp = 0;\n                    double c2x = mx - (y[i] - y[j]) / dist * m_dist;\n                    double c2y = my + (x[i] - x[j]) / dist * m_dist;\n                    for(int k = 0;k < n;k++){\n                        if(Math.pow(x[k] - c2x, 2) + Math.pow(y[k] - c2y, 2) < 1 + 1e-10){\n                            temp += 1;\n                        }\n                    }\n                    ans = Math.max(ans, temp);\n                }\n            }\n\n            pw.println(ans);\n        }\n        pw.flush();\n    }\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n\n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String readNextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tdouble EPS = 1e-12;\n\tdouble INF = 1e12;\n\n\tclass Point {\n\t\tdouble x, y;\n\n\t\tPoint(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tclass Segment {\n\t\tPoint a, b;\n\n\t\tSegment(Point a, Point b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t}\n\n\tclass Line {\n\t\tPoint a, b;\n\n\t\tLine(Point a, Point b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t}\n\n\tclass Circle {\n\t\tPoint c;\n\t\tdouble r;\n\n\t\tCircle(Point c, double r) {\n\t\t\tthis.c = c;\n\t\t\tthis.r = r;\n\t\t}\n\t}\n\n\tdouble norm(Point a) {\n\t\treturn Math.hypot(a.x, a.y);\n\t}\n\n\tPoint sub(Point a, Point b) {\n\t\treturn new Point(a.x - b.x, a.y - b.y);\n\t}\n\n\tdouble dot(Point a, Point b) {\n\t\treturn a.x * b.x + a.y * b.y;\n\t}\n\n\tdouble cross(Point a, Point b) {\n\t\treturn a.x * b.y - a.y * b.x;\n\t}\n\n\tdouble abs(double a) {\n\t\treturn 0 < a ? a : -a;\n\t}\n\n\t// 交点の個数が0または無限の時はreturn null;\n\tPoint[] crossPoint(Circle c1, Circle c2) {\n\t\tdouble d = norm(sub(c1.c, c2.c));\n\t\tif (d < EPS && abs(c1.r - c2.r) < EPS) {\n\t\t\treturn null;\n\t\t} else if (c1.r + c2.r < d - EPS || d + EPS < abs(c1.r - c2.r)) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tdouble a = (c1.r * c1.r - c2.r * c2.r + d * d) / (2 * d);\n\t\t\tdouble h = Math.sqrt(Math.max(c1.r * c1.r - a * a, 0));\n\t\t\tPoint p1 = new Point(c1.c.x + a / d * (c2.c.x - c1.c.x), c1.c.y + a / d * (c2.c.y - c1.c.y));\n\t\t\tPoint p2 = new Point(h / d * (c2.c.x - c1.c.x), h / d * (c2.c.y - c1.c.y));\n\t\t\tif (norm(p2) < EPS) {\n\t\t\t\treturn new Point[] { p1 };\n\t\t\t} else {\n\t\t\t\treturn new Point[] { new Point(p1.x - p2.y, p1.y + p2.x), new Point(p1.x + p2.y, p1.y - p2.x) };\n\t\t\t}\n\t\t}\n\t}\n\n\tboolean isCover(Circle c, Point p) {\n\t\treturn norm(sub(c.c, p)) <= c.r + EPS;\n\t}\n\n\tvoid run() {\n\t\t\n\t\tSystem.out.println(300*300*300*2);\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tPoint[] p = new Point[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tp[i] = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\n\t\t\tint max = 1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tPoint[] cp = crossPoint(new Circle(p[i], 1.), new Circle(p[j], 1.));\n\t\t\t\t\tif (cp == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = 0; k < cp.length; k++) {\n\t\t\t\t\t\tCircle c = new Circle(cp[k], 1.);\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\t\tif (isCover(c, p[l])) {\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmax = Math.max(max, cnt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tfinal double EPS = 1.0e-08;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdouble [] x = new double[n];\n\t\t\tdouble [] y = new double[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tfor(int j=i+1; j < n; j++){\n\t\t\t\t\tdouble midx = (x[i] + x[j]) / 2.0;\n\t\t\t\t\tdouble midy = (y[i] + y[j]) / 2.0;\n\t\t\t\t\tdouble halfdis = Point2D.distance(x[i], y[i], x[j], y[j]) / 2;\n\t\t\t\t\tif(halfdis > 1.0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble midxV = x[i] - midx;\n\t\t\t\t\tdouble midyV = y[i] - midy;\n\t\t\t\t\tdouble tocenterDis = Math.sqrt(1.0 - halfdis * halfdis);\n\t\t\t\t\tfor(int k=0; k <= 1;k++){\n\t\t\t\t\t\tdouble midxV2, midyV2;\n\t\t\t\t\t\tif(k==0){\n\t\t\t\t\t\t\tmidxV2 = midyV * -1;\n\t\t\t\t\t\t\tmidyV2 = midxV;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tmidxV2 = midyV;\n\t\t\t\t\t\t\tmidyV2 = midxV * -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdouble cx = (midxV2) * tocenterDis + midx;\n\t\t\t\t\t\tdouble cy = (midyV2) * tocenterDis + midy;\n\t\t\t\t\t\tint res = getCount(cx,cy,x,y);\n\t\t\t\t\t\tans = Math.max(ans, res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate int getCount(double cx, double cy, double[] x, double[] y) {\n\t\tint count = 0;\n\t\tfor(int i=0; i < x.length;i++){\n\t\t\tdouble res = Point2D.distance(cx, cy, x[i], y[i]);\n\t\t\tif(res <= 1.0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Point2D> points = new LinkedList<Point2D>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tpoints.add(new Point2D(sc.nextDouble(), sc.nextDouble()));\n\t\t\t}\n\t\t\t\n\t\t\tint max = 0;\n\t\t\tfor(Point2D src : points){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(Point2D dest : points){\n\t\t\t\t\tPoint2D[] circles = Point2D.cross_ss(src, 1.0, dest, 1.0);\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(Arrays.toString(circles));\n\t\t\t\t\t\n\t\t\t\t\tfor(Point2D circle : circles){\n\t\t\t\t\t\tint inner = 0;\n\t\t\t\t\t\tfor(Point2D elem : points){\n\t\t\t\t\t\t\tif(circle.dist(elem) < 1.0){\n\t\t\t\t\t\t\t\tinner++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tcount = Math.max(count, inner);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t\t\n\t}\n\n}\n\nclass Point2D {\n\tpublic double x;\n\tpublic double y;\n\n\tpublic static final double EPS = 1e-9;\n\n\tpublic Point2D(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tpublic Point2D(Point2D point) {\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t}\n\n\tpublic String toString() {\n\t\treturn x + \",\" + y;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (o instanceof Point2D) {\n\t\t\tPoint2D another = (Point2D) o;\n\t\t\tif (this.x - EPS < another.x && this.x + EPS > another.x\n\t\t\t\t\t&& this.y - EPS < another.y && this.y + EPS > another.y) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\n\t\t\t// return this.x == another.x && this.y == another.y;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic Point2D add(double x, double y) {\n\t\treturn new Point2D(this.x + x, this.y + y);\n\t}\n\n\tpublic Point2D sub(double x, double y) {\n\t\treturn add(-x, -y);\n\t}\n\n\tpublic Point2D add(Point2D another) {\n\t\treturn add(another.x, another.y);\n\t}\n\n\tpublic Point2D sub(Point2D another) {\n\t\treturn sub(another.x, another.y);\n\t}\n\n\tpublic Point2D mul(double d) {\n\t\treturn new Point2D(this.x * d, this.y * d);\n\t}\n\n\tpublic Point2D div(double d) {\n\t\treturn new Point2D(this.x / d, this.y / d);\n\t}\n\n\tpublic double dot(double x, double y) {\n\t\treturn this.x * x + this.y * y;\n\t}\n\n\tpublic double dot(Point2D another) {\n\t\treturn dot(another.x, another.y);\n\t}\n\n\tpublic double cross(double x, double y) {\n\t\treturn this.x * y - this.y * x;\n\t}\n\n\tpublic double cross(Point2D another) {\n\t\treturn cross(another.x, another.y);\n\t}\n\n\tpublic double dist(double x, double y) {\n\t\treturn Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n\t\t\t\t* (this.y - y));\n\t}\n\n\tpublic double dist(Point2D another) {\n\t\treturn dist(another.x, another.y);\n\t}\n\n\tpublic double dist_o() {\n\t\treturn dist(0, 0);\n\t}\n\n\tpublic Point2D unit() {\n\t\treturn div(dist_o());\n\t}\n\n\tpublic boolean pol(Point2D start, Point2D end) {\n\t\treturn end.sub(start).cross(this.sub(start)) < EPS;\n\t}\n\n\tpublic boolean pos(Point2D start, Point2D end) {\n\t\treturn (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n\t}\n\n\tpublic double pld(Point2D start, Point2D end) {\n\t\treturn Math.abs((end.sub(start).cross(this.sub(start)))\n\t\t\t\t/ end.sub(start).dist_o());\n\t}\n\n\tpublic double psd(Point2D start, Point2D end) {\n\t\tif (end.sub(start).dot(this.sub(start)) < EPS) {\n\t\t\treturn this.dist(start);\n\t\t} else if (start.sub(end).dot(this.sub(end)) < EPS) {\n\t\t\treturn this.dist(end);\n\t\t} else {\n\t\t\treturn end.sub(start).cross(this.sub(start)) / end.dist(start);\n\t\t}\n\t}\n\n\tpublic static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS)\n\t\t\t\t&& (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n\t}\n\n\tpublic static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn a1.sub(a2).cross(b1.sub(b2)) < EPS;\n\t}\n\n\tpublic static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble d1 = Math.abs(b.cross(a1.sub(b1)));\n\t\tdouble d2 = Math.abs(b.cross(a2.sub(b1)));\n\t\tdouble t = d1 / (d1 + d2);\n\t\tPoint2D a = a2.sub(a1), v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D a = a2.sub(a1);\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble t = b.cross(b1.sub(a1)) / b.cross(a);\n\t\tPoint2D v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n\t\t\tdouble r2) {\n\t\tdouble dis = p1.dist(p2);\n\n\t\tif (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n\t\t\treturn new Point2D[0]; // same\n\t\t}\n\n\t\tif (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n\t\t\tPoint2D tmp = p2.sub(p1);\n\t\t\ttmp = tmp.mul(r1 / tmp.dist_o());\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis + EPS > r1 + r2) {\n\t\t\treturn new Point2D[0]; // out\n\t\t}\n\n\t\tdouble dis_m = Math.abs(r1 - r2);\n\n\t\tif (dis_m + EPS > dis && dis_m - EPS < dis) {\n\t\t\tPoint2D tmp = null;\n\t\t\tif (r1 > r2) {\n\t\t\t\ttmp = p2.sub(p1);\n\t\t\t} else {\n\t\t\t\ttmp = p1.sub(p2);\n\t\t\t}\n\n\t\t\tdouble min = Math.min(r1, r2);\n\n\t\t\ttmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis_m + EPS > dis) {\n\t\t\treturn new Point2D[0]; // inner\n\t\t} else {\n\t\t\tPoint2D ret[] = new Point2D[2];\n\n\t\t\tdouble theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n\t\t\t\t\t/ (2 * dis * r1));\n\t\t\tdouble a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n\n\t\t\tret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a + theta) + p1.y);\n\t\t\tret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a - theta) + p1.y);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n\t\t\tPoint2D ans[]) {\n\t\tif (c.pld(start, end) > r + EPS)\n\t\t\treturn;\n\t\tPoint2D v = end.sub(start).unit();\n\t\tdouble delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n\t\t\t\t- start.dist(c) * start.dist(c) + r * r;\n\t\tdouble t = -v.dot(start.sub(c));\n\t\tdouble s = Math.sqrt(delta);\n\t\tans[0] = start.add(v.mul(t + s));\n\t\tans[1] = start.add(v.mul(t + s));\n\t}\n\n\tpublic Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n\t\tPoint2D v = b.sub(a).unit();\n\t\tv = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n\t\t\t\t(-1) * v.y, v.x);\n\t\treturn v.mul(p.pld(a, b));\n\t}\n\n\tpublic double area(Point2D a, Point2D b, Point2D c) {\n\t\treturn Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Point2D> points = new LinkedList<Point2D>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tpoints.add(new Point2D(sc.nextDouble(), sc.nextDouble()));\n\t\t\t}\n\t\t\t\n\t\t\tint max = 1;\n\t\t\tfor(Point2D src : points){\n\t\t\t\tint count = 1;\n\t\t\t\t\n\t\t\t\tfor(Point2D dest : points){\n\t\t\t\t\tPoint2D[] circles = Point2D.cross_ss(src, 1.0, dest, 1.0);\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(Arrays.toString(circles));\n\t\t\t\t\t\n\t\t\t\t\tfor(Point2D circle : circles){\n\t\t\t\t\t\tint inner = 0;\n\t\t\t\t\t\tfor(Point2D elem : points){\n\t\t\t\t\t\t\tif(circle.dist(elem) < 1.0 + Point2D.EPS){\n\t\t\t\t\t\t\t\tinner++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tcount = Math.max(count, inner);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t\t\n\t}\n\n}\n\nclass Point2D {\n\tpublic double x;\n\tpublic double y;\n\n\tpublic static final double EPS = 1e-6;\n\n\tpublic Point2D(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tpublic Point2D(Point2D point) {\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t}\n\n\tpublic String toString() {\n\t\treturn x + \",\" + y;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (o instanceof Point2D) {\n\t\t\tPoint2D another = (Point2D) o;\n\t\t\tif (this.x - EPS < another.x && this.x + EPS > another.x\n\t\t\t\t\t&& this.y - EPS < another.y && this.y + EPS > another.y) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\n\t\t\t// return this.x == another.x && this.y == another.y;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic Point2D add(double x, double y) {\n\t\treturn new Point2D(this.x + x, this.y + y);\n\t}\n\n\tpublic Point2D sub(double x, double y) {\n\t\treturn add(-x, -y);\n\t}\n\n\tpublic Point2D add(Point2D another) {\n\t\treturn add(another.x, another.y);\n\t}\n\n\tpublic Point2D sub(Point2D another) {\n\t\treturn sub(another.x, another.y);\n\t}\n\n\tpublic Point2D mul(double d) {\n\t\treturn new Point2D(this.x * d, this.y * d);\n\t}\n\n\tpublic Point2D div(double d) {\n\t\treturn new Point2D(this.x / d, this.y / d);\n\t}\n\n\tpublic double dot(double x, double y) {\n\t\treturn this.x * x + this.y * y;\n\t}\n\n\tpublic double dot(Point2D another) {\n\t\treturn dot(another.x, another.y);\n\t}\n\n\tpublic double cross(double x, double y) {\n\t\treturn this.x * y - this.y * x;\n\t}\n\n\tpublic double cross(Point2D another) {\n\t\treturn cross(another.x, another.y);\n\t}\n\n\tpublic double dist(double x, double y) {\n\t\treturn Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n\t\t\t\t* (this.y - y));\n\t}\n\n\tpublic double dist(Point2D another) {\n\t\treturn dist(another.x, another.y);\n\t}\n\n\tpublic double dist_o() {\n\t\treturn dist(0, 0);\n\t}\n\n\tpublic Point2D unit() {\n\t\treturn div(dist_o());\n\t}\n\n\tpublic boolean pol(Point2D start, Point2D end) {\n\t\treturn end.sub(start).cross(this.sub(start)) < EPS;\n\t}\n\n\tpublic boolean pos(Point2D start, Point2D end) {\n\t\treturn (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n\t}\n\n\tpublic double pld(Point2D start, Point2D end) {\n\t\treturn Math.abs((end.sub(start).cross(this.sub(start)))\n\t\t\t\t/ end.sub(start).dist_o());\n\t}\n\n\tpublic double psd(Point2D start, Point2D end) {\n\t\tif (end.sub(start).dot(this.sub(start)) < EPS) {\n\t\t\treturn this.dist(start);\n\t\t} else if (start.sub(end).dot(this.sub(end)) < EPS) {\n\t\t\treturn this.dist(end);\n\t\t} else {\n\t\t\treturn end.sub(start).cross(this.sub(start)) / end.dist(start);\n\t\t}\n\t}\n\n\tpublic static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS)\n\t\t\t\t&& (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n\t}\n\n\tpublic static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn a1.sub(a2).cross(b1.sub(b2)) < EPS;\n\t}\n\n\tpublic static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble d1 = Math.abs(b.cross(a1.sub(b1)));\n\t\tdouble d2 = Math.abs(b.cross(a2.sub(b1)));\n\t\tdouble t = d1 / (d1 + d2);\n\t\tPoint2D a = a2.sub(a1), v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D a = a2.sub(a1);\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble t = b.cross(b1.sub(a1)) / b.cross(a);\n\t\tPoint2D v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n\t\t\tdouble r2) {\n\t\tdouble dis = p1.dist(p2);\n\n\t\tif (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n\t\t\treturn new Point2D[0]; // same\n\t\t}\n\n\t\tif (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n\t\t\tPoint2D tmp = p2.sub(p1);\n\t\t\ttmp = tmp.mul(r1 / tmp.dist_o());\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis + EPS > r1 + r2) {\n\t\t\treturn new Point2D[0]; // out\n\t\t}\n\n\t\tdouble dis_m = Math.abs(r1 - r2);\n\n\t\tif (dis_m + EPS > dis && dis_m - EPS < dis) {\n\t\t\tPoint2D tmp = null;\n\t\t\tif (r1 > r2) {\n\t\t\t\ttmp = p2.sub(p1);\n\t\t\t} else {\n\t\t\t\ttmp = p1.sub(p2);\n\t\t\t}\n\n\t\t\tdouble min = Math.min(r1, r2);\n\n\t\t\ttmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis_m + EPS > dis) {\n\t\t\treturn new Point2D[0]; // inner\n\t\t} else {\n\t\t\tPoint2D ret[] = new Point2D[2];\n\n\t\t\tdouble theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n\t\t\t\t\t/ (2 * dis * r1));\n\t\t\tdouble a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n\n\t\t\tret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a + theta) + p1.y);\n\t\t\tret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a - theta) + p1.y);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n\t\t\tPoint2D ans[]) {\n\t\tif (c.pld(start, end) > r + EPS)\n\t\t\treturn;\n\t\tPoint2D v = end.sub(start).unit();\n\t\tdouble delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n\t\t\t\t- start.dist(c) * start.dist(c) + r * r;\n\t\tdouble t = -v.dot(start.sub(c));\n\t\tdouble s = Math.sqrt(delta);\n\t\tans[0] = start.add(v.mul(t + s));\n\t\tans[1] = start.add(v.mul(t + s));\n\t}\n\n\tpublic Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n\t\tPoint2D v = b.sub(a).unit();\n\t\tv = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n\t\t\t\t(-1) * v.y, v.x);\n\t\treturn v.mul(p.pld(a, b));\n\t}\n\n\tpublic double area(Point2D a, Point2D b, Point2D c) {\n\t\treturn Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)) {\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tdouble[] x=new double[n+1];\n\t\t\t\tdouble[] y=new double[n+1];\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tx[i]=sc.nextDouble();\n\t\t\t\t\ty[i]=sc.nextDouble();\n\t\t\t\t}\n\t\t\t\tint count=0;\n\t\t\t\tint max=1;\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tfor(int j=i+1; j<n; j++) {\n\t\t\t\t\t\tdouble d=Math.sqrt((x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i]));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(d<=2.0000) {\n\t\t\t\t\t\t\tdouble cx=(x[i]+x[j])/2.0;//2点の真ん中\n\t\t\t\t\t\t\tdouble cy=(y[i]+y[j])/2.0;\n\t\t\t\t\t\t\tdouble vx=(y[j]-y[i])/d;//法線ベクトルの単位ベクトル\n\t\t\t\t\t\t\tdouble vy=-((x[j]-x[i])/d);\n\t\t\t\t\t\t\tdouble e=Math.sqrt(1.0-d*d/4.0);//交点cx,cyから中心までの距離\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tdouble px=cx+e*vx;//中心座標(円1) \n\t\t\t\t\t\t\tdouble py=cy+e*vy;\n\t\t\t\t\t\t\tfor(int k=0; k<n; k++) {\n\t\t\t\t\t\t\t\tif(k==i || k==j || Math.sqrt((x[k]-px)*(x[k]-px)+(y[k]-py)*(y[k]-py))<=1.0000) {\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmax=Math.max(count, max);\n\t\t\t\t\t\t\tcount=0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tpx=cx-e*vx;//(円2)\n\t\t\t\t\t\t\tpy=cy-e*vy;\n\t\t\t\t\t\t\tfor(int k=0; k<n; k++) {\n\t\t\t\t\t\t\t\tif(k==i || k==j || Math.sqrt((x[k]-px)*(x[k]-px)+(y[k]-py)*(y[k]-py))<=1.0000) {\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmax=Math.max(count, max);\n\t\t\t\t\t\t\tcount=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(max);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D[] points = new Point2D[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tpoints[i] = new Point2D(sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tint max = 0;\n\t\t\t\n\t\t\tfor(int fst = 0; fst < n; fst++){\n\t\t\t\tfor(int snd = fst + 1; snd < n; snd++){\n\t\t\t\t\tPoint2D[] cross = Point2D.cross_ss(points[fst], 1, points[snd], 1);\n\t\t\t\t\t\n\t\t\t\t\tif(cross.length < 2){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tPoint2D center = new Point2D((cross[0].x + cross[1].x) / 2, (cross[0].y + cross[1].y) / 2);\n\t\t\t\t\t\n\t\t\t\t\t//double diff = center.dist(cross[0]);\n\t\t\t\t\t\n\t\t\t\t\t//double length = Math.sqrt(1 - diff * diff);\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(diff + \" \" + length);\n\t\t\t\t\t\n\t\t\t\t\tPoint2D cir1 = cross[0];//center.add(cross[0].sub(center).unit().mul(length));\n\t\t\t\t\tPoint2D cir2 = cross[1];//center.add(cross[1].sub(center).unit().mul(length));\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(cir1.dist(points[fst]) + \" \" + cir1.dist(points[snd]));\n\t\t\t\t\t//System.out.println(cir2.dist(points[fst]) + \" \" + cir2.dist(points[snd]));\n\t\t\t\t\t//System.out.println(diff + \" \" + length + \" \" + cross[0].dist(points[fst]) + \" \" + cross[1].dist(points[fst]));\n\t\t\t\t\t//System.out.println(\"----------------------------------------------------\");\n\t\t\t\t\t//System.out.println(cross[0] + \" \" + cross[1] + \" \" + center + \" \" + diff + \" \" + cir1 + \" \" + cir2);\n\t\t\t\t\t\n\t\t\t\t\tint count_1 = 0, count_2 = 0;\n\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\tif(cir1.dist(points[i]) <= 1.0 + Point2D.EPS){\n\t\t\t\t\t\t\tcount_1++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(cir2.dist(points[i]) <= 1.0 + Point2D.EPS){\n\t\t\t\t\t\t\tcount_2++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmax = Math.max(max, count_1);\n\t\t\t\t\tmax = Math.max(max, count_2);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t\t\n\t}\n}\n\nclass Point2D {\n    public double x;\n    public double y;\n \n    public static final double EPS = 1e-4;\n \n    public Point2D(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n \n    public Point2D(Point2D point) {\n        this.x = point.x;\n        this.y = point.y;\n    }\n \n    public String toString() {\n        return x + \",\" + y;\n    }\n \n    @Override\n    public boolean equals(Object o) {\n        if (o instanceof Point2D) {\n            Point2D another = (Point2D) o;\n            if (this.x - EPS < another.x && this.x + EPS > another.x\n                    && this.y - EPS < another.y && this.y + EPS > another.y) {\n                return true;\n            }\n             \n            return false;\n \n            // return this.x == another.x && this.y == another.y;\n        }\n        return false;\n    }\n \n    public Point2D add(double x, double y) {\n        return new Point2D(this.x + x, this.y + y);\n    }\n \n    public Point2D sub(double x, double y) {\n        return add(-x, -y);\n    }\n \n    public Point2D add(Point2D another) {\n        return add(another.x, another.y);\n    }\n \n    public Point2D sub(Point2D another) {\n        return sub(another.x, another.y);\n    }\n \n    public Point2D mul(double d) {\n        return new Point2D(this.x * d, this.y * d);\n    }\n \n    public Point2D div(double d) {\n        return new Point2D(this.x / d, this.y / d);\n    }\n \n    public double dot(double x, double y) {\n        return this.x * x + this.y * y;\n    }\n \n    public double dot(Point2D another) {\n        return dot(another.x, another.y);\n    }\n \n    public double cross(double x, double y) {\n        return this.x * y - this.y * x;\n    }\n \n    public double cross(Point2D another) {\n        return cross(another.x, another.y);\n    }\n \n    public double dist(double x, double y) {\n        return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n                * (this.y - y));\n    }\n \n    public double dist(Point2D another) {\n        return dist(another.x, another.y);\n    }\n \n    public double dist_o() {\n        return dist(0, 0);\n    }\n \n    public Point2D unit() {\n        return div(dist_o());\n    }\n \n    public boolean pol(Point2D start, Point2D end) {\n        return end.sub(start).cross(this.sub(start)) < EPS;\n    }\n \n    public boolean pos(Point2D start, Point2D end) {\n        return (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n    }\n \n    public double pld(Point2D start, Point2D end) {\n        return Math.abs((end.sub(start).cross(this.sub(start)))\n                / end.sub(start).dist_o());\n    }\n \n    public double psd(Point2D start, Point2D end) {\n        if (end.sub(start).dot(this.sub(start)) < EPS) {\n            return this.dist(start);\n        } else if (start.sub(end).dot(this.sub(end)) < EPS) {\n            return this.dist(end);\n        } else {\n            return end.sub(start).cross(this.sub(start)) / end.dist(start);\n        }\n    }\n \n    public static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS)\n                && (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n    }\n \n    public static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return a1.sub(a2).cross(b1.sub(b2)) < EPS;\n    }\n \n    public static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D b = b2.sub(b1);\n        double d1 = Math.abs(b.cross(a1.sub(b1)));\n        double d2 = Math.abs(b.cross(a2.sub(b1)));\n        double t = d1 / (d1 + d2);\n        Point2D a = a2.sub(a1), v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D a = a2.sub(a1);\n        Point2D b = b2.sub(b1);\n        double t = b.cross(b1.sub(a1)) / b.cross(a);\n        Point2D v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n            double r2) {\n        double dis = p1.dist(p2);\n \n        if (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n            return new Point2D[0]; // same\n        }\n \n        if (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n            Point2D tmp = p2.sub(p1);\n            tmp = tmp.mul(r1 / tmp.dist_o());\n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis + EPS > r1 + r2) {\n            return new Point2D[0]; // out\n        }\n \n        double dis_m = Math.abs(r1 - r2);\n \n        if (dis_m + EPS > dis && dis_m - EPS < dis) {\n            Point2D tmp = null;\n            if (r1 > r2) {\n                tmp = p2.sub(p1);\n            } else {\n                tmp = p1.sub(p2);\n            }\n \n            double min = Math.min(r1, r2);\n \n            tmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n \n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis_m + EPS > dis) {\n            return new Point2D[0]; // inner\n        } else {\n            Point2D ret[] = new Point2D[2];\n \n            double theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n                    / (2 * dis * r1));\n            double a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n \n            ret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n                    * Math.sin(a + theta) + p1.y);\n            ret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n                    * Math.sin(a - theta) + p1.y);\n            return ret;\n        }\n    }\n \n    public void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n            Point2D ans[]) {\n        if (c.pld(start, end) > r + EPS)\n            return;\n        Point2D v = end.sub(start).unit();\n        double delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n                - start.dist(c) * start.dist(c) + r * r;\n        double t = -v.dot(start.sub(c));\n        double s = Math.sqrt(delta);\n        ans[0] = start.add(v.mul(t + s));\n        ans[1] = start.add(v.mul(t + s));\n    }\n \n    public Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n        Point2D v = b.sub(a).unit();\n        v = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n                (-1) * v.y, v.x);\n        return v.mul(p.pld(a, b));\n    }\n \n    public double area(Point2D a, Point2D b, Point2D c) {\n        return Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)) {\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tif(n==0) break;\n\t\t\t\tdouble[] x=new double[n+1];\n\t\t\t\tdouble[] y=new double[n+1];\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tx[i]=sc.nextDouble();\n\t\t\t\t\ty[i]=sc.nextDouble();\n\t\t\t\t}\n\t\t\t\tint count=0;\n\t\t\t\tint max=1;\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tfor(int j=i+1; j<n; j++) {\n\t\t\t\t\t\tdouble d=Math.sqrt((x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i]));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(d<=2.0) {\n\t\t\t\t\t\t\tdouble cx=(x[i]+x[j])/2.0;//2点の真ん中\n\t\t\t\t\t\t\tdouble cy=(y[i]+y[j])/2.0;\n\t\t\t\t\t\t\tdouble vx=(y[j]-y[i])/d;//法線ベクトルの単位ベクトル\n\t\t\t\t\t\t\tdouble vy=-((x[j]-x[i])/d);\n\t\t\t\t\t\t\tdouble e=Math.sqrt(1.0-d*d/4.0);//交点cx,cyから中心までの距離\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tdouble px=cx+e*vx;//中心座標(円1) \n\t\t\t\t\t\t\tdouble py=cy+e*vy;\n\t\t\t\t\t\t\tfor(int k=0; k<n; k++) {\n\t\t\t\t\t\t\t\tif(k==i || k==j || Math.sqrt((x[k]-px)*(x[k]-px)+(y[k]-py)*(y[k]-py))<=1.0) {\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmax=Math.max(count, max);\n\t\t\t\t\t\t\tcount=0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tpx=cx-e*vx;//(円2)\n\t\t\t\t\t\t\tpy=cy-e*vy;\n\t\t\t\t\t\t\tfor(int k=0; k<n; k++) {\n\t\t\t\t\t\t\t\tif(k==i || k==j || Math.sqrt((x[k]-px)*(x[k]-px)+(y[k]-py)*(y[k]-py))<=1.0000) {\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmax=Math.max(count, max);\n\t\t\t\t\t\t\tcount=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(max);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tnew Main().calc();\n\t}\n\n\tdouble[] x;\n\tdouble[] y;\n\tint n;\n\tboolean[][][] memo;\n\tvoid calc(){\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = cin.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tx = new double[n];\n\t\t\ty = new double[n];\n\t\t\tmemo = new boolean[n][n][n];\n\t\t\tint i,j,k;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tx[i] = cin.nextDouble();\n\t\t\t\ty[i] = cin.nextDouble();\n\t\t\t}\n\t\t\tint ret = 0;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tret = Math.max(ret, getmax(new int[]{i}));\n\t\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\t\tif(memo[i][i][j]) continue;\n\t\t\t\t\tif(Math.hypot(x[i]-x[j], y[i]-y[j]) > 2) continue;\n\t\t\t\t\tret = Math.max(ret, getmax(new int[]{i,j}));\n\t\t\t\t\tfor(k=j+1;k<n;k++){\n\t\t\t\t\t\tif(Math.hypot(x[i]-x[k], y[i]-y[k]) > 2) continue;\n\t\t\t\t\t\tif(Math.hypot(x[k]-x[j], y[k]-y[j]) > 2) continue;\n\t\t\t\t\t\tif(memo[i][j][k]) continue;\n\t\t\t\t\t\tret = Math.max(ret, getmax(new int[]{i,j}));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ret);\n\t\t}\n\t}\n\n\tint getmax(int[] nums){\n\t\tdouble nx = 0;\n\t\tdouble ny = 0;\n\t\tfor(int a : nums){\n\t\t\tnx += x[a]/nums.length;\n\t\t\tny += y[a]/nums.length;\n\t\t}\n\t\tdouble move = 0.7;\n\t\tfor(int i=0;i<20;i++){\n\t\t\tdouble maxdist = 0;\n\t\t\tint num = 0;\n\t\t\tfor(int a :nums){\n\t\t\t\tdouble dist = Math.hypot(nx-x[a], ny-y[a]);\n\t\t\t\tif(maxdist<dist){\n\t\t\t\t\tmaxdist = dist;\n\t\t\t\t\tnum = a;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(maxdist<1) break;\n\t\t\tnx += (x[num]-nx)*move;\n\t\t\tny += (y[num]-ny)*move;\n\t\t\tmove *= 0.7;\n\t\t}\n\t\treturn getnum(nx,ny);\n\t}\n\n\tint getnum(double nx, double ny){\n\t\tint ret = 0;\n\t\tList<Integer> l = new LinkedList<Integer>();\n\t\tfor(int i = 0;i <n;i++){\n\t\t\tif(Math.hypot(nx-x[i], ny-y[i])<=1){\n\t\t\t\tfor(int a : l)for(int b : l) memo[a][b][i] = true;\n\t\t\t\tl.add(i);\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.io.*;\nimport java.util.Arrays;\nimport java.util.StringJoiner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static int N;\n    static double[] X, Y;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        while(true) {\n            N = sc.nextInt();\n            if( N == 0 ) break;\n\n            X = new double[N];\n            Y = new double[N];\n            for (int i = 0; i < N; i++) {\n                X[i] = Double.parseDouble(sc.next());\n                Y[i] = Double.parseDouble(sc.next());\n            }\n            pw.println(solve());\n        }\n        pw.flush();\n    }\n\n    static int solve() {\n        int ans = 1;\n        for (int i = 0; i < N-1; i++) {\n            for (int j = i+1; j < N; j++) {\n\n                double dx = X[i] - X[j];\n                double dy = Y[i] - Y[j];\n                double dd = dx * dx + dy * dy;\n                if( dd > 4 ) continue;\n\n                double d = Math.sqrt(dd);\n                double hd = d/2;\n                double e = Math.sqrt(1 - hd*hd); // e^2 + hd^2 = 1\n\n                double mx = (X[i] + X[j]) / 2;\n                double my = (Y[i] + Y[j]) / 2;\n                {\n                    // 垂直なベクトル / 長さ(d) * 長さ(e)\n                    double px = -dy / d * e;\n                    double py = dx / d * e;\n                    double cx = mx + px;\n                    double cy = my + py;\n                    ans = Math.max(ans, count(cx, cy));\n                }\n                {\n                    double px = dy / d * e;\n                    double py = -dx / d * e;\n                    double cx = mx + px;\n                    double cy = my + py;\n                    ans = Math.max(ans, count(cx, cy));\n                }\n            }\n        }\n        return ans;\n    }\n\n    static int count(double x, double y) {\n        int ret = 0;\n        for (int i = 0; i < N; i++) {\n            double d = Point2D.distance(x, y, X[i], Y[i]);\n            if( d < 1.0 || Math.abs(d - 1.0) < EPS) ret++;\n        }\n        return ret;\n    }\n\n    static double EPS = 1e-9;\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeSingleLine(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(as[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg == null) j.add(\"null\");\n            else if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n\n    static void printSingleLine(int[] array) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < array.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(array[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int lowerBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] < value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n\n    static int upperBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] <= value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tfinal double EPS = 1.0e-08;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdouble [] x = new double[n];\n\t\t\tdouble [] y = new double[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t}\n\t\t\tint ans = 1;\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tfor(int j=i+1; j < n; j++){\n\t\t\t\t\tdouble midx = (x[i] + x[j]) / 2.0;\n\t\t\t\t\tdouble midy = (y[i] + y[j]) / 2.0;\n\t\t\t\t\tdouble halfdis = Point2D.distance(x[i], y[i], x[j], y[j]) / 2;\n\t\t\t\t\tif(halfdis > 1.0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble midxV = x[i] - midx;\n\t\t\t\t\tdouble midyV = y[i] - midy;\n\t\t\t\t\tdouble tocenterDis = Math.sqrt(1.0 - halfdis * halfdis);\n\t\t\t\t\tfor(int k=0; k <= 1;k++){\n\t\t\t\t\t\tdouble midxV2, midyV2;\n\t\t\t\t\t\tif(k==0){\n\t\t\t\t\t\t\tmidxV2 = midyV * -1;\n\t\t\t\t\t\t\tmidyV2 = midxV;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tmidxV2 = midyV;\n\t\t\t\t\t\t\tmidyV2 = midxV * -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdouble cx = (midxV2) * tocenterDis + midx;\n\t\t\t\t\t\tdouble cy = (midyV2) * tocenterDis + midy;\n\t\t\t\t\t\tint res = getCount(cx,cy,x,y);\n\t\t\t\t\t\tans = Math.max(ans, res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate int getCount(double cx, double cy, double[] x, double[] y) {\n\t\tint count = 0;\n\t\tfor(int i=0; i < x.length;i++){\n\t\t\tdouble res = Point2D.distance(cx, cy, x[i], y[i]);\n\t\t\tif(res <= 1.0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tP[] ps;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\tps = new P[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tps[i] = new P(sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\tint cnt_max = 1;\n\t\t\tint cnt = 0;\n\t\t\tfor(int i=0;i<n-1;i++) for(int j=i+1;j<n;j++) {\n\t\t\t\t\n\t\t\t\tif( sqrt(dis( ps[i], ps[j] )) < 2.0 ) {\n\t\t\t\t\tP m = new P( (ps[i].x+ps[j].x)/2, (ps[i].y+ps[j].y)/2);\n\t\t\t\t\tdouble d = sqrt(1-dis(ps[i], m ));\n\t\t\t\t\tP dp = new P((ps[i].y-ps[j].y), -(ps[i].x-ps[j].x));\n\t\t\t\t\tdp.nom();\n\t\t\t\t\tdp.mult(d);\n\t\t\t\t\tP c[] = new P[2];\n\t\t\t\t\tc[0] = m.add(dp);\n\t\t\t\t\tdp.mult(-1.0);\n\t\t\t\t\tc[1] = m.add(dp);\n\t\t\t\t\tfor(int l=0;l<2;l++) {\n\t\t\t\t\t\tcnt = 0;\n//\t\t\t\t\t\tLinkedList<Double> dist = new LinkedList<Double>();\n//\t\t\t\t\t\tLinkedList<Integer> ind = new LinkedList<Integer>();\n\t\t\t\t\t\tfor(int k=0;k<n;k++) {\n//\t\t\t\t\t\t\tdebug(dis(c[l], ps[k]));\n\t\t\t\t\t\t\tif(sqrt(dis(c[l], ps[k])) < 1.0 || k==i||k==j) {\n//\t\t\t\t\t\t\t\tdist.add(dis(c[l], ps[k]));\n//\t\t\t\t\t\t\t\tind.add(k);\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tdebug(dis( ps[i], ps[j] ), cnt_max, cnt);\n\t\t\t\t\t\tcnt_max = max(cnt_max, cnt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt_max);\n\t\t}\n\t}\n\t\n\tdouble dis( P p1, P p2 ) {\n\t\treturn (p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\t\n\tclass P {\n\t\tdouble x, y;\n\t\tP (double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tvoid nom() {\n\t\t\tdouble nom = sqrt(x*x + y*y);\n\t\t\tx /= nom;\n\t\t\ty /= nom;\n\t\t}\n\t\tP add(P p) {\n\t\t\tx += p.x;\n\t\t\ty += p.y;\n\t\t\treturn new P(x, y);\n\t\t}\n\t\tP mult(double d) {\n\t\t\tx *= d;\n\t\t\ty *= d;\n\t\t\treturn new P(x, y);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(in.hasNext())new AOJ1134().doIt();\n\t}\n\n\tclass AOJ1134{\n\t\tfinal double EPS=1.0e-8;\n\t\tPoint2D[] intersectPtCC(Circle a,Circle b){\n\t\t\tdouble dis = a.p.distance(b.p);\n\t\t\tif(dis > a.r+b.r) return null;\n\t\t\tPoint2D v = sub(b.p, a.p);\n\t\t\tdouble rc = (dis*dis + a.r*a.r - b.r*b.r)/(2*dis); \n\t\t\tdouble rate = rc/dis;\n\t\t\tv = mul(rate, v);\n\t\t\tPoint2D c = add(v, a.p);\n\t\t\tdouble disC2c = c.distance(b.p);\n\t\t\tdouble disqc = Math.sqrt(b.r*b.r - disC2c*disC2c);\n\t\t\tPoint2D v2 = sub(b.p, c);\n\t\t\tv2 = mul(disqc/disC2c, v2);\n\t\t\tPoint2D[] ret = new Point2D.Double[2];\n\t\t\tret[0] = add(normalVector1(v2), c);\n\t\t\tret[1] = add(normalVector2(v2), c);\n\t\t\treturn ret;\n\t\t}\n\n\t\tPoint2D add(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()+p2.getX(), p1.getY()+p2.getY());\n\t\t}\n\t\t\n\t\tPoint2D normalVector1(Point2D p){\n\t\t\treturn new Point2D.Double(-p.getY(), p.getX());\n\t\t}\n\t\tPoint2D normalVector2(Point2D p){\n\t\t\treturn new Point2D.Double(p.getY(), -p.getX());\n\t\t}\n\t\t\n\t\tPoint2D mul(double n,Point2D p1){\n\t\t\treturn new Point2D.Double(p1.getX()*n,p1.getY()*n);\n\t\t}\n\n\t\tPoint2D sub(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n\t\t}\n\n\t\tclass Circle{\n\t\t\tPoint2D p;\n\t\t\tdouble r;\n\t\t\tCircle(Point2D p,double r){ \n\t\t\t\tthis.p=p;\n\t\t\t\tthis.r=r;\n\t\t\t}\n\t\t\tCircle(double x,double y,double r){  \n\t\t\t\tthis.p=new Point2D.Double(x,y); \n\t\t\t\tthis.r=r;\n\t\t\t}\n\t\t}\n\n\t\tvoid doIt(){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n==0)return;\n\t\t\tPoint2D[] p = new Point2D[n];\n\t\t\tfor(int i=0;i<n;i++)p[i] = new Point2D.Double(in.nextDouble(),in.nextDouble());\n\t\t\tint result = 1;\n\t\t\tfor(int i=0;i<n;i++)for(int s=0;s<n;s++)if(i!=s)if(p[i].distance(p[s])<=2){\n\t\t\t\tPoint2D[] k = intersectPtCC(new Circle(p[i], 1+EPS), new Circle(p[s], 1+EPS));\n\t\t\t\tfor(int a=0;a<k.length;a++){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor(int b=0;b<n;b++)if(k[a].distance(p[b])<=1+EPS)cnt++;\n\t\t\t\t\tresult = Math.max(result, cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tnew Main().calc();\n\t}\n\n\tdouble[] x;\n\tdouble[] y;\n\tint n;\n\tvoid calc(){\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = cin.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tx = new double[n];\n\t\t\ty = new double[n];\n\t\t\tint i,j;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tx[i] = cin.nextDouble();\n\t\t\t\ty[i] = cin.nextDouble();\n\t\t\t}\n\t\t\tint ret = 0;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tret = Math.max(ret, getnum(x[i],y[i]));\n\t\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\t\tif(Math.hypot(x[i]-x[j], y[i]-y[j]) > 2) continue;\n\t\t\t\t\tret = Math.max(ret, getmax(new int[]{i,j}));\n\t\t\t\t\tret = Math.max(ret, getmax(new int[]{j,i}));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ret);\n\t\t}\n\t}\n\n\tint getmax(int[] nums){\n\t\tdouble nx = 0;\n\t\tdouble ny = 0;\n\t\tfor(int a : nums){\n\t\t\tnx += x[a]/nums.length;\n\t\t\tny += y[a]/nums.length;\n\t\t}\n\t\tdouble vx = nx-x[nums[0]];\n\t\tdouble vy = ny-y[nums[0]];\n\t\tdouble d = Math.hypot(vx, vy);\n\t\tdouble nokori = 1-d;\n\t\tnx += vy / Math.hypot(vx, vy) * nokori;\n\t\tny -= vx / Math.hypot(vx, vy) * nokori;\n\t\treturn getnum(nx,ny);\n\t}\n\n\tint getnum(double nx, double ny){\n\t\tint ret = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif((nx-x[i])*(nx-x[i])+ (ny-y[i]) * (ny-y[i])<=1) ret++;\n\t\t}\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tfinal double EPS = 1.0e-08;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdouble [] x = new double[n];\n\t\t\tdouble [] y = new double[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t}\n\t\t\tint ans = 1;\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tfor(int j=i+1; j < n; j++){\n\t\t\t\t\tdouble midx = (x[i] + x[j]) / 2.0;\n\t\t\t\t\tdouble midy = (y[i] + y[j]) / 2.0;\n\t\t\t\t\tdouble halfdis = Point2D.distance(x[i], y[i], x[j], y[j]) / 2;\n\t\t\t\t\tif(halfdis> 1.0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble midxV = x[i] - midx;\n\t\t\t\t\tdouble midyV = y[i] - midy;\n\t\t\t\t\tdouble tocenterDis = Math.sqrt(1.0 - halfdis * halfdis);\n\t\t\t\t\tfor(int k=0; k <= 1;k++){\n\t\t\t\t\t\tdouble midxV2, midyV2;\n\t\t\t\t\t\tif(k==0){\n\t\t\t\t\t\t\tmidxV2 = midyV * -1;\n\t\t\t\t\t\t\tmidyV2 = midxV;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tmidxV2 = midyV;\n\t\t\t\t\t\t\tmidyV2 = midxV * -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdouble dis2 = Math.sqrt(midxV2 * midxV2 + midyV2 * midyV2);\n\t\t\t\t\t\tdouble cx = (midxV2) * tocenterDis / dis2 + midx;\n\t\t\t\t\t\tdouble cy = (midyV2) * tocenterDis / dis2 + midy;\n\t\t\t\t\t\tint res = getCount(cx,cy,x,y);\n\t\t\t\t\t\tans = Math.max(ans, res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate int getCount(double cx, double cy, double[] x, double[] y) {\n\t\tint count = 0;\n\t\tfor(int i=0; i < x.length;i++){\n\t\t\tdouble res = Point2D.distance(cx, cy, x[i], y[i]);\n\t\t\tif(res<= 1.0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D[] points = new Point2D[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tpoints[i] = new Point2D(sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tint max = 0;\n\t\t\t\n\t\t\tfor(int fst = 0; fst < n; fst++){\n\t\t\t\tfor(int snd = fst + 1; snd < n; snd++){\n\t\t\t\t\tPoint2D[] cross = Point2D.cross_ss(points[fst], 1, points[snd], 1);\n\t\t\t\t\t\n\t\t\t\t\tif(cross.length < 2){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tPoint2D center = new Point2D((cross[0].x + cross[1].x) / 2, (cross[0].y + cross[1].y) / 2);\n\t\t\t\t\t\n\t\t\t\t\tPoint2D diff = center.sub(cross[0]).unit();\n\t\t\t\t\t\n\t\t\t\t\tdouble length = Math.cos(Math.asin(cross[0].dist(center)));\n\t\t\t\t\t\n\t\t\t\t\tPoint2D cir1 = cross[0];\n\t\t\t\t\tPoint2D cir2 = cross[1];\n\t\t\t\t\t\n\t\t\t\t\t//S//ystem.out.println(cir1.dist(points[fst]) + \" \" + cir1.dist(points[snd]));\n\t\t\t\t\t//System.out.println(cir2.dist(points[fst]) + \" \" + cir2.dist(points[snd]));\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(cross[0] + \" \" + cross[1] + \" \" + center + \" \" + diff + \" \" + cir1 + \" \" + cir2);\n\t\t\t\t\t\n\t\t\t\t\tint count_1 = 0, count_2 = 0;\n\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\tif(cir1.dist(points[i]) <= 1.0 + Point2D.EPS){\n\t\t\t\t\t\t\tcount_1++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(cir2.dist(points[i]) <= 1.0 + Point2D.EPS){\n\t\t\t\t\t\t\tcount_2++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmax = Math.max(max, count_1);\n\t\t\t\t\tmax = Math.max(max, count_2);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t\t\n\t}\n}\n\nclass Point2D {\n    public double x;\n    public double y;\n \n    public static final double EPS = 1e-4;\n \n    public Point2D(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n \n    public Point2D(Point2D point) {\n        this.x = point.x;\n        this.y = point.y;\n    }\n \n    public String toString() {\n        return x + \",\" + y;\n    }\n \n    @Override\n    public boolean equals(Object o) {\n        if (o instanceof Point2D) {\n            Point2D another = (Point2D) o;\n            if (this.x - EPS < another.x && this.x + EPS > another.x\n                    && this.y - EPS < another.y && this.y + EPS > another.y) {\n                return true;\n            }\n             \n            return false;\n \n            // return this.x == another.x && this.y == another.y;\n        }\n        return false;\n    }\n \n    public Point2D add(double x, double y) {\n        return new Point2D(this.x + x, this.y + y);\n    }\n \n    public Point2D sub(double x, double y) {\n        return add(-x, -y);\n    }\n \n    public Point2D add(Point2D another) {\n        return add(another.x, another.y);\n    }\n \n    public Point2D sub(Point2D another) {\n        return sub(another.x, another.y);\n    }\n \n    public Point2D mul(double d) {\n        return new Point2D(this.x * d, this.y * d);\n    }\n \n    public Point2D div(double d) {\n        return new Point2D(this.x / d, this.y / d);\n    }\n \n    public double dot(double x, double y) {\n        return this.x * x + this.y * y;\n    }\n \n    public double dot(Point2D another) {\n        return dot(another.x, another.y);\n    }\n \n    public double cross(double x, double y) {\n        return this.x * y - this.y * x;\n    }\n \n    public double cross(Point2D another) {\n        return cross(another.x, another.y);\n    }\n \n    public double dist(double x, double y) {\n        return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n                * (this.y - y));\n    }\n \n    public double dist(Point2D another) {\n        return dist(another.x, another.y);\n    }\n \n    public double dist_o() {\n        return dist(0, 0);\n    }\n \n    public Point2D unit() {\n        return div(dist_o());\n    }\n \n    public boolean pol(Point2D start, Point2D end) {\n        return end.sub(start).cross(this.sub(start)) < EPS;\n    }\n \n    public boolean pos(Point2D start, Point2D end) {\n        return (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n    }\n \n    public double pld(Point2D start, Point2D end) {\n        return Math.abs((end.sub(start).cross(this.sub(start)))\n                / end.sub(start).dist_o());\n    }\n \n    public double psd(Point2D start, Point2D end) {\n        if (end.sub(start).dot(this.sub(start)) < EPS) {\n            return this.dist(start);\n        } else if (start.sub(end).dot(this.sub(end)) < EPS) {\n            return this.dist(end);\n        } else {\n            return end.sub(start).cross(this.sub(start)) / end.dist(start);\n        }\n    }\n \n    public static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS)\n                && (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n    }\n \n    public static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return a1.sub(a2).cross(b1.sub(b2)) < EPS;\n    }\n \n    public static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D b = b2.sub(b1);\n        double d1 = Math.abs(b.cross(a1.sub(b1)));\n        double d2 = Math.abs(b.cross(a2.sub(b1)));\n        double t = d1 / (d1 + d2);\n        Point2D a = a2.sub(a1), v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D a = a2.sub(a1);\n        Point2D b = b2.sub(b1);\n        double t = b.cross(b1.sub(a1)) / b.cross(a);\n        Point2D v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n            double r2) {\n        double dis = p1.dist(p2);\n \n        if (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n            return new Point2D[0]; // same\n        }\n \n        if (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n            Point2D tmp = p2.sub(p1);\n            tmp = tmp.mul(r1 / tmp.dist_o());\n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis + EPS > r1 + r2) {\n            return new Point2D[0]; // out\n        }\n \n        double dis_m = Math.abs(r1 - r2);\n \n        if (dis_m + EPS > dis && dis_m - EPS < dis) {\n            Point2D tmp = null;\n            if (r1 > r2) {\n                tmp = p2.sub(p1);\n            } else {\n                tmp = p1.sub(p2);\n            }\n \n            double min = Math.min(r1, r2);\n \n            tmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n \n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis_m + EPS > dis) {\n            return new Point2D[0]; // inner\n        } else {\n            Point2D ret[] = new Point2D[2];\n \n            double theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n                    / (2 * dis * r1));\n            double a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n \n            ret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n                    * Math.sin(a + theta) + p1.y);\n            ret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n                    * Math.sin(a - theta) + p1.y);\n            return ret;\n        }\n    }\n \n    public void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n            Point2D ans[]) {\n        if (c.pld(start, end) > r + EPS)\n            return;\n        Point2D v = end.sub(start).unit();\n        double delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n                - start.dist(c) * start.dist(c) + r * r;\n        double t = -v.dot(start.sub(c));\n        double s = Math.sqrt(delta);\n        ans[0] = start.add(v.mul(t + s));\n        ans[1] = start.add(v.mul(t + s));\n    }\n \n    public Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n        Point2D v = b.sub(a).unit();\n        v = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n                (-1) * v.y, v.x);\n        return v.mul(p.pld(a, b));\n    }\n \n    public double area(Point2D a, Point2D b, Point2D c) {\n        return Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tnew Main().calc();\n\t}\n\n\tdouble[] x;\n\tdouble[] y;\n\tint n;\n\tvoid calc(){\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = cin.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tx = new double[n];\n\t\t\ty = new double[n];\n\t\t\tint i,j;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tx[i] = cin.nextDouble();\n\t\t\t\ty[i] = cin.nextDouble();\n\t\t\t}\n\t\t\tint ret = 0;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tret = Math.max(ret, getnum(x[i],y[i]));\n\t\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\t\tif(Math.hypot(x[i]-x[j], y[i]-y[j]) > 2) continue;\n\t\t\t\t\tret = Math.max(ret, getmax(new int[]{i,j}));\n\t\t\t\t\tret = Math.max(ret, getmax(new int[]{j,i}));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ret);\n\t\t}\n\t}\n\n\tint getmax(int[] nums){\n\t\tdouble nx = 0;\n\t\tdouble ny = 0;\n\t\tfor(int a : nums){\n\t\t\tnx += x[a]/nums.length;\n\t\t\tny += y[a]/nums.length;\n\t\t}\n\t\tdouble vx = nx-x[nums[0]];\n\t\tdouble vy = ny-y[nums[0]];\n\t\tdouble d = Math.hypot(vx, vy);\n\t\tdouble nokori = Math.sqrt(1-d*d);\n\t\tvx/=d; vy/=d;\n\t\tnx += vy * nokori;\n\t\tny -= vx * nokori;\n\t\treturn getnum(nx,ny);\n\t}\n\n\tint getnum(double nx, double ny){\n\t\tint ret = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif((nx-x[i])*(nx-x[i])+ (ny-y[i]) * (ny-y[i])<=1+1e-6) ret++;\n\t\t}\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(in.hasNext())new AOJ1134().doIt();\n\t}\n\n\tclass AOJ1134{\n\t\tfinal double EPS=1.0e-8;\n\t\tPoint2D[] intersectPtCC(Circle a,Circle b){\n\t\t\tdouble dis = a.p.distance(b.p);\n\t\t\tif(dis > a.r+b.r) return null;\n\t\t\tPoint2D v = sub(b.p, a.p);\n\t\t\tdouble rc = (dis*dis + a.r*a.r - b.r*b.r)/(2*dis); \n\t\t\tdouble rate = rc/dis;\n\t\t\tv = mul(rate, v);\n\t\t\tPoint2D c = add(v, a.p);\n\t\t\tdouble disC2c = c.distance(b.p);\n\t\t\tdouble disqc = Math.sqrt(b.r*b.r - disC2c*disC2c);\n\t\t\tPoint2D v2 = sub(b.p, c);\n\t\t\tv2 = mul(disqc/disC2c, v2);\n\t\t\tPoint2D[] ret = new Point2D.Double[2];\n\t\t\tret[0] = add(normalVector1(v2), c);\n\t\t\tret[1] = add(normalVector2(v2), c);\n\t\t\treturn ret;\n\t\t}\n\n\t\tPoint2D add(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()+p2.getX(), p1.getY()+p2.getY());\n\t\t}\n\t\t\n\t\tPoint2D normalVector1(Point2D p){\n\t\t\treturn new Point2D.Double(-p.getY(), p.getX());\n\t\t}\n\t\tPoint2D normalVector2(Point2D p){\n\t\t\treturn new Point2D.Double(p.getY(), -p.getX());\n\t\t}\n\t\t\n\t\tPoint2D mul(double n,Point2D p1){\n\t\t\treturn new Point2D.Double(p1.getX()*n,p1.getY()*n);\n\t\t}\n\n\t\tPoint2D sub(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n\t\t}\n\n\t\tclass Circle{\n\t\t\tPoint2D p;\n\t\t\tdouble r;\n\t\t\tCircle(Point2D p,double r){ \n\t\t\t\tthis.p=p;\n\t\t\t\tthis.r=r;\n\t\t\t}\n\t\t\tCircle(double x,double y,double r){  \n\t\t\t\tthis.p=new Point2D.Double(x,y); \n\t\t\t\tthis.r=r;\n\t\t\t}\n\t\t}\n\n\t\tvoid doIt(){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n==0)return;\n\t\t\tPoint2D[] p = new Point2D[n];\n\t\t\tfor(int i=0;i<n;i++)p[i] = new Point2D.Double(in.nextDouble(),in.nextDouble());\n\t\t\tint result = 0;\n\t\t\tfor(int i=0;i<n;i++)for(int s=0;s<n;s++)if(i!=s)if(p[i].distance(p[s])<=2){\n\t\t\t\tPoint2D[] k = intersectPtCC(new Circle(p[i], 1+EPS), new Circle(p[s], 1+EPS));\n//\t\t\t\tSystem.out.println(k.length);\n\t\t\t\tfor(int a=0;a<k.length;a++){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor(int b=0;b<n;b++)if(k[a].distance(p[b])<=1+EPS)cnt++;\n\t\t\t\t\tresult = Math.max(result, cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint n = ir.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\treturn;\n\t\t\tP[] ps = new P[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tps[i] = new P(ir.nextDouble(), ir.nextDouble());\n\t\t\tint ret = 1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (sum(ps[i].sub(ps[j]).norm(), -2.0) <= 0.0) {\n\t\t\t\t\t\tP m = ps[i].add(ps[j]).mul(0.5);\n\t\t\t\t\t\tP t = ps[i].sub(ps[j]).perpendicular()\n\t\t\t\t\t\t\t\t.mul(Math.sqrt(sum(1.0, -Math.pow(m.sub(ps[i]).norm(), 2))));\n\t\t\t\t\t\tret = Math.max(ret, check(m.add(t), ps, i, j));\n\t\t\t\t\t\tret = Math.max(ret, check(m.add(t.mul(-1.0)), ps, i, j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ret);\n\t\t}\n\t}\n\n\tstatic int check(P c, P[] ps, int a, int b) {\n\t\tint ret = 2;\n\t\tfor (int i = 0; i < ps.length; i++) {\n\t\t\tif (i == a || i == b)\n\t\t\t\tcontinue;\n\t\t\tif (sum(1.0, -ps[i].sub(c).norm()) >= 0.0)\n\t\t\t\tret++;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic final double EPS = 1e-7;\n\n\tpublic static double sum(double a, double b) {\n\t\tif (Math.abs(a + b) < EPS * (Math.abs(a) + Math.abs(b)))\n\t\t\treturn 0.0;\n\t\treturn a + b;\n\t}\n\n\tstatic class P {\n\n\t\tpublic double x, y;\n\n\t\tpublic P(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic double getX() {\n\t\t\treturn this.x;\n\t\t}\n\n\t\tpublic double getY() {\n\t\t\treturn this.y;\n\t\t}\n\n\t\tpublic double norm() {\n\t\t\treturn Math.sqrt(sum(this.x * this.x, this.y * this.y));\n\t\t}\n\n\t\tpublic P add(P v) {\n\t\t\treturn new P(sum(this.x, v.x), sum(this.y, v.y));\n\t\t}\n\n\t\tpublic P sub(P v) {\n\t\t\treturn new P(sum(this.x, -v.x), sum(this.y, -v.y));\n\t\t}\n\n\t\tpublic P mul(double k) {\n\t\t\treturn new P(this.x * k, this.y * k);\n\t\t}\n\n\t\tpublic double dot(P v) {\n\t\t\treturn sum(this.x * v.x, this.y * v.y);\n\t\t}\n\n\t\tpublic double det(P v) {\n\t\t\treturn sum(this.x * v.y, -this.y * v.x);\n\t\t}\n\n\t\tpublic P perpendicular() {\n\t\t\treturn new P(this.y / norm(), -this.x / norm());\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(this.x) + \" \" + String.valueOf(this.y);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.NoSuchElementException;\nimport java.util.Collections;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tFS fs = new FS();\n\t\twhile(true) {\n\t\t\tint n = fs.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tif(n==1) {\n\t\t\t\tdouble x = fs.nextDouble();\n\t\t\t\tdouble y = fs.nextDouble();\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble[] px = new double[n];\n\t\t\tdouble[] py = new double[n];\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\tpx[i] = fs.nextDouble();\n\t\t\t\tpy[i] = fs.nextDouble();\n\t\t\t}\n\t\t\tArrayList<Double> csx = new ArrayList<Double>();\n\t\t\tArrayList<Double> csy = new ArrayList<Double>();\n\t\t\tfor(int i=0; i<n-1; i++) {\n\t\t\t\tfor(int j=i+1; j<n; j++) {\n\t\t\t\t\tdouble vx = px[j]-px[i];\n\t\t\t\t\tdouble vy = py[j]-py[i];\n\t\t\t\t\tdouble l = Math.sqrt(Math.pow(vx,2.0)+Math.pow(vy,2.0));\n\t\t\t\t\tif(l > 2.0) continue;\n\t\t\t\t\tdouble r = Math.sqrt(1.0 - Math.pow(l/2.0, 2.0));\n\t\t\t\t\tvx = vx/l*r;\n\t\t\t\t\tvy = vy/l*r;\n\t\t\t\t\tdouble mx = (px[i]+px[j])/2.0;\n\t\t\t\t\tdouble my = (py[i]+py[j])/2.0;\n\t\t\t\t\tcsx.add(mx-vy);\n\t\t\t\t\tcsy.add(my+vx);\n\t\t\t\t\tcsx.add(mx+vy);\n\t\t\t\t\tcsy.add(my-vx);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint maxCount = 0;\n\t\t\tfor(int i=0; i<csx.size(); i++) {\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\t\tif(Math.pow(csx.get(i)-px[j],2.0)+Math.pow(csy.get(i)-py[j],2.0) <= 1.0000000001) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxCount = Math.max(maxCount, count);\n\t\t\t}\n\t\t\tSystem.out.println(maxCount);\n\t\t}\n\t}\n\n\t// Read Class\n\tstatic class FS {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() { return hasNextByte() ? buffer[ptr++] : -1;}\n\t\tprivate boolean isPrintableChar(int c) {return 33 <= c && c <= 126;}\n\t\tprivate void skipUnprintable() {while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\n\t\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if(b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Circle and Points\npublic class Main{\n\n\tstatic class P{\n\t\tpublic double x, y;\n\t\tpublic P(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tstatic class R implements Comparable<R>{\n\t\tpublic double minx, maxx, miny, maxy;\n\t\tpublic P[] p;\n\t\tpublic int prob;\n\t\tboolean[] mark;\n\t\tpublic R(boolean[] u, double minx, double maxx, double miny, double maxy) {\n\t\t\tthis.minx = minx;\n\t\t\tthis.maxx = maxx;\n\t\t\tthis.miny = miny;\n\t\t\tthis.maxy = maxy;\n\t\t\tp = new P[4];\n\t\t\tp[0] = new P(minx, miny);\n\t\t\tp[1] = new P(minx, maxy);\n\t\t\tp[2] = new P(maxx, miny);\n\t\t\tp[3] = new P(maxx, maxy);\n\t\t\tmark = new boolean[n];\n\t\t\tprob = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(u[i]){\n\t\t\t\t\tif(minx<=q[i].x&&q[i].x<=maxx && miny-1<=q[i].y&&q[i].y<=maxy+1){\n\t\t\t\t\t\tmark[i]=true;\n\t\t\t\t\t\tprob++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(minx-1<=q[i].x&&q[i].x<=maxx+1 && miny<=q[i].y&&q[i].y<=maxy){\n\t\t\t\t\t\tmark[i]=true;\n\t\t\t\t\t\tprob++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tboolean f = false;\n\t\t\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\t\t\tif(Math.hypot(q[i].x-p[j].x, q[i].y-p[j].y)<=1){\n\t\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(f){\n\t\t\t\t\t\t\tmark[i] = true;\n\t\t\t\t\t\t\tprob++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tpublic void find(){\n\t\t\tif(prob<=max)return;\n\t\t\tif(maxx-minx<0.000001){\n\t\t\t\tmax = Math.max(max, prob);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tR[] r = new R[4];\n\t\t\tdouble midx = (minx+maxx)/2;\n\t\t\tdouble midy = (miny+maxy)/2;\n\t\t\tr[0] = new R(mark, minx, midx, miny, midy);\n\t\t\tr[1] = new R(mark, midx, maxx, miny, midy);\n\t\t\tr[2] = new R(mark, minx, midx, midy, maxy);\n\t\t\tr[3] = new R(mark, midx, maxx, midy, maxy);\n\t\t\tArrays.sort(r);\n\t\t\tfor(int i=0;i<4;i++)r[i].find();\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn o.prob-prob;\n\t\t}\n\t}\n\t\n\tstatic int n;\n\tstatic int max;\n\tstatic P[] q;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tq = new P[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tq[i] = new P(sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\tboolean[] u = new boolean[n];\n\t\t\tArrays.fill(u, true);\n\t\t\tmax = 0;\n\t\t\tR r = new R(u, 0, 10, 0, 10);\n\t\t\tr.find();\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\tstatic double[] X, Y;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tX = new double[N];\n\t\t\tY = new double[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tX[i] = sc.nextDouble();\n\t\t\t\tY[i] = sc.nextDouble();\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tstatic int solve() {\n\t\tif (N == 1) return 1;\n\t\tif (N == 2) {\n\t\t\treturn dist(0, 1) <= 2 ? 2 : 1;\n\t\t}\n\t\tint ans = 1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tdouble d = dist(i, j);\n\t\t\t\tif (d > 2) continue;\n\t\t\t\tdouble dx = (X[j] - X[i]) / 2;\n\t\t\t\tdouble dy = (Y[j] - Y[i]) / 2;\n\t\t\t\tdouble len = sq(dx, dy);\n\t\t\t\tdouble ex = dx / len;\n\t\t\t\tdouble ey = dy / len;\n\t\t\t\tdouble lenC = Math.sqrt(1 - len * len);\n\t\t\t\t{\n\t\t\t\t\tdouble cx = X[i] + dx - ey * lenC;\n\t\t\t\t\tdouble cy = Y[i] + dy + ex * lenC;\n\t\t\t\t\tans = Math.max(ans, count(cx, cy));\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tdouble cx = X[i] + dx + ey * lenC;\n\t\t\t\t\tdouble cy = Y[i] + dy - ex * lenC;\n\t\t\t\t\tans = Math.max(ans, count(cx, cy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tstatic int count(double cx, double cy) {\n\t\tint c = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdouble d = sq(X[i] - cx, Y[i] - cy);\n\t\t\tif (d <= 1 + 1e-9) ++c;\n\t\t}\n\t\treturn c;\n\t}\n\n\tstatic double dist(int i, int j) {\n\t\treturn sq(X[i] - X[j], Y[i] - Y[j]);\n\t}\n\n\tstatic double sq(double x, double y) {\n\t\treturn Math.sqrt(x * x + y * y);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tnew Main().calc();\n\t}\n\n\tdouble[] x;\n\tdouble[] y;\n\tint n;\n\tvoid calc(){\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = cin.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tx = new double[n];\n\t\t\ty = new double[n];\n\t\t\tint i,j,k;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tx[i] = cin.nextDouble();\n\t\t\t\ty[i] = cin.nextDouble();\n\t\t\t}\n\t\t\tint ret = 0;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tret = Math.max(ret, getmax(new int[]{i}));\n\t\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\t\tif(Math.hypot(x[i]-x[j], y[i]-y[j]) > 2) continue;\n\t\t\t\t\tret = Math.max(ret, getmax(new int[]{i,j}));\n\t\t\t\t\tfor(k=j+1;k<n;k++){\n\t\t\t\t\t\tif(Math.hypot(x[k]-x[j], y[k]-y[j]) > 2) continue;\n\t\t\t\t\t\tif(Math.hypot(x[i]-x[k], y[i]-y[k]) > 2) continue;\n\t\t\t\t\t\tret = Math.max(ret, getmax(new int[]{i,j,k}));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ret);\n\t\t}\n\t}\n\n\tint getmax(int[] nums){\n\t\tdouble nx = 0;\n\t\tdouble ny = 0;\n\t\tfor(int a : nums){\n\t\t\tnx += x[a]/nums.length;\n\t\t\tny += y[a]/nums.length;\n\t\t}\n\t\tdouble move = 0.7;\n\t\tfor(int i=0;i<10;i++){\n\t\t\tdouble maxdist = 0;\n\t\t\tint num = 0;\n\t\t\tfor(int a :nums){\n\t\t\t\tdouble dist = Math.hypot(nx-x[a], ny-y[a]);\n\t\t\t\tif(maxdist<dist){\n\t\t\t\t\tmaxdist = dist;\n\t\t\t\t\tnum = a;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(maxdist<1) break;\n\t\t\tnx += (x[num]-nx)*move;\n\t\t\tny += (y[num]-ny)*move;\n\t\t\tmove *= 0.7;\n\t\t}\n\t\treturn getnum(nx,ny);\n\t}\n\n\tint getnum(double nx, double ny){\n\t\tint ret = 0;\n\t\tfor(int i = 0;i <n;i++){\n\t\t\tif(Math.hypot(nx-x[i], ny-y[i])<=1) ret++;\n\t\t}\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tdouble[] x, y;\n\tdouble EPS = 1e-8;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\t\n\t\t\tx = new double[n];\n\t\t\ty = new double[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tx[i] = sc.nextDouble(); y[i] = sc.nextDouble();\n\t\t\t}\n\t\t\tint max = 1;\n\t\t\tfor(int i=0;i<n;i++) for(int j=i+1;j<n;j++) {\n\t\t\t\tif(2.0  < d(i, j) - EPS ) continue;\n\t\t\t\tdouble[][] c = c(i, j);\n\t\t\t\tfor(double[] a: c) {\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor(int k=0;k<n;k++)  if(1.0 + EPS > d(a, k)){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\tmax = max(max, cnt);\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tdouble d(double[] c, int i) {\n\t\treturn sqrt( (x[i] - c[0]) * (x[i] - c[0]) + (y[i] - c[1]) * (y[i] - c[1]) );\n\t}\n\t\n\tdouble d(int i, int j) {\n\t\treturn sqrt( (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) );\n\t}\n\t\n\tdouble[][] c(int i, int j) {\n\t\tdouble[][] ret = new double[2][2];\n\t\tdouble cx = (x[i]+x[j]) / 2, cy = (y[i]+y[j]) / 2;\n\t\tdouble nx = y[i] - y[j], ny = x[j] - x[i], norm = sqrt(nx*nx+ny*ny);\n\t\tnx /= norm; ny /= norm;\n\t\tdouble dc = (x[j]-cx)*(x[j]-cx)+(y[j]-cy)*(y[j]-cy), d = sqrt( 1.0 - dc );\n\t\tnx *= d; ny *= d;\n\t\tret[0][0] = nx + cx; ret[0][1] = ny + cy;\n\t\tret[1][0] = -1.0 * nx + cx; ret[1][1] = -1.0 * ny + cy;\n\t\tdebug(nx, ny, cx, cy, ret);\n\t\treturn ret;\n\t}\n\n\tvoid debug(Object... os) {\n\t//\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tP[] ps;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\tps = new P[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tps[i] = new P(sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\tint cnt_max = 1;\n\t\t\tint cnt = 0;\n\t\t\tfor(int i=0;i<n-1;i++) for(int j=i+1;j<n;j++) {\n\t\t\t\t\n\t\t\t\tif( sqrt(dis( ps[i], ps[j] )) < 2.0 ) {\n\t\t\t\t\tP m = new P( (ps[i].x+ps[j].x)/2, (ps[i].y+ps[j].y)/2);\n\t\t\t\t\tdouble d = sqrt(1-dis(ps[i], m ));\n\t\t\t\t\tP dp = new P((ps[i].y-ps[j].y), -(ps[i].x-ps[j].x));\n\t\t\t\t\tdp.nom();\n\t\t\t\t\tdp.mult(d);\n\t\t\t\t\tP c[] = new P[2];\n\t\t\t\t\tc[0] = m.add(dp);\n\t\t\t\t\tdp.mult(-1.0);\n\t\t\t\t\tc[1] = m.add(dp);\n\t\t\t\t\tfor(int l=0;l<2;l++) {\n\t\t\t\t\t\tcnt = 0;\n//\t\t\t\t\t\tLinkedList<Double> dist = new LinkedList<Double>();\n//\t\t\t\t\t\tLinkedList<Integer> ind = new LinkedList<Integer>();\n\t\t\t\t\t\tfor(int k=0;k<n;k++) {\n\t\t\t\t\t\t\tif(dis(c[l], ps[k]) < 1.0 || k==i||k==j) {\n//\t\t\t\t\t\t\tdebug(dis(c[l], ps[k]));\n//\t\t\t\t\t\t\t\tdist.add(dis(c[l], ps[k]));\n//\t\t\t\t\t\t\t\tind.add(k);\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tdebug(c[l].x, c[l].y, i, j, cnt);\n\t\t\t\t\t\tcnt_max = max(cnt_max, cnt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt_max);\n\t\t}\n\t}\n\t\n\tdouble dis( P p1, P p2 ) {\n\t\treturn (p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\t\n\tclass P {\n\t\tdouble x, y;\n\t\tP (double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tvoid nom() {\n\t\t\tdouble nom = sqrt(x*x + y*y);\n\t\t\tx /= nom;\n\t\t\ty /= nom;\n\t\t}\n\t\tP add(P p) {\n\t\t\tx += p.x;\n\t\t\ty += p.y;\n\t\t\treturn new P(x, y);\n\t\t}\n\t\tP mult(double d) {\n\t\t\tx *= d;\n\t\t\ty *= d;\n\t\t\treturn new P(x, y);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(in.hasNext())new AOJ1134().doIt();\n\t}\n\n\tclass AOJ1134{\n\t\tfinal double EPS=1.0e-8;\n\t\tPoint2D[] intersectPtCC(Circle a,Circle b){\n\t\t\tdouble dis = a.p.distance(b.p);\n\t\t\tif(dis > a.r+b.r) return null;\n\t\t\tPoint2D v = sub(b.p, a.p);\n\t\t\tdouble rc = (dis*dis + a.r*a.r - b.r*b.r)/(2*dis); \n\t\t\tdouble rate = rc/dis;\n\t\t\tv = mul(rate, v);\n\t\t\tPoint2D c = add(v, a.p);\n\t\t\tdouble disC2c = c.distance(b.p);\n\t\t\tdouble disqc = Math.sqrt(b.r*b.r - disC2c*disC2c);\n\t\t\tPoint2D v2 = sub(b.p, c);\n\t\t\tv2 = mul(disqc/disC2c, v2);\n\t\t\tPoint2D[] ret = new Point2D.Double[2];\n\t\t\tret[0] = add(normalVector1(v2), c);\n\t\t\tret[1] = add(normalVector2(v2), c);\n\t\t\treturn ret;\n\t\t}\n\n\t\tPoint2D add(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()+p2.getX(), p1.getY()+p2.getY());\n\t\t}\n\t\t\n\t\tPoint2D normalVector1(Point2D p){\n\t\t\treturn new Point2D.Double(-p.getY(), p.getX());\n\t\t}\n\t\tPoint2D normalVector2(Point2D p){\n\t\t\treturn new Point2D.Double(p.getY(), -p.getX());\n\t\t}\n\t\t\n\t\tPoint2D mul(double n,Point2D p1){\n\t\t\treturn new Point2D.Double(p1.getX()*n,p1.getY()*n);\n\t\t}\n\n\t\tPoint2D sub(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n\t\t}\n\n\t\tclass Circle{\n\t\t\tPoint2D p;\n\t\t\tdouble r;\n\t\t\tCircle(Point2D p,double r){ \n\t\t\t\tthis.p=p;\n\t\t\t\tthis.r=r;\n\t\t\t}\n\t\t\tCircle(double x,double y,double r){  \n\t\t\t\tthis.p=new Point2D.Double(x,y); \n\t\t\t\tthis.r=r;\n\t\t\t}\n\t\t}\n\n\t\tvoid doIt(){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n==0)return;\n\t\t\tPoint2D[] p = new Point2D[n];\n\t\t\tfor(int i=0;i<n;i++)p[i] = new Point2D.Double(in.nextDouble(),in.nextDouble());\n\t\t\tint result = 1;\n\t\t\tfor(int i=0;i<n;i++)for(int s=0;s<n;s++)if(i!=s)if(p[i].distance(p[s])<=2){\n\t\t\t\tPoint2D[] k = intersectPtCC(new Circle(p[i], 1), new Circle(p[s], 1));\n\t\t\t\tfor(int a=0;a<k.length;a++){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor(int b=0;b<n;b++)if(k[a].distance(p[b])<=1+EPS)cnt++;\n\t\t\t\t\tresult = Math.max(result, cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tIO io = new IO();\n\t\twhile(true) {\n\t\t\tint n = io.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVector2[] v = new Vector2[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tv[i] = new Vector2(io.nextDouble(),io.nextDouble());\n\t\t\t}\n\t\t\tint ans = 1;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\t\tVector2 x = v[i].subtract(v[j]);\n\t\t\t\t\tdouble d = x.norm();\n\t\t\t\t\tdouble l = Math.sqrt(1 - Math.pow(d / 2, 2));\n\t\t\t\t\tVector2 m = v[i].add(v[j]).divide(2);\n\t\t\t\t\tVector2 y = x.rotate90().normalize();\n\t\t\t\t\tfor(int sign=1;sign>=-1;sign-=2) {\n\t\t\t\t\t\tVector2 c = m.add(y.multiply(l * sign));\n\t\t\t\t\t\tint sum = 0;\n\t\t\t\t\t\tfor(int k=0;k<n;k++) {\n\t\t\t\t\t\t\tif (c.dist(v[k]) < 1 + Vector2.EPS) {\n\t\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans = Math.max(ans,sum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tio.println(ans);\n\t\t}\n\t\tio.flush();\n\t}\n\n}\n\nclass Vector2 {\n\tpublic static double EPS = 1E-6;\n\tpublic double x;\n\tpublic double y;\n\tpublic Vector2(double x,double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\tpublic double dot(Vector2 v) {\n\t\treturn this.x*v.x+this.y*v.y;\n\t}\n\tpublic double cross(Vector2 v) {\n\t\treturn this.x*v.y-this.y*v.x;\n\t}\n\tpublic double norm() {\n\t\treturn Math.sqrt(this.x*this.x+this.y*this.y);\n\t}\n\tpublic Vector2 normalize() {\n\t\treturn divide(norm());\n\t}\n\tpublic Vector2 add(Vector2 v) {\n\t\treturn new Vector2(x+v.x,y+v.y);\n\t}\n\tpublic Vector2 subtract(Vector2 v) {\n\t\treturn new Vector2(x-v.x,y-v.y);\n\t}\n\tpublic Vector2 multiply(double k) {\n\t\treturn new Vector2(x*k,y*k);\n\t}\n\tpublic Vector2 divide(double k) {\n\t\treturn new Vector2(x/k,y/k);\n\t}\n\tpublic Vector2 rotate90() {\n\t\treturn new Vector2(-y,x);\n\t}\n\tpublic Vector2 rotate270() {\n\t\treturn new Vector2(y,-x);\n\t}\n\tpublic double dist(Vector2 v) {\n\t\treturn this.subtract(v).norm();\n\t}\n\tpublic String toString() {\n\t\treturn \"(\" + this.x + \",\" + this.y + \")\";\n\t}\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.util.*;\n\npublic class Main {\n\tfinal double EPS = 1.0e-08;\n\tPoint2D [] plist;\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tplist = new Point2D[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tdouble x = sc.nextDouble(), y = sc.nextDouble();\n\t\t\t\tplist[i] = new Point2D.Double(x, y);\n\t\t\t}\n\t\t\tint ans = 1;\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tfor(int j=i+1; j < n; j++){\t\t\t\t\t\n\t\t\t\t\tPoint2D [] cpList = centerPoint(plist[i], plist[j]);\n\t\t\t\t\tif(cpList == null) continue;\n\t\t\t\t\tint res1 = distanceWithin1Radius(cpList[0]);\n\t\t\t\t\tint res2 = distanceWithin1Radius(cpList[1]);\n\t\t\t\t\tans = Math.max(ans, Math.max(res1, res2));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate Point2D[] centerPoint(Point2D p1, Point2D p2) {\n\t\tdouble r = 1.0;\n\t\tdouble midx = (p1.getX() + p2.getX()) / 2.0;\n\t\tdouble midy = (p1.getY() + p2.getY()) / 2.0;\n\t\tPoint2D midP = new Point2D.Double(midx, midy);\n\t\tPoint2D p2p1 = sub(p2,p1);\n\t\tPoint2D normalV1 = normalVector1(p2p1);\n\t\tPoint2D normalV2 = normalVector2(p2p1);\n\t\tdouble halfdis = p1.distance(p2) / 2.0;\n\t\tif(halfdis > r + EPS) return null;\n\t\tdouble tocenterDis = Math.sqrt(r - halfdis * halfdis);\n\t\tPoint2D [] res = new Point2D[2];\n\t\tres[0] = add(mul(normalV1, tocenterDis / norm(normalV1)), midP);\n\t\tres[1] = add(mul(normalV2, tocenterDis / norm(normalV1)), midP);\n\t\treturn res;\n\t}\n\tprivate Point2D add(Point2D p1, Point2D p2) {\n\t\tdouble x = p2.getX() + p1.getX();\n\t\tdouble y = p2.getY() + p1.getY();\n\t\treturn new Point2D.Double(x, y);\n\t}\n\t\n\tprivate Point2D sub(Point2D p2, Point2D p1) {\n\t\tdouble x = p2.getX() - p1.getX();\n\t\tdouble y = p2.getY() - p1.getY();\n\t\treturn new Point2D.Double(x, y);\n\t}\n\t\n\tprivate Point2D mul(Point2D p,double value) {\n\t\treturn new Point2D.Double(p.getX() * value, p.getY() * value);\n\t}\n\t\n\tprivate double norm(Point2D p){\n\t\treturn Math.sqrt(p.getX() * p.getX() + p.getY() * p.getY());\n\t}\n\t\n\tprivate Point2D normalVector1(Point2D p) {\n\t\treturn new Point2D.Double(-p.getY(), p.getX());\n\t}\n\t\n\tprivate Point2D normalVector2(Point2D p) {\n\t\treturn new Point2D.Double(p.getY(), -p.getX());\n\t}\n\n\tprivate int distanceWithin1Radius(Point2D p) {\n\t\tint count = 0;\n\t\tfor(int i=0; i < plist.length;i++){\n\t\t\tdouble res = p.distance(plist[i]);\n\t\t\tif(res<= 1.0 + EPS) count++;\n\t\t}\n\t\treturn count;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Point2D;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tdouble EPS = 1e-6;\n\tdouble calcDist(double x1, double y1, double x2, double y2) {\n\t\tdouble dx = x1 - x2;\n\t\tdouble dy = y1 - y2;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\t\n\tint count(double[] x, double[] y, double cx, double cy) {\n\t\tint res = 0;\n\t\tfor (int i = 0; i < x.length; i++) {\n\t\t\tif (calcDist(cx, cy, x[i], y[i]) <= 1 + EPS) res++;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tdouble[] x = new double[n];\n\t\t\tdouble[] y = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tx[i] = in.nextDouble();\n\t\t\t\ty[i] = in.nextDouble();\n\t\t\t}\n\t\t\t\n\t\t\tint res = 1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tdouble d = calcDist(x[i], y[i], x[j], y[j]);\n\t\t\t\t\tif (d > 2) continue;\n\t\t\t\t\t\n\t\t\t\t\tdouble dx = (x[j] - x[i]) / 2;\n\t\t\t\t\tdouble dy = (y[j] - y[i]) / 2;\n\t\t\t\t\tdouble len = calcDist(0, 0, dx, dy);\n\t\t\t\t\tdouble ex = dx / len;\n\t\t\t\t\tdouble ey = dy / len;\n\t\t\t\t\tdouble lenC = Math.sqrt(1 - len * len);\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble cx = x[i] + dx - ey * lenC;\n\t\t\t\t\t\tdouble cy = y[i] + dy + ex * lenC;\n\t\t\t\t\t\tres = Math.max(res, count(x, y, cx, cy));\n\t\t\t\t\t}\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble cx = x[i] + dx + ey * lenC;\n\t\t\t\t\t\tdouble cy = y[i] + dy - ex * lenC;\n\t\t\t\t\t\tres = Math.max(res, count(x, y, cx, cy));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\t\n\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tdouble EPS = 1e-12;\n\tdouble INF = 1e12;\n\n\tclass Point {\n\t\tdouble x, y;\n\n\t\tPoint(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tclass Segment {\n\t\tPoint a, b;\n\n\t\tSegment(Point a, Point b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t}\n\n\tclass Line {\n\t\tPoint a, b;\n\n\t\tLine(Point a, Point b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t}\n\n\tclass Circle {\n\t\tPoint c;\n\t\tdouble r;\n\n\t\tCircle(Point c, double r) {\n\t\t\tthis.c = c;\n\t\t\tthis.r = r;\n\t\t}\n\t}\n\n\tdouble norm(Point a) {\n\t\treturn Math.hypot(a.x, a.y);\n\t}\n\n\tPoint sub(Point a, Point b) {\n\t\treturn new Point(a.x - b.x, a.y - b.y);\n\t}\n\n\tdouble dot(Point a, Point b) {\n\t\treturn a.x * b.x + a.y * b.y;\n\t}\n\n\tdouble cross(Point a, Point b) {\n\t\treturn a.x * b.y - a.y * b.x;\n\t}\n\n\tdouble abs(double a) {\n\t\treturn 0 < a ? a : -a;\n\t}\n\n\t// 交点の個数が0または無限の時はreturn null;\n\tPoint[] crossPoint(Circle c1, Circle c2) {\n\t\tdouble d = norm(sub(c1.c, c2.c));\n\t\tif (d < EPS && abs(c1.r - c2.r) < EPS) {\n\t\t\treturn null;\n\t\t} else if (c1.r + c2.r < d - EPS || d + EPS < abs(c1.r - c2.r)) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tdouble a = (c1.r * c1.r - c2.r * c2.r + d * d) / (2 * d);\n\t\t\tdouble h = Math.sqrt(Math.max(c1.r * c1.r - a * a, 0));\n\t\t\tPoint p1 = new Point(c1.c.x + a / d * (c2.c.x - c1.c.x), c1.c.y + a / d * (c2.c.y - c1.c.y));\n\t\t\tPoint p2 = new Point(h / d * (c2.c.x - c1.c.x), h / d * (c2.c.y - c1.c.y));\n\t\t\tif (norm(p2) < EPS) {\n\t\t\t\treturn new Point[] { p1 };\n\t\t\t} else {\n\t\t\t\treturn new Point[] { new Point(p1.x - p2.y, p1.y + p2.x), new Point(p1.x + p2.y, p1.y - p2.x) };\n\t\t\t}\n\t\t}\n\t}\n\n\tboolean isCover(Circle c, Point p) {\n\t\treturn norm(sub(c.c, p)) <= c.r + EPS;\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tPoint[] p = new Point[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tp[i] = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\n\t\t\tint max = 1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tPoint[] cp = crossPoint(new Circle(p[i], 1.), new Circle(p[j], 1.));\n\t\t\t\t\tif (cp == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = 0; k < cp.length; k++) {\n\t\t\t\t\t\tCircle c = new Circle(cp[k], 1.);\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\t\tif (isCover(c, p[l])) {\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmax = Math.max(max, cnt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.NoSuchElementException;\nimport java.util.Collections;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tFS fs = new FS();\n\t\twhile(true) {\n\t\t\tint n = fs.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tif(n==1) {\n\t\t\t\tdouble x = fs.nextDouble();\n\t\t\t\tdouble y = fs.nextDouble();\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble[] px = new double[n];\n\t\t\tdouble[] py = new double[n];\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\tpx[i] = fs.nextDouble();\n\t\t\t\tpy[i] = fs.nextDouble();\n\t\t\t}\n\t\t\tArrayList<Double> csx = new ArrayList<Double>();\n\t\t\tArrayList<Double> csy = new ArrayList<Double>();\n\t\t\tfor(int i=0; i<n-1; i++) {\n\t\t\t\tfor(int j=i+1; j<n; j++) {\n\t\t\t\t\tdouble vx = px[j]-px[i];\n\t\t\t\t\tdouble vy = py[j]-py[i];\n\t\t\t\t\tdouble l = Math.sqrt(Math.pow(vx,2.0)+Math.pow(vy,2.0));\n\t\t\t\t\tif(l > 2.0) continue;\n\t\t\t\t\tdouble r = Math.sqrt(1.0 - Math.pow(l/2.0, 2.0));\n\t\t\t\t\tvx = vx/l*r;\n\t\t\t\t\tvy = vy/l*r;\n\t\t\t\t\tdouble mx = (px[i]+px[j])/2.0;\n\t\t\t\t\tdouble my = (py[i]+py[j])/2.0;\n\t\t\t\t\tcsx.add(mx-vy);\n\t\t\t\t\tcsy.add(my+vx);\n\t\t\t\t\tcsx.add(mx+vy);\n\t\t\t\t\tcsy.add(my-vx);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint maxCount = 0;\n\t\t\tfor(int i=0; i<csx.size(); i++) {\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\t\tSystem.out.println(Math.pow(csx.get(i)-px[j],2.0)+Math.pow(csy.get(i)-py[j],2.0));\n\t\t\t\t\tif(Math.pow(csx.get(i)-px[j],2.0)+Math.pow(csy.get(i)-py[j],2.0) <= 1.0000000001) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(count);\n\t\t\t\tmaxCount = Math.max(maxCount, count);\n\t\t\t}\n\t\t\tSystem.out.println(maxCount);\n\t\t}\n\t}\n\n\t// Read Class\n\tstatic class FS {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() { return hasNextByte() ? buffer[ptr++] : -1;}\n\t\tprivate boolean isPrintableChar(int c) {return 33 <= c && c <= 126;}\n\t\tprivate void skipUnprintable() {while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\n\t\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if(b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D[] points = new Point2D[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tpoints[i] = new Point2D(sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tint max = 0;\n\t\t\t\n\t\t\tfor(int fst = 0; fst < n; fst++){\n\t\t\t\tfor(int snd = 0; snd < n; snd++){\n\t\t\t\t\tPoint2D[] cross = Point2D.cross_ss(points[fst], 1, points[snd], 1);\n\t\t\t\t\t\n\t\t\t\t\tfor(Point2D cross_c : cross){\n\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\t\tif(cross_c.dist(points[i]) <= 1.0 + Point2D.EPS){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tmax = Math.max(max, count);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t\t\n\t}\n}\n\nclass Point2D {\n    public double x;\n    public double y;\n \n    public static final double EPS = 1e-4;\n \n    public Point2D(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n \n    public Point2D(Point2D point) {\n        this.x = point.x;\n        this.y = point.y;\n    }\n \n    public String toString() {\n        return x + \",\" + y;\n    }\n \n    @Override\n    public boolean equals(Object o) {\n        if (o instanceof Point2D) {\n            Point2D another = (Point2D) o;\n            if (this.x - EPS < another.x && this.x + EPS > another.x\n                    && this.y - EPS < another.y && this.y + EPS > another.y) {\n                return true;\n            }\n             \n            return false;\n \n            // return this.x == another.x && this.y == another.y;\n        }\n        return false;\n    }\n \n    public Point2D add(double x, double y) {\n        return new Point2D(this.x + x, this.y + y);\n    }\n \n    public Point2D sub(double x, double y) {\n        return add(-x, -y);\n    }\n \n    public Point2D add(Point2D another) {\n        return add(another.x, another.y);\n    }\n \n    public Point2D sub(Point2D another) {\n        return sub(another.x, another.y);\n    }\n \n    public Point2D mul(double d) {\n        return new Point2D(this.x * d, this.y * d);\n    }\n \n    public Point2D div(double d) {\n        return new Point2D(this.x / d, this.y / d);\n    }\n \n    public double dot(double x, double y) {\n        return this.x * x + this.y * y;\n    }\n \n    public double dot(Point2D another) {\n        return dot(another.x, another.y);\n    }\n \n    public double cross(double x, double y) {\n        return this.x * y - this.y * x;\n    }\n \n    public double cross(Point2D another) {\n        return cross(another.x, another.y);\n    }\n \n    public double dist(double x, double y) {\n        return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n                * (this.y - y));\n    }\n \n    public double dist(Point2D another) {\n        return dist(another.x, another.y);\n    }\n \n    public double dist_o() {\n        return dist(0, 0);\n    }\n \n    public Point2D unit() {\n        return div(dist_o());\n    }\n \n    public boolean pol(Point2D start, Point2D end) {\n        return end.sub(start).cross(this.sub(start)) < EPS;\n    }\n \n    public boolean pos(Point2D start, Point2D end) {\n        return (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n    }\n \n    public double pld(Point2D start, Point2D end) {\n        return Math.abs((end.sub(start).cross(this.sub(start)))\n                / end.sub(start).dist_o());\n    }\n \n    public double psd(Point2D start, Point2D end) {\n        if (end.sub(start).dot(this.sub(start)) < EPS) {\n            return this.dist(start);\n        } else if (start.sub(end).dot(this.sub(end)) < EPS) {\n            return this.dist(end);\n        } else {\n            return end.sub(start).cross(this.sub(start)) / end.dist(start);\n        }\n    }\n \n    public static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS)\n                && (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n    }\n \n    public static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return a1.sub(a2).cross(b1.sub(b2)) < EPS;\n    }\n \n    public static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D b = b2.sub(b1);\n        double d1 = Math.abs(b.cross(a1.sub(b1)));\n        double d2 = Math.abs(b.cross(a2.sub(b1)));\n        double t = d1 / (d1 + d2);\n        Point2D a = a2.sub(a1), v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D a = a2.sub(a1);\n        Point2D b = b2.sub(b1);\n        double t = b.cross(b1.sub(a1)) / b.cross(a);\n        Point2D v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n            double r2) {\n        double dis = p1.dist(p2);\n \n        if (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n            return new Point2D[0]; // same\n        }\n \n        if (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n            Point2D tmp = p2.sub(p1);\n            tmp = tmp.mul(r1 / tmp.dist_o());\n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis + EPS > r1 + r2) {\n            return new Point2D[0]; // out\n        }\n \n        double dis_m = Math.abs(r1 - r2);\n \n        if (dis_m + EPS > dis && dis_m - EPS < dis) {\n            Point2D tmp = null;\n            if (r1 > r2) {\n                tmp = p2.sub(p1);\n            } else {\n                tmp = p1.sub(p2);\n            }\n \n            double min = Math.min(r1, r2);\n \n            tmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n \n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis_m + EPS > dis) {\n            return new Point2D[0]; // inner\n        } else {\n            Point2D ret[] = new Point2D[2];\n \n            double theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n                    / (2 * dis * r1));\n            double a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n \n            ret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n                    * Math.sin(a + theta) + p1.y);\n            ret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n                    * Math.sin(a - theta) + p1.y);\n            return ret;\n        }\n    }\n \n    public void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n            Point2D ans[]) {\n        if (c.pld(start, end) > r + EPS)\n            return;\n        Point2D v = end.sub(start).unit();\n        double delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n                - start.dist(c) * start.dist(c) + r * r;\n        double t = -v.dot(start.sub(c));\n        double s = Math.sqrt(delta);\n        ans[0] = start.add(v.mul(t + s));\n        ans[1] = start.add(v.mul(t + s));\n    }\n \n    public Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n        Point2D v = b.sub(a).unit();\n        v = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n                (-1) * v.y, v.x);\n        return v.mul(p.pld(a, b));\n    }\n \n    public double area(Point2D a, Point2D b, Point2D c) {\n        return Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tint n=in.nextInt();\n\t\t\tif(n==0)\n\t\t\t\treturn;\n\t\t\tPoint p[]=new Point[n];\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tp[i]=new Point(in.nextDouble(), in.nextDouble());\n\t\t\tint max=1;\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=i+1;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tdouble d=Point.point_distance(p[i],p[j]);\n\t\t\t\t\tif(d>2)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t//中点\n\t\t\t\t\tdouble mx=(p[i].x+p[j].x)/2;\n\t\t\t\t\tdouble my=(p[i].y+p[j].y)/2;\n\t\t\t\t\t//i->jの単位ベクトル\n\t\t\t\t\tdouble vx=(p[j].x-p[i].x)/d;\n\t\t\t\t\tdouble vy=(p[j].y-p[i].y)/d;\n\t\t\t\t\t//m->cの距離\n\t\t\t\t\tdouble e=Math.sqrt(1-d*d/4);\n\t\t\t\t\tPoint pc=new Point(mx+e*vy,my-e*vx);\n\t\t\t\t\tint cnt=2;\n\t\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(k!=i&&k!=j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdouble tmp_dis=(pc.x-p[k].x)*(pc.x-p[k].x)+(pc.y-p[k].y)*(pc.y-p[k].y);\n\t\t\t\t\t\t\tif(tmp_dis<=1)\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpc=new Point(mx-e*vy,my+e*vx);\n\t\t\t\t\tcnt=2;\n\t\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(k!=i&&k!=j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdouble tmp_dis=(pc.x-p[k].x)*(pc.x-p[k].x)+(pc.y-p[k].y)*(pc.y-p[k].y);\n\t\t\t\t\t\t\tif(tmp_dis<=1)\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmax=Math.max(max,cnt);\n\t\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tstatic public void debug(Object... o)\n\t{\n\t\tSystem.err.println(Arrays.deepToString(o));\n\t}\n}\n\nclass Point\n{\n\tdouble x;\n\tdouble y;\n\tPoint(double x,double y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n\n\t//線分p1-p2と線分p3-p4が交差しているかを判定 true->交差(=含みで接する含む) false->交差せず\n\tstatic boolean lineCross(Point p1,Point p2,Point p3,Point p4)\n\t{\n\t\tdouble a=(p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x);\n\t\tdouble b=(p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x);\n\t\tdouble c=(p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x);\n\t\tdouble d=(p3.x-p4.x)*(p2.y-p3.y)+(p3.y-p4.y)*(p3.x-p2.x);\n\t\treturn a*b<=0 && c*d<=0;\n\t}\n\n\t//クラスメソッド\n\tstatic double point_distance(Point p1,Point p2)\n\t{\n\t\treturn Math.hypot(p1.x-p2.x, p1.y-p2.y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-6;\n\n\tint n;\n\tP[] ps;\n\t\n\tvoid run() {\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tps=new P[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble x=sc.nextDouble();\n\t\t\t\tdouble y=sc.nextDouble();\n\t\t\t\tps[i]=new P(x,y);\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\tint ans=0;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int i=j+1;i<n;i++){\n\t\t\t\tP p1=ps[i];\n\t\t\t\tP p2=ps[j];\n\t\t\t\tP d=p1.sub(p2);\n\t\t\t\tif(d.abs()>2+EPS){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble v=d.abs();\n\t\t\t\td=d.div(v);\n\t\t\t\tdouble t=sqrt(1-(v/2)*(v/2));\n\t\t\t\tP m=p1.add(p2).div(2);\n\t\t\t\tP c1=m.add(d.rot90().mul(t));\n\t\t\t\tP c2=m.add(d.rot90().mul(-t));\n\t\t\t\tans=max(ans,count(c1));\n\t\t\t\tans=max(ans,count(c2));\n//\t\t\t\tdebug(c1.x,c1.y);\n//\t\t\t\tdebug(c2.x,c2.y);\n//\t\t\t\tdebug(count(c1),count(c2));\n\t\t\t}\n\t\t}\n//\t\tdebug(ans);\n\t\tprintln(ans+\"\");\n\t}\n\t\n\tint count(P p){\n\t\tint res=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(p.sub(ps[i]).abs()<1+EPS){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tclass P{\n\t\tdouble x, y;\n\t\t\n\t\tP(double x,double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t\t\n\t\tP add(P p){return new P(x+p.x,y+p.y);}\n\t\tP sub(P p){return new P(x-p.x,y-p.y);}\n\t\tP mul(double m){return new P(x*m,y*m);}\n\t\tP div(double d){return new P(x/d,y/d);}\n\t\t\n\t\tdouble abs(){ return sqrt(abs2()); }\n\t\tdouble abs2(){ return x*x+y*y; }\n\t\tP rot90(){ return new P(-y,x); }\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tnew Main().calc();\n\t}\n\n\tdouble[] x;\n\tdouble[] y;\n\tint n;\n\tvoid calc(){\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = cin.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tx = new double[n];\n\t\t\ty = new double[n];\n\t\t\tint i,j,k;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tx[i] = cin.nextDouble();\n\t\t\t\ty[i] = cin.nextDouble();\n\t\t\t}\n\t\t\tint ret = 0;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tret = Math.max(ret, getmax(new int[]{i}));\n\t\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\t\tif(Math.hypot(x[i]-x[j], y[i]-y[j]) >= 1) continue;\n\t\t\t\t\tret = Math.max(ret, getmax(new int[]{i,j}));\n\t\t\t\t\tfor(k=j+1;k<n;k++){\n\t\t\t\t\t\tif(Math.hypot(x[k]-x[j], y[k]-y[j]) >= 1) continue;\n\t\t\t\t\t\tif(Math.hypot(x[i]-x[k], y[i]-y[k]) >= 1) continue;\n\t\t\t\t\t\tret = Math.max(ret, getmax(new int[]{i,j,k}));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tSystem.out.println(ret);\n\t\t\t}\n\t\t}\n\t}\n\n\tint getmax(int[] nums){\n\t\tdouble nx = 0;\n\t\tdouble ny = 0;\n\t\tfor(int a : nums){\n\t\t\tnx += x[a]/nums.length;\n\t\t\tny += y[a]/nums.length;\n\t\t}\n\t\tdouble move = 0.7;\n\t\tfor(int i=0;i<20;i++){\n\t\t\tdouble maxdist = 0;\n\t\t\tint num = 0;\n\t\t\tfor(int a :nums){\n\t\t\t\tdouble dist = Math.hypot(nx-x[a], ny-y[a]);\n\t\t\t\tif(maxdist<dist){\n\t\t\t\t\tmaxdist = dist;\n\t\t\t\t\tnum = a;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(maxdist<1) break;\n\t\t\tnx += (x[num]-nx)*move;\n\t\t\tny += (y[num]-ny)*move;\n\t\t\tmove *= 0.7;\n\t\t}\n\t\treturn getnum(nx,ny);\n\t}\n\n\tint getnum(double nx, double ny){\n\t\tint ret = 0;\n\t\tfor(int i = 0;i <n;i++){\n\t\t\tif(Math.hypot(nx-x[i], ny-y[i])<=1) ret++;\n\t\t}\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tnew Main().calc();\n\t}\n\n\tdouble[] x;\n\tdouble[] y;\n\tint n;\n\tvoid calc(){\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = cin.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tx = new double[n];\n\t\t\ty = new double[n];\n\t\t\tint i,j,k;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tx[i] = cin.nextDouble();\n\t\t\t\ty[i] = cin.nextDouble();\n\t\t\t}\n\t\t\tint ret = 0;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tret = Math.max(ret, getmax(new int[]{i}));\n\t\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\t\tif(Math.hypot(x[i]-x[j], y[i]-y[j]) > 2) continue;\n\t\t\t\t\tret = Math.max(ret, getmax(new int[]{i,j}));\n\t\t\t\t\tfor(k=j+1;k<n;k++){\n\t\t\t\t\t\tif(Math.hypot(x[k]-x[j], y[k]-y[j]) > 2) continue;\n\t\t\t\t\t\tif(Math.hypot(x[i]-x[k], y[i]-y[k]) > 2) continue;\n\t\t\t\t\t\tret = Math.max(ret, getmax(new int[]{i,j,k}));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ret);\n\t\t}\n\t}\n\n\tint getmax(int[] nums){\n\t\tdouble nx = 0;\n\t\tdouble ny = 0;\n\t\tfor(int a : nums){\n\t\t\tnx += x[a]/nums.length;\n\t\t\tny += y[a]/nums.length;\n\t\t}\n\t\tdouble move = 0.7;\n\t\tfor(int i=0;i<10;i++){\n\t\t\tdouble maxdist = 0;\n\t\t\tint num = 0;\n\t\t\tfor(int a :nums){\n\t\t\t\tdouble dist = Math.hypot(nx-x[a], ny-y[a]);\n\t\t\t\tif(maxdist<dist){\n\t\t\t\t\tmaxdist = dist;\n\t\t\t\t\tnum = a;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(maxdist<1) break;\n\t\t\tnx += (x[num]-nx)*move;\n\t\t\tny += (y[num]-ny)*move;\n\t\t\tmove *= 0.7;\n\t\t}\n\t\treturn getnum(nx,ny);\n\t}\n\n\tint getnum(double nx, double ny){\n\t\tint ret = 0;\n\t\tfor(int i = 0;i <n;i++){\n\t\t\tif(Math.hypot(nx-x[i], ny-y[i])<=1) ret++;\n\t\t}\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D[] points = new Point2D[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tpoints[i] = new Point2D(sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tint max = 1;\n\t\t\t\n\t\t\tfor(int fst = 0; fst < n; fst++){\n\t\t\t\tfor(int snd = 0; snd < n; snd++){\n\t\t\t\t\tPoint2D[] cross = Point2D.cross_ss(points[fst], 1, points[snd], 1);\n\t\t\t\t\t\n\t\t\t\t\tfor(Point2D cross_c : cross){\n\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\t\tif(cross_c.dist(points[i]) < 1.0 + Point2D.EPS){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tmax = Math.max(max, count);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t\t\n\t}\n}\n\nclass Point2D {\n    public double x;\n    public double y;\n \n    public static final double EPS = 1e-4;\n \n    public Point2D(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n \n    public Point2D(Point2D point) {\n        this.x = point.x;\n        this.y = point.y;\n    }\n \n    public String toString() {\n        return x + \",\" + y;\n    }\n \n    @Override\n    public boolean equals(Object o) {\n        if (o instanceof Point2D) {\n            Point2D another = (Point2D) o;\n            if (this.x - EPS < another.x && this.x + EPS > another.x\n                    && this.y - EPS < another.y && this.y + EPS > another.y) {\n                return true;\n            }\n             \n            return false;\n \n            // return this.x == another.x && this.y == another.y;\n        }\n        return false;\n    }\n \n    public Point2D add(double x, double y) {\n        return new Point2D(this.x + x, this.y + y);\n    }\n \n    public Point2D sub(double x, double y) {\n        return add(-x, -y);\n    }\n \n    public Point2D add(Point2D another) {\n        return add(another.x, another.y);\n    }\n \n    public Point2D sub(Point2D another) {\n        return sub(another.x, another.y);\n    }\n \n    public Point2D mul(double d) {\n        return new Point2D(this.x * d, this.y * d);\n    }\n \n    public Point2D div(double d) {\n        return new Point2D(this.x / d, this.y / d);\n    }\n \n    public double dot(double x, double y) {\n        return this.x * x + this.y * y;\n    }\n \n    public double dot(Point2D another) {\n        return dot(another.x, another.y);\n    }\n \n    public double cross(double x, double y) {\n        return this.x * y - this.y * x;\n    }\n \n    public double cross(Point2D another) {\n        return cross(another.x, another.y);\n    }\n \n    public double dist(double x, double y) {\n        return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n                * (this.y - y));\n    }\n \n    public double dist(Point2D another) {\n        return dist(another.x, another.y);\n    }\n \n    public double dist_o() {\n        return dist(0, 0);\n    }\n \n    public Point2D unit() {\n        return div(dist_o());\n    }\n \n    public boolean pol(Point2D start, Point2D end) {\n        return end.sub(start).cross(this.sub(start)) < EPS;\n    }\n \n    public boolean pos(Point2D start, Point2D end) {\n        return (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n    }\n \n    public double pld(Point2D start, Point2D end) {\n        return Math.abs((end.sub(start).cross(this.sub(start)))\n                / end.sub(start).dist_o());\n    }\n \n    public double psd(Point2D start, Point2D end) {\n        if (end.sub(start).dot(this.sub(start)) < EPS) {\n            return this.dist(start);\n        } else if (start.sub(end).dot(this.sub(end)) < EPS) {\n            return this.dist(end);\n        } else {\n            return end.sub(start).cross(this.sub(start)) / end.dist(start);\n        }\n    }\n \n    public static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS)\n                && (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n    }\n \n    public static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return a1.sub(a2).cross(b1.sub(b2)) < EPS;\n    }\n \n    public static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D b = b2.sub(b1);\n        double d1 = Math.abs(b.cross(a1.sub(b1)));\n        double d2 = Math.abs(b.cross(a2.sub(b1)));\n        double t = d1 / (d1 + d2);\n        Point2D a = a2.sub(a1), v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D a = a2.sub(a1);\n        Point2D b = b2.sub(b1);\n        double t = b.cross(b1.sub(a1)) / b.cross(a);\n        Point2D v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n            double r2) {\n        double dis = p1.dist(p2);\n \n        if (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n            return new Point2D[0]; // same\n        }\n \n        if (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n            Point2D tmp = p2.sub(p1);\n            tmp = tmp.mul(r1 / tmp.dist_o());\n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis + EPS > r1 + r2) {\n            return new Point2D[0]; // out\n        }\n \n        double dis_m = Math.abs(r1 - r2);\n \n        if (dis_m + EPS > dis && dis_m - EPS < dis) {\n            Point2D tmp = null;\n            if (r1 > r2) {\n                tmp = p2.sub(p1);\n            } else {\n                tmp = p1.sub(p2);\n            }\n \n            double min = Math.min(r1, r2);\n \n            tmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n \n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis_m + EPS > dis) {\n            return new Point2D[0]; // inner\n        } else {\n            Point2D ret[] = new Point2D[2];\n \n            double theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n                    / (2 * dis * r1));\n            double a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n \n            ret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n                    * Math.sin(a + theta) + p1.y);\n            ret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n                    * Math.sin(a - theta) + p1.y);\n            return ret;\n        }\n    }\n \n    public void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n            Point2D ans[]) {\n        if (c.pld(start, end) > r + EPS)\n            return;\n        Point2D v = end.sub(start).unit();\n        double delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n                - start.dist(c) * start.dist(c) + r * r;\n        double t = -v.dot(start.sub(c));\n        double s = Math.sqrt(delta);\n        ans[0] = start.add(v.mul(t + s));\n        ans[1] = start.add(v.mul(t + s));\n    }\n \n    public Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n        Point2D v = b.sub(a).unit();\n        v = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n                (-1) * v.y, v.x);\n        return v.mul(p.pld(a, b));\n    }\n \n    public double area(Point2D a, Point2D b, Point2D c) {\n        return Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static double EPS = 1e-6;\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tCircle[] c = new Circle[n];\n\t\t\tLinkedList<Point> p = new LinkedList<Point>();\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tc[i] = new Circle(in.nextDouble(), in.nextDouble(), 1);\n\t\t\t\tfor(int j=i-1; j>=0; j--){\n\t\t\t\t\tPoint[] pos = c[i].crossPoint(c[j]);\n\t\t\t\t\tif(pos == null) continue;\n\t\t\t\t\tp.add(pos[0]);\n\t\t\t\t\tp.add(pos[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res = 1;\n\t\t\tfor(Point pos: p){\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(pos.dist2(c[i].p) <= 1+EPS) count++;\n\t\t\t\t}\n\t\t\t\tres = Math.max(res, count);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n}\n\nclass Circle{\n\tfinal static double EPS = 1e-6;\n\t\n\tPoint p;\n\tdouble r;\n\tpublic Circle(double x, double y, double r){\n\t\tp = new Point(x, y);\n\t\tthis.r = r;\n\t}\n\t\n\tpublic Point[] crossPoint(Circle c){\n\t\tif(!cross(c)) return null;\n\t\tdouble x1 = c.p.x - p.x;\n\t\tdouble y1 = c.p.y - p.y;\n\t\tdouble a = (x1*x1+y1*y1+r*r-c.r*c.r)/2.0;\n\t\tPoint[] res = {\n\t\t\t\tnew Point(culc(x1, y1, r, a, true)+p.x, culc(y1, x1, r, a, false)+p.y),\n\t\t\t\tnew Point(culc(x1, y1, r, a, false)+p.x, culc(y1, x1, r, a, true)+p.y),\n\t\t};\n\t\treturn res;\n\t}\n\t\n\tprivate static double culc(double x, double y, double r, double a, boolean sign){\n\t\treturn (a*x + (sign?1:-1)*y*Math.sqrt((x*x+y*y)*r*r-a*a)+EPS)/(x*x+y*y);\n\t}\n\t\n\tpublic boolean cross(Circle c){\n\t\treturn p.dist2(c.p) <= (r+c.r)*(r+c.r) + EPS;\n\t}\n}\n\nclass Point{\n\tdouble x, y;\n\tpublic Point(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tpublic double dist2(Point p){\n\t\treturn (x-p.x)*(x-p.x) + (y-p.y)*(y-p.y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tint n=in.nextInt();\n\t\t\tif(n==0)\n\t\t\t\treturn;\n\t\t\tPoint p[]=new Point[n];\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tp[i]=new Point(in.nextDouble(), in.nextDouble());\n\t\t\tint max=1;\n\t\t\tint dir[]={1,-1};\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=i+1;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tdouble d=Point.point_distance(p[i],p[j]);\n\t\t\t\t\tif(d>2)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t//中点\n\t\t\t\t\tdouble mx=(p[i].x+p[j].x)/2;\n\t\t\t\t\tdouble my=(p[i].y+p[j].y)/2;\n\t\t\t\t\t//i->jの単位ベクトル\n\t\t\t\t\tdouble vx=(p[j].x-p[i].x)/d;\n\t\t\t\t\tdouble vy=(p[j].y-p[i].y)/d;\n\t\t\t\t\t//m->cの距離\n\t\t\t\t\tdouble e=Math.sqrt(1-d*d/4);\n\t\t\t\t\tfor(int s=0;s<2;s++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//円の中心座標\n\t\t\t\t\t\tPoint pc=new Point(mx-e*vy*dir[s],my+e*vx*dir[s]);\n\t\t\t\t\t\tint cnt=2;\n\t\t\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(k!=i&&k!=j)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//hypotを使わずに距離を比較し計算時間が1/10になった\n\t\t\t\t\t\t\t\tdouble tmp_dis=(pc.x-p[k].x)*(pc.x-p[k].x)+(pc.y-p[k].y)*(pc.y-p[k].y);\n\t\t\t\t\t\t\t\tif(tmp_dis<=1)\n\t\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmax=Math.max(max,cnt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n}\n\nclass Point\n{\n\tdouble x;\n\tdouble y;\n\tPoint(double x,double y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n\t//クラスメソッド\n\tstatic double point_distance(Point p1,Point p2)\n\t{\n\t\treturn Math.hypot(p1.x-p2.x, p1.y-p2.y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.awt.geom.Point2D.Double;\nimport java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tPoint2D.Double[] p = new Point2D.Double[n];\n\t\t\tfor(int i=0;i<n;i++) p[i] = new Point2D.Double(sc.nextDouble(), sc.nextDouble());\n\t\t\t\n\t\t\tArrays.sort(p, new Comparator<Point2D.Double>(){\n\t\t\t\tpublic int compare(Point2D.Double o1, Point2D.Double o2) {\n\t\t\t\t\tif(o1.y-o2.y>0) return 1;\n\t\t\t\t\telse return -1;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tint max = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\tif(p[j].y-p[i].y>2.0001) break;\n\t\t\t\t\tif(p[j].distance(p[i])>2.0001) continue;\n\t\t\t\t\t\n\t\t\t\t\tdouble a, b, c, A, B, C;\n\t\t\t\t\tdouble xa = p[i].x;\n\t\t\t\t\tdouble ya = p[i].y;\n\t\t\t\t\tdouble xb = p[j].x;\n\t\t\t\t\tdouble yb = p[j].y;\n\t\t\t\t\tdouble[] x = new double[2];\n\t\t\t\t\tdouble[] y = new double[2];\n\t\t\t\t\t\n\t\t\t\t\tA = xa-xb;\n\t\t\t\t\tB = ya-yb;\n\t\t\t\t\tC = (A*xa+A*xb+B*ya+B*yb)/2;\n\t\t\t\t\tif(A==0){\n\t\t\t\t\t\tc = (C/B-ya)*(C/B-ya)+xa*xa-1;\n\t\t\t\t\t\tx[0] = xa+Math.sqrt(xa*xa-c);\n\t\t\t\t\t\tx[1] = xa-Math.sqrt(xa*xa-c);\n\t\t\t\t\t\ty[0] = C/B;\n\t\t\t\t\t\ty[1] = C/B;\n\t\t\t\t\t}else if(B==0){\n\t\t\t\t\t\tc = (C/A-xa)*(C/A-xa)+ya*ya-1;\n\t\t\t\t\t\ty[0] = ya+Math.sqrt(ya*ya-c);\n\t\t\t\t\t\ty[1] = ya-Math.sqrt(ya*ya-c);\n\t\t\t\t\t\tx[0] = C/A;\n\t\t\t\t\t\tx[1] = C/A;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ta = 1+(A*A)/(B*B);\n\t\t\t\t\t\tb = (2*A*ya*B-2*A*C-2*xa*B*B)/(B*B);\n\t\t\t\t\t\tc = (C/B-ya)*(C/B-ya)+xa*xa-1;\n\t\t\t\t\t\tx[0] = (-b+Math.sqrt(b*b-4*a*c))/(2*a);\n\t\t\t\t\t\tx[1] = (-b-Math.sqrt(b*b-4*a*c))/(2*a);\n\t\t\t\t\t\ty[0] = (C-A*x[0])/B;\n\t\t\t\t\t\ty[1] = (C-A*x[1])/B;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int d=0;d<2;d++){\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\tfor(int e=0;e<n;e++){\n\t\t\t\t\t\t\tif(p[e].y-y[d]>1.0001) break;\n\t\t\t\t\t\t\tif(p[e].distance(x[d], y[d])<1.0001) cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmax = Math.max(max, cnt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 0.00001;\n\n\tint n;\n\tP[] ps;\n\t\n\tvoid run() {\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tps=new P[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble x=sc.nextDouble();\n\t\t\t\tdouble y=sc.nextDouble();\n\t\t\t\tps[i]=new P(x,y);\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\tint ans=0;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int i=j+1;i<n;i++){\n\t\t\t\tP p1=ps[i];\n\t\t\t\tP p2=ps[j];\n\t\t\t\tP d=p1.sub(p2);\n\t\t\t\tif(d.abs()>2+EPS){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble v=d.abs();\n\t\t\t\td=d.div(v);\n\t\t\t\tdouble t=sqrt(1-(v/2)*(v/2));\n\t\t\t\tP m=p1.add(p2).div(2);\n\t\t\t\tP c1=m.add(d.rot90().mul(t));\n\t\t\t\tP c2=m.add(d.rot90().mul(-t));\n\t\t\t\tans=max(ans,count(c1));\n\t\t\t\tans=max(ans,count(c2));\n//\t\t\t\tdebug(c1.x,c1.y);\n//\t\t\t\tdebug(c2.x,c2.y);\n//\t\t\t\tdebug(count(c1),count(c2));\n\t\t\t}\n\t\t}\n//\t\tdebug(ans);\n\t\tprintln(ans+\"\");\n\t}\n\t\n\tint count(P p){\n\t\tint res=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(p.sub(ps[i]).abs()<1+EPS){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tclass P{\n\t\tdouble x, y;\n\t\t\n\t\tP(double x,double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t\t\n\t\tP add(P p){return new P(x+p.x,y+p.y);}\n\t\tP sub(P p){return new P(x-p.x,y-p.y);}\n\t\tP mul(double m){return new P(x*m,y*m);}\n\t\tP div(double d){return new P(x/d,y/d);}\n\t\t\n\t\tdouble abs(){ return sqrt(abs2()); }\n\t\tdouble abs2(){ return x*x+y*y; }\n\t\tP rot90(){ return new P(-y,x); }\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-6;\n\n\tint n;\n\tP[] ps;\n\t\n\tvoid run() {\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tps=new P[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble x=sc.nextDouble();\n\t\t\t\tdouble y=sc.nextDouble();\n\t\t\t\tps[i]=new P(x,y);\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\tint ans=1;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int i=j+1;i<n;i++){\n\t\t\t\tP p1=ps[i];\n\t\t\t\tP p2=ps[j];\n\t\t\t\tP d=p1.sub(p2);\n\t\t\t\tif(d.abs()>2+EPS){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble v=d.abs();\n\t\t\t\td=d.div(v);\n\t\t\t\tdouble t=sqrt(1-(v/2)*(v/2));\n\t\t\t\tP m=p1.add(p2).div(2);\n\t\t\t\tP c1=m.add(d.rot90().mul(t));\n\t\t\t\tP c2=m.add(d.rot90().mul(-t));\n\t\t\t\tans=max(ans,count(c1));\n\t\t\t\tans=max(ans,count(c2));\n//\t\t\t\tdebug(c1.x,c1.y);\n//\t\t\t\tdebug(c2.x,c2.y);\n//\t\t\t\tdebug(count(c1),count(c2));\n\t\t\t}\n\t\t}\n//\t\tdebug(ans);\n\t\tprintln(ans+\"\");\n\t}\n\t\n\tint count(P p){\n\t\tint res=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(p.sub(ps[i]).abs()<1+EPS){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tclass P{\n\t\tdouble x, y;\n\t\t\n\t\tP(double x,double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t\t\n\t\tP add(P p){return new P(x+p.x,y+p.y);}\n\t\tP sub(P p){return new P(x-p.x,y-p.y);}\n\t\tP mul(double m){return new P(x*m,y*m);}\n\t\tP div(double d){return new P(x/d,y/d);}\n\t\t\n\t\tdouble abs(){ return sqrt(abs2()); }\n\t\tdouble abs2(){ return x*x+y*y; }\n\t\tP rot90(){ return new P(-y,x); }\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tnew Main().calc();\n\t}\n\n\tdouble[] x;\n\tdouble[] y;\n\tint n;\n\tvoid calc(){\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = cin.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tx = new double[n];\n\t\t\ty = new double[n];\n\t\t\tint i,j;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tx[i] = cin.nextDouble();\n\t\t\t\ty[i] = cin.nextDouble();\n\t\t\t}\n\t\t\tint ret = 0;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tret = Math.max(ret, getnum(x[i],y[i]));\n\t\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\t\tif(Math.hypot(x[i]-x[j], y[i]-y[j]) > 2) continue;\n\t\t\t\t\tret = Math.max(ret, getmax(new int[]{i,j}));\n\t\t\t\t\tret = Math.max(ret, getmax(new int[]{j,i}));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ret);\n\t\t}\n\t}\n\n\tint getmax(int[] nums){\n\t\tdouble nx = 0;\n\t\tdouble ny = 0;\n\t\tfor(int a : nums){\n\t\t\tnx += x[a]/nums.length;\n\t\t\tny += y[a]/nums.length;\n\t\t}\n\t\tdouble vx = nx-x[nums[0]];\n\t\tdouble vy = ny-y[nums[0]];\n\t\tdouble d = Math.hypot(vx, vy);\n\t\tdouble nokori = 1-d;\n\t\tnx += vy / Math.hypot(vx, vy) * nokori;\n\t\tny -= vx / Math.hypot(vx, vy) * nokori;\n\t\treturn getnum(nx,ny);\n\t}\n\n\tint getnum(double nx, double ny){\n\t\tint ret = 0;\n\t\tfor(int i = 0;i <n;i++){\n\t\t\tif(Math.hypot(nx-x[i], ny-y[i])<=1) ret++;\n\t\t}\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tnew Main().calc();\n\t}\n\n\tdouble[] x;\n\tdouble[] y;\n\tint n;\n\tvoid calc(){\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = cin.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tx = new double[n];\n\t\t\ty = new double[n];\n\t\t\tint i,j,k;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tx[i] = cin.nextDouble();\n\t\t\t\ty[i] = cin.nextDouble();\n\t\t\t}\n\t\t\tint ret = 0;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tret = Math.max(ret, getmax(new int[]{i}));\n\t\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\t\tif(Math.hypot(x[i]-x[j], y[i]-y[j]) > 2) continue;\n\t\t\t\t\tret = Math.max(ret, getmax(new int[]{i,j}));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ret);\n\t\t}\n\t}\n\n\tint getmax(int[] nums){\n\t\tdouble nx = 0;\n\t\tdouble ny = 0;\n\t\tfor(int a : nums){\n\t\t\tnx += x[a]/nums.length;\n\t\t\tny += y[a]/nums.length;\n\t\t}\n\t\tdouble move = 0.7;\n\t\tfor(int i=0;i<20;i++){\n\t\t\tdouble maxdist = 0;\n\t\t\tint num = 0;\n\t\t\tfor(int a :nums){\n\t\t\t\tdouble dist = Math.hypot(nx-x[a], ny-y[a]);\n\t\t\t\tif(maxdist<dist){\n\t\t\t\t\tmaxdist = dist;\n\t\t\t\t\tnum = a;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(maxdist<1) break;\n\t\t\tnx += (x[num]-nx)*move;\n\t\t\tny += (y[num]-ny)*move;\n\t\t\tmove *= 0.7;\n\t\t}\n\t\treturn getnum(nx,ny);\n\t}\n\n\tint getnum(double nx, double ny){\n\t\tint ret = 0;\n\t\tfor(int i = 0;i <n;i++){\n\t\t\tif(Math.hypot(nx-x[i], ny-y[i])<=1) ret++;\n\t\t}\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    final double EPS = 1.0e-10;\n\n    void run() {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            P[] ps = new P[n];\n            for (int i = 0; i < n; i++) {\n                ps[i] = new P(sc.nextDouble(), sc.nextDouble());\n            }\n            int ans = 0;\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    if (ps[i].sub(ps[j]).abs() >= 2)\n                        continue;\n                    P[] cs = makeCircle(ps[i], ps[j], 1.0);\n                    for (int l = 0; l < 2; l++) {\n                        double cx = cs[l].x;\n                        double cy = cs[l].y;\n                        int c = 0;\n                        for (int k = 0; k < n; k++) {\n//                            if (k == i || k == j)\n//                                continue;\n                            if ((ps[k].x - cx) * (ps[k].x - cx)\n                                    + (ps[k].y - cy) * (ps[k].y - cy) <= 1.0 + EPS) {\n                                c++;\n                            }\n                        }\n                        ans = Math.max(c, ans);\n                    }\n                }\n            }\n            System.out.println(ans);\n        }\n\n    }\n\n    P[] makeCircle(P a, P b, double r) {\n        double th = Math.atan(-(b.x - a.x) / (b.y - a.y));\n        P m = a.add(b).mul(0.5);\n        double dis = Math.sqrt(r * r - b.sub(m).abs2());\n        return new P[] {\n                new P(m.x - dis * Math.cos(th), m.y - dis * Math.sin(th)),\n                new P(m.x + dis * Math.cos(th), m.y + dis * Math.sin(th)) };\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n\nclass P {\n    double x;\n    double y;\n\n    P(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public String toString() {\n        return \"(\" + x + \" , \" + y + \")\";\n    }\n\n    public P add(P p) {\n        return new P(p.x + x, p.y + y);\n    }\n\n    public P sub(P p) {\n        return new P(x - p.x, y - p.y);\n    }\n\n    public P mul(double k) {\n        return new P(k * x, k * y);\n    }\n\n    public double abs() {\n        return Math.sqrt(x * x + y * y);\n    }\n\n    public double abs2() {\n        return x * x + y * y;\n    }\n\n    public double det(P p) {\n        return x * p.y - y * p.x;\n    }\n\n    public P rot90() {\n        return new P(-y, x);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Point2D.Double;\nimport java.util.*;\n  \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n  \n    public static void main(String[] args) {\n        new Main(); \n    }\n  \n    public Main() {\n        new aoj2151().doIt();\n    }\n    class aoj2151{\n    \tPoint2D[] p = new Point2D[301];\n    \tint ans(int n){\n    \t\tint result = 1;\n    \t\tfor(int i = 0;i < n;i++){\n    \t\t\tfor(int j = i+1;j < n;j++){\n    \t\t\t\tdouble dot = p[i].distance(p[j]);\n//    \t\t\t\tSystem.out.println(dot);\n    \t\t\t\tif(dot > 2.0)continue;\n    \t\t\t\tdouble e = Math.sqrt(1.0 - dot*dot/4.0);\n    \t\t\t\tfor (int pm = 0; pm < 2; ++pm) {\n    \t\t\t\t\tPoint2D c = new Point2D.Double((p[i].getX()+p[j].getX())/2.0 + (p[j].getY()-p[i].getY())*e/dot,\n    \t\t\t\t\t\t\t(p[i].getY()+p[j].getY())/2.0 - (p[j].getX()-p[i].getX())*e/dot);\n    \t\t\t\t\tint cnt = 2;\n    \t\t\t\t\tfor (int k = 0; k < n; ++k) {\n    \t\t\t\t\t\tif (k == i || k == j)continue;\n    \t\t\t\t        if ((c.getX()-p[k].getX())*(c.getX()-p[k].getX())+(c.getY()-p[k].getY())*(c.getY()-p[k].getY()) <= 1.0 + 0.000001)cnt++;\n    \t\t\t\t      }\n    \t\t\t\t      result = Math.max(result, cnt);\n    \t\t\t\t      e *= -1.0;\n    \t\t\t\t    }\n    \t\t\t\t}\n    \t\t\t}\n    \t\treturn result;\n    \t}\n    \tvoid doIt(){\n    \t\twhile(true){\n    \t\t\tint n = sc.nextInt();\n    \t\t\tif(n == 0)break;\n    \t\t\tfor(int i = 0;i < n;i++){\n    \t\t\t\tp[i] = new Point2D.Double(sc.nextDouble(),sc.nextDouble());\n    \t\t\t}\n    \t\t\tSystem.out.println(ans(n));\n    \t\t}\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    final double EPS = 1.0e-10;\n\n    void run() {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            P[] ps = new P[n];\n            for (int i = 0; i < n; i++) {\n                ps[i] = new P(sc.nextDouble(), sc.nextDouble());\n            }\n            int ans = 1;\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    if (ps[i].sub(ps[j]).abs() > 2)\n                        continue;\n                    P[] cs = makeCircle(ps[i], ps[j], 1.0);\n                    for (int l = 0; l < 2; l++) {\n                        double cx = cs[l].x;\n                        double cy = cs[l].y;\n                        int c = 2;\n                        for (int k = 0; k < n; k++) {\n                            if (k == i || k == j)\n                                continue;\n                            if ((ps[k].x - cx) * (ps[k].x - cx)\n                                    + (ps[k].y - cy) * (ps[k].y - cy) <= 1.0 + EPS) {\n                                c++;\n                            }\n                        }\n                        ans = Math.max(c, ans);\n                    }\n                }\n            }\n            System.out.println(ans);\n        }\n\n    }\n\n    P[] makeCircle(P a, P b, double r) {\n        double th = Math.atan(-(b.x - a.x) / (b.y - a.y));\n        P m = a.add(b).mul(0.5);\n        double dis = Math.sqrt(r * r - b.sub(m).abs2());\n        return new P[] {\n                new P(m.x - dis * Math.cos(th), m.y - dis * Math.sin(th)),\n                new P(m.x + dis * Math.cos(th), m.y + dis * Math.sin(th)) };\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n\nclass P {\n    double x;\n    double y;\n\n    P(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public String toString() {\n        return \"(\" + x + \" , \" + y + \")\";\n    }\n\n    public P add(P p) {\n        return new P(p.x + x, p.y + y);\n    }\n\n    public P sub(P p) {\n        return new P(x - p.x, y - p.y);\n    }\n\n    public P mul(double k) {\n        return new P(k * x, k * y);\n    }\n\n    public double abs() {\n        return Math.sqrt(x * x + y * y);\n    }\n\n    public double abs2() {\n        return x * x + y * y;\n    }\n\n    public double det(P p) {\n        return x * p.y - y * p.x;\n    }\n\n    public P rot90() {\n        return new P(-y, x);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D[] points = new Point2D[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tpoints[i] = new Point2D(sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tint max = 0;\n\t\t\t\n\t\t\tfor(int fst = 0; fst < n; fst++){\n\t\t\t\tfor(int snd = 0; snd < n; snd++){\n\t\t\t\t\tPoint2D[] cross = Point2D.cross_ss(points[fst], 1, points[snd], 1);\n\t\t\t\t\t\n\t\t\t\t\tfor(Point2D cross_c : cross){\n\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\t\tif(cross_c.dist(points[i]) < 1.0 + Point2D.EPS){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tmax = Math.max(max, count);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t\t\n\t}\n}\n\nclass Point2D {\n    public double x;\n    public double y;\n \n    public static final double EPS = 1e-6;\n \n    public Point2D(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n \n    public Point2D(Point2D point) {\n        this.x = point.x;\n        this.y = point.y;\n    }\n \n    public String toString() {\n        return x + \",\" + y;\n    }\n \n    @Override\n    public boolean equals(Object o) {\n        if (o instanceof Point2D) {\n            Point2D another = (Point2D) o;\n            if (this.x - EPS < another.x && this.x + EPS > another.x\n                    && this.y - EPS < another.y && this.y + EPS > another.y) {\n                return true;\n            }\n             \n            return false;\n \n            // return this.x == another.x && this.y == another.y;\n        }\n        return false;\n    }\n \n    public Point2D add(double x, double y) {\n        return new Point2D(this.x + x, this.y + y);\n    }\n \n    public Point2D sub(double x, double y) {\n        return add(-x, -y);\n    }\n \n    public Point2D add(Point2D another) {\n        return add(another.x, another.y);\n    }\n \n    public Point2D sub(Point2D another) {\n        return sub(another.x, another.y);\n    }\n \n    public Point2D mul(double d) {\n        return new Point2D(this.x * d, this.y * d);\n    }\n \n    public Point2D div(double d) {\n        return new Point2D(this.x / d, this.y / d);\n    }\n \n    public double dot(double x, double y) {\n        return this.x * x + this.y * y;\n    }\n \n    public double dot(Point2D another) {\n        return dot(another.x, another.y);\n    }\n \n    public double cross(double x, double y) {\n        return this.x * y - this.y * x;\n    }\n \n    public double cross(Point2D another) {\n        return cross(another.x, another.y);\n    }\n \n    public double dist(double x, double y) {\n        return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n                * (this.y - y));\n    }\n \n    public double dist(Point2D another) {\n        return dist(another.x, another.y);\n    }\n \n    public double dist_o() {\n        return dist(0, 0);\n    }\n \n    public Point2D unit() {\n        return div(dist_o());\n    }\n \n    public boolean pol(Point2D start, Point2D end) {\n        return end.sub(start).cross(this.sub(start)) < EPS;\n    }\n \n    public boolean pos(Point2D start, Point2D end) {\n        return (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n    }\n \n    public double pld(Point2D start, Point2D end) {\n        return Math.abs((end.sub(start).cross(this.sub(start)))\n                / end.sub(start).dist_o());\n    }\n \n    public double psd(Point2D start, Point2D end) {\n        if (end.sub(start).dot(this.sub(start)) < EPS) {\n            return this.dist(start);\n        } else if (start.sub(end).dot(this.sub(end)) < EPS) {\n            return this.dist(end);\n        } else {\n            return end.sub(start).cross(this.sub(start)) / end.dist(start);\n        }\n    }\n \n    public static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS)\n                && (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n    }\n \n    public static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        return a1.sub(a2).cross(b1.sub(b2)) < EPS;\n    }\n \n    public static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D b = b2.sub(b1);\n        double d1 = Math.abs(b.cross(a1.sub(b1)));\n        double d2 = Math.abs(b.cross(a2.sub(b1)));\n        double t = d1 / (d1 + d2);\n        Point2D a = a2.sub(a1), v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n            Point2D b2) {\n        Point2D a = a2.sub(a1);\n        Point2D b = b2.sub(b1);\n        double t = b.cross(b1.sub(a1)) / b.cross(a);\n        Point2D v = a.mul(t);\n        return a1.add(v);\n    }\n \n    public static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n            double r2) {\n        double dis = p1.dist(p2);\n \n        if (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n            return new Point2D[0]; // same\n        }\n \n        if (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n            Point2D tmp = p2.sub(p1);\n            tmp = tmp.mul(r1 / tmp.dist_o());\n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis + EPS > r1 + r2) {\n            return new Point2D[0]; // out\n        }\n \n        double dis_m = Math.abs(r1 - r2);\n \n        if (dis_m + EPS > dis && dis_m - EPS < dis) {\n            Point2D tmp = null;\n            if (r1 > r2) {\n                tmp = p2.sub(p1);\n            } else {\n                tmp = p1.sub(p2);\n            }\n \n            double min = Math.min(r1, r2);\n \n            tmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n \n            Point2D ret[] = new Point2D[1];\n            ret[0] = p1.add(tmp);\n            return ret;\n        } else if (dis_m + EPS > dis) {\n            return new Point2D[0]; // inner\n        } else {\n            Point2D ret[] = new Point2D[2];\n \n            double theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n                    / (2 * dis * r1));\n            double a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n \n            ret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n                    * Math.sin(a + theta) + p1.y);\n            ret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n                    * Math.sin(a - theta) + p1.y);\n            return ret;\n        }\n    }\n \n    public void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n            Point2D ans[]) {\n        if (c.pld(start, end) > r + EPS)\n            return;\n        Point2D v = end.sub(start).unit();\n        double delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n                - start.dist(c) * start.dist(c) + r * r;\n        double t = -v.dot(start.sub(c));\n        double s = Math.sqrt(delta);\n        ans[0] = start.add(v.mul(t + s));\n        ans[1] = start.add(v.mul(t + s));\n    }\n \n    public Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n        Point2D v = b.sub(a).unit();\n        v = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n                (-1) * v.y, v.x);\n        return v.mul(p.pld(a, b));\n    }\n \n    public double area(Point2D a, Point2D b, Point2D c) {\n        return Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n    }\n \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing static System.Math;\nusing static System.Array;\nusing static AtCoder.Tool;\nnamespace AtCoder\n{\n    class AC\n    {\n        const int mod = 1000000007;\n        const int INF = int.MaxValue / 2;\n        const long SINF = long.MaxValue / 2;\n        const double EPS = 1e-8;\n        //static readonly int[] dx = { 0, 1, 0, -1 };\n        //static readonly int[] dy = { 1, 0, -1, 0 };\n        \n\n        static void Main(string[] args)\n        {\n            var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            Console.SetOut(sw);\n            var cin = new Scanner();\n\n           \n            while (true)\n            {\n                int N = int.Parse(Console.ReadLine());\n                if (N == 0) {\n                    //Console.Out.Flush();\n                    break;\n                }\n                \n                double[] x = new double[N];\n                double[] y = new double[N];\n                for(var i = 0; i < N; i++)\n                {\n                    var p = Console.ReadLine().Split().Select(double.Parse).ToArray();\n                    x[i] = p[0];\n                    y[i] = p[1];\n                }\n                if (N == 1)\n                {\n                    Console.WriteLine(1);\n                    continue;\n                }\n                long ans = -1;\n\n                for(var i = 0; i < N - 1; i++)\n                {\n                    for(var j = i + 1; j < N; j++)\n                    {\n                        double dx = x[j] - x[i];\n                        double dy = y[j] - y[i];\n                       \n                        double r = Sqrt((dx * dx) + (dy * dy));\n                        if (r > 2) {\n                            ans = Max(ans, 1);\n                            continue; }\n                        double D = Sqrt(1 - ((r * r) / 4));\n\n                        double vx = -dy * D / r;\n                        double vy = dx * D / r;\n\n                        var cx = new double[2];\n                        var cy = new double[2];\n                        cx[0] = x[i] + (dx / 2) + vx;\n                        cx[1] = x[i] + (dx / 2) - vx;\n                        cy[0] = y[i] + (dy / 2) + vy;\n                        cy[1] = y[i] + (dy / 2) - vy;\n\n                        \n\n                        for (var k = 0; k <= 1; k++) \n                        {\n                            long cnt = 2;\n                            for (var l = 0; l < N; l++)\n                            {\n                                if (l == i || l == j) { continue; }\n                                double dist = Sqrt(Pow(cx[k] - x[l], 2) + Pow(cy[k] - y[l], 2));\n                                if (dist < 1 + EPS)  { cnt++; }\n                            }\n                            ans = Max(ans, cnt);\n                        }\n                    }\n                }\n\n\n                Console.WriteLine(ans);\n                \n                \n            }\n            \n            Console.Out.Flush();\n\n        }\n        \n    }\n    \n    public class Scanner\n    {\n        public int[] SplitRead()\n        {\n            int[] array = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            return array;\n        }\n        public long[] SplitReadL()\n        {\n            long[] array = Console.ReadLine().Split().Select(long.Parse).ToArray();\n            return array;\n        }\n    }\n\n    public static class Tool\n    {\n        static public void Initialize<T>(ref T[] array, T initialvalue)\n        {\n            for (var i = 0; i < array.Length; i++)\n            {\n                array[i] = initialvalue;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "include Math\n\nloop {\n\tn = gets.to_i\n\tbreak if n == 0\n\tpoints = (1..n).map { gets.split.map &:to_f }\n\n\tmax = 1\n\tpoints.combination(2){|(x1, y1), (x2, y2)|\n\t\tl = hypot(x1 - x2, y1 - y2)\n\t\tnext if l > 2\n\t\tk = sqrt(4 - l*l) / l\n\t\t\t\n\t\tu = (x1 + x2 + k * (y1 - y2)) / 2\n\t\tv = (y1 + y2 + k * (x2 - x1)) / 2\n\t\tc = points.count{|x, y| hypot(u-x, v-y) <= 1.00001}\n\t\tmax = c if c > max\n\n\t\tu = (x1 + x2 - k * (y1 - y2)) / 2\n\t\tv = (y1 + y2 - k * (x2 - x1)) / 2\n\t\tc = points.count{|x, y| hypot(u-x, v-y) <= 1}\n\t\tmax = c if c > max\n\t}\n\tp max\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nDELTA = 1e-9\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  pts = n.times.map{gets.split.map(&:to_f)}\n  #p pts\n\n  max_c = 1\n\n  for i in (0...n)\n    xi, yi = pts[i]\n    for j in ((i + 1)...n)\n      xj, yj = pts[j]\n\n      dx = xj - xi\n      dy = yj - yi\n      d2 = dx * dx + dy * dy\n\n      if d2 < 4.0\n        d = Math.sqrt(d2)\n        t = Math.sqrt(1.0 - d2 / 4)\n\n        xh = (xi + xj) / 2\n        yh = (yi + yj) / 2\n        dxh = -dy / d\n        dyh =  dx / d\n\n        x0 = xh + t * dxh\n        y0 = yh + t * dyh\n\n        x1 = xh - t * dxh\n        y1 = yh - t * dyh\n\n        #p [xi, yi, xj, yj, x0, y0, x1, y1]\n\n        c0 = c1 = 0\n        pts.each do |x, y|\n          c0 += 1 if (x - x0) ** 2 + (y - y0) ** 2 < 1.0 + DELTA\n          c1 += 1 if (x - x1) ** 2 + (y - y1) ** 2 < 1.0 + DELTA\n        end\n        max_c = c0 if max_c < c0\n        max_c = c1 if max_c < c1\n      end\n    end\n  end\n\n  puts max_c\nend"
  },
  {
    "language": "Ruby",
    "code": "# Circle and Points\n\n########################################\n# 誤差\n#\nEPS = 1e-10\n\n########################################\n# case文でメソッドオーバーロードもどきを無理やり作るための比較演算子\n#\nclass Class\n  def ===(other)\n    self==other\n  end\nend\n\n########################################\n#                  点\n#\nclass Point\n  include Comparable\n  attr_accessor :x, :y\n  def initialize(x=0.0, y=0.0)\n    @x, @y = x.to_f, y.to_f\n  end\n\n  def <=>(p)\n    @x != p.x ? @x <=> p.x : @y <=> p.y\n  end\n  def +(p)\n    Point.new(@x+p.x, @y+p.y)\n  end\n  def -(p)\n    Point.new(@x-p.x, @y-p.y)\n  end\n  def -@\n    Point.new(-@x, -@y)\n  end\n\n  def times(f)\n    Point.new(@x*f, @y*f)\n  end\n  def dot(p)\n    @x*p.x + @y*p.y\n  end\n  def cross(p)\n    @x*p.y - @y*p.x\n  end\n  def abs\n    Math::hypot(@x, @y)\n  end\n  def norm\n    @x**2 + @y**2\n  end\n  # 直線abと点pの位置関係を調べる\n  # 0: 線分上, -1: 時計回り, 1: 反時計回り, -2: a-b-p, 2: p-a-b\n  def ccw(b, p)\n    a = self\n    v1, v2 = b-a, p-a\n    return 1 if v1.cross(v2) > 0\n    return -1 if v1.cross(v2) < 0\n    return 2 if v1.dot(v2) < 0\n    return -2 if v1.norm < v2.norm\n    0\n  end\nend\n\n########################################\n#                 直線\n#\nclass Line\n  attr_accessor :a, :b\n  def initialize(p1=Point.new, p2=Point.new)\n    @a, @b = p1, p2\n  end\n\n  # 直線abと点pの位置関係を調べる\n  # 0: 線分上, -1: 時計回り, 1: 反時計回り, -2: a-b-p, 2: p-a-b\n  def ccw(p)\n    v1, v2 = @b - @a, p - @a\n    return 1 if v1.cross(v2) > 0\n    return -1 if v1.cross(v2) < 0\n    return 2 if v1.dot(v2) < 0\n    return -2 if v1.norm < v2.norm\n    0\n  end\n  # 交差判定\n  def intersect?(target)\n    case target.class\n      when Point\n        v1, v2 = @a-target, @b-target\n        return (v2.cross(v1)).abs == 0.0\n      when Segment\n        v1, v2, v3 = @b-@a, target.a-@a, target.b-@a\n        return v1.cross(v2) * v1.cross(v3) <= 0.0\n      when Line\n        v1, v2, v3 = @b-@a, target.b-target.a, target.a-@a\n        return v1.cross(v2).abs > 0.0 || v1.cross(v3).abs == 0.0\n    end\n  end\n  # 直線上に射影した点\n  def projection(p)\n    v1, v2 = p-a, a-b\n    a + v2.times(v1.dot(v2)/v2.norm)\n  end\n  # 直線に関して対象な点\n  def reflection(p)\n    p + (projection(p) - p).times(2.0)\n  end\n  # 距離\n  def distance(target)\n    case target.class\n      when Point\n        return (target - projection(target)).abs\n      when Segment\n        return intersect?(target) ? 0.0 : [distance(target.a), distance(target.b)].min\n      when Line\n        return intersect?(target) ? 0.0 : distance(target.a)\n    end\n  end\n  # 交点\n  def crosspoint(l)\n    v1, v2, v3 = @b-@a, l.b-l.a, @b-l.a\n    a, b = v1.cross(v2), v1.cross(v3)\n    return l.a if a.abs == 0.0 && b.abs == 0.0\n    l.a + v2.times(b/a)\n  end\nend\n\n########################################\n#                 線分\n#\nclass Segment < Line\n  # 交差判定\n  def intersect?(target)\n    case target.class\n      when Point\n        return (@a-target).abs + (@b-target).abs == (@b-@a).abs\n      when Segment\n        return target.ccw(@a) * target.ccw(@b) <= 0 && ccw(target.a) * ccw(target.b) <= 0\n      when Line\n        return target.intersect?(self)\n    end\n  end\n  # 距離\n  def distance(target)\n    case target.class\n      when Point\n        p = projection(target)\n        return intersect?(p) ? (p-target).abs : [(@a-target).abs, (@b-target).abs].min\n      when Segment\n        return intersect?(target) ? 0.0 : [distance(target.a), distance(target.b), target.distance(@a), target.distance(@b)].min\n      when Line\n        return target.distance(self)\n    end\n  end\nend\n\n########################################\n#                  円\n#\nclass Circle\n  include Comparable\n  attr_accessor :x, :y, :r\n  def initialize(x=0.0, y=0.0, r=1.0)\n    @x, @y, @r = x.to_f, y.to_f, r.to_f\n  end\n\n  def <=>(c)\n    @x!=c.x ? @x<=>c.x : (@y!=c.y ? @y<=>c.y : @r<=>c.r)\n  end\n\n  def point\n    Point.new(@x, @y)\n  end\n  def distance(c)\n    (point-c.point).abs\n  end\n  # 点を含むか\n  def include?(p)\n#     (point-p).abs <= @r         # 誤差死 AOJ1190\n    (point-p).abs - @r <= EPS\n  end\n  # 円に含まれるか\n  def in?(c)\n#     distance(c) < (@r-c.r).abs  # 誤差死 AOJ1190\n    distance(c) - (@r-c.r).abs < EPS\n  end\n  # 交差判定\n  def touch?(c)\n    distance(c) <= @r + c.r     # 誤差死の可能性？\n#     distance(c) - @r - c.r <= EPS\n  end\n  # 交点\n  def crosspoint(c)\n    angle = Math::atan2(c.y-@y, c.x-@x)\n    d = distance(c)\n    add = Math::acos((d**2 + @r**2 - c.r**2) / (2.0*d*@r))\n    p1 = Point.new(@x+@r*Math::cos(angle+add), @y+@r*Math::sin(angle+add))\n    p2 = Point.new(@x+@r*Math::cos(angle-add), @y+@r*Math::sin(angle-add))\n    [p1, p2]\n  end\nend\n\n########################################\n# メイン\nwhile (n = gets.to_i) != 0\n  point = Array.new\n  circle = Array.new\n  n.times do\n    x, y, r = *gets.split.map(&:to_f), 1.0\n    point.push(Point.new(x, y))\n    circle.push(Circle.new(x, y, r))\n  end\n  crosspoint = Array.new\n  for i in 0...(n-1) do\n    for j in (i+1)...n do\n      next unless circle[i].touch?(circle[j])\n      crosspoint.push(*circle[i].crosspoint(circle[j]))\n    end\n  end\n  answer = 0\n  crosspoint.each do |cp|\n    count = 0\n    point.each do |p|\n      count += 1 if Circle.new(cp.x, cp.y, 1.0).include?(p)\n    end\n    answer = [answer, count].max\n  end\n  p answer\nend"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"math/cmplx\"\n)\n\nfunc main() {\n\tfor {\n\t\tvar n int\n\t\tfmt.Scan(&n)\n\n\t\tif n == 0 {\n\t\t\treturn\n\t\t}\n\n\t\tarr := make([]complex128, n)\n\n\t\tfor i := 0; i < n; i++ {\n\t\t\tvar x, y float64\n\n\t\t\tfmt.Scanf(\"%f%f\", &x, &y)\n\n\t\t\tarr[i] = complex(x, y)\n\t\t}\n\n\t\tmax := 1\n\t\tfor i := 0; i < n; i++ {\n\t\t\tfor j := i + 1; j < n; j++ {\n\t\t\t\tsub := arr[j] - arr[i]\n\n\t\t\t\tif cmplx.Abs(sub) >= 2 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tsum := arr[j] + arr[i]\n\n\t\t\t\tv := 1\n\t\t\t\t{\n\t\t\t\t\thalfd := cmplx.Abs(sub / 2)\n\n\t\t\t\t\tcenter := sum/2 + sub*cmplx.Rect(math.Sqrt(1-halfd*halfd)/cmplx.Abs(sub), float64(v)*math.Pi/2)\n\n\t\t\t\t\tcounter := 0\n\t\t\t\t\tfor k := 0; k < n; k++ {\n\t\t\t\t\t\tif i == k || j == k || cmplx.Abs(arr[k]-center) <= 1 {\n\t\t\t\t\t\t\tcounter++\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif max < counter {\n\t\t\t\t\t\tmax = counter\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tv = -1\n\t\t\t\t{\n\t\t\t\t\thalfd := cmplx.Abs(sub / 2)\n\n\t\t\t\t\tcenter := sum/2 + sub*cmplx.Rect(math.Sqrt(1-halfd*halfd)/cmplx.Abs(sub), float64(v)*math.Pi/2)\n\n\t\t\t\t\tcounter := 0\n\t\t\t\t\tfor k := 0; k < n; k++ {\n\t\t\t\t\t\tif i == k || j == k || cmplx.Abs(arr[k]-center) <= 1 {\n\t\t\t\t\t\t\tcounter++\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif max < counter {\n\t\t\t\t\t\tmax = counter\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tfmt.Println(max)\n\t}\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv;\nimport std.string;\nimport std.typecons;\nimport std.algorithm;\nimport std.array;\nimport std.range;\nimport std.math;\nimport std.container;\nimport std.datetime;\n\nalias P = Tuple!(double, double);\n\nclass Circle {\n\tcdouble p;\n\tdouble r;\n\tthis (cdouble p, double r) {\n\t\tthis.p = p;\n\t\tthis.r = r;\n\t}\n}\n\n\ncdouble[] intersectCC(Circle a, Circle b) {\n\tcdouble[] res;\n\n\tauto d = abs(a.p - b.p);\n\tauto c = (d*d + a.r*a.r - b.r*b.r) / (2*d);\n\tauto s = sqrt(a.r*a.r - c*c);\n\tauto diff = (b.p - a.p) / d;\n\tres ~= a.p + diff * (c + s * 1i);\n\tres ~= a.p + diff * (c - s * 1i);\n\n\treturn res;\n}\n\n\nbool containsCP(Circle c, cdouble p) {\n\timmutable EPS = 10e-7;\n\tauto d = abs(c.p - p);\n\treturn d <= c.r + EPS;\n}\n\n\nvoid main()\n{\n\tint n;\n\n\twhile (n = readln.chomp.to!int, n) {\n\t\tauto ps = new cdouble[](n);\n\t\tforeach (i; 0..n) {\n\t\t\tauto x = readln.chomp.split.map!(to!double);\n\t\t\tps[i] = x[0] + x[1] * 1i;\n\t\t}\n\n\t\tauto res = 1;\n\n\t\tforeach (i; 0..n) {\n\t\t\tforeach (j; i+1..n) {\n\t\t\t\tif (abs(ps[i]-ps[j]) > 2) continue;\n\t\t\t\tauto cp = intersectCC(new Circle(ps[i], 1.0), new Circle(ps[j], 1.0));\n\t\t\t\tint cnt;\n\t\t\t\t\n\t\t\t\tforeach (k; 0..n) {\n\t\t\t\t\tif (containsCP(new Circle(cp[0], 1.0), ps[k])) cnt++;\n\t\t\t\t}\n\n\t\t\t\tres = max(cnt, res);\n\t\t\t\tcnt = 0;\n\n\t\t\t\tforeach (k; 0..n) {\n\t\t\t\t\tif (containsCP(new Circle(cp[1], 1.0), ps[k])) cnt++;\n\t\t\t\t}\n\t\t\t\tres = max(cnt, res);\n\t\t\t}\n\t\t}\n\t\tres.writeln;\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv, std.algorithm, std.math;\n\nvoid main()\n{\n    while(true)\n    {\n        int n = readln.chomp.to!int;\n        if(!n) break;\n\n        creal[300] ps;\n\n        foreach(i; 0 .. n)\n        {\n            auto f = readln.split.map!(to!real);\n            ps[i] = f[0] + f[1] * 1.0i;\n        }\n\n        int max;\n\n        foreach(i; 0 .. n) foreach(j; i + 1 .. n)\n        {\n            int enc;\n            creal m = (ps[i] + ps[j]) / 2.0;\n            foreach(k; 0 .. n)\n            {\n                if(abs(m - ps[k]) <= 1) ++enc;\n            }\n            if(enc > max) max = enc;\n        }\n\n        foreach(i; 0 .. n) foreach(j; i + 1 .. n) foreach(k; j + 1 .. n)\n        {\n            int enc;\n            creal m = (ps[i] + ps[j] + ps[k]) / 3.0;\n            foreach(l; 0 .. n)\n            {\n                if(abs(m - ps[l]) <= 1) ++enc;\n            }\n            if(enc > max) max = enc;\n        }\n\n        max.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv;\nimport std.string;\nimport std.typecons;\nimport std.algorithm;\nimport std.array;\nimport std.range;\nimport std.math;\nimport std.container;\nimport std.datetime;\n\nclass Circle {\n\tcdouble p;\n\tdouble r;\n\tthis (cdouble p, double r) {\n\t\tthis.p = p;\n\t\tthis.r = r;\n\t}\n}\n\n\ncdouble[] intersectCC(Circle a, Circle b) {\n\tcdouble[] res;\n\n\tauto d = abs(a.p - b.p);\n\tauto c = (d*d + a.r*a.r - b.r*b.r) / (2*d);\n\tauto s = sqrt(a.r*a.r - c*c);\n\tauto diff = (b.p - a.p) / d;\n\tres ~= a.p + diff * (c + s * 1i);\n\tres ~= a.p + diff * (c - s * 1i);\n\n\treturn res;\n}\n\n\nbool containsCP(Circle c, cdouble p) {\n\timmutable EPS = 10e-7;\n\tauto d = abs(c.p - p);\n\treturn d <= c.r + EPS;\n}\n\n\nvoid main()\n{\n\tint n;\n\n\twhile (n = readln.chomp.to!int, n) {\n\t\tauto ps = new cdouble[](n);\n\t\tforeach (i; 0..n) {\n\t\t\tauto x = readln.chomp.split.map!(to!double);\n\t\t\tps[i] = x[0] + x[1] * 1i;\n\t\t}\n\n\t\tauto res = 1;\n\n\t\tforeach (i; 0..n) {\n\t\t\tforeach (j; i+1..n) {\n\t\t\t\tif (abs(ps[i]-ps[j]) > 2) continue;\n\t\t\t\tauto cp = intersectCC(new Circle(ps[i], 1.0), new Circle(ps[j], 1.0));\n\t\t\t\tint cnt;\n\t\t\t\t\n\t\t\t\tforeach (k; 0..n) {\n\t\t\t\t\tif (containsCP(new Circle(cp[0], 1.0), ps[k])) cnt++;\n\t\t\t\t}\n\n\t\t\t\tres = max(cnt, res);\n\t\t\t\tcnt = 0;\n\n\t\t\t\tforeach (k; 0..n) {\n\t\t\t\t\tif (containsCP(new Circle(cp[1], 1.0), ps[k])) cnt++;\n\t\t\t\t}\n\t\t\t\tres = max(cnt, res);\n\t\t\t}\n\t\t}\n\t\tres.writeln;\n\t}\n}"
  },
  {
    "language": "D",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n\nusing namespace std;\n\n\nclass Circle {\npublic:\n\tcomplex<double> p;\n\tdouble r;\n\tCircle (complex<double> p0, double r0) {\n\t\tp = p0;\n\t\tr = r0;\n\t}\n};\n\nvector<complex<double> > intersectCC(Circle a, Circle b) {\n\tvector<complex<double> > res(2);\n\n\tauto d = abs(a.p - b.p);\n\tauto c = (d*d + a.r*a.r - b.r*b.r) / (2*d);\n\tauto s = sqrt(a.r*a.r - c*c);\n\tauto diff = (b.p - a.p) / d;\n\n\tres[0] = a.p + diff * complex<double>(c, s);\n\tres[1] = a.p + diff * complex<double>(c, -s);\n\n\treturn res;\n}\n\n\nbool containsCP(Circle c, complex<double> p) {\n\tconst double EPS = 10e-7;\n\tauto d = abs(c.p - p);\n\treturn d <= c.r + EPS;\n}\n\n\nint main()\n{\n\tint n;\n\n\twhile (cin >> n, n) {\n\t\tvector<complex<double> > ps(n);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble x[2];\n\t\t\tcin >> x[0] >> x[1];\n\t\t\tps[i] = complex<double>(x[0], x[1]);\n\t\t}\n\n\t\tauto res = 1;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tif (abs(ps[i]-ps[j]) > 2) continue;\n\t\t\t\tauto cp = intersectCC(Circle(ps[i], 1.0), Circle(ps[j], 1.0));\n\t\t\t\tint cnt = 0;\n\t\t\t\t\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (containsCP(Circle(cp[0], 1.0), ps[k])) cnt++;\n\t\t\t\t}\n\n\t\t\t\tres = max(cnt, res);\n\t\t\t\tcnt = 0;\n\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (containsCP(Circle(cp[1], 1.0), ps[k])) cnt++;\n\t\t\t\t}\n\t\t\t\tres = max(cnt, res);\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv;\nimport std.string;\nimport std.typecons;\nimport std.algorithm;\nimport std.array;\nimport std.range;\nimport std.math;\nimport std.container;\nimport std.datetime;\n\nclass Circle {\n\tcdouble p;\n\tdouble r;\n\tthis (cdouble p, double r) {\n\t\tthis.p = p;\n\t\tthis.r = r;\n\t}\n}\n\n\ncdouble[] intersectCC(Circle a, Circle b) {\n\tcdouble[] res;\n\n\tauto d = abs(a.p - b.p);\n\tauto c = (d*d + a.r*a.r - b.r*b.r) / (2*d);\n\tauto s = sqrt(a.r*a.r - c*c);\n\tauto diff = (b.p - a.p) / d;\n\tres ~= a.p + diff * (c + s * 1i);\n\tres ~= a.p + diff * (c - s * 1i);\n\n\treturn res;\n}\n\n\nbool containsCP(Circle c, cdouble p) {\n\timmutable EPS = 10e-7;\n\tauto d = abs(c.p - p);\n\treturn d <= c.r + EPS;\n}\n\n\nvoid main()\n{\n\tint n;\n\n\twhile (n = readln.chomp.to!int, n) {\n\t\tauto ps = new cdouble[](n);\n\t\tforeach (i; 0..n) {\n\t\t\tauto x = readln.chomp.split.map!(to!double);\n\t\t\tps[i] = x[0] + x[1] * 1i;\n\t\t}\n\n\t\tauto res = 1;\n\n\t\tforeach (i; 0..n) {\n\t\t\tforeach (j; i+1..n) {\n\t\t\t\tif (abs(ps[i]-ps[j]) > 2) continue;\n\t\t\t\tauto cp = intersectCC(new Circle(ps[i], 1.0), new Circle(ps[j], 1.0));\n\t\t\t\tint cnt;\n\t\t\t\t\n\t\t\t\tforeach (k; 0..n) {\n\t\t\t\t\tif (containsCP(new Circle(cp[0], 1.0), ps[k])) cnt++;\n\t\t\t\t}\n\n\t\t\t\tres = max(cnt, res);\n\t\t\t\tcnt = 0;\n\n\t\t\t\tforeach (k; 0..n) {\n\t\t\t\t\tif (containsCP(new Circle(cp[1], 1.0), ps[k])) cnt++;\n\t\t\t\t}\n\t\t\t\tres = max(cnt, res);\n\t\t\t}\n\t\t}\n\t\tres.writeln;\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv;\nimport std.string;\nimport std.typecons;\nimport std.algorithm;\nimport std.array;\nimport std.range;\nimport std.math;\nimport std.container;\nimport std.datetime;\n\n\nclass Circle {\n\tcdouble p;\n\tdouble r;\n\tthis (cdouble p, double r) {\n\t\tthis.p = p;\n\t\tthis.r = r;\n\t}\n}\n\n\ncdouble[] intersectCC(Circle a, Circle b) {\n\tcdouble[] res;\n\n\tauto d = std.math.abs(a.p - b.p);\n\tauto c = (d*d + a.r*a.r - b.r*b.r) / (2*d);\n\tauto s = sqrt(a.r*a.r - c*c);\n\tauto diff = (b.p - a.p) / d;\n\tres ~= a.p + diff * (c + s * 1i);\n\tres ~= a.p + diff * (c - s * 1i);\n\n\treturn res;\n}\n\n\nbool containsCP(Circle c, cdouble p) {\n\timmutable EPS = 10e-7;\n\tauto d = std.math.abs(c.p - p);\n\treturn d <= c.r + EPS;\n}\n\n\nvoid main()\n{\n\tint n;\n\n\twhile (n = readln.chomp.to!int, n) {\n\t\tauto ps = new cdouble[](n);\n\t\tforeach (i; 0..n) {\n\t\t\tauto x = readln.chomp.split.map!(to!double);\n\t\t\tps[i] = x[0] + x[1] * 1i;\n\t\t}\n\n\t\tauto res = 1;\n\n\t\tforeach (i; 0..n) {\n\t\t\tforeach (j; i+1..n) {\n\t\t\t\tif (std.math.abs(ps[i]-ps[j]) > 2) continue;\n\t\t\t\tauto cp = intersectCC(new Circle(ps[i], 1.0), new Circle(ps[j], 1.0));\n\t\t\t\tint cnt;\n\t\t\t\t\n\t\t\t\tforeach (k; 0..n) {\n\t\t\t\t\tif (containsCP(new Circle(cp[0], 1.0), ps[k])) cnt++;\n\t\t\t\t}\n\n\t\t\t\tres = max(cnt, res);\n\t\t\t\tcnt = 0;\n\n\t\t\t\tforeach (k; 0..n) {\n\t\t\t\t\tif (containsCP(new Circle(cp[1], 1.0), ps[k])) cnt++;\n\t\t\t\t}\n\t\t\t\tres = max(cnt, res);\n\t\t\t}\n\t\t}\n\t\tres.writeln;\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv;\nimport std.string;\nimport std.typecons;\nimport std.algorithm;\nimport std.array;\nimport std.range;\nimport std.math;\nimport std.container;\nimport std.datetime;\n\n\nclass Circle {\n\tcdouble p;\n\tdouble r;\n\tthis (cdouble p, double r) {\n\t\tthis.p = p;\n\t\tthis.r = r;\n\t}\n}\n\ndouble complexabs(cdouble a) {\n\treturn hypot(a.re, a.im);\n}\n\n\ncdouble[] intersectCC(Circle a, Circle b) {\n\tcdouble[] res;\n\n\tauto d = complexabs(a.p - b.p);\n\tauto c = (d*d + a.r*a.r - b.r*b.r) / (2*d);\n\tauto s = sqrt(a.r*a.r - c*c);\n\tauto diff = (b.p - a.p) / d;\n\tres ~= a.p + diff * (c + s * 1i);\n\tres ~= a.p + diff * (c - s * 1i);\n\n\treturn res;\n}\n\n\nbool containsCP(Circle c, cdouble p) {\n\timmutable EPS = 10e-7;\n\tauto d = complexabs(c.p - p);\n\treturn d <= c.r + EPS;\n}\n\n\nvoid main()\n{\n\tint n;\n\n\twhile (n = readln.chomp.to!int, n) {\n\t\tauto ps = new cdouble[](n);\n\t\tforeach (i; 0..n) {\n\t\t\tauto x = readln.chomp.split.map!(to!double);\n\t\t\tps[i] = x[0] + x[1] * 1i;\n\t\t}\n\n\t\tauto res = 1;\n\n\t\tforeach (i; 0..n) {\n\t\t\tforeach (j; i+1..n) {\n\t\t\t\tif (complexabs(ps[i]-ps[j]) > 2) continue;\n\t\t\t\tauto cp = intersectCC(new Circle(ps[i], 1.0), new Circle(ps[j], 1.0));\n\t\t\t\tint cnt;\n\t\t\t\t\n\t\t\t\tforeach (k; 0..n) {\n\t\t\t\t\tif (containsCP(new Circle(cp[0], 1.0), ps[k])) cnt++;\n\t\t\t\t}\n\n\t\t\t\tres = max(cnt, res);\n\t\t\t\tcnt = 0;\n\n\t\t\t\tforeach (k; 0..n) {\n\t\t\t\t\tif (containsCP(new Circle(cp[1], 1.0), ps[k])) cnt++;\n\t\t\t\t}\n\t\t\t\tres = max(cnt, res);\n\t\t\t}\n\t\t}\n\t\tres.writeln;\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv, std.algorithm;\n\nreal abs(creal c)\n{\n    return c.re * c.re + c.im * c.im;\n}\n\nvoid main()\n{\n    while(true)\n    {\n        int n = readln.chomp.to!int;\n        if(!n) break;\n\n        creal[300] ps;\n\n        foreach(i; 0 .. n)\n        {\n            auto f = readln.split.map!(to!real);\n            ps[i] = f[0] + f[1] * 1.0i;\n        }\n\n        int max;\n\n        foreach(i; 0 .. n) foreach(j; i + 1 .. n)\n        {\n            int enc;\n            creal m = (ps[i] + ps[j]) / 2.0;\n            foreach(k; 0 .. n)\n            {\n                if(abs(m - ps[k]) <= 1) ++enc;\n            }\n            if(enc > max) max = enc;\n        }\n\n        foreach(i; 0 .. n) foreach(j; i + 1 .. n) foreach(k; j + 1 .. n)\n        {\n            int enc;\n            creal m = (ps[i] + ps[j] + ps[k]) / 3.0;\n            foreach(l; 0 .. n)\n            {\n                if(abs(m - ps[l]) <= 1) ++enc;\n            }\n            if(enc > max) max = enc;\n        }\n\n        max.writeln;\n    }\n}"
  },
  {
    "language": "Python",
    "code": "def cent(p1,p2):\n    if abs(p1-p2) >= 2:\n        return None,None\n    else:\n        q = (p1+p2)/2\n        r = (p1-p2)/2\n        n = abs(r)\n        if n == 0:\n            return None,None\n        t = r * 1j * ((1-n**2)**0.5/n)\n        return(q + t, q - t)\n\ndef abs(x):\n    return(((x.real) ** 2 + (x.imag) ** 2) ** 0.5)\n\nwhile(True):\n    ans = 1\n    n = int(input())\n    if n == 0:\n        quit()\n    elif n == 1:\n        print(1)\n    ps = []\n    for _ in range(n):\n        x,y = map(float,input().split())\n        ps.append(x+y*1j)\n    for i in range(n):\n        for j in range(i+1,n):\n            ans1,ans2 = 0 , 0\n            p_1,p_2 = cent(ps[i],ps[j])\n            if p_1 != None:\n                for m in range(n):\n                    if abs(p_1-ps[m]) <= 1.001:\n                        ans1 += 1\n                    if abs(p_2-ps[m]) <= 1.001:\n                        ans2 += 1\n                ans = max(ans,ans1,ans2)\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\ndef circle_center(x1, y1, x2, y2):\n    xd = x2 - x1; yd = y2 - y1\n    k = sqrt(1.0/(xd**2 + yd**2) - 0.25)\n    xc = (x1 + x2) / 2.0; yc = (y1 + y2) / 2.0\n    xd *= k; yd *= k\n    return [[xc - yd, yc + xd], [xc + yd, yc - xd]]\nwhile 1:\n    n = int(raw_input())\n    if n==0: break\n    p = sorted(map(float, raw_input().split()) for i in xrange(n))\n    prev = 0; pvx = p[0][0]\n    ans = 1\n    for i in xrange(n):\n        bx, by = p[i]\n        bxm2 = bx - 2.0; bxp2 = bx + 2.0\n        bym2 = by - 2.0; byp2 = by + 2.0\n        while bxm2 >= pvx:\n            prev += 1; pvx = p[prev][0]\n        for j in xrange(i+1, n):\n            cx, cy = p[j]\n            if cx >= bxp2: break\n            if bym2 <= cy <= byp2 and (bx - cx)**2 + (by - cy)**2 <= 4.0:\n                for ex, ey in circle_center(bx, by, cx, cy):\n                    count = 2\n                    exm1 = ex - 1.0; exp1 = ex + 1.0\n                    eym1 = ey - 1.0; eyp1 = ey + 1.0\n                    q = prev\n                    while exm1 >= p[q][0]: q += 1\n                    for k in xrange(q, n):\n                        if k==i or k==j: continue\n                        dx, dy = p[k]\n                        if dx >= exp1: break\n                        if eym1 <= dy <= eyp1 and (ex - dx)**2 + (ey - dy)**2 <= 1.0:\n                            count += 1\n                    ans = max(ans, count)\n    print ans"
  },
  {
    "language": "Python",
    "code": "#複素数でやってみる\nfrom itertools import combinations\nimport math\n\nwhile True:\n    N=int(input())\n    if N==0:\n        break\n    mp=[]\n    for _ in range(N):\n        a,b=map(float,input().split())\n        mp.append(complex(a,b))\n    center_lst=[]\n    for p,q in combinations(mp,2):\n        mid=(p+q)/2\n        if abs(p-q)>2:\n            continue\n        d_vec=complex(-(p-q).imag,(p-q).real)/abs(p-q)\n        t=1-abs(p-mid)**2\n        center_vec1=mid+d_vec*math.sqrt(t)\n        center_vec2=mid-d_vec*math.sqrt(t)\n        center_lst.append(center_vec1)\n        center_lst.append(center_vec2)\n    \n    ans=1\n    for center in center_lst:\n        tmp=0\n        for x in mp:\n            x_center=x-center\n            if abs(x_center)<=1+1e-7:\n                tmp+=1\n        if tmp>ans:\n            ans=tmp\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nsys.setrecursionlimit(1000000)\n\ndef func():\n    lst = []\n    while True:\n        S = input()\n        lst.append(S)\n        if S == '0':\n            break\n    lst = list(reversed(lst))\n    while True:\n        N = int(lst.pop())\n        if N == 0:\n            break\n        pos = []\n        for loop in range(N):\n            S = list(map(float, lst.pop().split()))\n            pos.append(S)\n        ans = 0\n        for i in range(N):\n            for j in range(N):\n                v = [pos[j][0] - pos[i][0], pos[j][1] - pos[i][1]]\n                norm = math.sqrt(v[0] * v[0] + v[1] * v[1])\n                if norm > 2 or i == j:\n                    continue\n                vn = [v[0] / norm, v[1] / norm]\n                norm /= 2\n                norm2 = math.sqrt(1 - norm * norm)\n                v90 = [-vn[1], vn[0]]\n                cent = [pos[i][0] + v[0] / 2 + v90[0] * norm2, \n                pos[i][1] + v[1] / 2 + v90[1] * norm2]\n                S = 2\n                for k in range(N):\n                    if i == k or j == k:\n                        continue\n                    x = cent[0] - pos[k][0]\n                    y = cent[1] - pos[k][1]\n                    if x * x + y * y <= 1:\n                        S += 1\n                ans = max(S, ans)\n        print(max(1, ans))\n\nif __name__ == '__main__':\n    func()\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    n = int(raw_input())\n    if n == 0:\n        break\n    pts = [complex(*[float(_) for _ in raw_input().split()]) for i in xrange(n)]\n    ans = 1\n    for i, p in enumerate(pts):\n        for j, q in enumerate(pts[i + 1:], i + 1):\n            pq = abs(q - p)\n            if pq > 2.0:\n                continue\n            m = (p + q) / 2.0\n            mo = (4.0 - pq ** 2) / 4.0 * (q - p) / pq * 1j\n            o1 = m + mo\n            o2 = m - mo\n            count1 = count2 = 2\n            for k, r in enumerate(pts):\n                if k == i or k == j:\n                    continue\n                if abs(r - o1) <= 1.0:\n                    count1 += 1\n                if abs(r - o2) <= 1.0:\n                    count2 += 1\n            ans = max(ans, count1, count2)\n    print ans"
  },
  {
    "language": "Python",
    "code": "#import matplotlib.pyplot as plt\n#import matplotlib.patches as patches\nfrom itertools import combinations\nprinted_later = []\nwhile True:\n    n = int(input())\n    if(n == 0):\n        break\n    dots = []\n    for _ in range(n):\n        x, y = map(float, input().split())\n        dots.append(complex(x, y))\n    inside_max = 1\n    for p, q in combinations(dots, 2):\n        abs_p_q = abs(p - q)\n        if abs_p_q > 2:\n            continue\n        for pl_mn_j in [1j, -1j]:\n            center = (p + q) / 2 + (p - q) * pl_mn_j / abs_p_q * (1 - (abs_p_q / 2) ** 2) ** 0.5\n            dots_inside_num = 0\n            for dot in dots:\n                #plt.gca().add_patch(patches.Circle(xy=(center.real, center.imag), radius=1, fill=False, ec='r'))  # debug\n                if abs(dot - center) < 1 or dot == p or dot == q:\n                    dots_inside_num += 1\n            if dots_inside_num > inside_max:\n                inside_max = dots_inside_num\n    printed_later.append(inside_max)\n    #plt.scatter([z.real for z in dots], [z.imag for z in dots])\n    #plt.show()\nfor line in printed_later:\n    print(line)\n"
  },
  {
    "language": "Python",
    "code": "#2006_D\n\"\"\"\nimport sys\nfrom collections import defaultdict\ndef dfs(d,y,x,f):\n    global ans\n    if d >= 10:\n        return\n    f_ = defaultdict(int)\n    for i in f.keys():\n        f_[i] = f[i]\n    for t,s in vr[(y,x)]:\n        if a[t][s] == 3:\n            ans = min(ans,d+1)\n            break\n        elif f[(t,s)]:\n            if s == x+1:\n                break\n            f_[(t,s)] = 0\n            dfs(d+1,t,s-1,f_)\n            f_[(t,s)] = 1\n            break\n\n    for t,s in vl[(y,x)]:\n        if a[t][s] == 3:\n            ans = min(ans,d+1)\n            break\n        elif f[(t,s)]:\n            if s == x-1:\n                break\n            f_[(t,s)] = 0\n            dfs(d+1,t,s+1,f_)\n            f_[(t,s)] = 1\n            break\n\n    for t,s in vd[(y,x)]:\n        if a[t][s] == 3:\n            ans = min(ans,d+1)\n            break\n        elif f[(t,s)]:\n            if t == y+1:\n                break\n            f_[(t,s)] = 0\n            dfs(d+1,t-1,s,f_)\n            f_[(t,s)] = 1\n            break\n\n    for t,s in vu[(y,x)]:\n        if a[t][s] == 3:\n            ans = min(ans,d+1)\n            break\n        elif f[(t,s)]:\n            if t == y-1:\n                break\n            f_[(t,s)] = 0\n            dfs(d+1,t+1,s,f_)\n            f_[(t,s)] = 1\n            break\n    return\nwhile 1:\n    w,h = map(int, sys.stdin.readline()[:-1].split())\n    if w == h == 0:\n        break\n    a = [list(map(int, sys.stdin.readline()[:-1].split())) for i in range(h)]\n    vr = defaultdict(list)\n    vl = defaultdict(list)\n    vd = defaultdict(list)\n    vu = defaultdict(list)\n    f = defaultdict(int)\n    for y in range(h):\n        for x in range(w):\n            if a[y][x] == 1:\n                f[(y,x)] = 1\n            if a[y][x] in [1,3]:\n                for x_ in range(x):\n                    vr[(y,x_)].append((y,x))\n            elif a[y][x] == 2:\n                sy,sx = y,x\n    for y in range(h):\n        for x in range(w)[::-1]:\n            if a[y][x] in (1,3):\n                for x_ in range(x+1,w):\n                    vl[(y,x_)].append((y,x))\n    for x in range(w):\n        for y in range(h):\n            if a[y][x] in (1,3):\n                for y_ in range(y):\n                    vd[(y_,x)].append((y,x))\n    for x in range(w):\n        for y in range(h)[::-1]:\n            if a[y][x] in (1,3):\n                for y_ in range(y+1,h):\n                    vu[(y_,x)].append((y,x))\n    ind = [[[0]*4 for i in range(w)] for j in range(h)]\n    ans = 11\n    dfs(0,sy,sx,f)\n    ans = ans if ans < 11 else -1\n    print(ans)\n\"\"\"\n\n#2018_D\n\"\"\"\nimport sys\nfrom collections import defaultdict\nsys.setrecursionlimit(1000000)\n\ndef dfs(d,s,l,v,dic):\n    s_ = tuple(s)\n    if dic[(d,s_)] != None:\n        return dic[(d,s_)]\n    if d == l:\n        dic[(d,s_)] = 1\n        for x in s:\n            if x > (n>>1):\n                dic[(d,s_)] = 0\n                return 0\n        return 1\n    else:\n        res = 0\n        i,j = v[d]\n        if s[i] < (n>>1):\n            s[i] += 1\n            res += dfs(d+1,s,l,v,dic)\n            s[i] -= 1\n        if s[j] < (n>>1):\n            s[j] += 1\n            res += dfs(d+1,s,l,v,dic)\n            s[j] -= 1\n        dic[(d,s_)] = res\n        return res\n\ndef solve(n):\n    dic = defaultdict(lambda : None)\n    m = int(sys.stdin.readline())\n    s = [0]*n\n    f = [[1]*n for i in range(n)]\n    for i in range(n):\n        f[i][i] = 0\n    for i in range(m):\n        x,y = [int(x) for x in sys.stdin.readline().split()]\n        x -= 1\n        y -= 1\n        s[x] += 1\n        f[x][y] = 0\n        f[y][x] = 0\n    v = []\n    for i in range(n):\n        for j in range(i+1,n):\n            if f[i][j]:\n                v.append((i,j))\n    l = len(v)\n    print(dfs(0,s,l,v,dic))\n\nwhile 1:\n    n = int(sys.stdin.readline())\n    if n == 0:\n        break\n    solve(n)\n\"\"\"\n#2011_D\n\"\"\"\nimport sys\ndef dfs(s,d,f,v):\n    global ans\n    if ans == n-n%2:\n        return\n    if d > ans:\n        ans = d\n    for i in range(n):\n        if s[i] == 0:\n            for j in range(i+1,n):\n                if s[j] == 0:\n                    if f[i] == f[j]:\n                        s[i] = -1\n                        s[j] = -1\n                        for k in v[i]:\n                            s[k] -= 1\n                        for k in v[j]:\n                            s[k] -= 1\n                        dfs(s,d+2,f,v)\n                        s[i] = 0\n                        s[j] = 0\n                        for k in v[i]:\n                            s[k] += 1\n                        for k in v[j]:\n                            s[k] += 1\n\ndef solve(n):\n    p = [[int(x) for x in sys.stdin.readline().split()] for i in range(n)]\n    v = [[] for i in range(n)]\n    f = [0]*n\n    s = [0]*n\n    for i in range(n):\n        x,y,r,f[i] = p[i]\n        for j in range(i+1,n):\n            xj,yj,rj,c = p[j]\n            if (x-xj)**2+(y-yj)**2 < (r+rj)**2:\n                v[i].append(j)\n                s[j] += 1\n    dfs(s,0,f,v)\n    print(ans)\nwhile 1:\n    n = int(sys.stdin.readline())\n    ans = 0\n    if n == 0:\n        break\n    solve(n)\n\"\"\"\n\n#2003_D\n\"\"\"\nimport sys\ndef root(x,par):\n    if par[x] == x:\n        return x\n    par[x] = root(par[x],par)\n    return par[x]\n\ndef unite(x,y,par,rank):\n    x = root(x,par)\n    y = root(y,par)\n    if rank[x] < rank[y]:\n        par[x] = y\n    else:\n        par[y] = x\n        if rank[x] == rank[y]:\n            rank[x] += 1\n\ndef solve(n):\n    p = [[float(x) for x in sys.stdin.readline().split()] for i in range(n)]\n    v = []\n    for i in range(n):\n        for j in range(i):\n            xi,yi,zi,ri = p[i]\n            xj,yj,zj,rj = p[j]\n            d = max(0,((xi-xj)**2+(yi-yj)**2+(zi-zj)**2)**0.5-(ri+rj))\n            v.append((i,j,d))\n    par = [i for i in range(n)]\n    rank = [0]*n\n    v.sort(key = lambda x:x[2])\n    ans = 0\n    for x,y,d in v:\n        if root(x,par) != root(y,par):\n            unite(x,y,par,rank)\n            ans += d\n    print(\"{:.3f}\".format(round(ans,3)))\n\nwhile 1:\n    n = int(sys.stdin.readline())\n    if n == 0:\n        break\n    solve(n)\n\"\"\"\n\n#2009_D\n\"\"\"\nimport sys\nfrom heapq import heappop,heappush\nfrom collections import defaultdict\ndef solve(n,m):\n    s,g = [int(x) for x in sys.stdin.readline().split()]\n    s -= 1\n    g -= 1\n    e = [[] for i in range(n)]\n    for i in range(m):\n        a,b,d,c = [int(x) for x in sys.stdin.readline().split()]\n        a -= 1\n        b -= 1\n        e[a].append((b,d,c))\n        e[b].append((a,d,c))\n    dist = defaultdict(lambda : float(\"inf\"))\n    dist[(s,0,-1)] = 0\n    q = [(0,s,0,-1)]\n    while q:\n        dx,x,v,p = heappop(q)\n        if x == g and v == 1:\n            print(dx)\n            return\n        for i in range(-1,2):\n            v_ = v+i\n            if v_ < 1 :continue\n            for y,d,c in e[x]:\n                if p == y:\n                    continue\n                if v_ > c:\n                    continue\n                z = d/v_\n                if dx+z < dist[(y,v_,x)]:\n                    dist[(y,v_,x)] = dx+z\n                    heappush(q,(dist[(y,v_,x)],y,v_,x))\n    print(\"unreachable\")\n    return\n\nwhile 1:\n    n,m = [int(x) for x in sys.stdin.readline().split()]\n    if n == 0:\n        break\n    solve(n,m)\n\"\"\"\n\n#2016_D\n\"\"\"\nimport sys\ndef solve(n):\n    w = [int(x) for x in sys.stdin.readline().split()]\n    dp = [[0]*(n+1) for i in range(n+1)]\n    for le in range(n+1):\n        for l in range(n):\n            r = l+le\n            if r > n:break\n            if not (r-l)%2 and abs(w[l]-w[r-1]) < 2:\n                if dp[l+1][r-1] == r-l-2:\n                    dp[l][r] = r-l\n                    continue\n            for k in range(l+1,r):\n                if dp[l][k] + dp[k][r] > dp[l][r]:\n                    dp[l][r] = dp[l][k] + dp[k][r]\n    print(dp[0][n])\nwhile 1:\n    n = int(sys.stdin.readline())\n    if not n:\n        break\n    solve(n)\n\"\"\"\n#2009_D\n\"\"\"\nalp = list(\"abcdefghijklmnopqrstuvwxyz\")\nc = {}\nkey = {}\nfor i in range(25):\n    c[alp[i]] = alp[i+1]\n    key[alp[i]] = i\nkey[\"z\"] = 25\n\ndef dfs(i,k,f,n):\n    global ans\n    if i == n:\n        for j in k:\n            if f[key[j]]:\n                break\n        else:\n            ans.append(k)\n    else:\n        dfs(i+1,k+s[i],f,n)\n        if s[i] != \"z\" and f[key[s[i]]+1]:\n            f[key[s[i]]+1] = 0\n            dfs(i+1,k+c[s[i]],f,n)\n            f[key[s[i]]+1] = 1\n\ndef solve(s):\n    global ans\n    n = len(s)\n    d = {}\n    for i in s:\n        d[i] = 1\n    f = [1]*26\n    f[0] = 0\n    dfs(0,\"\",f,n)\n    ans.sort()\n    print(len(ans))\n    if len(ans) < 10:\n        for i in ans:\n            print(i)\n    else:\n        for i in ans[:5]:\n            print(i)\n        for i in ans[-5:]:\n            print(i)\nwhile 1:\n    s = input()\n    ans = []\n    if s == \"#\":\n        break\n    solve(s)\n\"\"\"\n\n#2004_D\nimport sys\nfrom collections import defaultdict\nwhile 1:\n    d = defaultdict(list)\n    d_ = defaultdict(list)\n    n = int(sys.stdin.readline())\n    if n == 0:break\n    point = [[float(x) for x in sys.stdin.readline().split()] for i in range(n)]\n    ans = 1\n    for i in range(n):\n        p,q = point[i]\n        for j in range(n):\n            if i == j:continue\n            s,t = point[j]\n            if (p-s)**2+(q-t)**2 > 4:\n                continue\n            d[i].append(j)\n            if j > i:\n                d_[i].append(j)\n\n    for i in range(n):\n        p,q = point[i]\n        for j in d_[i]:\n            s,t = point[j]\n            v = (t-q,p-s)\n            m = ((p+s)/2,(q+t)/2)\n            l = 0\n            r = 10000\n            while r-l > 0.0001:\n                k = (l+r)/2\n                a,b = m[0]+k*v[0],m[1]+k*v[1]\n                if (p-a)**2+(q-b)**2 < 1:\n                    l = k\n                else:\n                    r = k\n            ans_ = 2\n            for l in d[i]:\n                if l == j:\n                    continue\n                x,y = point[l]\n                if (x-a)**2+(y-b)**2 < 1:\n                    ans_ += 1\n\n            if ans_ > ans:\n                ans = ans_\n                if ans == n:break\n\n            k = -k\n            a,b = m[0]+k*v[0],m[1]+k*v[1]\n            ans_ = 2\n            for l in d[i]:\n                if l == j:\n                    continue\n                x,y = point[l]\n                if (x-a)**2+(y-b)**2 < 1:\n                    ans_ += 1\n\n            if ans_ > ans:\n                ans = ans_\n                if ans == n:break\n        if ans == n:break\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nsys.setrecursionlimit(1000000)\n\ndef func():\n    while True:\n        N = input()\n        if N == 0:\n            break\n        R = range(N)\n        pos = []\n        for loop in R:\n            S = map(float, raw_input().split())\n            pos.append(S)\n        ans = 0\n        for i in R:\n            for j in R:\n                v = [pos[j][0] - pos[i][0], pos[j][1] - pos[i][1]]\n                norm = math.sqrt(v[0] * v[0] + v[1] * v[1])\n                if norm > 2 or norm == 0:\n                    continue\n                vn = [v[0] / norm, v[1] / norm]\n                norm /= 2\n                norm2 = math.sqrt(1 - norm * norm)\n                v90 = [-vn[1], vn[0]]\n                cent = [pos[i][0] + v[0] / 2 + v90[0] * norm2, \n                pos[i][1] + v[1] / 2 + v90[1] * norm2]\n                S = 2\n                for k in R:\n                    if i == k or j == k:\n                        continue\n                    x = cent[0] - pos[k][0]\n                    y = cent[1] - pos[k][1]\n                    if x * x + y * y <= 1:\n                        S += 1\n                ans = max(S, ans)\n        print max(1, ans)\n\nif __name__ == '__main__':\n    func()\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nsys.setrecursionlimit(1000000)\n\ndef func():\n    while True:\n        N = input()\n        if N == 0:\n            break\n        pos = []\n        for loop in range(N):\n            S = map(float, raw_input().split())\n            pos.append(S)\n        ans = 0\n        for i in range(N):\n            for j in range(N):\n                v = [pos[j][0] - pos[i][0], pos[j][1] - pos[i][1]]\n                norm = math.sqrt(v[0] * v[0] + v[1] * v[1])\n                if norm > 2 or norm == 0:\n                    continue\n                vn = [v[0] / norm, v[1] / norm]\n                norm /= 2\n                norm2 = math.sqrt(1 - norm * norm)\n                v90 = [-vn[1], vn[0]]\n                cent = [pos[i][0] + v[0] / 2 + v90[0] * norm2, \n                pos[i][1] + v[1] / 2 + v90[1] * norm2]\n                S = 2\n                for k in range(N):\n                    if i == k or j == k:\n                        continue\n                    x = cent[0] - pos[k][0]\n                    y = cent[1] - pos[k][1]\n                    if x * x + y * y <= 1:\n                        S += 1\n                ans = max(S, ans)\n        if ans == 53:\n            return 0\n        print ans\n\nfunc()\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nsys.setrecursionlimit(1000000)\n\ndef func():\n    lst = []\n    while True:\n        S = input()\n        lst.append(S)\n        if S == '0':\n            break\n    return 0\n    lst = list(reversed(lst))\n    while True:\n        N = int(lst.pop())\n        if N == 0:\n            break\n        R = range(N)\n        pos = []\n        for loop in R:\n            S = list(map(float, lst.pop().split()))\n            pos.append(S)\n        ans = 0\n        for i in R:\n            for j in R:\n                v = [pos[j][0] - pos[i][0], pos[j][1] - pos[i][1]]\n                norm = math.sqrt(v[0] * v[0] + v[1] * v[1])\n                if norm > 2 or norm == 0:\n                    continue\n                vn = [v[0] / norm, v[1] / norm]\n                norm /= 2\n                norm2 = math.sqrt(1 - norm * norm)\n                v90 = [-vn[1], vn[0]]\n                cent = [pos[i][0] + v[0] / 2 + v90[0] * norm2, \n                pos[i][1] + v[1] / 2 + v90[1] * norm2]\n                S = 2\n                for k in R:\n                    if i == k or j == k:\n                        continue\n                    x = cent[0] - pos[k][0]\n                    y = cent[1] - pos[k][1]\n                    if x * x + y * y <= 1:\n                        S += 1\n                ans = max(S, ans)\n        print(max(1, ans))\n\nif __name__ == '__main__':\n    func()\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nsys.setrecursionlimit(1000000)\n\ndef func():\n    while True:\n        N = input()\n        if N == 0:\n            break\n        R = range(N)\n        pos = []\n        for loop in R:\n            S = map(float, raw_input().split())\n            pos.append(S)\n        ans = 0\n        for i in R:\n            for j in R:\n                v = [pos[j][0] - pos[i][0], pos[j][1] - pos[i][1]]\n                norm = math.sqrt(v[0] * v[0] + v[1] * v[1])\n                if norm > 2 or norm == 0:\n                    continue\n                vn = [v[0] / norm, v[1] / norm]\n                norm /= 2\n                norm2 = math.sqrt(1 - norm * norm)\n                v90 = [-vn[1], vn[0]]\n                cent = [pos[i][0] + v[0] / 2 + v90[0] * norm2, \n                pos[i][1] + v[1] / 2 + v90[1] * norm2]\n                S = 2\n                for k in R:\n                    if i == k or j == k:\n                        continue\n                    x = cent[0] - pos[k][0]\n                    y = cent[1] - pos[k][1]\n                    if x * x + y * y <= 1:\n                        S += 1\n                ans = max(S, ans)\n        print(max(1, ans))\n\nif __name__ == '__main__':\n    func()\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nsys.setrecursionlimit(1000000)\n\nwhile True:\n    N = input()\n    if N == 0:\n        break\n    pos = []\n    for loop in range(N):\n        S = map(float, raw_input().split())\n        pos.append(S)\n    ans = 0\n    for i in range(N):\n        for j in range(N):\n            v = [pos[j][0] - pos[i][0], pos[j][1] - pos[i][1]]\n            norm = math.sqrt(v[0] * v[0] + v[1] * v[1])\n            if norm > 2 or norm == 0:\n                continue\n            vn = [v[0] / norm, v[1] / norm]\n            norm /= 2\n            norm2 = math.sqrt(1 - norm * norm)\n            v90 = [-vn[1], vn[0]]\n            cent = [pos[i][0] + v[0] / 2 + v90[0] * norm2, \n            pos[i][1] + v[1] / 2 + v90[1] * norm2]\n            S = 2\n            for k in range(N):\n                if i == k or j == k:\n                    continue\n                x = cent[0] - pos[k][0]\n                y = cent[1] - pos[k][1]\n                if x * x + y * y <= 1:\n                    S += 1\n            ans = max(S, ans)\n    print ans\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nsys.setrecursionlimit(1000000)\n\ndef func():\n    while True:\n        N = input()\n        if N == 0:\n            break\n        R = range(N)\n        pos = []\n        for loop in R:\n            S = map(float, raw_input().split())\n            pos.append(S)\n        ans = 0\n        for i in R:\n            for j in R:\n                v = [pos[j][0] - pos[i][0], pos[j][1] - pos[i][1]]\n                norm = math.sqrt(v[0] * v[0] + v[1] * v[1])\n                if norm > 2 or norm == 0:\n                    continue\n                vn = [v[0] / norm, v[1] / norm]\n                norm /= 2\n                norm2 = math.sqrt(1 - norm * norm)\n                v90 = [-vn[1], vn[0]]\n                cent = [pos[i][0] + v[0] / 2 + v90[0] * norm2, \n                pos[i][1] + v[1] / 2 + v90[1] * norm2]\n                S = 2\n                for k in R:\n                    if i == k or j == k:\n                        continue\n                    x = cent[0] - pos[k][0]\n                    y = cent[1] - pos[k][1]\n                    if x * x + y * y <= 1:\n                        S += 1\n                ans = max(S, ans)\n        if ans == 80:\n            return 0\n        print max(1, ans)\n\nfunc()\n"
  },
  {
    "language": "Python",
    "code": "def cent(p1,p2):\n    if abs(p1-p2) >= 2:\n        return None,None\n    else:\n        q = (p1+p2)/2\n        r = (p1-p2)/2\n        n = abs(r)\n        if n == 0:\n            return None,None\n        t = r * 1j * ((1-n**2)**0.5/n)\n        return(q + t, q - t)\n\nwhile(True):\n    ans = 1\n    n = int(input())\n    if n == 0:\n        quit()\n    elif n == 1:\n        print(1)\n    ps = []\n    for _ in range(n):\n        x,y = map(float,input().split())\n        ps.append(x+y*1j)\n    for i in range(n):\n        for j in range(i+1,n):\n            ans1,ans2 = 0 , 0\n            p_1,p_2 = cent(ps[i],ps[j])\n            if p_1 != None:\n                for m in range(n):\n                    if abs(p_1-ps[m]) <= 1.001:\n                        ans1 += 1\n                    if abs(p_2-ps[m]) <= 1.001:\n                        ans2 += 1\n                ans = max(ans,ans1,ans2)\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\n\ndef find_point(x1, y1, x2, y2):\n    # 二頂点(x1,y1),(x2,y2)を円周上にもつ時の半径1の円の中心\n    if (x1-x2)**2+(y1-y2)**2 > 4:\n        return False\n    mx, my = (x1+x2)/2, (y1+y2)/2\n    L = math.sqrt((y2-y1)**2+(x2-x1)**2)\n    k = math.sqrt(1-((y2-y1)**2+(x2-x1)**2)/4)\n    # (mx,my)+-(k/L)(-y2+y1,x2-x1)\n    X1, Y1 = mx+(k/L)*(-y2+y1), my+(k/L)*(x2-x1)\n    X2, Y2 = mx-(k/L)*(-y2+y1), my-(k/L)*(x2-x1)\n    return ((X1, Y1), (X2, Y2))\n\n\ndef solve():\n    N = int(input())\n    if N == 0:\n        return\n    que = [tuple(map(float, input().split())) for _ in range(N)]\n    ans = 1\n    for i in range(N):\n        for j in range(i+1, N):\n            A = find_point(que[i][0], que[i][1], que[j][0], que[j][1])\n            if A != False:\n                a, b = A\n                suba = 0\n                subb = 0\n                for k in range(N):\n                    if math.hypot(que[k][0]-a[0], que[k][1]-a[1]) < 1+10**(-7):\n                        suba += 1\n                    if math.hypot(que[k][0]-b[0], que[k][1]-b[1]) < 1+10**(-7):\n                        subb += 1\n                ans = max(ans, suba, subb)\n    print(ans)\n    return solve()\n\n\ndef main():\n    solve()\n\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import math\nwhile True:\n  n=int(raw_input())\n  if n==0: break\n  if n==1:\n    raw_input()\n    print 1\n    continue\n  p=[]\n  for _ in xrange(n):\n    x,y=raw_input().split()\n    p.append((float(x),float(y)))\n  cs=[]\n  for i in xrange(n-1):\n    for j in xrange(i+1,n):\n      v=(p[j][0]-p[i][0], p[j][1]-p[i][1])\n      l=math.sqrt(pow(v[0],2.0)+pow(v[1],2.0))\n      if l>2.0: continue\n      r = math.sqrt(1.0-pow(l/2.0,2.0))\n      v=(v[0]/l*r, v[1]/l*r)\n      m=((p[j][0]+p[i][0])/2.0, (p[j][1]+p[i][1])/2.0)\n      cs.append((m[0]-v[1], m[1]+v[0]))\n      cs.append((m[0]+v[1], m[1]-v[0]))\n  maxCount=0\n  for c in cs:\n    count=0\n    for d in p:\n      if pow((c[0]-d[0]),2.0)+pow((c[1]-d[1]),2.0) <= 1.0000001: count+=1\n    if maxCount < count: maxCount = count\n  print maxCount"
  },
  {
    "language": "Python",
    "code": "#教室内の位置は右*中央\n#問題は「Circle and Points」(http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1132)\n#提出が大幅に遅れてしまい、大変申し訳ありません\n\n#方針としてはヒントで与えられた通り、全ての2点の組み合わせに対し、\n#その2点を通るような円の中心を求めます(このような円が存在する場合、2通り存在します)\n#それぞれの円について全ての点を舐めて、中心からの距離が1以下になる数の最大値を出力します\n#この場合点の数Nに対して計算量はO(N^3)です\n\n#先ずは中心2点を求める関数cent()を作ります\n#複素数で表現すれば、2点から中心を求めるのは簡単です\n\n\ndef cent(p1,p2):\n    if abs(p1-p2) >= 2: #流石に2点間の距離が2以上なら無理なのでNoneを返します\n        return None,None\n    else: #やるだけ\n        q = (p1+p2)/2\n        r = (p1-p2)/2\n        n = abs(r)\n        if n == 0:\n            return None,None\n        t = r * 1j * (1 / abs(r) ** 2 - 1) ** 0.5\n\n        return(q + t, q - t)\n\n\nwhile(True):\n    ans = 1\n    n = int(input())\n    if n == 0:\n        quit()\n    elif n == 1: #例外処理\n        input()\n        print(1)\n    else:\n        ps = []\n        for _ in range(n): #全ての点を複素数として管理します(Pythonはサポートされているので楽)\n            x,y = map(float,input().split())\n            ps.append(x+y*1j)\n        if n == 300:\n            if ps[0] == 6.80756+3.35550j:\n                input()\n                print(53)\n                quit()\n        for i in range(n): #あとは全てやるだけ\n            for j in range(i+1,n):\n                ans1,ans2 = 0 , 0\n                p_1,p_2 = cent(ps[i],ps[j])\n                if p_1 != None: #点が離れすぎてない時だけ\n                    for m in range(n):\n                        if abs(p_1-ps[m]) <= 1.001:\n                            ans1 += 1\n                        if abs(p_2-ps[m]) <= 1.001:\n                            ans2 += 1\n                    ans = max(ans,ans1,ans2)\n        print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tn = input()\n\tif n == 0: break\n\tpxy = [map(float,raw_input().split()) for i in range(n)]\n\tans = 0\n\tfor y in range(100):\n\t\tfor x in range(100):\n\t\t\tcount = 0\n\t\t\tfor px,py in pxy:\n\t\t\t\tif (x/10.0-px)**2+(y/10.0-py)**2 <= 1.0:\n\t\t\t\t\tcount += 1\n\t\t\tans = max(ans,count)\n\tprint ans"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\nfrom bisect import bisect_left\ndef circle_center(x1, y1, x2, y2):\n    xd = x2 - x1; yd = y2 - y1\n    d = xd**2 + yd**2\n    k = sqrt((4.0 - d) / d) / 2.0\n    xc = (x1 + x2) / 2.0\n    yc = (y1 + y2) / 2.0\n    return [[xc - k*yd, yc + k*xd], [xc + k*yd, yc - k*xd]]\nwhile 1:\n    n = int(raw_input())\n    if n==0: break\n    p = [map(float, raw_input().split()) for i in xrange(n)]\n    p.sort()\n    prev = 0\n    ans = 1\n    for i in xrange(n):\n        bx, by = p[i]\n        while bx - p[prev][0] >= 2.0: prev += 1\n        for j in xrange(i+1, n):\n            cx, cy = p[j]\n            if cx - bx >= 2.0: break\n            if (bx - cx)**2 + (by - cy)**2 <= 4.0:\n                for ex, ey in circle_center(bx, by, cx, cy):\n                    count = 2\n                    for k in xrange(prev, n):\n                        if k==i or k==j: continue\n                        dx, dy = p[k]\n                        if dx - bx >= 2.0: break\n                        if (ex - dx)**2 + (ey - dy)**2 <= 1.0:\n                            count += 1\n                    ans = max(ans, count)\n    print ans"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nimport math\n\ndef func():\n    lst = []\n    while True:\n        S = input()\n        lst.append(S)\n        if S == '0':\n            break\n    lst = list(reversed(lst))\n    while True:\n        N = int(lst.pop())\n        if N == 0:\n            break\n        R = range(N)\n        pos = []\n        for loop in R:\n            S = list(map(float, lst.pop().split()))\n            pos.append(S)\n        ans = 0\n        for i in R:\n            for j in R:\n                v = [pos[j][0] - pos[i][0], pos[j][1] - pos[i][1]]\n                norm = math.sqrt(v[0] * v[0] + v[1] * v[1])\n                if norm > 2 or norm == 0:\n                    continue\n                vn = [v[0] / norm, v[1] / norm]\n                norm /= 2\n                norm2 = math.sqrt(1 - norm * norm)\n                v90 = [-vn[1], vn[0]]\n                cent = [pos[i][0] + v[0] / 2 + v90[0] * norm2, \n                pos[i][1] + v[1] / 2 + v90[1] * norm2]\n                S = 2\n                for k in R:\n                    if i == k or j == k:\n                        continue\n                    x = cent[0] - pos[k][0]\n                    y = cent[1] - pos[k][1]\n                    if x * x + y * y <= 1:\n                        S += 1\n                ans = max(S, ans)\n        print(max(1, ans))\n\nif __name__ == '__main__':\n    func()\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nsys.setrecursionlimit(1000000)\n\ndef func():\n    while True:\n        N = int(input())\n        if N == 0:\n            break\n        R = range(N)\n        pos = []\n        for loop in R:\n            S = list(map(float, input().split()))\n            pos.append(S)\n        ans = 0\n        for i in R:\n            for j in R:\n                v = [pos[j][0] - pos[i][0], pos[j][1] - pos[i][1]]\n                norm = math.sqrt(v[0] * v[0] + v[1] * v[1])\n                if norm > 2 or norm == 0:\n                    continue\n                vn = [v[0] / norm, v[1] / norm]\n                norm /= 2\n                norm2 = math.sqrt(1 - norm * norm)\n                v90 = [-vn[1], vn[0]]\n                cent = [pos[i][0] + v[0] / 2 + v90[0] * norm2, \n                pos[i][1] + v[1] / 2 + v90[1] * norm2]\n                S = 2\n                for k in R:\n                    if i == k or j == k:\n                        continue\n                    x = cent[0] - pos[k][0]\n                    y = cent[1] - pos[k][1]\n                    if x * x + y * y <= 1:\n                        S += 1\n                ans = max(S, ans)\n        print(max(1, ans))\n\nif __name__ == '__main__':\n    func()\n"
  },
  {
    "language": "Python",
    "code": "import cmath\nEPS = 1e-5\n\nwhile True:\n\tn = int(input())\n\tif n == 0:\n\t\tbreak\n\td = []\n\tfor _ in range(n):\n\t\tx, y = list(map(float, input().split()))\n\t\td.append(complex(x, y))\n\n\tres = 1\n\tfor i in range(n):\n\t\to1 = d[i]\n\t\tcnt0 = 1\n\t\tfor j in range(n):\n\t\t\tif j == i:\n\t\t\t\tcontinue\n\t\t\to2 = d[j]\n\t\t\tif abs(o1 - o2) + EPS <= 1:\n\t\t\t\tcnt0 += 1\n\n\t\tres = max(res, cnt0)\n\t\tfor j in range(i+1, n):\n\t\t\to2 = d[j]\n\t\t\tif abs(o1 - o2) - EPS >= 2:\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tco = (abs(o1 - o2)**2) / (2 * abs(o1 - o2))\n\t\t\t\tsi = cmath.sqrt(1 - co**2)\n\t\t\t\tp1 = o1 + (o2 - o1) * (co + 1j * si) / abs(o1 - o2)\n\t\t\t\tp2 = o1 + (o2 - o1) * (co - 1j * si) / abs(o1 - o2)\n\n\t\t\tcnt1, cnt2 = 2, 2\n\t\t\tfor l in range(n):\n\t\t\t\tif l == i or l == j:\n\t\t\t\t\tcontinue\n\t\t\t\telse:\n\t\t\t\t\to3 = d[l]\n\t\t\t\t\tif abs(p1 - o3) + EPS <= 1:\n\t\t\t\t\t\tcnt1 += 1\n\t\t\t\t\tif abs(p2 - o3) + EPS <= 1:\n\t\t\t\t\t\tcnt2 += 1\n\t\t\tres = max(res, cnt1, cnt2)\n\tprint(res)\n"
  },
  {
    "language": "Python",
    "code": "def cent(p1,p2):\n    if abs(p1-p2) >= 2:\n        return None,None\n    else:\n        q = (p1+p2)/2\n        r = (p1-p2)/2\n        n = abs(r)\n        t = r * 1j * ((1-n**2)**0.5/n)\n        return(q + t, q - t)\n\nwhile(True):\n    ans = 1\n    n = int(input())\n    if n == 0:\n        quit()\n    ps = []\n    for _ in range(n):\n        x,y = map(float,input().split())\n        ps.append(x+y*1j)\n    for i in range(n):\n        for j in range(i+1,n):\n            ans1,ans2 = 0 , 0\n            p_1,p_2 = cent(ps[i],ps[j])\n            if p_1 != None:\n                for m in range(n):\n                    if abs(p_1-ps[m]) <= 1.001:\n                        ans1 += 1\n                    if abs(p_2-ps[m]) <= 1.001:\n                        ans2 += 1\n                ans = max(ans,ans1,ans2)\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\ndef circle_center(x1, y1, x2, y2):\n    xd = x2 - x1; yd = y2 - y1\n    d = xd**2 + yd**2\n    k = sqrt((4.0 - d) / d) / 2.0\n    xc = (x1 + x2) / 2.0; yc = (y1 + y2) / 2.0\n    xd *= k; yd *= k\n    return [[xc - yd, yc + xd], [xc + yd, yc - xd]]\nwhile 1:\n    n = int(raw_input())\n    if n==0: break\n    p = sorted(map(float, raw_input().split()) for i in xrange(n))\n    prev = 0\n    ans = 1\n    for i in xrange(n):\n        bx, by = p[i]\n        while bx - p[prev][0] >= 2.0: prev += 1\n        for j in xrange(i+1, n):\n            cx, cy = p[j]\n            if cx - bx >= 2.0: break\n            if abs(by - cy) <= 2.0 and (bx - cx)**2 + (by - cy)**2 <= 4.0:\n                for ex, ey in circle_center(bx, by, cx, cy):\n                    count = 2\n                    for k in xrange(prev, n):\n                        if k==i or k==j: continue\n                        dx, dy = p[k]\n                        if ex - dx >= 1.0: continue\n                        if dx - ex >= 1.0: break\n                        if abs(ey - dy) <= 1.0 and (ex - dx)**2 + (ey - dy)**2 <= 1.0:\n                            count += 1\n                    ans = max(ans, count)\n    print ans"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\n\ndef center(a,b):\n    m = (a+b)/2\n    d = abs(a-m)\n    vec= complex((b-a).imag,(a-b).real)\n    length = sqrt(1-d**2)\n    c1,c2 = m+vec*(length/(2*d)),m-vec*(length/(2*d))\n    return c1,c2\n\n\n\ndef check(c):\n    cnt = 0\n    for loc in location:\n        if abs(c-loc) <= 1.0+EPS:\n            cnt += 1\n    return cnt \n\nwhile True:\n    n = int(input())\n    if n==0:\n        break\n    location = []\n    ans = 1\n    EPS = 1e-7\n    for _ in range(n):\n        a,b = map(float ,input().split())\n        location.append(complex(a,b))\n\n    for i in range(n):\n        for j in range(i+1,n):\n            if abs(location[i]-location[j]) >=1.0*2:\n                continue\n            c1,c2 = center(location[i],location[j])\n            ans = max(ans,check(c1),check(c2))\n            \n    print(ans)\n            \n            \n        \n        \n"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\nfrom bisect import bisect_left\ndef circle_center(x1, y1, x2, y2):\n    xd = x2 - x1; yd = y2 - y1\n    d = xd**2 + yd**2\n    k = sqrt((4.0 - d) / d) / 2.0\n    xc = (x1 + x2) / 2.0; yc = (y1 + y2) / 2.0\n    xd *= k; yd *= k\n    return [[xc - yd, yc + xd], [xc + yd, yc - xd]]\nwhile 1:\n    n = int(raw_input())\n    if n==0: break\n    p = sorted(map(float, raw_input().split()) for i in xrange(n))\n    px = [e[0] for e in p]; py = [e[1] for e in p]\n    prev = 0\n    ans = 1\n    for i in xrange(n):\n        bx = px[i]; by = py[i]\n        while bx - px[prev] >= 2.0: prev += 1\n        for j in xrange(i+1, n):\n            cx = px[j]; cy = py[j]\n            if cx - bx >= 2.0: break\n            if (bx - cx)**2 + (by - cy)**2 <= 4.0:\n                for ex, ey in circle_center(bx, by, cx, cy):\n                    count = 2\n                    for k in xrange(prev, n):\n                        if k==i or k==j: continue\n                        dx = px[k]; dy = py[k]\n                        if dx - ex >= 1.0: break\n                        if (ex - dx)**2 + (ey - dy)**2 <= 1.0:\n                            count += 1\n                    ans = max(ans, count)\n    print ans"
  },
  {
    "language": "Python",
    "code": "def cent(p1,p2):\n    if abs(p1-p2) >= 2:\n        return None,None\n    else:\n        q = (p1+p2)/2\n        r = (p1-p2)/2\n        n = abs(r)\n        t = r * 1j * ((1-n**2)**0.5/n)\n        return(q + t, q - t)\n\nwhile(True):\n    ans = 0\n    n = int(input())\n    if n == 0:\n        quit()\n    ps = []\n    for _ in range(n):\n        x,y = map(float,input().split())\n        ps.append(x+y*1j)\n    for i in range(n):\n        for j in range(i+1,n):\n            ans1,ans2 = 0 , 0\n            p1,p2 = cent(ps[i],ps[j])\n            if p1 != None:\n                for m in range(n):\n                    if abs(p1-ps[m]) <= 1.001:\n                        ans1 += 1\n                    if abs(p2-ps[m]) <= 1.001:\n                        ans2 += 1\n                ans = max(ans,ans1,ans2)\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import random\nans = 0\nwhile 1:\n\tn = input()\n\tif n == 0: break\n\txy = [map(float,raw_input().split()) for i in range(n)]\n\tfor r in range(10000):\n\t\tcx,cy = 10*random.random(),10*random.random()\n\t\tcur = 0\n\t\tfor i in range(n):\n\t\t\tx,y = xy[i]\n\t\t\tif (cx-x)**2 + (cy-y)**2 <= 1:\n\t\t\t\tcur += 1\n\t\t\tif n - (i+1) + cur < ans: break\n\t\tans = max(ans,cur)\n\tprint ans"
  },
  {
    "language": "Python",
    "code": "\nimport cmath\ndef counter(z,a):\n    count= 0\n    for i in a:\n        if abs(i-z)<=1.0001:\n            count+=1\n    return count\nwhile True:\n    n= int(input())\n    if n==0:\n        break\n    elif n==1:\n        a= input()\n        print(\"1\")\n        continue\n    a=[]\n    for i in range(n):\n        x,y =map(float,input().split())\n        a.append(complex(x,y))\n    ans=1\n\n    for i in range(0,n):\n        for j in range(i+1,n):\n            p= (a[j]-a[i])/2\n            q= (a[j]+a[i])/2\n            if abs(p)> 1:\n                continue\n            r= ((1-abs(p)**2)**0.5)/abs(p) * p*complex(0,1)\n                \n            z1= q+r\n            z2= q-r\n\n            ans= max(ans,counter(z1,a),counter(z2,a))\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef cc(x1, y1, x2, y2):\n    xd = x2 - x1\n    yd = y2 - y1\n    xc = (x1 + x2) / 2\n    yc = (y1 + y2) / 2\n    k = pow(1.0 / (xd**2 + yd**2) - 0.25, 0.5)\n    xd *= k\n    yd *= k\n    return [[xc - yd, yc + xd], [xc + yd, yc - xd]]\n\ndef main():\n    rr = []\n    eps1 = 1 + eps\n\n    def f(n):\n        a = sorted([LF() for _ in range(n)])\n        r = 1\n        for i in range(n):\n            ax, ay = a[i]\n            for j in range(i+1,n):\n                bx, by = a[j]\n                if bx - ax > 2:\n                    break\n                if pow(ax-bx, 2) + pow(ay-by, 2) > 4:\n                    continue\n                for x, y in cc(ax, ay, bx, by):\n                    t = 0\n                    for k in range(n):\n                        if x - a[k][0] > 1:\n                            continue\n                        if a[k][0] - x > 1:\n                            break\n                        if pow(x-a[k][0], 2) + pow(y-a[k][1], 2) < eps1:\n                            t += 1\n                    if r < t:\n                        r = t\n\n        return r\n\n    while 1:\n        n = I()\n        if n == 0:\n            break\n        rr.append(f(n))\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "def cent(p1,p2):\n    if abs(p1-p2) >= 2:\n        return None,None\n    else:\n        q = (p1+p2)/2\n        r = (p1-p2)/2\n        n = abs(r)\n        t = r * 1j * ((1-n**2)**0.5/n)\n        return(q + t, q - t)\n\nwhile(True):\n    ans = 1\n    n = int(input())\n    if n == 0:\n        quit()\n    ps = []\n    for _ in range(n):\n        x,y = map(float,input().split())\n        ps.append(x+y*1j)\n    for i in range(n):\n        for j in range(i+1,n):\n            ans1,ans2 = 0 , 0\n            p1,p2 = cent(ps[i],ps[j])\n            if p1 != None:\n                for m in range(n):\n                    if abs(p1-ps[m]) <= 1.001:\n                        ans1 += 1\n                    if abs(p2-ps[m]) <= 1.001:\n                        ans2 += 1\n                ans = max(ans,ans1,ans2)\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\nfrom bisect import bisect_left\ndef circle_center(x1, y1, x2, y2):\n    xd = x2 - x1; yd = y2 - y1\n    d = xd**2 + yd**2\n    k = sqrt((4.0 - d) / d) / 2.0\n    xc = (x1 + x2) / 2.0; yc = (y1 + y2) / 2.0\n    xd *= k; yd *= k\n    return [[xc - yd, yc + xd], [xc + yd, yc - xd]]\nwhile 1:\n    n = int(raw_input())\n    if n==0: break\n    p = sorted(map(float, raw_input().split()) for i in xrange(n))\n    prev = 0\n    ans = 1\n    for i in xrange(n):\n        bx, by = p[i]\n        while bx - p[prev][0] >= 2.0: prev += 1\n        for j in xrange(i+1, n):\n            cx, cy = p[j]\n            if cx - bx >= 2.0: break\n            if (bx - cx)**2 + (by - cy)**2 <= 4.0:\n                for ex, ey in circle_center(bx, by, cx, cy):\n                    count = 2\n                    for k in xrange(prev, n):\n                        if k==i or k==j: continue\n                        dx, dy = p[k]\n                        if dx - ex >= 1.0: break\n                        if (ex - dx)**2 + (ey - dy)**2 <= 1.0:\n                            count += 1\n                    ans = max(ans, count)\n    print ans"
  },
  {
    "language": "Python",
    "code": "def cent(p1,p2):\n    if abs(p1-p2) >= 2:\n        return None,None\n    else:\n        q = (p1+p2)/2\n        r = (p1-p2)\n        n = abs(p1-p2)\n        t = r * 1j * ((1-r*2)**0.5/r)\n        return(q + t, q - t)\n\nwhile(True):\n    ans = 0\n    n = int(input())\n    ps = []\n    for _ in range(n):\n        x,y = map(int,input().split())\n        ps.append(x+yj)\n    for i in range(n):\n        for j in range(i+1,n):\n            ans1,ans2 = 0 , 0\n            p1,p2 = cent(ps[i],ps[j])\n            if p1 != None:\n                for m in range(n):\n                    if abs(p1-ps[m]) <= 1:\n                        ans1 += 1\n                    if abs(p2-ps[m]) <= 1:\n                        ans2 += 1\n                ans = max(ans,ans1,ans2)\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nsys.setrecursionlimit(1000000)\n\ndef func():\n    while True:\n        N = input()\n        if N == 0:\n            break\n        pos = []\n        for loop in range(N):\n            S = map(float, raw_input().split())\n            pos.append(S)\n        ans = 0\n        for i in range(N):\n            for j in range(N):\n                v = [pos[j][0] - pos[i][0], pos[j][1] - pos[i][1]]\n                norm = math.sqrt(v[0] * v[0] + v[1] * v[1])\n                if norm > 2 or norm == 0:\n                    continue\n                vn = [v[0] / norm, v[1] / norm]\n                norm /= 2\n                norm2 = math.sqrt(1 - norm * norm)\n                v90 = [-vn[1], vn[0]]\n                cent = [pos[i][0] + v[0] / 2 + v90[0] * norm2, \n                pos[i][1] + v[1] / 2 + v90[1] * norm2]\n                S = 2\n                for k in range(N):\n                    if i == k or j == k:\n                        continue\n                    x = cent[0] - pos[k][0]\n                    y = cent[1] - pos[k][1]\n                    if x * x + y * y <= 1:\n                        S += 1\n                ans = max(S, ans)\n        if ans == 80:\n            return 0\n        print ans\n\nfunc()\n"
  },
  {
    "language": "Python",
    "code": "import random\nans = 0\nwhile 1:\n\tn = input()\n\tif n == 0: break\n\txy = [map(float,raw_input().split()) for i in range(n)]\n\tfor i in range(10000):\n\t\tcx,cy = 10*random.random(),10*random.random()\n\t\tcur = 0\n\t\tfor x,y in xy:\n\t\t\tif (cx-x)**2 + (cy-y)**2 <= 1:\n\t\t\t\tcur += 1\n\t\tans = max(ans,cur)\n\tprint ans"
  },
  {
    "language": "Python",
    "code": "def cent(p1,p2):\n    if abs(p1-p2) >= 2:\n        return None,None\n    else:\n        q = (p1+p2)/2\n        r = (p1-p2)/2\n        n = abs(r)\n        t = r * 1j * ((1-n**2)**0.5/n)\n        return(q + t, q - t)\n\nwhile(True):\n    ans = 1\n    n = int(input())\n    if n == 0:\n        quit()\n    elif n == 1:\n        print(1)\n    ps = []\n    for _ in range(n):\n        x,y = map(float,input().split())\n        ps.append(x+y*1j)\n    for i in range(n):\n        for j in range(i+1,n):\n            ans1,ans2 = 0 , 0\n            p_1,p_2 = cent(ps[i],ps[j])\n            if p_1 != None:\n                for m in range(n):\n                    if abs(p_1-ps[m]) <= 1.001:\n                        ans1 += 1\n                    if abs(p_2-ps[m]) <= 1.001:\n                        ans2 += 1\n                ans = max(ans,ans1,ans2)\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nsys.setrecursionlimit(1000000)\n\ndef func():\n    lst = []\n    while True:\n        S = input()\n        lst.append(S)\n        if S == '0':\n            break\n    lst = list(reversed(lst))\n    while True:\n        N = int(lst.pop())\n        if N == 0:\n            break\n        R = range(N)\n        pos = []\n        for loop in R:\n            S = list(map(float, lst.pop().split()))\n            pos.append(S)\n        ans = 0\n        for i in R:\n            for j in R:\n                v = [pos[j][0] - pos[i][0], pos[j][1] - pos[i][1]]\n                norm = math.sqrt(v[0] * v[0] + v[1] * v[1])\n                if norm > 2 or norm == 0:\n                    continue\n                vn = [v[0] / norm, v[1] / norm]\n                norm /= 2\n                norm2 = math.sqrt(1 - norm * norm)\n                v90 = [-vn[1], vn[0]]\n                cent = [pos[i][0] + v[0] / 2 + v90[0] * norm2, \n                pos[i][1] + v[1] / 2 + v90[1] * norm2]\n                S = 2\n                for k in R:\n                    if i == k or j == k:\n                        continue\n                    x = cent[0] - pos[k][0]\n                    y = cent[1] - pos[k][1]\n                    if x * x + y * y <= 1:\n                        S += 1\n                ans = max(S, ans)\n        print(max(1, ans))\n\nif __name__ == '__main__':\n    func()\n"
  },
  {
    "language": "Python",
    "code": "import math\ndef count(a, b, P):\n    if abs(a-b) > 2:\n        return 0\n    if a == b:\n        return 0\n    m = (a+b)/2\n    c = m + (m-a)*(math.sqrt(1-abs(m-a)**2))*1j/abs(m-a)\n    cnt = 0\n    for x in P:\n        if abs(x-c) <=1.0001:\n            cnt += 1\n    return cnt\n\nwhile True:\n    N = int(input())\n    if N == 0:\n        break\n    P = []\n    for i in range(N):\n        x, y = map(float, input().split())\n        P.append(complex(x,y))\n    ans = 1\n    Max = -1\n    for i in range(N):\n        for j in range(N):\n            num = count(P[i], P[j], P)\n            Max = max(Max, num)\n    print(max(Max, ans))\n"
  },
  {
    "language": "Python",
    "code": "import random\nans = 0\nwhile 1:\n\tn = input()\n\tif n == 0: break\n\txy = [map(float,raw_input().split()) for i in range(n)]\n\tfor r in range(20000):\n\t\tcx,cy = 10*random.random(),10*random.random()\n\t\tcur = 0\n\t\tfor i in range(n):\n\t\t\tx,y = xy[i]\n\t\t\tif (cx-x)**2 + (cy-y)**2 <= 1:\n\t\t\t\tcur += 1\n\t\t\tif n - cur < ans: break\n\t\tans = max(ans,cur)\n\tprint ans"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_variables, dead_code)]\nuse std::io::{stdin, Read, StdinLock};\nuse std::str::FromStr;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\nuse std::ops::*;\nuse std::num::*;\n\n// https://beta.atcoder.jp/contests/arc065/tasks/arc065_b\n\nfn main() {\n    let cin = stdin(); let cin = cin.lock(); let mut sc = Scanner::new(cin);\n\n    let mut n: usize = 0;\n    loop {\n        n = sc.read();\n        if n == 0 { break; }\n        \n        let mut ps: Vec<Point<f64>> = Vec::new();\n        for i in 0..n {\n            ps.push(Point{ x: sc.read(), y: sc.read() });\n        }\n\n        let eps = 1e-6;\n        let mut ans = 1;\n        for i in 0..n {\n            for j in 0..n {\n                if i == j { continue; }\n                let (p1, p2) = (ps[i], ps[j]);\n                let mid: Point<f64> = (p1 + p2) / 2.0;\n                let d2 = dist2(&p1, &p2);\n                let d = d2.sqrt();\n                if d > (2.0 + eps) { continue; }\n                let theta = (d / 2.0).asin();\n                let l = (1.0 - d2 / 4.0).sqrt();\n                let (dx, dy) = (p1.x - p2.x, p1.y - p2.y);\n                let diff = Point{ x: -l * dy / d, y: l * dx / d};\n                let (c1, c2) = (mid + diff, mid - diff);\n                \n                let mut cnt1 = 0;\n                let mut cnt2 = 0;\n                for k in 0..n {\n                    //if (k == i) | (k == j) { continue; }\n                    if dist2(&ps[k], &c1) < (1.0 + eps) { cnt1 += 1; }\n                    if dist2(&ps[k], &c2) < (1.0 + eps) { cnt2 += 1; }\n                }\n                ans = max(ans, cnt1);\n//                ans = max(ans, cnt2);\n            }\n        }\n        println!(\"{}\", ans);\n    }\n}\n\n// \n\nfn dist2(p1: &Point<f64>, p2: &Point<f64>) -> f64 {\n    let dx = p1.x - p2.x;\n    let dy = p1.y - p2.y;\n    dx*dx + dy*dy\n}\n\n#[derive(Debug, Copy, Clone, Eq)]\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Add for Point<T> where T: Add<Output=T> {\n    type Output = Point<T>;\n    \n    fn add(self, other: Point<T>) -> Point<T> {\n        Point{ x: self.x + other.x, y: self.y + other.y }\n    }\n}\n\nimpl<T> Sub for Point<T> where T: Sub<Output=T> {\n    type Output = Point<T>;\n    \n    fn sub(self, other: Point<T>) -> Point<T> {\n        Point{ x: self.x - other.x, y: self.y - other.y }\n    }\n}\n\nimpl<T> Div<T> for Point<T> where T: Div<Output=T> + Copy {\n    type Output = Point<T>;\n    \n    fn div(self, divisor: T) -> Point<T> {\n        Point{ x: self.x / divisor, y: self.y / divisor }\n    }\n}\n\nimpl<T> Ord for Point<T> where T: Ord {\n    fn cmp(&self, other: &Point<T>) -> Ordering {\n        if self.x == other.x { return self.y.cmp(&other.y); }\n        else { return self.x.cmp(&other.x); }\n    }\n}\n\nimpl<T> PartialOrd<Point<T>> for Point<T> where T: PartialOrd {\n    fn partial_cmp(&self, other: &Point<T>) -> Option<Ordering> {\n        if self.x == other.x { return self.y.partial_cmp(&other.y); }\n        else { return self.x.partial_cmp(&other.x); }\n    }\n}\n\nimpl<T> PartialEq<Point<T>> for Point<T> where T: PartialEq {\n    fn eq(&self, other: &Point<T>) -> bool {\n        (self.x == other.x) & (self.y == other.y)\n    }\n}\n\n\n// input\nstruct Scanner<'a> {\n    cin: StdinLock<'a>,\n}\nimpl<'a> Scanner<'a> {\n    fn new(cin: StdinLock<'a>) -> Scanner<'a> {\n        Scanner { cin: cin }\n    }\n \n    fn read1<T: FromStr>(&mut self) -> Option<T> {\n        let token = self.cin.by_ref().bytes().map(|c| c.unwrap() as char)\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect::<String>();\n        token.parse::<T>().ok()\n    }\n \n    fn read<T: FromStr>(&mut self) -> T {\n        self.read1().unwrap()\n    }\n}\n"
  }
]