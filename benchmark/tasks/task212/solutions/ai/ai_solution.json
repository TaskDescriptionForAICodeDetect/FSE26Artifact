[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double x;\n    double y;\n} Point;\n\ndouble distance_squared(Point a, Point b) {\n    double dx = a.x - b.x;\n    double dy = a.y - b.y;\n    return dx * dx + dy * dy;\n}\n\nint max_points_in_circle(Point points[], int n) {\n    if (n == 0) return 0;\n    int max_count = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            double d_sq = distance_squared(points[i], points[j]);\n            if (d_sq > 4.0) continue;\n            double d = sqrt(d_sq);\n            double r = 1.0;\n            double h = sqrt(r * r - d_sq / 4.0);\n            Point mid = {\n                (points[i].x + points[j].x) / 2,\n                (points[i].y + points[j].y) / 2\n            };\n            double dx = points[j].x - points[i].x;\n            double dy = points[j].y - points[i].y;\n            Point center1 = {\n                mid.x - (dy * h) / d,\n                mid.y + (dx * h) / d\n            };\n            Point center2 = {\n                mid.x + (dy * h) / d,\n                mid.y - (dx * h) / d\n            };\n            int count1 = 0, count2 = 0;\n            for (int k = 0; k < n; k++) {\n                if (distance_squared(center1, points[k]) <= 1.0 + 1e-9) {\n                    count1++;\n                }\n                if (distance_squared(center2, points[k]) <= 1.0 + 1e-9) {\n                    count2++;\n                }\n            }\n            if (count1 > max_count) max_count = count1;\n            if (count2 > max_count) max_count = count2;\n        }\n    }\n    return max_count;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Point points[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &points[i].x, &points[i].y);\n    }\n    printf(\"%d\\n\", max_points_in_circle(points, n));\n    return 0;\n}",
    "timestamp": "2025-08-05 19:06:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public int maxPointsEnclosed(int[][] points) {\n        int n = points.length;\n        int maxPoints = 0;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                int count = 0;\n                for (int k = 0; k < n; k++) {\n                    double distance = Math.sqrt(\n                        Math.pow(points[k][0] - points[i][0], 2) +\n                        Math.pow(points[k][1] - points[i][1], 2)\n                    );\n                    \n                    if (distance <= 1.0) {\n                        count++;\n                    }\n                }\n                maxPoints = Math.max(maxPoints, count);\n            }\n        }\n\n        return maxPoints;\n    }\n}",
    "timestamp": "2025-08-05 19:06:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\nint maxEnclosedPoints(vector<Point>& points) {\n    int n = points.size();\n    if (n <= 1) return n;\n\n    int max_points = 1;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            double dx = points[j].x - points[i].x;\n            double dy = points[j].y - points[i].y;\n            double dist = sqrt(dx * dx + dy * dy);\n            if (dist > 2.0) continue;\n\n            double mid_x = (points[i].x + points[j].x) / 2.0;\n            double mid_y = (points[i].y + points[j].y) / 2.0;\n            double h = sqrt(1.0 - (dist * dist / 4.0));\n\n            double cx1 = mid_x - (dy * h) / dist;\n            double cy1 = mid_y + (dx * h) / dist;\n            double cx2 = mid_x + (dy * h) / dist;\n            double cy2 = mid_y - (dx * h) / dist;\n\n            int count1 = 0, count2 = 0;\n            for (const auto& p : points) {\n                double dx1 = p.x - cx1;\n                double dy1 = p.y - cy1;\n                if (dx1 * dx1 + dy1 * dy1 <= 1.0 + 1e-9) {\n                    count1++;\n                }\n                double dx2 = p.x - cx2;\n                double dy2 = p.y - cy2;\n                if (dx2 * dx2 + dy2 * dy2 <= 1.0 + 1e-9) {\n                    count2++;\n                }\n            }\n            max_points = max(max_points, max(count1, count2));\n        }\n    }\n    return max_points;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Point> points(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> points[i].x >> points[i].y;\n    }\n    cout << maxEnclosedPoints(points) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 19:06:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define MAX_POINTS 1000\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble distance(Point p1, Point p2) {\n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\nint count_points_in_circle(Point *points, int n, Point center) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (distance(points[i], center) <= 1.0) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint max_points_in_circle(Point *points, int n) {\n    int max_points = 0;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            double d = distance(points[i], points[j]);\n            \n            if (d > 2.0) continue;\n            \n            Point center1, center2;\n            \n            if (d == 0.0) {\n                center1 = points[i];\n                int curr_points = count_points_in_circle(points, n, center1);\n                max_points = fmax(max_points, curr_points);\n                continue;\n            }\n            \n            double a = (1.0 - d * d / 4.0) / (2 * (points[i].y - points[j].y));\n            double b = (points[i].x + points[j].x) / 2.0 - a * (points[i].x - points[j].x);\n            \n            center1.x = b;\n            center1.y = a * b + (points[i].y + points[j].y) / 2.0;\n            \n            center2.x = b;\n            center2.y = -a * b + (points[i].y + points[j].y) / 2.0;\n            \n            int curr_points1 = count_points_in_circle(points, n, center1);\n            int curr_points2 = count_points_in_circle(points, n, center2);\n            \n            max_points = fmax(max_points, fmax(curr_points1, curr_points2));\n        }\n    }\n    \n    return max_points;\n}\n\nint main() {\n    int n;\n    Point points[MAX_POINTS];\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &points[i].x, &points[i].y);\n    }\n    \n    printf(\"%d\\n\", max_points_in_circle(points, n));\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:06:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nconst double EPS = 1e-9;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n};\n\ndouble dist(const Point& a, const Point& b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nint maxPointsInCircle(vector<Point>& points) {\n    int n = points.size();\n    int maxPoints = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (dist(points[i], points[j]) > 2.0) continue;\n\n            double midX = (points[i].x + points[j].x) / 2.0;\n            double midY = (points[i].y + points[j].y) / 2.0;\n\n            double dx = points[i].x - points[j].x;\n            double dy = points[i].y - points[j].y;\n            double d = sqrt(dx * dx + dy * dy);\n\n            double h = sqrt(1.0 - (d / 2.0) * (d / 2.0));\n\n            Point center1, center2;\n            if (abs(dx) > EPS) {\n                double angle = atan2(dy, dx);\n                center1.x = midX + h * sin(angle);\n                center1.y = midY - h * cos(angle);\n                center2.x = midX - h * sin(angle);\n                center2.y = midY + h * cos(angle);\n            } else {\n                center1.x = midX + h;\n                center1.y = midY;\n                center2.x = midX - h;\n                center2.y = midY;\n            }\n\n            int count1 = 0, count2 = 0;\n            for (const Point& p : points) {\n                if (dist(p, center1) <= 1.0 + EPS) count1++;\n                if (dist(p, center2) <= 1.0 + EPS) count2++;\n            }\n\n            maxPoints = max(maxPoints, max(count1, count2));\n        }\n    }\n\n    for (const Point& p : points) {\n        int count = 0;\n        for (const Point& q : points) {\n            if (dist(p, q) <= 1.0 + EPS) count++;\n        }\n        maxPoints = max(maxPoints, count);\n    }\n\n    return maxPoints;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> points(n);\n\n    for (int i = 0; i < n; i++) {\n        cin >> points[i].x >> points[i].y;\n    }\n\n    cout << maxPointsInCircle(points) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:07:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MaxPointsInCircle {\n    public static int maxPoints(int[][] points) {\n        if (points.length <= 1) {\n            return points.length;\n        }\n        int max = 1;\n        for (int i = 0; i < points.length; i++) {\n            for (int j = i + 1; j < points.length; j++) {\n                double[] center = getCenter(points[i], points[j]);\n                if (center == null) {\n                    continue;\n                }\n                int count = 0;\n                for (int[] point : points) {\n                    double dx = point[0] - center[0];\n                    double dy = point[1] - center[1];\n                    if (dx * dx + dy * dy <= 1.0 + 1e-8) {\n                        count++;\n                    }\n                }\n                max = Math.max(max, count);\n            }\n        }\n        return max;\n    }\n\n    private static double[] getCenter(int[] p1, int[] p2) {\n        double x1 = p1[0], y1 = p1[1];\n        double x2 = p2[0], y2 = p2[1];\n        double dx = x2 - x1, dy = y2 - y1;\n        double dist = Math.sqrt(dx * dx + dy * dy);\n        if (dist > 2.0) {\n            return null;\n        }\n        double midX = (x1 + x2) / 2.0;\n        double midY = (y1 + y2) / 2.0;\n        if (Math.abs(dist - 2.0) < 1e-8) {\n            return new double[]{midX, midY};\n        }\n        double angle = Math.atan2(dy, dx);\n        double perpendicularDist = Math.sqrt(1.0 - (dist * dist / 4.0));\n        double centerX1 = midX - perpendicularDist * Math.sin(angle);\n        double centerY1 = midY + perpendicularDist * Math.cos(angle);\n        return new double[]{centerX1, centerY1};\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[][] points = new int[N][2];\n        for (int i = 0; i < N; i++) {\n            points[i][0] = scanner.nextInt();\n            points[i][1] = scanner.nextInt();\n        }\n        System.out.println(maxPoints(points));\n    }\n}",
    "timestamp": "2025-08-05 19:07:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef max_enclosed_points(points):\n    def distance_squared(p1, p2):\n        return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2\n\n    def is_inside_circle(center, point):\n        return distance_squared(center, point) <= 1**2\n\n    def find_centers(p1, p2):\n        dx, dy = p2[0] - p1[0], p2[1] - p1[1]\n        q = math.sqrt(dx**2 + dy**2)\n        if q > 2:\n            return []\n        mid_x = (p1[0] + p2[0]) / 2\n        mid_y = (p1[1] + p2[1]) / 2\n        base_x = mid_x\n        base_y = mid_y\n\n        h = math.sqrt(1 - (q/2)**2)  # height from midpoint to center\n        return [(base_x - h * dy/q, base_y + h * dx/q), \n                (base_x + h * dy/q, base_y - h * dx/q)]\n\n    def count_enclosed(center):\n        return sum(is_inside_circle(center, point) for point in points)\n\n    n = len(points)\n    max_count = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            centers = find_centers(points[i], points[j])\n            for center in centers:\n                max_count = max(max_count, count_enclosed(center))\n\n    return max_count\n\n# Example usage:\n# points = [(0, 0), (1, 0), (0, 1), (1, 1)]\n# print(max_enclosed_points(points))",
    "timestamp": "2025-08-13 02:30:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class CircleEnclosure {\n\n    public static void main(String[] args) {\n        int[][] points = {{0, 0}, {1, 0}, {0, 1}, {1, 1}, {2, 0}, {0, 2}};\n        System.out.println(maxPointsInCircle(points)); // Example usage\n    }\n\n    public static int maxPointsInCircle(int[][] points) {\n        int n = points.length;\n        if (n == 0) return 0;\n\n        int maxPoints = 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i != j && distance(points[i], points[j]) <= 4) {\n                    double[] center1 = findCircleCenter(points[i], points[j], true);\n                    double[] center2 = findCircleCenter(points[i], points[j], false);\n                    maxPoints = Math.max(maxPoints, countPointsInCircle(points, center1));\n                    maxPoints = Math.max(maxPoints, countPointsInCircle(points, center2));\n                }\n            }\n        }\n        return maxPoints;\n    }\n\n    private static double distance(int[] a, int[] b) {\n        return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]);\n    }\n\n    private static double[] findCircleCenter(int[] a, int[] b, boolean flag) {\n        double dist = Math.sqrt(distance(a, b));\n        double xMid = (a[0] + b[0]) / 2.0;\n        double yMid = (a[1] + b[1]) / 2.0;\n        double h = Math.sqrt(1 - (dist / 2) * (dist / 2));\n        double ratio = ((flag) ? 1 : -1) * h / dist;\n        double deltaX = b[0] - a[0];\n        double deltaY = b[1] - a[1];\n        double cx = xMid + ratio * deltaY;\n        double cy = yMid - ratio * deltaX;\n        return new double[]{cx, cy};\n    }\n\n    private static int countPointsInCircle(int[][] points, double[] center) {\n        int count = 0;\n        for (int[] point : points) {\n            if (Math.pow(point[0] - center[0], 2) + Math.pow(point[1] - center[1], 2) <= 1.000001) {\n                count++;\n            }\n        }\n        return count;\n    }\n}",
    "timestamp": "2025-08-13 02:30:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define MAX_POINTS 1000\n\ntypedef struct {\n    double x, y;\n} Point;\n\nint count_points_inside(Point points[], int n, Point center) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        double dx = points[i].x - center.x;\n        double dy = points[i].y - center.y;\n        if (dx * dx + dy * dy <= 1.0)\n            count++;\n    }\n    return count;\n}\n\nint max_enclosed_points(Point points[], int n) {\n    int max_count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            // Case 1: Circle with center at one of the points\n            max_count = fmax(max_count, count_points_inside(points, n, points[i]));\n\n            // Case 2: Circle with center between two points\n            double dx = points[j].x - points[i].x;\n            double dy = points[j].y - points[i].y;\n            double dist_sq = dx * dx + dy * dy;\n            if (dist_sq > 4.0) continue;  // Only consider pairs with distance <= 2\n\n            double r_sq = 1.0;\n            double h = sqrt(fmax(0.0, r_sq - dist_sq / 4));\n            double mid_x = (points[i].x + points[j].x) / 2;\n            double mid_y = (points[i].y + points[j].y) / 2;\n\n            // Calculate the two possible center positions\n            Point centers[2];\n            centers[0].x = mid_x + h * dy / sqrt(dist_sq);\n            centers[0].y = mid_y - h * dx / sqrt(dist_sq);\n            centers[1].x = mid_x - h * dy / sqrt(dist_sq);\n            centers[1].y = mid_y + h * dx / sqrt(dist_sq);\n\n            for (int c = 0; c < 2; c++)\n                max_count = fmax(max_count, count_points_inside(points, n, centers[c]));\n        }\n    }\n    return max_count;\n}\n\nint main() {\n    int n;\n    Point points[MAX_POINTS];\n    \n    // Reading input\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++)\n        scanf(\"%lf %lf\", &points[i].x, &points[i].y);\n        \n    printf(\"%d\\n\", max_enclosed_points(points, n));\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 02:31:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_points_in_circle(points):\n    n = len(points)\n    max_points = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            # Try circles passing through two points\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            \n            # Circle centers with radius 1\n            centers = find_circle_centers(x1, y1, x2, y2)\n            \n            for cx, cy in centers:\n                points_in_circle = sum(1 for x, y in points \n                                       if (x - cx)**2 + (y - cy)**2 <= 1)\n                max_points = max(max_points, points_in_circle)\n    \n    return max_points\n\ndef find_circle_centers(x1, y1, x2, y2):\n    # Distance between points\n    d = ((x1 - x2)**2 + (y1 - y2)**2)**0.5\n    \n    # If points are too far apart, no circle possible\n    if d > 2:\n        return []\n    \n    # Midpoint of points\n    mx, my = (x1 + x2) / 2, (y1 + y2) / 2\n    \n    # Perpendicular bisector\n    if x1 == x2:\n        dx, dy = 1, 0\n    else:\n        slope = -(x2 - x1) / (y2 - y1) if y1 != y2 else 0\n        dx = (1 / (1 + slope**2))**0.5\n        dy = slope * dx\n    \n    # Two possible circle centers\n    dist = (1 - (d/2)**2)**0.5\n    \n    return [\n        (mx + dist * dx, my + dist * dy),\n        (mx - dist * dx, my - dist * dy)\n    ]",
    "timestamp": "2025-08-13 02:31:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef max_points_enclosed(points):\n    max_count = 1  # At least one point can be enclosed\n    n = len(points)\n    if n <= 1:\n        return n\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dx, dy = x2 - x1, y2 - y1\n            distance = math.hypot(dx, dy)\n            \n            if distance > 2.0:\n                continue  # Cannot be covered by a unit circle\n            \n            # Calculate the center(s) of the circle(s)\n            mid_x, mid_y = (x1 + x2) / 2, (y1 + y2) / 2\n            if distance == 2.0:\n                centers = [(mid_x, mid_y)]\n            else:\n                h = math.sqrt(1.0 - (distance / 2.0) ** 2)\n                nx, ny = -dy / distance, dx / distance\n                c1 = (mid_x + h * nx, mid_y + h * ny)\n                c2 = (mid_x - h * nx, mid_y - h * ny)\n                centers = [c1, c2]\n            \n            for center in centers:\n                cx, cy = center\n                count = 0\n                for (px, py) in points:\n                    if (px - cx) ** 2 + (py - cy) ** 2 <= 1.0 + 1e-9:\n                        count += 1\n                if count > max_count:\n                    max_count = count\n    \n    return max_count\n\n# Example usage:\n# points = [(0,0), (1,0), (2,0), (0,1)]\n# print(max_points_enclosed(points))",
    "timestamp": "2025-08-13 02:31:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nconst double EPS = 1e-9;\nconst double RADIUS = 1.0;\n\nstruct Point {\n    double x, y;\n};\n\nbool isInsideCircle(const Point& point, const Point& center) {\n    double distSq = (point.x - center.x) * (point.x - center.x) +\n                    (point.y - center.y) * (point.y - center.y);\n    return distSq <= RADIUS * RADIUS + EPS;\n}\n\nint maxEnclosedPoints(int N, const vector<Point>& points) {\n    int maxCount = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            vector<Point> centers;\n            double dx = points[j].x - points[i].x;\n            double dy = points[j].y - points[i].y;\n            double dSq = dx * dx + dy * dy;\n            if (dSq <= 4 * RADIUS * RADIUS + EPS) {\n                double d = sqrt(dSq);\n                double h = sqrt(RADIUS * RADIUS - (d / 2) * (d / 2));\n                double mx = (points[i].x + points[j].x) / 2.0;\n                double my = (points[i].y + points[j].y) / 2.0;\n                double hx = -dy / d * h;\n                double hy = dx / d * h;\n\n                centers.push_back(Point{mx + hx, my + hy});\n                centers.push_back(Point{mx - hx, my - hy});\n            } else {\n                centers.push_back(points[i]);\n                centers.push_back(points[j]);\n            }\n\n            for (const auto& center : centers) {\n                int count = 0;\n                for (const auto& point : points) {\n                    if (isInsideCircle(point, center)) {\n                        ++count;\n                    }\n                }\n                maxCount = max(maxCount, count);\n            }\n        }\n    }\n    return maxCount;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Point> points(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> points[i].x >> points[i].y;\n    }\n    cout << maxEnclosedPoints(N, points) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:06:21"
  }
]