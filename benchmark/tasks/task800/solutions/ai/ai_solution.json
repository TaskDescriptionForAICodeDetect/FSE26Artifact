[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\ntypedef struct {\n    int from;\n    int to;\n    long long cost;\n} Edge;\n\nint compare(const void* a, const void* b) {\n    Edge* edgeA = (Edge*)a;\n    Edge* edgeB = (Edge*)b;\n    return (edgeA->cost > edgeB->cost) - (edgeA->cost < edgeB->cost);\n}\n\nint find(int* parent, int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent, parent[x]);\n    return parent[x];\n}\n\nvoid unionSet(int* parent, int x, int y) {\n    int rootX = find(parent, x);\n    int rootY = find(parent, y);\n    parent[rootX] = rootY;\n}\n\nint main() {\n    int N, D;\n    scanf(\"%d %d\", &N, &D);\n\n    int A[N];\n    for (int i = 0; i < N; i++)\n        scanf(\"%d\", &A[i]);\n\n    Edge edges[N * (N - 1) / 2];\n    int edgeCount = 0;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            edges[edgeCount].from = i;\n            edges[edgeCount].to = j;\n            edges[edgeCount].cost = abs(i - j) * D + A[i] + A[j];\n            edgeCount++;\n        }\n    }\n\n    qsort(edges, edgeCount, sizeof(Edge), compare);\n\n    int parent[N];\n    for (int i = 0; i < N; i++)\n        parent[i] = i;\n\n    long long totalCost = 0;\n    int edgesAdded = 0;\n\n    for (int i = 0; i < edgeCount; i++) {\n        int from = edges[i].from;\n        int to = edges[i].to;\n\n        if (find(parent, from) != find(parent, to)) {\n            unionSet(parent, from, to);\n            totalCost += edges[i].cost;\n            edgesAdded++;\n\n            if (edgesAdded == N - 1)\n                break;\n        }\n    }\n\n    printf(\"%lld\\n\", totalCost);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:57:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int cost;\n    int u;\n    int v;\n} Edge;\n\nint compare(const void *a, const void *b) {\n    Edge *edgeA = (Edge *)a;\n    Edge *edgeB = (Edge *)b;\n    return edgeA->cost - edgeB->cost;\n}\n\nint find(int parent[], int i) {\n    if (parent[i] != i) {\n        parent[i] = find(parent, parent[i]);\n    }\n    return parent[i];\n}\n\nvoid unionSets(int parent[], int rank[], int x, int y) {\n    int xroot = find(parent, x);\n    int yroot = find(parent, y);\n    if (rank[xroot] < rank[yroot]) {\n        parent[xroot] = yroot;\n    } else if (rank[xroot] > rank[yroot]) {\n        parent[yroot] = xroot;\n    } else {\n        parent[yroot] = xroot;\n        rank[xroot]++;\n    }\n}\n\nint main() {\n    int N, D;\n    scanf(\"%d %d\", &N, &D);\n    int *A = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    Edge *edges = (Edge *)malloc(N * (N - 1) / 2 * sizeof(Edge));\n    int edgeCount = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            edges[edgeCount].cost = abs(i - j) * D + A[i] + A[j];\n            edges[edgeCount].u = i;\n            edges[edgeCount].v = j;\n            edgeCount++;\n        }\n    }\n\n    qsort(edges, edgeCount, sizeof(Edge), compare);\n\n    int *parent = (int *)malloc(N * sizeof(int));\n    int *rank = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n\n    long long totalCost = 0;\n    int selectedEdges = 0;\n    for (int i = 0; i < edgeCount; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        int uroot = find(parent, u);\n        int vroot = find(parent, v);\n        if (uroot != vroot) {\n            unionSets(parent, rank, uroot, vroot);\n            totalCost += edges[i].cost;\n            selectedEdges++;\n            if (selectedEdges == N - 1) {\n                break;\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", totalCost);\n\n    free(A);\n    free(edges);\n    free(parent);\n    free(rank);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:58:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n    int u, v;\n    long long cost;\n    bool operator<(const Edge &other) const {\n        return cost < other.cost;\n    }\n};\n\nstruct DSU {\n    vector<int> parent;\n    DSU(int n) : parent(n) {\n        for (int i = 0; i < n; ++i) parent[i] = i;\n    }\n    int find(int u) {\n        if (parent[u] != u) parent[u] = find(parent[u]);\n        return parent[u];\n    }\n    bool unite(int u, int v) {\n        u = find(u);\n        v = find(v);\n        if (u == v) return false;\n        parent[v] = u;\n        return true;\n    }\n};\n\nint main() {\n    int N;\n    long long D;\n    cin >> N >> D;\n    vector<long long> A(N);\n    for (int i = 0; i < N; ++i) cin >> A[i];\n\n    vector<Edge> edges;\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            long long cost = (j - i) * D + A[i] + A[j];\n            edges.push_back({i, j, cost});\n        }\n    }\n\n    sort(edges.begin(), edges.end());\n    DSU dsu(N);\n    long long total_cost = 0;\n    for (const Edge &e : edges) {\n        if (dsu.unite(e.u, e.v)) {\n            total_cost += e.cost;\n        }\n    }\n\n    cout << total_cost << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:58:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int N = Integer.parseInt(st.nextToken());\n        long D = Long.parseLong(st.nextToken());\n        \n        long[] A = new long[N];\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < N; i++) {\n            A[i] = Long.parseLong(st.nextToken());\n        }\n        \n        PriorityQueue<Edge> minHeap = new PriorityQueue<>((a, b) -> Long.compare(a.cost, b.cost));\n        boolean[] visited = new boolean[N];\n        visited[0] = true;\n        \n        for (int j = 1; j < N; j++) {\n            long cost = Math.abs(0 - j) * D + A[0] + A[j];\n            minHeap.add(new Edge(0, j, cost));\n        }\n        \n        long totalCost = 0;\n        int edgesAdded = 0;\n        \n        while (!minHeap.isEmpty() && edgesAdded < N - 1) {\n            Edge edge = minHeap.poll();\n            if (visited[edge.u] && visited[edge.v]) continue;\n            \n            totalCost += edge.cost;\n            edgesAdded++;\n            \n            int newNode = visited[edge.u] ? edge.v : edge.u;\n            visited[newNode] = true;\n            \n            for (int j = 0; j < N; j++) {\n                if (!visited[j]) {\n                    long cost = Math.abs(newNode - j) * D + A[newNode] + A[j];\n                    minHeap.add(new Edge(newNode, j, cost));\n                }\n            }\n        }\n        \n        System.out.println(totalCost);\n    }\n    \n    static class Edge {\n        int u, v;\n        long cost;\n        \n        Edge(int u, int v, long cost) {\n            this.u = u;\n            this.v = v;\n            this.cost = cost;\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:58:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class MinimumRoadCost {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        \n        int N = Integer.parseInt(br.readLine());\n        String[] input = br.readLine().split(\" \");\n        \n        int[] A = new int[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = Integer.parseInt(input[i]);\n        }\n        \n        int D = Integer.parseInt(br.readLine());\n        \n        // Using Kruskal's algorithm with disjoint set\n        PriorityQueue<Edge> edges = new PriorityQueue<>();\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                int cost = Math.abs(i - j) * D + A[i] + A[j];\n                edges.offer(new Edge(i, j, cost));\n            }\n        }\n        \n        DisjointSet ds = new DisjointSet(N);\n        long totalCost = 0;\n        int roadsBuilt = 0;\n        \n        while (!edges.isEmpty() && roadsBuilt < N - 1) {\n            Edge edge = edges.poll();\n            if (ds.union(edge.u, edge.v)) {\n                totalCost += edge.cost;\n                roadsBuilt++;\n            }\n        }\n        \n        System.out.println(totalCost);\n    }\n    \n    static class Edge implements Comparable<Edge> {\n        int u, v, cost;\n        \n        Edge(int u, int v, int cost) {\n            this.u = u;\n            this.v = v;\n            this.cost = cost;\n        }\n        \n        public int compareTo(Edge other) {\n            return Integer.compare(this.cost, other.cost);\n        }\n    }\n    \n    static class DisjointSet {\n        int[] parent;\n        int[] rank;\n        \n        DisjointSet(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n        \n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        boolean union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            \n            if (rootX == rootY) {\n                return false;\n            }\n            \n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n            \n            return true;\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:58:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nstruct Edge {\n    int u, v, cost;\n    bool operator<(const Edge& other) const {\n        return cost > other.cost;\n    }\n};\n\nclass UnionFind {\nprivate:\n    vector<int> parent, rank;\n\npublic:\n    UnionFind(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    bool unite(int x, int y) {\n        int px = find(x), py = find(y);\n        if (px == py) return false;\n\n        if (rank[px] < rank[py]) {\n            parent[px] = py;\n        } else {\n            parent[py] = px;\n            if (rank[px] == rank[py]) {\n                rank[px]++;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    int N, D;\n    cin >> N >> D;\n\n    vector<int> A(N);\n    for (int i = 0; i < N; i++) {\n        cin >> A[i];\n    }\n\n    priority_queue<Edge> edges;\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            int cost = abs(i - j) * D + A[i] + A[j];\n            edges.push({i, j, cost});\n        }\n    }\n\n    UnionFind uf(N);\n    long long total_cost = 0;\n    int connected_edges = 0;\n\n    while (!edges.empty() && connected_edges < N - 1) {\n        Edge e = edges.top();\n        edges.pop();\n\n        if (uf.unite(e.u, e.v)) {\n            total_cost += e.cost;\n            connected_edges++;\n        }\n    }\n\n    cout << total_cost << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:59:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def minimum_cost_to_connect_cities(N, D, city_sizes):\n    import heapq\n\n    def prim():\n        visited = [False] * N\n        min_heap = [(0, 0)]  # (cost, city)\n        total_cost = 0\n        count = 0\n\n        while min_heap and count < N:\n            cost, city = heapq.heappop(min_heap)\n            if visited[city]:\n                continue\n            visited[city] = True\n            total_cost += cost\n            count += 1\n\n            for next_city in range(N):\n                if not visited[next_city]:\n                    edge_cost = abs(city - next_city) * D + city_sizes[city] + city_sizes[next_city]\n                    heapq.heappush(min_heap, (edge_cost, next_city))\n\n        return total_cost\n\n    return prim()\n\n# Example Usage\nN = 5\nD = 2\ncity_sizes = [1, 5, 3, 4, 2]\nprint(minimum_cost_to_connect_cities(N, D, city_sizes))",
    "timestamp": "2025-08-13 13:07:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Arrays;\n\nclass Solution {\n    public long minimumCost(int N, int D, int[] A) {\n        long[] minCost = new long[N];\n        boolean[] visited = new boolean[N];\n        Arrays.fill(minCost, Long.MAX_VALUE);\n        minCost[0] = 0;\n        \n        PriorityQueue<long[]> pq = new PriorityQueue<>((a, b) -> Long.compare(a[0], b[0]));\n        pq.offer(new long[] { 0, 0 }); // {cost, cityIndex}\n        \n        while (!pq.isEmpty()) {\n            long[] current = pq.poll();\n            long currentCost = current[0];\n            int currentIndex = (int) current[1];\n            \n            if (visited[currentIndex]) continue;\n            visited[currentIndex] = true;\n            \n            for (int nextIndex = 0; nextIndex < N; nextIndex++) {\n                if (!visited[nextIndex]) {\n                    long nextCost = currentCost + Math.abs(nextIndex - currentIndex) * D + A[currentIndex] + A[nextIndex];\n                    if (nextCost < minCost[nextIndex]) {\n                        minCost[nextIndex] = nextCost;\n                        pq.offer(new long[] { nextCost, nextIndex });\n                    }\n                }\n            }\n        }\n        \n        long totalCost = 0;\n        for (long cost : minCost) totalCost += cost;\n        return totalCost;\n    }\n}",
    "timestamp": "2025-08-13 13:07:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100000\n\ntypedef struct {\n    int cost;\n    int index;\n} City;\n\nint compareCities(const void* a, const void* b) {\n    return ((City*)a)->cost - ((City*)b)->cost;\n}\n\nlong long minCost(int N, int D, int A[]) {\n    City cities[MAX_N];\n    for (int i = 0; i < N; i++) {\n        cities[i].cost = A[i];\n        cities[i].index = i;\n    }\n    \n    qsort(cities, N, sizeof(City), compareCities);\n\n    long long totalCost = 0;\n    \n    for (int i = 0; i < N - 1; i++) {\n        totalCost += ((long long)D * abs(cities[i].index - cities[i + 1].index)) + cities[i].cost + cities[i + 1].cost;\n    }\n\n    return totalCost;\n}\n\nint main() {\n    int N, D;\n    int A[MAX_N];\n    \n    scanf(\"%d %d\", &N, &D);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n    \n    printf(\"%lld\\n\", minCost(N, D, A));\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 13:07:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nusing ll = long long;\n\nstruct Edge {\n    ll cost;\n    int u, v;\n    Edge(ll cost, int u, int v) : cost(cost), u(u), v(v) {}\n    bool operator<(const Edge& other) const {\n        return cost < other.cost;\n    }\n};\n\nstruct UnionFind {\n    vector<int> parent, rank;\n    UnionFind(int n) : parent(n), rank(n, 0) {\n        iota(parent.begin(), parent.end(), 0);\n    }\n    int find(int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    bool unite(int x, int y) {\n        int xr = find(x), yr = find(y);\n        if (xr == yr) return false;\n        if (rank[xr] < rank[yr])\n            parent[xr] = yr;\n        else if (rank[xr] > rank[yr])\n            parent[yr] = xr;\n        else {\n            parent[yr] = xr;\n            rank[xr]++;\n        }\n        return true;\n    }\n};\n\nint main() {\n    int N;\n    ll D;\n    cin >> N >> D;\n    vector<ll> A(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> A[i];\n    }\n\n    vector<Edge> edges;\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            ll cost = abs(i - j) * D + A[i] + A[j];\n            edges.emplace_back(cost, i, j);\n        }\n    }\n\n    sort(edges.begin(), edges.end());\n\n    UnionFind uf(N);\n    ll total_cost = 0;\n    for (const Edge& e : edges) {\n        if (uf.unite(e.u, e.v)) {\n            total_cost += e.cost;\n        }\n    }\n\n    cout << total_cost << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:07:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N, A, D):\n    # Initialize a disjoint set data structure\n    parent = list(range(N))\n    rank = [0] * N\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        px, py = find(x), find(y)\n        if px == py:\n            return False\n        if rank[px] < rank[py]:\n            px, py = py, px\n        parent[py] = px\n        if rank[px] == rank[py]:\n            rank[px] += 1\n        return True\n    \n    # Create a list of all possible roads with their costs\n    roads = []\n    for i in range(N):\n        for j in range(i+1, N):\n            cost = abs(i-j) * D + A[i] + A[j]\n            roads.append((cost, i, j))\n    \n    # Sort roads by cost\n    roads.sort()\n    \n    # Kruskal's algorithm to find minimum spanning tree\n    total_cost = 0\n    roads_used = 0\n    \n    for cost, u, v in roads:\n        if union(u, v):\n            total_cost += cost\n            roads_used += 1\n            \n            # Stop when N-1 roads are used (complete spanning tree)\n            if roads_used == N-1:\n                break\n    \n    return total_cost\n\n# Read input\nN, D = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Print result\nprint(solve(N, A, D))",
    "timestamp": "2025-08-13 13:08:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    D = int(data[idx])\n    idx += 1\n    A = list(map(int, data[idx:idx+N]))\n    \n    heap = []\n    for i in range(N):\n        heapq.heappush(heap, (A[i], i))\n    \n    parent = [i for i in range(N)]\n    \n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n    \n    def union(u, v):\n        root_u = find(u)\n        root_v = find(v)\n        if root_u != root_v:\n            parent[root_v] = root_u\n    \n    total_cost = 0\n    edges = []\n    \n    left = [ -1 for _ in range(N) ]\n    right = [ -1 for _ in range(N) ]\n    active = [ False for _ in range(N) ]\n    \n    while heap:\n        val, i = heapq.heappop(heap)\n        active[i] = True\n        if i > 0 and active[i-1]:\n            cost = D * (i - (i-1)) + A[i] + A[i-1]\n            edges.append((cost, i, i-1))\n        if i < N-1 and active[i+1]:\n            cost = D * ((i+1) - i) + A[i] + A[i+1]\n            edges.append((cost, i, i+1))\n    \n    edges.sort()\n    \n    for cost, u, v in edges:\n        if find(u) != find(v):\n            union(u, v)\n            total_cost += cost\n    \n    print(total_cost)\n\nsolve()",
    "timestamp": "2025-08-13 13:08:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minimumCostToConnectCities(N, A, D) {\n    const INF = Number.MAX_SAFE_INTEGER;\n    const costs = Array(N).fill(INF);\n    const visited = Array(N).fill(false);\n    \n    costs[0] = 0;\n    let totalCost = 0;\n    \n    for (let _ = 0; _ < N; _++) {\n        let minCost = INF;\n        let minIndex = -1;\n        \n        for (let i = 0; i < N; i++) {\n            if (!visited[i] && costs[i] < minCost) {\n                minCost = costs[i];\n                minIndex = i;\n            }\n        }\n        \n        visited[minIndex] = true;\n        totalCost += minCost;\n        \n        for (let j = 0; j < N; j++) {\n            if (!visited[j]) {\n                let cost = Math.abs(minIndex - j) * D + A[minIndex] + A[j];\n                costs[j] = Math.min(costs[j], cost);\n            }\n        }\n    }\n    \n    return totalCost;\n}",
    "timestamp": "2025-08-13 13:08:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, A, D) {\n    const parent = new Array(N).fill(0).map((_, i) => i);\n    const rank = new Array(N).fill(0);\n\n    function find(x) {\n        if (parent[x] !== x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    function union(x, y) {\n        let rootX = find(x);\n        let rootY = find(y);\n        if (rootX === rootY) return false;\n\n        if (rank[rootX] < rank[rootY]) {\n            [rootX, rootY] = [rootY, rootX];\n        }\n        parent[rootY] = rootX;\n        if (rank[rootX] === rank[rootY]) {\n            rank[rootX]++;\n        }\n        return true;\n    }\n\n    const edges = [];\n    for (let i = 0; i < N; i++) {\n        for (let j = i + 1; j < N; j++) {\n            const cost = Math.abs(i - j) * D + A[i] + A[j];\n            edges.push({from: i, to: j, cost: cost});\n        }\n    }\n\n    edges.sort((a, b) => a.cost - b.cost);\n\n    let totalCost = 0;\n    let connectedEdges = 0;\n\n    for (const edge of edges) {\n        if (union(edge.from, edge.to)) {\n            totalCost += edge.cost;\n            connectedEdges++;\n            if (connectedEdges === N - 1) break;\n        }\n    }\n\n    return totalCost;\n}",
    "timestamp": "2025-08-13 13:08:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const [N, D] = input[0].split(' ').map(Number);\n    const A = input[1].split(' ').map(Number);\n    \n    let minHeap = new MinHeap();\n    let totalCost = 0;\n    \n    minHeap.push({ cost: A[0], index: 0 });\n    \n    for (let i = 1; i < N; i++) {\n        while (minHeap.size() > 0 && minHeap.peek().index < i - 2 * N) {\n            minHeap.pop();\n        }\n        if (minHeap.size() === 0) break;\n        const best = minHeap.peek();\n        const cost = best.cost + A[i] + i * D;\n        totalCost += cost;\n        minHeap.push({ cost: best.cost - best.index * D, index: i });\n    }\n    \n    console.log(totalCost);\n}\n\nclass MinHeap {\n    constructor() {\n        this.heap = [];\n    }\n    \n    push(value) {\n        this.heap.push(value);\n        this.bubbleUp(this.heap.length - 1);\n    }\n    \n    pop() {\n        const min = this.heap[0];\n        const end = this.heap.pop();\n        if (this.heap.length > 0) {\n            this.heap[0] = end;\n            this.bubbleDown(0);\n        }\n        return min;\n    }\n    \n    peek() {\n        return this.heap[0];\n    }\n    \n    size() {\n        return this.heap.length;\n    }\n    \n    bubbleUp(index) {\n        const element = this.heap[index];\n        while (index > 0) {\n            const parentIndex = Math.floor((index - 1) / 2);\n            const parent = this.heap[parentIndex];\n            if (element.cost >= parent.cost) break;\n            this.heap[index] = parent;\n            index = parentIndex;\n        }\n        this.heap[index] = element;\n    }\n    \n    bubbleDown(index) {\n        const length = this.heap.length;\n        const element = this.heap[index];\n        while (true) {\n            const leftChildIndex = 2 * index + 1;\n            const rightChildIndex = 2 * index + 2;\n            let leftChild, rightChild;\n            let swap = null;\n            \n            if (leftChildIndex < length) {\n                leftChild = this.heap[leftChildIndex];\n                if (leftChild.cost < element.cost) {\n                    swap = leftChildIndex;\n                }\n            }\n            if (rightChildIndex < length) {\n                rightChild = this.heap[rightChildIndex];\n                if (\n                    (swap === null && rightChild.cost < element.cost) ||\n                    (swap !== null && rightChild.cost < leftChild.cost)\n                ) {\n                    swap = rightChildIndex;\n                }\n            }\n            if (swap === null) break;\n            this.heap[index] = this.heap[swap];\n            index = swap;\n        }\n        this.heap[index] = element;\n    }\n}\n\nsolve();",
    "timestamp": "2025-08-13 13:08:51"
  }
]