[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX_N 20\n\nint calculate_probability(int n, int a) {\n    int initial_state[MAX_N];\n    int perm[MAX_N];\n    int factorial[MAX_N + 1];\n    long long total_ways = 0, winning_ways = 0;\n\n    // Precompute factorials\n    factorial[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        factorial[i] = ((long long)factorial[i-1] * i) % MOD;\n    }\n\n    // Generate all permutations\n    for (int mask = 0; mask < (1 << n); mask++) {\n        // Reset initial state\n        for (int i = 0; i < n; i++) {\n            initial_state[i] = (i < a);\n            perm[i] = i;\n        }\n\n        // Apply button presses based on mask\n        for (int i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                if (initial_state[i]) {\n                    initial_state[perm[i]] = !initial_state[perm[i]];\n                }\n            }\n        }\n\n        // Check if all lamps are off\n        int all_off = 1;\n        for (int i = 0; i < n; i++) {\n            if (initial_state[i]) {\n                all_off = 0;\n                break;\n            }\n        }\n\n        if (all_off) {\n            winning_ways++;\n        }\n        total_ways++;\n    }\n\n    // Calculate winning probability multiplied by N!\n    return (winning_ways * factorial[n]) % MOD;\n}\n\nint main() {\n    int n, a;\n    scanf(\"%d %d\", &n, &a);\n    printf(\"%d\\n\", calculate_probability(n, a));\n    return 0;\n}",
    "timestamp": "2025-08-05 22:31:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAXN 5000\n\nint N, A;\nlong long fact[MAXN + 1];\nlong long inv_fact[MAXN + 1];\nlong long dp[MAXN + 1][MAXN + 1];\n\nlong long mod_pow(long long base, long long exp) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % MOD;\n        }\n        base = (base * base) % MOD;\n        exp /= 2;\n    }\n    return result;\n}\n\nvoid precompute_factorials() {\n    fact[0] = 1;\n    for (int i = 1; i <= N; i++) {\n        fact[i] = (fact[i - 1] * i) % MOD;\n    }\n    inv_fact[N] = mod_pow(fact[N], MOD - 2);\n    for (int i = N - 1; i >= 0; i--) {\n        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;\n    }\n}\n\nlong long comb(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return (fact[n] * inv_fact[k] % MOD) * inv_fact[n - k] % MOD;\n}\n\nlong long solve() {\n    precompute_factorials();\n    memset(dp, 0, sizeof(dp));\n    dp[A][N - A] = 1;\n\n    for (int on = A; on >= 0; on--) {\n        for (int off = N - A; off >= 0; off--) {\n            if (on == 0 && off == 0) continue;\n            if (dp[on][off] == 0) continue;\n            long long total = on + off;\n            long long inv_total = mod_pow(total, MOD - 2);\n            if (on > 0) {\n                long long prob = (on * inv_total) % MOD;\n                dp[on - 1][off] = (dp[on - 1][off] + dp[on][off] * prob) % MOD;\n            }\n            if (off > 0) {\n                long long prob = (off * inv_total) % MOD;\n                dp[on + 1][off - 1] = (dp[on + 1][off - 1] + dp[on][off] * prob) % MOD;\n            }\n        }\n    }\n\n    long long result = dp[0][0];\n    result = (result * fact[N]) % MOD;\n    return result;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &A);\n    printf(\"%lld\\n\", solve());\n    return 0;\n}",
    "timestamp": "2025-08-05 22:31:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nvector<int> factorial;\nvector<int> inv_fact;\n\nint mod_pow(int a, int b) {\n    int res = 1;\n    while (b > 0) {\n        if (b & 1) res = (1LL * res * a) % MOD;\n        a = (1LL * a * a) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid precompute_factorials(int n) {\n    factorial.resize(n + 1);\n    inv_fact.resize(n + 1);\n    factorial[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        factorial[i] = (1LL * factorial[i - 1] * i) % MOD;\n    }\n    inv_fact[n] = mod_pow(factorial[n], MOD - 2);\n    for (int i = n - 1; i >= 0; --i) {\n        inv_fact[i] = (1LL * inv_fact[i + 1] * (i + 1)) % MOD;\n    }\n}\n\nint comb(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return (1LL * factorial[n] * inv_fact[k] % MOD) * inv_fact[n - k] % MOD;\n}\n\nint solve(int N, int A) {\n    precompute_factorials(N);\n    vector<int> dp(N + 1, 0);\n    dp[A] = 1;\n    for (int i = A; i < N; ++i) {\n        if (dp[i] == 0) continue;\n        int ways = (1LL * dp[i] * (N - i)) % MOD;\n        ways = (1LL * ways * (N - i - 1)) % MOD;\n        dp[i + 1] = (dp[i + 1] + ways) % MOD;\n    }\n    int total = 0;\n    for (int i = A; i <= N; ++i) {\n        total = (total + dp[i]) % MOD;\n    }\n    total = (1LL * total * factorial[N - A]) % MOD;\n    total = (1LL * total * factorial[A]) % MOD;\n    return total;\n}",
    "timestamp": "2025-08-05 22:31:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    private static final int MOD = 1_000_000_007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int A = scanner.nextInt();\n        System.out.println(solve(N, A));\n    }\n\n    private static int solve(int N, int A) {\n        if (N == 1) {\n            return 1;\n        }\n        if (A == 0) {\n            return 0;\n        }\n        if (A == N) {\n            return factorial(N);\n        }\n\n        long[] fact = new long[N + 1];\n        fact[0] = 1;\n        for (int i = 1; i <= N; i++) {\n            fact[i] = (fact[i - 1] * i) % MOD;\n        }\n\n        long[] invFact = new long[N + 1];\n        invFact[N] = modInverse(fact[N], MOD);\n        for (int i = N - 1; i >= 0; i--) {\n            invFact[i] = (invFact[i + 1] * (i + 1)) % MOD;\n        }\n\n        long res = 0;\n        for (int k = 1; k <= A; k++) {\n            long term = (fact[A] * invFact[k] % MOD) * invFact[A - k] % MOD;\n            term = term * fact[N - k] % MOD;\n            term = term * fact[k] % MOD;\n            res = (res + term) % MOD;\n        }\n\n        return (int) res;\n    }\n\n    private static long modInverse(long a, int mod) {\n        return power(a, mod - 2, mod);\n    }\n\n    private static long power(long a, long b, int mod) {\n        long res = 1;\n        a = a % mod;\n        while (b > 0) {\n            if ((b & 1) == 1) {\n                res = (res * a) % mod;\n            }\n            a = (a * a) % mod;\n            b >>= 1;\n        }\n        return res;\n    }\n\n    private static int factorial(int n) {\n        long res = 1;\n        for (int i = 2; i <= n; i++) {\n            res = (res * i) % MOD;\n        }\n        return (int) res;\n    }\n}",
    "timestamp": "2025-08-05 22:32:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "class Solution {\n    private static final int MOD = 1_000_000_007;\n\n    public int solve(int N, int A) {\n        long[][] dp = new long[N + 1][N + 1];\n        dp[0][0] = 1;\n\n        for (int i = 1; i <= N; i++) {\n            for (int j = 0; j <= i; j++) {\n                if (j > 0) {\n                    dp[i][j] += dp[i - 1][j - 1] * j;\n                }\n                if (j < i) {\n                    dp[i][j] += dp[i - 1][j] * (i - j);\n                }\n                dp[i][j] %= MOD;\n            }\n        }\n\n        long factorial = 1;\n        for (int i = 1; i <= N; i++) {\n            factorial = (factorial * i) % MOD;\n        }\n\n        long result = (dp[N][A] * factorial) % MOD;\n        return (int) result;\n    }\n}",
    "timestamp": "2025-08-05 22:32:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nclass Solution {\npublic:\n    int winningProbability(int N, int A) {\n        vector<int> perm(N);\n        for (int i = 0; i < N; i++) {\n            perm[i] = i;\n        }\n        \n        long long winningCount = 0;\n        long long totalCount = 0;\n        \n        do {\n            vector<bool> lamp(N, false);\n            for (int i = 0; i < A; i++) {\n                lamp[perm[i]] = true;\n            }\n            \n            bool possible = true;\n            for (int i = 0; i < N; i++) {\n                if (lamp[i]) {\n                    bool found = false;\n                    for (int j = 0; j < N; j++) {\n                        if (i != j && !lamp[j] && perm[j] == i) {\n                            lamp[j] = true;\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        possible = false;\n                        break;\n                    }\n                }\n            }\n            \n            if (possible && all_of(lamp.begin(), lamp.end(), [](bool v) { return v; })) {\n                winningCount++;\n            }\n            totalCount++;\n        } while (next_permutation(perm.begin(), perm.end()));\n        \n        long long factorial = 1;\n        for (int i = 1; i <= N; i++) {\n            factorial = (factorial * i) % MOD;\n        }\n        \n        long long result = (winningCount * factorial) % MOD;\n        return result;\n    }\n};",
    "timestamp": "2025-08-05 22:32:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def factorial_mod(n, mod):\n    result = 1\n    for i in range(2, n + 1):\n        result = result * i % mod\n    return result\n\ndef winning_probability(n, a, mod=10**9 + 7):\n    if a == 0:\n        return 0\n    if a == n:\n        return factorial_mod(n, mod)\n    \n    win_prob_numerator = factorial_mod(n - 1, mod)\n    win_prob_denominator = factorial_mod(n, mod)\n    \n    probability_numerator = win_prob_numerator * a % mod\n    probability_denominator = win_prob_denominator * n % mod\n    \n    probability = probability_numerator * pow(probability_denominator, mod - 2, mod) % mod\n    \n    result = probability * factorial_mod(n, mod) % mod\n    return result\n\n# Example Usage:\nN = 5\nA = 3\nprint(winning_probability(N, A))",
    "timestamp": "2025-08-13 11:08:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class LampGame {\n    private static final int MOD = 1000000007;\n\n    public static long factorialMod(int n, int mod) {\n        long result = 1;\n        for (int i = 2; i <= n; i++) {\n            result = result * i % mod;\n        }\n        return result;\n    }\n\n    public static long powerMod(long base, long exp, int mod) {\n        long result = 1;\n        while (exp > 0) {\n            if ((exp & 1) == 1) {\n                result = result * base % mod;\n            }\n            base = base * base % mod;\n            exp >>= 1;\n        }\n        return result;\n    }\n\n    public static long inverseMod(long a, int mod) {\n        return powerMod(a, mod - 2, mod);\n    }\n\n    public static long winningProbability(int n, int a) {\n        if (a == n) return factorialMod(n, MOD);\n        if (a == 0) return 0;\n\n        long totalWays = factorialMod(n, MOD);\n        long successfulWays = totalWays * inverseMod(powerMod(2, n - a, MOD), MOD) % MOD;\n        return successfulWays;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n, a;\n        n = scanner.nextInt();\n        a = scanner.nextInt();\n        System.out.println(winningProbability(n, a));\n    }\n}",
    "timestamp": "2025-08-13 11:08:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 1000000007\n\ntypedef long long ll;\n\n// Helper function to calculate factorial modulo MOD\nll factorial(int n) {\n    ll result = 1;\n    for (int i = 2; i <= n; i++) {\n        result = (result * i) % MOD;\n    }\n    return result;\n}\n\n// Helper function to calculate modular exponentiation\nll mod_exp(ll base, ll exp, ll mod) {\n    ll result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\n// Function to calculate winning probability multiplied by N!\nll calculate_probability(int N, int A) {\n    if (A == N) {\n        return factorial(N) % MOD;\n    }\n\n    ll win_prob = factorial(N - A);\n    win_prob = mod_exp(win_prob, MOD - 2, MOD); // To get the modular inverse\n\n    win_prob = (win_prob * factorial(N - A)) % MOD;\n    win_prob = (win_prob * factorial(N)) % MOD;\n\n    return win_prob;\n}\n\nint main() {\n    int N, A;\n    scanf(\"%d %d\", &N, &A);\n\n    ll result = calculate_probability(N, A);\n    printf(\"%lld\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:08:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 1000000007;\n\nfunction factorial(n) {\n    let result = 1;\n    for (let i = 2; i <= n; i++) {\n        result = result * i % MOD;\n    }\n    return result;\n}\n\nfunction binPow(base, exp, mod) {\n    let result = 1;\n    while (exp > 0) {\n        if (exp % 2 === 1) {\n            result = result * base % mod;\n        }\n        base = base * base % mod;\n        exp = Math.floor(exp / 2);\n    }\n    return result;\n}\n\nfunction winningProbability(N, A) {\n    if (A === N) {\n        return factorial(N);\n    }\n    let totalProb = factorial(N);\n    totalProb = totalProb * binPow(2, MOD - 2, MOD) % MOD;\n    return totalProb * factorial(N - A) % MOD;\n}\n\n// Example Usage:\n// console.log(winningProbability(N, A));",
    "timestamp": "2025-08-13 11:08:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N, A):\n    MOD = 10**9 + 7\n    \n    def factorial(n):\n        result = 1\n        for i in range(1, n + 1):\n            result = (result * i) % MOD\n        return result\n    \n    def count_ways(perm):\n        used = [False] * N\n        total_cycles = 0\n        \n        for i in range(N):\n            if not used[i]:\n                total_cycles += 1\n                curr = i\n                while not used[curr]:\n                    used[curr] = True\n                    curr = perm[curr]\n        \n        return total_cycles\n    \n    total_ways = 0\n    valid_ways = 0\n    \n    import itertools\n    \n    for perm in itertools.permutations(range(N)):\n        total_ways += 1\n        \n        on_lamps = [i for i in range(A)]\n        can_win = False\n        \n        for lamp in on_lamps:\n            remaining_lamps = [l for l in range(N) if l not in on_lamps]\n            \n            if perm[lamp] in remaining_lamps:\n                can_win = True\n                break\n        \n        if can_win:\n            valid_ways += 1\n    \n    return (valid_ways * factorial(N)) % MOD",
    "timestamp": "2025-08-13 11:08:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, A) {\n    const MOD = 1000000007;\n    \n    function factorial(n) {\n        let result = 1n;\n        for (let i = 2; i <= n; i++) {\n            result *= BigInt(i);\n        }\n        return result;\n    }\n    \n    function calculateWinProbability(N, A) {\n        let winningStates = 0;\n        let totalStates = 0;\n        \n        // Generate all permutations\n        const permutations = [];\n        const used = new Array(N).fill(false);\n        \n        function generatePermutations(current) {\n            if (current.length === N) {\n                permutations.push([...current]);\n                return;\n            }\n            \n            for (let i = 0; i < N; i++) {\n                if (!used[i]) {\n                    used[i] = true;\n                    current.push(i);\n                    generatePermutations(current);\n                    current.pop();\n                    used[i] = false;\n                }\n            }\n        }\n        \n        generatePermutations([]);\n        \n        // Check each permutation\n        for (const perm of permutations) {\n            const lamps = new Array(N).fill(false);\n            for (let i = 0; i < A; i++) {\n                lamps[i] = true;\n            }\n            \n            let movesLeft = N;\n            let canWin = true;\n            \n            while (movesLeft > 0) {\n                let moveFound = false;\n                \n                for (let i = 0; i < N; i++) {\n                    if (lamps[i]) {\n                        const targetLamp = perm[i];\n                        if (!lamps[targetLamp]) {\n                            lamps[i] = false;\n                            lamps[targetLamp] = true;\n                            moveFound = true;\n                            break;\n                        }\n                    }\n                }\n                \n                if (!moveFound) {\n                    canWin = false;\n                    break;\n                }\n                \n                movesLeft--;\n            }\n            \n            totalStates++;\n            if (canWin && lamps.every(lamp => lamp)) {\n                winningStates++;\n            }\n        }\n        \n        return winningStates;\n    }\n    \n    const winningStates = calculateWinProbability(N, A);\n    const totalStates = factorial(N);\n    \n    return Number((BigInt(winningStates) * totalStates) % BigInt(MOD));\n}",
    "timestamp": "2025-08-13 11:09:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 10**9 + 7\n\ndef solve():\n    N, A = map(int, sys.stdin.readline().split())\n    P = list(map(int, sys.stdin.readline().split()))\n    \n    fact = [1] * (N + 1)\n    for i in range(1, N + 1):\n        fact[i] = fact[i-1] * i % MOD\n    \n    inv_fact = [1] * (N + 1)\n    inv_fact[N] = pow(fact[N], MOD-2, MOD)\n    for i in range(N-1, -1, -1):\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n    \n    def comb(n, k):\n        if k < 0 or k > n:\n            return 0\n        return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD\n    \n    res = 0\n    for k in range(1, N - A + 1):\n        term = comb(N - A, k) * fact[A + k - 1] % MOD\n        term = term * fact[N - A - k] % MOD\n        res = (res + term) % MOD\n    \n    total = fact[N] * inv_fact[A] % MOD * inv_fact[N - A] % MOD * fact[A] % MOD * fact[N - A] % MOD\n    inv_total = pow(total, MOD-2, MOD)\n    ans = res * inv_total % MOD\n    ans = ans * fact[N] % MOD\n    print(ans)\n\nsolve()",
    "timestamp": "2025-08-13 11:09:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 1e9 + 7;\n\nfunction solve(N, A) {\n    if (A === N) return 1;\n    if (A === 0) return 0;\n    \n    let fact = new Array(N + 1).fill(1);\n    for (let i = 1; i <= N; i++) {\n        fact[i] = (fact[i - 1] * i) % MOD;\n    }\n    \n    let invFact = new Array(N + 1).fill(1);\n    invFact[N] = powMod(fact[N], MOD - 2, MOD);\n    for (let i = N - 1; i >= 0; i--) {\n        invFact[i] = (invFact[i + 1] * (i + 1)) % MOD;\n    }\n    \n    function comb(n, k) {\n        if (k < 0 || k > n) return 0;\n        return (fact[n] * invFact[k] % MOD) * invFact[n - k] % MOD;\n    }\n    \n    let dp = new Array(N + 1).fill(0);\n    dp[A] = 1;\n    \n    for (let i = A; i < N; i++) {\n        let ways = (N - i) * (N - i) % MOD;\n        let denom = (i * (N - i) % MOD + (N - i) * (N - i) % MOD) % MOD;\n        denom = powMod(denom, MOD - 2, MOD);\n        let prob = ways * denom % MOD;\n        dp[i + 1] = dp[i] * prob % MOD;\n    }\n    \n    return (dp[N] * fact[N]) % MOD;\n}\n\nfunction powMod(a, b, mod) {\n    let res = 1;\n    a = a % mod;\n    while (b > 0) {\n        if (b % 2 === 1) {\n            res = (res * a) % mod;\n        }\n        a = (a * a) % mod;\n        b = Math.floor(b / 2);\n    }\n    return res;\n}",
    "timestamp": "2025-08-13 11:09:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint factorial(int n) {\n    long long result = 1;\n    for (int i = 2; i <= n; ++i) {\n        result = result * i % MOD;\n    }\n    return result;\n}\n\nint main() {\n    int N, A;\n    cin >> N >> A;\n\n    // Calculate factorial of N.\n    int factN = factorial(N);\n    \n    // The probability is optimized to winning case if A lamps are initially on.\n    int winningProbability = (A >= N ? 1 : 0);\n\n    // Calculate the winning probability multiplied by N! modulo (10^9 + 7)\n    int result = (long long)winningProbability * factN % MOD;\n    \n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 12:02:32"
  }
]