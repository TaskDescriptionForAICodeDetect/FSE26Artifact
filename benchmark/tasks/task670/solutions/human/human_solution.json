[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  ll n,a,dp[6100][5100][3]={},ans=0,co[5100]={};\n  cin >> n >> a;\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[i][0][2]*KAI(i)%MOD*KAI(n-a)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,A;\nconst ll mo=1000000007;\n\nconst int NUM_=10400001;\nstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>A;\n\tinv[1]=fact[0]=factr[0]=1;\n\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t\n\tll ret=0;\n\tfor(i=1;i<=A;i++) {\n\t\tint a,b,c;\n\t\ta=i;\n\t\tif(i==A) {\n\t\t\tb=N-i;\n\t\t\tc=0;\n\t\t}\n\t\telse {\n\t\t\tb=N-A;\n\t\t\tc=A-i-1;\n\t\t}\n\t\t\n\t\tll sum=0;\n\t\tfor(j=i-1;j>=0;j--) {\n\t\t\tll pat=fact[a-j]*fact[(a-j)+b-1]%mo*factr[(a-j)-1]%mo;\n\t\t\t(pat*=fact[a]*factr[j]%mo*factr[a-j]%mo*fact[(a-j)+b+c]%mo*factr[(a-j)+b]%mo)%=mo;\n\t\t\tif(j&1) ret-=pat;\n\t\t\telse ret+=pat;\n\t\t}\n\t}\n\tcout<<(ret%mo+mo)%mo<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=10000005,M=1e9+7;\nint fac[N],inv[N],f[5005][5005],n,m;\ninline int ksm(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=x*x%M)\n\t\tif (y&1)(ans*=x)%=M;\n\treturn ans; \n}\ninline int P(int x,int y){\n\tif (x>y)return 1;\n\tif (!x)return 0;\n\treturn fac[y]*inv[x-1]%M;\n}\ninline int C(int x,int y){\n\tif (x<0)return 1;\n\tif (x<y)return 0;\n\treturn fac[x]*inv[y]%M*inv[x-y]%M;\n}\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfac[0]=1;\n\tfor (int i=1;i<N;i++)fac[i]=fac[i-1]*i%M;\n\tinv[N-1]=ksm(fac[N-1],M-2);\n\tfor (int i=N-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%M;\n\tn-=m;int ans=0;\n\tfor (int i=1;i<=m+1;i++)\n\t\tfor (int j=0;j<=m;j++)f[i][j]=((!j?0:f[i][j-1])+inv[j]*fac[i-2+n+j])%M;\n\tfor (int i=1;i<=m+1;i++)\n\t\tfor (int j=0;j<i;j++){\n\t\t\tint s=f[i-j][max(0ll,m-i)];\n\t\t\tif (j&1)(ans+=M-C(i-1,j)*(i-j-1)%M*(i>m?1:fac[m-i])%M*s%M)%=M;\n\t\t\telse (ans+=C(i-1,j)*(i-j-1)%M*(i>m?1:fac[m-i])%M*s)%=M;\n\t\t}\n\tprintf(\"%lld\\n\",ans);\n} "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=1e7+5,mod=1e9+7;\nint n,m,fact[N],inv[N],ans;\ninline void inc(int& x,CI y)\n{\n\tif ((x+=y)>=mod) x-=mod;\n}\ninline void dec(int& x,CI y)\n{\n\tif ((x-=y)<0) x+=mod;\n}\ninline int quick_pow(int x,int p=mod-2,int mul=1)\n{\n\tfor (;p;p>>=1,x=1LL*x*x%mod) if (p&1) mul=1LL*mul*x%mod; return mul;\n}\ninline void init(CI n)\n{\n\tRI i; for (fact[0]=i=1;i<=n;++i) fact[i]=1LL*fact[i-1]*i%mod;\n\tfor (inv[n]=quick_pow(fact[n]),i=n-1;~i;--i) inv[i]=1LL*inv[i+1]*(i+1)%mod;\n}\ninline int C(CI n,CI m)\n{\n\treturn 1LL*fact[n]*inv[m]%mod*inv[n-m]%mod;\n}\ninline int calc(CI a,CI b,CI c)\n{\n\treturn 1LL*fact[a+b+c]*a%mod*quick_pow(a+b)%mod;\n}\nint main()\n{\n\tRI i,j; for (scanf(\"%d%d\",&n,&m),init(n),i=1;i<=m+1;++i)\n\tfor (j=0;j<i;++j) if (j&1) dec(ans,1LL*calc(i-1-j,n-m,max(m-i,0))*C(i-1,j)%mod);\n\telse inc(ans,1LL*calc(i-1-j,n-m,max(m-i,0))*C(i-1,j)%mod);\n\treturn printf(\"%d\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<set>\n#include<vector>\n#include<string>\nusing namespace std;\nconst int mod=1000000007;\nint add(int a, int b)\n{\n\tint c=a+b;\n\tif(c>=mod)c-=mod;\n\treturn c;\n}\nint dif(int a, int b)\n{\n\tint c=a-b;\n\tif(c<0)c+=mod;\n\treturn c;\n}\nint mlt(int a, int b)\n{\n\tlong long c=a*1LL*b;\n\treturn c%mod;\n}\nint bp(int a, int b)\n{\n\tif(b==0)return 1;\n\tif(b%2==0)\n\t{\n\t\tint val=bp(a, b/2);\n\t\treturn mlt(val, val);\n\t}\n\tif(b%2==1)\n\t{\n\t\tint val=bp(a, b-1);\n\t\treturn mlt(val, a);\n\t}\n}\nint inv(int a)\n{\n\treturn bp(a, mod-2);\n}\nvoid outp(vector<vector<int>>&v)\n{\n\tfor(int i=0; i<v.size(); i++)\n\t{\n\t\tfor(int j=0; j<v[i].size(); j++)cout<<v[i][j]<<' ';\n\t\tcout<<endl;\n\t}\n\tcout<<endl;\n}\nint maxn=1e7+7;\nvector<int>fact(maxn), ofact(maxn);\nint C(int a, int b)\n{\n\tif(b<0)return 0;\n\tif(a<0)return 0;\n\tif(a>b)return 0;\n\tint val=fact[b];\n\tval=mlt(val, ofact[a]);\n\tval=mlt(val, ofact[b-a]);\n\treturn val;\n}\nint main()\n{\n\tfact[0]=1;\n\tofact[0]=1;\n\tfor(int i=1; i<maxn; i++)\n\t{\n\t\tfact[i]=mlt(fact[i-1], i);\n\t}\n\tofact[maxn-1]=inv(fact[maxn-1]);\n\tfor(int j=maxn-2; j>=1; j--)\n\t{\n\t\tofact[j]=mlt(ofact[j+1], j+1);\n\t}\n\tint n, a;\n\tcin>>n>>a;\n\tint all=0;\n\tint d=n-a;\n\tvector<int>fat(a+2), us(a+2);\n\tus[0]=1;\n\tint ans=fact[a];\n\tfor(int i=a-1; i>=1; i--)\n\t{\n\t\tvector<int>newfat(a+2), newus(a+2);\n\t\tfor(int j=0; j<=a; j++)\n\t\t{\n\t\t\tnewfat[j]= mlt(i,us[j]);\n\t\t\tnewus[j+1]=us[j];\n\t\t}\n\t\tfor(int j=0; j<=a; j++)\n\t\t{\n\t\t\tnewfat[j]= add(newfat[j],mlt(i,fat[j]));\n\t\t\tnewus[j]=add(newus[j], fat[j]);\n\t\t}\n\t\tfat=newfat;\n\t\tus=newus;\n\t\tfor(int j=0; j<=a; j++)\n\t\t{\n\t\t\tint val=add(fat[j], us[j]);\n\t\t\tval=mlt(val, C(a-i, a-i+d-1-j));\n\t\t\tval=mlt(val, fact[i]);\n\t\t\tans=add(ans, val);\n\t\t}\n\t}\n\tcout<<mlt(ans, fact[d])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  ll n,a,dp[5100][5100][3]={},ans=0,co[5100]={};\n  cin >> n >> a;\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  printf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nint cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \nint fstTrue(function<bool(int)> f, int lo, int hi) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tint mid = (lo+hi)/2; \n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(bool b) { return b ? \"true\" : \"false\"; }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) { \n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\tbool fst = 1; str res = \"{\";\n\tfor (const auto& x: v) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(x);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n#define dbg(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(string s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\n/**\n * Description: modular arithmetic operations \n * Source: \n\t* KACTL\n\t* https://codeforces.com/blog/entry/63903\n\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)\n\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)\n * Verification: \n\t* https://open.kattis.com/problems/modulararithmetic\n */\n\nstruct mi {\n\ttypedef decay<decltype(MOD)>::type T; \n \t/// don't silently convert to T\n\tT v; explicit operator T() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\tfriend str ts(mi a) { return ts(a.v); }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = (ll)v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\n/**\n * Description: pre-compute factorial mod inverses,\n \t* assumes $MOD$ is prime and $SZ < MOD$.\n * Time: O(SZ)\n * Source: KACTL\n * Verification: https://dmoj.ca/problem/tle17c4p5\n */\n\nvi invs, fac, ifac;\nvoid genFac(int SZ) {\n\tinvs.rsz(SZ), fac.rsz(SZ), ifac.rsz(SZ); \n\tinvs[1] = fac[0] = ifac[0] = 1; \n\tFOR(i,2,SZ) invs[i] = MOD-(ll)MOD/i*invs[MOD%i]%MOD;\n\tFOR(i,1,SZ) {\n\t\tfac[i] = (ll)fac[i-1]*i%MOD;\n\t\tifac[i] = (ll)ifac[i-1]*invs[i]%MOD;\n\t}\n}\n\nmi comb(int a, int b) {\n\tif (a < b || b < 0) return 0;\n\treturn (ll)fac[a]*ifac[b]%MOD*ifac[a-b]%MOD;\n}\n\n\nint N,A;\nmi dp[5001][5001],need[5001];\n\nmi range(int l, int r) {\n\tmi res = 1; FOR(i,l,r+1) res *= i;\n\treturn res;\n}\n\nint extra;\nmi getCycs(int num, int sing) {\n\t//if (!num) return 0;\n\tint lef = N-A-sing; if (lef < 0) return 0;\n\tmi tmp = mi(fac[N-A])*ifac[lef];\n\ttmp *= mi(fac[num+lef-1])*ifac[num-1];\n\treturn tmp;\n\t//return tmp;\n\t// num .. num+lef-1\n\tassert(sing <= num);\n\tmi res = 0;\n\tF0R(i,sing+1) { // (A+1)*...*N\n\t\t// - comb(i,1)*A*...*N-1\n\t\t// + comb(i,2)*(A-1)*...*(N-2)\n\t\tmi tmp = range(num-i,num+extra-1-i)*comb(sing,i);\n\t\tif (i&1) tmp *= -1;\n\t\tres += tmp;\n\t}\n\tdbg(\"HUH\",num,sing,res);\n\tdbg(\"OOPS\",tmp,res);\n\treturn res;\n}\n\nbool ok(vi perm) {\n\tvector<bool> vis(N);\n\tbool single = 0;\n\tF0R(i,N) if (!vis[i]) {\n\t\tif (i >= A) return 0; // not in a good cycle ...\n\t\tif (perm[i] == i) single = 1;\n\t\telse if (single) return 0;\n\t\tint t = i;\n\t\twhile (!vis[t]) {\n\t\t\tvis[t] = 1;\n\t\t\tt = perm[t];\n\t\t}\n\t}\n\treturn 1;\n}\n\nmi cum[5005];\nint main() {\n\tgenFac((int)1e7+5);\n\tsetIO(); re(N,A); extra = N-A;\n\t// vi perm; F0R(i,N) perm.pb(i);\n\t// int res = 0;\n\t// do {\n\t// \tif (!ok(perm)) dbg(\"BAD\",perm);\n\t// \tres += ok(perm);\n\t// } while (next_permutation(all(perm)));\n\t// ps(res);\n\t//exit(0);\n\t//dbg(\"HUH\");\n\tF0R(i,A+1) {\n\t\tF0R(j,A+1-i) { // i = # left\n\t\t\tdp[i][j] = getCycs(A-i,j)*fac[max(i-1,0)]; // A-i = # so far, j = # singles so far\n\t\t\tif (i) dp[i][j] += dp[i-1][j+1];\n\t\t\tif (i >= 2) cum[j] += ifac[i-2]*dp[i-2][j];\n\t\t\tdp[i][j] += fac[i-1]*cum[j];\n\t\t\t// FOR(cyc,2,i+1) dp[i][j] += ifac[i-cyc]*dp[i-cyc][j]*fac[i-1];\n\t\t}\n\t}\n\tps(dp[A][0]);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for (int i = (a); i <= int(b); i++)\n#define per(i, a, b) for (int i = (a); i >= int(b); i--)\nusing namespace std;\n\nconst int maxn = 1e7, mod = 1e9 + 7;\nint n, A, fact[maxn + 5], finv[maxn + 5];\n\nint qpow(int a, int b) {\n\tint c = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % mod) if (b & 1) c = 1ll * a * c % mod;\n\treturn c;\n}\n\ninline void mod_add(int &x, int y) { x += y, x < mod ? 0 : x -= mod; }\n\nvoid prework(int n) {\n\tfact[0] = 1;\n\trep(i, 1, n) fact[i] = 1ll * fact[i - 1] * i % mod;\n\tfinv[n] = qpow(fact[n], mod - 2);\n\tper(i, n, 1) finv[i - 1] = 1ll * finv[i] * i % mod;\n}\n\nint binom(int n, int m) {\n\treturn 1ll * fact[n] * finv[m] % mod * finv[n - m] % mod;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &A);\n\tprework(n);\n\tint ans = 0;\n\trep(i, 2, A + 1) {\n\t\tint a = i - 1, b = n - A, c = max(0, A - i), res = 0;\n\t\trep(j, 0, a) {\n\t\t\tint x = 1ll * binom(a, j) * j % mod * qpow(j + b, mod - 2) % mod * fact[j + b + c] % mod;\n\t\t\tif ((a - j) & 1) mod_add(res, mod - x);\n\t\t\telse mod_add(res, x);\n\t\t}\n\t\tmod_add(ans, res);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define endl '\\n'\n#define ll long long\n#define pi pair<int, int>\n#define f first\n#define s second\n\nconst int mod = 1000000007;\nconst int mxn = 10000001;\nint n, m;\nll iv[mxn], f[mxn], rf[mxn];\n\nvoid init(){\n\tiv[1] = f[0] = f[1] = rf[0] = rf[1] = 1;\n\tfor(int i = 2; i < mxn; i++){\n\t\tiv[i] = mod - mod / i * iv[mod % i] % mod;\n\t\tf[i] = i * f[i - 1] % mod;\n\t\trf[i] = iv[i] * rf[i - 1] % mod;\n\t}\n}\n\nll C(int x, int y){\n\treturn f[x] * rf[y] % mod * rf[x - y] % mod;\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tinit();\n\t\n\tcin >> n >> m;\n\t\n\tll ret = 0;\n\tfor(int i = 1; i <= m; i++)\n\tfor(int j = 0; j <= i; j++){\n\t\t(ret += (j & 1 ? mod - 1 : 1) * C(i, j) % mod * (i - j) % mod *\n\t\t\tiv[i - j + n - m] % mod * f[n - j - (i < m)]) %= mod;\n\t}\n\n\tcout << ret << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=5007;\nconst int vax=10*1007*1007;\nconst ll mod=1000*1000*1000+7;\n\nint n, k;\n\nll dp[nax][nax];\n\nll sil[vax];\nll odw[vax];\n\nll wyn;\n\nvoid dod(ll &a, ll b)\n{\n\tif ((a+=b)>=mod)\n\t\ta-=mod;\n}\n \nvoid sdod(ll &a, ll b)\n{\n\ta=(a+b)%mod;\n}\n\nll dziel(ll a, ll b)\n{\n\tll wyk=mod-2;\n\twhile(wyk)\n\t{\n\t\tif (wyk&1)\n\t\t\ta=(a*b)%mod;\n\t\tb=(b*b)%mod;\n\t\twyk>>=1;\n\t}\n\treturn a;\n}\n\nll kom(int a, int b)\n{\n\tif (b<0 || b>a)\n\t\treturn 0;\n\treturn (sil[a]*(odw[b]*odw[a-b]%mod))%mod;\n}\n\nll spo[nax][nax];\n\nvoid ogar(int moge, int musze, ll mno)\n{\n\tif (!mno || !moge)\n\t\treturn;\n\tint jest=n-k;\n\tif (jest<musze)\n\t\treturn;\n\twyn=(wyn+mno*spo[moge][musze])%mod;\n\t//~ debug() << imie(moge) << imie(musze) << imie(mno);\n}\n\nll pchaj[nax][nax];\n\nint main()\n{\n\tsil[0]=1;\n\tfor (int i=1; i<vax; i++)\n\t\tsil[i]=(sil[i-1]*i)%mod;\n\todw[vax-1]=dziel(1, sil[vax-1]);\n\tfor (int i=vax-2; i>=0; i--)\n\t\todw[i]=(odw[i+1]*(i+1))%mod;\n\tscanf(\"%d%d\", &n, &k);\n\tint poza=n-k;\n\tfor (int j=0; j<=k; j++)\n\t{\n\t\tfor (int i=max(1, j); i<=k; i++)\n\t\t{\n\t\t\tif (!j)\n\t\t\t{\n\t\t\t\tspo[i][j]=(sil[i+poza-1]*odw[i-1])%mod;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspo[i][j]=(spo[i][j-1]-spo[i-1][j-1]+mod)%mod;\n\t\t}\n\t}\n\tdp[k][0]=1;\n\tfor (int i=k; i>=0; i--)\n\t{\n\t\tfor (int j=0; j<=k; j++)\n\t\t{\n\t\t\tsdod(dp[i][j], pchaj[i][j]*odw[i]);\n\t\t\tsdod(pchaj[i-1][j], pchaj[i][j]);\n\t\t\tif (!dp[i][j] || !i)\n\t\t\t\tcontinue;\n\t\t\tsdod(dp[i-1][j+1], dp[i][j]);\n\t\t\t//~ for (int l=2; l<=i; l++)\n\t\t\t\t//~ sdod(dp[i-l][j], dp[i][j]*sil[i-1]%mod*odw[i-l]%mod);\n\t\t\t\n\t\t\tif (i>=2)\n\t\t\t\tsdod(pchaj[i-2][j], dp[i][j]*sil[i-1]);\n\t\t\t\n\t\t\togar(k-i, j, dp[i][j]*sil[i-1]%mod);\n\t\t}\n\t}\n\t//~ for (int i=k; i>=0; i--)\n\t//~ {\n\t\t//~ for (int j=0; j<=k; j++)\n\t\t//~ {\n\t\t\t//~ if (!dp[i][j])\n\t\t\t\t//~ continue;\n\t\t\t//~ debug() << i << \" \" << j << \"  \" << dp[i][j];\n\t\t//~ }\n\t//~ }\n\tfor (int i=0; i<=k; i++)\n\t\togar(k, i, dp[0][i]);\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,A;\nconst ll mo=1000000007;\n\nconst int NUM_=10400001;\nstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\n\nll pat[5050][5050];\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>A;\n\tinv[1]=fact[0]=factr[0]=1;\n\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t\n\tll ret=0;\n\tfor(i=1;i<=A;i++) {\n\t\tint a,b,c;\n\t\tif(i==A) {\n\t\t\ta=i;\n\t\t\tb=N-i;\n\t\t\tc=0;\n\t\t}\n\t\telse {\n\t\t\ta=i;\n\t\t\tb=N-A;\n\t\t\tc=A-i-1;\n\t\t}\n\t\t\n\t\tll sum=0;\n\t\tfor(j=i-1;j>=0;j--) {\n\t\t\tpat[i][j]=fact[a-j]*fact[(a-j)+b-1]%mo*factr[(a-j)-1]%mo;\n\t\t\t(pat[i][j]*=fact[a]*factr[j]%mo*factr[a-j]%mo*fact[(a-j)+b+c]*factr[(a-j)+b]%mo)%=mo;\n\t\t\tif(j&1) ret-=pat[i][j];\n\t\t\telse ret+=pat[i][j];\n\t\t}\n\t}\n\tcout<<(ret%mo+mo)%mo<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-11;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 11100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tinline long long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nlong long f(int a,int b,int c){\n\treturn fact[a+b+c]*a%mod*inv[a+b]%mod;\n}\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tinit_C(11000000);\n\tlong long ret=0;\n\tfor(int i=1;i<=b;i++){\n\t\tfor(int j=0;j<i;j++){\n\t\t\tlong long tmp=Comb(i,j);\n\t\t\ttmp=tmp*f(i-j,a-b,max(0,b-i-1))%mod;\n\t\t\t// printf(\"%d %d: %lld\\n\",i,j,tmp);\n\t\t\tif(j%2){\n\t\t\t\tret=(ret+mod-tmp)%mod;\n\t\t\t}else{\n\t\t\t\tret=(ret+tmp)%mod;\n\t\t\t}\n\t\t}\n\t}\n\t// ret=ret*fact[a]%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 10000010;\nconst int maxa = 5010;\nconst int mod = 1e9+7;\n\nint n, a;\n\nint fac[maxn+maxa], ifac[maxn+maxa], inv[maxn+maxa];\n\nint binom(int x, int y) {\n\tif (y > x) return 0;\n\treturn 1LL * fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n}\n\nint cal(int x, int y) {\n\tif (!y) return 1;\n\tif (x) return 1LL * fac[x + y - 1] * ifac[x - 1] % mod;\n\telse return 0;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &a);\n\tfac[0] = ifac[0] = 1, inv[1] = 1;\n\tfor (int i = 2; i <= n+a; i++) inv[i] = mod - 1LL * inv[mod % i] * (mod / i) % mod;\n\tfor (int i = 1; i <= n+a; i++) {\n\t\tfac[i] = 1LL * fac[i-1] * i % mod;\n\t\tifac[i] = 1LL * ifac[i-1] * inv[i] % mod;\n\t}\n\tint ans = 0;\n\tfor (int p = 1; p <= a; p++) {\n\t\tfor (int k = 0; k < p; k++) {\n\t\t\tif (k == p-1) {\n\t\t\t\tint K = binom(p-1, k); if (k & 1) K = mod - K;\n\t\t\t\tfor (int s = p-1; s <= a-1; s++) {\n\t\t\t\t\tint w = 1;\n\t\t\t\t\tw = 1LL * w * binom(a-p, s-p+1) % mod;\n\t\t\t\t\tw = 1LL * w * cal(s-k, n-a) % mod;\n\t\t\t\t\tw = 1LL * w * fac[a-s-1] % mod;\n\t\t\t\t\tw = 1LL * w * cal(p-1-k, s-p+1) % mod;\n\t\t\t\t\tw = 1LL * w * fac[p-1-k] % mod;\n\t\t\t\t\tans = (ans + 1LL * K * w % mod) % mod;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint K = binom(p-1, k); if (k & 1) K = mod - K;\n\t\t\t\tint w = 1;\n\t\t\t\tw = 1LL * w * (p-1-k) % mod;\n\t\t\t\tw = 1LL * w * fac[a-p] % mod;\n\t\t\t\tw = 1LL * w * fac[p-k+n-a-2] % mod;\n\t\t\t\tw = 1LL * w * binom(n-k-1, a-p) % mod;\n\t\t\t\tans = (ans + 1LL * K * w % mod) % mod;\n\t\t\t}\n\t\t}\n\t}\n\t// 一个自环都没得\n\t{\n\t\tfor (int k = 0; k <= a; k++) {\n\t\t\tint K = binom(a, k); if (k & 1) K = mod - K;\n\t\t\tans = (ans + 1LL * fac[a - k] * cal(a - k, n - a) % mod * K % mod) % mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\ntypedef long long ll;\nconst ll MOD = 1000000007;\n\nll kaikai[11000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n\nll extGCD(ll a, ll b, ll *x, ll *y) {\n    if (b == 0) {\n        *x = 1;\n        *y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    *y -= a / b * *x;\n    return d;\n}\n\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, &x, &y);\n    return (x % MOD + MOD) % MOD;\n}\n\nll n,a,ans=0,co[5100]={},dp[5005][5005][3]={};\n\nint main()\n{\n \n  scanf(\"%lld%lld\",&n,&a);\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[i][j][2]*KAI(i)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  rep(i,n-a){\n    ans*=(i+1);\n    ans%=MOD;\n  }\n  printf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 10000010, P = 1000000007;\nint n, A, fact[maxn], finv[maxn], inv[maxn];\n\nint main() {\n    scanf(\"%d %d\", &n, &A);\n    fact[0] = finv[0] = inv[0] = inv[1] = 1;\n    for (int i = 1; i <= n; i++) {\n        fact[i] = 1LL * i * fact[i - 1] % P;\n        if (i > 1) inv[i] = 1LL * (P - P / i) * inv[P % i] % P;\n        finv[i] = 1LL * finv[i - 1] * inv[i] % P;\n    }\n    auto C = [&](int x, int y) {\n        return 1LL * fact[x] * finv[y] % P * finv[x - y] % P;\n    };\n    int ans = 0;\n    for (int t = 2; t <= A + 1; t++) {\n        int a = t - 1, b = n - A, c = max(0, A - t);\n        for (int j = 0; j <= a; j++) {\n            int coef = j & 1 ? P - 1 : 1;\n            ans = (ans + 1LL * coef * C(a, j) % P * (a - j) % P * inv[a - j + b]\n                % P * fact[a - j + b + c]) % P;\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>bool chmax(t&a,u b){if(a<b)a=b;return a<b;}\ntemplate<class t,class u>bool chmin(t&a,u b){if(b<a)a=b;return b<a;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n\tint size(){\n\t\treturn v.size();\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\n//uint MODULAR=998244353;\nuint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\nll n,a;\nMint dp[5005][5005][2],ans;\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>n>>a;\n\tInitfact(n);\n\tif(n==a){\n\t\tprint(fact[n]);\n\t\treturn 0;\n\t}\n\tdp[1][1][1]=1;\n\tfor(int i=1;i<=a;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tdp[i+1][j+1][1]+=(dp[i][j][0]+dp[i][j][1]);\n\t\t\tif(j>0)dp[i+1][j-1][0]+=dp[i][j][1]*Mint(a-i);\n\t\t\tdp[i+1][j][0]+=dp[i][j][0]*Mint(a-i);\n\t\t\tif(i>1&&j>0&&n-a>=j-1)ans+=dp[i][j][1]*fact[a-i]*fact[n-a]*comb(n-a-j+1+i-2,i-2);\n\t\t\tif(i==a&&n-a>=j)ans+=(dp[i][j][0]+dp[i][j][1])*fact[n-a]*comb(n-a-j+i-1,i-1);\n\t\t}\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 1e7 + 5;\nconst int P = 1e9 + 7;\nint n,k;\nint sil[MAX];\nint mul(int a,int b){\n  return a * b % P;\n}\nvoid sub(int &a,int b){\n  a -= b;\n  if(a < 0)a += P;\n}\nvoid add(int &a,int b){\n  a += b;\n  if(a >= P)\n    a-=P;\n}\n\nint pot(int a,int w){\n  int r = 1;\n  while(w){\n    if(w & 1){\n      r = a * r % P;\n    }\n    w/=2;\n    a = a * a % P;\n  }\n  return r;\n}\nconst int MAXK = 5001;\nint dwu[MAXK][MAXK];\nint dp[MAXK];\nint odw[MAXK];\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> k;\n  sil[0] = 1;\n  R(i,n + 1){\n    sil[i+1] = mul(sil[i], i+1);\n  }\n  R(i,k+1){\n    odw[i] = pot(sil[i], P-2);\n  }\n  R(i,k+1)R(j,i+1){\n    if(j == 0){\n      dwu[i][j] = 1;\n    }else{\n      dwu[i][j] = dwu[i-1][j-1];\n      add(dwu[i][j], dwu[i-1][j]);\n    }\n  }\n  for(int i = 1; i <= k; i++){\n    dp[i] = mul(i, sil[n - k + i - 1]);\n    for(int j = 1; j < i; j++)\n      sub(dp[i], mul(dwu[i][j], dp[j]));\n  }\n  int res = dp[k];\n  vector<int> sum(k + 1);\n  for(int i = k; i >= 2;i --){\n    for(int z = 2; z <= i; z++){\n      int mn = ((i + z)&1 ? P-1 : 1);\n      mn = mul(mn, dwu[i-1][i-z]);\n      mn = mul(mn, z-1);\n      mn = mul(mn, sil[k-i]);\n      debug(n,z,i);\n      add(sum[z], mul(sil[n + z - i - 2], odw[k-i]));\n      mn = mul(mn, sum[z]);\n      add(res, mn);\n    }\n  }\n  cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  ll n,a,dp[5100][5100][3]={},ans=0,co[5100]={};\n  cin >> n >> a;\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[i][j][2]*KAI(i)%MOD*KAI(n-a)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n\n #include <stdio.h>\n #include <bits/stdc++.h>\n\n\n\n\n\n\nusing namespace std;\n\n\n\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a);\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a);\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, deque<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\n\n\n\n\n\n\nusing li = long long int;\nusing lu = long long unsigned;\nusing ld = long double;\n\n\nusing pii = tuple<li, li>;\nusing piii = tuple<li, li, li>;\nusing piiii = tuple<li, li, li, li>;\nusing vi = vector<li>;\nusing vii = vector<pii>;\nusing viii = vector<piii>;\nusing vvi = vector<vi>;\nusing vvii = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\nstruct empty_t {};\n\n\n\nnamespace tuple_access {\n\n  struct xx_t {} xx;\n  struct yy_t {} yy;\n  struct zz_t {} zz;\n  struct ww_t {} ww;\n\n  template<class T>\n  typename tuple_element<0,T>::type& operator^(T& v, xx_t) { return get<0>(v); }\n  template<class T>\n  typename tuple_element<0,T>::type const& operator^(T const& v, xx_t) { return get<0>(v); }\n  template<class T>\n  typename tuple_element<0,T>::type&& operator^(T&& v, xx_t) { return get<0>(v); }\n\n  template<class T>\n  typename tuple_element<1,T>::type& operator^(T& v, yy_t) { return get<1>(v); }\n  template<class T>\n  typename tuple_element<1,T>::type const& operator^(T const& v, yy_t) { return get<1>(v); }\n  template<class T>\n  typename tuple_element<1,T>::type&& operator^(T&& v, yy_t) { return get<1>(v); }\n\n  template<class T>\n  typename tuple_element<2,T>::type& operator^(T& v, zz_t) { return get<2>(v); }\n  template<class T>\n  typename tuple_element<2,T>::type const& operator^(T const& v, zz_t) { return get<2>(v); }\n  template<class T>\n  typename tuple_element<2,T>::type&& operator^(T&& v, zz_t) { return get<2>(v); }\n\n  template<class T>\n  typename tuple_element<3,T>::type& operator^(T& v, ww_t) { return get<3>(v); }\n  template<class T>\n  typename tuple_element<3,T>::type const& operator^(T const& v, ww_t) { return get<3>(v); }\n  template<class T>\n  typename tuple_element<3,T>::type&& operator^(T&& v, ww_t) { return get<3>(v); }\n}\nusing namespace tuple_access;\n\n\nint ilog2(int x){ return 31 - __builtin_clz(x); }\n\ntemplate <class T>\nstruct identity : std::unary_function <T, T> {\n  T operator() (const T& x) const {return x;}\n};\n\ntemplate<class T>\nT& smin(T& x, T const& y) { x = min(x,y); return x; }\n\ntemplate <class T>\nT& smax(T& x, T const& y) { x = max(x, y); return x; }\n\n\ntemplate<typename T>\nT isqrt(T const&x){\n  static_assert(is_integral<T>::value, \"is_integral<T>::value\");\n  assert(x>=T(0));\n  T ret = static_cast<T>(sqrtl(x));\n  while(ret>0 && ret*ret>x) --ret;\n  while(x-ret*ret>2*ret) ++ret;\n  return ret;\n}\n\ntemplate<typename T>\nT icbrt(T const&x) {\n  static_assert(is_integral<T>::value, \"is_integral<T>::value\");\n  assert(x>=T(0));\n  T ret = static_cast<T>(cbrt(x));\n  while(ret>0 && ret*ret*ret>x) --ret;\n  while(x-ret*ret*ret>3*ret*(ret+1)) ++ret;\n  return ret;\n}\n\n\n\ntemplate<li M = 1'000'000'007>\nstruct Zn {\n  static_assert(M > 2, \"M > 2\");\n  static_assert(M < (1ll<<31), \"M < (1ll<<31)\");\n  int value;\n\n  Zn() : value(0) { }\n\n  Zn(int x) : value(x%M) {\n    if(value < 0) value += M;\n  }\n\n  Zn(li x) : value(x%M) {\n    if(value < 0) value += M;\n  }\n\n  Zn& operator+=(Zn const& o) {\n    value += o.value;\n    if(value >= M) value -= M;\n    return *this;\n  }\n\n  Zn& operator-=(Zn const& o) {\n    value += M - o.value;\n    if(value >= M) value -= M;\n    return *this;\n  }\n\n  Zn& operator*=(Zn const& o) {\n    value = ((li)value*(li)o.value)%M;\n    return *this;\n  }\n\n  Zn& operator/=(Zn const& o) {\n    return operator*=(o.inverse());\n  }\n\n  Zn operator-() const { Zn r; r.value = value ? M-value : 0; return r; }\n  Zn operator+(Zn const& o) const { Zn r; r.value = value+o.value; if(r.value>=M) r.value -= M; return r; }\n  Zn operator-(Zn const& o) const { Zn r; r.value = value+M-o.value; if(r.value>=M) r.value -= M; return r; }\n  Zn operator*(Zn const& o) const { return Zn((li)value * (li)o.value); }\n  Zn operator/(Zn const& o) const { Zn a = *this; a /= o; return a; }\n\n  Zn inverse() const {\n    int a = value, b = M, u = 0, v = 1;\n    while (a != 0) {\n      int t = b / a;\n      b -= t * a; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    return Zn(u);\n  }\n\n  bool operator==(Zn const& o) const { return value == o.value; }\n  bool operator!=(Zn const& o) const { return value != o.value; }\n  bool operator<(Zn const& o) const { return value < o.value; }\n  bool operator>(Zn const& o) const { return value > o.value; }\n  bool operator<=(Zn const& o) const { return value <= o.value; }\n  bool operator>=(Zn const& o) const { return value >= o.value; }\n};\n\ntemplate<li M>\nZn<M> pow(Zn<M> a, li b) {\n  Zn<M> r = 1;\n  while(b){\n    if(b&1) r = r*a;\n    a = a * a;\n    b /= 2;\n  }\n  return r;\n}\n\ntemplate<li M>\nZn<M> operator+(int const& x, Zn<M> const& o) { return Zn<M>(x) + o; }\ntemplate<li M>\nZn<M> operator+(li const& x, Zn<M> const& o) { return Zn<M>(x) + o; }\n\ntemplate<li M>\nZn<M> operator*(int const& x, Zn<M> const& o) { return Zn<M>(x) * o; }\ntemplate<li M>\nZn<M> operator*(li const& x, Zn<M> const& o) { return Zn<M>(x) * o; }\n\ntemplate<li M>\nZn<M> operator/(int const& x, Zn<M> const& o) { return Zn<M>(x) / o; }\ntemplate<li M>\nZn<M> operator/(li const& x, Zn<M> const& o) { return Zn<M>(x) / o; }\n\n\ntemplate<li M>\nostream& operator<<(ostream& ss, Zn<M> const& a) {\n  return ss << a.value;\n}\n\ntemplate<li M>\nistream& operator>>(istream& ss, Zn<M> &a) {\n  li x; ss>>x;\n  a = Zn<M>(x);\n  return ss;\n}\n\n\ntemplate<li M>\nstruct with_ntt {\n  static bool has_ntt;\n  static Zn<M> prim_root;\n  static int MAXN;\n  static vector<vector<int>> roots;\n  static vector<vector<int>> rroots;\n\n  static void calc_roots(int N) {\n    for(;MAXN <= N; MAXN *= 2) {\n      li h = pow(prim_root, (1'000'000'007 -1)/MAXN).value;\n      li ih = (1/Zn<M>(h)).value;\n      li w = 1;\n      roots.emplace_back(vector<int>(MAXN));\n      for(li i = 0; i < (li)(MAXN); ++i) {\n        roots.back()[i] = w;\n        w = (w*h)%M;\n      }\n      w = 1;\n      rroots.emplace_back(vector<int>(MAXN));\n      for(li i = 0; i < (li)(MAXN); ++i) {\n        rroots.back()[i] = w;\n        w = (w*ih)%M;\n      }\n    }\n  }\n\n  static void ntt(int N, vector<int>& a, bool reverse) {\n    assert((N & (N - 1)) == 0);\n    calc_roots(N);\n    vector<vector<int>> const& aroots = reverse ? rroots : roots;\n\n    for(int m = N; m >= 2; m /= 2){\n      int mh = m/2;\n      int im = ilog2(mh)+1;\n      vector<int> const& aroots0 = aroots[im];\n      for(int j = 0; j < N; j += m){\n        for(li i = 0; i < (li)(mh); ++i){\n          li w = aroots0[i];\n          li x = (a[i+j]+a[i+j+mh]);\n          if(x >= M) x -= M;\n          li y = ((M+a[i+j]-a[i+j+mh]) * w) % M;\n          a[i+j] = x;\n          a[i+j+mh] = y;\n        }\n      }\n    }\n\n    int i = 0;\n    for(li j = (1); j <= (li)(N-2); ++j){\n      for(int k = N/2; k > (i^=k); k /= 2);\n      if(j<i) swap(a[i],a[j]);\n    }\n    if(reverse) {\n      li IN = (1/Zn<M>(N)).value;\n      for(li j = 0; j < (li)(N); ++j) a[j] = ((li)a[j]*IN) % M;\n    }\n  }\n};\n\ntemplate<li M>\nint with_ntt<M>::MAXN = 1;\n\ntemplate<li M>\nvector<vector<int>> with_ntt<M>::roots;\n\ntemplate<li M>\nvector<vector<int>> with_ntt<M>::rroots;\n\ntemplate<li M>\nZn<M> with_ntt<M>::prim_root = 0;\n\ntemplate<li M>\nbool with_ntt<M>::has_ntt = false;\n\ntemplate<>\nbool with_ntt<119*(1<<23) + 1>::has_ntt = true;\ntemplate<>\nZn<119*(1<<23) + 1> with_ntt<119*(1<<23) + 1>::prim_root = 15311432;\n\ntemplate<li M = 1'000'000'007>\nstruct polymod {\n  vector<Zn<M>> A;\n\n  polymod() { }\n\n  polymod(int const& x) {\n    A = {x};\n  }\n\n  polymod(li const& x) {\n    A = {x};\n  }\n\n  polymod(Zn<M> const& x) {\n    A = {x};\n  }\n\n  void truncate() {\n    while(!A.empty() && A.back() == 0) A.pop_back();\n  }\n\n  void truncate(int n) {\n    while(!A.empty() && (A.back() == 0 || (int)A.size() > n)) A.pop_back();\n  }\n\n  Zn<M>& operator[](int i) {\n    while(i >= (int)A.size()) A.push_back(0);\n    return A[i];\n  }\n\n  Zn<M> operator[](int i) const {\n    return i<(int)A.size()?A[i]:0;\n  }\n\n  int degree() {\n    truncate();\n    return (int)A.size() - 1;\n  }\n\n  polymod& operator+=(polymod const& o) {\n    int n = max(A.size(), o.A.size());\n    A.resize(n, 0);\n    for(li i = 0; i < (li)(o.A.size()); ++i) A[i] += o.A[i];\n    truncate();\n    return *this;\n  }\n\n  polymod operator+(polymod const& o) const {\n    polymod r = *this;\n    r += o;\n    return r;\n  }\n\n  polymod& operator-=(polymod const& o) {\n    int n = max(A.size(), o.A.size());\n    A.resize(n, 0);\n    for(li i = 0; i < (li)(o.A.size()); ++i) A[i] -= o.A[i];\n    truncate();\n    return *this;\n  }\n\n  polymod operator-(polymod const& o) const {\n    polymod r = *this;\n    r -= o;\n    return r;\n  }\n\n  bool operator==(polymod const& o) const {\n    int mi = min(A.size(),o.A.size());\n    for(li i = 0; i < (li)(mi); ++i) if(A[i] != o.A[i]) return false;\n    for(li i = (mi); i <= (li)(A.size()-1); ++i) if(A[i] != 0) return false;\n    for(li i = (mi); i <= (li)(o.A.size()-1); ++i) if(o.A[i] != 0) return false;\n    return true;\n  }\n\n  static void karatsuba_mul(li const* a, li const* b, li* c1, li* c2, li* d1, li* d2, int n) {\n    if(n <= 8) {\n      for(li i = 0; i < (li)(2*n); ++i) c1[i] = 0;\n      for(li i = 0; i < (li)(n); ++i) for(li j = 0; j < (li)(n); ++j) {\n        c1[i+j] += a[i] * b[j];\n        c1[i+j] %= M;\n      }\n      return;\n    }\n\n    karatsuba_mul(a, b, c1, c2, d1, d2, (n/2));\n    karatsuba_mul(a+(n/2), b+(n/2), c1+n, c2+n, d1, d2, (n/2));\n    for(li i = 0; i < (li)(n/2); ++i) {\n      d1[i] = a[i]+a[(n/2)+i];\n      if(d1[i] >= M) d1[i] -= M;\n    }\n    for(li i = 0; i < (li)(n/2); ++i) {\n      d2[i] = b[i]+b[(n/2)+i];\n      if(d2[i] >= M) d2[i] -= M;\n    }\n    karatsuba_mul(d1, d2, c2, c2+n, d1+(n/2), d2+(n/2), (n/2));\n    for(li i = 0; i < (li)(n); ++i) d1[i] = M+M+c2[i]-c1[i]-c1[n+i];\n    for(li i = 0; i < (li)(n); ++i) {\n      c1[i+(n/2)] += d1[i];\n      while(c1[i+(n/2)] >= M) c1[i+(n/2)] -= M;\n    }\n  }\n\n  static polymod mul(polymod const& a, polymod const& b, int n) {\n    if(with_ntt<M>::has_ntt) {\n      int m = 1; while(m < min(2*n, (int)a.A.size()+(int)b.A.size())) m *= 2;\n      static vector<int> aa, bb;\n      if((int)aa.size() < m) aa.resize(m);\n      if((int)bb.size() < m) bb.resize(m);\n      memset(aa.data(), 0, m*sizeof(int));\n      memset(bb.data(), 0, m*sizeof(int));\n      for(li i = 0; i < (li)(min(n,(int)a.A.size())); ++i) aa[i] = a.A[i].value;\n      for(li i = 0; i < (li)(min(n,(int)b.A.size())); ++i) bb[i] = b.A[i].value;\n      with_ntt<M>::ntt(m,aa,0);\n      with_ntt<M>::ntt(m,bb,0);\n      for(li i = 0; i < (li)(m); ++i) aa[i] = ((li)aa[i]*(li)bb[i]) % M;\n      with_ntt<M>::ntt(m,aa,1);\n      polymod r;\n      r.A.resize(min(n,m));\n      for(li i = 0; i < (li)(min(n,m)); ++i) r.A[i] = aa[i];\n      r.truncate(n);\n      return r;\n    }else{\n      int m = 1;\n      while(m < max((int)a.A.size(),(int)b.A.size())) m *= 2;\n      static vector<li> aa, bb, c1, c2, d1, d2;\n      if((int)aa.size() < m) aa.resize(m);\n      if((int)bb.size() < m) bb.resize(m);\n      if((int)c1.size() < 2*m) c1.resize(2*m);\n      if((int)c2.size() < 2*m) c2.resize(2*m);\n      if((int)d1.size() < m) d1.resize(m);\n      if((int)d2.size() < m) d2.resize(m);\n      memset(aa.data(), 0, m*sizeof(int));\n      memset(bb.data(), 0, m*sizeof(int));\n      for(li i = 0; i < (li)(min(n,(int)a.A.size())); ++i) aa[i] = a.A[i].value;\n      for(li i = 0; i < (li)(min(n,(int)b.A.size())); ++i) bb[i] = b.A[i].value;\n      karatsuba_mul(aa.data(),bb.data(),c1.data(),c2.data(),d1.data(),d2.data(),m);\n      polymod rr; rr.A.resize(min(n,2*m));\n      for(li i = 0; i < (li)(min(n,2*m)); ++i) rr.A[i] = c1[i];\n      rr.truncate(n);\n      return rr;\n    }\n  }\n\n  polymod operator*(polymod const& o) const {\n    return mul(*this, o, A.size() + o.A.size());\n  }\n\n  polymod& operator*=(polymod const& o) {\n    return *this = (*this) * o;\n  }\n\n  polymod operator*(Zn<M> const& o) const {\n    polymod r = *this; r *= o;\n    return r;\n  }\n\n  polymod& operator*=(Zn<M> const& o) {\n    for(li i = 0; i < (li)((int)A.size()); ++i) A[i] *= o;\n    return *this;\n  }\n\n  polymod operator/(Zn<M> const& o) const {\n    auto io = 1/o;\n    polymod r = *this; r *= io;\n    return r;\n  }\n\n  polymod& operator/=(Zn<M> const& o) {\n    auto io = 1/o;\n    for(li i = 0; i < (li)((int)A.size()); ++i) A[i] *= io;\n    return *this;\n  }\n\n  static polymod inverse(polymod const& a, int n) {\n    assert(a[0] != 0);\n    polymod b = 1/a[0];\n    int m = 1;\n    while(m < n) {\n      m *= 2; m = min(m, n);\n      b = mul(b, polymod(2) - mul(a,b,m), m);\n    }\n    b.truncate(n);\n    return b;\n  }\n\n  static polymod power(polymod a, int k, int n) {\n    if(k == 1) return a;\n    polymod r = 1;\n    while(k) {\n      if(k&1) r = mul(r,a,n);\n      a = mul(a,a,n);\n      k /= 2;\n    }\n    return r;\n  }\n\n  static polymod sqroot(polymod const& a, int n) {\n    assert(a[0] == 1);\n    polymod b = 1;\n    polymod c = 1;\n    int m = 1;\n    while(m < n) {\n      m *= 2; m = min(m, n);\n      c = mul(c, polymod(2) - mul(b,c,m), m);\n      b = (b + mul(a,c,m)) / Zn<M>(2);\n      c = mul(c, polymod(2) - mul(b,c,m), m);\n    }\n    b.truncate(n);\n    return b;\n  }\n\n  static polymod root(polymod const& a, int k, int n) {\n    assert(a[0] == 1);\n    polymod b = 1;\n    polymod c = 1;\n    int m = 1;\n    while(m < n) {\n      m *= 2; m = min(m, n);\n      c = mul(c, polymod(2) - mul(b,c,m), m);\n      auto ck = power(c, k, m) / Zn<M>(k);\n      b = mul(b, polymod(Zn<M>(k-1)/Zn<M>(k)) + mul(a, ck, m), m);\n      c = mul(c, polymod(2) - mul(b,c,m), m);\n    }\n    b.truncate(n);\n    return b;\n  }\n\n  Zn<M> eval(Zn<M> x) {\n    Zn<M> y = 1;\n    Zn<M> z = 0;\n    for(li i = 0; i < (li)(A.size()); ++i) {\n      z += A[i] * y;\n      y *= x;\n    }\n    return z;\n  }\n\n\n  static polymod interpolate(vector<Zn<M>> const& x, vector<Zn<M>> const& y) {\n    assert(x.size() == y.size());\n    polymod r;\n    int n = x.size();\n    for(li i = 0; i < (li)(n); ++i) {\n      polymod a = Zn<M>(y[i]); Zn<M> b = 1;\n      for(li j = 0; j < (li)(n); ++j) if(j != i) {\n        polymod aa; aa[0] = -x[j]; aa[1] = 1;\n        a *= aa;\n        b *= (x[i]-x[j]);\n      }\n      a /= b;\n      r += a;\n    }\n    return r;\n  }\n\n};\n\ntemplate<li M>\nostream& operator<<(ostream& ss, polymod<M> const& a) {\n  for(li i = 0; i < (li)((int)a.A.size()); ++i) if(a.A[i].value != 0) {\n    ss << a.A[i] << \" X^\" << i;\n    if(i+1 != (int)a.A.size()) ss << \" + \";\n  }\n  return ss;\n}\n\nusing ZN = Zn<1'000'000'007>;\n\nconst li N = 11'111'111;\nconst li A = 11111;\nZN F[N];\nZN IF[N];\n\nZN cnk(li n, li k) {\n  if(k < 0 || k > n) return 0;\n  return F[n]*IF[k]*IF[n-k];\n}\n\nZN dp[A][A];\nZN dp20[A];\nZN dp21[A];\n\nint main(){\n  ios::sync_with_stdio(0); cin.tie(0);\n\n  F[0] = 1; for(li i = 0; i < (li)(N-1); ++i) F[i+1] = ZN(i+1)*F[i];\n  IF[N-1] = ZN(1)/F[N-1];\n  for(li i = (N-2); i >= (li)(0); --i) IF[i] = ZN(i+1)*IF[i+1];\n\n  li n, a; cin>>n>>a;\n  li b = n-a;\n\n  dp20[0] = 1;\n  for(li i = (a-1); i >= (li)(0); --i) {\n    for(li j = (a); j >= (li)(0); --j) {\n      dp21[j+2] += i * dp20[j];\n      dp21[j+1] += i * dp21[j];\n      dp20[j] = dp20[j]+dp21[j];\n      dp21[j] = 0;\n    }\n    for(li j = (0); j <= (li)(a-i); ++j) {\n      dp[a-i-j][j] += dp20[j] * (i>1?F[i-1]:1);\n    }\n  }\n  ZN ans = 0;\n\n  for(li i = (0); i <= (li)(a); ++i) {\n\n    for(li j = (0); j <= (li)(a-i); ++j) if(dp[i][j] != 0) {\n\n      ans += dp[i][j] * cnk(b+j-1, i+j-1);\n    }\n  }\n\n  cout << ans*F[b] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\n \nusing namespace std;\n \ntypedef long long ll;\n \nll pow_mod(ll x,int k) {\n  ll ans=1;\n  while (k) {\n    if (k&1) ans=ans*x%MOD;\n    x=x*x%MOD;\n    k>>=1;\n  }\n  return ans;\n}\n \nint C[5005][5005],facd[10000005],facv[10000005],inv[5005];\n \nvoid pre(int n,int m) {\n  facd[0]=1;\n  for(int i=1;i<=n;i++) facd[i]=(ll)facd[i-1]*i%MOD;\n  facv[n]=pow_mod(facd[n],MOD-2);\n  for(int i=n-1;i>=0;i--) facv[i]=(ll)facv[i+1]*(i+1)%MOD;\n  for(int i=0;i<=m;i++) C[i][0]=1;\n  for(int i=1;i<=m;i++)\n    for(int j=1;j<=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD;\n  inv[1]=1;\n  for(int i=2;i<=m;i++) inv[i]=(ll)(MOD-MOD/i)*inv[MOD%i]%MOD;\n}\n \nll f[5005][5005];\n \nint main() {\n  int n,m;\n  scanf(\"%d%d\",&n,&m);\n  pre(n,m);\n  ll v=1;\n  for(int i=0;i<=m;i++) {\n  \tll t=v*((i)?inv[i]:1)%MOD;\n  \tfor(int j=i+1;j<=m;j++) {\n  \t\tf[i][j]=(f[i][j]+t*inv[j])%MOD;\n  \t\tf[j][j]=(f[j][j]-t*inv[j]%MOD+MOD)%MOD;\n\t  } \n    ll s=0;\n    for(int j=i;j<=m;j++) {\n        if (i) f[i][j]=(f[i][j]-f[i-1][j-1]*inv[j]%MOD+MOD)%MOD;\n        f[i][j]=(f[i][j]+s*inv[j])%MOD;\n        s=(s+f[i][j])%MOD;\n      }\n    if (i) v=v*(1LL+inv[i])%MOD;\n  } \n  ll ans=0;\n  for(int i=0;i<m;i++)\n    ans=(ans+f[i][m]*facd[n-i-1]%MOD*facv[m-i-1])%MOD;\n  ans=ans*facd[m]%MOD;\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\nusing vint=vector<int>;\nusing pint=pair<int,int>;\nusing vpint=vector<pint>;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n\tost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n\treturn ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n\tost<<\"{\";\n\tfor(int i=0;i<v.size();i++){\n\t\tif(i)ost<<\",\";\n\t\tost<<v[i];\n\t}\n\tost<<\"}\";\n\treturn ost;\n}\n\ninline int topbit(unsigned long long x){\n\treturn x?63-__builtin_clzll(x):-1;\n}\n\ninline int popcount(unsigned long long x){\n\treturn __builtin_popcountll(x);\n}\n\ninline int parity(unsigned long long x){\n\treturn __builtin_parity(x);\n}\n\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n\tModInt& s(uint32_t vv){\n\t\ta=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\n\tModInt(int64_t x=0){s(x%mod+mod);}\n\n\tModInt& operator+=(const ModInt &x){return s(a+x.a);}\n\tModInt& operator-=(const ModInt &x){return s(a+mod-x.a);}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=uint64_t(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\tbool operator<(const ModInt &x)const{return a<x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int64_t n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\nusing mint=ModInt<1000000007>;\n\ntemplate<class Mint,int32_t lg>\nstruct ModIntTable{\n\tint N;\n\tvector<Mint>facts,finvs,invs;\n\tModIntTable():N(1<<lg),facts(N),finvs(N),invs(N){\n\t\tconst uint32_t mod=Mint(-1).a+1;\n\t\tinvs[1]=1;\n\t\tfor(int i=2;i<N;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n\t\tfacts[0]=1;\n\t\tfinvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n)const{return facts[n];}\n\tinline Mint finv(int n)const{return finvs[n];}\n\tinline Mint inv(int n)const{return invs[n];}\n\tinline Mint binom(int n,int k)const{\n\t\tif(n<0||k<0||k>n)return 0;\n\t\treturn facts[n]*finvs[k]*finvs[n-k];\n\t}\n\tinline Mint perm(int n,int k)const{\n\t\tif(n<0||k<0||k>n)return 0;\n\t\treturn facts[n]*finvs[n-k];\n\t}\n\tinline Mint catalan(int n){\n\t\treturn facts[2*n]*finvs[n+1]*finvs[n];\n\t}\n};\nModIntTable<mint,24>mt;\n\nsigned main(){\n\tint N,A;\n\tcin>>N>>A;\n\n\tmint ans=0;\n\tfor(int i=1;i<=A;i++){\n\t\tmint num=0;\n\t\tint r=max(0ll,A-i-1);\n\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tmint tmp=mt.fact(i-j)*mt.perm(i-j+(N-A)-1,N-A)*mt.binom(i,j);\n\t\t\ttmp*=mt.perm(i-j+N-A+r,r);\n\t\t\tif(j&1)num-=tmp;\n\t\t\telse num+=tmp;\n\t\t}\n\t\tans+=num;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 1000000007\nusing namespace std;\n#define gc getchar\ninline ll read(){\n    register ll x=0,f=1;char ch=gc();\n    while (!isdigit(ch)){if (ch=='-') f=-1;ch=gc();}\n    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}\n    return (f==1)?x:-x;\n}\nll n,A,fac[10000001],inv[10000001],_inv[10000001];\ninline ll getC(ll n,ll m){\n    if (n<m) return 0;\n    return fac[n]*_inv[m]%ljc*_inv[n-m]%ljc;\n}\ninline ll query(ll i1,ll i2){\n\tif (i1<=0||i2<=0||i1>i2) return 0;\n\treturn fac[i2]*_inv[i1-1]%ljc;\n}\ninline ll solve(ll i1,ll i2){\n\tif (n-A<i1) return 0; \n\treturn query(n-A-i1+1,n-A)*query(i1+i2,i2-n-A+1)%ljc*query(n-A+i1+i2+2,n)%ljc;\n}\nll dp[5001][5001],sum[5001][5001];\ninline void add(ll &a,ll b){a+=b;a%=ljc;}\nsigned main(){\n    fac[0]=inv[0]=inv[1]=_inv[0]=1;\n    for (ll i=1;i<=10000000;i++) fac[i]=fac[i-1]*i%ljc;\n    for (ll i=2;i<=10000000;i++) inv[i]=(ljc-inv[ljc%i]*(ljc/i)%ljc)%ljc;\n    for (ll i=1;i<=10000000;i++) _inv[i]=_inv[i-1]*inv[i]%ljc;\n    n=read(),A=read(); \n//    for (int i1=0;i1<=A;i1++){\n//    \tfor (int i2=0;i2+i1<=A;i2++){\n//    \t\tif (i1==0&&i2==0){\n//    \t\t\tdp[0][0]=1;continue;\n//\t\t\t}\n//    \t\tif (i2) add(dp[i1][i2],dp[i1][i2-1]);\n//    \t\tfor (int j=1;j<i1;j++) add(dp[i1][i2],dp[i1-j-1][i2]*getC(i1+i2-1,j)%ljc);\n//\t\t}\n//\t}\n//\tll _=0;\n//\tfor (int i=2;i<=A+1;i++){\n//\t\tfor (int i1=0;i1<i;i1++){\n//\t\t\t_=(_+solve(i1,i-1-i1)*dp[i1][i-1-i1]%ljc)%ljc;\t\t\t\t\n//\t\t}\n//\t}\n\tll _=0;\n\tfor (int T=2;T<=A+1;T++) {\n\t\tint x=T-1,y=max(A-T,0ll),z=n-A;\n\t\tfor (int i=0;i<T;i++){\n\t\t\tif (i&1) add(_,ljc-getC(x,i)*(x-i)%ljc*inv[x-i+z]%ljc*fac[x-i+y+z]%ljc);\n\t\t\telse add(_,getC(x,i)*(ll)(x-i)%ljc*inv[x-i+z]%ljc*fac[x-i+y+z]%ljc);\n\t\t} \n\t}\n\tcout<<_;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#include <list>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k){\n        if(k&1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k>>=1;\n    }\n    return ans;\n}\nll inv(ll a){\n    return powmod(a, MOD-2);\n}\nll f[10000010], invf[10000010];\nvoid fac(int n){\n    f[0]=1;\n    for(ll i=1; i<=n; i++) f[i]=f[i-1]*i%MOD;\n    invf[n]=inv(f[n]);\n    for(ll i=n-1; i>=0; i--) invf[i]=invf[i+1]*(i+1)%MOD;\n}\nll comb(int x, int y){\n    if(!(0<=y && y<=x)) return 0;\n    return f[x]*invf[y]%MOD*invf[x-y]%MOD;\n}\nll dp[2][2][5050][5050];\nint main()\n{\n    int n, a; cin>>n>>a;\n    fac(n);\n    ll ans=0;\n    dp[0][0][a][0]=dp[1][1][a][0]=1;\n    for(int i=a; i>=1; i--){\n        for(int j=0; j<=a-i; j++){\n            for(int p=0; p<2; p++){\n                for(int q=0; q<2; q++){\n                    (dp[p][q][i-1][j]+=dp[p][0][i][j]*i)%=MOD;\n                    (dp[p][q][i-1][j+q]+=dp[p][1][i][j])%=MOD;\n                }\n            }\n        }\n    }\n    for(int x=0; x<a; x++){\n        for(int i=0; i<=a; i++){\n            ll c=(dp[1][0][x+1][i]*(x+1)+dp[1][1][x+1][i])%MOD*f[x+1]%MOD;\n            (ans+=c*comb(n-x-i-2, a-x-1)%MOD*f[n-a])%=MOD;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  ll n,a,ans=0,co[5100]={};\n  cin >> n >> a;\n  ll dp[a+5][a+5][3]={};\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[i][j][2]*KAI(i)%MOD*KAI(n-a)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  ll n,a,dp[5001][5001][3]={},ans=0,co[5100]={};\n  cin >> n >> a;\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[i][j][2]*KAI(i)%MOD*KAI(n-a)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 5005\n#define MX 10000005\n#define MOD 1000000007\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nll inv[MX],fac[MX],finv[MX];\nll dp[SIZE][SIZE];\nll dp2[SIZE];\nll rt[SIZE];\n\nvoid make()\n{\n\tinv[1]=1;\n\tfac[0]=fac[1]=1;\n\tfinv[0]=finv[1]=1;\n\tfor(int i=2;i<MX;i++)\n\t{\n\t\tinv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n\t\tfac[i]=fac[i-1]*(ll) i%MOD;\n\t\tfinv[i]=finv[i-1]*inv[i]%MOD;\n\t}\n\trt[0]=1;\n\tfor(int i=1;i<SIZE;i++) rt[i]=rt[i-1]*2LL%MOD;\n}\nll C(int a,int b)\n{\n\tif(a<b) return 0;\n\treturn fac[a]*(finv[b]*finv[a-b]%MOD)%MOD;\n}\nint main()\n{\n\tmake();\n\tint n,A;\n\tscanf(\"%d %d\",&n,&A);\n\tfor(int i=0;i<=A;i++)\n\t{\n\t\tdp2[i]=1;\n\t\tfor(int j=2;j<=i;j++)\n\t\t{\n\t\t\tdp2[i]-=inv[i]*dp2[i-j]%MOD;\n\t\t\tif(dp2[i]<0) dp2[i]+=MOD;\n\t\t}\n\t}\n\tint B=n-A;\n\tdp[0][0]=1;\n\tll ret=0;\n\tfor(int i=0;i<=A;i++)\n\t{\n\t\tll sum=0;\n\t\tfor(int j=0;j<=A;j++)\n\t\t{\n\t\t\tif(i>0||j>0)\n\t\t\t{\n\t\t\t\tll now=sum;\n\t\t\t\tif(i>0&&j>0)\n\t\t\t\t{\n\t\t\t\t\tnow+=dp[i-1][j-1]*inv[A-j+1]%MOD;\n\t\t\t\t\tif(now>=MOD) now-=MOD;\n\t\t\t\t}\n\t\t\t\tdp[i][j]=now;\n\t\t\t\tif(j>0)\n\t\t\t\t{\n\t\t\t\t\tsum+=dp[i][j-1]*inv[A-j+1]%MOD;\n\t\t\t\t\tif(sum>=MOD) sum-=MOD;\n\t\t\t\t}\n\t\t\t\tif(dp[i][j]>0&&i<=B)\n\t\t\t\t{\n\t\t\t\t\tret+=C(B+j-i-1,B-i)*dp[i][j]%MOD*dp2[A-j]%MOD;\n\t\t\t\t\tif(ret>=MOD) ret-=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret*fac[A]%MOD*fac[B]%MOD);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 5005\n#define MX 10000005\n#define MOD 1000000007\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nll inv[MX],fac[MX],finv[MX];\nll dp[SIZE][SIZE];\nll dp2[SIZE];\nll rt[SIZE];\n\nvoid make()\n{\n\tinv[1]=1;\n\tfac[0]=fac[1]=1;\n\tfinv[0]=finv[1]=1;\n\tfor(int i=2;i<MX;i++)\n\t{\n\t\tinv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n\t\tfac[i]=fac[i-1]*(ll) i%MOD;\n\t\tfinv[i]=finv[i-1]*inv[i]%MOD;\n\t}\n\trt[0]=1;\n\tfor(int i=1;i<SIZE;i++) rt[i]=rt[i-1]*2LL%MOD;\n}\nll C(int a,int b)\n{\n\tif(a<b) return 0;\n\treturn fac[a]*(finv[b]*finv[a-b]%MOD)%MOD;\n}\nint main()\n{\n\tmake();\n\tint n,A;\n\tscanf(\"%d %d\",&n,&A);\n\tfor(int i=0;i<=A;i++)\n\t{\n\t\tdp2[i]=1;\n\t\tfor(int j=2;j<=i;j++)\n\t\t{\n\t\t\tdp2[i]-=inv[i]*dp2[i-j]%MOD;\n\t\t\tif(dp2[i]<0) dp2[i]+=MOD;\n\t\t}\n\t}\n\tint B=n-A;\n\tdp[0][0]=1;\n\tll ret=0;\n\tfor(int i=0;i<=A;i++)\n\t{\n\t\tll sum=0;\n\t\tfor(int j=0;j<=A;j++)\n\t\t{\n\t\t\tif(i>0||j>0)\n\t\t\t{\n\t\t\t\tll now=sum;\n\t\t\t\tif(i>0&&j>0)\n\t\t\t\t{\n\t\t\t\t\tnow+=dp[i-1][j-1]*inv[A-j+1]%MOD;\n\t\t\t\t\tif(now>=MOD) now-=MOD;\n\t\t\t\t}\n\t\t\t\tdp[i][j]=now;\n\t\t\t\tif(j>0)\n\t\t\t\t{\n\t\t\t\t\tsum+=dp[i][j-1]*inv[A-j+1]%MOD;\n\t\t\t\t\tif(sum>=MOD) sum-=MOD;\n\t\t\t\t}\n\t\t\t\tif(dp[i][j]>0&&i<=B)\n\t\t\t\t{\n\t\t\t\t\tret+=C(B+j-i-1,j-1)*dp[i][j]%MOD*dp2[A-j]%MOD;\n\t\t\t\t\tif(ret>=MOD) ret-=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret*fac[A]%MOD*fac[B]%MOD);\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\n#ifdef DEBUG\nmt19937 mrand(300); \n#else\nmt19937 mrand(chrono::steady_clock::now().time_since_epoch().count()); \n#endif\n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nconst int mod = (int) 1e9 + 7;\n\nint mul(int a, int b) {\n  return (long long) a * b % mod;\n}\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= mod) {\n    a -= mod;\n  }\n}\n\nconst int maxn = (int) 1e7 + 5, maxa = 5005;\nint f[maxn], inv[maxn], finv[maxn];\n\nvoid precalc() {\n  f[0] = 1;\n  for (int i = 1; i < maxn; i++) {\n    f[i] = mul(f[i - 1], i);\n  }\n  inv[1] = 1;\n  for (int i = 2; i < maxn; i++) {\n    inv[i] = (mod - (long long) (mod / i) * inv[mod % i] % mod) % mod;\n  }\n  finv[0] = 1;\n  for (int i = 1; i < maxn; i++) {\n    finv[i] = mul(finv[i - 1], inv[i]);\n  }\n}\n\nint n, a;\n\nbool read() {\n  if (scanf(\"%d%d\", &n, &a) < 2) {\n    return false;\n  }\n  return true;\n}\n\nint dp[maxa][maxa];\nint cnt[maxa][maxa];\n\nvoid solve() {\n  for (int j = 0; j <= a; j++) {\n    cnt[a][j] = 0;\n  }\n  for (int i = a - 1; i >= 0; i--) {\n    for (int j = 0; i + j <= a; j++) {\n      auto &cur = cnt[i][j];\n      if (!j) {\n        cur = mul(f[n - i - 1], finv[a - i - 1]);\n        continue;\n      }\n      cur = cnt[i][j - 1];\n      add(cur, mod - cnt[i + 1][j - 1]);\n    }\n  }\n  memset(dp, 0, sizeof(dp));\n  dp[a][0] = f[a];\n  dp[a - 1][0] = mod - f[a];\n  int res = 0;\n  for (int i = a; i >= 0; i--) {\n    for (int j = 0; j <= a; j++) {\n      {\n        auto &cur = dp[i][j];\n        add(cur, dp[i + 1][j]);\n        if (!cur) {\n          continue;\n        }\n      }\n      auto cur = dp[i][j];\n      cur = mul(cur, finv[i]);\n      eprintf(\"%d %d: %d\\n\", i, j, cur);\n      if (i < a) {\n        add(res, mul(cur, cnt[i][j]));\n      }\n      //...\n      if (!i) {\n        continue;\n      }\n      int val = mul(cur, f[i - 1]);\n      add(dp[i - 1][j + 1], val);\n      if (i >= 2) {\n        add(dp[i - 2][j + 1], mod - val);\n        add(dp[i - 2][j], val);\n      }\n    }\n  }\n  printf(\"%d\\n\", res);\n  exit(0);\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=20000005,M=1e9+7;\nint fac[N],inv[N],f[5005][5005],n,m;\ninline int ksm(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=x*x%M)\n\t\tif (y&1)(ans*=x)%=M;\n\treturn ans; \n}\ninline int P(int x,int y){\n\tif (x>y)return 1;\n\tif (!x)return 0;\n\treturn fac[y]*inv[x-1]%M;\n}\ninline int C(int x,int y){\n\tif (x<0)return 1;\n\tif (x<y)return 0;\n\treturn fac[x]*inv[y]%M*inv[x-y]%M;\n}\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfac[0]=1;\n\tfor (int i=1;i<N;i++)fac[i]=fac[i-1]*i%M;\n\tinv[N-1]=ksm(fac[N-1],M-2);\n\tfor (int i=N-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%M;\n\tn-=m;int ans=0;\n\tfor (int i=1;i<=m+1;i++)\n\t\tfor (int j=0;j<=m;j++)f[i][j]=((!j?0:f[i][j-1])+inv[j]*fac[i-2+n+j])%M;\n\tfor (int i=1;i<=m+1;i++)\n\t\tfor (int j=0;j<i;j++){\n\t\t\tint s=f[i-j][max(0ll,m-i)];\n\t\t\tif (j&1)(ans+=M-C(i-1,j)*(i-j-1)%M*(i>m?1:fac[m-i])%M*s%M)%=M;\n\t\t\telse (ans+=C(i-1,j)*(i-j-1)%M*(i>m?1:fac[m-i])%M*s)%=M;\n\t\t}\n\tprintf(\"%lld\\n\",ans);\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod = 1e9+7;\ninline int add(int a,int b){a+=b;return a>=mod?a-mod:a;}\ninline int sub(int a,int b){a-=b;return a<0?a+mod:a;}\ninline int mul(int a,int b){return 1ll*a*b%mod;}\ninline int qpow(int a,int b){int ret=1;for(;b;b>>=1,a=mul(a,a))if(b&1)ret=mul(ret,a);return ret;}\n/* math */\nconst int N = 1e7+5;\nconst int M = 5010;\nint fac[N], ifac[N], inv[N];\ninline void init(int n=1e7){\n\tfac[0]=ifac[0]=1;for(int i=1;i<=n;i++)fac[i]=mul(fac[i-1],i);\n\tifac[n]=qpow(fac[n],mod-2);for(int i=n-1;i;--i)ifac[i]=mul(ifac[i+1],i+1);\n\tinv[1]=1;for(int i=2;i<=n;i++)inv[i]=mul(mod-mod/i,inv[mod%i]);\n}\nint g[M];\nint n,a;\n\ninline int binom(int a,int b){\n\treturn mul(fac[a],mul(ifac[b],ifac[a-b]));\n}\n\ninline int solve(int a,int b,int c){\n\treturn mul(fac[a+b+c],mul(a,inv[a+b]));\n}\nint ans=0;\nint main()\n{\n\tinit();\n\tcin >> n >> a;\n\tfor(int i=1;i<=a;i++){\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tint w=binom(i,j);if((i-j)&1)w=sub(0,w);\n\t\t\tint qwq=solve(j,n-a,max(0,a-i-1));\n\t\t\tans=add(ans, mul(w,qwq));\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long lol;\nconst int N = 1e7 + 5;\nconst int M = 5e3 + 5;\nconst int mod = 1e9 + 7;\ninline int pls( int a , int b ) { a += b - mod; return a + ( a >> 31 & mod ); }\ninline int mns( int a , int b ) { a -= b; return a + ( a >> 31 & mod ); }\ninline void inc( int & a , int b ) { a += b - mod; a += a >> 31 & mod; }\ninline void dec( int & a , int b ) { a -= b; a += a >> 31 & mod; }\ninline int fpow( int base , int k ) {\n  int res = 1;\n  while( k ) {\n    if( k & 1 ) res = (long long)res * base % mod;\n    base = (long long)base * base % mod; k >>= 1;\n  }\n  return res;\n}\n\nint n , A , fac[N] , ifac[N] , inv[N];\n\ninline int binom( int n , int m ) { return (lol)fac[n]*ifac[m]%mod*ifac[n-m]%mod; }\n\nint main( void ) {\n  cin >> n >> A;\n  fac[0] = fac[1] = ifac[0] = ifac[1] = inv[1] = 1;\n  for( int i = 2 ; i <= n ; ++i ) {\n    fac[i] = (lol)fac[i - 1] * i % mod;\n    inv[i] = (lol)(mod-mod/i)*inv[mod%i]%mod;\n    ifac[i] = (lol)ifac[i - 1] * inv[i] % mod;\n  }\n  int ans = 0 , tmp;\n  for( int i = 2 , a , b , c ; i <= A + 1 ; ++i ) {\n    a = i - 1 , b = n - A , c = max( 0 , A - i );\n    for( int j = 0 ; j < i ; ++j ) {\n      tmp = (lol)binom( i - 1 , j ) * (a-j) % mod * inv[a+b-j] % mod * fac[a+b+c-j] % mod;\n      if( j & 1 ) dec( ans , tmp );\n      else inc( ans , tmp );\n    }\n  }\n  printf(\"%d\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define lld long double\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nconst int N = 101000,mod = 1e9+7;\nint n,K;\nll fac[10000010],ifac[10000010];\nll fp(ll a,ll k){\n\tll ans=1;\n\tfor(;k;k>>=1,a=a*a%mod)\n\t\tif(k&1) ans=a*ans%mod;\n\treturn ans;\n}\nll UP(int n,int m){\n\tif(n==0) return 0;\n\treturn fac[n+m-1]*ifac[n-1]%mod;\n}\nll C(int n,int m){\n\treturn fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\nint main(){\n\tread(n);read(K);\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mod;\n\tifac[n]=fp(fac[n],mod-2);\n\tfor(int i=n;i;i--) ifac[i-1]=ifac[i]*i%mod;\n\tll ans=0;\n\tfor(int i=1;i<=K;i++){\n\t\tfor(int j=0;j<i;j++)\n\t\t\tans=(ans+(j&1?-1:1)*C(i-1,j)*fac[i-1-j]%mod*UP(i-1-j,n-K)%mod*UP(i-j-K+n,K-i))%mod;\n\t}\n\tfor(int i=0;i<=K;i++){\n\t\tans=(ans+(i&1?-1:1)*C(K,i)*fac[K-i]%mod*UP(K-i,n-K))%mod;\n\t}\n\tcout<<(ans+mod)%mod<<'\\n';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n#define N 10000100\nconst int mod=1e9+7;\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,A,fac[N],inv[N],ans;\nint qpow(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=1LL*ans*a%mod;\n\t\ta=1LL*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nvoid init(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t}\n\tinv[n]=qpow(fac[n],mod-2);\n\tfor(int i=n-1;i>=0;--i){\n\t\tinv[i]=1LL*inv[i+1]*(i+1)%mod;\n\t}\n}\ninline int C(int n,int m){\n\treturn 1LL*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\ninline int calc(int a,int b,int c){\n\treturn !(a+b)?0:1LL*fac[a+b+c]*a%mod*inv[a+b]%mod*fac[a+b-1]%mod;\n}\nint main(){\n\tn=read(),A=read();\n\tinit(n);\n\tfor(int i=1;i<=A+1;++i){\n\t\tfor(int j=0;j<i;++j){\n\t\t\tans=(ans+(j&1?-1:1)*1LL*C(i-1,j)*calc(i-j-1,n-A,max(0,A-i))%mod+mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  ll n,a,dp[5100][5100][3]={},ans=0,co[11000000]={};\n  cin >> n >> a;\n  co[0]=1;\n  rep(i,10500000)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[i][j][2]*KAI(i)%MOD*KAI(n-a)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \nstd::mt19937 rnd((int)std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\n\nconst int MAXN = 10000000;\nconst int MAXON = 5000;\nconst int MOD = 1000000007;\nvoid inc(int &a, int b) { if ((a += b) >= MOD) a -= MOD; }\nvoid dec(int &a, int b) { inc(a, MOD - b); }\n\nint inv[MAXN + 1];\nint fac[MAXN + 1];\nint ifac[MAXN + 1];\n\nint prod(int l, int h) { return (ll)fac[h] * ifac[l - 1] % MOD; }\nint choose(int n, int k) { if (k<0 || k>n) return 0; return (ll)fac[n] * ifac[k] % MOD*ifac[n - k] % MOD; }\n\n// a items that we pick, b items that should be in the same cycles, c items that we don't care about\nint calc(int a, int b, int c) {\n\tint ret = 0;\n\tFORE(i, 1,a) {\n\t\t// i items are non-identity\n\t\tint cur = fac[i];\n\t\tcur = (ll)cur*prod(i, i + b - 1) % MOD;\n\t\tcur = (ll)cur*prod(i + b + 1, i + b + c) % MOD;\n\t\tcur = (ll)cur*choose(a, i) % MOD;\n\t\t//printf(\"\\t(%d,%d,%d): %d = %d\\n\", a, b, c, i, cur);\n\t\tif ((a - i) % 2 == 0) inc(ret, cur); else dec(ret, cur);\n\t}\n\treturn ret;\n}\n\nint n, on;\n\nint solve() {\n\tinv[1] = 1; FORE(i, 2, n) inv[i] = (ll)(MOD - MOD / i)*inv[MOD%i] % MOD;\n\tfac[0] = 1; FORE(i, 1, n) fac[i] = (ll)fac[i - 1] * i%MOD;\n\tifac[0] = 1; FORE(i, 1, n) ifac[i] = (ll)ifac[i - 1] * inv[i] % MOD;\n\n\tint ret = 0;\n\tint off = n - on;\n\tFORE(i, 1, on) {\n\t\tint cur = calc(i, off, i == on ? 0 : on - i - 1);\n\t\t//printf(\"%d: %d\\n\", i, cur);\n\t\tinc(ret, cur);\n\t}\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%d%d\", &n, &on);\n\tprintf(\"%d\\n\", solve());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << a << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n \ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nmt19937_64 rng;\n\nconst int \n    M = 1e7 + 10,\n    MOD = 1e9 + 7;\n\nint inv[M], fact[M], ifact[M];\n\nint comb(int m, int n) {\n    if (m < 0 || n < 0 || n > m) return 0;\n    return (ll) fact[m] * ifact[n] % MOD * ifact[m-n] % MOD;\n}\n\nint f(int a, int b, int c) {\n    return (ll) fact[a+b+c] * inv[a+b] % MOD * a % MOD;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    rng.seed(time(0));\n\n    inv[1] = 1;\n    forsn(n,2,M) {\n        inv[n] = ll(MOD - MOD/n) * inv[MOD%n] % MOD;\n        assert((ll) inv[n] * n % MOD == 1);\n    }\n    fact[0] = ifact[0] = 1;\n    forsn(n,1,M) {\n        fact[n] = ll(n) * fact[n-1] % MOD;\n        ifact[n] = ll(inv[n]) * ifact[n-1] % MOD;\n        assert((ll) fact[n] * ifact[n] % MOD == 1);\n    }\n\n    ll ans = 0;\n    int n,a; cin >> n >> a;\n    for (int i = 1; i <= a; i++) {\n        for (int k = 0; k <= i; k++) {\n            ll sign = k%2 ? MOD - 1 : 1;\n            ans += sign * comb(i,k) % MOD * f(i-k, n-a, max(0, a-1-i)) % MOD;\n        }\n    }\n    cout << ans%MOD << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  ll n,a,dp[6100][5100][3]={},ans=0,co[5100]={};\n  cin >> n >> a;\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[0][j][2]*KAI(i)%MOD*KAI(n-a)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i = a; i <= b; ++i)\n#define PER(i,a,b) for(int i = a; i >= b; --i)\n#define MP make_pair\n#define PB push_back\n#define fi first\n#define se second\ntypedef long long LL;\ntypedef long double LD;\n\nconst int maxn = 1e7;\nconst int maxa = 5000;\nconst int P = 1e9+7;\n\nint Fac[maxn+5], InvFac[maxn+5];\nLL PowMod(LL a, LL b) { LL r=1; while(b) { if(b&1) r=r*a%P; a=a*a%P, b>>=1; } return r; }\nLL C(int n, int m) { return LL(Fac[n]) * InvFac[m] % P * InvFac[n-m] % P; }\n\nvoid Add(int &a, int b) { a+=b; if(a>=P) a-=P; }\nvoid Sub(int &a, int b) { a-=b; if(a<0) a+=P; }\n\nint main() {\n    Fac[0] = 1;\n    REP(i,1,maxn) Fac[i] = Fac[i-1] * LL(i) % P;\n    InvFac[maxn] = PowMod(Fac[maxn], P-2);\n    PER(i,maxn-1,0) InvFac[i] = InvFac[i+1] * LL(i+1) % P;\n\n    int n, m, ans = 0;\n    scanf(\"%d%d\", &n, &m), n -= m;\n    REP(t,1,m+1) {\n        int tmp = 0;\n        for(int i = 1; i <= t-1; ++i) {\n            LL ha = C(t-1, i);\n            ha = ha * Fac[i] % P * Fac[i+n-1] % P;\n            if(i >= 1)\n                ha = ha * InvFac[i-1] % P;\n            if(t <= m)\n                ha = ha * Fac[i+n+m-t] % P * InvFac[i+n] % P;\n            if((t-1-i)&1) Sub(tmp, ha);\n            else Add(tmp, ha);\n        }\n        Add(ans, tmp);\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\n#include <algorithm>\n#include <chrono>\n#include <random>\n#include <functional>\n#include <vector>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int P = 1000000007;\n\nint mpow(int x, int k, int p = P) {\n  int ret = 1;\n  while (k) {\n    if (k & 1)\n      ret = ret * (ll) x % p;\n    x = x * (ll) x % p;\n    k >>= 1;\n  }\n  return ret;\n}\n\nint norm(int x) { return x >= P ? x - P : x; }\n\nstruct NumberTheory {\n\n  typedef pair<int, int> _P2_Field;\n\n  mt19937 rng;\n\n  NumberTheory() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}\n\n  void _exGcd(int a, int b, int &x, int &y) {\n    if (!b) {\n      x = 1;\n      y = 0;\n      return;\n    }\n    _exGcd(b, a % b, y, x);\n    y -= a / b * x;\n  }\n\n  int inv(int a, int p = P) {\n    int x, y;\n    _exGcd(a, p, x, y);\n    if (x < 0)\n      x += p;\n    return x;\n  }\n\n  template<class Integer>\n  bool quadRes(Integer a, Integer b) {\n    if (a <= 1)\n      return true;\n    while (a % 4 == 0)\n      a /= 4;\n    if (a % 2 == 0)\n      return (b % 8 == 1 || b % 8 == 7) == quadRes(a / 2, b);\n    return ((a - 1) % 4 == 0 || (b - 1) % 4 == 0) == quadRes(b % a, a);\n  }\n\n  // assume p in prime, x in quadratic residue\n  int sqrt(int x, int p = P) {\n    if (p == 2 || x <= 1)\n      return x;\n    int w, v, k = (p + 1) / 2;\n    do {\n      w = rng() % p;\n    } while (quadRes(v = int((w * (ll) w - x + p) % p), p));\n    _P2_Field res(1, 0), a(w, 1);\n    while (k) {\n      if (k & 1)\n        res = _P2_Field((res.first * (ll) a.first + res.second * (ll) a.second % p * v) % p,\n                        (res.first * (ll) a.second + res.second * (ll) a.first) % p);\n      if (k >>= 1)\n        a = _P2_Field((a.first * (ll) a.first + a.second * (ll) a.second % p * v) % p,\n                      (a.first * (ll) a.second << 1) % p);\n    }\n    return min(res.first, p - res.first);\n  }\n\n} nt;\n\nstruct Simple {\n  int n;\n  vector<int> fac, ifac, inv;\n\n  void build(int n) {\n    this->n = n;\n    fac.resize(n + 1);\n    ifac.resize(n + 1);\n    inv.resize(n + 1);\n    fac[0] = 1;\n    for (int x = 1; x <= n; ++x)\n      fac[x] = fac[x - 1] * (ll) x % P;\n    inv[1] = 1;\n    for (int x = 2; x <= n; ++x)\n      inv[x] = -(P / x) * (ll) inv[P % x] % P + P;\n    ifac[0] = 1;\n    for (int x = 1; x <= n; ++x)\n      ifac[x] = ifac[x - 1] * (ll) inv[x] % P;\n  }\n\n  Simple() {\n    build(1);\n  }\n\n  void check(int k) {\n    int nn = n;\n    if (k > nn) {\n      while (k > nn)\n        nn <<= 1;\n      build(nn);\n    }\n  }\n\n  int gfac(int k) {\n    check(k);\n    return fac[k];\n  }\n\n  int gifac(int k) {\n    check(k);\n    return ifac[k];\n  }\n\n  int ginv(int k) {\n    check(k);\n    return inv[k];\n  }\n\n  int binom(int n, int m) {\n    if (m < 0 || m > n)\n      return 0;\n    return gfac(n) * (ll) gifac(m) % P * gifac(n - m) % P;\n  }\n} simp;\n\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T>\nistream &operator>>(istream &is, vector<T> &v) {\n  for (T &x : v)\n    is >> x;\n  return is;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nvoid add(int &x, int y) { if ((x += y) >= P) x -= P; }\n\nvoid sub(int &x, int y) { if ((x -= y) < 0) x += P; }\n\nvoid exGcd(int a, int b, int &x, int &y) {\n  if (!b) {\n    x = 1;\n    y = 0;\n    return;\n  }\n  exGcd(b, a % b, y, x);\n  y -= a / b * x;\n}\n\nint inv(int a) {\n  int x, y;\n  exGcd(a, P, x, y);\n  return norm(x + P);\n}\n\nint main() {\n#ifdef ELEGIA\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, A;\n  cin >> n >> A;\n  n -= A;\n\n  int ans = 0;\n\n  vector<int> fafa(A + 1);\n\n  vector<vector<int>> dp(A + 1, vector<int>(A + 1));\n  vector<int> sum(A + 1), sum2(A + 1);\n  dp[0][0] = 1;\n  for (int i = 1; i <= A; ++i) {\n    dp[i][0] = simp.gifac(i - 1);\n    for (int j = i; j; --j) sum[j] = sum[j - 1]; sum[0] = 0;\n    for (int j = 0; j <= i; ++j) add(sum[j], dp[i - 1][j]);\n    for (int j = 0; j <= i; ++j) add(sum2[j], dp[i - 1][j]);\n    for (int j = 0; j < i; ++j) {\n      add(dp[i][j + 1], sum[j]);\n      sub(dp[i][j], sum2[j]);\n    }\n    for (int j = 0; j <= i; ++j)\n      dp[i][j] = dp[i][j] * (ll) simp.ginv(i) % P;\n  }\n  for (int i = 0; i <= A; ++i) {\n    for (int j = 0; j <= i; ++j)\n      add(fafa[i], dp[i][j] * (ll) simp.binom(n + j - 1, j - 1) % P);\n    //cerr << i << \": \" << (fafa[i] * (ll) simp.gfac(i) % P * simp.gfac(n) % P) << '\\n';\n  }\n\n  for (int i = 1; i <= A; ++i) add(fafa[i], fafa[i - 1]);\n  for (int i = 0; i <= A; ++i) {\n    int coe = 1;\n    if ((A - i) & 1) coe = P - 1;\n    add(ans, coe * (ll) simp.gifac(A - i) % P * fafa[i] % P);\n  }\n\n  ans = ans * (ll) simp.gfac(n) % P * simp.gfac(A) % P;\n  cout << ans << '\\n';\n\n#ifdef ELEGIA\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=10000005,M=5005,inf=0x3f3f3f3f,p=1000000007;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint qpow (int x,int k){\n\tint t=1;\n\tfor (;k;k>>=1){\n\t\tif (k&1) t=(ll)t*x%p;\n\t\tx=(ll)x*x%p;\n\t}\n\treturn t;\n}\nint n,m,fac[N],ifac[N],s[M][M],sum[M],f[M][M],g[M],ans;\nvoid check(int &x,int y){if((x+=y)>=p) x-=p;}\nint C(int n,int m){return (n<m) ? 0 : (ll)fac[n]*ifac[m]%p*ifac[n-m]%p;}\nint P(int n,int m){return (n<m) ? 0 : (ll)fac[n]*ifac[n-m]%p;}\nint main(){\n//\tfreopen(\"a.in\",\"r\",stdin);\n\tn=read();m=read();\n\tfac[0]=1;\n\tfor (int i=1;i<=n;i++) fac[i]=(ll)fac[i-1]*i%p;\n\tifac[n]=qpow(fac[n],p-2);\n\tfor (int i=n;i;i--) ifac[i-1]=(ll)ifac[i]*i%p;\n\ts[0][0]=sum[0]=1;\n\tfor(int i=1;i<=m;i++)\n\tfor(int j=1;j<=i;j++)\n\t\ts[i][j]=(s[i-1][j-1]+(ll)(i-1)*s[i-1][j])%p,check(sum[i],s[i][j]);\n\n\tf[0][0]=1;\n\tfor (int i=0;i<=m;i++)\n\tfor (int j=0;j<=i;j++){\n\t\tcheck(f[i][j],(ll)g[j]*ifac[m-i]%p);\n\t\tif (i!=0)\n\t\t\tcheck(ans,(ll)f[i][j]*P(n-m,j)%p*P(n-m-j+i-1,n-m-j)%p*sum[max(0,m-i-1)]%p);\n\t\tif (i!=m){\n\t\t\tcheck(f[i+1][j+1],f[i][j]);\n\t\t\tif (i!=0) check(g[j],(ll)f[i-1][j]*fac[m-(i-1)-1]%p);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint N, A; cin >> N >> A;\n\n\tusing num = modnum<int(1e9)+7>;\n\tvector<num> fact(N+1);\n\tfact[0] = 1; for (int i = 1; i <= N; i++) fact[i] = fact[i-1] * num(i);\n\tvector<num> ifact(N+1);\n\tifact[N] = inv(fact[N]); for (int i = N; i >= 1; i--) ifact[i-1] = ifact[i] * num(i);\n\tauto choose = [&](int n, int r) -> num {\n\t\tif (0 <= r && r <= n) return fact[n] * ifact[r] * ifact[n-r];\n\t\telse return num(0);\n\t};\n\n\tnum ans = 0;\n\tfor (int j = 0; j <= A; j++) {\n\t\tans += choose(A, j) * num(j & 1 ? -1 : 1) * fact[N-1-j] * (A-j);\n\t}\n\tfor (int j = 0; j <= A-2; j++) {\n\t\tfor (int k = 0; j+k <= A-2; k++) {\n\t\t\tans += fact[k] * num(j & 1 ? -1 : 1) * fact[N-1-(j+k+1)] * choose(A, j + k + 2) * num(j+1);\n\t\t}\n\t}\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Awwawa! Dis cold yis ratten buy tEMMIE!\n#include <bits/stdc++.h>\n#define ll long long\n#define maxn 10000005 /*rem*/\n#define mod 1000000007 \n#define db double\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n#define pi pair<int, int>\n#define fi first\n#define se second\n\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,true:false;}\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,true:false;}\n\nusing namespace std;\nll ksm(ll a, ll b) {\n   if (!b) return 1;\n   ll ns = ksm(a, b >> 1);\n   ns = ns * ns % mod;\n   if (b & 1) ns = ns * a % mod;\n   return ns;\n}\nint n, a;\nll jc[maxn], bjc[maxn];\nll bk[20005];\nll pr[5005]; // 恰有\nll tr[5005][5005]; // 有x个自环 钦定若干个不能是 \nll c(int a, int b) {\n\tif (b > a || b < 0) return 0;\n\treturn 1ll * jc[a] * bjc[b] % mod * bjc[a - b] % mod;\n} \nll dp[5005][5005]; //还剩若干个 要求若干个 \nll r[5005];\nll s[5005][5005];\nint main() {\n\tjc[0] = bjc[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t\tjc[i] = jc[i - 1] * i % mod;\n\tbjc[maxn - 1] = ksm(jc[maxn - 1], mod - 2);\n\tfor (int j = maxn - 2; j >= 0; j--)\n\t\tbjc[j] = bjc[j + 1] * (j + 1) % mod;\n\tfor (int i = 0; i < 20005; i++)\t\n\t\tbk[i] = ksm(i, mod - 2);\n\tint n, k;\n\tcin >> n >> k;\n\tfor (int i = 0; i < k; i++) {\n\t\t// 钦定i个数 假\n\t\tpr[i] = 1;\n\t\tpr[i] = pr[i] * jc[n - i - 1] % mod;\n\t\tpr[i] = pr[i] * bjc[k - i - 1] % mod; \n\t}\n\tfor (int i = 0; i <= k; i++) // 有i个必须交互 j个数不能和后面交互 \n\t\tfor (int j = 0; j <= k - i; j++) {\n\t\t\t//要求i不能是 j必须是\n\t\t\tll er = 0;\n\t\t\tif (i == 0) er = pr[j];\n\t\t\telse {\n\t\t\t\ter = tr[i - 1][j] - tr[i - 1][j + 1];\n\t\t\t\ter %= mod;\n\t\t\t\tif (er < 0) er += mod;\n\t\t\t}\n\t\t\ttr[i][j] = er;\n\t\t}\n\tfor (int i = 0; i <= k; i++)\n\t\tfor (int j = 0; j <= k - i; j++) { // 有j个限制 剩余长度是i \n\t\t\tll mt = bk[i];\n\t\t\tif (i == 0) mt = 1;\n\t\t\tdp[i][j] = tr[j][i] * mt % mod;// * bk[i] % mod; // 当前点要求是自环 \n\t\t\tdp[i][j] += (s[i - 1][j] - dp[i - 1][j] + dp[i - 1][j + 1]) % mod * bk[i] % mod;\n\t\t\tdp[i][j] %= mod;\n\t\t\tif (i) s[i][j] = s[i - 1][j];\n\t\t\ts[i][j] = (s[i][j] + dp[i][j]) % mod;\n\t\t}\n\tll ans = dp[k][0];\n\tans %= mod;\n\tans = ans * jc[k] % mod;\n\tans %= mod;\n\tif (ans < 0) ans += mod;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define ll long long\n//{{{ read()\ninline ll read(){\n\tregister ll x=0,f=1;\n\tregister char ch=getchar();\n\twhile(ch<'0'||ch>'9'){\n\t\tif(ch=='-')\tf=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\tx=x*10+(ch^48),ch=getchar();\n\treturn x*f;\n}\n//}}}\nconst int P=1e9+7;\nconst int N=1e7+5;\nll ans,fac[N],iac[N],inv[N];\nll C(int n,int m){\n\tif(n<m)\treturn 0;\n\treturn fac[n]*iac[m]%P*iac[n-m]%P;\n}\nint calc(int a,int b,int c){\n\treturn fac[a+b+c]*a%P*inv[a+c]%P;\n}\nint n,m;\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read(),m=read(),inv[1]=iac[0]=fac[0]=1;\n\tfor(int i=1;i<=n;i++)\tfac[i]=fac[i-1]*i%P;\n\tfor(int i=2;i<=n;i++)\tinv[i]=(P-P/i)*inv[P%i]%P;\n\tfor(int i=1;i<=n;i++)\tiac[i]=iac[i-1]*inv[i]%P;\n\tfor(int i=0;i<=m;i++){\n\t\tif(i&1)\tans=(ans-C(m,i)*calc(m-i,0,n-m)%P+P)%P;\n\t\telse\tans=(ans+C(m,i)*calc(m-i,0,n-m))%P;\n\t}\n\tfor(int i=1;i<=m;i++)\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(j&1)\tans=(ans-C(i-1,j)*calc(i-j-1,m-i,n-m)%P+P)%P;\n\t\t\telse\tans=(ans+C(i-1,j)*calc(i-j-1,m-i,n-m))%P;\n\t\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#ifdef CURIOUSCAT\n#define Pr(f,...) fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n#else\n#define Pr(f,...) \n#endif\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int P=1e9+7,oo=P;\n\nint mul(int a,int b){ return 1ll*a*b%P; }\nint add(int a,int b){ a+=b; return a>=P?a-P:a; }\nvoid upd(int &a,int b){ a=add(a,b); }\nint sub(int a,int b){ a-=b; return a<0?a+P:a; }\nint gcd(int a,int b){ return !b?a:gcd(b,a%b); }\n\nconst int N=1e7+50;\nint n,fac[N],a,ans,inv[N],facinv[N];\nint C(int n,int m){\n\tif(n<0||m>n)return 0;\n\treturn mul(fac[n],mul(facinv[m],facinv[n-m])); \n}\n\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n\tfreopen(\"d.in\",\"r\",stdin); \n#endif\n\tread(n),read(a); \n\tfac[0]=1; \n\trep(i,1,n)fac[i]=mul(fac[i-1],i);\n\tinv[1]=1; \n\trep(i,2,n)inv[i]=mul(P-P/i,inv[P%i]); \n\tfacinv[0]=1; \n\trep(i,1,n)facinv[i]=mul(facinv[i-1],inv[i]);\n\trep(t,2,a+1){\n\t\tint x=t-1,y=n-a,z=max(0,a-t);\n\t\t//Pr(\"%d,%d,%d\\n\",x,y,z);\n\t\trep(d,0,a){\n\t\t\tint w=mul(C(x,d),mul(x-d,inv[x-d+y]));\n\t\t\tw=mul(w,fac[x-d+y+z]);\n\t\t\tif(d&1)ans=sub(ans,w);else ans=add(ans,w);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n\nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n\nint main()\n{\n  ll n,a,ans=0,co[5100]={};\n  cin >> n >> a;\n  ll dp[5005][5005][3]={};\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[i][j][2]*KAI(i)%MOD*KAI(n-a)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int P = 1e9 + 7;\n\nstruct modint {\n    int x;\n    inline modint(int x = 0) : x(x) {}\n    inline modint &operator = (int o) { return x = o, *this; }\n    inline modint &operator += (modint o) { return (x += o.x) >= P && (x -= P), *this; }\n    inline modint &operator -= (modint o) { return (x -= o.x) < 0 && (x += P), *this; }\n    inline modint &operator *= (modint o) { return x = 1ll * x * o.x % P, *this; }\n    inline modint &operator ^= (ll b) {\n        modint a = *this, c;\n        if (!~b) b = P - 2;\n        c.x = 1 % P;\n        while (b) {\n            if (b & 1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return x = c.x, *this;\n    }\n    inline modint &operator /= (modint o) { return *this *= o ^ -1; }\n    inline modint &operator += (int o) { return (x += o) >= P && (x -= P), *this; }\n    inline modint &operator -= (int o) { return (x -= o) < 0 && (x += P), *this; }\n    inline modint &operator *= (int o) { return x = 1ll * x * o % P, *this; }\n    inline modint &operator /= (int o) { return *this *= (modint)o ^ -1; }\n    template <class I>\n    inline friend modint operator + (modint a, I b) { return a += b; }\n    template <class I>\n    inline friend modint operator - (modint a, I b) { return a -= b; }\n    template <class I>\n    inline friend modint operator * (modint a, I b) { return a *= b; }\n    inline friend modint operator ^ (modint a, ll b) { return a ^= b; }\n    template <class I>\n    inline friend modint operator / (modint a, I b) { return a /= b; }\n    inline friend bool operator == (modint a, int b) { return a.x == b; }\n    inline friend bool operator != (modint a, int b) { return a.x != b; }\n    inline friend bool operator < (modint a, int b) { return a.x < b; }\n    inline friend bool operator <= (modint a, int b) { return a.x <= b; }\n    inline friend bool operator > (modint a, int b) { return a.x > b; }\n    inline friend bool operator >= (modint a, int b) { return a.x >= b; }\n    inline friend bool operator == (modint a, modint b) { return a.x == b.x; }\n    inline friend bool operator != (modint a, modint b) { return a.x != b.x; }\n    inline friend bool operator < (modint a, modint b) { return a.x < b.x; }\n    inline friend bool operator <= (modint a, modint b) { return a.x <= b.x; }\n    inline friend bool operator > (modint a, modint b) { return a.x > b.x; }\n    inline friend bool operator >= (modint a, modint b) { return a.x >= b.x; }\n    inline bool operator ! () { return !x; }\n    inline modint operator - () { return x ? P - x : 0; }\n};\ninline void rd(modint &x) { rd(x.x); }\ninline void print(modint x, char k = '\\n') { print(x.x, k); }\n\nconst int NP = 1e7 + 7;\nmodint p[NP], v[NP], vp[NP];\ninline void init(int n) {\n  p[0] = v[0] = 1;\n  for (int i = 1; i <= n; i++) p[i] = p[i-1] * i;\n  vp[n] = 1 / p[n];\n  for (int i = n; i; i--) v[i] = vp[i] * p[i-1], vp[i-1] = vp[i] * i;\n}\ninline modint binom(int n, int m) {\n  return (m < 0 || n < m) ? 0 : p[n] * vp[m] * vp[n-m];\n}\n\nint main() {\n\tint n, a;\n\tmodint ans;\n\trd(n, a), init(n);\n\tfor (int t = 2; t <= a + 1; t++) {\n\t\tint x = t - 1, y = max(a - t, 0), z = n - a;\n\t\tfor (int i = 0; i <= x; i++)\n\t\t\tif (i & 1) ans -= binom(x, i) * (x - i) * v[x-i+z] * p[x-i+y+z];\n\t\t\telse ans += binom(x, i) * (x - i) * v[x-i+z] * p[x-i+y+z];\n\t}\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nvector<int> fact;\nvector<int> ifact;\nvector<int> inv;\nvector<int> pow2;\nconst int MOD = (1e9 + 7);\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nvoid radd(int &a, int b)\n{\n\ta=add(a,b); \n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nvoid rmult(int &a, int b)\n{\n\ta=mult(a,b);\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\nint choose(int a, int b)\n{\n\tif(a<b) return 0;\n\tif(b==0) return 1;\n\tif(a==b) return 1;\n\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n}\nint inverse(int a)\n{\n\treturn modpow(a,MOD-2);\n}\nvoid init(int _n)\n{\n\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\tfact.resize(_n+1);\n\tifact.resize(_n+1);\n\tinv.resize(_n+1);\n\tpow2.resize(_n+1);\n\tpow2[0]=1;\n\tifact[0]=1;\n\tfact[0]=1;\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\tfact[i]=mult(fact[i-1],i);\n\t\t//ifact[i]=mult(ifact[i-1],inv[i]);\n\t}\n\tifact[_n] = inverse(fact[_n]);\n\tfor(int i=_n-1;i>=1;i--)\n\t{\n\t\tifact[i] = mult(ifact[i + 1], i + 1);\n\t}\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tinv[i] = mult(fact[i-1],ifact[i]);\n\t}\n}\n\nint dp[5555];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tinit(10111111);\n\tint n,a; cin>>n>>a;\n\tfor(int i=1;i<=a+1;i++)\n\t{\n\t\t//at least one loop at i\n\t\t//i+1 to a are ignored\n\t\tint A = i-1; //good prefix\n\t\tint B = n-a; //bad suffix\n\t\tdp[i]=mult(((i>a)?fact[n]:fact[n-1]),mult(A,inv[A+B]));\n\t\tfor(int j=1;j<i;j++) \n\t\t{\n\t\t\tint sgn=((j&1)?MOD-1:1);\n\t\t\tsgn=mult(sgn,choose(i-1,j));\n\t\t\t//if exist j loops before\n\t\t\tint A = i-1-j;\n\t\t\tint B = n-a;\n\t\t\tint val = mult(((i>a)?fact[n-j]:fact[n-j-1]),mult(A,inv[A+B]));\n\t\t\tradd(dp[i],mult(sgn,val));\n\t\t}\n\t\t//cerr<<i<<' '<<dp[i]<<'\\n';\n\t}\n\tint sum=0;\n\tfor(int i=1;i<=a+1;i++) radd(sum,dp[i]);\n\tcout<<sum<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nstruct modinfo{uint mod,root;};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(int n)const{\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(int x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(int x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(int x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(int x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n//extern constexpr modinfo base{998244353,3};\nextern constexpr modinfo base{1000000007,0};\n//modinfo base{1,0};\nusing mint=modular<base>;\n\nconst int vmax=ten(7)+10;\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\nmint sub(int a,int b,int c){\n\treturn fact[a+b+c]*a*invs[a+b];\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n,a;cin>>n>>a;\n\tint b=n-a;\n\t\n\tmint res;\n\trep(i,a){\n\t\tmint w=choose(a,i)*sub(a-i,b,0);\n\t\tif(i%2==0)res+=w;\n\t\telse res-=w;\n\t}\n\trep(i,a)rep(j,i){\n\t\tmint w=choose(i,j)*sub(i-j,b,a-i-1);\n\t\tif(j%2==0)res+=w;\n\t\telse res-=w;\n\t}\n\t\n\tcout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  ll n,a,dp[5100][5100][3]={},ans=0,co[5100]={};\n  cin >> n >> a;\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[i][j][2]*KAI(i)%MOD*KAI(n-a)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nconst int P = 1e9 + 7;\nconst int N = 1e7 + 7;\nint spow(int a, int b) {\n  int r = 1;\n  while (b) {\n    if (b % 2) {\n      r = r * a % P;\n    }\n    a = a * a % P;\n    b /= 2;\n  }\n  return r;\n}\nint fac[N];\nint inv_fac[N];\nint Newt(int a, int b) {\n  return fac[a] * inv_fac[a - b] % P * inv_fac[b] % P;\n}\nint Prod(int a, int len) {\n  return fac[a + len - 1] * inv_fac[a - 1] % P;\n}\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  // policzmy takie permutacje ze wsrod pierwszych k nie ma petli i kazdy cykl zawiera cos z tych pierwszych k\n  // zafiksujmy sobie zbior petelek przez incl-excl\n  // k! * (k-petle)*(k+1)*...*(n-1)\n  int n, a;\n  cin>>n>>a;\n  fac[0] = 1;\n  RE (i, n) {\n    fac[i] = i * fac[i - 1] % P;\n  }\n  inv_fac[n] = spow(fac[n], P - 2);\n  FORD (i, n - 1, 0) {\n    inv_fac[i] = inv_fac[i + 1] * (i + 1) % P;\n  }\n  // mamy k-petle dozwolonych\n  // jak k<a to mamy jedno mniej\n  // (k-petle)! * (k-petle)*(k-petle+1)*...*(n-petle-1)\n  int res = 0;\n  RE (k, a) {\n    int outer = 0;\n    FOR (petle, 0, k - 1) {\n      int inner = Newt(k, petle);\n      inner = inner * fac[k - petle] % P;\n      if (k < a) {\n        inner = inner * Prod(k - petle, n - a) % P;\n        inner = inner * Prod(n - a + 1 + k - petle, a - k - 1) % P;\n      } else {\n        inner = inner * Prod(k - petle, n - a) % P;\n      }\n        //inner = inner * fac[n - (k < a) - petle - 1] % P;\n//       if (k-petle-1 >= 0) {\n//         inner = inner * inv_fac[k - 1 - petle] % P;\n//       } else {\n//         inner = 0;\n      //}\n      debug(k, petle, inner);\n      if (petle % 2 == 0) {\n        outer = (outer + inner) % P;\n      } else {\n        outer = (outer - inner + P) % P;\n      }\n    }\n    debug(k, outer);\n    res = (res + outer) % P;\n  }\n  cout<<res<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>bool chmax(t&a,u b){if(a<b)a=b;return a<b;}\ntemplate<class t,class u>bool chmin(t&a,u b){if(b<a)a=b;return b<a;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n\tint size(){\n\t\treturn v.size();\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\n//uint MODULAR=998244353;\nuint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\nll n,a;\nMint dp[5005][5005],ans;\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>n>>a;\n\tInitfact(n);\n\tif(n==a){\n\t\tprint(fact[n]);\n\t\treturn 0;\n\t}\n\tdp[0][0]=1;\n\tfor(int i=0;i<=a;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(dp[i][j]==0)continue;\n\t\t\t//cout<<i<<' '<<j<<' '<<dp[i][j]<<endl;\n\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\tdp[i+1][j]+=dp[i][j]*Mint(i-j);\n\t\t\tif(j>0)dp[i+1][j-1]+=dp[i][j]*Mint(j);\n\t\t\tif(i>0&&j<=n-a){\n\t\t\t\tMint s=fact[n-a]*comb(i-1+n-a-j,i-1);\n\t\t\t\tif(i<a)ans+=dp[i][j]*s*fact[a-i-1];\n\t\t\t\telse ans+=dp[i][j]*s;\n\t\t\t}\n\t\t}\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  ll n,a,dp[5100][5100][3]={},ans=0,co[10000010]={};\n  cin >> n >> a;\n  co[0]=1;\n  rep(i,10000005)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[i][j][2]*KAI(i)%MOD*KAI(n-a)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef unsigned u32;\ntypedef unsigned long long u64;\nconst u32 P=1e9+7;\nconst int N=1e7+5;\nu32 fac[N], ifac[N], inv[N];\nu64 power(u64 a, int b) {\n\tu64 ans=1;\n\tfor(; b; a=a*a%P, b/=2) {\n\t\tif(b&1) ans=ans*a%P;\n\t}\n\treturn ans;\n}\nint main() {\n\tint n, a;\n\tu32 ans=0;\n\tscanf(\"%d%d\", &n, &a);\n\tfac[0]=1;\n\tfor(int i=1; i<=n; ++i) fac[i]=1llu*fac[i-1]*i%P;\n\tifac[n]=power(fac[n], P-2);\n\tfor(int i=n; i--; ) ifac[i]=(i+1llu)*ifac[i+1]%P;\n\tfor(int i=1; i<=n; ++i) inv[i]=1llu*ifac[i]*fac[i-1]%P;\n\tfor(int i=1; i<=a; ++i) {\n\t\tfor(int k=0; k<i-1; ++k) {\n\t\t\tu32 cur=1llu*fac[i-1]*ifac[k]%P*fac[n-k-1]%P*ifac[i-k-2]%P*inv[i-k+n-a-1]%P;\n\t\t\tif(k&1)\n\t\t\t\tans=(ans+P-cur)%P;\n\t\t\telse\n\t\t\t\tans=(ans+cur)%P;\n\t\t}\n\t}\n\tfor(int k=0; k<=a; ++k) {\n\t\tu32 cur=1llu*fac[a]*ifac[k]%P*fac[n-k-1]%P*ifac[a-k-1]%P;\n\t\tif(k&1)\n\t\t\tans=(ans+P-cur)%P;\n\t\telse\n\t\t\tans=(ans+cur)%P;\n\t}\n\tprintf(\"%u\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nnamespace IO\n{\nchar gc()\n{\n#ifdef FREAD\n\tstatic char buf[1<<21], *P1 = buf, *P2 = buf;\n\tif(P1 == P2)\n\t{\n\t\tP1 = buf;\n\t\tP2 = buf + fread(buf, 1, 1<<21, stdin);\n\t\tif(P1 == P2) return EOF;\n\t}\n\treturn *(P1++);\n#else\n\treturn getchar();\n#endif\n}\ntemplate<typename Tp> bool get1(Tp &x)\n{\n\tbool neg = 0;\n\tchar c = gc();\n\twhile( c != EOF && (c < '0' || c > '9') && c != '-' ) c = gc();\n\tif(c == '-') c = gc(), neg = 1;\n\tif(c == EOF) return false;\n\tx = 0;\n\tfor(; c>='0' && c<='9'; c = gc()) x = x*10 + c - '0';\n\tif(neg) x = -x;\n\treturn true;\n}\ntemplate<typename Tp> void printendl(Tp x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tstatic short a[40], sz;\n\tsz = 0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n\tputs(\"\");\n}\n} // namespace IO\nusing IO::get1;\nusing IO::printendl;\n#define get2(x,y) get1(x) && get1(y)\n#define get3(x,y,z) get2(x,y) && get1(z)\n#define get4(x,y,z,w) get3(x,y,z) && get1(w)\n#define pb push_back\n#define mp std::make_pair\n#define ff first\n#define ss second\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef std::pair<int,int> pii;\nconst int inf = 0x3f3f3f3f;\nconst LL Linf = 1ll<<61;\n\nconst int maxn = 10000111;\nconst int maxa = 5111;\nconst int mod = 1e9 + 7;\nint qpow(int x, int y)\n{\n\tint ret = 1;\n\twhile(y)\n\t{\n\t\tif(y & 1) ret = 1ll * ret * x % mod;\n\t\tx = 1ll * x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn ret;\n}\n\nint n, a, fac[maxn], inv[maxn], c[maxa][maxa];\nint main()\n{\n\tfac[0] = 1; for(int i=1; i<maxn; i++) fac[i] = 1ll * i * fac[i-1] % mod;\n\tinv[1] = 1; for(int i=2; i<maxn; i++) inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;\n\tfor(int i=0; i<maxa; i++)\n\t{\n\t\tc[i][0] = 1;\n\t\tfor(int j=1; j<=i; j++)\n\t\t{\n\t\t\tc[i][j] = c[i-1][j] + c[i-1][j-1];\n\t\t\tif(c[i][j] >= mod) c[i][j] -= mod;\n\t\t}\n\t}\n\t\n\tget2(n, a);\n\t\n\tint ans = 0;\n\tfor(int i=1; i<=a; i++)\n\t{\n\t\tint sum = 1ll * fac[i == a ? n : n - 1] * i % mod * inv[i + n - a] % mod;\n\t\tfor(int j=1; j<i; j++)\n\t\t{\n\t\t\tint now = 1ll * c[i][j] * fac[(i == a ? n : n - 1) - j] % mod * (i - j) % mod * inv[i - j + n - a] % mod;\n\t\t\tif(j & 1)\n\t\t\t{\n\t\t\t\tsum -= now;\n\t\t\t\tif(sum < 0) sum += mod;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsum += now;\n\t\t\t\tif(sum >= mod) sum -= mod;\n\t\t\t}\n\t\t}\n\t\tans += sum;\n\t\tif(ans >= mod) ans -= mod;\n\t}\n\tprintendl(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing R = __int128;\nusing pii = pair<int, int>;\ntemplate <class T>\nusing V = vector<T>;\ntemplate <class T>\nusing VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for (int i = m; i < (n); i++)\n#define per(i, b) per2(i, 0, b)\n#define per2(i, a, b) for (int i = int(b) - 1; i >= int(a); i--)\n#define ALL(c) (c).begin(), (c).end()\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <class T, class U>\nvoid chmin(T& t, const U& u) {\n    if (t > u) t = u;\n}\ntemplate <class T, class U>\nvoid chmax(T& t, const U& u) {\n    if (t < u) t = u;\n}\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"{\";\n    rep(i, v.size()) {\n        if (i) os << \",\";\n        os << v[i];\n    }\n    os << \"}\";\n    return os;\n}\n\n#ifdef LOCAL\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << H;\n    debug_out(T...);\n}\n#define debug(...) \\\n    cerr << __LINE__ << \" [\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else\n#define debug(...) (void(0))\n#define dump(x) (void(0))\n#endif\n\ntemplate <unsigned int MOD>\nstruct ModInt {\n    using uint = unsigned int;\n    using ull = unsigned long long;\n    using M = ModInt;\n\n    uint v;\n\n    ModInt(ll _v = 0) { set_norm(_v % MOD + MOD); }\n    M& set_norm(uint _v) {  //[0, MOD * 2)->[0, MOD)\n        v = (_v < MOD) ? _v : _v - MOD;\n        return *this;\n    }\n\n    explicit operator bool() const { return v != 0; }\n    M operator+(const M& a) const { return M().set_norm(v + a.v); }\n    M operator-(const M& a) const { return M().set_norm(v + MOD - a.v); }\n    M operator*(const M& a) const { return M().set_norm(ull(v) * a.v % MOD); }\n    M operator/(const M& a) const { return *this * a.inv(); }\n    M& operator+=(const M& a) { return *this = *this + a; }\n    M& operator-=(const M& a) { return *this = *this - a; }\n    M& operator*=(const M& a) { return *this = *this * a; }\n    M& operator/=(const M& a) { return *this = *this / a; }\n    M operator-() const { return M() - *this; }\n    M& operator++(int) { return *this = *this + 1; }\n    M& operator--(int) { return *this = *this - 1; }\n\n    M pow(ll n) const {\n        if (n < 0) return inv().pow(-n);\n        M x = *this, res = 1;\n        while (n) {\n            if (n & 1) res *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    M inv() const {\n        ll a = v, b = MOD, p = 1, q = 0, t;\n        while (b != 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(p -= t * q, q);\n        }\n        return M(p);\n    }\n\n    bool operator==(const M& a) const { return v == a.v; }\n    bool operator!=(const M& a) const { return v != a.v; }\n    friend ostream& operator<<(ostream& os, const M& a) { return os << a.v; }\n    static uint get_mod() { return MOD; }\n};\n\nusing Mint = ModInt<1000000007>;\n\nconst int maxv = TEN(7) * 2;\n\nV<Mint> fact(maxv), ifact(maxv), inv(maxv);\n\nvoid init() {\n    fact[0] = 1;\n    for (int i = 1; i < maxv; ++i) {\n        fact[i] = fact[i - 1] * i;\n    }\n\n    ifact[maxv - 1] = fact[maxv - 1].inv();\n\n    for (int i = maxv - 2; i >= 0; --i) {\n        ifact[i] = ifact[i + 1] * (i + 1);\n    }\n\n    for (int i = 1; i < maxv; ++i) {\n        inv[i] = ifact[i] * fact[i - 1];\n    }\n}\n\nMint comb(int n, int r) {\n    if (n < 0 || r < 0 || r > n) return Mint(0);\n    return fact[n] * ifact[r] * ifact[n - r];\n}\n\nint main() {\n    init();\n    int N, A;\n    cin >> N >> A;\n    Mint ans;\n\n    rep(s, A + 1) {\n        // smallest s, p_s != s\n        Mint val;\n        for (int fr = 0; fr <= s; ++fr) {\n            int p = fr, q = max(0, A - s - 1), r = N - A;\n            Mint t = fact[p + q + r] * p * inv[p + r] * comb(s, fr);\n            if ((s - fr) & 1) t = -t;\n            val += t;\n        }\n        ans += val;\n    }\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing v_bool = vector<bool>;\nusing v_Pii = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n    mint Catalan(int n){\n        if(n < 0) return 0;\n        else if(n == 0) return 1;\n        if(fact.size() < 2 * n + 1) fact_initialize(2 * n);\n        return fact[2 * n] * invfact[n + 1] * invfact[n];\n    }\n\n};\n\n\n\nsigned main(){\n\n    int N, A; cin >> N >> A;\n    int B = N - A;\n\n    mmat dp(A + 1, mvec(A + 1, 0));\n    Combination C(N);\n    \n    REP(j, A + 1) dp[1][j] = C.fact[B + j];\n    FOR(n, 2, A + 1){\n        REP(i, n + 1){\n            if(i % 2 == 0) dp[n][0] += C.nCr(n, i) * C.fact[n - i] * C.nPr(n - i + B - 1, B);\n            else dp[n][0] -= C.nCr(n, i) * C.fact[n - i] * C.nPr(n - i + B - 1, B);\n        }\n\n        FOR(j, 1, A + 1){\n            dp[n][j] = (mint)(n - 1) * (dp[n - 2][j] + dp[n - 1][j]) + (mint)(B + j) * (dp[n - 1][j - 1] + dp[n][j - 1]);\n        }\n    }\n    \n    mint ans = dp[A][0];\n    FOR(n, 1, A){\n        int m = A - n - 1;\n        REP(k, m + 1) ans += C.nCr(m, k) * C.fact[m - k] * dp[n][k];\n    }\n\n\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  ll n,a,dp[51][51][5]={},ans=0,co[5100]={};\n  cin >> n >> a;\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[i][j][2]*KAI(i)%MOD*KAI(n-a)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nCode for problem D by cookiedoth\nGenerated 08 Jun 2020 at 07.26 PM\n\n\n█▒▒▒▒▒▒▒▒▒\n10%\n███▒▒▒▒▒▒▒\n30%\n█████▒▒▒▒▒\n50%\n███████▒▒▒\n70%\n██████████\n100%\n\nz_z\n>_<\no_O\n\n*/\n\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <ctime>\n#include <functional>\n#include <unordered_set>\n#include <unordered_map>\n#include <string>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <complex>\n#include <cassert>\n#include <random>\n#include <cstring>\n#include <numeric>\n#define ll long long\n#define ld long double\n#define null NULL\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define debug(a) cerr << #a << \" = \" << a << endl\n#define forn(i, n) for (int i = 0; i < n; ++i)\n#define sz(a) (int)a.size()\n\nusing namespace std;\n\ntemplate<class T> int chkmax(T &a, T b) {\n\tif (b > a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class T> int chkmin(T &a, T b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class iterator> void output(iterator begin, iterator end, ostream& out = cerr) {\n\twhile (begin != end) {\n\t\tout << (*begin) << \" \";\n\t\tbegin++;\n\t}\n\tout << endl;\n}\n\ntemplate<class T> void output(T x, ostream& out = cerr) {\n\toutput(x.begin(), x.end(), out);\n}\n\nvoid fast_io() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n}\n\nconst int MOD = 1e9 + 7;\n\nvoid add(int &a, int b) {\n\ta += b;\n\tif (a >= MOD) {\n\t\ta -= MOD;\n\t}\n}\n\nint mul(int a, int b) {\n\treturn (1LL * a * b) % MOD;\n}\n\nint power(int a, int deg) {\n\tint res = 1;\n\tfor (; deg; deg >>= 1, a = mul(a, a)) {\n\t\tif (deg & 1) {\n\t\t\tres = mul(res, a);\n\t\t}\n\t}\n\treturn res;\n}\n\nint inverse(int a) {\n\treturn power(a, MOD - 2);\n}\n\nconst int MX = 1e7 + 10;\nint fact[MX], inv[MX], _fact[MX];\n\nvoid calc_fact() {\n\tinv[1] = 1;\n\tfor (int i = 2; i < MX; ++i) {\n\t\tinv[i] = mul(MOD - MOD / i, inv[MOD % i]);\n\t}\n\tfact[0] = 1;\n\t_fact[0] = 1;\n\tfor (int i = 1; i < MX; ++i) {\n\t\tfact[i] = mul(fact[i - 1], i);\n\t\t_fact[i] = mul(_fact[i - 1], inv[i]);\n\t}\n}\n\nint func(int a, int b, int c) {\n\treturn mul(mul(fact[a + b + c], a), inv[a + b]);\n}\n\nint C(int n, int k) {\n\treturn (k > n ? 0 : mul(fact[n], mul(_fact[k], _fact[n - k])));\n}\n\nint A, n;\n\nsigned main() {\n\tfast_io();\n\tcalc_fact();\n\tcin >> n >> A;\n\tint ans = 0;\n\tfor (int i = 0; i <= A; ++i) {\n\t\tint c = max(0, A - 1 - i);\n\t\tfor (int bad = 0; bad <= i; ++bad) {\n\t\t\tint sign = (bad % 2 ? MOD - 1 : 1);\n\t\t\tint curC = C(i, bad);\n\t\t\tadd(ans, mul(sign, mul(curC, func(i - bad, n - A, c))));\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\nusing namespace std;\nconst int mo=1000000007;\nconst int N=10000005;\nconst int M=5005;\nint fac[N],inv[N],Inv[N];\nint n,m,f[M][M],g[M][M];\nvoid init(){\n\tfac[0]=inv[0]=inv[1]=Inv[0]=1;\n\tFor(i,2,N-1) inv[i]=1ll*inv[mo%i]*(mo-mo/i)%mo;\n\tFor(i,1,N-1) Inv[i]=1ll*Inv[i-1]*inv[i]%mo;\n\tFor(i,1,N-1) fac[i]=1ll*fac[i-1]*i%mo;\n}\nint C(int x,int y){\n\treturn 1ll*fac[x]*Inv[y]%mo*Inv[x-y]%mo;\n}\nint main(){\n\tinit();\n\tscanf(\"%d%d\",&n,&m);\n\tFor(i,0,m) f[i][0]=1ll*fac[i+n-m-1]*i%mo;\n\tFor(i,0,m) For(j,1,m-i){\n\t\tint val=1ll*f[i][0]*C(i+j,i)%mo;\n\t\tf[i+j][0]=(f[i+j][0]+mo-val)%mo;\n\t\tf[i+j][j]=val;\n\t}\n\tFor(i,1,m) For(j,0,m-i){\n\t\tg[i][j]=f[i-1][j];\n\t\tg[i][j]=(g[i][j]+1ll*g[i-1][j]*(n-m+i-(j+1)))%mo;\n\t\tg[i][j]=(g[i][j]+1ll*g[i-1][j+1]*(j+1))%mo;\n\t}\n\tint ans=(g[m][0]+f[m][0])%mo;\n\tcout<<ans<<endl;\n}\n/*\n>_<\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>bool chmax(t&a,u b){if(a<b)a=b;return a<b;}\ntemplate<class t,class u>bool chmin(t&a,u b){if(b<a)a=b;return b<a;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n\tint size(){\n\t\treturn v.size();\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\n//uint MODULAR=998244353;\nuint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\nll n,a;\nMint dp[5005][5005],ans;\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>n>>a;\n\tInitfact(n);\n\tif(n==a){\n\t\tprint(fact[n]);\n\t\treturn 0;\n\t}\n\tdp[0][0]=1;\n\tfor(int i=0;i<=a;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(dp[i][j]==0)continue;\n\t\t\t//cout<<i<<' '<<j<<' '<<dp[i][j]<<endl;\n\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\tdp[i+1][j]+=dp[i][j]*Mint(i-j);\n\t\t\tif(j>0)dp[i+1][j-1]+=dp[i][j]*Mint(j);\n\t\t\tif(i>0){\n\t\t\t\tif(i==a){\n\t\t\t\t\tif(j<=n-a)ans+=fact[n-a]*comb(i-1+n-a-j,i-1)*dp[i][j];\n\t\t\t\t}else{\n\t\t\t\t\tfor(int k=0;k+i+1<=a;k++){\n\t\t\t\t\t\tif(j<=n-a+k)ans+=fact[n-a+k]*comb(i-1+n-a+k-j,i-1)*dp[i][j]*fact[a-i-1-k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  ll n,a,dp[5100][5100][5]={},ans=0,co[5100]={};\n  cin >> n >> a;\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=KAI(i)%MOD*KAI(n-a)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define pb push_back\n#define SZ(x) ((int)x.size()-1)\n#define ms(a,b) memset(a,b,sizeof a)\n#define F(i,a,b) for (int i=(a);i<=(b);++i)\n#define DF(i,a,b) for (int i=(a);i>=(b);--i)\nusing namespace std;\ninline int read(){\n\tchar ch=getchar(); int w=1,c=0;\n\tfor(;!isdigit(ch);ch=getchar()) if (ch=='-') w=-1;\n\tfor(;isdigit(ch);ch=getchar()) c=(c<<1)+(c<<3)+(ch^48);\n\treturn w*c;\n}\nconst int mod=1e9+7,M=1e7+10;\nLL fast(LL x,LL p){\n\tLL ret=1;\n\tfor (;p;p>>=1,x=x*x%mod) if (p&1) ret=ret*x%mod; \n\treturn ret; \n} \nLL fac[M],iv[M],inv[M];\nint n,A;\nint main(){\n\tn=read(); A=read();\n\tfac[0]=1; F(i,1,n) fac[i]=fac[i-1]*i%mod;\n\tinv[n]=fast(fac[n],mod-2); \n\tDF(i,n,1) inv[i-1]=inv[i]*i%mod;\n\tF(i,1,n) iv[i]=fast(i,mod-2);\n\tLL ans=0;\n\tF(i,2,A+1){\n\t\tint x=i-1,z=n-A,y=max(0,A-i);\n\t\tF(t,0,x){\n\t\t\tif (t&1) ans=(mod-fac[x]*inv[t]%mod*inv[x-t]%mod*(x-t)%mod*iv[x+z-t]%mod*fac[x+y+z-t]%mod+ans)%mod; \n\t\t\telse  ans=(fac[x]*inv[t]%mod*inv[x-t]%mod*(x-t)%mod*iv[x+z-t]%mod*fac[x+y+z-t]+ans)%mod; \n\t\t}\n\t}\n\tcout<<ans<<'\\n'; \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  ll n,a,dp[5100][5100][5]={},ans=0,co[5100]={};\n  cin >> n >> a;\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[i][j][2]%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod = 1e9 + 7;\nconst int N = 1e7 + 5;\nint fac[N], ifac[N], inv[N];\n\nint mul(int x, int y) { return x * 1ll * y % mod; }\nint add(int x, int y) { return x+y < mod ? x+y : x+y-mod; }\nint sub(int x, int y) { return x-y < 0 ? x-y+mod: x-y; }\nint norm(int x) { return x < 0 ? add(x, mod) : sub(x, mod); }\ntemplate<class T, class... O> int mul(T x, O... y) { return mul(x, mul(y...)); }\n\nint main() {\n  int n, a; cin >> n >> a;\n  fac[0] = ifac[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    fac[i] = mul(fac[i-1], i);\n    inv[i] = i == 1 ? 1 : mod - mul(mod / i, inv[mod % i]);\n    ifac[i] = mul(ifac[i-1], inv[i]);\n  }\n  int ans = 0;\n  for (int i = 1; i <= a+1; i++) // [1 .. i-1]\n    for (int j = 0; j+1 < i; j++) // j singletons before\n      ans = norm(ans + ((j & 1) ? -1 : 1) * mul(fac[i-1], ifac[j], ifac[i-2-j], fac[n-j-1], i == a+1 ? 1 : inv[n-a+i-1-j]));\n  cout << ans << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define trav(x,a) for (auto& x: a)\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(), x.end()\n#define mem(a,v) memset((a), (v), sizeof (a))\n#define enl printf(\"\\n\")\n#define case(t) printf(\"Case #%d: \", (t))\n#define ni(n) scanf(\"%d\", &(n))\n#define nl(n) scanf(\"%lld\", &(n))\n#define nai(a, n) for (int _i = 0; _i < (n); _i++) ni(a[_i])\n#define nal(a, n) for (int _i = 0; _i < (n); _i++) nl(a[_i])\n#define pri(n) printf(\"%d\\n\", (n))\n#define prl(n) printf(\"%lld\\n\", (n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define vii vector<pii>\n#define vll vector<pll>\n#define vi vector<int>\n#define vl vector<long long>\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef cc_hash_table<int,int,hash<int>> ht;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> oset;\nconst double pi = acos(-1);\nconst int mod = 1e9 + 7;\nconst int inf = 1e9 + 7;\nconst int N = 1e7 + 5;\nconst double eps = 1e-9;\nint fac[N], ifac[N], inv[N];\n\nint mul(int x, int y) { return x * 1ll * y % mod; }\nint add(int x, int y) { return x+y < mod ? x+y : x+y-mod; }\nint sub(int x, int y) { return x-y < 0 ? x-y+mod: x-y; }\nint norm(int x) { return x < 0 ? add(x, mod) : sub(x, mod); }\ntemplate<class T, class... O> int mul(T x, O... y) { return mul(x, mul(y...)); }\nint ncr(int n, int k) { return n<k ? 0 : mul(fac[n], ifac[k], ifac[n-k]); }\nint pw(int x, int y) {\n  int r = 1;\n  for (; y; y /= 2, x = mul(x, x))\n    if (y & 1)\n      r = mul(r, x);\n  return r;\n}\n\nvoid pr(vector<int>& db) { cerr << \"{ \"; trav(x, db) cerr << x << \" \"; cerr << \"}\\n\"; }\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, a; cin >> n >> a;\n  fac[0] = 1;\n  for (int i = 1; i <= n; i++)\n    fac[i] = mul(fac[i-1], i);\n  ifac[n] = pw(fac[n], mod - 2);\n  for (int i = n-1; ~i; i--) {\n    ifac[i] = mul(ifac[i+1], i+1);\n    inv[i+1] = mul(fac[i], ifac[i+1]);\n  }\n  int ans = 0;\n  for (int i = 1; i <= a; i++) // [1 .. i-1]\n    for (int j = 0; j < i; j++) // j singletons before\n      ans = norm(ans + ((j & 1) ? -1 : 1) * mul(ncr(i-1, j), fac[n-j-1], i-1-j, inv[n-a+i-1-j]));\n  for (int j = 0; j <= a; j++)\n    ans = norm(ans + ((j & 1) ? -1 : 1) * mul(ncr(a, j), fac[n-j], a-j, inv[n-a+a-j]));\n  cout << ans << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\ntypedef long long ll;\nconst ll MOD = 1000000007;\n\nll kaikai[11000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n\nll extGCD(ll a, ll b, ll *x, ll *y) {\n    if (b == 0) {\n        *x = 1;\n        *y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    *y -= a / b * *x;\n    return d;\n}\n\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, &x, &y);\n    return (x % MOD + MOD) % MOD;\n}\n\n\nint main()\n{\n  ll n,a,ans=0,co[5100]={};\n  scanf(\"%lld%lld\",&n,&a);\n  ll dp[a+5][a+5][3]={};\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[i][j][2]*KAI(i)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  rep(i,n-a){\n    ans*=(i+1);\n    ans%=MOD;\n  }\n  printf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do{cout << \"\\033[32;1m\" << #x << \"->\" ; err(x);} while(0)\nvoid err(){cout << \"\\033[39;0m\" << endl;}\ntemplate<template<typename...> class T,typename t,typename... A>\nvoid err(T<t> a,A... x){for (auto v:a) cout << v << ' '; err(x...);}\ntemplate<typename T,typename... A>\nvoid err(T a,A... x){cout << a << ' '; err(x...);}\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n        print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int INF=0x3f3f3f3f;\nconst int maxn=1e7+7;\nconst int mod=1e9+7;\nll C[5005][5005];\nll inv[maxn],f[maxn],finv[maxn];\nvoid init() //inv,f,finv 都开ll\n{\n    inv[1] = 1;\n    for (int i = 2; i < maxn; i++)\n        inv[i] = (mod - mod / i) * inv[mod % i] % mod; //inv: 逆元\n    f[0] = finv[0] = 1;                                //f: 阶乘    finv:阶乘逆元(1/f)\n    for (int i = 1; i < maxn; i++)\n    {\n        f[i] = f[i - 1] * i % mod;\n        finv[i] = finv[i - 1] * inv[i] % mod;\n    }\n\tfor(int i=0;i<5005;i++)\n\t{\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n\t}\n}\nint main()\n{\n\tinit();\n\tint n,a;\n\tcin>>n>>a;\n\tll ans=0;\n\tfor(int i=2;i<=a+1;i++)\n\t{\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t\tint x=i-1-j,b=n-a,rem=max(0,a-i);\n\t\t\tll cur=C[i-1][j]*x%mod*inv[x+b]%mod*f[x+b+rem]%mod;\n\t\t\t//dbg(i,j,cur,x,b,rem);\n\t\t\tif(j&1) ans=(ans-cur+mod)%mod;\n\t\t\telse ans=(ans+cur)%mod;\n\t\t}\n\t\t//dbg(i,ans);\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define inver(a) power(a,mod-2)\n#define upd(a,b) a=add(a+b)\n#define INV(a) ((ll)inv[a]*fac[a-1]%mod)\nusing namespace std;\ninline char gc() {\n//\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int mod=1e9+7;\nconst int maxn=1e7+50;\nconst int maxA=5000+5;\nint n,A;\nint fac[maxn],inv[maxn];\ninline int add(int x) {return x>=mod?x-mod:x;}\ninline int sub(int x) {return x<0?x+mod:x;}\nll power(ll x,ll y) {\n\tll re=1;\n\twhile(y) {\n\t\tif(y&1) re=re*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn re;\n}\ninline int binom(int x,int y) {\n\treturn (ll)fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\ninline int cal(int a,int b,int c) {\n\treturn (ll)fac[a+b+c]*a%mod*INV(a+b)%mod;\n}\nvoid init(int n) {\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i) fac[i]=(ll)fac[i-1]*i%mod;\n\tinv[n]=inver(fac[n]);\n\tfor(int i=n;i>=1;--i) inv[i-1]=(ll)inv[i]*i%mod;\n}\nint main() {\n\trd(n),rd(A);\n\tinit(n);\n\tint an=0;\n\tfor(int t=1;t<=A+1;++t) {\n\t\tfor(int j=0,f=1;j<t;++j,f=mod-f) {\n\t\t\tan=(an+(ll)cal(t-j-1,n-A,max(0,A-t))*binom(t-1,j)%mod*f)%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n#define N 10000100\nconst int mod=1e9+7;\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,A,fac[N],inv[N],ans;\nint qpow(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=1LL*ans*a%mod;\n\t\ta=1LL*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint init(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t}\n\tinv[n]=qpow(fac[n],mod-2);\n\tfor(int i=n-1;i>=0;--i){\n\t\tinv[i]=1LL*inv[i+1]*(i+1)%mod;\n\t}\n}\ninline int C(int n,int m){\n\treturn 1LL*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\ninline int calc(int a,int b,int c){\n\treturn !(a+b)?0:1LL*fac[a+b+c]*a%mod*inv[a+b]%mod*fac[a+b-1]%mod;\n}\nint main(){\n\tn=read(),A=read();\n\tinit(n);\n\tfor(int i=1;i<=A+1;++i){\n\t\tfor(int j=0;j<i;++j){\n\t\t\tans=(ans+(j&1?-1:1)*1LL*C(i-1,j)*calc(i-j-1,n-A,max(0,A-i))%mod+mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>bool chmax(t&a,u b){if(a<b)a=b;return a<b;}\ntemplate<class t,class u>bool chmin(t&a,u b){if(b<a)a=b;return b<a;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n\tint size(){\n\t\treturn v.size();\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\n//uint MODULAR=998244353;\nuint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\nll n,a;\nMint dp[5005][5005],ans;\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tInitfact();\n\tcin>>n>>a;\n\tdp[0][0]=1;\n\tfor(int i=0;i<=a;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(dp[i][j]==0)continue;\n\t\t\t//cout<<i<<' '<<j<<' '<<dp[i][j]<<endl;\n\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\tdp[i+1][j]+=dp[i][j]*Mint(i-j);\n\t\t\tif(j>0)dp[i+1][j-1]+=dp[i][j]*Mint(j);\n\t\t\tif(i>0){\n\t\t\t\tMint s=0;\n\t\t\t\tfor(int k=0;k<=j&&k<i;k++){\n\t\t\t\t\tif(k%2==0)s+=comb(j,k)*fact[i-k-1+n-a]*finv[i-k-1];\n\t\t\t\t\telse s-=comb(j,k)*fact[i-k-1+n-a]*finv[i-k-1];\n\t\t\t\t}\n\t\t\t\tif(i<a)ans+=dp[i][j]*s*fact[a-i-1];\n\t\t\t\telse ans+=dp[i][j]*s;\n\t\t\t}\n\t\t}\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nconst int P = 1e9 + 7;\nconst int N = 1e7 + 7;\nint spow(int a, int b) {\n  int r = 1;\n  while (b) {\n    if (b % 2) {\n      r = r * a % P;\n    }\n    a = a * a % P;\n    b /= 2;\n  }\n  return r;\n}\nint fac[N];\nint inv_fac[N];\nint Newt(int a, int b) {\n  return fac[a] * inv_fac[a - b] % P * inv_fac[b] % P;\n}\nint Prod(int a, int len) {\n  return fac[a + len - 1] * inv_fac[a - 1] % P;\n}\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  // policzmy takie permutacje ze wsrod pierwszych k nie ma petli i kazdy cykl zawiera cos z tych pierwszych k\n  // zafiksujmy sobie zbior petelek przez incl-excl\n  // k! * (k-petle)*(k+1)*...*(n-1)\n  int n, a;\n  cin>>n>>a;\n  fac[0] = 1;\n  RE (i, n) {\n    fac[i] = i * fac[i - 1] % P;\n  }\n  inv_fac[n] = spow(fac[n], P - 2);\n  FORD (i, n - 1, 0) {\n    inv_fac[i] = inv_fac[i + 1] * (i + 1) % P;\n  }\n  // mamy k-petle dozwolonych\n  // jak k<a to mamy jedno mniej\n  // (k-petle)! * (k-petle)*(k-petle+1)*...*(n-petle-1)\n  int res = 0;\n  RE (k, a) {\n    int outer = 0;\n    FOR (petle, 0, k - 1) {\n      int inner = Newt(k, petle);\n      inner = inner * fac[k - petle] % P;\n      if (k < a) {\n        inner = inner * Prod(k - petle, n - a) % P;\n        inner = inner * Prod(n - a + 1 + k - petle, a - k - 1);\n      } else {\n        inner = inner * Prod(k - petle, n - a) % P;\n      }\n        //inner = inner * fac[n - (k < a) - petle - 1] % P;\n//       if (k-petle-1 >= 0) {\n//         inner = inner * inv_fac[k - 1 - petle] % P;\n//       } else {\n//         inner = 0;\n      //}\n      debug(k, petle, inner);\n      if (petle % 2 == 0) {\n        outer = (outer + inner) % P;\n      } else {\n        outer = (outer - inner) % P;\n      }\n    }\n    debug(k, outer);\n    res = (res + outer) % P;\n  }\n  cout<<res<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof (x))\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define kill _z_kill\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outv(x) cerr<<#x\" = \"<<x<<\"  \"\n#define outtag(x) cerr<<\"--------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\tFor(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\n#define User_Time ((double)clock()/CLOCKS_PER_SEC)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned uint;\ntypedef long double LD;\ntypedef vector <int> vi;\ntypedef pair <int,int> pii;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int mod=1e9+7;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nvoid ckmax(int &x,int y){\n\tif (x<y)\n\t\tx=y;\n}\nvoid ckmin(int &x,int y){\n\tif (x>y)\n\t\tx=y;\n}\nconst int N=1e7+5;\nint n,a;\nint Fac[N],Inv[N],Iv[N];\nint calc(int a,int b,int c){\n\treturn (LL)Fac[a+b+c]*a%mod*Iv[a+b]%mod;\n}\nint Comb(int n,int m){\n\treturn (LL)Fac[n]*Inv[m]%mod*Inv[n-m]%mod;\n}\nint main(){\n\tn=read(),a=read();\n\tFac[0]=1;\n\tFor(i,1,n)\n\t\tFac[i]=(LL)Fac[i-1]*i%mod;\n\tInv[n]=Pow(Fac[n],mod-2);\n\tFod(i,n,1)\n\t\tInv[i-1]=(LL)Inv[i]*i%mod;\n\tFor(i,1,n)\n\t\tIv[i]=(LL)Inv[i]*Fac[i-1]%mod;\n\tint ans=0;\n\tFor(i,1,a+1)\n\t\tFor(j,0,i-1){\n\t\t\tint A=i-1-j,C=max(a-i,0),B=n-a;\n\t\t\tint v=(LL)calc(A,B,C)*Comb(i-1,j)%mod;\n\t\t\tif (j&1)\n\t\t\t\tDel(ans,v);\n\t\t\telse\n\t\t\t\tAdd(ans,v);\n\t\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  ll n,a,dp[5100][5100][5]={},ans=0,co[5100]={};\n  cin >> n >> a;\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=KAI(i)%MOD*KAI(n-a)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing v_bool = vector<bool>;\nusing v_Pii = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n    mint Catalan(int n){\n        if(n < 0) return 0;\n        else if(n == 0) return 1;\n        if(fact.size() < 2 * n + 1) fact_initialize(2 * n);\n        return fact[2 * n] * invfact[n + 1] * invfact[n];\n    }\n\n};\n\nmint dp[201][201][201][2] = {};\n\nsigned main(){\n\n    int N, A; cin >> N >> A;\n    if(A > 200) exit(1);\n\n    dp[0][0][0][0] = 1;\n    REP(i, A){\n        REP(j, i + 1) REP(k, j + 1){\n            dp[i + 1][j + 1][k + 1][0] += dp[i][j][k][0];\n            dp[i + 1][j + 1][k][0] += dp[i][j][k][0] * (j - k);\n            if(k > 0) dp[i + 1][j + 1][k - 1][0] += dp[i][j][k][0] * k;\n\n            dp[i + 1][j][k][1] += dp[i][j][k][0];\n\n            dp[i + 1][j][k][1] += dp[i][j][k][1];\n            dp[i + 1][j + 1][k][1] += dp[i][j][k][1] * (j - k);\n            if(k > 0) dp[i + 1][j + 1][k - 1][1] += dp[i][j][k][1] * k;\n        }\n    }\n    \n    Combination C(N);\n    mint ans = 0;\n    int M = N - A;\n    FOR(j, 1, A) FOR(k, 0, j + 1){\n        if(k <= M) ans += dp[A][j][k][1] * C.fact[A - j - 1] * C.nPr(M, k) * C.nPr(j + M - k - 1, M - k);\n    }\n    FOR(k, 0, A + 1){\n        if(k <= M) ans += dp[A][A][k][0] * C.nPr(M, k) * C.nPr(A + M - k - 1, M - k);\n    }\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=10000000,mod=1000000007;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\n\nint n,m;\n\nvoid into(){\n  scanf(\"%d%d\",&n,&m);\n}\n\nint inv[N+9],fac[N+9],ifac[N+9];\n\nvoid Get_inv(){\n  inv[1]=1;\n  fac[0]=fac[1]=1;\n  ifac[0]=ifac[1]=1;\n  for (int i=2;i<=n;++i){\n\tinv[i]=mul(mod-mod/i,inv[mod%i]);\n\tfac[i]=mul(fac[i-1],i);\n\tifac[i]=mul(ifac[i-1],inv[i]);\n  }\n}\n\nint Get_c(int n,int m){return n<m||m<0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));}\n\nint ans;\n\nvoid Get_ans(){\n  for (int i=1;i<=m;++i)\n\tfor (int j=1;j<=i;++j){\n\t  int a=j,b=max(m-i-1,0),c=n-m,t=mul(mul(Get_c(i,j),a),mul(fac[a+b+c],inv[a+c]));\n\t  i-j&1?ssub(ans,t):sadd(ans,t);\n\t}\n}\n\nvoid work(){\n  Get_inv();\n  Get_ans();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef vector<int> vi;\ntypedef pair<int, int> ii;\n\nconst int64 MODULO = (int64) 1e9 + 7;\n\ntypedef long long ll;\n#define SZ 233333\nconst int MOD=1e9+7; //or any prime\nll qp(ll a,ll b)\n{\n  ll x=1; a%=MOD;\n  while(b)\n  {\n    if(b&1) x=x*a%MOD;\n    a=a*a%MOD; b>>=1;\n  }\n  return x;\n}\nnamespace linear_seq {\n  inline vector<int> BM(vector<int> x)\n  {\n    //ls: (shortest) relation sequence (after filling zeroes) so far\n    //cur: current relation sequence\n    vector<int> ls,cur;\n    //lf: the position of ls (t')\n    //ld: delta of ls (v')\n    int lf,ld;\n    for(int i=0;i<int(x.size());++i)\n    {\n      ll t=0;\n      //evaluate at position i\n      for(int j=0;j<int(cur.size());++j)\n        t=(t+x[i-j-1]*(ll)cur[j])%MOD;\n      if((t-x[i])%MOD==0) continue; //good so far\n      //first non-zero position\n      if(!cur.size())\n      {\n        cur.resize(i+1);\n        lf=i; ld=(t-x[i])%MOD;\n        continue;\n      }\n      //cur=cur-c/ld*(x[i]-t)\n      ll k=-(x[i]-t)*qp(ld,MOD-2)%MOD/*1/ld*/;\n      vector<int> c(i-lf-1); //add zeroes in front\n      c.pb(k);\n      for(int j=0;j<int(ls.size());++j)\n        c.pb(-ls[j]*k%MOD);\n      if(c.size()<cur.size()) c.resize(cur.size());\n      for(int j=0;j<int(cur.size());++j)\n        c[j]=(c[j]+cur[j])%MOD;\n      //if cur is better than ls, change ls to cur\n      if(i-lf+(int)ls.size()>=(int)cur.size())\n        ls=cur,lf=i,ld=(t-x[i])%MOD;\n      cur=c;\n    }\n    for(int i=0;i<int(cur.size());++i)\n      cur[i]=(cur[i]%MOD+MOD)%MOD;\n    return cur;\n  }\n  int m; //length of recurrence\n//a: first terms\n//h: relation\n  ll a[SZ],h[SZ],t_[SZ],s[SZ],t[SZ];\n//calculate p*q mod f\n  inline void mull(ll*p,ll*q)\n  {\n    for(int i=0;i<m+m;++i) t_[i]=0;\n    for(int i=0;i<m;++i) if(p[i])\n        for(int j=0;j<m;++j)\n          t_[i+j]=(t_[i+j]+p[i]*q[j])%MOD;\n    for(int i=m+m-1;i>=m;--i) if(t_[i])\n        //miuns t_[i]x^{i-m}(x^m-\\sum_{j=0}^{m-1} x^{m-j-1}h_j)\n        for(int j=m-1;~j;--j)\n          t_[i-j-1]=(t_[i-j-1]+t_[i]*h[j])%MOD;\n    for(int i=0;i<m;++i) p[i]=t_[i];\n  }\n  inline ll calc(ll K)\n  {\n    for(int i=m;~i;--i)\n      s[i]=t[i]=0;\n    //init\n    s[0]=1; if(m!=1) t[1]=1; else t[0]=h[0];\n    //binary-exponentiation\n    while(K)\n    {\n      if(K&1) mull(s,t);\n      mull(t,t); K>>=1;\n    }\n    ll su=0;\n    for(int i=0;i<m;++i) su=(su+s[i]*a[i])%MOD;\n    return (su%MOD+MOD)%MOD;\n  }\n  inline int work(vector<int> x,ll n)\n  {\n    if(n<int(x.size())) return x[n];\n    vector<int> v=BM(x); m=v.size(); if(!m) return 0;\n    for(int i=0;i<m;++i) h[i]=v[i],a[i]=x[i];\n    return calc(n);\n  }\n}\n\nclass TaskD {\n public:\n  void solveOne(istream &in, ostream &out) {\n    int N, A;\n    in >> N >> A;\n    int bound = 3 * A;\n    vector<vector<int64>> w0(min(N, bound) + 1, vector<int64>(A + 1));\n    vector<vector<int64>> w1(min(N, bound) + 1, vector<int64>(A + 1));\n    vector<int64> fact(N + 1);\n    fact[0] = 1;\n    for (int i = 1; i <= N; ++i) {\n      fact[i] = i * fact[i - 1] % MODULO;\n    }\n    for (int n = 1; n < w0.size(); ++n) {\n      for (int a = 1; a <= A && a <= n; ++a) {\n        if (a == n) {\n          w0[n][a] = fact[n];\n          w1[n][a] = fact[n];\n        } else {\n          w0[n][a] = ((n - a) * w1[n - 1][a] + (a - 1) * w1[n - 1][a - 1]) % MODULO;\n          w1[n][a] = (w0[n - 1][a - 1] + w0[n][a]) % MODULO;\n        }\n      }\n    }\n    vector<int> seq(w0.size() - A);\n    for (int i = A; i < w0.size(); ++i) seq[i - A] = w0[i][A] * qp(fact[i - A], MODULO - 2) % MODULO;\n    out << linear_seq::work(seq, N - A) * fact[N - A] % MODULO << \"\\n\";\n  }\n\n  void solve(std::istream &in, std::ostream &out) {\n    int nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne(in, out);\n    }\n  }\n};\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  TaskD solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define eb(x,y) emplace_back(x,y)\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=1e7+5,Mod=1e9+7;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint n,A,ans,Fac[MAXN],iFac[MAXN],inv[MAXN];\ninline int Fp(int x,int k){int ans=1;for(;k;k>>=1,x=1ll*x*x%Mod)if(k&1)ans=1ll*ans*x%Mod;return ans;}\ninline int C(int n,int m){return n<0||m<0||n<m?0:1ll*Fac[n]*iFac[n-m]%Mod*iFac[m]%Mod;}\ninline int Solve(int a,int b,int c){return 1ll*Fac[a+b+c]*inv[a+b]%Mod*a%Mod;}\ninline void Init(){\n\tinv[1]=1;Rep(i,2,n)inv[i]=1ll*inv[Mod%i]*(Mod-Mod/i)%Mod;\n\tFac[0]=1;Rep(i,1,n)Fac[i]=1ll*Fac[i-1]*i%Mod;\n\tiFac[n]=Fp(Fac[n],Mod-2);Red(i,n,1)iFac[i-1]=1ll*iFac[i]*i%Mod;\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),A=read(),Init();\n\tRep(i,1,A)Rep(j,1,i)ans=(ans+1ll*(((i-j)&1)?Mod-C(i,j):C(i,j))*Solve(j,n-A,max(0,A-i-1)))%Mod;\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,A;\nconst ll mo=1000000007;\n\nconst int NUM_=10400001;\nstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\n\nll pat[5050][5050];\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>A;\n\tinv[1]=fact[0]=factr[0]=1;\n\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t\n\tll ret=0;\n\tfor(i=1;i<=A;i++) {\n\t\tint a,b,c;\n\t\tif(i==A) {\n\t\t\ta=i;\n\t\t\tb=N-i;\n\t\t\tc=0;\n\t\t}\n\t\telse {\n\t\t\ta=i;\n\t\t\tb=N-A;\n\t\t\tc=A-i-1;\n\t\t}\n\t\t\n\t\tll sum=0;\n\t\tfor(j=i-1;j>=0;j--) {\n\t\t\tpat[i][j]=fact[a-j]*fact[(a-j)+b-1]%mo*factr[(a-j)-1]%mo;\n\t\t\t(pat[i][j]*=fact[a]*factr[j]%mo*factr[a-j]%mo*fact[(a-j)+b+c]%mo*factr[(a-j)+b]%mo)%=mo;\n\t\t\tif(j&1) ret-=pat[i][j];\n\t\t\telse ret+=pat[i][j];\n\t\t}\n\t}\n\tcout<<(ret%mo+mo)%mo<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\n#define TRACE(x) std::cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n\nusing namespace std;\ntemplate <int32_t P>\nstruct ModInt_t {\n  static constexpr auto mod = P;\n\n  int32_t value;\n\n  static_assert(P < (1 << 30) - 1, \"2xP must fit into 32-bit signed integer\");\n\n  ModInt_t() : value{0} {};\n\n  explicit ModInt_t(int32_t v) : value(v) {\n    if (value >= P || value <= -P) value %= P;\n    if (value < 0) value += P;\n  };\n\n  explicit operator bool() const { return value != 0; }\n  explicit operator int32_t() const { return value; }\n\n  ModInt_t& operator+=(const ModInt_t& other) {\n    value += other.value;\n    if (value >= P) value -= P;\n    return *this;\n  }\n\n  ModInt_t& operator-=(const ModInt_t& other) {\n    value -= other.value;\n    if (value < 0) value += P;\n    return *this;\n  }\n\n  ModInt_t& operator*=(const ModInt_t& other) {\n    int64_t result = static_cast<int64_t>(value) * other.value;\n    value = static_cast<int32_t>(result % P);\n    return *this;\n  }\n\n  static ModInt_t inverse(ModInt_t x) { return ModInt_t{inverse(x.value)}; }\n\n private:\n  static int32_t inverse(int32_t a) {\n    int32_t b = P, x = 1, y = 0;\n    while (b != 0) {\n      auto k = a / b;\n      a -= k * b;\n      std::swap(a, b);\n      x -= k * y;\n      std::swap(x, y);\n    }\n    assert(a == 1);\n    if (x < 0) x += P;\n    return x;\n  }\n};\n\ntemplate <int32_t P>\nModInt_t<P> operator+(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  auto res = a;\n  return res += b;\n};\n\ntemplate <int32_t P>\nModInt_t<P> operator-(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  auto res = a;\n  return res -= b;\n};\n\ntemplate <int32_t P>\nModInt_t<P> operator*(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  auto res = a;\n  return res *= b;\n};\n\ntemplate <int32_t P>\nbool operator==(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  return a.value == b.value;\n};\n\ntemplate <int32_t P>\nstd::ostream& operator<<(std::ostream& os, const ModInt_t<P>& a) {\n  os << a.value;\n  return os;\n}\n\ntemplate <typename T>\nstruct MulMonoid {\n  using value_type = T;\n  constexpr static T identity() { return T{1}; }\n  constexpr static T op(const T& a, const T& b) { return a * b; }\n};\n\ntemplate <typename T, typename U, typename Monoid = MulMonoid<T>>\nT power(T a, U n) {\n  T r{Monoid::identity()};\n  while (n > 0) {\n    if (n % 2) r = Monoid::op(r, a);\n    a = Monoid::op(a, a);\n    n /= 2;\n  }\n  return r;\n}\n\nusing ModInt = ModInt_t<1000000007>;\n\nstruct ModInverses {\n  vector<ModInt> inv;\n\n  ModInverses(int n) : inv(n, ModInt{0}) {\n    auto mod = ModInt::mod;\n    assert(n < mod);\n\n    inv[1] = ModInt{1};\n    for (int i = 2; i < n; ++i) {\n      inv[i] = ModInt{0} - ModInt{mod / i} * inv[mod % i];\n    }\n  };\n};\n\nstruct Factorial {\n  vector<ModInt> fact;\n  vector<ModInt> invfact;\n\n  ModInt choose(int n, int k) { return fact[n] * invfact[k] * invfact[n - k]; }\n\n  Factorial(int n) : fact(n, ModInt{0}), invfact(n, ModInt{0}) {\n    ModInverses inv(n);\n\n    fact[0] = invfact[0] = ModInt{1};\n    for (int i = 1; i < n; ++i) {\n      fact[i] = fact[i - 1] * ModInt{i};\n      invfact[i] = invfact[i - 1] * inv.inv[i];\n    }\n  }\n};\n\nModInt solve(int N, int A) {\n  Factorial f(N + 1);\n\n  ModInt ans{0};\n  for (int k = 0; k <= A; ++k) {\n    for (int p = 1; p <= k; ++p) {\n      auto v = f.fact[p];\n      v *= f.choose(k, p);\n\n      v *= f.fact[p + N - A - 1] * f.invfact[p - 1];\n\n      int c = max(0, A - k - 1);\n      v *= f.fact[p + N - A + c] * f.invfact[p + N - A];\n\n      if ((k - p) % 2)\n        ans -= v;\n      else\n        ans += v;\n    }\n  }\n\n  return ans;\n}\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  int N, A;\n  cin >> N >> A;\n\n  auto ret = solve(N, A);\n  cout << ret << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long \nconst int mod=1e9+7,N=1e7+5;\nint fac[N],inv[N],ins[N];\nint ksm(int b,int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1) res=res*b%mod;\n\t\tb=b*b%mod; n>>=1;\n\t}\n\treturn res;\n} \nvoid init(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfac[i]=fac[i-1]*i%mod;\n\tinv[n]=ksm(fac[n],mod-2);\n\tfor(int i=n-1;i>=0;--i)\n\t\tinv[i]=inv[i+1]*(i+1)%mod;\n\tins[1]=1;\n\tfor(int i=2;i<=n;++i)\n\t\tins[i]=(mod-(mod/i))*ins[mod%i]%mod;\n}\nint C(int n,int m){\n\tif(n<m) return 0;\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nsigned main(){\n\tint n,A,sum=0,res;\n\tcin>>n>>A;\n\tinit(n);\n\tfor(int t=2;t<=A+1;++t){\n\t\tint x=t-1,y=max(A-t,0ll),z=n-A;\n\t\tfor(int i=0;i<=x;++i){\n\t\t\tres=C(x,i)*(x-i)%mod*ins[x+z-i]%mod*fac[x+y+z-i]%mod;\n\t\t\tif(i&1) sum+=(mod-res)%mod;\n\t\t\telse sum+=res;\n\t\t\tsum%=mod;\n\t\t}\n\t}\n\tcout<<sum;\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 5010, P = 998244353;\nint n, A, fact[maxn], finv[maxn], inv[maxn];\n\nint main() {\n    scanf(\"%d %d\", &n, &A);\n    fact[0] = finv[0] = inv[0] = inv[1] = 1;\n    for (int i = 1; i <= n; i++) {\n        fact[i] = 1LL * i * fact[i - 1] % P;\n        if (i > 1) inv[i] = 1LL * (P - P / i) * inv[P % i] % P;\n        finv[i] = 1LL * finv[i - 1] * inv[i] % P;\n    }\n    auto C = [&](int x, int y) {\n        return 1LL * fact[x] * finv[y] % P * finv[x - y] % P;\n    };\n    int ans = 0;\n    for (int t = 2; t <= A + 1; t++) {\n        int a = t - 1, b = n - A, c = max(0, A - t);\n        for (int j = 0; j <= a; j++) {\n            int coef = j & 1 ? P - 1 : 1;\n            ans = (ans + 1LL * coef * C(a, j) % P * (a - j) % P * inv[a - j + b]\n                % P * fact[a - j + b + c]) % P;\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 10000010;\nconst int INF = 2147483600;\nconst LL Mod = 1e9+7;\n\nLL N,A; LL fac[MAXN+1],inv[MAXN+1],ifac[MAXN+1];\ninline LL C(LL n,LL m){ if(n<m) return 0; return fac[n]*ifac[m]%Mod*ifac[n-m]%Mod; }\ninline LL F(LL a,LL b,LL c){ return fac[a+b+c]*a%Mod*inv[a+b]%Mod; }\ninline void Add(LL &a,LL b){ a=(a+b>=Mod?a+b-Mod:a+b); }\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read(),A=read(); fac[0]=inv[1]=ifac[0]=1; LL ans=0;\n\tfor(int i=1;i<=N;i++) fac[i]=fac[i-1]*i%Mod;\n\tfor(int i=2;i<=N;i++) inv[i]=(Mod-(Mod/i)*inv[Mod%i]%Mod)%Mod;\n\tfor(int i=1;i<=N;i++) ifac[i]=ifac[i-1]*inv[i]%Mod;\n\tfor(LL a=1;a<=A+1;a++){\n\t\tLL b=N-A,c=A-min(a,A); LL op=1;\n\t\tfor(int j=0;j<=a-1;j++)\n\t\t\tAdd(ans,op*F(a-1-j,b,c)%Mod*C(a-1,j)%Mod),op=Mod-op;\n\t} printf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  int n,a,dp[501][501][3]={},ans=0,co[5100]={};\n  cin >> n >> a;\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[i][j][2]*KAI(i)%MOD*KAI(n-a)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5e3+10;\nconst int M=1e7+10;\nconst int mod=1e9+7;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint qpow(int a,int b) {\n\tint ret=1;\n\twhile(b) {\n\t\tif(b&1) ret=1ll*ret*a%mod;\n\t\ta=1ll*a*a%mod;b>>=1;\n\t}\n\treturn ret;\n}\n\nint n,fac[M],inv[M],ifac[M],C[N][N],A;\n\nint cal(int a,int b,int c) {\n\treturn 1ll*fac[a+b+c]*a%mod*inv[a+b]%mod;\n}\n\nint main() {\n\tcin>>n>>A;\n\tfac[0]=inv[1]=ifac[0]=1;\n\tfor(int i=1;i<M;i++) {\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\t\tif(i>1) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\t\tifac[i]=1ll*ifac[i-1]*inv[i]%mod;\n\t}\n\tfor(int i=0;i<N;i++) {\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=A+1;i++)\n\t\tfor(int j=0;j<i;j++) ans=(ans+1ll*C[i-1][j]*((j&1)?mod-1:1)%mod*cal(i-1-j,n-A,max(0,A-i)))%mod;\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << a << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n \ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nmt19937_64 rng;\n\nconst int \n    M = 1e7 + 10,\n    MOD = 1e9 + 7;\n\nint inv[M], fact[M], ifact[M];\n\nint comb(int m, int n) {\n    if (m < 0 || n < 0 || n > m) return 0;\n    return (ll) fact[m] * ifact[n] % MOD * ifact[m-n] % MOD;\n}\n\nint f(int a, int b, int c) {\n    return (ll) fact[a+b+c] * inv[a+b] % MOD * a % MOD;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    rng.seed(time(0));\n\n    inv[1] = 1;\n    forsn(n,2,M) {\n        inv[n] = ll(MOD - MOD/n) * inv[MOD%n] % MOD;\n        assert((ll) inv[n] * n % MOD == 1);\n    }\n    fact[0] = ifact[0] = 1;\n    forsn(n,1,M) {\n        fact[n] = ll(n) * fact[n-1] % MOD;\n        ifact[n] = ll(inv[n]) * ifact[n-1] % MOD;\n        assert((ll) fact[n] * ifact[n] % MOD == 1);\n    }\n\n    ll ans = 0;\n    int n,a; cin >> n >> a;\n    for (int i = 1; i < a; i++) {\n        for (int k = 0; k <= i; k++) {\n            ll sign = k%2 ? MOD - 1 : 1;\n            ans += sign * comb(i,k) % MOD * f(i-k, n-a, a-1-i) % MOD;\n        }\n    }\n    for (int k = 0; k <= a; k++) {\n        ll sign = k%2 ? MOD - 1 : 1;\n        ans += sign * comb(a,k) % MOD * f(a-k, n-a, 0) % MOD;\n    }\n\n    cout << ans%MOD << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\n#define SIZE 10101010\nll inv[SIZE + 1];\nll kai[SIZE + 1];\nll invkai[SIZE + 1];\nvoid invinit()\n{\n\tinv[1] = 1;\n\tfor (int i = 2; i <= SIZE; i++)\n\t{\n\t\tinv[i] = mod - (mod / i)*inv[mod%i] % mod;\n\t}\n\tkai[0] = invkai[0] = 1;\n\tfor (int i = 1; i <= SIZE; i++)\n\t{\n\t\tkai[i] = kai[i - 1] * i%mod;\n\t\tinvkai[i] = invkai[i - 1] * inv[i] % mod;\n\t}\n}\nll com(ll a, ll b)\n{\n\tif (b < 0 || a < b)return 0;\n\treturn (invkai[b] * invkai[a - b]) % mod*kai[a] % mod;\n}\nint main()\n{\n\tint num, gen;\n\tscanf(\"%d%d\", &num, &gen);\n\tinvinit();\n\tll r = 0;\n\tint t = num - gen;\n\tfor (int i = 1; i <= gen; i++)\n\t{\n\t\tll s = 0;\n\t\tfor (int j = 0; j < i; j++)\n\t\t{\n\t\t\tint rem = i - j;\n\t\t\tll z = kai[t] * kai[rem] % mod*com(t + rem - 1, t) % mod*com(i, j) % mod;\n\t\t\tif (i < gen)\n\t\t\t{\n\t\t\t\tll q = kai[num - j - 1] * invkai[num - gen + i - j] % mod;\n\t\t\t\tz = (z*q) % mod;\n\t\t\t}\n\t\t\tif (j % 2 == 0)s = (s + z) % mod;\n\t\t\telse s = (s + mod - z) % mod;\n\t\t}\n\t\t//printf(\"%d %lld\\n\", i, s);\n\t\tr = (r + s) % mod;\n\t}\n\tprintf(\"%lld\\n\", r);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n\nconst int N = 10000005, P = 1000000007;\nint n, a, ans, fac[N], ifac[N];\nint Pow(ll x, int y=P-2){\n\tint ans=1;\n\tfor(; y; y>>=1, x=x*x%P) if(y&1) ans=ans*x%P;\n\treturn ans;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &a);\n\tfac[0]=1;\n\tfor(int i=1; i<=n; ++i) fac[i]=(ll)fac[i-1]*i%P;\n\tifac[n]=Pow(fac[n]);\n\tfor(int i=n; i; --i) ifac[i-1]=(ll)ifac[i]*i%P;\n\tfor(int i=1; i<=a; ++i) for(int j=0; j<=i; ++j)\n\t\tans=(ans+(j&1?P-1ll:1ll)*fac[i]%P*ifac[j]%P*ifac[i-j]%P*fac[n-(i<a)-j]%P*(i-j)%P*ifac[n-a+i-j]%P*fac[n-a+i-j-1])%P;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 20000000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nint n, a, fac[N], inv[N];\n\nint POW(int a, int b){\n\tint res = 1;\n\twhile (b){\n\t\tif (b & 1) res = res * 1ll * a % MOD;\n\t\tb >>= 1;\n\t\ta = a * 1ll * a % MOD;\n\t}\n\treturn res;\n}\n\nint nCr(int a, int b){\n\tif (a < b || a < 0 || b < 0) return 0;\n\tint res = fac[a];\n\tres = res * 1ll * inv[b] % MOD;\n\tres = res * 1ll * inv[a - b] % MOD;\n\treturn res;\n}\n\nint mul(int a, int b){\n\treturn a * 1ll * b % MOD;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> a;\n\tfac[0] = 1;\n\tfor (int i = 1; i < N; i++) fac[i] = (fac[i - 1] * 1ll * i) % MOD;\n\tinv[N - 1] = POW(fac[N - 1], MOD - 2);\n\tfor (int i = N - 2; i >= 0; i--){\n\t\tinv[i] = (inv[i + 1] * 1ll * (i + 1)) % MOD;\n\t}\n//\tcout << \"YES\" << endl;\n//\tcout << nCr(6,3) << '\\n';\n\tint b = n - a;\n\tint ans = 0;\n\tfor (int i = 1; i <= a + 1; i++){\n\t\tint res = 0;\n\t\tif (i == 1 && n == a){\n\t\t\tans++;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = 0; j < i - 1; j++){\n\t\t\tint delta = nCr(i - 1, j);\n\t\t\tint x = i - 1 - j;\n\t\t\tint c = max(0, a - i);\n\t\t\tdelta = mul(delta, fac[x + b + c]);\n\t\t\tdelta = mul(delta, mul(x, mul(inv[x + b], fac[x + b - 1])));\n\t\t\tres += ((j % 2)?-delta:delta);\n\t\t\tres %= MOD;\n\t\t\tres += MOD;\n\t\t\tres %= MOD;\n//\t\t\tcout << i << ' ' << j << ' ' << x << ' ' << b << ' ' << c << ' ' << res << '\\n';\n\t\t}\n//\t\tcout << res << '\\n';\n\t\tans = (ans + res) % MOD;\n\t}\n\tcout << ans;\n\n\n\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, K;\nlong long F[10100000], Inv[10100], Mod = 1000000007;\nint Comb[5010][5010];\nlong long Pow(long long a, long long b){\n    long long r=1;\n    while(b){\n        if(b&1)r=r*a%Mod;\n        a=a*a%Mod;b>>=1;\n    }\n    return r;\n}\nlong long Calc(int B){\n    int i;\n    long long r=0;\n    int m = n-K;\n    for(i=0;i<B;i++){\n        long long t;\n        if(B!=K) t = Comb[B][i]*F[n-i-1]%Mod*Inv[n-(B-i+m)]%Mod*(B-i)%Mod;\n        else t = Comb[B][i]*F[n-i-1]%Mod*(B-i)%Mod;\n        if(i&1)r+=Mod-t;\n        else r+=t;\n    }\n    r%=Mod;\n    //printf(\"%d %lld\\n\",B,r);\n    return r;\n}\nint main(){\n    scanf(\"%d%d\",&n,&K);\n    int i;\n    F[0]=1;\n    for(i=0;i<=5000;i++){\n        Comb[i][0]=1;\n        for(int j=1;j<=i;j++)Comb[i][j]=(Comb[i-1][j-1]+Comb[i-1][j])%Mod;\n    }\n    for(i=1;i<=n;i++)F[i]=F[i-1]*i%Mod;\n    for(i=0;i<=10000;i++)Inv[i]=Pow(n-i,Mod-2);\n    long long res=0;\n    for(i=0;i<=K;i++){\n        res+=Calc(i);\n        res%=Mod;\n    }\n    printf(\"%lld\\n\",res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for (int i = x; i < (int)(n); ++i)\n\nint const N = 5000, M = 10000000, md = 1e9 + 7;\nint fc[M + 1], inv[M + 1], fcin[N + 1];\n\nint ch(int n, int k) { return (ll)fc[n] * fcin[k] % md * fcin[n - k] % md; }\nvoid ad(int &x, int y) { if ((x += y) >= md)x -= md; }\n\nint main(){\n\tfc[0] = 1;\n\tf(i, 1, M + 1)fc[i] = (ll)fc[i - 1] * i % md;\n\tinv[1] = 1;\n\tf(i, 2, M + 1)inv[i] = md - md / i * (ll)inv[md % i] % md;\n\t\n\tint n, a;\n\tscanf(\"%d%d\", &n, &a);\n\t\n\tfcin[0] = 1;\n\tf(i, 1, a + 1)fcin[i] = (ll)fcin[i - 1] * inv[i] % md;\n\tn -= a;\n\t\n\tint an = 0;\n\tf(i, 2, a + 2)f(j, 0, i){\n\t\tint t = (ll)ch(i - 1, j) * (i - 1 - j) % md * fc[a - 1 + n - j + (i == a + 1)] % md * inv[n + i - 1 - j] % md;\n\t\tad(an, j & 1 ? md - t : t);\n\t}\n\t\n\tprintf(\"%d\\n\", an);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 07.06.2020 15:24:20       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, a;\n  cin >> n >> a;\n  vector<Mint> fact(n + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    fact[i] = fact[i - 1] * i;\n  }\n  vector<Mint> inv_fact(n + 1);\n  inv_fact[n] = 1 / fact[n];\n  for (int i = n - 1; i >= 0; i--) {\n    inv_fact[i] = inv_fact[i + 1] * (i + 1);\n  }\n  vector<Mint> der(a + 1);\n  der[0] = 1;\n  for (int i = 1; i <= a; i++) {\n    der[i] = der[i - 1] * i + (i % 2 == 1 ? -1 : 1);\n  }\n  Mint ans = 0;\n  {\n    int last = 0;\n    for (int other = 0; other <= a - last; other++) {\n      Mint ways = 1;\n      if (other > 0) { \n        ways *= fact[a - last] * inv_fact[other] * inv_fact[a - last - other];\n      }\n      if (other % 2 == 1) {\n        ways = -ways;\n      }\n      ways *= fact[n - last - other - 1] * (a - last - other);\n//      debug(last, other, ways);\n      ans += ways;\n    }\n  }\n  vector<vector<Mint>> go(a + 2, vector<Mint>(a + 2));\n  for (int f = 1; f < a; f++) {\n    for (int other = 0; other < f; other++) {\n      Mint ways = fact[a - f - 1] * fact[f] * inv_fact[other] * inv_fact[f - other - 1] * fact[n - other - 2] * inv_fact[a - f - 1];\n      if (other & 1) {\n        ways = -ways;\n      }\n      go[other + 2][a - f - 1] += ways;\n    }\n  }\n  for (int i = 0; i <= a; i++) {\n    for (int j = 0; j <= a; j++) {\n      if (go[i][j] == 0) { \n        continue;\n      }\n      ans += go[i][j];\n      if (j > 0) {\n        go[i + 1][j - 1] += go[i][j] * fact[n - i - 1] * inv_fact[n - i] * j;\n      }\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\nnamespace Base{\n\t# define mr make_pair\n\ttypedef long long ll;\n\ttypedef double db;\n\tconst int inf = 0x3f3f3f3f, INF = 0x7fffffff;\n\tconst ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\n\ttemplate<typename T> void read(T &x){\n    \tx = 0; int fh = 1; double num = 1.0; char ch = getchar();\n\t\twhile (!isdigit(ch)){ if (ch == '-') fh = -1; ch = getchar(); }\n\t\twhile (isdigit(ch)){ x = x * 10 + ch - '0'; ch = getchar(); }\n\t    if (ch == '.'){\n\t    \tch = getchar();\n\t    \twhile (isdigit(ch)){num /= 10; x = x + num * (ch - '0'); ch = getchar();}\n\t\t}\n\t\tx = x * fh;\n\t}\n\ttemplate<typename T> void chmax(T &x, T y){x = x < y ? y : x;}\n\ttemplate<typename T> void chmin(T &x, T y){x = x > y ? y : x;}\n}\nusing namespace Base;\n\nconst int P = 1e9 + 7, N = 5010, M = 1e7 + 10;\nint mul[M], inv[M], m, n, ans, c[N][N];\nint power(int x, int y){\n\tint i = x; x = 1;\n\twhile (y > 0){\n\t\tif (y & 1) x = 1ll * i * x % P;\n\t\ti = 1ll * i * i % P;\n\t\ty /= 2;\n\t}\n\treturn x;\n}\nint main(){\n\tread(m); read(n);\n\tmul[0] = 1; for (int i = 1; i <= m; i++) mul[i] = 1ll * mul[i - 1] * i % P;\n\tinv[m] = power(mul[m], P - 2); \n\tfor (int i = m - 1; i >= 0; i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % P;\n\tfor (int i = 0; i <= n; i++){\n\t\tc[i][0] = 1;\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tc[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % P;\n\t}\n\tfor (int i = n + 1; i >= 2; i--){\n\t\tint fh;\n\t\tfor (int j = 0; j <= i - 1; j++){\n\t\t\tif (j % 2 == 0) fh = c[i - 1][j];\telse fh = -c[i - 1][j];\n\t\t\tint a = i - 1 - j, b = m - n, c = max(0, n - i);\n\t\t\tans = (ans + 1ll * fh * mul[a + b + c] * a % P * inv[a + b] % P * mul[a + b - 1] % P + P) % P;\n\t\t}\n\t}\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=5007;\nconst int vax=10*1007*1007;\nconst ll mod=1000*1000*1000+7;\n\nint n, k;\n\nint dp[nax][nax];\n\nll sil[vax];\nll odw[nax];\n\nll wyn;\n\nvoid sdod(ll &a, ll b)\n{\n\ta=(a+b)%mod;\n}\n \nvoid sdod(int &a, ll b)\n{\n\ta=(a+b)%mod;\n}\n\nll dziel(ll a, ll b)\n{\n\tll wyk=mod-2;\n\twhile(wyk)\n\t{\n\t\tif (wyk&1)\n\t\t\ta=(a*b)%mod;\n\t\tb=(b*b)%mod;\n\t\twyk>>=1;\n\t}\n\treturn a;\n}\n\nll kom(int a, int b)\n{\n\tif (b<0 || b>a)\n\t\treturn 0;\n\treturn (sil[a]*(odw[b]*odw[a-b]%mod))%mod;\n}\n\nint spo[nax][nax];\n\nvoid ogar(int moge, int musze, ll mno)\n{\n\tif (!mno || !moge)\n\t\treturn;\n\tint jest=n-k;\n\tif (jest<musze)\n\t\treturn;\n\twyn=(wyn+mno*spo[moge][musze])%mod;\n\t//~ debug() << imie(moge) << imie(musze) << imie(mno);\n}\n\nint pchaj[nax][nax];\n\nint main()\n{\n\tsil[0]=1;\n\tfor (int i=1; i<vax; i++)\n\t\tsil[i]=(sil[i-1]*i)%mod;\n\todw[nax-1]=dziel(1, sil[nax-1]);\n\tfor (int i=nax-2; i>=0; i--)\n\t\todw[i]=(odw[i+1]*(i+1))%mod;\n\tscanf(\"%d%d\", &n, &k);\n\tint poza=n-k;\n\tfor (int j=0; j<=k; j++)\n\t{\n\t\tfor (int i=max(1, j); i<=k; i++)\n\t\t{\n\t\t\tif (!j)\n\t\t\t{\n\t\t\t\tspo[i][j]=(sil[i+poza-1]*odw[i-1])%mod;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspo[i][j]=(spo[i][j-1]-spo[i-1][j-1]+mod)%mod;\n\t\t}\n\t}\n\tdp[k][0]=1;\n\tfor (int i=k; i>=0; i--)\n\t{\n\t\tfor (int j=0; j<=k; j++)\n\t\t{\n\t\t\tsdod(dp[i][j], pchaj[i][j]);\n\t\t\tif (i)\n\t\t\t\tsdod(pchaj[i-1][j], pchaj[i][j]*(ll)i);\n\t\t\tif (!dp[i][j] || !i)\n\t\t\t\tcontinue;\n\t\t\tsdod(dp[i-1][j+1], dp[i][j]);\n\t\t\t\n\t\t\tif (i>=2)\n\t\t\t\tsdod(pchaj[i-2][j], dp[i][j]*(i-1LL));\n\t\t\t\n\t\t\togar(k-i, j, dp[i][j]*sil[i-1]%mod);\n\t\t}\n\t}\n\tfor (int i=0; i<=k; i++)\n\t\togar(k, i, dp[0][i]);\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  ll n,a,dp[5100][5100][3]={},ans=0,co[1000010]={};\n  cin >> n >> a;\n  co[0]=1;\n  rep(i,1000005)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[i][j][2]*KAI(i)%MOD*KAI(n-a)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class t> inline t read(t &x){\n\tchar c=getchar();bool f=0;x=0;\n\twhile(!isdigit(c)) f|=c=='-',c=getchar();\n\twhile(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\tif(f) x=-x;return x;\n}\ntemplate<class t,class ...A> inline void read(t &x,A &...a){\n\tread(x);read(a...);\n}\ntemplate<class t> inline void write(t x){\n\tif(x<0) putchar('-'),write(-x);\n\telse{if(x>9) write(x/10);putchar('0'+x%10);}\n}\n\nconst int mod=1e9+7,N=1e7+5,M=5e3+5;\nint n,m,ans,fac[N],inv[N],C[M][M];\n\nsigned main(){\n\tread(n,m);\n\tfac[0]=1; for(int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[1]=1; for(int i=2;i<=n;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=0;i<=m;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n\t}\n\tfor(int i=1;i<=m+1;i++) for(int j=0;j<i;j++){\n\t\tint a=i-1-j,c=max(m-i,0),b=n-m;\n\t\tint cur=1ll*C[i-1][j]*fac[a+b+c]%mod*a%mod*inv[a+b]%mod;\n\t\tif(j&1) ans=(ans-cur+mod)%mod;\n\t\telse ans=(ans+cur)%mod;\n\t}\n\twrite(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\nconst int MOD = 1000 * 1000 * 1000 + 7;\n\n\nconst int N = 10 * 1000 * 1000 + 6000;\nconst int NREV = 5005;\n\nlong long fact[N], revFact[N];\n\nlong long expo(long long a, long long n, long long mod) {\n    long long ans = 1;\n\n    while (n) {\n        if (n & 1LL) ans = (ans * a) % mod;\n\n        n >>= 1;\n        a = (a * a) % mod;\n    }\n\n    return ans;\n}\n\nlong long revMod(long long a, long long mod) {\n    return expo(a, mod - 2, mod);\n}\n\nvoid pre() {\n    fact[0] = revFact[0] = 1;\n\n    for (int i = 1; i < N; i++) {\n        fact[i] = (i * fact[i-1]) % MOD;\n        \n        if (i < NREV) {\n            revFact[i] = revMod(fact[i], MOD);\n        }\n    }\n}\n\nlong long binom(int n, int m) {\n    if (m > n) return 0;\n\n    long long res = (fact[n] * revFact[n-m]) % MOD;\n    res = (res * revFact[m]) % MOD;\n\n    return res;\n}\n\n\nint solve(int n, int a) {\n    int ans = 0;\n    int q = n - a;\n\n    for (int notLoops = 1; notLoops <= a; notLoops++) {\n        int ansHere = 0;\n\n        vector <long long> values(a + 1);\n\n        for (int x = 0; x <= a; x++) {\n            long long summand = 1;\n\n            summand = (summand * revFact[x]) % MOD;\n            summand = (summand * notLoops) % MOD;\n            summand = (summand * fact[notLoops + x + q - 1]) % MOD;\n\n            values[x] = summand;\n        }\n\n        for (int x = 1; x <= a; x++) {\n            values[x] = (values[x] + values[x-1]) % MOD;\n        }\n\n        for (int loops = 0; loops < a && loops <= a - notLoops; loops++) {\n            int p = loops + notLoops;\n            int m = max(a - p - 1, 0);\n\n            long long sum = values[m];\n\n            sum = (sum * binom(p, loops)) % MOD;\n            sum = (sum * fact[m]) % MOD;\n\n            if (loops % 2 == 0) {\n                ansHere = (ansHere + sum) % MOD;\n            } else {\n                ansHere = (ansHere + MOD - sum) % MOD;\n            }\n        }\n\n        ans = (ans + ansHere) % MOD;\n    }\n\n    return ans;\n}\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    pre();\n\n    int n, a;\n    cin >> n >> a;\n\n    cout << solve(n, a);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 10000005, M = 5005, P = 1000000007;\n\nint n, m;\nint fac[N], inv[N], C[M][M];\n\nint main() {\n\tread(n), read(m);\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfac[i] = 1ll * fac[i - 1] * i % P;\n\t}\n\tinv[1] = 1;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tinv[i] = 1ll * (P - P / i) * inv[P % i] % P;\n\t}\n\tfor (int i = 0; i <= m; ++i) {\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor (int j = 1; j < i; ++j) {\n\t\t\tC[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % P;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= m + 1; ++i) {\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tint a = i - 1 - j, c = std::max(m - i, 0), b = n - m;\n\t\t\tint t = 1ll * C[i - 1][j] * fac[a + b + c] % P * a % P * inv[a + b] % P;\n\t\t\tif (j & 1) {\n\t\t\t\tans = (ans + P - t) % P;\n\t\t\t} else {\n\t\t\t\tans = (ans + t) % P;\n\t\t\t}\n\t\t}\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#include <ext/pb_ds/assoc_container.hpp> // Common file\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n \nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\ntypedef tree<\nll,\nnull_type,\nless<ll>,\nrb_tree_tag,\ntree_order_statistics_node_update>\nordered_set;\n// ordered_set X;\n// *X.find_by_order(i) = ith largest element (counting from zero)\n// X.order_of_key(k) = number of items in X < k (strict lt)\n\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { ll v; i >> v; n = modnum(v); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(ll e) const {\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static int totient() {\n        int tot = MOD, tmp = MOD;\n        for (int p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static int primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        int tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (int p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (int r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (int p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static int discrete_log(modnum v) {\n        static const int M = ceil(sqrt(MOD));\n        static unordered_map<int, int> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (int i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (int i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum<MOD>> fact = { 1 };\n        for (assert(n >= 0); fact.size() <= n; )\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum finv(int n) {\n        static vector<modnum<MOD>> finv = { 1 };\n        for (assert(n >= 0); finv.size() <= n; )\n            finv.push_back(finv.back() / finv.size());\n        return finv[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        if (r < 0 || n < r) return 0;\n        return fact(n) * finv(r) * finv(n - r);\n    }\n};\n\nconstexpr ll MOD = 1e9 + 7;\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int N, A;\n    cin >> N >> A;\n\n    int rN = N;\n    if (N > 10000) {\n        N = 10000;\n    }\n\n    vector<modnum<MOD>> dprow(A+1, 0);\n    vector<vector<modnum<MOD>>> dp(N+1, dprow);\n    vector<vector<modnum<MOD>>> dp2(N+1, dprow);\n\n    for (int i=0;i<=N;i++) dp[i][0] = 0;\n    for (int i=0;i<=min(N, A);i++) dp[i][i]=modnum<MOD>::fact(i);\n    \n    for (int i=0;i<=N;i++) dp2[i][0] = 0;\n    for (int i=0;i<=min(N, A);i++) dp2[i][i]=modnum<MOD>::fact(i);\n\n    for (int i=1;i<=N;i++) {\n        for (int j=1;j<=min(i-1, A);j++) {\n            dp[i][j] = (j-1)*dp2[i-1][j-1] + dp2[i-1][j];\n            dp2[i][j] = dp[i-1][j-1] + dp[i][j];\n            // dp[i][j] = ((j-1)*dp2[i-1][j-1])/i  + ((i-j)*dp2[i-1][j])/i;\n            // dp2[i][j] = dp[i-1][j-1]/i + dp[i][j];\n        }\n    }\n\n    if (rN == N) {\n        cout << dp[N][A] * modnum<MOD>::fact(N-A) << endl;\n    } else {\n        // interpolate\n        modnum<MOD> ans = 0;\n        for (int i=A+1;i<=2*A;i++) {\n            modnum<MOD> term = dp[i][A];\n            modnum<MOD> num = 1;\n            modnum<MOD> den = 1;\n            for (int j=A+1;j<=2*A;j++) {\n                if (i == j) continue;\n                num *= (rN - j);\n                den *= (i - j);\n            }\n            ans += term * (num / den);\n        }\n\n        cout << ans * modnum<MOD>::fact(rN-A) << endl;\n    }\n    \n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\ntypedef long long ll;\nconst int N=1e7;\nint fact[N+5],inv[N+5],Inv[N+5];\nint power(int x,int y){\n\tint ret=1;\n\tdo{\n\t\tif(y&1)ret=(ll)ret*x%mod;\n\t\tx=(ll)x*x%mod;\n\t}while(y>>=1);\n\treturn ret;\n}\nint n,A;\ninline void add(int &x,int y){\n\tx+=y;if(x>=mod)x-=mod;\n}\ninline void sub(int &x,int y){\n\tx-=y;if(x<0)x+=mod;\n}\ninline int comb(int nn,int mm){\n\treturn (ll)fact[nn]*inv[mm]%mod*inv[nn-mm]%mod;\n}\nint main(){\n\tfact[0]=1;for(int i=1;i<=N;i++)fact[i]=(ll)fact[i-1]*i%mod;\n\tinv[N]=power(fact[N],mod-2);for(int i=N-1;i>=0;i--)inv[i]=(ll)inv[i+1]*(i+1)%mod;\n\tfor(int i=1;i<=N;i++)Inv[i]=(ll)fact[i-1]*inv[i]%mod;\n\tcin>>n>>A;\n\tint ans=0;\n\tfor(int t=2;t<=A+1;t++){\n\t\tint a=t-1,b=max(0,A-t),c=n-A;\n\t\tfor(int d=0;d<=a;d++){\n\t\t\tif(d&1)sub(ans,(ll)comb(a,d)*fact[a+b+c-d]%mod*(a-d)%mod*Inv[a-d+c]%mod);\n\t\t\telse add(ans,(ll)comb(a,d)*fact[a+b+c-d]%mod*(a-d)%mod*Inv[a-d+c]%mod);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\ntypedef long long LL;\nconst int Mod = 1000000007;\nconst int MN = 10000005, MA = 5005;\n\ninline int qPow(int b, int e) {\n\tint a = 1;\n\tfor (; e; e >>= 1, b = (LL)b * b % Mod)\n\t\tif (e & 1) a = (LL)a * b % Mod;\n\treturn a;\n}\n\nint Fac[MN], iFac[MN], Inv[MN];\ninline void Init(int N) {\n\tFac[0] = 1;\n\tfor (int i = 1; i <= N; ++i) Fac[i] = (LL)Fac[i - 1] * i % Mod;\n\tiFac[N] = qPow(Fac[N], Mod - 2);\n\tfor (int i = N; i >= 1; --i) iFac[i - 1] = (LL)iFac[i] * i % Mod; \n\tfor (int i = 1; i <= N; ++i) Inv[i] = (LL)iFac[i] * Fac[i - 1] % Mod;\n}\ninline int Binom(int N, int M) {\n\treturn (LL)Fac[N] * iFac[M] % Mod * iFac[N - M] % Mod;\n}\n\nint N, A;\n\nint main() {\n\tscanf(\"%d%d\", &N, &A);\n\tInit(N);\n\tint Ans = 0;\n\tfor (int t = 2; t <= A + 1; ++t) {\n\t\tint a = t - 1, b = N - A, c = t <= A ? A - t : 0;\n\t\tfor (int d = 0; d <= a; ++d)\n\t\t\tAns = (Ans + (d & 1 ? -1ll : 1ll) * Binom(a, d) * Fac[a - d + b + c] % Mod * (a - d) % Mod * Inv[a - d + b]) % Mod;\n\t}\n\tprintf(\"%d\\n\", (Ans + Mod) % Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 5005;\nconst int MAXM = 10000005;\nconst int MOD = 1000000007;\n\nint n,A,ans;\nint fac[MAXM];\nint inv[MAXM];\nint v[MAXN][MAXN];\n\nint power(int a,int b)\n{\n\tint res = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1)\n\t\t\tres = (ll)res * a % MOD;\n\t\ta = (ll)a * a % MOD;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nll C(int x,int y)\n{\n\treturn (ll)fac[x] * inv[y] % MOD * inv[x - y] % MOD;\n}\n\nll getv(int l,int r)\n{\n\treturn (ll)fac[r] * inv[l - 1] % MOD;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&A);\n\tfac[0] = 1;\n\tfor (int i = 1;i <= n;i++)\n\t\tfac[i] = (ll)fac[i - 1] * i % MOD;\n\tinv[n] = power(fac[n],MOD - 2);\n\tfor (int i = n;i >= 1;i--)\n\t\tinv[i - 1] = (ll)inv[i] * i % MOD;\n\tfor (int i = 1;i <= A;i++)\n\t{\n\t\tint res = 0,ed = min(i + 1,A);\n\t\tfor (int j = 0;j <= i;j++)\n\t\t\t(res += (j & 1 ? -1ll : 1ll) * C(i,j) * fac[i - j] % MOD * getv(i - j,i - j + n - A - 1) % MOD * getv(i - j + n - A + 1,i - j + n - ed) % MOD) %= MOD;\n\t\t(ans += res) %= MOD;\n\t}\n\tprintf(\"%d\\n\",(ans + MOD) % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ui unsigned int\n#define ull unsigned ll\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define db long double\n#define mp make_pair\n#define X first\n#define Y second\n#define vi vector<int>\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,b,a) for(int i=(b);i>=(a);--i)\n#define rep0(i,a,b) for(int i=(a);i<(b);++i)\n#define fore(i,a) for(int i=0;i<(a).size();++i)\n#define ls x<<1,l,m\n#define rs x<<1|1,m+1,r\n#define gc getchar\ninline ll rd()\n{\n\tll x=0,w=1;char c=gc();while(!isdigit(c)&&c!='-')c=gc();\n\tif(c=='-')c=gc(),w=-1;while(isdigit(c))x=x*10+c-48,c=gc();return x*w;\n}\nconst int N=1e7+5,P=1e9+7;\nint n,m,ans,fac[N],ifac[N],iv[N];\ninline int C(int a,int b){return a<b||b<0?0:1ll*fac[a]*ifac[b]%P*ifac[a-b]%P;}\ninline int D(int a,int b,int c){return 1ll*fac[a+b+c]*a%P*iv[a+c]%P;}\nint main()\n{\n\tfac[0]=1;rep0(i,1,N)fac[i]=1ll*fac[i-1]*i%P;\n\tiv[1]=1;rep0(i,2,N)iv[i]=1ll*(P-P/i)*iv[P%i]%P;\n\tifac[0]=1;rep0(i,1,N)ifac[i]=1ll*ifac[i-1]*iv[i]%P;\n\tn=rd();m=rd();\n\trep(i,1,m+1)rep(j,0,i-1)\n\t\tans=(ans+1ll*(j&1?P-1:1)*C(i-1,j)%P*D(i-1-j,max(0,m-i),n-m))%P;\n\tprintf(\"%d\\n\",ans);return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  ll n,a,dp[5100][5100][5]={},ans=0,co[5100]={};\n  cin >> n >> a;\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[i][j][0]*KAI(i)%MOD*KAI(n-a)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  ll n,a,dp[5100][5100][5]={},ans=0,co[5100]={};\n  cin >> n >> a;\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[0][0][2]*KAI(i)%MOD*KAI(n-a)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef vector<int> vi;\ntypedef pair<int, int> ii;\n\nconst int64 MODULO = (int64) 1e9 + 7;\n\ntypedef long long ll;\n#define SZ 233333\nconst int MOD=1e9+7; //or any prime\nll qp(ll a,ll b)\n{\n  ll x=1; a%=MOD;\n  while(b)\n  {\n    if(b&1) x=x*a%MOD;\n    a=a*a%MOD; b>>=1;\n  }\n  return x;\n}\nnamespace linear_seq {\n  inline vector<int> BM(vector<int> x)\n  {\n    //ls: (shortest) relation sequence (after filling zeroes) so far\n    //cur: current relation sequence\n    vector<int> ls,cur;\n    //lf: the position of ls (t')\n    //ld: delta of ls (v')\n    int lf,ld;\n    for(int i=0;i<int(x.size());++i)\n    {\n      ll t=0;\n      //evaluate at position i\n      for(int j=0;j<int(cur.size());++j)\n        t=(t+x[i-j-1]*(ll)cur[j])%MOD;\n      if((t-x[i])%MOD==0) continue; //good so far\n      //first non-zero position\n      if(!cur.size())\n      {\n        cur.resize(i+1);\n        lf=i; ld=(t-x[i])%MOD;\n        continue;\n      }\n      //cur=cur-c/ld*(x[i]-t)\n      ll k=-(x[i]-t)*qp(ld,MOD-2)%MOD/*1/ld*/;\n      vector<int> c(i-lf-1); //add zeroes in front\n      c.pb(k);\n      for(int j=0;j<int(ls.size());++j)\n        c.pb(-ls[j]*k%MOD);\n      if(c.size()<cur.size()) c.resize(cur.size());\n      for(int j=0;j<int(cur.size());++j)\n        c[j]=(c[j]+cur[j])%MOD;\n      //if cur is better than ls, change ls to cur\n      if(i-lf+(int)ls.size()>=(int)cur.size())\n        ls=cur,lf=i,ld=(t-x[i])%MOD;\n      cur=c;\n    }\n    for(int i=0;i<int(cur.size());++i)\n      cur[i]=(cur[i]%MOD+MOD)%MOD;\n    return cur;\n  }\n  int m; //length of recurrence\n//a: first terms\n//h: relation\n  ll a[SZ],h[SZ],t_[SZ],s[SZ],t[SZ];\n//calculate p*q mod f\n  inline void mull(ll*p,ll*q)\n  {\n    for(int i=0;i<m+m;++i) t_[i]=0;\n    for(int i=0;i<m;++i) if(p[i])\n        for(int j=0;j<m;++j)\n          t_[i+j]=(t_[i+j]+p[i]*q[j])%MOD;\n    for(int i=m+m-1;i>=m;--i) if(t_[i])\n        //miuns t_[i]x^{i-m}(x^m-\\sum_{j=0}^{m-1} x^{m-j-1}h_j)\n        for(int j=m-1;~j;--j)\n          t_[i-j-1]=(t_[i-j-1]+t_[i]*h[j])%MOD;\n    for(int i=0;i<m;++i) p[i]=t_[i];\n  }\n  inline ll calc(ll K)\n  {\n    for(int i=m;~i;--i)\n      s[i]=t[i]=0;\n    //init\n    s[0]=1; if(m!=1) t[1]=1; else t[0]=h[0];\n    //binary-exponentiation\n    while(K)\n    {\n      if(K&1) mull(s,t);\n      mull(t,t); K>>=1;\n    }\n    ll su=0;\n    for(int i=0;i<m;++i) su=(su+s[i]*a[i])%MOD;\n    return (su%MOD+MOD)%MOD;\n  }\n  inline int work(vector<int> x,ll n)\n  {\n    if(n<int(x.size())) return x[n];\n    vector<int> v=BM(x); m=v.size(); if(!m) return 0;\n    for(int i=0;i<m;++i) h[i]=v[i],a[i]=x[i];\n    return calc(n);\n  }\n}\n\nclass TaskD {\n public:\n  void solveOne(istream &in, ostream &out) {\n    int N, A;\n    in >> N >> A;\n    int bound = 3 * A;\n    vector<vector<int>> w0(min(N, bound) + 1, vector<int>(A + 1));\n    vector<vector<int>> w1(min(N, bound) + 1, vector<int>(A + 1));\n    vector<int64> fact(N + 1);\n    fact[0] = 1;\n    for (int i = 1; i <= N; ++i) {\n      fact[i] = i * fact[i - 1] % MODULO;\n    }\n    for (int n = 1; n < w0.size(); ++n) {\n      for (int a = 1; a <= A && a <= n; ++a) {\n        if (a == n) {\n          w0[n][a] = fact[n];\n          w1[n][a] = fact[n];\n        } else {\n          w0[n][a] = ((n - a) * (int64) w1[n - 1][a] + (a - 1) * (int64) w1[n - 1][a - 1]) % MODULO;\n          w1[n][a] = (w0[n - 1][a - 1] + w0[n][a]) % MODULO;\n        }\n      }\n    }\n    vector<int> seq(w0.size() - A);\n    for (int i = A; i < w0.size(); ++i) seq[i - A] = w0[i][A] * qp(fact[i - A], MODULO - 2) % MODULO;\n    out << linear_seq::work(seq, N - A) * fact[N - A] % MODULO << \"\\n\";\n  }\n\n  void solve(std::istream &in, std::ostream &out) {\n    int nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne(in, out);\n    }\n  }\n};\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  TaskD solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  int n,a,dp[3001][3001][3]={},ans=0,co[5100]={};\n  cin >> n >> a;\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[i][j][2]*KAI(i)%MOD*KAI(n-a)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  int n,a,dp[5010][5010][4]={},ans=0,co[5100]={};\n  cin >> n >> a;\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[i][j][2]*KAI(i)%MOD*KAI(n-a)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst ld eps=1e-7;\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod=1000000007;\nconst int MAXN=10000010, N=5010;\n\nll n, m, k, u, v, x, y, t, a, b, ans;\nll F[MAXN], I[MAXN];\nll dp[N];\n\nll powmod(ll a, ll b){\n\tll res=1;\n\tfor (; b; b>>=1, a=a*a%mod) if (b&1) res=res*a%mod;\n\treturn res;\n}\n\nll nCr(ll n, ll r){\n\tif (r<0 || r>n) return 0;\n\treturn F[n]*I[r]%mod*I[n-r]%mod;\n}\n\nll Count(ll n, ll m, ll k){\n\treturn F[n+m-1]*I[n-1]%mod*F[n]%mod*F[n+m+k]%mod*I[n+m]%mod;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tF[0]=1;\n\tfor (int i=1; i<MAXN; i++) F[i]=F[i-1]*i%mod;\n\tI[MAXN-1]=powmod(F[MAXN-1], mod-2);\n\tfor (int i=MAXN-1; i; i--) I[i-1]=I[i]*i%mod;\n\tdp[0]=1;\n\tfor (int n=2; n<N; n++) dp[n]=(dp[n-1] + dp[n-2])*(n-1ll)%mod;\n\t\n\tcin>>m>>n;\n\tfor (int i=2; i<=n; i++){\n\t\tfor (int t=0; t<i-1; t++){\n\t\t\tll tmp=nCr(i-1, t)*Count(i-1-t, m-n, n-i)%mod;\n\t\t\tif (t&1) tmp*=-1;\n\t\t\tans=(ans + tmp)%mod;\n\t\t}\n\t}\n\tfor (int t=0; t<n; t++){\n\t\tll tmp=nCr(n, t)*Count(n-t, m-n, 0)%mod;\n\t\tif (t&1) tmp*=-1;\n\t\tans=(ans + tmp)%mod;\n\t}\n\t\n\t//debug(ans)\n\tif (ans<0) ans+=mod;\n\tcout<<ans<<'\\n';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  int n,a,dp[5010][5010][3]={},ans=0,co[5100]={};\n  cin >> n >> a;\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[i][j][2]*KAI(i)%MOD*KAI(n-a)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 10000010, P = 998244353;\nint n, A, fact[maxn], finv[maxn], inv[maxn];\n\nint main() {\n    scanf(\"%d %d\", &n, &A);\n    fact[0] = finv[0] = inv[0] = inv[1] = 1;\n    for (int i = 1; i <= n; i++) {\n        fact[i] = 1LL * i * fact[i - 1] % P;\n        if (i > 1) inv[i] = 1LL * (P - P / i) * inv[P % i] % P;\n        finv[i] = 1LL * finv[i - 1] * inv[i] % P;\n    }\n    auto C = [&](int x, int y) {\n        return 1LL * fact[x] * finv[y] % P * finv[x - y] % P;\n    };\n    int ans = 0;\n    for (int t = 2; t <= A + 1; t++) {\n        int a = t - 1, b = n - A, c = max(0, A - t);\n        for (int j = 0; j <= a; j++) {\n            int coef = j & 1 ? P - 1 : 1;\n            ans = (ans + 1LL * coef * C(a, j) % P * (a - j) % P * inv[a - j + b]\n                % P * fact[a - j + b + c]) % P;\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 5005\n#define MX 10000005\n#define MOD 1000000007\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nll inv[MX],fac[MX],finv[MX];\nll dp[SIZE][SIZE];\nll naive[SIZE][SIZE];\nll dp2[SIZE];\nll rt[SIZE];\n\nvoid make()\n{\n\tinv[1]=1;\n\tfac[0]=fac[1]=1;\n\tfinv[0]=finv[1]=1;\n\tfor(int i=2;i<MX;i++)\n\t{\n\t\tinv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n\t\tfac[i]=fac[i-1]*(ll) i%MOD;\n\t\tfinv[i]=finv[i-1]*inv[i]%MOD;\n\t}\n\trt[0]=1;\n\tfor(int i=1;i<SIZE;i++) rt[i]=rt[i-1]*2LL%MOD;\n}\nll C(int a,int b)\n{\n\tif(a<b) return 0;\n\treturn fac[a]*(finv[b]*finv[a-b]%MOD)%MOD;\n}\nint main()\n{\n\tmake();\n\tint n,A;\n\tscanf(\"%d %d\",&n,&A);\n\tfor(int i=0;i<=A;i++)\n\t{\n\t\tdp2[i]=1;\n\t\tfor(int j=2;j<=i;j++)\n\t\t{\n\t\t\tdp2[i]-=inv[i];\n\t\t\tif(dp2[i]<0) dp2[i]+=MOD;\n\t\t}\n\t}\n\tint B=n-A;\n\tdp[0][0]=1;\n\tll ret=0;\n\tfor(int i=0;i<=A;i++)\n\t{\n\t\tll sum=0;\n\t\tfor(int j=0;j<=A;j++)\n\t\t{\n\t\t\tif(i>0||j>0)\n\t\t\t{\n\t\t\t\tll now=sum;\n\t\t\t\tif(i>0&&j>0)\n\t\t\t\t{\n\t\t\t\t\tnow+=dp[i-1][j-1]*inv[A-j+1]%MOD;\n\t\t\t\t\tif(now>=MOD) now-=MOD;\n\t\t\t\t}\n\t\t\t\tdp[i][j]=now;\n\t\t\t\tif(j>0)\n\t\t\t\t{\n\t\t\t\t\tsum+=dp[i][j-1]*inv[A-j+1]%MOD;\n\t\t\t\t\tif(sum>=MOD) sum-=MOD;\n\t\t\t\t}\n\t\t\t\tif(dp[i][j]>0&&i<=B)\n\t\t\t\t{\n\t\t\t\t\tret+=C(B+j-i-1,j-1)*dp[i][j]%MOD*dp2[A-j]%MOD;\n\t\t\t\t\tif(ret>=MOD) ret-=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret*fac[A]%MOD*fac[B]%MOD);\n\t/*\n\tll ret2=0;\n\tnaive[A][B]=fac[A]*fac[B]%MOD;\n\tfor(int i=A;i>=0;i--)\n\t{\n\t\tfor(int j=B;j>=0;j--)\n\t\t{\n\t\t\tfor(int k=1;k<=i;k++)\n\t\t\t{\n\t\t\t\tfor(int l=0;l<=j;l++)\n\t\t\t\t{\n\t\t\t\t\tif(k+l==1) continue;\n\t\t\t\t\tll vl=naive[i][j]*C(k+l-1,k-1)%MOD*inv[i]%MOD;\n\t\t\t\t\tnaive[i-k][j-l]+=vl;\n\t\t\t\t\tif(naive[i-k][j-l]>=MOD) naive[i-k][j-l]-=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=A;i++)\n\t{\n\t\tret2+=naive[i][0]*dp2[i]%MOD;\n\t\tif(ret2>=MOD) ret2-=MOD;\n\t}\n\tprintf(\"%lld\\n\",ret2);*/\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define st first\n#define nd second\n\nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n\nconst int kMaxA = 6000;\nconst int kMaxN = 1.2e7;\nconst int mod = 1e9 + 7;\n\nint fact[kMaxN];\nint inv_fact[kMaxN];\n\nint PowMod(int a, int n) {\n\tint r = 1;\n\twhile (n) {\n\t\tif (n & 1) { r = (ll)r * a % mod; }\n\t\tn >>= 1;\n\t\ta = (ll)a * a % mod;\n\t}\n\treturn r;\n}\n\nvoid Preproc() {\n\tfact[0] = 1;\n\tfor (int i = 1; i < kMaxN; ++i) {\n\t\tfact[i] = (ll)fact[i-1] * i % mod;\n\t}\n\tinv_fact[kMaxN - 1] = PowMod(fact[kMaxN - 1], mod - 2);\n\tfor (int i = kMaxN - 2; i >= 0; --i) {\n\t\tinv_fact[i] = (ll)inv_fact[i + 1] * (i + 1) % mod;\n\t}\n}\n\nint Binom(int n, int k) {\n\tif (k < 0 || k > n) { return 0; }\n\tint ans = (ll)fact[n] * inv_fact[k] % mod;\n\treturn (ll)ans * inv_fact[n-k] % mod;\n}\n\nint N, A;\n\nint some_fill_ways[kMaxA];\n//~ int all_fill_ways[kMaxA];\nint dpx[kMaxA][kMaxA];\n\ninline void Add(int &x, int y) {\n\tx += y;\n\tif (x >= mod) { x -= mod; }\n}\ninline void Sub(int &x, int y) {\n\tx -= y;\n\tif (x < 0) { x += mod; }\n}\ninline void Mul(int &x, int y) {\n\tx = (ll)x * y % mod;\n}\n\nvoid MakeWays() {\n\tconst int L = N - A;\n\tfor (int k = 1; k <= A; ++k) {\n\t\tsome_fill_ways[k] = (ll)fact[k + L - 1] * inv_fact[k - 1] % mod;\n\t}\n\n\tfor (int s = 0; s <= A; ++s) {\n\t\tfor (int m = 0; m <= s; ++m) {\n\t\t\tif (m == 0) {\n\t\t\t\tdpx[s][m] = some_fill_ways[s];\n\t\t\t} else {\n\t\t\t\tdpx[s][m] = dpx[s][m - 1];\n\t\t\t\tSub(dpx[s][m], dpx[s - 1][m - 1]);\n\t\t\t}\n\n\t\t\tdebug() << imie(s) << imie(m) << imie(dpx[s][m]);\n\t\t}\n\t}\n}\n\nint dp[kMaxA][kMaxA];\nint cyc[kMaxA][kMaxA];\n\nvoid MakeDP() {\n\tfor (int rem_left = 0; rem_left <= A; ++rem_left) {\n\t\tfor (int k = A; k >= 0; --k) {\n\t\t\tint start_coef = dpx[A - rem_left][k];\n\t\t\tif (rem_left >= 1) {\n\t\t\t\tMul(start_coef, fact[rem_left - 1]);\n\t\t\t}\n\t\t\tdp[rem_left][k] = start_coef;\n\t\t\tif (rem_left) {\n\t\t\t\tAdd(dp[rem_left][k], dp[rem_left - 1][k + 1]);\n\t\t\t\tAdd(dp[rem_left][k], cyc[rem_left - 1][k]);\n\n\t\t\t\tAdd(cyc[rem_left][k], cyc[rem_left - 1][k]);\n\t\t\t\tAdd(cyc[rem_left][k], dp[rem_left - 1][k]);\n\t\t\t\tMul(cyc[rem_left][k], rem_left);\n\t\t\t}\n\n\t\t\tdebug() << imie(rem_left) << imie(k) << imie(dp[rem_left][k]) <<\n\t\t\t\timie(cyc[rem_left][k]);\n\t\t}\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(11);\n\tcerr << fixed << setprecision(6);\n\n\tPreproc();\n\tcin >> N >> A;\n\n\tMakeWays();\n\tMakeDP();\n\tcout << dp[A][0] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define PI 3.14159265358979323846\n#define int long long\nconstexpr long long INF = numeric_limits<long long>::max() / 2;\nconstexpr int MOD = 1000000007;\nusing Graph = vector<vector<int>>;\n\n\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    string S;\n    cin>>S;\n    int N=S.size();\n\n    int co=0;\n    int c=0;\n    int ans=0;\n    int c0=0,c1=0,cq=0;\n    rep(i,N){\n        if(S[i]=='0')c0++;\n        else if(S[i]=='1')c1++;\n        else cq++;\n    }\n    int mx=0;\n    int mn=0;\n    int no=-1;\n    rep(i,N){\n        if(S[i]=='?')co++;\n        if(S[i]=='1'){\n            \n        }\n        if(S[i]=='0'){\n\n        }\n    }\n\n    \n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>bool chmax(t&a,u b){if(a<b)a=b;return a<b;}\ntemplate<class t,class u>bool chmin(t&a,u b){if(b<a)a=b;return b<a;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n\tint size(){\n\t\treturn v.size();\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\n//uint MODULAR=998244353;\nuint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\nll n,a;\nMint dp[5005][5005];\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tInitfact();\n\tcin>>n>>a;\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=a;j++){\n\t\t\tif(i==j){\n\t\t\t\tdp[i][j]=fact[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(ll x=0;x<j;x++){\n\t\t\t\tfor(ll y=0;y<=i-j;y++){\n\t\t\t\t\tif(x==0&&y==0)continue;\n\t\t\t\t\tdp[i][j]+=comb(j-1,x)*comb(i-j,y)*fact[x+y]*dp[i-x-y-1][j-x-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprint(dp[n][a]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")   //\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define per(i, b, a) for(int i = b - 1; i >= a; i--)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nunsigned seed = std::chrono::system_clock::now().time_since_epoch().count();\nstd::mt19937 eng(seed);\n\nuniform_int_distribution<> DD(0, (1ll << 31));\n\nll random2(){\n    return (ll(DD(eng))*(1ll << 31) + ll(DD(eng))) & ((1ll << 62ll)-1);\n}\n\nll n,m,k,q,T;\n\nconst ll big = 1000000007;\nconst ll big2 = 1000000009;\nconst ll mod =  998244353;\n\n\nconst int MAXN = 10000001;\n\nll FAC2[MAXN] = {0};\nll FAC[MAXN] = {0};\nll IFAC[MAXN] = {0};\n\nll upp(ll i, ll j){\n    if(j == 0)return 1;\n    ll h = upp(i,j/2);\n    if(j%2 == 0)return (h*h)%big;\n    return (i*((h*h)%big))%big;\n}\n\nll DP[5002][5002] = {0};\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"autput.txt\",\"w\",stdout);\n\n    ll a,b,c,d,e;\n\n    cin >> n >> m;\n\n    ll nf = 1;\n    ll nf2 = 1;\n\n    rep(c1,0,n){\n        FAC2[c1] = nf2;\n        nf2 *= ll(n-c1);\n        nf2 %= big;\n        FAC[c1] = nf;\n        nf *= ll(c1+1);\n        nf %= big;\n    }\n\n    rep(c1,0,m+1){\n        IFAC[c1] = upp(FAC[c1], big-2);\n    }\n\n    ll no_self = 0;\n    ll t = 1;\n    for(ll s = 0; s <= m; s++){\n        ll bin = (((FAC[m]*IFAC[s])%big)*IFAC[m-s])%big;\n        no_self += t * (bin*(((m-s) * FAC[n-s-1])%big))%big;\n        if(no_self < 0)no_self += big;\n        if(no_self >= big)no_self -= big;\n\n        t *= -1;\n    }\n\n    ll ans = no_self;\n\n\n    ll self_cyc = 0;\n\n\n    for(ll M = m; M >= 0; M--){\n        for(ll x = 0; x <= m; x++){\n            if(n-M-x-2 < 0){\n                DP[M][x] = 0;\n                continue;\n            }\n            if(x == 0){\n                DP[M][x] = FAC[n-M-2];\n                continue;\n            }\n            if(M == m){\n                DP[M][x] = 0;\n                for(ll b = 0; b <= x; b++){\n                    DP[M][x] += IFAC[x-b]*((FAC[n-M-b-2] * FAC[x])%big);\n                    DP[M][x] %= big;\n                }\n                continue;\n            }\n            DP[M][x] = x*DP[M+1][x-1] + FAC[n-M-2];// + FAC[n-M-2-x] * FAC[x];\n            DP[M][x] %= big;\n        }\n    }\n\n    for(ll x = 2; x <= m; x++){\n\n        ll t = 1;\n        for(ll s = 0; s < x-1; s++){\n            ll ts = big+t;\n            ts *= (x-1-s);\n            ts %= big;\n            ts *= FAC[x-1];\n            ts %= big;\n            ts *= IFAC[s];\n            ts %= big;\n            ts *= IFAC[x-1-s];\n            ts %= big;\n\n            ans += ts*DP[s][m-x];\n            ans %= big;\n\n            t *= -1;\n        }\n\n    }\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 1000000007\nusing namespace std;\n#define gc getchar\ninline ll read(){\n    register ll x=0,f=1;char ch=gc();\n    while (!isdigit(ch)){if (ch=='-') f=-1;ch=gc();}\n    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}\n    return (f==1)?x:-x;\n}\nll n,A,fac[10000001],inv[10000001],_inv[10000001];\ninline ll getC(ll n,ll m){\n    if (n<m) return 0;\n    return fac[n]*_inv[m]%ljc*_inv[n-m]%ljc;\n}\ninline ll query(ll i1,ll i2){\n\tif (i1<=0||i2<=0||i1>i2) return 0;\n\treturn fac[i2]*_inv[i1-1]%ljc;\n}\ninline solve(ll i1,ll i2){\n\tif (n-A<i1) return 0; \n\treturn query(n-A-i1+1,n-A)*query(i1+i2,i2-n-A+1)%ljc*query(n-A+i1+i2+2,n)%ljc;\n}\nll dp[5001][5001],sum[5001][5001];\ninline void add(ll &a,ll b){a+=b;a%=ljc;}\nsigned main(){\n    fac[0]=inv[0]=inv[1]=_inv[0]=1;\n    for (ll i=1;i<=10000000;i++) fac[i]=fac[i-1]*i%ljc;\n    for (ll i=2;i<=10000000;i++) inv[i]=(ljc-inv[ljc%i]*(ljc/i)%ljc)%ljc;\n    for (ll i=1;i<=10000000;i++) _inv[i]=_inv[i-1]*inv[i]%ljc;\n    n=read(),A=read(); \n//    for (int i1=0;i1<=A;i1++){\n//    \tfor (int i2=0;i2+i1<=A;i2++){\n//    \t\tif (i1==0&&i2==0){\n//    \t\t\tdp[0][0]=1;continue;\n//\t\t\t}\n//    \t\tif (i2) add(dp[i1][i2],dp[i1][i2-1]);\n//    \t\tfor (int j=1;j<i1;j++) add(dp[i1][i2],dp[i1-j-1][i2]*getC(i1+i2-1,j)%ljc);\n//\t\t}\n//\t}\n//\tll _=0;\n//\tfor (int i=2;i<=A+1;i++){\n//\t\tfor (int i1=0;i1<i;i1++){\n//\t\t\t_=(_+solve(i1,i-1-i1)*dp[i1][i-1-i1]%ljc)%ljc;\t\t\t\t\n//\t\t}\n//\t}\n\tll _=0;\n\tfor (int T=2;T<=A+1;T++) {\n\t\tint x=T-1,y=max(A-T,0ll),z=n-A;\n\t\tfor (int i=0;i<T;i++){\n\t\t\tif (i&1) add(_,ljc-getC(x,i)*(x-i)%ljc*inv[x-i+z]%ljc*fac[x-i+y+z]%ljc);\n\t\t\telse add(_,getC(x,i)*(ll)(x-i)%ljc*inv[x-i+z]%ljc*fac[x-i+y+z]%ljc);\n\t\t} \n\t}\n\tcout<<_;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define SZ(x) ((int)x.size())\n#define ALL(x) x.begin(),x.end()\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> T gcd(T a, T b){return !b?a:gcd(b,a%b);}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 1e7+11, mo = 1e9+7, inv2 =(mo+1)/2;\nconst ll MOD=7LL*mo*mo;\ninline void add(int &x, int y){x=x+y<mo?x+y:x+y-mo;}\ninline void sub(int &x, int y){x=x-y>=0?x-y:x-y+mo;}\ninline int power(int a, int n) {\n\tint res=1;\n\twhile (n) {\n\t\tif (n&1) res=1LL*res*a%mo;\n\t\ta=1LL*a*a%mo; n>>=1;\n\t}\n\treturn res;\n}\n\nint fac[N],ifac[N];\nvoid iniC(int n){\n\tfac[0]=1;rep(i,1,n)fac[i]=1LL*fac[i-1]*i%mo;\n\tifac[n]=power(fac[n],mo-2);\n\tper(i,n-1,0)ifac[i]=1LL*ifac[i+1]*(i+1)%mo;\n}\ninline int C(int n, int m){return m>=0&&m<=n?1LL*fac[n]*ifac[m]%mo*ifac[n-m]%mo:0;}\nint res;\nint calc(int a, int t, int b){\n\treturn 1ll*fac[a+b-1]*a%mo*fac[a+b+t]%mo*ifac[a+b]%mo;\n}\nint getans(int a, int t, int b){\n\tint res=0;rep(i,0,a)res=(res+1ll*(i&1?mo-1:1)*C(a,i)%mo*calc(a-i,t,b))%mo;\n\treturn res;\n}\nint main() {\n\tint n,a;read(n);read(a);iniC(n+1);\n\tres=getans(a,0,n-a);\n\trep(i,1,a)add(res,getans(i-1,a-i,n-a));\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  ll n,a,dp[5100][5100][3]={},ans=0,co[11000000]={},kai[11000000]={};\n  cin >> n >> a;\n  co[0]=1;\n  kai[0]=1;\n  rep(i,10500000)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  rep(i,10500000)kai[i+1]=kai[i]*(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[i][j][2]*kai[i]%MOD*kai[n-a]%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing v_bool = vector<bool>;\nusing v_Pii = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n    mint Catalan(int n){\n        if(n < 0) return 0;\n        else if(n == 0) return 1;\n        if(fact.size() < 2 * n + 1) fact_initialize(2 * n);\n        return fact[2 * n] * invfact[n + 1] * invfact[n];\n    }\n\n};\n\n\n\nsigned main(){\n\n    int N, A; cin >> N >> A;\n    int B = N - A;\n\n    Combination C(N);\n    mint ans = 0;\n    \n    FOR(a, 1, A + 1){\n        int c = max(A - a - 1, 0LL);\n        REP(k, a){\n            mint t = C.nCr(a, k) * C.fact[a - k] * C.nPr(a + B - 1 - k, B) * C.nPr(a + B + c - k, c);\n            if(k % 2 == 0) ans += t;\n            else ans -= t;\n        }\n    }\n\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Awwawa! Dis cold yis ratten buy tEMMIE!\n#include <bits/stdc++.h>\n#define ll long long\n#define maxn 10000005 /*rem*/\n#define mod 1000000007 \n#define db double\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n#define pi pair<int, int>\n#define fi first\n#define se second\n\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,true:false;}\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,true:false;}\n\nusing namespace std;\nll ksm(ll a, ll b) {\n   if (!b) return 1;\n   ll ns = ksm(a, b >> 1);\n   ns = ns * ns % mod;\n   if (b & 1) ns = ns * a % mod;\n   return ns;\n}\nint n, a;\nll jc[maxn], bjc[maxn];\nll bk[20005];\nll pr[5005]; // 恰有\nll tr[5005][5005]; // 有x个自环 钦定若干个不能是 \nll c(int a, int b) {\n\tif (b > a || b < 0) return 0;\n\treturn 1ll * jc[a] * bjc[b] % mod * bjc[a - b] % mod;\n} \nll dp[5005][5005]; //还剩若干个 要求若干个 \nll s[5005][5005];\nint main() {\n\tjc[0] = bjc[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t\tjc[i] = jc[i - 1] * i % mod;\n\tbjc[maxn - 1] = ksm(jc[maxn - 1], mod - 2);\n\tfor (int j = maxn - 2; j >= 0; j--)\n\t\tbjc[j] = bjc[j + 1] * (j + 1) % mod;\n\tfor (int i = 0; i < 20005; i++)\t\n\t\tbk[i] = ksm(i, mod - 2);\n\tint n, k;\n\tcin >> n >> k;\n\tfor (int i = 0; i < k; i++) {\n\t\t// 钦定i个数 假\n\t\tpr[i] = 1;\n\t\tpr[i] = pr[i] * jc[n - i - 1] % mod;\n\t\tpr[i] = pr[i] * bjc[k - i - 1] % mod; \n\t}\n\tfor (int i = 0; i <= k; i++) // 有i个必须交互 j个数不能和后面交互 \n\t\tfor (int j = 0; j <= k - i; j++) {\n\t\t\t//要求i不能是 j必须是\n\t\t\tll er = 0;\n\t\t\tif (i == 0) er = pr[j];\n\t\t\telse {\n\t\t\t\ter = tr[i - 1][j] - tr[i - 1][j + 1];\n\t\t\t\ter %= mod;\n\t\t\t\tif (er < 0) er += mod;\n\t\t\t}\n\t\t\ttr[i][j] = er;\n\t\t}\n\tfor (int i = 0; i <= k; i++)\n\t\tfor (int j = 0; j <= k - i; j++) { // 有j个限制 剩余长度是i \n\t\t\tll mt = bk[i];\n\t\t\tif (i == 0) mt = 1;\n\t\t\tdp[i][j] = tr[j][i] * mt % mod;// * bk[i] % mod; // 当前点要求是自环\n\t\t\tif (i) \n\t\t\t\tdp[i][j] += (s[i - 1][j] - dp[i - 1][j] + dp[i - 1][j + 1]) % mod * bk[i] % mod;\n\t\t\tdp[i][j] %= mod;\n\t\t\tif (i) s[i][j] = s[i - 1][j];\n\t\t\ts[i][j] = (s[i][j] + dp[i][j]) % mod;\n\t\t}\n\tll ans = dp[k][0];\n\tans %= mod;\n\tans = ans * jc[k] % mod;\n\tans %= mod;\n\tif (ans < 0) ans += mod;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ll long long\n#define ld long double\n#define vec vector \n#define vi vector <ll> \n#define vvi vector <vector <ll> > \n#define vvvi vector < vector <vector <ll> > >\n/*\nvi a(n);\nvvi a(n, vi(m));\nvvvi a(n, vvi(m, vi(u)));\nfor(int h = 0; h < n; ++h){\nfor(auto h : b){\n*/\nconst int P = 1e9+7;\nconst int N = 1e7+5;\nint si[N], de[N], inv[N], siv[N];\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    si[0] = 1;\n    de[0] = 1;\n    de[1] = 0;\n    de[2] = 1;\n    for(int i = 1; i < N; ++i)si[i] = (i*si[i-1])%P;\n    for(int i = 2; i < N; ++i)de[i] = ((i-1)*((de[i-2]+de[i-1])%P))%P;\n    inv[0] = inv[1] = 1;\n    for(int i = 2; i < N; ++i){\n        inv[i] = P - (P / i) * inv[P % i] % P;\n    }\n\n    siv[0]=siv[1]=1;\n    for(int i = 1; i < N; ++i)siv[i] = (inv[i]*siv[i-1])%P;\n    /*cout << si[N-1] << ',';\n    cout << inv[N-1] << ',';\n    cout << de[N-1] << ',';\n    cout << siv[N-1] << ',';\n    cout << '\\n';*/\n    //for(int i = 0; i < 10; ++i)cout <<si[i] <<','; cout <<'\\n';\n    //for(int i = 0; i < 10; ++i)cout <<de[i] <<','; cout <<'\\n';\n    //for(int i = 0; i < 10; ++i)cout <<(si[i]*inv[i])%P <<','; cout <<'\\n';\n    //for(int i = 0; i < 10; ++i)cout <<siv[i] <<','; cout <<'\\n';\n    //for(int i = 0; i < 10; ++i)cout <<(siv[i]*si[i])%P <<','; cout <<'\\n';\n    \n    int z=1; \n    //cin >> z;\n    while(z--){\n        int n, k;\n        cin >> n >> k;\n        n -= k;\n        int an = 0;\n        for(int j = 0; j <= n; ++j){\n            int x = 1; \n            x *= si[n]; x %= P;\n            x *= siv[j]; x %= P;\n            x *= siv[n-j]; x %= P;\n            //cerr << \" n po j \" << n << ' ' << j << ' ' << x << '\\n';\n            x *= de[k+j]; x %= P;\n            an += x; an %= P;\n        }\n        //cerr << si[n+k] << '\\n';\n        cout << (si[n+k] - an + P)%P << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e7 + 5;\nconst int MAXM = 5e3 + 5;\nconst int P = 1e9 + 7;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint fac[MAXN], inv[MAXN];\nint power(int x, int y) {\n\tif (y == 0) return 1;\n\tint tmp = power(x, y / 2);\n\tif (y % 2 == 0) return 1ll * tmp * tmp % P;\n\telse return 1ll * tmp * tmp % P * x % P;\n}\nint binom(int x, int y) {\n\tif (y > x) return 0;\n\telse return 1ll * fac[x] * inv[y] % P * inv[x - y] % P;\n}\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nvoid init(int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfac[i] = 1ll * fac[i - 1] * i % P;\n\tinv[n] = power(fac[n], P - 2);\n\tfor (int i = n - 1; i >= 0; i--)\n\t\tinv[i] = inv[i + 1] * (i + 1ll) % P;\n}\nint n, m, dp[MAXM][MAXM], sum[MAXM][MAXM];\nint func(int x, int y) {\n\treturn 1ll * fac[x] * inv[x - y] % P;\n}\nint main() {\n\tread(n), read(m), init(n);\n\tdp[0][0] = 1, sum[0][0] = fac[m - 1];\n\tfor (int i = 1; i <= m; i++)\n\tfor (int j = 0; j <= i; j++) {\n\t\tupdate(dp[i][j], dp[i - 1][j - 1]);\n\t\tif (i >= 2) update(dp[i][j], 1ll * sum[i - 2][j] * inv[m - i] % P);\n\t\tsum[i][j] = (sum[i - 1][j] + 1ll * dp[i][j] * fac[m - i - 1]) % P;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= m; i++)\n\tfor (int j = 0; j <= i && j <= n - m; j++)\n\t\tupdate(ans, 1ll * dp[i][j] * fac[max(m - i - 1, 0)] % P * func(n - m, j) % P * func(i + (n - m - j) - 1, n - m - j) % P);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n\nusing namespace std;\n\nconst int mod = 1000000007;\nconst int N = 10010007;\nconst int M = 5007;\n\nint fact[N];\n\ninline int mult(int a, int b) {\n\treturn ((ll) a * b) % mod;\n}\n\ninline int sum(int a, int b) {\n\tif (a+b < 0) return a+b+mod;\n\tif (a+b >= mod) return a+b-mod;\n\treturn a+b;\n}\n\nint pw(int x, int y) {\n\n\tint ans = 1;\n\tint deg = x;\n\n\tfor (int i = 0; i < 30; ++i) {\n\t\tif ((1<<i)&y) {\n\t\t\tans = mult(ans, deg);\n\t\t}\n\t\tdeg = mult(deg, deg);\n\t}\n\n\treturn ans;\n\n}\n\nint dp[M][M][2][2];\n\nint C(int n, int k) {\n\tint x = mult(pw(fact[k], mod-2), pw(fact[n-k], mod-2));\n\treturn mult(fact[n], x);\n}\n\nint box[M];\n\nint main(){\n#ifdef LOCAL\n\tfreopen(\"F_input.txt\", \"r\", stdin);\n\t//freopen(\"F_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n, k;\n\tcin >> n >> k;\n\n\tfact[0] = 1;\n\tfor (int i = 1; i < N; ++i) fact[i] = mult(fact[i-1], i);\n\n\tdp[0][0][0][0] = 1;\n\n\tfor (int was = 0; was <= k; ++was) {\n\t\tfor (int one = 0; one <= k; ++one) {\n\t\t\tfor (int start = 1; start >= 0; start--) {\n\t\t\t\tfor (int take = 0; take <= 1; ++take) {\n\n\t\t\t\t\tif (!dp[was][one][start][take]) continue;\n\n\t\t\t\t\tif (start == 0) {\n\t\t\t\t\t\tdp[was+1][one+1][0][1] = sum(dp[was+1][one+1][0][1], dp[was][one][start][take]);\n\n\t\t\t\t\t\tint have = k-was;\n\n\t\t\t\t\t\tif (have >= 2) {\n\t\t\t\t\t\t\tdp[was+2][one][1][0] = sum(dp[was+2][one][1][0], mult(dp[was][one][start][take], have - 1));\n\t\t\t\t\t\t\tdp[was+2][one+1][1][1] = sum(dp[was+2][one+1][1][1], mult(dp[was][one][start][take], 2*have - 2));\n\t\t\t\t\t\t\tdp[was+2][one+2][1][1] = sum(dp[was+2][one+2][1][1], mult(dp[was][one][start][take], have-1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\n\t\t\t\t\t\tint have = k-was;\n\n\t\t\t\t\t\tdp[was+1][one+1][1][1] = sum(dp[was+1][one+1][1][1], mult(dp[was][one][start][take], have));\n\t\t\t\t\t\tdp[was+1][one][1][take] = sum(dp[was+1][one][1][take], mult(dp[was][one][start][take], have));\n\t\t\t\t\t\tdp[was][one][0][take] = sum(dp[was][one][0][take], dp[was][one][start][take]);\n\t\t\t\t\t}\n\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\tint dop = n-k;\n\n\tbox[0] = 0;\n\tfor (int i = 1; i < M; ++i) {\n\t\tif (i > dop) continue;\n\t\tbox[i] = C(dop-1, i-1);\n\n\t}\n\n\tfor (int i = 0; i < M; ++i) {\n\t\tbox[i] = mult(box[i], fact[dop]);\n\t}\n\n\t//cout << box[1] << endl;\n\n\t//cout << pw(1, 2) << endl;\n\n\t//cout << dp[2][2][1][1] << endl;\n\n\t//cout << dp[1][1][0][1] << endl;\n\n\tfor (int i = 0; i <= k; ++i) for (int j = 0; j <= k; ++j) {\n\t\tif (!dp[i][j][0][1]) continue;\n\t\tif (j > dop) continue;\n\n\t\tint res = dp[i][j][0][1];\n\n\t\tres = mult(res, box[j]);\n\n\t\tres = mult(res, fact[k-i]);\n/*\n\t\tif (res) {\n\t\t\tcout << res << \" \" << i << \" \" << j << endl;\n\t\t}\n*/\n\t\tans = sum(ans, res);\n\t}\n\n\tcout << ans;\n\n\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=10000005,M=5005;\nconst int MOD=1000000007;\nint n,m;\nlong long ksm(long long a,long long b)\n{\n\tlong long res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD,b>>=1;\n\t}\n\treturn res;\n}\nlong long fac[N],inv[N];\nvoid init(int n=10000000)\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfac[i]=fac[i-1]*i%MOD;\n\tinv[n]=ksm(fac[n],MOD-2);\n\tfor(int i=n;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%MOD;\n\treturn;\n}\nlong long C(int n,int m)\n{\n\tif(m>n) return 0;\n\telse return fac[n]*inv[m]%MOD*inv[n-m]%MOD;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tinit();\n\tlong long ans=0;\n\tfor(int i=1;i<=m+1;i++)\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t\tint a=i-1-j,b=n-m,c=max(m-i,0);\n\t\t\tlong long res=C(i-1,j);\n\t\t\tres=(res*fac[a])%MOD;\n\t\t\tres=(res*fac[a+b-1]%MOD*inv[a-1]%MOD)%MOD;\n\t\t\tres=(res*fac[a+b+c]%MOD*inv[a+b]%MOD)%MOD;\n\t\t\tif(j&1) ans=(ans-res+MOD)%MOD;\n\t\t\telse ans=(ans+res)%MOD;\n\t\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<ll,ll>\n#define poly vector<ll>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\n#define SZ(x) ((int)(x.size()))\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\nll rnd(){\n\tull ans=0;\n\tFor(i,0,4)ans=ans<<15^rand();\n\treturn ans%((ull)1<<63);\n}\nconst int N=10000005,mod=1e9+7;\nll n,m,fac[N],ni[N],alb[5005];\nll c(int a,int b){\n\treturn fac[a]*ni[b]%mod*ni[a-b]%mod;\n}\nll ksm(ll a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1)ans=ans*a%mod;\n\t\ta=a*a%mod;\n\t}\n\treturn ans;\n}\nll inv(int n){\n\treturn fac[n-1]*ni[n]%mod;\n}\nint main(){\n\t#ifdef Brollan\n\t\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tn=read(),m=read();\n\tFor(i,fac[0]=1,n)fac[i]=fac[i-1]*i%mod;\n\tni[n]=ksm(fac[n],mod-2);\n\tRep(i,n,1)ni[i-1]=ni[i]*i%mod;\n\tn-=m;\n\tll ans=0;\n\tFor(i,0,m)alb[i]=i*inv(i+n)%mod;\n\tFor(mn,2,m+1){\n\t\tFor(i,0,mn-2){\n\t\t\t//cout<<n+m-i-1<<\" \"<<endl;\n\t\t\tans=(ans+(i%2?-1:1)*c(mn-1,i)*(mn<=m?fac[n+m-i-1]:fac[n+m-i])%mod\n\t\t\t*alb[mn-i-1])%mod;\n\t\t}\n\t\t//cout<<ans<<endl;\n\t}\n\tcout<<(ans+mod)%mod<<endl;\n\t/*\n\tdp[0][0]=1;\n\tFor(i,0,m-1){\n\t\tFor(j,0,n){\n\t\t\tFor(k,1,m-i){\n\t\t\t\tFor(l,0,n-j){\n\t\t\t\t\tif(j!=n&&k+l==1)continue;\n\t\t\t\t\tdp[i+k][j+l]+=fac[k+l-1]*dp[i][j]*c(m-i,k)*c(n-j,l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[m][n]<<endl;\n\t*/\n}\n/*\n枚举不合法1第一个位置 \nmn-1不能有1 ，容斥这个条件 \nmn-i-1无所谓 \nm-mn无所谓\nn只能连之前的 \n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define M 10000500\n#define N 5200\n\nconst LL mod=1000000007;\nLL n,m,ans,f[N][N],fac[M],ifac[M];\n\nvoid upd(LL &x,LL y){\n\tx=(x+y)%mod;\n}\n\nLL pw(LL x,LL k){\n\tif (!k) return 1;\n\tLL tmp=pw(x*x%mod,k>>1);\n\treturn k&1?tmp*x%mod:tmp;\n}\n\nLL inv(LL x){return x==1?1:(mod-mod/x)*inv(mod%x)%mod;}\n\nLL C(LL x,LL y){\n\treturn x<y||y<0?0:fac[x]*ifac[y]%mod*ifac[x-y]%mod;\n}\n\nvoid calc(LL i,LL j){\n\tLL k=n-i-j;\n\tupd(ans,f[i][j]*C(m-n+k-1,k-1)%mod*fac[m-n]%mod*(i?fac[i-1]:1));\n}\n\nint main(){\n\tscanf(\"%lld%lld\",&m,&n);\n\tfac[0]=1; for (LL i=1;i<=m;++i) fac[i]=fac[i-1]*i%mod;\n\tifac[m]=inv(fac[m]); for (LL i=m-1;~i;--i) ifac[i]=ifac[i+1]*(i+1)%mod;\n\tf[n][0]=1;\n\tfor (LL i=n-1;~i;--i){\n\t\tfor (LL j=0;j<=n-i;++j){\n\t\t\tf[i+1][j]=(f[i+1][j]*fac[i]%mod+f[i+2][j])%mod;\n\t\t}\n\t\tfor (LL j=0;j<=n-i;++j){\n\t\t\tf[i][j]=f[i+1][j]*ifac[i]%mod;\n\t\t\tif (j) upd(f[i][j],-(f[i+1][j-1]-f[i+2][j-1])*ifac[i]);\n\t\t\tcalc(i,j);\n\t\t}\n\t}\n\tupd(ans,mod);\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<int(1e9) + 7>;\n\nvector<num> fact, ifact;\n\nvoid init(){\n\tint N = 20000;\n\tfact = {1};\n\tfor(int i = 1; i < N; i++) fact.push_back(i * fact[i-1]);\n\tifact.resize(N);\n\tifact.back() = 1 / fact.back();\n\tfor(int i = N - 1; i > 0; i--) ifact[i-1] = i * ifact[i];\n}\n\nnum ncr(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\treturn fact[n] * ifact[k] * ifact[n-k];\n}\n\nusing ll = long long;\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tinit();\n\tll n, a;\n\tcin >> n >> a;\n\tnum ans = 0;\n\tconst ll D = 20000;\n\tvector<num> inv(2*D+1, 0);\n\tfor(ll r = -D; r <= D; r++){\n\t\tif(n + r != 0) inv[D+r] = 1 / num(n + r);\n\t}\n\t{\n\t\tnum prob = 0;\n\t\tnum pfixed = 1;\n\t\tfor(ll d = 0; d <= a; d++){\n\t\t\tif(d > 0) pfixed *= inv[D-(d-1)];\n\t\t\tnum mult = ncr(a, d) * ((d & 1) ? -1 : 1);\n\t\t\tprob += mult * pfixed * (a-d) * inv[D-d];\n\t\t}\n\t\tans += prob;\n\t}\n\tfor(ll c = 0; c < a; c++){\n\t\tnum prob = 0;\n\t\tnum pfixed = inv[D];\n\t\tfor(ll d = 0; d <= c; d++){\n\t\t\tif(d > 0) pfixed *= inv[D-d];\n\t\t\tnum mult = ncr(c, d) * ((d & 1) ? -1 : 1);\n\t\t\tprob += mult * pfixed * (c-d) * inv[D-a+c-d];\n\t\t}\n\t\tans += prob;\n\t}\n\tfor(ll i = 1; i <= n; i++) ans *= i;\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  ll n,a,dp[5100][5100][5]={},ans=0,co[5100]={};\n  cin >> n >> a;\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[i][j][2]*KAI(i)%MOD*KAI(n-a)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  ll n,a,dp[5100][5100][3]={},ans=0,co[11000000]={},kai[11000000]={};\n  cin >> n >> a;\n  co[0]=1;\n  kai[0]=1;\n  rep(i,10500000)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  rep(i,10500000)kai[i+1]=kai[i]*(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[i][j][2]*kai[i]%MOD*kai[n-a]%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define debug(x) cerr<<#x<<\" = \"<<x\n#define sp <<\"  \"\n#define el <<endl\n#define fgx cerr<<\" ---------------------------------------------- \"<<endl\n#define LL long long\n#define uint unsigned int \n#define ULL unsigned long long\n#define LDB long double\n#define DB double\n#define pii pair<int,int>\n#define pli pair<LL,int>\n#define mp make_pair\n#define pb push_back\nusing namespace std;\ninline LL read(){\n\tLL nm=0; bool fh=true; char cw=getchar();\n\tfor(;!isdigit(cw);cw=getchar()) fh^=(cw=='-');\n\tfor(;isdigit(cw);cw=getchar()) nm=nm*10+(cw-'0');\n\treturn fh?nm:-nm;\n}\n#define mod 1000000007\nnamespace  CALC{\n\tinline int add(int x,int y){return (x+y>=mod)?(x+y-mod):(x+y);}\n\tinline int mns(int x,int y){return (x-y<0)?(x-y+mod):(x-y);}\n\tinline int mul(LL x,LL y){return x*y%mod;}\n\tinline void upd(int &x,int y){x=(x+y>=mod)?(x+y-mod):(x+y);}\n\tinline void dec(int &x,int y){x=(x-y<0)?(x-y+mod):(x-y);}\n\tinline int qpow(int x,int sq){int res=1;for(;sq;sq>>=1,x=mul(x,x))if(sq&1)res=mul(res,x);return res;}\n}using namespace CALC;\n#define M 10000200\nint n,m,ans;\nint fac[M],ifac[M],iv[M];\ninline int C(int N,int K){return (N<K||K<0)?0:mul(fac[N],mul(ifac[N-K],ifac[K]));}\ninline int G(int A,int B,int C){return mul(fac[A+B+C],mul(A,iv[A+C]));}\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read(),m=read(),fac[0]=ifac[0]=fac[1]=ifac[1]=iv[1]=1;\n\tfor(int i=2;i<=n;i++) fac[i]=mul(fac[i-1],i),iv[i]=mul(mod-mod/i,iv[mod%i]),ifac[i]=mul(ifac[i-1],iv[i]);\n\tfor(int i=0,w;i<=m;i++) w=mul(C(m,i),G(m-i,0,n-m)),(i&1)?dec(ans,w):upd(ans,w);\n\tfor(int i=2,w;i<=m;i++) for(int j=0;j<i;j++)\n\t\tw=mul(C(i-1,j),G(i-1-j,m-i,n-m)),(j&1)?dec(ans,w):upd(ans,w);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define PRIM 3\n#define INF (1 << 29)\n#define LINF (1LL << 60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nInt fact[11000000];\nInt revfact[11000000];\nInt rev[11000000];\n\nvoid init()\n{\n    Int m = MOD;\n    fact[0] = 1;\n    revfact[0] = 1;\n    rev[0] = 0;\n    rev[1] = 1;\n    for (int i = 1; i < 11000000; i++) {\n        fact[i] = fact[i - 1] * i % m;\n        if (i > 1)\n            rev[i] = MOD / i * (MOD - rev[MOD % i]) % MOD;\n        revfact[i] = revfact[i - 1] * rev[i] % MOD;\n    }\n}\n\nInt nCk(Int n, Int k)\n{\n    if (n < k)\n        return 0;\n    return fact[n] * revfact[n - k] % MOD * revfact[k] % MOD;\n}\n\nInt n, a, ans;\nint main()\n{\n    init();\n    cin >> n >> a;\n    for (int t = 1; t <= a + 1; t++) {\n        int on = t - 1;\n        int free = max(0ll, a - t);\n        int off = n - a;\n        for (int loop = 0; loop <= on; loop++) {\n            Int tmp = fact[on - loop + off + free] * (on - loop) % MOD *\n                      rev[on - loop + off] % MOD * nCk(on, loop) % MOD;\n            if (loop % 2 == 0)\n                ans = (ans + tmp) % MOD;\n            else\n                ans = (ans - tmp) % MOD;\n        }\n    }\n    if (ans < 0)\n        ans += MOD;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing v_bool = vector<bool>;\nusing v_Pii = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n    mint Catalan(int n){\n        if(n < 0) return 0;\n        else if(n == 0) return 1;\n        if(fact.size() < 2 * n + 1) fact_initialize(2 * n);\n        return fact[2 * n] * invfact[n + 1] * invfact[n];\n    }\n\n};\n\nmint dp[301][301][301][2] = {};\n\nsigned main(){\n\n    int N, A; cin >> N >> A;\n    if(A > 300) exit(1);\n\n    dp[0][0][0][0] = 1;\n    REP(i, A){\n        REP(j, i + 1) REP(k, j + 1){\n            dp[i + 1][j + 1][k + 1][0] += dp[i][j][k][0];\n            dp[i + 1][j + 1][k][0] += dp[i][j][k][0] * (j - k);\n            if(k > 0) dp[i + 1][j + 1][k - 1][0] += dp[i][j][k][0] * k;\n\n            dp[i + 1][j][k][1] += dp[i][j][k][0];\n\n            dp[i + 1][j][k][1] += dp[i][j][k][1];\n            dp[i + 1][j + 1][k][1] += dp[i][j][k][1] * (j - k);\n            if(k > 0) dp[i + 1][j + 1][k - 1][1] += dp[i][j][k][1] * k;\n        }\n    }\n    \n    Combination C(N);\n    mint ans = 0;\n    int M = N - A;\n    FOR(j, 1, A) FOR(k, 0, j + 1){\n        if(k <= M) ans += dp[A][j][k][1] * C.fact[A - j - 1] * C.nPr(M, k) * C.nPr(j + M - k - 1, M - k);\n    }\n    FOR(k, 0, A + 1){\n        if(k <= M) ans += dp[A][A][k][0] * C.nPr(M, k) * C.nPr(A + M - k - 1, M - k);\n    }\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Konrad Paluszek,University of Warsaw(former XIV LO Staszic)\n//#STAY AT HOME\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#define TIME (chrono::steady_clock::now().time_since_epoch().count())\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#define xfm(a,b)a##b\n#define xwb(a,b)xfm(a,b)\n#define _ xwb(nvj,__LINE__)\n#define __ xwb(kjy,__LINE__)\n#define ___ xwb(cjm,__LINE__)\n#define REP(i,n)for(urs(n)i=0;i<(n);++i)\n#define UNTIL(t)while(clock()<(t)*CLOCKS_PER_SEC)\n#define PER(r...)for(bool _=1;_||next_permutation(r);_=false)\n#define ALL(r)(r).begin(),(r).end()\n#define RALL(r)(r).rbegin(),(r).rend()\n#define FS(r)r.first,r.second\n#define SF(r)r.second,r.first\n#define M0(r) memset(r, 0, sizeof(r))\n#define sim template<class c\n#define ros return o\n#define rans return ans\n#define forbits(i,m)if(m)for(urs(m)i=ctz(m),i##nvj=m;i##nvj;i##nvj^=((urs(m))1<<i),i=ctz(i##nvj))\n#define fordbits(i,m)if(m)for(urs(m)i=8*sizeof(m)-clz(m)-1,i##nxd=m;i##nxd;i##nxd^=((urs(m))1<<i),i=8*sizeof(m)-clz(i##nxd)-1)\n#define ksets(t, m, k, n) for (t m = (((t)1 << (k)) - 1); m < ((t)1 << (n)); m = nux(m))\n#define urs(r...)typename decay<decltype(r)>::type\n#define hur(f,g,r)sim>int f(c a){if(sizeof(c)==16)return r;if(sizeof(c)==8)return g##ll(a);return g(a);}\n#define pwq(t,i) int clz(t x){return clz<int>(x)-i;}\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wconversion\"\nusing namespace __gnu_pbds;using namespace std;using ll=long long;using ld=long double;using ull=unsigned long long;using vi=vector<int>;using vll=vector<ll>;using pii=pair<int,int>;using pll=pair<ll,ll>;using vpii=vector<pii>;using spii=set<pii>;using mii=map<int,int>;using unt=unsigned int;sim>using min_queue=priority_queue<c,vector<c>,greater<c>>;sim,class b,class cmp=less<c> >using ordered_map=tree<c,b,cmp,rb_tree_tag,tree_order_statistics_node_update>;sim, class cmp=less<c>>using ordered_set = ordered_map<c,null_type,cmp>;hur(popc,__builtin_popcount,popc<ull>(a)+popc<ull>(a>>64))hur(ctz,__builtin_ctz,(ull)a?ctz<ull>(a):64+ctz<ull>(a>>64))hur(clz,__builtin_clz,a>>64?clz<ull>(a>>64):64+clz<ull>(a))pwq(short,16)pwq(uint16_t,16)pwq(char,24)pwq(int8_t,24)pwq(uint8_t,24)sim,class N>bool mini(c&o,const N&h){if(o>h)ros=h,1;return 0;}sim,class N>bool maxi(c&o,const N&h){if(o<h)ros=h,1;return 0;}sim,class n>using gyv=c;\n#if defined(LOCAL) // || defined(LOCAL2)\n#include </home/kjp/headers/debuglib.hpp>\n#else\n#define loc(...)\n#define onl(r...)r\n#define debug(...)\n#define print_stack(...)\n#define mark_stack(...)\n#define set_pre(...)\n#define reg_it(...)\n#define def_op(...) struct _{};\n#if !defined(LOCAL) && !defined(LOCAL2)\n#define exit my_exit\nvoid my_exit(int x) {fflush(stdout);_Exit(x);}\n#endif\n#endif\n#define next nexT\n#define prev preV\n#define tree trEE\n#define left lefT\n#define right righT\n#define div diV\n#define y1 y_1\n#define pow do not use cmath pow unless you know what you are doing\null mix(ull o){o+=0x9e3779b97f4a7c15;o=(o^(o>>30))*0xbf58476d1ce4e5b9;o=(o^(o>>27))*0x94d049bb133111eb;ros^(o>>31);}ull SALT=0x7a14a4b0881ebf9,tqu=0x7a14a4b0881ebf9;ull my_rand(){return tqu=mix(tqu);}void my_srand(ull x){SALT=tqu=x;}const int inf = 1023400000;const ll llinf=1234567890000000000ll;ll fix(ll o, ll m){o%=m;if(o<0)o+=m;ros;}\n#define rand my_rand\n#define srand my_srand\n#define random_shuffle(r...)random_shuffle(r,[](int _){return my_rand()%_;})\nsim>inline c nux(c m){if(!m)return numeric_limits<c>::max();c A=m&-m;c B=~((A-1)^m);c C=B&-B;c D=(C>>(1+ctz(A)))-1;return C|(m&~(C-1))|D;}__attribute__((no_sanitize_undefined))ll mul(ll a,ll b,ll m){ll q=(ll)(a*(ld)b/m);ll o=a*b-q*m;o%=m;if(o<0)o+=m;ros;}sim>void unq(c&x){x.resize(unique(ALL(x))-x.begin());}\n#pragma GCC diagnostic pop\n#if ((ULONG_MAX) != (UINT_MAX))\nnamespace std {template <> struct is_signed<__int128> : public true_type {};}\n#endif\nsim, class d> typename common_type<c,d>::type floor_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using floor_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b - (a % b < 0);}\nsim, class d> typename common_type<c,d>::type ceil_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using ceil_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b + (a % b > 0);}\nsim> struct REV {using value_type=typename c::value_type;c &x;using it=typename c::reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> struct CREV {using value_type=typename c::value_type;const c&x;using it=typename c::const_reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> REV<c> reversed(c&x) {return REV<c>{x};}sim> CREV<c> reversed(const c&x) {return CREV<c>{x};}\n#define done(r...) exit(0 * printf(r))\n#if defined(LOCAL) || defined(LOCAL2)\nvoid __tmi() {cerr << setprecision(6) << fixed << \"total time: \" << clock() / (ld)CLOCKS_PER_SEC << \"s\" << endl;}int _ = (atexit(__tmi), 0);\n#endif\n//#STAY AT HOME\nconst int mod = 1e9 + 7, nax = 1e7 + 44;\nll inv(ll x) {\n\tint e = mod - 2;\n\tll r = 1;\n\twhile (e) {\n\t\tif (e & 1) r = r * x % mod;\n\t\tx = x * x % mod;\n\t\te >>= 1;\n\t}\n\treturn r;\n}\nll fac[nax], fin[nax];\nll Inv[nax];\nll cho(int a, int b) {\n\tif (b > a || b < 0) {\n\t\tdebug(imie(a), imie(b), \"warn\");\n\t\treturn 0;\n\t}\n\treturn fac[a] * fin[b] % mod * fin[a - b] % mod;\n}\nint main() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < nax; ++i) fac[i] = fac[i - 1] * i % mod;\n\tfin[nax - 1] = inv(fac[nax - 1]);\n\tfor (int i = 1; i < nax; i++)\n\t\tInv[i] = i == 1 ? 1 : 1ll * (mod - mod / i) * Inv[mod%i] % mod;\n\t// for (int i = 1; i < nax; ++i) assert(Inv[i] * i % mod == 1);\n\tfor (int i = nax - 2; i >= 0; --i) fin[i] = fin[i + 1] * (i + 1) % mod;\n\tint n, a;\n\tscanf(\"%d%d\", &n, &a);\n\tll ans = 0;\n\tfor (int pref = 1; pref <= a; ++pref) {\n\t\tint tot = n - (pref != a);\n\t\tint aft = n - a;\n\t\tfor (int fixed = 0; fixed < pref; ++fixed) {\n\t\t\tint s = fixed % 2 ? -1 : 1;\n\t\t\tll good = fac[tot - fixed] * Inv[pref + aft - fixed] % mod * (pref - fixed) % mod;\n\t\t\tdebug(imie(pref), imie(fixed), imie(s), imie(good));\n\t\t\t(ans += s * good * cho(pref, fixed)) %= mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", fix(ans, mod));\n}\n//#STAY AT HOME\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\nconstexpr dd PI  = 3.1415926535897932;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define each(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll Upper2N(ll s) { return 1LL<<MSB(s)<<1; }//s<2^nなる最小の2^n\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\n[[nodiscard]] inline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\n[[nodiscard]] inline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\n[[nodiscard]] inline ll BitCut(ll s, ll i){ return s & (1LL<<++i)-1; }//sの第0～第ibitを抽出\ninline vll str2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'0'); return move(v);}\ninline vll ALP2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'A'); return move(v);}\ninline vll alp2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'a'); return move(v);}\ntemplate<class T> inline ll FloorIdx(vector<T> &v, T x){ return upper_bound(ALL(v), x)-v.begin()-1; }\ntemplate<class T> inline ll CeilIdx(vector<T> &v, T x){ return lower_bound(ALL(v), x)-v.begin(); }\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> inline void coutv(deque<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T, class S> void Dump(map<T, S> &m){\n\tfor(auto e: m) cout << e.first << \" : \" << e.second << '\\n';\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<1000000007LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\n\nstruct Combination{\n\tvmll f, g; // factorial, factorial^-1\n\tCombination(){}\n\tCombination(ll maxN): f(maxN+1, 1), g(maxN+1){ InitSub(maxN); }\n\tvoid Init(ll maxN){ f.resize(maxN+1, 1); g.resize(maxN+1); InitSub(maxN); }\n\tmll operator () (ll n, ll r){ return (n<0||r<0||n<r) ? mll(0) : f[n]*g[n-r]*g[r]; }\n\tmll P(ll n, ll r){ return (n<0 || r<0 || n<r) ? mll(0) : f[n]*g[n-r]; }\n\tmll Inv(ll n) { return f[n-1] * g[n]; }\n\tmll Fact(ll n) { return f[n]; }\n\tmll FInv(ll n) { return g[n]; }\n\tvoid InitSub(ll maxN){\n\t\tREPS(i, 1, maxN){ f[i] = f[i-1] * i; }\n\t\tg[maxN] = 1 / f[maxN];\n\t\tDEPS(i, 1, maxN){ g[i-1] = g[i] * i; }\n\t}\n};\n\n\nvoid solve()\n{\n\tll n, a;  cin >> n >> a;\n\tll b=n-a;\n\tCombination cmb(n+10);\n\n\tvvmll dp(a+1, vmll(a+1));\n\tauto Dp = [&](ll i, ll j)->mll&{\n\t\tstatic mll zero=0;\n\t\tif (j<0) return zero;\n\t\treturn dp[i][j];\n\t};\n\n\tDp(0, 0)=1;\n#if 0\n\trep(i, 1, a){\n\t\trep(j, 0, a){\n\t\t\trep(k, 0, i-2){\n\t\t\t\tDp(i, j)+=Dp(k, j)*cmb.P(a-k-1, i-k-1);\n\t\t\t}\n\t\t\tDp(i, j) += Dp(i-1, j-1);\n\t\t}\n\t}\n#endif\n\tDp(1, 1)=1;\n\trep(i, 2, a){\n\t\trep(j, 0, a){\n\t\t\tDp(i,j) = ( Dp(i-1,j)-Dp(i-2,j-1)+Dp(i-2,j) )*(a-i+1)  + Dp(i-1,j-1);\n\t\t}\n\t}\n\n\tmll sum1=0;\n\trep(j, 0, a){\n\t\tsum1 += cmb(b-j+a-1, a-1)*Dp(a, j)*cmb.Fact(b);\n\t}\n\tmll sum2=0;\n\trep(i, 1, a-1)rep(j, 0, a){\n\t\tsum2 += cmb(b-j+i-1, i-1) * Dp(i, j) * cmb.Fact(a-i-1) * cmb.Fact(b);\n\t}\n\n\tmll ans=sum1+sum2;\n\tcout << ans << '\\n';\n}\n\nint main(){\n#if 1\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nconst int mo=1000000007;\nconst int N=10000005;\nconst int M=5005;\nint fac[N],inv[N],Inv[N];\nint n,m,f[M][M],g[M][M];\nvoid init(){\n\tfac[0]=inv[0]=inv[1]=Inv[0]=1;\n\tFor(i,2,N-1) inv[i]=1ll*inv[mo%i]*(mo-mo/i)%mo;\n\tFor(i,1,N-1) Inv[i]=1ll*Inv[i-1]*inv[i]%mo;\n\tFor(i,1,N-1) fac[i]=1ll*fac[i-1]*i%mo;\n}\nint C(int x,int y){\n\treturn 1ll*fac[x]*Inv[y]%mo*Inv[x-y]%mo;\n}\nint main(){\n\tinit();\n\tscanf(\"%d%d\",&n,&m);\n\tFor(i,0,m) f[i][0]=1ll*fac[i+n-m-1]*i%mo;\n\tFor(i,0,m) For(j,1,m-i){\n\t\tint val=1ll*f[i][0]*C(i+j,i)%mo;\n\t\tf[i+j][0]=(f[i+j][0]+mo-val)%mo;\n\t\tf[i+j][j]=val;\n\t}\n\tFor(i,1,m) For(j,0,m-i){\n\t\tg[i][j]=f[i-1][j];\n\t\tg[i][j]=(g[i][j]+1ll*g[i-1][j]*(n-m+(i-1)-(j+1)+1))%mo;\n\t\tg[i][j]=(g[i][j]+1ll*g[i-1][j+1]*(j+1))%mo;\n\t}\n\tint ans=(g[m][0]+f[m][0])%mo;\n\tcout<<ans<<endl;\n}\n/*\n>_<\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e7 + 5;\nconst int MAXM = 5e3 + 5;\nconst int P = 1e9 + 7;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint fac[MAXN], inv[MAXN];\nint power(int x, int y) {\n\tif (y == 0) return 1;\n\tint tmp = power(x, y / 2);\n\tif (y % 2 == 0) return 1ll * tmp * tmp % P;\n\telse return 1ll * tmp * tmp % P * x % P;\n}\nint binom(int x, int y) {\n\tif (y > x) return 0;\n\telse return 1ll * fac[x] * inv[y] % P * inv[x - y] % P;\n}\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nvoid init(int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfac[i] = 1ll * fac[i - 1] * i % P;\n\tinv[n] = power(fac[n], P - 2);\n\tfor (int i = n - 1; i >= 0; i--)\n\t\tinv[i] = inv[i + 1] * (i + 1ll) % P;\n}\nint n, m, dp[MAXN];\nint func(int x, int y) {\n\treturn 1ll * fac[y] * inv[x - 1] % P;\n}\nint main() {\n\tread(n), read(m), init(n);\n\tdp[0] = 1;\n\tfor (int i = 0; i <= m - 1; i++)\n\tfor (int j = 1; j <= m - i; j++)\n\t\tupdate(dp[i + j], 1ll * dp[i] * binom(m - i - 1, j - 1) % P * fac[j - 1] % P);\n\tint ans = 0;\n\tfor (int i = m - 1; i <= m; i++)\n\t\tif ((m - i) & 1) update(ans, P - 1ll * dp[i] * func(i, i + n - m - 1) % P);\n\t\telse update(ans, 1ll * dp[i] * func(i, i + n - m - 1) % P);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int mod=1000000007;\nint N,A,f[5010][5010][2],fac[10000010],ifac[10000010];\nlong long C(int n,int m){return m<0||m>n?0:1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;}\nlong long inv(int a,int p=mod){return a==1?1:(1+p*(a-inv(p%a,a)))/a%p;}\nint main(){\n\tscanf(\"%d%d\",&N,&A);\n\tfor(int i=*fac=1;i<=N;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[N]=inv(fac[N]);\n\tfor(int i=N;i;i--)ifac[i-1]=1ll*ifac[i]*i%mod;\n\tfor(int i=A;i>=0;i--){\n\t\tfor(int j=i;j>=0;j--){\n\t\t\tf[i][j][0]=(C(N-A+i-j-1,i-1)*(i<A?fac[A-i-1]:1)+f[i+1][j+1][0]+f[i+1][j][1]*(A-i-1ll))%mod;\n\t\t\tf[i][j][1]=(f[i+1][j][0]+f[i+1][j][1]*(A-i-1ll))%mod;\n\t\t}\n\t}\n\tint s=***f*1ll*fac[N-A]%mod;\n\tprintf(\"%d\\n\",s);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nconst int P = 1e9 + 7;\nconst int N = 1e7 + 7;\nint spow(int a, int b) {\n  int r = 1;\n  while (b) {\n    if (b % 2) {\n      r = r * a % P;\n    }\n    a = a * a % P;\n    b /= 2;\n  }\n  return r;\n}\nint fac[N];\nint inv_fac[N];\nint Newt(int a, int b) {\n  return fac[a] * inv_fac[a - b] % P * inv_fac[b] % P;\n}\nint Prod(int a, int len) {\n  return fac[a + len - 1] * inv_fac[a - 1] % P;\n}\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  // policzmy takie permutacje ze wsrod pierwszych k nie ma petli i kazdy cykl zawiera cos z tych pierwszych k\n  // zafiksujmy sobie zbior petelek przez incl-excl\n  // k! * (k-petle)*(k+1)*...*(n-1)\n  int n, a;\n  cin>>n>>a;\n  fac[0] = 1;\n  RE (i, n) {\n    fac[i] = i * fac[i - 1] % P;\n  }\n  inv_fac[n] = spow(fac[n], P - 2);\n  FORD (i, n - 1, 0) {\n    inv_fac[i] = inv_fac[i + 1] * (i + 1) % P;\n  }\n  // mamy k-petle dozwolonych\n  // jak k<a to mamy jedno mniej\n  // (k-petle)! * (k-petle)*(k-petle+1)*...*(n-petle-1)\n  int res = 0;\n  RE (k, a) {\n    int outer = 0;\n    FOR (petle, 0, k - 1) {\n      int inner = Newt(k, petle);\n      inner = inner * fac[k - petle] % P;\n      if (k < a) {\n        inner = inner * Prod(k - petle, n - a) % P;\n        inner = inner * Prod(n - a + 1 + k - petle, a - k - 1) % P;\n      } else {\n        inner = inner * Prod(k - petle, n - a) % P;\n      }\n        //inner = inner * fac[n - (k < a) - petle - 1] % P;\n//       if (k-petle-1 >= 0) {\n//         inner = inner * inv_fac[k - 1 - petle] % P;\n//       } else {\n//         inner = 0;\n      //}\n      debug(k, petle, inner);\n      if (petle % 2 == 0) {\n        outer = (outer + inner) % P;\n      } else {\n        outer = (outer - inner) % P;\n      }\n    }\n    debug(k, outer);\n    res = (res + outer) % P;\n  }\n  cout<<res<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nvoid exgcd(int a, int b, int& x, int& y) {\n  if (!b) {\n    x = 1, y = 0;\n  } else {\n    exgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n}\n\nint inv(int a, int n) {\n  int x, y;\n  exgcd(a, n, x, y);\n  return (x < 0) ? (x + n) : (x);\n}\n\nconst int Mod = 1e9 + 7;\n\ntemplate <const int Mod = :: Mod>\nclass Z {\n  public:\n    int v;\n\n    Z() : v(0) {\t}\n    Z(int x) : v(x){\t}\n    Z(ll x) : v(x % Mod) {\t}\n\n    friend Z operator + (const Z& a, const Z& b) {\n      int x;\n      return Z(((x = a.v + b.v) >= Mod) ? (x - Mod) : (x));\n    }\n    friend Z operator - (const Z& a, const Z& b) {\n      int x;\n      return Z(((x = a.v - b.v) < 0) ? (x + Mod) : (x));\n    }\n    friend Z operator * (const Z& a, const Z& b) {\n      return Z(a.v * 1ll * b.v);\n    }\n    friend Z operator ~(const Z& a) {\n      return inv(a.v, Mod);\n    }\n    friend Z operator - (const Z& a) {\n      return Z(0) - a;\n    }\n    Z& operator += (Z b) {\n      return *this = *this + b;\n    }\n    Z& operator -= (Z b) {\n      return *this = *this - b;\n    }\n    Z& operator *= (Z b) {\n      return *this = *this * b;\n    }\n};\n\nZ<> qpow(Z<> a, int p) {\n  Z<> rt = Z<>(1), pa = a;\n  for ( ; p; p >>= 1, pa = pa * pa) {\n    if (p & 1) {\n      rt = rt * pa;\n    }\n  }\n  return rt;\n}\n\ntypedef Z<> Zi;\n\nconst int N = 1e7 + 5, M = 5005;\n\nvector<Zi> fac, _fac;\nZi comb[M][M];\n\nvoid init_fac(int n) {\n  fac.resize(n + 1);\n  _fac.resize(n + 1);\n  fac[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    fac[i] = fac[i - 1] * i;\n  }\n  _fac[n] = ~fac[n];\n  for (int i = n; i; i--) {\n    _fac[i - 1] = _fac[i] * i;\n  }\n}\nvoid init(int n) {\n  comb[0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    comb[i][0] = 1;\n    for (int j = 1; j <= i; j++) {\n      comb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j];\n    }\n  }\n}\n\nint n, m;\nZi f[M][M], g[M][M], t[M];\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  init_fac(n);\n  init(m);\n\n  for (int i = 0; i < m; i++) {\n    t[i] = fac[n - 1 - i] * _fac[m - 1 - i];\n  }\n  for (int d = 1; d <= m; d++) {\n    g[d][0] = t[m - d + 1];\n    if (d == 1) {\n      for (int j = 1; d + j <= m; j++) {\n        g[d][j] = g[d][j - 1];\n      }\n    } else {\n      for (int j = 1; d + j <= m; j++) {\n        g[d][j] = g[d][j - 1] + fac[d + j - 2] * _fac[d - 2] * _fac[j] * t[m - d + 1 - j];\n      }\n    }\n    for (int j = 1; d + j <= m; j++) {\n      g[d][j] *= fac[j];\n    }\n  }\n  f[0][0] = 1;\n  Zi ans = 0;\n  for (int i = 1; i <= m; i++) {\n    f[i][0] = f[i - 1][0] * i;\n    for (int j = 1; j <= i; j++) {\n      f[i][j] = f[i - 1][j] * (i - j) - f[i - 1][j - 1];\n    }\n    for (int j = 0; j < i; j++) {\n      ans += f[i - 1][j] * g[i - j][m - i];\n    }\n  }\n  for (int i = 0; i < m; i++) {\n    ans += f[m][i] * t[i];\n  }\n  printf(\"%d\\n\", ans.v);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3,inline,unroll-loops\")\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#define N 20000020\n#define MOD 1000000007\nusing namespace std;\n\nnamespace Comb\n{\n    int f[N], g[N];\n \n    int Power(int x, int y)\n    {\n        int o;\n \n        for(o = 1; y; y >>= 1)\n        {\n            if(y & 1)\n                o = (long long)o * x % MOD;\n            x = (long long)x * x % MOD;\n        }\n \n        return o;\n    }\n \n    void InitComb(void)\n    {\n        int i;\n \n        for(i = f[0] = 1; i < N; i ++)\n            f[i] = (long long)f[i - 1] * i % MOD;\n        g[N - 1] = Power(f[N - 1], MOD - 2);\n        for(i = N - 2; i > -1; i --)\n            g[i] = (long long)g[i + 1] * (i + 1) % MOD;\n \n        return;\n    }\n\n    int C(int n, int m)\n    {\n        return n >= m ? (long long)f[n] * g[m] % MOD * g[n - m] % MOD : 0;\n    }\n\n    int S(int x, int y, int z)\n    {\n        return (long long)f[x + y + z] * g[x + y] % MOD * f[x + y - 1] % MOD * x % MOD;\n    }\n}\n\nint main(void)\n{\n    int n, a;\n    int i, j, o;\n\n    Comb::InitComb();\n    cin >> n >> a;\n    for(i = o = 0; i < a; i ++)\n        o = (o + (long long)(i & 1 ? MOD - 1 : 1) * Comb::C(a, i) % MOD * Comb::S(a - i, n - a, 0) % MOD) % MOD;\n    for(i = 0; i < a; i ++)\n        for(j = 0; j < a; j ++)\n            o = (o + (long long)(j & 1 ? MOD - 1 : 1) * Comb::C(i, j) % MOD * Comb::S(i - j, n - a, a - i - 1) % MOD) % MOD;\n    cout << o << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\nnamespace Base{\n\t# define mr make_pair\n\ttypedef long long ll;\n\ttypedef double db;\n\tconst int inf = 0x3f3f3f3f, INF = 0x7fffffff;\n\tconst ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\n\ttemplate<typename T> void read(T &x){\n    \tx = 0; int fh = 1; double num = 1.0; char ch = getchar();\n\t\twhile (!isdigit(ch)){ if (ch == '-') fh = -1; ch = getchar(); }\n\t\twhile (isdigit(ch)){ x = x * 10 + ch - '0'; ch = getchar(); }\n\t    if (ch == '.'){\n\t    \tch = getchar();\n\t    \twhile (isdigit(ch)){num /= 10; x = x + num * (ch - '0'); ch = getchar();}\n\t\t}\n\t\tx = x * fh;\n\t}\n\ttemplate<typename T> void chmax(T &x, T y){x = x < y ? y : x;}\n\ttemplate<typename T> void chmin(T &x, T y){x = x > y ? y : x;}\n}\nusing namespace Base;\n\nconst int P = 1e9 + 7, N = 5010, M = 1e7 + 10;\nint mul[M], inv[M], m, n, ans, c[N][N];\nint power(int x, int y){\n\tint i = x; x = 1;\n\twhile (y > 0){\n\t\tif (y & 1) x = 1ll * i * x % P;\n\t\ti = 1ll * i * i % P;\n\t\ty /= 2;\n\t}\n\treturn x;\n}\nint main(){\n\tread(m); read(n);\n\tmul[0] = 1; for (int i = 1; i <= m; i++) mul[i] = 1ll * mul[i - 1] * i % P;\n\tinv[m] = power(mul[m], P - 2); \n\tfor (int i = m - 1; i >= 0; i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % P;\n\tfor (int i = 0; i <= n; i++){\n\t\tc[i][0] = 1;\n\t\tfor (int j = 1; j <= i; j++)\n\t\t\tc[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % P;\n\t}\n\tfor (int i = n + 1; i >= 2; i--){\n\t\tint fh;\n\t\tfor (int j = 0; j <= i - 1; j++){\n\t\t\tif (j % 2 == 0) fh = c[i - 1][j]; else fh = -c[i - 1][j];\n\t\t\tint a = i - 1 - j, b = m - n, c = max(0, n - i);\n\t\t\tans = (ans + 1ll * fh * mul[a + b + c] % P * a % P * inv[a + b] % P * mul[a + b - 1] % P + P) % P;\n\t\t}\n\t}\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PQ priority_queue\n#define EPS (1e-7)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = std::end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n\nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n\n/*\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return m*modinv(n)%MOD*COM(m-1,n-1)%MOD;\n}\n*/\n\nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)*modinv(KAI(n))%MOD*modinv(KAI(m-n))%MOD;\n}\n\nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  if(m==2){\n    if(x&(1<<n))return 1;\n    else return 0;\n  }\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll DigSum(ll n)//10進数での桁和\n{\n  if(n==0)return 0;\n  return n%10+DigSum(n/10);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n \nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n \nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n \nbool is_prime(int64_t x) {\n  if(x==1)return false;\n  for(int64_t i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n \nstruct edge{ll to, cost;};\nstruct Dij{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n \n  Dij(ll n){\n    init(n);\n  }\n \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n \n  void find(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nstruct BF{\n  ll V;\n  vector<vector<edge>> G;\n  vector<ll> d;\n\n  BF(ll n){\n    init(n);\n  }\n  \n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i]=INF;\n    }\n  }\n  \n  void add(ll s, ll t, ll cost){\n    edge e;\n    e.to=t,e.cost=cost;\n    G[s].push_back(e);\n  }\n  bool find(ll s){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            d[e.to]=d[j]+e.cost;\n            if(i==V-1)return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  bool find2(ll s,ll t){\n    rep(i,V){\n      d[i]=INF;\n    }\n    d[s]=0;\n    rep(i,V*2){\n      rep(j,V){\n        ll m=G[j].size();\n        rep(k,m){\n          edge e=G[j][k];\n          if(d[j]!=INF&&d[e.to]>d[j]+e.cost){\n            if(i>=V-1&&e.to==t)return true;\n            else if(i>=V-1)d[e.to]=-INF;\n            else d[e.to]=d[j]+e.cost;\n          }\n        }\n      }\n    }\n    return false;\n  }\n};\n\nll dist[410][410];\n\nvoid WF(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n}\n \nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nstruct Segtree{\n  ll N=1;\n  ll elem;\n  vector<ll> value;\n  ll calc(ll s,ll t){\n    return max(s,t); //演算\n  }\n  Segtree(ll n,ll Elem){\n    elem=Elem;\n    while(N<n)N*=2;\n    value.assign(2*N-1,elem);\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=x;\n    while(i>0){\n      i=(i-1)/2;\n      value[i]=calc(value[i*2+1],value[i*2+2]);\n    }\n  }\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return elem;\n    if(a<=l&&r<=b)return value[k];\n    else{\n      ll c1=query(a,b,2*k+1,l,(l+r)/2);\n      ll c2=query(a,b,2*k+2,(l+r)/2,r);\n      return calc(c1,c2);\n    }\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N);\n  }\n  ll v(ll s){\n    return query(s,s+1,0,0,N);\n  }\n};\n\nstring LCS(string s,string t){\n  ll x=s.size();\n  ll dp[x+1][x+1]={},m[x+1][x+1]={},a,b;\n  string h;\n  stack<char>p;\n  a=s.size();\n  b=t.size();\n  rep(i,a){\n    rep(j,b){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n        m[i+1][j+1]=0;\n      }\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\n      if(dp[i+1][j+1]==dp[i+1][j]){\n        m[i+1][j+1]=1;\n      }\n      if(dp[i+1][j+1]==dp[i][j+1]){\n        m[i+1][j+1]=2;\n      }\n    }\n  }        \n  while(a>=1&&b>=1){\n    if(m[a][b]==0){\n      p.push(s[a-1]);\n      a--;\n      b--;\n    }\n    else if(m[a][b]==1)b--;\n    else a--;\n  }\n  while(p.size()){\n    h+=p.top();\n    p.pop();\n  }\n  return h;\n}\n\nstruct Edge{\n    ll src, dst;\n    ll cap;\n    Edge(ll src_, ll dst_, ll cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\n\nstruct EK{\n    ll n;\n    vector<ll> prev, dist;\n    vector<vector<ll>> cap, flow;\n    vector<vector<ll>> g;\n    ll inf;\n    EK(ll n)\n        : n(n), cap(n, vector<ll>(n)), flow(n, vector<ll>(n)),\n          g(n, vector<ll>()), inf(INF){}\n    EK(const vector<vector<Edge>> &graph){\n        *this = EK(graph.size());\n        rep(i,n) for(auto &e : graph[i]) add(e.src, e.dst, e.cap);\n    }\n    void add(ll u, ll v, ll c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    ll find(ll s, ll t){\n        ll res = 0, aug = 1;\n        while(aug > 0){\n            prev.assign(n, -1); dist.assign(n, inf); dist[s] = 0;\n            res += (aug = augment(s,t));\n        }\n        return res;\n    }\n    ll augment(ll s, ll t){\n        queue<pair<ll,ll>> q;\n        q.emplace(s,inf);\n        ll aug = 0;\n        while(q.size()){\n            ll v; ll f;\n            tie(v,f) = q.front(); q.pop();\n            if(v == t){ aug = f; break; }\n            for(const ll& d : g[v]){\n                if(dist[d] <= dist[v] + 1 || cap[v][d] - flow[v][d] == 0) continue;\n                dist[d] = dist[v] + 1; prev[d] = v;\n                q.emplace(d, min(f, cap[v][d] - flow[v][d]));\n            }\n        }\n        if(aug == 0) return 0;\n        ll c = t;\n        while(c != s){\n            ll p = prev[c];\n            flow[p][c] += aug; flow[c][p] -= aug;\n            c = p;\n        }\n        return aug;\n    }\n};\n\nll LIS(vector<ll>a) {\n  ll n=a.size();\n  ll dp[n];\n  fill(dp,dp+n,INF);\n  rep(i,n)*lower_bound(dp,dp+n,a[i])=a[i];\n  return lower_bound(dp,dp+n,INF)-dp;\n}\n\nstruct RMQ{\n  ll N=1;\n  ll elem=INF;\n  vector<LP> value;\n  RMQ(ll n){\n    while(N<n)N*=2;\n    rep(i,2*N-1)value.PB(MP(elem,INF));\n  }\n  void update(ll i,ll x) {\n    i+=N-1;\n    value[i]=MP(x,i+1-N);\n  }\n  void UPDATE(){\n    per(i,N-1)value[i]=min(value[i*2+1],value[i*2+2]);\n  }\n  LP query(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return MP(INF,INF);\n    if(a<=l&&r<=b)return value[k];\n    return min(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n  ll find(ll s,ll t){\n    return query(s,t+1,0,0,N).S;\n  }\n};\n\nstruct LCA{\n  vector<vector<ll>>v;\n  vector<ll>vs;\n  vector<ll>id;\n  vector<ll>depth;\n  vector<RMQ>r;\n  ll k;\n  ll N;\n  LCA(ll n){\n    v.resize(n);\n    id.resize(n);\n    r.PB((RMQ){2*n-1});\n    N=n;\n  }\n  void add(ll s,ll t){\n    v[s].PB(t);\n  }\n  void root(ll n){\n    k=0;\n    dfs(n,0);\n    r[0].UPDATE();\n  }\n  void dfs(ll n,ll d){\n    id[n]=k;\n    ll m=v[n].size();\n    rep(i,m){\n      vs.PB(n);\n      depth.PB(d);\n      r[0].update(k,d);\n      k++;\n      dfs(v[n][i],d+1);\n    }\n    vs.PB(n);\n    depth.PB(d);\n    r[0].update(k,d);\n    k++;\n  }\n  ll find(ll s,ll t){\n    return vs[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n  ll dist(ll s,ll t){\n    return depth[id[s]]+depth[id[t]]-2*depth[r[0].find(min(id[s],id[t]),max(id[s],id[t]))];\n  }\n};\n\nint main()\n{\n  int n,a,dp[5010][5010][3]={},ans=0,co[5100]={};\n  cin >> n >> a;\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n        if(k==2){\n          ans+=dp[i][j][2]*KAI(i)%MOD*KAI(n-a)%MOD*co[j-1]%MOD;\n          ans%=MOD;\n        }\n      }\n    }\n  }\n  printf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ncs int Mod = 1e9 + 7;\nint add(int a, int b){ return a + b >= Mod ? a + b - Mod : a + b; }\nint dec(int a, int b){ return a - b < 0 ? a - b + Mod : a - b; }\nint mul(int a, int b){ return 1ll * a * b % Mod; }\nvoid Add(int &a, int b){ a = add(a,b); }\nvoid Mul(int &a, int b){ a = mul(a,b); }\nvoid Dec(int &a, int b){ a = dec(a,b); }\ncs int N = 1e7 + 50;\nint n, A, fc[N], ifc[N], iv[N];\nint C(int n, int m){ return mul(fc[n],mul(ifc[n-m],ifc[m])); }\nvoid fc_init(int n){\n\tfc[0]=fc[1]=ifc[0]=ifc[1]=iv[1]=1;\n\tfor(int i=2;i<=n;i++)fc[i]=mul(fc[i-1],i);\n\tfor(int i=2;i<=n;i++)iv[i]=mul(Mod-Mod/i,iv[Mod%i]);\n\tfor(int i=2;i<=n;i++)ifc[i]=mul(ifc[i-1],iv[i]);\n}\nint calc(int a, int b, int c){ return mul(fc[a+b+c],mul(a,iv[a+b])); }\nint main(){\n\tscanf(\"%d%d\",&n,&A);\n\tfc_init(n); int ans=0;\n\tfor(int i=1;i<=A;i++)\n\tfor(int j=1,coe;j<=i;j++){\n\t\tcoe=C(i,j);if((i-j)&1)coe=dec(0,coe);\n\t\tMul(coe,calc(j,n-A,max(0,A-i-1)));\n\t\tAdd(ans,coe);\n\t} cout<<ans; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define cerr if (false) cerr\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntemplate <typename A, typename B>\nostream& operator<<(ostream& os, const pair<A, B>& x) {\n\treturn os << \"(\" << x.first << \",\" << x.second << \")\";\n}\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nstruct Mint {\n\tint val;\n\tMint() { val = 0; }\n\tMint(const ll& x) {\n\t\tval = (-MOD <= x && x < MOD) ? x : x % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\ttemplate <typename U>\n\texplicit operator U() const { return (U)val; }\n\tfriend bool operator==(const Mint& a, const Mint& b) { return a.val == b.val; }\n\tfriend bool operator!=(const Mint& a, const Mint& b) { return !(a == b); }\n\tfriend bool operator<(const Mint& a, const Mint& b) { return a.val < b.val; }\n\tMint& operator+=(const Mint& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tMint& operator-=(const Mint& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tMint& operator*=(const Mint& m) { val = (ll)val * m.val % MOD; return *this; }\n\tfriend Mint modex(Mint a, ll p) {\n\t\tassert(p >= 0);\n\t\tMint ans = 1;\n\t\tfor (; p; p >>= 1, a *= a) if (p & 1) ans *= a;\n\t\treturn ans;\n\t}\n\tMint& operator/=(const Mint& m) { return *this *= modex(m, MOD - 2); }\n\tMint& operator++() { return *this += 1; }\n\tMint& operator--() { return *this -= 1; }\n\tMint operator++(int) { Mint result(*this); *this += 1; return result; }\n\tMint operator--(int) { Mint result(*this); *this -= 1; return result; }\n\tMint operator-() const { return Mint(-val); }\n\tfriend Mint operator+(Mint a, const Mint& b) { return a += b; }\n\tfriend Mint operator-(Mint a, const Mint& b) { return a -= b; }\n\tfriend Mint operator*(Mint a, const Mint& b) { return a *= b; }\n\tfriend Mint operator/(Mint a, const Mint& b) { return a /= b; }\n\tfriend ostream& operator<<(ostream& os, const Mint& x) { return os << x.val; }\n};\nMint dp[5005][5005];\nconst int MAXN = 10000005;\nMint fac[MAXN], invfac[MAXN];\nMint binom(ll a, ll b) {\n\tif (b < 0) return 0;\n\tif (b > a) return 0;\n\treturn fac[a] * invfac[b] * invfac[a - b];\n}\nint main() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < MAXN; ++i)\n\t\tfac[i] = fac[i - 1] * i;\n\tinvfac[MAXN - 1] = 1 / fac[MAXN - 1];\n\tfor (int i = MAXN - 2; i >= 0; --i)\n\t\tinvfac[i] = invfac[i + 1] * (i + 1);\n\tint n, A;\n\tscanf(\"%d%d\", &n, &A);\n\tint B = n - A;\n\tMint ans = 0;\n\tdp[0][0] = 1;\n\tfor (int ones = 0; ones <= A; ++ones) {\n\t\tMint sum = 0;\n\t\tfor (int i = 1; i <= A; ++i) {\n\t\t\tif (i >= 2) sum += dp[i - 2][ones] * fac[A - i + 1];\n\t\t\tdp[i][ones] = sum * invfac[A - i];\n\t\t\tif (ones) dp[i][ones] += dp[i - 1][ones - 1];\n\t\t\tif (i >= 2) {\n\t\t\t\tans += dp[i - 1][ones] * binom(i - 2 + B - ones, i - 2) * fac[A - i] * fac[B];\n\t\t\t}\n\t\t}\n\t\tans += dp[A][ones] * binom(A - 1 + B - ones, A - 1) * fac[B];\n\t}\n\tprintf(\"%d\\n\", ans.val);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int M=1e7+10,N=5e3+10,mod=1e9+7;\nll fac[M],fm[M];\nll power(ll n,ll k){\n    if (k==0) return 1;\n    if (k%2==1){\n        ll x=power(n,k/2);\n        return x*x%mod*n%mod;\n    }\n    ll x=power(n,k/2);\n    return x*x%mod;\n}\nll ent(ll k,ll n){\n    if (k<0 || k>n || n<0) return 0;\n    if (k==0 || k==n) return 1;\n    return (fac[n]*fm[k])%mod*fm[n-k]%mod;\n}\nll sol(ll x,ll y){\n    ll ans=fac[x+y-1]*x%mod;\n    return ans;\n}\nll solve(ll a,ll b,ll c){\n    ll p1=a+b+1;\n    ll ans=sol(a,b)%mod;\n    for (int i=1;i<=c;i++){\n        ans*=p1;\n        ans%=mod;\n        p1++;\n    }\n    p1=-1;\n    for (int i=1;i<=a;i++){\n        ans+=p1*ent(i,a)*sol(a-i,b)%mod*fac[a-i+b+c]%mod*fm[a-i+b]%mod;\n        ans+=mod;\n        ans%=mod;\n        p1*=-1;\n    }\n    return ans;\n}\nint32_t main(){\n    fac[0]=1;\n    fm[1]=1;\n    for (int i=1;i<M;i++) fac[i]=fac[i-1]*i%mod;\n    for (int i=0;i<M;i++) fm[i]=power(fac[i],mod-2);\n    ll n,a;\n    cin >> n >> a;\n    ll ans=0;\n    for (int i=1;i<=a;i++){\n        ll z=ans;\n        if (i!=a){\n            ans+=solve(i,n-a,a-i-1);\n        }\n        else\n            ans+=solve(i,n-a,a-i);\n        ans%=mod;\n     //    cout << ans-z << \" \" << cheker(i+1) << endl;\n\n    }\n    cout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC OPTIMIZE (\"03\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef double D;\ntypedef long long int LL;\n\n#define st first\n#define nd second\n#define PLL pair <LL, LL>\n#define PII pair <int, int>\n\nconst int A = 5007;\nconst int N = 10 * 1000 * 1000 + 7;\nconst int MX = 1e9 + 7;\nconst LL INF = 1LL * MX * MX;\n\nint n, a;\nint nperm[A];\n\nint newt[A][A];\nint sil[N], rv[N];\n\nint fast(int a, int b){\n\tint ret = 1;\n\tfor(; b; b >>= 1, a = 1LL * a * a % MX)\n\t\tif(b & 1)\n\t\t\tret = 1LL * ret * a % MX;\n\treturn ret;\n}\n\ninline void add(int &a, int b){\n\ta += b;\n\tif(a >= MX)\n\t\ta -= MX;\n}\n\nvoid preprocess(){\n\tsil[0] = 1;\n\tfor(int i = 1; i <= n; ++i)\n\t\tsil[i] = 1LL * sil[i - 1] * i % MX;\n\t\n\trv[n] = fast(sil[n], MX - 2);\n\tfor(int i = n; i >= 1; --i)\n\t\trv[i - 1] = 1LL * rv[i] * i % MX;\n\t\n\tnperm[0] = 1;\n\tnperm[1] = 0;\n\t\n\tfor(int i = 2; i <= a; ++i)\n\t\tnperm[i] = (nperm[i - 1] + nperm[i - 2]) * 1LL * (i - 1) % MX;\n\t\n\tfor(int i = 0; i <= a; ++i){\n\t\tnewt[i][0] = newt[i][i] = 1;\n\t\tfor(int j = 1; j < i; ++j){\n\t\t\tadd(newt[i][j], newt[i - 1][j - 1]);\n\t\t\tadd(newt[i][j], newt[i - 1][j]);\n\t\t}\n\t}\n}\n\nint get(int _n, int _a, int m = 0){\n\tint ans = 0;\n\tfor(int k = 0; k <= _a; ++k){\n\t\tint mt = 1LL * newt[_a][k] * nperm[_a - k] % MX;\n\n\t\tint sum = 0;\n\t\tfor(int i = 0; i <= k; ++i){\n\t\t\tint val = 1LL * newt[k][i] * sil[_n - i - 1] % MX;\n\t\t\tif(_a >= i + 1)\n\t\t\t\tval = 1LL * val * rv[_a - i - 1] % MX;\n\t\t\telse\n\t\t\t\tval = 0;\n\n\t\t\tif(m)\n\t\t\t\tval = 1LL * val * sil[n - 1 - i] % MX * rv[_n - i] % MX;\n\n\t\t\tif(i & 1)\n\t\t\t\tsum = (sum - val) % MX;\n\t\t\telse\n\t\t\t\tsum = (sum + val) % MX;\n\t\t}\n\t\t\n\t\tsum = (sum + MX) % MX;\n\t\tans = (ans + 1LL * mt * sum) % MX;\n\t}\n\t\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d %d\", &n, &a);\n\tpreprocess();\n\t\n\tint ans = get(n, a);\n\tfor(int i = 1; i < a; ++i)\n\t\tans = (ans + 1LL * get(n - a + i, i, 1));\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 1000000007\nusing namespace std;\n#define gc getchar\ninline ll read(){\n    register ll x=0,f=1;char ch=gc();\n    while (!isdigit(ch)){if (ch=='-') f=-1;ch=gc();}\n    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}\n    return (f==1)?x:-x;\n}\nll n,A,fac[10000001],inv[10000001],_inv[10000001];\ninline ll getC(ll n,ll m){\n    if (n<m) return 0;\n    return fac[n]*_inv[m]%ljc*_inv[n-m]%ljc;\n}\ninline ll query(ll i1,ll i2){\n\tif (i1<=0||i2<=0||i1>i2) return 0;\n\treturn fac[i2]*_inv[i1-1]%ljc;\n}\ninline solve(ll i1,ll i2){\n\tif (n-A<i1) return 0; \n\treturn query(n-A-i1+1,n-A)*query(i1+i2,i2-n-A+1)%ljc*query(n-A+i1+i2+2,n)%ljc;\n}\nll dp[5001][5001],sum[5001][5001];\ninline void add(ll &a,ll b){a+=b;a%=ljc;}\nsigned main(){\n    fac[0]=inv[0]=inv[1]=_inv[0]=1;\n    for (ll i=1;i<=10000000;i++) fac[i]=fac[i-1]*i%ljc;\n    for (ll i=2;i<=10000000;i++) inv[i]=(ljc-inv[ljc%i]*(ljc/i)%ljc)%ljc;\n    for (ll i=1;i<=10000000;i++) _inv[i]=_inv[i-1]*inv[i]%ljc;\n    n=read(),A=read(); \n//    for (int i1=0;i1<=A;i1++){\n//    \tfor (int i2=0;i2+i1<=A;i2++){\n//    \t\tif (i1==0&&i2==0){\n//    \t\t\tdp[0][0]=1;continue;\n//\t\t\t}\n//    \t\tif (i2) add(dp[i1][i2],dp[i1][i2-1]);\n//    \t\tfor (int j=1;j<i1;j++) add(dp[i1][i2],dp[i1-j-1][i2]*getC(i1+i2-1,j)%ljc);\n//\t\t}\n//\t}\n//\tll _=0;\n//\tfor (int i=2;i<=A+1;i++){\n//\t\tfor (int i1=0;i1<i;i1++){\n//\t\t\t_=(_+solve(i1,i-1-i1)*dp[i1][i-1-i1]%ljc)%ljc;\t\t\t\t\n//\t\t}\n//\t}\n\tll _=0;\n\tfor (int T=2;T<=A+1;T++) {\n\t\tint x=T-1,y=max(A-T,0ll),z=n-A;\n\t\tfor (int i=0;i<T;i++){\n\t\t\tif (i&1) add(_,ljc-getC(x,i)*(x-i)%ljc*inv[x-i+z]%ljc*fac[x-i+y+z]%ljc);\n\t\t\telse add(_,getC(x,i)*(ll)(x-i)%ljc*inv[x-i+z]%ljc*fac[x-i+y+z]%ljc);\n\t\t} \n\t}\n\tcout<<_;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod = 1e9 + 7;\nconst int N = 1e7 + 5;\nint fac[N], ifac[N], inv[N];\n\nint mul(int x, int y) { return x * 1ll * y % mod; }\nint add(int x, int y) { return x+y < mod ? x+y : x+y-mod; }\nint sub(int x, int y) { return x-y < 0 ? x-y+mod: x-y; }\nint norm(int x) { return x < 0 ? add(x, mod) : sub(x, mod); }\ntemplate<class T, class... O> int mul(T x, O... y) { return mul(x, mul(y...)); }\n\nint main() {\n  int n, a; cin >> n >> a;\n  fac[0] = ifac[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    fac[i] = mul(fac[i-1], i);\n    inv[i] = i == 1 ? 1 : mod - mul(mod / i, inv[mod % i]);\n    ifac[i] = mul(ifac[i-1], inv[i]);\n  }\n  int ans = 0;\n  for (int i = 1; i <= a+1; i++) // [1 .. i-1]\n    for (int j = 0; j+1 < i; j++) // j singletons before\n      ans = norm(ans + ((j & 1) ? -1 : 1) * mul(fac[i-1], ifac[j], ifac[i-2-j], fac[n-j-1], i == a+1 ? 1 : inv[n-a+i-1-j]));\n  cout << ans << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nusing Int = long long;\nconst char newl = '\\n';\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n\n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n\n  Mint inv(){return pow(MOD-2);}\n\n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n  Mint operator+(Mint a) const{return Mint(v)+=a;}\n  Mint operator-(Mint a) const{return Mint(v)-=a;}\n  Mint operator*(Mint a) const{return Mint(v)*=a;}\n  Mint operator/(Mint a) const{return Mint(v)/=a;}\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  static Mint comb(long long n,int k){\n    Mint num(1),dom(1);\n    for(int i=0;i<k;i++){\n      num*=Mint(n-i);\n      dom*=Mint(i+1);\n    }\n    return num/dom;\n  }\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n\n\ntemplate<typename M_>\nclass Enumeration{\n  using M = M_;\nprotected:\n  static vector<M> fact,finv,invs;\npublic:\n  static void init(int n){\n    n=min<decltype(M::mod)>(n,M::mod-1);\n\n    int m=fact.size();\n    if(n<m) return;\n\n    fact.resize(n+1,1);\n    finv.resize(n+1,1);\n    invs.resize(n+1,1);\n\n    if(m==0) m=1;\n    for(int i=m;i<=n;i++) fact[i]=fact[i-1]*M(i);\n    finv[n]=M(1)/fact[n];\n    for(int i=n;i>=m;i--) finv[i-1]=finv[i]*M(i);\n    for(int i=m;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n\n  static M Fact(int n){\n    init(n);\n    return fact[n];\n  }\n  static M Finv(int n){\n    init(n);\n    return finv[n];\n  }\n  static M Invs(int n){\n    init(n);\n    return invs[n];\n  }\n\n  static M C(int n,int k){\n    if(n<k||k<0) return M(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static M P(int n,int k){\n    if(n<k||k<0) return M(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n\n  // put n identical balls into k distinct boxes\n  static M H(int n,int k){\n    if(n<0||k<0) return M(0);\n    if(!n&&!k) return M(1);\n    init(n+k);\n    return C(n+k-1,n);\n  }\n};\ntemplate<typename M>\nvector<M> Enumeration<M>::fact=vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::finv=vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::invs=vector<M>();\n\n//INSERT ABOVE HERE\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int n,a;\n  cin>>n>>a;\n\n  using M = Mint<int>;\n  using E = Enumeration<M>;\n  E::init(n+a);\n\n  M ans{0};\n  for(int i=1;i<=a;i++){\n    for(int j=0;j<i;j++){\n      int x=i-j;\n      int y=a-i;\n      int z=n-a;\n\n      // self loop if exist\n      if(y) y--;\n\n      M res{1};\n\n      // choose self loops\n      res*=E::C(i,j);\n\n      // create permutation\n      res*=E::Fact(x);\n\n      // insert in the loop\n      res*=E::P(x+z-1,z);\n\n      // insert (no ristriction)\n      res*=E::P(x+z+y,y);\n\n      if(~j&1) ans+=res;\n      else ans-=res;\n    }\n  }\n\n  cout<<ans<<newl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>bool chmax(t&a,u b){if(a<b)a=b;return a<b;}\ntemplate<class t,class u>bool chmin(t&a,u b){if(b<a)a=b;return b<a;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n\tint size(){\n\t\treturn v.size();\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\n//uint MODULAR=998244353;\nuint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\nll n,a;\nMint dp[5005][5005],ans;\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>n>>a;\n\tInitfact(n);\n\tif(n==a){\n\t\tprint(fact[n]);\n\t\treturn 0;\n\t}\n\tdp[0][0]=1;\n\tfor(int i=0;i<=a;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(dp[i][j]==0)continue;\n\t\t\t//cout<<i<<' '<<j<<' '<<dp[i][j]<<endl;\n\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\tdp[i+1][j]+=dp[i][j]*Mint(i-j);\n\t\t\tif(j>0)dp[i+1][j-1]+=dp[i][j]*Mint(j);\n\t\t\tif(i>0){\n\t\t\t\tif(i==a){\n\t\t\t\t\tif(j<=n-a)ans+=fact[n-a]*comb(i-1+n-a-j,i-1)*dp[i][j];\n\t\t\t\t}else{\n\t\t\t\t\tfor(int k=0;k+i+1<=a;k++){\n\t\t\t\t\t\tif(j<=n-a+k)ans+=comb(a-i-1,k)*fact[n-a+k]*comb(i-1+n-a+k-j,i-1)*dp[i][j]*fact[a-i-1-k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\n#ifdef DEBUG\nmt19937 mrand(300); \n#else\nmt19937 mrand(chrono::steady_clock::now().time_since_epoch().count()); \n#endif\n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nconst int mod = (int) 1e9 + 7;\n\nint mul(int a, int b) {\n  return (long long) a * b % mod;\n}\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= mod) {\n    a -= mod;\n  }\n}\n\nconst int maxn = (int) 1e7 + 5, maxa = 5005;\nint f[maxn], inv[maxn], finv[maxn];\n\nvoid precalc() {\n  f[0] = 1;\n  for (int i = 1; i < maxn; i++) {\n    f[i] = mul(f[i - 1], i);\n  }\n  inv[1] = 1;\n  for (int i = 2; i < maxn; i++) {\n    inv[i] = (mod - (long long) (mod / i) * inv[mod % i] % mod) % mod;\n  }\n  finv[0] = 1;\n  for (int i = 1; i < maxn; i++) {\n    finv[i] = mul(finv[i - 1], inv[i]);\n  }\n}\n\nint n, a;\n\nbool read() {\n  if (scanf(\"%d%d\", &n, &a) < 2) {\n    return false;\n  }\n  return true;\n}\n\nint dp[maxa][maxa];\nint cnt[maxa][maxa];\n\nvoid solve() {\n  for (int j = 0; j <= a; j++) {\n    cnt[a][j] = 0;\n  }\n  for (int i = a - 1; i >= 0; i--) {\n    for (int j = 0; i + j <= a; j++) {\n      auto &cur = cnt[i][j];\n      if (!j) {\n        cur = mul(f[n - i - 1], finv[a - i - 1]);\n        continue;\n      }\n      cur = cnt[i][j - 1];\n      add(cur, mod - cnt[i + 1][j - 1]);\n    }\n  }\n  memset(dp, 0, sizeof(dp));\n  add(dp[a][0], f[a]);\n  add(dp[a - 1][0], mod - f[a]);\n  int res = 0;\n  for (int i = a; i >= 0; i--) {\n    for (int j = 0; j <= a; j++) {\n      {\n        auto &cur = dp[i][j];\n        add(cur, dp[i + 1][j]);\n        if (!cur) {\n          continue;\n        }\n      }\n      auto cur = dp[i][j];\n      cur = mul(cur, finv[i]);\n      int val = mul(cur, f[max(0, i - 1)]);\n      add(res, mul(val, cnt[i][j]));\n      if (!i) {\n        continue;\n      }\n      add(dp[i - 1][j + 1], val);\n      if (i >= 2) {\n        add(dp[i - 2][j + 1], mod - val);\n        add(dp[i - 2][j], val);\n      }\n    }\n  }\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\nint64_t power_mod(int64_t num, int64_t power){\n    int64_t prod = 1;\n    num %= MOD;\n    while(power > 0){\n        if(power&1) prod = prod * num % MOD;\n        num = num * num % MOD;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint64_t extgcd(int64_t a, int64_t b, int64_t& x, int64_t& y){\n    int64_t d = a;\n    if(b != 0){\n        d = extgcd(b, a%b, y, x);\n        y -= (a/b) * x;\n    }else{\n        x = 1; y = 0;\n    }\n    return d;\n}\n\nint64_t inv_mod(int64_t a){\n    int64_t x, y;\n    extgcd(a, MOD, x, y);\n    return (MOD + x%MOD) % MOD;\n}\n\nvector<int64_t> fact, fact_inv;\n\nvoid create_mod_tables(int num){\n    fact.assign(num+1, 1);\n    fact_inv.assign(num+1, 1);\n    for(int i=1; i<=num; i++) fact[i] = fact[i-1] * i % MOD;\n    fact_inv[num] = inv_mod(fact[num]);\n    for(int i=num; i>0; i--) fact_inv[i-1] = fact_inv[i] * i % MOD;\n}\n\nint64_t comb_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD * fact_inv[k] % MOD;\n}\n\nint64_t perm_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD;\n}\n\nint main(){\n    int N, A;\n    cin >> N >> A;\n    create_mod_tables(N);\n\n    // sub[i] = inv_mod(N-A+i)\n    vector<int64_t> sub(A+1);\n    for(int i=0; i<=A; i++) sub[i] = inv_mod(N-A+i);\n\n    int64_t ans = 0;\n    for(int t=1; t<=A; t++){\n        for(int l=0; l<=t; l++){\n            int a = t-l;\n            int b = N-A;\n            int c = max(0, A-t-1);\n            int64_t res = fact[a+b+c] * a % MOD * sub[a] % MOD * comb_mod(t, l) % MOD;\n            if(l%2) res = MOD-res;\n            add(ans, res);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 1e7+10, mod = 1e9+7;\nint n,m;\n\nint fac[N],ifac[N],inv[N];\ninline int Mod(int x){\n\treturn x>=mod?x-mod:x;\n}\ninline int power(int a,int b){\n\tint ret=1;\n\tfor (;b;b>>=1,a=1ll*a*a%mod) if (b&1) ret=1ll*ret*a%mod;\n\treturn ret;\n}\ninline void init(int n){\n\tfac[0]=1;\n\tFor(i,1,n) fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[n]=power(fac[n],mod-2);\n\tDow(i,n-1,0) ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n\tFor(i,1,n) inv[i]=1ll*ifac[i]*fac[i-1]%mod;\n}\ninline int C(int n,int m){\n\tif (n<m||m<0) return 0;\n\treturn 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\ninline int calc(int x,int y,int z){\n\treturn 1ll*fac[x+y+z]*x%mod*inv[x+y]%mod;\n}\ninline int calc(){\n\tint ans=0;\n\tFor(i,2,m+1){\n\t\tint ret=0;\n\t\tFOR(j,0,i){\n\t\t\tint tmp=1ll*C(i-1,j)*calc(i-j-1,n-m,max(0,m-i))%mod;\n\t\t\tif (j&1) ret=Mod(ret+mod-tmp);\n\t\t\t\telse ret=Mod(ret+tmp);\n\t\t}\n\t\tans=Mod(ans+ret);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tn=read(),m=read(),init(n);\n\tprintf(\"%d\\n\",calc());\n}"
  },
  {
    "language": "C",
    "code": "たすけてくれ～"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\ntypedef long long ll;\nconst ll MOD = 1000000007;\n\nll kaikai[11000000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n\nll extGCD(ll a, ll b, ll *x, ll *y) {\n    if (b == 0) {\n        *x = 1;\n        *y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    *y -= a / b * *x;\n    return d;\n}\n\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, &x, &y);\n    return (x % MOD + MOD) % MOD;\n}\n\n\nint main()\n{\n  ll n,a,ans=0,co[5100]={};\n  scanf(\"%lld%lld\",&n,&a);\n  ll dp[5005][5005][3]={};\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[i][j][2]*KAI(i)%MOD*KAI(n-a)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  printf(\"%lld\",ans);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\ntypedef long long ll;\nconst ll MOD = 1000000007;\n\nll kaikai[11000]={};\nll KAI(ll m)\n{\n  if(kaikai[m])return kaikai[m];\n  if(m<0) return 0;\n  if(m==0) return 1;\n  kaikai[m]=m*KAI(m-1)%MOD;\n  return kaikai[m];\n}\n\nll extGCD(ll a, ll b, ll *x, ll *y) {\n    if (b == 0) {\n        *x = 1;\n        *y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    *y -= a / b * *x;\n    return d;\n}\n\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, &x, &y);\n    return (x % MOD + MOD) % MOD;\n}\n\n\nint main()\n{\n  ll n,a,ans=0,co[5100]={};\n  scanf(\"%lld%lld\",&n,&a);\n  ll dp[5005][5005][3]={};\n  co[0]=1;\n  rep(i,5050)co[i+1]=co[i]*(n-a-1-i)%MOD*modinv(i+1)%MOD;\n  dp[a][0][0]=1;\n  ROF(i,1,a+1){\n    rep(j,a+2){\n      rep(k,3){\n        if(k==0){\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k];\n          dp[i][j+1][2]%=MOD;\n        }\n        else if(k==1){\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n          dp[i][j+1][2]+=dp[i][j][k]%MOD;\n          dp[i][j+1][2]%=MOD;\n        }\n        else{\n          dp[i-1][j][0]+=dp[i][j][k]%MOD;\n          dp[i-1][j][0]%=MOD;\n          dp[i-1][j][1]+=dp[i][j][k]*(i-1)%MOD;\n          dp[i-1][j][1]%=MOD;\n        }\n      }\n    }\n  }\n  rep(i,a+1){\n    FOR(j,1,a+2){\n      if(j>n-a)continue;\n      ans+=dp[i][j][2]*KAI(i)%MOD*co[j-1]%MOD;\n      ans%=MOD;\n    }\n  }\n  rep(i,n-a){\n    ans*=(i+1);\n    ans%=MOD;\n  }\n  printf(\"%lld\",ans);\n}"
  },
  {
    "language": "Java",
    "code": "public class Main {\n    public static void main(String[] args) {\n        System.out.println(\"test\");\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.mathspecial, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\nstruct ModInt(int M_) {\n  import std.conv : to;\n  alias M = M_;\n  int x;\n  this(ModInt a) { x = a.x; }\n  this(long a) { x = cast(int)(a % M); if (x < 0) x += M; }\n  ref ModInt opAssign(long a) { return (this = ModInt(a)); }\n  ref ModInt opOpAssign(string op)(ModInt a) {\n    static if (op == \"+\") { x += a.x; if (x >= M) x -= M; }\n    else static if (op == \"-\") { x -= a.x; if (x < 0) x += M; }\n    else static if (op == \"*\") { x = cast(int)((cast(long)(x) * a.x) % M); }\n    else static if (op == \"/\") { this *= a.inv(); }\n    else static assert(false);\n    return this;\n  }\n  ref ModInt opOpAssign(string op)(long a) {\n    static if (op == \"^^\") {\n      if (a < 0) return (this = inv()^^(-a));\n      ModInt t2 = this, te = ModInt(1);\n      for (long e = a; e > 0; e >>= 1) {\n        if (e & 1) te *= t2;\n        t2 *= t2;\n      }\n      x = cast(int)(te.x);\n      return this;\n    } else return mixin(\"this \" ~ op ~ \"= ModInt(a)\");\n  }\n  ModInt inv() const {\n    int a = x, b = M, y = 1, z = 0, t;\n    for (; ; ) {\n      t = a / b; a -= t * b;\n      if (a == 0) {\n        assert(b == 1 || b == -1);\n        return ModInt(b * z);\n      }\n      y -= t * z;\n      t = b / a; b -= t * a;\n      if (b == 0) {\n        assert(a == 1 || a == -1);\n        return ModInt(a * y);\n      }\n      z -= t * y;\n    }\n  }\n  ModInt opUnary(string op: \"-\")() const { return ModInt(-x); }\n  ModInt opBinary(string op, T)(T a) const {\n    return mixin(\"ModInt(this) \" ~ op ~ \"= a\");\n  }\n  ModInt opBinaryRight(string op)(long a) const {\n    return mixin(\"ModInt(a) \" ~ op ~ \"= this\");\n  }\n  bool opCast(T: bool)() const { return (x != 0); }\n  string toString() const { return x.to!string; }\n}\n\nenum MO = 10^^9 + 7;\nalias Mint = ModInt!MO;\n\nenum LIM = 10^^7 + 5;\nMint[] inv, fac, invFac;\nvoid prepare() {\n  inv = new Mint[LIM];\n  fac = new Mint[LIM];\n  invFac = new Mint[LIM];\n  inv[1] = 1;\n  foreach (i; 2 .. LIM) {\n    inv[i] = -(Mint.M / i) * inv[cast(size_t)(Mint.M % i)];\n  }\n  fac[0] = invFac[0] = 1;\n  foreach (i; 1 .. LIM) {\n    fac[i] = fac[i - 1] * i;\n    invFac[i] = invFac[i - 1] * inv[i];\n  }\n}\nMint binom(long n, long k) {\n  if (0 <= k && k <= n) {\n    assert(n < LIM);\n    return fac[cast(size_t)(n)] * invFac[cast(size_t)(k)] * invFac[cast(size_t)(n - k)];\n  } else {\n    return Mint(0);\n  }\n}\n\n\nvoid main() {\n  prepare;\n  try {\n    for (; ; ) {\n      const N = readInt();\n      const A = readInt();\n      \n      Mint ans;\n      foreach (i; 0 .. A + 1) {\n        foreach (j; 0 .. i) {\n          // i - j, N - A, A - i - 1\n          Mint tmp = (-1)^^(j & 1) * binom(i, j);\n          tmp *= fac[i - j];\n          tmp *= invFac[(i - j) - 1] * fac[(i - j) + (N - A) - 1];\n          if (i < A) {\n            tmp *= invFac[(i - j) + (N - A)] * fac[(i - j) + (N - A) + (A - i - 1)];\n          }\n          ans += tmp;\n        }\n      }\n      writeln(ans);\n      \n      debug {\n        if (A <= 10) {\n          auto dp = new Mint[][](A + 1, A + 1);\n          dp[0][0] = 1;\n          foreach (i; 0 .. A) {\n            foreach (j; 0 .. i + 1) {\n              // new cycle\n              dp[i + 1][j + 1] += dp[i][j];\n              // resolve self\n              if (j >= 1) {\n                dp[i + 1][j - 1] += dp[i][j] * j;\n              }\n              // other insertion\n              dp[i + 1][j] += dp[i][j] * (i - j);\n            }\n          }\n          foreach (i; 0 .. A + 1) {\n            writeln(i, \": \", dp[i]);\n          }\n          Mint slow;\n          foreach (i; 0 .. A + 1) {\n            foreach (j; 0 .. i + 1) {\n              Mint tmp;\n              foreach (k; 0 .. j + 1) {\n                if (i - k >= 1) {\n                  tmp += (-1)^^(k & 1) * binom(j, k) * invFac[(i - k) - 1] * fac[(i - k) + (N - A) - 1] * ((i == A) ? Mint(1) : (invFac[N - k - (A - i)] * fac[N - k - 1]));\n                }\n              }\n              writeln(i, \" \", j, \": \", tmp);\n              slow += dp[i][j] * tmp;\n            }\n          }\n          writeln(\"slow = \", slow);\n        }\n      }\n      \n      debug {\n        if (N <= 10) {\n          int brt;\n          auto brts = new int[A + 1];\n          auto perm = iota(N).array;\n          do {\n            auto used = new bool[N];\n            int cnt = A;\n            foreach (i; 0 .. A) {\n              if (!used[i]) {\n                if (perm[i] == i) {\n                  goto brtDone;\n                }\n                for (int j = i; ; ) {\n                  used[j] = true;\n                  if (j >= A) {\n                    ++cnt;\n                    if (cnt == N) {\n                      goto brtDone;\n                    }\n                  }\n                  j = perm[j];\n                  if (j == i) {\n                    break;\n                  }\n                }\n              }\n            }\n           brtDone:\n            if (cnt == N) {\n              if (N <= 5) {\n                writeln(\"perm = \", perm);\n              }\n              ++brt;\n              foreach (i; 0 .. A + 1) {\n                if (i == A || perm[i] == i) {\n                  ++brts[i];\n                  break;\n                }\n              }\n            }\n          } while (perm.nextPermutation);\n          writeln(\"brt = \", brt);\n          writeln(\"brts = \", brts);\n        }\n      }\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "Python",
    "code": "#さようなら\nn,a=map(int,input().split())\nb=n-a\nmod=10**9+7\nf=[1]\nfor i in range(n):f+=[f[-1]*(i+1)%mod]\ndef comb(a,b):return f[a]*pow(f[b],mod-2,mod)*pow(f[a-b],mod-2,mod)%mod\nans=0\nfor k in range(1,min(a,b)+1):\n  x=comb(b,k)*f[k]\n  y=comb(a,a-k)*f[k]\n  z=comb(a,k)*f[k]\n  yz=y*z\n  t=a-k\n  inv=pow(a,mod-2,mod)\n  s=0\n  for l in range(1,t+1):\n    s=(s+comb(a,l)*l*inv)%mod\n  yz=(yz-s)%mod\n  w=pow(k,b-k,mod)*f[k]\n  ans=(ans+w*x*yz)%mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def prepare(n, MOD):\n    factorials = [1] * (n + 1)\n    for i in range(2, n + 1):\n        factorials[i] = factorials[i - 1] * i % MOD\n    finvs = [1] * (n + 1)\n    finvs[n] = pow(factorials[n], MOD - 2, MOD)\n    for i in range(n, 1, -1):\n        finvs[i - 1] = finvs[i] * i % MOD\n    return factorials, finvs\n\n\ndef solve(n, a):\n    MOD = 10 ** 9 + 7\n    facts, finvs = prepare(n, MOD)\n    invs = [facts[i - 1] * finvs[i] % MOD for i in range(n + 1)]  # invs[0]: undefined\n    r = n - a\n\n    ans = 0\n    # a個がいずれも自己ループを持たないパターン\n    for l in range(a):\n        tmp1 = facts[a] * finvs[l] % MOD * finvs[a - l] % MOD\n        tmp2 = facts[n - l - 1] * (a - l) % MOD\n        ans = (ans + (-1) ** (l & 1) * tmp1 * tmp2) % MOD\n\n    # a個中k+1個目ではじめて自己ループを持つが、それまでのk個で全点灯できるパターン\n    for k in range(1, a):\n        for l in range(k):\n            tmp1 = facts[k] * finvs[l] % MOD * finvs[k - l] % MOD\n            tmp2 = facts[n - l - 1] * (k - l) % MOD * invs[r + k - l] % MOD\n            ans = (ans + (-1) ** (l & 1) * tmp1 * tmp2) % MOD\n\n    return ans\n\n\nn, a = map(int, input().split())\nprint(solve(n, a))\n"
  },
  {
    "language": "Python",
    "code": "from numba import njit\nimport numpy as np\n\n\n@njit('i8(i8, i8, i8)', cache=True)\ndef mod_pow(x, a, MOD):\n    # Numbaではmod付き累乗が使えなかった...\n    ret = 1\n    cur = x\n    while a:\n        if a & 1:\n            ret = ret * cur % MOD\n        cur = cur * cur % MOD\n        a >>= 1\n    return ret\n\n\n@njit('UniTuple(i8[:], 2)(i8, i8)', cache=True)\ndef prepare(n, MOD):\n    factorials = np.ones(n + 1, dtype=np.int64)\n    for i in range(2, n + 1):\n        factorials[i] = factorials[i - 1] * i % MOD\n    finvs = np.ones(n + 1, dtype=np.int64)\n    finvs[n] = mod_pow(factorials[n], MOD - 2, MOD)\n    for i in range(n, 1, -1):\n        finvs[i - 1] = finvs[i] * i % MOD\n    return factorials, finvs\n\n\n@njit('i8(i8, i8)', cache=True)\ndef solve(n, a):\n    MOD = 10 ** 9 + 7\n    facts, finvs = prepare(n, MOD)\n    invs = [facts[i - 1] * finvs[i] % MOD for i in range(n + 1)]  # invs[0]: undefined\n    r = n - a\n\n    ans = 0\n    # a個がいずれも自己ループを持たないパターン\n    for l in range(a):\n        tmp1 = facts[a] * finvs[l] % MOD * finvs[a - l] % MOD\n        tmp2 = facts[n - l - 1] * (a - l) % MOD\n        ans = (ans + (-1) ** (l & 1) * tmp1 * tmp2) % MOD\n\n    # a個中k+1個目ではじめて自己ループを持つが、それまでのk個で全点灯できるパターン\n    for k in range(1, a):\n        for l in range(k):\n            tmp1 = facts[k] * finvs[l] % MOD * finvs[k - l] % MOD\n            tmp2 = facts[n - l - 1] * (k - l) % MOD * invs[r + k - l] % MOD\n            ans = (ans + (-1) ** (l & 1) * tmp1 * tmp2) % MOD\n\n    return ans\n\n\nn, a = map(int, input().split())\nprint(solve(n, a))\n"
  }
]