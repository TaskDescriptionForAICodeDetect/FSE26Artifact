[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include <vector>\n\n#define MAX_N 100005\n\nstd::vector<int> graph[MAX_N];\nint N, M;\nbool visited[MAX_N];\n\nbool dfs(int u, bool is_takahashi_turn) {\n    visited[u] = true;\n    \n    bool can_win_on_this_node = true;\n    for (int v : graph[u]) {\n        if (!visited[v]) {\n            bool sub_result = dfs(v, !is_takahashi_turn);\n            \n            // If current player can force a loss in any subtree, they lose\n            if (is_takahashi_turn && !sub_result) {\n                can_win_on_this_node = false;\n            }\n            \n            // If it's Aoki's turn and any subtree is a win, he wins\n            if (!is_takahashi_turn && sub_result) {\n                can_win_on_this_node = true;\n                break;\n            }\n        }\n    }\n    \n    return is_takahashi_turn ? can_win_on_this_node : !can_win_on_this_node;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    \n    for (int i = 0; i < M; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    \n    memset(visited, 0, sizeof(visited));\n    \n    bool winner = dfs(1, true);\n    \n    printf(\"%s\\n\", winner ? \"Takahashi\" : \"Aoki\");\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:20:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 200000\n\ntypedef struct Node {\n    int vertex;\n    struct Node* next;\n} Node;\n\nNode* adj[MAX_N + 1];\nint color[MAX_N + 1];\nint depth[MAX_N + 1];\nint parent[MAX_N + 1];\n\nvoid add_edge(int u, int v) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->vertex = v;\n    node->next = adj[u];\n    adj[u] = node;\n\n    node = (Node*)malloc(sizeof(Node));\n    node->vertex = u;\n    node->next = adj[v];\n    adj[v] = node;\n}\n\nvoid dfs(int u, int p) {\n    parent[u] = p;\n    depth[u] = (p == -1) ? 0 : depth[p] + 1;\n    Node* node = adj[u];\n    while (node != NULL) {\n        int v = node->vertex;\n        if (v != p) {\n            dfs(v, u);\n        }\n        node = node->next;\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N - 1; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        add_edge(a, b);\n    }\n\n    dfs(1, -1);\n\n    int u = 1;\n    for (int i = 2; i <= N; i++) {\n        if (depth[i] > depth[u]) {\n            u = i;\n        }\n    }\n\n    dfs(u, -1);\n\n    int v = 1;\n    for (int i = 2; i <= N; i++) {\n        if (depth[i] > depth[v]) {\n            v = i;\n        }\n    }\n\n    int diameter = depth[v];\n    if (diameter % 3 != 1) {\n        printf(\"First\\n\");\n    } else {\n        printf(\"Second\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:20:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> adj(N + 1);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    if (N == 1) {\n        cout << \"First\" << endl;\n        return 0;\n    }\n\n    vector<int> degree(N + 1);\n    queue<int> leaves;\n    for (int i = 1; i <= N; ++i) {\n        degree[i] = adj[i].size();\n        if (degree[i] == 1) {\n            leaves.push(i);\n        }\n    }\n\n    vector<bool> removed(N + 1, false);\n    int count = 0;\n    while (!leaves.empty()) {\n        int u = leaves.front();\n        leaves.pop();\n        if (removed[u]) continue;\n        removed[u] = true;\n        int v = -1;\n        for (int neighbor : adj[u]) {\n            if (!removed[neighbor]) {\n                v = neighbor;\n                break;\n            }\n        }\n        if (v == -1) continue;\n        removed[v] = true;\n        count++;\n        for (int neighbor : adj[v]) {\n            if (!removed[neighbor]) {\n                degree[neighbor]--;\n                if (degree[neighbor] == 1) {\n                    leaves.push(neighbor);\n                }\n            }\n        }\n    }\n\n    if (count * 3 == N) {\n        cout << \"Second\" << endl;\n    } else {\n        cout << \"First\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:21:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 0; i < N - 1; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            adj.get(u).add(v);\n            adj.get(v).add(u);\n        }\n\n        if (N == 1) {\n            System.out.println(\"First\");\n            return;\n        }\n\n        int[] dist = new int[N + 1];\n        Arrays.fill(dist, -1);\n        Queue<Integer> q = new LinkedList<>();\n        int start = 1;\n        dist[start] = 0;\n        q.add(start);\n        int maxDist = 0, farthest = start;\n        while (!q.isEmpty()) {\n            int u = q.poll();\n            for (int v : adj.get(u)) {\n                if (dist[v] == -1) {\n                    dist[v] = dist[u] + 1;\n                    q.add(v);\n                    if (dist[v] > maxDist) {\n                        maxDist = dist[v];\n                        farthest = v;\n                    }\n                }\n            }\n        }\n\n        Arrays.fill(dist, -1);\n        dist[farthest] = 0;\n        q.add(farthest);\n        maxDist = 0;\n        int otherEnd = farthest;\n        while (!q.isEmpty()) {\n            int u = q.poll();\n            for (int v : adj.get(u)) {\n                if (dist[v] == -1) {\n                    dist[v] = dist[u] + 1;\n                    q.add(v);\n                    if (dist[v] > maxDist) {\n                        maxDist = dist[v];\n                        otherEnd = v;\n                    }\n                }\n            }\n        }\n\n        int diameter = maxDist;\n        if (diameter % 3 != 1) {\n            System.out.println(\"First\");\n        } else {\n            System.out.println(\"Second\");\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:22:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TreeColoring {\n    static ArrayList<Integer>[] graph;\n    static int N;\n\n    public static String determineWinner(int[] edges) {\n        // Build adjacency list graph\n        N = edges.length + 1;\n        graph = new ArrayList[N + 1];\n        for (int i = 1; i <= N; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        \n        // Populate graph\n        for (int i = 0; i < edges.length; i++) {\n            int u = i + 1, v = edges[i];\n            graph[u].add(v);\n            graph[v].add(u);\n        }\n        \n        // Determine game outcome\n        return solve() ? \"Takahashi\" : \"Aoki\";\n    }\n    \n    static boolean solve() {\n        int whiteCount = 0;\n        \n        // Find vertices that Takahashi can ensure remain white\n        for (int v = 1; v <= N; v++) {\n            if (graph[v].size() <= 1) {\n                whiteCount++;\n            }\n        }\n        \n        // If whiteCount is odd, Takahashi wins\n        return whiteCount % 2 == 1;\n    }\n}",
    "timestamp": "2025-08-05 23:22:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nvector<int> graph[MAXN];\nint n;\n\nbool canWin(int start) {\n    vector<int> white, black;\n    vector<bool> visited(n + 1, false);\n    \n    function<bool(int, bool)> dfs = [&](int v, bool isTakahashi) {\n        visited[v] = true;\n        \n        if (isTakahashi) white.push_back(v);\n        else black.push_back(v);\n        \n        for (int u : graph[v]) {\n            if (!visited[u]) {\n                if (!dfs(u, !isTakahashi)) return false;\n            }\n        }\n        \n        return true;\n    };\n    \n    dfs(start, true);\n    \n    for (int v : black) {\n        for (int u : graph[v]) {\n            auto it = find(white.begin(), white.end(), u);\n            if (it != white.end()) {\n                white.erase(it);\n            }\n        }\n    }\n    \n    return !white.empty();\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    cin >> n;\n    \n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    \n    bool takahashiWins = false;\n    \n    for (int start = 1; start <= n; start++) {\n        if (canWin(start)) {\n            takahashiWins = true;\n            break;\n        }\n    }\n    \n    cout << (takahashiWins ? \"Takahashi\" : \"Aoki\") << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:22:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\n\ndef find_winner(N, edges):\n    graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        has_white_child = False\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                if not dfs(neighbor, node):\n                    has_white_child = True\n        return has_white_child\n\n    # Starting DFS from any node. Let's start with node 1.\n    if dfs(1, -1):\n        return 'Takahashi'\n    else:\n        return 'Aoki'\n\n# Example usage\nN = 5\nedges = [(1, 2), (2, 3), (3, 4), (4, 5)]\nprint(find_winner(N, edges))  # Output: 'Takahashi' or 'Aoki'",
    "timestamp": "2025-08-13 14:53:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TreeGame {\n    private static List<List<Integer>> tree;\n    private static int N;\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        N = scanner.nextInt();\n        tree = new ArrayList<>();\n        for (int i = 0; i < N + 1; i++) {\n            tree.add(new ArrayList<>());\n        }\n        for (int i = 0; i < N - 1; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            tree.get(u).add(v);\n            tree.get(v).add(u);\n        }\n        boolean[] visited = new boolean[N + 1];\n        int[] depth = new int[N + 1];\n        dfs(1, visited, depth, 0);\n\n        int maxDepth = 0;\n        int whiteCount = 0;\n        for (int d : depth) {\n            if (d > maxDepth) {\n                maxDepth = d;\n                whiteCount = 0;\n            }\n            if (d == maxDepth) {\n                whiteCount++;\n            }\n        }\n        System.out.println(whiteCount % 2 == 1 ? \"Takahashi\" : \"Aoki\");\n    }\n\n    private static void dfs(int u, boolean[] visited, int[] depth, int d) {\n        visited[u] = true;\n        depth[u] = d;\n        for (int v : tree.get(u)) {\n            if (!visited[v]) {\n                dfs(v, visited, depth, d + 1);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-13 14:53:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_N 1000\n\nint N;\nint edges[MAX_N][MAX_N];\nbool visited[MAX_N];\nint color[MAX_N];\n\nbool canWin(int current, int count) {\n    if (count == N) {\n        for (int i = 0; i < N; ++i) {\n            if (color[i] == 1) { // Check if there is any white vertex\n                bool adjacentBlack = false;\n                for (int j = 0; j < N; ++j) {\n                    if (edges[i][j] && color[j] == 2) {\n                        adjacentBlack = true;\n                        break;\n                    }\n                }\n                if (!adjacentBlack) {\n                    return true; // Takahashi wins\n                }\n            }\n        }\n        return false; // Aoki wins\n    }\n\n    // Simulate the turn\n    int player = (count % 2) + 1; // 1 for Takahashi's turn, 2 for Aoki's turn\n    bool result = (player == 1) ? false : true; // Assume lose for Takahashi, win for Aoki\n\n    for (int i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            visited[i] = true;\n            color[i] = player;\n            if (player == 1) {\n                if (canWin(current + 1, count + 1)) {\n                    result = true;\n                }\n            } else {\n                if (!canWin(current + 1, count + 1)) {\n                    result = false;\n                }\n            }\n            color[i] = 0;\n            visited[i] = false;\n            if (result == (player == 1)) {\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    int M;\n    scanf(\"%d %d\", &N, &M);\n    memset(edges, 0, sizeof(edges));\n    memset(visited, false, sizeof(visited));\n    memset(color, 0, sizeof(color));\n\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        --u;\n        --v;\n        edges[u][v] = edges[v][u] = 1;\n    }\n\n    if (canWin(0, 0)) {\n        printf(\"Takahashi\\n\");\n    } else {\n        printf(\"Aoki\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:53:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nbool bfs(const vector<vector<int>> &adj, int start, int color) {\n    vector<int> colors(adj.size(), -1);\n    queue<int> q;\n    q.push(start);\n    colors[start] = color;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for (int v : adj[u]) {\n            if (colors[v] == -1) {\n                colors[v] = 1 - colors[u];\n                q.push(v);\n            } else if (colors[v] == colors[u]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nbool isBipartite(const vector<vector<int>> &adj) {\n    int n = adj.size();\n    for (int i = 0; i < n; i++) {\n        if (!bfs(adj, i, 0)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> adj(N);\n\n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    if (isBipartite(adj)) {\n        cout << \"Takahashi\" << endl;\n    } else {\n        cout << \"Aoki\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:53:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List\n\ndef solve(N: int, edges: List[List[int]]) -> str:\n    # Create adjacency list representation of the graph\n    graph = [[] for _ in range(N+1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Determine the number of vertices in each subtree\n    subtree_size = [0] * (N+1)\n    def dfs_size(node: int, parent: int) -> int:\n        subtree_size[node] = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                subtree_size[node] += dfs_size(neighbor, node)\n        return subtree_size[node]\n    \n    dfs_size(1, 0)\n    \n    # Check if Takahashi can win\n    winning_vertices = sum(1 for size in subtree_size[1:] if size % 2 == 1)\n    \n    return \"Takahashi\" if winning_vertices > 0 else \"Aoki\"\n\n# Read input\nN = int(input())\nedges = []\nfor _ in range(N-1):\n    u, v = map(int, input().split())\n    edges.append([u, v])\n\n# Solve and print result\nprint(solve(N, edges))",
    "timestamp": "2025-08-13 14:54:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    N = int(sys.stdin.readline())\n    adj = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        a, b = map(int, sys.stdin.readline().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    # Find the diameter of the tree\n    def bfs(start):\n        dist = [-1] * (N+1)\n        q = deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    q.append(v)\n        far_node = dist.index(max(dist))\n        return far_node, dist[far_node]\n    \n    u, _ = bfs(1)\n    v, diameter = bfs(u)\n    \n    if diameter % 3 != 1:\n        print(\"First\")\n    else:\n        print(\"Second\")\n\nsolve()",
    "timestamp": "2025-08-13 14:54:06"
  }
]