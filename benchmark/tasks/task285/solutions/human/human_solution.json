[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct Point {\n  int x, y;\n  Point(){}\n  Point(int x, int y):x(x), y(y){}\n  Point operator + (const Point p) {\n    return Point(x+p.x, y+p.y);\n  }\n  Point operator - (const Point p) {\n    return Point(x-p.x, y-p.y);\n  }\n};\n\nstruct Man {\n  Point p;\n  int d;\n  Man(){}\n  Man(Point p, int d):p(p), d(d){}\n};\n\nstruct Interval {\n  int l, r;\n  Interval(){}\n  Interval(int l, int r):l(l), r(r){}\n  Interval operator + (Interval i) {\n    return Interval(l+i.l, r+i.r);\n  }\n  Interval operator - (Interval i) {\n    return Interval(l-i.l, r-i.r);\n  }\n  bool operator < (const Interval &i) const {\n    return l != i.l ? l < i.l : r < i.r;\n  }\n};\n\nstring D = \"NESW\";\nPoint dv[] = {\n  Point(-1, 1),\n  Point(1, 1),\n  Point(1, -1),\n  Point(-1, -1)\n};\n\nint n, w, h;\nvector<Man> men;\nvector<Interval> vec;\n\nbool intersect(Point p) {\n  return p.x<=0||w<=p.x||p.y<=0||h<=p.y;\n}\n\nint project(Point p) {\n  if(p.y == 0) return p.x;\n  if(p.x == w) return w+p.y;\n  if(p.y == h) return w+h+(w-p.x);\n  if(p.x == 0) return w+h+w+(h-p.y);\n  assert(false);\n}\n\nInterval getInterval(Man man) {\n  Point cpl = man.p, cpr = man.p;\n  while(!intersect(cpl)) cpl = cpl+dv[(man.d+1)%4];\n  while(!intersect(cpr)) cpr = cpr+dv[man.d];\n  Interval res(project(cpl), project(cpr));\n  return res;\n}\n\nbool contain(Interval i, int pos) {\n  if(i.l <= pos && pos <= i.r) return true;\n  if(i.r < i.l && pos <= i.r) return true;\n  if(i.r < i.l && i.l <= pos) return true;\n  return false;\n}\n\nint solve(int pos) {\n  vector<Interval> rem;\n  rep(i, n) {\n    if(contain(vec[i], pos)) continue;\n    int l = vec[i].l, r = vec[i].r;\n    if(r < l) r += (w+h)*2;\n    rem.push_back(Interval(l, r));\n  }\n  if(rem.empty()) return 1;\n  sort(all(rem));\n  int res = 2;\n  int prev = inf;\n  rep(i, rem.size()) {\n    if(rem[i].l <= prev) chmin(prev, rem[i].r);\n    else res++, prev = rem[i].r;\n  }\n  return res;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> n >> w >> h;\n  rep(i, n) {\n    int x, y; char d;\n    cin >> x >> y >> d;\n    men.push_back(Man(Point(x, y), D.find(d)));\n  }\n\n  rep(i, n) {\n    vec.push_back(getInterval(men[i]));\n    //cout<<vec[i].l<<\" \"<<vec[i].r<<endl;\n  }\n\n  int ans = inf;\n  rep(i, n) {\n    chmin(ans, solve(vec[i].l));\n    chmin(ans, solve(vec[i].r));\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <set>\nusing namespace std;\nusing T=tuple<int,int,int>;//i,r=0/l=1,i\nint main(){\n    int n,w,d;\n    cin>>n>>w>>d;\n    vector<T> V;\n    for(int i=0;i<n;i++){\n        int x,y; char dir;\n        cin>>x>>y>>dir;\n        if(dir=='N'){\n            //left\n            if(x+y<=d){\n                V.emplace_back(2*w+2*d-(x+y),1,i);\n            }else{\n                V.emplace_back(2*w+d-(x+y-d),1,i);\n            }\n            //right\n            if(y+w-x<=d){\n                V.emplace_back(w+(y+w-x),0,i);\n            }else{\n                V.emplace_back(2*w+d-(x+d-y),0,i);\n            }\n        }else if(dir=='S'){\n            //left\n            if(x+y-w>=0){\n                V.emplace_back(w+(x+y-w),1,i);\n            }else{\n                V.emplace_back(x+y,1,i);\n            }\n            //right\n            if(y-x>=0){\n                V.emplace_back(2*w+2*d-(y-x),0,i);\n            }else{\n                V.emplace_back(x-y,0,i);\n            }\n        }else if(dir=='E'){\n            //left\n            if(y+w-x<=d){\n                V.emplace_back(w+(y+w-x),1,i);\n            }else{\n                V.emplace_back(2*w+d-(x+d-y),1,i);\n            }           \n            //right\n            if(x+y-w>=0){\n                V.emplace_back(w+(x+y-w),0,i);\n            }else{\n                V.emplace_back(x+y,0,i);\n            }\n        }else if(dir=='W'){\n            //left\n            if(y-x>=0){\n                V.emplace_back(2*w+2*d-(y-x),1,i);\n            }else{\n                V.emplace_back(x-y,1,i);\n            }\n            //right\n            if(x+y<=d){\n                V.emplace_back(2*w+2*d-(x+y),0,i);\n            }else{\n                V.emplace_back(2*w+d-(x+y-d),0,i);\n            }\n        }\n    }\n    for(int i=0;i<2*n;i++){\n        int a,b,c; tie(a,b,c)=V[i];\n        V.emplace_back(a+2*w+2*d,b,c);\n        V.emplace_back(a+4*w+4*d,b,c);\n    }\n    sort(V.begin(),V.end());\n    /*\n    for(auto v:V){\n        int a,b,c; tie(a,b,c)=v;\n        cout<<a<<' '<<b<<' '<<c<<endl;\n    }*/\n    int best = n+1;\n    for(int j=0;j<2*n;j++){\n        set<int> S;\n        vector<int> Sta(n);//0:not covered, 1:covered\n        int ans = 0;\n        for(int i=j;i<j+2*n;i++){\n            int loc,id,lr; tie(loc,lr,id)=V[i];\n            if(lr==0){//r\n                //S[id]=1;\n                S.insert(id);\n            }else{//l\n                S.erase(id);\n            }\n        }\n        for(int i=j+2*n;i<j+4*n;i++){\n            int loc,id,lr; tie(loc,lr,id)=V[i];\n            if(lr==0){//r\n                //cout<<loc<<' '<<id<<endl;\n                if(Sta[id]==0){\n                    S.insert(id);\n                }\n            }else{//l\n                if(S.count(id)){\n                    ans++;\n                    for(auto &s:S){\n                        Sta[s]=1;\n                    }\n                    S.clear();\n                }\n            }\n        }\n        //cout<<ans<<endl;\n        best=min(ans,best);\n    }\n    cout<<best<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> Pi;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) (int)x.size()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\n\nint n, w, d;\nPi p[1010], q[1010], D[1010];\n\nint get(int x,int y,int dir){\n\t// 3 0\n\t// 2 1\n\tif(dir == 0){\n\t\tif(w - x > d - y)return x + (d - y);\n\t\telse return w + d - (y + (w - x));\n\t}\n\telse if(dir == 1){\n\t\tif(w - x > y)return w + d + w - (x + y);\n\t\telse return w + d - (y - (w - x));\n\t}\n\telse if(dir == 2){\n\t\tif(x > y)return w + d + w - (x - y);\n\t\telse return w + d + w + (y - x);\n\t}\n\telse{\n\t\tif(x >= d - y)return x - (d - y);\n\t\telse return w + d + w + (x + y);\n\t}\n\t// [0, 2*(w+d)-1]\n}\n\nbool comp(const Pi &a, const Pi &b){\n\treturn a.Se != b.Se ? a.Se < b.Se : a.Fi < b.Fi;\n}\n\nvoid solve(int tc){\n\tscanf(\"%d%d%d\", &n, &w, &d);\n\tfor(int i=0;i<n;i++){\n\t\tint x, y;\n\t\tchar ch[2];\n\t\tscanf(\"%d%d%s\", &x, &y, ch);\n\t\tif(ch[0] == 'E'){\n\t\t\tp[i].Fi = get(x, y, 0);\n\t\t\tp[i].Se = get(x, y, 1);\n\t\t}\n\t\telse if(ch[0] == 'S'){\n\t\t\tp[i].Fi = get(x, y, 1);\n\t\t\tp[i].Se = get(x, y, 2);\n\t\t}\n\t\telse if(ch[0] == 'W'){\n\t\t\tp[i].Fi = get(x, y, 2);\n\t\t\tp[i].Se = get(x, y, 3);\n\t\t}\n\t\telse{\n\t\t\tp[i].Fi = get(x, y, 3);\n\t\t\tp[i].Se = get(x, y, 0);\n\t\t}\n\t}\n\t\n\tsort(p, p+n, comp);\n\t//for(int i=0;i<n;i++)printf(\"%d %d\\n\", p[i].Fi, p[i].Se);puts(\"\");puts(\"\");\n\t\n\t\n\tint ans = ~0u>>1;\n\tint SZ = 2 * (d + w);\n\tfor(int i=0;i<n;i++){\n\t\t//put at p[i].Se;\n\t\tint top = 0;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(p[j].Se != p[i].Se && p[j].Fi > p[i].Se && p[j].Fi < p[j].Se)q[top++] = Pi(p[j].Fi - p[i].Se, p[j].Se - p[i].Se);\n\t\t}\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(p[j].Se != p[i].Se && (p[j].Fi > p[i].Se || p[j].Fi < p[j].Se))q[top++] = Pi((p[j].Fi - p[i].Se + SZ) % SZ, p[j].Se - p[i].Se + SZ);\n\t\t}\n\t\t\n\t\t\n\t\t//for(int i=0;i<top;i++)printf(\"%d %d\\n\", q[i].Fi, q[i].Se);puts(\"\");\n\t\t\n\t\tint z = 0, mx = 0;\n\t\tD[z++] = Pi(0, 0);\n\t\tfor(int j=0;j<top;j++){\n\t\t\tint v = (lower_bound(D, D+z, Pi(p[j].Fi-1, 100001)) - 1)->Se;\n\t\t\tD[z++] = Pi(p[j].Se, mx = max(mx, v + 1));\n\t\t}\n\t\tans = min(ans, mx + 1);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main(){\n\tint Tc = 1;// scanf(\"%d\",&Tc);\n\tfor(int i=1;i<=Tc;i++){\n\t\tsolve(i);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <cstdio>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long double ldb;\ntypedef complex<ldb> P;\n\nconst ldb eps = 1e-9;\nconst ldb pi = acos(-1);\nint sig(ldb a) {return (a<-eps)?-1:(a>eps)?1:0;}\nbool eq(ldb a,ldb b){return abs(a-b)<eps;}\nldb dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\nldb cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nldb ang(P a,P b,P c) {\n  P p = a-b;\n  P q = c-b;\n  if( eq(abs(p)*abs(q),0) ) return 0;\n  return acos(dot(p,q)/(abs(p)*abs(q)));\n}\n\nstruct L {\n  P a,b;\n  L(){}\n  L(P a,P b):a(a),b(b){}\n  ldb len(){return abs(a-b);}\n  P vec(){return b-a;}\n};\n\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\nint ccw(L s, P p) {\n  P a = s.vec();\n  p -= s.a;\n  ldb cr = cross(a, p);\n  if (eq(cr, 0)) {\n    if (sig(dot(a, p)) < 0) return BACK;\n    if (sig(norm(a) - norm(p)) < 0) return FRONT;\n    return ON;\n  }\n  return (cr > 0) ? LEFT : RIGHT;\n}\n\nP iP2(L a,L b) {\n  P c = b.b-b.a;\n  ldb d1 = abs(cross(c, a.a-b.a));\n  ldb d2 = abs(cross(c, a.b-b.a));\n  ldb t = d1 / (d1 + d2);\n  return a.a + (a.b-a.a) * t;\n}\n\nbool iI2_2(L a, L b) {\n  int cwa = ccw(a, b.a) | ccw(a, b.b);\n  int cwb = ccw(b, a.a) | ccw(b, a.b);\n  return ((cwa | cwb) & ON) || ((cwa & cwb) == (LEFT | RIGHT));\n}\n\nint n, w, d;\nint x[1111], y[1111];\nchar f[1111];\nP mid;\n\npair<int, int> tp(const P& p) {\n  return {p.real()+eps, p.imag()+eps};\n}\n\nint main(void) {\n  scanf(\"%d%d%d\", &n, &w, &d);\n\n  mid = P(w/2.0, d/2.0);\n  \n  for (int i = 0; i < n; i++) {\n    scanf(\"%d%d %c\", x+i, y+i, f+i);\n  }\n\n  vector<L> ls {\n    L(P(0, 0), P(w, 0)),\n        L(P(0, 0), P(0, d)),\n        L(P(w, 0), P(w, d)),\n        L(P(0, d), P(w, d)),\n  };\n  vector<P> p1, p2;\n  vector<tuple<ldb, ldb, int>> a;\n  vector<pair<int, int>> pos;\n  const int I = 1000000;\n\n  for (int i = 0; i < n; i++) {\n    L l1, l2;\n    P pos(x[i], y[i]);\n    if (f[i] == 'N') {\n      l1 = L(pos, P(x[i]+I, y[i]+I));\n      l2 = L(pos, P(x[i]-I, y[i]+I));\n    } else if (f[i] == 'W') {\n      l1 = L(pos, P(x[i]-I, y[i]+I));\n      l2 = L(pos, P(x[i]-I, y[i]-I));\n    } else if (f[i] == 'S') {\n      l1 = L(pos, P(x[i]-I, y[i]-I));\n      l2 = L(pos, P(x[i]+I, y[i]-I));\n    } else {\n      l1 = L(pos, P(x[i]+I, y[i]-I));\n      l2 = L(pos, P(x[i]+I, y[i]+I));\n    }\n    for (int i = 0; i < 4; i++) {\n      if (iI2_2(l1, ls[i])) {\n        p1.push_back(iP2(l1, ls[i]));\n        break;\n      }\n    }\n    for (int i = 0; i < 4; i++) {\n      if (iI2_2(l2, ls[i])) {\n        p2.push_back(iP2(l2, ls[i]));\n        break;\n      }\n    }\n  }\n\n  for (int i = 0; i < int(p1.size()); i++) {\n    pos.push_back(tp(p1[i]));\n    pos.push_back(tp(p2[i]));\n  }\n  sort(pos.begin(), pos.end());\n  pos.erase(unique(pos.begin(), pos.end()), pos.end());\n\n  vector<ldb> cl;\n  for (int i = 0; i < int(pos.size()); i++) {\n    cl.push_back(arg(mid-P(pos[i].first, pos[i].second))+pi);\n  }\n  sort(cl.begin(), cl.end());\n\n  /*\n  for (int i = 0; i < int(pos.size()); i++) {\n    printf(\"%d %d\\n\", pos[i].first, pos[i].second);\n  }\n  //*/\n\n  /*\n  for (int i = 0; i < int(cl.size()); i++) {\n    printf(\"%.10Lf\\n\", cl[i]/pi*180);\n  }\n  //*/\n\n  for (int i = 0; i < int(p1.size()); i++) {\n    ldb a1 = arg(mid-p1[i])+pi;\n    ldb a2 = arg(mid-p2[i])+pi;\n    if (a1 > a2) a2 += 2*pi;\n    a.emplace_back(a1, a2, i);\n  }\n  sort(a.begin(), a.end());\n\n  /*\n  for (int i = 0; i < int(a.size()); i++) {\n    printf(\"%20.10Lf %20.10Lf \", get<0>(a[i])/pi*180, get<1>(a[i])/pi*180);\n    printf(\"%d\\n\", get<2>(a[i]));\n  }\n  //*/\n\n  int res = 114514;\n  for (int i = 0; i < n; i++) {\n    {\n      int u[2222] {};\n      int b = 0;\n      for (int j = 0; j < int(cl.size()); j++) {\n        if (eq(cl[j], arg(mid-p1[get<2>(a[i])])+pi)) {\n          b = j;\n          break;\n        }\n        /*\n          if ((sig(get<0>(a[i])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[i])) <= 0) ||\n          (sig(get<0>(a[i])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[i])) <= 0)) {\n          b = j;\n          }\n        */\n      }\n      // printf(\"%d\\n\", b);\n      int c = 0;\n      int j = b;\n      u[j] = 1;\n      int k = (i+1)%n;\n      // printf(\"%d %d\\n\", k, j);\n      while (k != i) {\n        while (k != i && ((sig(get<0>(a[k])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[k])) <= 0) ||\n                          (sig(get<0>(a[k])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[k])) <= 0))) {\n          k = (k+1)%n;\n        }\n        if (k != i) {\n          while (!((sig(get<0>(a[k])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[k])) <= 0) ||\n                   (sig(get<0>(a[k])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[k])) <= 0))) {\n            j = (j+1)%cl.size();\n          }\n          int pj = j;\n          while (((sig(get<0>(a[k])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[k])) <= 0) ||\n                  (sig(get<0>(a[k])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[k])) <= 0))) {\n            pj = j;\n            j = (j+1)%cl.size();\n          }\n          j = pj;\n          u[j] = 1;\n        }\n        // printf(\"%d %d\\n\", k, j);\n      }\n      //*\n      for (int p = 0; p < int(cl.size()); p++) {\n        c += u[p];\n        //printf(\"%d \", u[p]);\n      }\n      // puts(\"\");\n      //*/\n      res = min(res, c);\n    }\n    {\n      int u[2222] {};\n      int b = 0;\n      for (int j = 0; j < int(cl.size()); j++) {\n        if (eq(cl[j], arg(mid-p2[get<2>(a[i])])+pi)) {\n          b = j;\n          break;\n        }\n        /*\n          if ((sig(get<0>(a[i])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[i])) <= 0) ||\n          (sig(get<0>(a[i])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[i])) <= 0)) {\n          b = j;\n          }\n        */\n      }\n      // printf(\"%d\\n\", b);\n      int c = 0;\n      int j = b;\n      u[j] = 1;\n      int k = (i+1)%n;\n      while (k != i) {\n        // printf(\"%d %d\\n\", k, j);\n        while (k != i && ((sig(get<0>(a[k])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[k])) <= 0) ||\n                          (sig(get<0>(a[k])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[k])) <= 0))) {\n          k = (k+1)%n;\n        }\n        if (k != i) {\n          while (!((sig(get<0>(a[k])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[k])) <= 0) ||\n                   (sig(get<0>(a[k])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[k])) <= 0))) {\n            j = (j+1)%cl.size();\n          }\n          int pj = j;\n          while (((sig(get<0>(a[k])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[k])) <= 0) ||\n                  (sig(get<0>(a[k])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[k])) <= 0))) {\n            pj = j;\n            j = (j+1)%cl.size();\n          }\n          j = pj;\n          u[j] = 1;\n        }\n      }\n      //*\n      for (int p = 0; p < int(cl.size()); p++) {\n        c += u[p];\n        //printf(\"%d \", u[p]);\n      }\n      // puts(\"\");\n      //*/\n      res = min(res, c);\n    }\n  }  \n\n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint w,d;\n\nstruct node\n{\n    int x,y;\n    int l;\n    int r;\n    int flag;\n}p[1010];\n\nbool cmp(node a,node b)\n{\n    if(a.l==b.l)\n    {\n        return a.r>=b.r;\n    }\n    else return a.l<b.l;\n}\nvoid cal1(int i)\n{\n   p[i].r=3*w+2*d-p[i].y-p[i].x;\n   p[i].l=w+2*d+p[i].x-p[i].y;\n   //printf(\"%d %d\\n\",p[i].l,p[i].r);\n}\n\nvoid cal2(int i)\n{\n   p[i].r=3*w+2*d+p[i].y-p[i].x;\n   p[i].l=3*w+2*d-p[i].x-p[i].y;\n   //printf(\"%d %d\\n\",p[i].l,p[i].r);\n}\n\nvoid cal3(int i)\n{\n   p[i].l=w+p[i].y-p[i].x;\n   p[i].r=w+p[i].y+p[i].x;\n   //printf(\"%d %d\\n\",p[i].l,p[i].r);\n}\n\nvoid cal4(int i)\n{\n   p[i].l=w+p[i].x+p[i].y;\n   p[i].r=w+2*d+p[i].x-p[i].y;\n   //printf(\"%d %d\\n\",p[i].l,p[i].r);\n}\n\nvoid Input(int i)\n{\n    char s[2];\n    scanf(\"%d%d\",&p[i].x,&p[i].y);\n    scanf(\"%s\",s);\n    if(s[0]=='E')\n    {\n        cal1(i);\n    }\n    else if(s[0]=='S')\n    {\n        cal2(i);\n    }\n    else if(s[0]=='W')\n    {\n       cal3(i);\n    }\n    else if(s[0]=='N')\n    {\n        cal4(i);\n    }\n    if(p[i].l>=2*w+2*d)\n    {\n        p[i].l=p[i].l-2*w-2*d;\n        p[i].r=p[i].r-2*w-2*d;\n    }\n    //printf(\"%d %d\\n\",p[i].l,p[i].r);\n    return;\n}\nint main()\n{\n    int n;\n    while(~scanf(\"%d\",&n))\n    {\n        memset(p,-1,sizeof(p));\n        scanf(\"%d%d\",&w,&d);\n        for(int i = 0; i < n; i++)\n        {\n            Input(i);\n        }\n        sort(p,p+n,cmp);\n        node b[1010];\n        b[0]=p[0];\n        int cnt1=0;int cnt2=0;\n        int flag=0,k=-1;\n        int i,j;\n        for(i = 1; i < n; i++)\n        {\n            if(p[i].l<=b[cnt2].r)\n            {\n                b[cnt2].l=p[i].l;\n                if(p[i].r<=b[cnt2].r)\n                    b[cnt2].r=p[i].r;\n                b[i].flag=0;\n            }\n\n            else\n                {\n                    b[++cnt2]=p[i];\n                    if(b[cnt2].r>=2*w+2*d&&flag==0)\n                    {\n                        k=cnt2;\n                        flag=1;\n                    }\n                }\n        }\n        //??????\n        for(i = k; i < cnt2+1&&k!=0; i++)\n        {\n            for(j = cnt1; j < cnt2+1; j++)\n            {\n                if(b[j].l>=b[i].l-2*w-2*d&&b[j].r<=b[i].r-2*w-2*d)\n                {\n                    b[i].l=b[j].l+2*w+2*d;\n                    b[i].r=b[j].r+2*w+2*d;\n                    cnt1++;\n                }\n                else if(b[j].l>=b[i].l-2*w-2*d&&b[j].l<=b[i].r-2*w-2*d&&b[i].flag==-1)\n                {\n                    b[cnt2].l=p[i].l;\n                    if(p[i].r<=b[cnt2].r)\n                        b[cnt2].r=p[i].r;\n                    cnt1++;\n                }\n            }\n        }\n        printf(\"%d\\n\",cnt2-cnt1+1);\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii=pair<int,int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define l first\n#define r second\n\nint main(){\n\tint n,w,h,p;\n\twhile(cin>>n>>w>>h){\n\t\tp=w*2+h*2;\n\t\tdeque<pii> rng(n);\n\t\trep(i,n){\n\t\t\tint x,y,v; char c;\n\t\t\tcin>>x>>y>>c;\n\t\t\trng[i].l=[=]{return (int[]){x-h+y,x+h-y,w*2+h+y-x,w*2+h-y-x}[\"NEWS\"s.find(c)];}();\n\t\t\trng[i].r=[=]{return (int[]){x+h-y,w*2+h-y-x,w*2+h+y+x,w*2+h+y-x}[\"NEWS\"s.find(c)];}();\n\t\t}\n\t\tsort(all(rng),[](pii a,pii b){return a.r<b.r;});\n\t\t//for(auto i:rng)cout<<i.l<<\",\"<<i.r<<endl;\n\t\t\n\t\tint ans=1e8;\n\t\trep(i,n) {\n\t\t\t//for(auto&j:rng) if(j.r<rng[0].r) j.l+=p, j.r+=p;\n\t\t\tsort(all(rng),[](pii a,pii b){return a.r<b.r;});\n\t\t\tint a=1,b=rng[0].r;\n\t\t\t//cout<<i<<\":\"<<b<<\"=====\"<<endl;\n\t\t\trange(j,1,n){\n\t\t\t\tif(rng[j].l>b){\n\t\t\t\t\ta++;\n\t\t\t\t\tb=rng[j].r;\n\t\t\t\t\t//cout<<j<<\":\"<<b<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans=min(ans,a);\n\t\t\trng[0].l+=p, rng[0].r+=p;\n\t\t\t//rng.push_back(rng[0]);\n\t\t\t//rng.pop_front();\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, w, h, z;\nvector<pi> v;\npi calc(int x, int y){\n\treturn mp(x - y, x + y);\n}\nint solve(int s){\n\tint cnt = 0, prev = -inf;\n\tfor(int i = s; i < s + n; i++){\n\t\tif(v[i].second <= prev) continue;\n\t\tcnt++;\n\t\tprev = v[i].first;\n\t}\n\treturn cnt;\n}\n\nint main(){\n\tcin >> n >> w >> h;\n\tint z = 2 * (w + h);\n\trep(i, n){\n\t\tint x, y; char c;\n\t\tcin >> x >> y >> c;\n\t\tpi p;\n\t\tif(c == 'S') p = calc(x, y);\n\t\tif(c == 'E') { p = calc(y, w - x); p.first += w; p.second += w; }\n\t\tif(c == 'N') { p = calc(w - x, h - y); p.first += w + h; p.second += w + h; }\n\t\tif(c == 'W') { p = calc(h - y, x); p.first += 2 * w + h; p.second += 2 * w + h; }\n\t\tint l = (p.first + z) % z;\n\t\tint r = (p.second+ z) % z;\n\t\tif(l > r) r += z;\n\t\tv.pb(mp(r, l));\n\t}\n\tsort(all(v));\n\trep(i, n) v.pb(mp(v[i].first + z, v[i].second + z));\n\t\n\tint ans = n;\n\trep(i, n) ans = min(ans, solve(i));\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P1;\nint n,w,d,x,y,ans;\nvector<P1> v;\nchar f;\nstack<int> q;\nbool used[N];\n\nvoid add_point(int num){\n  if(f=='N'){\n    if(x+y<d)v.push_back(P1(P(x+y+w*2+d,0),num));\n    else v.push_back(P1(P(x+y-d,0),num));\n    if(w+y-x<d)v.push_back(P1(P(d-(w+y-x)+w,1),num));\n    else v.push_back(P1(P(d-(y-x),1),num));\n  }\n  if(f=='E'){\n    if(d-(y-x)<w)v.push_back(P1(P(d-(y-x),0),num));\n    else v.push_back(P1(P(d-(w+(y-x))+w,0),num));\n    if(y+x<w)v.push_back(P1(P(w-(y+x)+w+d,1),num));\n    else v.push_back(P1(P(d-(-w+y+x)+w,1),num));\n  }\n  if(f=='S'){\n    if(0<=-w+y+x)v.push_back(P1(P(d-(-w+y+x)+w,0),num));\n    else v.push_back(P1(P(w-(y+x)+w+d,0),num));\n    if(0<=y-x)v.push_back(P1(P(y-x+w*2+d,1),num));\n    else v.push_back(P1(P(w-(-(y-x))+w+d,1),num));\n  }\n  if(f=='W'){\n    if(0<=-(y-x))v.push_back(P1(P(w-(-(y-x))+w+d,0),num));\n    else v.push_back(P1(P(y-x+w*2+d,0),num));\n    if(0<=y+x-d)v.push_back(P1(P(y+x-d,1),num));\n    else v.push_back(P1(P(y+x+w*2+d,1),num));\n  }\n}\n\nbool usednum[500000];\n\nvoid solve(){\n  int len=v.size(),cnt;\n  for(int i=0;i<len;i++){\n    memset(used,0,sizeof(used));\n    memset(usednum,0,sizeof(usednum));\n    if(v[i].first.second)continue;\n    cnt=0;\n    for(int j=i;j<len+i;j++){\n      int idx=j%len;\n      if(used[v[idx].second])continue;\n      if(!v[idx].first.second)q.push(v[idx].second);\n      else{\n\tcnt++;\n\tif(usednum[v[idx].first.first])cnt--;\n\tusednum[v[idx].first.first]=true;\n\tused[v[idx].second]=true;\n\twhile(!q.empty()){\n\t  int num=q.top(); q.pop();\n\t  used[num]=true;\n\t}\n      }\n    }\n    ans=min(ans,cnt);\n  }\n}\n\nint main(){\n  cin>>n>>w>>d;\n  for(int i=0;i<n;i++){\n    cin>>x>>y>>f;\n    add_point(i);\n  }\n  sort(v.begin(),v.end());\n  for(int i=0;i<v.size();i++)\n    cout<<v[i].first.first<<' '<<v[i].first.second<<' '<<v[i].second<<endl;\n  ans=(1e9);\n  solve();\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define pii pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< pii >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; cin >> x;\n#define int2(x, y) Int(x); Int(y);\n#define int3(x, y, z) Int(x); int2(y, z);\n#define in(x, a, b) ((a) <= (x) && (x) < (b))\n#define fir first\n#define sec second\n#define ffir first.first\n#define fsec first.second\n#define sfir second.first\n#define ssec second.second\n#define Decimal fixed << setprecision(10)\n\n//int dxy[5] = {0, 1, 0, -1, 0};\n// cmd\n\n\nint solve(vp &range, const int p, const int over)\n{\n    //cout << \"call \" << p << \" : \";\n    int n = range.size(), bef = p, ret = 1;\n\n    for (int i = (p + 1) % n; i != p; i = (i + 1) % n) {\n        if (range[i].fir < range[i].sec && \n                range[i].fir <= range[bef].sec && range[bef].sec <= range[i].sec) {\n            continue;\n        } else if (range[i].fir > range[i].sec &&\n                (range[i].fir <= range[bef].sec || range[bef].sec <= range[i].sec)) {\n            continue;\n        } else {\n            //cout << i << \" , \";\n            ret++;\n            bef = i;\n        }\n    }\n\n    //cout << endl;\n\n    return ret;\n}\n\nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    Int(n);\n    int2(w, d);\n\n    vector<pair<pii, pii>> data(n);\n    rep(i, n) {\n        int2(x, y); // yoko, tate\n        string st;\n        cin >> st;\n        if (st[0] == 'E') { // right\n            int b = y - x;\n            data[i].ffir = d - b;\n            data[i].fsec = d;\n            if (data[i].ffir < 0 || w < data[i].ffir) {\n                data[i].ffir = w;\n                data[i].fsec = w + b;\n            }\n            b = y + x;\n            data[i].sfir = b;\n            data[i].ssec = 0;\n            if (data[i].sfir < 0 || w < data[i].sfir) {\n                data[i].sfir = w;\n                data[i].ssec = -w + b;\n            }\n        } else if (st[0] == 'W') {\n            int b = y - x;\n            data[i].ffir = -b;\n            data[i].fsec = 0;\n            if (data[i].ffir < 0 || w < data[i].ffir) {\n                data[i].ffir = 0;\n                data[i].fsec = b;\n            }\n            b = y + x;\n            data[i].sfir = b - d;\n            data[i].ssec = d;\n            if (data[i].sfir < 0 || w < data[i].sfir) {\n                data[i].sfir = 0;\n                data[i].ssec = b;\n            }\n        } else if (st[0] == 'N') {\n            int b = y + x;\n            data[i].ffir = b - d;\n            data[i].fsec = d;\n            if (data[i].ffir < 0 || w < data[i].ffir) {\n                data[i].ffir = 0;\n                data[i].fsec = b;\n            }\n            b = y - x;\n            data[i].sfir = d - b;\n            data[i].ssec = d;\n            if (data[i].sfir < 0 || w < data[i].sfir) {\n                data[i].sfir = w;\n                data[i].ssec = w + b;\n            }\n        } else if (st[0] == 'S') {\n            int b = y + x;\n            data[i].ffir = b;\n            data[i].fsec = 0;\n            if (data[i].ffir < 0 || w < data[i].ffir) {\n                data[i].ffir = w;\n                data[i].fsec = -w + b;\n            }\n            b = y - x;\n            data[i].sfir = -b;\n            data[i].ssec = 0;\n            if (data[i].sfir < 0 || w < data[i].sfir) {\n                data[i].sfir = 0;\n                data[i].ssec = b;\n            }\n        }\n    }\n\n/*\nrep(i, n) {\n        cout << data[i].ffir << \" \" << data[i].fsec << endl;\n        cout << data[i].sfir << \" \" << data[i].ssec << endl;\n    }\n*/\n\n    int rn = w + w + d + d;\n    vp range(n);\n    rep(i, n) {\n        int s, e;\n        if (data[i].ffir == 0) {\n            s = data[i].fsec;\n        } else if (data[i].fsec == d) {\n            s = d + data[i].ffir;\n        } else if (data[i].ffir == w) {\n            s = d + w + (d - data[i].fsec);\n        } else if (data[i].fsec == 0) {\n            s = d + d + w + (w - data[i].ffir);\n        }\n\n        if (data[i].sfir == 0) {\n            e = data[i].ssec;\n        } else if (data[i].ssec == d) {\n            e = d + data[i].sfir;\n        } else if (data[i].sfir == w) {\n            e = d + w + (d - data[i].ssec);\n        } else if (data[i].ssec == 0) {\n            e = d + d + w + (w - data[i].sfir);\n        }\n        /*\n        range[i].fir = s;\n        range[i].sec = e;\n        //range[i].sec = (e > s ? e : e + rn);\n        */\n        range[i].fir = e;\n        range[i].sec = s;\n    }\n\n    sort(all(range));\n    rep(i, n) swap(range[i].fir, range[i].sec);\n\n    //cout << \"ops\" << endl;\n    //rep(i, n) {\n    //    cout << range[i].fir << \" \" << range[i].sec << endl;\n    //}\n\n    int ans = n;\n    rep(i, n) {\n        ans = min(ans, solve(range, i, rn));\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\nstruct Range{\n    int b, e;\n    bool operator < (const Range& r) const {\n        if(b != r.b) return b < r.b;\n        return e < r.e;\n    }\n};\nint N, W, H;\nint solve(vector<Range> ranges) {\n    const int n = ranges.size();\n    const int L = 2 * (W + H);\n    sort(ranges.begin(), ranges.end(), [&](Range a, Range b){ if(a.e != b.e) return a.e < b.e; return a.b < b.b;});\n    REP(i, n) ranges.push_back({ranges[i].b + L, ranges[i].e + L});\n    int ans = INT_MAX;\n    REP(s, n) {\n        int sub = 0;\n        vector<bool> used(n);\n        while(true) {\n            bool updated = false;\n            REP(i, n) {\n                if(!used[i]) {\n                    updated = true;\n                    const int take = ranges[s+i].e;\n                    REP(j, n) {\n                        if(ranges[s+j].b <= take && take <= ranges[s+j].e) {\n                            used[j] = true;\n                        }\n                    }\n                    break;\n                }\n            }\n            if(!updated) break;\n            sub++;\n        }\n        ans = min(ans, sub);\n    }\n    return ans;\n}\n// int solve(vector<Range> ranges) {\n//     sort(ranges.begin(), ranges.end());\n//     vector<Range> rs;\n//     vector<Range> rs2;\n//     const int L = 2 * (W + H);\n//     REP(i, ranges.size()) {\n//         // if(rs.empty() || rs.back().e < ranges[i].e) {\n//             rs.push_back(ranges[i]);\n//             rs2.push_back({ranges[i].b + L, ranges[i].e + L});\n//         // }\n//     }\n//     REP(i, rs2.size()) rs.push_back(rs2[i]);\n//     sort(rs.begin(), rs.end(), [&](Range a, Range b){ if(a.e != b.e) return a.e < b.e; return a.b < b.b;});\n//     int n = rs.size() / 2;\n//     int ans = INT_MAX;\n//     for(int s = 0; s < n; s++) {\n//         int sub = 0;\n//         for(int i = s; i < 2 * n;) {\n//             if(i >= s + n) break;\n//             const int take = rs[i].e;\n//             while(i < s + n && rs[i].b <= take && take <= rs[i].e) {\n//                 i++;\n//             }\n//             sub++;\n//         }\n//         ans = min(ans, sub);\n//     }\n//     return ans;\n// }\nvoid move(int& x, int& y, int dx, int dy) {\n    int t = INT_MAX;\n    if(dx == -1) t = min(t, x);\n    if(dx == +1) t = min(t, (W-1) - x);\n    if(dy == -1) t = min(t, y);\n    if(dy == +1) t = min(t, (H-1) - y);\n    x += t * dx;\n    y += t * dy;\n}\nint convert(int x, int y) {\n    if(x == 0 && y == 0) return 0;\n    if(y == 0) {\n        return x;\n    }\n    if(x == W - 1) {\n        return W + y;\n    }\n    if(y == H - 1) {\n        return W + H + (W - 1 - x);\n    }\n    assert(x == 0);\n    return W + H + W + (H - 1 - y);\n}\nint main(){\n    iostream_init();\n    while(cin >> N >> W >> H) {\n        W++; H++;\n        vector<Range> ranges;\n        REP(i, N) {\n            int x, y;\n            cin >> x >> y;\n            string F;\n            cin >> F;\n            int lx = x, ly = y;\n            int rx = x, ry = y;\n            if(F == \"N\") {\n                // up\n                move(lx, ly, +1, +1);\n                move(rx, ry, -1, +1);\n            } else if(F == \"E\") {\n                // right\n                move(lx, ly, +1, -1);\n                move(rx, ry, +1, +1);\n            } else if(F == \"S\") {\n                // down\n                move(lx, ly, -1, -1);\n                move(rx, ry, +1, -1);\n            } else if(F == \"W\") {\n                // left\n                move(lx, ly, -1, +1);\n                move(rx, ry, -1, -1);\n            }\n            int L = convert(lx, ly);\n            int R = convert(rx, ry);\n            if(L > R) R += 2 * (W + H); // ok ???\n            ranges.push_back({L, R});\n        }\n        // REP(i, ranges.size()) {\n        //     cout << \"(\" << ranges[i].b << \",\" << ranges[i].e << \") \";\n        // }\n        // cout << endl;\n        cout << solve(ranges) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int w,h,n;\n  cin>>n>>w>>h;\n  int x,y,B=2*(w+h),ans=n;\n  char c;\n  vector<P> m;\n  for(int i=0;i<n;i++){\n    cin>>x>>y>>c;\n    if(c=='S')m.push_back(P(x+y,(x-y+B)%B));\n    if(c=='E')m.push_back(P(w+y+(w-x),w+y-(w-x)));\n    if(c=='N')m.push_back(P(w+h+(w-x)+(h-y),w+h+(w-x)-(h-y)));\n    if(c=='W')m.push_back(P((w*2+h+(h-y)+x)%B,w*2+h+(h-y)-x));\n  }\n  sort(m.begin(),m.end());\n  for(int i=0;i<n;i++){\n    int tp=0,p=m[i].first;\n    for(int j=0;j<n;j++){\n      int s=m[(i+j)%n].second,g=m[(i+j)%n].first;\n      if(s>g&&!(g<p&&p<s))continue;\n      if(s<g&&s<=p&&p<=g)continue;\n      tp++,p=g;\n    }\n    ans=min(tp,ans);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\ntypedef std::pair<int,int> ii;\n\nbool IsContain(ii pos,int h,int w){\n  if(1<=pos.first&&pos.first<=w-1&&1<=pos.second&pos.second<=h-1){\n    return true;\n  }else{\n    return false;\n  }\n}\n\nint GetPos(ii pos,int h,int w){\n  int result=0;\n  if(pos.first==0){\n    result= 2*w+h+(h-pos.second);\n  }else if(pos.first==w){\n    result= w+pos.second;\n  }else if(pos.second==0){\n    result= pos.first;\n  }else{\n   result= w+h+(w-pos.first);\n  }\n  // if(result>=(h+w)*2){\n  //   result=0;\n  // }\n  return result;\n}\n\n\n\nint Solve(std::vector<ii> job,int start,int d,int w,int it){\n  int result=1;\n  int time=start;\n  int start_itr=it;\n\n  int itr=start_itr;\n  bool looped=false;\n  while(true){\n    if(itr==start_itr&&looped){\n      break;\n    }\n    if(job[itr].first<job[itr].second){\n      if(!(job[itr].first<=time&&time<=job[itr].second)){\n        time=job[itr].second;\n        result++;\n      }\n    }else{\n      if(!((job[itr].first<=time&&time<=2*(d+w))||(0<=time&&time<=job[itr].second))){\n        time=job[itr].second;\n        result++;\n      }\n    }\n    itr++;\n    if(itr>=job.size()){\n      looped=true;\n      itr=0;\n    }\n  }\n\n  return result;\n}\n\nint main(void) {\n  cout << std::fixed << std::setprecision(10);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  int n,w,d;\n  cin>>n>>w>>d;\n  std::vector<ii> job;\n  for(int i=0;i<n;i++){\n    int x,y;\n    char f;\n    cin>>x>>y>>f;\n    int limit_l,limit_r;\n    ii l_pos=std::make_pair(x,y);\n    ii r_pos=l_pos;\n    if(f=='E'){\n      while(IsContain(l_pos,d,w)){\n        l_pos.first++;\n        l_pos.second--;\n      }\n      while(IsContain(r_pos,d,w)){\n        r_pos.first++;\n        r_pos.second++;\n      }\n    } else if(f=='W'){\n      while(IsContain(l_pos,d,w)){\n        l_pos.first--;\n        l_pos.second++;\n      }\n      while(IsContain(r_pos,d,w)){\n        r_pos.first--;\n        r_pos.second--;\n      }\n    } else if(f=='N'){\n      while(IsContain(l_pos,d,w)){\n        l_pos.first++;\n        l_pos.second++;\n      }\n      while(IsContain(r_pos,d,w)){\n        r_pos.first--;\n        r_pos.second++;\n      }\n    } else {//f=='S'\n      while(IsContain(l_pos,d,w)){\n        l_pos.first--;\n        l_pos.second--;\n      }\n      while(IsContain(r_pos,d,w)){\n        r_pos.first++;\n        r_pos.second--;\n      }\n    }\n\n    limit_l=GetPos(l_pos,d,w);\n    limit_r=GetPos(r_pos,d,w);\n    if(limit_r==0){\n      limit_r=32;\n    }\n\n    job.push_back(std::make_pair(limit_l,limit_r));\n  }\n\n  int result=INT32_MAX;\n  std::sort(job.begin(), job.end(),[](ii a,ii b){\n    return a.second<b.second;\n  });\n\n  for(int i=0;i<2*n;i++){\n    if(i%2==0){\n      result=std::min(result,Solve(job,job[i/2].first,d,w,i/2));\n    }else{\n      result=std::min(result,Solve(job,job[i/2].second,d,w,i/2));\n    }\n\n\n  }\n  cout<<result<<endl;\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nint n,w,d;\nint s[1010],g[1010];\n\ninline int convert(int x,int y){\n\tif(x==0) return y;\n\tif(y==d) return d+x;\n\tif(x==w) return d+w+(d-y);\n\tif(y==0) return d+w+d+(w-x);\n\treturn 0;\n}\n\nint main(void){\n\tcin >> n >> w >> d;\n\trep(i,n){\n\t\tint x,y;\n\t\tchar w;\n\t\tcin >> x >> y >> w;\n\n\t\tconst int u=d-y,b=y,l=x,r=w-x;\n\n\t\tswitch(w){\n\t\t\tcase 'N':\n\t\t\t\ts[i]=(l<=u?convert(0,y+l):convert(x-u,d));\n\t\t\t\tg[i]=(r<=u?convert(w,y+r):convert(x+u,d));\n\t\t\t\tbreak;\n\n\t\t\tcase 'W':\n\t\t\t\ts[i]=(b<=l?convert(x-b,0):convert(w,y-l));\n\t\t\t\tg[i]=(u<=l?convert(x-u,d):convert(w,y+l));\n\t\t\t\tbreak;\n\n\t\t\tcase 'E':\n\t\t\t\ts[i]=(u<=r?convert(x+u,d):convert(w,y+r));\n\t\t\t\tg[i]=(b<=r?convert(x+b,0):convert(w,y-r));\n\t\t\t\tbreak;\n\n\t\t\tcase 'S':\n\t\t\t\ts[i]=(r<=b?convert(w,y-r):convert(x+b,0));\n\t\t\t\tg[i]=(l<=b?convert(0,y-l):convert(x-b,0));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tconst int all=2*(w+d);\n\tusing state=tuple<int,int>;\n\tvector<state> ary;\n\trep(i,n){\n\t\tif(s[i]>g[i]) g[i]+=all;\n\t\tary.push_back(make_tuple(s[i],g[i]));\n\t}\n\n\tsort(_all(ary));\n\trep(i,n){\n\t\tint cs,cg;\n\t\ttie(cs,cg)=ary[i];\n\t\tary.push_back(make_tuple(cs+all,cg+all));\n\t}\n\t//rep(i,n) cout << get<0>(ary[i]) << \" \" << get<1>(ary[i]) << endl;\n\n\tint ans=n;\n\trep(i,n){\n\t\tint cur=get<1>(ary[i]),j=i+1,res=1;\n\t\twhile(j-i<n){\n\t\t\tif(cur<get<0>(ary[j])) cur=get<1>(ary[j]),res++;\n\t\t\tchmin(cur,get<1>(ary[j]));\n\t\t\tj++;\n\t\t}\n\t\tchmin(ans,res);\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\n#include <ctype.h> // isdigit\n#include <cassert>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(u) begin(u),end(u)\n#define PB push_back\n#define LE(n,m) ((n) < (m) + EPS * (abs(n) + abs(m)))\n#define GE(n,m) ((n) + EPS * (abs(n) + abs(m)) > (m))\n#define LT(n,m) ((n) + EPS * (abs(n) + abs(m)) < (m))\n#define GT(n,m) ((n) > (m) + EPS * (abs(n) + abs(m)))\n#define EQ(n,m) (abs((n)-(m)) < EPS * (abs(n) + abs(m)))\n\ntypedef long long int ll;\nconst int INF = (1<<30) - 1;\nconst double EPS = 1e-9;\nconst int MOD = 1000000007;\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    //cout.setf(ios::fixed);\n    \n    int N, W, D;\n    cin >> N >> W >> D;\n    int L = 2 * (W + D);\n    //end, start\n    vector<pair<int, int>> lines;\n    \n    for(int i=0; i<N; i++){\n        int x, y; string f;\n        cin >> x >> y >> f;\n        int nx, ny;\n        if(f == \"S\"){\n            nx = x;\n            ny = y;\n        }\n        if(f == \"E\"){\n            nx = y + W;\n            ny = W - x;\n        }\n        if(f == \"N\"){\n            nx = 2*W + D - x;\n            ny = D - y;\n        }\n        if(f == \"W\"){\n            nx = -y;\n            ny = x;\n        }\n        lines.emplace_back(nx + ny, nx - ny);\n    }\n    sort(lines.begin(), lines.end());\n    \n    int ans = INF;\n    for(int s=0; s<N; s++){ //????????°???????§??????¨?????????\n        int tans = 0;\n        int p = lines[s].first;\n        for(int i=0; i<N; i++){\n            while(i<N && lines[(s+i)%N].second <= p) i++;\n            p = lines[(s+i--)%N].first;\n            tans++;\n        }\n        ans = min(ans, tans);\n        \n        lines[s].first += L;\n        lines[s].second += L;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\n#define EPS (1e-8)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\nconst double PI=4*atan(1.0);\n\ntypedef complex<double> P;\n\n// ??????\ndouble dot(const P &a, const P &b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// ??????\ndouble cross(const P &a, const P &b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distance_ls_p(const P &a, const P &b, const P &c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nint is_intersected_ls(const P &a1, const P &a2, const P &b1, const P &b2) {\n  // ????????????????????´???\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    // ????????¨???????????¢???0??????????????£????????????\n    if(EQ(distance_ls_p(a1,a2,b1),0)||EQ(distance_ls_p(a1,a2,b2),0))\n      return 1;\n    return 0;\n  }\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n    ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nP intersection_ls(const P &a1, const P &a2, const P &b1, const P &b2) {\n  // ????????????????????´????????????????????£???????????????????????£???????????¨????????????\n  // ?????£??¨???x??§?¨?????°??????????????????????\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    // ????????¨???????????¢???0??????????????£????????????\n    if(EQ(distance_ls_p(a1,a2,b1),0)||EQ(distance_ls_p(a1,a2,b2),0)){\n      // x??§?¨????a1<a2,b1<b2??¨????????????????????????\n      P la1=a1,la2=a2;\n      P lb1=b1,lb2=b2;\n      if(a1.real()>a2.real())swap(la1,la2);\n      if(b1.real()>b2.real())swap(lb1,lb2);\n      P res;\n      if(la1.real()>lb1.real())res=la1;\n      else res=lb1;\n      return res;\n    }\n    // ????????£???????????´??????...?\n    else{\n      // ??????????±?????????????????????§?????????\n      // ????????¢??°?????????????????????????????????????????¨????????????\n      return P(-1,-1);\n    }\n  }\n  else{\n    P b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n  }\n}\n\n// ??§?¨?????????¢(??§?¨?p???????????????,???????¨??????????a(????????¢???)?????¢)\nP roundPoint(const P &p,double a){\n  return P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n\nbool used[1010];\ntypedef tuple<int,int,int> tpl;\n\nint N,W,D;\nint XS[1001];\nint YS[1001];\nchar AS[1001];\nint main(){\n\n  cin>>N>>W>>D;\n  for(int i=0;i<N;i++)cin>>XS[i]>>YS[i]>>AS[i];\n  vector<pii> poses;\n  // ???????£????????????????, ??§?¨????????????????????????????\n  for(int i=0;i<N;i++){\n    P ang_v;\n    // ????????§????????????????¨????????????????\n    if(AS[i]=='W')ang_v = P(-1, 0);\n    else if(AS[i]=='E')ang_v = P(1, 0);\n    else if(AS[i]=='N')ang_v = P(0, 1);\n    else if(AS[i]=='S')ang_v = P(0, -1);\n    ang_v *= 10000000;\n\n    // 2?????????????????????????¨????????????????\n    P ps[2] = {roundPoint(ang_v, PI/4) + P(XS[i], YS[i]), roundPoint(ang_v, -PI/4) + P(XS[i], YS[i])};\n    // ??????????????¶??????????????????????????????\n    const P corner[4] = {P(0,0), P(0,D), P(W,D), P(W,0)};\n    int ds[2];\n    for(int k=0;k<2;k++){\n        int sum_dist = 0;\n        int dist = -1;\n        for(int j = 0; j < 4; j++){\n            const P &p1 = corner[j];\n            const P &p2 = corner[(j+1)%4];\n            // p1-p2???????????¨ps[j]?????????????????????????????????\n            // cross????????????, ????????§?¨?????±???????\n            if(is_intersected_ls(p1, p2, ps[k], P(XS[i], YS[i]))){\n                // ??§?¨???¨,corner[j]??¨????????¢????¨??????????\n                P c = intersection_ls(p1, p2, ps[k], P(XS[i], YS[i]));\n                dist = sum_dist + abs(c-corner[j]) + 0.1;\n                break;\n            }\n            else{\n              sum_dist += (abs(p2-p1) + 0.1);\n              continue;\n            }\n        }\n        // dist???2(D+W)?????£??????, 0????£???£????????????\n        if((2*(D+W) == dist)){\n            dist = 0;\n        }\n        ds[k] = dist;\n    }\n    \n    if(ds[0] > ds[1])\n        ds[1] += 2*(W+D);\n\n    poses.push_back(make_pair(ds[0], ds[1]));\n  }\n\n  // vector???????????????2??????????????????\n  for(int i=0;i<N;i++){\n    // ??????????????????+2*(W+D)???????????????push_back\n    pii pd = poses[i];\n    pd.first += 2*(W+D);\n    pd.second += 2*(W+D);\n    poses.push_back(pd);\n  }\n  \n  int min_ans = 1<<29;\n  // ?????¨?????£??????, ??????????§???°???????±???????, ????????????n?????????????????°????¨??????????\n  for(int start = 0; start < N; start++){\n      memset(used,0,sizeof(used));\n      vector<tpl> vec;\n      for(int i=0;i<N;i++){\n        pii t = poses[start + i];\n        vec.push_back(make_tuple(t.first, 0, i));\n        vec.push_back(make_tuple(t.second, 1, i));\n      }\n      // start??????????????????end????????£????????????????´???????????????????\n      queue<int> q;\n      // ?????¢??§?????????\n      sort(vec.begin(), vec.end());\n      \n      int vec_idx = 0;\n      int ans = 0;\n      // ???????????¢?????¨??????????????????????????????\n      while((int)vec.size() != vec_idx){\n          // ???????????¢??§????´??????????????????????\n          int d = get<0>(vec[vec_idx]);\n          vector<int> vs[2];\n          while((int)vec.size()!=vec_idx && (get<0>(vec[vec_idx]) == d)){\n            vs[get<1>(vec[vec_idx])].push_back(get<2>(vec[vec_idx]));\n            vec_idx++;\n          }\n          \n          // start???????´???????????????????\n          // start???????´????, queue????????????\n          for(int i=0;i<(int)vs[0].size();i++){\n              int idx = vs[0][i];\n              q.push(idx);\n          }\n          \n          // end???????´????, ?????§???????????????????????°continue\n          for(int i=0;i<(int)vs[1].size();i++){\n              int idx = vs[1][i];\n              if(used[idx])continue;\n              else{\n                  // ?????????????????£????????????????????§start???????´?????§£???????????????\n                  // ????????????end????§£?????????????????§??????????????????\n                  ans++;\n                  while(q.size()){\n                      const int a = q.front(); q.pop();\n                      used[a] = true;\n                  }\n                  break;\n              }\n          }\n      }\n      min_ans = min(min_ans, ans);\n  }\n\n  cout<<min_ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef tuple<int,int,int> tpl;\n\nint N,W,D;\nint XS[1001];\nint YS[1001];\nchar AS[1001];\nbool used[1010];\nint main(){\n\n  cin>>N>>W>>D;\n  for(int i=0;i<N;i++)cin>>XS[i]>>YS[i]>>AS[i];\n  vector<pii> poses;\n  // ???????£????????????????, ??§?¨????????????????????????????\n  for(int i=0;i<N;i++){\n\n    // w,n,e,s?????????????????¶??????????£??????§????????¢\n    const int wall_dist[4] = {XS[i], D - YS[i], W - XS[i], YS[i]};\n\n    // nw,ne,se,sw?????????????????????????????????\n    const int dy[] = {1, 1, -1, -1};\n    const int dx[] = {-1, 1, 1, -1};\n    \n    // nw,ne,se,sw???????????§, ????????§?¨?????¨????????????????\n    int stripex[4],stripey[4];\n    for(int j = 0; j < 4; j++){\n      int d1 = wall_dist[j];\n      int d2 = wall_dist[(j+1)%4];\n      // ????????????????§????\n      int d = min(d1,d2);\n      const int y = YS[i] + dy[j] * d;\n      const int x = XS[i] + dx[j] * d;\n      stripex[j] = x;\n      stripey[j] = y;\n    }\n\n    // ?????¨???, ???????????????????????§?¨??????????????????§, ??????????????¨??????\n    int usex[2],usey[2];\n    \n    // ????????§????????????????¨????????????????\n    if(AS[i]=='W'){\n      usex[0] = stripex[3], usey[0] = stripey[3];\n      usex[1] = stripex[0], usey[1] = stripey[0];\n    }\n    else if(AS[i]=='E'){\n      usex[0] = stripex[1], usey[0] = stripey[1];\n      usex[1] = stripex[2], usey[1] = stripey[2];\n    }\n    else if(AS[i]=='N'){\n      usex[0] = stripex[0], usey[0] = stripey[0];\n      usex[1] = stripex[1], usey[1] = stripey[1];\n    }\n    else if(AS[i]=='S'){\n      usex[0] = stripex[2], usey[0] = stripey[2];\n      usex[1] = stripex[3], usey[1] = stripey[3];\n    }\n\n    // ??§?¨?????????¢???????????????\n    int dists[2];\n    for(int j = 0; j < 2; j++){\n      int x = usex[j];\n      int y = usey[j];\n      if(x == 0)dists[j] = y;\n      else if(y == D)dists[j] = x + D;\n      else if(x == W)dists[j] = W + D + (D - y);\n      else dists[j] = W + D + D + (W - x);\n      if(dists[j] == 2*(W+D)){\n        dists[j] = 0;\n      }\n    }\n    if(dists[0] > dists[1]){\n      dists[1] += 2*(W + D);\n    }\n    // ?????¢????????\\\n    poses.push_back(make_pair(dists[0], dists[1]));\n  }\n\n  // vector???????????????2??????????????????\n  for(int i=0;i<N;i++){\n    // ??????????????????+2*(W+D)???????????????push_back\n    pii pd = poses[i];\n    pd.first += 2*(W+D);\n    pd.second += 2*(W+D);\n    poses.push_back(pd);\n  }\n  \n  int min_ans = 1<<29;\n  // ?????¨?????£??????, ??????????§???°???????±???????, ????????????n?????????????????°????¨??????????\n  for(int start = 0; start < N; start++){\n      memset(used,0,sizeof(used));\n      vector<tpl> vec;\n      for(int i=0;i<N;i++){\n        pii t = poses[start + i];\n        vec.push_back(make_tuple(t.first, 0, i));\n        vec.push_back(make_tuple(t.second, 1, i));\n      }\n      // start??????????????????end????????£????????????????´???????????????????\n      queue<int> q;\n      // ?????¢??§?????????\n      sort(vec.begin(), vec.end());\n      \n      int vec_idx = 0;\n      int ans = 0;\n      // ???????????¢?????¨??????????????????????????????\n      while((int)vec.size() != vec_idx){\n          // ???????????¢??§????´??????????????????????\n          int d = get<0>(vec[vec_idx]);\n          vector<int> vs[2];\n          while((int)vec.size()!=vec_idx && (get<0>(vec[vec_idx]) == d)){\n            vs[get<1>(vec[vec_idx])].push_back(get<2>(vec[vec_idx]));\n            vec_idx++;\n          }\n          \n          // start???????´???????????????????\n          // start???????´????, queue????????????\n          for(int i=0;i<(int)vs[0].size();i++){\n              int idx = vs[0][i];\n              q.push(idx);\n          }\n          \n          // end???????´????, ?????§???????????????????????°continue\n          for(int i=0;i<(int)vs[1].size();i++){\n              int idx = vs[1][i];\n              if(used[idx])continue;\n              else{\n                  // ?????????????????£????????????????????§start???????´?????§£???????????????\n                  // ????????????end????§£?????????????????§??????????????????\n                  ans++;\n                  while(q.size()){\n                      const int a = q.front(); q.pop();\n                      used[a] = true;\n                  }\n                  break;\n              }\n          }\n      }\n      min_ans = min(min_ans, ans);\n  }\n\n  cout<<min_ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\n#define EPS (1e-8)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\nconst double PI=4*atan(1.0);\n\ntypedef complex<double> P;\n\n// ??????\ndouble dot(const P &a, const P &b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// ??????\ndouble cross(const P &a, const P &b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distance_ls_p(const P &a, const P &b, const P &c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nint is_intersected_ls(const P &a1, const P &a2, const P &b1, const P &b2) {\n  // ????????????????????´???\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    // ????????¨???????????¢???0??????????????£????????????\n    if(EQ(distance_ls_p(a1,a2,b1),0)||EQ(distance_ls_p(a1,a2,b2),0))\n      return 1;\n    return 0;\n  }\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n    ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nP intersection_ls(const P &a1, const P &a2, const P &b1, const P &b2) {\n  // ????????????????????´????????????????????£???????????????????????£???????????¨????????????\n  // ?????£??¨???x??§?¨?????°??????????????????????\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    // ????????¨???????????¢???0??????????????£????????????\n    if(EQ(distance_ls_p(a1,a2,b1),0)||EQ(distance_ls_p(a1,a2,b2),0)){\n      // x??§?¨????a1<a2,b1<b2??¨????????????????????????\n      P la1=a1,la2=a2;\n      P lb1=b1,lb2=b2;\n      if(a1.real()>a2.real())swap(la1,la2);\n      if(b1.real()>b2.real())swap(lb1,lb2);\n      P res;\n      if(la1.real()>lb1.real())res=la1;\n      else res=lb1;\n      return res;\n    }\n    // ????????£???????????´??????...?\n    else{\n      // ??????????±?????????????????????§?????????\n      // ????????¢??°?????????????????????????????????????????¨????????????\n      return P(-1,-1);\n    }\n  }\n  else{\n    P b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n  }\n}\n\n// ??§?¨?????????¢(??§?¨?p???????????????,???????¨??????????a(????????¢???)?????¢)\nP roundPoint(const P &p,double a){\n  return P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n\nbool used[1010];\ntypedef tuple<double,int,int> tpl;\ntypedef pair<double,double> pdd;\n\nint N,W,D;\nint XS[1001];\nint YS[1001];\nchar AS[1001];\nint main(){\n\n  cin>>N>>W>>D;\n  for(int i=0;i<N;i++)cin>>XS[i]>>YS[i]>>AS[i];\n  vector<pdd> poses;\n  // ???????£????????????????, ??§?¨????????????????????????????\n  for(int i=0;i<N;i++){\n    P ang_v;\n    // ????????§????????????????¨????????????????\n    if(AS[i]=='W')ang_v = P(-1, 0);\n    else if(AS[i]=='E')ang_v = P(1, 0);\n    else if(AS[i]=='N')ang_v = P(0, 1);\n    else if(AS[i]=='S')ang_v = P(0, -1);\n    ang_v *= 10000000;\n\n    // 2?????????????????????????¨????????????????\n    P ps[2] = {roundPoint(ang_v, PI/4) + P(XS[i], YS[i]), roundPoint(ang_v, -PI/4) + P(XS[i], YS[i])};\n    // ??????????????¶??????????????????????????????\n    const P corner[4] = {P(0,0), P(0,D), P(W,D), P(W,0)};\n    double ds[2];\n    for(int k=0;k<2;k++){\n        double sum_dist = 0;\n        double dist = 0;\n        for(int j = 0; j < 4; j++){\n            const P &p1 = corner[j];\n            const P &p2 = corner[(j+1)%4];\n            // p1-p2???????????¨ps[j]?????????????????????????????????\n            // cross????????????, ????????§?¨?????±???????\n            if(is_intersected_ls(p1, p2, ps[k], P(XS[i], YS[i]))){\n                // ??§?¨???¨,corner[j]??¨????????¢????¨??????????\n                P c = intersection_ls(p1, p2, ps[k], P(XS[i], YS[i]));\n                dist = sum_dist + abs(c-corner[j]);\n                break;\n            }\n            else{\n                sum_dist += abs(p2-p1);\n                continue;\n            }\n        }\n        // dist???2(D+W)?????£??????, 0????£???£????????????\n        if(EQ(2*(D+W), dist)){\n            dist = 0;\n        }\n        ds[k] = dist;\n    }\n    \n    if(ds[0] > ds[1])\n        ds[1] += 2*(W+D);\n\n    poses.push_back(make_pair(ds[0], ds[1]));\n  }\n\n  // vector???????????????2??????????????????\n  for(int i=0;i<N;i++){\n      // ??????????????????+2*(W+D)???????????????push_back\n      pdd pd = poses[i];\n      pd.first += 2*(W+D);\n      pd.second += 2*(W+D);\n      poses.push_back(pd);\n  }\n  \n  int min_ans = 1<<29;\n  // ?????¨?????£??????, ??????????§???°???????±???????, ????????????n?????????????????°????¨??????????\n  for(int start = 0; start < N; start++){\n      memset(used,0,sizeof(used));\n      vector<tpl> vec;\n      for(int i=0;i<N;i++){\n          pdd t = poses[start + i];\n          vec.push_back(make_tuple(t.first, 0, i));\n          vec.push_back(make_tuple(t.second, 1, i));\n      }\n      // start??????????????????end????????£????????????????´???????????????????\n      queue<int> q;\n      // ?????¢??§?????????\n      sort(vec.begin(), vec.end());\n      \n      int vec_idx = 0;\n      int ans = 0;\n      // ???????????¢?????¨??????????????????????????????\n      while((int)vec.size() != vec_idx){\n          // ???????????¢??§????´??????????????????????\n          double d = get<0>(vec[vec_idx]);\n          vector<int> vs[2];\n          while((int)vec.size()!=vec_idx && EQ(get<0>(vec[vec_idx]), d)){\n              vs[get<1>(vec[vec_idx])].push_back(get<2>(vec[vec_idx]));\n              vec_idx++;\n          }\n          \n          // start???????´???????????????????\n          // start???????´????, queue????????????\n          for(int i=0;i<(int)vs[0].size();i++){\n              int idx = vs[0][i];\n              q.push(idx);\n          }\n          \n          // end???????´????, ?????§???????????????????????°continue\n          for(int i=0;i<(int)vs[1].size();i++){\n              int idx = vs[1][i];\n              if(used[idx])continue;\n              else{\n                  // ?????????????????£????????????????????§start???????´?????§£???????????????\n                  // ????????????end????§£?????????????????§??????????????????\n                  ans++;\n                  while(q.size()){\n                      const int a = q.front(); q.pop();\n                      used[a] = true;\n                  }\n                  break;\n              }\n          }\n      }\n      int cnt = 0;\n      for(int i=0;i<N;i++)cnt+=used[i];\n      assert(cnt == N);\n      min_ans = min(min_ans, ans);\n  }\n\n  cout<<min_ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> Pi;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) (int)x.size()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\n\nint n, w, d;\nPi p[1010], q[1010], D[1010];\n\nint get(int x,int y,int dir){\n\t// 3 0\n\t// 2 1\n\tif(dir == 0){\n\t\tif(w - x > d - y)return x + (d - y);\n\t\telse return w + d - (y + (w - x));\n\t}\n\telse if(dir == 1){\n\t\tif(w - x > y)return w + d + w - (x + y);\n\t\telse return w + d - (y - (w - x));\n\t}\n\telse if(dir == 2){\n\t\tif(x > y)return w + d + w - (x - y);\n\t\telse return w + d + w + (y - x);\n\t}\n\telse{\n\t\tif(x >= d - y)return x - (d - y);\n\t\telse return w + d + w + (x + y);\n\t}\n\t// [0, 2*(w+d)-1]\n}\n\nbool comp(const Pi &a, const Pi &b){\n\treturn a.Se != b.Se ? a.Se < b.Se : a.Fi < b.Fi;\n}\n\nvoid solve(int tc){\n\tscanf(\"%d%d%d\", &n, &w, &d);\n\tfor(int i=0;i<n;i++){\n\t\tint x, y;\n\t\tchar ch[2];\n\t\tscanf(\"%d%d%s\", &x, &y, ch);\n\t\tif(ch[0] == 'E'){\n\t\t\tp[i].Fi = get(x, y, 0);\n\t\t\tp[i].Se = get(x, y, 1);\n\t\t}\n\t\telse if(ch[0] == 'S'){\n\t\t\tp[i].Fi = get(x, y, 1);\n\t\t\tp[i].Se = get(x, y, 2);\n\t\t}\n\t\telse if(ch[0] == 'W'){\n\t\t\tp[i].Fi = get(x, y, 2);\n\t\t\tp[i].Se = get(x, y, 3);\n\t\t}\n\t\telse{\n\t\t\tp[i].Fi = get(x, y, 3);\n\t\t\tp[i].Se = get(x, y, 0);\n\t\t}\n\t}\n\t\n\tsort(p, p+n, comp);\n\t//for(int i=0;i<n;i++)printf(\"%d %d\\n\", p[i].Fi, p[i].Se);puts(\"\");puts(\"\");\n\t\n\t\n\tint ans = ~0u>>1;\n\tint SZ = 2 * (d + w);\n\tfor(int i=0;i<n;i++){\n\t\t//put at p[i].Se;\n\t\tint top = 0;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(p[j].Se != p[i].Se && p[j].Fi > p[i].Se && p[j].Fi < p[j].Se)q[top++] = Pi(p[j].Fi - p[i].Se, p[j].Se - p[i].Se);\n\t\t}\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(p[j].Se != p[i].Se && (p[j].Fi > p[i].Se || p[j].Fi < p[j].Se))q[top++] = Pi((p[j].Fi - p[i].Se + SZ) % SZ, p[j].Se - p[i].Se + SZ);\n\t\t}\n\t\t\n\t\t\n\t\t//for(int i=0;i<top;i++)printf(\"%d %d\\n\", q[i].Fi, q[i].Se);puts(\"\");\n\t\t\n\t\tint z = 0, mx = 0;\n\t\tD[z++] = Pi(0, 0);\n\t\tfor(int j=0;j<top;j++){\n\t\t\tint v = (lower_bound(D, D+z, Pi(q[j].Fi-1, 100001)) - 1)->Se;\n\t\t\tD[z++] = Pi(q[j].Se, mx = max(mx, v + 1));\n\t\t}\n\t\tans = min(ans, mx + 1);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main(){\n\tint Tc = 1;// scanf(\"%d\",&Tc);\n\tfor(int i=1;i<=Tc;i++){\n\t\tsolve(i);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint n,h,w;\n\nbool valid(P p){\n  return p.fi>=0&&p.fi<=w&&p.se>=0&&p.se<=h;\n}\n\nP ur(int x,int y){\n  int d=y-x;\n  P p1=P(w,w+d),p2=P(h-d,h);\n  if(valid(p1))return p1;\n  else return p2;\n}\n\nP ll(int x,int y){\n  int d=y-x;\n  P p1=P(0,0+d),p2=P(0-d,0);\n  if(valid(p1))return p1;\n  else return p2;\n}\n\nP ul(int x,int y){\n  int d=y+x;\n  P p1=P(0,d-0),p2=P(d-h,h);\n  if(valid(p1))return p1;\n  else return p2;\n}\n\nP lr(int x,int y){\n  int d=y+x;\n  P p1=P(w,d-w),p2=P(d-0,0);\n  if(valid(p1))return p1;\n  else return p2;\n}\n\nint calc(P p){\n  assert(p.fi==0||p.fi==w||p.se==0||p.se==h);\n  if(p.se==0){\n    return p.fi;\n  }else if(p.fi==w){\n    return w+p.se;\n  }else if(p.se==h){\n    return w+h+(w-p.fi);\n  }else if(p.fi==0){\n    return w+h+w+(h-p.se);\n  }\n  return -1;\n}\n\nint main(){\n  cin>>n>>w>>h;\n  int M=w*2+h*2;\n  vector<P> rs;\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    char c;\n    cin>>c;\n    if(c=='E'){\n      P p1=lr(x,y); P p2=ur(x,y);\n      rs.push_back(P(calc(p1),calc(p2)));\n    }else if(c=='N'){\n      P p1=ur(x,y); P p2=ul(x,y);\n      rs.push_back(P(calc(p1),calc(p2)));\n    }else if(c=='W'){\n      P p1=ul(x,y); P p2=ll(x,y);\n      rs.push_back(P(calc(p1),calc(p2)));\n    }else{\n      P p1=ll(x,y); P p2=lr(x,y);\n      rs.push_back(P(calc(p1),calc(p2)));\n    }\n  }\n\n  vector<P> ps;\n  rep(i,rs.size()){\n    if(rs[i].fi>rs[i].se)rs[i].se+=M;\n    ps.push_back(P(rs[i].se,rs[i].fi));\n    ps.push_back(P(rs[i].se+M,rs[i].fi+M));\n  }\n  sort(all(ps));\n\n  int res=0;\n  rep(i,n){\n    int tmp=0,last=0;\n    for(int j=i;ps[j].fi<ps[i].se+M;j++){\n      if(last<ps[j].se){\n        tmp++;\n        last=ps[j].fi;\n      }\n    }\n    maxch(res,tmp);\n  }\n\n  cout<<res<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h;\n \nint calc(int x,int y){\n  if(x==0) return y;\n  if(y==h) return h+x;\n  if(x==w) return h+w+h-y;\n  return h+w+h+w-x;\n}\n \nint LU(int x,int y){\n  int d=min(x,h-y);\n  return calc(x-d,y+d);\n}\n \nint RU(int x,int y){\n  int d=min(w-x,h-y);\n  return calc(x+d,y+d);\n}\n \nint RD(int x,int y){\n  int d=min(w-x,y);\n  return calc(x+d,y-d);\n}\n \nint LD(int x,int y){\n  int d=min(x,y);\n  return calc(x-d,y-d);\n}\n \nbool check(P a,int b){\n  if(a.f<a.s&&(a.f<=b&&b<=a.s))return 1;\n  if(a.f>a.s&&!(a.s<b&&b<a.f)) return 1;\n  return 0;\n}\n \nint main(){\n  int n;\n  cin>>n>>w>>h;\n   \n  vector <P> lr;\n  for(int i=0;i<n;i++){\n    int x,y;\n    char ch;\n    cin>>x>>y>>ch;\n    if(ch=='N')lr.push_back(P(LU(x,y),RU(x,y)));\n    if(ch=='E')lr.push_back(P(RU(x,y),RD(x,y)));\n    if(ch=='S')lr.push_back(P(RD(x,y),LD(x,y)));\n    if(ch=='W')lr.push_back(P(LD(x,y),LU(x,y)));\n  }\n \n  for(int i=0;i<n;i++)swap(lr[i].f,lr[i].s);\n  sort(lr.begin(),lr.end());\n  for(int i=0;i<n;i++)swap(lr[i].f,lr[i].s);\n   \n   \n  int ans=n;\n  for(int i=0;i<n;i++){\n    int cnt=1,pos=lr[i].s;\n    for(int j=0;j<n;j++){\n      int idx=(i+j)%n;\n      if(check(lr[idx],pos))continue;\n      cnt++;\n      pos=lr[idx].s;\n    }\n    ans=min(ans,cnt);\n  }\n  cout <<ans<<endl;  \n   \n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nbool eq(const ld a, const ld b) {\n  return (abs(a - b) < eps);\n}\n\nld dot(const Point& a, const Point& b) {\n  return real(conj(a) * b);\n}\n\nld cross(const Point& a, const Point& b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line(Point a, Point b) : a(a), b(b) {}\n  Point operator[](const int _num)const {\n    if (_num == 0)return a;\n    else if (_num == 1)return b;\n    else {\n      assert(false);\n      return Point();\n    }\n  }\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle() : p(Point(0, 0)), r(0) {}\n  Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n  const Point nb(b - a);\n  const Point nc(c - a);\n  if (cross(nb, nc) > eps) return 1;   // a,b,c\n  if (cross(nb, nc) < -eps) return -1; // a,\n  if (dot(nb, nc) < 0) return 2;       //\n  if (norm(nb) < norm(nc)) return -2;  // \n  return 0;                          \n}\n\n\nbool isis_ll(const Line& l, const Line& m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(const Line& l, const Line& s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\nbool isis_ss(const Line& s, const Line& t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(const Line& l, const Point& p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(const Line& s, const Point& p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(const Line &l, const Point& p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(const Line &s, const Line& t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\nvector<Point> is_ll2(const Line &s, const Line& t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  if (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n  else {\n    vector<Point>ans;\n    for (int k = 0; k < 2; ++k) {\n      if (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n      if (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n    }\n    return ans;\n  }\n}\nPoint is_ss(const Line &s, const Line& t) {\n  if (isis_ss(s, t)) {\n    for (int k = 0; k < 2; ++k) {\n      for (int l = 0; l < 2; ++l) {\n        if (s[k] == t[l])return s[k];\n      }\n    }\n    return is_ll(s, t);\n  }\n  else {\n    assert(false);\n    return Point(0, 0);\n  }\n}\nld dist_lp(const Line& l, const Point& p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll(const Line& l, const Line& m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(const Line& l, const Line& s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(const Line& s, const Point& p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(const Line& s, const Line& t) {\n  if (isis_ss(s, t)) return 0;\n  return min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nLine bisection(const Line &s, const Line &t) {\n  const Point laglanju(is_ll(s, t));\n  const Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n  const Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n  return Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\nPoint  inner_center(const vector<Line>&ls) {\n  vector<Point>vertics;\n  for (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n    vertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n  }\n  if (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n  Line bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n  Line bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n  if (bi1[0] == bi2[0])return bi1[0];\n  else {\n    return is_ll(bi1, bi2);\n  }\n}\n\nvector<Point>  ex_center(const vector<Line>&ls) {\n  vector<Point>vertics;\n  for (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n    vertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n  }\n  if (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n  vector<Point>ecs;\n  for (int i = 0; i < 3; ++i) {\n    Line bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n    Line bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n    ecs.push_back(is_ll(bi1, bi2));\n  }\n  return ecs;\n}\n\n\nvector<Point>  same_dis(const vector<Line>&ls) {\n  vector<Point>vertics;\n  vertics.push_back(is_ll(ls[0], ls[2]));\n  vertics.push_back(is_ll(ls[1], ls[2]));\n\n  if (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n  Line bis(bisection(ls[0], ls[1]));\n  vector<Point>ecs;\n\n  Line abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n  ecs.push_back(is_ll(bis, abi));\n\n\n  Line bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n  ecs.push_back(is_ll(bis, bbi));\n\n  return ecs;\n}\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res; // no intersection\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nint is_in_circle(const Circle &cir, const  Point& p) {\n  ld dis = abs(cir.p - p);\n  if (dis > cir.r + eps)return 0;\n  else if (dis < cir.r - eps)return 2;\n  else return 1;\n}\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n  ld dis = abs(lc.p - rc.p);\n  if (dis < rc.r - lc.r - eps)return 2;\n  else if (dis>rc.r - lc.r + eps)return 0;\n  else return 1;\n}\n\nvector<Point> is_lc(const Circle& c, const Line& l) {\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps) {\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\nvector<Point> is_sc(const Circle& c, const Line& l) {\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d, c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0, 1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\nld two_circle_area(const Circle&l, const Circle&r) {\n  ld dis = abs(l.p - r.p);\n  if (dis > l.r + r.r)return 0;\n  else if (dis + r.r < l.r) {\n    return r.r*r.r*pi;\n  }\n  else if (dis + l.r < r.r) {\n    return l.r*l.r*pi;\n  }\n  else {\n    ld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n      (r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n      sqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n    return ans;\n  }\n\n}\n\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j, n) res += cross(p[j], p[(j + 1) % n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise(const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i, n) {\n    Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i, n) {\n    Point a = poly[i], b = poly[(i + 1) % n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n  const int n = P.size();\n  Point g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n  int a = 0, b = n;\n  while (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n    int c = (a + b) / 2;\n    if (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n      if (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n      else                                                  a = c;\n    }\n    else {\n      if (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n      else                                                  b = c;\n    }\n  }\n  b %= n;\n  if (cross(P[a] - p, P[b] - p) < 0) return 0;\n  if (cross(P[a] - p, P[b] - p) > 0) return 2;\n  return 1;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\n\n\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n  int n = ps.size();\n  Polygon Q;\n  Polygon R;\n  REP(i, n) {\n    Point A = ps[i], B = ps[(i + 1) % n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) != 1) R.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n      Q.push_back(is_ll(l, m));\n      R.push_back(is_ll(l, m));\n    }\n  }\n  const vector<Polygon>polys{ Q,R };\n  return polys;\n}\n\n\nvoid add_point(vector<Point> &ps, const Point p) {\n  for (Point q : ps) if (abs(q - p) < eps) return;\n  ps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n  g[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n  int n = p.size(), m = s.size();\n  Graph g(n);\n  REP(i, m) {\n    vector<pair<ld, int>> vec;\n    REP(j, n) if (isis_sp(s[i], p[j]))\n      vec.emplace_back(abs(s[i].a - p[j]), j);\n    sort(ALL(vec));\n    REP(j, vec.size() - 1) {\n      int from = vec[j].second, to = vec[j + 1].second;\n      add_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n    }\n  }\n  return g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n  vector<Point>crss;\n  for (int i = 0; i < static_cast<int>(s.size()); ++i) {\n    for (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n      if (isis_ss(s[i], s[j])) {\n        crss.push_back(is_ll(s[i], s[j]));\n      }\n    }\n  }\n  for (int i = 0; i <static_cast<int>(s.size()); ++i) {\n    crss.push_back(s[i][0]);\n    crss.push_back(s[i][1]);\n  }\n  return segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\nconst int dx0[4] = { -1,0,1,0 };\nconst int dy0[4] = { 0,1,0,-1 };\n\nconst int dx[4] = { -1,-1,1,1 };\nconst int dy[4] = { -1,1,1,-1 };\n\nint N, W, D;\n\nint getnum(int x, int y) {\n  if (x == 0) {\n    return y;\n  }\n  else if (y == D) {\n    return D + x;\n  }\n  else if (x == W) {\n    return 2 * D + W - y;\n  }\n  else {\n    assert(!y);\n    return 2 * D + 2 * W - x;\n  }\n}\nbool isorder(const int a, const int b, const int c) {\n  if (a < c) {\n    return a <= b&&b <= c;\n  }\n  else if (a>c) {\n    return a <= b || b <= c;\n  }\n  else\n  {\n    return true;\n  }\n}\nstruct Compress {\n  map<int, int>mp;\n  map<int, int>revmp;\n\n  Compress(vector<int>vs) {\n    sort(vs.begin(), vs.end());\n    vs.erase(unique(vs.begin(), vs.end()),vs.end());\n    for (int i = 0; i < vs.size(); ++i) {\n      mp[vs[i]] = i;\n      revmp[i] = vs[i];\n    }\n  }\n};\nmap<char, int>mp;\nint main() {\n  mp['W'] = 0;\n  mp['S'] = 1;\n  mp['E'] = 2;\n  mp['N'] = 3;\n  cin >> N >> W >> D;\n  \n  vector<Line> ls;\n  ls.push_back(Line(Point(0, 0), Point(0, D)));\n  ls.push_back(Line(Point(0, D), Point(W, D)));\n  ls.push_back(Line(Point(W, D), Point(W, 0)));\n  ls.push_back(Line(Point(W, 0), Point(0, 0)));\n  vector<pair<int, int>>ps;\n  for (int i = 0; i < N; ++i) {\n    int x, y; char f; cin >> x >> y >> f;\n    y = D - y;\n    Point p(x, y);\n    int num1, num2;\n    int betnum;\n    {\n      const int way = mp[f];\n      Line l(p, p + 1000000.l * Point(dx[way], dy[way]));\n      for (int i = 0; i < 4; ++i) {\n        if (isis_ss(l, ls[i])) {\n          Point sect(is_ll(l, ls[i]));\n          num1 = getnum(round(sect.real()), round(sect.imag()));\n          break;\n        }\n      }\n    }\n    {\n      const int way = (mp[f]+1)%4;\n      Line l(p, p + 1000000.l * Point(dx[way], dy[way]));\n      for (int i = 0; i < 4; ++i) {\n        if (isis_ss(l, ls[i])) {\n          Point sect(is_ll(l, ls[i]));\n          num2 = getnum(round(sect.real()), round(sect.imag()));\n          break;\n        }\n      }\n    }\n    {\n      const int way = mp[f];\n      Line l(p, p + 1000000.l * Point(dx0[way], dy0[way]));\n      for (int i = 0; i < 4; ++i) {\n        if (isis_ss(l, ls[i])) {\n          Point sect(is_ll(l, ls[i]));\n          betnum = getnum(round(sect.real()), round(sect.imag()));\n          break;\n        }\n      }\n    }\n    if (num1 < num2) {\n      if (num1 < betnum&&betnum < num2) {\n\n      }\n      else {\n        swap(num1, num2);\n      }\n    }\n    else {\n      if (num2 < betnum&&betnum < num1) {\n        swap(num1, num2);\n      }\n      else {\n      }\n    }\n    ps.emplace_back(num1, num2);\n  }\n  sort(ps.begin(), ps.end());\n  vector<int>v;\n  for (auto p : ps) {\n    v.emplace_back(p.first);\n    v.emplace_back(p.second);\n  }\n  Compress comp(v);\n  \n  for (auto&p : ps) {\n    p.first = comp.mp[p.first];\n    p.second = comp.mp[p.second];\n  }\n  {\n    bool a = is_sorted(ps.begin(), ps.end());\n    assert(a);\n  }\n  int _size = comp.mp.size();\n  int ans = 1e8;\n  for (int start = 0; start < ps.size(); ++start) {\n    int num = 1;\n    const int anum = ps[start].first;\n    queue<int>que;\n    int amin = 1e8;\n    for (int p = start; p < start + ps.size();++p) {\n      const int from = ps[p%N].first;\n      const int to = ps[p%N].second;\n      if (isorder(from, anum, to))continue;\n      const int realfrom = from < anum ? from + _size : from;\n      const int realto = to < anum ? to + _size : to;\n      amin = min(amin, realto);\n      if (amin < realfrom) {\n        amin = realto;\n        num++;\n      }\n    }\n    if (amin != 1e8)num++;\n    ans = min(ans, num);\n\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n\nusing namespace std;\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) os << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n\ntemplate <typename T> void print(T a, int n, const string& split = \" \") { for (int i = 0; i < n; i++) { cout << a[i]; if (i + 1 != n) cout << split; } cout << endl; }\ntemplate <typename T> void print2d(T a, int w, int h, int width = -1, int br = 0) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) { if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\ntemplate <typename T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n#define dump(v) (cout << #v << \": \" << v << endl)\n\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define clr(a, x) memset(a, x, sizeof(a))\n#define sz(a) ((int)(a).size())\n#define mp(a, b) make_pair(a, b)\n#define ten(n) ((long long)(1e##n))\n\ntemplate <typename T, typename U> void upmin(T& a, const U& b) { a = min<T>(a, b); }\ntemplate <typename T, typename U> void upmax(T& a, const U& b) { a = max<T>(a, b); }\ntemplate <typename T> void uniq(T& a) { sort(a.begin(), a.end()); a.erase(unique(a.begin(), a.end()), a.end()); }\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nint main()\n{\n    int n, w, h;\n    cin >> n >> w >> h;\n    const int peri = 2 * (w + h);\n\n    auto index = [&](int x, int y, int dx, int dy)\n    {\n        if (dx < 0)\n        {\n            int ty = y + x * dy;\n            if (0 <= ty && ty <= h)\n                return (w + h + w + (h - ty)) % peri;\n        }\n        else\n        {\n            int ty = y + (w - x) * dy;\n            if (0 <= ty && ty <= h)\n                return (w + ty) % peri;\n        }\n\n        if (dy < 0)\n        {\n            int tx = x + y * dx;\n            if (0 <= tx && tx <= w)\n                return tx % peri;\n        }\n        else\n        {\n            int tx = x + (h - y) * dx;\n            if (0 <= tx && tx <= w)\n                return (w + h + (w - tx)) % peri;\n        }\n        assert(false);\n    };\n\n    vector<pint> seg;\n    rep(i, n)\n    {\n        int x, y;\n        char d;\n        cin >> x >> y >> d;\n\n        switch (d)\n        {\n            case 'E':\n                seg.push_back(pint(index(x, y, +1, -1), index(x, y, +1, +1)));\n                break;\n            case 'N':\n                seg.push_back(pint(index(x, y, +1, +1), index(x, y, -1, +1)));\n                break;\n            case 'W':\n                seg.push_back(pint(index(x, y, -1, +1), index(x, y, -1, -1)));\n                break;\n            case 'S':\n                seg.push_back(pint(index(x, y, -1, -1), index(x, y, +1, -1)));\n                break;\n            default:\n                assert(false);\n        }\n    }\n\n    vector<int> split;\n    for (auto& it : seg)\n    {\n        split.push_back(it.first % peri);\n        split.push_back(it.second % peri);\n    }\n    uniq(split);\n\n//     dump(peri);\n//     dump(seg);\n\n    int res = 1919810;\n    for (int x : split)\n    {\n//         dump(x);\n        vector<pint> nseg;\n        for (auto& it : seg)\n        {\n            auto s = it;\n\n            if (s.first > s.second)\n                s.second += peri;\n\n            if (s.second < x)\n            {\n                s.first += peri;\n                s.second += peri;\n            }\n\n            if (s.first <= x && x <= s.second || s.first <= x + peri && x + peri <= s.second)\n                continue;\n\n            assert(s.first <= s.second);\n//             printf(\"(%3d, %3d) -> (%3d, %3d)\\n\", it.first, it.second, s.first, s.second);\n            nseg.push_back(s);\n        }\n        sort(all(nseg), [](const pint& a, const pint& b){ return a.second < b.second; });\n\n//         if (x == 22)\n//             dump(nseg);\n\n//         dump(x);\n//         dump(nseg);\n//         cout << endl;\n\n        int clocks = 1;\n        for (int i = 0; i < nseg.size(); )\n        {\n            ++clocks;\n\n            int r = nseg[i].second;\n            while (i < nseg.size() && nseg[i].first <= r)\n                ++i;\n        }\n        upmin(res, clocks);\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii=pair<int,int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define l first\n#define r second\n\nint main(){\n\tint n,w,h,p;\n\twhile(cin>>n>>w>>h){\n\t\tp=w*2+h*2;\n\t\tvector<pii> rng(n);\n\t\trep(i,n){\n\t\t\tint x,y,v; char c;\n\t\t\tcin>>x>>y>>c;\n\t\t\trng[i].l=[=]{return (int[]){x-h+y,x+h-y,w*2+h+y-x,w*2+h-y-x}[\"NEWS\"s.find(c)];}();\n\t\t\trng[i].r=[=]{return (int[]){x+h-y,w*2+h-y-x,w*2+h+y+x,w*2+h+y-x}[\"NEWS\"s.find(c)];}();\n\t\t}\n\t\tsort(all(rng),[](pii a,pii b){return a.r<b.r;});\n\t\t\n\t\tint ans=1e8;\n\t\trep(i,n) {\n\t\t\tsort(all(rng),[](pii a,pii b){return a.r<b.r;});\n\t\t\tint a=1,b=rng[0].r;\n\t\t\trange(j,1,n){\n\t\t\t\tif(rng[j].l>b){\n\t\t\t\t\ta++;\n\t\t\t\t\tb=rng[j].r;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans=min(ans,a);\n\t\t\trng[0].l+=p, rng[0].r+=p;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\n    int n, w, h; cin >> n >> w >> h;\n    vector<pair<int, int> > p;     //{r, l}\n    for(int i = 0; i < n; i++){\n        int x, y;\n        char c;\n        cin >> x >> y >> c;\n        if(c == 'W') {\n            p.push_back({x + y, -x + y});\n        } else if(c == 'N') {\n            p.push_back({2*h + x - y, x + y});\n        } else if(c == 'E') {\n            p.push_back({2*(h+w) - x - y, 2*h + x - y});\n        } else {\n            p.push_back({2*(h+w) - x + y ,2*(h+w) - x - y});\n        }\n\n        //if(p[i].first < 0) p[i].first += 2 * (h + w) - 1;\n        //if(p[i].second < 0) p[i].second += 2 * (h + w) - 1;\n        \n    }\n\n    \n    sort(p.begin(), p.end());\n\n    /*for(int i = 0; i < p.size(); i++){\n        cout << \"(\" << p[i].first << \", \" << p[i].second << \")\" << endl;\n    }*/\n\n    //スタート位置でループ\n    int ans = n;\n    int L = 2*(w + h);\n    for(int i=0; i<n; ++i) {\n        vector<pair<int, int> > tmp;\n        tmp = p;\n        for(int j=i-1; j>=0; --j) {\n            if(tmp[j].first < tmp[i].first) {\n                tmp[j].first += L;\n                tmp[j].second += L;\n            }\n        }\n        sort(tmp.begin(), tmp.end());\n        int cnt = 1;\n        int now = tmp[0].first;\n        for(int j=0; j<n; ++j) {\n            if(tmp[j].second > now) {\n                now = tmp[j].first;\n                cnt++;\n            }\n        }\n        ans = min(ans, cnt);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <tuple>\n\nusing namespace std;\ntypedef pair<int, int> pii;\nstatic const int INF = 1000000000;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tvector<pii> ranges;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x, y;\n\t\tstring f;\n\t\tcin >> x >> y >> f;\n\t\tconst int lu = y + x;\n\t\tconst int ru = h + x + (h - y);\n\t\tconst int rd = h + w + (h - y) + (w - x);\n\t\tconst int ld = h + w + h + (w - x) + y;\n\t\tint lo = 0, hi = 0;\n\t\tif(f[0] == 'N'){\n\t\t\tlo = lu; hi = ru;\n\t\t}else if(f[0] == 'E'){\n\t\t\tlo = ru; hi = rd;\n\t\t}else if(f[0] == 'S'){\n\t\t\tlo = rd; hi = ld;\n\t\t}else if(f[0] == 'W'){\n\t\t\tlo = ld; hi = lu + (h + w) * 2;\n\t\t}\n\t\tconst int hw2 = h + w + h + w;\n\t\tranges.emplace_back(lo, hi);\n\t\tranges.emplace_back(lo + hw2, hi + hw2);\n\t}\n\tsort(\n\t\tranges.begin(), ranges.end(),\n\t\t[](const pii &a, const pii &b){ return a.second < b.second; });\n\tint answer = INF;\n\tfor(int i = 0; i < n; ++i){\n\t\tvector<pii> r(ranges.begin() + i, ranges.begin() + i + n);\n\t\tconst int hw2 = (h + w) * 2;\n\t\tint count = 1, last = r[0].second;\n\t\tfor(int j = 0; j < n; ++j){\n\t\t\tif(r[j].first <= last){ continue; }\n\t\t\tif(r[j].second >= r[0].second + hw2){ continue; }\n\t\t\t++count;\n\t\t\tlast = r[j].second;\n\t\t}\n\t\tanswer = min(answer, count);\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\n#define fst first\n#define snd second\n \nint n, len; \n \nint solve(vector<pair<int, int>> & lr){\n    for(auto & e : lr) swap(e.fst, e.snd);\n    sort(begin(lr), end(lr));\n    for(auto & e : lr) swap(e.fst, e.snd);\n\n    int ret = n;\n    rep(i, n){\n        int cur = 1;\n        int rs = lr[i].snd, frs = rs;\n \n        range(_, 1, n){\n            int j = (j + _) % n;\n \n            int cl = lr[j].fst, cr = lr[j].snd;\n            if(cl >= cr){\n                if((cl - len <= rs and rs <= cr) or (cl <= rs and rs <= cr + len)){\n                    continue;\n                }\n            }\n            else {\n                if(cl <= rs and rs <= cr){\n                    continue;\n                }\n            }\n            if(cl >= cr){\n                if((cl - len <= frs and frs <= cr) or (cl <= frs and frs <= cr + len)){\n                    continue;\n                }\n            }\n            else {\n                if(cl <= frs and frs <= cr){\n                    continue;\n                }\n            }\n \n            cur++;\n            rs = cr;\n        }\n \n        ret = min(ret, cur);\n    }\n \n    return ret;\n}\n \nint main(void){\n    int w, h; cin >> n >> w >> h;\n \n    vector<pair<int, int>> lr(n);\n    len = 2 * w + 2 * h;\n    for(auto & e : lr){\n        int x, y; cin >> x >> y;\n        y = h - y;\n        char f; cin >> f;\n \n        int o, p;\n        switch(f){\n        case 'N': o = x;                 p = y;     break;\n        case 'E': o = w + y;             p = w - x; break;\n        case 'S': o = 2 * w + h - x;     p = h - y; break;\n        case 'W': o = 2 * w + 2 * h - y; p = x;     break;\n        }\n \n        e.fst = (o - p + len) % len;\n        e.snd = (o + p) % len;\n    }\n \n    sort(begin(lr), end(lr));\n    int res = solve(lr);\n \n    for(auto & e : lr){\n        swap(e.fst, e.snd);\n        e.fst = (len - 1) - e.fst;\n        e.snd = (len - 1) - e.snd;\n    }\n    sort(begin(lr), end(lr));\n    res = min(res, solve(lr));\n \n    cout << res << endl;\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Range{\n    int l,r;\n    bool contain(Range x){\n        if(l<=r) return x.l<=x.r && l<=x.l && x.r<=r;\n        else{\n            if(x.l<=x.r) return l<=x.l || x.r<=r;\n            else return l<=x.l && x.r<=r;\n        }\n    }\n};\n\nchar dc[]=\"NESW\";\nint dx[]={-1,1,1,-1};\nint dy[]={1,1,-1,-1};\nint main(){\n    int n,w,d;\n    cin>>n>>w>>d;\n    vector<int> x(n),y(n);\n    vector<int> df(n);\n    for(int i=0;i<n;i++){\n        char f;\n        cin>>x[i]>>y[i]>>f;\n        for(int j=0;j<4;j++) if(dc[j]==f) df[i]=j;\n        \n    }\n    auto crossPoint=[&](int px,int py,int dir){\n        int ub=1000000;\n        int lb=0;\n        while(ub-lb>1){\n            int mid=(ub+lb)/2;\n            int tx=px+dx[dir]*mid;\n            int ty=py+dy[dir]*mid;\n            if(0<=tx && tx<=w && 0<=ty && ty<=d) lb=mid;\n            else ub=mid;\n        }\n        return make_pair(px+dx[dir]*lb,py+dy[dir]*lb);\n    };\n    auto pos=[&](int x,int y){\n        int sum=0;\n        if(y==0) return x;\n        sum+=w;\n        if(x==w) return sum+y;\n        sum+=d;\n        if(y==d) return sum+w-x;\n        sum+=w;\n        return sum+d-y;\n    };\n    vector<Range> range(n);\n    for(int i=0;i<n;i++){\n        auto p=crossPoint(x[i],y[i],df[i]);\n        int l=pos(p.first,p.second);\n        p=crossPoint(x[i],y[i],(df[i]+1)%4);\n        int r=pos(p.first,p.second);\n        range[i]={r,l};\n    }\n    vector<int> reject(n,false);\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(i!=j && range[i].contain(range[j])){\n                reject[i]=true;\n            }\n        }\n    }\n\n    {\n        vector<Range> tmp;\n        for(int i=0;i<n;i++){\n            if(!reject[i]) tmp.push_back(range[i]);\n        }\n        range=tmp;\n        n=range.size();\n    }\n    sort(range.begin(),range.end(),[](Range lhs,Range rhs){return lhs.l<rhs.l;});\n    vector<int> kouho(n);\n    for(int i=0;i<n;i++) kouho[i]=range[i].r;\n    int res=n;\n    for(int i=0;i<n;i++){\n        Range p={kouho[i],kouho[i]};\n        queue<Range> que;\n        for(int j=0;j<n;j++){\n            if(range[j].contain(p)){\n                int prej=j;\n                while(j<n && range[j].contain(p)){\n                    j++;\n                }\n                for(int k=j;k<n;k++) que.push({range[k]});\n                for(int k=0;k<prej;k++) que.push({range[k]});\n                break;\n            }\n        }\n        int cnt=1;\n        while(!que.empty()){\n            auto t=que.front(); que.pop();\n            if(!t.contain(p)){\n                cnt++;\n                p={t.r,t.r};\n            }\n        }\n        res=min(res,cnt);\n    }\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\n#define EPS (1e-8)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\nconst double PI=4*atan(1.0);\n\ntypedef complex<double> P;\n\n// ??????\ndouble dot(const P &a, const P &b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// ??????\ndouble cross(const P &a, const P &b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distance_ls_p(const P &a, const P &b, const P &c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nint is_intersected_ls(const P &a1, const P &a2, const P &b1, const P &b2) {\n  // ????????????????????´???\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    // ????????¨???????????¢???0??????????????£????????????\n    if(EQ(distance_ls_p(a1,a2,b1),0)||EQ(distance_ls_p(a1,a2,b2),0))\n      return 1;\n    return 0;\n  }\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n    ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nP intersection_ls(const P &a1, const P &a2, const P &b1, const P &b2) {\n  // ????????????????????´????????????????????£???????????????????????£???????????¨????????????\n  // ?????£??¨???x??§?¨?????°??????????????????????\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    // ????????¨???????????¢???0??????????????£????????????\n    if(EQ(distance_ls_p(a1,a2,b1),0)||EQ(distance_ls_p(a1,a2,b2),0)){\n      // x??§?¨????a1<a2,b1<b2??¨????????????????????????\n      P la1=a1,la2=a2;\n      P lb1=b1,lb2=b2;\n      if(a1.real()>a2.real())swap(la1,la2);\n      if(b1.real()>b2.real())swap(lb1,lb2);\n      P res;\n      if(la1.real()>lb1.real())res=la1;\n      else res=lb1;\n      return res;\n    }\n    // ????????£???????????´??????...?\n    else{\n      // ??????????±?????????????????????§?????????\n      // ????????¢??°?????????????????????????????????????????¨????????????\n      return P(-1,-1);\n    }\n  }\n  else{\n    P b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n  }\n}\n\n// ??§?¨?????????¢(??§?¨?p???????????????,???????¨??????????a(????????¢???)?????¢)\nP roundPoint(const P &p,double a){\n  return P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n\nbool used[1010];\ntypedef tuple<double,int,int> tpl;\ntypedef pair<double,double> pdd;\n\nint N,W,D;\nint XS[1001];\nint YS[1001];\nchar AS[1001];\nint main(){\n\n  cin>>N>>W>>D;\n  for(int i=0;i<N;i++)cin>>XS[i]>>YS[i]>>AS[i];\n  vector<pdd> poses;\n  // ???????£????????????????, ??§?¨????????????????????????????\n  for(int i=0;i<N;i++){\n    P ang_v;\n    // ????????§????????????????¨????????????????\n    if(AS[i]=='W')ang_v = P(-1, 0);\n    else if(AS[i]=='E')ang_v = P(1, 0);\n    else if(AS[i]=='N')ang_v = P(0, 1);\n    else if(AS[i]=='S')ang_v = P(0, -1);\n    ang_v *= 10000000;\n\n    // 2?????????????????????????¨????????????????\n    P ps[2] = {roundPoint(ang_v, PI/4) + P(XS[i], YS[i]), roundPoint(ang_v, -PI/4) + P(XS[i], YS[i])};\n    // ??????????????¶??????????????????????????????\n    const P corner[4] = {P(0,0), P(0,D), P(W,D), P(W,0)};\n    double ds[2];\n    for(int k=0;k<2;k++){\n        double sum_dist = 0;\n        double dist = -1;\n        for(int j = 0; j < 4; j++){\n            const P &p1 = corner[j];\n            const P &p2 = corner[(j+1)%4];\n            // p1-p2???????????¨ps[j]?????????????????????????????????\n            // cross????????????, ????????§?¨?????±???????\n            if(is_intersected_ls(p1, p2, ps[k], P(XS[i], YS[i]))){\n                // ??§?¨???¨,corner[j]??¨????????¢????¨??????????\n                P c = intersection_ls(p1, p2, ps[k], P(XS[i], YS[i]));\n                dist = sum_dist + abs(c-corner[j]);\n                break;\n            }\n            else{\n                sum_dist += abs(p2-p1);\n                continue;\n            }\n        }\n        assert(!EQ(dist, -1));\n        // dist???2(D+W)?????£??????, 0????£???£????????????\n        if(EQ(2*(D+W), dist)){\n            dist = 0;\n        }\n        ds[k] = dist;\n    }\n    \n    if(ds[0] > ds[1])\n        ds[1] += 2*(W+D);\n\n    poses.push_back(make_pair(ds[0], ds[1]));\n  }\n\n  // vector???????????????2??????????????????\n  for(int i=0;i<N;i++){\n      // ??????????????????+2*(W+D)???????????????push_back\n      pdd pd = poses[i];\n      pd.first += 2*(W+D);\n      pd.second += 2*(W+D);\n      poses.push_back(pd);\n  }\n  \n  int min_ans = 1<<29;\n  // ?????¨?????£??????, ??????????§???°???????±???????, ????????????n?????????????????°????¨??????????\n  for(int start = 0; start < N; start++){\n      memset(used,0,sizeof(used));\n      vector<tpl> vec;\n      for(int i=0;i<N;i++){\n          pdd t = poses[start + i];\n          vec.push_back(make_tuple(t.first, 0, i));\n          vec.push_back(make_tuple(t.second, 1, i));\n      }\n      // start??????????????????end????????£????????????????´???????????????????\n      queue<int> q;\n      // ?????¢??§?????????\n      sort(vec.begin(), vec.end());\n      \n      int vec_idx = 0;\n      int ans = 0;\n      // ???????????¢?????¨??????????????????????????????\n      while((int)vec.size() != vec_idx){\n          // ???????????¢??§????´??????????????????????\n          double d = get<0>(vec[vec_idx]);\n          vector<int> vs[2];\n          while((int)vec.size()!=vec_idx && EQ(get<0>(vec[vec_idx]), d)){\n              vs[get<1>(vec[vec_idx])].push_back(get<2>(vec[vec_idx]));\n              vec_idx++;\n          }\n          \n          // start???????´???????????????????\n          // start???????´????, queue????????????\n          for(int i=0;i<(int)vs[0].size();i++){\n              int idx = vs[0][i];\n              q.push(idx);\n          }\n          \n          // end???????´????, ?????§???????????????????????°continue\n          for(int i=0;i<(int)vs[1].size();i++){\n              int idx = vs[1][i];\n              if(used[idx])continue;\n              else{\n                  // ?????????????????£????????????????????§start???????´?????§£???????????????\n                  // ????????????end????§£?????????????????§??????????????????\n                  ans++;\n                  while(q.size()){\n                      const int a = q.front(); q.pop();\n                      used[a] = true;\n                  }\n                  break;\n              }\n          }\n      }\n      min_ans = min(min_ans, ans);\n  }\n\n  cout<<min_ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nint n,w,d;\nint s[1010],g[1010];\n\ninline int convert(int x,int y){\n\tif(x==0) return y;\n\tif(y==d) return d+x;\n\tif(x==w) return d+w+(d-y);\n\tif(y==0) return d+w+d+(w-x);\n\treturn 0;\n}\n\nint main(void){\n\tcin >> n >> w >> d;\n\trep(i,n){\n\t\tint x,y;\n\t\tchar w;\n\t\tcin >> x >> y >> w;\n\n\t\tconst int u=d-y,b=y,l=x,r=w-x;\n\n\t\tswitch(w){\n\t\t\tcase 'N':\n\t\t\t\ts[i]=(l<=u?convert(0,y+l):convert(x-u,d));\n\t\t\t\tg[i]=(r<=u?convert(w,y+r):convert(x+u,d));\n\t\t\t\tbreak;\n\n\t\t\tcase 'W':\n\t\t\t\ts[i]=(b<=l?convert(x-b,0):convert(w,y-l));\n\t\t\t\tg[i]=(u<=l?convert(x-u,d):convert(w,y+l));\n\t\t\t\tbreak;\n\n\t\t\tcase 'E':\n\t\t\t\ts[i]=(u<=r?convert(x+u,d):convert(w,y+r));\n\t\t\t\tg[i]=(b<=r?convert(x+b,0):convert(w,y-r));\n\t\t\t\tbreak;\n\n\t\t\tcase 'S':\n\t\t\t\ts[i]=(r<=b?convert(w,y-r):convert(x+b,0));\n\t\t\t\tg[i]=(l<=b?convert(0,y-l):convert(x-b,0));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tconst int all=2*(w+d);\n\tusing state=tuple<int,int>;\n\tvector<state> ary;\n\trep(i,n){\n\t\tif(s[i]>g[i]) g[i]+=all;\n\t\tary.push_back(make_tuple(g[i],s[i]));\n\t}\n\n\tsort(_all(ary));\n\trep(i,n){\n\t\tint cg,cs;\n\t\ttie(cg,cs)=ary[i];\n\t\tary.push_back(make_tuple(cg+all,cs+all));\n\t}\n\n\t//rep(i,n) cout << get<0>(ary[i]) << \" \" << get<1>(ary[i]) << endl;\n\n\tint ans=n;\n\trep(i,n){\n\t\tint cur=get<0>(ary[i]),j=i+1,res=1;\n\t\twhile(j-i<n){\n\t\t\tif(cur<get<1>(ary[j])) cur=get<0>(ary[j]),res++;\n\t\t\tj++;\n\t\t}\n\t\tchmin(ans,res);\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\tint n, w, d;\n\twhile(cin >> n >> w >> d){\n\t\tvector< pair<int, int> > base;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x, y; char f;\n\t\t\tcin >> x >> y >> f;\n\t\t\tint a, b;\n\t\t\tif(f == 'S'){\n\t\t\t\ta = x;\n\t\t\t\tb = y;\n\t\t\t} else if(f == 'E'){\n\t\t\t\ta = w+y;\n\t\t\t\tb = w-x;\n\t\t\t} else if(f == 'N') {\n\t\t\t\ta = w+d+w-x;\n\t\t\t\tb = d-y;\n\t\t\t} else if(f == 'W'){\n\t\t\t\ta = 2*w+d+d-y;\n\t\t\t\tb = x;\n\t\t\t}\n\t\t\tbase.push_back(make_pair(a-b, a+b));\n\t\t}\n\t\tint res = n;\n\t\tvector<int> startPos;\n\t\tfor(const pair<int, int> pr : base){\n\t\t\tstartPos.push_back(pr.first);\n\t\t\tstartPos.push_back(pr.second);\n\t\t}\n\t\tfor(int i=0;i<startPos.size();i++){\n\t\t\tvector< pair<int, int> > vp;\n\t\t\tint start = startPos[i];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tbool ok = false;\n\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\tif(base[j].first+k*2*(w+d) <= start && start <= base[j].second+k*2*(w+d)) ok = true;\n\t\t\t\t}\n\t\t\t\tif(ok) continue;\n\t\t\t\tvp.push_back(base[j]);\n\t\t\t\tif(vp.back().second < start){\n\t\t\t\t\tvp.back().first += 2*(w+d);\n\t\t\t\t\tvp.back().second += 2*(w+d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 1, pos = start;\n\t\t\tsort(vp.begin(),\n\t\t\t\t vp.end(),\n\t\t\t\t [](const pair<int, int>& a, const pair<int, int>& b){\n\t\t\t\t\treturn a.second == b.second ? a.first < b.first : a.second < b.second;\n\t\t\t\t });\n\t\t\tfor(int j=0;j<vp.size();j++){\n\t\t\t\tif(vp[j].first > pos){\n\t\t\t\t\t++cnt;\n\t\t\t\t\tpos = vp[j].second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = min(res, cnt);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\n#define fst first\n#define snd second\n\nint n, w, h, len; \n\nint solve(vector<pair<double, double>> & lr){\n    int ret = n;\n    rep(i, n){\n        int cur = 1;\n        double rs = lr[i].snd;\n\n        range(_, 1, n){\n            int j = (j + _) % n;\n\n            double cl = lr[j].fst, cr = lr[j].snd;\n            if(cl >= cr){\n                if((cl - len <= rs and rs <= cr) or (cl <= rs and rs <= cr + len)){\n                    continue;\n                }\n            }\n            else {\n                if(cl <= rs and rs <= cr){\n                    continue;\n                }\n            }\n\n            cur++;\n            rs = cr;\n        }\n\n        ret = min(ret, cur);\n    }\n\n    return ret;\n}\n\nint main(void){\n    cin >> n >> w >> h;\n\n    vector<pair<double, double>> lr(n);\n    len = 2 * w + 2 * h;\n    for(auto & e : lr){\n        int x, y; cin >> x >> y;\n        y = h - y;\n        char f; cin >> f;\n\n        int o, p;\n        switch(f){\n        case 'N': o = x;                 p = y;     break;\n        case 'E': o = w + y;             p = w - x; break;\n        case 'S': o = 2 * w + h - x;     p = h - y; break;\n        case 'W': o = 2 * w + 2 * h - y; p = x;     break;\n        }\n\n        e.fst = (o - p + len) % len;\n        e.snd = (o + p) % len;\n    }\n\n    sort(begin(lr), end(lr));\n    int res = solve(lr);\n\n    for(auto & e : lr){\n        swap(e.fst, e.snd);\n        e.fst = len - e.fst;\n        e.snd = len - e.snd;\n    }\n    sort(begin(lr), end(lr));\n    res = min(res, solve(lr));\n\n    cout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar in[2];\npair<int,int> rng[110000];\nint n;\npair<int,int> d[3100];\nint calc(int st,int go){\n\tint ret=1;\n\tint now=st;\n\tfor(int i=0;i<3*n;i++){\n\t\tif(d[i].second<=now)continue;\n\t\tif(d[i].first>=go)break;\n\t\tret++;\n\t\tnow=d[i].first;\n\t}\n\treturn ret;\n}\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tn=a;\n\tfor(int i=0;i<a;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d%s\",&x,&y,in);\n\t\ty=c-y;\n\t\tint X1,X2,Y1,Y2;\n\t\tif(in[0]=='E'){\n\t\t\tX1=x+y;\n\t\t\tX2=x+(c-y);\n\t\t\tY1=0;\n\t\t\tY2=c;\n\t\t\tif(X1>b){\n\t\t\t\tY1+=X1-b;\n\t\t\t\tX1=b;\n\t\t\t}\n\t\t\tif(X2>b){\n\t\t\t\tY2-=X2-b;\n\t\t\t\tX2=b;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='W'){\n\t\t\tX1=x-y;\n\t\t\tX2=x-(c-y);\n\t\t\tY1=0;\n\t\t\tY2=c;\n\t\t\tif(X1<0){\n\t\t\t\tY1+=-X1;\n\t\t\t\tX1=0;\n\t\t\t}\n\t\t\tif(X2<0){\n\t\t\t\tY2-=-X2;\n\t\t\t\tX2=0;\n\t\t\t}\n\t\t\tswap(X1,X2);\n\t\t\tswap(Y1,Y2);\n\t\t}\t\n\t\tif(in[0]=='N'){\n\t\t\tX1=0;\n\t\t\tX2=b;\n\t\t\tY1=y-x;\n\t\t\tY2=y-(b-x);\n\t\t\tif(Y1<0){\n\t\t\t\tX1+=-Y1;\n\t\t\t\tY1=0;\n\t\t\t}\n\t\t\tif(Y2<0){\n\t\t\t\tX2-=-Y2;\n\t\t\t\tY2=0;\n\t\t\t}\n\t\t}\n\t\tif(in[0]=='S'){\n\t\t\tX1=0;\n\t\t\tX2=b;\n\t\t\t Y1=y+x;\n\t\t\t Y2=y+(b-x);\n\t\t\tif(Y1>c){\n\t\t\t\tX1+=Y1-c;\n\t\t\t\tY1=c;\n\t\t\t}\n\t\t\tif(Y2>c){\n\t\t\t\tX2-=Y2-c;\n\t\t\t\tY2=c;\n\t\t\t}\n\t\t\tswap(X1,X2);\n\t\t\tswap(Y1,Y2);\n\t\t}\n\t\tint z1,z2;\n\t\tif(Y1==0)z1=X1;\n\t\telse if(X1==b)z1=b+Y1;\n\t\telse if(Y1==c)z1=b+c+b-X1;\n\t\telse z1=b+c+b+c-Y1;\n\t\tif(Y2==0)z2=X2;\n\t\telse if(X2==b)z2=b+Y2;\n\t\telse if(Y2==c)z2=b+c+b-X2;\n\t\telse z2=b+c+b+c-Y2;\n\t\trng[i]=make_pair(z1,z2);\n\t//\tprintf(\"%d %d, %d %d\\n\",X1,Y1,X2,Y2);\n\t}\n\tint ret=99999999;\n\tfor(int i=0;i<a;i++){\n\t\tif(rng[i].first>rng[i].second)rng[i].second+=b*2+c*2;\n\t}\n\tfor(int i=0;i<a;i++){\n\t\td[i*3]=make_pair(rng[i].second,rng[i].first);\n\t\td[i*3+1]=make_pair(rng[i].second+b*2+c*2,rng[i].first+b*2+c*2);\n\t\td[i*3+2]=make_pair(rng[i].second+b*4+c*4,rng[i].first+b*4+c*4);\n\t\t\n\t}\n\tstd::sort(d,d+a*3);\n\tfor(int i=0;i<a;i++){\n\t\tret=min(ret,calc(rng[i].first,rng[i].first+b*2+c*2));\n\t\tret=min(ret,calc(rng[i].second,rng[i].second+b*2+c*2));\n\t}\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define RREP(i,n,N) for(int i=N-1;i>=n;i--)\n#define p(S) cout<<S<<endl;\n#define CK(n,a,b) ((a)<=(n)&&(n)<=(b))\nusing namespace std;\n\n\nint ans;\nint N, w ,d;\nset<int> st[1010];\npair<int, int> rpoint[1010], lpoint[1010];// 座標、id\nint x[1010], y[1010];\nchar f[1010];\nint main() {\n    cin>>N>>w>>d;\n    REP(i,0,N){\n        cin >> x[i] >> y [i] >> f[i];\n    }\n    REP(i,0,N){\n        // 清水君のコード\n        lpoint[i].second = rpoint[i].second = i;\n        if(f[i]=='N'){\n            rpoint[i].first = x[i] + (d - y[i]);\n            if(0 <= x[i] - (d-y[i])){\n                lpoint[i].first = x[i] - (d - y[i]);\n            }else{\n                lpoint[i].first = x[i] - (d - y[i]) + 2*w + 2*d;\n            }\n        }else if(f[i]=='E'){\n            rpoint[i].first = 2 * w + d - x[i] - y[i];\n            lpoint[i].first = x[i] + (d - y[i]);\n        }else if(f[i]=='S'){\n            rpoint[i].first = 2 * w + d - x[i] + y[i];\n            lpoint[i].first = 2 * w + d - x[i] - y[i];\n        }else{// f[i] == 'W';\n            rpoint[i].first = (2 * w + d + x[i] + y[i]) % (2*w + 2*d);\n            lpoint[i].first = 2 * w + d - x[i] + y[i];\n        }\n    }\n    REP(i,0,N){\n        //p(lpoint[i].first);\n//        cout<<lpoint[i].first<<\" \"<<rpoint[i].first<<endl;\n    }\n    sort(rpoint, rpoint+N);\n\n    REP(i,0,N){\n        int id = rpoint[i].second;\n        REP(j,0,N){\n            int op_id = rpoint[j].second;\n            if(id==op_id) continue;\n//            cout<<\"op_id: \"<<op_id<<\" \"<<lpoint[op_id].first <<\", \"<< rpoint[j].first<<endl;\n            if(lpoint[op_id].first < rpoint[j].first){\n                if(CK(rpoint[i].first, lpoint[op_id].first, rpoint[j].first)){\n                    st[i].insert(op_id);\n//                    cout<<\"st_i: \"<<i<<\" <- \"<<op_id<<endl;\n                }\n            }else{\n                if(CK(rpoint[i].first, lpoint[op_id].first, 2*w+2*d) || (CK(rpoint[i].first, 0,  rpoint[j].first))){\n                    st[i].insert(op_id);\n//                    cout<<\"st_i: \"<<i<<\" <- \"<<op_id<<endl;\n                }\n            }\n        }\n    }\n    ans = N;\n    REP(i,0,N){\n//        cout<<\"start man id: \"<<i<<\":\"<<endl;\n        vector<bool> used(N,false);\n        int cnt = 0;\n        REP(k,i,N){\n            int j=rpoint[k].second;\n//            REP(ii,0,N){\n//                cout<<used[ii]<<\", \";\n//            }\n//            cout<<\" -> \";\n            if(used[j]) continue;\n            used[j]=true;\n            cnt++;\n            for(int id: st[k]){// set\n                used[id]=true;\n            }\n//            REP(ii,0,N){\n//                cout<<used[ii]<<\", \";\n//            }\n//            cout<<endl;\n        }\n        REP(k,0,i){\n            int j=rpoint[k].second;\n//            REP(ii,0,N){\n//                cout<<used[ii]<<\", \";\n//            }\n//            cout<<\" -> \";\n            if(used[j]) continue;\n            used[j]=true;\n            cnt++;\n            for(int id: st[k]){// set\n                used[id]=true;\n            }\n//            REP(ii,0,N){\n//                cout<<used[ii]<<\", \";\n//            }\n//            cout<<endl;\n        }\n        ans = min(ans, cnt);\n    }\n    p(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing In = tuple<int, int, char>;\nusing BA = tuple<int, int>;\nusing P = tuple<int, int>;\n\nint n, w, h;\n\nint calc(P p){\n    int x, y;\n    tie(x, y) = p;\n\n    int xx = 0;\n    if(x == 0){\n        xx = (h - y);\n    }\n    else if(y == 0){\n        xx = h + x;\n    }\n    else if(x == w - 1){\n        xx = h + w + y;\n    }\n    else {\n        xx = h + w + h + (w - x);\n    }\n\n    return xx;\n}\n\nint main(void){\n    cin >> n >> w >> h;\n\n    vector<In> in(n);\n    for(auto & e : in){\n        int x, y; char c; cin >> x >> y >> c;\n        e = In(x, y, c);\n    }\n\n    vector<BA> ba;\n\n    const int L = 2 * w + 2 * h;\n    for(auto & e : in){\n        int x, y; char f;\n        tie(x, y, f) = e;\n\n        vi idxs = {\n            (y - x + L) % L,\n            (y + x + L) % L,\n            (w + h + (h - (y + (w - x))) + L) % L,\n            (w + h + (h - (y - (w - x))) + L) % L\n        };\n\n        int a, b;\n        switch(f){\n            case 'S': { a = idxs[3], b = idxs[0]; break; }\n            case 'E': { a = idxs[2], b = idxs[3]; break; }\n            case 'N': { a = idxs[1], b = idxs[2]; break; }\n            case 'W': { a = idxs[0], b = idxs[1]; break; }\n        }\n        \n        ba.push_back(BA(b, a));\n    }\n\n    int res = n;\n    rep(rev, 2){\n        if(rev){\n            rep(i, n){\n                int a, b; tie(b, a) = ba[i];\n                b = L - b;\n                a = L - a;\n                swap(a, b);\n                ba[i] = BA(b, a);\n            }\n        }\n        auto ba_origin = ba;\n\n        rep(tar, n){\n            int base; tie(ignore, base) = ba[tar];\n            rep(i, n){\n                int a, b; tie(b, a) = ba[i];\n                a = (a - base + L) % L;\n                b = (b - base + L) % L;\n                if(a > b) a = 0;\n                ba[i] = BA(b, a);\n            }\n\n            sort(_all(ba));\n\n            int ri = -1;\n            int cnt = 0;\n            rep(i, n){\n                int a, b; tie(b, a) = ba[i];\n                if(cnt == 0 or a > ri){\n                    cnt++;\n                    ri = b;\n                }\n            }\n\n            chmin(res, cnt);\n\n            ba = ba_origin;\n        }\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint n,h,w;\n\tcin>>n>>w>>h;\n\tvector<pii> a(n),b(n);\n\tint mod=2*(h+w);\n\trep(i,n){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tchar c;\n\t\tcin>>c;\n\t\tif(c=='N'){\n\t\t\ta[i]=pii(w-x,h-y);\n\t\t\tb[i]=pii(h+w+h+x,h-y);\n\t\t}\n\t\tif(c=='W'){\n\t\t\ta[i]=pii(w+h-y,x);\n\t\t\tb[i]=pii(h+w+y,x);\n\t\t}\n\t\tif(c=='S'){\n\t\t\ta[i]=pii(w+h+x,y);\n\t\t\tb[i]=pii(h+w-x,y);\n\t\t}\n\t\tif(c=='E'){\n\t\t\ta[i]=pii(w+h+w+y,w-x);\n\t\t\tb[i]=pii(h-y,w-x);\n\t\t}\n\t\ta[i]=pii(a[i].F-a[i].S,a[i].F+a[i].S);\n\t\tb[i]=pii(b[i].F-b[i].S,b[i].F+b[i].S);\n\t\ta[i]=pii((a[i].F+mod)%mod,(a[i].S+mod)%mod);\n\t\tb[i]=pii((b[i].F+mod)%mod,(b[i].S+mod)%mod);\n\t}\n\tint ans=INF;\n\trep(o,2){\n\t\trep(i,n){\n\t\t\tvector<pii> tmp=(o?a:b);\n\t\t\trep(j,n){\n\t\t\t\tint t=(i+j)%n;\n\t\t\t\ttmp[j]=pii(a[t].F-a[i].F,a[t].S-a[i].F);\n\t\t\t\ttmp[j]=pii((tmp[j].F+mod)%mod,(tmp[j].S+mod)%mod);\n\t\t\t}\n\t\t\tvector<bool> used(n);\n\t\t\tused[0]=true;\n\t\t\treep(j,1,n){\n\t\t\t\tif(tmp[j].F>tmp[j].S) used[j]=true;\n\t\t\t\tif(tmp[j].F==0) used[j]=true;\n\t\t\t}\n\t\t\tvector<pii> v;\n\t\t\trep(j,n){\n\t\t\t\tif(used[j]) continue;\n\t\t\t\tv.PB(pii(tmp[j].F,-j));\n\t\t\t\tv.PB(pii(tmp[j].S,j));\n\t\t\t}\n\t\t\tsort(ALL(v));\n\t\t\tqueue<int> q;\n\t\t\tint tans=1;\n\t\t\trep(i,v.size()){\n\t\t\t\tif(v[i].S<0){\n\t\t\t\t\tq.push(-v[i].S);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(used[v[i].S]) continue;\n\t\t\t\t\tused[v[i].S]=true;\n\t\t\t\t\ttans++;\n\t\t\t\t\twhile(q.size()){\n\t\t\t\t\t\tused[q.front()]=true;\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmins(ans,tans);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\nint n,w,d,x,y,ans;\nvector<P> v;\nchar f;\n\nvoid add_point(){\n  int s,t;\n  if(f=='N'){\n    s=(x+y<d?x+y+w*2+d:x+y-d);\n    t=(w+y-x<d?d-(w+y-x)+w:d-(y-x));\n  }\n  if(f=='E'){\n    s=(d-(y-x)<w?d-(y-x):d-(w+(y-x))+w);\n    t=(y+x<w?w-(y+x)+w+d:d-(-w+y+x)+w);\n  }\n  if(f=='S'){\n    s=(0<=-w+y+x?d-(-w+y+x)+w:w-(y+x)+w+d);\n    t=(0<=y-x?y-x+w*2+d:w-(-(y-x))+w+d);\n  }\n  if(f=='W'){\n    s=(0<=-(y-x)?w-(-(y-x))+w+d:y-x+w*2+d);\n    t=(0<=y+x-d?y+x-d:y+x+w*2+d);\n  }\n  v.push_back(P(t,s));\n}\n\nvoid solve(){\n  int len=v.size();\n  for(int i=0;i<len;i++){\n    int cnt=1,clock=v[i].first;\n    for(int j=i;j<len+i;j++){\n      int idx=j%len,c=clock;\n      int l=v[idx].second,r=v[idx].first;\n      if(l>r)r+=w*2+d*2;\n      if(l>c)c+=w*2+d*2;\n      if(!(l<=c&&c<=r)){\n\tclock=v[j].first;\n\tcnt++;\n      }\n    }\n    ans=min(ans,cnt);\n  }\n}\n\nint main(){\n  cin>>n>>w>>d;\n  for(int i=0;i<n;i++){\n    cin>>x>>y>>f;\n    add_point();\n  }\n  sort(v.begin(),v.end());\n  ans=(1e9);\n  solve();\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nint n, w, d;\nP v[1002];\n\n\nint main() {\n    cin >> n >> w >> d;\n    int l = 2 * d + 2 * w; \n\n    for (int i = 0; i < n; ++i) {\n        int x, y;\n        char f;\n        cin >> x >> y >> f;\n        int c, b;\n        switch (f) {\n            case 'N':\n                c = x;\n                b = d - y;\n            break;\n            case 'E':\n                c = d - y + w;\n                b = w - x;\n            break;\n            case 'S':\n                c = w - x + w + d;\n                b = y;\n            break;\n            case 'W':\n                c = y + 2 * w + d;\n                b = x;\n            break;\n        }\n        \n        // v[i] = (left end of view, right end of view)\n\n        v[i] = P ((c - b + l) % l, (c + b + l) % l);\n    } \n\n    // sort by the left end of view\n\n    sort(v, v + n);\n\n    int minc = 10000;\n    for (int i = 0; i < n; ++i) {\n        \n        // Put a clock at the left end of i-th member's view\n\n        int c = 1;\n        int tmp = v[i].first;\n        for (int j = 0; j < n - 1; ++ j) {\n            int k = (i - j + n) % n;\n\n            int left = v[k].first;\n            int right = v[k].second;\n            if (left > right) right += l;\n            if (left <= tmp && tmp <= right) continue;\n            if (left - l <= tmp && tmp <= right - l) continue;\n\n            c++;\n            tmp = left;\n        }\n        if (c < minc) minc = c;\n    }\n    cout << minc << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<cctype>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef long long LL;\ntypedef long double ld;\n\n#define rep(i, x) for(int i = 0; i < (int)(x); i++)\n#define outint(x) printf(\"%d\\n\", (x))\n\nconst int INF = 0x3f3f3f3f;\nconst double EPS = 1e-8;\nconst double PI = 3.1415926535897932384626433832795;\n\ninline int get_int() {\n    int res, t = 1; char c;\n    while(!isdigit(c = getchar())) if(c == '-') t = -1;\n    for(res = c - '0'; isdigit(c = getchar()); )\n        res = res * 10 + c - '0';\n    return res * t;\n}\n\nstruct node {\n    int l, r;\n    bool operator < (const node &rhs) const {\n        return r < rhs.r;\n    }\n};\n\nconst int MAXN = 1000;\n\nint n, W, D;\nvector<node> A;\nvector<int>B;\n\nvoid ins(int X, int Y, int dir) {\n    int n = W * 2 + D * 2;\n    int a, b;\n    switch(dir) {\n        case 'S':\n            a = X-Y, b = X+Y;\n            if(a < 0) a += n;\n            break;\n        case 'E':\n            a = Y-(W-X), b = Y+(W-X);\n            a += W;\n            b += W;\n            break;\n        case 'W':\n            b = Y-X;\n            a = Y+X;\n            a = (n - a)%n;\n            b = (n - b)%n;\n            break;\n        case 'N':\n            b = X - (D-Y);\n            a = X + (D-Y);\n            a = W+D+(W-a);\n            b = W+D+(W-b);\n            break;\n    }\n    if(a > b) b += n;\n    A.push_back((node){a, b});\n    B.push_back(a);\n    B.push_back(b);\n}\n\nint main() {\n\n    n = get_int();\n    W = get_int();\n    D = get_int();\n\n    for(int i = 1; i <= n; i++) {\n        int X = get_int(), Y = get_int();\n        ins(X, Y, getchar());\n    }\n    sort(B.begin(), B.end());\n    sort(A.begin(), A.end());\n\n    int ans = INF;\n    for(int f = 0; f < B.size(); f++) {\n        static int vis[MAXN + 10];\n        int p = B[f], cc = 0;\n        if(p >= (W+D)*2) break;\n        rep(i, A.size()) {\n            if(A[i].l <= p && p <= A[i].r) vis[i] = f + 1, cc++;\n            if(A[i].l <= p+(W+D)*2 && p+(W+D)*2 <= A[i].r) vis[i] = f + 1, cc++;\n        }\n\n        int st = n, x, last, cnt = 2;\n        rep(i, A.size()) if(A[i].l > p && vis[i] != f + 1) { st = i; break; }\n        if(st == n)st = 0;\n        if(cc==n) {\n            ans = 1;\n            break;\n        }\n        last = x = st;\n        bool first = 1;\n        do {\n            if(vis[x] != f + 1) {\n                if(A[last].r - (first ? 0 : W*2+D*2)< A[x].l)\n                    last = x, cnt++;\n            }\n            x = (x+1)%n;\n            if(x == 0) first = 0;\n        } while(x != st);\n        ans = min(ans, cnt);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint n,w,d,mod;\nvector<pair<int,int> >a;\nmain()\n{\n\tcin>>n>>w>>d;\n\tmod=2*(w+d);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint x,y;char f;cin>>x>>y>>f;\n\t\ta.push_back(make_pair(\n\t\t\t(f=='E'?d+x+y:f=='W'?mod-x+d-y:f=='S'?d+x-y:mod-x-d+y)%mod,\n\t\t\t(f=='E'?mod-x-d+y:f=='W'?d+x-y:f=='S'?d+x+y:mod-x+d-y)%mod));\n\t}\n\tint ans=1e9;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint now=1,id=a[i].second;\n\t\tvector<pair<int,int> >m;\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(a[j].first<=id&&id<=a[j].second||a[j].second<a[j].first&&(id<=a[j].second||a[j].first<=id))continue;\n\t\t\tm.push_back(make_pair((a[j].second-id+mod)%mod,(a[j].first-id+mod)%mod));\n\t\t}\n\t\tsort(m.begin(),m.end());\n\t\tint p=-1;\n\t\tfor(int j=0;j<m.size();j++)\n\t\t{\n\t\t\tif(p<m[j].second)\n\t\t\t{\n\t\t\t\tp=m[j].first;\n\t\t\t\tnow++;\n\t\t\t}\n\t\t}\n\t\tans=min(ans,now);\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//  aoj-VolumeICPCOOC2015-D  / 2015-11-30\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef ll int__;\n#define rep(i,j) for(int__ i=0;i<(int__)(j);i++)\n#define repeat(i,j,k) for(int__ i=(j);i<(int__)(k);i++)\n#define all(v) v.begin(),v.end()\nconst int INF = 1 << 30;\n//vector\ntemplate<typename T>ostream& operator << (ostream &os , const vector<T> &v){\n    rep(i,v.size()) os << v[i] << (i!=v.size()-1 ? \" \" : \"\\n\"); return os;\n}\ntemplate<typename T>istream& operator >> (istream &is , vector<T> &v){\n    rep(i,v.size()) is >> v[i]; return is;\n}\n//debug\n#ifdef DEBUG\nvoid debug(){ cerr << \"\\033[0m\" << endl; }\n#endif\ntemplate<class F,class...R> void debug(const F &car,const R&... cdr){\n#ifdef DEBUG\n    cerr << \"\\033[33m\" << car << \" \"; debug(cdr...);\n#endif\n}\n\nstruct Point{\n    int x,y;\n    Point():x(0),y(0){}\n    Point(int x,int y):x(x),y(y){};\n    Point& operator +=(const Point &p){x += p.x; y += p.y; return *this;}\n};\nostream &operator << (ostream& os, const Point& p){ return os << \"(\" << p.x << \",\" << p.y << \")\";}\n\nstruct ClosedRange{\n    int l,r; //[l,r]\n    ClosedRange(){}\n    ClosedRange(int l,int r):l(l),r(r){}\n    bool operator < (const ClosedRange &a) const { return make_pair(r,l) < make_pair(a.r, a.l); }\n};\nostream& operator << (ostream &os, const ClosedRange &r){ return os << \"[\" << r.l << \" \" << r.r << \"]\"; }\n\n\n// // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //\n\n\n// 2d to 1d\nint lower_dimension(Point p, int w, int d){\n    return  p.y == 0 ? p.x :\n            p.x == w ? w + p.y :\n            p.y == d ? w + d + (w - p.x) :\n            p.x == 0 ? w*2 + d + (d - p.y) : -1;\n}\n\nPoint find_cross_point(Point p, Point dp, int w, int d){\n    while(0 < p.x and p.x < w and 0 < p.y and p.y < d) p += dp;\n    return p;\n}\n\nClosedRange calc_range(Point p, char dir, int w, int d){\n    ClosedRange ret;\n    Point dp[] = {Point(-1, 1), Point(1, 1), Point(1, -1), Point(-1, -1)};\n    map<char, int> dtoi = {{'N', 0}, {'E', 1}, {'S', 2}, {'W', 3}};\n    Point dp1 = dp[ ( dtoi[ dir ] + 1 ) % 4 ];\n    Point dp2 = dp[ dtoi[ dir ] ];\n    Point l = find_cross_point(p, dp1, w, d);\n    Point r = find_cross_point(p, dp2, w, d);\n    return ClosedRange(lower_dimension(l, w, d), lower_dimension(r, w, d));\n}\n\nbool check_used(set<int> &clock, ClosedRange &r){\n    if(r.l <= r.r){\n        auto itr = clock.lower_bound(r.l);\n        return itr != clock.end() ? *itr <= r.r : false;\n    } else {\n        auto itr = clock.lower_bound(r.l);\n        auto itr2 = clock.upper_bound(r.r);\n        return  itr  != clock.end()   ? true :\n                itr2 != clock.begin() ? *--itr <= r.r : false;\n    }\n}\n\nint trial(vector<ClosedRange> &range, int start){\n    debug(\"start at \",start);\n    int n = range.size();\n    set<int> clock;\n    for(int i = start; i < start + n; i++){\n        if( check_used(clock,range[ i%n ]) ) continue;\n        clock.insert(range[ i%n ].r);\n        debug(\"clock at \",range[ i%n ].r);\n    }\n    return clock.size();\n}\n\nbool solve(){\n    int n, w, d; cin >> n >> w >> d;\n    vector<ClosedRange> range(n);\n    rep(i,n){\n        int x,y;\n        char f; cin >> x >> y >> f;\n        range[i] = calc_range(Point(x,y), f, w, d);\n        debug(range[i]);\n    }   \n    sort( all( range ) );\n    int ans = INF;\n    rep(i, n){\n        ans = min(ans, trial(range, i));\n    }\n    cout << ans << endl;\n    return false;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <cstdio>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long double ldb;\ntypedef complex<ldb> P;\n\nconst ldb eps = 1e-9;\nconst ldb pi = acos(-1);\nint sig(ldb a) {return (a<-eps)?-1:(a>eps)?1:0;}\nbool eq(ldb a,ldb b){return abs(a-b)<eps;}\nldb dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\nldb cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nldb ang(P a,P b,P c) {\n  P p = a-b;\n  P q = c-b;\n  if( eq(abs(p)*abs(q),0) ) return 0;\n  return acos(dot(p,q)/(abs(p)*abs(q)));\n}\n\nstruct L {\n  P a,b;\n  L(){}\n  L(P a,P b):a(a),b(b){}\n  ldb len(){return abs(a-b);}\n  P vec(){return b-a;}\n};\n\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\nint ccw(L s, P p) {\n  P a = s.vec();\n  p -= s.a;\n  ldb cr = cross(a, p);\n  if (eq(cr, 0)) {\n    if (sig(dot(a, p)) < 0) return BACK;\n    if (sig(norm(a) - norm(p)) < 0) return FRONT;\n    return ON;\n  }\n  return (cr > 0) ? LEFT : RIGHT;\n}\n\nP iP2(L a,L b) {\n  P c = b.b-b.a;\n  ldb d1 = abs(cross(c, a.a-b.a));\n  ldb d2 = abs(cross(c, a.b-b.a));\n  ldb t = d1 / (d1 + d2);\n  return a.a + (a.b-a.a) * t;\n}\n\nbool iI2_2(L a, L b) {\n  int cwa = ccw(a, b.a) | ccw(a, b.b);\n  int cwb = ccw(b, a.a) | ccw(b, a.b);\n  return ((cwa | cwb) & ON) || ((cwa & cwb) == (LEFT | RIGHT));\n}\n\nint n, w, d;\nint x[1111], y[1111];\nchar f[1111];\nP mid;\n\npair<int, int> tp(const P& p) {\n  return {p.real()+0.4, p.imag()+0.4};\n}\n\nint main(void) {\n  scanf(\"%d%d%d\", &n, &w, &d);\n\n  mid = P(w/2.0, d/2.0);\n  \n  for (int i = 0; i < n; i++) {\n    scanf(\"%d%d %c\", x+i, y+i, f+i);\n  }\n\n  vector<L> ls {\n    L(P(0, 0), P(w, 0)),\n        L(P(0, 0), P(0, d)),\n        L(P(w, 0), P(w, d)),\n        L(P(0, d), P(w, d)),\n  };\n  vector<P> p1, p2;\n  vector<tuple<ldb, ldb, int>> a;\n  vector<pair<int, int>> pos;\n  const int I = 1000000;\n\n  for (int i = 0; i < n; i++) {\n    L l1, l2;\n    P pos(x[i], y[i]);\n    if (f[i] == 'N') {\n      l1 = L(pos, P(x[i]+I, y[i]+I));\n      l2 = L(pos, P(x[i]-I, y[i]+I));\n    } else if (f[i] == 'W') {\n      l1 = L(pos, P(x[i]-I, y[i]+I));\n      l2 = L(pos, P(x[i]-I, y[i]-I));\n    } else if (f[i] == 'S') {\n      l1 = L(pos, P(x[i]-I, y[i]-I));\n      l2 = L(pos, P(x[i]+I, y[i]-I));\n    } else {\n      l1 = L(pos, P(x[i]+I, y[i]-I));\n      l2 = L(pos, P(x[i]+I, y[i]+I));\n    }\n    for (int i = 0; i < 4; i++) {\n      if (iI2_2(l1, ls[i])) {\n        p1.push_back(iP2(l1, ls[i]));\n        break;\n      }\n    }\n    for (int i = 0; i < 4; i++) {\n      if (iI2_2(l2, ls[i])) {\n        p2.push_back(iP2(l2, ls[i]));\n        break;\n      }\n    }\n  }\n\n  for (int i = 0; i < int(p1.size()); i++) {\n    pos.push_back(tp(p1[i]));\n    pos.push_back(tp(p2[i]));\n  }\n  sort(pos.begin(), pos.end());\n  pos.erase(unique(pos.begin(), pos.end()), pos.end());\n\n  vector<ldb> cl;\n  for (int i = 0; i < int(pos.size()); i++) {\n    cl.push_back(arg(mid-P(pos[i].first, pos[i].second))+pi);\n  }\n  sort(cl.begin(), cl.end());\n\n  /*\n  for (int i = 0; i < int(pos.size()); i++) {\n    printf(\"%d %d\\n\", pos[i].first, pos[i].second);\n  }\n  //*/\n\n  /*\n  for (int i = 0; i < int(cl.size()); i++) {\n    printf(\"%.10Lf\\n\", cl[i]/pi*180);\n  }\n  //*/\n\n  for (int i = 0; i < int(p1.size()); i++) {\n    ldb a1 = arg(mid-p1[i])+pi;\n    ldb a2 = arg(mid-p2[i])+pi;\n    if (a1 > a2) a2 += 2*pi;\n    a.emplace_back(a1, a2, i);\n  }\n  sort(a.begin(), a.end());\n\n  /*\n  for (int i = 0; i < int(a.size()); i++) {\n    printf(\"%20.10Lf %20.10Lf \", get<0>(a[i])/pi*180, get<1>(a[i])/pi*180);\n    printf(\"%d\\n\", get<2>(a[i]));\n  }\n  //*/\n\n  int res = 114514;\n  for (int i = 0; i < n; i++) {\n    {\n      int u[2222] {};\n      int b = 0;\n      for (int j = 0; j < int(cl.size()); j++) {\n        if (eq(cl[j], arg(mid-p1[get<2>(a[i])])+pi)) {\n          b = j;\n          break;\n        }\n        /*\n          if ((sig(get<0>(a[i])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[i])) <= 0) ||\n          (sig(get<0>(a[i])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[i])) <= 0)) {\n          b = j;\n          }\n        */\n      }\n      // printf(\"%d\\n\", b);\n      int c = 0;\n      int j = b;\n      u[j] = 1;\n      int k = (i+1)%n;\n      // printf(\"%d %d\\n\", k, j);\n      while (k != i) {\n        while (k != i && ((sig(get<0>(a[k])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[k])) <= 0) ||\n                          (sig(get<0>(a[k])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[k])) <= 0))) {\n          k = (k+1)%n;\n        }\n        if (k != i) {\n          while (!((sig(get<0>(a[k])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[k])) <= 0) ||\n                   (sig(get<0>(a[k])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[k])) <= 0))) {\n            j = (j+1)%cl.size();\n          }\n          int pj = j;\n          while (((sig(get<0>(a[k])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[k])) <= 0) ||\n                  (sig(get<0>(a[k])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[k])) <= 0))) {\n            pj = j;\n            j = (j+1)%cl.size();\n          }\n          j = pj;\n          u[j] = 1;\n        }\n        // printf(\"%d %d\\n\", k, j);\n      }\n      //*\n      for (int p = 0; p < int(cl.size()); p++) {\n        c += u[p];\n        //printf(\"%d \", u[p]);\n      }\n      // puts(\"\");\n      //*/\n      res = min(res, c);\n    }\n    {\n      int u[2222] {};\n      int b = 0;\n      for (int j = 0; j < int(cl.size()); j++) {\n        if (eq(cl[j], arg(mid-p2[get<2>(a[i])])+pi)) {\n          b = j;\n          break;\n        }\n        /*\n          if ((sig(get<0>(a[i])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[i])) <= 0) ||\n          (sig(get<0>(a[i])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[i])) <= 0)) {\n          b = j;\n          }\n        */\n      }\n      // printf(\"%d\\n\", b);\n      int c = 0;\n      int j = b;\n      u[j] = 1;\n      int k = (i+1)%n;\n      while (k != i) {\n        // printf(\"%d %d\\n\", k, j);\n        while (k != i && ((sig(get<0>(a[k])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[k])) <= 0) ||\n                          (sig(get<0>(a[k])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[k])) <= 0))) {\n          k = (k+1)%n;\n        }\n        if (k != i) {\n          while (!((sig(get<0>(a[k])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[k])) <= 0) ||\n                   (sig(get<0>(a[k])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[k])) <= 0))) {\n            j = (j+1)%cl.size();\n          }\n          int pj = j;\n          while (((sig(get<0>(a[k])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[k])) <= 0) ||\n                  (sig(get<0>(a[k])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[k])) <= 0))) {\n            pj = j;\n            j = (j+1)%cl.size();\n          }\n          j = pj;\n          u[j] = 1;\n        }\n      }\n      //*\n      for (int p = 0; p < int(cl.size()); p++) {\n        c += u[p];\n        //printf(\"%d \", u[p]);\n      }\n      // puts(\"\");\n      //*/\n      res = min(res, c);\n    }\n  }  \n\n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct range{\n\tint st, en;\n} pos[1000];\n\nint n, w, d;\nmap<int,vector<int> > m;\nmap<int,vector<int> >::iterator it;\nmap<int,int> nxt;\nvector<int> xx[2000];\nbool saw[1000];\n\nint main(){\n\tcin >> n >> w >> d;\n\trep(i,n){\n\t\tint x, y; char f;\n\t\tcin >> x >> y >> f;\n\t\ty = d-y;\n\t\tif(f == 'N'){\n\t\t\tif(w-x < y){\n\t\t\t\t//pos[i].st = P(w,y-w+x);\n\t\t\t\tpos[i].st = w+d*2-(y-w+x);\n\t\t\t} else{\n\t\t\t\t//pos[i].st = P(x+y,0);\n\t\t\t\tpos[i].st = w*2+d*2-(x+y);\n\t\t\t}\n\t\t\tif(x < y){\n\t\t\t\t//pos[i].en = P(0,y-x);\n\t\t\t\tpos[i].en = y-x;\n\t\t\t} else{\n\t\t\t\t//pos[i].en = P(x-y,0);\n\t\t\t\tpos[i].en = w*2+d*2-(x-y);\n\t\t\t}\n\t\t} else if(f == 'E'){\n\t\t\tif(w-x < d-y){\n\t\t\t\t//pos[i].st = P(w,y+w-x);\n\t\t\t\tpos[i].st = w+d*2-(y+w-x);\n\t\t\t} else{\n\t\t\t\t//pos[i].st = P(x+d-y,d);\n\t\t\t\tpos[i].st = d+x+d-y;\n\t\t\t}\n\t\t\tif(w-x < y){\n\t\t\t\t//pos[i].en = P(w,y-w+x);\n\t\t\t\tpos[i].en = w+d*2-(y-w+x);\n\t\t\t} else{\n\t\t\t\t//pos[i].en = P(x+y,0);\n\t\t\t\tpos[i].en = w*2+d*2-(x+y);\n\t\t\t}\n\t\t} else if(f == 'W'){\n\t\t\tif(x < y){\n\t\t\t\t//pos[i].en = P(0,y-x);\n\t\t\t\tpos[i].st = y-x;\n\t\t\t} else{\n\t\t\t\t//pos[i].en = P(x-y,0);\n\t\t\t\tpos[i].st = w*2+d*2-(x-y);\n\t\t\t}\n\t\t\tif(x < d-y){\n\t\t\t\t//pos[i].en = P(0,y+x);\n\t\t\t\tpos[i].en = y+x;\n\t\t\t} else{\n\t\t\t\t//pos[i].en = P(x+y-d,d);\n\t\t\t\tpos[i].en = d+x+y-d;\n\t\t\t}\n\t\t} else{\n\t\t\tif(x < d-y){\n\t\t\t\t//pos[i].en = P(0,y+x);\n\t\t\t\tpos[i].st = y+x;\n\t\t\t} else{\n\t\t\t\t//pos[i].en = P(x+y-d,d);\n\t\t\t\tpos[i].st = d+x+y-d;\n\t\t\t}\n\t\t\tif(w-x < d-y){\n\t\t\t\t//pos[i].st = P(w,y+w-x);\n\t\t\t\tpos[i].en = w+d*2-(y+w-x);\n\t\t\t} else{\n\t\t\t\t//pos[i].st = P(x+d-y,d);\n\t\t\t\tpos[i].en = d+x+d-y;\n\t\t\t}\n\t\t}\n\t\tcout << pos[i].st << \" \" << pos[i].en  << endl;\n\t\tm[pos[i].st].push_back(i);\n\t\tm[pos[i].en].push_back(i);\n\t}\n\tint cnt = 0;\n\tfor(it = m.begin(); it != m.end(); it++){\n\t\tvector<int> v = (*it).second;\n\t\txx[cnt] = v;\n\t\tnxt[(*it).first] = cnt;\n\t\tcnt++;\n\t}\n\tint ans = INF;\n\trep(i,cnt){\n\t\tint counter = 1;\n\t\trep(j,n) saw[j] = false;\n\t\trep(j,xx[i].size()){\n\t\t\tsaw[xx[i][j]] = true;\n\t\t}\n\t\tmap<int,int> tmp;\n\t\tfor(int j = i+1; j < cnt; j++){\n\t\t\trep(k,xx[j].size()){\n\t\t\t\tif(saw[xx[j][k]]) continue;\n\t\t\t\tif(nxt[pos[xx[j][k]].en] == j){\n\t\t\t\t\tif(tmp[xx[j][k]] == 1){\n\t\t\t\t\t\ttmp.clear();\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else{\n\t\t\t\t\ttmp[xx[j][k]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < i; j++){\n\t\t\trep(k,xx[j].size()){\n\t\t\t\tif(saw[xx[j][k]]) continue;\n\t\t\t\tif(nxt[pos[xx[j][k]].en] == j){\n\t\t\t\t\tif(tmp[xx[j][k]] == 1){\n\t\t\t\t\t\ttmp.clear();\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else{\n\t\t\t\t\ttmp[xx[j][k]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = min(ans,counter);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P1;\nint n,w,d,x,y,ans;\nvector<P1> v;\nchar f;\nstack<P> q;\nbool used[N];\n\nvoid add_point(int num){\n  if(f=='N'){\n    if(x+y<d)v.push_back(P1(P(x+y+w*2+d,0),num));\n    else v.push_back(P1(P(x+y-d,0),num));\n    if(w+y-x<d)v.push_back(P1(P(d-(w+y-x)+w,1),num));\n    else v.push_back(P1(P(d-(y-x),1),num));\n  }\n  if(f=='E'){\n    if(d-(y-x)<w)v.push_back(P1(P(d-(y-x),0),num));\n    else v.push_back(P1(P(d-(w+(y-x))+w,0),num));\n    if(y+x<w)v.push_back(P1(P(w-(y+x)+w+d,1),num));\n    else v.push_back(P1(P(d-(-w+y+x)+w,1),num));\n  }\n  if(f=='S'){\n    if(0<=-w+y+x)v.push_back(P1(P(d-(-w+y+x)+w,0),num));\n    else v.push_back(P1(P(w-(y+x)+w+d,0),num));\n    if(0<=y-x)v.push_back(P1(P(y-x+w*2+d,1),num));\n    else v.push_back(P1(P(w-(-(y-x))+w+d,1),num));\n  }\n  if(f=='W'){\n    if(0<=-(y-x))v.push_back(P1(P(w-(-(y-x))+w+d,0),num));\n    else v.push_back(P1(P(y-x+w*2+d,0),num));\n    if(0<=y+x-d)v.push_back(P1(P(y+x-d,1),num));\n    else v.push_back(P1(P(y-x+w*2+d,1),num));\n  }\n}\n\nbool usednum[500000];\n\nvoid solve(){\n  int len=v.size(),cnt;\n  for(int i=0;i<len;i++){\n    memset(used,0,sizeof(used));\n    memset(usednum,0,sizeof(usednum));\n    if(v[i].first.second)continue;\n    useds[v[i].second]=true;\n    cnt=0;\n    for(int j=i;j<len+i;j++){\n      int idx=j%len;\n      if(used[v[idx].second])continue;\n      if(!v[idx].first.second){\n\tuseds[v[idx].second]=true;\n\tq.push(P(v[idx].second,v[idx].first.first));\n      }\n      else{\n\tcnt++;\n\tif(usednum[v[idx].first.first])cnt--;\n\tusednum[v[idx].first.first]=true;\n\twhile(!q.empty()){\n\t  P num=q.top(); q.pop();\n\t  used[num.first]=true;\n\t  if(num.first==v[idx].second)break;\n\t}\n      }\n    }\n    ans=min(ans,cnt);\n  }\n}\n\nint main(){\n  cin>>n>>w>>d;\n  for(int i=0;i<n;i++){\n    cin>>x>>y>>f;\n    add_point(i);\n  }\n  sort(v.begin(),v.end());\n  ans=(1e9);\n  solve();\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint N,W,H,L;\nvector<P> t;\n\nbool check(P p,int a){\n  if(p.first<p.second)\n    return (p.first<=a&&a<=p.second);\n  return (p.first<=a||a<=p.second);\n}\nint calcArg(int x,int y){\n  if(x==0)return y;\n  if(y==H)return H+x;\n  if(x==W)return H+W+H-y;\n  return H+W+H+W-x;\n}\nint solve(int si){\n  int res=1,last=t[si].second;\n  for(int i=si;i<si+N;i++){\n    if(check(t[i],last)) continue;\n    res++;\n    last=t[i].second;\n  }\n  return res;\n}\nint main(){\n  cin>>N>>W>>H;\n  L=W+W+H+H;\n  for(int i=0;i<N;i++){\n    int x,y,s;\n    char ch;\n    P p;\n    cin>>x>>y>>ch;\n    if(ch=='N'){\n      s=calcArg(x,H);\n      p.first = (s-H+y+L)%L;\n      p.second = (s-y+H)%L;\n    }\n    if(ch=='E'){\n      s=calcArg(W,y);\n      p.first = (s-W+x+L)%L;\n      p.second = (s-x+W)%L;\n    }\n    if(ch=='S'){\n      s=calcArg(x,0);\n      p.first = (s-y+L)%L;\n      p.second = (s+y)%L;\n    }\n    if(ch=='W'){\n      s=calcArg(0,y);\n      p.first = (s-x+L)%L;\n      p.second = (s+x)%L;\n    } \n    t.push_back(p);\n  }\n  for(int i=0;i<N;i++) swap(t[i].first,t[i].second);\n  sort(t.begin(),t.end());\n  for(int i=0;i<N;i++) t.push_back(t[i]);\n  for(int i=0;i<N+N;i++) swap(t[i].first,t[i].second);\n  int ans = N;\n  for(int i=0;i<N;i++)ans = min(ans,solve(i));\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef pair< int, int > pii;\n\npii getRange(int w, int d, int x, int y, char f) {\n\tif (f == 'N') {\n\t\tint a = x - (d - y), b = (w - x) - (d - y);\n\t\treturn pii(a, w - b);\n\t}\n\t\n\tif (f == 'E') {\n\t\tint a = (d - y) - (w - x), b = y - (w - x);\n\t\treturn pii(w + a, w + d - b);\n\t}\n\t\n\tif (f == 'S') {\n\t\tint a = (w - x) - y, b = x - y;\n\t\treturn pii(w + d + a, 2*w + d - b);\n\t}\n\t\n\tif (f == 'W') {\n\t\tint a = y - x, b = (d - y) - x;\n\t\treturn pii(2*w + d + a, 2*w+2*d - b);\n\t}\n\t\n\treturn pii(-1,-1);\n}\n\nint solve(int n, vector< vector< int > >& collision, vector< int >& order, int s) {\n\tint ret = 0;\n\tvector< bool > bad(n, false);\n\tfor_(i,0,n) {\n\t\tint v = order[(s + i) % n];\n\t\tif (bad[v]) continue;\n\t\t++ret;\n\t\tfor (int u : collision[v]) bad[u] = true;\n\t}\n\treturn ret;\n}\n\nstruct Rng {\n\tint id, L, R;\n\tRng(int __id, pii p) : id(__id), L(p.first), R(p.second) {}\n\tbool operator < (const Rng& o) const { return R < o.R; }\n};\n\nint main() {\n\tint n, w, d;\n\tcin >> n >> w >> d;\n\t\n\tint UB = 2*w + 2*d;\n\tvector< Rng > vp;\n\tfor_(i,0,n) {\n\t\tint x, y; char f;\n\t\tcin >> x >> y >> f;\n\t\tpii p = getRange(w, d, x, y, f);\n\t\tvp.push_back(Rng(i, p));\n\t\tvp.push_back(Rng(i, pii(p.first + UB, p.second + UB)));\n\t}\n\t\n\tsort(vp.begin(), vp.end());\n\tvector< int > order, vis(n, false);\n\tfor (Rng r : vp) if (!vis[r.id]) order.push_back(r.id), vis[r.id] = true;\n\t\n\tvector< vector< int > > collision(n, vector< int >());\n\tfor (Rng x : vp) for (Rng y : vp) {\n\t\tif (x.id == y.id) continue;\n\t\tif (x.R >= y.L && x.L <= y.R) collision[x.id].push_back(y.id);\n\t}\n\t\n\tcout << max(solve(n, collision, order, 0), solve(n, collision, order, 1)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class U, class V> ostream& operator<<(ostream& os, const pair<U, V>& p) {\n        return os << \"(\" << p.first << \",\" << p.second << \")\";\n    }\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int N, W, D;\n    int p(int x, int y) {\n        if (x == 0) return y;\n        else if (x == W) return D + W + (D - y);\n        else if (y == D) return D + x;\n        else { assert(y == 0);\n            return D + W + D + (W - x);\n        }\n    }\n    int p(const pair<int, int>& s) {\n        return p(s.first, s.second);\n    }\n\n    map<string, int> M;\n    void init() { M[\"W\"] = 0; M[\"N\"] = 1; M[\"E\"] = 2; M[\"S\"] = 3; }\n\n    pair<int, int> cr(int x, int y, string f) {\n        vector< pair<int, int> > ds;\n\n        if (x - y > 0) ds.push_back(make_pair(x - y, 0));\n        else ds.push_back(make_pair(0, y - x));\n\n        if (x - (D - y) > 0) ds.push_back(make_pair(x - (D - y), D));\n        else ds.push_back(make_pair(0, x + y));\n\n        if (x + D - y < W) ds.push_back(make_pair(x + D - y, D));\n        else ds.push_back(make_pair(W, y + W - x));\n\n        if (x + y < W) ds.push_back(make_pair(x + y, 0));\n        else ds.push_back(make_pair(W, y - (W - x)));\n\n        //cout << make_pair(x, y) << \" -> \" << ds << endl;\n\n        int p0 = p(ds[ M[f] ]);\n        int p1 = p(ds[ (M[f] + 1) % 4 ]);\n        return make_pair(p0, p1);\n    }\n\n    vector< pair<int, int> > V;\n    void input() {\n        init();\n        cin >> N >> W >> D;\n        for (int i = 0; i < N; i++) {\n            int x, y; string f;\n            cin >> x >> y >> f;\n            V.push_back(cr(x, y, f));\n        }\n        //cout << V << endl;\n    }\n\n    const int INF = 1<<28;\n\n    bool contain(pair<int, int> s, int k) {\n        int x = 2 * (W + D);\n        s.first %= x; s.second %= x;\n        k %= x;\n        if (s.first > s.second) s.second += 2 * (W + D);\n        return (s.first <= k && k <= s.second) || (s.first <= k + x && k + x <= s.second);\n    }\n\n    int calc(int index) {\n        int k = V[index].second;\n        vector< pair<int, int> > T;\n        for (int i = 0; i < N; i++) {\n            if (!contain(V[i], k)) {\n                int x = V[i].first, y = V[i].second;\n                if (x < k) x += 2 * (W + D);\n                if (y < k) y += 2 * (W + D);\n                T.push_back(make_pair(x, y));\n            }\n        }\n        sort(T.begin(), T.end());\n        //cout << \"k: \" << k << \" \" << \"T: \" << T << endl;\n        int c = 0;\n        for (int i = 0, a = 0; a < T.size(); ) {\n            while (i < T.size() && T[i].first <= T[a].second) {\n                i++;\n            }\n            a = i + 1;\n            c++;\n        }\n        return c;\n    }\n\n    void solve() {\n        int ans = INF;\n        for (int i = 0; i < V.size(); i++) {\n            ans = min(ans, calc(i) + 1);\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define REP(i, n) for(int i=0;i<(int)n;i++)\n#define REPS(i, n) for(int i=1;i<=(int)n;i++)\n#define RREP(i, n) for(int i=n-1;i>=0;i--)\n#define RREPS(i, n) for(int i=n;i>0;i--)\n#define ALL(v) v.begin(), v.end()\n#define RALL(v) v.rbegin(), v.rend()\n#define pb push_back\n#define eb emplace_back\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint T, n, w, h;\nint m;\nint place(int x, int y, int dx, int dy){\n\tint step = 10000000;\n\tif(dx > 0) step = min(step, w - x);\n\tif(dx < 0) step = min(step, x);\n\tif(dy > 0) step = min(step, h - y);\n\tif(dy < 0) step = min(step, y);\n\tx += dx * step;\n\ty += dy * step;\n\tif(y == 0) return x;\n\tif(x == w) return w + y;\n\tif(y == h) return 2*w+h - x;\n\tif(x == 0) return 2*w+2*h - y;\n\tassert(false);\n}\n\n\nint solve(vector<pii> rng){\n\tint ans = 1;\n\tint tail = rng[0].first - 1;\n\tint start = tail;\n\tfor(auto it : rng){\n\t\tint s, t;\n\t\ttie(t, s) = it;\n\t\tif(s <= tail) continue;\n\t\tif(start + m < t) continue;\n\t\tans ++;\n\t\ttail = t-1;\n\t}\n\treturn ans;\n}\nint main(){\n\tcin >> n >> w >> h;\n\tm = 2*w+2*h;\n\tvector<pii> rng;\n\tREP(i, n){\n\t\tint x, y;\n\t\tchar f;\n\t\tcin >> x >> y >> f;\n\t\tint s, t;\n\t\tif(f == 'E'){\n\t\t\ts = place(x, y, 1, -1);\n\t\t\tt = place(x, y, 1, 1) + 1;\n\t\t}\n\t\tif(f == 'N'){\n\t\t\ts = place(x, y, 1, 1);\n\t\t\tt = place(x, y, -1, 1) + 1;\n\t\t}\n\t\tif(f == 'W'){\n\t\t\ts = place(x, y, -1, 1);\n\t\t\tt = place(x, y, -1, -1) + 1;\n\t\t}\n\t\tif(f == 'S'){\n\t\t\ts = place(x, y, -1, -1);\n\t\t\tt = place(x, y, 1, -1) + 1;\n\t\t}\n\t\tif(t <= s) t += m;\n\t\trng.eb(t, s);\n\t}\n\tint ans = n;\n\tREP(_, 2*n){\n\t\tsort(ALL(rng));\n\t\tans = min(ans, solve(rng));\n\t\trng[0].first += m;\n\t\trng[0].second += m;\n\t\trng.eb(rng[0]);\n\t\trng.erase(rng.begin());\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\n#define REP(i, n) for(int i=0; i<(n); i++)\n\nusing namespace std;\n\nvector<int> wall[400005];\nint main(){\n\tint n, w, d, x, y;\n\tchar f;\n\t\n\tcin >> n >> w >> d;\n\tfor(int i=1; i<=n; i++){\n\t\tcin >> x >> y >> f;\n\t\tint vx[2], vy[2];\n\t\tif( f == 'W' ){\n\t\t\tvx[0] = -1; vy[0] = -1;\n\t\t\tvx[1] = -1; vy[1] =  1;\n\t\t}else if( f == 'E' ){\n\t\t\tvx[0] =  1; vy[0] =  1;\n\t\t\tvx[1] =  1; vy[1] = -1;\n\t\t}else if( f == 'S' ){\n\t\t\tvx[0] =  1; vy[0] = -1;\n\t\t\tvx[1] = -1; vy[1] = -1;\n\t\t}else if( f == 'N' ){\n\t\t\tvx[0] = -1; vy[0] =  1;\n\t\t\tvx[1] =  1; vy[1] =  1;\n\t\t}\n\t\t//cout << \"vx=\" << vx[0] << endl;\n\t\tREP(k,2){\n\t\t\tint _x = x, _y = y;\n\t\t\twhile( _x > 0 && _x < w && _y > 0 && _y < d ){\n\t\t\t\t_x += vx[k];\n\t\t\t\t_y += vy[k];\n\t\t\t}\n\t\t\tif( _x == 0 ){\n\t\t\t\twall[_y].push_back( i * (1-2*k) );\n\t\t\t}else if( _y == d ){\n\t\t\t\twall[d+_x].push_back( i * (1-2*k) );\n\t\t\t}else if( _x == w ){\n\t\t\t\twall[d+w+d-_y].push_back( i * (1-2*k) );\n\t\t\t}else if( _y == 0 ){\n\t\t\t\twall[d+w+d+w-_x].push_back( i * (1-2*k) );\n\t\t\t}\n\t\t}\n\t}\n\t//REP(i,2*(w+d)) for(auto t: wall[i]){\n\t\t//cout << t << \" \";\n\t//}\n\t//cout << endl;\n\n\tint ans=0x3fffffff;\n\tREP(i,n){\n\t\tbool check[1005]={};\n\t\tint sum=0;\n\t\tint th = i, count = 0, pos=0;\n\t\tvector<int> st;\n\t\twhile( count < n ){\n\t\t\tbool ck=false;\n\t\t\tfor(auto t: wall[pos] ){\n\t\t\t\tif( t>0 ){\n\t\t\t\t\tif( th-- > 0 ) continue;\n\t\t\t\t\tst.push_back( t );\n\t\t\t\t}else{\n\t\t\t\t\tif( th > 0 ) continue;\n\t\t\t\t\tif( check[abs(t)] ) continue;\n\t\t\t\t\tck = true;\n\t\t\t\t\tst.push_back( abs(t) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( ck ){\n\t\t\t\t\tsum++;\n\t\t\t\t\tfor(auto l: st){\n\t\t\t\t\t\tif( !check[abs(l)] ) count++;\n\t\t\t\t\t\tcheck[abs(l)] = true;\n\t\t\t\t\t}\n\t\t\t\t\tst.clear();\n\t\t\t\t\t//cout << \"pos:\" << pos << \" count:\" << count << endl;\n\t\t\t}\n\t\t\tpos++; if( pos > 2*(d+w) ) pos = 0;\n\t\t\t//cout << \"next\" << pos << endl;\n\t\t}\n\t\tans = min( ans, sum );\n\t}\n\t\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\nstruct Range{\n    int b, e;\n    bool operator < (const Range& r) const {\n        if(b != r.b) return b < r.b;\n        return e < r.e;\n    }\n};\nint N, W, H;\nint solve(vector<Range> ranges) {\n    sort(ranges.begin(), ranges.end());\n    vector<Range> rs;\n    vector<Range> rs2;\n    const int L = 2 * (W + H);\n    REP(i, ranges.size()) {\n        if(rs.empty() || rs.back().e < ranges[i].e) {\n            rs.push_back(ranges[i]);\n            rs2.push_back({ranges[i].b + L, ranges[i].e + L});\n        }\n    }\n    REP(i, rs2.size()) rs.push_back(rs2[i]);\n    sort(rs.begin(), rs.end());\n    int n = rs.size() / 2;\n    int ans = INT_MAX;\n    // cout << \"L: \" << L << endl;\n    for(int s = 0; s < n; s++) {\n        int sub = 0;\n        // cout << \"s: \" << s << endl;\n        for(int i = s; i < 2 * n;) {\n            if(i >= s + n) break;\n            const int take = rs[i].e;\n            // cout << \"take: \" << take << endl;\n            while(i < s + n && rs[i].b <= take && take <= rs[i].e) {\n                // cout << \"ok: \" << i << endl;\n                i++;\n            }\n            sub++;\n        }\n        // cout << sub << endl;\n        ans = min(ans, sub);\n    }\n    return ans;\n}\nvoid move(int& x, int& y, int dx, int dy) {\n    int t = INT_MAX;\n    if(dx == -1) t = min(t, x);\n    if(dx == +1) t = min(t, (W-1) - x);\n    if(dy == -1) t = min(t, y);\n    if(dy == +1) t = min(t, (H-1) - y);\n    x += t * dx;\n    y += t * dy;\n}\nint convert(int x, int y) {\n    if(x == 0 && y == 0) return 0;\n    if(y == 0) {\n        return x;\n    }\n    if(x == W - 1) {\n        return W + y;\n    }\n    if(y == H - 1) {\n        return W + H + (W - 1 - x);\n    }\n    assert(x == 0);\n    return W + H + W + (H - 1 - y);\n}\nint main(){\n    iostream_init();\n    while(cin >> N >> W >> H) {\n        W++; H++;\n        vector<Range> ranges;\n        REP(i, N) {\n            int x, y;\n            cin >> x >> y;\n            string F;\n            cin >> F;\n            int lx = x, ly = y;\n            int rx = x, ry = y;\n            if(F == \"N\") {\n                // up\n                move(lx, ly, +1, +1);\n                move(rx, ry, -1, +1);\n            } else if(F == \"E\") {\n                // right\n                move(lx, ly, +1, -1);\n                move(rx, ry, +1, +1);\n            } else if(F == \"S\") {\n                // down\n                move(lx, ly, -1, -1);\n                move(rx, ry, +1, -1);\n            } else if(F == \"W\") {\n                // left\n                move(lx, ly, -1, +1);\n                move(rx, ry, -1, -1);\n            }\n            int L = convert(lx, ly);\n            int R = convert(rx, ry);\n            if(L > R) R += 2 * (W + H); // ok ???\n            ranges.push_back({L, R});\n        }\n        // REP(i, ranges.size()) {\n        //     cout << \"(\" << ranges[i].b << \",\" << ranges[i].e << \") \";\n        // }\n        // cout << endl;\n        cout << solve(ranges) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\tint n, w, d;\n\twhile(cin >> n >> w >> d){\n\t\tvector< pair<int, int> > base;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x, y; char f;\n\t\t\tcin >> x >> y >> f;\n\t\t\tint a, b;\n\t\t\tif(f == 'S'){\n\t\t\t\ta = x;\n\t\t\t\tb = y;\n\t\t\t} else if(f == 'E'){\n\t\t\t\ta = w+y;\n\t\t\t\tb = w-x;\n\t\t\t} else if(f == 'N') {\n\t\t\t\ta = w+d+w-x;\n\t\t\t\tb = d-y;\n\t\t\t} else if(f == 'W'){\n\t\t\t\ta = 2*w+d+d-y;\n\t\t\t\tb = x;\n\t\t\t}\n\t\t\tbase.push_back(make_pair(a-b, a+b));\n\t\t}\n\t\tint res = n;\n\t\tvector< pair<int, int> > vp(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint start = base[i].second;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tvp[j] = base[j];\n\t\t\t\tif(vp[j].second < start){\n\t\t\t\t\tvp[j].first += 2*(w+d);\n\t\t\t\t\tvp[j].second += 2*(w+d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 1, pos = start;\n\t\t\tsort(vp.begin(), vp.end(), [](const pair<int, int>& a, const pair<int, int>& b){ return a.second == b.second ? a.first < b.first : a.second < b.second; });\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(vp[j].first > pos){\n\t\t\t\t\t++cnt;\n\t\t\t\t\tpos = vp[j].second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = min(res, cnt);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n  int n, w, d;\n  cin >> n >> w >> d;\n  vector<pair<int,int>> ps;\n  // mapping to the south-west corner \n  auto mapping0 = [](int x, int y) {\n    return x - y;\n  };\n  // mapping in one of four directions\n  auto mappingX = [w,d,&mapping0](int x, int y, int dir) {\n    switch(dir) {\n    case 0 : { // (-1, -1)-direction\n      int o = mapping0(x, y);\n      return o; // o >= 0 ? o : w + w + d + d + o; // normalization\n    }\n    case 1 : { // (1, -1)-direction\n      int o = mapping0(w-x, y); // flipping in x\n      return w - o; // o >= 0 ? w - o : w + (- o);\n    }\n    case 2 : { // (1, 1)-direction\n      int o = mapping0(w-x, d-y); // flipping in x and y\n      return w + d + o; // o >= 0 ? w + d + o : w + d + o;\n    }\n    case 3 : { // (-1, 1)-direction\n      int o = mapping0(x, d-y); // flipping in y\n      return w + d + w - o; // o >= 0 ? w + d + w - o : w + d + w + -o;\n    }\n    return -1;\n    }\n  };\n  // mapping to a range\n  auto make_range = [w,d,&mappingX](int x, int y, char c) {\n    switch(c){\n    case 'N': return make_pair(mappingX(x, y, 2), mappingX(x, y, 3));\n    case 'E': return make_pair(mappingX(x, y, 1), mappingX(x, y, 2));\n    case 'S': {\n      int s = mappingX(x, y, 0);\n      int e = mappingX(x, y, 1);\n      return make_pair(s, e);\n    }\n    case 'W': {\n      int s = mappingX(x, y, 3);\n      int e = mappingX(x, y, 0) + w + w + d + d;\n      if(e > w + w + d + d) {\n        s -= + w + w + d + d;\n        e -= + w + w + d + d;\n      }\n      return make_pair(s, e);\n    }\n    }\n    return make_pair(-10, -10);\n  };\n  \n  auto sw = [](const pair<int,int> p) {\n    return make_pair(p.second, p.first);\n  };\n  \n  for(int i = 0; i < n; i++) {\n    int x, y, d;\n    char c;\n    cin >> x >> y;\n    cin >> c;\n    ps.push_back(sw(make_range(x, y, c)));\n  }\n  // a desk = a range on walls\n  // a lock = a point on walls\n  // todo: put points so that every range contains a point\n\n  // sort the ranges\n  sort(ps.begin(), ps.end());\n\n  // shrink the region (endpoint ee) by the range r\n  auto wrap = [d,w](bool aug, int a) {\n    return aug ? a + d + d + w + w : a;\n  };\n\n  auto contains = [d,w,&ps](int i, int x) {\n    int s = ps[i].second;\n    int e = ps[i].first;\n    if(s <= x && x <= e) return true;\n    int y = x + d + d + w + w;\n    if(s <= y && y <= e) return true;\n    int z = x - (d + d + w + w);\n    if(s <= z && z <= e) return true;\n    return false;\n  };\n\n  // locating clocks from i's view\n  auto count = [&ps,n,&wrap,&contains](const int ii){\n    int i = ii;\n    int k = 0;\n    int cnt = 0;\n    while(k < n) {\n      int e = ps[i].first; //wrap(i < ii, ps[i].first);\n      int kk = k;\n      k++;\n      i = (i + 1) % n;\n      while(k < n && contains(i, e)) {\n        i = (i + 1) % n;\n        k++;\n      }\n      cnt++;\n    }\n    return cnt;\n  };\n  \n\n  int cnt = n; // at most n\n  // possible starting points\n  for(int i = 0; i < n; i++) {\n    cnt = min(cnt, count(i));\n  }\n  cout << cnt << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\n#include <ctype.h> // isdigit\n#include <cassert>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(u) begin(u),end(u)\n#define PB push_back\n#define LE(n,m) ((n) < (m) + EPS * (abs(n) + abs(m)))\n#define GE(n,m) ((n) + EPS * (abs(n) + abs(m)) > (m))\n#define LT(n,m) ((n) + EPS * (abs(n) + abs(m)) < (m))\n#define GT(n,m) ((n) > (m) + EPS * (abs(n) + abs(m)))\n#define EQ(n,m) (abs((n)-(m)) < EPS * (abs(n) + abs(m)))\n\ntypedef long long int ll;\nconst int INF = (1<<30) - 1;\nconst double EPS = 1e-9;\nconst int MOD = 1000000007;\n\ntypedef complex<double> P;\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    //cout.setf(ios::fixed);\n    \n    int N, W, D;\n    cin >> N >> W >> D;\n    int L = 2 * (W + D);\n    //end, start\n    vector<pair<int, int>> lines;\n    \n    for(int i=0; i<N; i++){\n        int x, y; string f;\n        cin >> x >> y >> f;\n        P p = P(x, y);\n        P p1 = P(W, 0);\n        P p2 = P(W, D);\n        P p3 = P(0, D);\n        P C = P(0, -1);\n        \n        switch (f[0]) {\n            case 'W':\n                p = (p - p3) * C + p3;\n            case 'N':\n                p = (p - p2) * C + p2;\n            case 'E':\n                p = (p - p1) * C + p1;\n            default:\n                break;\n        }\n        \n        lines.emplace_back(p.real()+p.imag(), p.real()-p.imag());\n    }\n    sort(lines.begin(), lines.end());\n    \n    int ans = INF;\n    for(int s=0; s<N; s++){\n        int tans = 0;\n        int p = lines[0].first;\n        for(int i=0; i<N; i++){\n            while(i<N && lines[i%N].second <= p) i++;\n            p = lines[i--%N].first;\n            tans++;\n        }\n        ans = min(ans, tans);\n        \n        lines[0].first += L;\n        lines[0].second += L;\n        sort(lines.begin(), lines.end());\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\nstruct Range{\n    int b, e;\n    bool operator < (const Range& r) const {\n        if(b != r.b) return b < r.b;\n        return e < r.e;\n    }\n};\nint N, W, H;\nint solve(vector<Range> ranges) {\n    const int n = ranges.size();\n    const int L = 2 * (W + H);\n    sort(ranges.begin(), ranges.end(), [&](Range a, Range b){ if(a.e != b.e) return a.e < b.e; return a.b < b.b;});\n    REP(i, n) ranges.push_back({ranges[i].b + L, ranges[i].e + L});\n    int ans = INT_MAX;\n    REP(s, n) {\n        vector<pair<int, int>> events;\n        REP(i, n) {\n            events.push_back(make_pair(ranges[s+i].b, -(i+1)));\n            events.push_back(make_pair(ranges[s+i].e, (i+1)));\n        }\n        sort(events.begin(), events.end());\n        vector<bool> used(n);\n        vector<int> list;\n        int sub = 0;\n        REP(i, events.size()) {\n            int idx = abs(events[i].second) - 1;\n            if(events[i].second < 0) {\n                list.push_back(idx);\n            } else {\n                if(!used[idx]) {\n                    sub++;\n                    for(int x : list) {\n                        used[x] = true;\n                    }\n                    list.clear();\n                }\n            }\n        }\n        ans = min(ans, sub);\n    }\n    return ans;\n}\n// int solve(vector<Range> ranges) {\n//     sort(ranges.begin(), ranges.end());\n//     vector<Range> rs;\n//     vector<Range> rs2;\n//     const int L = 2 * (W + H);\n//     REP(i, ranges.size()) {\n//         // if(rs.empty() || rs.back().e < ranges[i].e) {\n//             rs.push_back(ranges[i]);\n//             rs2.push_back({ranges[i].b + L, ranges[i].e + L});\n//         // }\n//     }\n//     REP(i, rs2.size()) rs.push_back(rs2[i]);\n//     sort(rs.begin(), rs.end(), [&](Range a, Range b){ if(a.e != b.e) return a.e < b.e; return a.b < b.b;});\n//     int n = rs.size() / 2;\n//     int ans = INT_MAX;\n//     for(int s = 0; s < n; s++) {\n//         int sub = 0;\n//         for(int i = s; i < 2 * n;) {\n//             if(i >= s + n) break;\n//             const int take = rs[i].e;\n//             while(i < s + n && rs[i].b <= take && take <= rs[i].e) {\n//                 i++;\n//             }\n//             sub++;\n//         }\n//         ans = min(ans, sub);\n//     }\n//     return ans;\n// }\nvoid move(int& x, int& y, int dx, int dy) {\n    int t = INT_MAX;\n    if(dx == -1) t = min(t, x);\n    if(dx == +1) t = min(t, (W-1) - x);\n    if(dy == -1) t = min(t, y);\n    if(dy == +1) t = min(t, (H-1) - y);\n    x += t * dx;\n    y += t * dy;\n}\nint convert(int x, int y) {\n    if(x == 0 && y == 0) return 0;\n    if(y == 0) {\n        return x;\n    }\n    if(x == W - 1) {\n        return W + y;\n    }\n    if(y == H - 1) {\n        return W + H + (W - 1 - x);\n    }\n    assert(x == 0);\n    return W + H + W + (H - 1 - y);\n}\nint main(){\n    iostream_init();\n    while(cin >> N >> W >> H) {\n        W++; H++;\n        vector<Range> ranges;\n        REP(i, N) {\n            int x, y;\n            cin >> x >> y;\n            string F;\n            cin >> F;\n            int lx = x, ly = y;\n            int rx = x, ry = y;\n            if(F == \"N\") {\n                // up\n                move(lx, ly, +1, +1);\n                move(rx, ry, -1, +1);\n            } else if(F == \"E\") {\n                // right\n                move(lx, ly, +1, -1);\n                move(rx, ry, +1, +1);\n            } else if(F == \"S\") {\n                // down\n                move(lx, ly, -1, -1);\n                move(rx, ry, +1, -1);\n            } else if(F == \"W\") {\n                // left\n                move(lx, ly, -1, +1);\n                move(rx, ry, -1, -1);\n            }\n            int L = convert(lx, ly);\n            int R = convert(rx, ry);\n            if(L > R) R += 2 * (W + H); // ok ???\n            ranges.push_back({L, R});\n        }\n        // REP(i, ranges.size()) {\n        //     cout << \"(\" << ranges[i].b << \",\" << ranges[i].e << \") \";\n        // }\n        // cout << endl;\n        cout << solve(ranges) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n,w,h;\nint pos(int x,int y){\n  if(y==0) return x;\n  if(y==h) return w+h+(w-x);\n  if(x==0) return w+h+w+(h-y);\n  if(x==w) return w+y;\n  assert(0);\n}\ntypedef pair<int,int> P;\nsigned main(){\n  cin>>n>>w>>h;\n  int x[n],y[n];\n  char f[n];\n  for(int i=0;i<n;i++) cin>>x[i]>>y[i]>>f[i];\n  vector<P> v;\n  for(int i=0;i<n;i++){\n    int a,b,c,d;\n    a=min(w-x[i],h-y[i]);\n    b=min(w-x[i],y[i]);\n    c=min(x[i],y[i]);\n    d=min(x[i],h-y[i]);\n    int l,r;\n    if(f[i]=='E'){\n      r=pos(x[i]+a,y[i]+a);\n      l=pos(x[i]+b,y[i]-b);\n    }\n    if(f[i]=='S'){\n      r=pos(x[i]+b,y[i]-b);\n      l=pos(x[i]-c,y[i]-c);\n    }\n    if(f[i]=='W'){\n      r=pos(x[i]-c,y[i]-c);\n      l=pos(x[i]-d,y[i]+d);\n    }\n    if(f[i]=='N'){\n      r=pos(x[i]-d,y[i]+d);\n      l=pos(x[i]+a,y[i]+a);\n    }\n    if(r<l) r+=2*(w+h);\n    v.push_back(P(l,r));\n  }\n\n  //for(int i=0;i<n;i++) cout<<v[i].first<<\" \"<<v[i].second<<endl;\n  \n  bool ovlp[n];\n  for(int i=0;i<n;i++){\n    ovlp[i]=0;\n    for(int j=0;j<n;j++)\n      ovlp[i]|=(i!=j)&&(v[j].first<=v[i].first&&v[i].second<=v[j].second);\n    //cout<<i<<\" \"<<ovlp[i]<<endl;\n  }\n  \n  for(int i=n-1;i>=0;i--) if(ovlp[i]) v.erase(v.begin()+i),n--;\n  sort(v.begin(),v.end());\n  for(int i=0;i<n;i++)\n    v.push_back(P(v[i].first+2*(w+h),v[i].second+2*(w+h)));\n\n  int ans=n;\n  for(int i=0;i<n;i++){\n    int tmp=0;\n    int j=i,p;\n    while(j<i+n){\n      tmp++;\n      p=v[j].second;\n      while(j<i+n&&v[j].first<=p) j++;\n    }\n    ans=min(ans,tmp);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint w,d;\n\nstruct node\n{\n    int x,y;\n    int l;\n    int r;\n}p[1010];\n\nbool cmp(node a,node b)\n{\n    if(a.l==b.l)\n    {\n        return a.r>=b.r;\n    }\n    else return a.l<b.l;\n}\nvoid cal1(int i)\n{\n   p[i].r=3*w+2*d-p[i].y-p[i].x;\n   p[i].l=w+2*d+p[i].x-p[i].y;\n   //printf(\"%d %d\\n\",p[i].l,p[i].r);\n}\n\nvoid cal2(int i)\n{\n   p[i].r=3*w+2*d+p[i].y-p[i].x;\n   p[i].l=3*w+2*d-p[i].x-p[i].y;\n   //printf(\"%d %d\\n\",p[i].l,p[i].r);\n}\n\nvoid cal3(int i)\n{\n   p[i].l=w+p[i].y-p[i].x;\n   p[i].r=w+p[i].y+p[i].x;\n   //printf(\"%d %d\\n\",p[i].l,p[i].r);\n}\n\nvoid cal4(int i)\n{\n   p[i].l=w+p[i].x+p[i].y;\n   p[i].r=w+2*d+p[i].x-p[i].y;\n   //printf(\"%d %d\\n\",p[i].l,p[i].r);\n}\n\nvoid Input(int i)\n{\n    char s[2];\n    scanf(\"%d%d\",&p[i].x,&p[i].y);\n    scanf(\"%s\",s);\n    if(s[0]=='E')\n    {\n        cal1(i);\n    }\n    else if(s[0]=='S')\n    {\n        cal2(i);\n    }\n    else if(s[0]=='W')\n    {\n        cal3(i);\n    }\n    else if(s[0]=='N')\n    {\n        cal4(i);\n    }\n    if(p[i].l>=2*w+2*d)\n    {\n        p[i].l=p[i].l-2*w-2*d;\n        p[i].r=p[i].r-2*w-2*d;\n    }\n    //printf(\"%d %d\\n\",p[i].l,p[i].r);\n    return;\n}\nint main()\n{\n    int n;\n    while(~scanf(\"%d\",&n))\n    {\n        memset(p,-1,sizeof(p));\n        scanf(\"%d%d\",&w,&d);\n        for(int i = 0; i < n; i++)\n        {\n            Input(i);\n        }\n        sort(p,p+n,cmp);\n        node b[1010];\n        b[0]=p[0];\n        int cnt1=0;int cnt2=0;\n        int flag=0,k=-1;\n        int i,j;\n        for(i = 1; i < n; i++)\n        {\n            if(p[i].l<=b[cnt2].r)\n            {\n                b[cnt2].l=p[i].l;\n                if(p[i].r<=b[cnt2].r)\n                    b[cnt2].r=p[i].r;\n            }\n\n            else\n                {\n                    b[++cnt2]=p[i];\n                    if(b[cnt2].r>=2*w+2*d&&flag==0)\n                    {\n                        k=cnt2;\n                        flag=1;\n                    }\n                }\n        }\n\n        for(i = k; i < cnt2+1; i++)\n        {\n            for(j = cnt1; j < cnt2+1; j++)\n            {\n                if(b[j].l>=b[i].l-2*w-2*d&&b[j].r<=b[i].r-2*w-2*d)\n                {\n                    b[i].l=b[j].l+2*w+2*d;\n                    b[i].r=b[j].r+2*w+2*d;\n                    cnt1++;\n                }\n            }\n        }\n        printf(\"%d\\n\",cnt2-cnt1+1);\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <tuple>\n\nusing namespace std;\ntypedef pair<int, int> pii;\nstatic const int INF = 1000000000;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tvector<pii> ranges;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x, y;\n\t\tstring f;\n\t\tcin >> x >> y >> f;\n\t\tconst int hw2 = h + w + h + w;\n\t\tconst int lu = y + x;\n\t\tconst int ru = h + x + (h - y);\n\t\tconst int rd = h + w + (h - y) + (w - x);\n\t\tconst int ld = h + w + h + (w - x) + y;\n\t\tint lo = 0, hi = 0;\n\t\tif(f[0] == 'N'){\n\t\t\tlo = lu; hi = ru;\n\t\t}else if(f[0] == 'E'){\n\t\t\tlo = ru; hi = rd;\n\t\t}else if(f[0] == 'S'){\n\t\t\tlo = rd; hi = ld;\n\t\t}else if(f[0] == 'W'){\n\t\t\tlo = ld; hi = lu + hw2;\n\t\t}\n\t\tif(lo >= hw2){\n\t\t\tlo -= hw2;\n\t\t\thi -= hw2;\n\t\t}\n\t\tranges.emplace_back(lo, hi);\n\t\tranges.emplace_back(lo + hw2, hi + hw2);\n\t\tranges.emplace_back(lo + 2 * hw2, hi + 2 * hw2);\n\t\tranges.emplace_back(lo + 3 * hw2, hi + 3 * hw2);\n\t}\n\tsort(\n\t\tranges.begin(), ranges.end(),\n\t\t[](const pii &a, const pii &b){\n\t\t\treturn (a.second == b.second) ? (a.first < b.first) : (a.second < b.second);\n\t\t});\n\tint answer = INF;\n\tfor(int i = 0; i < 3 * n; ++i){\n\t\tconst int hw2 = (h + w) * 2;\n\t\tvector<pii> r(ranges.begin() + i, ranges.begin() + i + n);\n\t\tint count = 1, last = r[0].second;\n\t\tfor(int j = 0; j < n; ++j){\n\t\t\tif(r[j].first <= last){ continue; }\n\t\t\tif(r[j].second >= r[0].second + hw2){ continue; }\n\t\t\t++count;\n\t\t\tlast = r[j].second;\n\t\t}\n\t\tanswer = min(answer, count);\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P1;\nint n,w,d,x,y,ans;\nvector<P1> v;\nchar f;\nstack<int> q;\nbool used[N];\n\nvoid add_point(int num){\n  if(f=='N'){\n    if(x+y<d)v.push_back(P1(P(x+y+w*2+d,0),num));\n    else v.push_back(P1(P(x+y-d,0),num));\n    if(w+y-x<d)v.push_back(P1(P(d-(w+y-x)+w,1),num));\n    else v.push_back(P1(P(d-(y-x),1),num));\n  }\n  if(f=='E'){\n    if(d-(y-x)<w)v.push_back(P1(P(d-(y-x),0),num));\n    else v.push_back(P1(P(d-(w+(y-x))+w,0),num));\n    if(y+x<w)v.push_back(P1(P(w-(y+x)+w+d,1),num));\n    else v.push_back(P1(P(d-(-w+y+x)+w,1),num));\n  }\n  if(f=='S'){\n    if(0<=-w+y+x)v.push_back(P1(P(d-(-w+y+x)+w,0),num));\n    else v.push_back(P1(P(w-(y+x)+w+d,0),num));\n    if(0<=y-x)v.push_back(P1(P(y-x+w*2+d,1),num));\n    else v.push_back(P1(P(w-(-(y-x))+w+d,1),num));\n  }\n  if(f=='W'){\n    if(0<=-(y-x))v.push_back(P1(P(w-(-(y-x))+w+d,0),num));\n    else v.push_back(P1(P(y-x+w*2+d,0),num));\n    if(0<=y+x-d)v.push_back(P1(P(y+x-d,1),num));\n    else v.push_back(P1(P(y+x+w*2+d,1),num));\n  }\n}\n\nbool usednum[500000];\n\nvoid solve(){\n  int len=v.size(),cnt;\n  for(int i=0;i<len;i++){\n    memset(used,0,sizeof(used));\n    memset(usednum,0,sizeof(usednum));\n    if(v[i].first.second)continue;\n    cnt=0;\n    for(int j=i;j<len+i;j++){\n      int idx=j%len;\n      if(used[v[idx].second]){\n\tif(!v[idx].first.second)break;\n\telse continue;\n      }\n      if(!v[idx].first.second)q.push(v[idx].second);\n      else{\n\tcnt++;\n\tif(usednum[v[idx].first.first])cnt--;\n\tusednum[v[idx].first.first]=true;\n\tused[v[idx].second]=true;\n\tint flag=0;\n\twhile(!q.empty()){\n\t  int num=q.top(); q.pop();\n\t  if(num==v[idx].second)flag=1;\n\t  used[num]=true;\n\t}\n      }\n    }\n    ans=min(ans,cnt);\n  }\n}\n\nint main(){\n  cin>>n>>w>>d;\n  for(int i=0;i<n;i++){\n    cin>>x>>y>>f;\n    add_point(i);\n  }\n  sort(v.begin(),v.end());\n  /*  for(int i=0;i<v.size();i++)\n      cout<<v[i].first.first<<' '<<v[i].first.second<<' '<<v[i].second<<endl;*/\n  ans=(1e9);\n  solve();\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> pii;\nconst int INF = 1e9;\n\nstruct s {\n\tint ps,pp;\n\tint idx;\n\ts(){}\n\ts(int ps_, int pp_, int idx_) {\n\t\tps = ps_; pp = pp_; idx = idx_;\n\t}\n};\n\nbool operator<(s a, s b) {\n\treturn a.pp > b.pp;\n}\n\nint main() {\n\tint n, w, d;\n\tvector<pii> v;\n\tcin >> n >> w >> d;\n\tfor(int i = 0; i < n; i++) {\n\t\tint x, y;\n\t\tchar f;\n\t\tint nx, ny;\n\t\tcin >> x >> y >> f;\n\t\tswitch(f) {\n\t\t\tcase 'N':\n\t\t\t\tnx = w-x;\n\t\t\t\tny = d-y;\n\t\t\t\tbreak;\n\t\t\tcase 'W':\n\t\t\t\tnx = w + d-y;\n\t\t\t\tny = x;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tnx = w+d + x;\n\t\t\t\tny = y;\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\tnx = w+d+w + y;\n\t\t\t\tny = w-x;\n\t\t\t\tbreak;\n\t\t}\n\t\tint ps, pp;\n\t\tps = nx - ny;\n\t\tpp = nx + ny;\n\t\tv.push_back(pii(ps,pp));\n\t}\n\n\tsort(v.begin(), v.end());\n\tint res = 10000;\n//-----\n\tfor(int i = 0; i < v.size(); i++) {\n\t\tvector<pii> vv;\n\t\tvector<int> pushed(n,0);\n\n\t\tvv.resize(v.size());\n\t\tpushed[0] = 1;\n\t\tfor(int j = 0; j < v.size(); j++) {\n\t\t\tvv[j].fi = (v[(i+j)%n].fi - v[i].fi + 4*(w+d)) % (2*(w+d));\n\t\t\tvv[j].se = (v[(i+j)%n].se - v[i].fi + 4*(w+d)) % (2*(w+d));\n\t\t\tif(vv[j].fi > vv[j].se) vv[j].se += 2*(w+d);\n\t\t}\n\n\t\tfor(int j = 0; j < vv.size(); j++) {\n\t\t\tif(2*(w+d) <= vv[j].se || vv[j].fi == 0) {\n\t\t\t\tpushed[j] = 1;\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<s> pq;\n\t\tint tmp = 1;\n\t\tfor(int j = 1; j < vv.size(); j++)  {\n\t\t\tif(!pushed[j]) {\n\t\t\t\tif(pq.empty() || vv[j].fi <= pq.top().pp) {\n\t\t\t\t\tpq.push(s(vv[j].fi,vv[j].se,j));\n\t\t\t\t\tpushed[j] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twhile(pq.size()) pq.pop();\n\t\t\t\t\ttmp++;\n\t\t\t\t\tpq.push(s(vv[j].fi,vv[j].se,j));\n\t\t\t\t\tpushed[j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(pq.size()) tmp++;\n\t\tres = min(res,tmp);\n\t}\n//-----\n\tfor(int i = 0; i < v.size(); i++) {\n\t\tvector<pii> vv;\n\t\tvector<int> pushed(n,0);\n\n\t\tvv.resize(v.size());\n\t\tpushed[0] = 1;\n\t\tfor(int j = 0; j < v.size(); j++) {\n\t\t\tvv[j].fi = (v[(i+j)%n].fi - v[i].se + 4*(w+d)) % (2*(w+d));\n\t\t\tvv[j].se = (v[(i+j)%n].se - v[i].se + 4*(w+d)) % (2*(w+d));\n\t\t\tif(vv[j].fi > vv[j].se) vv[j].se += 2*(w+d);\n\t\t}\n\n\t\tfor(int j = 0; j < vv.size(); j++) {\n\t\t\tif(2*(w+d) <= vv[j].se || vv[j].fi == 0) {\n\t\t\t\tpushed[j] = 1;\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<s> pq;\n\t\tint tmp = 1;\n\t\tfor(int j = 1; j < vv.size(); j++)  {\n\t\t\tif(!pushed[j]) {\n\t\t\t\tif(pq.empty() || vv[j].fi <= pq.top().pp) {\n\t\t\t\t\tpq.push(s(vv[j].fi,vv[j].se,j));\n\t\t\t\t\tpushed[j] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twhile(pq.size()) pq.pop();\n\t\t\t\t\ttmp++;\n\t\t\t\t\tpq.push(s(vv[j].fi,vv[j].se,j));\n\t\t\t\t\tpushed[j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(pq.size()) tmp++;\n\t\tres = min(res,tmp);\n\t}\n//-----\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\tint n, w, d;\n\twhile(cin >> n >> w >> d){\n\t\tvector< pair<int, int> > base;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x, y; char f;\n\t\t\tcin >> x >> y >> f;\n\t\t\tint a, b;\n\t\t\tif(f == 'S'){\n\t\t\t\ta = x;\n\t\t\t\tb = y;\n\t\t\t} else if(f == 'E'){\n\t\t\t\ta = w+y;\n\t\t\t\tb = w-x;\n\t\t\t} else if(f == 'N') {\n\t\t\t\ta = w+d+w-x;\n\t\t\t\tb = d-y;\n\t\t\t} else if(f == 'W'){\n\t\t\t\ta = 2*w+d+d-y;\n\t\t\t\tb = x;\n\t\t\t}\n\t\t\tbase.push_back(make_pair(a-b, a+b));\n\t\t}\n\t\tint res = n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tvector< pair<int, int> > vp;\n\t\t\tint start = base[i].second;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tbool ok = false;\n\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\tif(base[j].first+k*2*(w+d) <= start && start <= base[j].second+k*2*(w+d)) ok = true;\n\t\t\t\t}\n\t\t\t\tif(ok) continue;\n\t\t\t\tvp.push_back(base[j]);\n\t\t\t\tif(vp.back().second < start){\n\t\t\t\t\tvp.back().first += 2*(w+d);\n\t\t\t\t\tvp.back().second += 2*(w+d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 1, pos = start;\n\t\t\tsort(vp.begin(),\n\t\t\t\t vp.end(),\n\t\t\t\t [](const pair<int, int>& a, const pair<int, int>& b){\n\t\t\t\t\treturn a.second == b.second ? a.first < b.first : a.second < b.second;\n\t\t\t\t });\n\t\t\tfor(int j=0;j<vp.size();j++){\n\t\t\t\tif(vp[j].first > pos){\n\t\t\t\t\t++cnt;\n\t\t\t\t\tpos = vp[j].second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = min(res, cnt);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\n#include <queue>\n\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define ft first\n#define sd second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef queue<int> QI;\n\nconst LL mod=1000000007;\nLL powmod(LL a,LL b) {LL res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint n,w,d,p[23];\n\nstruct node{\n    int x,y,l,r,to;\n    bool ab=true;\n    void read(){\n        int x1,y1;char c;\n        scanf(\"%d%d %c\",&x1,&y1,&c);\n        x=x1;y=y1;if(c=='N')to=1;else if(c=='E')to=2;else if(c=='S')to=3;else to=4;\n    }\n    void work(){\n        if(to==1){\n            int s=d-y,yo=w-x;\n            if(x>s)l=x-s;\n            else l=p[4]+y+x;\n            if(yo>s)r=x+s;\n            else r=p[2]+(s-yo);\n        }else if(to==2){\n            int s=d-y,yo=w-x;\n            if(yo>s)l=x+s;\n            else l=p[2]+(s-yo);\n            if(yo>y)r=p[3]+yo-y;\n            else r=p[2]+s+yo;\n        }else if(to==3){\n            int s=d-y,yo=w-x;\n            if(yo>y)l=p[3]+yo-y;\n            else l=p[2]+s+yo;\n            if(x>y)r=p[3]+yo+y;\n            else r=p[4]+y-x;\n        }else{\n            int s=d-y,yo=w-x;\n            if(x>y)l=p[3]+yo+y;\n            else l=p[4]+y-x;\n            if(x>s)r=x-s;\n            else r=p[4]+y+x;\n        }\n        if(r<l)r+=w+w+d+d;\n    }\n}a[2333];\n\nbool cmp(node x,node y){\n    if(x.l==y.l)return x.r<y.r;\n    else return x.l<y.l;\n}\n\nint work(int x){\n    int now=-1,re=0;\n    rep(i,x,n){\n      //  cout<<\"!!!\"<<i<<a[i].ab<<endl;\n        if(a[i].ab){\n            if(now>=a[i].l && now<=a[i].r)continue;\n            else now=a[i].r,re++;\n        }\n    }\n    rep(i,0,x){\n      //  cout<<\"!!!\"<<i<<a[i].ab<<endl;\n        if(a[i].ab){\n            if(now>=(a[i].l+w+w+d+d)&&now<=(a[i].r+w+w+d+d))continue;\n            else now=a[i].r+w+w+d+d,re++;\n        }\n    }\n    return re;\n}\n\nint main(){\n    scanf(\"%d%d%d\",&n,&w,&d);p[1]=0;p[2]=w;p[3]=w+d;p[4]=w+d+w;\n    rep(i,0,n){a[i].read();a[i].work();}\n    sort(a,a+n,cmp);\n    int ans=23333;\n    rep(i,0,n){\n        rep(j,0,n){\n            if(i==j)continue;\n            if(a[i].ab && a[j].ab){\n                if(a[i].l<=a[j].l && a[i].r>=a[j].r)a[i].ab=false;\n                if(a[i].l<=(a[j].l+w+w+d+d)&&a[i].r>=(a[j].r+w+w+d+d))a[i].ab=false;\n            }\n        }\n    }\n    rep(i,0,n){\n        ans=min(ans,work(i));\n    }\n   /* rep(i,0,n){\n        if(a[i].ab)cout<<a[i].l<<' '<<a[i].r<<endl;\n    }*/\n    cout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint w,d;\n\nstruct node\n{\n    int x,y;\n    int l;\n    int r;\n    int flag;\n}p[1010];\n\nbool cmp(node a,node b)\n{\n    if(a.l==b.l)\n    {\n        return a.r>=b.r;\n    }\n    else return a.l<b.l;\n}\nvoid cal1(int i)\n{\n   p[i].r=3*w+2*d-p[i].y-p[i].x;\n   p[i].l=w+2*d+p[i].x-p[i].y;\n   //printf(\"%d %d\\n\",p[i].l,p[i].r);\n}\n\nvoid cal2(int i)\n{\n   p[i].r=3*w+2*d+p[i].y-p[i].x;\n   p[i].l=3*w+2*d-p[i].x-p[i].y;\n   //printf(\"%d %d\\n\",p[i].l,p[i].r);\n}\n\nvoid cal3(int i)\n{\n   p[i].l=w+p[i].y-p[i].x;\n   p[i].r=w+p[i].y+p[i].x;\n   //printf(\"%d %d\\n\",p[i].l,p[i].r);\n}\n\nvoid cal4(int i)\n{\n   p[i].l=w+p[i].x+p[i].y;\n   p[i].r=w+2*d+p[i].x-p[i].y;\n   //printf(\"%d %d\\n\",p[i].l,p[i].r);\n}\n\nvoid Input(int i)\n{\n    char s[2];\n    scanf(\"%d%d\",&p[i].x,&p[i].y);\n    scanf(\"%s\",s);\n    if(s[0]=='E')\n    {\n        cal1(i);\n    }\n    else if(s[0]=='S')\n    {\n        cal2(i);\n    }\n    else if(s[0]=='W')\n    {\n       cal3(i);\n    }\n    else if(s[0]=='N')\n    {\n        cal4(i);\n    }\n    if(p[i].l>=2*w+2*d)\n    {\n        p[i].l=p[i].l-2*w-2*d;\n        p[i].r=p[i].r-2*w-2*d;\n    }\n    printf(\"%d %d\\n\",p[i].l,p[i].r);\n    return;\n}\nint main()\n{\n    int n;\n    while(~scanf(\"%d\",&n))\n    {\n        memset(p,-1,sizeof(p));\n        scanf(\"%d%d\",&w,&d);\n        for(int i = 0; i < n; i++)\n        {\n            Input(i);\n        }\n        sort(p,p+n,cmp);\n        node b[1010];\n        b[0]=p[0];\n        int cnt1=0;int cnt2=0;\n        int flag=0,k=-1;\n        int i,j;\n        for(i = 1; i < n; i++)\n        {\n            if(p[i].l<=b[cnt2].r)\n            {\n                b[cnt2].l=p[i].l;\n                if(p[i].r<=b[cnt2].r)\n                    b[cnt2].r=p[i].r;\n                b[i].flag=0;\n            }\n\n            else\n                {\n                    b[++cnt2]=p[i];\n                    if(b[cnt2].r>=2*w+2*d&&flag==0)\n                    {\n                        k=cnt2;\n                        flag=1;\n                    }\n                }\n        }\n        //??????\n        for(i = k; i < cnt2+1; i++)\n        {\n            for(j = cnt1; j < cnt2+1; j++)\n            {\n                if(b[j].l>=b[i].l-2*w-2*d&&b[j].r<=b[i].r-2*w-2*d)\n                {\n                    b[i].l=b[j].l+2*w+2*d;\n                    b[i].r=b[j].r+2*w+2*d;\n                    cnt1++;\n                }\n                else if(b[j].l>=b[i].l-2*w-2*d&&b[j].l<=b[i].r-2*w-2*d&&b[i].flag==-1)\n                {\n                    b[cnt2].l=p[i].l;\n                    if(p[i].r<=b[cnt2].r)\n                        b[cnt2].r=p[i].r;\n                    cnt1++;\n                }\n            }\n        }\n        printf(\"%d\\n\",cnt2-cnt1+1);\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nint n, w, h;\n\nint ru(int x, int y) {\n\tpii p1(x+h-y, h);\n\tpii p2(w, y+w-x);\n\tif(abs(p1.fi-x)+abs(p1.se-y) < abs(p2.fi-x)+abs(p2.se-y)) {\n\t\treturn h+p1.fi;\n\t} else {\n\t\treturn h*2 + w - p2.se;\n\t}\n}\n\nint rd(int x, int y) {\n\tpii p1(w, y-(w-x));\n\tpii p2(x+y, 0);\n\tif(abs(p1.fi-x)+abs(p1.se-y) < abs(p2.fi-x)+abs(p2.se-y)) {\n\t\treturn w+h*2-p1.se;\n\t} else {\n\t\treturn w*2 + h*2 - p2.fi;\n\t}\n}\n\nint lu(int x, int y) {\n\tpii p1(0, y+x);\n\tpii p2(x-(h-y), h);\n\tif(abs(p1.fi-x)+abs(p1.se-y) < abs(p2.fi-x)+abs(p2.se-y)) {\n\t\treturn p1.se;\n\t} else {\n\t\treturn h + p2.fi;\n\t}\n}\n\nint ld(int x, int y) {\n\tpii p1(0, y-x);\n\tpii p2(x-y, 0);\n\tif(abs(p1.fi-x)+abs(p1.se-y) < abs(p2.fi-x)+abs(p2.se-y)) {\n\t\treturn p1.se;\n\t} else {\n\t\treturn w*2 + h*2 - p2.fi;\n\t}\n}\n\nbool sortBySecond(const pii& lhs, const pii& rhs) {\n\tif( lhs.se == rhs.se ) {\n\t\treturn lhs.fi < rhs.fi;\n\t}\n\treturn lhs.se < rhs.se;\n}\n\nint main() {\n\tcin >> n >> w >> h;\n\tvector<pii> vp;\n\trep(i, n) {\n\t\tint x, y;\n\t\tchar f;\n\t\tcin >> x >> y >> f;\n\t\tif(f=='E') vp.push_back( pii(ru(x,y), rd(x,y)) );\n\t\tif(f=='W') vp.push_back( pii(ld(x,y), lu(x,y)) );\n\t\tif(f=='N') vp.push_back( pii(lu(x,y), ru(x,y)) );\n\t\tif(f=='S') vp.push_back( pii(rd(x,y), ld(x,y)) );\n\t\tif(vp[i].fi > vp[i].se) {\n\t\t\tvp[i].se += w*2 + h*2;\n\t\t}\n\t}\n\n\tsort(vp.begin(), vp.end(), sortBySecond);\n\n\tint res = 10000000;\n\tfor(int s=0; s<n; s++) {\n\t\tint cnt = 1;\n\t\tint pos = vp[s].se;\n\t\tfor(int i=1; i<n; i++) {\n\t\t\tint idx = (s+i) % n;\n\t\t\tif(vp[idx].fi <= pos && pos <= vp[idx].se) {\n\t\t\t} else {\n\t\t\t\tcnt++;\n\t\t\t\tpos = vp[idx].se;\n\t\t\t}\n\t\t}\n\t\tres = min(res, cnt);\n\t\tvp[s].fi += w*2 + h*2;\n\t\tvp[s].se += w*2 + h*2;\n\t}\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, W, D;\nvector<pair<int, int> > interval;\n\nint projection(int x, int y, int dx, int dy){\n\tint dist = 1000000000;\n\tint xx = x;\n\tint yy = y;\n\tif(dx > 0) dist = min(dist, W - x);\n\tif(dx < 0) dist = min(dist, x);\n\tif(dy > 0) dist = min(dist, D - y);\n\tif(dy < 0) dist = min(dist, y);\n\tx += dist * dx;\n\ty += dist * dy;\n\tint ret;\n\tif(x == 0) ret =  y;\n\telse if(y == D) ret = D + x;\n\telse if(x == W) ret =  D + W + (D - y);\n\telse ret =  D + W + D + (W - x);\n\treturn ret;\n}\n\n\n\nint main(){\n\tcin >> N >> W >> D;\n\tfor(int i = 0; i < N; i++){\n\t\tint x, y; char c;\n\t\tcin >> x >> y >> c;\n\t\tint s, e;\n\t\tif(c == 'N'){\n\t\t\ts = projection(x, y, -1, 1);\n\t\t\te = projection(x, y, 1, 1);\n\t\t}else if(c == 'E'){\n\t\t\ts = projection(x, y,  1, 1);\n\t\t\te = projection(x, y, 1, -1);\n\t\t}else if(c == 'S'){\n\t\t\ts = projection(x, y, 1, -1);\n\t\t\te = projection(x, y, -1, -1);\n\t\t}else if(c == 'W'){\n\t\t\ts = projection(x, y, -1, -1);\n\t\t\te = projection(x, y, -1, 1);\n\t\t}\n\t\tif(s > e) e += 2 * W + 2 * D;\n\t\tinterval.push_back({e, s});\n\t}\n\tsort(interval.begin(), interval.end());\n\n\tint ans = 10000000;\n\tfor(int i = 0; i < N; i++){\n\t\tint a1 = 1;\n\t\tint start = interval[i].first;\n\t\tint cur = start;\n\t\t//cout << \"=======\" << i << \"===========\" << endl;\n\t\tfor(int j = 1; j < N; j++){\n\t\t\tint e = interval[i + j].first;\n\t\t\tint s = interval[i + j].second;\n\t\t//\tprintf(\"%d+%d (%d, %d) %d %d\\n\", i, j, s, e, cur, start);\n\t\t\tif(!(s <= cur && cur <= e)  && start + 2 * W + 2 * D > e ){\n\t\t\t\ta1 += 1;\n\t\t\t\tcur = e;\n\t\t\t}\n\t\t}\n\t\t//cout << \"(\" << a1 << \")\" << endl;\n\t\tans = min(ans, a1);\n\t\tint e = interval[i].first + 2 * W + 2 * D;\n\t\tint s = interval[i].second + 2 * W + 2 * D;\n\t\tinterval.push_back({e, s});\n\t}\n\tcout << ans << endl;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> pii;\n\nstruct s {\n\tint ps,pp;\n\tint idx;\n\ts(){}\n\ts(int ps_, int pp_, int idx_) {\n\t\tps = ps_; pp = pp_; idx = idx_;\n\t}\n};\n\nbool operator<(s a, s b) {\n\treturn a.pp > b.pp;\n}\n\nint main() {\n\tint n, w, d;\n\tvector<pii> v;\n\tcin >> n >> w >> d;\n\tfor(int i = 0; i < n; i++) {\n\t\tint x, y;\n\t\tchar f;\n\t\tint nx, ny;\n\t\tcin >> x >> y >> f;\n\t\tswitch(f) {\n\t\t\tcase 'N':\n\t\t\t\tnx = w-x;\n\t\t\t\tny = d-y;\n\t\t\t\tbreak;\n\t\t\tcase 'W':\n\t\t\t\tnx = w + d-y;\n\t\t\t\tny = x;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tnx = w+d + x;\n\t\t\t\tny = y;\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\tnx = w+d+w + y;\n\t\t\t\tny = w-x;\n\t\t\t\tbreak;\n\t\t}\n\t\tint ps, pp;\n\t\tps = nx - ny;\n\t\tpp = nx + ny;\n\t\tv.push_back(pii(ps,pp));\n\t}\n\n\tsort(v.begin(), v.end());\n\tint res = 10000;\n\tfor(int i = 0; i < v.size(); i++) {\n\t\tvector<pii> vv;\n\t\tvector<int> pushed(n,0);\n\t\tpriority_queue<s> pq;\n\n\t\tvv.resize(v.size());\n\t\tfor(int j = 0; j < v.size(); j++) {\n\t\t\tvv[j].fi = (v[(i+j)%n].fi - v[i].fi + 4*(w+d)) % (2*(w+d));\n\t\t\tvv[j].se = (v[(i+j)%n].se - v[i].fi + 4*(w+d)) % (2*(w+d));\n\t\t\tif(vv[j].fi > vv[j].se) vv[j].se += 2*(w+d);\n\t\t}\n//\t\tfor(int j = 0; j < vv.size(); j++)\n//\t\t\tcout << vv[j].fi << \",\" << vv[j].se << \" \";\n//\t\tcout << endl;\n\n\t\tpq.push(s(vv[0].fi, vv[0].se, 0));\n\t\tint tmp = 0;\n\t\tfor(int j = 1; j < vv.size(); j++)  {\n\t\t\tif(vv[j].fi <= pq.top().pp) {\n\t\t\t\tpq.push(s(vv[j].fi,vv[j].se,j));\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile(pq.size()) pq.pop();\n\t\t\t\ttmp++;\n\t\t\t\tpq.push(s(vv[j].fi,vv[j].se,j));\n\t\t\t}\n\t\t}\n\t\tif(pq.size()) tmp++;\n\t\tres = min(res,tmp);\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P1;\nint n,w,d,x,y,ans;\nvector<P1> v;\nchar f;\nstack<P> q;\nbool used[N];\n\nvoid add_point(int num){\n  if(f=='N'){\n    if(x+y<d)v.push_back(P1(P(x+y+w*2+d,0),num));\n    else v.push_back(P1(P(x+y-d,0),num));\n    if(w+y-x<d)v.push_back(P1(P(d-(w+y-x)+w,1),num));\n    else v.push_back(P1(P(d-(y-x),1),num));\n  }\n  if(f=='E'){\n    if(d-(y-x)<w)v.push_back(P1(P(d-(y-x),0),num));\n    else v.push_back(P1(P(d-(w+(y-x))+w,0),num));\n    if(y+x<w)v.push_back(P1(P(w-(y+x)+w+d,1),num));\n    else v.push_back(P1(P(d-(-w+y+x)+w,1),num));\n  }\n  if(f=='S'){\n    if(0<=-w+y+x)v.push_back(P1(P(d-(-w+y+x)+w,0),num));\n    else v.push_back(P1(P(w-(y+x)+w+d,0),num));\n    if(0<=y-x)v.push_back(P1(P(y-x+w*2+d,1),num));\n    else v.push_back(P1(P(w-(-(y-x))+w+d,1),num));\n  }\n  if(f=='W'){\n    if(0<=-(y-x))v.push_back(P1(P(w-(-(y-x))+w+d,0),num));\n    else v.push_back(P1(P(y-x+w*2+d,0),num));\n    if(0<=y+x-d)v.push_back(P1(P(y+x-d,1),num));\n    else v.push_back(P1(P(y-x+w*2+d,1),num));\n  }\n}\n\nbool usednum[500000];\n\nvoid solve(){\n  int len=v.size(),cnt;\n  for(int i=0;i<len;i++){\n    memset(used,0,sizeof(used));\n    memset(usednum,0,sizeof(usednum));\n    if(v[i].first.second)continue;\n    cnt=0;\n    for(int j=i;j<len+i;j++){\n      int idx=j%len;\n      if(used[v[idx].second])continue;\n      if(!v[idx].first.second)q.push(P(v[idx].second,v[idx].first.first));\n      else{\n\tcnt++;\n\tif(usednum[v[idx].first.first])cnt--;\n\tusednum[v[idx].first.first]=true;\n\twhile(!q.empty()){\n\t  P num=q.top(); q.pop();\n\t  used[num.first]=true;\n\t  if(num.first==v[idx].second)break;\n\t}\n      }\n    }\n    ans=min(ans,cnt);\n  }\n}\n\nint main(){\n  cin>>n>>w>>d;\n  for(int i=0;i<n;i++){\n    cin>>x>>y>>f;\n    add_point(i);\n  }\n  sort(v.begin(),v.end());\n  ans=(1e9);\n  solve();\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct data{\n\tint l,r;\n\tdata(){}\n\tdata(int ll,int rr){\n\t\tl=ll;\n\t\tr=rr;\n\t}\n\tbool operator<(const data &d)const{\n\t\tif(r==d.r)return l<d.l;\n\t\treturn r<d.r;\n\t}\n};\n\nint n,w,d;\nvector<data> query;\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&w,&d);\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tchar c;\n\t\tscanf(\"%d%d%*c%c\",&x,&y,&c);\n\t\tif(c=='N'){\n\t\t\tint ll=x-(d-y);\n\t\t\tint rr=x+(d-y);\n\t\t\tif(ll<0)ll+=(w+d)*2;\n\t\t\tquery.push_back(data(ll,rr));\n\t\t}\n\t\tif(c=='E'){\n\t\t\tint ll=w+d-y-(w-x);\n\t\t\tint rr=w+d-y+(w-x);\n\t\t\tquery.push_back(data(ll,rr));\n\t\t}\n\t\tif(c=='S'){\n\t\t\tint ll=w+d+(w-x)-y;\n\t\t\tint rr=w+d+(w-x)+y;\n\t\t\tquery.push_back(data(ll,rr));\n\t\t}\n\t\tif(c=='W'){\n\t\t\tint ll=w+d+w+y-x;\n\t\t\tint rr=w+d+w+y+x;\n\t\t\tif(rr>=(w+d)*2)rr-=(w+d)*2;\n\t\t\tquery.push_back(data(ll,rr));\n\t\t}\n\t}\n\tsort(query.begin(),query.end());\n\tint res=n;\n\tfor(int i=0;i<n;i++){\n\t\tint tmp=0,last=-1,lup=-1;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tdata dd=query[(i+j)%n];\n\t\t\tif(dd.l<dd.r){\n\t\t\t\tif(last<dd.l || dd.r<last){\n\t\t\t\t\ttmp++;\n\t\t\t\t\tlup=j;\n\t\t\t\t\tlast=dd.r;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(last<dd.l || dd.r<last){\n\t\t\t\t\ttmp++;\n\t\t\t\t\tlup=j;\n\t\t\t\t\tlast=dd.r;\n\t\t\t\t\twhile(j<n && query[(i+j+1)%n].l>=w+d)j++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres=min(res,tmp);\n\t\t//printf(\"%d %d %d %d\\n\",i,query[i].l,query[i].r,tmp);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int w,h,n;\n  cin>>n>>w>>h;\n  int x,y,B=2*(w+h);\n  char c;\n  vector<P> m;\n  for(int i=0;i<n;i++){\n    cin>>x>>y>>c;\n    if(c=='S')m.push_back(P((x-y+B)%B,x+y));\n    if(c=='E')m.push_back(P(w+y-(w-x),w+y+(w-x)));\n    if(c=='N')m.push_back(P(w+h+(w-x)-(h-y),w+h+(w-x)+(h-y)));\n    if(c=='W')m.push_back(P(w*2+h+(h-y)-x,(w*2+h+(h-y)+x)%B));\n  }\n\n  for(int i=0;i<n;i++)swap(m[i].first,m[i].second);\n  sort(m.begin(),m.end());\n  for(int i=0;i<n;i++)swap(m[i].first,m[i].second);\n  int ans=n;\n  for(int i=0;i<n;i++){\n    int tp=1,p=m[i].second;\n    for(int j=0;j<n;j++){\n      int s=m[(i+j)%n].first,g=m[(i+j)%n].second;\n      if(s>g&&!(g<p&&p<s))continue;\n      if(s<g&&s<=p&&p<=g)continue;\n      tp++,p=g;\n    }\n    ans=min(tp,ans);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct range{\n\tint st, en;\n} pos[1000];\n\nint n, w, d;\nmap<int,vector<int> > m;\nmap<int,vector<int> >::iterator it;\nmap<int,int> nxt;\nvector<int> xx[2000];\nbool saw[1000];\n\nint main(){\n\tcin >> n >> w >> d;\n\trep(i,n){\n\t\tint x, y; char f;\n\t\tcin >> x >> y >> f;\n\t\ty = d-y;\n\t\tif(f == 'N'){\n\t\t\tif(w-x < y){\n\t\t\t\t//pos[i].st = P(w,y-w+x);\n\t\t\t\tpos[i].st = w+d*2-(y-w+x);\n\t\t\t} else{\n\t\t\t\t//pos[i].st = P(x+y,0);\n\t\t\t\tpos[i].st = w*2+d*2-(x+y);\n\t\t\t}\n\t\t\tif(x < y){\n\t\t\t\t//pos[i].en = P(0,y-x);\n\t\t\t\tpos[i].en = y-x;\n\t\t\t} else{\n\t\t\t\t//pos[i].en = P(x-y,0);\n\t\t\t\tpos[i].en = w*2+d*2-(x-y);\n\t\t\t}\n\t\t} else if(f == 'E'){\n\t\t\tif(w-x < d-y){\n\t\t\t\t//pos[i].st = P(w,y+w-x);\n\t\t\t\tpos[i].st = w+d*2-(y+w-x);\n\t\t\t} else{\n\t\t\t\t//pos[i].st = P(x+d-y,d);\n\t\t\t\tpos[i].st = d+x+d-y;\n\t\t\t}\n\t\t\tif(w-x < y){\n\t\t\t\t//pos[i].en = P(w,y-w+x);\n\t\t\t\tpos[i].en = w+d*2-(y-w+x);\n\t\t\t} else{\n\t\t\t\t//pos[i].en = P(x+y,0);\n\t\t\t\tpos[i].en = w*2+d*2-(x+y);\n\t\t\t}\n\t\t} else if(f == 'W'){\n\t\t\tif(x < y){\n\t\t\t\t//pos[i].en = P(0,y-x);\n\t\t\t\tpos[i].st = y-x;\n\t\t\t} else{\n\t\t\t\t//pos[i].en = P(x-y,0);\n\t\t\t\tpos[i].st = w*2+d*2-(x-y);\n\t\t\t}\n\t\t\tif(x < d-y){\n\t\t\t\t//pos[i].en = P(0,y+x);\n\t\t\t\tpos[i].en = y+x;\n\t\t\t} else{\n\t\t\t\t//pos[i].en = P(x+y-d,d);\n\t\t\t\tpos[i].en = d+x+y-d;\n\t\t\t}\n\t\t} else{\n\t\t\tif(x < d-y){\n\t\t\t\t//pos[i].en = P(0,y+x);\n\t\t\t\tpos[i].st = y+x;\n\t\t\t} else{\n\t\t\t\t//pos[i].en = P(x+y-d,d);\n\t\t\t\tpos[i].st = d+x+y-d;\n\t\t\t}\n\t\t\tif(w-x < d-y){\n\t\t\t\t//pos[i].st = P(w,y+w-x);\n\t\t\t\tpos[i].en = w+d*2-(y+w-x);\n\t\t\t} else{\n\t\t\t\t//pos[i].st = P(x+d-y,d);\n\t\t\t\tpos[i].en = d+x+d-y;\n\t\t\t}\n\t\t}\n\t\t//cout << pos[i].st << \" \" << pos[i].en  << endl;\n\t\tm[pos[i].st].push_back(i);\n\t\tm[pos[i].en].push_back(i);\n\t}\n\tint cnt = 0;\n\tfor(it = m.begin(); it != m.end(); it++){\n\t\tvector<int> v = (*it).second;\n\t\txx[cnt] = v;\n\t\tnxt[(*it).first] = cnt;\n\t\tcnt++;\n\t}\n\tint ans = INF;\n\trep(i,cnt){\n\t\tint counter = 1;\n\t\trep(j,n) saw[j] = false;\n\t\trep(j,xx[i].size()){\n\t\t\tsaw[xx[i][j]] = true;\n\t\t}\n\t\tmap<int,int> tmp;\n\t\tfor(int j = i+1; j < cnt; j++){\n\t\t\trep(k,xx[j].size()){\n\t\t\t\tif(saw[xx[j][k]]) continue;\n\t\t\t\tif(nxt[pos[xx[j][k]].en] == j){\n\t\t\t\t\tif(tmp[xx[j][k]] == 1){\n\t\t\t\t\t\ttmp.clear();\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else{\n\t\t\t\t\ttmp[xx[j][k]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < i; j++){\n\t\t\trep(k,xx[j].size()){\n\t\t\t\tif(saw[xx[j][k]]) continue;\n\t\t\t\tif(nxt[pos[xx[j][k]].en] == j){\n\t\t\t\t\tif(tmp[xx[j][k]] == 1){\n\t\t\t\t\t\ttmp.clear();\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else{\n\t\t\t\t\ttmp[xx[j][k]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = min(ans,counter);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n#define rdll(x) scanf(\"%lld\",&x);\nint n,w,h;\nvector<P>vec;\nvector<int>za;\nbool in[400005];\nbool cmp(P a,P b){\n\treturn a.sc < b.sc;\n}\nvector<P>zwa;\nint main(){\n    cin>>n>>w>>h;\n    \tfor(int i=0;i<w;i++){\n    \t\t//(i,0)\n    \t\tzwa.pb(mp(i,0));\n    \t}\n    \tfor(int i=0;i<h;i++){\n    \t\t//(w,i)\n    \t\tzwa.pb(mp(w,i));\n    \t}\n    \tfor(int i=w;i>0;i--){\n    \t\t//(i,h)\n    \t\tzwa.pb(mp(i,h));\n    \t}\n    \tfor(int i=h;i>0;i--){\n    \t\t//(0,i)\n    \t\tzwa.pb(mp(0,i));\n    \t}\n    rep(i,n){\n    \tint x,y; string st;\n    \tcin>>x>>y>>st;\n    \tint lb1,ub1;\n    \tif(st == \"N\" || st == \"E\"){\n    \t\tlb1 = x+y;\n    \t\tub1 = w+h;\n    \t}\n    \telse{\n    \t\tlb1 = 0;\n    \t\tub1 = x+y;\n    \t}\n    \tint lb2,ub2;\n    \tif(st == \"S\" || st == \"E\"){\n    \t\tlb2 = x-y;\n    \t\tub2 = w;\n    \t}\n    \telse{\n    \t\tlb2 = -h;\n    \t\tub2 = x-y;\n    \t}\n    \t//x+y; [lb1,ub1] x-y; [lb2,ub2]\n    \tvector<int>vecc;\n    \tfor(int i=0;i<w;i++){\n    \t\t//(i,0)\n    \t\tif(i == x+y) vecc.pb(i);\n    \t\tif(i == x-y) vecc.pb(i);\n    \t}\n    \tfor(int i=0;i<h;i++){\n    \t\t//(w,i)\n    \t\tif(w+i == x+y) vecc.pb(w+i);\n    \t\tif(w-i == x-y) vecc.pb(w+i);\n    \t}\n    \tfor(int i=w;i>0;i--){\n    \t\t//(i,h)\n    \t\tif(i+h == x+y) vecc.pb(w+h+w-i);\n    \t\tif(i-h == x-y) vecc.pb(w+h+w-i);\n    \t}\n    \tfor(int i=h;i>0;i--){\n    \t\t//(0,i)\n    \t\tif(i == x+y) vecc.pb(w+h+w+h-i);\n    \t\tif(-i == x-y) vecc.pb(w+h+w+h-i);\n    \t}\n    \tassert(vecc.size() == 4);\n    \tSORT(vecc);\n    \tint u = 0;\n    \trep(i,4){\n    \t\tint L = vecc[i], R = vecc[(i+1)%4];\n    \t\tint w = (L+1)%zwa.size();\n    \t\tint X = zwa[w].fi, Y = zwa[w].sc;\n    \t\tif(lb1<=X+Y&&X+Y<=ub1&&lb2<=X-Y&&X-Y<=ub2){\n\t    \t\tvec.pb(mp(L,R));\n\t    \t\tza.pb(L); za.pb(R);\n\t    \t\tu++;\n\t    \t}\n\t}\n\tassert(u==1);\n    }\n    SORT(za); ERASE(za);\n    rep(i,vec.size()){\n    \tvec[i].fi = lower_bound(za.begin(),za.end(),vec[i].fi)-za.begin();\n    \tvec[i].sc = lower_bound(za.begin(),za.end(),vec[i].sc)-za.begin();\n    \tif(vec[i].fi > vec[i].sc) vec[i].sc+=za.size();\n    }\n    int ans = INF;\n    for(int i=0;i<za.size();i++){\n        vector<P>nw;\n        int cur = 0, ret = 1;\n        rep(j,vec.size()){\n            int a=vec[j].fi,b=vec[j].sc;\n            {\n                if(a<=i && i<=b);\n                else if(a<=i+za.size() && i+za.size()<=b);\n                else nw.pb(vec[j]);\n            }\n        }\n        sort(nw.begin(),nw.end(),cmp);\n        while(cur != nw.size()){\n        \tint las = nw[cur].sc; ret++;\n        \twhile(cur != nw.size() && las >= nw[cur].fi) cur++;\n    \t}\n    \tans = min(ans,ret);\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\tint n, w, d;\n\twhile(cin >> n >> w >> d){\n\t\tvector< pair<int, int> > base;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x, y; char f;\n\t\t\tcin >> x >> y >> f;\n\t\t\tint a, b;\n\t\t\tif(f == 'S'){\n\t\t\t\ta = x;\n\t\t\t\tb = y;\n\t\t\t} else if(f == 'E'){\n\t\t\t\ta = w+y;\n\t\t\t\tb = w-x;\n\t\t\t} else if(f == 'N') {\n\t\t\t\ta = w+d+w-x;\n\t\t\t\tb = d-y;\n\t\t\t} else if(f == 'W'){\n\t\t\t\ta = 2*w+d+d-y;\n\t\t\t\tb = x;\n\t\t\t}\n\t\t\tbase.push_back(make_pair(a-b, a+b));\n\t\t}\n\t\tint res = n;\n\t\tvector<int> startPos;\n\t\tfor(const pair<int, int> pr : base){\n\t\t\tstartPos.push_back(pr.first);\n\t\t\tstartPos.push_back(pr.second);\n\t\t}\n\t\tfor(int i=0;i<startPos.size();i++){\n\t\t\tvector< pair<int, int> > vp;\n\t\t\tint start = startPos[i];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tbool ok = false;\n\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\tif(base[j].first+k*2*(w+d) <= start && start <= base[j].second+k*2*(w+d)) ok = true;\n\t\t\t\t}\n\t\t\t\tif(ok) continue;\n\t\t\t\tvp.push_back(base[j]);\n\t\t\t\tif(vp.back().second < start){\n\t\t\t\t\tvp.back().first += 2*(w+d);\n\t\t\t\t\tvp.back().second += 2*(w+d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 1, pos = -1000000;\n\t\t\tsort(vp.begin(), vp.end());\n\t\t\tfor(int j=0;j<vp.size();j++){\n\t\t\t\tif(vp[j].first > pos){\n\t\t\t\t\t++cnt;\n\t\t\t\t\tpos = vp[j].second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = min(res, cnt);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n  int n, w, d;\n  cin >> n >> w >> d;\n  vector<pair<int,int>> ps;\n  // mapping to the south-west corner \n  auto mapping0 = [](int x, int y) {\n    return x - y;\n  };\n  // mapping in one of four directions\n  auto mappingX = [w,d,&mapping0](int x, int y, int dir) {\n    switch(dir) {\n    case 0 : { // (-1, -1)-direction\n      int o = mapping0(x, y);\n      return o; // o >= 0 ? o : w + w + d + d + o; // normalization\n    }\n    case 1 : { // (1, -1)-direction\n      int o = mapping0(w-x, y); // flipping in x\n      return w - o; // o >= 0 ? w - o : w + (- o);\n    }\n    case 2 : { // (1, 1)-direction\n      int o = mapping0(w-x, d-y); // flipping in x and y\n      return w + d + o; // o >= 0 ? w + d + o : w + d + o;\n    }\n    case 3 : { // (-1, 1)-direction\n      int o = mapping0(x, d-y); // flipping in y\n      return w + d + w - o; // o >= 0 ? w + d + w - o : w + d + w + -o;\n    }\n    return -1;\n    }\n  };\n  // mapping to a range\n  auto make_range = [w,d,&mappingX](int x, int y, char c) {\n    switch(c){\n    case 'N': return make_pair(mappingX(x, y, 2), mappingX(x, y, 3));\n    case 'E': return make_pair(mappingX(x, y, 1), mappingX(x, y, 2));\n    case 'S': {\n      int s = mappingX(x, y, 0);\n      int e = mappingX(x, y, 1);\n      if(s < 0) { // normalize to non-negative\n        s += d + d + w + w;\n        e += d + d + w + w;\n      }\n      return make_pair(s, e);\n    }\n    case 'W': {\n      int s = mappingX(x, y, 3);\n      int e = mappingX(x, y, 0) + w + w + d + d;\n      return make_pair(s, e);\n    }\n    }\n    return make_pair(-10, -10);\n  };\n  \n  for(int i = 0; i < n; i++) {\n    int x, y, d;\n    char c;\n    cin >> x >> y;\n    cin >> c;\n    ps.push_back(make_range(x, y, c));\n  }\n  // a desk = a range on walls\n  // a lock = a point on walls\n  // todo: put points so that every range contains a point\n\n  // sort the ranges\n  sort(ps.begin(), ps.end());\n\n  // shrink the region (endpoint ee) by the range r\n  auto wrap = [d,w](bool aug, int a) {\n    return aug ? a + d + d + w + w : a;\n  };\n\n  // shrink the region (endpoint ee) by the range r\n  auto shrink = [&wrap](bool aug, const pair<int,int> &r, int *ee) {\n    int s = wrap(aug, r.first);\n    int e = wrap(aug, r.second);\n    if(s <= *ee) {\n      *ee = min(*ee, e);\n      return true;\n    }\n    return false;\n  };\n  // locating clocks from i's view\n  auto count = [&ps,n,&shrink,&wrap](const int ii){\n    int i = ii;\n    int k = 0;\n    int cnt = 0;\n    while(k < n) {\n      int e = wrap(i < ii, ps[i].second);\n      int kk = k;\n      k++;\n      i = (i + 1) % n;\n      while(k < n && shrink(i < ii, ps[i], &e)) {\n        i = (i + 1) % n;\n        k++;\n      }\n      cnt++;\n    }\n    return cnt;\n  };\n  \n\n  int cnt = n; // at most n\n  // possible starting points\n  for(int i = 0; i < n; i++) {\n    cnt = min(cnt, count(i));\n  }\n  cout << cnt << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P1;\nint n,w,d,x,y,ans;\nvector<P1> v;\nchar f;\nstack<int> q;\nbool used[N];\n\nvoid add_point(int num){\n  if(f=='N'){\n    if(x+y<d)v.push_back(P1(P(x+y+w*2+d,0),num));\n    else v.push_back(P1(P(x+y-d,0),num));\n    if(w+y-x<d)v.push_back(P1(P(d-(w+y-x)+w,1),num));\n    else v.push_back(P1(P(d-(y-x),1),num));\n  }\n  if(f=='E'){\n    if(d-(y-x)<w)v.push_back(P1(P(d-(y-x),0),num));\n    else v.push_back(P1(P(d-(w+(y-x))+w,0),num));\n    if(y+x<w)v.push_back(P1(P(w-(y+x)+w+d,1),num));\n    else v.push_back(P1(P(d-(-w+y+x)+w,1),num));\n  }\n  if(f=='S'){\n    if(0<=-w+y+x)v.push_back(P1(P(d-(-w+y+x)+w,0),num));\n    else v.push_back(P1(P(w-(y+x)+w+d,0),num));\n    if(0<=y-x)v.push_back(P1(P(y-x+w*2+d,1),num));\n    else v.push_back(P1(P(w-(-(y-x))+w+d,1),num));\n  }\n  if(f=='W'){\n    if(0<=-(y-x))v.push_back(P1(P(w-(-(y-x))+w+d,0),num));\n    else v.push_back(P1(P(y-x+w*2+d,0),num));\n    if(0<=y+x-d)v.push_back(P1(P(y+x-d,1),num));\n    else v.push_back(P1(P(y+x+w*2+d,1),num));\n  }\n}\n\nbool usednum[500000];\n\nvoid solve(){\n  int len=v.size(),cnt;\n  for(int i=0;i<len;i++){\n    memset(used,0,sizeof(used));\n    memset(usednum,0,sizeof(usednum));\n    if(v[i].first.second)continue;\n    cnt=0;\n    for(int j=i;j<len+i;j++){\n      int idx=j%len;\n      if(used[v[idx].second])continue;\n      if(!v[idx].first.second)used[v[idx].second]=true;//q.push(v[idx].second);\n      else{\n\tcnt++;\n\tif(usednum[v[idx].first.first])cnt--;\n\tusednum[v[idx].first.first]=true;\n\tused[v[idx].second]=true;\n\t/*while(!q.empty()){\n\t  int num=q.top(); q.pop();\n\t  used[num]=true;\n\t  }*/\n      }\n    }\n    ans=min(ans,cnt);\n  }\n}\n\nint main(){\n  cin>>n>>w>>d;\n  for(int i=0;i<n;i++){\n    cin>>x>>y>>f;\n    add_point(i);\n  }\n  sort(v.begin(),v.end());\n  for(int i=0;i<v.size();i++)\n    cout<<v[i].first.first<<' '<<v[i].first.second<<' '<<v[i].second<<endl;\n  ans=(1e9);\n  solve();\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nint n, w, d;\nP v[1002];\n\n\nint main() {\n    cin >> n >> w >> d;\n    int l = 2 * d + 2 * w; \n\n    for (int i = 0; i < n; ++i) {\n        int x, y;\n        char f;\n        cin >> x >> y >> f;\n        int c, b;\n        switch (f) {\n            case 'N':\n                c = x;\n                b = d - y;\n            break;\n            case 'E':\n                c = d - y + w;\n                b = w - x;\n            break;\n            case 'S':\n                c = w - x + w + d;\n                b = y;\n            break;\n            case 'W':\n                c = y + 2 * w + d;\n                b = x;\n            break;\n        }\n        \n        // v[i] = (left end of view, right end of view)\n\n        v[i] = P ((c - b + l) % l, (c + b + l) % l);\n    } \n\n    // sort by the left end of view\n\n    sort(v, v + n);\n\n    int minc = 10000;\n    for (int i = 0; i < n; ++i) {\n        \n        // Put a clock at the left end of i-th member's view\n\n        int c = 1;\n        int tmp = v[i].first;\n        for (int j = 0; j < n - 1; ++ j) {\n            int k = (i - j + n) % n;\n\n            int left = v[k].first;\n            int right = v[k].second;\n            if (left > right) right += l;\n            if (left <= tmp && tmp <= right) continue;\n            if (left - l <= tmp && tmp <= right - l) continue;\n\n            c++;\n            tmp = left;\n        }\n        if (c < minc) minc = c;\n    }\n    cout << minc << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\tint n, w, d;\n\twhile(cin >> n >> w >> d){\n\t\tvector< pair<int, int> > base;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x, y; char f;\n\t\t\tcin >> x >> y >> f;\n\t\t\tint a, b;\n\t\t\tif(f == 'S'){\n\t\t\t\ta = x;\n\t\t\t\tb = y;\n\t\t\t} else if(f == 'E'){\n\t\t\t\ta = w+y;\n\t\t\t\tb = w-x;\n\t\t\t} else if(f == 'N') {\n\t\t\t\ta = w+d+w-x;\n\t\t\t\tb = d-y;\n\t\t\t} else if(f == 'W'){\n\t\t\t\ta = 2*w+d+d-y;\n\t\t\t\tb = x;\n\t\t\t}\n\t\t\tbase.push_back(make_pair(a-b, a+b));\n\t\t}\n\t\tint res = n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tvector< pair<int, int> > vp;\n\t\t\tint start = base[i].second;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tbool ok = false;\n\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\tif(base[j].first+k*2*(w+d) <= start && start <= base[j].second+k*2*(w+d)) ok = true;\n\t\t\t\t}\n\t\t\t\tif(ok) continue;\n\t\t\t\tvp.push_back(base[j]);\n\t\t\t\tif(vp.back().second < start){\n\t\t\t\t\tvp.back().first += 2*(w+d);\n\t\t\t\t\tvp.back().second += 2*(w+d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 1, pos = -1000000;\n\t\t\tsort(vp.begin(), vp.end());\n\t\t\tfor(int j=0;j<vp.size();j++){\n\t\t\t\tif(pos < vp[j].first){\n\t\t\t\t\t++cnt;\n\t\t\t\t\tpos = vp[j].second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = min(res, cnt);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n  int n, w, d;\n  cin >> n >> w >> d;\n  vector<pair<int,int>> ps;\n  // mapping to the south-west corner \n  auto mapping0 = [](int x, int y) {\n    return x - y;\n  };\n  // mapping in one of four directions\n  auto mappingX = [w,d,&mapping0](int x, int y, int dir) {\n    switch(dir) {\n    case 0 : { // (-1, -1)-direction\n      int o = mapping0(x, y);\n      return o; // o >= 0 ? o : w + w + d + d + o; // normalization\n    }\n    case 1 : { // (1, -1)-direction\n      int o = mapping0(w-x, y); // flipping in x\n      return w - o; // o >= 0 ? w - o : w + (- o);\n    }\n    case 2 : { // (1, 1)-direction\n      int o = mapping0(w-x, d-y); // flipping in x and y\n      return w + d + o; // o >= 0 ? w + d + o : w + d + o;\n    }\n    case 3 : { // (-1, 1)-direction\n      int o = mapping0(x, d-y); // flipping in y\n      return w + d + w - o; // o >= 0 ? w + d + w - o : w + d + w + -o;\n    }\n    return -1;\n    }\n  };\n  // mapping to a range\n  auto make_range = [w,d,&mappingX](int x, int y, char c) {\n    switch(c){\n    case 'N': return make_pair(mappingX(x, y, 2), mappingX(x, y, 3));\n    case 'E': return make_pair(mappingX(x, y, 1), mappingX(x, y, 2));\n    case 'S': {\n      int s = mappingX(x, y, 0);\n      int e = mappingX(x, y, 1);\n      if(s < 0) { // normalize to non-negative\n        s += d + d + w + w;\n        e += d + d + w + w;\n      }\n      return make_pair(s, e);\n    }\n    case 'W': {\n      int s = mappingX(x, y, 3);\n      int e = mappingX(x, y, 0) + w + w + d + d;\n      return make_pair(s, e);\n    }\n    }\n    return make_pair(-10, -10);\n  };\n  \n  for(int i = 0; i < n; i++) {\n    int x, y, d;\n    char c;\n    cin >> x >> y;\n    cin >> c;\n    ps.push_back(make_range(x, y, c));\n  }\n  // a desk = a range on walls\n  // a lock = a point on walls\n  // todo: put points so that every range contains a point\n\n  // sort the ranges\n  sort(ps.begin(), ps.end());\n\n  // shrink the region (endpoint ee) by the range r\n  auto shrink = [d,w](bool aug, const pair<int,int> &r, int *ee) {\n    int s = r.first + (aug ? (d + d + w + w) : 0);\n    int e = r.second + (aug ? (d + d + w + w) : 0);\n    if(s <= *ee) {\n      *ee = min(*ee, e);\n      return true;\n    }\n    return false;\n  };\n  // locating clocks from i's view\n  auto count = [&ps,n,&shrink](const int ii){\n    int i = ii;\n    int k = 0;\n    int cnt = 0;\n    while(k < n) {\n      int e = ps[i].second;\n      k++;\n      i = (i + 1) % n;\n      while(k < n && shrink(i < ii, ps[i], &e)) {\n        i = (i + 1) % n;\n        k++;\n      }\n      cnt++;\n    }\n    return cnt;\n  };\n\n  int cnt = n; // at most n\n  // possible starting points\n  for(int i = 0; i < n; i++) {\n    cnt = min(cnt, count(i));\n  }\n  cout << cnt << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef pair< int, int > pii;\n\npii getRange(int w, int d, int x, int y, char f) {\n\tif (f == 'N') {\n\t\tint a = x - (d - y), b = (w - x) - (d - y);\n\t\treturn pii(a, w - b);\n\t}\n\t\n\tif (f == 'E') {\n\t\tint a = (d - y) - (w - x), b = y - (w - x);\n\t\treturn pii(w + a, w + d - b);\n\t}\n\t\n\tif (f == 'S') {\n\t\tint a = (w - x) - y, b = x - y;\n\t\treturn pii(w + d + a, 2*w + d - b);\n\t}\n\t\n\tif (f == 'W') {\n\t\tint a = y - x, b = (d - y) - x;\n\t\treturn pii(2*w + d + a, 2*w+2*d - b);\n\t}\n\t\n\treturn pii(-1,-1);\n}\n\nint solve(int n, vector< vector< int > >& collision, int s) {\n\tint ret = 0;\n\tvector< bool > bad(n, false);\n\tfor_(i,0,n) {\n\t\tint v = (s + i) % n;\n\t\tif (bad[v]) continue;\n\t\t++ret;\n\t\tfor (int u : collision[v]) bad[u] = true;\n\t}\n\treturn ret;\n}\n\nstruct Rng {\n\tint id, L, R;\n\tRng(int __id, pii p) : id(__id), L(p.first), R(p.second) {}\n\tbool operator < (const Rng& o) const { return R < o.R; }\n};\n\nint main() {\n\tint n, w, d;\n\tcin >> n >> w >> d;\n\t\n\tint UB = 2*w + 2*d;\n\tvector< Rng > vp;\n\tfor_(i,0,n) {\n\t\tint x, y; char f;\n\t\tcin >> x >> y >> f;\n\t\tpii p = getRange(w, d, x, y, f);\n\t\tvp.push_back(Rng(i, p));\n\t\tvp.push_back(Rng(i, pii(p.first + UB, p.second + UB)));\n\t}\n\t\n\tsort(vp.begin(), vp.end());\n\t\n\tvector< vector< int > > collision(n, vector< int >());\n\tfor (Rng x : vp) for (Rng y : vp) {\n\t\tif (x.id == y.id) continue;\n\t\tif (x.R >= y.L && x.L <= y.R) collision[x.id].push_back(y.id);\n\t}\n\t\n\tcout << max(solve(n, collision, 0), solve(n, collision, 1)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <tuple>\n\nusing namespace std;\ntypedef pair<int, int> pii;\nstatic const int INF = 1000000000;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tvector<pii> ranges;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x, y;\n\t\tstring f;\n\t\tcin >> x >> y >> f;\n\t\tint lo = 0, hi = 0;\n\t\tif(f[0] == 'N'){\n\t\t\tlo = min(y + x, h + x - (h - y));\n\t\t\thi = min(h + x + (h - y), h + w + (h - y -  (w - x)));\n\t\t}else if(f[0] == 'E'){\n\t\t\tlo = min(h + x + (h - y), h + w + (h - y - (w - x)));\n\t\t\thi = min(h + w + (h - y + (w - x)), h + w + h + (w - x - y)); \n\t\t}else if(f[0] == 'S'){\n\t\t\tlo = min(h + w + (h - y + (w - x)), h + w + h + (w - x - y)); \n\t\t\thi = min(h + w + h + (w - x + y), h + w + h + w + y - x);\n\t\t}else if(f[0] == 'W'){\n\t\t\tlo = min(h + w + h + (w - x + y), h + w + h + w + y - x);\n\t\t\thi = h + w + h + w + min(y + x, h + x - (h - y));\n\t\t}\n\t\tconst int hw2 = h + w + h + w;\n\t\tranges.emplace_back(lo, hi);\n\t\tranges.emplace_back(lo + hw2, hi + hw2);\n\t}\n\tsort(\n\t\tranges.begin(), ranges.end(),\n\t\t[](const pii &a, const pii &b){ return a.second < b.second; });\n\tint answer = INF;\n\tfor(int i = 0; i < n; ++i){\n\t\tvector<pii> r(ranges.begin() + i, ranges.begin() + i + n);\n\t\tconst int hw2 = (h + w) * 2;\n\t\tint count = 1, last = r[0].second;\n\t\tfor(int j = 0; j < n; ++j){\n\t\t\tif(r[j].first <= last){ continue; }\n\t\t\tif(r[j].second >= last + hw2){ continue; }\n\t\t\t++count;\n\t\t\tlast = r[j].second;\n\t\t}\n\t\tanswer = min(answer, count);\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct data{\n\tint l,r;\n\tdata(){}\n\tdata(int ll,int rr){\n\t\tl=ll;\n\t\tr=rr;\n\t}\n\tbool operator<(const data &d)const{\n\t\tif(r==d.r)return l<d.l;\n\t\treturn r<d.r;\n\t}\n};\n\nint n,w,d;\nstring dir=\"NWSE\";\nvector<data> query;\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&w,&d);\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tchar c;\n\t\tscanf(\"%d%d%*c%c\",&x,&y,&c);\n\t\tif(c=='N'){\n\t\t\tint ll=x-(d-y);\n\t\t\tint rr=x+(d-y);\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\t//query.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t\tif(c=='E'){\n\t\t\tint ll=w+d-y-(w-x);\n\t\t\tint rr=w+d-y+(w-x);\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\t//query.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t\tif(c=='S'){\n\t\t\tint ll=w+d+(w-x)-y;\n\t\t\tint rr=w+d+(w-x)+y;\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\t//query.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t\tif(c=='W'){\n\t\t\tint ll=w+d+w+y-x;\n\t\t\tint rr=w+d+w+y+x;\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\t//query.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t}\n\tsort(query.begin(),query.end());\n\tint res=n;\n\tfor(int i=0;i<n;i++){\n\t\tint tmp=1,last=query[i].r;\n\t\tfor(int j=1;j<n;j++){\n\t\t\tdata dd=query[(i+j)%n];\n\t\t\tif((i+j)%n<i)dd.l+=(w+d)*2,dd.r+=(w+d)*2;\n\t\t\tif(last<dd.l){\n\t\t\t\ttmp++;\n\t\t\t\tlast=dd.r;\n\t\t\t}\n\t\t}\n\t\tres=min(res,tmp);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint main()\n{\n  int N, W, D;\n  cin >> N >> W >> D;\n\n  int L = D + D + W + W;\n  deque< pair< int, int > > range;\n  for(int i = 0; i < N; i++) {\n    int X, Y;\n    char F;\n    cin >> X >> Y >> F;\n    if(F == 'N') range.emplace_back(X + Y, D + X + D - Y);\n    if(F == 'E') range.emplace_back(D + X + D - Y, L - X - Y);\n    if(F == 'S') range.emplace_back(L - X - Y, L - X + Y);\n    if(F == 'W') range.emplace_back(L - X + Y, X + Y + L);\n  }\n  sort(begin(range), end(range));\n\n\n  int ret = INF;\n  for(int i = 0; i < N; i++) {\n    int count = 0;\n    for(int j = 0; j < N;) {\n      int ps = range[j].second;\n      while(j < N && range[j].first <= ps) ++j;\n      ++count;\n    }\n\n\n/*\n    for(auto& p : range) {\n      cout << p.first%L << \" \" << p.second%L << endl;\n    }\n*/\n    ret = min(ret, count);\n    range.front().first += L;\n    range.front().second += L;\n    range.push_back(range.front());\n    range.pop_front();\n    sort(begin(range), end(range));\n  }\n  cout << ret << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Poi { int x, y; } A[1050], p[1050];\n\ntypedef int arr[40010];\n\narr vis, B;\nint n, W, D, cnt, tot, tim;\n\ninline Poi trans(Poi a, Poi b)\n{\n\tint x, y;\n\tif (a.x == W) x = a.y + W;\n\tif (a.x == 0) x = D - a.y + 2 * W + D;\n\tif (a.y == D) x = W - a.x + W + D;\n\tif (a.y == 0) x = a.x;\n\n\t\n\tif (b.x == W) y = b.y + W;\n\tif (b.x == 0) y = D - b.y + 2 * W + D;\n\tif (b.y == D) y = W - b.x + W + D;\n\tif (b.y == 0) y = b.x;\n\n\treturn (Poi) { x, y };\n}\n\ninline bool cross(int x, int pos)\n{\n\tif (p[x].x <= p[x].y)\n\t\t{ if (p[x].x <= pos && p[x].y >= pos) return true; }\n\telse if (pos <= p[x].y || pos >= p[x].x) return true;\n\treturn false;\n}\n\ninline void getInter(char c, int X, int Y)\n{\n\tPoi p1, p2, p3, p4;\n\tif (X + D - Y > W) p1.x = W, p1.y = Y + W - X; else p1.x = X + D - Y, p1.y = D;\n\tif (X + Y < W) p2.x = X + Y, p2.y = 0; else p2.x = W, p2.y = Y - (W - X);\n\tif (X > Y) p3.x = X - Y, p3.y = 0; else p3.x = 0, p3.y = Y - X;\n\tif (Y + X > D) p4.x = X - (D - Y), p4.y = D; else p4.x = 0, p4.y = X + Y;\n\n\tif (c == 'E') p[++cnt] = trans( p2, p1 );\n\tif (c == 'S') p[++cnt] = trans( p3, p2 );\n\tif (c == 'W') p[++cnt] = trans( p4, p3 );\n\tif (c == 'N') p[++cnt] = trans( p1, p4 );\n\n}\n\ninline int getans()\n{\n\tint last = -1, sum = 0;\n\tfor (int i = 1; i <= tot; i ++)\n\t\tif (vis[B[i]] != tim && A[i].x > last) sum ++, last = A[i].y;\n\treturn sum;\n}\n\ninline bool cmp(Poi a, Poi b) \n{ \nif (a.x > a.y) a.y += 2 * D + 2 * W;\nif (b.x > b.y) b.y += 2 * D + 2 * W; return a.y < b.y || (a.y == b.y && a.x < b.x); }\n\ninline void solve()\n{\n\tint ans = (int) 1e9;\n\tfor (int cur = 0, j, tans, k; cur < 2 * W + 2 * D; cur ++)\n\t\t{\n\t\t\ttans = 0; ++tim;\n\t\t\tfor (int i = 1; i <= n; i ++)\n\t\t\t\tif (cross(i, cur)) vis[i] = tim, tans = 1;\n\t\t\ttot = 0;\n\t\t\tfor (j = 1; j <= n; j ++) if (p[j].x >= cur) break;\n\t\t\tif (j == n + 1) j = 1;\n\t\t\tfor (k = 1; k <= n; k ++, j = (j == n) ? 1 : j + 1)\n\t\t\t\tif (!cross(j, cur)) A[++tot] = p[j], B[tot] = j;\n\t\t\t\n\t\t\ttans += getans();\n\t\t\tif (tans < ans)\n\t\t\t\tans = tans;\n\t\t}\n\tprintf(\"%d\\n\", ans);\t\t\n}\n\nint main()\n{\n\n\tscanf(\"%d%d%d\", &n, &W, &D);\n\tfor (int i = 1, a, b; i <= n; i ++)\n\t\t{\n\t\t\tscanf(\"%d%d\", &a, &b); char ch[3]; scanf(\"%s\", ch);\n\t\t\tgetInter(ch[0], a, b);\n\t\t}\n\tsort(p + 1, p + cnt + 1, cmp);\n\tsolve();\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint N,W,H;\nvector<P> t;\n\nbool check(P p,int a){\n  if(p.first<p.second)\n    return (p.first<=a&&a<=p.second);\n  return (p.first<=a||a<=p.second);\n}\nint calcArg(int x,int y){\n  if(x==0)return y;\n  if(y==H)return H+x;\n  if(x==W)return H+W+H-y;\n  return H+W+H+W-x;\n}\n\nint calcLU(int x,int y){\n  int d=min(x,H-y);\n  return calcArg(x-d,y+d);\n}\nint calcLD(int x,int y){\n  int d=min(x,y);\n  return calcArg(x-d,y-d);\n}\nint calcRU(int x,int y){\n  int d=min(W-x,H-y);\n  return calcArg(x+d,y+d);\n}\nint calcRD(int x,int y){\n  int d=min(W-x,y);\n  return calcArg(x+d,y-d);\n}\n\nint solve(int si){\n  int res=1,last=t[si].second;\n  for(int i=si;i<si+N;i++){\n    if(check(t[i],last)) continue;\n    res++;\n    last=t[i].second;\n  }\n  return res;\n}\n\nint main(){\n  cin>>N>>W>>H;\n  for(int i=0;i<N;i++){\n    int x,y;\n    char ch;\n    P p;\n    cin>>x>>y>>ch;\n    if(ch=='N'){\n      p.first = calcLU(x,y);\n      p.second = calcRU(x,y);\n    }\n    if(ch=='E'){\n      p.first = calcRU(x,y);\n      p.second = calcRD(x,y);\n    }\n    if(ch=='S'){\n      p.first = calcRU(x,y);\n      p.second = calcLU(x,y);\n    }\n    if(ch=='W'){\n      p.first = calcLD(x,y);\n      p.second = calcLU(x,y);\n    }\n    t.push_back(p);\n  }\n  for(int i=0;i<N;i++) swap(t[i].first,t[i].second);\n  sort(t.begin(),t.end());\n  for(int i=0;i<N;i++) t.push_back(t[i]);\n  for(int i=0;i<N+N;i++) swap(t[i].first,t[i].second);\n  int ans = N;\n  for(int i=0;i<N;i++)ans = min(ans,solve(i));\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef tuple<int,int,int> tpl;\n\nconst int MAX_N = 1001;\n\nint N,W,D;\nint XS[MAX_N];\nint YS[MAX_N];\nchar AS[MAX_N];\nbool used[MAX_N];\nint main(){\n\n  cin>>N>>W>>D;\n  for(int i=0;i<N;i++)cin>>XS[i]>>YS[i]>>AS[i];\n  vector<pii> poses;\n  // ???????£????????????????, ??§?¨????????????????????????????\n  for(int i=0;i<N;i++){\n\n    // w,n,e,s?????????????????¶??????????£??????§????????¢\n    const int wall_dist[4] = {XS[i], D - YS[i], W - XS[i], YS[i]};\n\n    // nw,ne,se,sw?????????????????????????????????\n    const int dy[] = {1, 1, -1, -1};\n    const int dx[] = {-1, 1, 1, -1};\n    \n    // nw,ne,se,sw???????????§, ????????§?¨?????¨????????????????\n    int stripex[4],stripey[4];\n    for(int j = 0; j < 4; j++){\n      int d1 = wall_dist[j];\n      int d2 = wall_dist[(j+1)%4];\n      // ????????????????§????\n      int d = min(d1,d2);\n      const int y = YS[i] + dy[j] * d;\n      const int x = XS[i] + dx[j] * d;\n      stripex[j] = x;\n      stripey[j] = y;\n    }\n\n    // ?????¨???, ???????????????????????§?¨??????????????????§, ??????????????¨??????\n    int usex[2], usey[2];\n    \n    // ????????§????????????????¨????????????????\n    if(AS[i]=='W'){\n      usex[0] = stripex[3], usey[0] = stripey[3];\n      usex[1] = stripex[0], usey[1] = stripey[0];\n    }\n    else if(AS[i]=='E'){\n      usex[0] = stripex[1], usey[0] = stripey[1];\n      usex[1] = stripex[2], usey[1] = stripey[2];\n    }\n    else if(AS[i]=='N'){\n      usex[0] = stripex[0], usey[0] = stripey[0];\n      usex[1] = stripex[1], usey[1] = stripey[1];\n    }\n    else if(AS[i]=='S'){\n      usex[0] = stripex[2], usey[0] = stripey[2];\n      usex[1] = stripex[3], usey[1] = stripey[3];\n    }\n\n    // ??§?¨?????????¢???????????????\n    int dists[2];\n    for(int j = 0; j < 2; j++){\n      int x = usex[j];\n      int y = usey[j];\n      if(x == 0)dists[j] = y;\n      else if(y == D)dists[j] = x + D;\n      else if(x == W)dists[j] = W + D + (D - y);\n      else dists[j] = W + D + D + (W - x);\n      if(dists[j] == 2*(W+D)){\n        dists[j] = 0;\n      }\n    }\n    if(dists[0] > dists[1]){\n      dists[1] += 2*(W + D);\n    }\n    // ?????¢????????\\\n    poses.push_back(make_pair(dists[0], dists[1]));\n  }\n\n  // vector???????????????2??????????????????\n  for(int i=0;i<N;i++){\n    // ??????????????????+2*(W+D)???????????????push_back\n    pii pd = poses[i];\n    pd.first += 2*(W+D);\n    pd.second += 2*(W+D);\n    poses.push_back(pd);\n  }\n  sort(poses.begin(), poses.end());\n  \n  int min_ans = 1<<29;\n  // ?????¨?????£??????, ??????????§???°???????±???????, ????????????n?????????????????°????¨??????????\n  for(int start = 0; start < N; start++){\n      memset(used,0,sizeof(used));\n      vector<tpl> vec;\n      for(int i=0;i<N;i++){\n        pii t = poses[start + i];\n        vec.push_back(make_tuple(t.first, 0, i));\n        vec.push_back(make_tuple(t.second, 1, i));\n      }\n      // start??????????????????end????????£????????????????´???????????????????\n      queue<int> q;\n      // ?????¢??§?????????\n      sort(vec.begin(), vec.end());\n      \n      int vec_idx = 0;\n      int ans = 0;\n      // ???????????¢?????¨??????????????????????????????\n      while((int)vec.size() != vec_idx){\n          // ???????????¢??§????´??????????????????????\n          int d = get<0>(vec[vec_idx]);\n          vector<int> vs[2];\n          while((int)vec.size()!=vec_idx && (get<0>(vec[vec_idx]) == d)){\n            vs[get<1>(vec[vec_idx])].push_back(get<2>(vec[vec_idx]));\n            vec_idx++;\n          }\n          \n          // start???????´???????????????????\n          // start???????´????, queue????????????\n          for(int i=0;i<(int)vs[0].size();i++){\n              int idx = vs[0][i];\n              q.push(idx);\n          }\n          \n          // end???????´????, ?????§???????????????????????°continue\n          for(int i=0;i<(int)vs[1].size();i++){\n              int idx = vs[1][i];\n              if(used[idx])continue;\n              else{\n                  // ?????????????????£????????????????????§start???????´?????§£???????????????\n                  // ????????????end????§£?????????????????§??????????????????\n                  ans++;\n                  while(q.size()){\n                      const int a = q.front(); q.pop();\n                      used[a] = true;\n                  }\n                  break;\n              }\n          }\n      }\n      min_ans = min(min_ans, ans);\n  }\n\n  cout<<min_ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint N,W,H,L;\nvector<P> t;\n\nbool check(P p,int a){\n  if(p.first<p.second)\n    return (p.first<=a&&a<=p.second);\n  return (p.first<=a||a<=p.second);\n}\nint solve(int si){\n  int res=1,last=t[si].second;\n  for(int i=si;i<si+N;i++){\n    if(check(t[i],last)) continue;\n    res++;\n    last=t[i].second;\n  }\n  return res;\n}\nint main(){\n  cin>>N>>W>>H;\n  L=W+W+H+H;\n  for(int i=0;i<N;i++){\n    int x,y,a,b;\n    char ch;\n    cin>>x>>y>>ch;\n    if(ch=='N'){\n      a = (x+y+L)%L;\n      b = (H+x-y+H)%L;\n    }\n    if(ch=='E'){\n      a = (H+H-y+x+L)%L;\n      b = (L-y-x)%L;\n    }\n    if(ch=='S'){\n      a = (L-x-y+L)%L;\n      b = (L-x+y)%L;\n    }\n    if(ch=='W'){\n      a = (y-x+L)%L;\n      b = (y+x)%L;\n    } \n    t.push_back(P(b,a));\n  }\n  sort(t.begin(),t.end());\n  for(int i=0;i<N;i++) t.push_back(t[i]);\n  for(int i=0;i<N+N;i++) swap(t[i].first,t[i].second);\n  int ans = N;\n  for(int i=0;i<N;i++)ans = min(ans,solve(i));\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n  int n, w, d;\n  cin >> n >> w >> d;\n  vector<pair<int,int>> ps;\n  // mapping to the south-west corner \n  auto mapping0 = [](int x, int y) {\n    return x - y;\n  };\n  // mapping in one of four directions\n  auto mappingX = [w,d,&mapping0](int x, int y, int dir) {\n    switch(dir) {\n    case 0 : { // (-1, -1)-direction\n      int o = mapping0(x, y);\n      return o; // o >= 0 ? o : w + w + d + d + o; // normalization\n    }\n    case 1 : { // (1, -1)-direction\n      int o = mapping0(w-x, y); // flipping in x\n      return w - o; // o >= 0 ? w - o : w + (- o);\n    }\n    case 2 : { // (1, 1)-direction\n      int o = mapping0(w-x, d-y); // flipping in x and y\n      return w + d + o; // o >= 0 ? w + d + o : w + d + o;\n    }\n    case 3 : { // (-1, 1)-direction\n      int o = mapping0(x, d-y); // flipping in y\n      return w + d + w - o; // o >= 0 ? w + d + w - o : w + d + w + -o;\n    }\n    return -1;\n    }\n  };\n  // mapping to a range\n  auto make_range = [w,d,&mappingX](int x, int y, char c) {\n    switch(c){\n    case 'N': return make_pair(mappingX(x, y, 2), mappingX(x, y, 3));\n    case 'E': return make_pair(mappingX(x, y, 1), mappingX(x, y, 2));\n    case 'S': return make_pair(mappingX(x, y, 0), mappingX(x, y, 1));\n    case 'W': {\n      int e = mappingX(x, y, 0) + w + d + w + d;\n      return make_pair(mappingX(x, y, 3), e);\n    }\n    }\n    return make_pair(-10, -10);\n  };\n  \n  for(int i = 0; i < n; i++) {\n    int x, y, d;\n    char c;\n    cin >> x >> y;\n    cin >> c;\n    ps.push_back(make_range(x, y, c));\n  }\n  // a desk = a range on walls\n  // a lock = a point on walls\n  // todo: put points so that every range contains a point\n\n  // sort the ranges\n  sort(ps.begin(), ps.end());\n\n  // range i contains x?\n  auto contains = [&ps,w,d](int i, int x) {\n    int s = ps[i].first;\n    int t = ps[i].second;\n    if(s <= x && x <= t) return true;\n    int y = x + d + d + w + w;\n    if(s <= y && y <= t) return true;\n    int z = x - (d + d + w + w);\n    if(s <= z && z <= t) return true;\n    return false;\n  };\n  // locating clocks from i's view\n  auto count = [&ps,&contains,n](int i){\n    int k = 0;\n    int cnt = 0;\n    while(k < n) {\n      int e = ps[i].second;\n      k++;\n      i = (i + 1) % n;\n      while(k < n && contains(i, e)) {\n        e = min(e, ps[i].second);\n        i++;\n        k++;\n      }\n      cnt++;\n    }\n    return cnt;\n  };\n  int cnt = n; // at most n\n  // possible starting points\n  for(int i = 0; i < n; i++) {\n    cnt = min(cnt, count(i));\n  }\n  cout << cnt << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//  aoj-VolumeICPCOOC2015-D  / 2015-11-30\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<map>\n#include<set>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef ll int__;\n#define rep(i,j) for(int__ i=0;i<(int__)(j);i++)\n#define repeat(i,j,k) for(int__ i=(j);i<(int__)(k);i++)\n#define all(v) v.begin(),v.end()\n//vector\ntemplate<typename T>ostream& operator << (ostream &os , const vector<T> &v){\n    rep(i,v.size()) os << v[i] << (i!=v.size()-1 ? \" \" : \"\\n\"); return os;\n}\ntemplate<typename T>istream& operator >> (istream &is , vector<T> &v){\n    rep(i,v.size()) is >> v[i]; return is;\n}\n\n//debug\n#ifdef DEBUG\nvoid debug(){ cerr << \"\\033[0m\" << endl; }\n#endif\ntemplate<class F,class...R> void debug(const F &car,const R&... cdr){\n#ifdef DEBUG\n    cerr << \"\\033[33m\" << car << \" \"; debug(cdr...);\n#endif\n}\n\nstruct Point{\n    int x,y;\n    Point():x(0),y(0){}\n    Point(int x,int y):x(x),y(y){};\n    Point& operator +=(const Point &p){\n        x += p.x;\n        y += p.y;\n        return *this;\n    }\n};\n\nostream &operator << (ostream& os, const Point& p){ return os << \"(\" << p.x << \",\" << p.y << \")\";}\n\nstruct ClosedRange{\n    int l,r; //[l,r]\n    ClosedRange(){}\n    ClosedRange(int l,int r):l(l),r(r){}\n    bool operator < (const ClosedRange &a) const {\n        return make_pair(r,l) < make_pair(a.r, a.l);\n    }\n};\n\nostream& operator << (ostream &os, const ClosedRange &r){ return os << \"[\" << r.l << \" \" << r.r << \"]\"; }\n\nint lower_dimension(Point p, int w, int d){\n    return  p.y == 0 ? p.x :\n            p.x == w ? w + p.y :\n            p.y == d ? w + d + (w - p.x) :\n            p.x == 0 ? w*2 + d + (d - p.y) : -1;\n}\n\nPoint find_cross(Point p, Point dp, int w, int d){\n    while(0 < p.x and p.x < w and 0 < p.y and p.y < d) p += dp;\n    return p;\n}\n\nbool is_in(ClosedRange &r, int x){\n    if(r.l <= r.r) return r.l <= x and x <= r.r;\n    else return r.l <= x or x <= r.r;\n}\n\nClosedRange calc_range(Point p, char dir, int w, int d){\n    ClosedRange ret;\n    Point dp[] = {Point(-1, 1), Point(1, 1), Point(1, -1), Point(-1, -1)};\n    map<char, int> dtoi = {{'N', 0}, {'E', 1}, {'S', 2}, {'W', 3}};\n    Point dp1 = dp[ ( dtoi[ dir ] + 1 ) % 4 ];\n    Point dp2 = dp[ dtoi[ dir ] ];\n    Point l = find_cross(p, dp1, w, d);\n    Point r = find_cross(p, dp2, w, d);\n    return ClosedRange(lower_dimension(l, w, d),\n                       lower_dimension(r, w, d));\n}\n\nbool check_used(set<int> &clock, ClosedRange &r){\n    if(r.l <= r.r){\n        auto itr = clock.lower_bound(r.l);\n        return itr != clock.end() ? *itr <= r.r : false ;\n    } else {\n        auto itr = clock.lower_bound(r.l);\n        auto itr2 = clock.upper_bound(r.r);\n        if(itr != clock.end()) return true;\n        if(itr2 == clock.begin()) return false;\n        itr2--;\n        return *itr2 <= r.r;\n    }\n}\n\nint trial(vector<ClosedRange> &range, int start){\n    debug(\"start at \",start);\n    int n = range.size();\n    set<int> clock;\n    for(int i = start; i<start+n; i++){\n        if( check_used(clock,range[i%n]))continue;\n        clock.insert(range[i%n].r);\n        debug(\"clock at \",range[i%n].r);\n    }\n    return clock.size();\n}\n\nbool solve(){\n    int n, w, d; cin >> n >> w >> d;\n    vector<ClosedRange> range(n);\n    rep(i,n){\n        int x,y;\n        char f; cin >> x >> y >> f;\n        range[i] = calc_range(Point(x,y), f, w, d);\n        debug(range[i]);\n    }\n    \n    sort( all( range ) );\n    int ans = 1 << 30;\n    rep(i, n){\n        ans = min(ans, trial(range, i));\n    }\n    cout << ans << endl;\n    return false;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\tint n, w, d;\n\twhile(cin >> n >> w >> d){\n\t\tvector< pair<int, int> > base;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x, y; char f;\n\t\t\tcin >> x >> y >> f;\n\t\t\tint a, b;\n\t\t\tif(f == 'S'){\n\t\t\t\ta = x;\n\t\t\t\tb = y;\n\t\t\t} else if(f == 'E'){\n\t\t\t\ta = w+y;\n\t\t\t\tb = w-x;\n\t\t\t} else if(f == 'N') {\n\t\t\t\ta = w+d+w-x;\n\t\t\t\tb = d-y;\n\t\t\t} else if(f == 'W'){\n\t\t\t\ta = 2*w+d+d-y;\n\t\t\t\tb = x;\n\t\t\t}\n\t\t\tbase.push_back(make_pair(a-b, a+b));\n\t\t}\n\t\tint res = n;\n\t\tvector<int> startPos;\n\t\tfor(const pair<int, int> pr : base){\n\t\t\tstartPos.push_back(pr.first);\n\t\t\tstartPos.push_back(pr.second);\n\t\t}\n\t\tfor(int i=0;i<startPos.size();i++){\n\t\t\tvector< pair<int, int> > vp;\n\t\t\tint start = startPos[i];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tbool ok = false;\n\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\tif(base[j].first+k*2*(w+d) <= start && start <= base[j].second+k*2*(w+d)) ok = true;\n\t\t\t\t}\n\t\t\t\tif(ok) continue;\n\t\t\t\tvp.push_back(base[j]);\n\t\t\t\tif(vp.back().second < start){\n\t\t\t\t\tvp.back().first += 2*(w+d);\n\t\t\t\t\tvp.back().second += 2*(w+d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 1, pos = -1000000;\n\t\t\tsort(vp.begin(), vp.end());\n\t\t\tfor(int j=0;j<vp.size();j++){\n\t\t\t\tif(vp[j].first > pos){\n\t\t\t\t\t++cnt;\n\t\t\t\t\tpos = vp[j].second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = min(res, cnt);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <set>\nusing namespace std;\nusing T=tuple<int,int,int>;//i,r=0/l=1,i\nint main(){\n\tint n,w,d;\n\tcin>>n>>w>>d;\n\tvector<T> V;\n\tfor(int i=0;i<n;i++){\n\t\tint x,y; char dir;\n\t\tcin>>x>>y>>dir;\n\t\tif(dir=='N'){\n\t\t\t//left\n\t\t\tif(x+y<=d){\n\t\t\t\tV.emplace_back(2*w+2*d-(x+y),1,i);\n\t\t\t}else{\n\t\t\t\tV.emplace_back(2*w+d-(x+y-d),1,i);\n\t\t\t}\n\t\t\t//right\n\t\t\tif(y+w-x<=d){\n\t\t\t\tV.emplace_back(w+(y+w-x),0,i);\n\t\t\t}else{\n\t\t\t\tV.emplace_back(2*w+d-(x+d-y),0,i);\n\t\t\t}\n\t\t}else if(dir=='S'){\n\t\t\t//left\n\t\t\tif(x+y-w>=0){\n\t\t\t\tV.emplace_back(w+(x+y-w),1,i);\n\t\t\t}else{\n\t\t\t\tV.emplace_back(x+y,1,i);\n\t\t\t}\n\t\t\t//right\n\t\t\tif(y-x>=0){\n\t\t\t\tV.emplace_back(2*w+2*d-(y-x),0,i);\n\t\t\t}else{\n\t\t\t\tV.emplace_back(x-y,0,i);\n\t\t\t}\n\t\t}else if(dir=='E'){\n\t\t\t//left\n\t\t\tif(y+w-x<=d){\n\t\t\t\tV.emplace_back(w+(y+w-x),1,i);\n\t\t\t}else{\n\t\t\t\tV.emplace_back(2*w+d-(x+d-y),1,i);\n\t\t\t}\t\t\t\n\t\t\t//right\n\t\t\tif(x+y-w>=0){\n\t\t\t\tV.emplace_back(w+(x+y-w),0,i);\n\t\t\t}else{\n\t\t\t\tV.emplace_back(x+y,0,i);\n\t\t\t}\n\t\t}else if(dir=='W'){\n\t\t\t//left\n\t\t\tif(y-x>=0){\n\t\t\t\tV.emplace_back(2*w+2*d-(y-x),1,i);\n\t\t\t}else{\n\t\t\t\tV.emplace_back(x-y,1,i);\n\t\t\t}\n\t\t\t//right\n\t\t\tif(x+y<=d){\n\t\t\t\tV.emplace_back(2*w+2*d-(x+y),0,i);\n\t\t\t}else{\n\t\t\t\tV.emplace_back(2*w+d-(x+y-d),0,i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<2*n;i++){\n\t\tint a,b,c; tie(a,b,c)=V[i];\n\t\tV.emplace_back(a+2*w+2*d,b,c);\n\t\tV.emplace_back(a+4*w+4*d,b,c);\n\t}\n\tsort(V.begin(),V.end());\n\t/*\n\tfor(auto v:V){\n\t\tint a,b,c; tie(a,b,c)=v;\n\t\tcout<<a<<' '<<b<<' '<<c<<endl;\n\t}*/\n\tint best = n+1;\n\tfor(int j=0;j<2*n;j++){\n\t\tset<int> S;\n\t\tvector<int> Sta(n);//0:not covered, 1:covered\n\t\tint ans = 0;\n\t\tfor(int i=j;i<j+2*n;i++){\n\t\t\tint loc,id,lr; tie(loc,lr,id)=V[i];\n\t\t\tif(lr==0){//r\n\t\t\t\t//S[id]=1;\n\t\t\t\tS.insert(id);\n\t\t\t}else{//l\n\t\t\t\tS.erase(id);\n\t\t\t}\n\t\t}\n\t\tfor(int i=j+2*n;i<j+4*n;i++){\n\t\t\tint loc,id,lr; tie(loc,lr,id)=V[i];\n\t\t\tif(lr==0){//r\n\t\t\t\t//cout<<loc<<' '<<id<<endl;\n\t\t\t\tif(Sta[id]==0){\n\t\t\t\t\tS.insert(id);\n\t\t\t\t}\n\t\t\t}else{//l\n\t\t\t\tif(S.count(id)){\n\t\t\t\t\tans++;\n\t\t\t\t\tfor(auto &s:S){\n\t\t\t\t\t\tSta[s]=1;\n\t\t\t\t\t}\n\t\t\t\t\tS.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout<<ans<<endl;\n\t\tbest=min(ans,best);\n\t}\n\tcout<<best<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\tint n, w, d;\n\twhile(cin >> n >> w >> d){\n\t\tvector< pair<int, int> > base;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x, y; char f;\n\t\t\tcin >> x >> y >> f;\n\t\t\tint a, b;\n\t\t\tif(f == 'S'){\n\t\t\t\ta = x;\n\t\t\t\tb = y;\n\t\t\t} else if(f == 'E'){\n\t\t\t\ta = w+y;\n\t\t\t\tb = w-x;\n\t\t\t} else if(f == 'N') {\n\t\t\t\ta = w+d+w-x;\n\t\t\t\tb = d-y;\n\t\t\t} else if(f == 'W'){\n\t\t\t\ta = 2*w+d+d-y;\n\t\t\t\tb = x;\n\t\t\t}\n\t\t\tbase.push_back(make_pair(a-b, a+b));\n\t\t}\n\t\tint res = n;\n\t\tvector< pair<int, int> > vp(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint start = base[i].second;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tvp[j] = base[j];\n\t\t\t\tif(vp[j].first + 2*(w+d) <= start && start <= vp[j].second + 2*(w+d)){\n\t\t\t\t\tvp[j].first += 2*(w+d);\n\t\t\t\t\tvp[j].second += 2*(w+d);\n\t\t\t\t} else if(vp[j].second < start){\n\t\t\t\t\tvp[j].first += 2*(w+d);\n\t\t\t\t\tvp[j].second += 2*(w+d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 1, pos = start;\n\t\t\tsort(vp.begin(), vp.end(), [](const pair<int, int>& a, const pair<int, int>& b){ return a.second == b.second ? a.first < b.first : a.second < b.second; });\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(vp[j].first > pos){\n\t\t\t\t\t++cnt;\n\t\t\t\t\tpos = vp[j].second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = min(res, cnt);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\n#define REP(i, n) for(int i=0; i<(n); i++)\n\nusing namespace std;\n\nvector<int> wall[400005];\nint main(){\n\tint n, w, d, x, y;\n\tchar f;\n\t\n\tcin >> n >> w >> d;\n\tfor(int i=1; i<=n; i++){\n\t\tcin >> x >> y >> f;\n\t\tint vx[2], vy[2];\n\t\tif( f == 'W' ){\n\t\t\tvx[0] = -1; vy[0] = -1;\n\t\t\tvx[1] = -1; vy[1] =  1;\n\t\t}else if( f == 'E' ){\n\t\t\tvx[0] =  1; vy[0] =  1;\n\t\t\tvx[1] =  1; vy[1] = -1;\n\t\t}else if( f == 'S' ){\n\t\t\tvx[0] =  1; vy[0] = -1;\n\t\t\tvx[1] = -1; vy[1] = -1;\n\t\t}else if( f == 'N' ){\n\t\t\tvx[0] = -1; vy[0] =  1;\n\t\t\tvx[1] =  1; vy[1] =  1;\n\t\t}\n\t\t//cout << \"vx=\" << vx[0] << endl;\n\t\tREP(k,2){\n\t\t\tint _x = x, _y = y;\n\t\t\twhile( _x > 0 && _x < w && _y > 0 && _y < d ){\n\t\t\t\t_x += vx[k];\n\t\t\t\t_y += vy[k];\n\t\t\t}\n\t\t\tif( _x == 0 ){\n\t\t\t\twall[_y].push_back( i * (1-2*k) );\n\t\t\t}else if( _y == d ){\n\t\t\t\twall[d+_x].push_back( i * (1-2*k) );\n\t\t\t}else if( _x == w ){\n\t\t\t\twall[d+w+d-_y].push_back( i * (1-2*k) );\n\t\t\t}else if( _y == 0 ){\n\t\t\t\twall[d+w+d+w-_x].push_back( i * (1-2*k) );\n\t\t\t}\n\t\t}\n\t}\n\t//REP(i,2*(w+d)) for(auto t: wall[i]){\n\t\t//cout << t << \" \";\n\t//}\n\t//cout << endl;\n\n\tint ans=0x3fffffff;\n\tREP(i,n){\n\t\tbool check[1005]={};\n\t\tint sum=0;\n\t\tint th = i, count = 0, pos=0;\n\t\tvector<int> st;\n\t\twhile( count < n ){\n\t\t\tbool ck=false;\n\t\t\tfor(auto t: wall[pos] ){\n\t\t\t\tif( t>0 ){\n\t\t\t\t\tif( th-- > 0 ) continue;\n\t\t\t\t\tst.push_back( t );\n\t\t\t\t}else{\n\t\t\t\t\tif( th > 0 ) continue;\n\t\t\t\t\tif( check[-t] ) continue;\n\t\t\t\t\tck = true;\n\t\t\t\t\tst.push_back( t );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( ck ){\n\t\t\t\t\tsum++;\n\t\t\t\t\tfor(auto l: st){\n\t\t\t\t\t\tif( !check[abs(l)] ) count++;\n\t\t\t\t\t\tcheck[l] = true;\n\t\t\t\t\t}\n\t\t\t\t\tst.clear();\n\t\t\t\t\t//cout << \"pos:\" << pos << \" count:\" << count << endl;\n\t\t\t}\n\t\t\tpos++; if( pos > 2*(d+w) ) pos = 0;\n\t\t\t//cout << \"next\" << pos << endl;\n\t\t}\n\t\tans = min( ans, sum );\n\t}\n\t\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n  int n, w, d;\n  cin >> n >> w >> d;\n  vector<pair<int,int>> ps;\n  // mapping to the south-west corner \n  auto mapping0 = [](int x, int y) {\n    return x - y;\n  };\n  // mapping in one of four directions\n  auto mappingX = [w,d,&mapping0](int x, int y, int dir) {\n    switch(dir) {\n    case 0 : { // (-1, -1)-direction\n      int o = mapping0(x, y);\n      return o; // o >= 0 ? o : w + w + d + d + o; // normalization\n    }\n    case 1 : { // (1, -1)-direction\n      int o = mapping0(w-x, y); // flipping in x\n      return w - o; // o >= 0 ? w - o : w + (- o);\n    }\n    case 2 : { // (1, 1)-direction\n      int o = mapping0(w-x, d-y); // flipping in x and y\n      return w + d + o; // o >= 0 ? w + d + o : w + d + o;\n    }\n    case 3 : { // (-1, 1)-direction\n      int o = mapping0(x, d-y); // flipping in y\n      return w + d + w - o; // o >= 0 ? w + d + w - o : w + d + w + -o;\n    }\n    return -1;\n    }\n  };\n  // mapping to a range\n  auto make_range = [w,d,&mappingX](int x, int y, char c) {\n    switch(c){\n    case 'N': return make_pair(mappingX(x, y, 2), mappingX(x, y, 3));\n    case 'E': return make_pair(mappingX(x, y, 1), mappingX(x, y, 2));\n    case 'S': {\n      int s = mappingX(x, y, 0);\n      int e = mappingX(x, y, 1);\n      if(s < 0) { // normalize to non-negative\n        s += d + d + w + w;\n        e += d + d + w + w;\n      }\n      return make_pair(s, e);\n    }\n    case 'W': {\n      int s = mappingX(x, y, 3);\n      int e = mappingX(x, y, 0) + w + w + d + d;\n      return make_pair(s, e);\n    }\n    }\n    return make_pair(-10, -10);\n  };\n  \n  auto sw = [](const pair<int,int> p) {\n    return make_pair(p.second, p.first);\n  };\n  \n  for(int i = 0; i < n; i++) {\n    int x, y, d;\n    char c;\n    cin >> x >> y;\n    cin >> c;\n    ps.push_back(sw(make_range(x, y, c)));\n  }\n  // a desk = a range on walls\n  // a lock = a point on walls\n  // todo: put points so that every range contains a point\n\n  // sort the ranges\n  sort(ps.begin(), ps.end());\n\n  // shrink the region (endpoint ee) by the range r\n  auto wrap = [d,w](bool aug, int a) {\n    return aug ? a + d + d + w + w : a;\n  };\n\n  // locating clocks from i's view\n  auto count = [&ps,n,&wrap](const int ii){\n    int i = ii;\n    int k = 0;\n    int cnt = 0;\n    while(k < n) {\n      int e = wrap(i < ii, ps[i].first);\n      int kk = k;\n      k++;\n      i = (i + 1) % n;\n      while(k < n && wrap(i < ii, ps[i].second) <= e) {\n        i = (i + 1) % n;\n        k++;\n      }\n      cnt++;\n    }\n    return cnt;\n  };\n  \n\n  int cnt = n; // at most n\n  // possible starting points\n  for(int i = 0; i < n; i++) {\n    cnt = min(cnt, count(i));\n  }\n  cout << cnt << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nvector<P> v;\nbool comp(P a, P b) {\n\tif (a.second != b.second)return a.second < b.second;\n\treturn a.first < b.first;\n}\nint n, w, h;\nbool inc(int id, int s) {\n\tint le = v[id].first, ri = v[id].second;\n\tfor (int i = -2; i <= 2; i++) {\n\t\tint ss = s + i * 2 * (w + h);\n\t\tif (le <= ss && ss <= ri)return true;\n\t}\n\treturn false;\n}\nvoid solve() {\n\tcin >> n >> w >> h;\n\trep(i, n) {\n\t\tint x, y; char t; cin >> x >> y >> t; y = h - y;\n\t\tswap(x, y);\n\t\tint le, ri;\n\t\tif (t == 'N') {\n\t\t\tle = y - x;\n\t\t\tri = y + x;\n\t\t}\n\t\telse if (t == 'S') {\n\t\t\tle = h + w + w - y - (h - x);\n\t\t\tri = h + w + w - y + h - x;\n\t\t}\n\t\telse if (t == 'E') {\n\t\t\tle = w + x - (w - y);\n\t\t\tri = w + x + w - y;\n\t\t}\n\t\telse {\n\t\t\tle = w + h + w + h-x - y;\n\t\t\tri = w + h + w + h-x + y;\n\t\t}\n\t\tv.push_back({ le,ri });\n\t\t//cout << le << \" \" << ri << endl;\n\t}\n\tint ans = 2 * n;\n\trep(i, n) {\n\t\tint s = v[i].second;\n\t\tvector<P> u;\n\t\trep(j, n) {\n\t\t\tif (inc(j, s))continue;\n\t\t\tint le = v[j].first - s;\n\t\t\tint ri = v[j].second - s;\n\t\t\twhile (le < 0) {\n\t\t\t\tle += 2 * (w + h);\n\t\t\t\tri += 2 * (w + h);\n\t\t\t}\n\t\t\tu.push_back({ le,ri });\n\t\t}\n\t\tsort(u.begin(), u.end(), comp);\n\t\tint cnt = 1, loc = 0;\n\t\trep(j, u.size()) {\n\t\t\tif (loc < u[j].first) {\n\t\t\t\tcnt++; loc = u[j].second;\n\t\t\t}\n\t\t}\n\t\tans = min(ans, cnt);\n\t}\n\tcout << ans << endl;\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nint n, w, d;\nP v[1002];\n\n\nint main() {\n    cin >> n >> w >> d;\n    int l = 2 * d + 2 * w; \n\n    for (int i = 0; i < n; ++i) {\n        int x, y;\n        char f;\n        cin >> x >> y >> f;\n        int c, b;\n        switch (f) {\n            case 'N':\n                c = x;\n                b = d - y;\n            break;\n            case 'E':\n                c = d - y + w;\n                b = w - x;\n            break;\n            case 'S':\n                c = w - x + w + d;\n                b = y;\n            break;\n            case 'W':\n                c = y + 2 * w + d;\n                b = x;\n            break;\n        }\n        \n        // v[i] = (left end of view, right end of view)\n\n        v[i] = P ((c - b + l) % l, (c + b + l) % l);\n    } \n\n    // sort by the left end of view\n\n    sort(v, v + n);\n\n    int minc = 10000;\n    for (int i = 0; i < n; ++i) {\n        \n        // Put a clock at the left end of i-th member's view\n\n        int c = 1;\n        int tmp = v[i].first;\n        for (int j = 0; j < n - 1; ++ j) {\n            int k = (i - j + n) % n;\n\n            int left = v[k].first;\n            int right = v[k].second;\n            if (left > right) right += l;\n            if (left <= tmp && tmp <= right) continue;\n            if (left - l <= tmp && tmp <= right - l) continue;\n\n            c++;\n            tmp = left;\n        }\n        if (c < minc) minc = c;\n    }\n    cout << minc << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct data{\n\tint l,r;\n\tdata(){}\n\tdata(int ll,int rr){\n\t\tl=ll;\n\t\tr=rr;\n\t}\n\tbool operator<(const data &d)const{\n\t\tif(r==d.r)return l<d.l;\n\t\treturn r<d.r;\n\t}\n};\n\nint n,w,d;\nvector<data> query;\n\n\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&w,&d);\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tchar c;\n\t\tscanf(\"%d%d%*c%c\",&x,&y,&c);\n\t\tif(c=='N'){\n\t\t\tint ll=x-(d-y);\n\t\t\tint rr=x+(d-y);\n\t\t\tif(ll<0)ll+=(w+d)*2;\n\t\t\tquery.push_back(data(ll,rr));\n\t\t}\n\t\tif(c=='E'){\n\t\t\tint ll=w+d-y-(w-x);\n\t\t\tint rr=w+d-y+(w-x);\n\t\t\tquery.push_back(data(ll,rr));\n\t\t}\n\t\tif(c=='S'){\n\t\t\tint ll=w+d+(w-x)-y;\n\t\t\tint rr=w+d+(w-x)+y;\n\t\t\tquery.push_back(data(ll,rr));\n\t\t}\n\t\tif(c=='W'){\n\t\t\tint ll=w+d+w+y-x;\n\t\t\tint rr=w+d+w+y+x;\n\t\t\tif(rr>=(w+d)*2)rr-=(w+d)*2;\n\t\t\tquery.push_back(data(ll,rr));\n\t\t}\n\t}\n\tsort(query.begin(),query.end());\n\tfor(int i=0;i<n;i++){\n\t\tquery.push_back(query[i]);\n\t}\n\tint res=n;\n\tfor(int i=0;i<n;i++){\n\t\tint tmp=1,last=query[i].r;\n\t\tfor(int j=1;j<n;j++){\n\t\t\tdata dd=query[i+j];\n\t\t\tif(dd.l<dd.r){\n\t\t\t\tif(last<dd.l || dd.r<last){\n\t\t\t\t\ttmp++;\n\t\t\t\t\tlast=dd.r;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(last<dd.l && dd.r<last){\n\t\t\t\t\ttmp++;\n\t\t\t\t\tlast=dd.r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres=min(res,tmp);\n\t\t//printf(\"%d %d %d %d\\n\",i,query[i].l,query[i].r,tmp);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct data{\n\tint l,r;\n\tdata(){}\n\tdata(int ll,int rr){\n\t\tl=ll;\n\t\tr=rr;\n\t}\n\tbool operator<(const data &d)const{\n\t\treturn r<d.r;\n\t}\n};\n\nint n,w,d;\nstring dir=\"NWSE\";\nvector<data> query;\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&w,&d);\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tchar c;\n\t\tscanf(\"%d%d%*c%c\",&x,&y,&c);\n\t\tif(c=='N'){\n\t\t\tint ll=x-(d-y);\n\t\t\tint rr=x+(d-y);\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\t//query.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t\tif(c=='E'){\n\t\t\tint ll=w+d-y-(w-x);\n\t\t\tint rr=w+d-y+(w-x);\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\t//query.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t\tif(c=='S'){\n\t\t\tint ll=w+d+(w-x)-y;\n\t\t\tint rr=w+d+(w-x)+y;\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\t//query.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t\tif(c=='W'){\n\t\t\tint ll=w+d+w+y-x;\n\t\t\tint rr=w+d+w+y+x;\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\t//query.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t}\n\tsort(query.begin(),query.end());\n\tint res=n;\n\tfor(int i=0;i<n;i++){\n\t\tint tmp=1,last=query[i].r;\n\t\tfor(int j=1;j<n;j++){\n\t\t\tdata dd=query[(i+j)%n];\n\t\t\tif((i+j)%n<i)dd.l+=(w+d)*2,dd.r+=(w+d)*2;\n\t\t\tif(last<dd.l){\n\t\t\t\ttmp++;\n\t\t\t\tlast=dd.r;\n\t\t\t}\n\t\t}\n\t\tres=min(res,tmp);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\n\n// better version\nint main(int argc, char *argv[])\n{\n  int n, w, d;\n  cin >> n >> w >> d;\n  vector<pair<int,int>> ps;\n  // mapping to the south-west corner \n  auto mapping0 = [](int x, int y) {\n    return x - y;\n  };\n  // mapping in one of four directions\n  auto mappingX = [w,d,&mapping0](int x, int y, int dir) {\n    switch(dir) {\n    case 0 : { // (-1, -1)-direction\n      int o = mapping0(x, y);\n      return o; // o >= 0 ? o : w + w + d + d + o; // normalization\n    }\n    case 1 : { // (1, -1)-direction\n      int o = mapping0(w-x, y); // flipping in x\n      return w - o; // o >= 0 ? w - o : w + (- o);\n    }\n    case 2 : { // (1, 1)-direction\n      int o = mapping0(w-x, d-y); // flipping in x and y\n      return w + d + o; // o >= 0 ? w + d + o : w + d + o;\n    }\n    case 3 : { // (-1, 1)-direction\n      int o = mapping0(x, d-y); // flipping in y\n      return w + d + w - o; // o >= 0 ? w + d + w - o : w + d + w + -o;\n    }\n    return -1;\n    }\n  };\n  // mapping to a range\n  auto make_range = [w,d,&mappingX](int x, int y, char c) {\n    switch(c){\n    case 'N': return make_pair(mappingX(x, y, 2), mappingX(x, y, 3));\n    case 'E': return make_pair(mappingX(x, y, 1), mappingX(x, y, 2));\n    case 'S': {\n      int s = mappingX(x, y, 0);\n      int e = mappingX(x, y, 1);\n      return make_pair(s, e);\n    }\n    case 'W': {\n      int s = mappingX(x, y, 3);\n      int e = mappingX(x, y, 0) + w + w + d + d;\n      if(e >= w + w + d + d) {\n        s -= + w + w + d + d;\n        e -= + w + w + d + d;\n      }\n      return make_pair(s, e);\n    }\n    }\n    return make_pair(-10, -10);\n  };\n  \n  auto sw = [](const pair<int,int> p) {\n    return make_pair(p.second, p.first);\n  };\n  \n  for(int i = 0; i < n; i++) {\n    int x, y, d;\n    char c;\n    cin >> x >> y;\n    cin >> c;\n    ps.push_back(sw(make_range(x, y, c)));\n  }\n  // a desk = a range on walls\n  // a lock = a point on walls\n  // todo: put points so that every range contains a point\n\n  // sort the ranges\n  sort(ps.begin(), ps.end());\n\n  // containment check\n  auto contains = [d,w,&ps](int i, int x) {\n    int s = ps[i].second;\n    int e = ps[i].first;\n    if(s <= x && x <= e) return true;\n    int y = x + d + d + w + w;\n    if(s <= y && y <= e) return true;\n    int z = x - (d + d + w + w);\n    if(s <= z && z <= e) return true;\n    return false;\n  };\n\n  // locating clocks from i's view\n  auto count = [&ps,n,&contains](const int ii){\n    int i = ii;\n    int k = 0;\n    int cnt = 0;\n    while(k < n) {\n      int e = ps[i].first;\n      int kk = k;\n      k++;\n      i = (i + 1) % n;\n      while(k < n && contains(i, e)) {\n        i = (i + 1) % n;\n        k++;\n      }\n      cnt++;\n    }\n    return cnt;\n  };  \n\n  auto norm = [w,d](int x) {\n    if(x < 0) return x + w + w + d + d;\n    if(x >= w + w + d + d) return x - (w + w + d + d);\n    return x;\n  };\n\n  // choosing the most overlapped end point\n  vector<pair<int,int>> ss;\n  for(int i = 0; i < n; i++) {\n    ss.push_back(make_pair(norm(ps[i].first), 1));  // end\n    ss.push_back(make_pair(norm(ps[i].second), -1)); // start\n  }\n  sort(ss.begin(), ss.end());\n  int mx = -n*2;\n  int mxi = -1;\n  {\n    int ov = 0;\n    for(int i = 0; i < ss.size(); i++) {\n      if(ss[i].second > 0) {\n        if(mx < ov) {\n          mx = ov;\n          mxi = i;\n        }\n        ov -= ss[i].second;\n      } else {\n        ov -= ss[i].second;\n      }\n    }\n  }\n  int thei = -1;\n  for(int i = 0; i < n; i++) {\n    if(ps[i].first == ss[mxi].first) {\n      thei = i;\n      break;\n    }\n  }\n  cout << count(thei) << endl;\n  // int cnt = n; // at most n\n  // // possible starting points\n  // for(int i = 0; i < n; i++) {\n  //   cnt = min(cnt, count(i));\n  // }\n  // cout << cnt << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int w,h,n;\n  cin>>n>>w>>h;\n  int x,y,B=2*(w+h),ans=n;\n  char c;\n  vector<P> m;\n  for(int i=0;i<n;i++){\n    cin>>x>>y>>c;\n    P A;\n    if(c=='S')A=P(x+y,(x-y+B)%B);\n    if(c=='E')A=P(w+y+(w-x),w+y-(w-x));\n    if(c=='N')A=P(w+h+(w-x)+(h-y),w+h+(w-x)-(h-y));\n    if(c=='W')A=P((w*2+h+(h-y)+x)%B,w*2+h+(h-y)-x);\n    m.push_back(A);\n  }\n  sort(m.begin(),m.end());\n  for(int i=0;i<n;i++){\n    int tp=1,p=m[i].first;\n    for(int j=0;j<n;j++){\n      int s=m[(i+j)%n].second,g=m[(i+j)%n].first;\n      if(!(s>g&&!(g<p&&p<s))&&!(s<g&&s<=p&&p<=g))tp++,p=g;\n    }\n    ans=min(tp,ans);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h;\n\nint calc(int x,int y){\n  if(x==0) return y;\n  if(y==h) return h+x;\n  if(x==w) return h+w+h-y;\n  return h+w+h+w-x;\n}\n\nint LU(int x,int y){\n  int d=min(x,h-y);\n  return calc(x-d,y+d);\n}\n\nint RU(int x,int y){\n  int d=min(w-x,h-y);\n  return calc(x+d,y+d);\n}\n\nint RD(int x,int y){\n  int d=min(w-x,y);\n  return calc(x+d,y-d);\n}\n\nint LD(int x,int y){\n  int d=min(x,y);\n  return calc(x-d,y-d);\n}\n\nbool check(P a,int b){\n  if(a.f<a.s&&(a.f<=b&&b<=a.s))return 1;\n  if(a.f>a.s&&!(a.s<b&&b<a.f)) return 1;\n  return 0;\n}\n\nint main(){\n  int n;\n  cin>>n>>w>>h;\n  \n  vector <P> lr;\n  for(int i=0;i<n;i++){\n    int x,y;\n    char ch;\n    cin>>x>>y>>ch;\n    if(ch=='N')lr.push_back(P(LU(x,y),RU(x,y)));\n    if(ch=='E')lr.push_back(P(RU(x,y),RD(x,y)));\n    if(ch=='S')lr.push_back(P(RD(x,y),LD(x,y)));\n    if(ch=='W')lr.push_back(P(LD(x,y),LU(x,y)));\n  }\n\n  for(int i=0;i<n;i++)swap(lr[i].f,lr[i].s);\n  sort(lr.begin(),lr.end());\n  for(int i=0;i<n;i++)swap(lr[i].f,lr[i].s);\n  \n  \n  int ans=n;\n  for(int i=0;i<n;i++){\n    int cnt=1,pos=lr[i].s;\n    for(int j=0;j<n;j++){\n      int idx=(i+j)%n;\n      if(check(lr[idx],pos))continue;\n      cnt++;\n      pos=lr[idx].s;\n    }\n    ans=min(ans,cnt);\n  }\n  cout <<ans<<endl;  \n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int w,h,n;\n  cin>>n>>w>>h;\n  int x,y,B=2*(w+h);\n  char c;\n  vector<P> m;\n  for(int i=0;i<n;i++){\n    cin>>x>>y>>c;\n    if(c=='S')m.push_back(P(x+y,(x-y+B)%B));\n    if(c=='E')m.push_back(P(w+y+(w-x),w+y-(w-x)));\n    if(c=='N')m.push_back(P(w+h+(w-x)+(h-y),w+h+(w-x)-(h-y)));\n    if(c=='W')m.push_back(P((w*2+h+(h-y)+x)%B,w*2+h+(h-y)-x));\n  }\n  sort(m.begin(),m.end());\n  int ans=n;\n  for(int i=0;i<n;i++){\n    int tp=0,p=-1;\n    for(int j=0;j<n;j++){\n      int s=m[(i+j)%n].second,g=m[(i+j)%n].first;\n      if(s>g&&!(g<p&&p<s))continue;\n      if(s<g&&s<=p&&p<=g)continue;\n      tp++,p=g;\n    }\n    ans=min(tp,ans);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\ntypedef complex<double> P;\n\nint main(){\n    int N, W, D;\n    cin >> N >> W >> D;\n    int L = 2 * (W + D);\n    P p1 = P(W, 0);\n    P p2 = P(W, D);\n    P p3 = P(0, D);\n    P C = P(0, -1);\n    \n    //end, start\n    vector<pair<int, int>> lines;\n    \n    for(int i=0; i<N; i++){\n        int x, y; string f;\n        cin >> x >> y >> f;\n        P p = P(x, y);\n        \n        switch (f[0]) {\n            case 'W':\n                p = (p - p3) * C + p3;\n            case 'N':\n                p = (p - p2) * C + p2;\n            case 'E':\n                p = (p - p1) * C + p1;\n            default:\n                break;\n        }\n        lines.emplace_back(p.real()+p.imag(), p.real()-p.imag());\n    }\n    sort(lines.begin(), lines.end());\n    \n    int ans = INF;\n    for(int s=0; s<N; s++){\n        int tans = 0;\n        for(int i=0; i<N; ){\n            int p = lines[i].first;\n            while(i<N && lines[i].second <= p) i++;\n            tans++;\n        }\n        ans = min(ans, tans);\n        \n        lines[0].first += L;\n        lines[0].second += L;\n        sort(lines.begin(), lines.end());\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n  int n, w, d;\n  cin >> n >> w >> d;\n  vector<pair<int,int>> ps;\n  // mapping to the south-west corner \n  auto mapping0 = [](int x, int y) {\n    return x - y;\n  };\n  // mapping in one of four directions\n  auto mappingX = [w,d,&mapping0](int x, int y, int dir) {\n    switch(dir) {\n    case 0 : { // (-1, -1)-direction\n      int o = mapping0(x, y);\n      return o; // o >= 0 ? o : w + w + d + d + o; // normalization\n    }\n    case 1 : { // (1, -1)-direction\n      int o = mapping0(w-x, y); // flipping in x\n      return w - o; // o >= 0 ? w - o : w + (- o);\n    }\n    case 2 : { // (1, 1)-direction\n      int o = mapping0(w-x, d-y); // flipping in x and y\n      return w + d + o; // o >= 0 ? w + d + o : w + d + o;\n    }\n    case 3 : { // (-1, 1)-direction\n      int o = mapping0(x, d-y); // flipping in y\n      return w + d + w - o; // o >= 0 ? w + d + w - o : w + d + w + -o;\n    }\n    return -1;\n    }\n  };\n  // mapping to a range\n  auto make_range = [w,d,&mappingX](int x, int y, char c) {\n    switch(c){\n    case 'N': return make_pair(mappingX(x, y, 2), mappingX(x, y, 3));\n    case 'E': return make_pair(mappingX(x, y, 1), mappingX(x, y, 2));\n    case 'S': {\n      int s = mappingX(x, y, 0);\n      int e = mappingX(x, y, 1);\n      if(s < 0) { // normalize to non-negative\n        s += d + d + w + w;\n        e += d + d + w + w;\n      }\n      return make_pair(s, e);\n    }\n    case 'W': {\n      int s = mappingX(x, y, 3);\n      int e = mappingX(x, y, 0) + w + w + d + d;\n      return make_pair(s, e);\n    }\n    }\n    return make_pair(-10, -10);\n  };\n  \n  for(int i = 0; i < n; i++) {\n    int x, y, d;\n    char c;\n    cin >> x >> y;\n    cin >> c;\n    ps.push_back(make_range(x, y, c));\n  }\n  // a desk = a range on walls\n  // a lock = a point on walls\n  // todo: put points so that every range contains a point\n\n  // sort the ranges\n  sort(ps.begin(), ps.end());\n\n  auto wrap = [d,w](bool aug, int a) {\n    return aug ? a + d + d + w + w : a;\n  };\n\n  // shrink the region (endpoint ee) by the range r\n  auto shrink = [&wrap](bool aug, const pair<int,int> &r, int *ee) {\n    int s = wrap(aug, r.first);\n    int e = wrap(aug, r.second);\n    //cout << \"s,e = \" << s << \",\"<<e<<endl;\n    if(s <= *ee) {\n      *ee = min(*ee, e);\n      return true;\n    }\n    return false;\n  };\n  int maxov = 0;\n  // locating clocks from i's view\n  auto count = [&ps,n,&shrink,&maxov,&wrap](const int ii){\n    int i = ii;\n    int k = 0;\n    int cnt = 0;\n    maxov = 0;\n    while(k < n) {\n      int e = wrap(i < ii, ps[i].second);\n      int kk = k;\n      k++;\n      i = (i + 1) % n;\n      while(k < n && shrink(i < ii, ps[i], &e)) {\n        i = (i + 1) % n;\n        k++;\n      }\n      if(k - kk > maxov) maxov = k - kk;\n      //cout << \"e = \" << e << \", i = \" << i << \", ii = \" << ii << \", k = \" << k << endl;\n      cnt++;\n    }\n    return cnt;\n  };\n\n  // cout << \"[\";\n  // for(int i = 0; i < n; i++) {\n  //   if(i > 0) cout << \",\";\n  //   cout << \"(\" << ps[i].first << \",\" << ps[i].second << \")\";\n  // }\n  // cout << \"]\" << endl;\n  int mx = 0;\n  int cntmx = 0;\n  int idx = -1;\n  int cnt = n; // at most n\n  // possible starting points\n  vector<int> cs;\n  for(int i = 0; i < n; i++) {\n    int cc = count(i);\n    //cout << \"starting from \" << i << \", cc = \" << cc << \", maxov = \" << maxov << endl;\n    cs.push_back(cc);\n    if(cc <= cnt) {\n      cnt = cc;\n      cntmx = max(cntmx, maxov);\n    }\n    if(mx < maxov) {\n      idx = i;\n      mx = maxov;\n    }\n  }\n  cout << cs[idx] << endl;\n  //cerr << \"maxov_of_best = \" << cntmx << \", global_maxov \" << mx << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int w,h,n;\n  cin>>n>>w>>h;\n  int x,y,B=2*(w+h),ans=n;\n  char c;\n  vector<P> m;\n  for(int i=0;i<n;i++){\n    cin>>x>>y>>c;\n    P A;\n    if(c=='S')A=P(x+y,(x-y+B)%B);\n    if(c=='E')A=P(w+y+(w-x),w+y-(w-x));\n    if(c=='N')A=P(w+h+(w-x)+(h-y),w+h+(w-x)-(h-y));\n    if(c=='W')A=P((w*2+h+(h-y)+x)%B,w*2+h+(h-y)-x);\n    m.push_back(A);\n  }\n  sort(m.begin(),m.end());\n  for(int i=0;i<n;i++){\n    int tp=1,p=m[i].first;\n    for(int j=0;j<n;j++){\n      int s=m[(i+j)%n].second,g=m[(i+j)%n].first;\n      if(!(s>g&&!(g<p&&p<s))&&!(s<g&&s<=p&&p<=g))tp++,p=g;\n    }\n    ans=min(tp,ans);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <cstdio>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long double ldb;\ntypedef complex<ldb> P;\n\nconst ldb eps = 1e-9;\nconst ldb pi = acos(-1);\nint sig(ldb a) {return (a<-eps)?-1:(a>eps)?1:0;}\nbool eq(ldb a,ldb b){return abs(a-b)<eps;}\nldb dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\nldb cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nldb ang(P a,P b,P c) {\n  P p = a-b;\n  P q = c-b;\n  if( eq(abs(p)*abs(q),0) ) return 0;\n  return acos(dot(p,q)/(abs(p)*abs(q)));\n}\n\nstruct L {\n  P a,b;\n  L(){}\n  L(P a,P b):a(a),b(b){}\n  ldb len(){return abs(a-b);}\n  P vec(){return b-a;}\n};\n\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\nint ccw(L s, P p) {\n  P a = s.vec();\n  p -= s.a;\n  ldb cr = cross(a, p);\n  if (eq(cr, 0)) {\n    if (sig(dot(a, p)) < 0) return BACK;\n    if (sig(norm(a) - norm(p)) < 0) return FRONT;\n    return ON;\n  }\n  return (cr > 0) ? LEFT : RIGHT;\n}\n\nP iP2(L a,L b) {\n  P c = b.b-b.a;\n  ldb d1 = abs(cross(c, a.a-b.a));\n  ldb d2 = abs(cross(c, a.b-b.a));\n  ldb t = d1 / (d1 + d2);\n  return a.a + (a.b-a.a) * t;\n}\n\nbool iI2_2(L a, L b) {\n  int cwa = ccw(a, b.a) | ccw(a, b.b);\n  int cwb = ccw(b, a.a) | ccw(b, a.b);\n  return ((cwa | cwb) & ON) || ((cwa & cwb) == (LEFT | RIGHT));\n}\n\nint n, w, d;\nint x[1111], y[1111];\nchar f[1111];\nP mid;\n\npair<int, int> tp(const P& p) {\n  return {p.real()+0.4, p.imag()+0.4};\n}\n\nint main(void) {\n  scanf(\"%d%d%d\", &n, &w, &d);\n\n  mid = P(w/2.0, d/2.0);\n  \n  for (int i = 0; i < n; i++) {\n    scanf(\"%d%d %c\", x+i, y+i, f+i);\n  }\n\n  vector<L> ls {\n    L(P(0, 0), P(w, 0)),\n        L(P(0, 0), P(0, d)),\n        L(P(w, 0), P(w, d)),\n        L(P(0, d), P(w, d)),\n  };\n  vector<P> p1, p2;\n  vector<tuple<ldb, ldb, int>> a;\n  vector<pair<int, int>> pos;\n  const int I = 1000000;\n\n  for (int i = 0; i < n; i++) {\n    L l1, l2;\n    P pos(x[i], y[i]);\n    if (f[i] == 'N') {\n      l1 = L(pos, P(x[i]+I, y[i]+I));\n      l2 = L(pos, P(x[i]-I, y[i]+I));\n    } else if (f[i] == 'W') {\n      l1 = L(pos, P(x[i]-I, y[i]+I));\n      l2 = L(pos, P(x[i]-I, y[i]-I));\n    } else if (f[i] == 'S') {\n      l1 = L(pos, P(x[i]-I, y[i]-I));\n      l2 = L(pos, P(x[i]+I, y[i]-I));\n    } else {\n      l1 = L(pos, P(x[i]+I, y[i]-I));\n      l2 = L(pos, P(x[i]+I, y[i]+I));\n    }\n    for (int i = 0; i < 4; i++) {\n      if (iI2_2(l1, ls[i])) {\n        p1.push_back(iP2(l1, ls[i]));\n        break;\n      }\n    }\n    for (int i = 0; i < 4; i++) {\n      if (iI2_2(l2, ls[i])) {\n        p2.push_back(iP2(l2, ls[i]));\n        break;\n      }\n    }\n  }\n\n  for (int i = 0; i < int(p1.size()); i++) {\n    pos.push_back(tp(p1[i]));\n    pos.push_back(tp(p2[i]));\n  }\n  sort(pos.begin(), pos.end());\n  pos.erase(unique(pos.begin(), pos.end()), pos.end());\n\n  vector<ldb> cl;\n  for (int i = 0; i < int(pos.size()); i++) {\n    cl.push_back(arg(mid-P(pos[i].first, pos[i].second))+pi);\n  }\n  sort(cl.begin(), cl.end());\n\n  /*\n  for (int i = 0; i < int(pos.size()); i++) {\n    printf(\"%d %d\\n\", pos[i].first, pos[i].second);\n  }\n  */\n\n  /*\n  for (int i = 0; i < int(cl.size()); i++) {\n    printf(\"%.10Lf\\n\", cl[i]/pi*180);\n  }\n  //*/\n\n  for (int i = 0; i < int(p1.size()); i++) {\n    ldb a1 = arg(mid-p1[i])+pi;\n    ldb a2 = arg(mid-p2[i])+pi;\n    if (a1 > a2) a2 += 2*pi;\n    a.emplace_back(a1, a2, i);\n  }\n  sort(a.begin(), a.end());\n\n  /*\n  for (int i = 0; i < int(a.size()); i++) {\n    printf(\"%20.10Lf %20.10Lf \", get<0>(a[i])/pi*180, get<1>(a[i])/pi*180);\n    printf(\"%d\\n\", get<2>(a[i]));\n  }\n  //*/\n\n  int res = 114514;\n  for (int i = 0; i < n; i++) {\n    int u[2222] {};\n    int b = 0;\n    for (int j = 0; j < int(cl.size()); j++) {\n      if ((sig(get<0>(a[i])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[i])) <= 0) ||\n          (sig(get<0>(a[i])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[i])) <= 0)) {\n        b = j;\n      }\n    }\n    // printf(\"%d\\n\", b);\n    int c = 0;\n    int j = b;\n    u[j] = 1;\n    int k = (i+1)%n;\n    while (k != i) {\n      // printf(\"%d %d\\n\", k, j);\n      while (k != i && ((sig(get<0>(a[k])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[k])) <= 0) ||\n              (sig(get<0>(a[k])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[k])) <= 0))) {\n        k = (k+1)%n;\n      }\n      if (k != i) {\n        while (!((sig(get<0>(a[k])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[k])) <= 0) ||\n                 (sig(get<0>(a[k])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[k])) <= 0))) {\n          j = (j+1)%cl.size();\n        }\n        int pj = j;\n        while (((sig(get<0>(a[k])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[k])) <= 0) ||\n                 (sig(get<0>(a[k])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[k])) <= 0))) {\n          pj = j;\n          j = (j+1)%cl.size();\n        }\n        j = pj;\n        u[j] = 1;\n      }\n    }\n    //*\n    for (int p = 0; p < int(cl.size()); p++) {\n      c += u[p];\n      //printf(\"%d \", u[p]);\n    }\n    // puts(\"\");\n    //*/\n    res = min(res, c);\n  }  \n\n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> P;\ntypedef vector<P> VP;\nstruct UNKO{\n    LL pos;\n    char st;\n    int id;\n    bool operator<(const UNKO& r){\n        if(pos==r.pos)return st<r.st;\n        else return pos<r.pos;\n    }\n    UNKO(){\n        pos=0;st='-';id=-1;\n    }\n    UNKO(LL p,char s,int i){\n        pos=p;st=s;id=i;\n    }\n    void print(){\n        string s;\n        cout<<\"(\"<<pos<<\",\"<<st<<\",\"<<id<<\")\";\n    }\n};\nvoid input(VP& unko,vector<UNKO>& kuso,int N,int w,int d){\n    kuso.reserve(2*N);\n    for(int i = 0; i < N; i++){\n        LL x,y;\n        char dir;\n        cin>>x>>y>>dir;\n        LL Rx=(w-x),Ry=(d-y);\n        LL S,T;\n        switch(dir){\n            case 'W':\n                S=(x<=y)?(y-x):(d+w+d+Rx+(x-y));\n                T=(x<=Ry)?(y+x):(d+x-Ry);\n                break;\n            case 'E':\n                S=(Rx<=Ry)?(d+w+Ry-Rx):(d+x+Ry);\n                T=(Rx<=y)?(d+w+Ry+Rx):(d+w+d+Rx-y);\n                break;\n            case 'N':\n                S=(x<=Ry)?(y+x):(d+x-Ry);\n                T=(Rx<=Ry)?(d+w+Ry-Rx):(d+x+Ry);\n                break;\n            case 'S':\n                S=(Rx<=y)?(d+w+Ry+Rx):(d+w+d+Rx-y);\n                T=(x<=y)?(y-x):(d+w+d+Rx+(x-y));\n                break;\n        }\n        UNKO ss=UNKO(S,'S',i);\n        UNKO tt=UNKO(T,'T',i);\n//        ss.print();\n//        tt.print();\n        kuso.push_back(ss);\n        kuso.push_back(tt);\n\n    }\n    sort(kuso.begin(),kuso.end());\n    for(int i=0;i<2*N;i++){\n        int ii=kuso[i].id;\n        if(kuso[i].st=='S')unko[ii].first=i;\n        else unko[ii].second=i;\n    }\n}\nint INF =1001;\nint greedy(int bg,vector<UNKO> unko,VP& idl,int N){\n    //for(int i=0;i<2*N;i++)cout<<unko[i].st;cout<<endl;\n    //for(int i=0;i<2*N;i++)cout<<unko[i].id;cout<<endl;\n    N*=2;\n    stack<int> s;\n    int index=bg,res=1;\n    for(int i=0;i<N;i++){\n        if(unko[i].st=='S'){\n            int lid=i;\n            int rid=idl[unko[i].id].second;\n            LL lp=unko[lid].pos;\n            LL rp=unko[rid].pos;\n            if(lp<rp){\n                if(lp<=unko[bg].pos&&unko[bg].pos<=rp)\n                    unko[lid].st=unko[rid].st='-';\n            }\n            else{\n                if(lp<=unko[bg].pos||unko[bg].pos<=rp)\n                    unko[lid].st=unko[rid].st='-';\n            }\n        }\n    }\n    index=(index+1)%N;\n    while(index!=bg){\n        if(unko[index].st=='S')s.push(index);\n        if(unko[index].st=='T'){\n    //        cout<<unko[index].id;\n            res++;\n            while(s.empty()==false){\n                int id=s.top();s.pop();\n                unko[id].st='-';\n                id=idl[unko[id].id].second;\n                unko[id].st='-';\n            }\n        }\n        index=(index+1)%N;\n    }\n//    cout<<endl;\n    if(s.empty()==false)return INF;\n    else return res;\n}\n\n\nint main() {\n    int N,W,D;\n    cin>>N>>W>>D;\n    vector<UNKO> line;\n    VP index(N);\n    input(index,line,N,W,D);\n    int res=INF;\n    for(int i=0;i<2*N;i++){\n        if(line[i].st=='T')\n        res=min(res,greedy(i,line,index,N));\n\n    }\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\n\n// better version\nint main(int argc, char *argv[])\n{\n  int n, w, d;\n  cin >> n >> w >> d;\n  vector<pair<int,int>> ps;\n  // mapping to the south-west corner \n  auto mapping0 = [](int x, int y) {\n    return x - y;\n  };\n  // mapping in one of four directions\n  auto mappingX = [w,d,&mapping0](int x, int y, int dir) {\n    switch(dir) {\n    case 0 : { // (-1, -1)-direction\n      int o = mapping0(x, y);\n      return o; // o >= 0 ? o : w + w + d + d + o; // normalization\n    }\n    case 1 : { // (1, -1)-direction\n      int o = mapping0(w-x, y); // flipping in x\n      return w - o; // o >= 0 ? w - o : w + (- o);\n    }\n    case 2 : { // (1, 1)-direction\n      int o = mapping0(w-x, d-y); // flipping in x and y\n      return w + d + o; // o >= 0 ? w + d + o : w + d + o;\n    }\n    case 3 : { // (-1, 1)-direction\n      int o = mapping0(x, d-y); // flipping in y\n      return w + d + w - o; // o >= 0 ? w + d + w - o : w + d + w + -o;\n    }\n    return -1;\n    }\n  };\n  // mapping to a range\n  auto make_range = [w,d,&mappingX](int x, int y, char c) {\n    switch(c){\n    case 'N': return make_pair(mappingX(x, y, 2), mappingX(x, y, 3));\n    case 'E': return make_pair(mappingX(x, y, 1), mappingX(x, y, 2));\n    case 'S': {\n      int s = mappingX(x, y, 0);\n      int e = mappingX(x, y, 1);\n      return make_pair(s, e);\n    }\n    case 'W': {\n      int s = mappingX(x, y, 3);\n      int e = mappingX(x, y, 0) + w + w + d + d;\n      if(e > w + w + d + d) {\n        s -= + w + w + d + d;\n        e -= + w + w + d + d;\n      }\n      return make_pair(s, e);\n    }\n    }\n    return make_pair(-10, -10);\n  };\n  \n  auto sw = [](const pair<int,int> p) {\n    return make_pair(p.second, p.first);\n  };\n  \n  for(int i = 0; i < n; i++) {\n    int x, y, d;\n    char c;\n    cin >> x >> y;\n    cin >> c;\n    ps.push_back(sw(make_range(x, y, c)));\n  }\n  // a desk = a range on walls\n  // a lock = a point on walls\n  // todo: put points so that every range contains a point\n\n  // sort the ranges\n  sort(ps.begin(), ps.end());\n\n  // containment check\n  auto contains = [d,w,&ps](int i, int x) {\n    int s = ps[i].second;\n    int e = ps[i].first;\n    if(s <= x && x <= e) return true;\n    int y = x + d + d + w + w;\n    if(s <= y && y <= e) return true;\n    int z = x - (d + d + w + w);\n    if(s <= z && z <= e) return true;\n    return false;\n  };\n\n  // locating clocks from i's view\n  auto count = [&ps,n,&contains](const int ii){\n    int i = ii;\n    int k = 0;\n    int cnt = 0;\n    while(k < n) {\n      int e = ps[i].first;\n      int kk = k;\n      k++;\n      i = (i + 1) % n;\n      while(k < n && contains(i, e)) {\n        i = (i + 1) % n;\n        k++;\n      }\n      cnt++;\n    }\n    return cnt;\n  };  \n\n  auto norm = [w,d](int x) {\n    if(x < 0) return x + w + w + d + d;\n    if(x >= w + w + d + d) return x - (w + w + d + d);\n    return x;\n  };\n\n  // choosing the most overlapped end point\n  vector<pair<int,int>> ss;\n  for(int i = 0; i < n; i++) {\n    ss.push_back(make_pair(norm(ps[i].first), 1));  // end\n    ss.push_back(make_pair(norm(ps[i].second), -1)); // start\n  }\n  sort(ss.begin(), ss.end());\n  int mx = 0;\n  int mxi = -1;\n  {\n    int ov = 0;\n    for(int i = 0; i < ss.size(); i++) {\n      ov -= ss[i].second;\n      if(ss[i].second > 0) {\n        if(mx < ov) {\n          mx = ov;\n          mxi = i;\n        }\n      }\n    }\n  }\n  int thei;\n  for(int i = 0; i < n; i++) {\n    if(ps[i].first == ss[mxi].first) {\n      thei = i;\n      break;\n    }\n  }\n  cout << count(thei) << endl;\n  // int cnt = n; // at most n\n  // // possible starting points\n  // for(int i = 0; i < n; i++) {\n  //   cnt = min(cnt, count(i));\n  // }\n  // cout << cnt << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <tuple>\n\nusing namespace std;\ntypedef pair<int, int> pii;\nstatic const int INF = 1000000000;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tvector<pii> ranges(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tint x, y;\n\t\tstring f;\n\t\tcin >> x >> y >> f;\n\t\tconst int hw2 = h + w + h + w;\n\t\tconst int lu = y + x;\n\t\tconst int ru = h + x + (h - y);\n\t\tconst int rd = h + w + (h - y) + (w - x);\n\t\tconst int ld = h + w + h + (w - x) + y;\n\t\tint lo = 0, hi = 0;\n\t\tif(f[0] == 'N'){\n\t\t\tlo = lu; hi = ru;\n\t\t}else if(f[0] == 'E'){\n\t\t\tlo = ru; hi = rd;\n\t\t}else if(f[0] == 'S'){\n\t\t\tlo = rd; hi = ld;\n\t\t}else if(f[0] == 'W'){\n\t\t\tlo = ld; hi = lu + hw2;\n\t\t}\n\t\tif(lo >= hw2){\n\t\t\tlo -= hw2;\n\t\t\thi -= hw2;\n\t\t}\n\t\tranges[i] = pii(lo, hi);\n\t}\n\tsort(\n\t\tranges.begin(), ranges.end(),\n\t\t[](const pii &a, const pii &b){\n\t\t\treturn (a.second == b.second) ? (a.first < b.first) : (a.second < b.second);\n\t\t});\n\tint answer = INF;\n\tfor(int i = 0; i < n; ++i){\n\t\tconst int hw2 = (h + w) * 2;\n\t\tvector<pii> r;\n\t\tfor(int j = i; j < n; ++j){ r.push_back(ranges[j]); }\n\t\tfor(int j = 0; j < i; ++j){\n\t\t\tr.emplace_back(ranges[j].first + hw2, ranges[j].second + hw2);\n\t\t}\n\t\tint count = 1, last = r[0].second;\n\t\tfor(int j = 0; j < n; ++j){\n\t\t\tif(r[j].first <= last){ continue; }\n\t\t\tif(r[j].second >= r[0].second + hw2){ continue; }\n\t\t\t++count;\n\t\t\tlast = r[j].second;\n\t\t}\n\t\tanswer = min(answer, count);\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\tint n, w, d;\n\twhile(cin >> n >> w >> d){\n\t\tvector< pair<int, int> > base;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x, y; char f;\n\t\t\tcin >> x >> y >> f;\n\t\t\tint a, b;\n\t\t\tif(f == 'S'){\n\t\t\t\ta = x;\n\t\t\t\tb = y;\n\t\t\t} else if(f == 'E'){\n\t\t\t\ta = w+y;\n\t\t\t\tb = w-x;\n\t\t\t} else if(f == 'N') {\n\t\t\t\ta = w+d+w-x;\n\t\t\t\tb = d-y;\n\t\t\t} else if(f == 'W'){\n\t\t\t\ta = 2*w+d+d-y;\n\t\t\t\tb = x;\n\t\t\t}\n\t\t\tbase.push_back(make_pair(a-b, a+b));\n\t\t}\n\t\tint res = n;\n\t\tvector<int> startPos;\n\t\tfor(const pair<int, int> pr : base){\n\t\t\tstartPos.push_back(pr.first);\n\t\t\tstartPos.push_back(pr.second);\n\t\t}\n\t\tfor(int i=0;i<startPos.size();i++){\n\t\t\tvector< pair<int, int> > vp;\n\t\t\tint start = startPos[i];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tbool ok = false;\n\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\tif(base[j].first+k*2*(w+d) <= start && start <= base[j].second+k*2*(w+d)) ok = true;\n\t\t\t\t}\n\t\t\t\tif(ok) continue;\n\t\t\t\tvp.push_back(base[j]);\n\t\t\t\tif(vp.back().second < start){\n\t\t\t\t\tvp.back().first += 2*(w+d);\n\t\t\t\t\tvp.back().second += 2*(w+d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 1, pos = start;\n\t\t\tsort(vp.begin(),\n\t\t\t\t vp.end(),\n\t\t\t\t [](const pair<int, int>& a, const pair<int, int>& b){\n\t\t\t\t\treturn a.second == b.second ? a.first < b.first : a.second < b.second;\n\t\t\t\t });\n\t\t\tfor(int j=0;j<vp.size();j++){\n\t\t\t\tif(vp[j].first > pos){\n\t\t\t\t\t++cnt;\n\t\t\t\t\tpos = vp[j].second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = min(res, cnt);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nint n, w, h;\n\nint ru(int x, int y) {\n\tpii p1(x+h-y, h);\n\tpii p2(w, y+w-x);\n\tif(abs(p1.fi-x)+abs(p1.se-y) < abs(p2.fi-x)+abs(p2.se-y)) {\n\t\treturn h+p1.fi;\n\t} else {\n\t\treturn h*2 + w - p2.se;\n\t}\n}\n\nint rd(int x, int y) {\n\tpii p1(w, y-(w-x));\n\tpii p2(x+y, 0);\n\tif(abs(p1.fi-x)+abs(p1.se-y) < abs(p2.fi-x)+abs(p2.se-y)) {\n\t\treturn w+h*2-p1.se;\n\t} else {\n\t\treturn w*2 + h*2 - p2.fi;\n\t}\n}\n\nint lu(int x, int y) {\n\tpii p1(0, y+x);\n\tpii p2(x-(h-y), h);\n\tif(abs(p1.fi-x)+abs(p1.se-y) < abs(p2.fi-x)+abs(p2.se-y)) {\n\t\treturn p1.se;\n\t} else {\n\t\treturn h + p2.fi;\n\t}\n}\n\nint ld(int x, int y) {\n\tpii p1(0, y-x);\n\tpii p2(x-y, 0);\n\tif(abs(p1.fi-x)+abs(p1.se-y) < abs(p2.fi-x)+abs(p2.se-y)) {\n\t\treturn p1.se;\n\t} else {\n\t\treturn w*2 + h*2 - p2.fi;\n\t}\n}\n\nbool sortBySecond(const pii& lhs, const pii& rhs) {\n\tif( lhs.se == rhs.se ) {\n\t\treturn lhs.fi < rhs.fi;\n\t}\n\treturn lhs.se < rhs.se;\n}\n\nint main() {\n\tcin >> n >> w >> h;\n\tvector<pii> vp;\n\trep(i, n) {\n\t\tint x, y;\n\t\tchar f;\n\t\tcin >> x >> y >> f;\n\t\tif(f=='E') vp.push_back( pii(ru(x,y), rd(x,y)) );\n\t\tif(f=='W') vp.push_back( pii(ld(x,y), lu(x,y)) );\n\t\tif(f=='N') vp.push_back( pii(lu(x,y), ru(x,y)) );\n\t\tif(f=='S') vp.push_back( pii(rd(x,y), ld(x,y)) );\n\t\tif(vp[i].fi > vp[i].se) {\n\t\t\tvp[i].se += w*2 + h*2;\n\t\t}\n\t}\n\n\tint res = 10000000;\n\tfor(int s=0; s<n; s++) {\n\t\tsort(vp.begin(), vp.end(), sortBySecond);\n\t\tint cnt = 1;\n\t\tint pos = vp[0].se;\n\t\tfor(int i=1; i<n; i++) {\n\t\t\tif(vp[i].fi <= pos && pos <= vp[i].se) {\n\t\t\t} else {\n\t\t\t\tcnt++;\n\t\t\t\tpos = vp[i].se;\n\t\t\t}\n\t\t}\n\t\tres = min(res, cnt);\n\t\tvp[0].fi += w*2 + h*2;\n\t\tvp[0].se += w*2 + h*2;\n\t}\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nint n,w,d;\nint s[1010],g[1010];\n\ninline int convert(int x,int y){\n\tif(x==0) return y;\n\tif(y==d) return d+x;\n\tif(x==w) return d+w+(d-y);\n\tif(y==0) return d+w+d+(w-x);\n\treturn 0;\n}\n\nint main(void){\n\tcin >> n >> w >> d;\n\trep(i,n){\n\t\tint x,y;\n\t\tchar w;\n\t\tcin >> x >> y >> w;\n\n\t\tconst int u=d-y,b=y,l=x,r=w-x;\n\n\t\tswitch(w){\n\t\t\tcase 'N':\n\t\t\t\ts[i]=(l<=u?convert(0,y+l):convert(x-u,d));\n\t\t\t\tg[i]=(r<=u?convert(w,y+r):convert(x+u,d));\n\t\t\t\tbreak;\n\n\t\t\tcase 'W':\n\t\t\t\ts[i]=(b<=l?convert(x-b,0):convert(w,y-l));\n\t\t\t\tg[i]=(u<=l?convert(x-u,d):convert(w,y+l));\n\t\t\t\tbreak;\n\n\t\t\tcase 'E':\n\t\t\t\ts[i]=(u<=r?convert(x+u,d):convert(w,y+r));\n\t\t\t\tg[i]=(b<=r?convert(x+b,0):convert(w,y-r));\n\t\t\t\tbreak;\n\n\t\t\tcase 'S':\n\t\t\t\ts[i]=(r<=b?convert(w,y-r):convert(x+b,0));\n\t\t\t\tg[i]=(l<=b?convert(0,y-l):convert(x-b,0));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tconst int all=2*(w+d);\n\tusing state=tuple<int,int>;\n\tvector<state> ary;\n\trep(i,n){\n\t\tif(s[i]>g[i]) g[i]+=all;\n\t\tary.push_back(make_tuple(s[i],g[i]));\n\t}\n\n\tsort(_all(ary));\n\trep(i,n){\n\t\tint cs,cg;\n\t\ttie(cs,cg)=ary[i];\n\t\tary.push_back(make_tuple(cs+all,cg+all));\n\t}\n\t//rep(i,n) cout << get<0>(ary[i]) << \" \" << get<1>(ary[i]) << endl;\n\n\tint ans=n;\n\trep(i,n){\n\t\tint cur=get<1>(ary[i]),j=i+1,res=1;\n\t\twhile(j-i<n){\n\t\t\tif(cur<get<0>(ary[j])) cur=get<1>(ary[j]),res++;\n\t\t\tj++;\n\t\t}\n\t\tchmin(ans,res);\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint main()\n{\n  int N, W, D;\n  cin >> N >> W >> D;\n\n  int L = D + D + W + W;\n  deque< pair< int, int > > range;\n  for(int i = 0; i < N; i++) {\n    int X, Y;\n    char F;\n    cin >> X >> Y >> F;\n    if(F == 'N') range.emplace_back(X + Y, D + X + D - Y);\n    if(F == 'E') range.emplace_back(D + X + D - Y, L - X - Y);\n    if(F == 'S') range.emplace_back(L - X - Y, L - X + Y);\n    if(F == 'W') range.emplace_back(L - X + Y, X + Y + L);\n  }\n\n\n  int ret = INF;\n  for(int i = 0; i < N; i++) {\n\n    sort(begin(range), end(range), [&](pair< int, int > a, pair< int, int > b)\n    {\n      swap(a.first, a.second);\n      swap(b.first, b.second);\n      return (a < b);\n    });\n\n    int count = 0;\n    for(int j = 0; j < N;) {\n      int ps = range[j].second;\n      while(j < N && range[j].first <= ps) ++j;\n      ++count;\n    }\n    ret = min(ret, count);\n    range.front().first += L;\n    range.front().second += L;\n    range.push_back(range.front());\n    range.pop_front();\n  }\n  cout << ret << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\tint n, w, d;\n\twhile(cin >> n >> w >> d){\n\t\tvector< pair<int, int> > base;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x, y; char f;\n\t\t\tcin >> x >> y >> f;\n\t\t\tint a, b;\n\t\t\tif(f == 'S'){\n\t\t\t\ta = x;\n\t\t\t\tb = y;\n\t\t\t} else if(f == 'E'){\n\t\t\t\ta = w+y;\n\t\t\t\tb = w-x;\n\t\t\t} else if(f == 'N') {\n\t\t\t\ta = w+d+w-x;\n\t\t\t\tb = d-y;\n\t\t\t} else if(f == 'W'){\n\t\t\t\ta = 2*w+d+d-y;\n\t\t\t\tb = x;\n\t\t\t}\n\t\t\tbase.push_back(make_pair(a-b, a+b));\n\t\t}\n\t\tint res = n;\n\t\tvector< pair<int, int> > vp(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint start = base[i].second;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tvp[j] = base[j];\n\t\t\t\tif(vp[j].second < start){\n\t\t\t\t\tvp[j].first += 2*(w+d);\n\t\t\t\t\tvp[j].second += 2*(w+d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 1, pos = start;\n\t\t\tsort(vp.begin(), vp.end(), [](const pair<int, int>& a, const pair<int, int>& b){ return a.second == b.second ? a.first < b.first : a.second < b.second; });\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(vp[j].first > pos){\n\t\t\t\t\t++cnt;\n\t\t\t\t\tpos = vp[j].second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = min(res, cnt);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nint n,w,d;\nint s[1010],g[1010];\n\ninline int convert(int x,int y){\n\tif(x==0) return y;\n\tif(y==d) return d+x;\n\tif(x==w) return d+w+(d-y);\n\tif(y==0) return d+w+d+(w-x);\n\treturn 0;\n}\n\nint main(void){\n\tcin >> n >> w >> d;\n\trep(i,n){\n\t\tint x,y;\n\t\tchar w;\n\t\tcin >> x >> y >> w;\n\n\t\tconst int u=d-y,b=y,l=x,r=w-x;\n\n\t\tswitch(w){\n\t\t\tcase 'N':\n\t\t\t\ts[i]=(l<=u?convert(0,y+l):convert(x-u,d));\n\t\t\t\tg[i]=(r<=u?convert(w,y+r):convert(x+u,d));\n\t\t\t\tbreak;\n\n\t\t\tcase 'W':\n\t\t\t\ts[i]=(b<=l?convert(x-b,0):convert(w,y-l));\n\t\t\t\tg[i]=(u<=l?convert(x-u,d):convert(w,y+l));\n\t\t\t\tbreak;\n\n\t\t\tcase 'E':\n\t\t\t\ts[i]=(u<=r?convert(x+u,d):convert(w,y+r));\n\t\t\t\tg[i]=(b<=r?convert(x+b,0):convert(w,y-r));\n\t\t\t\tbreak;\n\n\t\t\tcase 'S':\n\t\t\t\ts[i]=(r<=b?convert(w,y-r):convert(x+b,0));\n\t\t\t\tg[i]=(l<=b?convert(0,y-l):convert(x-b,0));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tconst int all=2*(w+d);\n\tusing state=tuple<int,int>;\n\n\tint ans=n;\n\n\trep(i,n){\n\t\tvector<state> ary;\n\t\tint start=g[i];\n\n\t\trep(j,n){\n\t\t\tif(j==i) continue;\n\t\t\tbool add=true;\n\t\n\t\t\tif(s[j]<=g[j]){\n\t\t\t\tif(s[j]<=start && start <= g[j]) add=false;\n\t\t\t}else{\n\t\t\t\tif(start<=g[j]||s[j]<=start) add=false;\n\t\t\t}\n\n\t\t\tif(add){\n\t\t\t\tint cs=(s[j]-start+all)%all,cg=(g[j]-start+all)%all;\n\t\t\t\tary.push_back(make_tuple(cg,cs));\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tsort(_all(ary));\n\t\t\n\t\tint res=1,cur=0;\n\t\t\n\t\tfor(auto &it:ary){\n\t\t\tif(cur<get<1>(it)) \n\t\t\t\tcur=get<0>(it),res++;\n\t\t}\n\n\t\tchmin(ans,res);\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if(a < b) {a = b; return true;}\n  return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if(a > b) {a = b; return true;}\n  return false;\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  for(int i=0;i<((int)(v.size()));++i) {\n    if(i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\nP pos0(int i, int j, int w, int d) {\n  int mi = min(i, j);\n  return make_pair(i-mi, j-mi);\n}\nP pos1(int i, int j, int w, int d) {\n  int mi = min(i, w-j);\n  return make_pair(i-mi, j+mi);\n}\nP pos2(int i, int j, int w, int d) {\n  int mi = min(d-i, w-j);\n  return make_pair(i+mi, j+mi);\n}\nP pos3(int i, int j, int w, int d) {\n  int mi = min(d-i, j);\n  return make_pair(i+mi, j-mi);\n}\nint rect_to_range(int r, int c, int w, int d) {\n  if(r == 0 && c != w) {\n    return c;\n  } else if(c == w && r != d) {\n    return w + r;\n  } else if(r == d && c != 0) {\n    return w + d + (w-c);\n  } else {\n    return 2 * w + d + (d-r);\n  }\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  int n, w, d; cin >> n >> w >> d;\n  vector<P> v(3*n);\n  for(int i=0;i<(n);++i) {\n    int x, y; char f; cin >> x >> y >> f;\n    P l, r;\n    if(f == 'S') {\n      l = pos0(y, x, w, d);\n      r = pos1(y, x, w, d);\n    } else if(f == 'E') {\n      l = pos1(y, x, w, d);\n      r = pos2(y, x, w, d);\n    } else if(f == 'N') {\n      l = pos2(y, x, w, d);\n      r = pos3(y, x, w, d);\n    } else {\n      l = pos3(y, x, w, d);\n      r = pos0(y, x, w, d);\n    }\n    v[i].first = rect_to_range(l.first, l.second, w, d);\n    v[i].second = rect_to_range(r.first, r.second, w, d);\n    if(v[i].first > v[i].second) v[i].second += 2 * (w + d);\n  }\n  for(int i=(n);i<(2*n);++i) {\n    v[i].first = v[i-n].first + 2*(w+d);\n    v[i].second = v[i-n].second + 2*(w+d);\n  }\n  for(int i=(2*n);i<(3*n);++i) {\n    v[i].first = v[i-n].first + 2*(w+d);\n    v[i].second = v[i-n].second + 2*(w+d);\n  }\n  set<int> st;\n  for(int i=0;i<(3*n);++i) {\n    st.insert(v[i].first);\n    st.insert(v[i].second);\n  }\n  map<int, int> mp;\n  int id = 0;\n  for(auto &e: st) {\n    mp[e] = id;\n    id++;\n  }\n  for(int i=0;i<(3*n);++i) {\n    v[i].first = mp[v[i].first];\n    v[i].second = mp[v[i].second];\n  }\n  vvi be(id), ed(id);\n  for(int i=0;i<(3*n);++i) {\n    be[v[i].first].push_back(i);\n    ed[v[i].second].push_back(i);\n  }\n  int mi = INF;\n  for(int i=0;i<(id);++i) {\n    vector<bool> sel(n);\n    vector<int> now;\n    int cnt = 0;\n    int nowbeg = i;\n    for(int j=(i);j<(id);++j) {\n      for(int k=0;k<((int)(be[j].size()));++k) {\n        now.push_back(be[j][k]);\n      }\n      bool ok = false;\n      for(int k=0;k<((int)(ed[j].size()));++k) {\n        int idx = ed[j][k];\n        if(!sel[idx%n] && v[idx].first >= nowbeg) {\n          ok = true;\n          break;\n        }\n      }\n      if(ok) {\n        nowbeg = j+1;\n        cnt++;\n        for(auto &e: now) {\n          sel[e%n] = true;\n        }\n        now.clear();\n      }\n    }\n    bool ok = true;\n    for(int j=0;j<(n);++j) ok &= sel[j];\n    if(ok) {\n      chmin(mi, cnt);\n    }\n  }\n  cout << mi << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\n#include <ctype.h> // isdigit\n#include <cassert>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(u) begin(u),end(u)\n#define PB push_back\n#define LE(n,m) ((n) < (m) + EPS * (abs(n) + abs(m)))\n#define GE(n,m) ((n) + EPS * (abs(n) + abs(m)) > (m))\n#define LT(n,m) ((n) + EPS * (abs(n) + abs(m)) < (m))\n#define GT(n,m) ((n) > (m) + EPS * (abs(n) + abs(m)))\n#define EQ(n,m) (abs((n)-(m)) < EPS * (abs(n) + abs(m)))\n\ntypedef long long int ll;\nconst int INF = (1<<30) - 1;\nconst double EPS = 1e-9;\nconst int MOD = 1000000007;\n\ntypedef complex<double> P;\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    //cout.setf(ios::fixed);\n    \n    int N, W, D;\n    cin >> N >> W >> D;\n    int L = 2 * (W + D);\n    P p1 = P(W, 0);\n    P p2 = P(W, D);\n    P p3 = P(0, D);\n    P C = P(0, -1);\n    \n    //end, start\n    vector<pair<int, int>> lines;\n    \n    for(int i=0; i<N; i++){\n        int x, y; string f;\n        cin >> x >> y >> f;\n        P p = P(x, y);\n        \n        switch (f[0]) {\n            case 'W':\n                p = (p - p3) * C + p3;\n            case 'N':\n                p = (p - p2) * C + p2;\n            case 'E':\n                p = (p - p1) * C + p1;\n            default:\n                break;\n        }\n        lines.emplace_back(p.real()+p.imag(), p.real()-p.imag());\n    }\n    sort(lines.begin(), lines.end());\n    \n    int ans = INF;\n    for(int s=0; s<N; s++){\n        int tans = 0;\n        int p = lines[0].first;\n        int i = 0;\n        while(i<N){\n            while(i<N && lines[i].second <= p) i++;\n            p = lines[i].first;\n            tans++;\n        }\n        ans = min(ans, tans);\n        \n        lines[0].first += L;\n        lines[0].second += L;\n        sort(lines.begin(), lines.end());\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nint n, w, d;\nP v[1002];\n\n\nint main() {\n    cin >> n >> w >> d;\n    int l = 2 * d + 2 * w; \n\n    for (int i = 0; i < n; ++i) {\n        int x, y;\n        char f;\n        cin >> x >> y >> f;\n        int c, b;\n        switch (f) {\n            case 'N':\n                c = x;\n                b = d - y;\n            break;\n            case 'E':\n                c = d - y + w;\n                b = w - x;\n            break;\n            case 'S':\n                c = w - x + w + d;\n                b = y;\n            break;\n            case 'W':\n                c = y + 2 * w + d;\n                b = x;\n            break;\n        }\n        \n        // v[i] = (left end of view, right end of view)\n\n        v[i] = P ((c - b + l) % l, (c + b + l) % l);\n    } \n\n    // sort by the left end of view\n\n    sort(v, v + n);\n\n    int minc = 10000;\n    for (int i = 0; i < n; ++i) {\n        \n        // Put a clock at the left end of i-th member's view\n\n        int c = 1;\n        int tmp = v[i].first;\n        for (int j = 1; j < n; ++ j) {\n            int k = (i - j + n) % n;\n\n            int left = v[k].first;\n            int right = v[k].second;\n            if (left > right) right += l;\n            if (left <= tmp && tmp <= right) continue;\n            if (left - l <= tmp && tmp <= right - l) continue;\n\n            c++;\n            tmp = left;\n        }\n        \n        if (c < minc) minc = c;\n    }\n    cout << minc << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <cstdio>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long double ldb;\ntypedef complex<ldb> P;\n\nconst ldb eps = 1e-9;\nconst ldb pi = acos(-1);\nint sig(ldb a) {return (a<-eps)?-1:(a>eps)?1:0;}\nbool eq(ldb a,ldb b){return abs(a-b)<eps;}\nldb dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\nldb cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nldb ang(P a,P b,P c) {\n  P p = a-b;\n  P q = c-b;\n  if( eq(abs(p)*abs(q),0) ) return 0;\n  return acos(dot(p,q)/(abs(p)*abs(q)));\n}\n\nstruct L {\n  P a,b;\n  L(){}\n  L(P a,P b):a(a),b(b){}\n  ldb len(){return abs(a-b);}\n  P vec(){return b-a;}\n};\n\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\nint ccw(L s, P p) {\n  P a = s.vec();\n  p -= s.a;\n  ldb cr = cross(a, p);\n  if (eq(cr, 0)) {\n    if (sig(dot(a, p)) < 0) return BACK;\n    if (sig(norm(a) - norm(p)) < 0) return FRONT;\n    return ON;\n  }\n  return (cr > 0) ? LEFT : RIGHT;\n}\n\nP iP2(L a,L b) {\n  P c = b.b-b.a;\n  ldb d1 = abs(cross(c, a.a-b.a));\n  ldb d2 = abs(cross(c, a.b-b.a));\n  ldb t = d1 / (d1 + d2);\n  return a.a + (a.b-a.a) * t;\n}\n\nbool iI2_2(L a, L b) {\n  int cwa = ccw(a, b.a) | ccw(a, b.b);\n  int cwb = ccw(b, a.a) | ccw(b, a.b);\n  return ((cwa | cwb) & ON) || ((cwa & cwb) == (LEFT | RIGHT));\n}\n\nint n, w, d;\nint x[1111], y[1111];\nchar f[1111];\nP mid;\n\npair<int, int> tp(const P& p) {\n  return {p.real()+0.4, p.imag()+0.4};\n}\n\nint main(void) {\n  scanf(\"%d%d%d\", &n, &w, &d);\n\n  mid = P(w/2.0, d/2.0);\n  \n  for (int i = 0; i < n; i++) {\n    scanf(\"%d%d %c\", x+i, y+i, f+i);\n  }\n\n  vector<L> ls {\n    L(P(0, 0), P(w, 0)),\n        L(P(0, 0), P(0, d)),\n        L(P(w, 0), P(w, d)),\n        L(P(0, d), P(w, d)),\n  };\n  vector<P> p1, p2;\n  vector<tuple<ldb, ldb, int>> a;\n  vector<pair<int, int>> pos;\n  const int I = 1000000;\n\n  for (int i = 0; i < n; i++) {\n    L l1, l2;\n    P pos(x[i], y[i]);\n    if (f[i] == 'N') {\n      l1 = L(pos, P(x[i]+I, y[i]+I));\n      l2 = L(pos, P(x[i]-I, y[i]+I));\n    } else if (f[i] == 'W') {\n      l1 = L(pos, P(x[i]-I, y[i]+I));\n      l2 = L(pos, P(x[i]-I, y[i]-I));\n    } else if (f[i] == 'S') {\n      l1 = L(pos, P(x[i]-I, y[i]-I));\n      l2 = L(pos, P(x[i]+I, y[i]-I));\n    } else {\n      l1 = L(pos, P(x[i]+I, y[i]-I));\n      l2 = L(pos, P(x[i]+I, y[i]+I));\n    }\n    for (int i = 0; i < 4; i++) {\n      if (iI2_2(l1, ls[i])) {\n        p1.push_back(iP2(l1, ls[i]));\n        break;\n      }\n    }\n    for (int i = 0; i < 4; i++) {\n      if (iI2_2(l2, ls[i])) {\n        p2.push_back(iP2(l2, ls[i]));\n        break;\n      }\n    }\n  }\n\n  for (int i = 0; i < int(p1.size()); i++) {\n    pos.push_back(tp(p1[i]));\n    pos.push_back(tp(p2[i]));\n  }\n  sort(pos.begin(), pos.end());\n  pos.erase(unique(pos.begin(), pos.end()), pos.end());\n\n  vector<ldb> cl;\n  for (int i = 0; i < int(pos.size()); i++) {\n    cl.push_back(arg(mid-P(pos[i].first, pos[i].second))+pi);\n  }\n  sort(cl.begin(), cl.end());\n\n  /*\n  for (int i = 0; i < int(pos.size()); i++) {\n    printf(\"%d %d\\n\", pos[i].first, pos[i].second);\n  }\n  */\n\n  /*\n  for (int i = 0; i < int(cl.size()); i++) {\n    printf(\"%.10Lf\\n\", cl[i]/pi*180);\n  }\n  //*/\n\n  for (int i = 0; i < int(p1.size()); i++) {\n    ldb a1 = arg(mid-p1[i])+pi;\n    ldb a2 = arg(mid-p2[i])+pi;\n    if (a1 > a2) a2 += 2*pi;\n    a.emplace_back(a1, a2, i);\n  }\n  sort(a.begin(), a.end());\n\n  /*\n  for (int i = 0; i < int(a.size()); i++) {\n    printf(\"%20.10Lf %20.10Lf \", get<0>(a[i])/pi*180, get<1>(a[i])/pi*180);\n    printf(\"%d\\n\", get<2>(a[i]));\n  }\n  //*/\n\n  int res = 114514;\n  for (int i = 0; i < n; i++) {\n    int u[2222] {};\n    int b = 0;\n    for (int j = 0; j < int(cl.size()); j++) {\n      if ((sig(get<0>(a[i])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[i])) <= 0) ||\n          (sig(get<0>(a[i])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[i])) <= 0)) {\n        b = j;\n      }\n    }\n    // printf(\"%d\\n\", b);\n    int c = 0;\n    int j = b;\n    u[j] = 1;\n    int k = (i+1)%n;\n    while (k != i) {\n      // printf(\"%d %d\\n\", k, j);\n      while (k != i && ((sig(get<0>(a[k])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[k])) <= 0) ||\n              (sig(get<0>(a[k])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[k])) <= 0))) {\n        k = (k+1)%n;\n      }\n      if (k != i) {\n        while (!((sig(get<0>(a[k])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[k])) <= 0) ||\n                 (sig(get<0>(a[k])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[k])) <= 0))) {\n          j = (j+1)%cl.size();\n        }\n        int pj = j;\n        while (((sig(get<0>(a[k])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[k])) <= 0) ||\n                 (sig(get<0>(a[k])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[k])) <= 0))) {\n          pj = j;\n          j = (j+1)%cl.size();\n        }\n        j = pj;\n        u[j] = 1;\n      }\n    }\n    /*\n    for (int p = 0; p < int(cl.size()); p++) {\n      c += u[p];\n      printf(\"%d \", u[p]);\n    }\n    puts(\"\");\n    */\n    res = min(res, c);\n  }  \n\n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, W, D;\nvector<pair<int, int> > interval;\n\nint projection(int x, int y, int dx, int dy){\n\tint dist = 1000000000;\n\tint xx = x;\n\tint yy = y;\n\tif(dx > 0) dist = min(dist, W - x);\n\tif(dx < 0) dist = min(dist, x);\n\tif(dy > 0) dist = min(dist, D - y);\n\tif(dy < 0) dist = min(dist, y);\n\tx += dist * dx;\n\ty += dist * dy;\n\tint ret;\n\tif(x == 0) ret =  y;\n\telse if(y == D) ret = D + x;\n\telse if(x == W) ret =  D + W + (D - y);\n\telse ret =  D + W + D + (W - x);\n\treturn ret;\n}\n\n\n\nint main(){\n\tcin >> N >> W >> D;\n\tfor(int i = 0; i < N; i++){\n\t\tint x, y; char c;\n\t\tcin >> x >> y >> c;\n\t\tint s, e;\n\t\tif(c == 'N'){\n\t\t\ts = projection(x, y, -1, 1);\n\t\t\te = projection(x, y, 1, 1);\n\t\t}else if(c == 'E'){\n\t\t\ts = projection(x, y,  1, 1);\n\t\t\te = projection(x, y, 1, -1);\n\t\t}else if(c == 'S'){\n\t\t\ts = projection(x, y, 1, -1);\n\t\t\te = projection(x, y, -1, -1);\n\t\t}else if(c == 'W'){\n\t\t\ts = projection(x, y, -1, -1);\n\t\t\te = projection(x, y, -1, 1);\n\t\t}\n\t\tif(s > e) e += 2 * W + 2 * D;\n\t\tinterval.push_back({e, s});\n\t}\n\tsort(interval.begin(), interval.end());\n\n\tint ans = 10000000;\n\tfor(int i = 0; i < N; i++){\n\t\tint a1 = 1;\n\t\tint start = interval[i].first;\n\t\tint cur = start;\n\t\t//cout << \"=======\" << i << \"===========\" << endl;\n\t\tfor(int j = 1; j < N; j++){\n\t\t\tint e = interval[i + j].first;\n\t\t\tint s = interval[i + j].second;\n\t\t//\tprintf(\"%d+%d (%d, %d) %d %d\\n\", i, j, s, e, cur, start);\n\t\t\tif(cur < s && start + 2 * W + 2 + D > e){\n\t\t\t\ta1 += 1;\n\t\t\t\tcur = e;\n\t\t\t}\n\t\t}\n\t\t//cout << \"(\" << a1 << \")\" << endl;\n\t\tans = min(ans, a1);\n\t\tint e = interval[i].first + 2 * W + 2 * D;\n\t\tint s = interval[i].second + 2 * W + 2 * D;\n\t\tinterval.push_back({e, s});\n\t}\n\tcout << ans << endl;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld eps = 1e-9;\n\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n};\n\ntemplate<typename T>\nusing Graph = vector<vector<edge<T>>>;\n\nusing State = string::const_iterator;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    // ifstream in(\"in.txt\");\n    // cin.rdbuf(in.rdbuf());\n\n    int n, w, d; cin >> n >> w >> d;\n    vector<P> events;\n    REP(i, n) {\n        int x, y;\n        char dir;\n        cin >> x >> y >> dir;\n        if (dir == 'W') {\n            events.emplace_back(-x + y, x + y);\n        }\n        if (dir == 'N') {\n            events.emplace_back(x + y, (d - y) - (w - x) + d + w);\n        }\n        if (dir == 'E') {\n            events.emplace_back((d - y) - (w - x) + d + w, (d - y) + (w - x) + d + w);\n        }\n        if (dir == 'S') {\n            events.emplace_back((d - y) + (w - x) + d + w, -x + y + 2 * d + 2 * w);\n        }\n    }\n    sort(ALL(events), [&](P a, P b){ return a.second < b.second; });\n\n    int ans = n;\n    REP(i, SZ(events)) {\n        auto tmp = events;\n        REP(j, i) {\n            if (tmp[j].second < tmp[i].second) {\n                tmp[j].first += 2*d + 2*w;\n                tmp[j].second += 2*d + 2*w;\n            }\n        }\n        sort(ALL(tmp), [&](P a, P b){ return a.second < b.second; });\n        int sum = 1, prev = tmp[0].second;\n        FOR(k, 1, SZ(tmp)) {\n            if (prev < tmp[k].first) {\n                prev = tmp[k].second;\n                ++sum;\n            }\n        }\n        chmin(ans, sum);\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P1;\nint n,w,d,x,y,ans;\nvector<P1> v;\nchar f;\nstack<int> q;\nbool used[N];\n\nvoid add_point(int num){\n  if(f=='N'){\n    if(x+y<d)v.push_back(P1(P(x+y+w*2+d,0),num));\n    else v.push_back(P1(P(x+y-d,0),num));\n    if(w+y-x<d)v.push_back(P1(P(d-(w+y-x)+w,1),num));\n    else v.push_back(P1(P(d-(y-x),1),num));\n  }\n  if(f=='E'){\n    if(d-(y-x)<w)v.push_back(P1(P(d-(y-x),0),num));\n    else v.push_back(P1(P(d-(w+(y-x))+w,0),num));\n    if(y+x<w)v.push_back(P1(P(w-(y+x)+w+d,1),num));\n    else v.push_back(P1(P(d-(-w+y+x)+w,1),num));\n  }\n  if(f=='S'){\n    if(0<=-w+y+x)v.push_back(P1(P(d-(-w+y+x)+w,0),num));\n    else v.push_back(P1(P(w-(y+x)+w+d,0),num));\n    if(0<=y-x)v.push_back(P1(P(y-x+w*2+d,1),num));\n    else v.push_back(P1(P(w-(-(y-x))+w+d,1),num));\n  }\n  if(f=='W'){\n    if(0<=-(y-x))v.push_back(P1(P(w-(-(y-x))+w+d,0),num));\n    else v.push_back(P1(P(y-x+w*2+d,0),num));\n    if(0<=y+x-d)v.push_back(P1(P(y+x-d,1),num));\n    else v.push_back(P1(P(y+x+w*2+d,1),num));\n  }\n}\n\nbool usednum[500000];\n\nvoid solve(){\n  int len=v.size(),cnt;\n  for(int i=0;i<len;i++){\n    memset(used,0,sizeof(used));\n    memset(usednum,0,sizeof(usednum));\n    if(v[i].first.second)continue;\n    cnt=0;\n    for(int j=i;j<len+i;j++){\n      int idx=j%len;\n      if(used[v[idx].second])continue;\n      if(!v[idx].first.second)q.push(v[idx].second);\n      else{\n\tcnt++;\n\tif(usednum[v[idx].first.first])cnt--;\n\tusednum[v[idx].first.first]=true;\n\t//used[v[idx].second]=true;\n\twhile(!q.empty()){\n\t  int num=q.top(); q.pop();\n\t  used[num]=true;\n\t}\n      }\n    }\n    ans=min(ans,cnt);\n  }\n}\n\nint main(){\n  cin>>n>>w>>d;\n  for(int i=0;i<n;i++){\n    cin>>x>>y>>f;\n    add_point(i);\n  }\n  sort(v.begin(),v.end());\n  ans=(1e9);\n  solve();\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <tuple>\n\nusing namespace std;\ntypedef pair<int, int> pii;\nstatic const int INF = 1000000000;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tvector<pii> ranges;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x, y;\n\t\tstring f;\n\t\tcin >> x >> y >> f;\n\t\tconst int hw2 = h + w + h + w;\n\t\tconst int lu = y + x;\n\t\tconst int ru = h + x + (h - y);\n\t\tconst int rd = h + w + (h - y) + (w - x);\n\t\tconst int ld = h + w + h + (w - x) + y;\n\t\tint lo = 0, hi = 0;\n\t\tif(f[0] == 'N'){\n\t\t\tlo = lu; hi = ru;\n\t\t}else if(f[0] == 'E'){\n\t\t\tlo = ru; hi = rd;\n\t\t}else if(f[0] == 'S'){\n\t\t\tlo = rd; hi = ld;\n\t\t}else if(f[0] == 'W'){\n\t\t\tlo = ld; hi = lu + hw2;\n\t\t}\n\t\tif(lo >= hw2){\n\t\t\tlo -= hw2;\n\t\t\thi -= hw2;\n\t\t}\n\t\tranges.emplace_back(lo, hi);\n\t\tranges.emplace_back(lo + hw2, hi + hw2);\n\t}\n\tsort(ranges.begin(), ranges.end());\n\tint answer = INF;\n\tfor(int i = 0; i < n; ++i){\n\t\tconst int hw2 = (h + w) * 2;\n\t\tvector<pii> r(ranges.begin() + i, ranges.begin() + i + n);\n\t\tsort(r.begin(), r.end(), [](const pii &a, const pii &b){\n\t\t\treturn (a.second == b.second) ? (a.first < b.first) : (a.second < b.second);\n\t\t});\n\t\tint count = 1, last = r[0].second;\n\t\tfor(int j = 0; j < n; ++j){\n\t\t\tif(r[j].first <= last){ continue; }\n\t\t\tif(r[j].second >= r[0].second + hw2){ continue; }\n\t\t\t++count;\n\t\t\tlast = r[j].second;\n\t\t}\n\t\tanswer = min(answer, count);\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tint n,X,Y;\n\tcin>>n>>X>>Y;\n\tvp in(n);\n\trep(i,n){\n\t\tint a,b;char d;\n\t\tpii c;\n\t\tcin>>a>>b>>d;\n\t\tif(d=='N')c={a,Y-b};\n\t\tif(d=='E')c={X+Y-b,X-a};\n\t\tif(d=='S')c={X+Y+X-a,b};\n\t\tif(d=='W')c={X+Y+X+b,a};\n\t\tint l=c.first-c.second,r=c.first+c.second;\n\t\tif(l<0)l+=X+X+Y+Y,r+=X+X+Y+Y;\n\t\tin[i]={r,l};\n\t}\n\tint out=inf;\n//\trep(i,n)cout<<in[i].second<<\" \"<<in[i].first<<endl;\n\trep(i,2*n){\n\t\tsort(all(in));\n\t\tint co=0;\n\t\tint mi=-1;\n\t//\trep(j,n)cout<<in[j].second<<\" \"<<in[j].first<<endl;\n\t\trep(j,n){\n\t\t\tif(mi<in[j].second){\n\t\t\t\tmi=in[j].first;\n\t\t\t\tco++;\n\t\t\t}\n//\t\t\tcout<<mi<<\" \"<<co<<endl;\n\t\t}\n//\t\tif(co==6){\n//\t\t\tcout<<i<<endl;\n//\t\t\trep(j,n)cout<<in[j].second<<\" \"<<in[j].first<<endl;\n//\t\t\treturn 0;\n//\t\t}\n\t\tout=min(out,co);\n\t\tin.pb({in[0].first+X+X+Y+Y,in[0].second+X+X+Y+Y});\n\t\tin.erase(in.begin());\n\t}\n\tcout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\nusing namespace std;\nint dtoi(char c) { // direction to index\n    return c == 'N' ? 0 :\n           c == 'S' ? 1 :\n           c == 'E' ? 2 :\n           c == 'W' ? 3 : -1;\n}\nint itoyl[] = { 1, -1, 1, -1 }; // direction index to difference of y of left edge\nint itoxl[] = { -1, 1, 1, -1 };\nint itoyr[] = { 1, -1, -1, 1 };\nint itoxr[] = { 1, -1, 1, -1 };\nint proj_ix(int y, int x, int h, int w) {\n    if (x == 0) return y;\n    if (y == h) return h + x;\n    if (x == w) return h + w + (h-y);\n    if (y == 0) return h + w + h + (w-x);\n    return -1;\n}\nint proj(int y, int x, int dy, int dx, int h, int w) {\n    while (proj_ix(y, x, h, w) == -1) {\n        y += dy;\n        x += dx;\n    }\n    return proj_ix(y, x, h, w);\n}\nbool proj_in(int i, int l, int r, int len) {\n    if (l <= i and i <= r) return true;\n    if (r < l and l <= i) return true;\n    if (r < l and i <= r) return true;\n    return false;\n}\nint greedy(int initial, int n, int len, vector<int> const & l, vector<int> const & r) {\n    vector<pair<int,int> > intervals;\n    repeat (i,n) {\n        if (not proj_in(initial, l[i], r[i], len)) {\n            intervals.push_back(make_pair((l[i] - initial + len) % len,\n                                          (r[i] - initial + len) % len));\n        }\n    }\n    sort(intervals.begin(), intervals.end());\n    int result = 1 + not intervals.empty();\n    int q = 1000000007;\n    for (auto p : intervals) {\n        if (q < p.first) {\n            result += 1;\n            q = p.second;\n        } else {\n            q = min(q, p.second);\n        }\n    }\n    return result;\n}\nint main() {\n    int n, w, h; cin >> n >> w >> h;\n    vector<int> l(n), r(n); // [l, r]\n    repeat (i,n) {\n        int x, y; char c; cin >> x >> y >> c;\n        int d = dtoi(c);\n        l[i] = proj(y, x, itoyl[d], itoxl[d], h, w);\n        r[i] = proj(y, x, itoyr[d], itoxr[d], h, w);\n    }\n    int result = 1000000007;\n    repeat (i,n) {\n        result = min(result, greedy(l[i],n,2*(w+h),l,r));\n        result = min(result, greedy(r[i],n,2*(w+h),l,r));\n    }\n    cout << result << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,w,d;\nstruct state {\n  int id,x;\n  bool in;\n  state(){}\n  state(int x,int id,bool in):id(id),x(x),in(in){}\n  bool operator<(const state& st) const {\n    if( x== st.x ) return in > st.in;\n    return x < st.x;\n  }\n};\nvector<state> v;\nconst int INF = 1<<30;\nstring dc=\"NESW\";\n\nint getX(int id, int x, int y ){\n  id%=4;\n  if( id == 0 )\n    return max( 0, x-(d-y) );\n  else if( id == 1 )\n    return min( w, x+(d-y) );\n  else if( id == 2 )\n    return min( w, x+y );  \n  return max( 0, x-y );\n}\nint getY(int id, int x, int y ){\n  id%=4;\n  if( id == 0 )\n    return min( d, y+x );\n  else if( id == 1 )\n    return min( d, y+(w-x) );\n  else if( id == 2 )\n    return max( 0, y-(w-x) );\n  return max( 0, y-x );\n}\n\nint getInter(int x,int y){ \n  if( x == 0 ) return y;\n  if( x == w ) return d+w+(d-y);\n  if( y == d ) return d+x;\n  return 2*d + 2*w - x;\n}\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint solve(int st){\n  int used[1111]={};\n  int m = v.size();\n  for(int i=0;i<m;i++)\n    if( v[i].in && v[i].id == st ){\n      st = i; break;\n    }\n  queue<int> q;\n  int ret = 0;\n  //cout << \"solve \" << endl;\n  for(int i=st;i<m;i++){\n    state p = v[i];\n    //cout << p.id << \" \" << p.x << \" \" << p.in << endl;\n    if( p.in ) {\n      if( !used[p.id] ) {\n        used[p.id]++; q.push( p.id );\n      }\n    } else if( used[p.id] == 1 ) {\n      if( q.empty() ) continue;\n      ret++;\n      while( !q.empty() ) {\n        int nid = q.front(); q.pop();\n        if( used[nid]==1 ) {\n          used[nid]++;\n        }\n      }\n    }\n  }\n  return ret;\n}\n\nint main(){\n  cin >> n >> w >> d;\n  for(int l=0;l<n;l++){\n    int x,y; char c; cin >> x >> y >> c;\n    int id;\n    for(int i=0;i<4;i++)\n      if( dc[i] == c ) id = i;\n    int in = getInter( getX( id, x, y ), getY( id, x, y ) );\n    int out= getInter( getX( id+1, x, y ), getY( id+1, x, y ) );\n    //cout << in << \" - \" << out << endl;\n    v.push_back( state( in, l, true ) );\n    v.push_back( state( out, l, false ) );\n    v.push_back( state( in+2*d+2*w, l, true ) );\n    v.push_back( state( out+2*d+2*w, l, false ) );\n    v.push_back( state( in+(2*d+2*w)*2, l, true ) );\n    v.push_back( state( out+(2*d+2*w)*2, l, false ) );\n  }\n\n  sort( v.begin(), v.end() );\n  int res = INF;\n  for(int i=0;i<n;i++){\n    res = min( res, solve(i) );\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct data{\n\tint l,r;\n\tdata(){}\n\tdata(int ll,int rr){\n\t\tl=ll;\n\t\tr=rr;\n\t}\n\tbool operator<(const data &d)const{\n\t\tif(r==d.r)return l<d.l;\n\t\treturn r<d.r;\n\t}\n};\n\nint n,w,d;\nvector<data> query;\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&w,&d);\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tchar c;\n\t\tscanf(\"%d%d%*c%c\",&x,&y,&c);\n\t\tif(c=='N'){\n\t\t\tint ll=x-(d-y);\n\t\t\tint rr=x+(d-y);\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\tquery.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t\tif(c=='E'){\n\t\t\tint ll=w+d-y-(w-x);\n\t\t\tint rr=w+d-y+(w-x);\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\tquery.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t\tif(c=='S'){\n\t\t\tint ll=w+d+(w-x)-y;\n\t\t\tint rr=w+d+(w-x)+y;\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\tquery.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t\tif(c=='W'){\n\t\t\tint ll=w+d+w+y-x;\n\t\t\tint rr=w+d+w+y+x;\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\tquery.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t}\n\tsort(query.begin(),query.end());\n\tint res=n;\n\tfor(int i=0;i<n;i++){\n\t\tint tmp=1,last=query[i].r;\n\t\tfor(int j=i+1;query[j].r<query[i].r+(w+d)*2;j++){\n\t\t\tdata dd=query[j];\n\t\t\tif(last<dd.l){\n\t\t\t\ttmp++;\n\t\t\t\tlast=dd.r;\n\t\t\t}\n\t\t}\n\t\tres=min(res,tmp);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\n#define fst first\n#define snd second\n\nint n, w, h, len; \n\nint solve(vector<pair<int, int>> & lr){\n    int ret = n;\n    rep(i, n){\n        int cur = 1;\n        int rs = lr[i].snd, frs = rs;\n\n        range(_, 1, n){\n            int j = (j + _) % n;\n\n            int cl = lr[j].fst, cr = lr[j].snd;\n            if(cl >= cr){\n                if((cl - len <= rs and rs <= cr) or (cl <= rs and rs <= cr + len)){\n                    continue;\n                }\n            }\n            else {\n                if(cl <= rs and rs <= cr){\n                    continue;\n                }\n            }\n            if(cl >= cr){\n                if((cl - len <= frs and frs <= cr) or (cl <= frs and frs <= cr + len)){\n                    continue;\n                }\n            }\n            else {\n                if(cl <= frs and frs <= cr){\n                    continue;\n                }\n            }\n\n            cur++;\n            rs = cr;\n        }\n\n        ret = min(ret, cur);\n    }\n\n    return ret;\n}\n\nint main(void){\n    cin >> n >> w >> h;\n\n    vector<pair<int, int>> lr(n);\n    len = 2 * w + 2 * h;\n    for(auto & e : lr){\n        int x, y; cin >> x >> y;\n        y = h - y;\n        char f; cin >> f;\n\n        int o, p;\n        switch(f){\n        case 'N': o = x;                 p = y;     break;\n        case 'E': o = w + y;             p = w - x; break;\n        case 'S': o = 2 * w + h - x;     p = h - y; break;\n        case 'W': o = 2 * w + 2 * h - y; p = x;     break;\n        }\n\n        e.fst = (o - p + len) % len;\n        e.snd = (o + p) % len;\n    }\n\n    sort(begin(lr), end(lr));\n    int res = solve(lr);\n\n    for(auto & e : lr){\n        swap(e.fst, e.snd);\n        e.fst = (len - 1) - e.fst;\n        e.snd = (len - 1) - e.snd;\n    }\n    sort(begin(lr), end(lr));\n    res = min(res, solve(lr));\n\n    cout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\n#define EPS (1e-7)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\nconst double PI=4*atan(1.0);\n\ntypedef complex<double> P;\n\n// ??????\ndouble dot(const P &a, const P &b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// ??????\ndouble cross(const P &a, const P &b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distance_ls_p(const P &a, const P &b, const P &c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nint is_intersected_ls(const P &a1, const P &a2, const P &b1, const P &b2) {\n  // ????????????????????´???\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    // ????????¨???????????¢???0??????????????£????????????\n    if(EQ(distance_ls_p(a1,a2,b1),0)||EQ(distance_ls_p(a1,a2,b2),0))\n      return 1;\n    return 0;\n  }\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n    ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nP intersection_ls(const P &a1, const P &a2, const P &b1, const P &b2) {\n  // ????????????????????´????????????????????£???????????????????????£???????????¨????????????\n  // ?????£??¨???x??§?¨?????°??????????????????????\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    // ????????¨???????????¢???0??????????????£????????????\n    if(EQ(distance_ls_p(a1,a2,b1),0)||EQ(distance_ls_p(a1,a2,b2),0)){\n      // x??§?¨????a1<a2,b1<b2??¨????????????????????????\n      P la1=a1,la2=a2;\n      P lb1=b1,lb2=b2;\n      if(a1.real()>a2.real())swap(la1,la2);\n      if(b1.real()>b2.real())swap(lb1,lb2);\n      P res;\n      if(la1.real()>lb1.real())res=la1;\n      else res=lb1;\n      return res;\n    }\n    // ????????£???????????´??????...?\n    else{\n      // ??????????±?????????????????????§?????????\n      // ????????¢??°?????????????????????????????????????????¨????????????\n      return P(-1,-1);\n    }\n  }\n  else{\n    P b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n  }\n}\n\n// ??§?¨?????????¢(??§?¨?p???????????????,???????¨??????????a(????????¢???)?????¢)\nP roundPoint(const P &p,double a){\n  return P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n\nbool used[1010];\ntypedef tuple<double,int,int> tpl;\n\n// place, start or end, idx???????????????\n\nint N,W,D;\nint XS[1001];\nint YS[1001];\nchar AS[1001];\nint main(){\n\n  cin>>N>>W>>D;\n  for(int i=0;i<N;i++)cin>>XS[i]>>YS[i]>>AS[i];\n  vector<pair<double, double> > poses;\n  // ???????£????????????????, ??§?¨????????????????????????????\n  for(int i=0;i<N;i++){\n    P ang_v;\n    // ????????§????????????????¨????????????????\n    if(AS[i]=='W')ang_v = P(-1, 0);\n    else if(AS[i]=='E')ang_v = P(1, 0);\n    else if(AS[i]=='N')ang_v = P(0, 1);\n    else if(AS[i]=='S')ang_v = P(0, -1);\n    ang_v *= 10000000;\n\n    // 2?????????????????????????¨????????????????\n    P ps[2] = {roundPoint(ang_v, PI/4) + P(XS[i], YS[i]), roundPoint(ang_v, -PI/4) + P(XS[i], YS[i])};\n    // ??????????????¶??????????????????????????????\n    const P corner[4] = {P(0,0), P(0,D), P(W,D), P(W,0)};\n    double ds[2];\n    for(int k=0;k<2;k++){\n        double sum_dist = 0;\n        double dist = 0;\n        for(int j = 0; j < 4; j++){\n            const P &p1 = corner[j];\n            const P &p2 = corner[(j+1)%4];\n            // p1-p2???????????¨ps[j]?????????????????????????????????\n            // cross????????????, ????????§?¨?????±???????\n            if(is_intersected_ls(p1, p2, ps[k], P(XS[i], YS[i]))){\n                // ??§?¨???¨,corner[j]??¨????????¢????¨??????????\n                P c = intersection_ls(p1, p2, ps[k], P(XS[i], YS[i]));\n                dist = sum_dist + abs(c-corner[j]);\n                break;\n            }\n            else{\n                sum_dist += abs(p2-p1);\n                continue;\n            }\n        }\n        // dist???2(D+W)?????£??????, 0????£???£????????????\n        if(EQ(2*(D+W), dist)){\n            dist = 0;\n        }\n        ds[k] = dist;\n    }\n    \n    if(ds[0] > ds[1])\n        ds[1] += 2*(W+D);\n\n    poses.push_back(make_pair(ds[0], ds[1]));\n  }\n\n  // vector???????????????2??????????????????\n  for(int i=0;i<N;i++){\n      // ??????????????????+2*(W+D)???????????????push_back\n      pair<double, double> pd = poses[i];\n      pd.first += 2*(W+D);\n      pd.second += 2*(W+D);\n      poses.push_back(pd);\n  }\n  \n  int min_ans = 1<<29;\n  // ?????¨?????£??????, ??????????§???°???????±???????, ????????????n?????????????????°????¨??????????\n  for(int start = 0; start < N; start++){\n      memset(used,0,sizeof(used));\n      vector<tuple<double, int, int> > vec;\n      for(int i=0;i<N;i++){\n          pair<double,double> t = poses[start + i];\n          vec.push_back(make_tuple(t.first, 0, i));\n          vec.push_back(make_tuple(t.second, 1, i));\n      }\n      // start??????????????????end????????£????????????????´???????????????????\n      queue<int> q;\n      // ?????¢??§?????????\n      sort(vec.begin(), vec.end());\n      \n      int vec_idx = 0;\n      int ans = 0;\n      // ???????????¢?????¨??????????????????????????????\n      while((int)vec.size() != vec_idx){\n          // ???????????¢??§????´??????????????????????\n          double d = get<0>(vec[vec_idx]);\n          vector<int> vs[2];\n          while((int)vec.size()!=vec_idx && EQ(get<0>(vec[vec_idx]), d)){\n              vs[get<1>(vec[vec_idx])].push_back(get<2>(vec[vec_idx]));\n              vec_idx++;\n          }\n          \n          // start???????´???????????????????\n          // start???????´????, queue????????????\n          for(int i=0;i<(int)vs[0].size();i++){\n              int idx = vs[0][i];\n              q.push(idx);\n          }\n          \n          // end???????´????, ?????§???????????????????????°continue\n          for(int i=0;i<(int)vs[1].size();i++){\n              int idx = vs[1][i];\n              if(used[idx])continue;\n              else{\n                  // ?????????????????£????????????????????§start???????´?????§£???????????????\n                  // ????????????end????§£?????????????????§??????????????????\n                  ans++;\n                  while(q.size()){\n                      const int a = q.front(); q.pop();\n                      used[a] = true;\n                  }\n                  break;\n              }\n          }\n      }\n      min_ans = min(min_ans, ans);\n  }\n\n  cout<<min_ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef pair< int, int > pii;\n\npii getRange(int w, int d, int x, int y, char f) {\n\tif (f == 'N') {\n\t\tint a = x - (d - y), b = (w - x) - (d - y);\n\t\treturn pii(a, w - b);\n\t}\n\t\n\tif (f == 'E') {\n\t\tint a = (d - y) - (w - x), b = y - (w - x);\n\t\treturn pii(w + a, w + d - b);\n\t}\n\t\n\tif (f == 'S') {\n\t\tint a = (w - x) - y, b = x - y;\n\t\treturn pii(w + d + a, 2*w + d - b);\n\t}\n\t\n\tif (f == 'W') {\n\t\tint a = y - x, b = (d - y) - x;\n\t\treturn pii(2*w + d + a, 2*w+2*d - b);\n\t}\n\t\n\treturn pii(-1,-1);\n}\n\nint solve(int n, vector< vector< int > >& collision, vector< int >& order, int s) {\n\tint ret = 0;\n\tvector< bool > bad(n, false);\n\tfor_(i,0,n) {\n\t\tint v = order[(s + i) % n];\n\t\tif (bad[v]) continue;\n\t\t++ret;\n\t\tfor (int u : collision[v]) bad[u] = true;\n\t}\n\treturn ret;\n}\n\nstruct Rng {\n\tint id, L, R;\n\tRng(int __id, pii p) : id(__id), L(p.first), R(p.second) {}\n\tbool operator < (const Rng& o) const { return R < o.R; }\n};\n\nint main() {\n\tint n, w, d;\n\tcin >> n >> w >> d;\n\t\n\tint UB = 2*w + 2*d;\n\tvector< Rng > vp;\n\tfor_(i,0,n) {\n\t\tint x, y; char f;\n\t\tcin >> x >> y >> f;\n\t\tpii p = getRange(w, d, x, y, f);\n\t\tvp.push_back(Rng(i, p));\n\t\tvp.push_back(Rng(i, pii(p.first + UB, p.second + UB)));\n\t}\n\t\n\tsort(vp.begin(), vp.end());\n\tvector< int > order, vis(n, false);\n\tfor (Rng r : vp) if (!vis[r.id]) order.push_back(r.id), vis[r.id] = true;\n\t\n\tvector< vector< int > > collision(n, vector< int >());\n\tfor (Rng x : vp) for (Rng y : vp) {\n\t\tif (x.id == y.id) continue;\n\t\tif (x.R >= y.L && x.L <= y.R) collision[x.id].push_back(y.id);\n\t}\n\t\n\tint ans = 0;\n\tfor_(i,0,n) ans = max(ans, solve(n, collision, order, i));\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#define  fi first\n#define  se second\n#define  mk make_pair\n#define  fr(i,x,y) for(i=x;i<=y;i++)\nusing namespace std;\ntypedef pair < int ,int > PII;\nconst int maxn=1010;\nint n,w,d,ans,m;\nPII a[maxn],b[maxn];\nint Get(int x,int y,int dir)\n{\n\tif(dir==1){\n\t\tif(x<y)return y-x;//(0,y-x)\n\t\telse return d+w+d+w-(x-y);//(x-y,0)\n\t}else if(dir==2){\n\t\tif(x<d-y)return y+x;//(0,y+x)\n\t\telse return d+x-(d-y);//(x-(d-y),d)\n\t}else if(dir==3){\n\t\tif(w-x<d-y)return d+w+d-(y+(w-x));//(w,y+(w-x))\n\t\telse return d+x+(d-y);//(x+(d-y),d)\n\t}else{\n\t\tif(w-x<y)return d+w+d-(y-(w-x));//(w,y-(w-x))\n\t\telse return d+w+d+w-(x+y);//(x+y,0)\n\t}\n}\nPII Get(int x,int y,char ch)\n{\n\tint ret1,ret2;\n\tif(ch=='W'){\n\t\tret1=Get(x,y,1);\n\t\tret2=Get(x,y,2);\n\t}else if(ch=='N'){\n\t\tret1=Get(x,y,2);\n\t\tret2=Get(x,y,3);\n\t}else if(ch=='E'){\n\t\tret1=Get(x,y,3);\n\t\tret2=Get(x,y,4);\n\t}else{\n\t\tret1=Get(x,y,4);\n\t\tret2=Get(x,y,1);\n\t}\n\treturn mk(ret1,ret2);\n}\nvoid Read()\n{\n\tint i,x,y;\n\tchar ch;\n\tscanf(\"%d%d%d\",&n,&w,&d);\n\tfr(i,1,n)\n\t{\n\t\tscanf(\"%d%d%c%c\",&x,&y,&ch,&ch);\n\t\ta[i]=Get(x,y,ch);\n\t}\n}\nint Cal(int x)\n{\n\tif(x>=0)return x;\n\treturn x+2*(w+d);\n}\nbool Cmp(const PII &x,const PII &y){return x.se<y.se;}\nvoid Minn(int &x,int y){if(y<x)x=y;}\nvoid Update(int x)\n{\n\tint i,sum,la;\n\tm=0;\n\tfr(i,1,n)\n\t\tif(a[i].fi<a[i].se)\n\t\t\tif(a[i].fi<=x&&x<=a[i].se);\n\t\t\telse b[++m]=mk(Cal(a[i].fi-x),Cal(a[i].se-x));\n\t\telse\n\t\t\tif(x>=a[i].fi||x<=a[i].se);\n\t\t\telse b[++m]=mk(Cal(a[i].fi-x),Cal(a[i].se-x));\n\tif(m==0){Minn(ans,1);return;}\n\tsort(b+1,b+m+1,Cmp);\n\tsum=2;\n\tla=b[1].se;\n\tfr(i,2,m)\n\t{\n\t\tif(b[i].fi<=la)continue;\n\t\tla=b[i].se;\n\t\tsum++;\n\t}\n\tMinn(ans,sum);\n}\nvoid Solve()\n{\n\tint i;\n\tans=n;\n\tfr(i,1,n)\n\t{\n\t\tUpdate(a[i].fi);\n\t\tUpdate(a[i].se);\n\t}\n\tprintf(\"%d\\n\",ans);\n}\nint main()\n{\n\tRead();\n\tSolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct data{\n\tint l,r;\n\tdata(){}\n\tdata(int ll,int rr){\n\t\tl=ll;\n\t\tr=rr;\n\t}\n\tbool operator<(const data &d)const{\n\t\tif(r==d.r)return l<d.l;\n\t\treturn r<d.r;\n\t}\n};\n\nint n,w,d;\nstring dir=\"NWSE\";\nvector<data> query;\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&w,&d);\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tchar c;\n\t\tscanf(\"%d%d%*c%c\",&x,&y,&c);\n\t\tif(c=='N'){\n\t\t\tint ll=x-(d-y);\n\t\t\tint rr=x+(d-y);\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\t//query.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t\tif(c=='E'){\n\t\t\tint ll=w+d-y-(w-x);\n\t\t\tint rr=w+d-y+(w-x);\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\t//query.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t\tif(c=='S'){\n\t\t\tint ll=w+d+(w-x)-y;\n\t\t\tint rr=w+d+(w-x)+y;\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\t//query.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t\tif(c=='W'){\n\t\t\tint ll=w+d+w+y-x;\n\t\t\tint rr=w+d+w+y+x;\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\t//query.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t}\n\tsort(query.begin(),query.end());\n\tint res=n;\n\tfor(int i=0;i<n;i++){\n\t\tint tmp=1,last=query[i].r;\n\t\tfor(int j=1;j<n;j++){\n\t\t\tdata dd=query[(i+j)%n];\n\t\t\tif((i+j)%n<i)dd.l+=(w+d)*2,dd.r+=(w+d)*2;\n\t\t\tif(last<dd.l){\n\t\t\t\ttmp++;\n\t\t\t\tlast=dd.r;\n\t\t\t}\n\t\t}\n\t\tres=min(res,tmp);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c\n\tif (cross(nb, nc) < -eps) return -1; // a,\n\tif (dot(nb, nc) < 0) return 2;       //\n\tif (norm(nb) < norm(nc)) return -2;  // \n\treturn 0;                          \n}\n\n\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\nconst int dx0[4] = { -1,0,1,0 };\nconst int dy0[4] = { 0,1,0,-1 };\n\nconst int dx[4] = { -1,-1,1,1 };\nconst int dy[4] = { -1,1,1,-1 };\n\nint N, W, D;\n\nint getnum(int x, int y) {\n\tif (x == 0) {\n\t\treturn y;\n\t}\n\telse if (y == D) {\n\t\treturn D + x;\n\t}\n\telse if (x == W) {\n\t\treturn 2 * D + W - y;\n\t}\n\telse {\n\t\tassert(!y);\n\t\treturn 2 * D + 2 * W - x;\n\t}\n}\nbool isorder(const int a, const int b, const int c) {\n\tif (a < c) {\n\t\treturn a <= b&&b <= c;\n\t}\n\telse if (a>c) {\n\t\treturn a <= b || b <= c;\n\t}\n\telse\n\t{\n\t\treturn true;\n\t}\n}\nstruct Compress {\n\tmap<int, int>mp;\n\tmap<int, int>revmp;\n\n\tCompress(vector<int>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()),vs.end());\n\t\tfor (int i = 0; i < vs.size(); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n};\nmap<char, int>mp;\nint main() {\n\tmp['W'] = 0;\n\tmp['S'] = 1;\n\tmp['E'] = 2;\n\tmp['N'] = 3;\n\tcin >> N >> W >> D;\n\tif (N == 1) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tvector<Line> ls;\n\tls.push_back(Line(Point(0, 0), Point(0, D)));\n\tls.push_back(Line(Point(1, D), Point(W - 1, D)));\n\tls.push_back(Line(Point(W, D), Point(W, 0)));\n\tls.push_back(Line(Point(W - 1, 0), Point(1, 0)));\n\tvector<pair<int, int>>ps;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y; char f; cin >> x >> y >> f;\n\t\ty = D - y;\n\t\tPoint p(x, y);\n\t\tint num1, num2;\n\t\tint betnum;\n\t\t{\n\t\t\tconst int way = mp[f];\n\t\t\tLine l(p, p + 1000000.l * Point(dx[way], dy[way]));\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tif (isis_ss(l, ls[i])) {\n\t\t\t\t\tPoint sect(is_ll(l, ls[i]));\n\t\t\t\t\tnum1 = getnum(round(sect.real()), round(sect.imag()));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tconst int way = (mp[f]+1)%4;\n\t\t\tLine l(p, p + 1000000.l * Point(dx[way], dy[way]));\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tif (isis_ss(l, ls[i])) {\n\t\t\t\t\tPoint sect(is_ll(l, ls[i]));\n\t\t\t\t\tnum2 = getnum(round(sect.real()), round(sect.imag()));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tconst int way = mp[f];\n\t\t\tLine l(p, p + 1000000.l * Point(dx0[way], dy0[way]));\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tif (isis_ss(l, ls[i])) {\n\t\t\t\t\tPoint sect(is_ll(l, ls[i]));\n\t\t\t\t\tbetnum = getnum(round(sect.real()), round(sect.imag()));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (num1 < num2) {\n\t\t\tif (num1 < betnum&&betnum < num2) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tswap(num1, num2);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (num2 < betnum&&betnum < num1) {\n\t\t\t\tswap(num1, num2);\n\t\t\t}\n\t\t\telse {\n\t\t\t}\n\t\t}\n\t\tps.emplace_back(num1, num2);\n\t}\n\tsort(ps.begin(), ps.end());\n\tvector<int>v;\n\tfor (auto p : ps) {\n\t\tv.emplace_back(p.first);\n\t\tv.emplace_back(p.second);\n\t}\n\tCompress comp(v);\n\t\n\tfor (auto&p : ps) {\n\t\tp.first = comp.mp[p.first];\n\t\tp.second = comp.mp[p.second];\n\t}\n\t{\n\t\tbool a = is_sorted(ps.begin(), ps.end());\n\t\tassert(a);\n\t}\n\tint _size = comp.mp.size();\n\tint ans = 1e5;\n\tfor (int start = 0; start < ps.size(); ++start) {\n\t\tint num = 1;\n\t\tconst int anum = ps[start].first;\n\t\tqueue<int>que;\n\t\tint amin = 1e8;\n\t\tfor (int p = start; p < start + ps.size();++p) {\n\t\t\tconst int from = ps[p%N].first;\n\t\t\tconst int to = ps[p%N].second;\n\t\t\tif (isorder(from, anum, to))continue;\n\t\t\tconst int realfrom = from < anum ? from + _size : from;\n\t\t\tconst int realto = to < anum ? to + _size : to;\n\t\t\tamin = min(amin, realto);\n\t\t\tif (amin < realfrom) {\n\t\t\t\tamin = realto;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t\tif (amin != 1e8)num++;\n\t\tans = min(ans, num);\n\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <tuple>\n\nusing namespace std;\ntypedef pair<int, int> pii;\nstatic const int INF = 1000000000;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tvector<pii> ranges;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x, y;\n\t\tstring f;\n\t\tcin >> x >> y >> f;\n\t\tconst int lu = y + x;\n\t\tconst int ru = h + x + (h - y);\n\t\tconst int rd = h + w + (h - y) + (w - x);\n\t\tconst int ld = h + w + h + (w - x) + y;\n\t\tint lo = 0, hi = 0;\n\t\tif(f[0] == 'N'){\n\t\t\tlo = lu; hi = ru;\n\t\t}else if(f[0] == 'E'){\n\t\t\tlo = ru; hi = rd;\n\t\t}else if(f[0] == 'S'){\n\t\t\tlo = rd; hi = ld;\n\t\t}else if(f[0] == 'W'){\n\t\t\tlo = ld; hi = lu + (h + w) * 2;\n\t\t}\n\t\tconst int hw2 = h + w + h + w;\n\t\tranges.emplace_back(lo, hi);\n\t\tranges.emplace_back(lo + hw2, hi + hw2);\n\t}\n\tif(n == 0){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tsort(\n\t\tranges.begin(), ranges.end(),\n\t\t[](const pii &a, const pii &b){\n\t\t\treturn (a.second == b.second) ? (a.first < b.first) : (a.second < b.second);\n\t\t});\n\tint answer = INF;\n\tfor(int i = 0; i < n; ++i){\n\t\tvector<pii> r(ranges.begin() + i, ranges.begin() + i + n);\n\t\tconst int hw2 = (h + w) * 2;\n\t\tint count = 1, last = r[0].second;\n\t\tfor(int j = 0; j < n; ++j){\n\t\t\tif(r[j].first <= last){ continue; }\n\t\t\tif(r[j].second >= r[0].second + hw2){ continue; }\n\t\t\t++count;\n\t\t\tlast = r[j].second;\n\t\t}\n\t\tanswer = min(answer, count);\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long LL;\ntypedef long double LD;\n\nstruct sta{\n  int pos;\n  int d;\n};\n\nint main(){\n  int n,w,h;\n  cin >> n >> w >> h;\n  int x,y;\n  char c;\n  vector<sta> s;\n  rep(i,n){\n    cin >> x >> y >> c;\n    if(c=='N'){\n      s.push_back({x-y+2*h,x+y}); \n    }else if(c=='S'){\n      s.push_back({(y-x<0?y-x+2*(h+w):y-x),(y-x<0?x+y+2*h:x+y-2*w)});\n    }else if(c=='E'){\n      s.push_back({x+y+2*h,x-y+2*h});\n    }else{\n      s.push_back({x+y,y-x});\n    }\n  }\n  sort(all(s),[](const sta &l, const sta &r){\n    return l.pos<r.pos;\n  });\n  list<sta> ls;\n  rep(i,n){\n    ls.push_back(s[i]);\n  }\n  int ans=IINF;\n  rep(i,n){\n    int tmp=0;\n    int pre=-IINF;\n    for(auto &p:ls){\n      if(p.d>pre){\n        tmp++;\n        pre=p.pos;\n      }\n    }\n    ans=min(ans,tmp);\n    sta p = ls.front();\n    p.pos+=2*(h+w);\n    p.d+=2*(h+w);\n    ls.pop_front();\n    ls.push_back(p);\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n,w,h;\nint pos(int x,int y){\n  if(y==0) return x;\n  if(y==h) return w+h+(w-x);\n  if(x==0) return w+h+w+(h-y);\n  if(x==w) return w+y;\n  assert(0);\n}\ntypedef pair<int,int> P;\nsigned main(){\n  cin>>n>>w>>h;\n  int x[n],y[n];\n  char f[n];\n  for(int i=0;i<n;i++) cin>>x[i]>>y[i]>>f[i];\n  vector<P> v;\n  for(int i=0;i<n;i++){\n    int a,b,c,d;\n    a=min(w-x[i],h-y[i]);\n    b=min(w-x[i],y[i]);\n    c=min(x[i],y[i]);\n    d=min(x[i],h-y[i]);\n    int l,r;\n    if(f[i]=='E'){\n      r=pos(x[i]+a,y[i]+a);\n      l=pos(x[i]+b,y[i]-b);\n    }\n    if(f[i]=='S'){\n      r=pos(x[i]+b,y[i]-b);\n      l=pos(x[i]-c,y[i]-c);\n    }\n    if(f[i]=='W'){\n      r=pos(x[i]-c,y[i]-c);\n      l=pos(x[i]-d,y[i]+d);\n    }\n    if(f[i]=='N'){\n      r=pos(x[i]-d,y[i]+d);\n      l=pos(x[i]+a,y[i]+a);\n    }\n    if(r<l) r+=2*(w+h);\n    v.push_back(P(l,r));\n  }\n  \n  bool ovlp[n];\n  for(int i=0;i<n;i++){\n    ovlp[i]=0;\n    for(int j=0;j<n;j++)\n      ovlp[i]|=(i!=j)&&(v[i].first<=v[j].first&&v[j].second<=v[i].second);\n    //cout<<i<<\" \"<<ovlp[i]<<endl;\n  }\n  \n  for(int i=n-1;i>=0;i--) if(ovlp[i]) v.erase(v.begin()+i),n--,ovlp[i]=0;\n  sort(v.begin(),v.end());\n  for(int i=0;i<n;i++)\n    v.push_back(P(v[i].first+2*(w+h),v[i].second+2*(w+h)));\n\n  //for(int i=0;i<n;i++) cout<<v[i].first<<\" \"<<v[i].second<<endl;\n\n  int ans=n;\n  for(int i=0;i<n;i++){\n    int tmp=0;\n    int j=i,p;\n    while(j<i+n){\n      tmp++;\n      p=v[j].second;\n      while(j<i+n&&v[j].first<=p) j++;\n    }\n    ans=min(ans,tmp);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define N 5010\nstruct rec{\n    int x,y,f,l,r;\n}a[N];\nstruct Seg{\n    int l,r,id;\n    Seg(){}\n    Seg(int l,int r,int id):l(l),r(r),id(id){}\n}seg[N];\nint n,w,d,m;\nvector<int> g[N];\nvoid calc_WN(int i,int &k)\n{\n    int tmp=min(a[i].x,d-a[i].y);\n    int x=a[i].x-tmp,y=a[i].y+tmp;\n    if(x==0) k=y;\n    else k=d+x;\n}\nvoid calc_EN(int i,int &k)\n{\n    int tmp=min(w-a[i].x,d-a[i].y);\n    int x=a[i].x+tmp,y=a[i].y+tmp;\n    if(x==w) k=d+w+d-y;\n    else k=d+x;\n}\nvoid calc_ES(int i,int &k)\n{\n    int tmp=min(w-a[i].x,a[i].y);\n    int x=a[i].x+tmp,y=a[i].y-tmp;\n    if(x==w) k=d+w+d-y;\n    else k=d+w+d+w-x;\n}\nvoid calc_WS(int i,int &k)\n{\n    int tmp=min(a[i].x,a[i].y);\n    int x=a[i].x-tmp,y=a[i].y-tmp;\n    if(x==0) k=y;\n    else k=d+w+d+w-x;\n}\nvoid calc(int i)\n{\n    int x,y,tmp,p1=d,p2=d+w,p3=d+w+d;\n    if(a[i].f==0)\n    {\n        calc_WN(i,a[i].l);\n        calc_EN(i,a[i].r);\n    }\n    else if(a[i].f==1)\n    {\n        calc_EN(i,a[i].l);\n        calc_ES(i,a[i].r);\n    }\n    else if(a[i].f==2)\n    {\n        calc_WS(i,a[i].l);\n        calc_WN(i,a[i].r);\n    }\n    else\n    {\n        calc_ES(i,a[i].l);\n        calc_WS(i,a[i].r);\n    }\n}\nbool cmp(Seg &a,Seg &b)\n{\n    return a.l<b.l;\n}\nint num[N];\nbool check(int mid)\n{\n    for(int i=1;i<=n;++i) num[i]=0;\n    int cnt=0;\n    for(int i=1;i<=mid;++i)\n    {\n        for(int x:g[i])\n        {\n            if(num[x]==0) ++cnt;\n            ++num[x];\n        }\n    }\n    if(cnt>=n) return true;\n    for(int i=mid+1;i<=m;++i)\n    {\n        for(int x:g[i-mid])\n        {\n            --num[x];\n            if(num[x]==0) --cnt;\n        }\n        for(int x:g[i])\n        {\n            if(num[x]==0) ++cnt;\n            ++num[x];\n        }\n        if(cnt>=n) return true;\n    }\n    return false;\n}\nint main()\n{\n    char st[10];\n    scanf(\"%d%d%d\",&n,&w,&d);\n    for(int i=1;i<=n;++i)\n    {\n        scanf(\"%d%d%s\",&a[i].x,&a[i].y,st);\n        if(st[0]=='N') a[i].f=0;\n        else if(st[0]=='E') a[i].f=1;\n        else if(st[0]=='W') a[i].f=2;\n        else if(st[0]=='S') a[i].f=3;\n        calc(i);\n    }\n//    for(int i=1;i<=n;++i) printf(\"%d %d %d ?\\n\",i,a[i].l,a[i].r);\n    int cnt=0,z=w*2+d*2;\n    for(int i=1;i<=n;++i)\n        if(a[i].l<=a[i].r)\n        {\n            seg[++cnt]=Seg(a[i].l,a[i].r,i);\n            seg[++cnt]=Seg(a[i].l+z,a[i].r+z,i);\n        }\n        else seg[++cnt]=Seg(a[i].l,a[i].r+z,i);\n    sort(seg+1,seg+cnt+1,cmp);\n//    for(int i=1;i<=cnt;++i) printf(\"%d %d %d %d !!\\n\",i,seg[i].l,seg[i].r,seg[i].id);\n    int minr=seg[1].r,last=1;\n    m=0;\n    for(int i=2;i<=cnt;++i)\n    {\n        if(minr<seg[i].l)\n        {\n            ++m;\n            for(int j=last;j<i;++j)\n                g[m].push_back(seg[j].id);\n            minr=seg[i].r;last=i;\n        }\n        else minr=min(minr,seg[i].r);\n    }\n    ++m;\n    for(int i=last;i<=cnt;++i)\n        g[m].push_back(seg[i].id);\n//    for(int i=1;i<=m;++i)\n//    {\n//        printf(\"i %d : \",i);\n//        for(int x:g[i]) printf(\"%d \",x);\n//        printf(\"\\n\");\n//    }\n    int l=1,r=n,mid;\n    while(l+1<r)\n    {\n        mid=l+r>>1;\n        if(check(mid)) r=mid;\n        else l=mid+1;\n    }\n    if(check(l)) printf(\"%d\\n\",l);\n    else printf(\"%d\\n\",r);\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\nint dx[]={1,1,-1,-1};\nint dy[]={-1,1,1,-1};\nint Con(char c){\n  if(c=='S')return 3;\n  if(c=='E')return 0;\n  if(c=='N')return 1;\n  if(c=='W')return 2;\n}\nint x,y,X,Y,n,w,h,l,r,d,cnt,ans=1e7;\nchar c;\nmap<P,int>m;\nvoid init(){\n  r(i,w+1)m[P(0,i)]=cnt++;\n  r(i,h+1)m[P(i,w)]=cnt++;\n  r(i,w+1)m[P(h,w-i)]=cnt++;\n  r(i,h+1)m[P(h-i,0)]=cnt++;\n}\nsigned main(){\n  vector<P>v;\n  cin>>n>>w>>h;\n  init();\n  r(i,n){\n    cin>>X>>Y>>c;\n    d=Con(c);\n    x=X;y=Y;\n    while(0<x&&x<w&&0<y&&y<h){\n      x+=dx[d];\n      y+=dy[d];\n    }\n    l=m[P(y,x)];\n    x=X;y=Y;\n    while(0<x&&x<w&&0<y&&y<h){\n      x+=dx[(d+1)%4];\n      y+=dy[(d+1)%4];\n    }\n    r=m[P(y,x)];\n    v.push_back(P(r,l));\n  }\n  sort(v.begin(),v.end());\n  r(i,n){\n    int now=v[i].first,count=1;\n    for(int k=0,j=i;k<n;k++,j=(j+1)%n){\n      r=v[j].first;\n      l=v[j].second;\n      if(l>r){\n        if(!((l<=now&&now<=cnt)||(0<=now&&now<=r))){\n          now=r;\n          count++;\n        }\n      }\n      else{\n        if(!(l<=now&&now<=r)){\n          now=r;\n          count++;\n        }\n      }\n    }\n    ans=min(ans,count);\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint N,W,H;\nvector<P> t;\n\nbool check(P p,int a){\n  if(p.first<p.second)\n    return (p.first<=a&&a<=p.second);\n  return (p.first<=a||a<=p.second);\n}\nint calcArg(int x,int y){\n  if(x==0)return y;\n  if(y==H)return H+x;\n  if(x==W)return H+W+H-y;\n  return H+W+H+W-x;\n}\n\nint calcLU(int x,int y){\n  int d=min(x,H-y);\n  return calcArg(x-d,y+d);\n}\nint calcLD(int x,int y){\n  int d=min(x,y);\n  return calcArg(x-d,y-d);\n}\nint calcRU(int x,int y){\n  int d=min(W-x,H-y);\n  return calcArg(x+d,y+d);\n}\nint calcRD(int x,int y){\n  int d=min(W-x,y);\n  return calcArg(x+d,y-d);\n}\n\nint solve(int si){\n  int res=1,last=t[si].second;\n  for(int i=si;i<si+N;i++){\n    if(check(t[i],last)) continue;\n    res++;\n    last=t[i].second;\n  }\n  return res;\n}\n\nint main(){\n  cin>>N>>W>>H;\n  for(int i=0;i<N;i++){\n    int x,y;\n    char ch;\n    P p;\n    cin>>x>>y>>ch;\n    if(ch=='N'){\n      p.first = calcLU(x,y);\n      p.second = calcRU(x,y);\n    }\n    if(ch=='E'){\n      p.first = calcRU(x,y);\n      p.second = calcRD(x,y);\n    }\n    if(ch=='S'){\n      p.first = calcRD(x,y);\n      p.second = calcLD(x,y);\n    }\n    if(ch=='W'){\n      p.first = calcLD(x,y);\n      p.second = calcLU(x,y);\n    }\n    t.push_back(p);\n  }\n  for(int i=0;i<N;i++) swap(t[i].first,t[i].second);\n  sort(t.begin(),t.end());\n  for(int i=0;i<N;i++) t.push_back(t[i]);\n  for(int i=0;i<N+N;i++) swap(t[i].first,t[i].second);\n  int ans = N;\n  for(int i=0;i<N;i++)ans = min(ans,solve(i));\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint N,W,H,L;\nvector<P> t;\n\nbool check(P p,int a){\n  if(p.first<p.second)\n    return (p.first<=a&&a<=p.second);\n  return (p.first<=a||a<=p.second);\n}\nint calcArg(int x,int y){\n  if(x==0)return y;\n  if(y==H)return H+x;\n  if(x==W)return H+W+H-y;\n  return H+W+H+W-x;\n}\n\nint calcLU(int x,int y){\n  int d=min(x,H-y);\n  return calcArg(x-d,y+d);\n}\nint calcLD(int x,int y){\n  int d=min(x,y);\n  return calcArg(x-d,y-d);\n}\nint calcRU(int x,int y){\n  int d=min(W-x,H-y);\n  return calcArg(x+d,y+d);\n}\nint calcRD(int x,int y){\n  int d=min(W-x,y);\n  return calcArg(x+d,y-d);\n}\n\nint solve(int si){\n  int res=1,last=t[si].second;\n  for(int i=si;i<si+N;i++){\n    if(check(t[i],last)) continue;\n    res++;\n    last=t[i].second;\n  }\n  return res;\n}\n\nint main(){\n  cin>>N>>W>>H;\n  L=W+W+H+H;\n  for(int i=0;i<N;i++){\n    int x,y,s;\n    char ch;\n    P p;\n    cin>>x>>y>>ch;\n    if(ch=='N'){\n      s=calcArg(x,H);\n      p.first = (s-H+y+L)%L;\n      p.second = (s-y+H)%L;\n    }\n    if(ch=='E'){\n      s=calcArg(W,y);\n      p.first = (s-W+x+L)%L;\n      p.second = (s-x+W)%L;\n    }\n    if(ch=='S'){\n      s=calcArg(x,0);\n      p.first = (s-y+L)%L;\n      p.second = (s+y)%L;\n    }\n    if(ch=='W'){\n      s=calcArg(0,y);\n      p.first = (s-x+L)%L;\n      p.second = (s+x)%L;\n    }\n    \n    t.push_back(p);\n  }\n  for(int i=0;i<N;i++) swap(t[i].first,t[i].second);\n  sort(t.begin(),t.end());\n  for(int i=0;i<N;i++) t.push_back(t[i]);\n  for(int i=0;i<N+N;i++) swap(t[i].first,t[i].second);\n  int ans = N;\n  for(int i=0;i<N;i++)ans = min(ans,solve(i));\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\n#define EPS (1e-5)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\nconst double PI=4*atan(1.0);\n\ntypedef complex<double> P;\n\n// ??????\ndouble dot(const P &a, const P &b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// ??????\ndouble cross(const P &a, const P &b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distance_ls_p(const P &a, const P &b, const P &c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nint is_intersected_ls(const P &a1, const P &a2, const P &b1, const P &b2) {\n  // ????????????????????´???\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    // ????????¨???????????¢???0??????????????£????????????\n    if(EQ(distance_ls_p(a1,a2,b1),0)||EQ(distance_ls_p(a1,a2,b2),0))\n      return 1;\n    return 0;\n  }\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n    ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nP intersection_ls(const P &a1, const P &a2, const P &b1, const P &b2) {\n  // ????????????????????´????????????????????£???????????????????????£???????????¨????????????\n  // ?????£??¨???x??§?¨?????°??????????????????????\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    // ????????¨???????????¢???0??????????????£????????????\n    if(EQ(distance_ls_p(a1,a2,b1),0)||EQ(distance_ls_p(a1,a2,b2),0)){\n      // x??§?¨????a1<a2,b1<b2??¨????????????????????????\n      P la1=a1,la2=a2;\n      P lb1=b1,lb2=b2;\n      if(a1.real()>a2.real())swap(la1,la2);\n      if(b1.real()>b2.real())swap(lb1,lb2);\n      P res;\n      if(la1.real()>lb1.real())res=la1;\n      else res=lb1;\n      return res;\n    }\n    // ????????£???????????´??????...?\n    else{\n      // ??????????±?????????????????????§?????????\n      // ????????¢??°?????????????????????????????????????????¨????????????\n      return P(-1,-1);\n    }\n  }\n  else{\n    P b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n  }\n}\n\n// ??§?¨?????????¢(??§?¨?p???????????????,???????¨??????????a(????????¢???)?????¢)\nP roundPoint(const P &p,double a){\n  return P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n\nbool used[1010];\ntypedef tuple<double,int,int> tpl;\n\n// place, start or end, idx???????????????\n\nint N,W,D;\nint XS[1001];\nint YS[1001];\nchar AS[1001];\nint main(){\n\n  cin>>N>>W>>D;\n  for(int i=0;i<N;i++)cin>>XS[i]>>YS[i]>>AS[i];\n  vector<pair<double, double> > poses;\n  // ???????£????????????????, ??§?¨????????????????????????????\n  for(int i=0;i<N;i++){\n    P ang_v;\n    // ????????§????????????????¨????????????????\n    if(AS[i]=='W')ang_v = P(-1, 0);\n    else if(AS[i]=='E')ang_v = P(1, 0);\n    else if(AS[i]=='N')ang_v = P(0, 1);\n    else if(AS[i]=='S')ang_v = P(0, -1);\n    ang_v *= 10000000;\n\n    // 2?????????????????????????¨????????????????\n    P ps[2] = {roundPoint(ang_v, PI/4) + P(XS[i], YS[i]), roundPoint(ang_v, -PI/4) + P(XS[i], YS[i])};\n    // ??????????????¶??????????????????????????????\n    const P corner[4] = {P(0,0), P(0,D), P(W,D), P(W,0)};\n    double ds[2];\n    for(int k=0;k<2;k++){\n        double sum_dist = 0;\n        double dist = 0;\n        for(int j = 0; j < 4; j++){\n            const P &p1 = corner[j];\n            const P &p2 = corner[(j+1)%4];\n            // p1-p2???????????¨ps[j]?????????????????????????????????\n            // cross????????????, ????????§?¨?????±???????\n            if(is_intersected_ls(p1, p2, ps[k], P(XS[i], YS[i]))){\n                // ??§?¨???¨,corner[j]??¨????????¢????¨??????????\n                P c = intersection_ls(p1, p2, ps[k], P(XS[i], YS[i]));\n                dist = sum_dist + abs(c-corner[j]);\n                break;\n            }\n            else{\n                sum_dist += abs(p2-p1);\n                continue;\n            }\n        }\n        // dist???2(D+W)?????£??????, 0????£???£????????????\n        if(EQ(2*(D+W), dist)){\n            dist = 0;\n        }\n        ds[k] = dist;\n    }\n    \n    if(ds[0] > ds[1])\n        ds[1] += 2*(W+D);\n\n    poses.push_back(make_pair(ds[0], ds[1]));\n  }\n\n  // vector???????????????2??????????????????\n  for(int i=0;i<N;i++){\n      // ??????????????????+2*(W+D)???????????????push_back\n      pair<double, double> pd = poses[i];\n      pd.first += 2*(W+D);\n      pd.second += 2*(W+D);\n      poses.push_back(pd);\n  }\n  \n  int min_ans = 1<<29;\n  // ?????¨?????£??????, ??????????§???°???????±???????, ????????????n?????????????????°????¨??????????\n  for(int start = 0; start < N; start++){\n      memset(used,0,sizeof(used));\n      vector<tuple<double, int, int> > vec;\n      for(int i=0;i<N;i++){\n          pair<double,double> t = poses[start + i];\n          vec.push_back(make_tuple(t.first, 0, i));\n          vec.push_back(make_tuple(t.second, 1, i));\n      }\n      // start??????????????????end????????£????????????????´???????????????????\n      queue<int> q;\n      // ?????¢??§?????????\n      sort(vec.begin(), vec.end());\n      \n      int vec_idx = 0;\n      int ans = 0;\n      // ???????????¢?????¨??????????????????????????????\n      while((int)vec.size() != vec_idx){\n          // ???????????¢??§????´??????????????????????\n          double d = get<0>(vec[vec_idx]);\n          vector<int> vs[2];\n          while((int)vec.size()!=vec_idx && EQ(get<0>(vec[vec_idx]), d)){\n              vs[get<1>(vec[vec_idx])].push_back(get<2>(vec[vec_idx]));\n              vec_idx++;\n          }\n          \n          // start???????´???????????????????\n          // start???????´????, queue????????????\n          for(int i=0;i<(int)vs[0].size();i++){\n              int idx = vs[0][i];\n              q.push(idx);\n          }\n          \n          // end???????´????, ?????§???????????????????????°continue\n          for(int i=0;i<(int)vs[1].size();i++){\n              int idx = vs[1][i];\n              if(used[idx])continue;\n              else{\n                  // ?????????????????£????????????????????§start???????´?????§£???????????????\n                  // ????????????end????§£?????????????????§??????????????????\n                  ans++;\n                  while(q.size()){\n                      const int a = q.front(); q.pop();\n                      used[a] = true;\n                  }\n                  break;\n              }\n          }\n      }\n      min_ans = min(min_ans, ans);\n  }\n\n  cout<<min_ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nint n,w,d;\nint s[1010],g[1010];\n\ninline int convert(int x,int y){\n\tif(x==0) return y;\n\tif(y==d) return d+x;\n\tif(x==w) return d+w+(d-y);\n\tif(y==0) return d+w+d+(w-x);\n\treturn 0;\n}\n\nint greedy(int n,int start,int all){\n\tusing state=tuple<int,int>;\n\tvector<state> ary;\n\t\n\trep(i,n){\n\t\tbool add=true;\n\n\t\tif(s[i]<=g[i]){\n\t\t\tif(s[i]<=start && start <= g[i]) add=false;\n\t\t}else{\n\t\t\tif(start<=g[i]||s[i]<=start) add=false;\n\t\t}\n\n\t\tif(add){\n\t\t\tint cs=(s[i]-start+2*all)%all,cg=(g[i]-start+2*all)%all;\n\t\t\tary.push_back(make_tuple(cg,cs));\n\t\t}\n\t}\n\n\t\n\tsort(_all(ary));\t\n\tint res=1,cur=0;\n\t\n\tfor(auto &it:ary){\n\t\tif(cur<get<1>(it)) \n\t\t\tcur=get<0>(it),res++;\n\t}\n\n\treturn res;\n}\n\nint main(void){\n\tcin >> n >> w >> d;\n\trep(i,n){\n\t\tint x,y;\n\t\tchar w;\n\t\tcin >> x >> y >> w;\n\n\t\tconst int u=d-y,b=y,l=x,r=w-x;\n\n\t\tswitch(w){\n\t\t\tcase 'N':\n\t\t\t\ts[i]=(l<=u?convert(0,y+l):convert(x-u,d));\n\t\t\t\tg[i]=(r<=u?convert(w,y+r):convert(x+u,d));\n\t\t\t\tbreak;\n\n\t\t\tcase 'W':\n\t\t\t\ts[i]=(b<=l?convert(x-b,0):convert(0,y-l));\n\t\t\t\tg[i]=(u<=l?convert(x-u,d):convert(0,y+l));\n\t\t\t\tbreak;\n\n\t\t\tcase 'E':\n\t\t\t\ts[i]=(u<=r?convert(x+u,d):convert(w,y+r));\n\t\t\t\tg[i]=(b<=r?convert(x+b,0):convert(w,y-r));\n\t\t\t\tbreak;\n\n\t\t\tcase 'S':\n\t\t\t\ts[i]=(r<=b?convert(w,y-r):convert(x+b,0));\n\t\t\t\tg[i]=(l<=b?convert(0,y-l):convert(x-b,0));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tconst int all=2*(w+d);\n\n\tint ans=n;\n\n\trep(i,n){\n\t\tchmin(ans,greedy(n,s[i],all));\n\t\tchmin(ans,greedy(n,g[i],all));\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\ntypedef complex<double> P;\n\nint main(){\n    int N, W, D;\n    cin >> N >> W >> D;\n    int L = 2 * (W + D);\n    P p1 = P(W, 0);\n    P p2 = P(W, D);\n    P p3 = P(0, D);\n    P C = P(0, -1);\n    \n    //end, start\n    vector<pair<int, int>> lines;\n    \n    for(int i=0; i<N; i++){\n        int x, y; string f;\n        cin >> x >> y >> f;\n        P p = P(x, y);\n        \n        switch (f[0]) {\n            case 'W':\n                p = (p - p3) * C + p3;\n            case 'N':\n                p = (p - p2) * C + p2;\n            case 'E':\n                p = (p - p1) * C + p1;\n            default:\n                break;\n        }\n        lines.emplace_back(p.real()+p.imag(), p.real()-p.imag());\n    }\n    sort(lines.begin(), lines.end());\n    \n    int ans = INF;\n    for(int s=0; s<N; s++){\n        int tans = 0;\n        int p = lines[0].first;\n        for(int i=0; i<N; ){\n            while(i<N && lines[i].second <= p) i++;\n            p = lines[i].first;\n            tans++;\n        }\n        ans = min(ans, tans);\n        \n        lines[0].first += L;\n        lines[0].second += L;\n        sort(lines.begin(), lines.end());\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\n\nint main(){\n    int n,w,d;\n    cin>>n>>w>>d;\n    vector<pair<int,int>> p(n);\n    rep(i,n){\n        int x,y;\n        char f;\n        cin>>x>>y>>f;\n        if(f=='N'){\n            p[i].first=2*w-x+y;\n            p[i].second=2*w+2*d-x-y;\n        }\n        else if(f=='S'){\n            p[i].first=x-y;\n            p[i].second=x+y;\n        }\n        else if(f=='E'){\n            p[i].first=x+y;\n            p[i].second=2*w-x+y;\n        }\n        else if(f=='W'){\n            p[i].first=-x-y;\n            p[i].second=x-y;\n        }\n    }\n    int ans=n;\n    int l=2*w+2*d;\n    rep(i,n){\n        vector<pair<int,int>> q;\n        int x=p[i].first;\n        for(auto pp : p){\n            if(pp.first<=x&&x<=pp.second)continue;\n            if(pp.first<=x-l&&x-l<=pp.second)continue;\n            if(pp.first<=x+l&&x+l<=pp.second)continue;\n            while(pp.first>x){\n                pp.first-=l;pp.second-=l;\n            }\n            while(pp.first<=x){\n                pp.first+=l;pp.second+=l;\n            }\n            q.push_back(pp);\n        }\n        sort(q.begin(),q.end(),[](auto x,auto y){\n            return x.second<y.second;\n        });\n        int ret=1;\n        int cur=-inf;\n        for(auto qq:q){\n            if(qq.first>cur){\n                ++ret;\n                cur=qq.second;\n            }\n        }\n        ans=min(ans,ret);\n        q.clear();\n        x=p[i].second;\n        for(auto pp : p){\n            if(pp.first<=x&&x<=pp.second)continue;\n            if(pp.first<=x-l&&x-l<=pp.second)continue;\n            if(pp.first<=x+l&&x+l<=pp.second)continue;\n            while(pp.first>x){\n                pp.first-=l;pp.second-=l;\n            }\n            while(pp.first<=x){\n                pp.first+=l;pp.second+=l;\n            }\n            q.push_back(pp);\n        }\n        sort(q.begin(),q.end(),[](auto x,auto y){\n            return x.second<y.second;\n        });\n        ret=1;\n        cur=-inf;\n        for(auto qq:q){\n            if(qq.first>cur){\n                ++ret;\n                cur=qq.second;\n            }\n        }\n        ans=min(ans,ret);\n    }\n    cout<<ans<<endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\n\n#define fi first\n#define se second\n\nusing P = pair<int, int>;\nint n, w, h;\nint L;\n\nP calc(int x, int y, char c) {\n    P ret;\n    if(c == 'E') ret = {x+y, 2*w - x + y};\n    else if(c == 'S') ret = {x - y, x + y};\n    else if(c == 'W') ret = {L-x-y, L+x-y};\n    else if(c == 'N') ret = {2*w-x+y, L-x-y};\n    else assert(false);\n    return ret;\n}\n\nint f(const vector<P>& d, int k) {\n    int n = d.size();\n    vector<P> v(n);\n    rep(i, n) {\n        v[i] = {d[i].fi - d[k].fi, d[i].se - d[k].fi};\n        while(v[i].fi < 0) {\n            v[i].fi += L;\n            v[i].se += L;\n        }\n    }\n    sort(v.begin(), v.end(), [&](const P& a, const P& b){return a.se < b.se;});\n    int z = -1;\n    int cnt = 0;\n    for(auto&& p : v) {\n        if(p.fi <= z) continue;\n        else {\n            z = p.se;\n            cnt++;\n        }\n    }\n    // cout << \"k :\" << k << endl;\n    // rep(i, n) cout << v[i].fi << \" \" << v[i].se << endl;\n    // cout << \"cnt :\" << cnt << endl;\n    return cnt;\n}\n\n\nint main() {\n    cin >> n >> w >> h;\n    L = 2*w + 2*h;\n    set<P> st;\n    rep(i, n) {\n        int x, y;\n        char c;\n        cin >> x >> y >> c;\n        st.insert(calc(x, y, c));\n    }\n    // for(auto&& p : st) cout << p.fi << \", \" << p.se << endl;\n    vector<P> d;\n    for(auto&& p : st) d.push_back(p);\n    int ans = 1e9;\n    rep(i, d.size()) {\n        ans = min(ans, f(d, i));\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct range{\n\tint st, en;\n} pos[1000];\n\nint n, w, d;\nmap<int,vector<int> > m;\nmap<int,vector<int> >::iterator it;\nmap<int,int> nxt;\nvector<int> xx[2000];\nbool saw[1000];\n\nint main(){\n\tcin >> n >> w >> d;\n\trep(i,n){\n\t\tint x, y; char f;\n\t\tcin >> x >> y >> f;\n\t\ty = d-y;\n\t\tif(f == 'N'){\n\t\t\tif(w-x < y){\n\t\t\t\t//pos[i].st = P(w,y-w+x);\n\t\t\t\tpos[i].st = w+d*2-(y-w+x);\n\t\t\t} else{\n\t\t\t\t//pos[i].st = P(x+y,0);\n\t\t\t\tpos[i].st = w*2+d*2-(x+y);\n\t\t\t}\n\t\t\tif(x < y){\n\t\t\t\t//pos[i].en = P(0,y-x);\n\t\t\t\tpos[i].en = y-x;\n\t\t\t} else{\n\t\t\t\t//pos[i].en = P(x-y,0);\n\t\t\t\tpos[i].en = w*2+d*2-(x-y);\n\t\t\t}\n\t\t} else if(f == 'E'){\n\t\t\tif(w-x < d-y){\n\t\t\t\t//pos[i].st = P(w,y+w-x);\n\t\t\t\tpos[i].st = w+d*2-(y+w-x);\n\t\t\t} else{\n\t\t\t\t//pos[i].st = P(x+d-y,d);\n\t\t\t\tpos[i].st = d+x+d-y;\n\t\t\t}\n\t\t\tif(w-x < y){\n\t\t\t\t//pos[i].en = P(w,y-w+x);\n\t\t\t\tpos[i].en = w+d*2-(y-w+x);\n\t\t\t} else{\n\t\t\t\t//pos[i].en = P(x+y,0);\n\t\t\t\tpos[i].en = w*2+d*2-(x+y);\n\t\t\t}\n\t\t} else if(f == 'W'){\n\t\t\tif(x < y){\n\t\t\t\t//pos[i].en = P(0,y-x);\n\t\t\t\tpos[i].st = y-x;\n\t\t\t} else{\n\t\t\t\t//pos[i].en = P(x-y,0);\n\t\t\t\tpos[i].st = w*2+d*2-(x-y);\n\t\t\t}\n\t\t\tif(x < d-y){\n\t\t\t\t//pos[i].en = P(0,y+x);\n\t\t\t\tpos[i].en = y+x;\n\t\t\t} else{\n\t\t\t\t//pos[i].en = P(x+y-d,d);\n\t\t\t\tpos[i].en = d+x+y-d;\n\t\t\t}\n\t\t} else{\n\t\t\tif(x < d-y){\n\t\t\t\t//pos[i].en = P(0,y+x);\n\t\t\t\tpos[i].st = y+x;\n\t\t\t} else{\n\t\t\t\t//pos[i].en = P(x+y-d,d);\n\t\t\t\tpos[i].st = d+x+y-d;\n\t\t\t}\n\t\t\tif(w-x < d-y){\n\t\t\t\t//pos[i].st = P(w,y+w-x);\n\t\t\t\tpos[i].en = w+d*2-(y+w-x);\n\t\t\t} else{\n\t\t\t\t//pos[i].st = P(x+d-y,d);\n\t\t\t\tpos[i].en = d+x+d-y;\n\t\t\t}\n\t\t}\n\t\t//cout << pos[i].st << \" \" << pos[i].en  << endl;\n\t\tm[pos[i].st].push_back(i);\n\t\tm[pos[i].en].push_back(i);\n\t}\n\tint cnt = 0;\n\tfor(it = m.begin(); it != m.end(); it++){\n\t\tvector<int> v = (*it).second;\n\t\txx[cnt] = v;\n\t\tnxt[(*it).first] = cnt;\n\t\tcnt++;\n\t}\n\tint ans = INF;\n\trep(i,cnt){\n\t\tint counter = 1;\n\t\trep(j,n) saw[j] = false;\n\t\trep(j,xx[i].size()){\n\t\t\tsaw[xx[i][j]] = true;\n\t\t}\n\t\tmap<int,int> tmp;\n\t\tfor(int j = i+1; j < cnt; j++){\n\t\t\trep(k,xx[j].size()){\n\t\t\t\tif(saw[xx[j][k]]) continue;\n\t\t\t\tif(nxt[pos[xx[j][k]].en] == j){\n\t\t\t\t\tif(tmp[xx[j][k]] == 1){\n\t\t\t\t\t\ttmp.clear();\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t}\n\t\t\t\t} else{\n\t\t\t\t\ttmp[xx[j][k]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < i; j++){\n\t\t\trep(k,xx[j].size()){\n\t\t\t\tif(saw[xx[j][k]]) continue;\n\t\t\t\tif(nxt[pos[xx[j][k]].en] == j){\n\t\t\t\t\tif(tmp[xx[j][k]] == 1){\n\t\t\t\t\t\ttmp.clear();\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t}\n\t\t\t\t} else{\n\t\t\t\t\ttmp[xx[j][k]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = min(ans,counter);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <set>\nusing namespace std;\nusing T=tuple<int,int,int>;//i,r=0/l=1,i\nint main(){\n\tint n,w,d;\n\tcin>>n>>w>>d;\n\tvector<T> V;\n\tfor(int i=0;i<n;i++){\n\t\tint x,y; char dir;\n\t\tcin>>x>>y>>dir;\n\t\tif(dir=='N'){\n\t\t\t//left\n\t\t\tif(x+y<=d){\n\t\t\t\tV.emplace_back(2*w+2*d-(x+y),1,i);\n\t\t\t}else{\n\t\t\t\tV.emplace_back(2*w+d-(x+y-d),1,i);\n\t\t\t}\n\t\t\t//right\n\t\t\tif(y+w-x<=d){\n\t\t\t\tV.emplace_back(w+(y+w-x),0,i);\n\t\t\t}else{\n\t\t\t\tV.emplace_back(2*w+d-(x+d-y),0,i);\n\t\t\t}\n\t\t}else if(dir=='S'){\n\t\t\t//left\n\t\t\tif(x+y-w>=0){\n\t\t\t\tV.emplace_back(w+(x+y-w),1,i);\n\t\t\t}else{\n\t\t\t\tV.emplace_back(x+y,1,i);\n\t\t\t}\n\t\t\t//right\n\t\t\tif(y-x>=0){\n\t\t\t\tV.emplace_back(2*w+2*d-(y-x),0,i);\n\t\t\t}else{\n\t\t\t\tV.emplace_back(x-y,0,i);\n\t\t\t}\n\t\t}else if(dir=='E'){\n\t\t\t//left\n\t\t\tif(y+w-x<=d){\n\t\t\t\tV.emplace_back(w+(y+w-x),1,i);\n\t\t\t}else{\n\t\t\t\tV.emplace_back(2*w+d-(x+d-y),1,i);\n\t\t\t}\t\t\t\n\t\t\t//right\n\t\t\tif(x+y-w>=0){\n\t\t\t\tV.emplace_back(w+(x+y-w),0,i);\n\t\t\t}else{\n\t\t\t\tV.emplace_back(x+y,0,i);\n\t\t\t}\n\t\t}else if(dir=='W'){\n\t\t\t//left\n\t\t\tif(y-x>=0){\n\t\t\t\tV.emplace_back(2*w+2*d-(y-x),1,i);\n\t\t\t}else{\n\t\t\t\tV.emplace_back(x-y,1,i);\n\t\t\t}\n\t\t\t//right\n\t\t\tif(x+y<=d){\n\t\t\t\tV.emplace_back(2*w+2*d-(x+y),0,i);\n\t\t\t}else{\n\t\t\t\tV.emplace_back(2*w+d-(x+y-d),0,i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<2*n;i++){\n\t\tint a,b,c; tie(a,b,c)=V[i];\n\t\tV.emplace_back(a+2*w+2*d,b,c);\n\t\tV.emplace_back(a+4*w+4*d,b,c);\n\t}\n\tsort(V.begin(),V.end());\n\t/*\n\tfor(auto v:V){\n\t\tint a,b,c; tie(a,b,c)=v;\n\t\tcout<<a<<' '<<b<<' '<<c<<endl;\n\t}*/\n\tint best = n+1;\n\tfor(int j=0;j<2*n;j++){\n\t\tset<int> S;\n\t\tvector<int> Sta(n);//0:not covered, 1:covered\n\t\tint ans = 0;\n\t\tfor(int i=j;i<j+2*n;i++){\n\t\t\tint loc,id,lr; tie(loc,lr,id)=V[i];\n\t\t\tif(lr==0){//r\n\t\t\t\t//S[id]=1;\n\t\t\t\tS.insert(id);\n\t\t\t}else{//l\n\t\t\t\tS.erase(id);\n\t\t\t}\n\t\t}\n\t\tfor(int i=j+2*n;i<j+4*n;i++){\n\t\t\tint loc,id,lr; tie(loc,lr,id)=V[i];\n\t\t\tif(lr==0){//r\n\t\t\t\t//cout<<loc<<' '<<id<<endl;\n\t\t\t\tif(Sta[id]==0){\n\t\t\t\t\tS.insert(id);\n\t\t\t\t}\n\t\t\t}else{//l\n\t\t\t\tif(S.count(id)){\n\t\t\t\t\tans++;\n\t\t\t\t\tfor(auto &s:S){\n\t\t\t\t\t\tSta[s]=1;\n\t\t\t\t\t}\n\t\t\t\t\tS.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout<<ans<<endl;\n\t\tbest=min(ans,best);\n\t}\n\tcout<<best<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c\n\tif (cross(nb, nc) < -eps) return -1; // a,\n\tif (dot(nb, nc) < 0) return 2;       //\n\tif (norm(nb) < norm(nc)) return -2;  // \n\treturn 0;                          \n}\n\n\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\nconst int dx0[4] = { -1,0,1,0 };\nconst int dy0[4] = { 0,1,0,-1 };\n\nconst int dx[4] = { -1,-1,1,1 };\nconst int dy[4] = { -1,1,1,-1 };\n\nint N, W, D;\n\nint getnum(int x, int y) {\n\tif (x == 0) {\n\t\treturn y;\n\t}\n\telse if (y == D) {\n\t\treturn D + x;\n\t}\n\telse if (x == W) {\n\t\treturn 2 * D + W - y;\n\t}\n\telse {\n\t\tassert(!y);\n\t\treturn 2 * D + 2 * W - x;\n\t}\n}\nbool isorder(const int a, const int b, const int c) {\n\tif (a < c) {\n\t\treturn a <= b&&b <= c;\n\t}\n\telse if (a>c) {\n\t\treturn a <= b || b <= c;\n\t}\n\telse\n\t{\n\t\treturn true;\n\t}\n}\nstruct Compress {\n\tmap<int, int>mp;\n\tmap<int, int>revmp;\n\n\tCompress(vector<int>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()),vs.end());\n\t\tfor (int i = 0; i < vs.size(); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n};\nmap<char, int>mp;\nint main() {\n\tmp['W'] = 0;\n\tmp['S'] = 1;\n\tmp['E'] = 2;\n\tmp['N'] = 3;\n\tcin >> N >> W >> D;\n\tvector<Line> ls;\n\tls.push_back(Line(Point(0, 0), Point(0, D)));\n\tls.push_back(Line(Point(1, D), Point(W - 1, D)));\n\tls.push_back(Line(Point(W, D), Point(W, 0)));\n\tls.push_back(Line(Point(W - 1, 0), Point(1, 0)));\n\tvector<pair<int, int>>ps;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y; char f; cin >> x >> y >> f;\n\t\ty = D - y;\n\t\tPoint p(x, y);\n\t\tint num1, num2;\n\t\tint betnum;\n\t\t{\n\t\t\tconst int way = mp[f];\n\t\t\tLine l(p, p + 1000000.l * Point(dx[way], dy[way]));\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tif (isis_ss(l, ls[i])) {\n\t\t\t\t\tPoint sect(is_ll(l, ls[i]));\n\t\t\t\t\tnum1 = getnum(round(sect.real()), round(sect.imag()));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tconst int way = (mp[f]+1)%4;\n\t\t\tLine l(p, p + 1000000.l * Point(dx[way], dy[way]));\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tif (isis_ss(l, ls[i])) {\n\t\t\t\t\tPoint sect(is_ll(l, ls[i]));\n\t\t\t\t\tnum2 = getnum(round(sect.real()), round(sect.imag()));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tconst int way = mp[f];\n\t\t\tLine l(p, p + 1000000.l * Point(dx0[way], dy0[way]));\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tif (isis_ss(l, ls[i])) {\n\t\t\t\t\tPoint sect(is_ll(l, ls[i]));\n\t\t\t\t\tbetnum = getnum(round(sect.real()), round(sect.imag()));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (num1 < num2) {\n\t\t\tif (num1 < betnum&&betnum < num2) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tswap(num1, num2);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (num2 < betnum&&betnum < num1) {\n\t\t\t\tswap(num1, num2);\n\t\t\t}\n\t\t\telse {\n\t\t\t}\n\t\t}\n\t\tps.emplace_back(num1, num2);\n\t}\n\tsort(ps.begin(), ps.end());\n\tvector<int>v;\n\tfor (auto p : ps) {\n\t\tv.emplace_back(p.first);\n\t\tv.emplace_back(p.second);\n\t}\n\tCompress comp(v);\n\t\n\tfor (auto&p : ps) {\n\t\tp.first = comp.mp[p.first];\n\t\tp.second = comp.mp[p.second];\n\t}\n\t{\n\t\tbool a = is_sorted(ps.begin(), ps.end());\n\t\tassert(a);\n\t}\n\tint _size = comp.mp.size();\n\tint ans = 1e5;\n\tfor (int start = 0; start < ps.size(); ++start) {\n\t\tint num = 1;\n\t\tconst int anum = ps[start].first;\n\t\tqueue<int>que;\n\t\tint amin = 1e8;\n\t\tfor (int p = start; p < start + ps.size();++p) {\n\t\t\tconst int from = ps[p%N].first;\n\t\t\tconst int to = ps[p%N].second;\n\t\t\tif (isorder(from, anum, to))continue;\n\t\t\tconst int realfrom = from < anum ? from + _size : from;\n\t\t\tconst int realto = to < anum ? to + _size : to;\n\t\t\tamin = min(amin, realto);\n\t\t\tif (amin < realfrom) {\n\t\t\t\tamin = realto;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t\tif (amin != 1e5)num++;\n\t\tans = min(ans, num);\n\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class U, class V> ostream& operator<<(ostream& os, const pair<U, V>& p) {\n        return os << \"(\" << p.first << \",\" << p.second << \")\";\n    }\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int N, W, D;\n    int p(int x, int y) {\n        if (x == 0) return y;\n        else if (x == W) return D + W + (D - y);\n        else if (y == D) return D + x;\n        else { assert(y == 0);\n            return D + W + D + (W - x);\n        }\n    }\n    int p(const pair<int, int>& s) {\n        return p(s.first, s.second);\n    }\n\n    map<string, int> M;\n    void init() { M[\"W\"] = 0; M[\"N\"] = 1; M[\"E\"] = 2; M[\"S\"] = 3; }\n\n    pair<int, int> cr(int x, int y, string f) {\n        vector< pair<int, int> > ds;\n\n        if (x - y > 0) ds.push_back(make_pair(x - y, 0));\n        else ds.push_back(make_pair(0, y - x));\n\n        if (x - (D - y) > 0) ds.push_back(make_pair(x - (D - y), D));\n        else ds.push_back(make_pair(0, x + y));\n\n        if (x + D - y < W) ds.push_back(make_pair(x + D - y, D));\n        else ds.push_back(make_pair(W, y + W - x));\n\n        if (x + y < W) ds.push_back(make_pair(x + y, 0));\n        else ds.push_back(make_pair(W, y - (W - x)));\n\n        //cout << make_pair(x, y) << \" -> \" << ds << endl;\n\n        int p0 = p(ds[ M[f] ]);\n        int p1 = p(ds[ (M[f] + 1) % 4 ]);\n        return make_pair(p0, p1);\n    }\n\n    vector< pair<int, int> > V;\n    void input() {\n        init();\n        cin >> N >> W >> D;\n        for (int i = 0; i < N; i++) {\n            int x, y; string f;\n            cin >> x >> y >> f;\n            V.push_back(cr(x, y, f));\n        }\n        //cout << V << endl;\n    }\n\n    const int INF = 1<<28;\n\n    bool contain(pair<int, int> s, int k) {\n        if (s.first > s.second) s.second += 2 * (W + D);\n        if (s.first <= k && k <= s.second) return true;\n        k += 2 * (W + D);\n        return s.first <= k && k <= s.second;\n    }\n\n    int calc(int index) {\n        int k = V[index].second;\n        vector< pair<int, int> > T;\n        for (int i = 0; i < N; i++) {\n            if (!contain(V[i], k)) {\n                int x = V[i].first, y = V[i].second;\n                if (x < k) x += 2 * (W + D);\n                if (y < k) y += 2 * (W + D);\n                T.push_back(make_pair(x, y));\n            }\n        }\n        sort(T.begin(), T.end());\n        //cout << \"k: \" << k << \" \" << \"T: \" << T << endl;\n        int c = 0;\n        for (int i = 0, a = 0; a < T.size(); ) {\n            while (i < T.size() && T[i].first <= T[a].second) {\n                i++;\n            }\n            a = i + 1;\n            c++;\n        }\n        return c;\n    }\n\n    void solve() {\n        int ans = INF;\n        for (int i = 0; i < V.size(); i++) {\n            ans = min(ans, calc(i) + 1);\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nint main(){\n    int n,w,d;\n    cin >>n >>w >>d;\n\n    auto crosspoint = [&](int dx, int dy, pi p){\n        int mind = 19191919;\n        pi ret(-1,-1);\n\n        int D;\n        // x = 0\n        D = -p.fi/dx;\n        if(D>=0){\n            if(D < mind){\n                mind = D;\n                ret = {0, p.se+D*dy};\n            }\n        }\n\n        // x = w\n        D = (w-p.fi)/dx;\n        if(D>=0){\n            if(D < mind){\n                mind = D;\n                ret = {w, p.se+D*dy};\n            }\n        }\n\n        // y = 0\n        D = -p.se/dy;\n        if(D>=0){\n            if(D < mind){\n                mind = D;\n                ret = {p.fi+D*dx, 0};\n            }\n        }\n\n        // y = d\n        D = (d-p.se)/dy;\n        if(D>=0){\n            if(D < mind){\n                mind = D;\n                ret = {p.fi+D*dx, d};\n            }\n        }\n\n        assert(ret.fi != -1);\n        return ret;\n    };\n\n    auto cv = [&](pi p){\n        if(p.se == 0) return p.fi;\n        if(p.fi == w) return w+p.se;\n        if(p.se == d) return w+d+(w-p.fi);\n        return w+d+w+(d-p.se);\n    };\n\n    vector<pi> r(n);\n    rep(i,n){\n        int x,y;\n        char f;\n        cin >>x >>y >>f;\n\n        int rdx,rdy,ldx,ldy;\n        if(f=='N'){\n            rdx = 1;\n            rdy = 1;\n            ldx = -1;\n            ldy = 1;\n        }\n        else if(f=='E'){\n            rdx = 1;\n            rdy = -1;\n            ldx = 1;\n            ldy = 1;\n        }\n        else if(f=='W'){\n            rdx = -1;\n            rdy = 1;\n            ldx = -1;\n            ldy = -1;\n        }\n        else if(f=='S'){\n            rdx = -1;\n            rdy = -1;\n            ldx = 1;\n            ldy = -1;\n        }\n\n        pi s = crosspoint(rdx,rdy,{x,y});\n        pi g = crosspoint(ldx,ldy,{x,y});\n\n        r[i] = {cv(s), cv(g)};\n    }\n\n    auto include = [&](pi p, int s){\n        if(p.fi<p.se) return p.fi<=s && s<=p.se;\n        else return p.fi<=s || s<=p.se;\n    };\n\n    auto check = [&](int idx){\n        int MOD = 2*(d+w);\n        int s = r[idx].se;\n\n        using P = pair<int,pi>;\n        vector<P> ev;\n        rep(i,n){\n            if(!include(r[i],s)){\n                ev.pb({(r[i].fi-s+MOD)%MOD, {0,i}});\n                ev.pb({(r[i].se-s+MOD)%MOD, {1,i}});\n            }\n        }\n        sort(all(ev));\n\n        int ret = 1;\n        vector<bool> used(n);\n        set<int> in;\n        for(const auto &e:ev){\n            int act = e.se.fi;\n            int ID = e.se.se;\n\n            if(act == 0) in.insert(ID);\n            else{\n                if(!used[ID]){\n                    for(int i:in) used[i] = true;\n                    in.clear();\n                    ++ret;\n                }\n            }\n        }\n        return ret;\n    };\n\n    int ans = n;\n    rep(i,n) ans = min(ans, check(i));\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\nstruct Range{\n    int b, e;\n    bool operator < (const Range& r) const {\n        if(b != r.b) return b < r.b;\n        return e < r.e;\n    }\n};\nint N, W, H;\nint solve(vector<Range> ranges) {\n    sort(ranges.begin(), ranges.end());\n    vector<Range> rs;\n    vector<Range> rs2;\n    const int L = 2 * (W + H);\n    REP(i, ranges.size()) {\n        // if(rs.empty() || rs.back().e < ranges[i].e) {\n            rs.push_back(ranges[i]);\n            rs2.push_back({ranges[i].b + L, ranges[i].e + L});\n        // }\n    }\n    REP(i, rs2.size()) rs.push_back(rs2[i]);\n    sort(rs.begin(), rs.end(), [&](Range a, Range b){ if(a.e != b.e) return a.e < b.e; return a.b < b.b;});\n    int n = rs.size() / 2;\n    int ans = INT_MAX;\n    for(int s = 0; s < n; s++) {\n        int sub = 0;\n        for(int i = s; i < 2 * n;) {\n            if(i >= s + n) break;\n            const int take = rs[i].e;\n            while(i < s + n && rs[i].b <= take && take <= rs[i].e) {\n                i++;\n            }\n            sub++;\n        }\n        ans = min(ans, sub);\n    }\n    return ans;\n}\nvoid move(int& x, int& y, int dx, int dy) {\n    int t = INT_MAX;\n    if(dx == -1) t = min(t, x);\n    if(dx == +1) t = min(t, (W-1) - x);\n    if(dy == -1) t = min(t, y);\n    if(dy == +1) t = min(t, (H-1) - y);\n    x += t * dx;\n    y += t * dy;\n}\nint convert(int x, int y) {\n    if(x == 0 && y == 0) return 0;\n    if(y == 0) {\n        return x;\n    }\n    if(x == W - 1) {\n        return W + y;\n    }\n    if(y == H - 1) {\n        return W + H + (W - 1 - x);\n    }\n    assert(x == 0);\n    return W + H + W + (H - 1 - y);\n}\nint main(){\n    iostream_init();\n    while(cin >> N >> W >> H) {\n        W++; H++;\n        vector<Range> ranges;\n        REP(i, N) {\n            int x, y;\n            cin >> x >> y;\n            string F;\n            cin >> F;\n            int lx = x, ly = y;\n            int rx = x, ry = y;\n            if(F == \"N\") {\n                // up\n                move(lx, ly, +1, +1);\n                move(rx, ry, -1, +1);\n            } else if(F == \"E\") {\n                // right\n                move(lx, ly, +1, -1);\n                move(rx, ry, +1, +1);\n            } else if(F == \"S\") {\n                // down\n                move(lx, ly, -1, -1);\n                move(rx, ry, +1, -1);\n            } else if(F == \"W\") {\n                // left\n                move(lx, ly, -1, +1);\n                move(rx, ry, -1, -1);\n            }\n            int L = convert(lx, ly);\n            int R = convert(rx, ry);\n            if(L > R) R += 2 * (W + H); // ok ???\n            ranges.push_back({L, R});\n        }\n        // REP(i, ranges.size()) {\n        //     cout << \"(\" << ranges[i].b << \",\" << ranges[i].e << \") \";\n        // }\n        // cout << endl;\n        cout << solve(ranges) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n  int n, w, d;\n  cin >> n >> w >> d;\n  vector<pair<int,int>> ps;\n  // mapping to the south-west corner \n  auto mapping0 = [](int x, int y) {\n    return x - y;\n  };\n  // mapping in one of four directions\n  auto mappingX = [w,d,&mapping0](int x, int y, int dir) {\n    switch(dir) {\n    case 0 : { // (-1, -1)-direction\n      int o = mapping0(x, y);\n      return o; // o >= 0 ? o : w + w + d + d + o; // normalization\n    }\n    case 1 : { // (1, -1)-direction\n      int o = mapping0(w-x, y); // flipping in x\n      return w - o; // o >= 0 ? w - o : w + (- o);\n    }\n    case 2 : { // (1, 1)-direction\n      int o = mapping0(w-x, d-y); // flipping in x and y\n      return w + d + o; // o >= 0 ? w + d + o : w + d + o;\n    }\n    case 3 : { // (-1, 1)-direction\n      int o = mapping0(x, d-y); // flipping in y\n      return w + d + w - o; // o >= 0 ? w + d + w - o : w + d + w + -o;\n    }\n    return -1;\n    }\n  };\n  // mapping to a range\n  auto make_range = [w,d,&mappingX](int x, int y, char c) {\n    switch(c){\n    case 'N': return make_pair(mappingX(x, y, 2), mappingX(x, y, 3));\n    case 'E': return make_pair(mappingX(x, y, 1), mappingX(x, y, 2));\n    case 'S': {\n      int s = mappingX(x, y, 0);\n      int e = mappingX(x, y, 1);\n      if(s < 0) { // normalize to non-negative\n        s += d + d + w + w;\n        e += d + d + w + w;\n      }\n      return make_pair(s, e);\n    }\n    case 'W': {\n      int s = mappingX(x, y, 3);\n      int e = mappingX(x, y, 0) + w + w + d + d;\n      return make_pair(s, e);\n    }\n    }\n    return make_pair(-10, -10);\n  };\n  \n  for(int i = 0; i < n; i++) {\n    int x, y, d;\n    char c;\n    cin >> x >> y;\n    cin >> c;\n    ps.push_back(make_range(x, y, c));\n  }\n  // a desk = a range on walls\n  // a lock = a point on walls\n  // todo: put points so that every range contains a point\n\n  // sort the ranges\n  sort(ps.begin(), ps.end());\n\n  // shrink the region (endpoint ee) by the range r\n  auto shrink = [d,w](bool aug, const pair<int,int> &r, int *ee) {\n    int s = r.first + (aug ? (d + d + w + w) : 0);\n    int e = r.second + (aug ? (d + d + w + w) : 0);\n    if(s <= *ee) {\n      *ee = min(*ee, e);\n      return true;\n    }\n    return false;\n  };\n  int maxov = 0;\n  // locating clocks from i's view\n  auto count = [&ps,n,&shrink,&maxov](const int ii){\n    int i = ii;\n    int k = 0;\n    int cnt = 0;\n    maxov = 0;\n    while(k < n) {\n      int e = ps[i].second;\n      int kk = k;\n      k++;\n      i = (i + 1) % n;\n      while(k < n && shrink(i < ii, ps[i], &e)) {\n        i = (i + 1) % n;\n        k++;\n      }\n      if(k - kk > maxov) maxov = k - kk;\n      cnt++;\n    }\n    return cnt;\n  };\n\n  int mx = 0;\n  int idx = -1;\n  int cnt = n; // at most n\n  // possible starting points\n  vector<int> cs;\n  for(int i = 0; i < n; i++) {\n    int cc = count(i);\n    cs.push_back(cc);\n    if(mx < maxov) {\n      idx = i;\n      mx = maxov;\n    }\n  }\n  cout << cs[idx] << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P1;\nint n,w,d,x,y,ans;\nvector<P1> v;\nchar f;\nstack<int> q;\nbool used[N];\n\nvoid add_point(int num){\n  if(f=='N'){\n    if(x+y<d)v.push_back(P1(P(x+y+w*2+d,0),num));\n    else v.push_back(P1(P(x+y-d,0),num));\n    if(w+y-x<d)v.push_back(P1(P(d-(w+y-x)+w,1),num));\n    else v.push_back(P1(P(d-(y-x),1),num));\n  }\n  if(f=='E'){\n    if(d-(y-x)<w)v.push_back(P1(P(d-(y-x),0),num));\n    else v.push_back(P1(P(d-(w+(y-x))+w,0),num));\n    if(y+x<w)v.push_back(P1(P(w-(y+x)+w+d,1),num));\n    else v.push_back(P1(P(d-(-w+y+x)+w,1),num));\n  }\n  if(f=='S'){\n    if(0<=-w+y+x)v.push_back(P1(P(d-(-w+y+x)+w,0),num));\n    else v.push_back(P1(P(w-(y+x)+w+d,0),num));\n    if(0<=y-x)v.push_back(P1(P(y-x+w*2+d,1),num));\n    else v.push_back(P1(P(w-(-(y-x))+w+d,1),num));\n  }\n  if(f=='W'){\n    if(0<=-(y-x))v.push_back(P1(P(w-(-(y-x))+w+d,0),num));\n    else v.push_back(P1(P(y-x+w*2+d,0),num));\n    if(0<y+x-d)v.push_back(P1(P(y+x-d,1),num));\n    else v.push_back(P1(P(y+x+w*2+d,1),num));\n  }\n}\n\nbool usednum[500000];\n\nvoid solve(){\n  int len=v.size(),cnt;\n  for(int i=0;i<len;i++){\n    memset(used,0,sizeof(used));\n    memset(usednum,0,sizeof(usednum));\n    if(v[i].first.second)continue;\n    cnt=0;\n    for(int j=i;j<len+i;j++){\n      int idx=j%len;\n      if(used[v[idx].second])continue;\n      if(!v[idx].first.second)q.push(v[idx].second);\n      else{\n\tcnt++;\n\tif(usednum[v[idx].first.first])cnt--;\n\tusednum[v[idx].first.first]=true;\n\twhile(!q.empty()){\n\t  int num=q.top(); q.pop();\n\t  used[num]=true;\n\t}\n      }\n    }\n    ans=min(ans,cnt);\n  }\n}\n\nint main(){\n  cin>>n>>w>>d;\n  for(int i=0;i<n;i++){\n    cin>>x>>y>>f;\n    add_point(i);\n  }\n  sort(v.begin(),v.end());\n  ans=(1e9);\n  solve();\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 100100;\n\nint n, w, h, x, y, id[N];\nchar c;\npair <int, int> p1;\npair <int, int> p2;\npair <int, int> a[N];\npair <int, int> b[N];\nmap < pair <int, int>, int > mp;\nvector < pair <int, int> > p;\nvector < pair < pair <int, int>, pair <int, int> > > v;\n\nbool cmp(pair <int, int> u, pair <int, int> v) {\n    if (u.first == v.first) {\n        if (u.first == 0) {\n            return u.second > v.second;\n        } else {\n            return u.second < v.second;\n        }\n    } else if (u.second == v.second) {\n        if (u.second == 0) {\n            return u.first < v.first;\n        } else {\n            return u.first == 0 || (v.first != 0 && u.first > v.first);\n        }\n    } else if (u.first == 0) {\n        return true;\n    } else if (u.second == 0) {\n        return v.first != 0;\n    } else if (u.first == w) {\n        return v.second == h;\n    } else {\n        return false;\n    }\n}\n\npair <int, int> get(int x, int y, int dx, int dy) {\n    int low = 0;\n    int high = 100000;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        int nx = x + dx * mid;\n        int ny = y + dy * mid;\n        if (0 < nx && nx < w && 0 < ny && ny < h) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    int nx = x + dx * low;\n    int ny = y + dy * low;\n    return make_pair(nx, ny);\n}\n\nint main() {\n\n    while (scanf(\"%d %d %d\", &n, &w, &h) != EOF) {\n        int ans = n;\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d %c\", &x, &y, &c);\n            y = h - y;\n            if (c == 'N') {\n                p1 = get(x, y, -1, -1);\n                p2 = get(x, y, 1, -1);\n            } else if (c == 'S') {\n                p1 = get(x, y, -1, 1);\n                p2 = get(x, y, 1, 1);\n            } else if (c == 'W') {\n                p1 = get(x, y, -1, -1);\n                p2 = get(x, y, -1, 1);\n            } else if (c == 'E') {\n                p1 = get(x, y, 1, -1);\n                p2 = get(x, y, 1, 1);\n            }\n            p.push_back(p1);\n            p.push_back(p2);\n            if (c == 'S' || c == 'W') {\n                swap(p1, p2);\n            }\n            v.push_back(make_pair(p1, p2));\n        }\n        int l = 0;\n        sort(p.begin(), p.end(), cmp);\n        for (int i = 0, j = 0; i < p.size(); i++) {\n            if (i == 0 || p[i] != p[i - 1]) {\n                mp[p[i]] = l++;\n            }\n        }\n        int m = v.size();\n        for (int i = 0; i < m; i++) {\n            a[i].first = mp[v[i].first];\n            a[i].second = mp[v[i].second];\n        }\n        for (int i = 0; i < l; i++) {\n            for (int j = 0; j < l; j++) {\n                int k = (i + j) % l;\n                id[k] = j;\n            }\n            /*for (int j = 0; j < m; j++) {\n                b[j].first = id[a[j].first];\n                b[j].second = id[a[j].second];\n                if (b[j].first > b[j].second) {\n                    b[j].second += l;\n                }\n                swap(b[j].first, b[j].second);\n            }\n            sort(b, b + m);\n            int pre = b[0].first;\n            int res = 1;\n            for (int j = 1; j < m; j++) {\n                if (b[j].second > pre) {\n                    ++res;\n                    pre = b[j].first;\n                }\n            }\n            ans = min(ans, res);*/\n        }\n        printf(\"%d\\n\", ans);\n        p.clear();\n        v.clear();\n        mp.clear();\n    }\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\n#define fst first\n#define snd second\n  \nint n, len; \n\nint solve(vector<pair<int, int>> & lr){\n    for(auto & e : lr) swap(e.fst, e.snd);\n    sort(begin(lr), end(lr));\n    for(auto & e : lr) swap(e.fst, e.snd);\n    \n    int ret = n;\n    rep(i, n){\n        int cur = 1;\n        int rs = lr[i].snd, frs = rs;\n  \n        // cout << rs << endl;\n\n        range(_, 1, n){\n            int j = (i + _) % n;\n  \n            int cl = lr[j].fst, cr = lr[j].snd;\n            // cout << cl << \" \" << cr << endl;\n            if(cl >= cr){\n                if(cl <= rs or rs <= cr){\n                    continue;\n                }\n                if(cl <= frs or frs <= cr){\n                    continue;\n                }\n\n            }\n            else {\n                if(cl <= rs and rs <= cr){\n                    continue;\n                }\n                if(cl <= frs and frs <= cr){\n                    continue;\n                }\n            }\n  \n            cur++;\n            rs = cr;\n        }\n  \n        ret = min(ret, cur);\n    }\n\n\n    return ret;\n}\n  \nint main(void){\n    int w, h; cin >> n >> w >> h;\n  \n    vector<pair<int, int>> lr(n);\n    len = 2 * w + 2 * h;\n    for(auto & e : lr){\n        int x, y; cin >> x >> y;\n        y = h - y;\n        char f; cin >> f;\n  \n        int o, p;\n        switch(f){\n        case 'N': o = x;                 p = y;     break;\n        case 'E': o = w + y;             p = w - x; break;\n        case 'S': o = 2 * w + h - x;     p = h - y; break;\n        case 'W': o = 2 * w + 2 * h - y; p = x;     break;\n        }\n  \n        e.fst = (o - p + len) % len;\n        e.snd = (o + p) % len;\n    }\n  \n    int res = solve(lr);\n  \n    for(auto & e : lr){\n        e.fst = (len - 1) - e.fst;\n        e.snd = (len - 1) - e.snd;\n    }\n    for(auto & e : lr) swap(e.fst, e.snd);\n    res = min(res, solve(lr));\n  \n    cout << res << endl;\n  \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct data{\n\tint l,r;\n\tdata(){}\n\tdata(int ll,int rr){\n\t\tl=ll;\n\t\tr=rr;\n\t}\n\tbool operator<(const data &d)const{\n\t\tif(r==d.r)return l<d.l;\n\t\treturn r<d.r;\n\t}\n};\n\nint n,w,d;\nvector<data> query;\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&w,&d);\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tchar c;\n\t\tscanf(\"%d%d%*c%c\",&x,&y,&c);\n\t\tif(c=='N'){\n\t\t\tint ll=x-(d-y);\n\t\t\tint rr=x+(d-y);\n\t\t\tif(ll<0)ll+=(w+d)*2;\n\t\t\tquery.push_back(data(ll,rr));\n\t\t}\n\t\tif(c=='E'){\n\t\t\tint ll=w+d-y-(w-x);\n\t\t\tint rr=w+d-y+(w-x);\n\t\t\tquery.push_back(data(ll,rr));\n\t\t}\n\t\tif(c=='S'){\n\t\t\tint ll=w+d+(w-x)-y;\n\t\t\tint rr=w+d+(w-x)+y;\n\t\t\tquery.push_back(data(ll,rr));\n\t\t}\n\t\tif(c=='W'){\n\t\t\tint ll=w+d+w+y-x;\n\t\t\tint rr=w+d+w+y+x;\n\t\t\tif(rr>=(w+d)*2)rr-=(w+d)*2;\n\t\t\tquery.push_back(data(ll,rr));\n\t\t}\n\t}\n\tsort(query.begin(),query.end());\n\tint res=n;\n\tfor(int i=0;i<n;i++){\n\t\tint tmp=0,last=-1,lup=-1;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tdata dd=query[(i+j)%n];\n\t\t\tif(dd.l<dd.r){\n\t\t\t\tif(last<dd.l || dd.r<last){\n\t\t\t\t\ttmp++;\n\t\t\t\t\tlup=j;\n\t\t\t\t\tlast=dd.r;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(last<dd.l){\n\t\t\t\t\ttmp++;\n\t\t\t\t\tlup=j;\n\t\t\t\t\tlast=dd.r;\n\t\t\t\t\twhile(j<n && query[(i+j+1)%n].l>=w+d)j++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres=min(res,tmp);\n\t\t//printf(\"%d %d %d %d\\n\",i,query[i].l,query[i].r,tmp);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint N, W, H;\nint sz;\nint idx(int x, int y){\n  if(y == 0) return x;\n  if(x == W) return W + y;\n  if(y == H) return W + H + W-x;\n  return W+H+W+H-y;\n}\nint projc(int x, int y, int dir){\n  switch(dir){\n  case 0:\n\treturn idx(x-min(x,y),y-min(x,y));\n  case 1:\n\treturn idx(x+min(W-x,y),y-min(W-x,y));\n  case 2:\n\treturn idx(x+min(W-x,H-y),y+min(W-x,H-y));\n  case 3:\n\treturn idx(x-min(x,H-y),y+min(x,H-y));\n  }\n  return -1;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> N >> W >> H;\n  sz = 2*(W+H); \n  vector<PII> xs(N);\n  REP(i,N){\n\tchar f;\n\tint x, y; cin >> x >> y >> f;\n\tPII p;\n\tint ix = string(\"SENW\").find(f);\n\tp.FF = projc(x,y,ix);\n\tp.SS = projc(x,y,(ix+1)%4);\n\tif(p.SS < p.FF) p.SS += sz;\n\txs[i] = p;\n  }\n\n  int ans = N;\n  REP(i,N) xs.EB(xs[i].FF+sz, xs[i].SS+sz);\n  SORT(xs);\n\n  for(int i=0;i<N;++i){\n\tint sum = 0;\n\tint e = -1;\n\tfor(int j=i;j<SZ(xs)&&xs[j].FF<xs[i].FF+sz;++j){\n\t  if(xs[j].FF <= e){\n\t\te = min(e, xs[j].SS);\n\t  }\n\t  else{\n\t\t++sum;\n\t\te = xs[j].SS;\n\t  }\n\t}\n\tans = min(ans, sum);\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\tint n, w, d;\n\twhile(cin >> n >> w >> d){\n\t\tvector< pair<int, int> > base;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x, y; char f;\n\t\t\tcin >> x >> y >> f;\n\t\t\tint a, b;\n\t\t\tif(f == 'S'){\n\t\t\t\ta = x;\n\t\t\t\tb = y;\n\t\t\t} else if(f == 'E'){\n\t\t\t\ta = w+y;\n\t\t\t\tb = w-x;\n\t\t\t} else if(f == 'N') {\n\t\t\t\ta = w+d+w-x;\n\t\t\t\tb = d-y;\n\t\t\t} else if(f == 'W'){\n\t\t\t\ta = 2*w+d+d-y;\n\t\t\t\tb = x;\n\t\t\t}\n\t\t\tbase.push_back(make_pair(a-b, a+b));\n\t\t}\n\t\tint res = n;\n\t\tvector< pair<int, int> > vp(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint start = base[i].second;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tvp[j] = base[j];\n\t\t\t\tif(vp[j].second < start){\n\t\t\t\t\tvp[j].first += 2*(w+d);\n\t\t\t\t\tvp[j].second += 2*(w+d);\n\t\t\t\t} else if(start <= vp[j].second - 2*(w+d)){\n\t\t\t\t\tvp[j].first -= 2*(w+d);\n\t\t\t\t\tvp[j].second -= 2*(w+d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 1, pos = start;\n\t\t\tsort(vp.begin(),\n\t\t\t\t vp.end(),\n\t\t\t\t [](const pair<int, int>& a, const pair<int, int>& b){\n\t\t\t\t\treturn a.second == b.second ? a.first < b.first : a.second < b.second;\n\t\t\t\t });\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(vp[j].first > pos){\n\t\t\t\t\t++cnt;\n\t\t\t\t\tpos = vp[j].second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = min(res, cnt);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define eb emplace_back\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n\nconst int INF = 1e9;\n\n\nint main(){\n\tint ans = INF;\n\tint n, w, d;\n\tvector<pair<int,pii> > vr;\n\n\tcin >> n >> w >> d;\n\tint N = 2*(w+d);\n\trep(i,n){\n\t\tint x, y;\n\t\tchar f;\n\t\tcin >> x >> y >> f;\n\t\tint l, r;\n\t\tif( f == 'W' ){\n\t\t\tl = 2*w + d - x + y;\n\t\t\tr = N + x - d + y;\n\t\t}\n\t\tif( f == 'E' ){\n\t\t\tl = x + d - y;\n\t\t\tr = 2*w + d - x - y;\n\t\t}\n\t\tif( f == 'N' ){\n\t\t\tl = 2*w + d + y + x;\n\t\t\tr = N + d - y + x;\n\t\t}\n\t\tif( f == 'S' ){\n\t\t\tl = 2*w + d - y - x;\n\t\t\tr = 2*w + d + y - x;\n\t\t}\n\t\tfor(;r<5*N; r+=N, l+=N){\n\t\t\tvr.eb( r, pii(i, l) );\n\t\t}\n\t}\n\tsort( all(vr) );\n\n\tint start=N;\n\trep(i,n){\n\t\tint cl = 0;\n\t\tauto cur = vr.begin();\n\t\twhile( cur->X < start ) cur++;\n\t\tstart = max(start+1, cur->X);\n\t\tint cnt = 0, sum = 0;\n\t\tbool f[1005] = {};\n\t\tfor(;cnt < n; cur++){\n\t\t\tint r  = cur->X;\n\t\t\tint id = cur->Y.X;\n\t\t\tint l  = cur->Y.Y;\n\t\t\tif( f[id] ) continue;\n\t\t\tif( cl < l ){\n\t\t\t\tcl = r;\n\t\t\t\tsum++;\n\t\t\t}\n\t\t\tf[id] = true;\n\t\t\tcnt++;\n\t\t}\n\t\tans = min(ans, sum);\n\t}\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong long H, W, N, L[100009], R[100009]; vector<long long>D;\n\nlong long solve(vector<pair<long long, long long>>V) {\n\tlong long cnt = 0, res = 0, pos = 0;\n\n\twhile (pos < V.size()) {\n\t\twhile (pos < V.size() && V[pos].first <= res) {\n\t\t\tres = min(res, V[pos].second); pos++;\n\t\t}\n\t\tcnt++; res = (1 << 30);\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tcin >> N >> W >> H;\n\tfor (int i = 0; i < N; i++) {\n\t\tint px, py; char c;\n\t\tcin >> px >> py >> c;\n\n\t\tif (c == 'N') {\n\t\t\tlong long BASE = px;\n\t\t\tL[i] = BASE - (H - py); R[i] = BASE + (H - py);\n\t\t}\n\t\tif (c == 'E') {\n\t\t\tlong long BASE = W + (H - py);\n\t\t\tL[i] = BASE - (W - px); R[i] = BASE + (W - px);\n\t\t}\n\t\tif (c == 'S') {\n\t\t\tlong long BASE = W + H + (W - px);\n\t\t\tL[i] = BASE - py; R[i] = BASE + py;\n\t\t}\n\t\tif (c == 'W') {\n\t\t\tlong long BASE = W + H + W + py;\n\t\t\tL[i] = BASE - px; R[i] = BASE + px;\n\t\t}\n\t\tL[i] += ((W + H) * 2); L[i] %= ((W + H) * 2);\n\t\tR[i] += ((W + H) * 2); R[i] %= ((W + H) * 2);\n\t\tD.push_back(L[i]);\n\t\tD.push_back(R[i]);\n\t}\n\tsort(D.begin(), D.end());\n\tD.erase(unique(D.begin(), D.end()), D.end());\n\n\tlong long LENG = (H + W) * 2;\n\tlong long ans = (1 << 30);\n\n\tfor (int i = 0; i < D.size(); i++) {\n\t\tvector<pair<long long, long long>>vec;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tlong long GL = (L[j] - D[i] + LENG) % LENG;\n\t\t\tlong long GR = (R[j] - D[i] + LENG) % LENG;\n\t\t\tif (GL > GR) GL = 0;\n\t\t\tvec.push_back(make_pair(GL, GR));\n\t\t}\n\t\tsort(vec.begin(), vec.end());\n\t\tlong long rem = solve(vec);\n\t\tans = min(ans, rem);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii=pair<int,int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define l first\n#define r second\n\nint main(){\n\tint n,w,h,p;\n\tcin>>n>>w>>h;\n\tp=w*2+h*2;\n\tdeque<pii> rng(n);\n\trep(i,n){\n\t\tint x,y,v; char c;\n\t\tcin>>x>>y>>c;\n\t\trng[i].l=[=]{return (int[]){x-h+y,x+h-y,w*2+h+y-x,w*2+h-y-x}[\"NEWS\"s.find(c)];}();\n\t\trng[i].r=[=]{return (int[]){x+h-y,w*2+h-y-x,w*2+h+y+x,w*2+h+y-x}[\"NEWS\"s.find(c)];}();\n\t}\n\tsort(all(rng),[](pii a,pii b){return a.r<b.r;});\n\t//for(auto i:rng)cout<<i.l<<\",\"<<i.r<<endl;\n\t\n\tint ans=1e8;\n\trep(i,n) {\n\t\tfor(auto j:{rng[0].l,rng[0].r}){\n\t\t\tint a=1,b=j;\n\t\t\t//cout<<i<<\":\"<<b<<\"=====\"<<endl;\n\t\t\trep(k,n){\n\t\t\t\twhile(k<n and rng[k].l<=b) k++;\n\t\t\t\tif(k==n) break;\n\t\t\t\ta++;\n\t\t\t\tb=rng[k].r;\n\t\t\t\t//cout<<k<<\":\"<<b<<endl;;\n\t\t\t}\n\t\t\tans=min(ans,a);\n\t\t}\n\t\trng.emplace_back(rng[0].l+p,rng[0].r+p);\n\t\trng.pop_front();\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\tint n, w, d;\n\twhile(cin >> n >> w >> d){\n\t\tvector< pair<int, int> > base;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x, y; char f;\n\t\t\tcin >> x >> y >> f;\n\t\t\tint a, b;\n\t\t\tif(f == 'S'){\n\t\t\t\ta = x;\n\t\t\t\tb = y;\n\t\t\t} else if(f == 'E'){\n\t\t\t\ta = w+y;\n\t\t\t\tb = w-x;\n\t\t\t} else if(f == 'N') {\n\t\t\t\ta = w+d+w-x;\n\t\t\t\tb = d-y;\n\t\t\t} else if(f == 'W'){\n\t\t\t\ta = 2*w+d+d-y;\n\t\t\t\tb = x;\n\t\t\t}\n\t\t\tbase.push_back(make_pair(a-b, a+b));\n\t\t}\n\t\tint res = n;\n\t\tvector< pair<int, int> > vp(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint start = base[i].second;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tvp[j] = base[j];\n\t\t\t\tif(vp[j].second < start){\n\t\t\t\t\tvp[j].first += 2*(w+d);\n\t\t\t\t\tvp[j].second += 2*(w+d);\n\t\t\t\t} else if(vp[j].first - 2*(w+d) <= start && start <= vp[j].second - 2*(w+d)){\n\t\t\t\t\tvp[j].first -= 2*(w+d);\n\t\t\t\t\tvp[j].second -= 2*(w+d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 1, pos = start;\n\t\t\tsort(vp.begin(),\n\t\t\t\t vp.end(),\n\t\t\t\t [](const pair<int, int>& a, const pair<int, int>& b){\n\t\t\t\t\treturn a.second == b.second ? a.first < b.first : a.second < b.second;\n\t\t\t\t });\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(vp[j].first > pos){\n\t\t\t\t\t++cnt;\n\t\t\t\t\tpos = vp[j].second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = min(res, cnt);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct data{\n\tint l,r;\n\tdata(){}\n\tdata(int ll,int rr){\n\t\tl=ll;\n\t\tr=rr;\n\t}\n\tbool operator<(const data &d)const{\n\t\treturn r<d.r;\n\t}\n};\n\nint n,w,d;\nstring dir=\"NWSE\";\nvector<data> query;\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&w,&d);\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tchar c;\n\t\tscanf(\"%d%d%*c%c\",&x,&y,&c);\n\t\tif(c=='N'){\n\t\t\tint ll=x-(d-y);\n\t\t\tint rr=x+(d+y);\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\t//query.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t\tif(c=='E'){\n\t\t\tint ll=w+d-y-(w-x);\n\t\t\tint rr=w+d-y+(w-x);\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\t//query.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t\tif(c=='S'){\n\t\t\tint ll=w+d+(w-x)-y;\n\t\t\tint rr=w+d+(w-x)+y;\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\t//query.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t\tif(c=='W'){\n\t\t\tint ll=w+d+w+y-x;\n\t\t\tint rr=w+d+w+y+x;\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\t//query.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t}\n\tsort(query.begin(),query.end());\n\tint res=n;\n\tfor(int i=0;i<n;i++){\n\t\tint tmp=1,last=query[i].r;\n\t\tfor(int j=1;j<n;j++){\n\t\t\tdata dd=query[(i+j)%n];\n\t\t\tif((i+j)%n<i)dd.l+=(w+d)*2,dd.r+=(w+d)*2;\n\t\t\tif(last<dd.l){\n\t\t\t\ttmp++;\n\t\t\t\tlast=dd.r;\n\t\t\t}\n\t\t}\n\t\tres=min(res,tmp);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ms(x,y) memset(x,y,sizeof(x))\nusing namespace std;\nint n,w,d,huan;\nconst int N=2005;\nstruct edge{\n\tint l,r;\n}e[N];\nint en;\nbool cmp(const edge &A,const edge& B){\n\treturn A.r<B.r;\n}\nbool exi[N];\n\n\nbool in(int i,int pos){\n\tif(e[i].l<=e[i].r){\n\t\tif(pos>=e[i].l && pos<=e[i].r)return true;\n\t}\n\telse if(pos>=e[i].l || pos<=e[i].r)return true;\n\treturn false;\n}\n\nint gao(int now,int pos){\n\tint ans=1;\n\tfor(int i=0;i<en;i++)\n\t\tif(in(i,pos))exi[i]=false;\n\tfor(int i=(now+1)%en,j;i!=now;) {\n\t\tif(exi[i]) {\n\t\t\texi[i]=false;\n\t\t\tans++;\n\t\t\tfor(j=(i+1)%en;j!=now;j=(j+1)%en)\n\t\t\t\tif((!exi[j]) || in(j,e[i].r)) exi[j]=false;\n\t\t\t\telse break;\n\t\t\ti=j;\n\t\t}\n\t\telse i++;\n\t}\n\treturn ans;\n}\n\n\nvoid add(int l,int r){\n\tif(l<0)l+=huan;\n\tif(r<0)r+=huan;\n\tif(l>=huan)l-=huan;\n\tif(r>=huan)r-=huan;\n\te[en].l=l;\n\te[en++].r=r;\n}\n\t\t\nint main(){\n\tcin>>n>>w>>d;\n\thuan=2*d+2*w;\n\tint x,y;\n\tchar ch;\n\ten=0;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d %d %c\",&x,&y,&ch);\n\t\tif(ch=='W')\n\t\t\tadd(y-x,y+x);\n\t\telse if (ch == 'N'){\n\t\t\ty=d-y;\n\t\t\tadd(x-y+d,x+y+d);\n\t\t}\n\t\telse if(ch == 'E'){\n\t\t\tx=w-x;y=d-y;\n\t\t\tadd(d+w+y-x,d+w+y+x);\n\t\t}\n\t\telse if(ch == 'S'){\n\t\t\tx=w-x;\n\t\t\tadd(d+w+d+x-y,d+w+d+x+y);\n\t\t}\n\t}\n\tsort(e,e+en,cmp);\n\tint ans=1000000;\n\tfor(int i=0;i<en;i++){\n\t\tms(exi,1);\n\t\tans=min(ans,gao(i,e[i].l));\n\t\tms(exi,1);\n\t\tans=min(ans,gao(i,e[i].r));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct range{\n\tint st, en;\n} pos[1000];\n\nint n, w, d;\nmap<int,vector<int> > m;\nmap<int,vector<int> >::iterator it;\nmap<int,int> nxt;\nvector<int> xx[2000];\nbool saw[1000];\n\nint main(){\n\tcin >> n >> w >> d;\n\trep(i,n){\n\t\tint x, y; char f;\n\t\tcin >> x >> y >> f;\n\t\ty = d-y;\n\t\tif(f == 'N'){\n\t\t\tif(w-x < y){\n\t\t\t\t//pos[i].st = P(w,y-w+x);\n\t\t\t\tpos[i].st = w+d*2-(y-w+x);\n\t\t\t} else{\n\t\t\t\t//pos[i].st = P(x+y,0);\n\t\t\t\tpos[i].st = w*2+d*2-(x+y);\n\t\t\t}\n\t\t\tif(x < y){\n\t\t\t\t//pos[i].en = P(0,y-x);\n\t\t\t\tpos[i].en = y-x;\n\t\t\t} else{\n\t\t\t\t//pos[i].en = P(x-y,0);\n\t\t\t\tpos[i].en = w*2+d*2-(x-y);\n\t\t\t}\n\t\t} else if(f == 'E'){\n\t\t\tif(w-x < d-y){\n\t\t\t\t//pos[i].st = P(w,y+w-x);\n\t\t\t\tpos[i].st = w+d*2-(y+w-x);\n\t\t\t} else{\n\t\t\t\t//pos[i].st = P(x+d-y,d);\n\t\t\t\tpos[i].st = d+x+d-y;\n\t\t\t}\n\t\t\tif(w-x < y){\n\t\t\t\t//pos[i].en = P(w,y-w+x);\n\t\t\t\tpos[i].en = w+d*2-(y-w+x);\n\t\t\t} else{\n\t\t\t\t//pos[i].en = P(x+y,0);\n\t\t\t\tpos[i].en = w*2+d*2-(x+y);\n\t\t\t}\n\t\t} else if(f == 'W'){\n\t\t\tif(x < y){\n\t\t\t\t//pos[i].en = P(0,y-x);\n\t\t\t\tpos[i].st = y-x;\n\t\t\t} else{\n\t\t\t\t//pos[i].en = P(x-y,0);\n\t\t\t\tpos[i].st = w*2+d*2-(x-y);\n\t\t\t}\n\t\t\tif(x < d-y){\n\t\t\t\t//pos[i].en = P(0,y+x);\n\t\t\t\tpos[i].en = y+x;\n\t\t\t} else{\n\t\t\t\t//pos[i].en = P(x+y-d,d);\n\t\t\t\tpos[i].en = d+x+y-d;\n\t\t\t}\n\t\t} else{\n\t\t\tif(x < d-y){\n\t\t\t\t//pos[i].en = P(0,y+x);\n\t\t\t\tpos[i].st = y+x;\n\t\t\t} else{\n\t\t\t\t//pos[i].en = P(x+y-d,d);\n\t\t\t\tpos[i].st = d+x+y-d;\n\t\t\t}\n\t\t\tif(w-x < d-y){\n\t\t\t\t//pos[i].st = P(w,y+w-x);\n\t\t\t\tpos[i].en = w+d*2-(y+w-x);\n\t\t\t} else{\n\t\t\t\t//pos[i].st = P(x+d-y,d);\n\t\t\t\tpos[i].en = d+x+d-y;\n\t\t\t}\n\t\t}\n\t\tcout << pos[i].st << \" \" << pos[i].en  << endl;\n\t\tm[pos[i].st].push_back(i);\n\t\tm[pos[i].en].push_back(i);\n\t}\n\tint cnt = 0;\n\tfor(it = m.begin(); it != m.end(); it++){\n\t\tvector<int> v = (*it).second;\n\t\txx[cnt] = v;\n\t\tnxt[(*it).first] = cnt;\n\t\tcnt++;\n\t}\n\tint ans = INF;\n\trep(i,cnt){\n\t\tint counter = 1;\n\t\trep(j,n) saw[j] = false;\n\t\trep(j,xx[i].size()){\n\t\t\tsaw[xx[i][j]] = true;\n\t\t}\n\t\tmap<int,int> tmp;\n\t\tfor(int j = i+1; j < cnt; j++){\n\t\t\trep(k,xx[j].size()){\n\t\t\t\tif(saw[xx[j][k]]) continue;\n\t\t\t\tif(nxt[pos[xx[j][k]].en] == j){\n\t\t\t\t\tif(tmp[xx[j][k]] == 1){\n\t\t\t\t\t\ttmp.clear();\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else{\n\t\t\t\t\ttmp[xx[j][k]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < i; j++){\n\t\t\trep(k,xx[j].size()){\n\t\t\t\tif(saw[xx[j][k]]) continue;\n\t\t\t\tif(nxt[pos[xx[j][k]].en] == j){\n\t\t\t\t\tif(tmp[xx[j][k]] == 1){\n\t\t\t\t\t\ttmp.clear();\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t}\n\t\t\t\t} else{\n\t\t\t\t\ttmp[xx[j][k]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = min(ans,counter);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\tint n, w, d;\n\twhile(cin >> n >> w >> d){\n\t\tvector< pair<int, int> > vp(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x, y; char f;\n\t\t\tcin >> x >> y >> f;\n\t\t\tint a, b;\n\t\t\tif(f == 'S'){\n\t\t\t\ta = x;\n\t\t\t\tb = y;\n\t\t\t} else if(f == 'E'){\n\t\t\t\ta = w+y;\n\t\t\t\tb = w-x;\n\t\t\t} else if(f == 'N') {\n\t\t\t\ta = w+d+w-x;\n\t\t\t\tb = d-y;\n\t\t\t} else if(f == 'W'){\n\t\t\t\ta = 2*w+d+d-y;\n\t\t\t\tb = x;\n\t\t\t}\n\t\t\tvp[i].first = (a-b+2*(w+d))%(2*(w+d));\n\t\t\tvp[i].second = (a+b)%(2*(w+d));\n\t\t}\n\t\tsort(vp.begin(),\n\t\t\t\tvp.end(),\n\t\t\t\t[](const pair<int, int>& a, const pair<int, int>& b){\n\t\t\t\t\treturn a.second == b.second ? a.first < b.first : a.second < b.second;\n\t\t\t\t}\n\t\t\t);\n\t\tint res = n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint cnt = 1, pos = vp[i].second;\n\t\t\tfor(int j=1;j<n;j++){\n\t\t\t\tpair<int, int> pr = vp[(i+j)%n];\n\t\t\t\tif(pr.first < pr.second ? (pr.first <= pos && pos <= pr.second) : (pos <= pr.second || pr.first <= pos)) continue;\n\t\t\t\tpos = pr.second;\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t\tres = min(res, cnt);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef pair<int,int> P;\nint N,W,H,L;\nvector<int> es;\nvector<P> vc,now;\nint mn[2010];\nint A;\nint inf=1e8;\nvoid solve(int e){\n//\tshow(e);\n\tnow.clear();\n\tfor(P p_:vc){\n\t\tP p=p_;\n\t\twhile(p.fs<e) p.fs+=L;\n\t\twhile(p.fs>p.sc) p.sc+=L;\n\t\tp.fs-=e,p.sc-=e;\n\t\tif(p.fs==0||(p.fs<=L&&L<=p.sc)) continue;\n\t\tnow.pb(p);\n\t}\n\tvector<int> ash;\n\tash.pb(0);\n\tfor(P p:now) ash.pb(p.fs),ash.pb(p.sc);\n\tsort(all(ash));\n\tash.erase(unique(all(ash)),ash.end());\n\tint M=ash.size();\n\tfor(P& p:now) p.fs=lower_bound(all(ash),p.fs)-ash.begin(),p.sc=lower_bound(all(ash),p.sc)-ash.begin();\n//\tshow(M);\n//\tfor(P p:now) cout<<p.fs<<\" \"<<p.sc<<endl;\n\trep(i,M+1) mn[i]=inf;\n\tfor(P p:now) chmin(mn[p.fs],p.sc);\n\tfor(int i=M-2;i>=0;i--) chmin(mn[i],mn[i+1]);\n\tint x=0,ans=0;\n\twhile(x<inf){\n\t\tx=mn[x+1];\n\t\tans++;\n\t}\n//\tshow(ans);\n\tchmin(A,ans);\n}\nint main(){\n\tcin>>N>>W>>H;\n\tL=2*(W+H);\n\trep(i,N){\n\t\tint x,y;\n\t\tchar c;\n\t\tcin>>x>>y>>c;\n\t\tint t[4]={x+y+H,y-x+2*W+H,-y-x+3*H+2*W,x-y+H};\n\t\trep(i,4) t[i]%=L;\n\t\tif(c=='E') vc.pb(P(t[0],t[1]));\n\t\tif(c=='N') vc.pb(P(t[1],t[2]));\n\t\tif(c=='W') vc.pb(P(t[2],t[3]));\n\t\tif(c=='S') vc.pb(P(t[3],t[0]));\n\t}\n\trep(i,N) es.pb(vc[i].fs),es.pb(vc[i].sc);\n//\trep(i,N) printf(\"(%d,%d)\\n\",vc[i].fs,vc[i].sc);\n\tA=inf;\n\tfor(int e:es) solve(e);\n//\tsolve(14);\n\tcout<<A<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nint n,w,d;\nint s[1010],g[1010];\n\ninline int convert(int x,int y){\n\tif(x==0) return y;\n\tif(y==d) return d+x;\n\tif(x==w) return d+w+(d-y);\n\tif(y==0) return d+w+d+(w-x);\n\treturn 0;\n}\n\nint greedy(int n,int start,int all){\n\tusing state=tuple<int,int>;\n\tvector<state> ary;\n\t\n\trep(i,n){\n\t\tbool add=true;\n\n\t\tif(s[i]<=g[i]){\n\t\t\tif(s[i]<=start && start <= g[i]) add=false;\n\t\t}else{\n\t\t\tif(start<=g[i]||s[i]<=start) add=false;\n\t\t}\n\n\t\tif(add){\n\t\t\tint cs=(s[i]-start+2*all)%all,cg=(g[i]-start+2*all)%all;\n\t\t\tary.push_back(make_tuple(cg,cs));\n\t\t}\n\t}\n\n\t\n\tsort(_all(ary));\t\n\tint res=1,cur=0;\n\t\n\tfor(auto &it:ary){\n\t\tif(cur<get<1>(it)) \n\t\t\tcur=get<0>(it),res++;\n\t}\n\n\treturn res;\n}\n\nint main(void){\n\tcin >> n >> w >> d;\n\trep(i,n){\n\t\tint x,y;\n\t\tchar w;\n\t\tcin >> x >> y >> w;\n\n\t\tconst int u=d-y,b=y,l=x,r=w-x;\n\n\t\tswitch(w){\n\t\t\tcase 'N':\n\t\t\t\ts[i]=(l<=u?convert(0,y+l):convert(x-u,d));\n\t\t\t\tg[i]=(r<=u?convert(w,y+r):convert(x+u,d));\n\t\t\t\tbreak;\n\n\t\t\tcase 'W':\n\t\t\t\ts[i]=(b<=l?convert(x-b,0):convert(0,y-l));\n\t\t\t\tg[i]=(u<=l?convert(x-u,d):convert(0,y+l));\n\t\t\t\tbreak;\n\n\t\t\tcase 'E':\n\t\t\t\ts[i]=(u<=r?convert(x+u,d):convert(w,y+r));\n\t\t\t\tg[i]=(b<=r?convert(x+b,0):convert(w,y-r));\n\t\t\t\tbreak;\n\n\t\t\tcase 'S':\n\t\t\t\ts[i]=(r<=b?convert(w,y-r):convert(x+b,0));\n\t\t\t\tg[i]=(l<=b?convert(0,y-l):convert(x-b,0));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tconst int all=2*(w+d);\n\n\tint ans=n;\n\n\trep(i,n){\n\t\tchmin(ans,greedy(n,s[i],all));\n\t\tchmin(ans,greedy(n,g[i],all));\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\n#define fst first\n#define snd second\n\nint n, w, h, len; \n\nint solve(vector<pair<double, double>> & lr){\n    int ret = n;\n    rep(i, n){\n        int cur = 1;\n        double rs = lr[i].snd;\n\n        range(_, 1, n){\n            int j = (j + _) % n;\n\n            double cl = lr[j].fst, cr = lr[j].snd;\n            if(cl >= cr){\n                if((cl - len <= rs and rs <= cr) or (cl <= rs and rs <= cr + len)){\n                    continue;\n                }\n            }\n            else {\n                if(cl <= rs and rs <= cr){\n                    continue;\n                }\n            }\n\n            cur++;\n            rs = cr;\n        }\n\n        ret = min(ret, cur);\n    }\n\n    return ret;\n}\n\nint main(void){\n    cin >> n >> w >> h;\n\n    vector<pair<double, double>> lr(n);\n    len = 2 * w + 2 * h;\n    for(auto & e : lr){\n        double x, y; cin >> x >> y;\n        char f; cin >> f;\n\n        int o, p;\n        switch(f){\n        case 'N': o = x; p = y; break;\n        case 'E': o = w + y; p = w - x; break;\n        case 'S': o = 2 * w + h - x; p = h - y; break;\n        case 'W': o = 2 * w + 2 * h - y; p = x; break;\n        }\n\n        e.fst = (o - p + len) % len;\n        e.snd = (o + p) % len;\n    }\n\n    sort(begin(lr), end(lr));\n    int res = solve(lr);\n\n    for(auto & e : lr){\n        swap(e.fst, e.snd);\n        e.fst = len - e.fst;\n        e.snd = len - e.snd;\n    }\n    sort(begin(lr), end(lr));\n    res = min(res, solve(lr));\n\n    cout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint main()\n{\n  int N, W, D;\n  cin >> N >> W >> D;\n\n  int L = D + D + W + W;\n  deque< pair< int, int > > range;\n  for(int i = 0; i < N; i++) {\n    int X, Y;\n    char F;\n    cin >> X >> Y >> F;\n    if(F == 'N') range.emplace_back(X + Y, D + X + D - Y);\n    if(F == 'E') range.emplace_back(D + X + D - Y, L - X - Y);\n    if(F == 'S') range.emplace_back(L - X - Y, L - X + Y);\n    if(F == 'W') range.emplace_back(L - X + Y, X + Y + L);\n  }\n  sort(begin(range), end(range));\n/*\n  for(auto& p : range) {\n    cout << p.first << \" \" << p.second << endl;\n  }\n  */\n  int ret = INF;\n  for(int i = 0; i < N; i++) {\n    int count = 0;\n    for(int j = 0; j < N;) {\n      int ps = range[j].second;\n      while(j < N && range[j].first <= ps) ++j;\n      ++count;\n    }\n    ret = min(ret, count);\n    range.front().first += L;\n    range.front().second += L;\n    range.push_back(range.front());\n    range.pop_front();\n  }\n  cout << ret << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint N, W, H;\nint sz;\nint idx(int x, int y){\n  if(y == 0) return x;\n  if(x == W) return W + y;\n  if(y == H) return W + H + W-x;\n  return W+H+W+H-y;\n}\nint projc(int x, int y, int dir){\n  switch(dir){\n  case 0:\n\treturn idx(x-min(x,y),y-min(x,y));\n  case 1:\n\treturn idx(x+min(W-x,y),y-min(W-x,y));\n  case 2:\n\treturn idx(x+min(W-x,H-y),y+min(W-x,H-y));\n  case 3:\n\treturn idx(x-min(x,H-y),y+min(x,H-y));\n  }\n  return -1;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> N >> W >> H;\n  sz = 2*(W+H); \n  vector<PII> xs(N);\n  REP(i,N){\n\tchar f;\n\tint x, y; cin >> x >> y >> f;\n\tPII p;\n\tint ix = string(\"SENW\").find(f);\n\tp.FF = projc(x,y,ix);\n\tp.SS = projc(x,y,(ix+1)%4);\n\tif(p.SS < p.FF) p.SS += sz;\n\txs[i] = p;\n  }\n\n  int ans = N;\n  REP(i,N) xs.EB(xs[i].FF+sz, xs[i].SS+sz);\n  SORT(xs);\n\n  for(int i=0;i<N;++i){\n\tint sum = 0;\n\tint e = -1;\n\tfor(int j=i;j<i+N;++j){\n\t  if(xs[j].FF <= e){\n\t\te = min(e, xs[j].SS);\n\t  }\n\t  else{\n\t\t++sum;\n\t\te = xs[j].SS;\n\t  }\n\t}\n\tans = min(ans, sum);\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> P;\ntypedef vector<P> VP;\nstruct UNKO{\n    LL pos;\n    char st;\n    int id;\n    bool operator<(const UNKO& r){\n        if(pos==r.pos)return st<r.st;\n        else return pos<r.pos;\n    }\n    UNKO(){\n        pos=0;st='-';id=-1;\n    }\n    UNKO(LL p,char s,int i){\n        pos=p;st=s;id=i;\n    }\n    void print(){\n        string s;\n        cout<<\"(\"<<pos<<\",\"<<st<<\",\"<<id<<\")\";\n    }\n};\nvoid input(VP& unko,vector<UNKO>& kuso,int N,int w,int d){\n    kuso.reserve(2*N);\n    for(int i = 0; i < N; i++){\n        LL x,y;\n        char dir;\n        cin>>x>>y>>dir;\n        LL Rx=(w-x),Ry=(d-y);\n        LL S,T;\n        switch(dir){\n            case 'W':\n                S=(x<=y)?(y-x):(d+w+d+Rx+y);\n                T=(x<=Ry)?(y+x):(d+x-Ry);\n                break;\n            case 'E':\n                S=(Rx<=Ry)?(d+w+Ry-Rx):(d+x+Ry);\n                T=(Rx<=y)?(d+w+Ry+Rx):(d+w+d+Rx-y);\n                break;\n            case 'N':\n                S=(x<=Ry)?(y+x):(d+x-Ry);\n                T=(Rx<=Ry)?(d+w+Ry-Rx):(d+x+Ry);\n                break;\n            case 'S':\n                S=(Rx<=y)?(d+w+Ry+Rx):(d+w+d+Rx-y);\n                T=(x<=y)?(y-x):(d+w+d+Rx+y);\n                break;\n        }\n        UNKO ss=UNKO(S,'S',i);\n        UNKO tt=UNKO(T,'T',i);\n//        ss.print();\n//        tt.print();\n        kuso.push_back(ss);\n        kuso.push_back(tt);\n\n    }\n    sort(kuso.begin(),kuso.end());\n    for(int i=0;i<2*N;i++){\n        int ii=kuso[i].id;\n        if(kuso[i].st=='S')unko[ii].first=i;\n        else unko[ii].second=i;\n    }\n}\nint INF =1001;\nint greedy(int bg,vector<UNKO> unko,VP& idl,int N){\n    //for(int i=0;i<2*N;i++)cout<<unko[i].st;cout<<endl;\n    //for(int i=0;i<2*N;i++)cout<<unko[i].id;cout<<endl;\n    N*=2;\n    stack<int> s;\n    int index=bg,res=1;\n    for(int i=0;i<N;i++){\n        if(unko[i].st=='S'){\n            int lid=i;\n            int rid=idl[unko[i].id].second;\n            LL lp=unko[lid].pos;\n            LL rp=unko[rid].pos;\n            if(lp<rp){\n                if(lp<=unko[bg].pos&&unko[bg].pos<=rp)\n                    unko[lid].st=unko[rid].st='-';\n            }\n            else{\n                if(lp<=unko[bg].pos||unko[bg].pos<=rp)\n                    unko[lid].st=unko[rid].st='-';\n            }\n        }\n    }\n    index=(index+1)%N;\n    while(index!=bg){\n        if(unko[index].st=='S')s.push(index);\n        if(unko[index].st=='T'){\n    //        cout<<unko[index].id;\n            res++;\n            while(s.empty()==false){\n                int id=s.top();s.pop();\n                unko[id].st='-';\n                id=idl[unko[id].id].second;\n                unko[id].st='-';\n            }\n        }\n        index=(index+1)%N;\n    }\n//    cout<<endl;\n    if(s.empty()==false)return INF;\n    else return res;\n}\n\n\nint main() {\n    int N,W,D;\n    cin>>N>>W>>D;\n    vector<UNKO> line;\n    VP index(N);\n    input(index,line,N,W,D);\n    int res=INF;\n    for(int i=0;i<2*N;i++){\n        if(line[i].st=='T')\n        res=min(res,greedy(i,line,index,N));\n\n    }\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n#define int long long\nconst int INF = (int)1e9;\nint N, W, D;\nvector<int> X, Y;\nvector<char> F;\nvector<pair<int, int>> getInterval() {\n  vector<pair<int, int>> ret;\n  REP(i,N) {\n    int left, right;\n    if(F[i] == 'N') {\n      left = 2*W + D + (D - Y[i]) + X[i];\n      right = W + Y[i] - (W - X[i]);\n    }\n    else if(F[i] == 'S') {\n      left = W + Y[i] + (W - X[i]);\n      right = 2*W + D + (D - Y[i]) - X[i];\n    }\n    else if(F[i] == 'E') {\n      left = W + Y[i] - (W - X[i]);\n      right = W + Y[i] + (W - X[i]);\n    }\n    else if(F[i] == 'W') {\n      left = 2*W + D + (D - Y[i]) - X[i];\n      right = 2*W + D + (D - Y[i]) + X[i];\n    }\n    else {\n      assert(false);\n    }\n    pair<int, int> ans;\n    ans.first = (left + 2*W + 2*D) % (2*W + 2*D);\n    ans.second = (right + 2*W + 2*D) % (2*W + 2*D);\n    ret.push_back(ans);\n  }\n  return ret;\n}\nstruct BIT {\n  int N;\n  vector<int> data;\n  BIT(int n) : N(n), data(n + 1, 0) {}\n  void add(int a, int w) {\n    ++a;\n    for(int x = a; x <= N; x += x & -x) {\n      data[x] += w;\n    }\n  }\n  int sum(int a) {\n    int ret = 0;\n    for(int x = a; x > 0; x -= x & -x) {\n      ret += data[x];\n    }\n    return ret;\n  }\n};\nbool compare(pair<int, int> left, pair<int, int> right) {\n  if(left.second != right.second) return left.second < right.second;\n  return left.first < right.first;\n}\nint compute(vector<pair<int, int>> &interval) {\n  // for(auto it : interval) {\n  //   cerr << \"(\" << it.first << \",\" << it.second << \")\" << endl;\n  // }\n  sort(interval.begin(), interval.end(), compare);\n  map<int, int> cmp;\n  for(auto it : interval) {\n    int v;\n    v = it.first;\n    if(!cmp.count(v)) cmp.insert(make_pair(v, cmp.size()));\n    v = it.second;\n    if(!cmp.count(v)) cmp.insert(make_pair(v, cmp.size()));\n    v = it.first + 2*W + 2*D;\n    if(!cmp.count(v)) cmp.insert(make_pair(v, cmp.size()));\n    v = it.second + 2*W + 2*D;\n    if(!cmp.count(v)) cmp.insert(make_pair(v, cmp.size()));\n  }\n  {\n    int n = 0;\n    for(auto &it : cmp) {\n      it.second = n++;\n    }\n  }\n  int c = 0;\n  BIT bit(cmp.size());\n  REP(i,N) {\n    if(bit.sum(cmp[interval[i].second] + 1) - bit.sum(cmp[interval[i].first]) == 0) {\n      ++c;\n      bit.add(cmp[interval[i].second], 1);\n      bit.add(cmp[interval[i].second + 2*W + 2*D], 1);\n    }\n  }\n  return c;\n}\nsigned main() {\n  cin >> N >> W >> D;\n  X.resize(N); Y.resize(N); F.resize(N);\n  REP(i,N) {\n    cin >> X[i] >> Y[i] >> F[i];\n    Y[i] = D - Y[i];\n  }\n  auto interval = getInterval();\n  // for(auto it : interval) {\n  //   cerr << \"(\" << it.first << \",\" << it.second << \")\" << endl;\n  // }\n  int ans = INF;\n  REP(i,N) {\n    vector<pair<int, int>> interval2;\n    int offset = interval[i].first;\n    REP(j,N) {\n      int left = interval[(i + j)%N].first - offset;\n      int right = interval[(i + j)%N].second - offset;\n      if(left < 0) left += 2*W + 2*D;\n      if(right < 0) right += 2*W + 2*D;\n      if(right < left) right += 2*W + 2*D;\n      interval2.emplace_back(left, right);\n    }\n    ans = min(ans, compute(interval2));\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-5L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this->data[i][0]) * (obj.data[0][q]);\n                for (int t = 1; t < obj.data[i].size(); ++t) {\n                    hoge += this->data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    u64 mod;\n    modint(ll a, ll b) : value(((a% b) + 2 * b) % b), mod(b) {\n\n    }\n    modint operator+(const modint rhs) const {\n        return modint(*this) += rhs;\n    }\n    modint operator-(const modint rhs) const {\n        return modint(*this) -= rhs;\n    }\n    modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    modint operator/(const modint rhs) const {\n        return modint(*this) /= rhs;\n    }\n    modint& operator+=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    modint& operator-=(const modint rhs) {\n        assert(rhs.mod == mod);\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    modint& operator*=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value = (value * rhs.value) % mod;\n        return *this;\n    }\n    modint& operator/=(modint rhs) {\n        assert(rhs.mod == mod);\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const {\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A, typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost) {\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n) {\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0 && level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s, int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n#define int ll\nint dx[4] = { 1,-1,-1,1 };\nint dy[4] = { 1,1,-1,-1 };\nvoid solve() {\n    int n, w, d;\n    cin >> n >> w >> d;\n    string check = \"NWSE\";\n    vector<pair<int, int>> gogo;\n    auto search = [w, d](int x, int y, int dir) {\n        while (x != 0 && x != w && y != 0 && y != d) {\n            x += dx[dir];\n            y += dy[dir];\n        }\n        if (y == 0) return x;\n        if (x == w) return w + y;\n        if (y == d) return d + w + (w - x);\n        return d + w + w + (d - y);\n    };\n    REP(i, n) {\n        int a, b;\n        cin >> a >> b;\n        string c;\n        cin >> c;\n        REP(q, check.size()) {\n            if (check[q] == c[0]) {\n                gogo.push_back(mp(search(a, b, q), search(a, b, (q + 1) % 4)));\n                break;\n            }\n        }\n    }\n    sort(ALL(gogo));\n    int ans = 1e9;\n    REP(i, gogo.size()) {\n        int tmp_cnt = 1;\n        priority_queue<int, vector<int>, greater<int>> next;\n        vector<pair<int, int>> next_go;\n        int target = gogo[i].second;\n        for (int q = i + 1; q < gogo.size(); ++q) {\n            pair<int, int> next = gogo[q];\n            if (gogo[q].first > gogo[q].second) {\n                next.second += 2 * (w + d);\n            }\n            if (gogo[q].first <= target && (gogo[q].first > gogo[q].second || target <= gogo[q].second)) continue;\n            next_go.push_back(next);\n        }\n        for (int q = 0; q < i; ++q) {\n            pair<int, int> next = gogo[q];\n            next.first += 2 * (w + d);\n            next.second += 2 * (w + d);\n            \n            if (next.first > next.second) {\n                next.second += 2 * (w + d);\n            }\n            if (gogo[q].first <= target && (gogo[q].first > gogo[q].second || target <= gogo[q].second)) continue;\n            next_go.push_back(next);\n        }\n        REP(q, next_go.size()) {\n            if (next.empty() == false && next.top() < next_go[q].first) {\n                while (next.empty() == false) next.pop();\n                tmp_cnt++;\n            }\n            next.push(next_go[q].second);\n        }\n        if (next.empty() == false) tmp_cnt++;\n        ans = min(ans, tmp_cnt);\n    }\n    cout << ans << endl;\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long LL;\nconst int N = 1005;\n\nint n , w , h;\npair<int , int> a[N] , b[N];\n\nint id(int x , int y) {\n    if (y == 0)\n        return x;\n    if (x == w)\n        return w + y;\n    if (y == h)\n        return w + h + w - x;\n    if (x == 0)\n        return w + h + w + h - y;\n    return -1;\n}\n\nint check(int x , int y , int dx , int dy) {\n    int xx , yy , X , Y;\n    if (dx == 1)\n        xx = w - x;\n    else\n        xx = x;\n    if (dy == 1)\n        yy = h - y;\n    else\n        yy = y;\n    int T = min(xx , yy);\n    X = x + dx * T;\n    Y = y + dy * T;\n    return id(X , Y);\n}\n \nvoid work() {    \n    scanf(\"%d%d%d\" , &n , &w , &h);\n    int L = 2 * (w + h);\n    vector<int> Q;\n    for (int i = 0 ; i < n ; ++ i) {\n        int x , y , l , r;\n        char dir[5];\n        scanf(\"%d%d%s\" , &x , &y , dir);\n        \n        if (*dir == 'E') {\n            l = check(x , y , 1 , -1);\n            r = check(x , y , 1 , 1);\n        }\n        if (*dir == 'N') {\n            l = check(x , y , 1 , 1);\n            r = check(x , y , -1 , 1);\n        }\n        if (*dir == 'W') {\n            l = check(x , y , -1 , 1);        \n            r = check(x , y , -1 , -1);            \n        }\n        if (*dir == 'S') {\n            l = check(x , y , -1 , -1);        \n            r = check(x , y , 1 , -1);            \n        }        \n        //if (l > r)\n        //    r += L;\n        //cout << l << ' ' << r << endl;\n        a[i] = make_pair(l , r);\n        Q.push_back(l);\n        Q.push_back(r);\n    }\n    sort(Q.begin(), Q.end());\n    Q.erase(unique(Q.begin(), Q.end()), Q.end());\n    // sort(a , a + n);\n    int m = 0;\n    int ans;\n    if (n == 0) ans = 0;\n    else ans = 1 << 30;\n    for (int c = 0; c < Q.size(); ++c) {\n        int t = Q[c];\n        vector<pair<int, int> > ver;\n        for (int i = 0; i < n; ++i) {\n            int l = a[i].first,  r = a[i].second;\n            if ((l <= t && r >= t && l <= r) || (l >= t && r >= t && l > r) ||\n                (l <= t && r <= t && l > r))\n                continue;\n            //if (t == 22) printf(\"%d %d\\n\", l, r);\n            l = l - t;\n            r = r - t;\n            if (l < 0) l += L;\n            if (r < 0) r += L;\n            ver.push_back(make_pair(l, -r)); \n        }\n        sort(ver.begin(), ver.end());\n        int p = 0;\n        for (int i = 0; i < ver.size(); ++i) {\n            ver[i].second = -ver[i].second;\n            while (p > 0 && ver[i].second <= ver[p - 1].second)\n                --p;\n            ver[p++] = ver[i];\n        }\n        int r = -1;\n        int res = 1;\n        for (int i = 0; i < p; ++i) {\n            if (ver[i].first > r) {\n                ++res;\n                r = ver[i].second;\n            }\n            else continue;\n        }\n        ans = min(ans, res);\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    work();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\nint dx[]={1,1,-1,-1};\nint dy[]={-1,1,1,-1};\nint Con(char c){\n  if(c=='S')return 3;\n  if(c=='E')return 0;\n  if(c=='N')return 1;\n  if(c=='W')return 2;\n}\nint x,y,X,Y,n,w,h,l,r,d,cnt,ans=1e7;\nchar c;\nmap<P,int>m;\nvoid init(){\n  r(i,w+1)m[P(0,i)]=cnt++;\n  r(i,h+1)m[P(i,w)]=cnt++;\n  r(i,w+1)m[P(h,w-i)]=cnt++;\n  r(i,h+1)m[P(h-i,0)]=cnt++;\n}\nsigned main(){\n  vector<P>v;\n  cin>>n>>w>>h;\n  init();\n  r(i,n){\n    cin>>X>>Y>>c;\n    d=Con(c);\n    x=X;y=Y;\n    while(0<x&&x<w&&0<y&&y<h){\n      x+=dx[d];\n      y+=dy[d];\n    }\n    l=m[P(y,x)];\n    x=X;y=Y;\n    while(0<x&&x<w&&0<y&&y<h){\n      x+=dx[(d+1)%4];\n      y+=dy[(d+1)%4];\n    }\n    r=m[P(y,x)];\n    v.push_back(P(r,l));\n  }\n  sort(v.begin(),v.end());\n  r(i,n){\n    int now=v[i].first,count=1;\n    for(int k=0,j=i;k<n;k++,j=(j+1)%n){\n      r=v[j].first;\n      l=v[j].second;\n      if(l>r){\n        if(!((l<=now&&now<=cnt)||(0<=now&&now<=r))){\n          now=r;\n          count++;\n        }\n      }\n      else{\n        if(!(l<=now&&now<=r)){\n          now=r;\n          count++;\n        }\n      }\n    }\n    ans=min(ans,count);\n  }\n  r(i,n)swap(v[i].first,v[i].second);\n  r(i,n){\n    v[i].first=cnt-v[i].first+1;\n    v[i].second=cnt-v[i].second+1;\n  }\n  sort(v.begin(),v.end());\n  r(i,n){\n    int now=v[i].first,count=1;\n    for(int k=0,j=i;k<n;k++,j=(j+1)%n){\n      r=v[j].first;\n      l=v[j].second;\n      if(l>r){\n        if(!((l<=now&&now<=cnt)||(0<=now&&now<=r))){\n          now=r;\n          count++;\n        }\n      }\n      else{\n        if(!(l<=now&&now<=r)){\n          now=r;\n          count++;\n        }\n      }\n    }\n    ans=min(ans,count);\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nint n, w, d;\nP v[1002];\n\n\nint main() {\n    cin >> n >> w >> d;\n    int l = 2 * d + 2 * w; \n\n    for (int i = 0; i < n; ++i) {\n        int x, y;\n        char f;\n        cin >> x >> y >> f;\n        int c, b;\n        switch (f) {\n            case 'N':\n                c = x;\n                b = d - y;\n            break;\n            case 'E':\n                c = d - y + w;\n                b = w - x;\n            break;\n            case 'S':\n                c = w - x + w + d;\n                b = y;\n            break;\n            case 'W':\n                c = y + 2 * w + d;\n                b = x;\n            break;\n        }\n        \n        // v[i] = (left end of view, right end of view)\n\n        v[i] = P ((c - b + l) % l, (c + b + l) % l);\n    } \n\n    // sort by the left end of view\n\n    sort(v, v + n);\n\n    int minc = 10000;\n    for (int i = 0; i < n; ++i) {\n        \n        // Put a clock at the left end of i-th member's view\n\n        int c = 1;\n        int tmp = v[i].first;\n        for (int j = 0; j < n - 1; ++ j) {\n            int k = (i - j + n) % n;\n\n            int left = v[k].first;\n            int right = v[k].second;\n            if (left > right) right += l;\n            if (left <= tmp && tmp <= right) continue;\n            if (left - l <= tmp && tmp <= right - l) continue;\n\n            c++;\n            tmp = left;\n        }\n        if (c < minc) minc = c;\n    }\n    cout << minc << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n// const long double PI = acos(-1);\nconstexpr int inf = 1e9;\nconstexpr ll INF = 2e18;\n// constexpr ll MOD = 1e9+7;\nconstexpr ll MOD = 998244353;\n\nint n,w,d;\nvector<pair<ll,ll>> v;\n\nvoid solve();\n\nvoid input() {\n    cin >> n >> w >> d;\n    for (int i = 0; i < n; i++) {\n        ll x,y;\n        char f;\n        cin >> x >> y >> f;\n        ll left,right,mid;\n        switch(f) {\n            case 'E':\n                mid = w + d - y;\n                left = mid - w + x;\n                right = mid + w - x;\n                break;\n            case 'S':\n                mid = w * 2 + d - x;\n                left = mid - y;\n                right = mid + y;\n                break;\n            case 'W':\n                mid = w * 2 + d + y;\n                left = mid - x;\n                right = mid + x;\n                break;\n            case 'N':\n                mid = x;\n                left = mid - d + y;\n                right = mid + d - y;\n                break;\n        }\n        if (right > 2 * (w + d)) {\n            left -= 2 * (w + d);\n            right -= 2 * (w + d);\n        }\n        v.push_back({right,left});\n        v.push_back({right + 2 * (w + d), left + 2 * (w + d)});\n    }\n    sort(v.begin(),v.end());\n    solve();\n\n}\n\nvoid solve() {\n    // for (int i = 0; i < v.size(); i++) {\n    //     cout << v[i].first << \" \" << v[i].second << endl;\n    // }\n    int ans = n;\n    for (int i = 0; i < n; i++) {\n        int cnt = 1;\n        int right = v[i].first;\n        for (int j = 1; j < n; j++) {\n            if (v[i + j].second > right) {\n                cnt++;\n                right = v[i + j].first;\n            }\n        }\n        ans = min(ans, cnt);\n    }\n    cout << ans << endl;\n}\n\nint main(int argc, char *argv[]) {\n    input();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cassert>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int MN = 1010;\nint n, ro;\nint l[MN], r[MN];\n\n\nint solve() {\n//\tcout << n << \" \" << ro << endl;\n//\tfor (int i = 0; i < n; i++) {\n//\t\tcout << l[i] << \" \" << r[i] << endl;\n//\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (r[i] < l[i]) r[i] += ro;\n\t}\n\tint mi = 100000;\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<P> v;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (l[j] <= l[i] && l[i] < r[j]) continue;\n\t\t\tif (l[j] <= l[i]+ro && l[i]+ro < r[j]) continue;\n\t\t\tif (l[i] < l[j]) {\n\t\t\t\tv.push_back(P(l[j], r[j]));\n\t\t\t} else {\n\t\t\t\tv.push_back(P(l[j]+ro, r[j]+ro));\n\t\t\t}\n\t\t}\n\n\t\tsort(v.begin(), v.end(), [&](const P &l, const P &r){\n\t\t\tif (l.second != r.second) return l.second < r.second;\n\t\t\treturn l.first < r.first;\n\t\t});\n\n\t\tint m = (int)v.size();\n\t\tint re = 1;\n\t\tint ba = l[i];\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (ba < v[j].first) {\n\t\t\t\tre++;\n\t\t\t\tba = v[j].second-1;\n\t\t\t}\n\t\t}\n//\t\tprintf(\"%d %d %d %d %d\\n\", i, m, re, v[0].first, v[0].second);\n\t\tmi = min(mi, re);\n\t}\n\treturn mi;\n}\n\nint main() {\n\tint w, h;\n\tcin >> n >> w >> h;\n\tro = 2*(h+w);\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y; char c;\n\t\tcin >> x >> y; cin >> c; y = h-y;\n\t\tint di[4];\n\t\tif (y + (w-x) < h) {\n\t\t\tdi[0] = w+y+(w-x);\n\t\t} else {\n\t\t\tdi[0] = w+h+w-(x+(h-y));\n\t\t}\n\n\t\tif (x - (h-y) > 0) {\n\t\t\tdi[1] = w+h+w-(x-(h-y));\n\t\t} else {\n\t\t\tdi[1] = w+h+w+h-(y+x);\n\t\t}\n\n\t\tif (y - x > 0) {\n\t\t\tdi[2] = w+h+w+h-(y-x);\n\t\t} else {\n\t\t\tdi[2] = x-y;\n\t\t}\n\n\t\tif (x + y < w) {\n\t\t\tdi[3] = x+y;\n\t\t} else {\n\t\t\tdi[3] = w+y-(w-x);\n\t\t}\n//\t\tcerr << di[0] << \" \" << di[1] << \" \" << di[2] << \" \" << di[3] << endl;\n\t\tswitch (c) {\n\t\tcase 'E':\n\t\t\tl[i] = di[3];\n\t\t\tr[i] = di[0];\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tl[i] = di[0];\n\t\t\tr[i] = di[1];\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\tl[i] = di[1];\n\t\t\tr[i] = di[2];\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tl[i] = di[2];\n\t\t\tr[i] = di[3];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t\tr[i]++;\n\t}\n\tcout << solve() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint w,d;\n\nstruct node\n{\n    int x,y;\n    int fangxiang=-1;\n    int l;\n    int r;\n}p[1010];\n\nbool cmp(node a,node b)\n{\n    if(a.l==b.l)\n    {\n        return a.r>=b.r;\n    }\n    else return a.l<b.l;\n}\nvoid cal1(int i)\n{\n   p[i].r=3*w+2*d-p[i].y-p[i].x;\n   p[i].l=w+2*d+p[i].x-p[i].y;\n   //printf(\"%d %d\\n\",p[i].l,p[i].r);\n}\n\nvoid cal2(int i)\n{\n   p[i].r=3*w+2*d+p[i].y-p[i].x;\n   p[i].l=3*w+2*d-p[i].x-p[i].y;\n   //printf(\"%d %d\\n\",p[i].l,p[i].r);\n}\n\nvoid cal3(int i)\n{\n   p[i].l=w+p[i].y-p[i].x;\n   p[i].r=w+p[i].y+p[i].x;\n   //printf(\"%d %d\\n\",p[i].l,p[i].r);\n}\n\nvoid cal4(int i)\n{\n   p[i].l=w+p[i].x+p[i].y;\n   p[i].r=w+2*d+p[i].x-p[i].y;\n   //printf(\"%d %d\\n\",p[i].l,p[i].r);\n}\n\nvoid Input(int i)\n{\n    char s[2];\n    scanf(\"%d%d\",&p[i].x,&p[i].y);\n    scanf(\"%s\",s);\n    if(s[0]=='E')\n    {\n        p[i].fangxiang=1;\n        cal1(i);\n    }\n    else if(s[0]=='S')\n    {\n        p[i].fangxiang=2;\n        cal2(i);\n    }\n    else if(s[0]=='W')\n    {\n        p[i].fangxiang=3;\n       cal3(i);\n    }\n    else if(s[0]=='N')\n    {\n        p[i].fangxiang=4;\n        cal4(i);\n    }\n    if(p[i].l>=2*w+2*d)\n    {\n        p[i].l=p[i].l-2*w-2*d;\n        p[i].r=p[i].r-2*w-2*d;\n    }\n    //printf(\"%d %d\\n\",p[i].l,p[i].r);\n    return;\n}\nint main()\n{\n    int n;\n    while(~scanf(\"%d\",&n))\n    {\n        memset(p,-1,sizeof(p));\n        scanf(\"%d%d\",&w,&d);\n        for(int i = 0; i < n; i++)\n        {\n            Input(i);\n        }\n        sort(p,p+n,cmp);\n        node b[1010];\n        b[0]=p[0];\n        int cnt1=0;int cnt2=0;\n        int flag=0,k=-1;\n        int i,j;\n        for(i = 1; i < n; i++)\n        {\n            if(p[i].l<=b[cnt2].r)\n            {\n                b[cnt2].l=p[i].l;\n                if(p[i].r<=b[cnt2].r)\n                    b[cnt2].r=p[i].r;\n            }\n\n            else\n                {\n                    b[++cnt2]=p[i];\n                    if(b[cnt2].r>=2*w+2*d&&flag==0)\n                    {\n                        k=cnt2;\n                        flag=1;\n                    }\n                }\n        }\n        for(i = k; i < cnt2+1; i++)\n        {\n            for(j = cnt1; j < cnt2+1; j++)\n            {\n                if(b[j].l>=b[i].l-2*w-2*d&&b[j].r<=b[i].r-2*w-2*d)\n                {\n                    b[i].l=b[j].l+2*w+2*d;\n                    b[i].r=b[j].r+2*w+2*d;\n                    cnt1++;\n                }\n            }\n        }\n        printf(\"%d\\n\",cnt2-cnt1+1);\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int w,h,n;\n  cin>>n>>w>>h;\n  int x,y,B=2*(w+h);\n  char c;\n  vector<P> m;\n  for(int i=0;i<n;i++){\n    cin>>x>>y>>c;\n    if(c=='S')m.push_back(P(x+y,(x-y+B)%B));\n    if(c=='E')m.push_back(P(w+y+(w-x),w+y-(w-x)));\n    if(c=='N')m.push_back(P(w+h+(w-x)+(h-y),w+h+(w-x)-(h-y)));\n    if(c=='W')m.push_back(P((w*2+h+(h-y)+x)%B,w*2+h+(h-y)-x));\n  }\n  sort(m.begin(),m.end());\n  int ans=n;\n  for(int i=0;i<n;i++){\n    int tp=0,p=m[i].second;\n    for(int j=0;j<n;j++){\n      int s=m[(i+j)%n].second,g=m[(i+j)%n].first;\n      if(s>g&&!(g<p&&p<s))continue;\n      if(s<g&&s<=p&&p<=g)continue;\n      tp++,p=g;\n    }\n    ans=min(tp,ans);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_start,int arg_end,int arg_id){\n\t\tstart = arg_start;\n\t\tend = arg_end;\n\t\tid = arg_id;\n\t}\n\n\tbool operator<(const struct Info &arg) const{\n\t\treturn end < arg.end;\n\t};\n\tint start,end,id;\n};\n\nstruct Data{\n\tData(int arg_start,int arg_end,int arg_id){\n\t\tstart = arg_start;\n\t\tend = arg_end;\n\t\tid = arg_id;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn start < arg.start;\n\t};\n\tint start,end,id;\n};\n\nint main(){\n\n\tint N,W,H;\n\n\tscanf(\"%d %d %d\",&N,&W,&H);\n\n\tint x,y,tmp_start,tmp_end;\n\tchar dir[2];\n\n\tvector<Info> V;\n\tvector<Data> D;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %s\",&x,&y,dir);\n\n\t\tswitch(dir[0]){\n\t\tcase 'N':\n\n\t\t\tif(W-x+y > H){\n\t\t\t\ttmp_start = W+H+(W-(H+x-y));\n\t\t\t}else{\n\t\t\t\ttmp_start = W+W-x+y;\n\t\t\t}\n\n\t\t\tif(x+y > H){\n\t\t\t\ttmp_end = W+H+(W-(x+y-H));\n\t\t\t}else{\n\t\t\t\ttmp_end = W+H+W+(H-(x+y));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'E':\n\n\t\t\tif(-W+x+y < 0){\n\t\t\t\ttmp_start = x+y;\n\t\t\t}else{\n\t\t\t\ttmp_start = W + (-W+x+y);\n\t\t\t}\n\n\t\t\tif(W-x+y > H){\n\t\t\t\ttmp_end = W+H+(W-(H+x-y));\n\t\t\t}else{\n\t\t\t\ttmp_end\t= W+W-x+y;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'W':\n\n\t\t\tif(x+y > H){\n\t\t\t\ttmp_start = W+H+(W-(x+y-H));\n\t\t\t}else{\n\t\t\t\ttmp_start = W+H+W+(H-(x+y));\n\t\t\t}\n\n\t\t\tif(-x+y < 0){\n\t\t\t\ttmp_end = x-y;\n\t\t\t}else{\n\t\t\t\ttmp_end = W+H+W+(H-(-x+y));\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 'S':\n\n\t\t\tif(-x+y < 0){\n\t\t\t\ttmp_start = x-y;\n\t\t\t}else{\n\t\t\t\ttmp_start = W+H+W+(H-(-x+y));\n\t\t\t}\n\n\t\t\tif(-W+x+y < 0){\n\t\t\t\ttmp_end = x+y;\n\t\t\t}else{\n\t\t\t\ttmp_end = W + (-W+x+y);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tV.push_back(Info(tmp_start,tmp_end,i));\n\t\tD.push_back(Data(tmp_start,tmp_end,i));\n\t}\n\n\tsort(V.begin(),V.end());\n\n\tint minimum = N,index;\n\n\tint clock_loc;\n\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tclock_loc = V[i].end;\n\t\tint tmp_count = 1;\n\n\t\tindex = (i+1)%N;\n\n\t\twhile(index != i){\n\n\t\t\twhile((index != i) && ((V[index].start <= clock_loc && V[index].end >= clock_loc) ||\n\t\t\t\t\t(V[index].start > V[index].end && (V[index].start <= clock_loc || V[index].end >= clock_loc)))){\n\t\t\t\tindex = (index+1)%N;\n\t\t\t}\n\t\t\tif(index != i){\n\t\t\t\ttmp_count++;\n\t\t\t\tclock_loc = V[index].end;\n\t\t\t\tindex = (index+1)%N;\n\t\t\t}\n\t\t}\n\n\t\tminimum = min(minimum,tmp_count);\n\t}\n\n\n\tsort(D.begin(),D.end());\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tclock_loc = D[i].start;\n\t\tint tmp_count = 1;\n\n\t\tindex = (i-1+N)%N;\n\n\t\twhile(index != i){\n\n\t\t\twhile((index != i) && ((D[index].start <= clock_loc && D[index].end >= clock_loc) ||\n\t\t\t\t\t(D[index].start > D[index].end && (D[index].start <= clock_loc || D[index].end >= clock_loc)))){\n\t\t\t\tindex = (index-1+N)%N;\n\t\t\t}\n\t\t\tif(index != i){\n\t\t\t\ttmp_count++;\n\t\t\t\tclock_loc = D[index].start;\n\t\t\t\tindex = (index-1+N)%N;\n\t\t\t}\n\t\t}\n\t\tminimum = min(minimum,tmp_count);\n\t}\n\tprintf(\"%d\\n\",minimum);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct Seg{\n\tint l, r;\n\tbool operator < (const Seg& x) const{\n\t\tif(l != x.l) return l < x.l;\n\t\treturn r > x.r;\n\t}\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tint H, W, N;\n\tcin >> N >> W >> H;\n\tdeque<Seg> deq;\n\tfor(int i = 0; i < N; i++){\n\t\tint x, y;\n\t\tchar c;\n\t\tcin >> x >> y >> c;\n\t\tint l, r;\n\t\tif(c == 'W') l = y - x, r = y + x;\n\t\tif(c == 'N') l = H + x - (H - y), r = H + x + (H - y);\n\t\tif(c == 'E') l = W + H + (H - y) - (W - x), r = W + H + (H - y) + (W - x);\n\t\tif(c == 'S') l = W + 2 * H + (W - x) - y, r = W + 2 * H + (W - x) + y;\n\t\tif(l < 0){\n\t\t\tl += 2 * (H + W);\n\t\t\tr += 2 * (H + W);\n\t\t}\n\t\tdeq.push_back({ l, r });\n\t}\n\tsort(deq.begin(), deq.end());\n\n\tint ans = 1e9;\n\tfor(int i = 0; i < N; i++){\n\t\tqueue<Seg> q;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tq.push(deq[i]);\n\t\t}\n\n\t\tint sum = 0;\n\t\twhile(q.size()){\n\t\t\tSeg s = q.front();\n\t\t\tq.pop();\n\t\t\tint l = s.l, r = s.r;\n\t\t\twhile(q.size()){\n\t\t\t\tint ll = q.front().l, rr = q.front().r;\n\t\t\t\tif(l <= ll && ll <= r){\n\t\t\t\t\tl = max(l, ll);\n\t\t\t\t\tr = min(r, rr);\n\t\t\t\t\tq.pop();\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tsum++;\n\t\t}\n\t\tans = min(ans, sum);\n\n\t\tSeg s = deq.front();\n\t\ts.l += 2 * (H + W), s.r += 2 * (H + W);\n\t\tdeq.pop_front();\n\t\tdeq.push_back(s);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nbool eq(const ld a, const ld b) {\n  return (abs(a - b) < eps);\n}\n\nld dot(const Point& a, const Point& b) {\n  return real(conj(a) * b);\n}\n\nld cross(const Point& a, const Point& b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line(Point a, Point b) : a(a), b(b) {}\n  Point operator[](const int _num)const {\n    if (_num == 0)return a;\n    else if (_num == 1)return b;\n    else {\n      assert(false);\n      return Point();\n    }\n  }\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle() : p(Point(0, 0)), r(0) {}\n  Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n  const Point nb(b - a);\n  const Point nc(c - a);\n  if (cross(nb, nc) > eps) return 1;   // a,b,c\n  if (cross(nb, nc) < -eps) return -1; // a,\n  if (dot(nb, nc) < 0) return 2;       //\n  if (norm(nb) < norm(nc)) return -2;  // \n  return 0;                          \n}\n\n\nbool isis_ll(const Line& l, const Line& m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(const Line& l, const Line& s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\nbool isis_ss(const Line& s, const Line& t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(const Line& l, const Point& p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(const Line& s, const Point& p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(const Line &l, const Point& p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(const Line &s, const Line& t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\nvector<Point> is_ll2(const Line &s, const Line& t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  if (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n  else {\n    vector<Point>ans;\n    for (int k = 0; k < 2; ++k) {\n      if (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n      if (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n    }\n    return ans;\n  }\n}\nPoint is_ss(const Line &s, const Line& t) {\n  if (isis_ss(s, t)) {\n    for (int k = 0; k < 2; ++k) {\n      for (int l = 0; l < 2; ++l) {\n        if (s[k] == t[l])return s[k];\n      }\n    }\n    return is_ll(s, t);\n  }\n  else {\n    assert(false);\n    return Point(0, 0);\n  }\n}\nld dist_lp(const Line& l, const Point& p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll(const Line& l, const Line& m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(const Line& l, const Line& s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(const Line& s, const Point& p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(const Line& s, const Line& t) {\n  if (isis_ss(s, t)) return 0;\n  return min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nLine bisection(const Line &s, const Line &t) {\n  const Point laglanju(is_ll(s, t));\n  const Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n  const Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n  return Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\nPoint  inner_center(const vector<Line>&ls) {\n  vector<Point>vertics;\n  for (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n    vertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n  }\n  if (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n  Line bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n  Line bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n  if (bi1[0] == bi2[0])return bi1[0];\n  else {\n    return is_ll(bi1, bi2);\n  }\n}\n\nvector<Point>  ex_center(const vector<Line>&ls) {\n  vector<Point>vertics;\n  for (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n    vertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n  }\n  if (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n  vector<Point>ecs;\n  for (int i = 0; i < 3; ++i) {\n    Line bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n    Line bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n    ecs.push_back(is_ll(bi1, bi2));\n  }\n  return ecs;\n}\n\n\nvector<Point>  same_dis(const vector<Line>&ls) {\n  vector<Point>vertics;\n  vertics.push_back(is_ll(ls[0], ls[2]));\n  vertics.push_back(is_ll(ls[1], ls[2]));\n\n  if (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n  Line bis(bisection(ls[0], ls[1]));\n  vector<Point>ecs;\n\n  Line abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n  ecs.push_back(is_ll(bis, abi));\n\n\n  Line bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n  ecs.push_back(is_ll(bis, bbi));\n\n  return ecs;\n}\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res; // no intersection\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nint is_in_circle(const Circle &cir, const  Point& p) {\n  ld dis = abs(cir.p - p);\n  if (dis > cir.r + eps)return 0;\n  else if (dis < cir.r - eps)return 2;\n  else return 1;\n}\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n  ld dis = abs(lc.p - rc.p);\n  if (dis < rc.r - lc.r - eps)return 2;\n  else if (dis>rc.r - lc.r + eps)return 0;\n  else return 1;\n}\n\nvector<Point> is_lc(const Circle& c, const Line& l) {\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps) {\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\nvector<Point> is_sc(const Circle& c, const Line& l) {\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d, c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0, 1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\nld two_circle_area(const Circle&l, const Circle&r) {\n  ld dis = abs(l.p - r.p);\n  if (dis > l.r + r.r)return 0;\n  else if (dis + r.r < l.r) {\n    return r.r*r.r*pi;\n  }\n  else if (dis + l.r < r.r) {\n    return l.r*l.r*pi;\n  }\n  else {\n    ld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n      (r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n      sqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n    return ans;\n  }\n\n}\n\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j, n) res += cross(p[j], p[(j + 1) % n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise(const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i, n) {\n    Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i, n) {\n    Point a = poly[i], b = poly[(i + 1) % n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n  const int n = P.size();\n  Point g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n  int a = 0, b = n;\n  while (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n    int c = (a + b) / 2;\n    if (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n      if (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n      else                                                  a = c;\n    }\n    else {\n      if (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n      else                                                  b = c;\n    }\n  }\n  b %= n;\n  if (cross(P[a] - p, P[b] - p) < 0) return 0;\n  if (cross(P[a] - p, P[b] - p) > 0) return 2;\n  return 1;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\n\n\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n  int n = ps.size();\n  Polygon Q;\n  Polygon R;\n  REP(i, n) {\n    Point A = ps[i], B = ps[(i + 1) % n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) != 1) R.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n      Q.push_back(is_ll(l, m));\n      R.push_back(is_ll(l, m));\n    }\n  }\n  const vector<Polygon>polys{ Q,R };\n  return polys;\n}\n\n\nvoid add_point(vector<Point> &ps, const Point p) {\n  for (Point q : ps) if (abs(q - p) < eps) return;\n  ps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n  g[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n  int n = p.size(), m = s.size();\n  Graph g(n);\n  REP(i, m) {\n    vector<pair<ld, int>> vec;\n    REP(j, n) if (isis_sp(s[i], p[j]))\n      vec.emplace_back(abs(s[i].a - p[j]), j);\n    sort(ALL(vec));\n    REP(j, vec.size() - 1) {\n      int from = vec[j].second, to = vec[j + 1].second;\n      add_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n    }\n  }\n  return g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n  vector<Point>crss;\n  for (int i = 0; i < static_cast<int>(s.size()); ++i) {\n    for (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n      if (isis_ss(s[i], s[j])) {\n        crss.push_back(is_ll(s[i], s[j]));\n      }\n    }\n  }\n  for (int i = 0; i <static_cast<int>(s.size()); ++i) {\n    crss.push_back(s[i][0]);\n    crss.push_back(s[i][1]);\n  }\n  return segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\nconst int dx0[4] = { -1,0,1,0 };\nconst int dy0[4] = { 0,1,0,-1 };\n\nconst int dx[4] = { -1,-1,1,1 };\nconst int dy[4] = { -1,1,1,-1 };\n\nint N, W, D;\n\nint getnum(int x, int y) {\n  if (x == 0) {\n    return y;\n  }\n  else if (y == D) {\n    return D + x;\n  }\n  else if (x == W) {\n    return 2 * D + W - y;\n  }\n  else {\n    assert(!y);\n    return 2 * D + 2 * W - x;\n  }\n}\nbool isorder(const int a, const int b, const int c) {\n  if (a < c) {\n    return a <= b&&b <= c;\n  }\n  else if (a>c) {\n    return a <= b || b <= c;\n  }\n  else\n  {\n    return true;\n  }\n}\nstruct Compress {\n  map<int, int>mp;\n  map<int, int>revmp;\n\n  Compress(vector<int>vs) {\n    sort(vs.begin(), vs.end());\n    vs.erase(unique(vs.begin(), vs.end()),vs.end());\n    for (int i = 0; i < vs.size(); ++i) {\n      mp[vs[i]] = i;\n      revmp[i] = vs[i];\n    }\n  }\n};\nmap<char, int>mp;\nint main() {\n  mp['W'] = 0;\n  mp['S'] = 1;\n  mp['E'] = 2;\n  mp['N'] = 3;\n  cin >> N >> W >> D;\n  \n  vector<Line> ls;\n  ls.push_back(Line(Point(0, 0), Point(0, D)));\n  ls.push_back(Line(Point(0, D), Point(W, D)));\n  ls.push_back(Line(Point(W, D), Point(W, 0)));\n  ls.push_back(Line(Point(W, 0), Point(0, 0)));\n  vector<pair<int, int>>ps;\n  for (int i = 0; i < N; ++i) {\n    int x, y; char f; cin >> x >> y >> f;\n    y = D - y;\n    Point p(x, y);\n    int num1, num2;\n    int betnum;\n    {\n      const int way = mp[f];\n      Line l(p, p + 1000000.l * Point(dx[way], dy[way]));\n      for (int i = 0; i < 4; ++i) {\n        if (isis_ss(l, ls[i])) {\n          Point sect(is_ll(l, ls[i]));\n          num1 = getnum(round(sect.real()), round(sect.imag()));\n          break;\n        }\n      }\n    }\n    {\n      const int way = (mp[f]+1)%4;\n      Line l(p, p + 1000000.l * Point(dx[way], dy[way]));\n      for (int i = 0; i < 4; ++i) {\n        if (isis_ss(l, ls[i])) {\n          Point sect(is_ll(l, ls[i]));\n          num2 = getnum(round(sect.real()), round(sect.imag()));\n          break;\n        }\n      }\n    }\n    {\n      const int way = mp[f];\n      Line l(p, p + 1000000.l * Point(dx0[way], dy0[way]));\n      for (int i = 0; i < 4; ++i) {\n        if (isis_ss(l, ls[i])) {\n          Point sect(is_ll(l, ls[i]));\n          betnum = getnum(round(sect.real()), round(sect.imag()));\n          break;\n        }\n      }\n    }\n    if (num1 < num2) {\n      if (num1 < betnum&&betnum < num2) {\n\n      }\n      else {\n        swap(num1, num2);\n      }\n    }\n    else {\n      if (num2 < betnum&&betnum < num1) {\n        swap(num1, num2);\n      }\n      else {\n      }\n    }\n    ps.emplace_back(num1, num2);\n  }\n  sort(ps.begin(), ps.end());\n  vector<int>v;\n  for (auto p : ps) {\n    v.emplace_back(p.first);\n    v.emplace_back(p.second);\n  }\n  Compress comp(v);\n  \n  for (auto&p : ps) {\n    p.first = comp.mp[p.first];\n    p.second = comp.mp[p.second];\n  }\n  {\n    bool a = is_sorted(ps.begin(), ps.end());\n    assert(a);\n  }\n  int _size = comp.mp.size();\n  int ans = 1e8;\n  for (int start = 0; start < ps.size(); ++start) {\n    int num = 1;\n    const int anum = ps[start].first;\n    queue<int>que;\n    int amin = 1e8;\n    for (int p = start; p < start + ps.size();++p) {\n      const int from = ps[p%N].first;\n      const int to = ps[p%N].second;\n      if (isorder(from, anum, to))continue;\n      const int realfrom = from < anum ? from + _size : from;\n      const int realto = to < anum ? to + _size : to;\n      amin = min(amin, realto);\n      if (amin < realfrom) {\n        amin = realto;\n        num++;\n      }\n    }\n    if (amin != 1e8)num++;\n    ans = min(ans, num);\n\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1005;\n\nint n;\nint w;\nint d;\nint len;\nint ln;\nint tln;\npair<int, int> pool[maxn << 1];\npair<int, int> seg[maxn];\npair<int, int> tmp[maxn << 1];\nbool ok[maxn];\n\nvoid input()\n{\n    cin >> w >> d;\n    len = 2 * (w + d);\n    tln = 0;\n    for (int i = 1; i <= n; i++) {\n        int x, y;\n        int U, D, L, R;\n        int st;\n        int ed;\n        char s[5];\n        cin >> x >> y >> s;\n        switch(s[0]) {\n        case 'N':\n            U = d - y;\n            L = x;\n            if (U == L) st = 0;\n            else if (U < L) st = x - U;\n            else st = len - (U - L);\n            ed = st + 2 * U;\n            break;\n        case 'S':\n            D = y;\n            R = w - x;\n            if (D == R) st = d + w;\n            else if (D < R) st = d + w + (R - D);\n            else st = d + w - (D - R);\n            ed = st + 2 * D;\n            break;\n        case 'W':\n            L = x;\n            D = y;\n            if (L == D) st = 2 * w + d;\n            else if (L < D) st = 2 * w + d + (D - L);\n            else st = 2 * w + d - (L - D);\n            ed = st + 2 * L;\n            break;\n        case 'E':\n            R = w - x;\n            U = d - y;\n            if (R == U) st = w;\n            else if (R > U) st = w - (R - U);\n            else st = w + (U - R);\n            ed = st + 2 * R;\n            break;\n        }\n        seg[i] = make_pair(st, ed);\n        tmp[++tln] = make_pair(st, -i);\n        tmp[++tln] = make_pair(ed, i);\n    }\n}\n\nint calc()\n{\n    int ans = 0;\n    bool vis[maxn];\n    stack<int> q;\n    memset(vis, 0, sizeof(vis));\n    while (q.size()) q.pop();\n    for (int i = 1; i <= ln; i++) {\n        if (vis[abs(pool[i].second)]) continue;\n        if (pool[i].second < 0) {\n            q.push(-pool[i].second);\n        } else {\n            ans ++;\n            while (q.size()) {\n                vis[q.top()] = true;\n                q.pop();\n            }\n        }\n    }\n    return ans;\n}\n\nvoid prepare()\n{\n    sort(tmp + 1, tmp + tln + 1);\n}\n\nvoid solve()\n{\n    int ans = 0x3f3f3f3f;\n    for (int i = 1; i <= n; i++) {\n        int x = seg[i].first;\n        ln = 0;\n        for (int j = 1; j <= n; j++) {\n            ok[j] = true;\n            if (seg[j].second <= len) {\n                if ((x <= seg[j].second && x >= seg[j].first) || (x == 0 && seg[j].second == len)) {\n                    ok[j] = false;\n                }\n            } else {\n                if (x >= seg[j].first || x <= seg[j].second % len) {\n                    ok[j] = false;\n                }\n            }\n        }\n        for (int j = 1; j <= tln; j++) {\n            if (ok[abs(tmp[j].second)]) {\n                pool[++ln] = tmp[j];\n            }\n        }\n        ans = min(ans, 1 + calc());\n        x = seg[i].second;\n        ln = 0;\n        for (int j = 1; j <= n; j++) {\n            ok[j] = true;\n            if (seg[j].second <= len) {\n                if ((x <= seg[j].second && x >= seg[j].first) || (x == 0 && seg[j].second == len)) {\n                    ok[j] = false;\n                }\n            } else {\n                if (x >= seg[j].first || x <= seg[j].second % len) {\n                    ok[j] = false;\n                }\n            }\n        }\n        for (int j = 1; j <= tln; j++) {\n            if (ok[abs(tmp[j].second)]) {\n                pool[++ln] = tmp[j];\n            }\n        }\n        ans = min(ans, 1 + calc());\n    }\n    cout << ans << endl;\n}\n\nint main()\n{\n    while (cin >> n) {\n        input();\n        prepare();\n        solve();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\n#define EPS (1e-9)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\nconst double PI=4*atan(1.0);\n\ntypedef complex<double> P;\n\n// ??????\ndouble dot(const P &a, const P &b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// ??????\ndouble cross(const P &a, const P &b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distance_ls_p(const P &a, const P &b, const P &c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nint is_intersected_ls(const P &a1, const P &a2, const P &b1, const P &b2) {\n  // ????????????????????´???\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    // ????????¨???????????¢???0??????????????£????????????\n    if(EQ(distance_ls_p(a1,a2,b1),0)||EQ(distance_ls_p(a1,a2,b2),0))\n      return 1;\n    return 0;\n  }\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n    ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nP intersection_ls(const P &a1, const P &a2, const P &b1, const P &b2) {\n  // ????????????????????´????????????????????£???????????????????????£???????????¨????????????\n  // ?????£??¨???x??§?¨?????°??????????????????????\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    // ????????¨???????????¢???0??????????????£????????????\n    if(EQ(distance_ls_p(a1,a2,b1),0)||EQ(distance_ls_p(a1,a2,b2),0)){\n      // x??§?¨????a1<a2,b1<b2??¨????????????????????????\n      P la1=a1,la2=a2;\n      P lb1=b1,lb2=b2;\n      if(a1.real()>a2.real())swap(la1,la2);\n      if(b1.real()>b2.real())swap(lb1,lb2);\n      P res;\n      if(la1.real()>lb1.real())res=la1;\n      else res=lb1;\n      return res;\n    }\n    // ????????£???????????´??????...?\n    else{\n      // ??????????±?????????????????????§?????????\n      // ????????¢??°?????????????????????????????????????????¨????????????\n      return P(-1,-1);\n    }\n  }\n  else{\n    P b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n  }\n}\n\n// ??§?¨?????????¢(??§?¨?p???????????????,???????¨??????????a(????????¢???)?????¢)\nP roundPoint(const P &p,double a){\n  return P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n\nbool used[1010];\ntypedef tuple<double,int,int> tpl;\n\n// place, start or end, idx???????????????\n\nint N,W,D;\nint XS[1001];\nint YS[1001];\nchar AS[1001];\nint main(){\n\n  cin>>N>>W>>D;\n  for(int i=0;i<N;i++)cin>>XS[i]>>YS[i]>>AS[i];\n  vector<pair<double, double> > poses;\n  // ???????£????????????????, ??§?¨????????????????????????????\n  for(int i=0;i<N;i++){\n    P ang_v;\n    // ????????§????????????????¨????????????????\n    if(AS[i]=='W')ang_v = P(-1, 0);\n    else if(AS[i]=='E')ang_v = P(1, 0);\n    else if(AS[i]=='N')ang_v = P(0, 1);\n    else if(AS[i]=='S')ang_v = P(0, -1);\n    ang_v *= 10000000;\n\n    // 2?????????????????????????¨????????????????\n    P ps[2] = {roundPoint(ang_v, PI/4) + P(XS[i], YS[i]), roundPoint(ang_v, -PI/4) + P(XS[i], YS[i])};\n    // ??????????????¶??????????????????????????????\n    const P corner[4] = {P(0,0), P(0,D), P(W,D), P(W,0)};\n    double ds[2];\n    for(int k=0;k<2;k++){\n        double sum_dist = 0;\n        double dist = 0;\n        for(int j = 0; j < 4; j++){\n            const P &p1 = corner[j];\n            const P &p2 = corner[(j+1)%4];\n            // p1-p2???????????¨ps[j]?????????????????????????????????\n            // cross????????????, ????????§?¨?????±???????\n            if(is_intersected_ls(p1, p2, ps[k], P(XS[i], YS[i]))){\n                // ??§?¨???¨,corner[j]??¨????????¢????¨??????????\n                P c = intersection_ls(p1, p2, ps[k], P(XS[i], YS[i]));\n                dist = sum_dist + abs(c-corner[j]);\n                break;\n            }\n            else{\n                sum_dist += abs(p2-p1);\n                continue;\n            }\n        }\n        // dist???2(D+W)?????£??????, 0????£???£????????????\n        if(EQ(2*(D+W), dist)){\n            dist = 0;\n        }\n        ds[k] = dist;\n    }\n    \n    if(ds[0] > ds[1])\n        ds[1] += 2*(W+D);\n\n    poses.push_back(make_pair(ds[0], ds[1]));\n  }\n\n  // vector???????????????2??????????????????\n  for(int i=0;i<N;i++){\n      // ??????????????????+2*(W+D)???????????????push_back\n      pair<double, double> pd = poses[i];\n      pd.first += 2*(W+D);\n      pd.second += 2*(W+D);\n      poses.push_back(pd);\n  }\n  \n  int min_ans = 1<<29;\n  // ?????¨?????£??????, ??????????§???°???????±???????, ????????????n?????????????????°????¨??????????\n  for(int start = 0; start < N; start++){\n      memset(used,0,sizeof(used));\n      vector<tuple<double, int, int> > vec;\n      for(int i=0;i<N;i++){\n          pair<double,double> t = poses[start + i];\n          vec.push_back(make_tuple(t.first, 0, i));\n          vec.push_back(make_tuple(t.second, 1, i));\n      }\n      // start??????????????????end????????£????????????????´???????????????????\n      queue<int> q;\n      // ?????¢??§?????????\n      sort(vec.begin(), vec.end());\n      \n      int vec_idx = 0;\n      int ans = 0;\n      // ???????????¢?????¨??????????????????????????????\n      while((int)vec.size() != vec_idx){\n          // ???????????¢??§????´??????????????????????\n          double d = get<0>(vec[vec_idx]);\n          vector<int> vs[2];\n          while((int)vec.size()!=vec_idx && EQ(get<0>(vec[vec_idx]), d)){\n              vs[get<1>(vec[vec_idx])].push_back(get<2>(vec[vec_idx]));\n              vec_idx++;\n          }\n          \n          // start???????´???????????????????\n          // start???????´????, queue????????????\n          for(int i=0;i<(int)vs[0].size();i++){\n              int idx = vs[0][i];\n              q.push(idx);\n          }\n          \n          // end???????´????, ?????§???????????????????????°continue\n          for(int i=0;i<(int)vs[1].size();i++){\n              int idx = vs[1][i];\n              if(used[idx])continue;\n              else{\n                  // ?????????????????£????????????????????§start???????´?????§£???????????????\n                  // ????????????end????§£?????????????????§??????????????????\n                  ans++;\n                  while(q.size()){\n                      const int a = q.front(); q.pop();\n                      used[a] = true;\n                  }\n                  break;\n              }\n          }\n      }\n      min_ans = min(min_ans, ans);\n  }\n\n  cout<<min_ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\n#define EPS (1e-8)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\nconst double PI=4*atan(1.0);\n\ntypedef complex<double> P;\n\n// ??????\ndouble dot(const P &a, const P &b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// ??????\ndouble cross(const P &a, const P &b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distance_ls_p(const P &a, const P &b, const P &c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nint is_intersected_ls(const P &a1, const P &a2, const P &b1, const P &b2) {\n  // ????????????????????´???\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    // ????????¨???????????¢???0??????????????£????????????\n    if(EQ(distance_ls_p(a1,a2,b1),0)||EQ(distance_ls_p(a1,a2,b2),0))\n      return 1;\n    return 0;\n  }\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n    ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nP intersection_ls(const P &a1, const P &a2, const P &b1, const P &b2) {\n  // ????????????????????´????????????????????£???????????????????????£???????????¨????????????\n  // ?????£??¨???x??§?¨?????°??????????????????????\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    // ????????¨???????????¢???0??????????????£????????????\n    if(EQ(distance_ls_p(a1,a2,b1),0)||EQ(distance_ls_p(a1,a2,b2),0)){\n      // x??§?¨????a1<a2,b1<b2??¨????????????????????????\n      P la1=a1,la2=a2;\n      P lb1=b1,lb2=b2;\n      if(a1.real()>a2.real())swap(la1,la2);\n      if(b1.real()>b2.real())swap(lb1,lb2);\n      P res;\n      if(la1.real()>lb1.real())res=la1;\n      else res=lb1;\n      return res;\n    }\n    // ????????£???????????´??????...?\n    else{\n      // ??????????±?????????????????????§?????????\n      // ????????¢??°?????????????????????????????????????????¨????????????\n      return P(-1,-1);\n    }\n  }\n  else{\n    P b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n  }\n}\n\n// ??§?¨?????????¢(??§?¨?p???????????????,???????¨??????????a(????????¢???)?????¢)\nP roundPoint(const P &p,double a){\n  return P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n\nbool used[1010];\ntypedef tuple<double,int,int> tpl;\n\n// place, start or end, idx???????????????\n\nint N,W,D;\nint XS[1001];\nint YS[1001];\nchar AS[1001];\nint main(){\n\n  cin>>N>>W>>D;\n  for(int i=0;i<N;i++)cin>>XS[i]>>YS[i]>>AS[i];\n  vector<pair<double, double> > poses;\n  // ???????£????????????????, ??§?¨????????????????????????????\n  for(int i=0;i<N;i++){\n    P ang_v;\n    // ????????§????????????????¨????????????????\n    if(AS[i]=='W')ang_v = P(-1, 0);\n    else if(AS[i]=='E')ang_v = P(1, 0);\n    else if(AS[i]=='N')ang_v = P(0, 1);\n    else if(AS[i]=='S')ang_v = P(0, -1);\n    ang_v *= 10000000;\n\n    // 2?????????????????????????¨????????????????\n    P ps[2] = {roundPoint(ang_v, PI/4) + P(XS[i], YS[i]), roundPoint(ang_v, -PI/4) + P(XS[i], YS[i])};\n    // ??????????????¶??????????????????????????????\n    const P corner[4] = {P(0,0), P(0,D), P(W,D), P(W,0)};\n    double ds[2];\n    for(int k=0;k<2;k++){\n        double sum_dist = 0;\n        double dist = 0;\n        for(int j = 0; j < 4; j++){\n            const P &p1 = corner[j];\n            const P &p2 = corner[(j+1)%4];\n            // p1-p2???????????¨ps[j]?????????????????????????????????\n            // cross????????????, ????????§?¨?????±???????\n            if(is_intersected_ls(p1, p2, ps[k], P(XS[i], YS[i]))){\n                // ??§?¨???¨,corner[j]??¨????????¢????¨??????????\n                P c = intersection_ls(p1, p2, ps[k], P(XS[i], YS[i]));\n                dist = sum_dist + abs(c-corner[j]);\n                break;\n            }\n            else{\n                sum_dist += abs(p2-p1);\n                continue;\n            }\n        }\n        // sum_dist???2(D+W)?????£??????, 0????£???£????????????\n        if(EQ(2*(D+W), dist)){\n            dist = 0;\n        }\n        ds[k] = dist;\n    }\n    \n    if(ds[0] > ds[1])\n        ds[1] += 2*(W+D);\n\n    poses.push_back(make_pair(ds[0], ds[1]));\n  }\n\n  // vector???????????????2??????????????????\n  for(int i=0;i<N;i++){\n      // ??????????????????+2*(W+D)???????????????push_back\n      pair<double, double> pd = poses[i];\n      pd.first += 2*(W+D);\n      pd.second += 2*(W+D);\n      poses.push_back(pd);\n  }\n  \n  int min_ans = 1<<29;\n  // ?????¨?????£??????, ??????????§???°???????±???????, ????????????n?????????????????°????¨??????????\n  for(int start = 0; start < N; start++){\n      memset(used,0,sizeof(used));\n      vector<tuple<double, int, int> > vec;\n      for(int i=0;i<N;i++){\n          pair<double,double> t = poses[start + i];\n          vec.push_back(make_tuple(t.first, 0, i));\n          vec.push_back(make_tuple(t.second, 1, i));\n      }\n      // start??????????????????end????????£????????????????´???????????????????\n      queue<int> q;\n      // ?????¢??§?????????\n      sort(vec.begin(), vec.end());\n      \n      int vec_idx = 0;\n      int ans = 0;\n      // ???????????¢?????¨??????????????????????????????\n      while((int)vec.size() != vec_idx){\n          // ???????????¢??§????´??????????????????????\n          double d = get<0>(vec[vec_idx]);\n          vector<int> vs[2];\n          while((int)vec.size()!=vec_idx && EQ(get<0>(vec[vec_idx]), d)){\n              vs[get<1>(vec[vec_idx])].push_back(get<2>(vec[vec_idx]));\n              vec_idx++;\n          }\n          // start???????´???????????????????\n          // start???????´????, queue????????????\n          for(int i=0;i<(int)vs[0].size();i++){\n              int idx = vs[0][i];\n              q.push(idx);\n          }\n          \n          // end???????´????, ?????§???????????????????????°continue\n          for(int i=0;i<(int)vs[1].size();i++){\n              int idx = vs[1][i];\n              if(used[idx])continue;\n              else{\n                  // ?????????????????£????????????????????§start???????´?????§£???????????????\n                  // ????????????end????§£?????????????????§??????????????????\n                  ans++;\n                  while(q.size()){\n                      const int a = q.front(); q.pop();\n                      used[a] = true;\n                  }\n                  break;\n              }\n          }\n      }\n      min_ans = min(min_ans, ans);\n  }\n\n  cout<<min_ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nint n,w,d;\nint s[1010],g[1010];\n\ninline int convert(int x,int y){\n\tif(x==0) return y;\n\tif(y==d) return d+x;\n\tif(x==w) return d+w+(d-y);\n\tif(y==0) return d+w+d+(w-x);\n\treturn 0;\n}\n\nint greedy(int n,int start,int all){\n\tusing state=tuple<int,int>;\n\tvector<state> ary;\n\t\n\trep(i,n){\n\t\tbool add=true;\n\n\t\tif(s[i]<=g[i]){\n\t\t\tif(s[i]<=start && start <= g[i]) add=false;\n\t\t}else{\n\t\t\tif(start<=g[i]||s[i]<=start) add=false;\n\t\t}\n\n\t\tif(add){\n\t\t\tint cs=(s[i]-start+2*all)%all,cg=(g[i]-start+2*all)%all;\n\t\t\tary.push_back(make_tuple(cg,cs));\n\t\t}\n\t}\n\n\t\n\tsort(_all(ary));\t\n\tint res=1,cur=0;\n\t\n\tfor(auto &it:ary){\n\t\tif(cur<get<1>(it)) \n\t\t\tcur=get<0>(it),res++;\n\t}\n\n\treturn res;\n}\n\nint main(void){\n\tcin >> n >> w >> d;\n\trep(i,n){\n\t\tint x,y;\n\t\tchar type;\n\t\tcin >> x >> y >> type;\n\n\t\tconst int u=d-y,b=y,l=x,r=w-x;\n\n\t\tswitch(type){\n\t\t\tcase 'N':\n\t\t\t\ts[i]=(l<=u?convert(0,y+l):convert(x-u,d));\n\t\t\t\tg[i]=(r<=u?convert(w,y+r):convert(x+u,d));\n\t\t\t\tbreak;\n\n\t\t\tcase 'W':\n\t\t\t\ts[i]=(b<=l?convert(x-b,0):convert(0,y-l));\n\t\t\t\tg[i]=(u<=l?convert(x-u,d):convert(0,y+l));\n\t\t\t\tbreak;\n\n\t\t\tcase 'E':\n\t\t\t\ts[i]=(u<=r?convert(x+u,d):convert(w,y+r));\n\t\t\t\tg[i]=(b<=r?convert(x+b,0):convert(w,y-r));\n\t\t\t\tbreak;\n\n\t\t\tcase 'S':\n\t\t\t\ts[i]=(r<=b?convert(w,y-r):convert(x+b,0));\n\t\t\t\tg[i]=(l<=b?convert(0,y-l):convert(x-b,0));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tconst int all=2*(w+d);\n\n\tint ans=n;\n\n\trep(i,n){\n\t\tchmin(ans,greedy(n,s[i],all));\n\t\tchmin(ans,greedy(n,g[i],all));\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <tuple>\n\nusing namespace std;\ntypedef pair<int, int> pii;\nstatic const int INF = 1000000000;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tvector<pii> ranges(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tint x, y;\n\t\tstring f;\n\t\tcin >> x >> y >> f;\n\t\tconst int hw2 = h + w + h + w;\n\t\tconst int lu = y + x;\n\t\tconst int ru = h + x + (h - y);\n\t\tconst int rd = h + w + (h - y) + (w - x);\n\t\tconst int ld = h + w + h + (w - x) + y;\n\t\tint lo = 0, hi = 0;\n\t\tif(f[0] == 'N'){\n\t\t\tlo = lu; hi = ru;\n\t\t}else if(f[0] == 'E'){\n\t\t\tlo = ru; hi = rd;\n\t\t}else if(f[0] == 'S'){\n\t\t\tlo = rd; hi = ld;\n\t\t}else if(f[0] == 'W'){\n\t\t\tlo = ld; hi = lu + hw2;\n\t\t}\n\t\tranges[i] = pii(lo, hi);\n\t}\n\tsort(\n\t\tranges.begin(), ranges.end(),\n\t\t[](const pii &a, const pii &b){\n\t\t\treturn (a.second == b.second) ? (a.first < b.first) : (a.second < b.second);\n\t\t});\n\tint answer = INF;\n\tfor(int i = 0; i < n; ++i){\n\t\tconst int hw2 = (h + w) * 2;\n\t\tvector<pii> r;\n\t\tfor(int j = i; j < n; ++j){ r.push_back(ranges[j]); }\n\t\tfor(int j = 0; j < i; ++j){\n\t\t\tr.emplace_back(ranges[j].first + hw2, ranges[j].second + hw2);\n\t\t}\n\t\tint count = 1, last = r[0].second;\n\t\tfor(int j = 0; j < n; ++j){\n\t\t\tif(r[j].first <= last){ continue; }\n\t\t\tif(r[j].second >= r[0].second + hw2){ continue; }\n\t\t\t++count;\n\t\t\tlast = r[j].second;\n\t\t}\n\t\tanswer = min(answer, count);\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\nint32_t H,W;\nint32_t N;\nstd::pair<int32_t, int32_t> pos[3000];\nint32_t solve(std::pair<int32_t, int32_t>* begin, std::pair<int32_t, int32_t>* end)\n{\n\tint32_t limit = (H + W + H + W) * 3;\n\tint32_t count = 0;\n\tfor (auto iter = begin; iter != end; iter++)\n\t{\n\t\tauto v = *iter;\n\t\tif (v.second < v.first) {\n\t\t\tv.second += H + W + H + W;\n\t\t}\n\n\t\tif (limit < v.first) {\n\t\t\t++count;\n\t\t\tlimit = v.second;\n\t\t}\n\t\telse {\n\t\t\tlimit = std::min(limit, v.second);\n\t\t}\n\t}\n\t++count;\n\treturn count;\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> N >> W>> H;\n\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tint32_t x, y;\n\t\tchar dir;\n\t\tin >> x >> y >> dir;\n\n\t\tauto get_lu = [&]() {\n\t\t\t//hで調整\n\t\t\tauto newx = x - (H - y);\n\t\t\tif (newx > 0) {\n\t\t\t\treturn H + W + H + W - newx;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//wで調整\n\t\t\t\tauto newy = H - (y + x);\n\t\t\t\treturn newy;\n\t\t\t}\n\t\t};\n\t\tauto get_ld = [&]() {\n\t\t\tauto newx = x - y;\n\t\t\treturn H + newx;\n\t\t};\n\t\tauto get_ru = [&]() {\n\t\t\tauto newx = x + (H - y);\n\t\t\treturn H + W + H + W - newx;\n\t\t};\n\t\tauto get_rd = [&]() {\n\t\t\treturn H + x + y;\n\t\t};\n\n\t\tif (dir == 'N') {\n\t\t\tpos[i].first = get_ru();\n\t\t\tpos[i].second = get_lu();\n\t\t}\n\t\telse if (dir == 'S') {\n\t\t\tpos[i].first = get_ld();\n\t\t\tpos[i].second = get_rd();\n\t\t}\n\t\telse if (dir == 'W') {\n\t\t\tpos[i].first = get_lu();\n\t\t\tpos[i].second = get_ld();\n\t\t}\n\t\telse if (dir == 'E') {\n\t\t\tpos[i].first = get_rd();\n\t\t\tpos[i].second = get_ru();\n\t\t}\n\t}\n\tauto begin = pos;\n\tauto end = pos + N;\n\tstd::sort(begin, end);\n\tint32_t res = (H + W + H + W) * 3;\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tres = std::min(res, solve(begin, end));\n\t\t*end = *begin;\n\t\tend->first += H + W + H + W;\n\t\tend->second += H + W + H + W;\n\t\t++begin; ++end;\n\t}\n\tout << res << endl;\n\treturn 0;\n}\n#endif\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nint n,w,d;\nint s[1010],g[1010];\n\ninline int convert(int x,int y){\n\tif(x==0) return y;\n\tif(y==d) return d+x;\n\tif(x==w) return d+w+(d-y);\n\tif(y==0) return d+w+d+(w-x);\n\treturn 0;\n}\n\nint greedy(int n,int start,int all){\n\tusing state=tuple<int,int>;\n\tvector<state> ary;\n\t\n\trep(i,n){\n\t\tbool add=true;\n\n\t\tif(s[i]<=g[i]){\n\t\t\tif(s[i]<=start && start <= g[i]) add=false;\n\t\t}else{\n\t\t\tif(start<=g[i]||s[i]<=start) add=false;\n\t\t}\n\n\t\tif(add){\n\t\t\tint cs=(s[i]-start+2*all)%all,cg=(g[i]-start+2*all)%all;\n\t\t\tary.push_back(make_tuple(cg,cs));\n\t\t}\n\t}\n\n\t\n\tsort(_all(ary));\t\n\tint res=1+!ary.empty(),cur=0;\n\t\n\tfor(auto &it:ary){\n\t\tif(cur<get<1>(it)) \n\t\t\tcur=get<0>(it),res++;\n\t}\n\n\treturn res;\n}\n\nint main(void){\n\tcin >> n >> w >> d;\n\trep(i,n){\n\t\tint x,y;\n\t\tchar w;\n\t\tcin >> x >> y >> w;\n\n\t\tconst int u=d-y,b=y,l=x,r=w-x;\n\n\t\tswitch(w){\n\t\t\tcase 'N':\n\t\t\t\ts[i]=(l<=u?convert(0,y+l):convert(x-u,d));\n\t\t\t\tg[i]=(r<=u?convert(w,y+r):convert(x+u,d));\n\t\t\t\tbreak;\n\n\t\t\tcase 'W':\n\t\t\t\ts[i]=(b<=l?convert(x-b,0):convert(w,y-l));\n\t\t\t\tg[i]=(u<=l?convert(x-u,d):convert(w,y+l));\n\t\t\t\tbreak;\n\n\t\t\tcase 'E':\n\t\t\t\ts[i]=(u<=r?convert(x+u,d):convert(w,y+r));\n\t\t\t\tg[i]=(b<=r?convert(x+b,0):convert(w,y-r));\n\t\t\t\tbreak;\n\n\t\t\tcase 'S':\n\t\t\t\ts[i]=(r<=b?convert(w,y-r):convert(x+b,0));\n\t\t\t\tg[i]=(l<=b?convert(0,y-l):convert(x-b,0));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tconst int all=2*(w+d);\n\n\tint ans=n;\n\n\trep(i,n){\n\t\tchmin(ans,greedy(n,s[i],all));\n\t\tchmin(ans,greedy(n,g[i],all));\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint N,W,H;\nvector<P> t;\n\nbool check(P p,int a){\n  if(p.first<p.second){\n    return (p.first<=a&&a<=p.second);\n  }else{\n    return (p.first<=a||a<=p.second);\n  }\n}\n\nint calcArg(int x,int y){\n  if(x==0)return y;\n  if(y==H)return H+x;\n  if(x==W)return H+W+H-y;\n  return H+W+H+W-x;\n}\n\nint calcLU(int x,int y){\n  int d=min(x,H-y);\n  return calcArg(x-d,y+d);\n}\n\nint calcRU(int x,int y){\n  int d=min(W-x,H-y);\n  return calcArg(x+d,y+d);\n}\n\nint calcRD(int x,int y){\n  int d=min(W-x,y);\n  return calcArg(x+d,y-d);\n}\n\nint calcLD(int x,int y){\n  int d=min(x,y);\n  return calcArg(x-d,y-d);\n}\n\nint solve(int si){\n  int res=1,last=t[si].second;\n  for(int i=si;i<si+N;i++){\n    if(check(t[i],last))continue;\n    res++;\n    last=t[i].second;\n  }\n  return res;\n}\n\nint main(){\n  cin>>N>>W>>H;\n  for(int i=0;i<N;i++){\n    int x,y;\n    char ch;\n    P p;\n    cin>>x>>y>>ch;\n    if(ch=='N'){\n      p.first=calcLU(x,y);\n      p.second=calcRU(x,y);\n    }else if(ch=='E'){\n      p.first=calcRU(x,y);\n      p.second=calcRD(x,y);\n    }else if(ch=='S'){\n      p.first=calcRD(x,y);\n      p.second=calcLD(x,y);\n    }else if(ch=='W'){\n      p.first=calcLD(x,y);\n      p.second=calcLU(x,y);\n    }\n    t.push_back(p);\n  }\n\n  for(int i=0;i<N;i++)swap(t[i].first,t[i].second);\n  sort(t.begin(),t.end());\n  for(int i=0;i<N;i++)t.push_back(t[i]);\n  for(int i=0;i<N+N;i++)swap(t[i].first,t[i].second);\n  int ans=1e9;\n  for(int i=0;i<N;i++)ans=min(ans,solve(i));\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c\n\tif (cross(nb, nc) < -eps) return -1; // a,\n\tif (dot(nb, nc) < 0) return 2;       //\n\tif (norm(nb) < norm(nc)) return -2;  // \n\treturn 0;                          \n}\n\n\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\nconst int dx0[4] = { -1,0,1,0 };\nconst int dy0[4] = { 0,1,0,-1 };\n\nconst int dx[4] = { -1,-1,1,1 };\nconst int dy[4] = { -1,1,1,-1 };\n\nint N, W, D;\n\nint getnum(int x, int y) {\n\tif (x == 0) {\n\t\treturn y;\n\t}\n\telse if (y == D) {\n\t\treturn D + x;\n\t}\n\telse if (x == W) {\n\t\treturn 2 * D + W - y;\n\t}\n\telse {\n\t\tassert(!y);\n\t\treturn 2 * D + 2 * W - x;\n\t}\n}\nbool isorder(const int a, const int b, const int c) {\n\tif (a < c) {\n\t\treturn a <= b&&b <= c;\n\t}\n\telse if (a>c) {\n\t\treturn a <= b || b <= c;\n\t}\n\telse\n\t{\n\t\treturn true;\n\t}\n}\nstruct Compress {\n\tmap<int, int>mp;\n\tmap<int, int>revmp;\n\n\tCompress(vector<int>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()),vs.end());\n\t\tfor (int i = 0; i < vs.size(); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n};\nmap<char, int>mp;\nint main() {\n\tmp['W'] = 0;\n\tmp['S'] = 1;\n\tmp['E'] = 2;\n\tmp['N'] = 3;\n\tcin >> N >> W >> D;\n\tif (W == 2 )assert(false);\n\t\n\tvector<Line> ls;\n\tls.push_back(Line(Point(0, 0), Point(0, D)));\n\tls.push_back(Line(Point(0, D), Point(W, D)));\n\tls.push_back(Line(Point(W, D), Point(W, 0)));\n\tls.push_back(Line(Point(W, 0), Point(0, 0)));\n\tvector<pair<int, int>>ps;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y; char f; cin >> x >> y >> f;\n\t\ty = D - y;\n\t\tPoint p(x, y);\n\t\tint num1, num2;\n\t\tint betnum;\n\t\t{\n\t\t\tconst int way = mp[f];\n\t\t\tLine l(p, p + 1000000.l * Point(dx[way], dy[way]));\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tif (isis_ss(l, ls[i])) {\n\t\t\t\t\tPoint sect(is_ll(l, ls[i]));\n\t\t\t\t\tnum1 = getnum(round(sect.real()), round(sect.imag()));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tconst int way = (mp[f]+1)%4;\n\t\t\tLine l(p, p + 1000000.l * Point(dx[way], dy[way]));\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tif (isis_ss(l, ls[i])) {\n\t\t\t\t\tPoint sect(is_ll(l, ls[i]));\n\t\t\t\t\tnum2 = getnum(round(sect.real()), round(sect.imag()));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tconst int way = mp[f];\n\t\t\tLine l(p, p + 1000000.l * Point(dx0[way], dy0[way]));\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tif (isis_ss(l, ls[i])) {\n\t\t\t\t\tPoint sect(is_ll(l, ls[i]));\n\t\t\t\t\tbetnum = getnum(round(sect.real()), round(sect.imag()));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (num1 < num2) {\n\t\t\tif (num1 < betnum&&betnum < num2) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tswap(num1, num2);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (num2 < betnum&&betnum < num1) {\n\t\t\t\tswap(num1, num2);\n\t\t\t}\n\t\t\telse {\n\t\t\t}\n\t\t}\n\t\tps.emplace_back(num1, num2);\n\t}\n\tsort(ps.begin(), ps.end());\n\tvector<int>v;\n\tfor (auto p : ps) {\n\t\tv.emplace_back(p.first);\n\t\tv.emplace_back(p.second);\n\t}\n\tCompress comp(v);\n\t\n\tfor (auto&p : ps) {\n\t\tp.first = comp.mp[p.first];\n\t\tp.second = comp.mp[p.second];\n\t}\n\t{\n\t\tbool a = is_sorted(ps.begin(), ps.end());\n\t\tassert(a);\n\t}\n\tint _size = comp.mp.size();\n\tint ans = 1e8;\n\tfor (int start = 0; start < ps.size(); ++start) {\n\t\tint num = 1;\n\t\tconst int anum = ps[start].first;\n\t\tqueue<int>que;\n\t\tint amin = 1e8;\n\t\tfor (int p = start; p < start + ps.size();++p) {\n\t\t\tconst int from = ps[p%N].first;\n\t\t\tconst int to = ps[p%N].second;\n\t\t\tif (isorder(from, anum, to))continue;\n\t\t\tconst int realfrom = from < anum ? from + _size : from;\n\t\t\tconst int realto = to < anum ? to + _size : to;\n\t\t\tamin = min(amin, realto);\n\t\t\tif (amin < realfrom) {\n\t\t\t\tamin = realto;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t\tif (amin != 1e8)num++;\n\t\tans = min(ans, num);\n\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//  aoj-VolumeICPCOOC2015-D  / 2015-11-30\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef ll int__;\n#define rep(i,j) for(int__ i=0;i<(int__)(j);i++)\n#define repeat(i,j,k) for(int__ i=(j);i<(int__)(k);i++)\n#define all(v) v.begin(),v.end()\nconst int INF = 1 << 30;\n//vector\ntemplate<typename T>ostream& operator << (ostream &os , const vector<T> &v){\n    rep(i,v.size()) os << v[i] << (i!=v.size()-1 ? \" \" : \"\\n\"); return os;\n}\ntemplate<typename T>istream& operator >> (istream &is , vector<T> &v){\n    rep(i,v.size()) is >> v[i]; return is;\n}\n//debug\n#ifdef DEBUG\nvoid debug(){ cerr << \"\\033[0m\" << endl; }\n#endif\ntemplate<class F,class...R> void debug(const F &car,const R&... cdr){\n#ifdef DEBUG\n    cerr << \"\\033[33m\" << car << \" \"; debug(cdr...);\n#endif\n}\n\nstruct Point{\n    int x,y;\n    Point():x(0),y(0){}\n    Point(int x,int y):x(x),y(y){};\n    Point& operator +=(const Point &p){x += p.x; y += p.y; return *this;}\n};\nostream &operator << (ostream& os, const Point& p){ return os << \"(\" << p.x << \",\" << p.y << \")\";}\n\nstruct ClosedRange{\n    int l,r; //[l,r]\n    ClosedRange(){}\n    ClosedRange(int l,int r):l(l),r(r){}\n    bool operator < (const ClosedRange &a) const { return make_pair(r,l) < make_pair(a.r, a.l); }\n};\nostream& operator << (ostream &os, const ClosedRange &r){ return os << \"[\" << r.l << \" \" << r.r << \"]\"; }\n\n\n// // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //\n\n\n// 2d to 1d\nint lower_dimension(Point p, int w, int d){\n    return  p.y == 0 ? p.x :\n            p.x == w ? w + p.y :\n            p.y == d ? w + d + (w - p.x) :\n            p.x == 0 ? w*2 + d + (d - p.y) : -1;\n}\n\nPoint find_cross_point(Point p, Point dp, int w, int d){\n    while(0 < p.x and p.x < w and 0 < p.y and p.y < d) p += dp;\n    return p;\n}\n\nClosedRange calc_range(Point p, char dir, int w, int d){\n    ClosedRange ret;\n    Point dp[] = {Point(-1, 1), Point(1, 1), Point(1, -1), Point(-1, -1)};\n    map<char, int> dtoi = {{'N', 0}, {'E', 1}, {'S', 2}, {'W', 3}};\n    Point dp1 = dp[ ( dtoi[ dir ] + 1 ) % 4 ];\n    Point dp2 = dp[ dtoi[ dir ] ];\n    Point l = find_cross_point(p, dp1, w, d);\n    Point r = find_cross_point(p, dp2, w, d);\n    return ClosedRange(lower_dimension(l, w, d), lower_dimension(r, w, d));\n}\n\nbool check_used(set<int> &clock, ClosedRange &r){\n    if(r.l <= r.r){\n        auto itr = clock.lower_bound(r.l);\n        return itr != clock.end() ? *itr <= r.r : false;\n    } else {\n        auto itr = clock.lower_bound(r.l);\n        auto itr2 = clock.upper_bound(r.r);\n        return  itr  != clock.end()   ? true :\n                itr2 != clock.begin() ? *--itr <= r.r : false;\n    }\n}\n\nint trial(vector<ClosedRange> &range, int start){\n    debug(\"start at \",start);\n    int n = range.size();\n    set<int> clock;\n    for(int i = start; i < start + n; i++){\n        if( check_used(clock,range[ i%n ]) ) continue;\n        clock.insert(range[ i%n ].r);\n        debug(\"clock at \",range[ i%n ].r);\n    }\n    return clock.size();\n}\n\nbool solve(){\n    int n, w, d; cin >> n >> w >> d;\n    vector<ClosedRange> range(n);\n    rep(i,n){\n        int x,y;\n        char f; cin >> x >> y >> f;\n        range[i] = calc_range(Point(x,y), f, w, d);\n        debug(range[i]);\n    }   \n    sort( all( range ) );\n    int ans = INF;\n    rep(i, n){\n        ans = min(ans, trial(range, i));\n    }\n    cout << ans << endl;\n    return false;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <cstdio>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long double ldb;\ntypedef complex<ldb> P;\n\nconst ldb eps = 1e-9;\nconst ldb pi = acos(-1);\nint sig(ldb a) {return (a<-eps)?-1:(a>eps)?1:0;}\nbool eq(ldb a,ldb b){return abs(a-b)<eps;}\nldb dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\nldb cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nldb ang(P a,P b,P c) {\n  P p = a-b;\n  P q = c-b;\n  if( eq(abs(p)*abs(q),0) ) return 0;\n  return acos(dot(p,q)/(abs(p)*abs(q)));\n}\n\nstruct L {\n  P a,b;\n  L(){}\n  L(P a,P b):a(a),b(b){}\n  ldb len(){return abs(a-b);}\n  P vec(){return b-a;}\n};\n\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\nint ccw(L s, P p) {\n  P a = s.vec();\n  p -= s.a;\n  ldb cr = cross(a, p);\n  if (eq(cr, 0)) {\n    if (sig(dot(a, p)) < 0) return BACK;\n    if (sig(norm(a) - norm(p)) < 0) return FRONT;\n    return ON;\n  }\n  return (cr > 0) ? LEFT : RIGHT;\n}\n\nP iP2(L a,L b) {\n  P c = b.b-b.a;\n  ldb d1 = abs(cross(c, a.a-b.a));\n  ldb d2 = abs(cross(c, a.b-b.a));\n  ldb t = d1 / (d1 + d2);\n  return a.a + (a.b-a.a) * t;\n}\n\nbool iI2_2(L a, L b) {\n  int cwa = ccw(a, b.a) | ccw(a, b.b);\n  int cwb = ccw(b, a.a) | ccw(b, a.b);\n  return ((cwa | cwb) & ON) || ((cwa & cwb) == (LEFT | RIGHT));\n}\n\nint n, w, d;\nint x[1111], y[1111];\nchar f[1111];\nP mid;\n\npair<int, int> tp(const P& p) {\n  return {p.real()+0.4, p.imag()+0.4};\n}\n\nint main(void) {\n  scanf(\"%d%d%d\", &n, &w, &d);\n\n  mid = P(w/2.0, d/2.0);\n  \n  for (int i = 0; i < n; i++) {\n    scanf(\"%d%d %c\", x+i, y+i, f+i);\n  }\n\n  vector<L> ls {\n    L(P(0, 0), P(w, 0)),\n        L(P(0, 0), P(0, d)),\n        L(P(w, 0), P(w, d)),\n        L(P(0, d), P(w, d)),\n  };\n  vector<P> p1, p2;\n  vector<tuple<ldb, ldb, int>> a;\n  vector<pair<int, int>> pos;\n  const int I = 1000000;\n\n  for (int i = 0; i < n; i++) {\n    L l1, l2;\n    P pos(x[i], y[i]);\n    if (f[i] == 'N') {\n      l1 = L(pos, P(x[i]+I, y[i]+I));\n      l2 = L(pos, P(x[i]-I, y[i]+I));\n    } else if (f[i] == 'W') {\n      l1 = L(pos, P(x[i]-I, y[i]+I));\n      l2 = L(pos, P(x[i]-I, y[i]-I));\n    } else if (f[i] == 'S') {\n      l1 = L(pos, P(x[i]-I, y[i]-I));\n      l2 = L(pos, P(x[i]+I, y[i]-I));\n    } else {\n      l1 = L(pos, P(x[i]+I, y[i]-I));\n      l2 = L(pos, P(x[i]+I, y[i]+I));\n    }\n    for (int i = 0; i < 4; i++) {\n      if (iI2_2(l1, ls[i])) {\n        p1.push_back(iP2(l1, ls[i]));\n        break;\n      }\n    }\n    for (int i = 0; i < 4; i++) {\n      if (iI2_2(l2, ls[i])) {\n        p2.push_back(iP2(l2, ls[i]));\n        break;\n      }\n    }\n  }\n\n  for (int i = 0; i < int(p1.size()); i++) {\n    pos.push_back(tp(p1[i]));\n    pos.push_back(tp(p2[i]));\n  }\n  sort(pos.begin(), pos.end());\n  pos.erase(unique(pos.begin(), pos.end()), pos.end());\n\n  vector<ldb> cl;\n  for (int i = 0; i < int(pos.size()); i++) {\n    cl.push_back(arg(mid-P(pos[i].first, pos[i].second))+pi);\n  }\n  sort(cl.begin(), cl.end());\n\n  /*\n  for (int i = 0; i < int(pos.size()); i++) {\n    printf(\"%d %d\\n\", pos[i].first, pos[i].second);\n  }\n  */\n\n  /*\n  for (int i = 0; i < int(cl.size()); i++) {\n    printf(\"%.10Lf\\n\", cl[i]/pi*180);\n  }\n  //*/\n\n  for (int i = 0; i < int(p1.size()); i++) {\n    ldb a1 = arg(mid-p1[i])+pi;\n    ldb a2 = arg(mid-p2[i])+pi;\n    if (a1 > a2) a2 += 2*pi;\n    a.emplace_back(a1, a2, i);\n  }\n  sort(a.begin(), a.end());\n\n  /*\n  for (int i = 0; i < int(a.size()); i++) {\n    printf(\"%20.10Lf %20.10Lf \", get<0>(a[i])/pi*180, get<1>(a[i])/pi*180);\n    printf(\"%d\\n\", get<2>(a[i]));\n  }\n  //*/\n\n  int res = 114514;\n  for (int i = 0; i < n; i++) {\n    int u[2222] {};\n    int b = 0;\n    for (int j = 0; j < int(cl.size()); j++) {\n      if ((sig(get<0>(a[i])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[i])) <= 0) ||\n          (sig(get<0>(a[i])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[i])) <= 0)) {\n        b = j;\n      }\n    }\n    // printf(\"%d\\n\", b);\n    int c = 0;\n    int j = b;\n    u[j] = 1;\n    int k = (i+1)%n;\n    while (k != i) {\n      // printf(\"%d %d\\n\", k, j);\n      while (k != i && ((sig(get<0>(a[k])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[k])) <= 0) ||\n              (sig(get<0>(a[k])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[k])) <= 0))) {\n        k = (k+1)%n;\n      }\n      if (k != i) {\n        while (!((sig(get<0>(a[k])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[k])) <= 0) ||\n                 (sig(get<0>(a[k])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[k])) <= 0))) {\n          j = (j+1)%cl.size();\n        }\n        int pj = j;\n        while (((sig(get<0>(a[k])-cl[j]) <= 0 && sig(cl[j]-get<1>(a[k])) <= 0) ||\n                 (sig(get<0>(a[k])-(cl[j]+pi*2)) <= 0 && sig((cl[j]+pi*2)-get<1>(a[k])) <= 0))) {\n          pj = j;\n          j = (j+1)%cl.size();\n        }\n        j = pj;\n        u[j] = 1;\n      }\n    }\n    //*\n    for (int p = 0; p < int(cl.size()); p++) {\n      c += u[p];\n      //printf(\"%d \", u[p]);\n    }\n    // puts(\"\");\n    //*/\n    res = min(res, c);\n  }  \n\n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tint n,X,Y;\n\tcin>>n>>X>>Y;\n\tvp in(n);\n\trep(i,n){\n\t\tint a,b;char d;\n\t\tpii c;\n\t\tcin>>a>>b>>d;\n\t\tif(d=='N')c={a,Y-b};\n\t\tif(d=='E')c={X+Y-b,X-a};\n\t\tif(d=='S')c={X+Y+X-a,b};\n\t\tif(d=='W')c={X+Y+X+b,a};\n\t\tint l=c.first-c.second,r=c.first+c.second;\n\t\tif(l<0)l+=X+X+Y+Y,r+=X+X+Y+Y;\n\t\tin[i]={r,l};\n\t}\n\tint out=inf;\n\tsort(all(in));\n//\trep(i,n)cout<<in[i].second<<\" \"<<in[i].first<<endl;\n\trep(i,n){\n\t\tint co=0;\n\t\tint mi=-1;\n\t//\trep(j,n)cout<<in[j].second<<\" \"<<in[j].first<<endl;\n\t\trep(j,n){\n\t\t\tif(mi<in[j].second){\n\t\t\t\tmi=in[j].first;\n\t\t\t\tco++;\n\t\t\t}\n//\t\t\tcout<<mi<<\" \"<<co<<endl;\n\t\t}\n\t\tout=min(out,co);\n\t\tin.pb({in[0].first+X+X+Y+Y,in[0].second+X+X+Y+Y});\n\t\tin.erase(in.begin());\n\t}\n\tcout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c\n\tif (cross(nb, nc) < -eps) return -1; // a,\n\tif (dot(nb, nc) < 0) return 2;       //\n\tif (norm(nb) < norm(nc)) return -2;  // \n\treturn 0;                          \n}\n\n\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\nconst int dx0[4] = { -1,0,1,0 };\nconst int dy0[4] = { 0,1,0,-1 };\n\nconst int dx[4] = { -1,-1,1,1 };\nconst int dy[4] = { -1,1,1,-1 };\n\nint N, W, D;\n\nint getnum(int x, int y) {\n\tif (x == 0) {\n\t\treturn y;\n\t}\n\telse if (y == D) {\n\t\treturn D + x;\n\t}\n\telse if (x == W) {\n\t\treturn 2 * D + W - y;\n\t}\n\telse {\n\t\tassert(!y);\n\t\treturn 2 * D + 2 * W - x;\n\t}\n}\nbool isorder(const int a, const int b, const int c) {\n\tif (a < c) {\n\t\treturn a <= b&&b <= c;\n\t}\n\telse if (a>c) {\n\t\treturn a <= b || b <= c;\n\t}\n\telse\n\t{\n\t\treturn true;\n\t}\n}\nstruct Compress {\n\tmap<int, int>mp;\n\tmap<int, int>revmp;\n\n\tCompress(vector<int>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()),vs.end());\n\t\tfor (int i = 0; i < vs.size(); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n};\nmap<char, int>mp;\nint main() {\n\tmp['W'] = 0;\n\tmp['S'] = 1;\n\tmp['E'] = 2;\n\tmp['N'] = 3;\n\tcin >> N >> W >> D;\n\tif (W == 2 && D == 2)assert(false);\n\t\n\tvector<Line> ls;\n\tls.push_back(Line(Point(0, 0), Point(0, D)));\n\tls.push_back(Line(Point(0, D), Point(W, D)));\n\tls.push_back(Line(Point(W, D), Point(W, 0)));\n\tls.push_back(Line(Point(W, 0), Point(0, 0)));\n\tvector<pair<int, int>>ps;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y; char f; cin >> x >> y >> f;\n\t\ty = D - y;\n\t\tPoint p(x, y);\n\t\tint num1, num2;\n\t\tint betnum;\n\t\t{\n\t\t\tconst int way = mp[f];\n\t\t\tLine l(p, p + 1000000.l * Point(dx[way], dy[way]));\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tif (isis_ss(l, ls[i])) {\n\t\t\t\t\tPoint sect(is_ll(l, ls[i]));\n\t\t\t\t\tnum1 = getnum(round(sect.real()), round(sect.imag()));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tconst int way = (mp[f]+1)%4;\n\t\t\tLine l(p, p + 1000000.l * Point(dx[way], dy[way]));\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tif (isis_ss(l, ls[i])) {\n\t\t\t\t\tPoint sect(is_ll(l, ls[i]));\n\t\t\t\t\tnum2 = getnum(round(sect.real()), round(sect.imag()));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tconst int way = mp[f];\n\t\t\tLine l(p, p + 1000000.l * Point(dx0[way], dy0[way]));\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tif (isis_ss(l, ls[i])) {\n\t\t\t\t\tPoint sect(is_ll(l, ls[i]));\n\t\t\t\t\tbetnum = getnum(round(sect.real()), round(sect.imag()));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (num1 < num2) {\n\t\t\tif (num1 < betnum&&betnum < num2) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tswap(num1, num2);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (num2 < betnum&&betnum < num1) {\n\t\t\t\tswap(num1, num2);\n\t\t\t}\n\t\t\telse {\n\t\t\t}\n\t\t}\n\t\tps.emplace_back(num1, num2);\n\t}\n\tsort(ps.begin(), ps.end());\n\tvector<int>v;\n\tfor (auto p : ps) {\n\t\tv.emplace_back(p.first);\n\t\tv.emplace_back(p.second);\n\t}\n\tCompress comp(v);\n\t\n\tfor (auto&p : ps) {\n\t\tp.first = comp.mp[p.first];\n\t\tp.second = comp.mp[p.second];\n\t}\n\t{\n\t\tbool a = is_sorted(ps.begin(), ps.end());\n\t\tassert(a);\n\t}\n\tint _size = comp.mp.size();\n\tint ans = 1e8;\n\tfor (int start = 0; start < ps.size(); ++start) {\n\t\tint num = 1;\n\t\tconst int anum = ps[start].first;\n\t\tqueue<int>que;\n\t\tint amin = 1e8;\n\t\tfor (int p = start; p < start + ps.size();++p) {\n\t\t\tconst int from = ps[p%N].first;\n\t\t\tconst int to = ps[p%N].second;\n\t\t\tif (isorder(from, anum, to))continue;\n\t\t\tconst int realfrom = from < anum ? from + _size : from;\n\t\t\tconst int realto = to < anum ? to + _size : to;\n\t\t\tamin = min(amin, realto);\n\t\t\tif (amin < realfrom) {\n\t\t\t\tamin = realto;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t\tif (amin != 1e8)num++;\n\t\tans = min(ans, num);\n\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii=pair<int,int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define l first\n#define r second\n\nint main(){\n\tint n,w,h,p;\n\tcin>>n>>w>>h;\n\tp=w*2+h*2;\n\tdeque<pii> rng(n);\n\trep(i,n){\n\t\tint x,y,v; char c;\n\t\tcin>>x>>y>>c;\n\t\trng[i].l=[=]{return (int[]){x-h+y,x+h-y,w*2+h+y-x,w*2+h-y-x}[\"NEWS\"s.find(c)];}();\n\t\trng[i].r=[=]{return (int[]){x+h-y,w*2+h-y-x,w*2+h+y+x,w*2+h+y-x}[\"NEWS\"s.find(c)];}();\n\t}\n\tsort(all(rng),[](pii a,pii b){return a.r<b.r;});\n\t//for(auto i:rng)cout<<i.l<<\",\"<<i.r<<endl;\n\t\n\tint ans=1e8;\n\trep(i,n) {\n\t\tfor(auto&j:rng) if(j.r<rng[0].r) j.l+=p, j.r+=p;\n\t\tsort(all(rng),[](pii a,pii b){return a.r<b.r;});\n\t\tint a=1,b=rng[0].r;\n\t\t//cout<<i<<\":\"<<b<<\"=====\"<<endl;\n\t\trange(j,1,n){\n\t\t\tif(rng[j].l>b){\n\t\t\t\ta++;\n\t\t\t\tb=rng[j].r;\n\t\t\t\t//cout<<j<<\":\"<<b<<endl;;\n\t\t\t}\n\t\t}\n\t\tans=min(ans,a);\n\t\trng.emplace_back(rng[0].l+p,rng[0].r+p);\n\t\trng.pop_front();\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int w,h,n;\n  cin>>n>>w>>h;\n  int x,y,B=2*(w+h),ans=n;\n  char c;\n  vector<P> m;\n  for(int i=0;i<n;i++){\n    cin>>x>>y>>c;\n    P A;\n    if(c=='S')A=P(x+y,(x-y+B)%B);\n    if(c=='E')A=P(w+y+(w-x),w+y-(w-x));\n    if(c=='N')A=P(w+h+(w-x)+(h-y),w+h+(w-x)-(h-y));\n    if(c=='W')A=P((w*2+h+(h-y)+x)%B,w*2+h+(h-y)-x);\n    m.push_back(A);\n  }\n  sort(m.begin(),m.end());\n  for(int i=0;i<n;i++){\n    int tp=1,p=m[i].first;\n    for(int j=0;j<n;j++){\n      int s=m[(i+j)%n].second,g=m[(i+j)%n].first;\n      if(!(s>g&&!(g<p&&p<s))&&!(s<g&&s<=p&&p<=g))tp++,p=g;\n    }\n    ans=min(tp,ans);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <tuple>\n\nusing namespace std;\ntypedef pair<int, int> pii;\nstatic const int INF = 1000000000;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tvector<pii> ranges;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x, y;\n\t\tstring f;\n\t\tcin >> x >> y >> f;\n\t\tconst int hw2 = h + w + h + w;\n\t\tconst int lu = y + x;\n\t\tconst int ru = h + x + (h - y);\n\t\tconst int rd = h + w + (h - y) + (w - x);\n\t\tconst int ld = h + w + h + (w - x) + y;\n\t\tint lo = 0, hi = 0;\n\t\tif(f[0] == 'N'){\n\t\t\tlo = lu; hi = ru;\n\t\t}else if(f[0] == 'E'){\n\t\t\tlo = ru; hi = rd;\n\t\t}else if(f[0] == 'S'){\n\t\t\tlo = rd; hi = ld;\n\t\t}else if(f[0] == 'W'){\n\t\t\tlo = ld; hi = lu + hw2;\n\t\t}\n\t\tif(lo >= hw2){\n\t\t\tlo -= hw2;\n\t\t\thi -= hw2;\n\t\t}\n\t\tranges.emplace_back(lo, hi);\n\t\tranges.emplace_back(lo + hw2, hi + hw2);\n\t}\n\tsort(\n\t\tranges.begin(), ranges.end(),\n\t\t[](const pii &a, const pii &b){\n\t\t\treturn (a.second == b.second) ? (a.first < b.first) : (a.second < b.second);\n\t\t});\n\tint answer = INF;\n\tfor(int i = 0; i < n; ++i){\n\t\tconst int hw2 = (h + w) * 2;\n\t\tvector<pii> r(ranges.begin() + i, ranges.begin() + i + n);\n\t\tint count = 1, last = r[0].second;\n\t\tfor(int j = 0; j < n; ++j){\n\t\t\tif(r[j].first <= last){ continue; }\n\t\t\tif(r[j].second >= r[0].second + hw2){ continue; }\n\t\t\t++count;\n\t\t\tlast = r[j].second;\n\t\t}\n\t\tanswer = min(answer, count);\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nint main() {\n    int n, w, d;\n    cin >> n >> w >> d;\n    vector<pii> v;\n    for(int i=0; i<n; ++i) {\n        int x, y;\n        char f;\n        cin >> x >> y >> f;\n        if(f == 'W') {\n            v.emplace_back(x + y, -x + y);\n        } else if(f == 'N') {\n            v.emplace_back(2*d + x - y, x + y);\n        } else if(f == 'E') {\n            v.emplace_back(2*(d+w) - x - y, 2*d + x - y);\n        } else {\n            v.emplace_back(2*(d+w) - x + y ,2*(d+w) - x - y);\n        }\n    }\n    sort(v.begin(), v.end());\n    int L = 2*(w + d);\n    int res = 1e9;\n    for(int i=0; i<n; ++i) {\n        auto tmp = v;\n        for(int j=i-1; j>=0; --j) {\n            if(tmp[j].first < tmp[i].first) {\n                tmp[j].first += L;\n                tmp[j].second += L;\n            }\n        }\n        sort(tmp.begin(), tmp.end());\n        int cnt = 1;\n        int now = tmp[0].first;\n        for(int j=0; j<n; ++j) {\n            if(tmp[j].second > now) {\n                now = tmp[j].first;\n                cnt++;\n            }\n        }\n        res = min(res, cnt);\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n,w,h;\nint pos(int x,int y){\n  if(y==0) return x;\n  if(y==h) return w+h+(w-x);\n  if(x==0) return w+h+w+(h-y);\n  if(x==w) return w+y;\n  assert(0);\n}\ntypedef pair<int,int> P;\nsigned main(){\n  cin>>n>>w>>h;\n  int x[n],y[n];\n  char f[n];\n  for(int i=0;i<n;i++) cin>>x[i]>>y[i]>>f[i];\n  vector<P> v;\n  for(int i=0;i<n;i++){\n    int a,b,c,d;\n    a=min(w-x[i],h-y[i]);\n    b=min(w-x[i],y[i]);\n    c=min(x[i],y[i]);\n    d=min(x[i],h-y[i]);\n    int l,r;\n    if(f[i]=='E'){\n      r=pos(x[i]+a,y[i]+a);\n      l=pos(x[i]+b,y[i]-b);\n    }\n    if(f[i]=='S'){\n      r=pos(x[i]+b,y[i]-b);\n      l=pos(x[i]-c,y[i]-c);\n    }\n    if(f[i]=='W'){\n      r=pos(x[i]-c,y[i]-c);\n      l=pos(x[i]-d,y[i]+d);\n    }\n    if(f[i]=='N'){\n      r=pos(x[i]-d,y[i]+d);\n      l=pos(x[i]+a,y[i]+a);\n    }\n    if(r<l) r+=2*(w+h);\n    v.push_back(P(l,r));\n  }\n \n  bool ovlp[n];\n  for(int i=0;i<n;i++){\n    ovlp[i]=0;\n    for(int j=0;j<n;j++){\n      ovlp[i]|=(i!=j)&&(v[i].first<=v[j].first&&v[j].second<=v[i].second);\n      ovlp[i]|=(i!=j)&&(v[i].first<=v[j].first+2*(w+h)&&\n\t\t\tv[j].second+2*(w+h)<=v[i].second);\n    }\n    //cout<<i<<\" \"<<ovlp[i]<<endl;\n  }\n  \n  for(int i=n-1;i>=0;i--) if(ovlp[i]) v.erase(v.begin()+i),n--;\n\n  sort(v.begin(),v.end());\n  for(int i=0;i<n;i++)\n    v.push_back(P(v[i].first+2*(w+h),v[i].second+2*(w+h)));\n\n  //for(int i=0;i<n;i++) cout<<v[i].first<<\" \"<<v[i].second<<endl;\n\n  int ans=n;\n  for(int i=0;i<n;i++){\n    int tmp=0;\n    int j=i,p;\n    while(j<i+n){\n      tmp++;\n      p=v[j].second;\n      while(j<i+n&&v[j].first<=p) j++;\n    }\n    //cout<<tmp<<endl;\n    ans=min(ans,tmp);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//1????????????????£??????£?¶?????????????????????£????????????\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, w, h;\nint x, y; char f;\nint l[1000], r[1000];\t//[l, r]\n\nint toId(int px, int py) {\n\tif (py == 0) return px;\n\tif (px == w) return w + py;\n\tif (py == h) return w + h + (w - px);\n\treturn 2 * w + h + (h - py);\n}\n\nint lay(int id, int x, int y) {\n\tint dist;\n\tint dx[4] = {1, -1, -1, 1};\n\tint dy[4] = {1, 1, -1, -1};\n\t\n\tif (dx[id] == 1) dist = w - x; else dist = x;\n\tif (dy[id] == 1) dist = min(dist, h - y); else dist = min(dist, y);\n\t\n\tint px = x + dist * dx[id];\n\tint py = y + dist * dy[id];\n\treturn toId(px, py);\n}\n\nint main() {\n\tint i, j;\n\t\n\tcin >> n >> w >> h;\n\tfor (i = 0; i < n; i++) {\n\t\tcin >> x >> y >> f;\n\t\t\n\t\tif (f == 'N') {\n\t\t\tl[i] = lay(1, x, y);\n\t\t\tr[i] = lay(0, x, y);\n\t\t}\n\t\tif (f == 'E') {\n\t\t\tl[i] = lay(0, x, y);\n\t\t\tr[i] = lay(3, x, y);\n\t\t}\n\t\tif (f == 'S') {\n\t\t\tl[i] = lay(3, x, y);\n\t\t\tr[i] = lay(2, x, y);\n\t\t}\n\t\tif (f == 'W') {\n\t\t\tl[i] = lay(2, x, y);\n\t\t\tr[i] = lay(1, x, y);\n\t\t}\n\t\tswap(l[i], r[i]);\t//???????¨???????????????????????????????????????§, [???->?£?, ???->?£?]??¨????????????????????????\n\t\tif (r[i] < l[i]) {\n\t\t\tr[i] += 2 * w + 2 * h;\n\t\t}\n\t}\n\t\n\ttypedef pair<int, int> P;\n\tP p[1000];\n\tfor (i = 0; i < n; i++) p[i] = P(l[i], r[i]);\n\tsort(p, p + n);\n\t\n\tint ans = 114514;\n\tfor (i = 0; i < n; i++) {\n\t\tint rMin = p[i].second;\n\t\tint ret = 0;\n\t\tfor (j = 1; j < n; j++) {\n\t\t\tint pl;\n\t\t\t\n\t\t\tif (i + j < n) {\n\t\t\t\tpl = p[i + j].first;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpl = p[i + j - n].first + 2 * w + 2 * h;\n\t\t\t}\n\t\t\t\n\t\t\tif (pl > rMin) {\n\t\t\t\tret++;\n\t\t\t\trMin = 11451419;\n\t\t\t}\n\t\t\trMin = min(rMin, p[(i + j) % n].second + (i + j >= n) * (2 * w + 2 * h));\n\t\t}\n\t\tret++;\n\t\tans = min(ans, ret);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define eb emplace_back\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n\nconst int INF = 1e9;\n\n\nint main(){\n\tint ans = INF;\n\tint n, w, d;\n\tvector<pair<int,pii> > vr;\n\n\tcin >> n >> w >> d;\n\tint N = 2*(w+d);\n\trep(i,n){\n\t\tint x, y;\n\t\tchar f;\n\t\tcin >> x >> y >> f;\n\t\tint l, r;\n\t\tif( f == 'W' ){\n\t\t\tl = 2*w + d - x + y;\n\t\t\tr = N + x - d + y;\n\t\t}\n\t\tif( f == 'E' ){\n\t\t\tl = x + d - y;\n\t\t\tr = 2*w + d - x - y;\n\t\t}\n\t\tif( f == 'N' ){\n\t\t\tl = 2*w + d + y + x;\n\t\t\tr = N + d - y + x;\n\t\t}\n\t\tif( f == 'S' ){\n\t\t\tl = 2*w + d - y - x;\n\t\t\tr = 2*w + d + y - x;\n\t\t}\n\t\t//cout << l << \" \" << r << endl;\n\t\tfor(;r<5*N; r+=N, l+=N){\n\t\t\tvr.eb( r, pii(i, l) );\n\t\t}\n\t}\n\tsort( all(vr) );\n\n\tint start=N-1;\n\trep(i,n+1){\n\t\tint cl = 0;\n\t\tauto cur = vr.begin();\n\t\twhile( cur->X < start ) cur++;\n\t\tstart = max(start+1, cur->X);\n\t\tint cnt = 0, sum = 0;\n\t\tbool f[1005] = {};\n\t\tfor(;cnt < n; cur++){\n\t\t\tint r  = cur->X;\n\t\t\tint id = cur->Y.X;\n\t\t\tint l  = cur->Y.Y;\n\t\t\tif( f[id] ) continue;\n\t\t\tif( cl < l ){\n\t\t\t\tcl = r;\n\t\t\t\tsum++;\n\t\t\t}\n\t\t\tf[id] = true;\n\t\t\tcnt++;\n\t\t}\n\t\tans = min(ans, sum);\n\t}\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define N 1000 + 5\n#define M 2000 + 5\n\nint n, r, c, tot, L[N], R[N], A[M], Right[M], Dp[M];\n\ninline int Trans(char ch)\n{\n\tif (ch == 'E') return 0;\n\tif (ch == 'N') return 1;\n\tif (ch == 'W') return 2;\n\tif (ch == 'S') return 3;\n}\n\ninline int DP()\n{\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tL[i] = L[i] == 0 ? tot - 1 : L[i] - 1;\n\t\tR[i] = R[i] == 0 ? tot - 1 : R[i] - 1;\n\t}\n\tint tmp = Right[0];\n\tfor (int i = 0; i < tot - 1; i ++)\n\t\tRight[i] = Right[i + 1];\n\tRight[tot - 1] = tmp;\n\tDp[0] = 1;\n\tfor (int i = 1; i < tot; i ++)\n\t\tif (i - Right[i] >= 0) Dp[i] = max(Dp[i - Right[i]] + 1, Dp[i - 1]);\n\t\t\telse Dp[i] = Dp[i - 1];\n\treturn Dp[tot - 1];\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &r, &c);\n\tr --, c --;\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tint x, y, op;\n\t\tchar s[9];\n\t\tscanf(\"%d%d%s\", &x, &y, s);\n\t\tx --, y --;\n\t\top = Trans(s[0]);\n\t\tif (op == 0)\n\t\t{\n\t\t\tL[i] = x + y;\n\t\t\tR[i] = r + c + (r - x) - (c - y);\n\t\t}\n\t\telse if (op == 1)\n\t\t{\n\t\t\tL[i] = r + c + (r - x) - (c - y);\n\t\t\tR[i] = r * 2 + c + (c - y) - x;\n\t\t}\n\t\telse if (op == 2)\n\t\t{\n\t\t\tL[i] = r * 2 + c + (c - y) - x;\n\t\t\tR[i] = ((r + c << 1) + x - y) % (r + c << 1);\n\t\t}\n\t\telse if (op == 3)\n\t\t{\n\t\t\tL[i] = ((r + c << 1) + x - y) % (r + c << 1);\n\t\t\tR[i] = x + y;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i ++)\n\t\tA[i] = L[i], A[i + n] = R[i];\n\tsort(A + 1, A + n * 2 + 1);\t\t\n\ttot = unique(A + 1, A + n * 2 + 1) - A - 1;\n\tfor (int i = 0; i < tot; i ++)\n\t\tRight[i] = tot;\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tL[i] = lower_bound(A + 1, A + tot + 1, L[i]) - A - 1;\n\t\tR[i] = lower_bound(A + 1, A + tot + 1, R[i]) - A - 1;\n\t\tint l = L[i], r = R[i], _r = R[i];\n\t\tif (r < l) r += tot;\n\t\tRight[_r] = min(Right[_r], r - l + 1);\n\t}\n\tint Min = n;\n\tfor (int b = 0; b < 1; b ++)\n\t{\n\t\tint tmp = DP();\n\t\tMin = min(Min, tmp);\n\t}\n\tprintf(\"%d\\n\", Min);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint N, W, H;\nint sz;\nint idx(int x, int y){\n  if(y == 0) return x;\n  if(x == W) return W + y;\n  if(y == H) return W + H + W-x;\n  return W+H+W+H-y;\n}\nint projc(int x, int y, int dir){\n  switch(dir){\n  case 0:\n\treturn idx(x-min(x,y),y-min(x,y));\n  case 1:\n\treturn idx(x+min(W-x,y),y-min(W-x,y));\n  case 2:\n\treturn idx(x+min(W-x,H-y),y+min(W-x,H-y));\n  case 3:\n\treturn idx(x-min(x,H-y),y+min(x,H-y));\n  }\n  return -1;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> N >> W >> H;\n  sz = 2*(W+H); \n  vector<PII> xs(N);\n  REP(i,N){\n\tchar f;\n\tint x, y; cin >> x >> y >> f;\n\tPII p;\n\tint ix = string(\"SENW\").find(f);\n\tp.FF = projc(x,y,ix);\n\tp.SS = projc(x,y,(ix+1)%4);\n\tif(p.SS < p.FF) p.SS += sz;\n\txs[i] = p;\n  }\n\n  int ans = N;\n  REP(i,N) xs.EB(xs[i].FF+sz, xs[i].SS+sz);\n  SORT(xs);\n\n  for(int i=0;i<N;++i){\n\tint sum = 0;\n\tint e = -1;\n\tfor(int j=i;j<SZ(xs)&&xs[j].FF<=xs[i].FF+sz;++j){\n\t  if(xs[j].FF <= e){\n\t\te = min(e, xs[j].SS);\n\t  }\n\t  else{\n\t\t++sum;\n\t\te = xs[j].SS;\n\t  }\n\t}\n\tans = min(ans, sum);\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P1;\nint n,w,d,x,y,ans;\nvector<P1> v;\nchar f;\nstack<P> q;\nbool used[N];\n\nvoid add_point(int num){\n  if(f=='N'){\n    if(x+y<d)v.push_back(P1(P(x+y+w*2+d,0),num));\n    else v.push_back(P1(P(x+y-d,0),num));\n    if(w+y-x<d)v.push_back(P1(P(d-(w+y-x)+w,1),num));\n    else v.push_back(P1(P(d-(y-x),1),num));\n  }\n  if(f=='E'){\n    if(d-(y-x)<w)v.push_back(P1(P(d-(y-x),0),num));\n    else v.push_back(P1(P(d-(w+(y-x))+w,0),num));\n    if(y+x<w)v.push_back(P1(P(w-(y+x)+w+d,1),num));\n    else v.push_back(P1(P(d-(-w+y+x)+w,1),num));\n  }\n  if(f=='S'){\n    if(0<=-w+y+x)v.push_back(P1(P(d-(-w+y+x)+w,0),num));\n    else v.push_back(P1(P(w-(y+x)+w+d,0),num));\n    if(0<=y-x)v.push_back(P1(P(y-x+w*2+d,1),num));\n    else v.push_back(P1(P(w-(-(y-x))+w+d,1),num));\n  }\n  if(f=='W'){\n    if(0<=-(y-x))v.push_back(P1(P(w-(-(y-x))+w+d,0),num));\n    else v.push_back(P1(P(y-x+w*2+d,0),num));\n    if(0<=y+x-d)v.push_back(P1(P(y+x-d,1),num));\n    else v.push_back(P1(P(y-x+w*2+d,1),num));\n  }\n}\n\nbool usednum[500000];\n\nvoid solve(){\n  int len=v.size(),cnt;\n  for(int i=0;i<len;i++){\n    memset(used,0,sizeof(used));\n    memset(usednum,0,sizeof(usednum));\n    if(v[i].first.second)continue;\n    cnt=0;\n    for(int j=i;j<len+i;j++){\n      int idx=j%len;\n      if(used[v[idx].second])continue;\n      if(!v[idx].first.second){\n\tuseds[v[idx].second]=true;\n\tq.push(P(v[idx].second,v[idx].first.first));\n      }\n      else{\n\tcnt++;\n\tif(usednum[v[idx].first.first])cnt--;\n\tusednum[v[idx].first.first]=true;\n\twhile(!q.empty()){\n\t  P num=q.top(); q.pop();\n\t  used[num.first]=true;\n\t  if(num.first==v[idx].second)break;\n\t}\n      }\n    }\n    ans=min(ans,cnt);\n  }\n}\n\nint main(){\n  cin>>n>>w>>d;\n  for(int i=0;i<n;i++){\n    cin>>x>>y>>f;\n    add_point(i);\n  }\n  sort(v.begin(),v.end());\n  ans=(1e9);\n  solve();\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <tuple>\n\nusing namespace std;\ntypedef pair<int, int> pii;\nstatic const int INF = 1000000000;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tvector<pii> ranges;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x, y;\n\t\tstring f;\n\t\tcin >> x >> y >> f;\n\t\tconst int lu = y + x;\n\t\tconst int ru = h + x + (h - y);\n\t\tconst int rd = h + w + (h - y) + (w - x);\n\t\tconst int ld = h + w + h + (w - x) + y;\n\t\tint lo = 0, hi = 0;\n\t\tif(f[0] == 'N'){\n\t\t\tlo = lu; hi = ru;\n\t\t}else if(f[0] == 'E'){\n\t\t\tlo = ru; hi = rd;\n\t\t}else if(f[0] == 'S'){\n\t\t\tlo = rd; hi = ld;\n\t\t}else if(f[0] == 'W'){\n\t\t\tlo = ld; hi = lu + (h + w) * 2;\n\t\t}\n\t\tconst int hw2 = h + w + h + w;\n\t\tranges.emplace_back(lo, hi);\n\t\tranges.emplace_back(lo + hw2, hi + hw2);\n\t\tranges.emplace_back(lo + hw2 * 2, hi + hw2 * 2);\n\t}\n\tsort(\n\t\tranges.begin(), ranges.end(),\n\t\t[](const pii &a, const pii &b){\n\t\t\treturn (a.second == b.second) ? (a.first < b.first) : (a.second < b.second);\n\t\t});\n\tint answer = INF;\n\tfor(int i = 0; i < 2 * n; ++i){\n\t\tvector<pii> r(ranges.begin() + i, ranges.begin() + i + n);\n\t\tconst int hw2 = (h + w) * 2;\n\t\tint count = 1, last = r[0].second;\n\t\tfor(int j = 0; j < n; ++j){\n\t\t\tif(r[j].first <= last){ continue; }\n\t\t\tif(r[j].second >= r[0].second + hw2){ continue; }\n\t\t\t++count;\n\t\t\tlast = r[j].second;\n\t\t}\n\t\tanswer = min(answer, count);\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n\t> File Name: d.cpp\n\t> Author: skt\n\t> Mail: sktsxy@gmail.com\n\t> Created Time: 2015??´11???29??\\ ????????\\ 12??¶36???46?§?\n ************************************************************************/\n\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <complex>\n#include <cassert>\n// #pragma comment(linker,\"/STACK:102400000,102400000\")\nusing namespace std;\n#define LL long long\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\ntemplate <typename T> inline void checkMax(T &a, T b) {a = a>b?a:b;}\ntemplate <typename T> inline void checkMin(T &a, T b) {a = a<b?a:b;}\ntypedef pair<int, int> PII;\ntypedef vector<int> vi;\nconst double PI = acos(-1.0);\nconst double eps = 1e-8;\n\nconst int NN = 1e3 + 5;\n\nstruct member {\n    double x, y;\n    char dir;\n}a[NN];\n\nstruct P {\n    double x, y;\n    P() {}\n    P(double _x, double _y) {\n        x = _x;\n        y = _y;\n    }\n}p[2 * NN];\nint p_tot = 0;\n\nvoid deal(member mem, double w, double d) {\n    P p1, p2;\n    if(mem.dir == 'N') {\n        double tmp = d - mem.y;\n        p1 = P(mem.x - tmp, d);\n        p2 = P(mem.x + tmp, d);\n        if(p1.x < 0) {\n            p1 = P(0, p1.y + p1.x);\n        }\n        if(p2.x > w) {\n            p2.x -= w;\n            p2 = P(w, p2.y - p2.x);\n        }\n    }\n    if(mem.dir == 'S') {\n        double tmp = mem.y;\n        p1 = P(mem.x - tmp, 0);\n        p2 = P(mem.x + tmp, 0);\n        if(p1.x < 0) {\n            p1 = P(0, p1.y - p1.x);\n        }\n        if(p2.x > w) {\n            p2.x -= w;\n            p2 = P(w, p2.y + p2.x);\n        }\n    }\n    if(mem.dir == 'W') {\n        double tmp = mem.x;\n        p1 = P(0, mem.y - tmp);\n        p2 = P(0, mem.y + tmp);\n        if(p1.y < 0) {\n            p1 = P(p1.x - p1.y, 0);\n        }\n        if(p2.y > d) {\n            p2.y -= d;\n            p2 = P(p2.x + p2.y, d);\n        }\n    }\n    if(mem.dir == 'E') {\n        double tmp = w - mem.x;\n        p1 = P(w, mem.y - tmp);\n        p2 = P(w, mem.y + tmp);\n        if(p1.y < 0) {\n            p1 = P(p1.x + p1.y, 0);\n        }\n        if(p2.y > d) {\n            p2.y -= d;\n            p2 = P(p2.x - p2.y, d);\n        }\n    }\n    p[p_tot++] = p1;\n    p[p_tot++] = p2;\n}\n\nvector<int> fg[2 * NN];\n\ndouble fun(double A, double B, int i) {\n    return p[i].y - (A * p[i].x + B);\n}\n\nbool ok(int i, int j) {\n    if(a[j].dir == 'N') {\n        double A = 1;\n        double B = a[j].y - a[j].x;\n        if(fun(A, B, i) < 0) return false;\n        A = -1;\n        B = a[j].y + a[j].x;\n        if(fun(A, B, i) < 0) return false;\n    }\n    if(a[j].dir == 'S') {\n        double A = 1;\n        double B = a[j].y - a[j].x;\n        if(fun(A, B, i) > 0) return false;\n        A = -1;\n        B = a[j].y + a[j].x;\n        if(fun(A, B, i) > 0) return false;\n    }\n    if(a[j].dir == 'W') {\n        double A = 1;\n        double B = a[j].y - a[j].x;\n        //cout<<'!'<<A<<' '<<B<<' '<<i<<' '<<j<<' '<<fun(A, B, i)<<endl;\n        if(fun(A, B, i) < 0) return false;\n        A = -1;\n        B = a[j].y + a[j].x;\n        if(fun(A, B, i) > 0) return false;\n    }\n    if(a[j].dir == 'E') {\n        double A = 1;\n        double B = a[j].y - a[j].x;\n        if(fun(A, B, i) > 0) return false;\n        A = -1;\n        B = a[j].y + a[j].x;\n        if(fun(A, B, i) < 0) return false;\n    }\n    return true;\n}\n\nconst int MAXM = 2005;\nconst int MAXN = 2005;\nconst int N = MAXN * MAXM;\nconst int INF = 0x3f3f3f3f;\nstruct DLX {\n    int n, m, size;\n    int U[N], D[N], R[N], L[N], row[N], col[N];\n    int H[MAXN], S[MAXM];\n    int ans[MAXN], ans_cnt;\n    void init(int _n, int _m) {\n        ans_cnt = INF;\n        n = _n;\n        m = _m;\n        for (int i = 0; i <= m; i++) {\n            S[i] = 0;\n            U[i] = D[i] = i;\n            L[i] = i - 1;\n            R[i] = i + 1;\n        }\n        R[m] = 0; L[0] = m;\n        size = m;\n        for (int i = 1; i <= n; i++)H[i] = -1;\n    }\n    void link(int r, int c) {\n        ++S[col[++size] = c];\n        row[size] = r;\n        D[size] = D[c];\n        U[D[c]] = size;\n        U[size] = c;\n        D[c] = size;\n        if (H[r] < 0)H[r] = L[size] = R[size] = size;\n        else {\n            R[size] = R[H[r]];\n            L[R[H[r]]] = size;\n            L[size] = H[r];\n            R[H[r]] = size;\n        }\n    }\n    void remove(int c) {\n        for (int i = D[c]; i != c; i = D[i])\n            L[R[i]] = L[i], R[L[i]] = R[i];\n    }\n    void resume(int c) {\n        for (int i = U[c]; i != c; i = U[i])\n            L[R[i]] = R[L[i]] = i;\n    }\n    bool v[MAXM];\n    int f() {\n        int ret = 0;\n        for (int c = R[0]; c != 0; c = R[c])v[c] = true;\n        for (int c = R[0]; c != 0; c = R[c])\n            if (v[c]) {\n                ret++;\n                v[c] = false;\n                for (int i = D[c]; i != c; i = D[i])\n                    for (int j = R[i]; j != i; j = R[j])\n                        v[col[j]] = false;\n            }\n        return ret;\n    }\n\t//??¨??????????????\\?????\\???????????????\n    void dance(int d) {\n        if (d + f() >= ans_cnt) return;\n        if (R[0] == 0) {\n            if (d < ans_cnt) ans_cnt = d;\n            return ;\n        }\n        int c = R[0];\n        for (int i = R[0]; i != 0; i = R[i])\n            if (S[i] < S[c])\n                c = i;\n        for (int i = D[c]; i != c; i = D[i]) {\n            remove(i);\n            //ans[d] = row[i];\n            for (int j = R[i]; j != i; j = R[j]) remove(j);\n            dance(d + 1);\n            for (int j = L[i]; j != i; j = L[j]) resume(j);\n            resume(i);\n        }\n    }\n\n\t//bool dance(int d, int limit) {\n\t//\tif (d + f() > limit) return false;\n    //    if (R[0] == 0) return d <= limit;\n    //    int c = R[0];\n    //    for (int i = R[0]; i != 0; i = R[i])\n    //        if (S[i] < S[c])\n    //            c = i;\n    //    for (int i = D[c]; i != c; i = D[i]) {\n    //        remove(i);\n    //        for (int j = R[i]; j != i; j = R[j]) remove(j);\n    //        if(dance(d + 1, limit)) return true;\n    //        for (int j = L[i]; j != i; j = L[j]) resume(j);\n    //        resume(i);\n    //    }\n\t//\treturn false;\n    //}\n} dlx;\n\nvoid work(int n, double w, double d) {\n    p_tot = 0;\n    for(int i = 0; i < n; ++i) {\n        deal(a[i], w, d);\n    }\n    for(int i = 0; i < p_tot; ++i) {\n        //cout<<p[i].x<<' '<<p[i].y<<endl;\n        fg[i].clear();\n    }\n\n    dlx.init(p_tot, n);\n    for(int i = 0; i < p_tot; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if(ok(i, j)) {\n                //fg[i].push_back(j);\n                dlx.link(i + 1, j + 1);\n            }\n        }\n    }\n    //for(int i = 0; i < p_tot; ++i) {\n    //    //cout<<i<<':';\n    //    for(int j = 0; j < fg[i].size(); ++j) {\n    //        //cout<<fg[i][j]<<' ';\n    //        dlx.link(i + 1, j + 1);\n    //    }\n    //    //cout<<endl;\n    //}\n    dlx.dance(0);\n    cout<<dlx.ans_cnt<<endl;\n}\nint main() {\n    int n;\n    double w, d;\n    while(scanf(\"%d%lf%lf\", &n, &w, &d) != EOF) {\n        double x, y;\n        char dir[3];\n        for(int i = 0; i < n; ++i) {\n            scanf(\"%lf%lf%s\", &x, &y, dir);\n            a[i].x = x; a[i].y = y; a[i].dir = dir[0];\n        }\n        work(n, w, d);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint n,h,w;\n\nbool valid(P p){\n  return p.fi>=0&&p.fi<=w&&p.se>=0&&p.se<=h;\n}\n\nP ur(int x,int y){\n  int d=y-x;\n  P p1=P(w,w+d),p2=P(h-d,h);\n  if(valid(p1))return p1;\n  else return p2;\n}\n\nP ll(int x,int y){\n  int d=y-x;\n  P p1=P(0,0+d),p2=P(0-d,0);\n  if(valid(p1))return p1;\n  else return p2;\n}\n\nP ul(int x,int y){\n  int d=y+x;\n  P p1=P(0,d-0),p2=P(d-h,h);\n  if(valid(p1))return p1;\n  else return p2;\n}\n\nP lr(int x,int y){\n  int d=y+x;\n  P p1=P(w,d-w),p2=P(d-0,0);\n  if(valid(p1))return p1;\n  else return p2;\n}\n\nint calc(P p){\n  assert(p.fi==0||p.fi==w||p.se==0||p.se==h);\n  if(p.se==0){\n    return p.fi;\n  }else if(p.fi==w){\n    return w+p.se;\n  }else if(p.se==h){\n    return w+h+(w-p.fi);\n  }else if(p.fi==0){\n    return w+h+w+(h-p.se);\n  }\n  return -1;\n}\n\nint main(){\n  cin>>n>>w>>h;\n  int M=w*2+h*2;\n  vector<P> rs;\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    char c;\n    cin>>c;\n    if(c=='E'){\n      P p1=lr(x,y); P p2=ur(x,y);\n      rs.push_back(P(calc(p1),calc(p2)));\n    }else if(c=='N'){\n      P p1=ur(x,y); P p2=ul(x,y);\n      rs.push_back(P(calc(p1),calc(p2)));\n    }else if(c=='W'){\n      P p1=ul(x,y); P p2=ll(x,y);\n      dbg(p1.fi); dbg(p1.se);\n      dbg(p2.fi); dbg(p2.se);\n      rs.push_back(P(calc(p1),calc(p2)));\n    }else{\n      P p1=ll(x,y); P p2=lr(x,y);\n      rs.push_back(P(calc(p1),calc(p2)));\n    }\n  }\n\n  vector<P> ps;\n  rep(i,rs.size()){\n    if(rs[i].fi>rs[i].se)rs[i].se+=M;\n    ps.push_back(P(rs[i].se,rs[i].fi));\n    ps.push_back(P(rs[i].se+M,rs[i].fi+M));\n  }\n  sort(all(ps));\n\n  int res=0;\n  rep(i,n){\n    int tmp=0,last=0;\n    for(int j=i;ps[j].fi<ps[i].se+M;j++){\n      if(last<ps[j].se){\n        tmp++;\n        last=ps[j].fi;\n      }\n    }\n    maxch(res,tmp);\n  }\n\n  cout<<res<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=2005,INF=1<<30;\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,W,H;cin>>N>>W>>H;\n    \n    int D=2*(H+W);\n    \n    vector<pair<int,int>> S(N);\n    \n    map<int,int> MA;\n    \n    for(int i=0;i<N;i++){\n        int x,y;char c;cin>>x>>y>>c;\n        int l,r;\n        if(c=='N'){\n            l=x+y;\n            r=H+x+(H-y);\n        }else if(c=='E'){\n            l=H+x+(H-y);\n            r=H+W+(H-y)+(W-x);\n        }else if(c=='S'){\n            l=H+W+(H-y)+(W-x);\n            r=H+W+H+(W-x)+y;\n        }else{\n            l=H+W+H+(W-x)+y;\n            r=x+y;\n        }\n        l%=D;\n        r%=D;\n        S[i]=mp(l,r);\n        \n        MA[l]=1;\n        MA[r]=1;\n    }\n    \n    int id=0;\n    \n    for(auto &a:MA){\n        a.se=id;\n        id++;\n    }\n    \n    for(int i=0;i<N;i++){\n        S[i].fi=MA[S[i].fi];\n        S[i].se=MA[S[i].se];\n    }\n    \n    int ans=INF;\n    \n    for(int t=0;t<id;t++){\n        vector<pair<int,int>> A;\n        for(int i=0;i<N;i++){\n            int l=S[i].fi,r=S[i].se;\n            if(l<=r){\n                if(l<=t&&t<=r) {}\n                else{\n                    if(t<l) A.push_back(mp(l-t,r-t));\n                    else A.push_back(mp(l+id-t,r+id-t));\n                }\n            }else{\n                if(l<=t||t<=r) {}\n                else A.push_back(mp(l-t,r+id-t));\n            }\n        }\n        \n        sort(all(A),[](auto a,auto b){\n            return a.se<b.se;\n        });\n        \n        int sum=1,last=0;\n        \n        int i=0;\n        \n        while(i<si(A)){\n            while(i<si(A)&&A[i].fi<=last) i++;\n            if(i==si(A)) break;\n            int j=i;\n            while(j<si(A)&&A[i].se==A[j].se) j++;\n            \n            sum++;\n            if(i<si(A)) last=A[i].se;\n            i=j;\n        }\n        \n        chmin(ans,sum);\n    }\n    \n    cout<<ans<<endl;\n    \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P1;\nint n,w,d,x,y,ans;\nvector<P1> v;\nchar f;\nstack<int> q;\nbool used[N];\n\nvoid add_point(int num){\n  if(f=='N'){\n    if(x+y<d)v.push_back(P1(P(x+y+w*2+d,0),num));\n    else v.push_back(P1(P(x+y-d,0),num));\n    if(w+y-x<d)v.push_back(P1(P(d-(w+y-x)+w,1),num));\n    else v.push_back(P1(P(d-(y-x),1),num));\n  }\n  if(f=='E'){\n    if(d-(y-x)<w)v.push_back(P1(P(d-(y-x),0),num));\n    else v.push_back(P1(P(d-(w+(y-x))+w,0),num));\n    if(y+x<w)v.push_back(P1(P(w-(y+x)+w+d,1),num));\n    else v.push_back(P1(P(d-(-w+y+x)+w,1),num));\n  }\n  if(f=='S'){\n    if(0<=-w+y+x)v.push_back(P1(P(d-(-w+y+x)+w,0),num));\n    else v.push_back(P1(P(w-(y+x)+w+d,0),num));\n    if(0<=y-x)v.push_back(P1(P(y-x+w*2+d,1),num));\n    else v.push_back(P1(P(w-(-(y-x))+w+d,1),num));\n  }\n  if(f=='W'){\n    if(0<=-(y-x))v.push_back(P1(P(w-(-(y-x))+w+d,0),num));\n    else v.push_back(P1(P(y-x+w*2+d,0),num));\n    if(0<=y+x-d)v.push_back(P1(P(y+x-d,1),num));\n    else v.push_back(P1(P(y+x+w*2+d,1),num));\n  }\n}\n\nbool usednum[500000];\nset<int> S;\n\nvoid solve(){\n  int len=v.size(),cnt;\n  for(int i=0;i<len;i++){\n    memset(used,0,sizeof(used));\n    memset(usednum,0,sizeof(usednum));\n    if(v[i].first.second)continue;\n    cnt=0;\n    S.clear();\n    for(int j=i;j<len+i;j++){\n      int idx=j%len;\n      if(used[v[idx].second])continue;\n      if(!v[idx].first.second){\n\tif(S.count(v[idx].second))break;\n\tq.push(v[idx].second);\n      }\n      else{\n\tcnt++;\n\tif(usednum[v[idx].first.first])cnt--;\n\tusednum[v[idx].first.first]=true;\n\tused[v[idx].second]=true;\n\tint flag=0;\n\twhile(!q.empty()){\n\t  int num=q.top(); q.pop();\n\t  if(num==v[idx].second)flag=1;\n\t  used[num]=true;\n\t}\n\tif(!flag)S.insert(v[idx].second);\n      }\n    }\n    ans=min(ans,cnt);\n  }\n}\n\nint main(){\n  cin>>n>>w>>d;\n  for(int i=0;i<n;i++){\n    cin>>x>>y>>f;\n    add_point(i);\n  }\n  sort(v.begin(),v.end());\n  /*  for(int i=0;i<v.size();i++)\n      cout<<v[i].first.first<<' '<<v[i].first.second<<' '<<v[i].second<<endl;*/\n  ans=(1e9);\n  solve();\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\n#define EPS (1e-8)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\nconst double PI=4*atan(1.0);\n\ntypedef complex<double> P;\n\n// ??????\ndouble dot(const P &a, const P &b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// ??????\ndouble cross(const P &a, const P &b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distance_ls_p(const P &a, const P &b, const P &c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nint is_intersected_ls(const P &a1, const P &a2, const P &b1, const P &b2) {\n  // ????????????????????´???\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    // ????????¨???????????¢???0??????????????£????????????\n    if(EQ(distance_ls_p(a1,a2,b1),0)||EQ(distance_ls_p(a1,a2,b2),0))\n      return 1;\n    return 0;\n  }\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n    ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nP intersection_ls(const P &a1, const P &a2, const P &b1, const P &b2) {\n  // ????????????????????´????????????????????£???????????????????????£???????????¨????????????\n  // ?????£??¨???x??§?¨?????°??????????????????????\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    // ????????¨???????????¢???0??????????????£????????????\n    if(EQ(distance_ls_p(a1,a2,b1),0)||EQ(distance_ls_p(a1,a2,b2),0)){\n      // x??§?¨????a1<a2,b1<b2??¨????????????????????????\n      P la1=a1,la2=a2;\n      P lb1=b1,lb2=b2;\n      if(a1.real()>a2.real())swap(la1,la2);\n      if(b1.real()>b2.real())swap(lb1,lb2);\n      P res;\n      if(la1.real()>lb1.real())res=la1;\n      else res=lb1;\n      return res;\n    }\n    // ????????£???????????´??????...?\n    else{\n      // ??????????±?????????????????????§?????????\n      // ????????¢??°?????????????????????????????????????????¨????????????\n      return P(-1,-1);\n    }\n  }\n  else{\n    P b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n  }\n}\n\n// ??§?¨?????????¢(??§?¨?p???????????????,???????¨??????????a(????????¢???)?????¢)\nP roundPoint(const P &p,double a){\n  return P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n\nbool used[1010];\ntypedef tuple<int,int,int> tpl;\n\nint N,W,D;\nint XS[1001];\nint YS[1001];\nchar AS[1001];\nint main(){\n\n  cin>>N>>W>>D;\n  for(int i=0;i<N;i++)cin>>XS[i]>>YS[i]>>AS[i];\n  vector<pii> poses;\n  // ???????£????????????????, ??§?¨????????????????????????????\n  for(int i=0;i<N;i++){\n    P ang_v;\n    // ????????§????????????????¨????????????????\n    if(AS[i]=='W')ang_v = P(-1, 0);\n    else if(AS[i]=='E')ang_v = P(1, 0);\n    else if(AS[i]=='N')ang_v = P(0, 1);\n    else if(AS[i]=='S')ang_v = P(0, -1);\n    ang_v *= 10000000;\n\n    // 2?????????????????????????¨????????????????\n    P ps[2] = {roundPoint(ang_v, PI/4) + P(XS[i], YS[i]), roundPoint(ang_v, -PI/4) + P(XS[i], YS[i])};\n    // ??????????????¶??????????????????????????????\n    const P corner[4] = {P(0,0), P(0,D), P(W,D), P(W,0)};\n    int ds[2];\n    for(int k=0;k<2;k++){\n        int sum_dist = 0;\n        int dist = -1;\n        for(int j = 0; j < 4; j++){\n            const P &p1 = corner[j];\n            const P &p2 = corner[(j+1)%4];\n            // p1-p2???????????¨ps[j]?????????????????????????????????\n            // cross????????????, ????????§?¨?????±???????\n            if(is_intersected_ls(p1, p2, ps[k], P(XS[i], YS[i]))){\n                // ??§?¨???¨,corner[j]??¨????????¢????¨??????????\n                P c = intersection_ls(p1, p2, ps[k], P(XS[i], YS[i]));\n                dist = sum_dist + abs(c-corner[j]) + 0.1;\n                break;\n            }\n            else{\n              sum_dist += (abs(p2-p1) + 0.1);\n              continue;\n            }\n        }\n        // dist???2(D+W)?????£??????, 0????£???£????????????\n        if((2*(D+W) == dist)){\n            dist = 0;\n        }\n        ds[k] = dist;\n    }\n    \n    if(ds[0] > ds[1])\n        ds[1] += 2*(W+D);\n\n    poses.push_back(make_pair(ds[0], ds[1]));\n  }\n\n  // vector???????????????2??????????????????\n  for(int i=0;i<N;i++){\n    // ??????????????????+2*(W+D)???????????????push_back\n    pii pd = poses[i];\n    pd.first += 2*(W+D);\n    pd.second += 2*(W+D);\n    poses.push_back(pd);\n  }\n  \n  int min_ans = 1<<29;\n  // ?????¨?????£??????, ??????????§???°???????±???????, ????????????n?????????????????°????¨??????????\n  for(int start = 0; start < N; start++){\n      memset(used,0,sizeof(used));\n      vector<tpl> vec;\n      for(int i=0;i<N;i++){\n        pii t = poses[start + i];\n        vec.push_back(make_tuple(t.first, 0, i));\n        vec.push_back(make_tuple(t.second, 1, i));\n      }\n      // start??????????????????end????????£????????????????´???????????????????\n      queue<int> q;\n      // ?????¢??§?????????\n      sort(vec.begin(), vec.end());\n      \n      int vec_idx = 0;\n      int ans = 0;\n      // ???????????¢?????¨??????????????????????????????\n      while((int)vec.size() != vec_idx){\n          // ???????????¢??§????´??????????????????????\n          int d = get<0>(vec[vec_idx]);\n          vector<int> vs[2];\n          while((int)vec.size()!=vec_idx && (get<0>(vec[vec_idx]) == d)){\n            vs[get<1>(vec[vec_idx])].push_back(get<2>(vec[vec_idx]));\n            vec_idx++;\n          }\n          \n          // start???????´???????????????????\n          // start???????´????, queue????????????\n          for(int i=0;i<(int)vs[0].size();i++){\n              int idx = vs[0][i];\n              q.push(idx);\n          }\n          \n          // end???????´????, ?????§???????????????????????°continue\n          for(int i=0;i<(int)vs[1].size();i++){\n              int idx = vs[1][i];\n              if(used[idx])continue;\n              else{\n                  // ?????????????????£????????????????????§start???????´?????§£???????????????\n                  // ????????????end????§£?????????????????§??????????????????\n                  ans++;\n                  while(q.size()){\n                      const int a = q.front(); q.pop();\n                      used[a] = true;\n                  }\n                  break;\n              }\n          }\n      }\n      min_ans = min(min_ans, ans);\n  }\n\n  cout<<min_ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c\n\tif (cross(nb, nc) < -eps) return -1; // a,\n\tif (dot(nb, nc) < 0) return 2;       //\n\tif (norm(nb) < norm(nc)) return -2;  // \n\treturn 0;                          \n}\n\n\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\nconst int dx0[4] = { -1,0,1,0 };\nconst int dy0[4] = { 0,1,0,-1 };\n\nconst int dx[4] = { -1,-1,1,1 };\nconst int dy[4] = { -1,1,1,-1 };\n\nint N, W, D;\n\nint getnum(int x, int y) {\n\tif (x == 0) {\n\t\treturn y;\n\t}\n\telse if (y == D) {\n\t\treturn D + x;\n\t}\n\telse if (x == W) {\n\t\treturn 2 * D + W - y;\n\t}\n\telse {\n\t\tassert(!y);\n\t\treturn 2 * D + 2 * W - x;\n\t}\n}\nbool isorder(const int a, const int b, const int c) {\n\tif (a < c) {\n\t\treturn a <= b&&b <= c;\n\t}\n\telse if (a>c) {\n\t\treturn a <= b || b <= c;\n\t}\n\telse\n\t{\n\t\treturn true;\n\t}\n}\nstruct Compress {\n\tmap<int, int>mp;\n\tmap<int, int>revmp;\n\n\tCompress(vector<int>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()),vs.end());\n\t\tfor (int i = 0; i < vs.size(); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n};\nmap<char, int>mp;\nint main() {\n\tmp['W'] = 0;\n\tmp['S'] = 1;\n\tmp['E'] = 2;\n\tmp['N'] = 3;\n\tcin >> N >> W >> D;\n\tif (N == 1) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tvector<Line> ls;\n\tls.push_back(Line(Point(0, 0), Point(0, D)));\n\tls.push_back(Line(Point(1, D), Point(W - 1, D)));\n\tls.push_back(Line(Point(W, D), Point(W, 0)));\n\tls.push_back(Line(Point(W - 1, 0), Point(1, 0)));\n\tvector<pair<int, int>>ps;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y; char f; cin >> x >> y >> f;\n\t\ty = D - y;\n\t\tPoint p(x, y);\n\t\tint num1, num2;\n\t\tint betnum;\n\t\t{\n\t\t\tconst int way = mp[f];\n\t\t\tLine l(p, p + 1000000.l * Point(dx[way], dy[way]));\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tif (isis_ss(l, ls[i])) {\n\t\t\t\t\tPoint sect(is_ll(l, ls[i]));\n\t\t\t\t\tnum1 = getnum(round(sect.real()), round(sect.imag()));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tconst int way = (mp[f]+1)%4;\n\t\t\tLine l(p, p + 1000000.l * Point(dx[way], dy[way]));\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tif (isis_ss(l, ls[i])) {\n\t\t\t\t\tPoint sect(is_ll(l, ls[i]));\n\t\t\t\t\tnum2 = getnum(round(sect.real()), round(sect.imag()));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tconst int way = mp[f];\n\t\t\tLine l(p, p + 1000000.l * Point(dx0[way], dy0[way]));\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tif (isis_ss(l, ls[i])) {\n\t\t\t\t\tPoint sect(is_ll(l, ls[i]));\n\t\t\t\t\tbetnum = getnum(round(sect.real()), round(sect.imag()));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (num1 < num2) {\n\t\t\tif (num1 < betnum&&betnum < num2) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tswap(num1, num2);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (num2 < betnum&&betnum < num1) {\n\t\t\t\tswap(num1, num2);\n\t\t\t}\n\t\t\telse {\n\t\t\t}\n\t\t}\n\t\tps.emplace_back(num1, num2);\n\t}\n\tsort(ps.begin(), ps.end());\n\tvector<int>v;\n\tfor (auto p : ps) {\n\t\tv.emplace_back(p.first);\n\t\tv.emplace_back(p.second);\n\t}\n\tCompress comp(v);\n\t\n\tfor (auto&p : ps) {\n\t\tp.first = comp.mp[p.first];\n\t\tp.second = comp.mp[p.second];\n\t}\n\t{\n\t\tbool a = is_sorted(ps.begin(), ps.end());\n\t\tassert(a);\n\t}\n\tint _size = comp.mp.size();\n\tint ans = 1e5;\n\tfor (int start = 0; start < ps.size(); ++start) {\n\t\tint num = 1;\n\t\tconst int anum = ps[start].first;\n\t\tqueue<int>que;\n\t\tint amin = 1e8;\n\t\tfor (int p = start; p < start + ps.size();++p) {\n\t\t\tconst int from = ps[p%N].first;\n\t\t\tconst int to = ps[p%N].second;\n\t\t\tif (isorder(from, anum, to))continue;\n\t\t\tconst int realfrom = from < anum ? from + _size : from;\n\t\t\tconst int realto = to < anum ? to + _size : to;\n\t\t\tamin = min(amin, realto);\n\t\t\tif (amin < realfrom) {\n\t\t\t\tamin = realto;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t\tif (amin != 1e5)num++;\n\t\tans = min(ans, num);\n\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, w, h;\nvector<pi> v;\n\npi calc(int x, int y, int w, int h){\n\tint z = 2 * (w + h);\n\tint a = x > y ? z - (x - y) : y - x;\n\tint b = x + y;\n\treturn mp(a, b);\n}\n\nint solve(int start){\n\tint end = start + n;\n\tint cnt = 1, pos = v[start].first;\n\tfor(int i = start; i < end; i++){\n\t\tif(v[i].second <= pos) continue;\n\t\tcnt++;\n\t\tpos = v[i].first;\n\t}\n\treturn cnt;\n}\n\nint main(){\n\tcin >> n >> w >> h;\n\tint z = 2 * (w + h);\n\trep(i, n){\n\t\tpi p;\n\t\tchar d;\n\t\tint x, y;\n\t\tcin >> x >> y >> d; y = h - y;\n\t\t\n\t\tif(d == 'W'){\n\t\t\tp = calc(x, y, w, h);\n\t\t}\n\t\telse if(d == 'S'){\n\t\t\tp = calc(h - y, x, h, w);\n\t\t\tp.first  += h;\n\t\t\tp.second += h;\n\t\t}\n\t\telse if(d  == 'E'){\n\t\t\tp = calc(w - x, h - y, w, h);\n\t\t\tp.first  += w + h;\n\t\t\tp.second += w + h;\n\t\t}\n\t\telse{\n\t\t\tp = calc(y, w - x, h, w);\n\t\t\tp.first  += w + 2 * h;\n\t\t\tp.second += w + 2 * h;\n\t\t}\n\t\tint l = p.first % z, r = p.second % z;\n\t\tif(l > r) r += z;\n\t\t\n\t\t//cerr<<\"l: \"<<l<<\" r: \"<<r<<endl;\n\t\t\n\t\tv.pb(mp(r, l));\n\t}\n\tsort(all(v));\n\trep(i, n) v.pb(mp(v[i].first + z, v[i].second + z));\n\tint ans = inf;\n\trep(i, n) ans = min(ans, solve(i));\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\nstruct Range{\n    int b, e;\n    bool operator < (const Range& r) const {\n        if(b != r.b) return b < r.b;\n        return e < r.e;\n    }\n};\nint N, W, H;\nint solve(vector<Range> ranges) {\n    sort(ranges.begin(), ranges.end());\n    vector<Range> rs;\n    vector<Range> rs2;\n    const int L = 2 * (W + H);\n    REP(i, ranges.size()) {\n        if(rs.empty() || rs.back().e < ranges[i].e) {\n            rs.push_back(ranges[i]);\n            rs2.push_back({ranges[i].b + L, ranges[i].e + L});\n        }\n    }\n    REP(i, rs2.size()) rs.push_back(rs2[i]);\n    sort(rs.begin(), rs.end());\n    int n = rs.size() / 2;\n    int ans = INT_MAX;\n    // cout << \"L: \" << L << endl;\n    for(int s = 0; s < n; s++) {\n        int sub = 0;\n        // cout << \"s: \" << s << endl;\n        for(int i = s; i < 2 * n;) {\n            if(i >= s + n) break;\n            const int take = rs[i].e;\n            // cout << \"take: \" << take << endl;\n            while(i < s + n && rs[i].b <= take && take <= rs[i].e) {\n                // cout << \"ok: \" << i << endl;\n                i++;\n            }\n            sub++;\n        }\n        // cout << sub << endl;\n        ans = min(ans, sub);\n    }\n    return ans;\n}\nvoid move(int& x, int& y, int dx, int dy) {\n    int t = INT_MAX;\n    if(dx == -1) t = min(t, x);\n    if(dx == +1) t = min(t, (W-1) - x);\n    if(dy == -1) t = min(t, y);\n    if(dy == +1) t = min(t, (H-1) - y);\n    x += t * dx;\n    y += t * dy;\n}\nint convert(int x, int y) {\n    if(x == 0 && y == 0) return 0;\n    if(y == 0) {\n        return x;\n    }\n    if(x == W - 1) {\n        return W + y;\n    }\n    if(y == H - 1) {\n        return W + H + (W - 1 - x);\n    }\n    assert(x == 0);\n    return W + H + W + (H - 1 - y);\n}\nint main(){\n    iostream_init();\n    // while(cin >> N >> W >> H) {\n        cin >> N >> W >> H;\n        W++; H++;\n        vector<Range> ranges;\n        REP(i, N) {\n            int x, y;\n            cin >> x >> y;\n            string F;\n            cin >> F;\n            int lx = x, ly = y;\n            int rx = x, ry = y;\n            if(F == \"N\") {\n                // up\n                move(lx, ly, +1, +1);\n                move(rx, ry, -1, +1);\n            } else if(F == \"E\") {\n                // right\n                move(lx, ly, +1, -1);\n                move(rx, ry, +1, +1);\n            } else if(F == \"S\") {\n                // down\n                move(lx, ly, -1, -1);\n                move(rx, ry, +1, -1);\n            } else if(F == \"W\") {\n                // left\n                move(lx, ly, -1, +1);\n                move(rx, ry, -1, -1);\n            }\n            int L = convert(lx, ly);\n            int R = convert(rx, ry);\n            if(L > R) R += 2 * (W + H); // ok ???\n            ranges.push_back({L, R});\n        }\n        // REP(i, ranges.size()) {\n        //     cout << \"(\" << ranges[i].b << \",\" << ranges[i].e << \") \";\n        // }\n        // cout << endl;\n        cout << solve(ranges) << endl;\n    // }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,w,d,mod;\nint sum[400040];\nvector<pair<int,int> >a;\nmain(){\n    cin>>n>>w>>d;\n    mod=2*(d+w);\n    for(int i=0;i<n;i++)\n    {\n        int x,y;char f;cin>>x>>y>>f;\n        if(f=='E')\n        {\n            a.push_back(make_pair(d+x+y,(mod-x-d+y)%mod));\n        }\n        else if(f=='W')a.push_back(make_pair((mod-x+d-y)%mod,(mod+d+x-y)%mod));\n        else if(f=='N')a.push_back(make_pair((mod-x-d+y)%mod,(mod-x+d-y)%mod));\n        else a.push_back(make_pair(d+x-y,d+x+y));\n    }\n    for(int i=0;i<n;i++)\n    {\n        if(a[i].second<a[i].first)\n        {\n            sum[0]++;\n            sum[a[i].second+1]--;\n            sum[a[i].first]++;\n            sum[mod]--;\n        }\n        else\n        {\n            sum[a[i].first]++;\n            sum[a[i].second+1]--;\n        }\n    }\n    for(int i=1;i<=mod;i++)sum[i]+=sum[i-1];\n    int maxsum=0,id;\n    for(int i=0;i<=mod;i++)\n    {\n        if(maxsum<=sum[i])maxsum=sum[id=i];\n    }\n    int ans=1;\n    vector<pair<int,int> >m;\n    for(int i=0;i<n;i++)\n    {\n        bool inc=0;\n        if(a[i].first<=id&&id<=a[i].second)inc=1;\n        else if(a[i].first>a[i].second&&(id<=a[i].second||id>=a[i].first))inc=1;\n        if(!inc)\n        {\n            m.push_back(make_pair((a[i].second+mod-id)%mod,(a[i].first+mod-id)%mod));\n        }\n    }\n    sort(m.begin(),m.end());\n    int p=-114514;\n    for(int i=0;i<m.size();i++)\n    {\n        if(m[i].second>p)\n        {\n            ans++;\n            p=m[i].first;\n        }\n    }\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\n#include <ctype.h> // isdigit\n#include <cassert>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(u) begin(u),end(u)\n#define PB push_back\n#define LE(n,m) ((n) < (m) + EPS * (abs(n) + abs(m)))\n#define GE(n,m) ((n) + EPS * (abs(n) + abs(m)) > (m))\n#define LT(n,m) ((n) + EPS * (abs(n) + abs(m)) < (m))\n#define GT(n,m) ((n) > (m) + EPS * (abs(n) + abs(m)))\n#define EQ(n,m) (abs((n)-(m)) < EPS * (abs(n) + abs(m)))\n\ntypedef long long int ll;\nconst int INF = (1<<30) - 1;\nconst double EPS = 1e-9;\nconst int MOD = 1000000007;\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    //cout.setf(ios::fixed);\n    \n    int N, W, D;\n    cin >> N >> W >> D;\n    int L = 2 * (W + D);\n    //end, start\n    vector<pair<int, int>> lines;\n    \n    for(int i=0; i<N; i++){\n        int x, y; string f;\n        cin >> x >> y >> f;\n        int nx, ny;\n        if(f == \"S\"){\n            nx = x;\n            ny = y;\n        }\n        if(f == \"E\"){\n            nx = y + W;\n            ny = W - x;\n        }\n        if(f == \"N\"){\n            nx = 2*W + D - x;\n            ny = D - y;\n        }\n        if(f == \"W\"){\n            nx = -y;\n            ny = x;\n        }\n        lines.emplace_back(nx + ny, nx - ny);\n    }\n    sort(lines.begin(), lines.end());\n    \n    int ans = INF;\n    for(int s=0; s<N; s++){ //????????°???????§??????¨?????????\n        int tans = 0;\n        int p = lines[0].first;\n        for(int i=0; i<N; i++){\n            while(i<N && lines[i%N].second <= p) i++;\n            p = lines[i--%N].first;\n            tans++;\n        }\n        ans = min(ans, tans);\n        \n        lines[0].first += L;\n        lines[0].second += L;\n        sort(lines.begin(), lines.end());\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P1;\nint n,w,d,x,y,ans;\nvector<P1> v;\nchar f;\nstack<int> q;\nbool used[N];\n\nvoid add_point(int num){\n  if(f=='N'){\n    if(x+y<d)v.push_back(P1(P(x+y+w*2+d,0),num));\n    else v.push_back(P1(P(x+y-d,0),num));\n    if(w+y-x<d)v.push_back(P1(P(d-(w+y-x)+w,1),num));\n    else v.push_back(P1(P(d-(y-x),1),num));\n  }\n  if(f=='E'){\n    if(d-(y-x)<w)v.push_back(P1(P(d-(y-x),0),num));\n    else v.push_back(P1(P(d-(w+(y-x))+w,0),num));\n    if(y+x<w)v.push_back(P1(P(w-(y+x)+w+d,1),num));\n    else v.push_back(P1(P(d-(-w+y+x)+w,1),num));\n  }\n  if(f=='S'){\n    if(0<=-w+y+x)v.push_back(P1(P(d-(-w+y+x)+w,0),num));\n    else v.push_back(P1(P(w-(y+x)+w+d,0),num));\n    if(0<=y-x)v.push_back(P1(P(y-x+w*2+d,1),num));\n    else v.push_back(P1(P(w-(-(y-x))+w+d,1),num));\n  }\n  if(f=='W'){\n    if(0<=-(y-x))v.push_back(P1(P(w-(-(y-x))+w+d,0),num));\n    else v.push_back(P1(P(y-x+w*2+d,0),num));\n    if(0<=y+x-d)v.push_back(P1(P(y+x-d,1),num));\n    else v.push_back(P1(P(y+x+w*2+d,1),num));\n  }\n}\n\nbool usednum[500000];\n\nvoid solve(){\n  int len=v.size(),cnt;\n  for(int i=0;i<len;i++){\n    memset(used,0,sizeof(used));\n    memset(usednum,0,sizeof(usednum));\n    if(v[i].first.second)continue;\n    cnt=0;\n    for(int j=i;j<len+i;j++){\n      int idx=j%len;\n      if(used[v[idx].second])continue;\n      if(!v[idx].first.second)q.push(v[idx].second);\n      else{\n\tcnt++;\n\tif(usednum[v[idx].first.first])cnt--;\n\tusednum[v[idx].first.first]=true;\n\tused[v[idx].second]=true;\n\twhile(!q.empty()){\n\t  int num=q.top(); q.pop();\n\t  used[num]=true;\n\t}\n      }\n    }\n    ans=min(ans,cnt);\n  }\n}\n\nint main(){\n  cin>>n>>w>>d;\n  for(int i=0;i<n;i++){\n    cin>>x>>y>>f;\n    add_point(i);\n  }\n  sort(v.begin(),v.end());\n  /*  for(int i=0;i<v.size();i++)\n      cout<<v[i].first.first<<' '<<v[i].first.second<<' '<<v[i].second<<endl;*/\n  ans=(1e9);\n  solve();\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\n#define EPS (1e-8)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\nconst double PI=4*atan(1.0);\n\ntypedef complex<double> P;\n\n// ??????\ndouble dot(const P &a, const P &b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// ??????\ndouble cross(const P &a, const P &b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distance_ls_p(const P &a, const P &b, const P &c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nint is_intersected_ls(const P &a1, const P &a2, const P &b1, const P &b2) {\n  // ????????????????????´???\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    // ????????¨???????????¢???0??????????????£????????????\n    if(EQ(distance_ls_p(a1,a2,b1),0)||EQ(distance_ls_p(a1,a2,b2),0))\n      return 1;\n    return 0;\n  }\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n    ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nP intersection_ls(const P &a1, const P &a2, const P &b1, const P &b2) {\n  // ????????????????????´????????????????????£???????????????????????£???????????¨????????????\n  // ?????£??¨???x??§?¨?????°??????????????????????\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    // ????????¨???????????¢???0??????????????£????????????\n    if(EQ(distance_ls_p(a1,a2,b1),0)||EQ(distance_ls_p(a1,a2,b2),0)){\n      // x??§?¨????a1<a2,b1<b2??¨????????????????????????\n      P la1=a1,la2=a2;\n      P lb1=b1,lb2=b2;\n      if(a1.real()>a2.real())swap(la1,la2);\n      if(b1.real()>b2.real())swap(lb1,lb2);\n      P res;\n      if(la1.real()>lb1.real())res=la1;\n      else res=lb1;\n      return res;\n    }\n    // ????????£???????????´??????...?\n    else{\n      // ??????????±?????????????????????§?????????\n      // ????????¢??°?????????????????????????????????????????¨????????????\n      return P(-1,-1);\n    }\n  }\n  else{\n    P b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n  }\n}\n\n// ??§?¨?????????¢(??§?¨?p???????????????,???????¨??????????a(????????¢???)?????¢)\nP roundPoint(const P &p,double a){\n  return P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n\nbool used[1010];\ntypedef tuple<double,int,int> tpl;\n\n// place, start or end, idx???????????????\n\nint N,W,D;\nint XS[1001];\nint YS[1001];\nchar AS[1001];\nint main(){\n\n  cin>>N>>W>>D;\n  for(int i=0;i<N;i++)cin>>XS[i]>>YS[i]>>AS[i];\n  vector<pair<double, double> > poses;\n  // ???????£????????????????, ??§?¨????????????????????????????\n  for(int i=0;i<N;i++){\n    P ang_v;\n    // ????????§????????????????¨????????????????\n    if(AS[i]=='W')ang_v = P(-1, 0);\n    else if(AS[i]=='E')ang_v = P(1, 0);\n    else if(AS[i]=='N')ang_v = P(0, 1);\n    else if(AS[i]=='S')ang_v = P(0, -1);\n    ang_v *= 10000000;\n\n    // 2?????????????????????????¨????????????????\n    P ps[2] = {roundPoint(ang_v, PI/4) + P(XS[i], YS[i]), roundPoint(ang_v, -PI/4) + P(XS[i], YS[i])};\n    // ??????????????¶??????????????????????????????\n    const P corner[4] = {P(0,0), P(0,D), P(W,D), P(W,0)};\n    double ds[2];\n    for(int k=0;k<2;k++){\n        double sum_dist = 0;\n        double dist = 0;\n        for(int j = 0; j < 4; j++){\n            const P &p1 = corner[j];\n            const P &p2 = corner[(j+1)%4];\n            // p1-p2???????????¨ps[j]?????????????????????????????????\n            // cross????????????, ????????§?¨?????±???????\n            if(is_intersected_ls(p1, p2, ps[k], P(XS[i], YS[i]))){\n                // ??§?¨???¨,corner[j]??¨????????¢????¨??????????\n                P c = intersection_ls(p1, p2, ps[k], P(XS[i], YS[i]));\n                dist = sum_dist + abs(c-corner[j]);\n                break;\n            }\n            else{\n                sum_dist += abs(p2-p1);\n                continue;\n            }\n        }\n        // sum_dist???2(D+W)?????£??????, 0????£???£????????????\n        if(EQ(2*(D+W), dist)){\n            dist = 0;\n        }\n        ds[k] = dist;\n    }\n    \n    if(ds[0] > ds[1])\n        ds[1] += 2*(W+D);\n\n    poses.push_back(make_pair(ds[0], ds[1]));\n  }\n\n  // vector???????????????2??????????????????\n  for(int i=0;i<N;i++){\n      // ??????????????????+2*(W+D)???????????????push_back\n      pair<double, double> pd = poses[i];\n      pd.first += 2*(W+D);\n      pd.second += 2*(W+D);\n      poses.push_back(pd);\n  }\n  \n  int min_ans = 1<<29;\n  // ?????¨?????£??????, ??????????§???°???????±???????, ????????????n?????????????????°????¨??????????\n  for(int start = 0; start < N; start++){\n      memset(used,0,sizeof(used));\n      vector<tuple<double, int, int> > vec;\n      for(int i=0;i<N;i++){\n          pair<double,double> t = poses[start + i];\n          vec.push_back(make_tuple(t.first, 0, i));\n          vec.push_back(make_tuple(t.second, 1, i));\n      }\n      // start??????????????????end????????£????????????????´???????????????????\n      queue<int> q;\n      // ?????¢??§?????????\n      sort(vec.begin(), vec.end());\n      \n      int vec_idx = 0;\n      int ans = 0;\n      // ???????????¢?????¨??????????????????????????????\n      while((int)vec.size() != vec_idx){\n          // ???????????¢??§????´??????????????????????\n          double d = get<0>(vec[vec_idx]);\n          vector<int> vs[2];\n          while((int)vec.size()!=vec_idx && EQ(get<0>(vec[vec_idx]), d)){\n              vs[get<1>(vec[vec_idx])].push_back(get<2>(vec[vec_idx]));\n              vec_idx++;\n          }\n          // start???????´???????????????????\n          // start???????´????, queue????????????\n          for(int i=0;i<(int)vs[0].size();i++){\n              int idx = vs[0][i];\n              q.push(idx);\n          }\n          \n          // end???????´????, ?????§???????????????????????°continue\n          for(int i=0;i<(int)vs[1].size();i++){\n              int idx = vs[1][i];\n              if(used[idx])continue;\n              else{\n                  // ?????????????????£????????????????????§start???????´?????§£???????????????\n                  // ????????????end????§£?????????????????§??????????????????\n                  ans++;\n                  while(q.size()){\n                      const int a = q.front(); q.pop();\n                      used[a] = true;\n                  }\n                  break;\n              }\n          }\n      }\n      min_ans = min(min_ans, ans);\n  }\n\n  cout<<min_ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\n#define fst first\n#define snd second\n\nint n, w, h, len; \n\nint solve(vector<pair<double, double>> & lr){\n    int ret = n;\n    rep(i, n){\n        int cur = 1;\n        double rs = lr[i].snd, frs = rs;\n\n        range(_, 1, n){\n            int j = (j + _) % n;\n\n            double cl = lr[j].fst, cr = lr[j].snd;\n            if(cl >= cr){\n                if((cl - len <= rs and rs <= cr) or (cl <= rs and rs <= cr + len)){\n                    continue;\n                }\n            }\n            else {\n                if(cl <= rs and rs <= cr){\n                    continue;\n                }\n            }\n            if(cl >= cr){\n                if((cl - len <= frs and frs <= cr) or (cl <= frs and frs <= cr + len)){\n                    continue;\n                }\n            }\n            else {\n                if(cl <= frs and frs <= cr){\n                    continue;\n                }\n            }\n\n            cur++;\n            rs = cr;\n        }\n\n        ret = min(ret, cur);\n    }\n\n    return ret;\n}\n\nint main(void){\n    cin >> n >> w >> h;\n\n    vector<pair<double, double>> lr(n);\n    len = 2 * w + 2 * h;\n    for(auto & e : lr){\n        int x, y; cin >> x >> y;\n        y = h - y;\n        char f; cin >> f;\n\n        int o, p;\n        switch(f){\n        case 'N': o = x;                 p = y;     break;\n        case 'E': o = w + y;             p = w - x; break;\n        case 'S': o = 2 * w + h - x;     p = h - y; break;\n        case 'W': o = 2 * w + 2 * h - y; p = x;     break;\n        }\n\n        e.fst = (o - p + len) % len;\n        e.snd = (o + p) % len;\n    }\n\n    sort(begin(lr), end(lr));\n    int res = solve(lr);\n\n    for(auto & e : lr){\n        swap(e.fst, e.snd);\n        e.fst = len - e.fst;\n        e.snd = len - e.snd;\n    }\n    sort(begin(lr), end(lr));\n    res = min(res, solve(lr));\n\n    cout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tvector<pii> v;\n\tREP(i, n)\n\t{\n\t\tint x, y; char d;\n\t\tcin >> x >> y >> d;\n\t\tif (d == 'W')\n\t\t{\n\t\t\tint rh = x;\n\t\t\tint r = y + rh;\n\t\t\tint l = y - rh;\n\t\t\tv.emplace_back(r, l);\n\t\t}\n\t\tif (d == 'N')\n\t\t{\n\t\t\tint rh = h - y;\n\t\t\tint r = h + x + rh;\n\t\t\tint l = h + x - rh;\n\t\t\tv.emplace_back(r, l);\n\t\t}\n\t\tif (d == 'E')\n\t\t{\n\t\t\tint rh = w - x;\n\t\t\tint r = h + w + (h - y) + rh;\n\t\t\tint l = h + w + (h - y) - rh;\n\t\t\tv.emplace_back(r, l);\n\t\t}\n\t\tif (d == 'S')\n\t\t{\n\t\t\tint rh = y;\n\t\t\tint r = h * 2 + w + (w - x) + rh;\n\t\t\tint l = h * 2 + w + (w - x) - rh;\n\t\t\tv.emplace_back(r, l);\n\t\t}\n\t}\n\tsort(ALL(v));\n\tint len = (h + w) * 2;\n\tint ans = INF;\n\tREP(i, n)\n\t{\n\t\tauto tv = v;\n\t\tREP(j, n)\n\t\t{\n\t\t\tif (tv[j].first < v[i].first)\n\t\t\t{\n\t\t\t\ttv[j].first += len;\n\t\t\t\ttv[j].second += len;\n\t\t\t}\n\t\t}\n\t\tsort(ALL(tv));\n\t\tint tmp = tv[0].first;\n\t\tint cnt = 1;\n\t\tREP(j, n)\n\t\t{\n\t\t\tif (tv[j].second > tmp)\n\t\t\t{\n\t\t\t\ttmp = tv[j].first;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tchmin(ans, cnt);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class U, class V> ostream& operator<<(ostream& os, const pair<U, V>& p) {\n        return os << \"(\" << p.first << \",\" << p.second << \")\";\n    }\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int N, W, D;\n    int p(int x, int y) {\n        if (x == 0) return y;\n        else if (x == W) return D + W + (D - y);\n        else if (y == D) return D + x;\n        else { assert(y == 0);\n            return D + W + D + (W - x);\n        }\n    }\n    int p(const pair<int, int>& s) {\n        return p(s.first, s.second);\n    }\n\n    map<string, int> M;\n    void init() { M[\"W\"] = 0; M[\"N\"] = 1; M[\"E\"] = 2; M[\"S\"] = 3; }\n\n    pair<int, int> cr(int x, int y, string f) {\n        vector< pair<int, int> > ds;\n\n        if (x - y > 0) ds.push_back(make_pair(x - y, 0));\n        else ds.push_back(make_pair(0, y - x));\n\n        if (x - (D - y) > 0) ds.push_back(make_pair(x - (D - y), D));\n        else ds.push_back(make_pair(0, x + y));\n\n        if (x + D - y < W) ds.push_back(make_pair(x + D - y, D));\n        else ds.push_back(make_pair(W, y + W - x));\n\n        if (x + y < W) ds.push_back(make_pair(x + y, 0));\n        else ds.push_back(make_pair(W, y - (W - x)));\n\n        //cout << make_pair(x, y) << \" -> \" << ds << endl;\n\n        int p0 = p(ds[ M[f] ]);\n        int p1 = p(ds[ (M[f] + 1) % 4 ]);\n        return make_pair(p0, p1);\n    }\n\n    vector< pair<int, int> > V;\n    void input() {\n        init();\n        cin >> N >> W >> D;\n        for (int i = 0; i < N; i++) {\n            int x, y; string f;\n            cin >> x >> y >> f;\n            V.push_back(cr(x, y, f));\n        }\n        //cout << V << endl;\n    }\n\n    const int INF = 1<<28;\n\n    bool contain(pair<int, int> s, int k) {\n        int x = 2 * (W + D);\n        s.first %= x; s.second %= x;\n        k %= x;\n        if (s.first > s.second) s.second += 2 * (W + D);\n        return (s.first <= k && k <= s.second) || (s.first <= k + x && k + x <= s.second);\n    }\n\n    int calc(int index) {\n        int k = V[index].second;\n        vector< pair<int, int> > T;\n        for (int i = 0; i < N; i++) {\n            if (!contain(V[i], k)) {\n                int x = V[i].first, y = V[i].second;\n                if (x > y) y += 2 * (W + D);\n                if (x < k) x += 2 * (W + D);\n                if (y < k) y += 2 * (W + D);\n                T.push_back(make_pair(x, y));\n            }\n        }\n        sort(T.begin(), T.end());\n        int c = 0;\n        for (int i = 0, a = 0; a < T.size(); ) {\n            int t = T[a].second;\n            while (i < T.size() && T[i].first <= t) {\n                i++;\n                t = min(t, T[i].second);\n            }\n            //cout << make_pair(a, i) << \" \" << make_pair(T[a].first, t) << endl;\n            a = i;\n            c++;\n        }\n        //cout << \"k: \" << k << \" \" << \"T: \" << T  << \" c: \" << c << endl;\n        return c;\n    }\n\n    void solve() {\n        int ans = INF;\n        for (int i = 0; i < V.size(); i++) {\n            ans = min(ans, calc(i) + 1);\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntypedef tuple<int,int,int> tiii;\n\nint main()\n{\n\tfor(int n,w,h;cin>>n>>w>>h && n|w|h;){\n\t\tint p=2*(w+h);\n\t\tvector<pii> rs;\n\t\trep(i,n){\n\t\t\tint x,y; string d; cin>>x>>y>>d;\n\t\t\tif(d==\"N\"){\n\t\t\t\tint l=x-(h-y),r=x+(h-y);\n\t\t\t\trs.emplace_back(l,r);\n\t\t\t}\n\t\t\tif(d==\"E\"){\n\t\t\t\tint b=y-(w-x),t=y+(w-x);\n\t\t\t\trs.emplace_back(w+(h-t),w+(h-b));\n\t\t\t}\n\t\t\tif(d==\"S\"){\n\t\t\t\tint l=x-y,r=x+y;\n\t\t\t\trs.emplace_back(w+h+(w-r),w+h+(w-l));\n\t\t\t}\n\t\t\tif(d==\"W\"){\n\t\t\t\tint b=y-x,t=y+x;\n\t\t\t\trs.emplace_back(w+h+w+b,w+h+w+t);\n\t\t\t}\n\t\t}\n\t\trep(i,n) if(rs[i].first<0){\n\t\t\trs[i].first+=p;\n\t\t\trs[i].second+=p;\n\t\t}\n\t\t\n\t\tint res=INF;\n\t\trep(i,n){\n\t\t\tpriority_queue<tiii,vector<tiii>,greater<tiii>> pq;\n\t\t\trep(j,n){\n\t\t\t\tif(rs[j].first>=rs[i].first){\n\t\t\t\t\tpq.emplace(rs[j].first,0,j);\n\t\t\t\t\tpq.emplace(rs[j].second,1,j);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tpq.emplace(rs[j].first+p,0,j);\n\t\t\t\t\tpq.emplace(rs[j].second+p,1,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tset<int> require;\n\t\t\tint cnt=0;\n\t\t\twhile(pq.size()){\n\t\t\t\tint l,s,j; tie(l,s,j)=pq.top(); pq.pop();\n\t\t\t\tif(s==0){ // open\n\t\t\t\t\trequire.insert(j);\n\t\t\t\t}\n\t\t\t\telse{ // close\n\t\t\t\t\tif(require.count(j)){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\trequire.clear();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres=min(res,cnt);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> PII;\n#define MP make_pair\n\nint N, W, H;\nint f(int x, int y){\n  if(y == 0) return x;\n  if(x == W) return y+W;\n  if(y == H) return W-x+W+H;\n  return H-y+W+H+W;\n}\n\nint main(){\n  cin >> N >> W >> H;\n  vector<PII> range(N*2);\n  for(int i=0;i<N;++i){\n\tint x, y; char c; cin >> x >> y >> c;\n\ty = H - y;\n\tvector<int> xs(4);\n\tint d = min(x, y);\n\txs[0] = f(x-d, y-d);\n\td = min(W-x, y);\n\txs[1] = f(x+d, y-d);\n\td = min(W-x, H-y);\n\txs[2] = f(x+d, y+d);\n\td = min(x, H-y);\n\txs[3] = f(x-d, y+d);\n\tfor(int i=0;i<4;++i)\n\t  if(c == \"NESW\"[i]){\n\t\tc = i;\n\t\tbreak;\n\t  }\n\trange[i] = MP(xs[c], xs[(c+1)%4]+1);\n\t//cout << range[i].first << \",\" << range[i].second << endl;\n  }\n  int HW = 2 * (H+W);\n  for(int i=0;i<N;++i){\n\tif(range[i].first >= range[i].second){\n\t  range[i] = MP(range[i].first, range[i].second+HW);\n\t  range[N+i] = MP(range[i].first+HW, 2*HW+1);\n\t}\n\telse\n\t  range[N+i] = MP(range[i].first+HW, range[i].second+HW);\n  }\n  sort(range.begin(), range.end());\n  //for(int i=0;i<N*2;++i)\n  //cout << range[i].first << \",\" << range[i].second << endl;\n\n  int ans = 1e9;\n  for(int i=0;i<N;++i){\n\tint tmp = 0;\n\tint last = -1;\n\tfor(int j=i;j<i+N;++j){\n\t  if(range[j].second <= last)\n\t\tlast = range[j].second;\n\t  else if(last <= range[j].first){\n\t\t++tmp;\n\t\tlast = range[j].second;\n\t  }\n\t}\n\tans = min(ans, tmp);\n  }\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <tuple>\n\nusing namespace std;\ntypedef pair<int, int> pii;\nstatic const int INF = 1000000000;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tvector<pii> ranges(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tint x, y;\n\t\tstring f;\n\t\tcin >> x >> y >> f;\n\t\tconst int hw2 = h + w + h + w;\n\t\tconst int lu = y + x;\n\t\tconst int ru = h + x + (h - y);\n\t\tconst int rd = h + w + (h - y) + (w - x);\n\t\tconst int ld = h + w + h + (w - x) + y;\n\t\tint lo = 0, hi = 0;\n\t\tif(f[0] == 'N'){\n\t\t\tlo = lu; hi = ru;\n\t\t}else if(f[0] == 'E'){\n\t\t\tlo = ru; hi = rd;\n\t\t}else if(f[0] == 'S'){\n\t\t\tlo = rd; hi = ld;\n\t\t}else if(f[0] == 'W'){\n\t\t\tlo = ld; hi = lu + hw2;\n\t\t}\n\t\tranges[i] = pii(lo, hi);\n\t}\n\tsort(\n\t\tranges.begin(), ranges.end(),\n\t\t[](const pii &a, const pii &b){\n\t\t\treturn (a.second == b.second) ? (a.first < b.first) : (a.second < b.second);\n\t\t});\n\tint answer = INF;\n\tfor(int i = 0; i < n; ++i){\n\t\tconst int hw2 = (h + w) * 2;\n\t\tvector<pii> r;\n\t\tfor(int j = i; j < n; ++j){ r.push_back(ranges[i]); }\n\t\tfor(int j = 0; j < i; ++j){\n\t\t\tr.emplace_back(ranges[i].first + hw2, ranges[i].second + hw2);\n\t\t}\n\t\tint count = 1, last = r[0].second;\n\t\tfor(int j = 0; j < n; ++j){\n\t\t\tif(r[j].first <= last){ continue; }\n\t\t\tif(r[j].second >= r[0].second + hw2){ continue; }\n\t\t\t++count;\n\t\t\tlast = r[j].second;\n\t\t}\n\t\tanswer = min(answer, count);\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,w,d,mod;\nint sum[400040];\nint check[2222];\nvector<pair<int,int> >a;\nmain(){\n    cin>>n>>w>>d;\n    mod=2*(d+w);\n    for(int i=0;i<n;i++)\n    {\n        int x,y;char f;cin>>x>>y>>f;\n        if(f=='E')\n        {\n            a.push_back(make_pair(d+x+y,(mod-x-d+y)%mod));\n        }\n        else if(f=='W')a.push_back(make_pair((mod-x+d-y)%mod,(mod+d+x-y)%mod));\n        else if(f=='N')a.push_back(make_pair((mod-x-d+y)%mod,(mod-x+d-y)%mod));\n        else a.push_back(make_pair(d+x-y,d+x+y));\n        check[i*2]=a[i].first;\n        check[i*2+1]=a[i].second;\n    }\n    int ans=1e9;\n    for(int index=0;index<2*n;index++)\n    {\n        int id=check[index];\n        vector<pair<int,int> >m;\n        int now=1;\n        for(int i=0;i<n;i++)\n        {\n            bool inc=0;\n            if(a[i].first<=id&&id<=a[i].second)inc=1;\n            else if(a[i].first>a[i].second&&(id<=a[i].second||id>=a[i].first))inc=1;\n            if(!inc)\n            {\n                m.push_back(make_pair((a[i].second+mod-id)%mod,(a[i].first+mod-id)%mod));\n            }\n        }\n        sort(m.begin(),m.end());\n        int p=-114514;\n        for(int i=0;i<m.size();i++)\n        {\n            if(m[i].second>p)\n            {\n                now++;\n                p=m[i].first;\n            }\n        }\n        ans=min(ans,now);\n    }\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <tuple>\n\nusing namespace std;\ntypedef pair<int, int> pii;\nstatic const int INF = 1000000000;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tvector<pii> ranges;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x, y;\n\t\tstring f;\n\t\tcin >> x >> y >> f;\n\t\tconst int lu = y + x;\n\t\tconst int ru = h + x + (h - y);\n\t\tconst int rd = h + w + (h - y) + (w - x);\n\t\tconst int ld = h + w + h + (w - x) + y;\n\t\tint lo = 0, hi = 0;\n\t\tif(f[0] == 'N'){\n\t\t\tlo = lu; hi = ru;\n\t\t}else if(f[0] == 'E'){\n\t\t\tlo = ru; hi = rd;\n\t\t}else if(f[0] == 'S'){\n\t\t\tlo = rd; hi = ld;\n\t\t}else if(f[0] == 'W'){\n\t\t\tlo = ld; hi = lu + (h + w) * 2;\n\t\t}\n\t\tconst int hw2 = h + w + h + w;\n\t\tranges.emplace_back(lo, hi);\n\t\tranges.emplace_back(lo + hw2, hi + hw2);\n\t}\n\tsort(\n\t\tranges.begin(), ranges.end(),\n\t\t[](const pii &a, const pii &b){\n\t\t\treturn (a.second == b.second) ? a.first < b.first : a.second < b.second;\n\t\t});\n\tint answer = INF;\n\tfor(int i = 0; i < n; ++i){\n\t\tvector<pii> r(ranges.begin() + i, ranges.begin() + i + n);\n\t\tconst int hw2 = (h + w) * 2;\n\t\tint count = 1, last = r[0].second;\n\t\tfor(int j = 0; j < n; ++j){\n\t\t\tif(r[j].first <= last){ continue; }\n\t\t\tif(r[j].second >= r[0].second + hw2){ continue; }\n\t\t\t++count;\n\t\t\tlast = r[j].second;\n\t\t}\n\t\tanswer = min(answer, count);\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint N,W,H,L;\nvector<P> t;\n\nbool check(P p,int a){\n  if(p.first<p.second)\n    return (p.first<=a&&a<=p.second);\n  return (p.first<=a||a<=p.second);\n}\nint solve(int si){\n  int res=1,last=t[si].second;\n  for(int i=si;i<si+N;i++){\n    if(check(t[i],last)) continue;\n    res++;\n    last=t[i].second;\n  }\n  return res;\n}\nint main(){\n  cin>>N>>W>>H;\n  L=W+W+H+H;\n  for(int i=0;i<N;i++){\n    int x,y,a,b;\n    char ch;\n    cin>>x>>y>>ch;\n    if(ch=='N'){\n      a = (x+y+L)%L;\n      b = (H+x-y+H)%L;\n    }\n    if(ch=='E'){\n      a = (H+H-y+x+L)%L;\n      b = (L-y-x)%L;\n    }\n    if(ch=='S'){\n      a = (L-x-y+L)%L;\n      b = (L-x+y)%L;\n    }\n    if(ch=='W'){\n      a = (y-x+L)%L;\n      b = (y+x)%L;\n    } \n    t.push_back(P(a,b));\n  }\n  for(int i=0;i<N;i++) swap(t[i].first,t[i].second);\n  sort(t.begin(),t.end());\n  for(int i=0;i<N;i++) t.push_back(t[i]);\n  for(int i=0;i<N+N;i++) swap(t[i].first,t[i].second);\n  int ans = N;\n  for(int i=0;i<N;i++)ans = min(ans,solve(i));\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef pair< int, int > pii;\n\npii getRange(int w, int d, int x, int y, char f) {\n\tif (f == 'N') {\n\t\tint a = x - (d - y), b = (w - x) - (d - y);\n\t\treturn pii(a, w - b);\n\t}\n\t\n\tif (f == 'E') {\n\t\tint a = (d - y) - (w - x), b = y - (w - x);\n\t\treturn pii(w + a, w + d - b);\n\t}\n\t\n\tif (f == 'S') {\n\t\tint a = (w - x) - y, b = x - y;\n\t\treturn pii(w + d + a, 2*w + d - b);\n\t}\n\t\n\tif (f == 'W') {\n\t\tint a = y - x, b = (d - y) - x;\n\t\treturn pii(2*w + d + a, 2*w+2*d - b);\n\t}\n\t\n\treturn pii(-1,-1);\n}\n\nint solve(int n, vector< vector< int > >& collision, int s) {\n\tint ret = 0;\n\tvector< bool > bad(n, false);\n\tfor_(i,0,n) {\n\t\tint v = (s + i) % n;\n\t\tif (bad[v]) continue;\n\t\t++ret;\n\t\tfor (int u : collision[v]) bad[u] = true;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint n, w, d;\n\tcin >> n >> w >> d;\n\t\n\tint UB = 2*w + 2*d;\n\tvector< pii > vp;\n\tfor_(i,0,n) {\n\t\tint x, y; char f;\n\t\tcin >> x >> y >> f;\n\t\tpii p = getRange(w, d, x, y, f);\n\t\tvp.push_back(p);\n\t\tvp.push_back(pii(p.first + UB, p.second + UB));\n\t}\n\t\t\n\tvector< vector< int > > collision(n, vector< int >());\n\tfor_(i,0,2*n) for_(j,0,2*n) {\n\t\tif (i / 2 == j / 2) continue;\n\t\tif (vp[i].first <= vp[j].second && vp[j].first <= vp[i].second) collision[i/2].push_back(j/2);\n\t}\n\t\n\tcout << max(solve(n, collision, 0), solve(n, collision, 1)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\nusing namespace std;\nint n,w,d;\nchar tem[10];\nint a[1000+10][2];\nint get(int x,int y,int type)\n{\n    if(type==0)\n    {\n        int xx=min(x,y);\n        x-=xx;y-=xx;\n        if(x==0)return y;\n        else return w+w+d+d-x;\n    }\n    else if(type==1)\n    {\n        int xx=min(x,d-y);\n        x-=xx;\n        y+=xx;\n        if(x==0)return y;\n        else return d+x;\n    }\n    else if(type==2)\n    {\n        int xx=min(w-x,d-y);\n        x+=xx;y+=xx;\n        if(y==d)return d+x;\n        else return d+w+d-y;\n    }\n    else if(type==3)\n    {\n        int xx=min(w-x,y);\n        x+=xx;y-=xx;\n        if(x==w)return w+d+d-y;\n        else return w+d+d+w-x;\n    }\n}\nint ans=0;\nstruct P\n{\n    int x;\n    bool l;\n    int ori;\n    bool operator <(const P &b)const\n    {\n        if(x!=b.x)return x<b.x;\n        else return (l!=b.l)&&l;\n    }\n}p[4000+10];\nbool vis[1000+10];\nint sta[4000+10];\nvoid solve(int st)\n{\n    int res=1;\n    int tail=0;\n    for(int i=1;i<=n;i++)\n    {\n        vis[i]=false;\n        int new1=a[i][0]-st,new2=a[i][1]-st;\n        while(new1<=-(w+w+d+d)){new1+=w+w+d+d;new2+=w+w+d+d;}\n        if(new1<=0&&new2>=0)continue;\n        p[tail++]=(P){new1,true,i};\n        p[tail++]=(P){new2,false,i};\n    }\n    sort(p,p+tail);\n    int m=tail;\n    tail=0;\n    for(int i=0;i<m;i++)\n    {\n        if(vis[p[i].ori])continue;\n        if(p[i].l)\n        {\n            sta[tail++]=p[i].ori;\n        }\n        else\n        {\n            res++;\n            while(tail)vis[sta[--tail]]=true;\n        }\n    }\n    ans=min(ans,res);\n}\nint main()\n{\n    scanf(\"%d%d%d\",&n,&w,&d);\n    for(int i=1;i<=n;i++)\n    {\n        int x,y;\n        scanf(\"%d%d%s\",&x,&y,tem);\n        if(tem[0]=='W')a[i][0]=get(x,y,0),a[i][1]=get(x,y,1);\n        else if(tem[0]=='N')a[i][0]=get(x,y,1),a[i][1]=get(x,y,2);\n        else if(tem[0]=='E')a[i][0]=get(x,y,2),a[i][1]=get(x,y,3);\n        else if(tem[0]=='S')a[i][0]=get(x,y,3),a[i][1]=get(x,y,0);\n        if(a[i][0]>a[i][1])a[i][0]-=w+w+d+d;\n    }\n    ans=0x3f3f3f3f;\n    for(int i=1;i<=n;i++)\n    {\n        solve(a[i][0]);solve(a[i][1]);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef pair< int, int > pii;\n\npii getRange(int w, int d, int x, int y, char f) {\n\tif (f == 'N') {\n\t\tint a = x - (d - y), b = (w - x) - (d - y);\n\t\treturn pii(a, w - b);\n\t}\n\t\n\tif (f == 'E') {\n\t\tint a = (d - y) - (w - x), b = y - (w - x);\n\t\treturn pii(w + a, w + d - b);\n\t}\n\t\n\tif (f == 'S') {\n\t\tint a = (w - x) - y, b = x - y;\n\t\treturn pii(w + d + a, 2*w + d - b);\n\t}\n\t\n\tif (f == 'W') {\n\t\tint a = y - x, b = (d - y) - x;\n\t\treturn pii(2*w + d + a, 2*w+2*d - b);\n\t}\n\t\n\treturn pii(-1,-1);\n}\n\nint solve(int n, vector< vector< int > >& collision, vector< int >& order, int s) {\n\tint ret = 0;\n\tvector< bool > bad(n, false);\n\tfor_(i,0,n) {\n\t\tint v = order[(s + i) % n];\n\t\tif (bad[v]) continue;\n\t\t++ret;\n\t\tfor (int u : collision[v]) bad[u] = true;\n\t}\n\treturn ret;\n}\n\nstruct Rng {\n\tint id, L, R;\n\tRng(int __id, pii p) : id(__id), L(p.first), R(p.second) {}\n\tbool operator < (const Rng& o) const { return R < o.R; }\n};\n\nint main() {\n\tint n, w, d;\n\tcin >> n >> w >> d;\n\t\n\tint UB = 2*w + 2*d;\n\tvector< Rng > vp;\n\tfor_(i,0,n) {\n\t\tint x, y; char f;\n\t\tcin >> x >> y >> f;\n\t\tpii p = getRange(w, d, x, y, f);\n\t\tvp.push_back(Rng(i, p));\n\t\tvp.push_back(Rng(i, pii(p.first + UB, p.second + UB)));\n\t}\n\t\n\tsort(vp.begin(), vp.end());\n\tvector< int > order, vis(n, false);\n\tfor (Rng r : vp) if (!vis[r.id]) order.push_back(r.id), vis[r.id] = true;\n\t\n\tvector< vector< int > > collision(n, vector< int >());\n\tfor (Rng x : vp) for (Rng y : vp) {\n\t\tif (x.id == y.id) continue;\n\t\tif (x.R >= y.L && x.L <= y.R) collision[x.id].push_back(y.id);\n\t}\n\t\n\tcout << max(solve(n, collision, order, 0), max(solve(n, collision, order, 1), solve(n, collision, order, 2))) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct data{\n\tint l,r;\n\tdata(){}\n\tdata(int ll,int rr){\n\t\tl=ll;\n\t\tr=rr;\n\t}\n\tbool operator<(const data &d)const{\n\t\treturn r<d.r;\n\t}\n};\n\nint n,w,d;\nstring dir=\"NWSE\";\nvector<data> query;\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&w,&d);\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tchar c;\n\t\tscanf(\"%d%d%*c%c\",&x,&y,&c);\n\t\tif(c=='N'){\n\t\t\tint ll=x-(d-y);\n\t\t\tint rr=x+(d+y);\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\tquery.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t\tif(c=='E'){\n\t\t\tint ll=w+d-y-(w-x);\n\t\t\tint rr=w+d-y+(w-x);\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\tquery.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t\tif(c=='S'){\n\t\t\tint ll=w+d+(w-x)-y;\n\t\t\tint rr=w+d+(w-x)+y;\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\tquery.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t\tif(c=='W'){\n\t\t\tint ll=w+d+w+y-x;\n\t\t\tint rr=w+d+w+y+x;\n\t\t\tquery.push_back(data(ll,rr));\n\t\t\tquery.push_back(data(ll+(w+d)*2,rr+(w+d)*2));\n\t\t}\n\t}\n\tsort(query.begin(),query.end());\n\tint res=n;\n\tfor(int i=0;i<n;i++){\n\t\tint tmp=1,last=query[i].r;\n\t\tfor(int j=i;query[j].r<query[i].r+(w+d)*2;j++){\n\t\t\tif(last<query[j].l){\n\t\t\t\ttmp++;\n\t\t\t\tlast=query[j].r;\n\t\t\t}\n\t\t}\n\t\tres=min(res,tmp);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> pii;\nconst int INF = 1e9;\n\nstruct s {\n\tint ps,pp;\n\tint idx;\n\ts(){}\n\ts(int ps_, int pp_, int idx_) {\n\t\tps = ps_; pp = pp_; idx = idx_;\n\t}\n};\n\nbool operator<(s a, s b) {\n\treturn a.pp > b.pp;\n}\n\nint main() {\n\tint n, w, d;\n\tvector<pii> v;\n\tcin >> n >> w >> d;\n\tfor(int i = 0; i < n; i++) {\n\t\tint x, y;\n\t\tchar f;\n\t\tint nx, ny;\n\t\tcin >> x >> y >> f;\n\t\tswitch(f) {\n\t\t\tcase 'N':\n\t\t\t\tnx = w-x;\n\t\t\t\tny = d-y;\n\t\t\t\tbreak;\n\t\t\tcase 'W':\n\t\t\t\tnx = w + d-y;\n\t\t\t\tny = x;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tnx = w+d + x;\n\t\t\t\tny = y;\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\tnx = w+d+w + y;\n\t\t\t\tny = w-x;\n\t\t\t\tbreak;\n\t\t}\n\t\tint ps, pp;\n\t\tps = nx - ny;\n\t\tpp = nx + ny;\n\t\tv.push_back(pii(ps,pp));\n\t}\n\n\tsort(v.begin(), v.end());\n\tint res = 10000;\n\tfor(int k = 0; k < 2; k++) {\n\tfor(int i = 0; i < v.size(); i++) {\n\t\tvector<pii> vv;\n\t\tvector<int> pushed(n,0);\n\n\t\tvv.resize(v.size());\n\t\tfor(int j = 0; j < v.size(); j++) {\n\t\t\tvv[j].fi = (v[(i+j)%n].fi - (k?v[i].se:v[i].fi) + 4*(w+d)) % (2*(w+d));\n\t\t\tvv[j].se = (v[(i+j)%n].se - (k?v[i].se:v[i].fi) + 4*(w+d)) % (2*(w+d));\n\t\t\tif(vv[j].fi > vv[j].se) vv[j].se += 2*(w+d);\n\t\t}\n\t\tsort(vv.begin(), vv.end());\n\t\t/*\n\t\tfor(int j = 0; j < vv.size(); j++)\n\t\t\tcout << vv[j].fi << \",\" << vv[j].se << \" \" ;\n\t\tcout << endl;\n\t\t// */\n\n\t\tfor(int j = 0; j < vv.size(); j++) {\n\t\t\tif(2*(w+d) <= vv[j].se || vv[j].fi == 0) {\n\t\t\t\tpushed[j] = 1;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < pushed.size(); i++)\n\t\t\tcout << pushed[i] << \" \";\n\t\tcout << endl;\n\t\t// */\n\n\t\tpriority_queue<s> pq;\n\t\tint tmp = 1;\n\t\tfor(int j = 0; j < vv.size(); j++)  {\n\t\t\tif(!pushed[j]) {\n\t\t\t\tif(pq.empty() || vv[j].fi <= pq.top().pp) {\n\t\t\t\t\tpq.push(s(vv[j].fi,vv[j].se,j));\n\t\t\t\t\tpushed[j] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twhile(pq.size()) pq.pop();\n\t\t\t\t\ttmp++;\n\t\t\t\t\tpq.push(s(vv[j].fi,vv[j].se,j));\n\t\t\t\t\tpushed[j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(pq.size()) tmp++;\n\t\tres = min(res,tmp);\n\n\t\t/*\n\t\tfor(int i = 0; i < pushed.size(); i++)\n\t\t\tcout << pushed[i] << \" \";\n\t\tcout << endl;\n\t\t// */\n\n\t}\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n  int n, w, d;\n  cin >> n >> w >> d;\n  vector<pair<int,int>> ps;\n  // mapping to the south-west corner \n  auto mapping0 = [](int x, int y) {\n    return x - y;\n  };\n  // mapping in one of four directions\n  auto mappingX = [w,d,&mapping0](int x, int y, int dir) {\n    switch(dir) {\n    case 0 : { // (-1, -1)-direction\n      int o = mapping0(x, y);\n      return o; // o >= 0 ? o : w + w + d + d + o; // normalization\n    }\n    case 1 : { // (1, -1)-direction\n      int o = mapping0(w-x, y); // flipping in x\n      return w - o; // o >= 0 ? w - o : w + (- o);\n    }\n    case 2 : { // (1, 1)-direction\n      int o = mapping0(w-x, d-y); // flipping in x and y\n      return w + d + o; // o >= 0 ? w + d + o : w + d + o;\n    }\n    case 3 : { // (-1, 1)-direction\n      int o = mapping0(x, d-y); // flipping in y\n      return w + d + w - o; // o >= 0 ? w + d + w - o : w + d + w + -o;\n    }\n    return -1;\n    }\n  };\n  // mapping to a range\n  auto make_range = [w,d,&mappingX](int x, int y, char c) {\n    switch(c){\n    case 'N': return make_pair(mappingX(x, y, 2), mappingX(x, y, 3));\n    case 'E': return make_pair(mappingX(x, y, 1), mappingX(x, y, 2));\n    case 'S': {\n      int s = mappingX(x, y, 0);\n      int e = mappingX(x, y, 1);\n      if(s < 0) { // normalize to non-negative\n        s += d + d + w + w;\n        e += d + d + w + w;\n      }\n      return make_pair(s, e);\n    }\n    case 'W': {\n      int s = mappingX(x, y, 3);\n      int e = mappingX(x, y, 0) + w + w + d + d;\n      return make_pair(s, e);\n    }\n    }\n    return make_pair(-10, -10);\n  };\n\n  auto sw = [](const pair<int,int> p) {\n    return make_pair(p.second, p.first);\n  };\n  \n  for(int i = 0; i < n; i++) {\n    int x, y, d;\n    char c;\n    cin >> x >> y;\n    cin >> c;\n    ps.push_back(sw(make_range(x, y, c)));\n  }\n  // a desk = a range on walls\n  // a lock = a point on walls\n  // todo: put points so that every range contains a point\n\n  // sort the ranges by the end points\n  sort(ps.begin(), ps.end());\n\n  // note: first is the end, second is the start point.\n  \n  auto wrap = [d,w](bool aug, int a) {\n    return aug ? a + d + d + w + w : a;\n  };\n  int maxov = 0;\n  auto count = [&ps,n,&wrap,&maxov](const int ii){\n    int i = ii;\n    int k = 0;\n    int cnt = 0;\n    maxov = 0;\n    while(k < n) {\n      int e = wrap(i < ii, ps[i].first);\n      int kk = k;\n      k++;\n      i = (i + 1) % n;\n      while(k < n && wrap(i < ii, ps[i].second) <= e) {\n        i = (i + 1) % n;\n        k++;\n      }\n      if(k - kk > maxov) maxov = k - kk;\n      // cout << \"e = \" << e << \", i = \" << i << \", ii = \" << ii << \", k = \" << k << endl;\n      cnt++;\n    }\n    return cnt;\n  };\n  \n  vector<pair<int,int>> ss;\n  for(int i = 0; i < n; i++) {\n    ss.push_back(make_pair(ps[i].first,1));\n    ss.push_back(make_pair(ps[i].second,-1));\n  }\n  sort(ss.begin(), ss.end());\n  int mov = 0;\n  int movi = -1;\n  int ov = 0;\n  for(int i = 0; i < ss.size(); i++) {\n    ov -= ss[i].second;\n    if(ov > mov) {\n      mov = ov;\n      movi = i;\n    }\n  }\n  // now, movi is the most overlapped point.\n  // lets start from that point!\n  \n  // cout << \"[\";\n  // for(int i = 0; i < n; i++) {\n  //   if(i > 0) cout << \",\";\n  //   cout << \"(\" << ps[i].first << \",\" << ps[i].second << \")\";\n  // }\n  // cout << \"]\" << endl;\n  int mx = 0;\n  int cntmx = 0;\n  int idx = -1;\n  int cnt = n; // at most n\n  // possible starting points\n  vector<int> cs;\n  for(int i = 0; i < n; i++) {\n    int cc = count(i);\n    // cout << \"starting from \" << i << \", cc = \" << cc << \", maxov = \" << maxov << endl;\n    cs.push_back(cc);\n    if(cc <= cnt) {\n      cnt = cc;\n      cntmx = max(cntmx, maxov);\n    }\n    if(mx < maxov) {\n      idx = i;\n      mx = maxov;\n    }\n  }\n  cout << cs[idx] << endl;\n  //cerr << \"maxov_of_best = \" << cntmx << \", global_maxov \" << mx << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1011;\nstruct node{int l, r;} a[maxn], b[maxn];\nint x[maxn],y[maxn]; char c[maxn];\nint n, M, N, ans;\nvoid init(){\n    scanf(\"%d%d%d\",&n,&N,&M);\n    for (int i=1;i<=n;++i){\n\t\tchar op[3];\n        scanf(\"%d%d%s\",x+i,y+i,op); c[i]=op[0];\n    }\n}\nbool cmp(node a, node b){\n    return (a.l < b.l) || ((a.l == b.l) && (a.r < b.r));\n}\nint cal(int st, int x){\n    if (st+x-1 <= n) return st+x-1;\n    else return st+x-1-n;\n}\nvoid work(){\n    int C = (N+M)*2;\n    for (int i=1;i<=n;++i){\n        if (c[i]=='N'){\n\t    int tmp = M-y[i];\n\t    b[i].r = x[i]+tmp;\n\t    b[i].l = x[i]-tmp;\n        }\n\tif (c[i] == 'S') {\n\t    int tmp = y[i];\n\t    b[i].l = (C-M-x[i])-tmp;\n\t    b[i].r = (C-M-x[i])+tmp;\n\t}\n\tif (c[i] == 'E') {\n\t    int tmp = N-x[i];\n\t    b[i].l = (N+M-y[i])-tmp;\n\t    b[i].r = (N+M-y[i])+tmp;\n\t}\n\tif (c[i] == 'W') {\n\t    int tmp = x[i];\n\t    b[i].l = (N+N+M+y[i])-tmp;\n\t    b[i].r = (N+N+M+y[i])+tmp;\n\t}\n    }\n    ans = n;\n    for(int i = 1; i <= n; i++){\n\tint tmp = b[i].l-1;\n\tfor(int j = 1; j <= n; j++)\n\t    a[j].l = b[j].l-tmp, a[j].r = b[j].r-tmp;\n\tfor(int j = 1; j <= n; j++){\n\t    if (a[j].l <= 0) a[j].l += C;\n\t    if (a[j].r <= 0) a[j].r += C;\n\t}\n\tsort(a+1,a+1+n,cmp);\n\tint last = a[1].r, num = 1;\n\tfor(int j = 2; j <= n; j++){\n\t    if (a[j].l <= last) continue;\n\t    last = a[j].r, num++;\n\t}\n\tans = min(ans,num);\n    }\n    cout << ans << endl;\n}\nint main(){\n\tinit();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <utility>\nusing namespace std;\nconst int inf = 1e9;\nconst int MAXN = 1000;\n\nint upper_right(int x, int y, int w, int h){\n\treturn 2*w +y -x;\n}\nint upper_left(int x, int y, int w, int h){\n\treturn 2*w +2*h -x -y;\n}\nint lower_right(int x, int y, int w, int h){\n\treturn x+y;\n}\nint lower_left(int x, int y, int w, int h){\n\treturn x>y? x-y: 2*h +2*w +x-y;\n}\n\nint main(){\n\tint n,w,h;\n\tcin >> n >> w >> h;\n\tvector<int> s(n), e(n);\n\tfor(int i=0; i<n; i++){\n\t\tint x,y;\n\t\tchar f;\n\t\tcin >> x >> y >> f;\n\t\tif(f == 'N'){\n\t\t\ts[i] = upper_right(x, y, w, h);\n\t\t\te[i] = upper_left(x, y, w, h);\n\t\t}\n\t\tif(f == 'W'){\n\t\t\ts[i] = upper_left(x, y, w, h);\n\t\t\te[i] = lower_left(x, y, w, h);\n\t\t}\n\t\tif(f == 'S'){\n\t\t\ts[i] = lower_left(x, y, w, h);\n\t\t\te[i] = lower_right(x, y, w, h);\n\t\t}\n\t\tif(f == 'E'){\n\t\t\ts[i] = lower_right(x, y, w, h);\n\t\t\te[i] = upper_right(x, y, w, h);\n\t\t}\n\t}\n\tvector<pair<int ,int> > es(n);\n\tfor(int i=0; i<n; i++) es[i] = make_pair(e[i], s[i]);\n\tsort(es.begin(), es.end());\n\tfor(int i=0; i<n; i++){ s[i] = es[i].second; e[i] = es[i].first; }\n\t\n\tvector<bitset<MAXN> > cover(n);\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif((i == j) ||\n\t\t\t\t(s[j] < e[j] && s[j]<=e[i] && e[i]<=e[j]) ||\n\t\t\t\t(s[j] > e[j] && (e[i]<=e[j] || s[j]<=e[i]))){\n\t\t\t\tcover[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = inf;\n\tfor(int i=0; i<n; i++){\n\t\tint sub = 0;\n\t\tbitset<MAXN> cov;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(cov[(i+j)%n] == 0){\n\t\t\t\tcov |= cover[(i+j)%n];\n\t\t\t\tsub++;\n\t\t\t}\n\t\t}\n\t\tans = min(ans, sub);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int w,h,n;\n  cin>>n>>w>>h;\n  int x,y,B=2*(w+h),ans=n;\n  char c;\n  vector<P> m;\n  for(int i=0;i<n;i++){\n    cin>>x>>y>>c;\n    if(c=='S')m.push_back(P(x+y,(x-y+B)%B));\n    if(c=='E')m.push_back(P(w+y+(w-x),w+y-(w-x)));\n    if(c=='N')m.push_back(P(w+h+(w-x)+(h-y),w+h+(w-x)-(h-y)));\n    if(c=='W')m.push_back(P((w*2+h+(h-y)+x)%B,w*2+h+(h-y)-x));\n  }\n  sort(m.begin(),m.end());\n  for(int i=0;i<n;i++){\n    int tp=1,p=m[i].first;\n    for(int j=0;j<n;j++){\n      int s=m[(i+j)%n].second,g=m[(i+j)%n].first;\n      if(s>g&&!(g<p&&p<s))continue;\n      if(s<g&&s<=p&&p<=g)continue;\n      tp++,p=g;\n    }\n    ans=min(tp,ans);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1359: Wall Clocks\n// 2018.1.22 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct { int f, t; } T;\nT t[1001];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint cmp(T *a, T *b) { if (a->t-b->t) return a->t-b->t; return a->f-b->f; }\n\nint main()\n{\n\tint n, w, d, i, j, k, x, y, p1, p2, lim, ans;\n\tchar f;\n\n\tn = in(), w = in(), d = in();\n\tlim = (w+d) << 1;\n\tfor (i = 0; i < n; i++) {\n\t\tx = in(), y = in(), f = getchar_unlocked(), getchar_unlocked();\n\t\tif      (f == 'S') t[i].f = x-y,       t[i].t = x+y;\n\t\telse if (f == 'E') t[i].f = x+y,       t[i].t = 2*w+y-x;\n\t\telse if (f == 'N') t[i].f = 2*w+y-x,   t[i].t = lim-(x+y);\n\t\telse               t[i].f = lim-(x+y), t[i].t = lim+(x-y);\n\t}\n\tqsort(t, n, sizeof(T), cmp);\n\n\tans = n;\n\tfor (i = 0; i < n; i++) {\n\t\tp1 = t[i].t; if (p1 >= lim) p1 -= lim;\n\t\tp2 = -1, k = 1;\n\t\tfor (j = 0; j < n; j++) if (i != j) {\n\t\t\tif (t[j].f <= p1 && p1 <= t[j].t) continue;\n//\t\t\tif (t[j].f < 0) { if (lim+t[j].f <= p1) continue; }\n\t\t\tif (t[j].t > lim) { if (p1 <= (t[j].t-lim)) continue; }\n\t\t\tif (p2 < 0 || p2 < t[j].f || t[j].t < p2) p2 = t[j].t, k++;\n\t\t}\n\t\tif (k < ans) ans = k;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1359: Wall Clocks\n// 2018.1.22 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct { int f, t; } T;\nT t[1001];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint cmp(T *a, T *b) { if (a->t-b->t) return a->t-b->t; return a->f-b->f; }\n\nint main()\n{\n\tint n, w, d, i, j, k, x, y, p1, p2, lim, ans;\n\tchar f;\n\n\tn = in(), w = in(), d = in();\n\tlim = (w+d) << 1;\n\tfor (i = 0; i < n; i++) {\n\t\tx = in(), y = in(), f = getchar_unlocked(), getchar_unlocked();\n\t\tif      (f == 'S') t[i].f = x-y,       t[i].t = x+y;\n\t\telse if (f == 'E') t[i].f = x+y,       t[i].t = 2*w+y-x;\n\t\telse if (f == 'N') t[i].f = 2*w+y-x,   t[i].t = lim-(x+y);\n\t\telse               t[i].f = lim-(x+y), t[i].t = lim+(x-y);\n\t}\n\tqsort(t, n, sizeof(T), cmp);\n\n\tans = n;\n\tfor (i = 0; i < n; i++) {\n\t\tp1 = t[i].t; if (p1 >= lim) p1 -= lim;\n\t\tp2 = -1, k = 1;\n\t\tfor (j = 0; j < n; j++) if (i != j) {\n\t\t\tif (t[j].f <= p1 && p1 <= t[j].t) continue;\n\t\t\tif (t[j].f < 0) { if (lim+t[j].f <= p1) continue; }\n\t\t\tif (t[j].t > lim) { if (p1 <= (t[j].t-lim)) continue; }\n\t\t\tif (p2 < 0 || p2 < t[j].f || t[j].t < p2) p2 = t[j].t, k++;\n\t\t}\n\t\tif (k < ans) ans = k;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static int[][] dirs = {{1, 1}, {1, -1}, {-1, -1}, {-1, 1}};\n\t\n\tpublic static Map<String, Integer> dirToIndex = new HashMap<String, Integer>();\n\tstatic {\n\t\tdirToIndex.put(\"E\", 0);\n\t\tdirToIndex.put(\"S\", 1);\n\t\tdirToIndex.put(\"W\", 2);\n\t\tdirToIndex.put(\"N\", 3);\n\t}\n\t\n\t// clock-wise\n\tpublic static int convertTo1D(final int x, final int y, final int w, final int h){\n\t\tif(x == 0){\n\t\t\treturn y;\n\t\t}else if(y == h){\n\t\t\treturn h + x;\n\t\t}else if(x == w){\n\t\t\treturn h + w + (h - y);\n\t\t}else {\n\t\t\treturn h + w + h + (w - x);\n\t\t}\n\t}\n\t\n\tpublic static int convertLeft(final int x, final int y, final int w, final int h, final int dir){\n\t\tfinal int x_sign = dirs[dir][0];\n\t\tfinal int y_sign = dirs[dir][1];\n\t\t\n\t\tfinal int x_lim = x_sign > 0 ? w : 0;\n\t\tfinal int y_lim = y_sign > 0 ? h : 0;\n\t\t\n\t\tfinal int x_diff = Math.abs(x_lim - x);\n\t\tfinal int y_diff = Math.abs(y_lim - y);\n\t\t\n\t\tfinal int min_diff = Math.min(x_diff, y_diff);\n\t\t\n\t\treturn convertTo1D(x + min_diff * x_sign, y + min_diff * y_sign, w, h);\n\t}\n\t\n\tpublic static int convertRight(final int x, final int y, final int w, final int h, final int dir){\n\t\treturn convertLeft(x, y, w, h, (dir + 1) % dirs.length);\n\t}\n\t\n\tpublic static class Pair implements Comparable<Pair> {\n\t\tint position, value;\n\t\t\n\t\tpublic Pair(int position, int value){\n\t\t\tthis.position = position;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn this.position + \" \" + this.value;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif(Integer.compare(this.position, o.position) != 0){\n\t\t\t\treturn Integer.compare(this.position, o.position);\n\t\t\t}else{\n\t\t\t\treturn Integer.compare(o.value, this.value);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int n = sc.nextInt();\n\t\tfinal int w = sc.nextInt();\n\t\tfinal int h = sc.nextInt();\n\t\t\n\t\tint[] ls = new int[n];\n\t\tint[] rs = new int[n];\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfinal int x = sc.nextInt();\n\t\t\tfinal int y = sc.nextInt();\n\t\t\tfinal String d = sc.next();\n\t\t\t\n\t\t\tls[i] = convertLeft(x, y, w, h, dirToIndex.get(d));\n\t\t\trs[i] = convertRight(x, y, w, h, dirToIndex.get(d));\n\t\t\tif(ls[i] > rs[i]){ rs[i] += 2 * (h + w); }\n\t\t}\n\t\t\n\t\t//System.out.println(Arrays.toString(ls));\n\t\t//System.out.println(Arrays.toString(rs));\n\t\t\n\t\tint min = Integer.MAX_VALUE;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint[] n_ls = new int[n];\n\t\t\tint[] n_rs = new int[n];\n\t\t\tSystem.arraycopy(ls, 0, n_ls, 0, n);\n\t\t\tSystem.arraycopy(rs, 0, n_rs, 0, n);\n\t\t\t\n\t\t\tfinal int origin = ls[i];\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tn_ls[j] -= origin;\n\t\t\t\twhile(n_ls[j] < 0){ n_ls[j] += 2 * (w + h); }\n\t\t\t\twhile(n_ls[j] >= 2 * (w + h)){ n_ls[j] -= 2 * (w + h); }\n\t\t\t\tn_rs[j] -= origin;\n\t\t\t\twhile(n_rs[j] < 0){ n_rs[j] += 2 * (w + h); }\n\t\t\t\twhile(n_rs[j] >= 2 * (w + h)){ n_rs[j] -= 2 * (w + h); }\n\t\t\t\t\n\t\t\t\tif(n_rs[j] < n_ls[j]){\n\t\t\t\t\tint tmp = n_ls[j];\n\t\t\t\t\tn_ls[j] = n_rs[j];\n\t\t\t\t\tn_rs[j] = tmp;\n\t\t\t\t}\n\t\t\t\t//System.out.println(n_ls[j] + \" \" + n_rs[j]);\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<Pair> queue = new PriorityQueue<Pair>();\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(n_ls[j] <= n_rs[i] && n_rs[i] <= n_rs[j]){\n\t\t\t\t\t//System.out.println(ls[j] + \" \" + origin + \" \" + rs[i]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tqueue.add(new Pair(n_ls[j], +1));\n\t\t\t\tqueue.add(new Pair(n_rs[j], -1));\n\t\t\t}\n\t\t\t\n\t\t\tint score = 1;\n\t\t\tint count = 0;\n\t\t\t//System.out.println(queue);\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tfinal Pair p = queue.poll();\n\t\t\t\t\n\t\t\t\t//System.out.println(p.position + \" \" + p.value);\n\t\t\t\t\n\t\t\t\tif(p.value >= 1){\n\t\t\t\t\tcount++;\n\t\t\t\t}else if(count >= 1){\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tscore++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println();\n\t\t\t\n\t\t\t//if(count == 0){\n\t\t\t\tmin = Math.min(min, score);\n\t\t\t//}\n\t\t}\n\t\t\n\t\tSystem.out.println(min);\n\t\t\n\t\tsc.close();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\n\npublic class Main {\n\t\n\tpublic static int[][] dirs = {{1, 1}, {1, -1}, {-1, -1}, {-1, 1}};\n\t\n\tpublic static Map<String, Integer> dirToIndex = new HashMap<String, Integer>();\n\tstatic {\n\t\tdirToIndex.put(\"E\", 0);\n\t\tdirToIndex.put(\"S\", 1);\n\t\tdirToIndex.put(\"W\", 2);\n\t\tdirToIndex.put(\"N\", 3);\n\t}\n\t\n\t// clock-wise\n\tpublic static int convertTo1D(final int x, final int y, final int w, final int h){\n\t\tif(x == 0){\n\t\t\treturn y;\n\t\t}else if(y == h){\n\t\t\treturn h + x;\n\t\t}else if(x == w){\n\t\t\treturn h + w + (h - y);\n\t\t}else {\n\t\t\treturn h + w + h + (w - x);\n\t\t}\n\t}\n\t\n\tpublic static int convertLeft(final int x, final int y, final int w, final int h, final int dir){\n\t\tfinal int x_sign = dirs[dir][0];\n\t\tfinal int y_sign = dirs[dir][1];\n\t\t\n\t\tfinal int x_lim = x_sign > 0 ? w : 0;\n\t\tfinal int y_lim = y_sign > 0 ? h : 0;\n\t\t\n\t\tfinal int x_diff = Math.abs(x_lim - x);\n\t\tfinal int y_diff = Math.abs(y_lim - y);\n\t\t\n\t\tfinal int min_diff = Math.min(x_diff, y_diff);\n\t\t\n\t\treturn convertTo1D(x + min_diff * x_sign, y + min_diff * y_sign, w, h);\n\t}\n\t\n\tpublic static int convertRight(final int x, final int y, final int w, final int h, final int dir){\n\t\treturn convertLeft(x, y, w, h, (dir + 1) % dirs.length);\n\t}\n\t\n\tpublic static class Pair implements Comparable<Pair> {\n\t\tint position, value;\n\t\t\n\t\tpublic Pair(int position, int value){\n\t\t\tthis.position = position;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn this.position + \" \" + this.value;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif(Integer.compare(this.position, o.position) != 0){\n\t\t\t\treturn Integer.compare(this.position, o.position);\n\t\t\t}else{\n\t\t\t\treturn Integer.compare(o.value, this.value);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int n = sc.nextInt();\n\t\tfinal int w = sc.nextInt();\n\t\tfinal int h = sc.nextInt();\n\t\t\n\t\tint[] ls = new int[n];\n\t\tint[] rs = new int[n];\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfinal int x = sc.nextInt();\n\t\t\tfinal int y = sc.nextInt();\n\t\t\tfinal String d = sc.next();\n\t\t\t\n\t\t\tls[i] = convertLeft(x, y, w, h, dirToIndex.get(d));\n\t\t\trs[i] = convertRight(x, y, w, h, dirToIndex.get(d));\n\t\t\tif(ls[i] > rs[i]){ rs[i] += 2 * (h + w); }\n\t\t}\n\t\t\n\t\t//System.out.println(Arrays.toString(ls));\n\t\t//System.out.println(Arrays.toString(rs));\n\t\t\n\t\tint min = Integer.MAX_VALUE;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint[] n_ls = new int[n];\n\t\t\tint[] n_rs = new int[n];\n\t\t\tSystem.arraycopy(ls, 0, n_ls, 0, n);\n\t\t\tSystem.arraycopy(rs, 0, n_rs, 0, n);\n\t\t\t\n\t\t\tfinal int origin = ls[i];\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tn_ls[j] -= origin;\n\t\t\t\twhile(n_ls[j] < 0){ n_ls[j] += 2 * (w + h); }\n\t\t\t\twhile(n_ls[j] >= 2 * (w + h)){ n_ls[j] -= 2 * (w + h); }\n\t\t\t\t\n\t\t\t\tn_rs[j] -= origin;\n\t\t\t\twhile(n_rs[j] < 0){ n_rs[j] += 2 * (w + h); }\n\t\t\t\twhile(n_rs[j] >= 2 * (w + h)){ n_rs[j] -= 2 * (w + h); }\n\t\t\t\t\n\t\t\t\tif(n_rs[j] < n_ls[j]){\n\t\t\t\t\tint tmp = n_ls[j];\n\t\t\t\t\tn_ls[j] = n_rs[j];\n\t\t\t\t\tn_rs[j] = tmp;\n\t\t\t\t}\n\t\t\t\t//System.out.println(n_ls[j] + \" \" + n_rs[j]);\n\t\t\t}\n\t\t\t\n\t\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tset.add(n_ls[j]);\n\t\t\t\tset.add(n_rs[j] + 1);\n\t\t\t}\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>(set);\n\t\t\tint[] array = new int[list.size()];\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tarray[Collections.binarySearch(list, n_ls[j])]++;\n\t\t\t\tarray[Collections.binarySearch(list, n_rs[j] + 1)]--;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 1; j < array.length; j++){\n\t\t\t\tarray[j] += array[j - 1];\n\t\t\t}\n\t\t\t\n\t\t\tint score = 0;\n\t\t\tboolean prev = false;\n\t\t\tfor(int j = 0; j < array.length; j++){\n\t\t\t\tif(!prev && array[j] >= 1){\n\t\t\t\t\tprev = true;\n\t\t\t\t}else if(prev && array[j] == 0){\n\t\t\t\t\tprev = false;\n\t\t\t\t\tscore++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(prev){\n\t\t\t\tscore++;\n\t\t\t}\n\t\t\t\n\t\t\tmin = Math.min(min, score);\n\t\t}\n\t\t\n\t\tSystem.out.println(min);\n\t\t\n\t\tsc.close();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        new Main().solve();\n    }\n\n    int w, h;\n\n    int flatten(int x, int y) {\n        // 1?¬????????±?????????????????????????ccw?????§\n//        System.out.println(\"(\" + x + \",\" + y + \")\");\n        // (0,0) -> 0\n        // (0,h) -> h\n        // (w,h) -> h+w\n        // (w,0) -> 2h+w\n        // (0,0) -> 2(h+w)\n        if (x == 0) {\n            return y;\n        }\n        else if (y == h) {\n            return h + x;\n        }\n        else if (x == w) {\n            return h + w + (h - y);\n        }\n        else if (y == 0) {\n            return 2 * h + w + (w - x);\n        }\n        else throw new IllegalArgumentException();\n    }\n\n    boolean inRange(int min, int v, int max) {\n        if (min > max) {\n            // ??????????????????\n            return min <= v || v <= max;\n        }\n        else {\n            return min <= v && v <= max;\n        }\n    }\n\n    boolean inRange(int v, int[] range) {\n        return inRange(range[0], v, range[1]);\n    }\n\n    private void solve() throws Exception {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        w = sc.nextInt();\n        h = sc.nextInt();\n\n        int[][] ranges = new int[n][2];  // start, end\n\n        for (int i = 0; i < n; i++) {\n            int x = sc.nextInt();\n            int y = h - sc.nextInt();\n            char d = sc.next().charAt(0);\n            if (d == 'N') {\n                int dl = Math.min(x, y);\n                int dr = Math.min(w - x, y);\n                ranges[i][0] = flatten(x + dr, y - dr);\n                ranges[i][1] = flatten(x - dl, y - dl);\n            }\n            else if (d == 'W') {\n                int dt = Math.min(x, y);\n                int db = Math.min(x, h - y);\n                ranges[i][0] = flatten(x - dt, y - dt);\n                ranges[i][1] = flatten(x - db, y + db);\n            }\n            else if (d == 'S') {\n                int dl = Math.min(x, h - y);\n                int dr = Math.min(w - x, h - y);\n                ranges[i][0] = flatten(x - dl, y + dl);\n                ranges[i][1] = flatten(x + dr, y + dr);\n            }\n            else if (d == 'E') {\n                int dt = Math.min(w - x, y);\n                int db = Math.min(w - x, h - y);\n                ranges[i][0] = flatten(x + db, y + db);\n                ranges[i][1] = flatten(x + dt, y - dt);\n            }\n        }\n\n        Arrays.sort(ranges, new Comparator<int[]>() {\n\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                // TODO Auto-generated method stub\n                return o1[1] - o2[1];\n            }\n\n        });\n\n        // debug show\n//        for (int i = 0; i < n; i++) {\n//            System.out.println(i + \": [\" + ranges[i][0] + \", \" + ranges[i][1] + \"]\");\n//        }\n        // ??????????????????\n\n        // n=1000?????????2??????????????????????????????????¬????????±???????????????????????????????????????§????????¨???????¬??????????\n\n        TreeSet<Integer> changingPoints = new TreeSet<Integer>();\n        for (int i = 0; i < n; i++) {\n            // changingPoints.add(ranges[i][0]);\n            changingPoints.add(ranges[i][1]);\n        }\n        int[] candidates = new int[changingPoints.size()];\n        {\n            int i = 0;\n            for (int c : changingPoints) {\n                candidates[i++] = c;\n            }\n        }\n\n        int ans = 10000000;\n        for (int firstClock : candidates) {\n            ArrayList<int[]> curRs = new ArrayList<int[]>();\n            int firstPosIdx = -1;\n            for (int i = 0; i < n; i++) {\n                if (!inRange(firstClock, ranges[i])) {\n                    curRs.add(ranges[i]);\n                }\n                else if (firstPosIdx == -1) {\n                    firstPosIdx = curRs.size();\n                }\n            }\n            Collections.rotate(curRs, curRs.size() - firstPosIdx);  // ??????????????????????????????????????£?????????\n//            System.out.print(\"curRs: [\");\n//            for (int[] range : curRs) {\n//                System.out.print(Arrays.toString(range) + \",\");\n//            }\n//            System.out.println(\"]\");\n            int lastClock = -1;\n            int numClock = 1;\n            for (int[] range : curRs) {\n                if (lastClock == -1 || !inRange(lastClock, range)) {\n                    numClock++;\n                    lastClock = range[1];\n                }\n            }\n//            System.out.println(\"firstClock: \" + firstClock + \", ans: \" + numClock);\n            ans = Math.min(ans, numClock);\n        }\n\n        System.out.println(ans);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n \npublic class Main{\n\tclass Pair{\n\t\tint begin;\n\t\tint end;\n\t\tpublic Pair(int begin, int end){\n\t\t\tthis.begin = begin;\n\t\t\tthis.end = end;\n\t\t}\n\t}\n\t\n\t\n\tint N;\n\tint W;\n\tint D;\n\tPair[] teams;\n\t\n\tpublic void solve(){\n\t\tN = nextInt();\n\t\tW = nextInt();\n\t\tD = nextInt();\n\t\tteams = new Pair[N];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint x = nextInt();\n\t\t\tint y = nextInt();\n\t\t\tchar d = next().charAt(0);\n\t\t\tint x1, x2;\n\t\t\tint y1, y2;\n\t\t\tswitch(d){\n\t\t\tcase 'N':\n\t\t\t\tif(D - y < x){\n\t\t\t\t\tx1 = x - (D - y);\n\t\t\t\t\ty1 = D;\n\t\t\t\t}else{\n\t\t\t\t\tx1 = 0;\n\t\t\t\t\ty1 = y + x;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(D - y < W - x){\n\t\t\t\t\tx2 = x + (D - y);\n\t\t\t\t\ty2 = D;\n\t\t\t\t}else{\n\t\t\t\t\tx2 = W;\n\t\t\t\t\ty2 = y + (W - x);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\tif(W - x < y){\n\t\t\t\t\tx2 = W;\n\t\t\t\t\ty2 = y - (W - x);\n\t\t\t\t}else{\n\t\t\t\t\tx2 = x + y;\n\t\t\t\t\ty2 = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(W - x < D - y){\n\t\t\t\t\tx1 = W;\n\t\t\t\t\ty1 = y + (W - x);\n\t\t\t\t}else{\n\t\t\t\t\tx1 = x + (D - y);\n\t\t\t\t\ty1 = D;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tcase 'W':\n\t\t\t\tif(x < y){\n\t\t\t\t\tx1 = 0;\n\t\t\t\t\ty1 = y - x;\n\t\t\t\t}else{\n\t\t\t\t\tx1 = x - y;\n\t\t\t\t\ty1 = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(x < D - y){\n\t\t\t\t\tx2 = 0;\n\t\t\t\t\ty2 = y + x;\n\t\t\t\t}else{\n\t\t\t\t\tx2 = x - (D - y);\n\t\t\t\t\ty2 = D;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tif(y < x){\n\t\t\t\t\tx2 = x - y;\n\t\t\t\t\ty2 = 0;\n\t\t\t\t}else{\n\t\t\t\t\tx2 = 0;\n\t\t\t\t\ty2 = y - x;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(y < W - x){\n\t\t\t\t\tx1 = x + y;\n\t\t\t\t\ty1 = 0;\n\t\t\t\t}else{\n\t\t\t\t\tx1 = W;\n\t\t\t\t\ty1 = y - (W - x);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault: throw new RuntimeException();\n\t\t\t}\n\t\t\tint i1 = toIdx(x1, y1);\n\t\t\tint i2 = toIdx(x2, y2);\n\t\t\tif(i2 < i1){\n\t\t\t\ti2 += D + D + W + W;\n\t\t\t}\n\t\t\tteams[i] = new Pair(i1, i2);\n\t\t}\n\t\t\n\t\tArrays.sort(teams, (a, b) -> Integer.compare(a.begin, b.begin));\n\t\tint ans = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint cur = 1;\n\t\t\tint pos = teams[i].end;\n\t\t\tint base = 0;\n\t\t\tfor(int j = 1; j < N; j++){\n\t\t\t\tPair p = teams[(i + j) % N];\n\t\t\t\tif(i + j >= N){\n\t\t\t\t\tbase = D + D + W + W;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(p.begin + base <= pos && pos <= p.end + base){\n\t\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\tcur ++;\n\t\t\t\t\tpos = p.end;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = Math.min(ans, cur);\n\t\t}\n\t\t\n\t\tArrays.sort(teams, (a, b) -> Integer.compare(a.end, b.end));\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint cur = 1;\n\t\t\tint pos = teams[i].end;\n\t\t\tint base = 0;\n\t\t\tfor(int j = 1; j < N; j++){\n\t\t\t\tPair p = teams[(i + j) % N];\n\t\t\t\tif(i + j >= N){\n\t\t\t\t\tbase = D + D + W + W;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(p.begin + base <= pos && pos <= p.end + base){\n\t\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\tcur ++;\n\t\t\t\t\tpos = p.end;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = Math.min(ans, cur);\n\t\t}\n\t\tout.println(ans);\n\t\t\n\t}\n\tpublic int toIdx(int x, int y){\n\t\tif(x == 0){\n\t\t\treturn y;\n\t\t}else if(y == D){\n\t\t\treturn D + x;\n\t\t}else if(x == W){\n\t\t\treturn D + W + (D - y);\n\t\t}else{\n\t\t\treturn D + W + D + (W - x);\n\t\t}\n\t}\n \n\t\n\tprivate static PrintWriter out;\n\tpublic static void main(String[] args){\n\t\tout = new PrintWriter(System.out);\n\t\tnew Main().solve();\n\t\tout.flush();\n\t}\n\t\n\t\n\t\n\tpublic static int nextInt(){\n\t\tint num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif(str.charAt(0) == '-'){\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor(;i < len; i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(!('0' <= c && c <= '9')) throw new RuntimeException();\n\t\t\tnum = num * 10 + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\t\n\tpublic static long nextLong(){\n\t\tlong num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif(str.charAt(0) == '-'){\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor(;i < len; i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(!('0' <= c && c <= '9')) throw new RuntimeException();\n\t\t\tnum = num * 10l + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\tpublic static String next(){\n\t\tint c;\n\t\twhile(!isAlNum(c = read())){}\n\t\tStringBuilder build = new StringBuilder();\n\t\tbuild.append((char)c);\n\t\twhile(isAlNum(c = read())){\n\t\t\tbuild.append((char)c);\n\t\t}\n\t\treturn build.toString();\n\t}\n\t\n\t\n\tprivate static byte[] inputBuffer = new byte[1024];\n\tprivate static int bufferLength = 0;\n\tprivate static int bufferIndex = 0;\n\tprivate static int read(){\n\t\tif(bufferLength < 0) throw new RuntimeException();\n\t\tif(bufferIndex >= bufferLength){\n\t\t\ttry{\n\t\t\t\tbufferLength = System.in.read(inputBuffer);\n\t\t\t\tbufferIndex = 0;\n\t\t\t}catch(IOException e){\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif(bufferLength <= 0) return (bufferLength = -1);\n\t\t}\n\t\treturn inputBuffer[bufferIndex++];\n\t}\n\t\n\tprivate static boolean isAlNum(int c){\n\t\treturn '!' <= c && c <= '~';\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint w = scan.nextInt();\n\t\tint d = scan.nextInt();\n\t\t\n\t\tint[][] ary = new int[n][2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = scan.nextInt();\n\t\t\tint y = scan.nextInt();\n\t\t\tswitch (scan.next()) {\n\t\t\tcase \"N\":\n\t\t\t\tary[i][0] = w + (d - x + y);\n\t\t\t\tary[i][1] = ary[i][0] + (d - y) * 2;\n\t\t\t\tbreak;\n\t\t\tcase \"E\":\n\t\t\t\tary[i][0] = x + y;\n\t\t\t\tary[i][1] = ary[i][0] + (w - x) * 2;\n\t\t\t\tbreak;\n\t\t\tcase \"S\":\n\t\t\t\tif (x < y)\n\t\t\t\t\tary[i][0] = 2 * w + 2 * d - (y - x);\n\t\t\t\telse\n\t\t\t\t\tary[i][0] = x - y;\n\t\t\t\tary[i][1] = ary[i][0] + y * 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tary[i][0] = w + d + (w - x) + (d - y);\n\t\t\t\tary[i][1] = ary[i][0] + x * 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n//\t\tfor (int i = 0; i < n; i++) {\n//\t\t\tSystem.out.println(ary[i][0] + \" \" + ary[i][1]);\n//\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tArrays.sort(ary, new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn o1[0] - o2[0];\n\t\t\t\t}\n\t\t\t});\n\t\t\tint ans = 1;\n\t\t\tint p = ary[0][1];\n\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\tif (p < ary[j][0]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tp = ary[j][1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tary[0][0] += 2 * w + 2 * d;\n\t\t\tary[0][1] += 2 * w + 2 * d;\n\t\t\tmin = Math.min(min, ans);\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        new Main().solve();\n    }\n\n    int w, h;\n\n    int flatten(int x, int y) {\n        // 1?¬????????±?????????????????????????ccw?????§\n//        System.out.println(\"(\" + x + \",\" + y + \")\");\n        // (0,0) -> 0\n        // (0,h) -> h\n        // (w,h) -> h+w\n        // (w,0) -> 2h+w\n        // (0,0) -> 2(h+w)\n        if (x == 0) {\n            return y;\n        }\n        else if (y == h) {\n            return h + x;\n        }\n        else if (x == w) {\n            return h + w + (h - y);\n        }\n        else if (y == 0) {\n            return 2 * h + w + (w - x);\n        }\n        else throw new IllegalArgumentException();\n    }\n\n    boolean inRange(int min, int v, int max) {\n        if (min > max) {\n            // ??????????????????\n            return min <= v || v <= max;\n        }\n        else {\n            return min <= v && v <= max;\n        }\n    }\n\n    boolean inRange(int v, int[] range) {\n        return inRange(range[0], v, range[1]);\n    }\n\n    private void solve() throws Exception {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        w = sc.nextInt();\n        h = sc.nextInt();\n\n        int[][] ranges = new int[n][2];  // start, end\n\n        for (int i = 0; i < n; i++) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            char d = sc.next().charAt(0);\n            if (d == 'N') {\n                int dl = Math.min(x, y);\n                int dr = Math.min(w - x, y);\n                ranges[i][0] = flatten(x + dr, y - dr);\n                ranges[i][1] = flatten(x - dl, y - dl);\n            }\n            else if (d == 'W') {\n                int dt = Math.min(x, y);\n                int db = Math.min(x, h - y);\n                ranges[i][0] = flatten(x - dt, y - dt);\n                ranges[i][1] = flatten(x - db, y + db);\n            }\n            else if (d == 'S') {\n                int dl = Math.min(x, h - y);\n                int dr = Math.min(w - x, h - y);\n                ranges[i][0] = flatten(x - dl, y + dl);\n                ranges[i][1] = flatten(x + dr, y + dr);\n            }\n            else if (d == 'E') {\n                int dt = Math.min(w - x, y);\n                int db = Math.min(w - x, h - y);\n                ranges[i][0] = flatten(x + db, y + db);\n                ranges[i][1] = flatten(x + dt, y - dt);\n            }\n        }\n\n        Arrays.sort(ranges, new Comparator<int[]>() {\n\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                // TODO Auto-generated method stub\n                return o1[1] - o2[1];\n            }\n\n        });\n\n        // debug show\n//        for (int i = 0; i < n; i++) {\n//            System.out.println(i + \": [\" + ranges[i][0] + \", \" + ranges[i][1] + \"]\");\n//        }\n        // ??????????????????\n\n        // n=1000?????????2??????????????????????????????????¬????????±???????????????????????????????????????§????????¨???????¬??????????\n\n        TreeSet<Integer> changingPoints = new TreeSet<Integer>();\n        for (int i = 0; i < n; i++) {\n            // changingPoints.add(ranges[i][0]);\n            changingPoints.add(ranges[i][1]);\n        }\n        int[] candidates = new int[changingPoints.size()];\n        {\n            int i = 0;\n            for (int c : changingPoints) {\n                candidates[i++] = c;\n            }\n        }\n\n        int ans = 10000000;\n        for (int firstClock : candidates) {\n            ArrayList<int[]> curRs = new ArrayList<int[]>();\n            int firstPosIdx = -1;\n            for (int i = 0; i < n; i++) {\n                if (!inRange(firstClock, ranges[i])) {\n                    curRs.add(ranges[i]);\n                }\n                else if (firstPosIdx == -1) {\n                    firstPosIdx = curRs.size();\n                }\n            }\n            Collections.rotate(curRs, curRs.size() - firstPosIdx);  // ??????????????????????????????????????£?????????\n//            System.out.print(\"curRs: [\");\n//            for (int[] range : curRs) {\n//                System.out.print(Arrays.toString(range) + \",\");\n//            }\n//            System.out.println(\"]\");\n            int lastClock = -1;\n            int numClock = 1;\n            for (int[] range : curRs) {\n                if (lastClock == -1 || !inRange(lastClock, range)) {\n                    numClock++;\n                    lastClock = range[1];\n                }\n            }\n//            System.out.println(\"firstClock: \" + firstClock + \", ans: \" + numClock);\n            ans = Math.min(ans, numClock);\n        }\n\n        System.out.println(ans);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.SortedMap;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n \npublic class Main {\n\t\n\t// sum ????????¶????????????, prod ?????????????????¨???????????????.\n\tpublic static long lower_prod(final int n, final int deep, String value, final int rest_sum, final long cur_prod, final long s_prod, final int upper_val, int[] using_values, HashMap<Long, Long> memoized, HashSet<String> same_number){\n\t\tfinal int trial = n - deep;\n\t\t//System.out.println(trial + \" \" + rest_sum + \" \" + cur_prod + \" \" + s_prod);\n\t\t\n\t\tif(trial == 0){\n\t\t\tif(!memoized.containsKey(cur_prod)){\n\t\t\t\tmemoized.put(cur_prod, 0l);\n\t\t\t}\n\t\t\t\n\t\t\tlong ret = 1;\n\t\t\t\n\t\t\tif(rest_sum > 0){\n\t\t\t\tret = 0;\n\t\t\t}else if(cur_prod >= s_prod){\n\t\t\t\tif(cur_prod == s_prod){ same_number.add(value); }\n\t\t\t\tret = 0;\n\t\t\t}else{\n\t\t\t\tfor(int i = 1; i <= n; i++){ ret *= i; }\n\t\t\t\tfor(int i = 0; i < 10; i++){\n\t\t\t\t\tfor(int j = 1; j <= using_values[i]; j++){\n\t\t\t\t\t\tret /= j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn memoized.put(cur_prod, memoized.get(cur_prod) + ret);\n\t\t}\n\t\t\n\t\tlong ret = 0;\n\t\tfor(int use_value = upper_val; use_value >= 0; use_value--){\n\t\t\tif(cur_prod * (use_value + 1) > s_prod){ continue; }\n\t\t\tif(rest_sum - use_value < 0){ continue; }\n\t\t\t\n\t\t\tusing_values[use_value]++;\n\t\t\tret += lower_prod(n, deep + 1, value + use_value, rest_sum - use_value, cur_prod * (use_value + 1), s_prod, use_value, using_values, memoized, same_number);\n\t\t\tusing_values[use_value]--;\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static long lower_number(final int n, final int deep, int[] s_part, int[] rest_values){\n\t\tif(deep == n){ return 0; }\n\t\t\n\t\tfinal int trial = n - deep;\n\t\tfinal int s_number = s_part[deep];\n\t\t\n\t\tlong ret = 0;\n\t\tfor(int i = 0; i < s_number; i++){\n\t\t\tif(rest_values[i] <= 0){ continue; }\n\t\t\trest_values[i]--;\n\t\t\t\n\t\t\tlong combs = 1;\n\t\t\tfor(int j = 1; j <= (trial - 1); j++){ combs *= j; }\n\t\t\tfor(int elem = 0; elem < 10; elem++){\n\t\t\t\tif(rest_values[elem] <= 0){ continue; }\n\t\t\t\tfor(int j = 1; j <= rest_values[elem]; j++){\n\t\t\t\t\tcombs /= j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret += combs;\n\t\t\t\n\t\t\trest_values[i]++;\n\t\t}\n\t\t\n\t\tif(rest_values[s_number] > 0){\n\t\t\trest_values[s_number]--;\n\t\t\t//System.out.println(deep + \" : \" + ret + \" : \" + Arrays.toString(rest_values));\n\t\t\treturn ret + lower_number(n, deep + 1, s_part, rest_values);\n\t\t}else{\n\t\t\treturn ret;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tString s = sc.next();\n\t\tint[] s_part = new int[s.length()];\n\t\tfor(int i = 0; i < s.length(); i++){ s_part[i] = Character.getNumericValue(s.charAt(i)); }\n\t\t\n\t\tfinal int n = s.length();\n\t\tfinal int sum_max = (n + 1) * 10;\n\t\t\n\t\tint s_sum = 0;\n\t\tfor(final char c : s.toCharArray()){ s_sum += Character.getNumericValue(c); }\n\t\t\n\t\tlong[][] SUM_USE_ZERO_DP = new long[n + 1][sum_max];\n\t\tlong[][] SUM_NOT_ZERO_DP = new long[n + 1][sum_max];\n\t\tSUM_USE_ZERO_DP[0][0] = SUM_NOT_ZERO_DP[0][0] = 1;\n\t\t\n\t\tfor(int len = 0; len < n; len++){\n\t\t\tfor(int num = 0; num < sum_max; num++){\n\t\t\t\tfor(int i = 0; i < 10 && (num + i) < sum_max; i++){\n\t\t\t\t\tif(i != 0){ SUM_NOT_ZERO_DP[len + 1][num + i] += SUM_NOT_ZERO_DP[len][num]; }\n\t\t\t\t\tSUM_USE_ZERO_DP[len + 1][num + i] += SUM_USE_ZERO_DP[len][num];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong[][] P_SUM_USE_ZERO_DP = new long[n + 1][sum_max];\n\t\tfor(int len = 0; len <= n; len++){\n\t\t\tP_SUM_USE_ZERO_DP[len][0] = SUM_USE_ZERO_DP[len][0];\n\t\t\t\n\t\t\tfor(int i = 1; i < sum_max; i++){\n\t\t\t\tP_SUM_USE_ZERO_DP[len][i] = SUM_USE_ZERO_DP[len][i] + P_SUM_USE_ZERO_DP[len][i - 1];\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong s_prod = 1;\n\t\tfor(final char c : s.toCharArray()){ s_prod *= Character.getNumericValue(c) + 1; }\n\t\t\n\t\t\n\t\tfinal long lower = s_sum == 0 ? 0 : P_SUM_USE_ZERO_DP[n][s_sum - 1];\n\t\tfinal long upper = P_SUM_USE_ZERO_DP[n][s_sum];\n\t\t/*\n\t\tfor(int i = 0; i <= s_sum; i++){\n\t\t\tSystem.out.println(i + \" : [\" + (i == 0 ? 0 : P_SUM_USE_ZERO_DP[n][i - 1]) + \" , \" + P_SUM_USE_ZERO_DP[n][i] + \") : \" + (P_SUM_USE_ZERO_DP[n][i] - (i == 0 ? 0 : P_SUM_USE_ZERO_DP[n][i - 1])));\n\t\t}\n\t\t*/\n\t\t//System.out.println(\"[\" + lower + \" , \" + upper + \")\");\n\t\t\n\t\tHashMap<Long, Long> prod_memoized = new HashMap<Long, Long>();\n\t\tHashSet<String> same_number = new HashSet<String>();\n\t\tfinal long lower_prod = lower_prod(n, 0, \"\", s_sum, 1, s_prod, 9, new int[10], prod_memoized, same_number);\n\t\tlong sum_memoized = 0;\n\t\tfor(final long val : prod_memoized.values()){ sum_memoized += val; }\n\t\t//System.out.println(sum_memoized);\n\t\t//System.out.println(prod_memoized);\n\t\t//System.out.println(same_number);\n\t\t\n\t\tlong lower_number = 0;\n\t\tfor(final String same : same_number){\n\t\t\tint[] values = new int[10];\n\t\t\t\n\t\t\tfor(final char elem : same.toCharArray()){ values[Character.getNumericValue(elem)]++; }\n\t\t\t//System.out.println(Arrays.toString(values));\n\t\t\tlower_number += lower_number(n, 0, s_part, values);\n\t\t\t//System.out.println(lower_number);\n\t\t}\n\t\t\n\t\t\n\t\t//final long ret = dfs(n, 0, 0, false, false, 1, s_sum, s_prod, s_part, SUM_USE_ZERO_DP, SUM_NOT_ZERO_DP);\n\t\t\n\t\tSystem.out.println(lower + sum_memoized + lower_number);\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint w = scan.nextInt();\n\t\tint d = scan.nextInt();\n\t\t\n\t\tint[][] ary = new int[n][2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = scan.nextInt();\n\t\t\tint y = scan.nextInt();\n\t\t\tswitch (scan.next()) {\n\t\t\tcase \"N\":\n\t\t\t\tary[i][0] = w + (w - x + y);\n\t\t\t\tary[i][1] = ary[i][0] + (d - y) * 2;\n\t\t\t\tbreak;\n\t\t\tcase \"E\":\n\t\t\t\tary[i][0] = x + y;\n\t\t\t\tary[i][1] = ary[i][0] + (w - x) * 2;\n\t\t\t\tbreak;\n\t\t\tcase \"S\":\n\t\t\t\tif (x < y)\n\t\t\t\t\tary[i][0] = 2 * w + 2 * d - (y - x);\n\t\t\t\telse\n\t\t\t\t\tary[i][0] = x - y;\n\t\t\t\tary[i][1] = ary[i][0] + y * 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tary[i][0] = w + d + (w - x) + (d - y);\n\t\t\t\tary[i][1] = ary[i][0] + x * 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n//\t\tfor (int i = 0; i < n; i++) {\n//\t\t\tSystem.out.println(ary[i][0] + \" \" + ary[i][1]);\n//\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tArrays.sort(ary, new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn o1[1] - o2[1];\n\t\t\t\t}\n\t\t\t});\n\t\t\tint ans = 1;\n\t\t\tint p = ary[0][1];\n\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\tif (p < ary[j][0]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tp = ary[j][1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tary[0][0] += 2 * w + 2 * d;\n\t\t\tary[0][1] += 2 * w + 2 * d;\n\t\t\tmin = Math.min(min, ans);\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n \npublic class Main{\n\tclass Pair{\n\t\tint begin;\n\t\tint end;\n\t\tpublic Pair(int begin, int end){\n\t\t\tthis.begin = begin;\n\t\t\tthis.end = end;\n\t\t}\n\t}\n\t\n\t\n\tint N;\n\tint W;\n\tint D;\n\tPair[] teams;\n\t\n\tpublic void solve(){\n\t\tN = nextInt();\n\t\tW = nextInt();\n\t\tD = nextInt();\n\t\tteams = new Pair[N];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint x = nextInt();\n\t\t\tint y = nextInt();\n\t\t\tchar d = next().charAt(0);\n\t\t\tint x1, x2;\n\t\t\tint y1, y2;\n\t\t\tswitch(d){\n\t\t\tcase 'N':\n\t\t\t\tif(D - y < x){\n\t\t\t\t\tx1 = x - (D - y);\n\t\t\t\t\ty1 = D;\n\t\t\t\t}else{\n\t\t\t\t\tx1 = 0;\n\t\t\t\t\ty1 = y + x;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(D - y < W - x){\n\t\t\t\t\tx2 = x + (D - y);\n\t\t\t\t\ty2 = D;\n\t\t\t\t}else{\n\t\t\t\t\tx2 = W;\n\t\t\t\t\ty2 = y + (W - x);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\tif(W - x < y){\n\t\t\t\t\tx2 = W;\n\t\t\t\t\ty2 = y - (W - x);\n\t\t\t\t}else{\n\t\t\t\t\tx2 = x + y;\n\t\t\t\t\ty2 = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(W - x < D - y){\n\t\t\t\t\tx1 = W;\n\t\t\t\t\ty1 = y + (W - x);\n\t\t\t\t}else{\n\t\t\t\t\tx1 = x + (D - y);\n\t\t\t\t\ty1 = D;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tcase 'W':\n\t\t\t\tif(x < y){\n\t\t\t\t\tx1 = 0;\n\t\t\t\t\ty1 = y - x;\n\t\t\t\t}else{\n\t\t\t\t\tx1 = x - y;\n\t\t\t\t\ty1 = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(x < D - y){\n\t\t\t\t\tx2 = 0;\n\t\t\t\t\ty2 = y + x;\n\t\t\t\t}else{\n\t\t\t\t\tx2 = x - (D - y);\n\t\t\t\t\ty2 = D;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tif(y < x){\n\t\t\t\t\tx2 = x - y;\n\t\t\t\t\ty2 = 0;\n\t\t\t\t}else{\n\t\t\t\t\tx2 = 0;\n\t\t\t\t\ty2 = y - x;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(y < W - x){\n\t\t\t\t\tx1 = x + y;\n\t\t\t\t\ty1 = 0;\n\t\t\t\t}else{\n\t\t\t\t\tx1 = W;\n\t\t\t\t\ty1 = y - (W - x);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault: throw new RuntimeException();\n\t\t\t}\n\t\t\tint i1 = toIdx(x1, y1);\n\t\t\tint i2 = toIdx(x2, y2);\n\t\t\tif(i2 < i1){\n\t\t\t\ti2 += D + D + W + W;\n\t\t\t}\n\t\t\tteams[i] = new Pair(i1, i2);\n\t\t}\n\t\t\n\t\tArrays.sort(teams, (a, b) -> Integer.compare(a.end, b.end));\n\t\tint ans = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint cur = 1;\n\t\t\tint pos = teams[i].end;\n\t\t\tint base = 0;\n\t\t\tfor(int j = 1; j < N; j++){\n\t\t\t\tPair p = teams[(i + j) % N];\n\t\t\t\tif(i + j >= N){\n\t\t\t\t\tbase = D + D + W + W;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(p.begin + base <= pos && pos <= p.end + base){\n\t\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\tcur ++;\n\t\t\t\t\tpos = p.end;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = Math.min(ans, cur);\n\t\t}\n\t\tout.println(ans);\n\t\t\n\t}\n\tpublic int toIdx(int x, int y){\n\t\tif(x == 0){\n\t\t\treturn y;\n\t\t}else if(y == D){\n\t\t\treturn D + x;\n\t\t}else if(x == W){\n\t\t\treturn D + W + (D - y);\n\t\t}else{\n\t\t\treturn D + W + D + (W - x);\n\t\t}\n\t}\n \n\t\n\tprivate static PrintWriter out;\n\tpublic static void main(String[] args){\n\t\tout = new PrintWriter(System.out);\n\t\tnew Main().solve();\n\t\tout.flush();\n\t}\n\t\n\t\n\t\n\tpublic static int nextInt(){\n\t\tint num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif(str.charAt(0) == '-'){\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor(;i < len; i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(!('0' <= c && c <= '9')) throw new RuntimeException();\n\t\t\tnum = num * 10 + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\t\n\tpublic static long nextLong(){\n\t\tlong num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif(str.charAt(0) == '-'){\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor(;i < len; i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(!('0' <= c && c <= '9')) throw new RuntimeException();\n\t\t\tnum = num * 10l + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\tpublic static String next(){\n\t\tint c;\n\t\twhile(!isAlNum(c = read())){}\n\t\tStringBuilder build = new StringBuilder();\n\t\tbuild.append((char)c);\n\t\twhile(isAlNum(c = read())){\n\t\t\tbuild.append((char)c);\n\t\t}\n\t\treturn build.toString();\n\t}\n\t\n\t\n\tprivate static byte[] inputBuffer = new byte[1024];\n\tprivate static int bufferLength = 0;\n\tprivate static int bufferIndex = 0;\n\tprivate static int read(){\n\t\tif(bufferLength < 0) throw new RuntimeException();\n\t\tif(bufferIndex >= bufferLength){\n\t\t\ttry{\n\t\t\t\tbufferLength = System.in.read(inputBuffer);\n\t\t\t\tbufferIndex = 0;\n\t\t\t}catch(IOException e){\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif(bufferLength <= 0) return (bufferLength = -1);\n\t\t}\n\t\treturn inputBuffer[bufferIndex++];\n\t}\n\t\n\tprivate static boolean isAlNum(int c){\n\t\treturn '!' <= c && c <= '~';\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static int[][] dirs = {{1, 1}, {1, -1}, {-1, -1}, {-1, 1}};\n\t\n\tpublic static Map<String, Integer> dirToIndex = new HashMap<String, Integer>();\n\tstatic {\n\t\tdirToIndex.put(\"E\", 0);\n\t\tdirToIndex.put(\"S\", 1);\n\t\tdirToIndex.put(\"W\", 2);\n\t\tdirToIndex.put(\"N\", 3);\n\t}\n\t\n\t// clock-wise\n\tpublic static int convertTo1D(final int x, final int y, final int w, final int h){\n\t\tif(x == 0){\n\t\t\treturn y;\n\t\t}else if(y == h){\n\t\t\treturn h + x;\n\t\t}else if(x == w){\n\t\t\treturn h + w + (h - y);\n\t\t}else {\n\t\t\treturn h + w + h + (w - x);\n\t\t}\n\t}\n\t\n\tpublic static int convertLeft(final int x, final int y, final int w, final int h, final int dir){\n\t\tfinal int x_sign = dirs[dir][0];\n\t\tfinal int y_sign = dirs[dir][1];\n\t\t\n\t\tfinal int x_lim = x_sign > 0 ? w : 0;\n\t\tfinal int y_lim = y_sign > 0 ? h : 0;\n\t\t\n\t\tfinal int x_diff = Math.abs(x_lim - x);\n\t\tfinal int y_diff = Math.abs(y_lim - y);\n\t\t\n\t\tfinal int min_diff = Math.min(x_diff, y_diff);\n\t\t\n\t\treturn convertTo1D(x + min_diff * x_sign, y + min_diff * y_sign, w, h);\n\t}\n\t\n\tpublic static int convertRight(final int x, final int y, final int w, final int h, final int dir){\n\t\treturn convertLeft(x, y, w, h, (dir + 1) % dirs.length);\n\t}\n\t\n\tpublic static class Pair implements Comparable<Pair> {\n\t\tint position, value;\n\t\t\n\t\tpublic Pair(int position, int value){\n\t\t\tthis.position = position;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn this.position + \" \" + this.value;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif(Integer.compare(this.position, o.position) != 0){\n\t\t\t\treturn Integer.compare(this.position, o.position);\n\t\t\t}else{\n\t\t\t\treturn Integer.compare(o.value, this.value);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int n = sc.nextInt();\n\t\tfinal int w = sc.nextInt();\n\t\tfinal int h = sc.nextInt();\n\t\t\n\t\tint[] ls = new int[n];\n\t\tint[] rs = new int[n];\n\t\tint[] ds = new int[n];\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfinal int x = sc.nextInt();\n\t\t\tfinal int y = sc.nextInt();\n\t\t\tfinal String d = sc.next();\n\t\t\t\n\t\t\tls[i] = convertLeft(x, y, w, h, dirToIndex.get(d));\n\t\t\trs[i] = convertRight(x, y, w, h, dirToIndex.get(d));\n\t\t\tif(ls[i] > rs[i]){ rs[i] += 2 * (h + w); }\n\t\t}\n\t\t\n\t\t//System.out.println(Arrays.toString(ls));\n\t\t//System.out.println(Arrays.toString(rs));\n\t\t\n\t\tint min = Integer.MAX_VALUE;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint[] n_ls = new int[n];\n\t\t\tint[] n_rs = new int[n];\n\t\t\tSystem.arraycopy(ls, 0, n_ls, 0, n);\n\t\t\tSystem.arraycopy(rs, 0, n_rs, 0, n);\n\t\t\t\n\t\t\tfinal int origin = ls[i];\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tn_ls[j] -= origin;\n\t\t\t\twhile(n_ls[j] < 0){ n_ls[j] += 2 * (w + h); }\n\t\t\t\twhile(n_ls[j] >= 2 * (w + h)){ n_ls[j] -= 2 * (w + h); }\n\t\t\t\tn_rs[j] -= origin;\n\t\t\t\twhile(n_rs[j] < 0){ n_rs[j] += 2 * (w + h); }\n\t\t\t\twhile(n_rs[j] >= 2 * (w + h)){ n_rs[j] -= 2 * (w + h); }\n\t\t\t\t\n\t\t\t\tif(n_rs[j] < n_ls[j]){\n\t\t\t\t\tint tmp = n_ls[j];\n\t\t\t\t\tn_ls[j] = n_rs[j];\n\t\t\t\t\tn_rs[j] = tmp;\n\t\t\t\t}\n\t\t\t\t//System.out.println(n_ls[j] + \" \" + n_rs[j]);\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<Pair> queue = new PriorityQueue<Pair>();\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(n_ls[j] <= n_rs[i] && n_rs[i] <= n_rs[j]){\n\t\t\t\t\t//System.out.println(ls[j] + \" \" + origin + \" \" + rs[i]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tqueue.add(new Pair(n_ls[j], +1));\n\t\t\t\tqueue.add(new Pair(n_rs[j], -1));\n\t\t\t}\n\t\t\t\n\t\t\tint score = 1;\n\t\t\tint count = 0;\n\t\t\t//System.out.println(queue);\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tfinal Pair p = queue.poll();\n\t\t\t\t\n\t\t\t\t//System.out.println(p.position + \" \" + p.value);\n\t\t\t\t\n\t\t\t\tif(p.value >= 1){\n\t\t\t\t\tcount++;\n\t\t\t\t}else if(count >= 1){\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tscore++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println();\n\t\t\t\n\t\t\tif(count == 0){\n\t\t\t\tmin = Math.min(min, score);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(min);\n\t\t\n\t\tsc.close();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n \npublic class Main{\n\tclass Pair{\n\t\tint begin;\n\t\tint end;\n\t\tpublic Pair(int begin, int end){\n\t\t\tthis.begin = begin;\n\t\t\tthis.end = end;\n\t\t}\n\t}\n\t\n\t\n\tint N;\n\tint W;\n\tint D;\n\tPair[] teams;\n\t\n\tpublic void solve(){\n\t\tN = nextInt();\n\t\tW = nextInt();\n\t\tD = nextInt();\n\t\tteams = new Pair[N];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint x = nextInt();\n\t\t\tint y = nextInt();\n\t\t\tchar d = next().charAt(0);\n\t\t\tint x1, x2;\n\t\t\tint y1, y2;\n\t\t\tswitch(d){\n\t\t\tcase 'N':\n\t\t\t\tif(D - y < x){\n\t\t\t\t\tx1 = x - (D - y);\n\t\t\t\t\ty1 = D;\n\t\t\t\t}else{\n\t\t\t\t\tx1 = 0;\n\t\t\t\t\ty1 = y + x;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(D - y < W - x){\n\t\t\t\t\tx2 = x + (D - y);\n\t\t\t\t\ty2 = D;\n\t\t\t\t}else{\n\t\t\t\t\tx2 = W;\n\t\t\t\t\ty2 = y + (W - x);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\tif(W - x < y){\n\t\t\t\t\tx2 = W;\n\t\t\t\t\ty2 = y - (W - x);\n\t\t\t\t}else{\n\t\t\t\t\tx2 = x + y;\n\t\t\t\t\ty2 = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(W - x < D - y){\n\t\t\t\t\tx1 = W;\n\t\t\t\t\ty1 = y + (W - x);\n\t\t\t\t}else{\n\t\t\t\t\tx1 = x + (D - y);\n\t\t\t\t\ty1 = D;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tcase 'W':\n\t\t\t\tif(x < y){\n\t\t\t\t\tx1 = 0;\n\t\t\t\t\ty1 = y - x;\n\t\t\t\t}else{\n\t\t\t\t\tx1 = x - y;\n\t\t\t\t\ty1 = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(x < D - y){\n\t\t\t\t\tx2 = 0;\n\t\t\t\t\ty2 = y + x;\n\t\t\t\t}else{\n\t\t\t\t\tx2 = x - (D - y);\n\t\t\t\t\ty2 = D;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tif(y < x){\n\t\t\t\t\tx2 = x - y;\n\t\t\t\t\ty2 = 0;\n\t\t\t\t}else{\n\t\t\t\t\tx2 = 0;\n\t\t\t\t\ty2 = y - x;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(y < W - x){\n\t\t\t\t\tx1 = x + y;\n\t\t\t\t\ty1 = 0;\n\t\t\t\t}else{\n\t\t\t\t\tx1 = W;\n\t\t\t\t\ty1 = y - (W - x);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault: throw new RuntimeException();\n\t\t\t}\n\t\t\tint i1 = toIdx(x1, y1);\n\t\t\tint i2 = toIdx(x2, y2);\n\t\t\tif(i2 < i1){\n\t\t\t\ti2 += D + D + W + W;\n\t\t\t}\n\t\t\tteams[i] = new Pair(i1, i2);\n\t\t}\n\t\t\n\t\tArrays.sort(teams, (a, b) -> Integer.compare(a.begin, b.begin));\n\t\tint ans = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint cur = 1;\n\t\t\tint pos = teams[i].end;\n\t\t\tfor(int j = 1; j < N; j++){\n\t\t\t\tPair p = teams[(i + j) % N];\n\t\t\t\tif(teams[(i + j + N - 1) % N].begin > p.begin){\n\t\t\t\t\tpos -= D + D + W + W;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(p.begin <= pos && pos <= p.end){\n\t\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\tcur ++;\n\t\t\t\t\tpos = p.end;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = Math.min(ans, cur);\n\t\t}\n\t\tout.println(ans);\n\t\t\n\t}\n\tpublic int toIdx(int x, int y){\n\t\tif(x == 0){\n\t\t\treturn y;\n\t\t}else if(y == D){\n\t\t\treturn D + x;\n\t\t}else if(x == W){\n\t\t\treturn D + W + (D - y);\n\t\t}else{\n\t\t\treturn D + W + D + (W - x);\n\t\t}\n\t}\n \n\t\n\tprivate static PrintWriter out;\n\tpublic static void main(String[] args){\n\t\tout = new PrintWriter(System.out);\n\t\tnew Main().solve();\n\t\tout.flush();\n\t}\n\t\n\t\n\t\n\tpublic static int nextInt(){\n\t\tint num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif(str.charAt(0) == '-'){\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor(;i < len; i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(!('0' <= c && c <= '9')) throw new RuntimeException();\n\t\t\tnum = num * 10 + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\t\n\tpublic static long nextLong(){\n\t\tlong num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif(str.charAt(0) == '-'){\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor(;i < len; i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(!('0' <= c && c <= '9')) throw new RuntimeException();\n\t\t\tnum = num * 10l + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\tpublic static String next(){\n\t\tint c;\n\t\twhile(!isAlNum(c = read())){}\n\t\tStringBuilder build = new StringBuilder();\n\t\tbuild.append((char)c);\n\t\twhile(isAlNum(c = read())){\n\t\t\tbuild.append((char)c);\n\t\t}\n\t\treturn build.toString();\n\t}\n\t\n\t\n\tprivate static byte[] inputBuffer = new byte[1024];\n\tprivate static int bufferLength = 0;\n\tprivate static int bufferIndex = 0;\n\tprivate static int read(){\n\t\tif(bufferLength < 0) throw new RuntimeException();\n\t\tif(bufferIndex >= bufferLength){\n\t\t\ttry{\n\t\t\t\tbufferLength = System.in.read(inputBuffer);\n\t\t\t\tbufferIndex = 0;\n\t\t\t}catch(IOException e){\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif(bufferLength <= 0) return (bufferLength = -1);\n\t\t}\n\t\treturn inputBuffer[bufferIndex++];\n\t}\n\t\n\tprivate static boolean isAlNum(int c){\n\t\treturn '!' <= c && c <= '~';\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n \npublic class Main{\n\tclass Pair{\n\t\tint begin;\n\t\tint end;\n\t\tpublic Pair(int begin, int end){\n\t\t\tthis.begin = begin;\n\t\t\tthis.end = end;\n\t\t}\n\t}\n\t\n\t\n\tint N;\n\tint W;\n\tint D;\n\tPair[] teams;\n\t\n\tpublic void solve(){\n\t\tN = nextInt();\n\t\tW = nextInt();\n\t\tD = nextInt();\n\t\tteams = new Pair[N];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint x = nextInt();\n\t\t\tint y = nextInt();\n\t\t\tchar d = next().charAt(0);\n\t\t\tint x1, x2;\n\t\t\tint y1, y2;\n\t\t\tswitch(d){\n\t\t\tcase 'N':\n\t\t\t\tif(D - y < x){\n\t\t\t\t\tx1 = x - (D - y);\n\t\t\t\t\ty1 = D;\n\t\t\t\t}else{\n\t\t\t\t\tx1 = 0;\n\t\t\t\t\ty1 = y + x;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(D - y < W - x){\n\t\t\t\t\tx2 = x + (D - y);\n\t\t\t\t\ty2 = D;\n\t\t\t\t}else{\n\t\t\t\t\tx2 = W;\n\t\t\t\t\ty2 = y + (W - x);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\tif(W - x < y){\n\t\t\t\t\tx2 = W;\n\t\t\t\t\ty2 = y - (W - x);\n\t\t\t\t}else{\n\t\t\t\t\tx2 = x + y;\n\t\t\t\t\ty2 = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(W - x < D - y){\n\t\t\t\t\tx1 = W;\n\t\t\t\t\ty1 = y + (W - x);\n\t\t\t\t}else{\n\t\t\t\t\tx1 = x + (D - y);\n\t\t\t\t\ty1 = D;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tcase 'W':\n\t\t\t\tif(x < y){\n\t\t\t\t\tx1 = 0;\n\t\t\t\t\ty1 = y - x;\n\t\t\t\t}else{\n\t\t\t\t\tx1 = x - y;\n\t\t\t\t\ty1 = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(x < D - y){\n\t\t\t\t\tx2 = 0;\n\t\t\t\t\ty2 = y + x;\n\t\t\t\t}else{\n\t\t\t\t\tx2 = x - (D - y);\n\t\t\t\t\ty2 = D;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tif(y < x){\n\t\t\t\t\tx2 = x - y;\n\t\t\t\t\ty2 = 0;\n\t\t\t\t}else{\n\t\t\t\t\tx2 = 0;\n\t\t\t\t\ty2 = y - x;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(y < W - x){\n\t\t\t\t\tx1 = x + y;\n\t\t\t\t\ty1 = 0;\n\t\t\t\t}else{\n\t\t\t\t\tx1 = W;\n\t\t\t\t\ty1 = y - (W - x);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault: throw new RuntimeException();\n\t\t\t}\n\t\t\tint i1 = toIdx(x1, y1);\n\t\t\tint i2 = toIdx(x2, y2);\n\t\t\tif(i2 < i1){\n\t\t\t\ti2 += D + D + W + W;\n\t\t\t}\n\t\t\tteams[i] = new Pair(i1, i2);\n\t\t}\n\t\t\n\t\tArrays.sort(teams, (a, b) -> Integer.compare(a.begin, b.begin));\n\t\tint ans = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint cur = 1;\n\t\t\tint pos = teams[i].end;\n\t\t\tint base = 0;\n\t\t\tfor(int j = 1; j < N; j++){\n\t\t\t\tPair p = teams[(i + j) % N];\n\t\t\t\tif(i + j >= N){\n\t\t\t\t\tbase = D + D + W + W;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(p.begin + base <= pos && pos <= p.end + base){\n\t\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\tcur ++;\n\t\t\t\t\tpos = p.end;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = Math.min(ans, cur);\n\t\t}\n\t\t\n\t\tArrays.sort(teams, (a, b) -> Integer.compare(a.end, b.end));\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint cur = 1;\n\t\t\tint pos = teams[i].end;\n\t\t\tint base = 0;\n\t\t\tfor(int j = 1; j < N; j++){\n\t\t\t\tPair p = teams[(i + j) % N];\n\t\t\t\tif(i + j >= N){\n\t\t\t\t\tbase = D + D + W + W;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(p.begin + base <= pos && pos <= p.end + base){\n\t\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\tcur ++;\n\t\t\t\t\tpos = p.end;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = Math.min(ans, cur);\n\t\t\t\n\n\t\t\tcur = 1;\n\t\t\tpos = teams[i].begin;\n\t\t\tbase = 0;\n\t\t\tfor(int j = 1; j < N; j++){\n\t\t\t\tPair p = teams[(i + j) % N];\n\t\t\t\tif(i + j >= N){\n\t\t\t\t\tbase = D + D + W + W;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(p.begin + base <= pos && pos <= p.end + base){\n\t\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\tcur ++;\n\t\t\t\t\tpos = p.end;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = Math.min(ans, cur);\n\t\t}\n\t\tout.println(ans);\n\t\t\n\t}\n\tpublic int toIdx(int x, int y){\n\t\tif(x == 0){\n\t\t\treturn y;\n\t\t}else if(y == D){\n\t\t\treturn D + x;\n\t\t}else if(x == W){\n\t\t\treturn D + W + (D - y);\n\t\t}else{\n\t\t\treturn D + W + D + (W - x);\n\t\t}\n\t}\n \n\t\n\tprivate static PrintWriter out;\n\tpublic static void main(String[] args){\n\t\tout = new PrintWriter(System.out);\n\t\tnew Main().solve();\n\t\tout.flush();\n\t}\n\t\n\t\n\t\n\tpublic static int nextInt(){\n\t\tint num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif(str.charAt(0) == '-'){\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor(;i < len; i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(!('0' <= c && c <= '9')) throw new RuntimeException();\n\t\t\tnum = num * 10 + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\t\n\tpublic static long nextLong(){\n\t\tlong num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif(str.charAt(0) == '-'){\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor(;i < len; i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(!('0' <= c && c <= '9')) throw new RuntimeException();\n\t\t\tnum = num * 10l + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\tpublic static String next(){\n\t\tint c;\n\t\twhile(!isAlNum(c = read())){}\n\t\tStringBuilder build = new StringBuilder();\n\t\tbuild.append((char)c);\n\t\twhile(isAlNum(c = read())){\n\t\t\tbuild.append((char)c);\n\t\t}\n\t\treturn build.toString();\n\t}\n\t\n\t\n\tprivate static byte[] inputBuffer = new byte[1024];\n\tprivate static int bufferLength = 0;\n\tprivate static int bufferIndex = 0;\n\tprivate static int read(){\n\t\tif(bufferLength < 0) throw new RuntimeException();\n\t\tif(bufferIndex >= bufferLength){\n\t\t\ttry{\n\t\t\t\tbufferLength = System.in.read(inputBuffer);\n\t\t\t\tbufferIndex = 0;\n\t\t\t}catch(IOException e){\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif(bufferLength <= 0) return (bufferLength = -1);\n\t\t}\n\t\treturn inputBuffer[bufferIndex++];\n\t}\n\t\n\tprivate static boolean isAlNum(int c){\n\t\treturn '!' <= c && c <= '~';\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint w = scan.nextInt();\n\t\tint d = scan.nextInt();\n\t\t\n\t\tint[][] ary = new int[n][2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = scan.nextInt();\n\t\t\tint y = scan.nextInt();\n\t\t\tswitch (scan.next()) {\n\t\t\tcase \"N\":\n\t\t\t\tary[i][0] = w + (d - x + y);\n\t\t\t\tary[i][1] = ary[i][0] + (d - y) * 2;\n\t\t\t\tbreak;\n\t\t\tcase \"E\":\n\t\t\t\tary[i][0] = x + y;\n\t\t\t\tary[i][1] = ary[i][0] + (w - x) * 2;\n\t\t\t\tbreak;\n\t\t\tcase \"S\":\n\t\t\t\tif (x < y)\n\t\t\t\t\tary[i][0] = 2 * w + 2 * d - (y - x);\n\t\t\t\telse\n\t\t\t\t\tary[i][0] = x - y;\n\t\t\t\tary[i][1] = ary[i][0] + y * 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tary[i][0] = w + d + (w - x) + (d - y);\n\t\t\t\tary[i][1] = ary[i][0] + x * 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n//\t\tfor (int i = 0; i < n; i++) {\n//\t\t\tSystem.out.println(ary[i][0] + \" \" + ary[i][1]);\n//\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tArrays.sort(ary, new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn o1[0] - o2[0];\n\t\t\t\t}\n\t\t\t});\n\t\t\tint ans = 1;\n\t\t\tint p = ary[0][1];\n\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\tif (p < ary[j][0]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tp = ary[j][1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tary[0][0] += 2 * w + 2 * d;\n\t\t\tary[0][1] += 2 * w + 2 * d;\n\t\t\tmin = Math.min(min, ans);\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int w,h,n;\n  cin>>n>>w>>h;\n  int x,y,B=2*(w+h),ans=n;\n  char c;\n  vector<P> m;\n  for(int i=0;i<n;i++){\n    cin>>x>>y>>c;\n    P A;\n    if(c=='S')A=P(x+y,(x-y+B)%B);\n    if(c=='E')A=P(w+y+(w-x),w+y-(w-x));\n    if(c=='N')A=P(w+h+(w-x)+(h-y),w+h+(w-x)-(h-y));\n    if(c=='W')A=P((w*2+h+(h-y)+x)%B,w*2+h+(h-y)-x);\n    m.push_back(A);\n  }\n  sort(m.begin(),m.end());\n  for(int i=0;i<n;i++){\n    int tp=1,p=m[i].first;\n    for(int j=0;j<n;j++){\n      int s=m[(i+j)%n].second,g=m[(i+j)%n].first;\n      if(!(s>g&&!(g<p&&p<s))&&!(s<g&&s<=p&&p<=g))tp++,p=g;\n    }\n    ans=min(tp,ans);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "D",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int w,h,n;\n  cin>>n>>w>>h;\n  int x,y,B=2*(w+h),ans=n;\n  char c;\n  vector<P> m;\n  for(int i=0;i<n;i++){\n    cin>>x>>y>>c;\n    P A;\n    if(c=='S')A=P(x+y,(x-y+B)%B);\n    if(c=='E')A=P(w+y+(w-x),w+y-(w-x));\n    if(c=='N')A=P(w+h+(w-x)+(h-y),w+h+(w-x)-(h-y));\n    if(c=='W')A=P((w*2+h+(h-y)+x)%B,w*2+h+(h-y)-x);\n    m.push_back(A);\n  }\n  sort(m.begin(),m.end());\n  for(int i=0;i<n;i++){\n    int tp=1,p=m[i].first;\n    for(int j=0;j<n;j++){\n      int s=m[(i+j)%n].second,g=m[(i+j)%n].first;\n      if(!(s>g&&!(g<p&&p<s))&&!(s<g&&s<=p&&p<=g))tp++,p=g;\n    }\n    ans=min(tp,ans);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "Python",
    "code": "# from (x,y) to SW (0,0) by (-1,-1) \ndef raySW(x,y):\n    return x - y\n    \nn,w,d=map(int,input().split())\ndef toRange(xyf):\n    sx,sy,f = xyf\n    x=int(sx)\n    y=int(sy)\n    if f == 'S':\n        s = raySW(x,y)\n        t = w - raySW(w-x,y)  # flip in X\n        return (s,t)\n    if f == 'E':\n        s = w - raySW(w-x,y)  # flip in X\n        t = w + d + raySW(w-x,d-y) # flip in both X and Y\n        return (s,t)\n    if f == 'N':\n        s = w + d + raySW(w-x,d-y) # flip in both X and Y\n        t = w + d + w - raySW(x,d-y)  # flip in Y\n        return (s,t)\n    if f == 'W':\n        s = w + d + w - raySW(x,d-y)  # flip in Y\n        t = w + d + w + d + raySW(x,y)\n        return (s,t) if t <= w+d+w+d else (s-w-w-d-d,t-w-w-d-d)\n    exit(-1)\n    \nxyfs=[input().split() for _ in range(n)]\n\ndef swap(xy):\n    x,y=xy\n    return (y,x)\n\nstso=list(map(swap,list(map(toRange,xyfs))))\nsts=sorted(stso)\n\ndef contains(s,t,r):\n    if t <= r <= s: return True\n    if t <= r+d+d+w+w <= s: return True\n    if t <= r-d-d-w-w <= s: return True\n    return False\n\ndef findMin(sts):\n    c = 0\n    r = w+w+d+d+w+w+d+d+w+w+d+d\n    for s,t in sts:\n        if not contains(s,t,r):    # put a new clock at t\n            c += 1\n            r = s\n    return c\n# stupid concat?\nmins=[findMin(sts[i:] + sts[:i]) for i in range(n)]\nprint(min(mins))\n\n"
  },
  {
    "language": "Python",
    "code": "N, W, D = map(int, input().split())\ndef calc(x0, y0, dx, dy):\n    s = min(W - x0 if dx >= 0 else x0, D - y0 if dy >= 0 else y0)\n    x = x0 + dx*s; y = y0 + dy*s\n    assert x in [0, W] or y in [0, D], (x, y)\n    if y == 0:\n        return x\n    if x == W:\n        return W+y\n    if y == D:\n        return 2*W+D-x\n    return 2*W+2*D-y\n\nS = []\nfor i in range(N):\n    x, y, f = input().split(); x = int(x); y = int(y)\n    if f == 'N':\n        t1 = calc(x, y, 1, 1)\n        t2 = calc(x, y, -1, 1)\n    elif f == 'E':\n        t1 = calc(x, y, 1, -1)\n        t2 = calc(x, y, 1, 1)\n    elif f == 'S':\n        t1 = calc(x, y, -1, -1)\n        t2 = calc(x, y, 1, -1)\n    else:\n        t1 = calc(x, y, -1, 1)\n        t2 = calc(x, y, -1, -1)\n    if t1 >= t2:\n        t1 -= 2*(W+D)\n    S.append((t1, t2))\nS.sort(key=lambda x: x[1])\nans = N\nINF = 10**9\nfor i in range(N):\n    r = 0\n    cur = -INF\n    base = 0\n    for j in range(N):\n        a, b = S[(i+j) % N]\n        if (i+j) % N == 0:\n            base += 2*(W+D)\n        if a + base <= cur:\n            continue\n        cur = b + base\n        r += 1\n    ans = min(r, ans)\nprint(ans)\n"
  }
]