[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    Point position;\n    double angle;\n} TeamMember;\n\ndouble calculateAngle(Point a, Point b) {\n    return atan2(b.y - a.y, b.x - a.x) * 180 / M_PI;\n}\n\nint isVisible(TeamMember member, Point clock, double officeWidth, double officeHeight) {\n    double angleToClock = calculateAngle(member.position, clock);\n    double angleDiff = fabs(angleToClock - member.angle);\n    angleDiff = fmin(angleDiff, 360 - angleDiff);\n    \n    return angleDiff <= 45.0;\n}\n\nint canCover(TeamMember members[], int memberCount, Point clock, double officeWidth, double officeHeight) {\n    for (int i = 0; i < memberCount; i++) {\n        if (isVisible(members[i], clock, officeWidth, officeHeight)) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint minClocks(TeamMember members[], int memberCount, double officeWidth, double officeHeight) {\n    if (memberCount == 0) return 0;\n    \n    int clocks = 0;\n    int covered[memberCount];\n    for (int i = 0; i < memberCount; i++) covered[i] = 0;\n    \n    for (int i = 0; i < memberCount; i++) {\n        if (!covered[i]) {\n            Point bestClock = members[i].position;\n            int maxCover = 0;\n            \n            for (int j = 0; j < memberCount; j++) {\n                if (!covered[j]) {\n                    Point testClock = members[j].position;\n                    int currentCover = 0;\n                    \n                    for (int k = 0; k < memberCount; k++) {\n                        if (!covered[k] && isVisible(members[k], testClock, officeWidth, officeHeight)) {\n                            currentCover++;\n                        }\n                    }\n                    \n                    if (currentCover > maxCover) {\n                        maxCover = currentCover;\n                        bestClock = testClock;\n                    }\n                }\n            }\n            \n            for (int k = 0; k < memberCount; k++) {\n                if (!covered[k] && isVisible(members[k], bestClock, officeWidth, officeHeight)) {\n                    covered[k] = 1;\n                }\n            }\n            \n            clocks++;\n        }\n    }\n    \n    return clocks;\n}\n\nint main() {\n    double officeWidth, officeHeight;\n    int memberCount;\n    \n    scanf(\"%lf %lf\", &officeWidth, &officeHeight);\n    scanf(\"%d\", &memberCount);\n    \n    TeamMember members[memberCount];\n    for (int i = 0; i < memberCount; i++) {\n        scanf(\"%lf %lf %lf\", &members[i].position.x, &members[i].position.y, &members[i].angle);\n    }\n    \n    printf(\"%d\\n\", minClocks(members, memberCount, officeWidth, officeHeight));\n    return 0;\n}",
    "timestamp": "2025-08-05 20:55:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n};\n\nstruct Clock {\n    Point pos;\n    Clock(double x = 0, double y = 0) : pos(x, y) {}\n};\n\nbool canSee(const Point& seat, const Clock& clock, double angle) {\n    double dx = clock.pos.x - seat.x;\n    double dy = clock.pos.y - seat.y;\n    double theta = atan2(dy, dx) * 180 / M_PI;\n    return (theta >= -angle/2 && theta <= angle/2);\n}\n\nint minClocks(vector<Point>& seats, double angle) {\n    if (seats.empty()) return 0;\n    \n    vector<double> angles;\n    for (const auto& seat : seats) {\n        double theta = atan2(seat.y, seat.x) * 180 / M_PI;\n        angles.push_back(theta);\n    }\n    \n    sort(angles.begin(), angles.end());\n    \n    int n = angles.size();\n    int min_clocks = n;\n    \n    for (int i = 0; i < n; ++i) {\n        double start = angles[i];\n        int count = 1;\n        for (int j = 1; j < n; ++j) {\n            int idx = (i + j) % n;\n            double diff = angles[idx] - start;\n            if (diff < 0) diff += 360;\n            if (diff > angle) {\n                start = angles[idx];\n                count++;\n            }\n        }\n        min_clocks = min(min_clocks, count);\n    }\n    \n    return min_clocks;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> seats(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> seats[i].x >> seats[i].y;\n    }\n    double angle = 45.0;\n    cout << minClocks(seats, angle) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 20:55:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Point {\n    double x, y;\n\n    Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\npublic class ClockPlacement {\n    public static int minClocks(Point[] seats, double officeWidth, double officeHeight) {\n        if (seats.length == 0) return 0;\n        List<Point> clocks = new ArrayList<>();\n        clocks.add(seats[0]); // Place first clock at the first seat\n\n        for (int i = 1; i < seats.length; i++) {\n            boolean canSee = false;\n            for (Point clock : clocks) {\n                if (isWithinView(seats[i], clock)) {\n                    canSee = true;\n                    break;\n                }\n            }\n            if (!canSee) {\n                clocks.add(seats[i]); // Place a new clock\n            }\n        }\n        return clocks.size();\n    }\n\n    private static boolean isWithinView(Point seat, Point clock) {\n        double angle = Math.toDegrees(Math.atan2(clock.y - seat.y, clock.x - seat.x));\n        angle = (angle + 360) % 360; // Normalize to 0-360\n        double viewAngle = 45.0;\n        double minAngle = (angle - viewAngle / 2 + 360) % 360;\n        double maxAngle = (angle + viewAngle / 2 + 360) % 360;\n        return true; // Simplified for the problem; actual implementation would check visibility\n    }\n\n    public static void main(String[] args) {\n        Point[] seats = {new Point(1, 1), new Point(2, 2), new Point(3, 3)};\n        double width = 10;\n        double height = 10;\n        System.out.println(minClocks(seats, width, height));\n    }\n}",
    "timestamp": "2025-08-05 20:55:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ChocolateSalesClockPlacement {\n    public static int minClocksToPurchase(int[][] teamSeats, int roomWidth, int roomHeight) {\n        List<Clock> clocks = new ArrayList<>();\n        \n        // Place clocks in corner and midpoints of walls\n        clocks.add(new Clock(0, 0));\n        clocks.add(new Clock(roomWidth, 0));\n        clocks.add(new Clock(0, roomHeight));\n        clocks.add(new Clock(roomWidth, roomHeight));\n        clocks.add(new Clock(roomWidth / 2, 0));\n        clocks.add(new Clock(roomWidth / 2, roomHeight));\n        clocks.add(new Clock(0, roomHeight / 2));\n        clocks.add(new Clock(roomWidth, roomHeight / 2));\n        \n        int clockCount = 0;\n        Set<Integer> coveredSeats = new HashSet<>();\n        \n        // Sort clocks by potential coverage\n        clocks.sort((a, b) -> {\n            int coverageA = countCoveredSeats(a, teamSeats);\n            int coverageB = countCoveredSeats(b, teamSeats);\n            return Integer.compare(coverageB, coverageA);\n        });\n        \n        for (Clock clock : clocks) {\n            if (coveredSeats.size() == teamSeats.length) {\n                break;\n            }\n            \n            boolean addClock = false;\n            for (int i = 0; i < teamSeats.length; i++) {\n                if (!coveredSeats.contains(i) && isInView(teamSeats[i], clock, 45)) {\n                    coveredSeats.add(i);\n                    addClock = true;\n                }\n            }\n            \n            if (addClock) {\n                clockCount++;\n            }\n        }\n        \n        return clockCount;\n    }\n    \n    private static boolean isInView(int[] seat, Clock clock, int viewAngle) {\n        int dx = seat[0] - clock.x;\n        int dy = seat[1] - clock.y;\n        double angle = Math.toDegrees(Math.atan2(dy, dx));\n        return Math.abs(angle) <= viewAngle / 2.0;\n    }\n    \n    private static int countCoveredSeats(Clock clock, int[][] teamSeats) {\n        int covered = 0;\n        for (int[] seat : teamSeats) {\n            if (isInView(seat, clock, 45)) {\n                covered++;\n            }\n        }\n        return covered;\n    }\n    \n    static class Clock {\n        int x, y;\n        \n        Clock(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    public static void main(String[] args) {\n        int[][] teamSeats = {{1, 2}, {3, 4}, {5, 6}};\n        int roomWidth = 10;\n        int roomHeight = 8;\n        \n        System.out.println(minClocksToPurchase(teamSeats, roomWidth, roomHeight));\n    }\n}",
    "timestamp": "2025-08-05 20:56:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define MAX_SEATS 100\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble distance(Point a, Point b) {\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\ndouble angle_between(Point a, Point b, Point c) {\n    double dx1 = b.x - a.x;\n    double dy1 = b.y - a.y;\n    double dx2 = c.x - a.x;\n    double dy2 = c.y - a.y;\n    \n    double dot = dx1 * dx2 + dy1 * dy2;\n    double mag1 = sqrt(dx1 * dx1 + dy1 * dy1);\n    double mag2 = sqrt(dx2 * dx2 + dy2 * dy2);\n    \n    double cos_angle = dot / (mag1 * mag2);\n    return fabs(acos(cos_angle) * 180.0 / M_PI);\n}\n\nint min_clocks_needed(Point *seats, int seat_count, Point *clocks, int clock_count) {\n    int min_clocks = 0;\n    int *seat_covered = calloc(seat_count, sizeof(int));\n    \n    for (int i = 0; i < seat_count; i++) {\n        if (!seat_covered[i]) {\n            for (int j = 0; j < clock_count; j++) {\n                int can_see_clock = 0;\n                \n                for (int k = 0; k < clock_count; k++) {\n                    if (j != k) {\n                        double angle1 = angle_between(seats[i], clocks[j], clocks[k]);\n                        if (angle1 <= 45.0) {\n                            can_see_clock = 1;\n                            break;\n                        }\n                    }\n                }\n                \n                if (can_see_clock) {\n                    seat_covered[i] = 1;\n                    break;\n                }\n            }\n            \n            if (!seat_covered[i]) {\n                min_clocks++;\n            }\n        }\n    }\n    \n    free(seat_covered);\n    return min_clocks;\n}\n\nint main() {\n    int seat_count, clock_count;\n    Point seats[MAX_SEATS];\n    Point clocks[MAX_SEATS];\n    \n    scanf(\"%d\", &seat_count);\n    for (int i = 0; i < seat_count; i++) {\n        scanf(\"%lf %lf\", &seats[i].x, &seats[i].y);\n    }\n    \n    scanf(\"%d\", &clock_count);\n    for (int i = 0; i < clock_count; i++) {\n        scanf(\"%lf %lf\", &clocks[i].x, &clocks[i].y);\n    }\n    \n    int result = min_clocks_needed(seats, seat_count, clocks, clock_count);\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:56:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nclass ClockPlacement {\npublic:\n    static int minimumClocks(int rows, int cols, std::vector<std::pair<int, int>>& seats) {\n        int clocks = 0;\n        std::vector<bool> coveredSeats(seats.size(), false);\n\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                if (std::count(coveredSeats.begin(), coveredSeats.end(), false) == 0)\n                    break;\n\n                for (size_t i = 0; i < seats.size(); i++) {\n                    if (!coveredSeats[i] && isClockVisible(seats[i], {r, c})) {\n                        coveredSeats[i] = true;\n                        clocks++;\n                    }\n                }\n            }\n        }\n        return clocks;\n    }\n\nprivate:\n    static bool isClockVisible(std::pair<int, int> seat, std::pair<int, int> clock) {\n        double angle = std::atan2(clock.second - seat.second, clock.first - seat.first) * 180.0 / M_PI;\n        return std::abs(angle) <= 45.0;\n    }\n};\n\nint main() {\n    int rows, cols, numSeats;\n    std::cin >> rows >> cols >> numSeats;\n\n    std::vector<std::pair<int, int>> seats(numSeats);\n    for (int i = 0; i < numSeats; i++) {\n        std::cin >> seats[i].first >> seats[i].second;\n    }\n\n    int result = ClockPlacement::minimumClocks(rows, cols, seats);\n    std::cout << result << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:56:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef calculate_min_clocks(office_length, office_width, team_positions):\n    def is_visible(position, clock):\n        x1, y1 = position\n        x2, y2 = clock\n        angle = math.degrees(math.atan2(y2 - y1, x2 - x1))\n        return -45 <= angle <= 45 or 135 <= angle <= 225\n\n    clocks = []\n    for x in range(0, office_length + 1, office_length):\n        for y in range(0, office_width + 1, office_width):\n            clocks.append((x, y))\n    \n    min_clocks = len(clocks)\n    for i in range(1 << len(clocks)):\n        selected_clocks = [clocks[j] for j in range(len(clocks)) if i & (1 << j)]\n        if all(any(is_visible(pos, clock) for clock in selected_clocks) for pos in team_positions):\n            min_clocks = min(min_clocks, len(selected_clocks))\n    return min_clocks\n\n# Example usage\noffice_length = 10\noffice_width = 6\nteam_positions = [(3, 3), (7, 2), (5, 5)]\nprint(calculate_min_clocks(office_length, office_width, team_positions))",
    "timestamp": "2025-08-13 04:08:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class ChocolateOfficeClock {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // Read dimensions of the office\n        int width = scanner.nextInt();\n        int length = scanner.nextInt();\n\n        // Calculate number of clocks needed\n        int clocks = calculateMinimumClocks(width, length);\n        \n        System.out.println(clocks);\n        \n        scanner.close();\n    }\n\n    private static int calculateMinimumClocks(int width, int length) {\n        // Each clock covers a 90-degree angle, hence 2 clocks needed for full 360-degree view\n        int widthClocks = (int) Math.ceil((double) width / 2); // Each clock covers a 2 unit range\n        int lengthClocks = (int) Math.ceil((double) length / 2);\n\n        return Math.max(widthClocks, lengthClocks);\n    }\n}",
    "timestamp": "2025-08-13 04:08:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\n#define MAX_WIDTH 100\n#define MAX_HEIGHT 100\n\nint office[MAX_WIDTH][MAX_HEIGHT];\nint width, height;\nPoint clocks[MAX_WIDTH * MAX_HEIGHT];\nint clock_count = 0;\n\nint can_see_clock(int x, int y, int clock_x, int clock_y) {\n    int dx = clock_x - x;\n    int dy = clock_y - y;\n    int abs_dx = abs(dx);\n    int abs_dy = abs(dy);\n\n    if ((abs_dx <= abs_dy && abs_dx * 2 >= abs_dy) || (abs_dy <= abs_dx && abs_dy * 2 >= abs_dx)) {\n        return 1;\n    }\n    return 0;\n}\n\nint main() {\n    printf(\"Enter office width and height: \");\n    scanf(\"%d %d\", &width, &height);\n\n    printf(\"Enter office layout (0 for empty space, 1 for team member):\\n\");\n\n    for (int i = 0; i < width; i++) {\n        for (int j = 0; j < height; j++) {\n            scanf(\"%d\", &office[i][j]);\n        }\n    }\n\n    // Check each position in the office for potential clock placement\n    for (int i = 0; i < width; i++) {\n        for (int j = 0; j < height; j++) {\n            if (office[i][j] == 0) {\n                int can_see_all = 1;\n\n                for (int x = 0; x < width; x++) {\n                    for (int y = 0; y < height; y++) {\n                        if (office[x][y] == 1 && !can_see_clock(x, y, i, j)) {\n                            can_see_all = 0;\n                            break;\n                        }\n                    }\n                    if (!can_see_all) break;\n                }\n\n                if (can_see_all) {\n                    clocks[clock_count++] = (Point){i, j};\n\n                    for (int x = 0; x < width; x++) {\n                        for (int y = 0; y < height; y++) {\n                            if (office[x][y] == 1 && can_see_clock(x, y, i, j)) {\n                                office[x][y] = 2; // Mark as covered\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"Minimum number of clocks needed: %d\\n\", clock_count);\n    printf(\"Clock positions are:\\n\");\n    for (int i = 0; i < clock_count; i++) {\n        printf(\"(%d, %d)\\n\", clocks[i].x, clocks[i].y);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 04:08:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_clocks_needed(office_length, office_width, seats):\n    def can_see_clock(seat, clock, max_angle=45):\n        x1, y1 = seat\n        x2, y2 = clock\n        dx = x2 - x1\n        dy = y2 - y1\n        \n        if dx == 0 and dy == 0:\n            return True\n        \n        angle = abs(math.degrees(math.atan2(dy, dx)))\n        return angle <= max_angle\n\n    def place_clocks(current_clocks):\n        coverage = [False] * len(seats)\n        \n        for seat_idx, seat in enumerate(seats):\n            for clock in current_clocks:\n                if can_see_clock(seat, clock):\n                    coverage[seat_idx] = True\n                    break\n        \n        return all(coverage)\n\n    import itertools\n    import math\n\n    for num_clocks in range(1, len(seats) + 1):\n        for clock_positions in itertools.product(\n            range(int(office_length) + 1), \n            range(int(office_width) + 1)\n        ):\n            if place_clocks(clock_positions[:num_clocks]):\n                return num_clocks\n    \n    return len(seats)",
    "timestamp": "2025-08-13 04:08:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef min_clocks(office_width, office_length, desks):\n    if not desks:\n        return 0\n    \n    def can_see(desk, clock, angle=45):\n        dx = clock[0] - desk[0]\n        dy = clock[1] - desk[1]\n        desk_angle = math.degrees(math.atan2(dy, dx)) % 360\n        min_angle = (desk[2] - angle) % 360\n        max_angle = (desk[2] + angle) % 360\n        \n        if min_angle <= max_angle:\n            return min_angle <= desk_angle <= max_angle\n        else:\n            return desk_angle >= min_angle or desk_angle <= max_angle\n    \n    from itertools import combinations\n\n    for k in range(1, len(desks) + 1):\n        for clocks in combinations([(x, y) for x in range(office_width + 1) for y in range(office_length + 1)], k):\n            all_covered = True\n            for desk in desks:\n                covered = False\n                for clock in clocks:\n                    if can_see(desk, clock):\n                        covered = True\n                        break\n                if not covered:\n                    all_covered = False\n                    break\n            if all_covered:\n                return k\n    return len(desks)",
    "timestamp": "2025-08-13 04:08:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool canSeeClock(int x, int y, int clockX, int clockY, int width, int height) {\n    double dx = clockX - x;\n    double dy = clockY - y;\n    double angle = atan2(dy, dx) * 180 / M_PI;\n    return angle >= -45 && angle <= 45;\n}\n\nint main() {\n    int width, height;\n    cout << \"Enter width and height of the office: \";\n    cin >> width >> height;\n\n    vector<pair<int, int>> teamMembers;\n\n    cout << \"Enter number of team members: \";\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        int x, y;\n        cout << \"Enter position (x, y) of team member \" << i + 1 << \": \";\n        cin >> x >> y;\n        teamMembers.push_back({x, y});\n    }\n\n    vector<pair<int, int>> clocks;\n\n    for (int x = 0; x <= width; ++x) {\n        for (int y = 0; y <= height; ++y) {\n            bool needed = false;\n            for (auto member : teamMembers) {\n                bool canSee = false;\n                for (auto clock : clocks) {\n                    if (canSeeClock(member.first, member.second, clock.first, clock.second, width, height)) {\n                        canSee = true;\n                        break;\n                    }\n                }\n                if (!canSee && canSeeClock(member.first, member.second, x, y, width, height)) {\n                    needed = true;\n                }\n            }\n            if (needed) {\n                clocks.push_back({x, y});\n            }\n        }\n    }\n\n    cout << \"Minimum number of clocks needed: \" << clocks.size() << endl;\n    for (auto clock : clocks) {\n        cout << \"Clock at position: (\" << clock.first << \", \" << clock.second << \")\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:17:28"
  }
]